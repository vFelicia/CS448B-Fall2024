00:00 - If you're interested in learning
about blockchain, this is the
00:02 - course for you. Patrick Collins
is a veteran software engineer
00:06 - and longtime finance industry
developer. Be sure to leave a
00:10 - comment with something you
learned from this course.
00:12 - Welcome to the ultimate solidity
smart contract and blockchain
00:17 - Developer course, JavaScript
addition, we recently did a
00:20 - version of this video in Python
that has over 2 million views
00:24 - right now making it the most
watched smart contract tutorial
00:28 - on the planet. We've learned a
ton from doing that first
00:31 - course. And if you love the
Python language, definitely be
00:34 - sure to check that one out.
We've taken all the learnings
00:36 - we've got from making that first
course, wrapped it up and put it
00:39 - into this JavaScript video for
you. If you're looking to get
00:42 - started in web three blockchain
smart contracts or any of these
00:46 - terms, this is the course for
you. And it's for anybody and
00:50 - everybody, no matter your
experience level in programming
00:53 - or in blockchain. Ideally, you
know, a little bit of JavaScript
00:57 - before starting this. But if you
don't, no worries, we will help
01:00 - you along the way. And in case
you do want to learn a little
01:03 - bit of JavaScript before
starting here, there are some
01:05 - fantastic courses on Free Code
Camp to learn more, but you
01:09 - absolutely don't have to. And
really, any experience with any
01:12 - object oriented programming
language will work, right. So if
01:15 - you're brand new to coding, or
if you're brand new to
01:18 - blockchain, this is exactly
where you should be. And if you
01:22 - already know a lot about
blockchain or coding, this
01:24 - course will give you even more
deep fundamentals on the space.
01:29 - So welcome to the edge of the
rabbit hole. So for those of you
01:32 - who don't know, my name is
Patrick Collins. I'm a smart
01:35 - contract engineer, developer
advocate on the chain link
01:38 - protocol. And I live in breed
smart contracts. I also make
01:43 - YouTube videos on my own
channel, medium Twitter threads
01:46 - and more. teaching people about
smart contracts about coding and
01:49 - about this new technology. I
love helping developers learn,
01:53 - grow and learn about this new
Advent. That's blockchain and
01:56 - smart contracts. And I'll be
taking you on your journey to
01:59 - becoming a blockchain expert and
Wizard of the smart contract
02:03 - developing world. And even if
you don't want to become a
02:06 - developer, the first section our
blockchain basics, will give you
02:10 - a lot of fundamental knowledge
about how blockchain and smart
02:14 - contracts, even work. I am so
excited for you to be here. And
02:18 - I hope you enjoy the journey.
This is a data dump, passion
02:21 - educational project of
everything I've learned working
02:24 - in this space. And I am 100%
certain that if you follow
02:28 - along, you'll come out the other
side of this, armed with the
02:31 - knowledge to be a positive force
in this incredible industry,
02:35 - solidity and smart contract
developers are massively in
02:38 - demand with an average salary of
being around $145,000 a year,
02:43 - there is massive economic
opportunity from learning this
02:47 - course. And this technology has
the ability to revolutionize
02:50 - everything that we interact
with, and you can be one of the
02:54 - pioneers ushering in this new
age. In our courses. We already
02:58 - have a track record of giving
people these educational needs
03:01 - and sending them into their
careers in the blockchain and
03:04 - smart contract space. And we are
going to give you all of the
03:08 - cutting edge tools and how to
use them including working with
03:11 - things like D phi NF TS Dows,
ERC 20s upgradable, smart
03:16 - contracts and more. We're going
to teach you the skills
03:19 - necessary to build defy
applications like Ave synthetics
03:22 - and compound, billion dollar
decentralized applications, or
03:27 - massively successful NFT
projects like crypto punks, or
03:30 - board apes. Dow is like maker
Dow or developer, Dow and any of
03:35 - the amazing things you've seen
in the cryptocurrency world. In
03:38 - learning these skills, you will
have all these economic
03:40 - opportunities at your fingertips
and the ability to be a pioneer
03:44 - in completely changing the way
we interact with each other. In
03:48 - a fundamental way. Building
decentralized smart contract
03:51 - applications is building a world
that's more accountable a world
03:54 - with unbreakable promises, a
faster, more efficient,
03:58 - financially free world, a
collaborative community,
04:00 - combining the prowess of
philosophy and technology into a
04:04 - new system. We'll learn more
about the purpose and the value
04:08 - of smart contracts and
decentralized applications in
04:11 - lesson one of this course, and
why they're so exciting. Finish
04:14 - this course. And you'll be
ready. So again, I want to give
04:17 - a major thank you and a major
kudos to you because you've
04:20 - taken the first step to enter
this realm. So welcome to Web
04:24 - three. Welcome to the
blockchain. Welcome to smart
04:26 - contracts. And I'll see you at
the bottom of the rabbit hole.
04:29 - So let's jump into some best
practices for this course so
04:33 - that you can learn most
effectively and learn with this
04:36 - course as best you can.
04:40 - You do not want to skip
04:41 - this part. It'll help you solve
80% of your issue. Now, while
04:44 - going through this course be
100% certain to follow along
04:48 - with a GitHub repository
associated with this course we
04:51 - have a link in the description
of this video for you to
04:54 - absolutely click on follow along
have open in a tab as you're
04:58 - doing this because it has all
the code Sam polls, timestamps a
05:01 - community to interact with and
more, it is going to be your
05:04 - Bible for watching this course.
And yes, we have a Discussions
05:07 - tab. This Discussions tab is a
place where you can ask
05:10 - questions, engage with other
developers who are going through
05:13 - this course as well. Get some
help, and etc. Be sure to say
05:17 - hello and meet other like minded
individuals like yourselves.
05:20 - Now, blockchain and smart
contracts move really quickly.
05:22 - And things are constantly being
updated. So to make sure you're
05:25 - always up to date with the
latest, when I open up some
05:28 - documentation, try to open up
the documentation for yourself
05:31 - as well. And maybe even have the
code sample next to you. And as
05:34 - you're writing code, be sure to
refer back to make sure that you
05:37 - are keeping pace, and then you
have the most up to date
05:39 - samples, sometimes technology
might change, and there might be
05:43 - a way to do something a little
bit better. So we have this file
05:46 - called chronological updates, be
sure that this is the first
05:49 - place to check when you run into
an issue to see if maybe
05:51 - something was updated that you
missed, it'll be chronologically
05:54 - ordered. So it's easier to find
updates. Basically, this is to
05:57 - say, always refer back to the
GitHub repo first. And if you do
06:00 - to find a mistake, or something
isn't working the way you
06:02 - expected, jump into the
conversation, leave a
06:05 - discussion, leave an issue, ask
questions here, take breaks, I
06:09 - cannot tell you how many people
tried rushing through our entire
06:13 - first course in one setting and
didn't retain as much
06:15 - information, your brain
remembers information much
06:18 - better if you take breaks. So
every 25 minutes or half an
06:21 - hour, maybe take a five minute
walk. And then every two hours
06:24 - take a much longer break. And if
you really want to make sure
06:27 - something drills in, try to go
back and reflect on what you did
06:30 - for the lesson prior before
continuing to the next lesson.
06:32 - And at the same time, though,
learn at your own speed. There
06:36 - is no right speed for this
course. If it takes you a day, a
06:41 - week, a month or even a year, it
doesn't matter. Learn at the
06:45 - pace that's right for you, you
can change the speed at which I
06:48 - talked using the little gear
icon in the YouTube video. If
06:52 - I'm talking way too fast for
you, you can slow me down. And
06:55 - at the same time, if I'm talking
too slow, you can speed me up,
06:59 - you also don't even have to go
in order. You can bounce around
07:02 - topic to topic, if you don't
want to learn full stack, you
07:05 - can skip the full stack stuff.
If you don't want to learn
07:07 - coding, we can skip the coding
stuff. If you only want to go to
07:10 - the advanced stuff, go to the
advanced stuff. You are highly
07:13 - encouraged to pause, come back
and ask questions. The
07:16 - blockchain and smart contract
world is incredibly
07:18 - collaborative. So be sure to use
tools like the discussions tab
07:22 - of our GitHub repository, asking
questions on Stack Overflow and
07:26 - Aetherium Stack Exchange and
tagging relative technologies,
07:30 - making issues on different
GitHub repositories that you're
07:33 - working with jumping into
discord, Reddit, Twitter, and
07:36 - any other place that these
communities and technologies are
07:39 - congregating. And the reason I'm
putting so much emphasis on
07:41 - these community aspects is that
becoming a solidity and
07:44 - blockchain engineer is so much
more than just the solidity
07:47 - part. Being comfortable with all
the tools in this space,
07:51 - including the ones to get help
and to give help are essential
07:55 - to being successful here.
Networking is massive, and it
07:58 - makes it a ton of fun. As you
continue your journey and you
08:01 - get more advanced and you're
looking for places to meet other
08:03 - developers. Hackathons are one
of the best places to connect
08:07 - with other engineers, the
chainlink hackathons eath,
08:10 - global hackathons, and Dev folio
hackathons are three great
08:13 - hackathon suites to connect. And
no matter where you are in your
08:16 - journey, they're great places to
flex what you've learned.
08:19 - Alright, so those are some of
the best practices for this
08:22 - course. You're standing at the
edge of the rabbit hole, looking
08:26 - down, peering into the world of
web three and smart contracts
08:30 - and blockchain. If you're like
me want to jump in, you want to
08:33 - keep going further. Let's begin
our journey into the world of
08:37 - smart contracts. And it all
starts with the blockchain
08:40 - basics.
08:43 - Now, I know you're excited
08:44 - to get coding. But before we
jump in, we want to learn some
08:47 - of the fundamentals of
blockchains and smart contracts.
08:50 - Understanding these ideologies
and these basics are so
08:53 - important, because it'll dictate
how you architect your
08:56 - decentralized applications,
learning the basics of
08:59 - blockchain and solidity is
critical. But if you already
09:02 - know the basics of a blockchain,
feel free to jump into lesson
09:05 - two.
09:08 - Now, since you're here,
09:09 - you've probably heard of Bitcoin
before. Bitcoin was one of the
09:12 - first protocols to use this
revolutionary technology called
09:16 - blockchain. The Bitcoin white
paper was created by the pseudo
09:19 - anonymous Satoshi Nakamoto, and
outlined how Bitcoin can make
09:23 - peer to peer transactions. In a
decentralized network. This
09:26 - network was powered by
cryptography, decent Tality, and
09:30 - allowed people to engage in
censorship resistant finance, in
09:34 - a decentralized manner due to
its features, which we'll talk
09:37 - about in a little bit. People
took to this as a superior
09:40 - digital store of value, a better
store of value over something
09:44 - like gold, for example, and
that's why you'll also hear
09:47 - people commonly refer to it as a
digital gold similar to gold.
09:51 - There's a scarce amount or a set
amount of bitcoin available on
09:54 - the planet, only so much that
you can buy and sell. You can
09:57 - read more about the original
vision in the white A paper
10:00 - we've linked to the white paper
in the GitHub repo associated
10:03 - with this course. Now, this was
an insane breakthrough in a
10:06 - little bit, we're going to learn
exactly how this is all possible
10:09 - and how this actually works
under the hood. Some people
10:11 - though, saw this technology and
wanted to take it a little bit
10:15 - farther, and do even more with
this blockchain technology. And
10:18 - a few years later, a man named
Vitalik Buterin, released a
10:22 - white paper for a new protocol
named Aetherium, which use this
10:26 - same blockchain infrastructure
with an additional feature. And
10:30 - in 2015, him and a number of
other co founders released the
10:34 - project Aetherium, where people
could not only make
10:37 - decentralized transactions, but
decentralized agreements,
10:40 - decentralized organizations, and
all these other ways to interact
10:43 - with each other without a
centralized intermediary or
10:46 - centralized governing force.
Basically, their idea was to
10:50 - take this thing that made
Bitcoin so great, and add
10:53 - decentralized agreements to it,
or smart contracts. And in fact,
10:58 - technically, these smart
contracts weren't even really a
11:00 - new idea. Back in 1994, a man
named Nick Zabo, had actually
11:05 - originally come up with the idea
smart contracts are a set of
11:08 - instructions executed in a
decentralized autonomous way,
11:12 - without the need for a third
party or centralized body to run
11:16 - them. And they come to life on
these blockchains, or these
11:19 - smart contract platforms, like
Aetherium. And it's the smart
11:22 - contracts that are going to be
the core thing that we're going
11:24 - to be working on in this course,
and that we're going to be
11:26 - developing, you can think of
smart contracts in the same way
11:29 - you think of traditional
contracts or traditional
11:31 - agreements. They're just a set
of instructions between parties,
11:34 - except instead of written on pen
and paper or typed up in
11:37 - Microsoft Word, they are written
in code and embodied on these
11:41 - decentralized blockchain
platforms. And that's also where
11:44 - they're executed. Instead of
being executed by the two
11:47 - parties, or three parties, or
however many parties that are
11:49 - involved. This removes this
centralized issue that we'll
11:53 - talk about more in a bit. This
is one of the main
11:55 - differentiators between the
Etherium protocol and the
11:58 - Bitcoin protocol. It's these
smart contracts. Now,
12:01 - technically, bitcoin does have
smart contracts, but they're
12:04 - intentionally Turing incomplete,
which means they don't have all
12:08 - the functionality that a
programming language would give
12:10 - them. This was an intentional
move by Bitcoin developers.
12:13 - Bitcoin developers viewed
Bitcoin as a store of value
12:17 - versus Aetherium, developers
viewed Aetherium as both a store
12:21 - of value and a utility to
facilitate these decentralized
12:25 - agreements. Now, the smart
contracts on blockchains alone
12:28 - are absolutely incredible.
However, they do come with a
12:31 - huge issue. If we want these
digital agreements to replace
12:34 - the agreements in our everyday
lives, they probably are going
12:37 - to need data from the real world
blockchains by themselves
12:40 - actually can't interact with and
can't read or listen to data
12:44 - from the real world. This is
what's known as the Oracle
12:47 - problem. These blockchains are
deterministic systems and
12:50 - they're deterministic on
purpose. And we'll learn about
12:52 - more about how that works in the
sessions to come. So everything
12:55 - that happens with them happens
in their little world. But if
12:58 - they're going to be these
agreements, they need external
13:00 - data and they need external
computation. And this is where
13:03 - Oracle's come into play.
Oracle's are any device that
13:06 - delivers data to these
decentralized blockchain or runs
13:09 - external computation. However,
if we want our applications to
13:12 - stay truly decentralized, we
can't work with a single Oracle
13:17 - or a single data provider or a
single source that's running
13:20 - these external computations. So
we need a decentralized Oracle
13:24 - network. Similar to our
decentralized blockchain
13:26 - network, you're on chain logic
will be decentralized, but you
13:29 - also need your off chain data
and computation be
13:32 - decentralized, combining this on
chain decentralized logic. With
13:36 - this off chain, decentralized
data and decentralized
13:39 - computation gives rise to
something called hybrid smart
13:42 - contracts. And most of the
biggest protocols that we
13:45 - interact with today are some
type of hybrid smart contract or
13:49 - interact with hybrid smart
contracts. To some extent, this
13:52 - is where the protocol chaining
comes into play. It is a
13:55 - modular, decentralized Oracle
network that can both bring
13:58 - external data and external
computation into our smart
14:02 - contracts to make sure they're
decentralized end to end, while
14:05 - giving them the feature richness
that we need for our agreements.
14:09 - chainlink allows for us to get
data to upkeeps, get random
14:13 - numbers or really customize our
smart contracts in any
14:16 - meaningful way. Now, throughout
the course, we're going to use
14:18 - the terminology smart contract.
However, whenever we say smart
14:22 - contract, we're often using it a
little interchangeably with
14:26 - hybrid smart contracts, but just
know that when we say hybrid
14:28 - smart contract, we're talking
specifically about smart
14:32 - contracts that have some type of
off chain component. Now since
14:35 - the theorems release, a number
of different block chains or
14:37 - smart contract platforms have
come to light such as avalanche
14:41 - polygon, Phantom harmony, and
more. For the majority of this
14:45 - course, we're going to be
assuming that we're going to be
14:47 - deploying to the Ethereum
network. However, everything
14:50 - that we learned here is going to
be applicable to the vast
14:53 - majority of the blockchains out
there like polygon, avalanche,
14:56 - Phantom harmony, etc, and
understanding everything from a
14:59 - theory and funding mentals will
give you the skills that you
15:01 - need to switch chains very
easily with literally one line
15:05 - of code. So don't worry about
learning a specific tool or with
15:08 - a specific chain because most of
them work together seamlessly.
15:12 - Now, there are a couple of smart
contract platforms that don't
15:15 - use solidity. But still learning
the fundamentals here will make
15:18 - you much better at those as
well. And the Etherium by far
15:21 - has the most value locked and is
the most used blockchain and
15:24 - smart contract platform out
there. You'll also hear those
15:26 - two terms used a little bit
interchangeably as well.
15:29 - Sometimes they'll say smart
contract platform, sometimes
15:31 - they'll say blockchain, they
kind of mean the same thing.
15:34 - Obviously, blockchains could
mean store of value and smart
15:37 - contract platform, but you get
the idea. Similarly, chainlink
15:41 - is the most popular and powerful
decentralized Oracle network is
15:44 - the one that we're going to be
focusing on for this course as
15:46 - well. chainlink is also
blockchain agnostic. So to work
15:50 - on Aetherium, avalanche, Polygon
Solana Terra, or really any
15:54 - other blockchain out there. Now,
throughout this course, you'll
15:56 - hear the term DAP or
decentralized Protocol, or smart
16:00 - contract Protocol, or
decentralized application. And
16:03 - they all kind of mean the same
thing. A decentralized
16:06 - application is usually the
combination of many smart
16:08 - contracts. And when we get into
solidity, you'll see what a
16:11 - singular smart contract really
looks like. And like I said,
16:14 - learning all these core
fundamentals will make you a
16:17 - better solidity and a better
smart contract developer, you'll
16:20 - also hear the term web three a
lot in this video. And in the
16:24 - industry, web three is the idea
that blockchain and smart
16:26 - contracts are the next iteration
of the web web one being this
16:30 - permissionless open source world
with static content, web two
16:34 - being the permissioned web with
dynamic content, but all the
16:37 - agreements and logic runs off of
centralized servers where they
16:41 - control your information. And
then web three comes back to the
16:44 - permissionless web. But once
again, with dynamic content, and
16:48 - instead of centralized servers,
running your logic,
16:50 - decentralized networks, run the
logic creating these censorship
16:54 - resistant agreements, that the
smart contracts enable is also
16:58 - generally accompanied by the
idea that the users own the
17:01 - protocols that they work with,
and it's an ownership economy.
17:04 - You'll see what I mean later in
this course. And we've talked a
17:06 - lot about the history and about
the high level of these
17:09 - protocols and of the smart
contracts and what they can do.
17:12 - But what do these smart
contracts really mean? What is
17:15 - it when I say trust, minimize
agreements or unbreakable
17:18 - promises? What is the real value
add of these smart contracts?
17:23 - Before we look under the hood,
take a peek at how this all
17:25 - works. From a technical
standpoint. Let's learn what all
17:29 - the value of this is. What is
the purpose of us building all
17:32 - these technologies? Have you
taken this course? What problem
17:35 - does this technology solve? In
my mind, a technology is really
17:38 - only as good as the problem that
it solves. If it doesn't solve a
17:41 - problem, then why bother Mark
contracts, Blockchain web three
17:45 - cryptocurrencies, those are all
just different words that
17:48 - encapsulate the idea of what
we're doing in such a unique
17:52 - paradigm. I think the easiest
way to sum up what these smart
17:55 - contracts do is that they create
trust minimized agreements. And
17:59 - if you might be scratching your
head to that. A much easier way
18:02 - to think about it is just that
give rise to unbreakable
18:06 - promises. Yes, you heard that
right. Unbreakable agreements
18:10 - and promises. Additionally, they
give rise to speed, efficiency
18:13 - and transparency, and a number
of other things. I made a video
18:17 - pretty recently about exactly
this. So let's dive in and take
18:21 - a listen to the purpose the
undeniable value
18:24 - of smart contracts
cryptocurrencies, fundamentally
18:30 - re landscape markets and
agreements as we know them.
18:33 - Unfortunately, you've probably
only been bombarded with people
18:36 - screaming about empties and
money. Now, some of the memes
18:38 - are fun, but let's forget the
bullet and get down to the
18:41 - essence of the space. If you're
already in web three. This is
18:44 - the video to send to your
friends to explain why you're so
18:47 - excited about this space and
explain why we're here. And then
18:50 - if you're not into crypto,
you've come to the right place.
18:53 - And yes, there are fun memes and
markets and there's some money
18:55 - stuff in there all these things.
But outside of all that the
18:58 - purpose of blockchains relates
to the age old elementary school
19:02 - unbreakable, promise the pinky
swear, let's get Froggy. Nearly
19:07 - everything you do in life is the
result of an agreement or a
19:10 - contract. Your chair was the
result of an agreement to buy
19:14 - and sell lumber to assemble and
sell the chair to a real tailor
19:16 - on Amazon. Then you made an
agreement to buy the chair for
19:19 - $40. The lights in your house
are powered by electricity,
19:23 - which is an agreement from you
and the electric company you
19:25 - agree to pay them in return
they'll keep the lights on the
19:28 - electricity they generate it's
agreements between them and
19:30 - engineers who built turbines to
generate the electricity with
19:33 - insurance you agree to pay some
amount of money to them every
19:36 - month, and in return, they will
do nothing or I mean, they'll
19:39 - cover your medical bills, almost
everything you do and everything
19:43 - you interact with is the result
of some form of agreement or
19:46 - contract in some aspect. Now,
agreements and contracts can
19:50 - feel kind of abstract and boring
to really grasp on to simplify,
19:54 - we can also refer to them as
promises. When you get an oil
19:57 - change. They're promising that
they will faithfully change your
19:59 - oil In exchange for money, when
you put money in the bank, they
20:03 - promise to keep it safe in
exchange for them to use your
20:06 - money to give out loans. When
you buy a lottery ticket, the
20:09 - lottery promises to give you a
fair chance at winning a ton of
20:12 - money in exchange for you buying
the ticket. Whenever you make
20:15 - one of these agreements. In a
way, you're asking them to pinky
20:19 - swear to not screw you over and
to treat you fairly. But this
20:22 - doesn't always happen. Let's
look at a real world example of
20:25 - someone breaking the Pinkie
swear back in the 80s and 90s,
20:28 - McDonald's ran a promotion for
people to win money by
20:30 - collecting McDonald's Monopoly
game cards. The idea was simple.
20:33 - You buy McDonald's in return,
you get a chance to win $1
20:36 - million. You can imagine
McDonald's literally going Hey,
20:41 - everybody, I promise you if you
buy our MC food and McNuggets,
20:44 - we'll give you a fair chance of
winning this money, we ended up
20:48 - breaking this promise, instead
of having a fair chance of
20:50 - winning your chance was in fact,
zero in the mid 90s. Between 13
20:56 - and $24 million went into the
pockets of not people playing
21:00 - the game, honestly. But a group
of corrupt insiders who had
21:03 - rigged the game, meaning that
when you played the McDonald's
21:06 - Monopoly game, you were buying
into a set of lies and promises
21:09 - that were 100% always going to
be broken. And the thing is, it
21:13 - doesn't really matter if this
was McDonald's fault or not.
21:16 - They were the ones making the
promises that they ultimately
21:19 - could not keep. Another way you
could think about it is that
21:21 - that's $24 million that they
essentially stole from you and I
21:26 - now if this system was deployed
on a blockchain was something
21:30 - called a smart contract, it
would have been impossible to
21:34 - defraud this $24 million due to
smart contracts being immutable,
21:39 - decentralized and transparent.
But I'll get back to that in a
21:42 - minute. In all the agreements
and contracts we make, imagine
21:47 - making a pinky swear with a 10
year old and imagining how that
21:51 - agreement would hold up. Hey,
buddy, Could you could you
21:53 - please keep my money safe? You
can play with it if you like,
21:55 - but just please have it when I
come back. Immediately. You
21:58 - might get that worrying feeling
in your chest, something might
22:01 - go wrong. This 10 year old might
lose your money. You might be
22:03 - thinking, how could I trust
them? Will they break their
22:07 - promise and this feeling of I
can't breathe because of
22:10 - untrustworthy situations
happens? Once all the time. Can
22:14 - I trust this used car
salesperson to give me a good
22:16 - car? Can I trust this tag that
says machine washable? Or will
22:20 - it make my shirt shrink? Will my
insurance provider break their
22:22 - promise of covering my medical
bills want to get hit by a bus?
22:25 - I'm Patrick promises he'll go on
a hike with me. Well, he
22:28 - actually I actually will. But
the issue with our current
22:32 - agreements and contracts is we
have to trust the people. We're
22:35 - making them to do the right
thing. However often they're
22:38 - actually incentivized to not do
the right thing. insurance
22:41 - doesn't want to pay out money.
Sometimes salespeople just want
22:44 - to get the shit off the shelves
and with my girlfriend, I
22:47 - promised to go on a hike. But I
need hikes. Where else is has
22:50 - happened. Now you might be
thinking okay, Patrick, this
22:52 - seems cool. But like Where has
this actually affected me? Well,
22:56 - the McDonald's lottery that we
just spoke about above during
22:59 - the Great Depression with the
run of the banks banks promised
23:01 - to keep our money safe and that
when we went back to go get it
23:04 - they would actually have the
money there. And well and behold
23:07 - there were times that they
didn't have the money they're
23:10 - just last year Robin Hood
painted this amazing picture. On
23:14 - user application we will give
you access to the markets we
23:17 - promise we will give you a
retail investor a fair chance of
23:22 - interacting with the world the
finance
23:25 - side, but not this asset. This
asset, this asset or this asset,
23:29 - the 2008 financial crisis
remember that shady deals behind
23:33 - closed doors combined with lies
about financial product brought
23:35 - the world to its economic knees,
how are you? hyperinflation in
23:39 - Zimbabwe hyperinflation in
Brazil, fair enough. US history
23:42 - is a relentless lesson of
trustworthy entities being
23:46 - notorious promised breakers and
we finally have a way to fix it
23:49 - with smart contracts. Now,
before I jump into smart
23:52 - contracts, a lot of people might
be thinking, hey, cool in all,
23:56 - however, we have systems in
place to protect against a lot
23:59 - of these things, which is true,
and which is great. And that is
24:03 - a very helpful step forward. But
these systems often breaks ones
24:06 - in 2008 Definitely didn't work.
The ones with the Robin Hood
24:09 - crisis definitely didn't work.
And even if these systems apply,
24:12 - and you go to court to try to
work them out, maybe you're in
24:15 - court for years before you
actually see a resolution and by
24:18 - that time, what you needed the
money for is longer. So what is
24:23 - this technology? What is this
tool that can fix this
24:26 - fundamental problem in our
agreements today, this tool is
24:30 - smart contracts and this tool is
what the blockchain was built
24:33 - for. Now, I'm gonna give you a
quick overview of what a smart
24:36 - contract is. However, I'm
leaving some links in the
24:39 - description for more in depth
explanations, but the basics of
24:42 - them is a smart contract is an
agreement contract or a set of
24:46 - instructions deployed on a
decentralized blockchain. And
24:49 - once the contract or set of
instructions is deployed, it
24:52 - cannot be altered, it
automatically executes and
24:56 - everyone can see the terms of
the agreement. Real basics of it
24:59 - is that the code is executed by
decentralized collective like a
25:02 - group of people but a group of
people running a certain
25:05 - software. This means that no one
person or entity can actually
25:08 - alter any of these agreements or
change the terms of the
25:11 - arrangement in these traditional
agreements. Whoever owns the
25:14 - contract, whoever owns the
execution of the contract can
25:17 - flip a switch and say, We're not
going to do that anymore. In
25:20 - smart contracts and web three in
blockchain, you no longer can do
25:24 - that. Typically, these smart
contracts are on a decentralized
25:26 - blockchain, and used in
combination with a decentralized
25:29 - Oracle network to get the real
world assets and information.
25:32 - And if these words sound like
I'm conjuring up a magic spell,
25:35 - well, again, check the links in
the description. If you want to
25:37 - learn more about the technical
implications. If you're not a
25:39 - technical person, then you're
not interested in getting into
25:41 - the nitty gritty, you can kind
of think of it like HTTPS, I bet
25:45 - the vast majority of you don't
even know what HTTPS stands for.
25:48 - And yet you use it every single
day whenever you log on to the
25:51 - internet. So how does this fix
the McDonald's Monopoly issue?
25:54 - In its traditional form, the
lottery was executed behind
25:57 - closed doors, somebody operated
and owned the code and the
26:01 - contracts and the agreements
that ran the lottery, and they
26:03 - had the power to alter it. And
nobody other than the people
26:07 - internal on the lottery could
audit this altering happening.
26:10 - Now if the code for this lottery
was deployed onto a blockchain,
26:15 - every time a hacker attempted to
alter it, everyone would be
26:18 - notified. Not only that, but you
couldn't even alter it, because
26:21 - the terms of a smart contract
cannot be altered. Once
26:23 - deployed, combine that smart
contract with a chain link VRF
26:26 - Oracle to get a verifiably
random number. And presto, you
26:30 - now have a perfectly
decentralized, unalterable
26:33 - agreement that is impossible to
hack commit fraud or manipulate
26:36 - we have just saved the public
between 13,000,020 $4 million
26:41 - just by fixing the issue of
trust. How does this fix Robin
26:46 - Hood? Well, the problem with
Robin Hood is already fixed.
26:48 - Right? Again, the problem is
that there's a centralized body
26:51 - that can flip a switch at any
time and say you can't access
26:55 - these markets anymore. We're
breaking our promise of actually
26:58 - giving you access to the
markets. This is already fixed
27:01 - with something called
decentralized exchanges. And
27:03 - these exist today, one of these
exchanges is one called uniswap.
27:07 - You can swap ERC 20 tokens,
which are kind of the equivalent
27:10 - of stocks, but some are some
are, it's a little confusing. I
27:13 - won't get into that here either.
But it doesn't have that
27:15 - centralized body that can flip a
switch and ruin access to the
27:19 - markets. And had these investors
been on a decentralized
27:22 - exchange, it would have saved
them hundreds of millions of
27:26 - dollars, and it would have
prevented fraudulent market
27:29 - manipulation. How does it fix
run of the banks with
27:31 - transparency built in an
automated solvency checks, you
27:34 - can build a bank like smart
contract that has insolvency
27:37 - checks built in that make it
impossible to get there and
27:39 - solve it means brokers any
agreement or any history lesson,
27:44 - where there was a trust
assumption that was broken,
27:47 - smart contracts can be applied
to and should be applied to,
27:50 - especially in a time where big
money runs, owns and controls
27:54 - everything, we desperately need
to move to a world where some
27:58 - self interested centralized
entity can't flip a switch and
28:01 - ruin people's access to the
services that they need. We can
28:04 - move away from a world that is
brand based to a world that is
28:08 - math based. Right now, if you
interact with a service that you
28:11 - don't like, or that they break
their promise, the only thing
28:15 - you can do is walk down the
street to the next service
28:18 - that's going to make the same
set of promises. And you have to
28:20 - hope and pray that they're
actually going to keep it we can
28:23 - move from that to a world where
we can just look at the map and
28:26 - say, oh, okay, one plus one
equals two. This is what this
28:29 - agreement is going to do for me
every single time guaranteed,
28:33 - because it's a decentralized
autonomous agent has no
28:36 - incentive to be evil, and
everything is transparent and
28:39 - out in the open of a big
company. And if it was better
28:42 - for me for one plus one to equal
three, maybe I would go behind
28:45 - some closed doors and flood some
numbers and come back and be
28:48 - like, hey, one plus one equals
three with smart contracts.
28:51 - That's impossible. Doing the
right thing is infrastructural
28:55 - now, given the choice between
two agreements, one where you
28:58 - have to trust a single
centralized entity that they're
29:01 - going to do the right thing for
you, versus a decentralized
29:05 - untampered double collective,
29:07 - which one you're gonna choose.
I'm picking the one that can't
29:09 - screw me over every single time.
For every agreement I can apply
29:14 - it to now this technology is
relatively new, but we have
29:17 - already seen it relandscaping
entire markets and continue to
29:20 - do so the traditional financial
world is already getting its
29:23 - lunch eaten by defy or
decentralized finance. There's
29:27 - already over $200 billion of
people's money in these
29:30 - protocols to help have a more
fair, more accountable, more
29:34 - transparent financial system.
This defy movement is one of the
29:37 - main reasons I got into this
space because we desperately
29:40 - need to move away from where we
are right now. And and people's
29:44 - chances for wealth being sucked
up by some group that's bending
29:47 - the rules in their favor and
smart contracts are our ticket
29:50 - to that better world. More and
more industries are also coming
29:53 - over to smart contracts and
blockchain because of all the
29:56 - innovations and because of all
the advantages that it has as we
29:59 - grow and as we get better as we
get closer to this vision of
30:02 - having this concept fulfilled,
trust minimized agreements.
30:06 - These smart contracts are
minimizing the trust that we
30:09 - need to give other people in
order for these agreements to be
30:12 - executed. If trust minimized
agreements is too confusing for
30:15 - you just say unbreakable
promises. Now I gotta be honest
30:18 - with you guys. blockchains and
smart contracts and
30:21 - cryptocurrencies can actually do
more than just trust, minimize
30:23 - agreements. They have security
benefits, uptime benefits,
30:26 - execution, speed benefits, and a
whole lot more. But it's a lot
30:29 - easier to just learn about one
and learn the other ones later,
30:31 - right. It's kind of like
sprinkles on top. So this is why
30:34 - we are here. This is why we're
building this future and this is
30:36 - why we are so excited about it.
30:42 - Even in just this introduction
part, we've learned a ton. So
30:46 - let's do a quick summary of what
we've learned so far. Bitcoin
30:49 - was the first protocol to take
this blockchain technology into
30:53 - the limelight and take these
cryptocurrencies into the
30:55 - mainstream Bitcoin is a sort of
digital gold or a store of value
30:59 - able to make transactions
between users in a decentralized
31:02 - manner. Aetherium and other
smart contract platforms take
31:05 - this blockchain technology one
step further, enabling people to
31:08 - make smart contracts and
decentralized trust minimized
31:11 - agreements, the smart contracts
and decentralized applications
31:14 - can access and interact with the
real world using something
31:18 - called decentralized Oracle
networks. chain link is a
31:21 - decentralized network that
allows us to build these hybrid
31:24 - smart contracts, which combines
our on chain logic with our off
31:28 - chain, decentralized data, and
decentralized computation,
31:31 - giving rise to our logic being
completely decentralized, and
31:35 - our data and external
computation being completely
31:37 - decentralized, giving us all the
features that traditional
31:41 - agreements and traditional
contracts have. Now these
31:44 - digital currencies like
Aetherium, and Bitcoin have
31:46 - value. Even without the smart
contract part, having a
31:50 - censorship resistant,
decentralized store of value is
31:53 - naturally powerful in its own
right, we have some links in the
31:56 - GitHub repository that will
teach you how this decentralized
31:58 - store of value flips traditional
finance on its head. And it's
32:02 - another one of the great reasons
for building smart contracts.
32:04 - But again, the easiest way to
boil it down is trust minimized
32:08 - agreements, or unbreakable
promises. But let's also go into
32:11 - some of these other features
that smart contracts have over
32:13 - our traditional environment. The
first feature, of course, is
32:16 - that they are decentralized. And
they have no centralized
32:19 - intermediary, the different
individuals that run one of
32:21 - these blockchains are known as
node operators. And it's the
32:24 - combination of all these 1000s
of node operators running the
32:28 - same software running these
algorithms running these smart
32:31 - contracts that make the network
decentralized. We'll dive deeper
32:34 - into how that works later. The
next feature is transparency and
32:38 - flexibility in these
decentralized networks. Since
32:41 - all these individual node
operators run the software,
32:44 - everybody can see everything
that's happening on chain,
32:47 - meaning there's no shady deals,
there's no weird things
32:49 - happening. Anything that's going
to be unfair, people will be
32:53 - able to see and just not use,
everybody has perfect
32:56 - information and has to play by
the same rules. Now
33:00 - additionally, this doesn't mean
that there's no privacy, the
33:03 - blockchain is pseudo anonymous,
meaning that you aren't
33:05 - necessarily tied to an identity
in real life, they also have the
33:09 - feature of speed and efficiency.
For those of you who have ever
33:12 - tried to do a bank transfer or
send money across seas, you
33:16 - know, it sometimes can take two
to three weeks, when in fact,
33:19 - all these banks are really doing
is basic math. They're
33:22 - subtracting money from your
balance and adding it to some
33:26 - other balance. Why does it take
so long, in the blockchain, all
33:29 - of these transactions happen
instantly. Another instance for
33:33 - those in the financial world
today know that clearing houses
33:35 - and settlement days can take a
long time. In the blockchain,
33:39 - there's no need for any of that,
because they happen instantly.
33:42 - This obviously is much quicker,
but it also makes for much more
33:45 - efficient interactions with each
other security and immutability.
33:48 - Again, immutable means that it
can't be changed. Once a smart
33:52 - contract is deployed, that's it,
whatever is in the code is going
33:56 - to be in the code forever, they
cannot be altered or tampered
33:59 - with in any way. This means that
the security is much easier.
34:02 - Whereas in a centralized world,
somebody can hack into the
34:04 - server, jump into the database
and change some numbers. You
34:08 - can't do that in the blockchain
world. And since it's
34:10 - decentralized, in order to hack
the blockchain, you'd have to
34:14 - take over half of the nodes as
opposed to in the centralized
34:17 - world, where you only have to
take over one in the regular
34:20 - world. If your computer and your
backup computer go down, all of
34:23 - your data is gone. In the
blockchain world, if your
34:27 - computer and your backup
computer go down, all your data
34:30 - is safe, because it's being run
on all these other decentralized
34:34 - nodes. And even if a few 100
nodes or a few 1000 nodes go
34:38 - down. It doesn't matter because
as long as one node has a copy
34:41 - of the blockchain, you're good
to go hacking a blockchain is
34:45 - nearly impossible, and leaps and
bounds more difficult than
34:49 - hacking a centralized server.
Not only that, but this is safer
34:52 - in the asset sense as well. All
you need to access your
34:56 - credentials and your information
in your assets is your private
34:59 - key. Which is basically your
password for all of this. And as
35:03 - we've discussed in the video,
the smart contracts remove this
35:06 - counterparty risk, remove this
centralized intermediary, remove
35:09 - these trust gateways that we
have to do in web two. When we
35:13 - engage with users and
individuals, they don't always
35:15 - have our best interests at heart
smart contracts, remove this
35:19 - counterparty risk, because once
one of these contracts is
35:21 - created, they can't go in and
they can't alter it. And they
35:24 - can't let greed or ego or
anything else, get the better of
35:27 - them and alter the terms of the
deal. And as we said, this gives
35:30 - rise to these trust minimized
agreements or these programmatic
35:34 - unbreakable promises. We move
away from brand based agreements
35:38 - to math based agreements, where
we can look at the cryptography
35:41 - we can look right at the code
and see exactly what something
35:44 - is going to do and how it's
going to execute, versus having
35:47 - to rely on a human being doing
the right thing with smart
35:51 - contracts and decentralized
hybrid smart contracts. Doing
35:54 - the right thing is
infrastructural all these pieces
35:57 - boil down to us having the
freedom to interact the way we
36:01 - want to interact without having
to be afraid that interacting
36:04 - like that is going to screw us
over this trust minimized piece,
36:07 - these unbreakable promises, make
interactions so much better. In
36:12 - a purely web two world, we're
constantly bombarded with
36:15 - messages of projects and
protocols pushing us to move or
36:19 - act in the direction that makes
them more profitable. Versus in
36:22 - the smart contract space,
36:23 - we can see everything
transparently. And we can even
36:26 - engage in interact and be
partially owners of the
36:29 - protocols and the interactions
that we decide that we want to
36:33 - be a part
36:33 - of. So smart contracts have
36:38 - been around for a few years now.
And what did they generate for
36:41 - what industries have come about
due to these smart contract
36:44 - platforms being around? Well,
you've probably heard of some of
36:46 - these and some of these we've
already mentioned, but let's
36:49 - give you a quick refresher, d
phi d phi stands for
36:52 - decentralized finance. And it
gives users the ability to
36:56 - engage with finance and markets
without having to go through a
36:58 - centralized intermediary. For
example, like we said, with
37:01 - Robin Hood, you no longer have
to trust that Robin Hood would
37:04 - continue to give you access to
the markets, you instead would
37:07 - be able to see in the smart
contract. Yes, I have access to
37:10 - the markets or in the 2008
financial crisis. You never have
37:13 - to trust that these groups and
institutions are giving you the
37:16 - correct things on the back end.
You can see everything
37:19 - transparently right on the
blockchain, you can engage with
37:22 - things like money markets and
sophisticated financial products
37:25 - easy effectively and securely at
the time of recording. defi has
37:30 - around $200 billion in assets
under management and is quickly
37:34 - growing. If you're really
excited about defy we have a ton
37:37 - of defy examples showing you how
to build and interact with these
37:40 - protocols. In coming lessons.
Dows or decentralized.
37:43 - autonomous organizations are
another group that we've already
37:46 - mentioned. Dows are groups that
are governed completely
37:49 - decentralized by a set of
instructions or smart contracts
37:52 - on chain. There are some massive
benefits here where engagement
37:56 - is much easier. The rules are
black and white. And you can see
37:58 - everything directly on chain
voting and governance
38:01 - technologies completely
decentralized in the blockchain
38:04 - space is one of the big ones
pushing how we can evolve
38:06 - politics and how we can evolve
governance to make it more
38:09 - efficient, fair and reasonable.
And you better know it, we have
38:12 - some examples of how to build
Dows and how to work with Dows
38:15 - incoming lessons. So be sure to
watch those NF T's Stanford non
38:18 - fungible tokens and can really
be kind of described as digital
38:22 - art or just a unique asset, they
can do so much more, but we'll
38:26 - keep it high level for now.
Projects like board apes and
38:29 - crypto punks have revolutionized
the way that people get paid for
38:32 - their work, show off their
creativity, status, and so much
38:35 - more. And yes, of course, we
have lessons showing you how to
38:38 - create and interact with NF T's
as well, so many other groups
38:42 - and so many other industries are
being created as a result of
38:44 - this insane technology. And
maybe after finishing the
38:47 - journey with us here, you go out
and you'd be the one to pioneer
38:51 - the next industry or the next
billion dollar idea you've
38:54 - learned so much already. But now
that we've learned a lot of this
38:58 - high level information, let's
finally jump in, and let's make
39:02 - your first transaction and let's
get you set up to interact with
39:06 - this new world. In this next
section, we're going to get you
39:09 - a wallet and we're going to show
you exactly what a transaction
39:12 - looks like and feels like. Let's
dive in. This is the Aetherium
39:20 - website aetherium.org We are
going to make a transaction on a
39:24 - test Aetherium blockchain I'll
explain what that means in a
39:28 - little bit. This is going to be
our first transaction that's
39:31 - made on the blockchain. Now
again, this process that we're
39:34 - going to follow is going to work
the exact same with polygon,
39:38 - avalanche Phantom and all these
other EVM compatible
39:41 - blockchains. I'll explain what
that means in a bit too. For
39:44 - now, just follow along and have
fun in order to make a
39:47 - transaction on any of these
blockchains. The first thing
39:50 - that we need to do is we need to
set up a wallet. So I'm gonna go
39:55 - ahead and go to meta mask
because it's one of the most
39:57 - popular wallets and one of the
easiest to Use, we're going to
40:00 - go ahead and download it. I'm
using the brave browser, but it
40:03 - works for Chrome, Firefox or
really any other browsers. And
40:07 - it's just going to be a little
extension in the top right hand
40:11 - of your browser. This way, we
can really easily see it any
40:14 - times what we have in our
wallet, will still are all of
40:17 - our Aetherium based currencies.
So I'm gonna go ahead and
40:21 - install meta mask for brave,
40:24 - add to brave, add extension. And
now we can go ahead and get
40:27 - started with working with Brave,
this is the first step you
40:31 - absolutely need to take when
starting your journey and one of
40:34 - the easiest steps to take. So
we're gonna go ahead and get
40:36 - started. And we're going to
create a brand new wallet. So
40:40 - we're gonna go ahead and hit
create wallet. If you already
40:42 - have a wallet, you can actually
import it via I have a seed
40:46 - phrase, and we'll talk about the
seed phrase or secret phrase in
40:49 - a little bit. So let's go ahead
and create a new wallet. And
40:53 - sure, we'll agree to help out
Metamask now we will create our
40:56 - password make sure that this is
really secure. For the purpose
41:00 - of this demo, my passwords are
just gonna be password. But
41:03 - please don't have that be your
password. You may also get a
41:06 - video like this teaching you
about your secret recovery
41:08 - phrase. This is the same thing
as your pneumonic. But see your
41:12 - recovery phrase is a lot more
clear as to what it is. And
41:15 - again, to give us a ton of
different tips on how to
41:17 - actually store it and keep it
safe. The main takeaway from
41:21 - this is never shared this
absolutely never shared this. So
41:24 - we're going to go ahead and
click reveal secret words. I'm
41:28 - showing you guys here because
this is just a demo and I don't
41:31 - really care. However, if you
show this secret phrase to
41:35 - anybody else, they will have
access to all the funds in your
41:38 - application. So everything that
we're going to do in this
41:41 - tutorial, we're going to use
fake money, we're going to use
41:44 - not real money, so it doesn't
matter. Now for the purposes of
41:47 - testing and developing, I always
recommend using a completely
41:51 - separate meta mask, a completely
separate Wallet. So for going
41:54 - throughout this entire course,
if you already have a wallet, or
41:57 - if you already have a meta mask,
please just set up a new one,
42:01 - create a new profile, create a
new meta mask, and this will be
42:04 - your wallet that you use for the
duration of this course.
42:06 - However, if you're going to
actually put money in here, you
42:09 - absolutely need to have this
written down. Because if you
42:11 - lose access to this, and all
your private keys, which we'll
42:14 - talk about in a little bit, you
will lose access to your wallet,
42:17 - and you will lose access to all
your funds. So they give some
42:20 - tips like store this phrase and
a password manager like one
42:23 - password, write this phrase down
on a piece of paper, put it in a
42:26 - secure location, memorize it,
whatever you want to do, just
42:30 - make sure you have this backed
up somewhere, I'm just gonna go
42:32 - ahead and hit download this for
now, it's not best practice to
42:35 - save to your computer, it is
much better to use a password
42:37 - manager or write it down on a
piece of paper or something. So
42:40 - we're gonna go ahead and hit
next. And it's going to ask us
42:44 - to verify that we actually have
it written down. And we're gonna
42:49 - go ahead and hit confirm, and
great and gives us a couple
42:52 - other tips. Remember, definitely
take these tips very seriously,
42:55 - especially if you're gonna use
this for real money. Like I
42:58 - said, For this demo, we're just
going to use test money. So it's
43:01 - not as big of a deal. But if you
put real money in, you
43:04 - absolutely need to backup this
seed phrase or secret phrase or
43:08 - we're going to refer to it as
our pneumonic phrase. Awesome.
43:11 - Now we can see the interface of
our wallet here full screen. And
43:16 - depending on your browser, you
can actually come up and pin it
43:19 - to your browser so that you can
just click it up in the top
43:22 - right, and it'll drop down and
you can see the same interface
43:25 - here our pneumonic phrase that
secret phrase, those that secret
43:29 - 12 words that they gave us have
given us access to a new
43:33 - account, the address of our
account is located right here.
43:36 - In fact, if we click it and copy
it to our clipboard, and go to a
43:41 - tool called a block explorer
called ether scan, we can
43:45 - actually paste our address in
here and see details about our
43:49 - account. Ether scan, like I
said, is what's known as a block
43:52 - Explorer. And it's a way to view
different addresses transactions
43:55 - and other happenings that happen
with a blockchain. If we look at
43:59 - this address that we just
created on ether scan for
44:02 - Etherium main net, we can see no
transactions have happened.
44:06 - There's really no analytics,
there's no comments, there's no
44:09 - balance, there's no value,
because it's a brand new wallet,
44:13 - and this address that we just
punched into ether scan
44:16 - represents our unique address
our unique wallet only
44:21 - identifiable for us. We'll talk
about ether scan a little bit
44:25 - more in a bit because it's a
tool that we're going to use
44:27 - quite often in wallets like meta
mask, you can actually even
44:30 - click right here and create even
more accounts. So let's go ahead
44:34 - and create a new account. We'll
call this
44:38 - account two.
44:41 - As you can see, this one has a
different address. So if we
44:44 - click this one, we go back to
ether scan. We paste the address
44:49 - in here. We hit Enter. We can
see another address again that's
44:53 - uniquely identifiable to us,
right here. It is zero balance,
44:57 - no value, no transactions now If
we go back to our Metamask, and
45:01 - we click the little button, we
can see we have two different
45:04 - accounts in here, it's the same.
If we hit the extension in the
45:07 - top right, click the button, we
have two different accounts. The
45:12 - 12 word secret recovery phrase
allows us to create multiple
45:16 - accounts, all with the same
secret recovery phrase. So that
45:20 - secret recovery phrase will give
us access to both account one
45:24 - and account two and any other
accounts that we create by
45:28 - hitting this Create Account
button, because it gives you
45:30 - access to all the accounts in
your meta mask. Now, these
45:34 - addresses of both of our
accounts are the public unique
45:38 - identifiers, but they also have
a private unique identifier only
45:43 - identifiable to us. Similar to
the pneumonic, these are private
45:48 - identifiers we never want to
share and we never want to give
45:51 - out their private This is known
as your accounts private key. So
45:55 - the mnemonic will give you
access over many of these
45:58 - accounts, the private key will
give you access to just one of
46:01 - these accounts, we can see it by
hitting these little three dots,
46:04 - going to account details and
export private key, you'll just
46:08 - have to punch in your password
here. And you'll be able to see
46:12 - your private key. This is going
to be your private key for your
46:16 - account, you can think of your
private key as a password for
46:19 - your account that lets you
create transactions. Now the
46:23 - reason that I'm showing mine on
screen is because I'm not going
46:26 - to put any real money in here.
And this is just going to be a
46:28 - burner account for this
tutorial. And I highly recommend
46:32 - once again, you use a burner
account, you use accounts that
46:35 - you never put any real money
into. And along the way, I'll
46:38 - show you how to make sure that
you don't do that. But normally,
46:42 - it's not a good idea to show or
share your private keys or your
46:45 - secret recovery phrase, if
somebody gets a hold of this
46:49 - private key, they will have
access to my account one.
46:53 - However, they won't have access
to my account to if they get a
46:57 - hold of my 12 word recovery
phrase or pneumonic they'll have
47:00 - access to both accounts. And
this is why when people say keep
47:04 - your private keys safe, your
keys, your Bitcoin, your keys,
47:07 - your Aetherium, they're talking
about both your mnemonics or
47:11 - your secret recovery phrases.
And your private keys keep those
47:15 - private, your public addresses
are totally public. And anybody
47:19 - can view your accounts on
something like ether scan, or
47:22 - any other explore. And it's
totally okay for people to share
47:25 - their public addresses. If you
lose your private key, you lose
47:28 - access to one of your accounts.
If you lose your mnemonic, you
47:31 - could potentially lose access to
all your accounts. Basically,
47:34 - what I'm trying to say is back
these up and keep them in safe
47:37 - places for this course it's okay
if you lose one, since we're not
47:41 - putting any real money in them.
But in the real world, be sure
47:44 - to do this. And great. Those are
some of the main security
47:46 - considerations here. Now, if you
look up in the top right, right
47:49 - next to that account button that
we've been clicking, you also
47:52 - see this thing saying Etherium
main net, this is our networks
47:57 - tab. And if we click it, we can
see a list of all the different
48:00 - networks that we currently have
access to a Etherium main net is
48:05 - the main network of Aetherium.
And this is where real money is
48:09 - spent and used for transactions.
For this course, we're not going
48:13 - to be working with the Etherium
main net, we're instead going to
48:15 - be working with something called
a test net. Since we're
48:18 - engineers, oftentimes, we're
going to want to test and see
48:22 - what our code is actually going
to do and how to interact with
48:25 - it. We're going to use a
combination of local networks
48:28 - and test networks to actually do
this to actually test our smart
48:32 - contracts. We're mainly going to
use local networks. But we'll
48:35 - get to that in a little bit to
see some of the test networks
48:38 - that come default with meta
mask, we hit show slash hide
48:42 - test networks, this will bring
us into the settings page. And
48:45 - we just hit select this to show
test networks in the list. And
48:48 - we just hit on Now if we scroll
back up, we'll close out of the
48:52 - settings, we hit the network's
tab again. Now we can see all of
48:57 - these other networks here like
ropsten, Koven, Rinkeby, and
49:01 - Garelli. These test networks or
networks that resemble
49:04 - Aetherium, or polygon, or
Avalanche or phantom or any of
49:08 - these other blockchains. And we
can actually switch our accounts
49:11 - to one of these other test
networks. Let's click rink B,
49:15 - for example, we can see that on
the Rinkeby test network. We
49:18 - also have zero Aetherium we have
no money or nothing in here, we
49:22 - have a blank Rinkeby wallet.
These test nets work nearly
49:26 - identical to how Aetherium main
networks except for they run
49:29 - with not real money. They run
with fake money as a way for us
49:33 - to learn and interact and see
how these different smart
49:36 - contracts actually work together
at the time of filming. rink B
49:39 - is one of the most popular test
networks along with COVID. So
49:43 - we're going to work a lot with
Rigby In this tutorial, however,
49:47 - be absolutely sure to check our
GitHub repository to make sure
49:51 - that you're always up to date
with the best test network for
49:55 - following along with the
tutorial here since their test
49:57 - networks people are running them
out of the goodness of their
50:00 - hearts. And sometimes the best
ones actually change so, so be
50:03 - sure to follow along with the
GitHub repository. We might also
50:06 - use COVID From time to time or
maybe even Grilli. So we're
50:10 - going to show you how to use a
couple of these different test
50:12 - nets. In fact, if we go to the
GitHub repo associated with this
50:15 - course, we can see recommended
test net is indeed currently
50:19 - ranking. So that's what we're
going to work with should this
50:22 - change, you should be able to
follow along with another test.
50:25 - And we'll leave notes as to how
to continue. Now what we can do
50:28 - actually is we can go to Rigby
ether scan, we can go to,
50:34 - you can look up Rinku ether
scan, and it looks like it's the
50:37 - first thing that shows up
Rinkeby dot ether scan.io, we
50:41 - can punch in this same address,
copy and paste it. And we can
50:47 - see some of the details of this
address on the Rinkeby ether
50:50 - scan. Like I said, right now,
it's totally blank. This
50:53 - networks interface later on is
also how we're going to be able
50:57 - to work with polygon, avalanche,
etc, we'll just have to add
51:00 - networks. But we'll get to that
in a bit. And just to reiterate,
51:03 - test nets are free and for
testing our smart contracts and
51:06 - main net networks cost money and
are considered live. Now I also
51:11 - do want to put a caveat here
that we do want to keep in mind
51:14 - that these test nets are being
run at the goodness of people's
51:17 - hearts. So we don't want to
abuse them, we want to use them
51:20 - to learn and then move on. So
try not to send a billion
51:23 - transactions on one of these
test nets. In fact, what we're
51:26 - going to do right now is we're
going to send a transaction on
51:30 - the Rinkeby test net. And this
will show us exactly what it
51:33 - would look like on a main
network. In order for us to
51:36 - simulate one of these
transactions, we're going to go
51:39 - to what's called a faucet. And
if you go to the GitHub
51:42 - repository associated with this
course, right underneath the
51:45 - recommended test net is going to
be a test net faucets, which is
51:49 - going to show us where the most
up to date faucet location is
51:53 - for us getting test net
Aetherium. So here we are at
51:56 - faucets dot chain dot link,
which again is the recommended
51:59 - faucet, and what we can do is we
can actually put our wallet
52:03 - address in and get some test net
link or test net Aetherium. Now
52:08 - what we are gonna have to do is
we are gonna have to connect our
52:11 - wallet to the Rinkeby network.
So we're going to come down,
52:15 - we're going to switch from COVID
to Etherium. Rigby, and then
52:21 - we're going to make sure our
meta mask is on the Rinkeby test
52:25 - network here. Once both of those
are set up, we're gonna go ahead
52:28 - and hit Connect wallet. And
we're going to choose meta mask.
52:33 - Once we do that, our meta mask
is actually going to pop up and
52:36 - say would you like to connect to
this website, connecting to a
52:40 - website is how we give these
websites in interface to
52:43 - interact with our wallets and
interact with our meta masks.
52:46 - Don't worry, we're not sending
any transactions like this,
52:49 - we'll get to that in a bit. So
we just we can pick an account
52:52 - we want to connect. Let's choose
our account one, we'll hit Next.
52:57 - And then we'll go ahead and
connect. Now that we're
53:00 - connected, we can actually see
our account connected up here.
53:04 - And that little warning is now
gone. And our wallet address is
53:07 - automatically placed into here,
we're going to make our first
53:10 - test transaction. And for now,
we don't need test link. So
53:15 - we're going to leave that off.
But later on, we're going to
53:17 - come back and get that test
link. For now we're just going
53:20 - to need 0.1 test Aetherium.
53:24 - So let's go ahead and complete
the security by choosing the
53:27 - traffic lights. And we're going
to hit Send Request. What this
53:31 - is going to do is we're asking
this faucet to send us 0.1 test
53:37 - Aetherium test net faucets are
ways for us to get money into
53:41 - our wallets on a test net. And
this is why this test and
53:44 - Aetherium isn't worth any actual
money. Since we can get it for
53:47 - free. These don't exist on Main
net, you can't get real
53:51 - Aetherium or real money for free
on a main network. So we're on
53:55 - Rinkeby we're getting fake
Rinckey Aetherium. And we're
53:58 - gonna go ahead and hit send
request. Once we hit Send
54:00 - Request, this transaction hash
is going to pop up here, and it
54:04 - says transactions have been
initiated waiting for
54:07 - confirmation. This means that
some other wallet is actually
54:11 - going to send us 0.1 test eath.
And this is the transaction that
54:15 - it's doing to do that now we
just have to wait for our
54:18 - transaction to finish verifying
and finish going through. Now if
54:22 - this doesn't work right away, I
would recommend Wait a minute
54:24 - and then just try it again. But
what we can do is we can click
54:27 - this transaction hash. If that
transaction doesn't show up, we
54:31 - can also just close this. And we
can copy our address here. And
54:35 - actually we already see 0.1 eath
in our wallets here. But we can
54:39 - go back over to Rinkeby ether
scan, paste our address and and
54:44 - we can see that we now have 0.1
ether as a balance. We can also
54:49 - see that we have a transaction
with all this information going
54:53 - into our wallet. That's what
this green is for. If you click
54:56 - that transaction link, you'd get
something like this, but If you
55:00 - didn't, don't worry, because on
the ether scan, if you click the
55:03 - transaction hash in the
transaction list, you can also
55:07 - see all the details like that.
So now in our meta mask, we have
55:10 - 0.1 eath. Again, this is fake
Aetherium. And we have a
55:15 - transaction associated with our
wallet now, which is awesome.
55:18 - Again, though, if we switch
networks, if we switch networks
55:22 - back to Etherium main net, you
can see that we have nothing on
55:25 - a theory main net. Or if we go
to ropsten, we also have
55:29 - nothing, we only have this 0.1
eath. On the Rinkeby test
55:33 - network, if you want to practice
working with another test net,
55:37 - and the faucet that we're using,
has multiple test nets. Let's go
55:40 - ahead and try it during this
section right now is completely
55:43 - optional, you can watch or you
can follow along. But for
55:46 - example, I can see in my wallet
that we already have COVID
55:49 - supported, so maybe I'll switch
to COVID. Maybe we'll switch to
55:53 - COVID. In the drop down here,
we'll remove test 10 Link,
55:57 - because we only need test eath.
We'll hit I'm not a robot, and
56:01 - we'll send request and the same
things will pop up this time,
56:04 - this is going to be for the
COVID test net. And once our
56:08 - transaction finishes going
through. Now, same thing on
56:11 - COVID. Here, like what we did
with rink B, once our
56:14 - transaction finishes going
through, we'll see 0.1 test eath
56:18 - on the COVID network, if you
want to go ahead and try working
56:21 - with another one of the test
nets. Like maybe, for example
56:25 - COVID recommend you go ahead and
giving it a try. But it's
56:28 - completely optional. And I would
always refer back to the GitHub
56:31 - repo to make sure you're working
with the most up to date faucet
56:34 - and test net. And if we look
back at ether scan, we can
56:37 - actually see more details on
what actually just took place.
56:41 - What actually just happened, how
did our Metamask get a balance
56:45 - of 0.1 eath. All of a sudden?
Well, if we looked down in the
56:48 - transaction section, we can see
that there's a transaction here,
56:53 - some address sent us 0.1 ether.
And if we click the transaction
56:58 - hash, we can see more details
about what actually went down
57:02 - with this transaction. Now
understanding what's going on in
57:05 - this transaction is essential to
learning and being a smart
57:09 - contract developer or just
engaging with the ecosystem. So
57:12 - let's learn the first bit at the
top is this transaction hash.
57:16 - This is a unique identifier for
this blockchain or this test net
57:21 - that identifies this exact
transaction. This transaction
57:24 - hash identifies sending 0.1 eath
to our address, we can see that
57:31 - the status of this transaction
was successful, it didn't break.
57:34 - In any case, we can see the
block number that this
57:38 - transaction was included in and
we'll get to blocks in a little
57:41 - bit, we can see the timestamp
which of course is when this
57:45 - transaction occurred, we can see
which account it was from which
57:49 - if we go ahead and open in a new
tab, we can see that this is the
57:54 - account that this transaction
came from. And it's got 3
57:57 - million ether. Of course, this
is fake Rinckey ether. So it
58:01 - doesn't really matter, we can
all see who it was to, which
58:04 - again, is just us. This is our
wallet address 0x 106 X blah,
58:10 - blah, blah, cero x 1066, blah,
blah, blah, right, the value of
58:15 - this transaction, of course, is
0.1 ether. Now what's all this
58:19 - that we see as the value so
obviously, the value is 0.1,
58:22 - because that's a mode which we
sent. But we see this
58:24 - transaction fee. In this gas
price, we hover over the
58:28 - tooltip, we can see if you zoom
in on your ether scan, you see
58:31 - amount paid to the miner for
processing the transaction. And
58:35 - we see a gas price which is cost
per unit of gas specified for
58:40 - the transaction and ether and
gray. The higher the gas price,
58:43 - the higher the chance of getting
included in the block. Now if we
58:46 - scroll down even more, and we
click See more, we can also see
58:50 - a ton of other information here.
For now we're just going to
58:53 - click to see less and just focus
on these two. I'll explain all
58:57 - of these in a later session.
59:01 - Let's talk about just
59:02 - the concept of transaction fees
and gas for a second. Remember
59:06 - how I said the blockchain is run
by all these different nodes
59:09 - will all those different nodes
are running this blockchain
59:12 - because they actually get paid
for all the transactions that
59:15 - happen on these blockchains
whenever you make a transaction,
59:19 - there's a node or a miner or or
a validator somebody running the
59:23 - blockchain software is gonna get
paid a tiny bit of Aetherium or
59:28 - polygon or whatever blockchain
that you're running on, they're
59:30 - gonna get paid a tiny bit of
that native blockchain currency.
59:34 - This payment is obviously to
incentivize people to continue
59:37 - to run nodes and they calculate
how much you pay and how much
59:40 - the node operators get paid
based off of how much gas you
59:43 - use. So there's this concept of
gas. Gas is a unit of
59:48 - computational measure. The more
computation a transaction uses,
59:52 - the more gas you'd have to pay
for. For example, we do hit
59:56 - click More just really quickly.
We can see this section say A
60:00 - gas limit and gas usage by
transaction, there was a limit
60:04 - of 60,000 units of gas on this
transaction, and 21,000 or
60:09 - actually use. So this
transaction use 21 units of gas.
60:15 - Now for very simple things like
sending ether, the units of gas
60:19 - are usually pretty cheap. But
maybe for more complex things
60:22 - like like minting NFT,
depositing to some defy
60:25 - contract, etc, maybe those will
cost more gas because they'll be
60:30 - more computationally expensive.
And this is a little confusing
60:33 - right now, don't worry too much
about it. But just know that we
60:35 - use 21,000 gas here. And if we
pull out the calculator 21,000
60:39 - gas times this gas price right
here, times the gas price, we
60:45 - get the exact same as we see for
the transaction fee. So gas
60:50 - price, times how much gas you
used, is the transaction fee. So
60:55 - whoever sent us this 0.1 ether,
also paid 0.0000525, etc Rinkeby
61:04 - ether to make this transaction.
Now, each blockchain has a
61:07 - different way of actually
calculating how this gas stuff
61:11 - works. So that's basically going
to be the high level of it. So
61:14 - we're going to focus just here
for now there's a total
61:16 - transaction fee. And then
there's obviously the gas price.
61:19 - After we cover how blockchain
works, I'll explain what this
61:22 - burn stuff is these gas fees and
all these other stuff. For now,
61:25 - just know that anytime you make
a transaction on chain, you have
61:28 - to pay a little bit of what I
call transaction gas. So for
61:32 - example, if we go to our
Metamask, we have two accounts
61:35 - right here, we have account one
was 0.1, Rinckey eath, and
61:39 - account two was zero. Rigby. If
I were to send 0.05 Rinckey
61:46 - eath. From this account to my
other account, how much rinky
61:50 - eath Do you think I'd have left?
Well, let's go ahead and try it,
61:54 - this will be the first
transaction that you're actually
61:56 - creating that you are going to
spend the gas for. So if we go
62:00 - ahead and hit send, we'll hit
transfer between my accounts.
62:03 - count two, we'll do 0.05.
62:07 - Next, we can see
62:10 - some information here about
what's actually going on
62:13 - Metamask has some new advanced
gas for UI and settings, we're
62:17 - also going to turn the song, so
go ahead and click that enable
62:20 - enhanced gas UI, turn that on,
and then go back. And again,
62:24 - this is going to be the
experimental tab. But it could
62:27 - also just be in the General
Settings tab. Depending on when
62:29 - you actually run this, we can
see a little notification here.
62:32 - Again, this depends on what
version of Metamask we're using.
62:35 - And we get this little drop down
that says Here are some of the
62:38 - different type of gas fees that
you can actually pay. The reason
62:41 - that gas fees might change, as
you can see here is that
62:45 - depending on how busy the
blockchain is, you have to pay
62:47 - more gas. If a lot of people are
sending transactions, that means
62:52 - there's not going to be enough
space for everyone's transaction
62:55 - to get through. That's a bit of
an oversimplification of what's
62:58 - happening. But don't worry too
much about it for now. Now, if
63:00 - we want to send the 0.05 ether
to our second account, we can
63:04 - see this gas estimated section,
which is saying it's estimating,
63:08 - we're going to pay 0.00004792
gas in addition to sending the
63:15 - 0.5 eath. So at the bottom, we
have amount plus gas fee. And
63:19 - this is going to be the total
amount that we're going to be
63:22 - spending on this transaction
0.05 is what we're sending. And
63:26 - we also have this gas piece. So
we go ahead and confirm, we now
63:30 - see we have a transaction
pending in our Rigby ether scan.
63:34 - And if we click on it, we can
even hit View on block Explorer.
63:39 - And a Rigby transaction hash
will pop up and depending on
63:42 - when you click it, it might say
indexing, this means that ether
63:46 - scan has received your
transaction and is trying to
63:49 - place it. If you don't see
anything here, it means that
63:52 - maybe the transaction hasn't
gone through yet. Maybe you need
63:54 - to wait a little bit more. Or
maybe you need to go back to the
63:57 - GitHub repo and pick the
recommended testament and
64:00 - faucet. So you might have to
wait a minute or so for this to
64:03 - actually finish indexing. After
a minute or so we can see that
64:06 - this transaction has indeed
passed. And we can see a lot of
64:09 - the same information that we saw
on our last one, this time with
64:13 - 0.05 ether. And now if we look
in our meta mask, we'll see we
64:18 - can see account one has 0.05
It's rounding up a little bit,
64:22 - we click on the big button, we
can see it actually has
64:24 - 0.049953, etc. And our other
account account two does have
64:30 - exactly 0.05. This is because we
spent a little bit of Aetherium
64:35 - on gas to send this transaction.
And now with just this little
64:39 - bit of information, you know how
to actually interact with
64:42 - applications that use the
blockchain, how to send
64:45 - transactions and a lot of the
non technical details. Now
64:48 - here's something that's
incredibly exciting with just
64:50 - this little bit of information.
You now know how to interact
64:53 - with blockchains and interact
with the Etherion protocol. So
64:56 - if you don't want to learn how
to code anything, you can go If
65:00 - you can start interacting with
Aetherium and interact with
65:02 - protocols with just as much
information. However, I know
65:06 - most of you guys are here to
learn how to code. So let's look
65:08 - under the hood of Aetherium. And
what is actually going on with
65:11 - these transactions, and what
these gas and what these
65:13 - blockchains. And what's really
going on, let's learn all the
65:17 - fundamentals of a blockchain.
Now, if you want to just go
65:19 - ahead and jump into the coding,
go ahead and grab a timestamp
65:22 - from the description. However,
learning exactly how the
65:26 - blockchain works is going to
make you an incredibly powerful
65:28 - developer.
65:29 - So let's take a look at that
first. So we're going to
65:33 - be going through this blockchain
demo on this site right here.
65:36 - Now, the creator of the site has
a fantastic video and a
65:39 - fantastic walk through
blockchain one on one, it is
65:41 - right on their site. So if
you're looking for another
65:44 - explanation, definitely check
out his video, it is absolutely
65:47 - fantastic. But the first thing
that we really need to do in
65:49 - order to understand blockchain
or just on really anything, and
65:52 - everything that's going on here
working first really need to
65:54 - understand this Sha 256, hash,
or hashing just kind of in
65:58 - general, let's first understand
what a hash is. A hash is a
66:01 - unique fixed length string,
meant to identify any piece of
66:06 - data, they are created by
putting some piece of data into
66:09 - a hash function. In this
example, the hashing algorithm
66:13 - used is Sha 256. Now Etherium
actually uses this, this right
66:18 - here for its hashing algorithm,
which isn't quite Sha 256, but
66:22 - as in kind of this SHA family.
But it's really just another way
66:26 - to hash things. And the specific
hash algorithm doesn't matter so
66:30 - much. So this example, you just
shot up to six, but you can
66:34 - imagine it's the same as the
Etherium. Hash, they're just
66:36 - going to result in a different
hash. So what's going to happen
66:40 - in this application here is
whatever data or whatever
66:44 - information we put into this
data section here, as you can
66:48 - see below this hash changes. So
what's happening is this data is
66:54 - running through the Sha 256 hash
algorithm. And it's outputting,
66:59 - this unique hash. So this hash
is a unique fixed length string,
67:04 - that's going to identify like a
blank data piece here, right. So
67:07 - if I put in, you know, my name
like Patrick Collins, this is
67:11 - the hash that's going to
represent Patrick Collins,
67:14 - right. And you can see, even
when I put, you know, tons and
67:18 - tons of data in here, the length
of the string doesn't change,
67:24 - right. So it's always gonna be
the same, we can put almost any
67:29 - amount of data in here, there is
an upper limit on the max size
67:32 - of the data. But for all intents
purposes, we can pretty much put
67:36 - any length in here. And you'll
see to that every time I type in
67:39 - Patrick Collins, this hash is
always gonna be this seven e
67:43 - five D, right? I'm gonna delete
I'm gonna do Patrick Collins,
67:46 - again, you're 75 B is always
this, this unique hash is always
67:50 - going to be unique, right, it's
always gonna be this fixed
67:53 - length string here. So now we
can take this idea while putting
67:57 - this data in here, we can move
on to this concept of a block.
68:01 - So with this block concept,
we're going to take the exact
68:04 - same thing with this hash this
this data section, right, but
68:06 - instead of having everything
just being in this, this
68:09 - singular data area right here,
we're going to split this data
68:12 - up into block, nuns, and data.
So all so what we're going to do
68:16 - is we're actually going to hash
all three of these to get to get
68:20 - this hash, right, we're gonna
put all three of these, we're
68:21 - gonna say all three of these are
combined. Together, we're gonna
68:24 - put every all three of them into
this hashing algorithm to figure
68:28 - it out. So if I type a bunch of
stuff here, we can see that
68:31 - block one with nonce, you know,
this nonce, and this data, we're
68:36 - going to get this hash. And as
you can see, actually, the
68:39 - screen turns red, this block
turned red. Now, what happens
68:44 - when I hit this mind button?
When I hit this mind button,
68:47 - it's actually gonna take some
time, it's gonna think for a
68:49 - little bit. And we can see that
the nonce here actually changed,
68:53 - right? The nonce is different
from what it was before. And
68:57 - this hash now starts with four
zeros. Okay, and then the back
69:02 - turn green. When we're talking
about mining, we're talking
69:04 - about miners solving some type
of very difficult problem that
69:08 - takes a lot of time to do now in
this example, here, the problem
69:12 - that the miners had to solve was
they had to find a nonce, or or
69:17 - a value in this nonce section
that when hashed with at block
69:20 - number one with this data, it
would start with four zeros. So
69:25 - the problem here the miners had
to solve was to start with four
69:28 - zeros and the only way for them
to really do that is kind of
69:31 - this brute force, you know,
trying stuff so they tried one
69:33 - okay, one didn't work. Okay,
two, nope, two didn't work. 3456
69:38 - Okay, five, well, that started
with one zero, but it's not
69:40 - four. And they have to keep
trying all these numbers until
69:43 - they get to this one where you
know, let's hit mine again.
69:50 - Where it has four zeros at the
top at the start. Now, this
69:54 - specific problem changes
blockchain to blockchain right
69:56 - yet. Aetherium has a different
problem for miners to solve A
70:00 - bitcoin is different problems
from yourself, but this concept
70:02 - is going to be the same. So they
have to take it, one block is
70:07 - going to be this, this, this
concept is going to be all this
70:10 - data, it's going to be the block
number. And it's going to be
70:13 - this nonce, right. And so this
nonce is the solution is going
70:18 - to be the the number that they
use to get like the solution to
70:20 - the problem, right? So if I go
to one here, you know, I do this
70:24 - again,
70:27 - hit mine. And the nonces
changed, right? And went from
70:30 - one to 33,128. Because this is
the nonce that allowed this hash
70:35 - to start with four zeros. And so
that's what's happening. When
70:40 - blockchain miners are mining
they're going through this
70:42 - process is very computationally
intensive process of trying to
70:46 - find a nonce that fulfills
whatever the problem is. So
70:50 - that's really it, actually. So
that's a block. And that's
70:52 - really what's happening when
miners are mining. They're just
70:54 - looking, there's trial and
error, brute force trying to
70:57 - find this nut so so now that we
know what a block is, let's go
71:00 - to the next step and figure out
okay, well, what's a block
71:03 - chain. So here we have an
example of what a blockchain is
71:08 - going to look like. Right, we
have a combination, you know, we
71:11 - have back here in the block
section, we have one what one
71:13 - block looks like. Now here, we
have multiple different blocks,
71:17 - right, each one of these
represents a different block,
71:20 - but we have an additional column
here, we have additional
71:23 - variable here. So like before,
you know, we have block nonce
71:26 - and data, right, we have blocked
nonce data, we also have this
71:30 - thing called previous right, and
so this is actually gonna be
71:33 - pointing to the previous hash of
the last block. So for example,
71:38 - if we go to the last block in
this blockchain, it says
71:41 - previous 008. And if we look at
the hash of block number four,
71:45 - is 00008. And then we look at
its previous it's four zeros, B
71:50 - nine, we have four zeros, B,
nine, and so on, all the way
71:54 - back to our first block, which
has previous of just all zeros,
71:58 - right. And so the block with the
previous of all zeros, is going
72:02 - to be known as the Genesis
block. So you've probably heard
72:04 - that before the Genesis block,
it's the first block in the
72:07 - blockchain were the previous
hash points to a hash that
72:10 - doesn't actually exist. Now, as
you can imagine, kind of the
72:13 - same as how this block worked,
how the block nuts and dated all
72:17 - go through the hashing algorithm
in the blockchain, the block
72:20 - nonce data, and previous hash
all go through this hashing
72:24 - algorithm to figure out what the
hashes okay? So if we go to over
72:28 - here, you know, for example, if
I type in Patrick, obviously,
72:31 - this is now no longer valid,
right? Because this nuns
72:35 - combined with the block the data
in the previous hash, aren't
72:37 - going to solve our problem of
having four zeros at the at the
72:41 - start, right. So I'm gonna go
and fix that. And that's, that's
72:44 - kind of an easy way to see it
being broken. But, but let's
72:47 - take a look, if I break this
block, right here, what happens
72:51 - if I, if I break the data in
here, if I do like Patrick in
72:54 - here, you can see that both of
these are now read, both of
72:59 - these are now invalid, right?
Because the block hash with the
73:03 - nonce hash with the new data,
which is my name, Patrick has
73:07 - hashed with the previous block
is now a brand new hash, right,
73:11 - and this block is still pointing
to this previous hash right
73:15 - here, right is pointing to this
previous block. And now it is
73:19 - wrong, and it is messed up and
now, and now it's nuts with this
73:24 - previous hash is also wrong.
Right? And this is where when we
73:28 - talk about blockchains, being
immutable, this is exactly how
73:32 - it's immutable, right? Because I
go back and I change anything,
73:35 - you know, if I've just typed a
right here, the entire
73:39 - blockchain is now invalidated.
Because none of these are going
73:42 - to have nonces that solve this
equation anymore. So this is why
73:47 - blockchains are immutable is
because anytime you change one
73:50 - thing, you ruin the rest of the
blockchain, okay? So however,
73:54 - though, you know, if it was
here, originally, we can go
73:57 - ahead and mine these, mine all
these but as you can see, you
74:00 - know, this is going to start
getting very computationally
74:03 - expensive, because I have to go
redo basically the entire
74:07 - blockchain. And the farther and
farther down the line you get,
74:10 - the harder and harder it becomes
to, you know, rehash and redo
74:13 - all these different block chains
here. Now, this makes a lot of
74:16 - sense, right? So we have this
blockchain, it's really hard to
74:17 - change something in the past,
but if we do, we can just go
74:19 - ahead and remind it. Now if I'm
the one who controls the
74:22 - blockchain, right, if I'm the
one who controls this, you know,
74:25 - and I want to change something,
the past will, okay, great. All
74:27 - I got to do is change the state
of here. And then you know,
74:30 - mine, each one of these, you
know, obviously, it's going to
74:32 - be very computationally
expensive, but it's something
74:34 - that I can do right if I'm the
one who owns the blockchain.
74:39 - Now, here's where the
decentralized nature or the
74:42 - distributed nature really makes
it incredibly powerful. So we're
74:47 - gonna go to the distributed tab
here, which is also referred to
74:50 - as the decentralized tab here,
and it's going to show us what a
74:53 - blockchain looks like in a
decentralized manner. So we have
74:57 - this exact same initial setup
here we have to Shoot a
75:00 - blockchain, we have our first
blockchain, which is kind of
75:02 - exactly as the one from here.
But we also have more than once
75:06 - we have peer, a peer beam, and
PRC and when people are talking
75:10 - about Peer to Peer, peer to peer
transactions through the
75:12 - talking, this is kind of that
concept that they're talking
75:15 - about, right. So we have a
number of different peers who
75:18 - are running this blockchain
technology, they're all weighted
75:20 - equally, right, each one of
these peers or each one of these
75:23 - nodes, each one of these
entities running a blockchain
75:27 - has the exact same power as
anybody else, right. So the way
75:32 - that we can tell very easily
which blockchain is correct, or
75:36 - which ones are correct, or by
looking at this end, hash here,
75:40 - right, or by looking at where we
are in the blockchain, because
75:44 - again, remember, because again,
remember this, this hash that
75:47 - this this in this last block
here, is going to encompass all
75:52 - of the blocks from before,
right, because this last hash is
75:55 - going to have the previous hash
here, which includes the
75:58 - previous hash here, which this
hash includes the previous hash
76:01 - here. And so this last hash is
encompasses everything in here,
76:05 - right? And we can look, we can
look at the hash of Piercey,
76:08 - which is four zeros, and then E
four B, we can look at the
76:11 - latest hash appear B, which is
four zeros, E for B, and then
76:15 - pure A, which is four zeros, E
for b. So all of these peers,
76:19 - all of these nodes, all of these
decentralized, you know these
76:23 - independent, all these
independent users running this
76:27 - blockchain software, they're all
matched up, it's very easy for
76:30 - their nodes to look at each
other and say, hey, great, we
76:32 - are all matched up. Now, what
let's say that a decides that,
76:37 - you know, something happened on
the blockchain that they didn't
76:40 - like, and they wanted to go back
and change something, right. So
76:43 - let's say they change here, you
know, obviously, the rest of
76:46 - their blockchain is invalidated.
And they have to spend a lot of
76:49 - computational power to catch up
to speed. So let's go ahead and
76:52 - humor it. Let's say that they
did, they ended up catching up.
76:55 - They ended up catching up, you
know, they ended up mining
76:57 - everything. And now they have a
valid blockchain. Right? It
77:01 - solves the equation. Awesome.
However, in block number three,
77:06 - there's something new, right?
This is here, and it shouldn't
77:10 - have been here, this is some
that Peer A put in by
77:12 - themselves. All that happens now
is we look at all the
77:17 - blockchains that are running the
software, and we're looking at
77:21 - all the hashes and hash at block
number five. So pure A has this
77:25 - new hash. Now, there's a 09 BC.
But pure B has a different hash
77:31 - 00, e for B, right? So who's
right? Is it disappear a with
77:35 - their new stuff? Or is it pure
B? Well, that's where the
77:39 - decentralized data comes in.
Because then we can look at
77:40 - Piercey Piercey, also as E
forby. So if you're being
77:45 - Piercey will say, Hey, you're a,
you're wrong, get out, right.
77:50 - And pure A will stop being able
to participate in the mining
77:52 - rewards because they have
essentially forked the
77:56 - blockchain and started their own
little blockchain right with
77:59 - their own history, because
they're the only ones with this,
78:02 - this piece of data in block
three, whereas pure B, and pure
78:07 - C have nothing in there. So that
really shows why in these
78:10 - blockchain worlds in this
decentralized world, there
78:12 - really is no centralized entity,
you know, pure A, you know,
78:15 - might have been maliciously
motivated to change. You know,
78:18 - there's this block number three,
however, democracy rules, right,
78:21 - the majority rules in the
blockchain, pure vmpfc will say,
78:24 - hey, you know, the, that's cute
and all puree. But you're wrong,
78:28 - right? That's not right. Now, it
might be a little abstract, that
78:31 - you just look at data and you
know, as typing kind of random
78:33 - stuff in here and think, okay,
yeah, that's, that's data,
78:36 - right? That makes sense, you
know, just kind of random
78:38 - strings in here doesn't really
do anything for us. So if we
78:41 - actually go over to the token
section here, this is where
78:44 - everything really starts to make
a lot of sense. So we have the
78:47 - exact same setup here with pure
a pure B Piercey. Except and the
78:52 - difference is, instead of having
kind of this, this data section,
78:55 - we have this TX This transaction
section, right? And this
78:59 - represents all the transactions
that are happening in this
79:03 - block, right? So we're sending
$25, from Darcy to Bingle, or to
79:08 - Bingley force toward dollars and
27 cents here. 1922, right. And
79:13 - it's the exact same thing. So
this, all these transactions are
79:17 - gonna get hashed in the exact
same way that the data is going
79:20 - to get hashed. And, and this is
why it's so powerful, because
79:23 - again, you know, if I want to be
malicious, right, if, if I want
79:26 - to say, hey, I really wanted to
give Jane a lot more money from
79:30 - Elizabeth, so I'm puree and I go
back and I change it to 100.
79:33 - Well, now, you know not only do
I does my whole blockchain get
79:37 - invalidated because that was so
so long ago, but I'm not going
79:41 - to match any of these other
chains. Right? And so my
79:43 - blockchain is going to be
excluded from the overall
79:46 - blockchain. So and let's let's
go ahead and fix this. And it's
79:50 - the same thing if down here if I
become malicious, and I want to
79:53 - send you know, I want
79:56 - Miss Audrey to have less money.
Maybe I want to send $1 And they
79:59 - go had in mind it the same thing
here, this hash now this two a
80:04 - one is not going to match the
rubies rubies hash of BBA. And
80:11 - it's not going to match Pierce's
hash of BBA as well. So the two
80:14 - of them are gonna say, hey,
this, your blockchain is
80:17 - invalid, it's not matching the
majority, you know, you're out,
80:20 - right. So that's really how
these blockchains work at a low
80:25 - level. And it all goes back to
this, this understanding this
80:28 - hash idea, and using it in this
very sophisticated manner, to
80:32 - kind of cryptographically prove,
you know, where, where stuff
80:36 - lies. Now, the way the
blockchain works is, instead of
80:39 - random stuff, put in the Status
section, it's actually going to
80:41 - be solidity code in here to
finding ways to interact with
80:44 - different blocks and different
protocols that are on chain, or,
80:48 - as we've said before, different
smart contracts. Now, the next
80:52 - question that you might be
asking is, okay, well, how do I
80:56 - know how can I be sure that I'm
the one? You know, let's say
81:00 - this is, let's say, I'm Darcy
right? How can I be sure that I
81:03 - was that Darcy was the one to
actually send us money here. How
81:06 - do we know that Darcy sent $25.
To Bingley? Well, this is where
81:11 - we get into private keys and
public keys. And that's what
81:15 - we're going to go into. Now.
Let's just do a quick recap of
81:18 - what we've learned in this
section. So far, right? We've
81:20 - learned that Aetherium actually
runs on this hit check 256. But
81:25 - we use Sha 256. For this demo,
it doesn't really matter. We're
81:28 - just talking about hashing
algorithms. So again, hash is a
81:33 - unique fixed length string meant
to identify any piece of data. A
81:39 - hash algorithm or a hash
function is a function or
81:42 - algorithm that computes any type
of data into a unique hash.
81:47 - Mining is going to be the
process of finding the solution
81:50 - to the blockchain problem. In
our example, the problem was
81:53 - finding a hash that starts with
four zeros. nodes get paid for
81:57 - mining different blocks. And the
problem is going to be different
82:00 - blockchain to blockchain a block
and a blockchain is basically a
82:03 - combination of a block, nonce
transaction and previous hash to
82:07 - create this unique hash for this
block. And again, depending on
82:11 - the blockchain implementation,
this might have a couple other
82:13 - fields or might have different
fields. But this is essentially
82:16 - what's going on blockchains are
decentralized and distributed
82:19 - because many independent users
are going to run this blockchain
82:22 - software. And they will check
and then we'll compare against
82:25 - each other to see which
blockchains are acting honestly,
82:27 - and which ones are acting
maliciously, in the blockchain
82:30 - world majority rules. The nonce
here is the answer used or the
82:35 - number used to get this hash.
Now nonce is kind of an
82:39 - overloaded term, it's actually
used for a number of different
82:41 - reasons. In this case, we're
using it to solve this problem
82:44 - of getting four or five zeros at
the stop or the hash. However,
82:48 - in Aetherium, it will also be
often used as the number of
82:51 - transactions from a given
address.
82:56 - So now we're going to talk a
little bit about signing these
82:58 - transactions and private keys
and some other cryptography
83:01 - pieces, right? Because in this
blockchain demo here, we can see
83:04 - we have all these these
fantastic transactions, right?
83:06 - All these things went through,
but how do we know that it was
83:09 - Darcy? Who was the one to send
$25? To bangli? Right? How do we
83:14 - know that actually happened. And
this is where all those pieces
83:18 - that we just learned about in
our test net, in our meta mask
83:22 - account are really going to
start to, to come to life here a
83:25 - little bit here. So here we have
an example of public and private
83:29 - keys, okay, at the top, we have
this private key, right that was
83:33 - that was randomly generated. A
private key is you know, as it
83:37 - kind of states is a key that you
really want to keep secret,
83:39 - because you're going to be using
this as kind of your your secret
83:43 - password for all your
transactions where I can really
83:45 - pick, you know, any, any, any
private key, anything that I
83:49 - want. And with it, this
algorithm, or they're going to
83:54 - use an algorithm for Aetherium.
Bitcoin, they both use this
83:56 - elliptic curve, digital
signature algorithm, it's a
84:00 - variant of just a digital
signature algorithm. And it's
84:03 - going to create this this public
key, right, I'm really not going
84:05 - to go at all into kind of this
digital signature algorithm. But
84:09 - just know it does use some of
these, some of the hash
84:13 - knowledge that we just learned
combined with some other pieces
84:16 - to kind of get this this public
here. So I'm not gonna go too
84:18 - deep into it. But we have this
private key that we create. And
84:22 - we get this public key. Now this
public key we want everybody to
84:26 - have access to right this is
yeah, whole world can see this,
84:28 - this private key, we really want
it to be private, we don't want
84:32 - people to see this, we're going
to use this private key as like
84:35 - a password to quote unquote,
digitally sign transactions, and
84:40 - then people can verify them with
this public key. So let's, let's
84:44 - see what this actually looks
like. Let's pick a random key, a
84:46 - more secure key, right? Because
the longer it is, the more
84:49 - secure it's going to be. And if
we go to signatures now, right?
84:54 - Let's say we have this, this
message that we want, right?
84:57 - We'll say hi world, right? We
want this To be the message,
85:00 - what's gonna happen is this
private key that we've created,
85:04 - we can use to sign this data,
right? Remember how in the
85:07 - blockchain demo, you know, we
were kind of we were hashing
85:10 - stuff, right? We were using this
Shea 256 hash to get this hash.
85:14 - Well, we're doing something
similar. But instead of hashing,
85:17 - we're, we're using this digital
signature algorithm to create
85:20 - this message signature. Now,
what's really powerful about how
85:24 - this this algorithm works, is
that you can create this message
85:28 - signature with your private key,
but somebody else can't derive
85:33 - your private key from the
message signature. And that's
85:36 - what makes this really, really
powerful. However, if we go to
85:39 - verify using this public key,
right, and so this is the this
85:43 - is that, Oh, 403. This is that
same public key, using this,
85:47 - using this public key, anybody
can verify, let's go ahead and
85:51 - sign again, anybody can verify
that the signature is yours,
85:57 - right? So you have a public a
private key, just for you. So
86:01 - you can sign things and a public
key that anybody can verify
86:04 - something, right. So anybody can
verify this, and let's say
86:07 - somebody tries to fake a
transaction from you, they say,
86:10 - Hey, you know, this is this is
this is their transaction, all
86:15 - they have to do is verify that
this signature against your
86:19 - public key and very easily, this
whole thing turns red, because
86:24 - it isn't verified, right, that
the algorithm says, hey, that's
86:27 - wrong. So we can go ahead and
take that into transactions in
86:31 - this exact same way. So if I
want to send money, you know, if
86:35 - I want to send $400, from, you
know, my address to another
86:40 - address, using my private key, I
can sign that transaction. And
86:45 - anybody else in the world can
then verify this transaction,
86:49 - right. And this is why when
people say Hydra keys, you know,
86:52 - protect your keys, this is what
we're talking about in our
86:55 - accounts here. Right? If we go
to settings, and again, the only
87:00 - reason that I'm showing you
guys, my pneumonic, and my
87:03 - private key is because this is
a, this is a dumpster account,
87:06 - I'm going to throw this away at
the end of this video, or I'm
87:08 - just not gonna put any real
money in it. But when we look at
87:15 - our Metamask, here, we have this
pneumonic phrase, which allows
87:19 - us to easily get these different
private keys, right? So
87:24 - pneumonic phrase combined with,
you know, whatever account
87:28 - number will get us a private
key. So mnemonic phrase combined
87:31 - with one, we're gonna get this
private key. And this is when we
87:34 - look at account details, export
private key.
87:40 - That's where it confirm, this is
going to be the private key that
87:44 - we're going to use to sign our
transactions, right, this, if
87:47 - anybody else gets access to this
private key, they then can sign
87:50 - transactions for us, and they
can send transactions for us.
87:54 - And that's why we want to keep
these private, so that it works
87:57 - the exact same way, right. And
so this is why it's so important
88:00 - to hide your private keys and
hide your mnemonics now, your
88:03 - Aetherium address is actually a
piece is actually a piece of
88:11 - your public key. Now, to get our
address in Aetherium, all we
88:15 - have to do is take this public
key that we've created with our
88:17 - private key, hash it using that
same Aetherium hashing
88:21 - algorithm, and then take the
last 20 bytes. And that's how
88:23 - we'll actually derive to our to
our address here. Now, knowing
88:28 - the exact methodology of how to
get the address doesn't really
88:31 - matter, because it could change
blockchain to blockchain and
88:34 - could even change it too. But
just know that that is
88:36 - essentially how kind of these
addresses are derived or there's
88:39 - some derivative of the public
key, right, because the public
88:43 - key is public. And you know,
using the public key and kind of
88:46 - any public way is totally fine,
but not the private key. So that
88:50 - is how we sign our transactions.
Note though, this isn't how we
88:53 - send the transaction. So so this
is just going to assign it
88:56 - create a transaction for us to
send, we'll learn later on how
89:00 - to send these transactions.
Cool. So that was a lot of
89:02 - information there too. Let's do
a quick recap, your public key
89:06 - is derived by using a digital
signature algorithm on your
89:10 - private key, right, and you want
to keep your private key private
89:13 - at all times, because you're
going to use your private key to
89:16 - sign transactions. Signing
transactions with your private
89:20 - key, you are the only one who
can actually do this because you
89:23 - can't get the private key from a
message signature. However,
89:27 - using your public key, you can
anybody can very easily verify
89:32 - that a signature that signed by
you is in fact signed by you in
89:35 - our meta mask. Our private keys
are located in this account
89:39 - details section you just hit
show private keys and type in
89:43 - your password. And you'll get
your your private key here. A
89:46 - quick note here is oftentimes
when using your private keys
89:49 - somewhere, they want it in
hexadecimal form. So if we're
89:52 - going to use our private key for
something like brownie, which
89:56 - we'll go into later, we need to
actually append a 0x to the
89:59 - front but We'll get into that
later. And the address of your
90:03 - account is derived from this. So
if you think about your private
90:07 - key creates your public key,
which then can create your
90:11 - address. And there's a little
barrier or a big barrier here.
90:16 - Because your private key, you
want to keep private and your
90:18 - public key and your address can
all be public information.
90:27 - Now that we know a little
90:28 - bit more about what's going on
underneath the hood of these
90:31 - blockchains, let's go back at
our transactions and look at
90:34 - this gas thing again, and we'll
look to see what's actually
90:36 - happening here, gas in
particular can be a little bit
90:39 - tricky to wrap your head around.
So if you don't get it right
90:42 - away, don't worry. As we go
through examples, it'll start to
90:45 - make more sense. So before I was
saying, let's just look at this
90:48 - transaction fee bid, which is
the costs associated with
90:51 - running this transaction. If I
scroll over this on ether scan,
90:54 - I can see this thing that says
block base fee per gas plus max
90:57 - party fee per gas times the gas
use, which might be a little bit
91:01 - confusing here, let's actually
break down what's going on on
91:04 - Aetherium with ERP 15, five nine
in place. And again, this is
91:08 - going to be specific to
Aetherium, as every blockchain
91:10 - might do it a little bit
differently. But if we click to
91:12 - see more, we can see a number of
useful values here, we can see
91:15 - gas limit is 21,000. And usage
is 21,000. So this transaction
91:21 - used 21,000 gas, and we sent
21,000 gas along with it.
91:26 - Sometimes when sending a
transaction, depending on when
91:29 - it's sent. And depending on what
the specific instructions are,
91:32 - it might actually use way more
gas than what you want it to
91:35 - use. So with your transactions,
you can actually set a limit,
91:38 - hey, I don't want to use more
than x amount of gas, I don't
91:41 - want to do more than x
computational units. And in
91:45 - fact, we go to our Metamask. And
we click Send to transfer
91:49 - between accounts again, and we
pick you know, 0.01 eath, or
91:53 - something next can actually hit
this little button here, go to
91:57 - Advanced, and we can actually
edit some specifics of this
92:00 - transaction, one of them is
going to be the gas limit, we
92:03 - can change this gas limit to
maybe 2200 2300, or more or even
92:09 - less, since sending Aetherium
takes exactly 21,000 Gas
92:13 - Metamask just defaults to
setting into that. Well, we also
92:16 - see these other interesting
things, we see a priority fee,
92:19 - and a max base fee. Let's reject
this transaction. And let's look
92:24 - back at ether scan to talk about
these. So currently in
92:27 - Aetherium, according to EE IP
1559, every transaction on
92:32 - Aetherium comes with something
called the base fee. This is the
92:36 - minimum gas price you need to
set to include your transaction.
92:40 - And you'll notice that these are
priced in something called
92:43 - gateway. So what is a gateway?
If we come to the site eath
92:47 - converter.com. And again,
there's a link to this in the
92:50 - GitHub repository, we scroll
down we can see way gateway and
92:55 - ether five put one ether in
here, I can see how much one
93:00 - ether is in terms of way. And in
terms of way, one ether is equal
93:04 - to 1-234-567-8990. So that's
that's 1 billion way is going to
93:12 - be one ether. And then
1-234-567-8910 1112 1314 Did 16
93:18 - Seven, eight team and then 18
zeros is away. These are just
93:23 - easier ways of referring to
really, really small amounts of
93:27 - Aetherium. So if we look at our
gas fees, we see that the base
93:31 - fee is 0.00000004 Go away. And
this obviously would be an even
93:38 - smaller number if this was in
units of weigh. So if we take
93:42 - this number, and we put it into
our calculator, we can see that
93:46 - this is equal to 40 weigh or
0.0000 a whole bunch of zeros
93:51 - for ether. The max fee here
refers to the maximum gas fee
93:55 - that we're willing to pay for
this transaction. And you can
93:59 - actually see that our max fee is
a little bit higher than what we
94:04 - actually ended up paying. Our
maximum was 2.2132 something
94:08 - something and the gas price we
actually paid was up here. Now
94:12 - your transaction might of course
be a little bit different than
94:15 - Additionally we have a max
priority fee. This is going to
94:18 - be the max gas fee that we're
willing to pay plus the max tip
94:21 - that we're willing to give to
miners. Now currently in
94:24 - Aetherium, this base fee ends up
getting burnt and we can see on
94:28 - ether scan exactly how much is
getting burnt here. And if we
94:31 - pull up our calculator again, we
can grab this gas fee, multiply
94:36 - it by the amount of gas we used,
and we can see that this is
94:40 - indeed how much Aetherium we
actually ended up burning. We go
94:44 - back to Ethereum converter,
paste it in we can see that
94:47 - these two numbers are indeed
equal. This means whenever you
94:51 - send a transaction, a little bit
of Aetherium is removed from
94:55 - circulation forever, or it's
considered burnt. So currently,
94:59 - in theory As part of your
Aetherium part of your
95:01 - transaction fee actually gets
burnt. And then the other part
95:05 - goes directly to miners. So to
figure out exactly how much went
95:08 - to miners, we could do this
number minus the burnt amount.
95:14 - And this is how much Etherium
was paid to Aetherium miner for
95:18 - this transaction, you'll see
down here your transaction type
95:21 - to ERP 15, five, nine, this is
the eip 15 five nine version of
95:26 - these transactions. Like I said,
every blockchain is going to
95:28 - have a different fee burning and
fee and gas process. And they're
95:33 - all going to be a little bit
different, but the some of it is
95:35 - blockchains have limited block
space for transactions, the gas
95:39 - price that costs for your
transaction to be included in
95:42 - one of these blocks changes
based off how much demand there
95:45 - is the base gas fee for
Aetherium will go up and down
95:49 - depending on how many people are
sending transactions and how
95:53 - many people want to be included
in a block. If a ton of people
95:57 - want to be included in a block.
That means a ton of gas is
96:01 - obviously going to get burnt.
We've left a link to a video in
96:04 - the GitHub repository with this
section from this YouTuber who
96:08 - does an amazing job breaking
down this EIP 15, five, nine and
96:12 - more about how this gas model
actually works. I highly
96:16 - recommend you pause this video
and watch that video. To
96:18 - understand more, the base fee
gets programmatically
96:21 - algorithmically adjusted to try
to target for all the blocks to
96:26 - be 50% full. If they're more
than 50% full, this base fee
96:30 - automatically goes up. If
they're less than 50% full, this
96:34 - base fee goes down. Now this is
a lot of the basics of how this
96:38 - transaction works. And it can be
a little confusing. So let's do
96:40 - a quick refresher of everything
in here. There's a unique
96:43 - transaction hash that uniquely
identifies this transaction. On
96:48 - this blockchain, we can see the
status, we can see the block
96:52 - number that it's confirmed on.
One other thing we want to look
96:56 - at. If we scroll up, we see
block number and block
96:58 - confirmations. This is how many
blocks have been mined. Since
97:03 - this block was included. Like we
saw with our blockchain demo,
97:07 - the longer the blockchain gets,
the harder it is to tamper with
97:10 - and the more secure it is
typically, you'll see some
97:12 - processes say they'll only do
something after 20 Block
97:16 - confirmations, 30 Block
confirmations or etc. The reason
97:20 - that they wait for these block
confirmations is because they
97:22 - want to make sure that that
transaction is actually
97:25 - included. And we can actually
see the block that our
97:28 - transaction was included in and
all the other transactions with
97:32 - it, different details about how
much gas was used, the gas
97:35 - limit, etc. timestamp is when
the transaction happened, we can
97:39 - see from and to we can see the
value. And then we can see the
97:44 - transaction fee, which we see
right here is blocked base fee
97:47 - per gas plus the max priority
fee per gas times the gas used.
97:51 - And we see all the details of
the gas down here gas price is
97:54 - the cost of one unit of gas gas
limit is the max amount of units
98:00 - of gas that we're willing to pay
in this transaction, the usage
98:03 - is how many actually got us the
base fee is going to be the base
98:07 - network fee per gas. So 40 way
per one gas used, the max gas is
98:13 - the max gas price we're willing
to pay. And Max priority is
98:18 - gonna be the max gas price, plus
the tip that we give to miners,
98:21 - and then we can see how much is
burnt. And then we see
98:23 - transaction savings which which
is the difference between how
98:27 - much was actually used or paid
for and then returned. So for
98:31 - example, in this transaction,
the gas price we ended up
98:34 - picking was a little less than
our max gas price here. So the
98:38 - gas price we ended up using was
a little less than our max
98:41 - priority fee here. So we had
some savings compared to that,
98:45 - we can also see that this was an
ERP 15 five nine transaction, we
98:49 - can see our nonce here, which
was not zero because the
98:53 - transaction that I'm showing is
our first nones. And then of
98:56 - course, we can see the input
data for transactions that are
98:59 - just sending Aetherium, the
input data is going to be blank.
99:02 - But you'll see that when we get
to smart contracts, the input
99:05 - data is not going to be blank.
And it's going to be one of the
99:07 - most important features of these
transactions. You'll also notice
99:11 - that there's a state tab. This
is an advanced tab, and it shows
99:15 - the different states that are
changed based off of this
99:18 - transaction. We're going to
ignore this one for now. Now
99:21 - that we know how the blockchain
itself works under the hood,
99:24 - let's talk about some blockchain
fundamentals. And we actually
99:28 - covered all these topics in a
previous Freako camp video. So
99:31 - let's go to that.
99:34 - If the first time
99:35 - you listen to this, some of
these concepts seem a little bit
99:38 - hard to grasp. Don't worry about
it. As we continue and as we
99:42 - move on with this course,
they'll start to make more sense
99:45 - when you see them used in real
examples. I definitely would
99:48 - recommend going back and
rewatching and re listening to
99:51 - the parts that you don't quite
get an asking questions in the
99:55 - discussions tab of the GitHub
repository. Awesome. So now that
99:58 - we know all the cryptography
pieces and all the little nitty
100:01 - gritties of how the blockchain
actually works, and how our
100:04 - signatures work and how
everything sticks together.
100:06 - Let's talk a little bit about
how this works, in actuality,
100:10 - and what's really going on. Now
for a lot of this, each
100:12 - different blockchain has
slightly different algorithms
100:15 - and slightly different metrics
and criteria for doing a lot of
100:18 - this stuff. So when we're
talking about these specific
100:21 - implementations, keep in mind,
the exact algorithm might be a
100:25 - little bit different, but the
concepts are all still going to
100:27 - be exactly the same. Hashing and
hash function is going to be the
100:30 - same. No matter where you look
at decentralized blockchain,
100:34 - it's going to be the same no
matter where you look, how it's
100:36 - actually implemented, is going
to be a little bit different.
100:39 - Now traditionally, when you run
an application, you will be
100:42 - website or something that
connects to some server, you are
100:45 - interacting with a centralized
entity. And unlike how we saw
100:49 - with the blockchain with
multiple different peers, it's
100:52 - going to be run by a single
centralized group. Now, it still
100:56 - could be run on many different
servers, but all those servers
100:59 - are still going to be controlled
by the same centralized group
101:02 - blockchains, as we saw run on a
network of different independent
101:07 - nodes. When we saw a peer, a
peer, B Piercey. Those were
101:10 - different examples of different
independent users running the
101:14 - blockchain technology on their
own node. Now, when I use the
101:17 - term node, I'm usually referring
to a single instance of a
101:20 - decentralized system. So when I
say a single node, when I'm
101:23 - talking about a blockchain, I'm
talking about one of those pure
101:26 - A's pure BS pure C's running
that blockchain software, I'm
101:29 - talking about one server running
this technology. And again, it's
101:33 - this network. It's this
combination of these nodes
101:35 - interacting with each other,
that creates this entire
101:38 - blockchain. What makes these so
potent too, is that anybody can
101:41 - join the network. And that's why
there's decentralized the
101:44 - barrier to entry is a little bit
of hardware requirements for
101:47 - getting the correct materials to
run the software. And then you
101:50 - running the software, anybody
can join these networks and
101:52 - participate. And that's what
makes it truly decentralized. In
101:55 - fact, you can go to GitHub right
now, and run your own Aetherium
101:58 - node in a few seconds. Now in
the traditional world,
102:02 - applications are run by
centralized entities. And if
102:05 - that entity goes down, or is
maliciously bribed, or decides
102:09 - that they want to shut off, they
just can't, because they are the
102:12 - ones that control everything.
blockchains, by contrast, don't
102:16 - have this problem. If one node
or one entity that runs several
102:20 - nodes goes down, since there are
so many other independent nodes
102:24 - running that it doesn't matter,
the blockchain and the system
102:27 - will persist so long as there is
at least one node always
102:30 - running. And luckily for us,
most of the most popular chains
102:34 - like Bitcoin and Aetherium, have
1000s and 1000s of nodes. And as
102:38 - we showed in our demo, if one
node acts maliciously, all the
102:42 - other nodes will ignore that
node and kick that out or even
102:46 - punish it in some systems,
because they can easily check
102:49 - everybody else's node and see,
okay, this one is out of sync
102:52 - with the majority. And yes,
majority rules when it comes to
102:55 - the blockchain. Each blockchain
keeps a full list of every
102:58 - transaction and interaction
that's happened on that
103:01 - blockchain and we saw if a node
tries to act maliciously, then
103:05 - all their hashes are going to be
way out of whack and they're not
103:07 - going to match everybody else.
This gives blockchains this
103:10 - incredibly potent immutability
trait where nothing can be
103:13 - changed or corrupted. So in
essence, we can think of a
103:16 - blockchain as a decentralized
database. And with Aetherium, it
103:20 - has an extra additional feature
where it also can do computation
103:24 - in a decentralized manner. Now
let's talk consensus, proof of
103:27 - work and proof of stake because
you've probably heard these
103:30 - before. And they're really
important to how these
103:33 - blockchains actually work. We
went through that blockchain
103:35 - example, and we did that mining
feature. This is what's known as
103:39 - proof of work. Proof of Work and
proof of steak fall under this
103:43 - umbrella of consensus and
consensus is a really important
103:47 - topic when it comes to
blockchains. Consensus is
103:49 - defined as the mechanism used to
reach an agreement on the state
103:53 - or a single value on the
blockchain, especially in a
103:56 - decentralized system. I briefly
alluded to this consensus
103:59 - mechanism in our blockchain
example, when I said if one
104:03 - change is something and the
other two, don't, then majority
104:06 - will rule and kick that one out.
This is part of that consensus
104:09 - mechanism. Now very roughly a
consensus protocol in a
104:13 - blockchain or decentralized
system can be broken down into
104:15 - two pieces, a chain selection
algorithm, and a civil
104:19 - resistance mechanism, that
mining piece that we were doing,
104:22 - or where the proof of work
algorithm is what's known as a
104:25 - civil resistance mechanism. And
this is what Aetherium and
104:28 - Bitcoin currently use. Please
note that depending on when
104:31 - you're watching this, if eath
two is out, then it's no longer
104:34 - proof of work. Now, proof of
work is known as a civil
104:37 - resistance mechanism, because it
defines a way to figure out who
104:40 - is the block author, which node
is going to be the node who did
104:43 - the work to find that mine and
be the author of that block so
104:47 - all the other nodes can verify
that it's accurate civil
104:50 - resistance is a blockchains
ability to defend against users
104:54 - creating a large number of
pseudo anonymous identities to
104:57 - gain a disproportionately
advantageous influence is over
105:00 - set system. And in layman's
terms, it's basically a way for
105:04 - a blockchain to defend against
somebody making a bunch of fake
105:06 - blockchains so that they can get
more and more rewards. Now,
105:09 - there are two types of civil
resistance mechanisms that we're
105:11 - going to talk about here. Namely
proof of work and proof of
105:15 - stake. Let's talk about proof of
work a little bit more in depth
105:18 - first, in proof of work. This is
civil resistant, because a
105:21 - single node has to go through a
very computationally expensive
105:24 - process called mining, which we
demonstrated earlier to figure
105:28 - out the answer to the
blockchains Riddle of finding
105:30 - that correct nonce, or, or
whatever the
105:32 - blockchain system has in place.
And proof of work. This works
105:34 - because no matter how many
pseudo anonymous accounts you
105:37 - make, each one still has to
undergo this very
105:40 - computationally expensive
activity of finding the answer
105:44 - to the proof of work problem, or
the proof of work riddle, which
105:47 - again, in our demonstration, it
was finding a nonce with that
105:50 - first four zeros. But again,
each blockchain might change the
105:54 - riddle work or change the
problem to be a little bit
105:55 - different. In fact, some of
these blockchains make this
105:58 - riddle intentionally hard or
intentionally easy to change
106:01 - what's called the block time,
the block time is how long it
106:04 - takes between blocks being
published. And it's proportional
106:06 - to how hard these algorithms
are. So these problems actually
106:10 - can change. Depending on how
long they want the blockchain to
106:13 - be. If a system wants to block
time to be very, very long, they
106:17 - just make the problem very, very
hard. If they wanted to be very
106:20 - short, they make the problem a
lot easier. We'll talk about
106:23 - civil attacks in a little bit
and how they can affect the
106:25 - system. But with proof of work,
it's a verifiable way to figure
106:28 - out who the block author is and
be civil resistant. Now, you
106:32 - need to combine this with a
chain selection rule create this
106:35 - consensus. Now, there's some
consensus protocols that have
106:37 - more features, but very, very
roughly, these are the two
106:40 - pieces that we're going to look
at. The second piece is going to
106:43 - be a chain selection rule. How
do we know which blockchain is
106:47 - actually the real blockchain and
the true blockchain now on
106:50 - Bitcoin and Aetherium, they both
use a form of consensus called
106:53 - Nakamoto consensus. And this is
a combination of proof of work
106:57 - and longest chain rule, the
decentralized network side that
107:00 - whichever blockchain has the
longest chain, or the most
107:03 - number of blocks on it is going
to be the chain that they use.
107:07 - This makes a lot of sense,
because every additional block
107:09 - that a chain is behind, it's
going to take more and more
107:12 - computation for it to come up.
That's why when we saw in our
107:16 - transaction, we actually saw
confirmations. The number of
107:19 - confirmations is the number of
additional blocks added on after
107:23 - our transaction went through in
a block. So if we see
107:26 - confirmations as to it means
that the block that our
107:28 - transaction was in has two
blocks ahead of it in the
107:32 - longest chain. Now, I do want to
point out that a lot of people
107:35 - use proof of work as a consensus
protocol. And I do want to say
107:38 - that this is a little bit
inaccurate, but sometimes people
107:41 - use it interchangeably. Proof of
Work is a piece of the overall
107:45 - consensus protocol, which in
Bitcoin and Aetherium. One
107:48 - current case is Nakamoto
consensus, Nakamoto consensus is
107:53 - a combination of proof of work,
and this longest chain rule,
107:56 - both equally and very, very
important. Now, proof of work
108:00 - also tells us where these
transaction fees and these block
108:03 - rewards go to remember how when
we made this transaction, we had
108:07 - to talk about gas and a
transaction fee. So who's
108:10 - getting paid who was getting
this transaction, and this
108:13 - transaction fee is going to the
miners or the validators in a
108:16 - proof of work network? They're
called miners and in the proof
108:19 - of stake network, they're called
validators there are a little
108:23 - bit different. And we'll get
into that when we talk about
108:25 - proof of stake in this proof of
work system. All these nodes are
108:28 - competing against each other to
find the answer to the
108:31 - blockchain riddle. Remember, in
our example, it was to find a
108:34 - hash that has four zeros at the
start. And again, depending on
108:38 - the blockchain implementation,
that riddle is going to be a
108:40 - little bit different. But all
the nodes are trying as many as
108:44 - possible to try to get this
answer first. Why? Because the
108:48 - first node to figure out the
answer to the blockchain real is
108:51 - gonna get that transaction fee,
they're gonna get paid from
108:53 - that. Now, when a node gets
paid, they actually get paid in
108:56 - two different ways. One is going
to be with a transaction fee.
108:59 - And another piece is going to be
the block reward. Remember how
109:02 - we talked about alternating the
gas price or the gray on our
109:05 - transaction? Well, that's the
transaction fee that we're going
109:08 - to pay to these blockchain nodes
for including our transaction,
109:11 - the block reward is given to
these nodes from the protocol
109:15 - from the blockchain itself.
You've probably heard of the
109:18 - Bitcoin halving before the
halving is referring to this
109:21 - block reward getting cut in half
and it's supposed to be cut in
109:24 - half, roughly every four years.
This block reward increases the
109:29 - circulating amount of whatever
cryptocurrency that is being
109:32 - rewarded. For example, on
Aetherium the block reward is
109:34 - giving out Aetherium and a
Bitcoin the block reward is
109:37 - giving out Bitcoin. So these
nodes are competing against each
109:40 - other to be the first one to
find this transaction to be the
109:43 - first one to find the answer to
this problem, so that they can
109:46 - be the ones to win both this
block reward and your
109:49 - transaction fee. Some block
chains like Bitcoin, for
109:52 - example, have a set time when
they're no longer going to give
109:55 - out block rewards and the miners
or the nodes are only going to
109:58 - get paid from trends. Action
fees. Now this gas fee, again is
110:02 - paid by whoever initialize the
transaction. When we got our
110:06 - funds from the faucet, there was
some server and somebody else
110:09 - was paying the transaction fee
for us. However, when we sent
110:13 - ether from one account to
another, our first account
110:16 - actually paid some transaction
fee to send that ether. In proof
110:20 - of steak. There's also a gas
fee, but it's paid out to
110:23 - validators instead of miners.
And we'll talk about that in a
110:26 - little bit. Now let's talk about
two types of attacks that can
110:29 - happen in these blockchain
worlds. Let's talk about the
110:31 - first one being the Sybil
attack. The Sybil attack is when
110:34 - a user creates a whole bunch of
pseudo anonymous accounts to try
110:37 - to influence a network. Now,
obviously, on Bitcoin and
110:41 - Aetherium, this is really,
really difficult because user
110:44 - needs to do all this work in
proof of work or have a ton of
110:47 - collateral and proof of stake,
which again, we'll talk about in
110:49 - a bit. The other more prevalent
attack is what's known as a 51%
110:53 - attack. Now, as we saw as part
of our consensus protocol, these
110:57 - block chains are going to agree
that the longest chain is the
111:00 - one that they're going to go
with, so long as it matches up
111:03 - with 51% of the rest of the
network. This means that if you
111:07 - have the longest chain, and you
have more than 51% of the rest
111:10 - of the network, you can do
what's called a fork in the
111:13 - network, and bring the network
onto your now longest chain. Now
111:16 - Sybil attacks, obviously, are
when a single node or a single
111:19 - entity tries to affect the
decent reality of the network by
111:23 - pretending to be multiple
different people, although
111:25 - they're just the same person or
entity. And like I said, it's
111:28 - really difficult to do in proof
of work and proof of steak. So
111:31 - you can see now that blockchains
are very democratic, whichever
111:33 - blockchain has the most buy in
and is the longest is the
111:37 - blockchain that the whole system
is going to corroborate. When
111:40 - nodes produce a new block and
add to the longest chain, the
111:43 - other nodes will follow this
longest chain that the rest of
111:45 - the network is agreeing with,
add those blocks to their chain
111:48 - and follow up. So very small
reorganizations are actually
111:51 - pretty common when a blockchain
picks a block from a different
111:54 - longest chain puts it on and
then has to swap it out for
111:58 - another block and continue with
a different blockchain. However,
112:01 - if a group of nodes had enough
nodes or enough power, they
112:04 - could essentially be 51% of the
network and influence the
112:08 - network in whatever direction
that they want it. This is
112:10 - what's known as a 51% attack.
And it's happened on blockchains
112:14 - like Ethereum classic, which is
not Aetherium. This is why the
112:17 - bigger a blockchain is, the more
decentralized and the more
112:20 - secure it becomes.
112:21 - So after you watch this video,
and you become a blockchain
112:24 - engineering expert, I definitely
recommend you run a node as
112:27 - well, because you are going to
increase the security of the
112:29 - network as a whole by running a
node. So proof of work is
112:32 - fantastic because it allows us
to very easily protect against
112:35 - the Sybil attacks and keep our
blockchain is decentralized and
112:38 - secure. However, it has some
drawbacks as well. Proof of Work
112:42 - costs a lot of electricity,
because every single node is
112:45 - running as fast as they can to
win this race to get the
112:48 - rewards. This leads to obviously
an environmental impact. Now
112:52 - since proof of work and Nakamoto
consensus, a lot of other
112:54 - protocols have taken this idea
and gone in a different
112:57 - direction with a different civil
resistance protocol, a lot of
113:00 - them with the intention to be a
lot more environmentally
113:03 - friendly. And the most popular
one right now is proof of stake.
113:06 - There are some chains that are
already using this proof of
113:09 - stake protocol, and that are
live and thriving. Some of them
113:12 - are like avalanche, LaLana,
Polygon, polka dot and Terra and
113:16 - additionally Aetherium is
decided to upgrade to eath. Two,
113:20 - which will have this proof of
stake algorithm as well, it will
113:23 - also have some other features,
which we'll talk about in a bit.
113:26 - Now as a quick aside, all the
tools that we're going to learn
113:29 - here are still going to work in
eath. Two, so depending on when
113:32 - you watch this, everything here
is still valid. So let's talk
113:34 - about proof of stake. Now,
again, this is a different civil
113:37 - resistance mechanism. Instead of
solving this difficult problem,
113:40 - proof of stake nodes put up some
collateral that they're going to
113:44 - behave honestly, aka, they stake
in the example of Aetherium. two
113:49 - nodes put up some Aetherium as a
stake that they're going to
113:52 - behave honestly in the network,
if they misbehave to the
113:55 - network, they are going to be
slashed or remove some of their
113:58 - steak. Obviously, this is a very
good civil resistance mechanism.
114:01 - Because if you try to create a
whole bunch of anonymous
114:04 - accounts, then each one of those
accounts, you have to put up
114:07 - some stake. And if you
misbehave, you're going to run
114:10 - the risk of losing all the money
that you put up as collateral.
114:13 - In this system, miners are
actually called validators
114:16 - because they're no longer
binding anything, they're
114:18 - actually just validating other
nodes. Now, unlike proof of
114:21 - work, which every node is racing
to be the first one to find the
114:24 - block, and proof of stake nodes
are actually randomly chosen to
114:28 - propose the new block and then
the rest of the validators will
114:31 - validate if that node has
proposed the block. Honestly, as
114:35 - we saw with our cryptography
lesson, it's usually very easy
114:38 - for other nodes to verify if a
proposal or a transaction is
114:42 - honest. Now randomness is a
really important topic when
114:45 - we're talking about blockchains.
Because keep in mind, these
114:47 - blockchains are deterministic
systems. They're walled gardens
114:51 - from the rest of the world. And
as you know, a deterministic
114:54 - system by definition can't have
random numbers. So how do we
114:58 - choose the random validators in
the system? While it changes
115:01 - from blockchain to blockchain,
and actually choosing the node
115:04 - will change blockchain to
blockchain, but eath two,
115:07 - they're using what's called Rand
doubt, at least for the original
115:09 - implementation. This is a
decentralized autonomous
115:12 - organization that collectively
chooses the random number and
115:15 - collectively chooses which node
is going to run. Next, we aren't
115:18 - going to dive too deep into this
because there's a good chance
115:20 - that this might change in the
future. But we will go into
115:23 - randomness solutions and
blockchain later on in this
115:25 - course. Now, proof of stake
obviously has some pros and cons
115:28 - as well, pros are that again, it
is a great civil resistance
115:31 - mechanism. And a great way to
figure out who the author of a
115:33 - block should be. The other pros
are that it's way less
115:37 - computationally expensive to
figure out the new block,
115:40 - because instead of every single
node on the network trying to do
115:42 - this, only one node needs to do
this. And then the rest of the
115:46 - nodes just need to validate it.
The cons are that it's usually
115:49 - considered a slightly less
decentralized network, due to
115:52 - the upfront staking costs it
cost to participate. Now, this
115:55 - gets into a little bit of a
philosophical battle on how
115:58 - decentralized is decentralized
enough. And I think that's up to
116:01 - the community to decide. And as
we progress, I think we'll learn
116:04 - more and more about how
decentralized is decentralized
116:06 - enough. The general consensus
amongst blockchain engineers,
116:09 - though, is that proof of stake
is very, very decentralized and
116:13 - very secure. This massive
environmental impact improvement
116:16 - is one of the two main reasons
why eath is shifting to eath.
116:19 - Two, it reduces the
environmental impact by up to
116:21 - 99%. Now, these are the main
pieces of proof of work and
116:25 - proof of stake. But I did want
to talk about another concept
116:28 - that's really important in these
ecosystems. And that is
116:31 - scalability. When we were
talking about gas prices, we
116:34 - were saying that the gas prices
can get really high if a lot of
116:37 - people want to send a
transaction, because a block
116:40 - only has so much black space,
and the nodes can only add so
116:43 - many notes. So when a lot of
people want to use a blockchain,
116:46 - the gas price skyrockets. This
is not very scalable, because if
116:51 - we want to add more and more
people to these blockchains,
116:54 - it's going to cost more and more
to use the blockchains. Because
116:57 - more people are going to want to
get into these blocks. This
117:00 - means that there's kind of a
ceiling to how many people can
117:02 - use the system because of the
financial constraints that will
117:04 - get imposed as gas prices keep
rising. Aetherium too is not
117:08 - only attacking the environmental
impact of proof of work by
117:10 - switching to proof of steak, but
they're also implementing this
117:13 - new methodology called sharding.
And sharding is a solution to
117:18 - the scalability problem, a
sharded blockchain really just
117:21 - means that it's going to be a
blockchain of blockchains
117:24 - there's a main chain that's
going to coordinate everything
117:27 - amongst several chains that hook
into this main chain. This means
117:32 - that there's more chains for
people to make transactions on
117:35 - effectively increasing the
amount of block space that there
117:38 - is sharding can greatly increase
the number of transactions on a
117:41 - blockchain layer one now there's
another term that might be the
117:44 - first time you heard it, a layer
one, we're going to talk about
117:47 - layer one and layer twos in
terms of scalability really
117:50 - quickly as well. A layer one
refers to any base layer
117:54 - blockchain implementation
Bitcoins, a layer one Aetherium
117:58 - the layer one avalanches, a
layer one, these are the base
118:01 - layer blockchain solutions. A
layer two is any application
118:06 - that is added on top of a layer
one added on top of the
118:09 - blockchain. Some examples of
layer twos are going to be chain
118:12 - link arbitrage, or optimism.
Arbitrage and optimism are very
118:16 - interesting because they are
layer twos that also look to
118:19 - solve this scalability issue.
Arbitrage and optimism are
118:22 - what's known as roll ups and
they roll up their transactions
118:27 - into a layer one like Aetherium,
we're not going to go too deep
118:30 - into roll ups and how they
actually work. But all you
118:32 - really need to know is that a
roll up is kind of like a
118:35 - sharded chain, they derive their
security from the base layer
118:38 - from the layer one like
Aetherium. And they bulk send
118:41 - their transactions onto the
layer one, they solve some of
118:44 - the scalability issues by being
another blockchain that people
118:47 - can make transactions on, still
on kind of this base Aetherium
118:51 - layer. Now they're different
from side chains. Because side
118:54 - chains derive their security
from their own protocols, roll
118:58 - ups, derive their security from
the base layers. So arbitrage
119:01 - and optimism, for example, is
going to be just about as secure
119:04 - as Aetherium. There's some
fantastic guys in there that go
119:06 - a little bit deeper into roll
ups and I've left a link in the
119:09 - description for you. All right,
so we just talked about a lot of
119:12 - stuff. So let's do a quick recap
before moving on. Aetherium and
119:16 - Bitcoin are currently both proof
of work blockchains that follow
119:19 - Nakamoto consensus, however,
Aetherium is moving to Aetherium
119:23 - two, which will be a proof of
stake sharded blockchain Sybil
119:26 - attacks are prevented due to
protocols like proof of work and
119:29 - proof of steak 51% attacks grow
increasingly harder with the
119:33 - size of blockchain. So you
should run a node consensus is
119:37 - the mechanism that allows a
blockchain to agree upon what
119:39 - the state of the blockchain is
sharding and roll ups are
119:43 - solutions to scalability issues
on layer ones. Layer One is any
119:48 - based blockchain implementation
like Bitcoin or Aetherium. A
119:51 - blockchain scalability problem
is that there's not always
119:53 - enough block space for the
amount of transactions that want
119:56 - to get in them. This leads to
very high gas prices and a
120:00 - Again, gas prices or how much it
costs to interact with the
120:03 - blockchain.
120:04 - So that's it for the blockchain
basics and the blockchain
120:08 - explainers. With just this
information, you now can go off
120:12 - into the world and start working
with blockchains and interacting
120:15 - with blockchains. With at least
some level of knowledge as to
120:19 - what's going on, you should be
incredibly proud of yourself for
120:22 - just making it this far.
Definitely be sure to give
120:26 - yourself a pat on the back and a
round of applause. Now that
120:29 - we've gotten a lot of the basics
and the fundamentals of the way,
120:32 - let's start jumping into the
coding aspect. This is where
120:36 - you're going to learn how to
actually build these smart
120:38 - contracts, how to build these
trust minimized agreements, in
120:42 - these blockchains. And in the
smart contract platforms. This
120:45 - next section, this solidity
basics, the solidity
120:48 - fundamentals section will give
you all the skills to start
120:52 - actually coding solidity and
understanding how these smart
120:56 - contracts work underneath the
hood. So at this point,
120:59 - absolutely, give yourself a high
five, maybe say hi, in the
121:02 - GitHub discussions, maybe say hi
in the community, on Twitter, on
121:05 - Reddit, etc, and be proud of
just making it this far, the
121:09 - journey has really only just
begun, but you've already
121:11 - learned so much. Let's begin the
next section. And let's
121:15 - jump into the code.
121:19 - Now that we're getting to the
coding sections, I need to
121:21 - stress to absolutely use the
GitHub repository associated
121:25 - with this course. If you come to
the GitHub repo, and you scroll
121:28 - down, and you click the lesson
that we're on right now, we're
121:31 - on lesson two. Welcome to remix,
simple storage. If you click on
121:35 - it, it'll give you a ton of
timestamps and, and other
121:38 - helpful links associated with
this lesson. Additionally, the
121:42 - biggest piece is that all the
code will be available right
121:45 - underneath the lesson title.
This will have all the code that
121:49 - we're going to be working with,
as well as some more additional
121:52 - information on how to work with
the code. Please, when asking
121:55 - questions and entering in
discussions, though, please ask
121:58 - your questions and the full
blockchain solidity course
122:01 - repository. Thank you. And if
we're at the top of the
122:03 - repository, and we scroll down,
we have the resources for this
122:06 - course section. Which brings us
to the GitHub discussions in
122:09 - which you can ask questions in
the GitHub discussion section of
122:12 - this course. Additionally, on
Stack Exchange, Aetherium, or at
122:17 - Stack Overflow. I'll talk a
little bit about how to format
122:21 - questions and ask questions the
best way so that you have the
122:24 - highest chance of getting a good
answer in a later lesson, I
122:28 - highly recommend you pause and
make accounts for Stack Exchange
122:32 - Aetherium, Stack Overflow, and
GitHub right now, if you haven't
122:36 - already, links to them, of
course, can be found in our
122:38 - GitHub repository. Typically,
for each coding section, I'll
122:42 - start it off by giving a quick
overview of the code of what
122:45 - we're going to be working with
and what we're going to be
122:46 - building towards, since
everything that we're doing is
122:49 - going to be project based. And
that's how we're going to learn.
122:51 - For our first one and remix
though, we're going to skip over
122:55 - that because there's a lot of
stuff to get used to. Now, I
122:58 - highly recommend that as I'm
coding this. And as I'm doing
123:01 - all this in remix, you follow
along with me and you code along
123:05 - with me. Remember, you can
change my speed if I'm coding
123:08 - too fast, or if I'm coding too
slow. To start, we're going to
123:10 - jump into a tool called remix.
If you're unsure how to get
123:13 - there, there's a link to remix
in our GitHub repository. This
123:17 - is where we're gonna be writing
all of our code. So welcome to
123:21 - the remix IDE, or integrated
development environment. This is
123:25 - where we're going to learn how
to code and interact with our
123:28 - smart contracts. If you want,
you can go ahead and accept help
123:32 - out remix. If you've never been
here before, it'll give you a
123:35 - quick walkthrough of some of the
tools that remix actually has,
123:38 - we're going to skip over them
for now. Because I'm gonna
123:40 - explain everything that's going
up. Remix is such a powerful
123:42 - tool because it has a lot of
features that allow us to really
123:46 - see and interact with our smart
contracts. Eventually, we're
123:49 - going to move off of remix,
actually to a local development
123:52 - environment. However, remix is
absolutely fantastic for
123:56 - learning the fundamentals of
solidity. And I highly recommend
123:58 - everybody start with remix when
they're getting started. When
124:01 - you come to the remix IDE,
there's a whole lot of different
124:04 - things that are popping out to
us. There's a lot of different
124:07 - plugins as well. Since we're
going to be working with
124:09 - solidity, which is going to be
the language that we're using to
124:12 - develop our smart contracts. We
can go ahead and get started by
124:15 - clicking the solidity plugin,
and a couple of other tools will
124:18 - show up on the side. Even if you
don't click the solidity plugin,
124:22 - you'll still be able to code
solidity smart contracts, the
124:25 - left hand side is where we're
going to start to actually
124:27 - interact with things. The button
on the top most of the left is
124:30 - our files or explore
directories, remix comes
124:34 - boilerplate with some different
contracts, some different
124:38 - scripts, some different tests,
and different dependencies. We
124:42 - are going to minimize this a
little bit. So if you want to go
124:45 - ahead and right click and delete
some of these folders other than
124:48 - the contracts folders, feel free
to do so. Or if you kind of like
124:51 - them there, feel free to leave
them as well. We're going to
124:55 - leave our contracts folder and
we're going to delete the
124:57 - different files inside of it
just so that we can start From a
125:00 - blank slate. Most projects come
with something known as a
125:07 - readme. Usually it's a
readme.md, which usually
125:10 - explains how to actually work
with code. But for our purposes,
125:13 - we're going to delete this as
well. And you can just follow
125:15 - along with
125:15 - me. Now we have a blank
125:20 - remix Setup, click on the
contracts folder and click the
125:23 - little page icon to create a new
file, a little box will pop up
125:27 - and you can start typing text
into it. We're going to type in
125:30 - simple storage dot Sol, dot Sol
tells our compilers that this is
125:37 - going to be a solidity file, and
that we're going to code
125:40 - solidity in this solidity is the
primary coding language of smart
125:43 - contracts. There are a few other
smart contract languages as
125:46 - well. But solidity by far is the
most dominant smart contract
125:50 - coding language out there. And
now we have a simple storage dot
125:53 - soul contract on the right that
we can actually start coding our
125:56 - solidity with. So let's start
coding some solidity. Now if you
126:00 - click on this button right below
the files button that looks like
126:04 - the solidity logo, you'll see a
bunch of stuff pop up in here.
126:08 - These are different parameters
for us to actually compile our
126:11 - solidity code so that we can run
it. So the first thing that
126:14 - you're going to need in any
solidity smart contract is going
126:17 - to be the version of solidity
that you're going to use. And
126:20 - this should always be at the top
of your solidity code, solidity
126:24 - is a constantly changing
language, and it constantly
126:26 - updating language. Because it's
relatively new compared to other
126:29 - languages, we need to tell our
code, hey, this is the version
126:32 - that I want you to use, we can
add the solidity version by
126:35 - doing pragma. solidity. And then
the version that we want to use,
126:40 - if we want to choose a very
specific version, we could say
126:42 - zero, point 8.7. The most
current version to date is 0.8.
126:48 - Point 12. But getting used to
different versions of solidity
126:51 - is good practice, and different
versions of solidity are
126:54 - considered more stable than
others. Zero point 8.7 is one of
126:57 - those versions that is
considered more stable. These
127:00 - double slashes here are what's
known as a comment, there are
127:03 - places where you can type stuff
that won't actually get executed
127:06 - in won't get compiled and isn't
really considered part of your
127:09 - code. For example, I could write
Hello all. I'm Patrick. And if
127:15 - we were going to run this code,
this part of my code would get
127:17 - completely ignored. So this
double backslash is how we do
127:20 - what's called comments. And as
we're coding, and as we're
127:23 - building our projects, be sure
to use this comments tool to
127:27 - your advantage every time you
write a new function, or you
127:31 - learn something that you didn't
understand, or you learned
127:34 - something new that you want to
remember, put it in a comment in
127:37 - your code, you're going to be
most effective at taking notes
127:40 - in this course, by making them
comments in your code and then
127:43 - saving your code so you can
refer back to it later. So leave
127:46 - comments in your code, leave
notes in your code. And that
127:49 - will be one of the best ways for
you to understand what you're
127:51 - coding when you want to refer
back to it later. Now when it
127:54 - comes to the versions of
solidity, there's actually a few
127:56 - different ways we can actually
write it, we can say we want to
127:59 - use only zero point 8.7. And
this is how we would write that.
128:04 - But maybe we're okay if we use a
more new version of solidity
128:07 - than zero point 8.7 to tell our
code that we're okay with a more
128:11 - new version, we can put a little
caret here. And this is how we
128:15 - tell solidity. Hey, any version
of zero point 8.7 And above is
128:20 - okay for this contract. This
means zero point 8.8 would work
128:24 - zero point 8.9 0.8 point 10,
etc. But if we wanted to use
128:29 - just 0.17, we would type in like
that if we want to use solidity
128:33 - versions between a specific
range, we could do something
128:36 - like this, we can say we want
our solidity version greater
128:39 - than or equal to zero point 8.7
But less than zero point 9.0.
128:45 - This means that any compiler
between zero point 8.7 and zero
128:50 - point 9.0 would work. This means
zero point 8.8 would work. Zero
128:55 - point 8.9 would work 0.8 point
10 would work. But zero point
129:00 - 9.0 would not work because it is
not strictly less than 0.9 point
129:06 - 00 point 9.1 would also not
work. To keep things simple for
129:09 - us, we're going to use zero
point 8.8. And every line of
129:13 - solidity that's completed, every
completed section needs to end
129:17 - with one of these semicolons
this is how you tell solidity
129:20 - it's the end of the line. Also
at the top of your code, you're
129:23 - always going to want to put
what's called an spdx license
129:26 - identifier. This is optional,
but some compilers will flag
129:30 - your warning that you don't have
one. This is to make licensing
129:33 - and sharing code a lot easier.
We have a link to more about how
129:37 - licenses work in the section of
this lesson in our GitHub
129:40 - repository to do an spdx license
identifier, we just say spdx
129:45 - license identifier, and we're
gonna choose MIT, the MIT
129:51 - license is one of the least
restrictive licenses out there.
129:54 - So we use the MIT license for
most of our code samples once
129:58 - you have a version and once you
have Is this much written, we
130:01 - can actually go ahead and write
to our compiler tab and scroll
130:04 - down and hit Compile, that
little turn thing will go. And
130:08 - in a minute, we'll see, this
contract is attempted to be
130:11 - compiled. Since we actually
don't have a contract, we see no
130:14 - contract compiled yet, but we
see the compiler automatically
130:17 - switched to zero point 8.8.
compiling our code means taking
130:21 - our more human readable code
like pragma, solidity and
130:24 - transforming it into computer
code, or very specific
130:29 - instructions for the computer to
use. We'll go over what a lot of
130:32 - this machine level code or this
computer level code is doing in
130:36 - a later section. If you're using
a Mac, you can also hit command
130:39 - S, and it will run the compiler
for you as well. On Windows, it
130:42 - might be Ctrl S, we can actually
choose the compiler version that
130:46 - we want to use. However, if we
tell in our code to specifically
130:49 - use zero, point 8.8, and we hit
the compile button, it'll
130:53 - automatically switch to zero
point 8.8. However, if we use
130:56 - the carrot thing, we get
specifically say, hey, we want
131:00 - 0.8 point 10, we can hit
compile, and it will compile
131:05 - with 0.8 point 10. Because
again, remember, the carrot says
131:09 - we want to use at least zero,
point eight, all the way up to
131:13 - the latest version of 0.8. Now
let's stay on zero point 8.8.
131:18 - The next thing that we're going
to do in our code is define our
131:20 - contract. And to get a full
screen view, you can go ahead
131:23 - and hit the compiler button to
get rid of it there. To start
131:25 - defining our contract, we're
gonna go ahead and write the
131:27 - word contract. This tells
solidity that the next pieces of
131:31 - code is going to be a contract
contract is a key word in
131:35 - solidity, and it tells our
compiler that the next section
131:37 - of this code is going to define
a contract. You can think of a
131:41 - contract similar to a class in
any object oriented programming
131:44 - like Java or JavaScript. Let's
go ahead and give our contract a
131:48 - name here, we're going to call
RS simple storage. And then we
131:53 - add this little open and close
curly brackets. Everything
131:57 - inside this open and close curly
brackets is going to be the
132:00 - contents of this contract.
Simple Storage. Now, if we go
132:03 - ahead and hit command S or Ctrl
S, we can see this little green
132:06 - checkmark show up. And if you
don't, you can always go back to
132:09 - the compiler tab, scroll down
and hit Compile and see the
132:13 - little green checkmark. That
little green checkmark means
132:16 - that our code is compiling
successfully. And we don't have
132:19 - any errors, we could
hypothetically deploy this
132:21 - contract right now. And it would
be a valid contract. So
132:25 - congratulations on writing your
first contract.
132:30 - Now solidity has multiple
different types or primitive
132:33 - data types. And if you go to the
solidity documentation, which
132:36 - again, is in our GitHub
repository, you can read more
132:39 - and learn more about the
different types that are in
132:41 - here. The four most basic types
are going to be Boolean,
132:45 - you int, int, and an address
132:49 - or bytes, which is a lower level
type, which we'll talk about a
132:52 - little bit later. A boolean
define some type of true false,
132:55 - a you int is going to be an
unsigned integer, which means
132:58 - it's going to be a whole number
that isn't positive or negative.
133:01 - It's just positive, we have an
integer, which is going to be a
133:05 - positive or negative whole
number. And then we have an
133:08 - address, which is going to be an
address, like what we see in our
133:12 - meta mask here. There are some
other types as well that you'll
133:15 - learn later on. The reason that
we have these types is we use
133:18 - them to define what different
variables are. Variables are
133:22 - basically holders for different
values. For example, we could
133:25 - create a variable called has
favorite number to represent if
133:31 - somebody has a favorite number.
And we would put this bull
133:35 - keyword before has to renumber
say, Okay, we have a variable
133:40 - called has favorite number, and
it's of type boolean. So this
133:44 - has favorite number is going to
represent a true or a false to
133:47 - set its value, we could say has
favorite number equals true. Now
133:52 - has favorite number is going to
be true. We could also say has
133:56 - favorite number equals false. So
this Boolean has faded number is
134:00 - now going to be false. For uns
we could say you went favorite
134:05 - number equals and then set a
number 123. This means that our
134:11 - favorite number is going to be
123 You'll enter is special
134:14 - because we can actually specify
how many bits want to allocate
134:18 - to this number bits and bytes
are pretty fundamental pieces of
134:22 - information for computer
science. We're not going to go
134:24 - over it here. However, there's a
fantastic video in the GitHub
134:27 - repository that explains it
more. Basically, it's how much
134:30 - storage or memory to allocate to
this number. How big can it get,
134:34 - if we say a you int eight can
have eight bits all the way up
134:38 - to you went to 56. If you don't
specify how big it is, it
134:42 - automatically defaults to you
into 256. Oftentimes, it's
134:46 - better when writing our code to
be very explicit. So usually
134:49 - you'll see me just do you int
256 to represent a un 256. We
134:53 - could also do an int favorite
number equals 123 or an int 256.
134:59 - I'm just Going to go ahead and
add this Boolean back here,
135:01 - we're going to change this back
to UNT to 36. And let's change
135:05 - our favorite number to five
here, we could also do something
135:07 - called strings, string, favorite
number in text
135:14 - equals five
135:16 - strings represent basically
words, and you can represent
135:20 - them by putting them in these
quotes, it's going to be some
135:23 - word or phrase, or really,
really just kind of any
135:25 - combination of keystrokes in
here, our ends can be positive
135:30 - or negative. So we could say,
negative five or positive five,
135:35 - both are going to be valid,
since we can also do address my
135:39 - address equals and grab our
address, right from Metamask.
135:45 - And paste it in, you'll notice
that we end all of these lines
135:48 - of code with the semicolon. We
also have bytes objects, or a
135:53 - bytes 32, again, representing
how many bytes we want them to
135:56 - be. And this says that we have
called favorite bytes, and we're
136:04 - just gonna set it equal to cat.
So strings are actually really
136:07 - interesting, because strings are
secretly just bytes objects, but
136:11 - only for text to a cat is
actually a string, but can
136:15 - automatically get converted into
one of these bytes object bytes,
136:18 - objects typically look like 0x.
And then some random letters and
136:23 - numbers that represent the bytes
object, but cat can
136:26 - automatically get converted down
to bytes. We'll talk about bytes
136:29 - more in coming sessions, you can
also do bytes, two bytes, three
136:32 - bytes, five bytes 22, you get
the picture for our uns and our
136:37 - into the sixth lowest we can go
is eight bits, because eight
136:41 - bits is a byte. And we can go up
by steps of eight. So we can do
136:44 - 816 32, etc, all the way to 256.
For example, down here, we can't
136:51 - do bytes 64. And if we go ahead
and try to compile this, we get
136:58 - a little red thing here. And if
we scroll down, we get a
137:02 - declaration error identifier not
found or not unique. Bytes 64
137:06 - favorite bytes equals cats. And
we even got a little red warning
137:10 - sign here in our remix. This is
remix telling us there's
137:13 - something wrong with this line.
So we can switch back to bite
137:16 - 32. Since byte 32 is the maximum
size that a bytes can be, you
137:20 - could also do just a bytes
object, which means it can have
137:23 - any size, but we typically want
to be explicit. And we're going
137:26 - to stick with bytes 32 For now
want to learn more about the
137:29 - different types and how to use
them and all the different
137:32 - features with them, be sure to
check out the solidity
137:34 - documentation. For now for our
simple storage, let's say we
137:37 - only want to store numbers. So
let's go ahead and delete
137:40 - everything except for the
favorite number section.
137:45 - Now in solidity,
137:46 - if I do this, and I remove the
equals five, this favorite
137:50 - number actually does get set to
a default value, the default
137:54 - value for solidity is going to
be whatever the null value is,
137:57 - which in solidity is case zero.
So saying you Intuit six
138:01 - favorite number is going to be
the same as saying you 256
138:04 - favorite number equals zero
since it gets initialized to
138:08 - zero. So for now, let's not
initialize it to anything. So
138:11 - that favorite number will
automatically start off as zero.
138:15 - Now, if you get confused, as
you're coding along, and you're
138:17 - following along with me, be sure
to write comments in your code
138:21 - so you know what's going on. So
maybe, for example, a great
138:24 - comment here would be this gets
initially alized to zero. And
138:30 - then if that's even confusing,
you could say, this means that
138:35 - this section is a comment. Now
let's go ahead and create a
138:44 - function functions or methods
are self contained modules that
138:48 - will execute some specific set
of instructions for us, when we
138:51 - call it if you're familiar with
Java, or Python, or JavaScript
138:54 - or anything like that functions
work the exact same way
138:57 - functions get identified by the
keyword function, let's create a
139:01 - function called store that will
change the value of favorite
139:06 - number to some new value. And
the number that we're going to
139:10 - change it to is going to be
variables that are passed to our
139:13 - store function here. So we're
going to allow our store
139:16 - function to take a variable of
type un 256. And we'll call it
139:22 - underscore favorite
139:25 - number, we'll make this a public
function, which we'll get to in
139:28 - a minute. And all we're going to
do is we're going to set
139:30 - favorite number equal to
whatever variable that we just
139:34 - passed. So now we have this
function called store, that it
139:39 - takes some parameter that we're
going to give it and it sets
139:43 - this favorite number variable
equal to whatever number that we
139:46 - give this function. Now to see
this actually in action, let's
139:49 - deploy this to an even thicker
blockchain than a test net.
139:52 - We're going to actually deploy
this to a local network or a
139:55 - JavaScript VM. And first before
we can even do that, let's just
139:59 - make sure that it's going
compiling correctly looks like
140:01 - we have a green checkmark, which
is good. And we'll come down to
140:04 - this button here, which is our
deploy and run Transactions tab.
140:08 - Our deploy and run Transactions
tab has a ton of different
140:11 - configuration pieces for
actually deploying this
140:14 - contract. First, we want to make
sure we are on the JavaScript VM
140:18 - London piece here, JavaScript VM
means we're going to be
140:21 - deploying to a fake local
JavaScript VM. The JavaScript VM
140:26 - is a fake local blockchain where
we can simulate transactions
140:30 - really quickly without having to
wait for them to go through on a
140:33 - test net, don't worry about the
London versus Berlin piece here
140:36 - for now, injected web three and
web three provider we'll talk
140:39 - about in a little bit. We also
have this account section here.
140:42 - When we run on our fake
JavaScript VM, we're given a
140:46 - whole bunch of fake accounts
from where to deploy from, and
140:49 - we're given 100 eath. For each
one of these fake accounts, you
140:53 - can kind of think of it similar
to our meta mask account in meta
140:56 - mask, except for the difference
here is that this is this fake
141:01 - JavaScript VM Aetherium that
we're given. For our
141:04 - transactions, including
deploying contracts, we're
141:06 - actually given a gas limit,
there's also values we can send,
141:09 - and we can choose our contracts.
Right now we only have one
141:12 - contract, simple storage, so
that's going to be the one that
141:15 - we're going to deploy. So on the
left hand side, to deploy this
141:18 - to our fake JavaScript VM, we're
gonna go ahead and hit the
141:22 - Deploy button. And if we scroll
all the way down to the bottom,
141:24 - now, we can see a contract was
deployed. It says simple storage
141:30 - at x, blah, blah, blah, blah,
blah. And we see this orange
141:34 - button store with come this
grade text you in 256,
141:38 - underscore favorite number on
our fake local blockchain, we're
141:42 - actually given an address every
single smart contract, it has an
141:46 - address, just like how our
wallets have an address. So if
141:51 - we hit this copy button here,
and we put it into a comment,
141:55 - make this a little bit bigger,
we can see that the address of
141:59 - this contract that we just
deployed, is located at this
142:02 - address. Additionally, if you
pull up the slider over here,
142:06 - you'll be able to see this
little green checkmark with all
142:08 - this information about this
deployment. And you can hit the
142:11 - little drop down and see a whole
lot more information about this.
142:14 - Something you might notice is
you'll see some familiar
142:17 - keywords like status,
transaction hash, from to gas,
142:22 - etc. When we deploy a contract,
it's actually the same as
142:27 - sending a transaction. Remember,
anytime we do anything on the
142:30 - blockchain, we modify any value,
we are sending a transaction. So
142:36 - deploying a contract is
modifying the blockchain to have
142:40 - this contract, it's modifying
the state of the blockchain. And
142:43 - if we had sent this on a
Rinkeby, or COVID, or main net
142:45 - network, we would have had to
spend the gas to actually deploy
142:49 - this contract. And this is the
simulation of how much gas and
142:53 - the transaction hash and from
and to and all this other stuff
142:56 - about our transaction had, we
actually deployed it to a real
142:59 - network. But since it's
JavaScript VM, it's all fake
143:02 - information. Now we have this
big orange button store, this
143:05 - big orange button resembles the
store function that we just
143:08 - created. So if we add some
number into this store, like
143:12 - 123, and we hit the Store
button, we actually call this
143:16 - store button. And we actually
execute a transaction on our
143:19 - fake Jasika. Blockchain to store
the number 1234 favorite number.
143:25 - And if we scroll all the way up
to our account, now, you'll see
143:29 - that we have a little bit less
ether in our fake account. This
143:32 - is because we spent the gas to
actually call this contract. And
143:37 - if we pull up this bottom bit
here, and I call this with five
143:40 - I call store, you'll see it
flashed for a quick second, we
143:43 - sent another transaction to
store the value five in our
143:47 - favorite number. Now the
question might be having is,
143:50 - that's really cool, Patrick, but
I can't see what favorite number
143:53 - actually is, how do I know that
those transactions are actually
143:56 - going through? Well, right now,
the visibility of our favorite
144:00 - number is set to private, so we
actually can't see it. And we'll
144:04 - talk about visibility in just a
second. To make it so that we
144:07 - can see it. We'll change our
favorite numbers visibility to
144:10 - public. So let's go ahead, we'll
recompile we'll go back to the
144:14 - deploy tab. We'll click the
little x here, which is to say
144:18 - let's get rid of this contract.
And it just gets rid of it from
144:21 - our window here. It doesn't
actually get rid of it from the
144:23 - blockchain, because again,
they're immutable, well, kind of
144:27 - immutable, since again, this is
kind of a fake simulated chain.
144:30 - But we go ahead and compile, and
now we hit Deploy again. And if
144:34 - we scroll down, our new
contract, will now have two
144:37 - buttons. One is the orange
button for store. But now we
144:41 - have a New Favorite button. This
button represents this public
144:45 - variable favorite number, and it
resembles a function saying,
144:48 - Hey, show me what favorite
number is. So if I were to click
144:52 - this favorite number button,
what do you think will show up?
144:55 - Well, do you remember what this
gets initialized to? Well, let's
144:58 - click it now. We do indeed See
that zero shows up, we see that
145:02 - this is a YouTube ID six, and
the value stored in it is zero.
145:06 - Now, if I were to change that
number to five by calling the
145:10 - store function, and now hitting
favorite number, we do indeed
145:13 - see, favorite number gets
updated to five functions and
145:16 - variables can have one for
visibility specifiers, we have
145:20 - public, private, external, and
internal. Public is visible
145:26 - externally and internally,
meaning anybody who interacts
145:30 - with this contract or sees this
contract can see what's stored
145:33 - in this favorite number
function. You'll see here in the
145:35 - solidity documentation, it says
it creates a getter function for
145:38 - the storage slash state
variables. When we add this
145:41 - keyword public to favorite
number, what we're actually
145:44 - doing is we're creating what's
called a getter function for
145:47 - favorite number, we're basically
creating a function that says to
145:50 - return the value of favorite
number, and that's why this blue
145:54 - button pops up. Because this
blue button is a function that
145:57 - says, hey, return the value of
favorite number private means
146:02 - only this specific contract can
call this function. Now for
146:05 - storage, it doesn't mean only
this contract can read what's
146:10 - stored here. And we'll get into
that a little bit later. But by
146:13 - that means, this is the only
contract that can call the
146:15 - favorite number function.
Private functions are only
146:18 - visible to the current contract.
External functions are only
146:21 - visible externally, meaning
somebody outside this contract
146:25 - can call this function. And then
internal means that only this
146:29 - contract and it's children
contracts can actually read it,
146:32 - but we'll get into that a little
bit later, too. So oddly enough,
146:36 - variables are just function
calls. Now, the reason that we
146:39 - didn't see favorite numbers show
up on the left hand side, when
146:42 - we first deployed this without
the public keyword. When we
146:45 - don't give a visibility
specifier to functions or
146:47 - variables, they automatically
get deployed as internal. And as
146:51 - we know, internal functions and
variables can only be called by
146:54 - this specific contract or
derived contracts, which again,
146:57 - we'll get into later. So let's
just keep it public. For now,
147:01 - the reason that we're prefixing,
our parameter here with an
147:04 - underscore is a way to tell us,
hey, this variable here is
147:09 - different from the favorite
number global, there are some
147:11 - different naming conventions
that are used for parameters.
147:14 - And as we get later into the
course, will understand more and
147:17 - more of what good names are
parameters are, every time we
147:20 - call this store function. And we
change the value here, we're
147:24 - actually sending a transaction
because remember, every single
147:27 - time we change the state of the
blockchain, we do it in a
147:30 - transaction. And we can see all
the details here. If you go over
147:33 - to the transaction details in
the logging area of your remix,
147:37 - you can actually scroll down and
you can see the transaction cost
147:41 - in units of gas, you'll see a
number of something around this.
147:44 - And you'll notice it's more than
that 21,000 number from sending
147:48 - Aetherium. That's because we're
doing something more
147:50 - computationally expensive. We're
actually storing a number over
147:55 - here. Now what do you think will
happen if we do more inside of
147:59 - the store function as well. So
instead of just storing this
148:01 - number, maybe what else we do is
we will store the number here.
148:06 - And then we'll update our
favorite number will say
148:08 - favorite number equals favorite
number plus one. Since we're
148:11 - doing more stuff, now we should
see this store function actually
148:15 - become more expensive. So let's
go ahead and recompile we'll do
148:19 - delete this will redeploy. We
now have a new contract will
148:24 - store five again. Now if we look
in the details of this
148:29 - transaction, and we scroll down
to execution costs, we do indeed
148:33 - see the amount of gas has
greatly increased. And that's
148:36 - because we're doing more things,
this store function is now more
148:40 - computationally expensive. And
like I said, each blockchain has
148:44 - a little different way of how
they actually calculate gas. But
148:46 - the easiest way to think about
it is, the more stuff you do,
148:50 - the more expensive that
transaction is going to cost. So
148:54 - let's go ahead and delete this
line to continue our example.
148:57 - Now let's talk about scope for a
second, our favorite number is
149:02 - basically in something called
the global scope, meaning
149:05 - anything inside of these
brackets can access this
149:09 - favorite number variable. But
what if I did something like
149:11 - this? What if I made a un 256
called Test var? And I set it
149:17 - equal to five? And then I
created a new function called
149:21 - something will have it take no
parameters and be public? Could
149:26 - I access the test var and then
change it to something like six?
149:30 - Can we do that? Well, let's go
ahead and see what happens when
149:33 - we try to compile this. We
actually run into an error. We
149:37 - had expected primary expression
right here. Oh, well, that's
149:41 - because I have the double
question mark. Let's try now. We
149:44 - get undeclared identifier. Our
something function doesn't know
149:48 - about this test var when you
create variables, they only can
149:51 - be viewed in the scope of where
they are. Now if that's a little
149:55 - confusing, just look for the
curly brackets. These two curly
149:57 - brackets encompass this whole
We'll section here write, the
150:01 - opening one is up here, the
closing one is down here. So if
150:04 - I create a variable directly
inside of these curly brackets,
150:08 - that means everything in here
can access it. However, test var
150:12 - was created inside of these
curly brackets, which means that
150:15 - only stuff inside of these curly
brackets can access test var,
150:19 - since our functions something
isn't inside of store, or
150:23 - something function won't know
about test var. So that's how
150:27 - scope works, you want to look to
see if your variable that you
150:30 - created is inside of these curly
brackets. And that's how you can
150:33 - know if other functions can work
with them. So this is why this
150:38 - fails. Now, like what we saw in
the documentation, when we add
150:41 - this public variable to favorite
number, we're secretly adding a
150:44 - function that just returns this
favorite number, we can also add
150:48 - our own function that also
returns the favorite number to
150:51 - resemble the function that's
getting created in the backend.
150:53 - So we can say function, we call
it retrieve, and we make it a
150:58 - public view. And we'll say it
returns, you went to 56. or
151:05 - explain what that means in just
a second. And we'll say return
151:08 - favorite number. Now, I'm going
to hit command S, which again,
151:13 - I'm going to do that a lot
throughout this section. But
151:16 - just remember that that's
equivalent to me going to the
151:19 - compile tab and hitting compile.
Now if we go to the deploy tab,
151:22 - delete our last one, deploy a
new one, we now have a retrieve
151:26 - function, which is going to
return the exact same thing that
151:30 - our favorite number is going to
return. Again, if we update this
151:32 - to five, called favorite number
and then retrieve they both now
151:36 - return five. Now as you can see
here, these two functions are
151:40 - blue, but this function is
orange. What's the difference?
151:44 - Why did these have these
different colors? Well, the key
151:47 - lies in this view keyword here,
there are actually two keywords
151:50 - in solidity that notate a
function that doesn't actually
151:54 - have to spend gas to run. And
those keywords are view, and
151:58 - pure. And let's also get rid of
this variable here. A function
152:02 - that is a view function means
we're just going to read state
152:06 - from this contract, we're just
going to read something off of
152:08 - this contract. For example, our
retrieve function right now is
152:11 - just reading what favorite
number is, a view function
152:14 - disallows any modification of
state. So you can't update the
152:19 - blockchain at all with a view
function. Pure functions also
152:22 - disallow any modification of
state. So we couldn't update our
152:26 - favorite number. Not only that,
but they also disallow reading
152:29 - from the blockchain. So we
couldn't read favorite number
152:32 - either. Instead, what you might
do with a pure function is maybe
152:36 - something like
152:38 - function, add public here, one
plus one,
152:45 - or return, one plus one, this
would be turns you into 36,
152:51 - maybe something like this, maybe
there's some math you want to
152:54 - use over and over again, maybe
there's some specific algorithm
152:57 - that you want to implement that
doesn't actually need to read
152:59 - any storage, etc. Now, if we
call a view function, or a pure
153:03 - function by itself, we actually
don't need to spend any gas.
153:07 - Since we're just reading from
the blockchain. Remember, we
153:09 - only spend gas we only make a
transaction if we modify the
153:13 - blockchain state. So you'll
notice in our little console
153:17 - down here, that if I call
retrieve this call things comes
153:21 - up. However, it looks different
than when we call the store
153:24 - function. And we call the store
function, we get this little
153:26 - checkmark, we get a hash, we
don't get a little checkmark.
153:30 - And we don't get a hash with the
calls. That's because clicking
153:33 - these blue buttons doesn't make
a transaction. This is saying,
153:37 - Hey, we're just going to read
off chain, we're just going to
153:39 - read this value. However, if you
look in the details of this
153:43 - call, there's this execution
cost bit here. So what's going
153:46 - on? Well, we can read this part
right here, cost only applies
153:50 - when called by contract. If we
do have a function that calls
153:54 - retrieve, if there's a function
that is updating state that
153:58 - calls a view or a pure function,
that's the only time it'll cost
154:01 - gas. So for example, if our
store function which is not a
154:05 - view function, were to call
retrieve at some point, then
154:08 - we'd have to pay the cost of the
Retrieve because reading from
154:12 - the blockchain cost this
computation and cost gas calling
154:16 - view functions is free, unless
you're calling it inside of a
154:20 - function that costs gas, in
which case it will cost gas. So
154:24 - if we leave it here, we delete
this recompile redeploy. We had
154:31 - favorite number retrieved, they
both still cost nothing. But if
154:34 - we add, restore eight in here,
we can see, we can see our
154:40 - execution cost has gone up from
what it was without retrieve,
154:43 - which we can go ahead, we can
compile, I hit command us to
154:45 - compile here, we can deploy.
Let's go ahead and store again.
154:50 - We'll click on that transaction,
we can see that it's much
154:53 - cheaper without that retrieve
function in there. And again,
154:56 - our favorite number variable as
long as it has this public
154:59 - visible solidity, it also is
counted as a view function that
155:04 - returns a un 256. The returns
keyword means what is this
155:08 - function going to give us after
we call it so we say this
155:11 - function is going to give us
this function is going to return
155:15 - a un 256. When we call retrieve,
it's going to return or give us
155:20 - a utility six. This is the
result of calling the function
155:25 - this six is the result of
calling arbitrary function.
155:31 - Now our contract is
155:32 - good as it is, it allows us to
store a single favorite number.
155:35 - But what if we want to store a
range of favorite numbers? Or
155:38 - maybe we want to store a whole
bunch of different people who
155:42 - have different favorite numbers?
Well, how do we do that there
155:44 - are several different ways that
we can approach this, one of the
155:46 - ways we could start approaching
this is by creating what's
155:48 - called a struct of people. Or we
create a new type. In our
155:53 - solidity, we can create a people
object that holds both someone's
155:57 - name, and their favorite number.
To do that, we say struct
156:02 - people, you went to 56, favorite
number, and a string name. Now
156:11 - we've created a new type called
people kinda like you intuited
156:15 - six, or Boolean, or string. Now
we have a people type that we
156:19 - can use. Now similar to how we
created a un 256 public favorite
156:23 - number, we can do the exact same
thing. But with a people, we
156:28 - could say people public, we call
this person, and we can create a
156:33 - new people and assign it to this
variable person. So we'll say
156:37 - equals people public person,
equals, and we'll add
156:42 - parentheses here to signify
we're creating a new person. And
156:46 - since we made this a struct, we
add little curly brackets here
156:49 - to let solidity know that we're
going to be grabbing from these
156:52 - struct variables, we'll say
favorite number is going to be
156:57 - two, and the name is going to be
Patrick semicolon, and then we
157:04 - can hit Ctrl S, or we can go
ahead and compile. Now if we go
157:07 - ahead and deploy this we now
have a new person, since this,
157:15 - again, is a public variable, it
has a getter function called
157:19 - person. And if we click person,
we see our new object, the
157:23 - favorite number is two. And then
the name is Patrick, you see
157:27 - this zero and this one, because
these are showing the index of
157:31 - the different variables. But
those of you new to computer
157:33 - science, typically in computer
science, let's start with the
157:36 - number zero. So what are zero
with index, we have you in 256,
157:39 - called favorite number, which is
saved at two. And then at index
157:43 - one, we have a string, which
stands for the name of Patrick,
157:47 - whenever you have a list of
variables inside of an object in
157:50 - solidity, they get automatically
indexed. So favorite number gets
157:54 - indexed to zero, and name gets
indexed to one. Interestingly
157:58 - enough, if you have a whole
bunch of variables inside your
158:01 - contract, like we have public
favorite number, this favorite
158:05 - number, actually, technically is
getting indexed at the zero with
158:09 - storage slot. And if we were to
make another one of these, maybe
158:12 - you want to get six public
brother's favorite number, this
158:16 - would technically be indexed at
the first slot. And then if we
158:19 - were to make one more, maybe
sister's favorite number, this
158:23 - would be the next add the second
slot. So favorite number at
158:25 - zero, this add one, and this a
two, but we'll learn more about
158:29 - that much later in the course.
Similarly, favorite number is
158:33 - index zero name is index at one.
Now what we have is great, but
158:37 - if we want a whole lot of people
are we gonna have to keep copy
158:39 - pasting and changing the
people's name person to their
158:43 - favorite one, number one, number
three, will name them ally.
158:48 - Person three, their favorite
number will be seven. Their name
158:53 - will be Chad or something. This
obviously isn't great way to
158:58 - create lists and large number of
people's because we have to
159:00 - statically keep typing them in.
So a much better way to create a
159:04 - list. And let's actually just go
ahead and delete Patrick to a
159:08 - much better way to create a list
is to use a data structure
159:11 - called an array. An array is a
way to store a list, or a
159:15 - sequence of objects, creating an
array works the exact same we've
159:19 - seen to initialize other
different types. Typically, we
159:22 - do the type of the object, the
visibility of the object, and
159:26 - then the variable name. We do
the exact same thing with
159:29 - arrays. We'll say we want a
people array. These little
159:33 - brackets represent that we want
an array of people. We'll give
159:37 - it a visibility of public and
we'll call it people you could
159:42 - do the same thing with you and
256 for example, you could say
159:45 - you went to 56
159:49 - public favorite numbers list
159:54 - and just add this little array
key here. And now favorite
159:57 - numbers list is going to be an
array or a list We're going to
160:00 - comment that out for now. Now if
I were to go ahead and deploy
160:03 - this contract, let's go ahead
delete the last one, let's
160:06 - redeploy. We now have this blue
people button here. Remember,
160:11 - since it's public, and it's a
variable, it automatically is
160:14 - given a view function, it's
given one of these blue buttons.
160:18 - And instead of just having a
single button where the value
160:22 - shows up, it's giving us a form
to fill out, it wants to take a
160:25 - un 256 as an input parameter. So
if I put zero, I get nothing
160:30 - back, if I put one, I get
nothing back. No matter what you
160:33 - put in this box, right? Now
we're gonna get nothing back.
160:36 - This is because our people array
or our people list is currently
160:40 - empty. And the value that it
wants is going to be the index
160:43 - of the object that you want. So
for example, if at index zero, I
160:47 - had Patrick, it would show
Patrick for zero, if it didn't x
160:50 - one I had John, or actually
better yet, to Patrick.
160:57 - Seven, John,
160:59 - etc. This is what it would show.
But since it's empty, it's going
161:03 - to show nothing. And let's go
ahead and remove the public
161:06 - variable from favorite numbers
so that we don't get the
161:09 - duplicate functions at the
moment, we'll just get the
161:12 - Retrieve function, we'll show
you how to add to this array in
161:14 - just a second. This type of
array is what's known as a
161:17 - dynamic array, because the size
of the array isn't given at the
161:22 - array initialization. If we were
to say, a people array and add a
161:26 - three in these brackets here,
that means that this list, or
161:29 - this array of people could only
be three people big, if we don't
161:34 - give it a size, it means it can
be any size and the size of the
161:37 - array can grow and shrink as we
add and subtract people, if I
161:40 - add three, it can only have a
maximum of three in the array
161:44 - ever, we're going to work with a
dynamic array, because we're
161:47 - going to want to add a arbitrary
number of people to this array.
161:50 - So let's go ahead and create a
function that's going to add
161:53 - people who are people array, so
we're gonna say function, add
161:58 - person. And we're going to take
string, memory, name as input
162:04 - parameter, and I'll explain that
in a minute. And a un 256
162:08 - underscore favorite number,
we're going to make this a
162:13 - public function, or we're going
to do is we're going to call a
162:17 - push function that's available
on our people object. So we're
162:21 - gonna say people dot push, and
we're going to create a new
162:25 - person, a new people object,
which is going to take in the
162:28 - favorite number.
162:31 - And the name.
162:34 - Now, this might be a little bit
tricky to you. So let's break
162:36 - this down. People here is
capitalized. So we know that
162:40 - since capitalize, it's referring
to this struct people and not
162:43 - our variable people, the
lowercase people here is
162:46 - referring to this lowercase
array. So we're saying our array
162:51 - dot push, or push is the
equivalent of adding basically,
162:55 - a new people that grabs favorite
number and name. Another way
162:59 - that we could actually do this
is we could create a variable of
163:03 - type people and then add it like
so. So we could say people, new
163:07 - person equals people. And then
we put those brackets the same
163:12 - way we did before. You say
favorite number is going to be
163:18 - this input value, this
parameter, and we could say name
163:22 - is going to be this parameter.
Now if you hit save, you'll get
163:26 - this error set here, saying data
location must be stored in
163:29 - memory, or called data for
variable but no one's given. For
163:32 - now, we're just going to add the
memory keyword here, and I'll
163:35 - explain what it does in a little
bit. And then of course, we need
163:37 - to add the new person into our
people dot push right here. So
163:40 - this is how we're actually going
to push people into our people
163:44 - array. And I'll get to this
memory keyword in a bit. Now if
163:47 - we go back to our deploy tab, we
delete our last contract. Let's
163:52 - deploy this new one. Right now,
if we try to look at the zero
163:56 - with person in our people array,
we get nothing but let's go
163:59 - ahead and add a person, we'll
call it, Patrick will be the
164:03 - name, and seven will be the
favorite number. So we added
164:07 - Patrick, we added seven. Now if
we look at people's zero, we
164:11 - should see the zeroeth person
has a name of Patrick, and a
164:14 - favorite number of seven, boom.
And that's exactly what we do
164:18 - see, we see a favorite number of
seven, and we see a string name
164:21 - Patrick, we tried to add John
and do his 16. We hit Add
164:26 - Person, we can see our
transaction go through. And now
164:29 - if we go to people at zero, it's
still Patrick with a favorite
164:33 - number of seven. But if we look
at the people at index one, it's
164:37 - going to be John with a favorite
number of 16. And if we look at
164:40 - two, this, of course, should be
blank. And we do indeed see
164:44 - nothing actually happens here.
Perfect. Now there's actually a
164:47 - couple of different ways to
create this new person here,
164:50 - like we showed before, we can
use this bracket notation, or
164:54 - what we can do is we can
actually just add the parameters
164:57 - in the order that they show. So
the first parameter for people
165:01 - is going to be favorite number.
So we can just do favorite
165:04 - number, comma, and the second
one is going to be name, the
165:08 - second one is going to be name.
So if we save this, this, this
165:12 - line we just created is the
exact same as the last line,
165:15 - we're being a little bit less
explicit here. So the other way
165:18 - is generally a little bit better
because it's more explicit as to
165:21 - what variables are what or we
don't even need to save to this
165:24 - variable here, we could take out
this whole line, replace new
165:27 - person with exactly what we just
saw, like so now we don't even
165:32 - need the memory keyword. Now,
you've probably seen this by
165:37 - now. But if I go ahead and
compile, and I see a little,
165:40 - little red one here, I roll
over. And it says something
165:44 - about error, expected semicolon,
but got bracket, all these
165:48 - errors mean that your code isn't
compiling. It's not working as
165:52 - expected. So now I can go over
here and do a little semicolon
165:56 - recompile, and I get a green.
Now if I delete this top line,
165:59 - for example, and I compile it,
actually get a yellow thing.
166:04 - Yellow stands for warnings, the
warning that I get is warning
166:08 - SPX license identifier, not
provided, you should add it. So
166:12 - let's go ahead and add that
back. recompile. And the warning
166:15 - goes away. Warnings Don't stop
your code from compiling. So if
166:18 - you get warnings, it's okay. But
it's usually a good idea to
166:20 - listen to the warnings, because
often they'll give really
166:23 - insightful information about how
to improve your smart contracts.
166:26 - So to summarize, if it's red,
it's broken. If it's yellow, you
166:30 - might want to check it out. But
it won't stop you from
166:32 - continuing to code. So one thing
166:39 - that you'll notice here is that
we have this memory keyword. And
166:42 - you'll notice if you try to
delete it from our function
166:44 - here, you try to compile, you
actually run into an error data
166:47 - location must be memory or call
data for parameter and function.
166:51 - Now there are actually six
places you can store data in
166:54 - solidity you have the stack,
memory, storage, call data, code
167:00 - and logs. We're not going to go
over these right now. But we are
167:03 - going to focus on three of the
big ones, or three of the
167:06 - important ones for this section,
which are called data, memory,
167:10 - and storage. So for this
section, we're going to talk
167:12 - about call data memory and
storage. And this is a little
167:15 - bit advanced. So if you don't
totally grasp it the first time,
167:18 - that's totally okay. Please
continue. Even if it's not
167:21 - crystal clear what's going on
here, call data and memory mean
167:24 - that the variable is only going
to exist temporarily. So this
167:29 - name variable only exists
temporarily during the
167:32 - transaction that this Add Person
function is called storage
167:36 - variables exist, even outside of
just the function executing.
167:41 - Even though we didn't specify it
up above, our favorite number is
167:45 - automatically cast to be a
storage variable. Since it's not
167:48 - explicitly defined in one of
these functions. Since we don't
167:52 - need this name variable anymore
after this function runs, we can
167:55 - keep it as memory, or we could
keep it as called data, you can
168:00 - have a parameter as called data
if you don't end up modifying
168:03 - the name. For example, we
couldn't reassign name to equal
168:07 - cat here, if we compile we run
into an error. Type literal
168:11 - string cat is not implicitly
convertible to expect the type
168:14 - string called data. However, if
we have this as memory, and we
168:18 - compile and save it, that error
goes away call data is temporary
168:22 - variables that can't be
modified. Memory is temporary
168:25 - variables that can be modified.
And storage is permanent
168:29 - variables that can be modified.
Now even though I just said
168:32 - there's actually six places
where we can access and store
168:35 - information, we cannot say a
variable is stack code or logs,
168:40 - we can only say memory storage
are called data, you will learn
168:43 - why in a much later section.
Now, this is a bit of an
168:46 - oversimplification of this. But
that's essentially what's going
168:49 - on. The next question you might
have is, well, why do I need to
168:53 - say memory here, but I don't
need to say memory here. Well,
168:58 - let's go ahead and put memory
here and hit CTRL S or compile.
169:02 - And let's see what happens we
get from solidity data location
169:05 - can only be specified for an
array, struct or mapping types.
169:08 - A memory was given arrays
structs and mappings are
169:12 - considered special types and
solidity. solidity automatically
169:15 - knows where are you in 256 is
going to be slowly knows that
169:19 - for this function, a un 256 is
going to live just in memory.
169:24 - However, it's not sure what a
string is going to be. Strings
169:27 - are actually kind of
complicated. Behind the scenes,
169:30 - a string is actually an array of
bytes. And since a string is an
169:34 - array, we need to add this
memory bit to it because we need
169:38 - to tell solidity, the data
location of arrays structs, or
169:41 - mappings and a string is
secretly an array. So that's why
169:45 - we need to tell it it's in
memory. You'll notice we can't
169:48 - add the storage keyword here
slowly also knows that since
169:50 - this is a function, this name
variable isn't actually getting
169:53 - stored anywhere. So it says Hey,
you can't have that you need to
169:56 - have it beat memory or called
data and those are the only two
169:59 - that it accepts So this is what
we want our function to look
170:02 - like here. So the summary of
this is struct mappings and
170:05 - arrays need to be given this
memory or called Data keyword
170:09 - when adding them as a parameter
to different functions. We'll
170:12 - learn more about storage memory
and call data in later
170:15 - sessions. Now, this list
170:19 - is great, but what if we know
someone's name, but we don't
170:22 - know their favorite number?
Well, what we could do is we
170:25 - could look through the whole
array looking for that person.
170:28 - For example, in our contract, we
can say, Okay, I'm looking for
170:32 - John. Okay, let's start with
zero. No, okay, that's Patrick.
170:36 - Okay, let's go to one. Okay.
That's John. Oh, great. His
170:39 - favorite number 16? Well, this
was really easy, because we only
170:42 - had two people. But what if we
had hundreds of people in this
170:45 - array? Well, we'd keep have to
iterating all the way up to the
170:48 - index that that person was in,
it's obviously really
170:51 - inefficient. What's another way
to store this information so
170:54 - that it's much easier and
quicker to access? Well, another
170:57 - data structure that we can use
is something called a mapping,
171:00 - you can think of a mapping as
sort of like a dictionary, it's
171:04 - a set of keys, which each key
returning a certain value
171:08 - associated with that key. And we
create a mapping variable the
171:10 - exact same way we create all of
our other variables. This is
171:14 - going to be a type mapping of
string
171:19 - to you and tivity sex,
171:22 - this is going to be our type of
visibility keyword is going to
171:25 - be public. And we'll call it
name to favorite number. Now we
171:32 - have a dictionary where every
single name is going to map to a
171:36 - specific number. So let's add
some capability to our Add
171:39 - Person function. So we are going
to add our people to our array.
171:44 - But let's also add them to our
mapping here, what we'll do is
171:48 - we'll say name to favorite
number. App key name is going to
171:53 - equal to
171:57 - favorite number. So let's go
ahead, compile this.
172:03 - We'll go to our deploy screen,
we'll deploy this click, we have
172:08 - a new button named a favorite
number. If I type in Patrick,
172:13 - nothing shows up. By typing
Patrick, you'll see I get zero
172:17 - response. By typing John, I also
get a zero response. If I type
172:21 - in Becca, I also get a with zero
response. When you create a
172:25 - mapping, you initialize
everything to its null value,
172:29 - every single possible string on
the planet right now is
172:32 - initialized to having a favorite
number of zero. So if we want to
172:35 - change that, we'll have to go in
and manually add that. So let's
172:38 - go ahead and add a person to our
mapping here. So we'll add
172:43 - Patrick. And we'll say my
favorite number is seven. And
172:47 - looks like that transaction did
go through also add, Becca, and
172:51 - we'll say her favorite number is
13. Let John and we'll say his
172:56 - favorite number is 16. Now, if I
look up, Patrick, I'll
173:01 - immediately get back what
Patrick's favorite number is, I
173:04 - get seven back. If we look up,
John, we immediately get back
173:08 - 16. Back up, we may only get
back 13. And we also can see
173:12 - them in our array. Because we
kept in this people that push
173:16 - bit zero, we see Patrick's
there. At one, we see Becca. And
173:22 - at two, we see John, in our
mapping, we're saying the string
173:26 - name is being mapped to the UN
256 favorite number. And a lot
173:31 - of my variables, I like to make
them explicitly named like that.
173:34 - So this is name to
173:35 - favorite number. So
173:39 - now we're in a space where let's
say that we really like our
173:43 - simple storage contract. Right
now we have a favorite number, a
173:46 - global variable that we can save
a favorite number to with our
173:51 - store function, we have a
mapping of name to favorite
173:56 - numbers, and we have an array of
a new type that we created
174:00 - called people, we can add to
both the array and to the
174:04 - mapping. Using this Add Person
function that we've created,
174:08 - we're able to save multiple
people's favorite numbers as
174:11 - well as kind of a global
favorite number as well. Let's
174:14 - say we really love this
contract, and we're ready to
174:17 - send it to a test net to have
other people interact with it.
174:20 - Now in future sections, you'll
hear me say that you shouldn't
174:23 - do this until you write tests
until you do some really simple
174:26 - auditing. But for now, let's go
ahead and learn how to actually
174:29 - deploy this to a test net or to
a real network. Now remember,
174:34 - test nets are run out of the
goodness of people's hearts. So
174:36 - if it's a little bit funky, or
maybe doesn't work exactly as we
174:39 - show here, that's okay. As long
as it works with the JavaScript
174:43 - VM, you'll be all set but it is
good practice to learn how to
174:46 - deploy these to a real test net.
Let's go ahead and do that. Our
174:50 - contract is here. Simple Storage
dot soul. It's compiled,
174:54 - compiling is passing we get this
little green checkmark here we
174:57 - go to the deploy section. Let's
go ahead and do Get this. And
175:00 - now we're going to change the
environment. So we were working
175:03 - with a JavaScript VM or kind of
this fake simulated environment,
175:07 - we want to now move to either
injected web three, or web three
175:11 - provider. If you hover over
injected web three, there's this
175:14 - really, really small text here.
But this basically means we're
175:18 - going to inject our meta mask or
our web three wallet into our
175:22 - browser to use similar to what
we did with the faucet, we'll
175:25 - pick our account we want to use.
So I'm gonna go ahead and pick
175:29 - account one. And now we actually
see our account in the Account
175:34 - section of remix, injected web
three means we're using our meta
175:38 - mask or whatever web three
wallet, web three provider is,
175:42 - when we a little bit more
manually choose an endpoint. And
175:45 - we're not going to go over this
right now. But as we get later
175:48 - into the course, you'll
understand what this means. So
175:50 - we're picking injected web
three, whatever network are
175:53 - injected web three, or in this
case, our wallet is connected to
175:57 - is going to be the network that
we deploy to. So for this
176:00 - section, we're going to be
deploying to Rinkeby. But again,
176:03 - depending on whatever the
recommended test net and the
176:05 - recommended faucet is, that will
dictate which test net you
176:09 - should actually deploy to. For
us, it's going to be Rigby. To
176:12 - deploy to a test that remember,
we're going to need gas, so
176:15 - we're going to need some tested
Etherium. Or if you're deploying
176:18 - to a main net main Aetherium,
which you shouldn't be come to
176:21 - the top of the GitHub repo to
make sure you have the most
176:23 - updated faucet, the other place
you can go is link token
176:27 - contracts page in the chain link
documentation and scroll down
176:31 - the ranking. And you can see
test that link available here,
176:35 - test that eath available here.
So this is the other location,
176:38 - you can always look to find the
most up to date faucets, and
176:41 - both of them point right back
here. So now that we're working
176:45 - with injected web three, we can
just go through the exact same
176:47 - steps to deploy to a test net as
to deploy to a virtual machine.
176:53 - And remember, if you run out of
gas to deploy this, be sure to
176:56 - check back to the faucets to
actually deploy this. So we're
176:58 - going to do the same thing,
we're gonna go ahead and hit
177:00 - Deploy. But this time Metamask
is going to pop up and ask us if
177:05 - we want to actually deploy this,
this is the exact same as what
177:09 - we saw with the blockchain
example, where we sign
177:13 - transactions, we are signing and
sending this transaction, the
177:17 - data of this transaction is this
massive, massive data thing
177:21 - here, which represents the
contract that we just created,
177:24 - we can see all the payment
information for this transaction
177:28 - for deploying this contract, we
see it's going to cost around
177:32 - this much Aetherium to deploy.
But again, we're on the Rinkeby
177:36 - test network. So this is going
to be fake Aetherium. We're
177:38 - gonna go ahead, hit Confirm. And
if you pop up a little console,
177:43 - and remix, you'll see that after
a slight delay, it'll actually
177:48 - say have this green checkmark
that it's confirmed that it went
177:51 - actually went through, we can go
ahead right click, open a new
177:55 - tab, and view this on ether
scan. And after a slight delay,
178:00 - we'll actually be able to see
the transaction details here,
178:03 - exactly the same as our
transaction details for sending
178:06 - Aetherium we have a hash, we
have a status, we have blocked
178:10 - block confirmations, we have
timestamp from which is going to
178:13 - be us two, which is going to be
the average of the contract that
178:16 - we just created. We didn't send
any value with this. So this is
178:20 - going to be zero ether. And then
of course, we see the
178:22 - transaction fee, and as well as
the gas price. Because again,
178:26 - deploying a contract to the
blockchain is modifying the
178:29 - state of the blockchain. So we
have to pay gas, and we can see
178:32 - all the different pieces here.
As we can see, gas limit and gas
178:36 - usage is much higher than just
sending Aetherium, since we are
178:39 - putting a lot of data on chain
and adding a lot of computation.
178:44 - So this number is much higher
than the 21,000 number of just
178:48 - sending Aetherium. Now, if we
come back to our remix and
178:51 - scroll down, we're able to see
our simple storage contract at
178:55 - this address. If we hit this
copy button, and we go to the
178:59 - rink be ether scan, we paste it
in the search bar, we will get
179:03 - the contract that we just
deployed. And we see this first
179:06 - transaction is going to be the
contract creation transaction.
179:10 - So this contract that we just
created one transaction, which
179:14 - is contract created. So now that
we have this contract created,
179:17 - we have all the exact same
functions that we saw when
179:19 - working with the JavaScript
virtual machine, or the our fake
179:22 - environment, or our super fake
environment. Now we can do all
179:25 - the exact same things that we
did with the JavaScript VM, but
179:28 - on a real test network. So
you'll see if I hit retrieve
179:32 - Metamask doesn't pop up. Because
again, this is a blue view
179:36 - function. If we look people at
zero, this is also a view
179:39 - function and nothing pops up,
named a favorite number should
179:42 - be blank. So if I type in
Patrick now, absolutely nothing
179:45 - happens, right? I get I get zero
returned because mappings
179:49 - initialize every single key with
a blank or a null value, which
179:53 - for you 256 is zero. Now, we can
go ahead and store a favorite
179:58 - number store When your favorite
number is going to modify the
180:01 - blockchain, so our meta mask
should pop up for us to confirm
180:06 - the transaction and sign that
transaction to modify the
180:10 - blockchain state. So I'm going
to store my favorite number of
180:13 - 16, we'll hit store, meta mask
will pop up, and we're going to
180:18 - go ahead and actually confirm
this didn't confirm is
180:21 - equivalent to US signing this
transaction and sending it to
180:24 - the blockchain to modify the
state. So we're gonna go ahead
180:27 - and confirm this, we should be
able to view this on ether scan.
180:31 - And again, it might take a
little bit for it to actually
180:34 - index or actually start working.
So please be patient with these
180:37 - test nets. And again, this is
why when building your
180:40 - applications, you want the test
net piece to absolutely try to
180:43 - be your last step, because you
have to wait a really long time.
180:47 - And it puts a burden on these
people running these tests into
180:50 - running it out of the goodness
of their heart. So please try to
180:52 - make this the last step of your
actual building process. For us
180:56 - learning right here, it's okay.
And after a slight delay, once
181:00 - we hit refresh, it looks like
it's indexing on ether scan, the
181:03 - ether scan website is still
figuring out where the
181:05 - transaction is going to remix,
it looks like on the blockchain,
181:08 - this has actually already gone
through. So now if we hit
181:10 - retrieve, we do indeed see, our
favorite number is 16. Of
181:14 - course, these two are still
going to be blank. And it looks
181:17 - like that transaction has gone
through and ether scan has
181:20 - indexed. So now let's go ahead
and add a person will add
181:23 - Patrick, and my favorite number
is going to be 16. We'll go
181:27 - ahead and add person. Again,
since these are orange
181:30 - transactions gonna pop up
because we're modifying the
181:33 - blockchain state, we'll go ahead
and hit Confirm. And we're going
181:36 - to be a little bit patient here
and wait for this transaction to
181:39 - go through. And we should see
this update. And this update.
181:43 - Now if I hit named a favorite
number of Patrick, I get 16. And
181:47 - if I hit people of zero, I get
favorite number 16. And the name
181:50 - is Patrick. Awesome. So you've
actually successfully deployed a
181:54 - contract to an actual test net,
and actually seen on ether scan
181:58 - what these transactions look
like, you should be incredibly
182:00 - proud of yourself, be sure to
give yourself a high five pat on
182:03 - the back, send a tweet saying
exactly how excited you are. But
182:07 - make sure to celebrate these
little wins, celebrating these
182:09 - little wins will give you the
motivation to keep going and
182:12 - really excite you for learning
each new thing. So huge.
182:16 - Congratulations. If you got this
far, you've deployed your first
182:19 - contract to a test net,
congratulations. Now if you want
182:22 - to see what it looks like to
deploy to a different network,
182:24 - all you need to do in your
Metamask is switch to a
182:28 - different test net. See, if we
switch to COVID remix
182:32 - automatically updates and says,
ah, injected web three is now
182:35 - the COVID test network. We could
switch again maybe to Grilley,
182:39 - we say Ah, the injected web
three is now at the Grilley.
182:42 - This is the test net that we'd
be deploying to of course, we
182:45 - need actual test net Aetherium
to do any deploying, so we
182:48 - wouldn't be able to here. And if
we go ahead and hit Deploy right
182:51 - now Metamask pops up. But we get
this little red thing saying
182:55 - insufficient funds. Of course,
later on, we'll learn how to add
182:59 - new networks like polygon like
avalanche like phantom into our
183:03 - Metamask. So we can deploy from
any one of them
183:05 - as well.
183:08 - Now, I mentioned this term
before, but all this code that
183:11 - we wrote, when we hit this
compile button, it compiles it
183:14 - down to the EVM or the Ethereum
virtual machine. Don't worry too
183:20 - much about what this means. EVM
is a standard of how to deploy
183:24 - smart contracts to Aetherium
like blockchains. And any
183:28 - blockchain that implements a
type of EVM. You can deploy
183:32 - solidity code to some examples
of EVM compatible blockchains
183:36 - are going to be avalanche,
Phantom, and polygon. Since
183:41 - these are EVM compatible, this
means we can write our solidity
183:44 - code, and deploy to these
blockchains, which again, I'll
183:48 - show you later on how to add
these new networks into your
183:50 - Metamask. And then how to deploy
them. Let's do a quick recap of
183:53 - our first smart contract. And
then you should actually take a
183:56 - break, maybe get some ice cream
or coffee because you absolutely
184:00 - deserve it. Congratulations. The
first thing you always need to
184:02 - do in your smart contracts is
tell solidity, what version of
184:06 - solidity that you're going to be
using. And additionally, you
184:09 - want to add an spdx license
identifier, then you have to
184:13 - create your contract object and
name your contract. The contract
184:16 - in solidity is similar to a
class in other programming
184:19 - languages, and everything inside
the squiggly brackets is a part
184:23 - of that contract. There are many
different types in solidity like
184:26 - unsigned integer, 256, Boolean
string, bytes, 32, etc. If we
184:32 - want to create a new type, we
can create what's called a
184:35 - struct in solidity. You can
create arrays or lists in
184:38 - solidity, you can create
dictionaries, or what's called
184:42 - mappings in solidity or hash
tables, which when you give it a
184:45 - key, it'll spit out the value
that that key represents. We can
184:49 - create functions in solidity
that modify the state of the
184:52 - blockchain. We can also create
functions in solidity that don't
184:55 - modify the state of the
blockchain view in pure
184:58 - functions, don't modify by the
state of a blockchain, we also
185:01 - can specify different data
locations in our functions,
185:05 - called data and memory mean that
that data is only temporary and
185:09 - will only exist for the duration
of the function. Storage
185:12 - variables are permanent and stay
there forever. function
185:15 - parameters can't be stored
variables because they're only
185:17 - going to exist for the duration
of the function. All the
185:20 - solidity code that we work with,
when we hit Compile, it actually
185:23 - compiles down to this Aetherium
virtual machine specifications.
185:28 - We'll learn more about those
specifications later. And last,
185:30 - but not least, another huge
congratulations on your first
185:33 - contract here.
185:37 - Awesome.
185:37 - All right, let's get started on
our lesson three, remember,
185:41 - everything is in the GitHub
repository. And we can scroll
185:43 - down, hit Lesson three and see
all the code here. I'm building
185:47 - up this repo as I film. So
underneath this lesson three is
185:50 - going to be a lot more
information than just the code
185:52 - here, all of our code samples
end with dash f f, c, which
185:57 - means dash Free Code Camp. So if
you see a GitHub repo that ends
186:00 - with dash F, F, C, know that
that repository is associated
186:05 - with this course, I'm going to
do a quick high level
186:07 - walkthrough of what we're going
to be building in this lesson.
186:10 - So you don't need to code right
now just sit back watch and
186:14 - enjoy. In this lesson, we're
actually going to expand to
186:16 - having three different
contracts. Let's say we want to
186:19 - be able to deploy simple storage
contracts from a contract
186:23 - itself. Yes, contracts can
indeed deploy contracts, we are
186:28 - going to create a contract
called storage factory dot sole,
186:31 - that's going to be able to
deploy and interact with other
186:34 - contracts itself. So what we
could do is we could go deploy
186:38 - this to a JavaScript VM, we're
going to choose storage factory,
186:42 - and we're gonna go ahead and hit
Deploy. In our contract down
186:45 - below, we have a number of
different functions. Our top
186:48 - function is this function called
crate simple storage contract,
186:52 - which we can click and it'll
actually create a simple storage
186:56 - contract for us, then we can go
ahead and interact with it at an
186:59 - IG zero will save a favorite
number of one. Now, if we hit SF
187:04 - get zero,
187:06 - we get one back. And
187:09 - we can see the address of the
simple storage contract that we
187:12 - just deployed. Additionally,
we're going to learn about a
187:14 - number of solidity features,
such as importing inheritance,
187:18 - and so much more. So let's go
ahead and jump in. And remember
187:22 - all the code is available here
from the GitHub repository. So
187:25 - be sure to refer back to these
contracts if you get lost.
187:31 - So here we are
187:32 - back in remix, and we have our
simple storage dot soul. If you
187:35 - skipped over the last section,
be sure to go to the full
187:38 - blockchain solidity course, Jas.
And scroll down to lesson two,
187:42 - welcome to remix and grab this
code. Go to simple storage
187:46 - outsole. And copy paste this
code into remix. Because this is
187:50 - where we're going to be starting
from, we have this simple
187:53 - storage contract, which is
great. It allows us to store a
187:56 - favorite number. And it allows
us to store favorite numbers
187:59 - across different people in both
mappings and arrays. But let's
188:02 - say we want to get even more
advanced with this, we actually
188:05 - can have a contract actually
deploy other contracts for us.
188:10 - And then go ahead and interact
with those contracts from other
188:13 - contracts, contracts interacting
with each other is an essential
188:17 - part of working with solidity
and working with smart
188:19 - contracts. The ability for
contracts to seamlessly interact
188:23 - with each other is what's known
as composability. smart
188:26 - contracts are composable,
because they can easily interact
188:28 - with each other. This is
especially awesome when it comes
188:31 - to things like defy where you
can have really complex
188:34 - financial products interact with
each other incredibly easily,
188:38 - since all their code is
available on chain. So we're
188:41 - going to learn how to do that.
So let's keep our simple storage
188:43 - contract exactly the way it is,
we're going to create a new
188:46 - contract called storage factory.
So we're going to hit the New
188:49 - File button and type in storage,
factory dot salt. And let's
188:56 - close this off for now. So let's
go ahead and get this contract
188:59 - setup from what we learned
before. First thing we're going
189:01 - to want to do is the spdx
license identifier, which we're
189:08 - going to do MIT. And then the
next thing we're always going to
189:11 - need is our solidity version.
189:13 - So we'll do pragma solidity
189:17 - and we could do zero point 8.7.
But for this one, let's do zero
189:21 - point 8.0 And then just add the
carrot, meaning any version of
189:25 - 0.8 point something will work.
And then let's add our contract
189:28 - name, which is going to be
storage factory. Now hit command
189:33 - S or ctrl S or go to the compile
tab and hit compile, and boom,
189:37 - we have our regular setup here.
Now we want to create a function
189:41 - that can actually deploy our
simple storage contract. So
189:44 - we'll create a function called
function. create simple storage
189:49 - contract, we'll have it be
public, so anybody can call it
189:53 - will have to deploy a simple
storage contract and save it to
189:57 - a global variable. But before we
can do it How can our storage
190:00 - factory contract know what our
simple storage contract looks
190:04 - like? In order to deploy it, if
our storage factory contract is
190:08 - going to deploy simple storage,
it's going to need to know code
190:11 - of simple storage. One way we
can do this is we can actually
190:14 - go to our simple storage dot
soul and copy everything
190:18 - underneath pragma, solidity and
down and paste it into our
190:23 - storage factory dot soul
underneath our pragma, solidity.
190:27 - If we go ahead and compile and
save this, it actually works our
190:30 - storage factory, that soul
contract actually now has two
190:33 - contracts in it. It has the
simple storage contract, and it
190:36 - has the storage factory contract
in it, you actually go to the
190:39 - deploy tab and scroll down to
deploy while you're on the
190:43 - storage factory dot soul, not
the simple storage that's all on
190:46 - storage factory, you can see
that you can actually choose
190:49 - which one of these contracts to
deploy, a single file of
190:52 - solidity can hold multiple
different contracts. Now that we
190:56 - have our simple storage, that's
all in our storage factory, we
190:59 - can actually go ahead and create
this function to deploy a simple
191:02 - storage console, we're going to
create a global variable the
191:05 - same way that we would create
any other global variable, we'll
191:07 - do the type, which is going to
be type simple storage contract,
191:12 - we'll give it a visibility of
public. And we'll give it a
191:17 - variable name. Type simple
storage contract going to be
191:20 - public, the name of the variable
is going to be simple storage.
191:24 - Now in our function, create
simple storage contract, we're
191:26 - gonna say simple storage equals
191:29 - new, simple storage.
191:34 - This new keyword is how solidity
knows Ah, okay, we're going to
191:37 - deploy a new simple storage
contract. So we go ahead and
191:41 - compile this, we'll go to the
deploy tab, make sure we're on
191:44 - the JavaScript VM, we'll scroll
down to the contract. And we'll
191:48 - choose storage factory. And
remember, you need to have
191:51 - storage factory dot soul
selected. In order for that to
191:54 - show up storage factory, we'll
go ahead and hit Deploy. And now
192:00 - we see our storage factory
contract has two buttons. One is
192:04 - create simple storage, and the
other one is going to be a view
192:07 - of our simple storage contract.
If we click it right now, it's
192:11 - going to show us that it's
currently at address zero,
192:13 - because it gets initialized to
being blank. It's saying there
192:16 - is no simple storage contract
currently deployed. Now if we
192:19 - pull up our console and click
create simple storage, we see we
192:23 - created a new function call
storage factory dot create
192:27 - simple storage contract. And in
doing so we called this function
192:30 - which created and deployed a new
simple storage contract, we can
192:34 - now see what address the simple
storage contract is out by
192:36 - clicking the simple storage
button and we see the address
192:39 - associated with it. So now we
know how a contract can actually
192:42 - deploy another contract. But the
thing is, having this massive
192:46 - chunk of code above our storage
factory is a little bit
192:49 - redundant, especially since we
have our other file called
192:52 - Simple Storage dot soul. And
let's say we have a contract
192:56 - that has got a ton of other
contracts in it. Always copy
192:59 - pasting all these contracts is
going to be a lot of work. So
193:02 - instead, what we can do is use
what's called an import. So
193:06 - let's go ahead and delete our
contracts simple storage. And
193:09 - now we're just going to type
import dot slash simple storage
193:15 - dot soul. This import dot slash
simple storage dot Seoul is the
193:19 - exact same as our copy pasted
version of simple storage.
193:22 - That's all. It takes the path of
another file, it takes the path
193:27 - package or GitHub, which we'll
get to in a minute of another
193:29 - file and says, Okay, we're going
to paste that contract into the
193:34 - top of this contract here, we
actually see we go back to
193:37 - compile, we go to deploy, let's
delete our old contract, we can
193:42 - actually see storage factory dot
soul again, we can deploy it,
193:46 - click the drop down. And once
again, we can run those
193:49 - functions exactly the same.
importing our contracts like
193:52 - this is much nicer than always
copy pasting the code. This way,
193:56 - if we want to change something
in simple storage, we have one
193:58 - canonical place to go ahead and
change it instead of having to
194:01 - change it in multiple different
places. Now additionally, you'll
194:03 - notice the pragma, solidity if
we have our contracts in two
194:06 - separate files, we actually can
have different versions of
194:09 - solidity right now our storage
factory has carrot zero point
194:13 - 8.0 Which means that anything
within the 0.8 range of this
194:18 - contract is okay. But for simple
storage that sole, it says
194:22 - anything in the zero point 8.8
And above range is okay. So if
194:27 - we were to try to change the
compiler version 8.5 And then go
194:31 - ahead and compile, a remix is
going to automatically bump it
194:34 - up to a better version that is
compatible with both of them, in
194:37 - this case eight point 13. But if
we, for example, changed our
194:41 - solidity version of storage
factory to zero point 7.0 And
194:46 - then tried to compile them. We
actually end up getting an issue
194:51 - parser error source file
requires a different compiler
194:54 - version. This is because our
storage factory is saying hey,
194:58 - anything in 0.7 means is okay.
However, our simple storage is
195:03 - saying anything in the zero
point 8.8 And above is okay. So
195:07 - those two versions are not
compatible. So what we need to
195:10 - do is we need to make sure our
versions of solidity are indeed
195:13 - compatible. So let's change the
version back recompile. And now
195:17 - we're looking good again. Now
since we have this create simple
195:20 - storage contract, every single
time we call it right now, it'll
195:23 - just replace whatever is
currently in our public simple
195:26 - storage variable. Let's go ahead
and update this so that we can
195:29 - actually keep a running list of
all of our deployed simple
195:32 - storage contracts. So instead of
having this be a single
195:35 - variable, we'll make this a
simple storage array or list
195:39 - public simple storage array.
Now, whenever we create a new
195:44 - simple storage contract, instead
of saving it like this, what
195:48 - we're going to do is we're going
to save it as a memory variable
195:51 - by saying simple storage, simple
storage equals new simple
195:56 - storage. And we're going to add
this variable to our simple
196:00 - storage array. So the same way
we did it before, we're gonna do
196:04 - simple storage array dot push,
simple storage. So I should
196:11 - spell storage, right? Let's go
ahead and compile this looks
196:14 - good. We'll deploy the storage
factory deploy. Like here, we
196:19 - now have simple storage array
View button, we'll do create
196:24 - simple storage. Now we can view
the simple storage contract
196:27 - zero. Right now there's nothing
at one. But if we create another
196:31 - simple storage contract, we can
see the new simple storage
196:33 - contract address at index one.
196:38 - All right, so this is great,
196:39 - we can now keep track of all of
our simple storage deployments.
196:43 - But how do we actually interact
with them, let's say we wanted
196:45 - to be able to call the store
function on all of our simple
196:48 - storage dot souls from our
storage factory, you can think
196:52 - of the storage factory as almost
like a manager of all of our
196:55 - simple storages. That's all
let's create a new function that
196:58 - can do exactly that. So we'll
create function, and we'll call
197:01 - it S F store, which is going to
stand for storage factory store.
197:07 - And it's going to take you in
256, simple storage index, and a
197:13 - UNT 256, underscore simple
storage
197:20 - number. There'll be a public
197:23 - auction as well. Now in order
for you to interact with any
197:26 - contract, you're always going to
need two things. And we're going
197:30 - to refer to this a lot. You're
always going to need the address
197:34 - of the contract, and the ABI of
the contract. The API stands for
197:40 - Application binary interface,
the API will tell our code
197:44 - exactly how it can interact with
the contract, we'll go deeper
197:48 - into API as we move on. But if
you go to your compile tab, you
197:52 - hit compile, and things are
actually compiling. You can
197:54 - scroll down, and you can see
compilation details. And you can
197:58 - see a whole bunch of information
on your different contracts. You
198:02 - can see the name of your
contract, which for our simple
198:05 - storage contract is simple
storage, you can see a whole
198:08 - bunch of metadata, like the
compiler, the language output
198:12 - settings, all this other stuff.
You can see the exact bytecode
198:15 - and the opcodes, which we'll
talk about much later. But you
198:18 - can also see this API, this API
tells you all the different
198:22 - inputs and outputs and
everything you could do with
198:24 - this contract. For example, in
our simple storage, if we look
198:28 - at the zero with index of our
API, we have a function add
198:32 - person. If we look at one, we
see our name to favorite number,
198:36 - we looked at two we can see our
people three retrieve for store,
198:42 - it tells us all these different
ways we can actually interact
198:44 - with our contract. And the
different functions that we can
198:47 - call, we know where addresses
are, because we're storing them
198:51 - in this array here, our simple
storage array, we can also get
198:55 - the API because we're importing
simple storage dot soul when you
198:58 - compile simple storage on soul.
As you saw on the compilation
199:02 - details, whenever you compile
it, it comes prepackaged with
199:05 - the ABI, we automatically get
the ABI just by importing it
199:09 - like this. In the future, we'll
see other ways that we can
199:12 - actually get API's really
easily. So to call the store
199:15 - function on one of our
contracts, we're first going to
199:18 - need to get that contract
object. So what we can do is we
199:21 - can say simple storage variable
named simple storage. Variable
199:27 - Name simple storage of type
simple storage is going to be
199:30 - equal to a simple storage
object. And instead of doing new
199:38 - simple storage, like we did last
time, we're just going to put
199:41 - the address of this simple
storage object in here, which
199:45 - again, we can get from our
array. And in this function,
199:48 - we're passing the array index.
So we can say simple storage
199:52 - contract at address simple
storage array. At index simple
200:00 - Storage index. This bracket
notation here is how you access
200:05 - different elements of arrays. So
if we want the zeroeth element
200:08 - of our list here, simple storage
index would be zero, and we pass
200:12 - it into this bit here, then
that'll give us the address of
200:16 - our simple storage contract,
which we pass into simple
200:18 - storage here. Since this is an
array of simple storage
200:22 - contracts, we can just access
that simple storage contract
200:25 - using the index. So we would
say, simple store, Edge array at
200:32 - index underscore simple storage
index. Now we're saving the
200:40 - contract object at index simple
storage index to our simple
200:44 - storage variable. Our array here
is keeping track of the
200:47 - addresses for us. And it
automatically comes with the ABI
200:52 - is here. If this was just an
array of addresses of the
200:56 - contract objects, instead, we
would have to wrap the address
201:00 - in a simple storage object like
this. But we'll get to that much
201:04 - later. So for now, all we have
to do is this and we now have a
201:07 - simple storage contract object.
Now that we have it, we can call
201:11 - our store function on the simple
storage contract. So we'll call
201:15 - simple storage dot store. And
we'll store the simple storage
201:23 - number to it. So this
201:24 - is perfect. And if we were to
deploy this right now, though,
201:26 - we wouldn't be able to read the
store function. So let's create
201:29 - another function that can read
from the simple storage contract
201:32 - from the storage factory. So
we'll create a function called S
201:36 - F get, which stands for storage
factory get, it'll take a un 256
201:42 - underscore simple storage index.
This will be a public view
201:47 - function, since we're just going
to be reading from our simple
201:50 - storage contract. And it's going
to return a UNT 256. And we'll
201:54 - say simple storage.
201:57 - Simple Storage. Equals
202:01 - when you use this same syntax
from up here to get the contract
202:04 - simple storage array at the
simple storage index. And then
202:07 - we're going to do return,
202:10 - simple storage.re retrieve
202:16 - to get that number that we just
stored up here. And I should
202:20 - spell retrieved correctly, so we
get no issues. Perfect. So now
202:24 - we'll compile, we'll deploy JAVA
script, we're working on a fake
202:29 - account, we're going to use our
storage factory, go ahead and
202:33 - delete all the contracts we have
so far. Let's go ahead and
202:35 - deploy the drop down rate. Right
now if we do SF get at zero,
202:41 - we're going to get nothing.
Simple Storage address zero is
202:44 - going to be nothing. Let's
create a simple storage
202:47 - contract. Now it's simple
storage list, we get an address
202:52 - at zero. If we hit SF get right
now it didn't zero, we get zero.
202:57 - So let's store a value on this
contract here. So the index of
203:02 - that contract is zero. So we're
going to pass zero as a symbol
203:05 - storage index. And we're going
to save the number seven. So
203:09 - we'll go ahead and do SF store.
And if we did this, right, this
203:13 - is going to store the value
seven into this contract. So if
203:18 - we do SF get of zero now, it
does indeed return seven. If we
203:23 - do SF get one we're going to get
nothing's going to happen. And
203:27 - we're actually going to get this
revert error here. So let's
203:30 - create another simple storage
contract. Now if we do SF get
203:33 - one, we get zero, because we're
gonna get that default value.
203:37 - Let's go ahead on the simple
storage contract and index one
203:40 - will store the number 16 will
hit SF store. Now we'll do SF
203:45 - get one and we get 16. Feel free
to pause right now and play
203:49 - around with this so that you
really understand it. The quick
203:51 - recap is our storage factory
contract allows us to create
203:54 - simple storage contracts, it
then saves it to our simple
203:58 - storage array, which we can then
call different functions on, we
204:02 - can store values from our
storage factory contract. And
204:06 - then we can read values from our
storage factory contract for any
204:09 - of the simple storage contracts
that we've created. This is
204:13 - incredibly powerful, we can
additionally make these two
204:16 - functions even easier. We can
call the Retrieve function
204:20 - directly on this when we call
simple storage array. And then
204:24 - we have these brackets and add
the simple storage index. This
204:28 - returns a simple storage object.
So what we could do is we could
204:31 - actually delete this whole part
204:34 - and just do dot retrieve
204:38 - right here, and then delete this
line and say return and just
204:41 - have it be just like this. If
you go ahead and save or hit
204:44 - Compile, you'll get the green
checkmark there. We're calling
204:47 - the Retrieve function on
whatever this is. And whatever
204:51 - this is, is a simple storage
object. So perfect. We can do
204:55 - the same thing up here by
deleting this part and just
204:59 - doing dot store, underscore
simple store edge number, we
205:08 - save it. And this will work
exactly the same. Awesome, we
205:11 - now have a simple storage
contract that can store
205:13 - variables in a storage factory
contract that can be almost like
205:16 - a manager of these simple
storage contracts and deploy and
205:19 - interact with them themselves.
This is
205:21 - fantastic. Now, let's say that
205:26 - we really liked the simple
storage contract, but it doesn't
205:28 - do everything that we want it to
do. Maybe we want it so that
205:32 - whenever we actually store value
doesn't store the favorite
205:35 - number, it stores the favorite
number plus five, for some
205:39 - reason you want a contract that
that everyone's favorite number
205:41 - is five numbers bigger than what
they think it is. But you really
205:44 - like everything else that this
contract has to offer. Let's
205:47 - create this new contract. And
we'll call it extra storage.
205:51 - So we'll say extra storage dot
soul.
205:56 - And we'll create this new
contract, we're going to set it
205:58 - up the exact same way we
normally would spdx license
206:02 - identifier, gonna be MIT, we'll
give it pragma solidity. And
206:09 - we'll just do zero
206:12 - point 8.0 with the carrot. And
we'll say contract, extra
206:17 - storage, like so
206:20 - if you save or compile, you'll
get the green checkmark. So what
206:23 - can we do? Well, the first thing
we could do is we could copy
206:26 - paste all this code back into
here, and then modify our extra
206:30 - storage contract as we see fit.
This seems a little bit
206:33 - redundant. And a lot of work
though. So what's another way we
206:36 - can actually get our extra
storage contract to be like our
206:39 - simple storage contract? Well,
this is where we can do
206:42 - something called inheritance, we
can have our extra storage
206:46 - contract, do what's called a
child contract of our simple
206:50 - storage contract. And we can
have extra storage, inherit all
206:54 - the functionality of simple
storage with two lines of code.
206:59 - So first, in order for our extra
storage contract to know about
207:03 - simple storage, we once again
need to import it. So we'll say
207:06 - import dot slash, simple storage
dot soul. And we'll say our
207:12 - contract extra storage is simple
storage. And we save or compile.
207:20 - Now our extra storage contract
is going to be the exact same as
207:25 - simple storage. And it's going
to do what's called inherit all
207:28 - the functionality of simple
storage. And we can actually
207:30 - even see that, let's go ahead
and make sure this is compiled.
207:34 - And we'll go and deploy this.
And now in our deployed
207:37 - contract, we can see we have
extra storage deployed with all
207:42 - the functions that simple
storage has, if you want a
207:45 - contract to inherit all the
functionality of another
207:48 - contract, you can just import it
and say your contract is that
207:52 - other contract. Now, we can add
additional functions to our
207:56 - extra storage contract. That
will include all the
207:59 - functionality of simple storage.
Now, let's say that we inherit
208:02 - simple storage to extra storage.
However, one of the functions in
208:06 - simple storage we don't really
actually like. So if we go back
208:09 - to our simple storage contract,
our store function, all it does
208:12 - is take a favorite number, and
then assigns the global favorite
208:15 - number to whatever new number
that we give it in our extra
208:19 - storage. We want the store
function to do something
208:21 - different. We want it to add
five, to any number that we give
208:26 - it. How can we achieve this?
Well, we can do something called
208:29 - overriding the functions. And
there are two keywords that
208:32 - we're going to use. Those are
virtual, and override. Right
208:36 - now, if I were to try to
implement a store function for
208:39 - extra storage, let's see what
happens. We'll say function
208:42 - store, you went to the six
favorite number. There'll be a
208:48 - public function. And let's say
instead of just storing favorite
208:53 - number, we'll say favorite
number equals favorite number,
208:59 - plus five. If we try to compile
this right now, we'll actually
209:03 - run into two different errors.
First one is going to say
209:07 - overriding function is missing,
override specifier. If the
209:10 - parent contract, which in our
case is simple storage has that
209:13 - same function, we need to tell
solidity that we're going to
209:17 - override this store function and
instead we're going to use this
209:22 - store function. But
additionally, we get this other
209:25 - error saying trying to override
non virtual function. Did you
209:28 - forget to add virtual in order
for a function to be overridable
209:33 - you need to add the virtual
keyword to the store function.
209:37 - Now it can be overridable.
However, if we save and compile,
209:41 - we still have this issue
overriding function is missing
209:44 - override specifier. And then all
we need to do is add override to
209:48 - restore function. Now if we save
everything compiles correctly,
209:52 - let's go ahead and deploy this.
Let's delete our old contracts.
209:56 - JavaScript VM right account.
Great we're going to choose
209:59 - extra store Reg, let's go ahead
and deploy. And here's our extra
210:02 - storage contract. Right now if
we retrieve, we get zero.
210:06 - Previously, our store function
would store the exact number.
210:09 - However, if I were to store
five, it'll store five, plus
210:13 - five. So we should have 10
stored here. Let's go ahead call
210:17 - store looks like that one
through, and we'll hit retrieved
210:21 - now. And we do indeed see 10 is
in here. So this is how we do
210:25 - inheritance, and we override
210:27 - functions. And that's it. For
this
210:32 - section, you've just learned a
ton of incredibly powerful
210:35 - solidity for having multiple
files. Let's do a quick overview
210:39 - of what we learned, we learned
that we can actually deploy
210:42 - contracts from other contracts
using the new keyword, we
210:46 - learned that we can actually
import other contracts into our
210:50 - contracts and into our code
using the Import keyword. And
210:53 - the import keyword is the same
as copying pasting that file to
210:56 - the location of the import line,
we learned that we can interact
210:59 - with other contracts. As long as
we have the ABI and address. We
211:03 - didn't learn too much about the
ABI. But we'll learn more later,
211:06 - we learned that if we want to
create a child contract and
211:09 - inherit the functionality of
some other contract, we can do
211:12 - something called inheritance.
And the way to inherit
211:15 - functionality is using the is
keyword and saying our contract
211:19 - is some other contract. However,
if we want to change from the
211:22 - functionality of the parent
contract, we have to override
211:26 - that function. And additionally,
we have to set the function we
211:29 - want to override to virtual now
we can have our own store
211:32 - function, do whatever we want it
to do. That is the end of this
211:36 - lesson. Once again, give
yourself a huge round of
211:38 - applause a pat on the back for
making it this far. And for
211:41 - finishing this section. You're
getting more and more advanced
211:44 - facility so quickly, so be sure
to celebrate the little wins by
211:48 - getting some ice cream, maybe
going for a walk or tweeting
211:50 - about or posting on Reddit.
Congratulations, you have
211:53 - completed this section.
211:57 - All right, everybody. Welcome
back. We are now headed into
212:00 - Lesson four remix Funmi. And of
course, all the code can be
212:06 - found on the GitHub repository
associated with this course.
212:09 - We're going to be working with
two contracts here, one of them
212:12 - is fundament outsole. And then
one of them is price converted
212:15 - outsole Funmi dot Sol is going
to be a contract that allows
212:19 - people to actually fund a
collective good. So people can
212:22 - send Aetherium send Aetherium,
or polygon or Avalanche or
212:26 - Phantom, or whatever blockchain
native token into this contract,
212:30 - and some owner of the contract
can then withdraw those funds
212:33 - and do whatever they want. After
deploying this to a test net, we
212:36 - can see the list of functions
this contract has, this will
212:39 - have two red buttons, which are
used to notate to payable
212:44 - functions in fund in our fund
function. And in our withdrawal
212:49 - function, withdraw allows users
to withdraw the funding and fund
212:54 - allows users to send money to
the contract, what we can do is
212:58 - we can send some value along
with our transaction. When we
213:02 - call this fund function, then
what we can do is we can
213:05 - actually fund this contract with
a certain amount of eath, or way
213:08 - by pasting some value into the
way value section. And then
213:12 - hitting fund, we will now have
sent money into our deployed
213:16 - contract. And we can see a list
of the funders and a mapping of
213:20 - those addresses and how much
they've actually sent into the
213:23 - contract, we can then withdraw
the funds out of the contract.
213:27 - With a special exception with
only the person who deployed
213:30 - this contract can actually
withdraw the funds back out.
213:33 - Once the funds are withdrawn,
the amount of all the funds is
213:35 - reset back to zero. Are you
excited? Well, you should be.
213:38 - And if you've finished the
section, you've completed most
213:41 - of the basics of solidity, and
you'll be ready to start making
213:44 - even more powerful smart
contracts, we'll be using
213:46 - channeling price feeds to
actually set the value of how
213:49 - much these people should be able
to fund in USD as opposed to
213:53 - just in terms of ether, we're
gonna go over a lot of advanced
213:56 - sections here. And I'll let you
know what parts might be a
213:58 - little bit harder to digest. So
you don't have to spend your
214:01 - entire time trying to figure out
exactly what's going on. Be sure
214:03 - to use the GitHub repo to your
advantage here and the
214:05 - discussions tab to stay
connected with other people
214:08 - taking this lesson. Alright,
let's jump in. So at this point,
214:14 - in remix, you'll have a couple
of contracts here, simple
214:17 - storage, storage, factory extra
storage, maybe you refreshed
214:20 - remix, and these have gone away.
And in the case, make sure that
214:23 - you just don't have any of those
tabs open, we're going to create
214:26 - a new contract called funding.
So let's go ahead and start
214:31 - creating our funding contract.
Again, we want it to be able to
214:35 - get funds from users and
withdraw funds and set a minimum
214:41 - funding value in USD. This is
what we're going to get our
214:45 - contract to do. So first, let's
set it up spdx license I tend to
214:51 - fire MIT do pragma solidity do
caret zero point 8.8. And we'll
215:00 - do contract bunbee. Awesome. And
we'll compile, see if things
215:05 - look good. And they do. Great.
Let's keep going. So before we
215:09 - actually embark on creating all
of our functions here, let's
215:11 - just add the different functions
that we're going to implement.
215:14 - So we want a function fund for
people to actually send money
215:18 - to, we want a function withdraw,
or the owner of this contract to
215:23 - actually withdraw the funds that
different funders actually give
215:25 - us. And that's pretty much it.
These are the two main functions
215:29 - that we want this contract to
do, we will be implementing more
215:32 - functions to help facilitate
these two functions. But let's
215:36 - get started by looking at fund.
let's comment out withdrawal for
215:39 - now. And let's just start with
fun. So we want anybody to be
215:42 - able to call this fun function.
So we'll make this public. So as
215:46 - we mentioned, we want to be able
to set a minimum font amount in
215:52 - USD. So there's a lot of things
to think about here. First thing
215:55 - we probably want to think about
is how do we send eath to this
215:58 - contract, whenever we create a
transaction on the on any of
216:02 - these EVM blockchains, there's
this value field that we can set
216:06 - value represents how much
Aetherium we're going to be
216:08 - sending with our transactions.
For example, when we transferred
216:12 - Aetherium. between our different
accounts, we were actually
216:15 - populating this value parameter
with different amounts of
216:19 - Aetherium. In fact, every single
transaction that we send, will
216:22 - have these fields, it'll have a
nonce or the transaction count
216:26 - the account the gas price, the
gas limit that we've seen on
216:30 - ether scan a to aka the address
that the transaction is sent to
216:35 - a value which is going to be
this amount that we're talking
216:37 - about. They'll also have data
which is going to be what we
216:40 - send if we make a function call
or deploy contract, and then
216:44 - we'll have this v r s
components. We're not really
216:47 - going to go over these v r and s
because this is that
216:50 - cryptographic magic that's
happening when a transaction is
216:53 - signed, but just know that
that's it Now, for sending
216:56 - value, we can populate some of
these fields, the gas limit, for
217:00 - example, was populated to 21,000
data is going to be empty. And
217:04 - then that two is going to be the
address of the transaction we
217:07 - want to send to, for a function
call, we can also still populate
217:12 - the way that we want to send. So
we can call a function and send
217:16 - a value at the same time in
remix has a little drop down
217:19 - here for way way Feeny and
ether, we're gonna ignore Feeny
217:23 - for now. But of course, we have
our way, great and ether. Again,
217:26 - we're one ether is worth this
much way. And this much way, the
217:30 - first thing we need to do in
order to make a function payable
217:33 - with Aetherium, or any other
native blockchain currency is we
217:36 - need to mark the function as
payable. It's this payable
217:39 - keyword that makes our font
function red, as opposed to
217:43 - having it normal orange, just
like how our wallet can hold
217:46 - funds, contract addresses can
hold funds as well, since every
217:51 - time you deploy a contract, they
get a contract address, it's
217:54 - nearly the exact same as a
wallet address. So both wallets
217:59 - and contracts can hold native
blockchain token like Aetherium.
218:04 - And you'll see that when we
deploy this later on in the
218:07 - lesson, that actually will gain
a balance of Aetherium. Now that
218:11 - we have it payable, we can
access this value attribute by
218:15 - using one of the global keywords
in solidity with message dot
218:18 - value to get how much value
somebody is sending. You use
218:22 - message dot value in your
function. Now let's say we want
218:25 - to set our message add value to
a certain value of Aetherium.
218:29 - Let's say we wanted it to be
let's say we wanted people to
218:32 - send at least one whole ether
with all the transactions. Or
218:37 - put another way, if they sent
Aetherium, they would need to
218:40 - send at least one Aetherium. How
would we implement that? Well,
218:43 - we could do something called
require, we would say we want to
218:46 - require the message dot value is
greater than one e 18. There's a
218:53 - couple of things to unpack here.
One, e 18 is equal to one times
218:59 - 10 raised to the 18th, which is
also equal to
219:04 - 112345 678-910-1234 5678. This
is the value in way of one
219:12 - Aetherium this much way is one
eath. So if we wanted the
219:16 - message dot value to be at least
one eath, or one polygon or
219:20 - whatever ranch etc, we would set
it like this require message on
219:23 - value is greater than one. This
require keyword is a checker it
219:28 - says hey, is message dot value
greater than one. If not, it's
219:33 - going to revert, it's going to
do what's called revert with an
219:35 - error message. And we can say
didn't send enough, we're gonna
219:40 - try deploying this on a
JavaScript VM, deploy Funmi,
219:44 - we'll hit Deploy, look at Funmi
we see this fun button is now
219:47 - red. If we call Funmi right now,
and we look at the console, you
219:52 - can see we actually get an error
here, call it again, we get an
219:55 - error, we get an error here, we
know that the air is going to be
219:59 - this didn't send enough. So what
we need to do is we need to send
220:04 - at least one ether with this fun
transaction, in order for this
220:07 - require statement to be
fulfilled. So back up in the
220:11 - value section, we can change
this value to one. So that's
220:15 - gonna be one ether, or this much
way or this much way. Now we can
220:20 - hit fund oh actually needs to be
greater than one.
220:23 - So let's send to for example.
Now we'll scroll down. And now
220:28 - we'll hit fund. And we see that
that actually passes the require
220:32 - statement says if our first
section is false, then go ahead
220:36 - and revert with this error. What
is reverting? Revert can be a
220:39 - little bit confusing, so I
wouldn't let this section hold
220:42 - you back. If it's a little bit
confusing. Revert is when it
220:46 - undos any actions that happened
before and send the remaining
220:49 - gas back. So what does that
actually look like? Well, let's
220:53 - say for example, we had a un
256. Public number. And in our
220:59 - fund function, we said number
equals five. If we were to go
221:04 - ahead and deploy this, let's
delete our old contract.
221:07 - deployed this new contract or
number right now is zero. But if
221:11 - we were to call our fund
function number gets set to
221:14 - five. However, if we call a fund
and this require isn't met, this
221:19 - transaction would revert an
undue setting number to five. So
221:23 - let's go ahead and look at our
logs here. We'll keep value zero
221:27 - so that our fun function
reverts. We'll call fund will
221:31 - see that this transaction failed
because this require end up
221:35 - reverting and number is still
zero. So then the question
221:38 - becomes, did we actually spend
gas Yes, we spent gas to change
221:43 - number to five and then any
remaining gas we would get
221:48 - returned by this require for
example, if we had a ton of
221:52 - computation here, it On a
computation here, we would have
221:56 - need to send a ton of gas with
our fun function. But all the
222:00 - extra gas that we send, after
this require gets returned the
222:05 - original user after it gets
reverted right here, if reverts
222:08 - are a little bit confusing for
you here, don't worry too much
222:10 - about it, we'll go over it in
future modules. All you need to
222:13 - know right now is that when you
do a require statement, if this
222:16 - first section isn't met, the
transaction will be canceled,
222:20 - and any prior work will be
undone, and it'll send an error
222:23 - message. Cool. Let's delete this
number for now. And we'll delete
222:27 - it from the global scope.
There's actually another way to
222:30 - do these reverts, which we'll go
over
222:32 - later in this contract. So what
we've done so far is great.
222:38 - However, we're checking message
dot value in terms of Aetherium,
222:43 - we're looking for one whole
Aetherium instead of $50, we
222:48 - want to check that message add
value is greater than some
222:52 - number like $50. Let's go ahead
and first set the minimum USD
222:56 - value we want people to send
along with the fund function, we
223:00 - can do that at the top of our
contract, we can say you went to
223:04 - 56 public minimum USD equals 50.
Now we have some place to check
223:14 - for minimum USD, we're going to
update this minimum USD to make
223:18 - it more gas efficient and a
little bit. Now that we've set
223:21 - our minimum USD, we want to be
able to require the message that
223:24 - value is greater than or let's
say greater than or equal to the
223:28 - minimum USD. But minimum USD is
in terms of USD and value is in
223:34 - terms of Aetherium. So how do we
convert Aetherium to USD, this
223:41 - is where Oracle's and chainlink
are going to come into play. The
223:44 - USD value of Aetherium is
something that we've assigned
223:47 - outside of the blockchain to
Aetherium, or any other layer
223:51 - one currency or any other native
smart contract platform
223:54 - currency. So in order to get
this value that is outside the
223:57 - blockchain, we have to use a
decentralized Oracle network to
224:00 - get the price of one ether in
terms of USD. So before we can
224:05 - continue on here, let's learn a
little bit more about the
224:08 - architecture of these
decentralized Oracle networks
224:11 - and the different solutions that
they have. So that we can create
224:13 - this Funmi contract in the most
advanced way possible, as we've
224:17 - talked about blockchains are
deterministic systems, which
224:20 - means that they themselves can't
actually interact with real
224:23 - world data and events. They
don't know what the value of an
224:26 - Aetherium is, they don't know
what random numbers are. They
224:29 - don't know if it's sunny
outside, they don't know the
224:31 - temperature, they don't know
who's president, they don't know
224:33 - any of this information. These
blockchains also can't do any
224:37 - external computation. Maybe you
have some amazing artificial
224:40 - intelligence model that you want
to integrate with a smart
224:43 - contract. smart contracts by
themselves can't do anything
224:46 - with that. As we've mentioned,
this is because blockchains are
224:49 - deterministic by design. This is
so that all the nodes can reach
224:52 - consensus. If you start adding
variable data or random data, or
224:57 - values that returned from an API
call, different nodes could get
225:00 - different results, and they
would never be able to reach a
225:03 - consensus. This is known as the
smart contract connectivity
225:06 - problem, or the Oracle problem.
And this is bad news, because we
225:10 - want our smart contracts to be
able to replace traditional
225:13 - agreements. And traditional
agreements need data and they
225:16 - need to interact with the real
world. So this is where
225:19 - chainlink and blockchain,
Oracle's come into place. A
225:22 - blockchain Oracle is going to be
any device that interacts with
225:25 - the often world to provide
external data or computation to
225:28 - smart contracts. However, the
whole story doesn't even in
225:31 - there. If we use a centralized
Oracle, we are reintroducing a
225:36 - point of failure. We've done all
this work to make our logic
225:39 - layer decentralized. But if we
get our data through a
225:42 - centralized node or through a
centralized API, we decide we
225:46 - want to make the API call
ourselves. We are reintroducing
225:49 - these trust assumptions that
we've worked so hard to get rid
225:52 - of, we're essentially ruining
the entire purpose of building a
225:55 - smart contract. So we don't want
to get our data or do external
225:59 - computation through centralized
nodes. Those are bad news. chain
226:03 - link is the solution here. chain
link is a decentralized Oracle
226:06 - network for bringing data and
external computation into our
226:10 - smart contracts. As we mentioned
before, this gives rise to these
226:13 - hybrid smart contracts, which
combined on chain and off chain
226:17 - to make incredibly feature rich,
powerful applications. chain
226:21 - link is a modular, decentralized
Oracle network that can be
226:23 - customized to deliver any data
or do any external computation
226:27 - that you like. So for example, a
lot of people say, Oh, I can
226:31 - just make an HTTPS call to some
API, and we'll be good to go.
226:36 - The blockchain nodes can't make
these HTTPS calls, because they
226:40 - wouldn't be able to reach
consensus. If they called the
226:42 - node at different times, or they
did something else. All the
226:45 - consensus would be broken. So
instead, we need a decentralized
226:49 - network of chain link Oracle's
to do this, and then in the
226:52 - transaction, this network of
nodes will work Turn the data to
226:56 - our smart contracts for us. Now
chainlink networks can be
226:59 - completely customized to bring
any data or any external
227:02 - computation that you want.
However, doing the customization
227:06 - can be a little bit extra work,
there are a ton of chainlink
227:09 - features that come out of the
box completely decentralized,
227:12 - ready to plug and play into your
smart contract applications.
227:15 - What are those features, the
first one is going to be
227:17 - channeling data feeds, and
that's the one we're actually
227:19 - going to be using for
application here. Channeling
227:21 - data feeds currently at the time
of recording are powering over
227:24 - $50 billion. In the defy world,
the way they work is a network
227:29 - of chain link nodes gets data
from different exchanges and
227:32 - data providers and brings that
data through a network of
227:36 - decentralized chain like notes,
the chain link nodes use a
227:39 - median to figure out what the
actual price of the asset is,
227:42 - and then deliver that in a
single transaction to what's
227:45 - called a reference contract, a
price feed contract or a data
227:48 - contract on chain that other
smart contracts can use. And
227:52 - then those smart contracts use
that pricing information to
227:55 - power their defy application, we
can see an example. We can see
227:58 - an example at data dot chain dot
link. And you can change
228:02 - networks, you can change price
feeds, you can change a whole
228:05 - bunch of different information
to see some of those popular
228:07 - price feeds. Let's look at eath
USD for example. On eath USD, we
228:11 - can see this whole network of
independent chain link node
228:14 - operators that are each getting
different answers for the price
228:17 - of eth USD, they're getting
aggregated by the network and
228:20 - then delivered on chain, we can
see how often they're updated.
228:24 - These ones are updated 4.5
deviation threshold or a few
228:28 - hour heartbeat, whichever one
hits. First, we can see when the
228:31 - last update was we can see the
number of Oracle responses etc,
228:35 - we can see the contract address
directly on chain, we can even
228:39 - look at the contract on ether
scan, we can see some of the
228:43 - history, we can see all the
responses of the different
228:46 - Oracle's. And then at the
bottom, we can see the different
228:49 - users and sponsors, keeping this
network up. Similar to
228:54 - transaction gas, whenever a node
operator delivers data to a
228:58 - smart contract, the chain link
node operators are paid a little
229:01 - bit of Oracle gas in the chain
link token. Right now these
229:04 - users of the protocol are
sponsoring keeping these feeds
229:07 - up and are paying the Oracle gas
associated with delivering this
229:10 - data on chain. Here's an
illustration of what the current
229:13 - model of these data feeds look
like a network of these chain
229:15 - link nodes, each reaches out and
gets the information about an
229:19 - asset and then signs the data
with their own private key in a
229:23 - single transaction, then, one
node will deliver all the data
229:27 - with all the different
signatures to a reference
229:29 - contract. If that node doesn't
deliver the data, another node
229:32 - will send it instead. Reputation
is incredibly important when
229:35 - your chain link node operator if
you miss data updates, if you
229:37 - forget to send transactions,
you'll probably be quickly
229:40 - kicked off these networks and
have no chance of making any
229:42 - more money in the future. These
data feeds are used by some of
229:45 - the largest protocols in the
space, such as synthetics, sushi
229:49 - swap compound, and Avi, with
several billion dollars each, we
229:53 - can take a look at an example
over at Doc's dot chain dot link
229:57 - work with EVM contracts, we're
going to hit EVM chains, scroll
230:00 - down to data feeds. We'll scroll
down to the solidity section.
230:04 - And we can see an example of an
entire contract that uses and
230:08 - reads from one of these trending
price feeds. We can even open
230:12 - this up and remix and work with
it and remix. It looks like this
230:17 - example is reading from a price
feed on COVID. The reason we're
230:20 - actually going to use a test net
to see this work is that there's
230:23 - a set of chain link nodes
monitoring the test network.
230:25 - Just to show you exactly how
this works out. Once we get
230:28 - deeper into the course, we'll
show you how to actually run
230:30 - tests and work with chain link
nodes without actually being on
230:34 - a test net, which will make your
development much faster. But I
230:36 - highly recommend walking through
this section along with me so
230:40 - that you can see firsthand how
this actually works. So let's go
230:44 - ahead and faucets dot chain dot
link slash COVID. We're going to
230:47 - switch to the COVID network,
we're going to get some COVID
230:51 - eath. But remember, look at the
network flag and use whatever
230:55 - network is in the documentation.
So to get some COVID, we're
230:59 - going to come to the faucet,
we're going to turn off test
231:01 - link, we'll just stay with eath
I'm not a robot,
231:06 - and then send request. Once our
COVID Aetherium has reached our
231:10 - wallet, we can go ahead and
close we can take a look in our
231:14 - wallet and see that we do indeed
have 0.1 eath on Kelvin. Now
231:18 - let's go back to our remix,
we'll compile this contract, go
231:22 - and deploy this on injected web
three. And again, the reason
231:25 - we're going to use injected web
three instead of JavaScript VM
231:28 - is that there's no network of
chain link nodes watching our
231:32 - little fake JavaScript VM. There
are a network of chain link
231:35 - nodes watching the test net. So
we'll scroll down. We'll switch
231:39 - contract to the price consumer V
three, and we'll hit Deploy and
231:43 - a mass will pop up and after a
brief delay, we can see our
231:47 - price feed consumer down here
and we can hit Get the latest
231:50 - price which shows us the latest
price of Aetherium in terms of
231:54 - USD you may be wondering why the
number looks so weird. That
231:57 - seems like a really large number
for the price of Aetherium in
232:00 - terms of USD, and this is
because decimals don't actually
232:03 - work so well in solidity, and
we'll get to that in a little
232:06 - bit. There's a decimals flag
associated with this price feed
232:09 - address, that tells us how many
decimals to include with this
232:13 - price. It's also in the
documentation. However, I know
232:16 - that this one has eight
decimals. So this is saying the
232:19 - value of Aetherium right now is
$3,262. It may of course be
232:24 - different when you go ahead and
try this. Now there's a number
232:27 - of things that happened in this
contract that I'll explain in
232:30 - our Funmi example. But if you
want to take a look now and see
232:32 - if you can figure out what's
going on, I recommend you do so.
232:35 - Price feeds are one of the most
powerful out of the box
232:37 - decentralized features, you can
use your smart contract to level
232:41 - them up, especially for
decentralized finance. If you're
232:44 - looking for different addresses
of different price feeds, you
232:46 - can check the contract addresses
section of the documentation,
232:49 - choose the network that you
want, and then scroll down and
232:53 - look some of the different
addresses of the different price
232:55 - feeds. For example, this address
will give you the price of one
232:59 - inch token in terms of
Aetherium. This address will
233:02 - give you the price of the Apple
stock in terms of USD, and so on
233:07 - and so forth. The next
decentralized application right
233:10 - out of the box is going to be
channeling VRF or channeling
233:13 - verifiable random dysfunction.
Once we do our lottery example a
233:17 - little bit later, we'll talk
about how randomness can be
233:20 - manipulated in blockchain.
blockchains are deterministic
233:22 - systems, which by definition
means that they can't have
233:25 - randomness. If you can determine
what a random number is, it's
233:28 - not really random anymore, is
it? So we need to wait to get a
233:31 - provably random number by
looking outside of the
233:34 - blockchain and Oracle's are
perfectly positioned to do
233:37 - exactly that. chainlink
verifiable randomness function
233:40 - is a way to get provably a
random number into our smart
233:42 - contract to guarantee fairness
and guarantee randomness of
233:46 - applications. Many protocols
like pool together x infinity,
233:50 - ether cards, avocado cheese and
more use channeling VRF for
233:54 - lotteries, randomizing NF T's
for gaming and for more, we're
233:58 - going to do an example of
channeling VRF in a later
234:01 - section. Once we get to the
lottery section, if you want to
234:03 - see if you can play with the
randomness yourself right now, I
234:06 - recommend you go into Doc's
chain link EVM chains, and
234:09 - scroll down to get a random
number. And this will teach you
234:12 - how to get a provably random
number into your applications.
234:15 - The next decentralized out of
the box feature of chain link is
234:18 - chain like keepers, which is
decentralized event driven
234:22 - execution. As we've seen, in
order to kick off some type of
234:25 - transaction, somebody needs to
spend the gas and somebody needs
234:29 - to sit down and hit the go
button or hit the transact
234:32 - button or hit the sun. But this
is obviously a centralized
234:34 - vector. If you have a
decentralized application that
234:37 - needs to run at specific times,
or after specific events are
234:40 - triggered. Channeling keepers
are the solution to this
234:42 - channeling keepers are chain
link nodes that listen to a
234:45 - registration contract for
different events that you
234:48 - specify to fire. Maybe you say
every 10 minutes, you want to do
234:52 - something or once a week do
something or if the price of
234:55 - some acid hits some number, or
maybe a liquidity pool is at a
234:59 - certain level, whatever event
that you want to code, you
235:02 - absolutely can the chain link
nodes constantly listen for
235:05 - these triggers to happen and
check the different contracts
235:08 - for these triggers. Once a
trigger returns true, the chain
235:12 - link nodes will then perform
whatever action that you tell
235:15 - the chain link nodes to do,
we're also not going to go over
235:18 - the chain link keepers examples
right now, because we're going
235:21 - to get to them in a later
module. However, if you want to
235:23 - try them out, go to Doc's
touching that link slash
235:26 - Aetherium. Going and go to
making compatible contracts and
235:30 - feel free to read the
documentation. Try it out
235:32 - yourself. The last out of the
box feature of chain link is the
235:35 - most customizable, but also the
hardest to get correct end to
235:38 - end reliability is the ultimate
promise of our smart contracts.
235:41 - And we want and need them to be
able to do anything, we want to
235:45 - be able to take any input and
get any output making HTTP GET
235:50 - HTTP POST request is an easy way
to customize our chain link
235:53 - nodes to be able to do anything.
Remember how we talked about
235:56 - making API calls that blockchain
nodes themselves can do that?
236:00 - Well, chain link nodes can do
that chain link nodes can make
236:04 - direct requests to any API that
you specify. In order to do
236:07 - this, you both have to choose
the chain link node and the URL
236:11 - slash data to send the request
to this is a little bit trickier
236:14 - than chain link VRF keepers or
price feeds because you then
236:18 - have to be responsible for
creating the chain link network
236:21 - that gets data from many
different chain link nodes and
236:23 - many different data providers.
236:25 - But let's look at an example in
remix anyways. For this section,
236:29 - feel free to just watch it since
we are working with a test net
236:31 - here. And test nets, as we've
seen, can take a little bit of
236:34 - time. As long as you're familiar
with what this process looks
236:36 - like. That's good enough. You
don't actually have to try it if
236:39 - you don't want to. So we'll open
up and remix will read through.
236:43 - It looks like this example is on
the COVID network. So we'll go
236:46 - ahead and compile API consumer.
We're gonna go ahead and deploy
236:50 - on the injected web three, we're
going to make sure that we're
236:53 - back on the COVID test network.
We're going to scroll down. And
236:57 - we're going to change the
contract to the API consumer.
236:59 - And we're going to go ahead and
hit Deploy, we're going to
237:02 - deploy this contract to the
COVID. Test net. And now we can
237:06 - call this function called
Request volume data to actually
237:09 - make an API call. Now, like I
mentioned before, whenever we
237:12 - request data from a chain link
node, we have to pay a little
237:15 - bit of Oracle gas, or link
token, in order to pay some link
237:20 - token, we're going to need to
have link token in our API
237:23 - consumer contract. This is
what's known as the basic
237:26 - request and receive model to get
link token, we go back to our
237:29 - faucet, and this time, we'll
select 10 test link for our
237:32 - contract. Let's go ahead and
verify that we're human. And
237:35 - we'll hit Send Request. This
time, instead of sending us
237:38 - Aetherium. They're sending us 10
test link, which is what's known
237:42 - as an ERC 20 token. Or more
accurately, in ERC 677 We'll get
237:47 - to understanding that a little
bit later, we can see the asset
237:50 - in our Metamask. By importing
the token, in order to get the
237:54 - token, we're going to come back
to the documentation. And we're
237:57 - going to look up link token
contracts like that, we're going
238:02 - to go to the network that we
just got the tokens on, which
238:05 - for us was COVID. We're going to
copy this address, we're gonna
238:10 - go to Metamask, hit import
tokens, paste that address, and
238:14 - hit add custom token, and then
import tokens. And now we can
238:19 - see in our account one, we both
have Aetherium and 10. Link, now
238:24 - that we have our link or Oracle
gas, we're going to send it to
238:27 - our API consumer, we're going to
copy the address of the API
238:31 - consumer, open up our meta mask,
we're gonna hit send, paste the
238:36 - address of our contract, switch
the asset to link. For now we'll
238:41 - just send 0.2 link. We'll hit
next, next. And we'll hit
238:46 - Confirm. And we'll wait for this
transaction to go through. I
238:49 - chose 0.2 Link, because in this
contract, there's a fee
238:54 - character, which tells us how
much making an API call for this
238:59 - is going to cost. This one is
actually 0.1 link, I send 0.2.
239:03 - Just in case, we want to make
that API call twice. Everything
239:05 - that's going on in this function
will explain in a little bit
239:08 - later section. But for now, I
just want to show you what it
239:10 - looks like to do is, once we
send the link to our contract,
239:13 - we can first check to see what
the volume is volume is zero, we
239:18 - want to get the volume of the
last 24 hours of Aetherium
239:21 - asset, we're going to be calling
this API which has a ton of raw
239:25 - data, including one in specific
called volume over the last 24
239:29 - hours, which can be this number
right here. Say we wanted to get
239:31 - this into our contract from this
API, we're going to make an HTTP
239:35 - GET call to this API. And what's
going to happen is we're going
239:39 - to make the request in one
transaction. And in a second
239:43 - transaction, the chain link node
is gonna return the value and
239:46 - store it in this volume variable
in the global scope. So let's go
239:51 - ahead and hit request volume
data Metamask gonna pop up,
239:55 - we're going to go ahead and hit
Confirm. And you'll notice right
239:57 - away volume doesn't update. This
is again, because we actually
240:01 - need to wait two transactions,
we're sending a transaction for
240:05 - the request. And then in a
second transaction, the chain
240:08 - link node is actually going to
respond. And after a slight
240:11 - delay, the chain link node has
indeed responded with the result
240:14 - of making that API call back to
our contract. We'll go over this
240:18 - process a little bit more in
depth in later sections. The
240:20 - reason that I wanted to show you
specifically the API calls, is
240:24 - because we're going to show you
a real life example of how to
240:27 - use chain link VRF and chain the
keepers in a later lesson.
240:32 - Now I know we've already gone
over a ton. So let's do a quick
240:35 - review. In order to send
Aetherium or whatever native
240:39 - blockchain token with a function
need to mark it as payable. If
240:43 - you need something in your
contract to happen, and you want
240:46 - the whole transaction to fail.
If that doesn't happen, you can
240:49 - use a require statement. To get
the Aetherium or native
240:52 - blockchain token value of a
transaction, you can use the
240:55 - global keyword message dot
value. chain link is a
240:59 - technology for getting external
data and doing external
241:02 - computation in a decentralized
context for our smart contracts.
241:06 - Channeling data feeds or price
feeds are ways to read pricing
241:09 - information or other pieces of
data from the real world that's
241:12 - already aggregated and
decentralized for us, channeling
241:15 - VRF is a way to get provably
random numbers from the real
241:19 - world into our smart contracts.
Channeling keepers are a way to
241:22 - do decentralized event driven
computation. We can set some
241:26 - trigger say if this trigger hits
do something and we get to
241:29 - define what the trigger is and
what to do something is
241:32 - channeling any API's is the
ultimate customization of
241:36 - channeling nodes and allows us
to connect to anything on the
241:39 - planet. To make this one
production ready. We have to do
241:42 - the most work because it doesn't
come already with a
241:44 - decentralized Oracle network,
like chaining the keepers and
241:47 - price feeds. We'll learn more
about these channeling services
241:50 - as we continue in this course.
Now in order for us to figure
241:56 - out if our message dot value is
actually greater than the
242:00 - minimum USD that we set, we
actually have to convert our
242:03 - message dot value from its layer
one slash Aetherium to the USD
242:09 - equivalent. So how are we
actually going to do that? Well,
242:12 - first, we're gonna need to get
the price of Aetherium, or
242:15 - Phantom, or Avalanche or
whatever layer, one blockchain
242:18 - that we're working with. So
let's create a function to get
242:21 - that price to get that
conversion rate. So we'll do
242:24 - function, get price, and this is
going to be the function that we
242:29 - use to get the price of the room
in terms of USD, so we can
242:33 - convert our message dot value to
USD. And then we're also going
242:37 - to do a function called Get
conversion rate. These are both
242:45 - going to be public functions, so
that we can go ahead and call
242:47 - them and test them and do
whatever we want with them. So
242:50 - in order to get the price, we're
going to have to use one of
242:52 - these chain link data feeds to
get the pricing information. And
242:56 - we can look right here at this
contract to see what using one
243:00 - of these channeling price feeds
looks like. What we're actually
243:03 - doing when we're interacting
with this channeling price feed
243:06 - is we're actually reading from
one of these contracts, there's
243:09 - a contract out there called the
aggregator contract that has a
243:12 - function called latest round
data, which returns a whole
243:15 - bunch of data. But namely, this
int price. And this in price is
243:20 - what we are interested in. Let's
look at our get price function
243:24 - and figure out how do we
actually call this since this is
243:27 - an instance of us interacting
with a contract outside of our
243:30 - project, we're going to need two
things. What are those two
243:34 - things,
243:35 - we're going to need the ABI of
the contract, and also the
243:39 - address of the contract. So the
address of the contract is going
243:43 - to be easy, we can get the
address of the contract from the
243:46 - contract address this section of
the chain link data feeds. Let's
243:50 - scroll on down to bank B. And we
can find the eath USD address on
243:56 - Rigby and we'll create this
contract so that it works on
243:59 - Rinkeby. So we're going to grab
this address, we're going to
244:01 - copy it. And we're going to move
back to our to our code here.
244:05 - And we're going to paste the
address here. So great, we have
244:08 - the address. Now we have the
address of the other contract
244:10 - that we don't want to interact.
Now, how do we get the ABI?
244:13 - Well, what we did before was
simple storage was we imported
244:16 - the entire contract into our
code here. That's something that
244:19 - we could do. But that's actually
a lot of code. So what's
244:22 - something that we could do
instead, remember, if we're
244:25 - looking at remix, and we look at
one of the contracts that we
244:28 - compiled before, the ABI is
really just kind of this list of
244:33 - the different functions and
interactions you can have with a
244:36 - contract. The ABI itself doesn't
actually need to include any of
244:39 - the logic, it just needs to
include, hey, here are the
244:42 - different functions that you can
call, for example, in this
244:45 - contract, we can call fund, we
have get conversion rate, we
244:48 - have get price, they're not
implemented yet, but they will
244:50 - be eventually now there
technically is another way to
244:53 - interact with contracts without
the API. But for now, we're just
244:57 - going to ignore that. So how can
we get the API, there's a
245:00 - concept in solidity called an
interface. And let's look at an
245:03 - example of an interface. If we
go to github.com/smart, contract
245:07 - kits, chainlink, we can see a
number of different contracts in
245:11 - the chainlink repository, we can
go to contracts, src, V 0.8,
245:17 - interfaces, and we'll go to
aggregator v3 interface, dot
245:22 - soul. And if we look at the
solidity in here, we can see a
245:25 - whole bunch of function
declarations, but none of the
245:28 - logic is actually implemented in
this. This is what's known as an
245:32 - interface. If we compile this,
we'll actually get the ABI of a
245:36 - contract, because it defines all
the different ways we can
245:40 - interact with the contract. It
doesn't actually say, what these
245:43 - functions do, which is fine,
though, because we don't need to
245:46 - know what the functions actually
do, those are going to be stored
245:49 - in the contract. So what we can
do is we can grab this interface
245:54 - from the code and paste it into
our remix. Now hold on, if
245:58 - you're following along, you
don't have to copy paste this
246:00 - with me, because I'm going to
show you an easier way in just a
246:02 - second. So for now, feel free to
go ahead and just watch. But
246:05 - once we have this interface
aggregator v3 interface, we can
246:09 - now use this to make API calls.
So now we could say, aggregator
246:14 - v3 interface at this address.
And the combination of these
246:19 - two, give us that aggregator v3
contract with whatever code is
246:24 - here. If at this contract
address is aggregator v3
246:27 - interfaces valid, we can do
something like dot version.
246:31 - Let's look at this interface. Is
there a version function? There
246:34 - sure is. So that means we can
call the version function on
246:39 - this contract. So let's actually
go ahead and copy this into a
246:42 - different section. I'm going to
create a new function called Get
246:45 - version just to illustrate this.
I'm going to be public. It's
246:50 - going to be a view and it's
going to return the UN 256 and
246:55 - We're gonna split it up into two
steps here. We're gonna say
246:58 - aggregate tour, v3 interface,
price feed. So we're creating a
247:04 - variable of type aggregator v3
interface equals aggregator v3
247:10 - interface at this address. And
then we're going to return price
247:18 - feed that version. Now I'm going
to go ahead and deploy this
247:22 - contract to Rigby just to show
you what this git version is
247:25 - going to return. But you don't
have to follow along here if you
247:28 - don't want because again, we're
working with the test net, you
247:30 - can just watch if you'd like for
this section, we're going to
247:33 - test a little bit more sparse.
Since we're going to be mainly
247:36 - using the test net, since we're
going to be working with an
247:38 - actual chain link Oracle
network, once you move over to
247:41 - hard hat, and with JavaScript,
all this testing locally will be
247:45 - a lot easier and a lot faster,
you're more than welcome to go
247:47 - ahead and fiddle and try and
test a lot of this stuff as we
247:50 - go along. But just know that it
might take a little bit longer
247:53 - to do some of the testing on the
test net,
247:55 - let's delete that last funding
contract, we're going to deploy
247:58 - this one, we're going to scroll
up, we're going to switch to
248:00 - injected web three, we're going
to switch from COVID to rink B.
248:05 - And the reason we want to make
sure we're on rink beam is
248:08 - because this address is specific
to rink B, the contract that
248:12 - we're looking to interact with
might not be at this address on
248:15 - every single chain, we want to
make sure we're on the rink B
248:17 - chain for this, because of some
other contract is there on the
248:20 - different chain, this version
function obviously won't exist,
248:23 - and this function could error.
So let's go ahead, we're gonna
248:26 - find me, we're going to deploy
this to the rink V chain. Again,
248:31 - you don't have to follow along
with me here, you can just
248:33 - watch. And once that contract
has been deployed, we now have a
248:36 - view function called Get
version. And we can see it's
248:39 - returning the variable for
showing us that this is the
248:42 - fourth version of a price feed.
So this is a really easy way for
248:47 - us to interact with contracts
that exist. Outside of our
248:50 - project, we use one of these
interfaces, which can get
248:53 - compiled down to the API, and
then combine that ABI with the
248:57 - address to call a function. As
we work with these interfaces
249:00 - more and more, they'll start to
make more and more sense. So if
249:03 - it's a little confusing to you
right now, don't get
249:05 - discouraged, the more you work
with it, the easier it will
249:08 - become. Now, though, now that we
know how to call these functions
249:13 - in here, we can start working
with this interface. However, as
249:17 - you know, if we have a whole
bunch of interfaces, we're gonna
249:19 - have to stick a whole bunch of
interfaces at the top of our
249:21 - code, which looks pretty ugly.
What's a better way for us to do
249:25 - this? Well, before we used
import, right, we imported from
249:29 - simple storage. That's all for
this one, what we could do is we
249:34 - could import from an array gay
Tore v3 interface. That's all,
249:39 - we can go ahead and create a new
contract with this aggregator v3
249:42 - interface. Or what we can do is
we can import this directly from
249:46 - GitHub. If we go back to the
documentation of these chainlink
249:50 - data feeds go to using data
feeds, we scroll down, we see at
249:53 - the top, we have this import
statement, import at chain link
249:57 - slash contracts slash SFC visa
right interfaces aggregator v3
250:01 - interface, this, this import is
has the same path setup as the
250:07 - GitHub repository for the chain
link code, instead of us
250:10 - directly adding all the code
right into our remix, what we
250:14 - can do instead is we can import
directly from GitHub, or what's
250:18 - called an NPM package. Remix is
smart enough to know that at
250:22 - chain link slash contracts, is
referring to the NPM package at
250:26 - chain link slash contracts,
we'll talk about NPM, a little
250:29 - bit in the future, it's what's
known as a package manager, and
250:32 - can keep versions of different
contracts for us to directly
250:35 - import into our code bases at
chain link slash contracts is
250:39 - created directly from the
chainlink GitHub repository. So
250:43 - remix downloads this code from
NPM, which is created from this
250:47 - GitHub. So now we know that if
we import at chain link slash
250:50 - contracts, src, V 0.8 interfaces
aggregator v3 interface dot
250:54 - soul, this is the same as if we
had just stuck this whole
250:59 - contract right at the top of our
funding contract, which makes
251:02 - our code look a lot nicer. And
now we have this aggregator v3
251:05 - interface that we can work with.
Okay, great. So now that we have
251:11 - a minimalistic interface, which
will give us the API, how do we
251:14 - actually go ahead and get the
price here? Well, documentation
251:17 - has a good example, if you want
to play with it and try to
251:19 - reverse engineer it as well.
Here's how we're going to do it.
251:21 - In our code. We're going to
create an aggregator v3
251:25 - interface object called price
feed an aggregator v3 variable
251:32 - called price feed, which is
going to equal to aggregator v3
251:36 - interface contract at address
this address exactly the same as
251:41 - what we're doing down here.
We're assuming a contract at
251:45 - this address is going to have
all the functionality of this
251:48 - aggregator v3 interface, which
again, means it has this
251:51 - decimals function, this
description function version,
251:54 - get round data. And the
important one latest round data,
251:57 - which has the latest price at
this answer piece, what we can
252:01 - do now is we can call that
latest round data function on
252:04 - the price feed. So we'll say
price feed dot latest round
252:09 - data. Now if we look at the
interface, we see that this
252:12 - latest round data actually
doesn't return one variable, it
252:16 - returns a whole bunch of
different variables. And that's
252:20 - what we're going to return in
our contract. So we're going to
252:22 - put these parentheses, and we're
going to say, you went at round
252:27 - ID, we can even look right at
the documentation to see what
252:30 - else it returns int price, you
went,
252:36 - you went started out, you went
timestamp. And then you went ad,
252:45 - answered and round. Now there's
a lot of code here. Since this
252:51 - function returns so many
different variables, we have to
252:54 - set something up to capture
them. However, all we care about
252:57 - is price. We don't care about
round Id started at timestamp or
253:01 - answered in round. So what we
can do is just remove them and
253:03 - just leave the commas.
253:10 - Now we have int price equals
price feed that latest round
253:15 - data. The reason that price is
an int 256. And not a un 256 is
253:19 - because some prices or some data
feeds could be negative here, so
253:23 - that it's an int 256. So it can
stay flexible. Now that we have
253:26 - the price, this is going to be
price of eath in terms of USD.
253:32 - And we saw an example of this
before, it was around 3000. And
253:35 - it returned this number because
solidity doesn't work with
253:39 - decimals for a number of
reasons. But we just need to
253:41 - know that there are eight
decimal places associated with
253:44 - this price feed. If you want to
double check how many decimals
253:47 - there are, this contract has a
decimal function that you can
253:50 - call as well, that will tell you
exactly how many decimals are in
253:53 - this price feed. Now as we know,
message dot value is going to
253:57 - have 18 decimal places. Why does
it have 18 decimal places? Well,
254:00 - because one ether is equal to
1-234-567-8910 12345678 Is this
254:07 - massive number in way which has
18 zeros, which is equivalent to
254:12 - 1.12345 678-910-1234 5678. So we
want these to have the same
254:20 - decimal places, right? Because
right now this has eight, this
254:22 - is 18. They're different units
right now. So to get them to
254:26 - match up, all we need to do is
return price times one, ie 10,
254:34 - or one raised to the 10th, which
is equal to 1123456789 10.
254:40 - Message dot value, though, is
going to be a UNT 256. And right
254:45 - now, price is an interval at
six. So why did we convert this
254:49 - value from n into 56. To a human
to 56? Well, we can do what's
254:54 - called typecasting, all we need
to do is add you into 56. And
254:58 - wrap this whole thing up between
these two parentheses, you can't
255:01 - typecast anything. But there are
some values like into 56 and you
255:06 - into 56, that can be easily
converted between the two. Now
255:09 - of course, since we're not
modifying any state with this
255:12 - get price function, we can make
this view and say it returns
255:17 - that you went to 36. And if we
save and compile, we go ahead
255:21 - and we get that checkmark. Now
math can be a little bit tricky.
255:23 - The first couple times you do it
in solidity. But the more you do
255:26 - it, the easier it becomes. And
in the future, we can always
255:28 - reference a function like this
to figure out okay, here's the
255:32 - easiest way for me to get this
number. Awesome. So now we have
255:35 - a get price function, which is
going to return a un 256, which
255:39 - is going to be the price of
Aetherium. In terms of USD, all
255:42 - we need to do is convert the
message dot value from
255:46 - Aetherium. To terms of dollars,
let's create this get conversion
255:51 - rate function. So this one,
we're going to take an input
255:54 - parameter of un 256 of eath
amount, it's going to be a
255:58 - public view function. And it's
going to return you went to 56,
256:04 - we're going to pass it some eath
amount. And on the other side,
256:08 - we're going to get how much that
eath is worth in terms of USD.
256:11 - So we're going to do a u
intuity. Six eath price equals
256:16 - get price. So first, we're going
to call our get price function
256:21 - that we just created to get the
price of Aetherium. Then we're
256:24 - going to do u and 256 eath
amount in USD equals eath price
256:32 - times eath amount, and then
we're going to divide it by 118.
256:37 - When you're doing multiplication
and division math in solidity,
256:40 - you always want to multiply and
add first and then go ahead and
256:44 - divide since eath price and eath
amount both have 18 additional
256:48 - decimal places if we were to
just let them rock without this,
256:52 - they would have an additional 36
zeros tax tacked onto the end.
256:56 - So we need to divide by one EA
team. Now when we get to the
256:58 - hard hat sections of this course
testing all this math is going
257:01 - to be a lot easier. And if
you're really struggling with
257:04 - some of the math bits right now,
I wouldn't let that slow you
257:06 - down. Because once we get to
heart, it's going to become a
257:08 - lot easier to actually test this
than working on a test net. And
257:12 - this eath amount in terms of USD
is the number that we're looking
257:15 - for. So we can just go ahead and
return eath amount in USD, CSB
257:20 - returns here, and boom, now we
have a good conversion rate
257:24 - function to walk you through the
math real quick. Let's say the
257:26 - eath price is going to be
$3,000. So it's going to be
257:29 - 3000. But it's going to have an
additional 18 zeros tacked on
257:33 - the end, it matches the message
dot value way units. And let's
257:37 - say for example, we send one
eath or 112345 678-910-1234 5678
257:45 - eath into this contract, one
eath should equal $3,000. So to
257:51 - get the price, we're going to
now do the eath price, which is
257:54 - 3000 times the eath amount,
which is this one, and then
257:59 - divide by one raised to the
18th. So method out we'll do
258:02 - 3123 1-234-567-8910 12345678
times we'd
258:09 - 1001 2345678 1-234-567-8910
times 112345678 1-234-567-8910.
258:20 - And now we divide that by
112345678 1-234-567-8910, which
258:27 - equals 2.9. Mmm, II 21, which
the calculator kind of messed up
258:32 - them a little bit, but 2.9, not
2.99, ie 21 means this has 21
258:38 - decimal places. So it'd be
2.1 234-567-8910 1-234-567-8910
258:46 - one, or
1-234-567-8910 12345678 2900 I
258:53 - 9.99 and a nine. And this is
actually exactly the reason why
258:58 - we don't do decimal math in
solidity, our calculator saw
259:01 - that massive number was having a
hard time getting it. So it
259:04 - ended up rounding that number to
2.999. And nine, when we work
259:07 - exclusively with whole numbers
in solidity, we don't have a
259:11 - chance of losing that precision.
And in solidity, this is going
259:14 - to return exactly $3,000, which
is correct one Aetherium at
259:19 - $3,000 per Aetherium is going to
be $3,000. And like I said,
259:24 - since we're building this
contract, assuming we're going
259:26 - to be working on this test net,
we're not going to test this
259:29 - function on the test net,
because we're going to have to
259:31 - wait for that transaction to go
through. If you want to go ahead
259:34 - and deploy this and play around
with it yourself, you're more
259:36 - than welcome to Okay, great, now
we have a function called Get
259:39 - conversion rate that we can use
on our fund function to make
259:43 - sure we've sent enough message
dot value in our fund. So what
259:46 - we can do now is all we need to
do is to get conversion rate of
259:50 - message dot value needs to be
greater than the minimum USD. Of
259:53 - course, right now our minimum
USD is just in terms of 50. And
259:57 - we know that conversion rate is
going to return it with 18 zeros
260:01 - to represent the decimal places,
our minimum USD amount needs to
260:05 - be upgraded to 10 to 50 times
one e 18. Or again, one times
260:12 - 10, raise the 18th, I'm going to
deploy this to a test net just
260:16 - to demonstrate it. But again,
you don't have to if you don't
260:19 - want to wait for this. So I'm
gonna go ahead and deploy this
260:22 - confirm. And now we have this
funny contract. If I don't say
260:25 - anything in value, and hit the
fun button, we're gonna get this
260:28 - gas estimation error failed.
This is kind of a blanket error,
260:32 - basically saying, Hey, you can
go ahead and send this
260:34 - transaction if you want, it's
highly likely that it's not
260:36 - going to work. And the reason
that remix knows that it's
260:39 - probably not going to work is
because it can see this require
260:42 - and simulate the transaction and
say, Hey, you didn't send enough
260:44 - money with this. However, even
if we send some money, like 5000
260:49 - way, it'll still give us this
error. Because that's not
260:52 - enough. Let's do the calculation
right now based on what the
260:55 - price of eath is. So we can
actually go to data dot chain
260:59 - that link, we look and see
approximately what the price is.
261:02 - So it looks like the price of
Aetherium right now is about
261:04 - $3,000. And this might be
different for you depending on
261:07 - when you do that. So if the
price of Aetherium is $3,000,
261:10 - and our minimum is at least 50.
We could do 50 divided by
261:15 - 3000 0.016 eath should be
approximately enough. So if we
261:21 - go to our Aetherium converter,
and we do 0.016, we'll get how
261:27 - much that is in way, let's do
0.02 Just to make sure that
261:33 - we're going to be over the
amount. So we'll paste that in.
261:36 - We'll change this to way. And
now if I hit the fun button,
261:40 - instead of us getting that error
popping up, it's going to
261:43 - actually go ahead and let us do
the fun function and we could
261:46 - confirm it and it wouldn't fail.
I'm going to reject it for now
261:49 - just because I don't really feel
like waiting for the transaction
261:51 - to go through. But great. We've
confirmed that our get
261:54 - conversion rate is one working
as intended, awesome, great
261:57 - work.
262:00 - So what's the next bit of this
funding contract that we want to
262:02 - do? Well, when people actually
send money to this contract, we
262:06 - want to keep track of all the
people who send us money. So
262:09 - let's create some data
structures. To keep track. Let's
262:12 - create an array of addresses
called funders. And we'll keep
262:16 - adding all the funders who send
money to us. So we'll say an
262:20 - address array, or an address
list. We'll make it public
262:25 - funders. And anytime somebody
sends us money, and this
262:29 - actually does indeed go through,
we'll add that funded server
262:32 - list. So we'll say funders dot
push message dot sender, like
262:37 - message dot value. Message dot
sender is an always available
262:41 - global keyword message dot value
stands for how much Aetherium or
262:45 - how much native blockchain
currency is sent. Message dot
262:48 - sender is the address of whoever
calls the font function. So if
262:53 - we're on Rigby message dot
sender is going to be equal to
262:56 - whatever address is calling that
function. Since our address is
263:00 - sending the ether, we're going
to add our address to this
263:04 - funders list. This way we can
keep track of all the wonderful
263:07 - donators who are donating to our
contract, then maybe we won't
263:11 - even make a mapping of addresses
to you and 250 sixes of
263:17 - addresses to how much money each
one of these people have
263:20 - actually sent. So we'll do
address to you and 256 public
263:26 - address to amount funded. And
when somebody funds our contract
263:31 - will say address to amount
funded of message dot sender
263:36 - equals message dot value. Now we
have a function where people can
263:40 - fund our contract. And we can
set a value in terms of USD and
263:44 - we keep track of the different
funders who actually fund our
263:47 - contract. This is fantastic. Now
I know we've gone over a lot of
263:54 - really intense math and intense
stuff here. So so let's do a
263:57 - quick refresher of what we've
learned so far. Whenever we work
264:00 - with a contract, we always need
the API and the address when
264:03 - compiled an interface gives us
that minimalistic API to
264:08 - interact with contracts outside
of our project. When you combine
264:12 - these compiled interfaces with
an address, we can call the
264:15 - functions on that interface on
that contract. chain link. data
264:19 - feeds are a decentralized way to
get information about the real
264:22 - world. In this case, we're
getting the price of Aetherium
264:25 - in terms of USD from a
decentralized collective of
264:29 - chain link nodes. When working
with math and solidity. Decimals
264:32 - don't work. So we need to keep
that in mind when doing any type
264:35 - of math in solidity. And we need
to make sure we always have the
264:38 - correct units, so that our math
makes sense. Message dot value,
264:42 - and message dot sender, our
globally available variables
264:46 - were message dot sender
represents the sender of the
264:49 - message or transaction. And
message dot value represents the
264:52 - number of ways sent with the
message. There's a whole bunch
264:55 - of different special variables
and functions that we can access
264:58 - at any time. And these are
available in the solidity
265:00 - documentation. Alright, great,
we've got a great way that we
265:06 - can actually start funding our
contract. But our code looks a
265:09 - little bit messy, we've got a
couple of different functions
265:11 - for getting the price and
working with these prices, is
265:14 - there a way to make this math a
lot easier to use, this is where
265:17 - we're going to introduce the
concept of a library. So what is
265:21 - a library, I definitely
recommend checking out solidity
265:23 - by example.org, as you're going
along with this course, as well,
265:27 - they've got some fantastic
examples. One of such example is
265:30 - going to be about libraries,
libraries are similar to
265:33 - contracts. But you can't declare
any state variables and you
265:35 - can't send ether. We can also
use libraries to add more
265:39 - functionality to different
values. What do I mean by that?
265:43 - Well, what we can do actually is
we can have get conversion rate
265:47 - be a function of a un 256. So we
could do something like Messer
265:53 - dot value dot get convert John,
conversion rate. And we can add
265:59 - functions as if you went to 36
was an object or a struct or a
266:03 - contract that we actually
created. So how do we do this?
266:06 - Well, let's create a new
contract in our contracts folder
266:10 - and create a new file. We're
going to call it price
266:12 - converter, dot salt. And our
price converted outsole is going
266:17 - to be a library that we're going
to attach to a un 256. So how do
266:21 - you actually create a library
and what is a library? Well, a
266:24 - library is going to be really,
really similar to a smart
266:27 - contract. It's gonna start with
spdx license identifier. My
266:34 - team, we're gonna give it a
pragma, solidity zero point 8.0.
266:40 - And instead of typing contract
for the name of the contract,
266:43 - we're going to do library for
the name of the library. We're
266:46 - going to call it price
converter. Now libraries can't
266:49 - have any state variables and
they also can't send ether and
266:52 - all the functions in a library
are going to be in there.
266:55 - kernel. So what we can do is we
can go back to fund me dot soul,
266:59 - we can grab get price, get
version and get conversion rate,
267:04 - copy them all, delete them from
Funmi dot soul and paste them
267:08 - into our library. And of course,
since we're using aggregator v3
267:11 - interface in here, we can also
copy the import from Funmi. And
267:17 - since we're not using the
aggregate of three interface and
267:19 - our contract anymore, and we're
using our price converter, we
267:23 - can paste it into our price
converter. Now, if we compile
267:26 - price converted at soul, we see
that it actually passes. Now all
267:30 - the functions inside of our
library need to be internal. And
267:33 - we're gonna make this library
price converter different
267:36 - functions, we can call on you
activity six, for example, we're
267:40 - going to be able to do message
dot value dot get conversion
267:42 - rate, we're going to directly be
able to get the conversion rate
267:46 - of a value of a U and 256 as if
that was a function for it the
267:50 - whole time. So first, let's make
this internal. Let's make get
267:54 - conversion rate internal. And
we'll make good version
267:57 - internal. Now that we have this
library price converter back in
268:00 - our Funmi, we can now import
this price converter and attach
268:04 - it to you in 256. So we'll do
import that slash price
268:08 - converter, dot soul.
268:11 - And in Funmi, we'll do using
price converter for UNT 256. Of
268:19 - course, if we compile our Funmi.
Now, this line is getting an
268:23 - issue because saying hey, get
conversion rate isn't defined.
268:26 - Now in our library, the first
variable that gets passed to the
268:31 - function is going to be the
object that it's called on
268:33 - itself. So in Funmi dot soul,
let's go ahead and comment out
268:37 - this line for now. If we do
message dot value dot get
268:40 - conversion rate, this is
secretly the same as we did get
268:44 - conversion rate or message dot
value in our price converter
268:47 - library, the message dot value
is going to be passed as the
268:50 - input parameter to get
conversion rate, forget price
268:53 - and get version we don't really
care about the number. So we're
268:56 - just going to leave it blank for
now. So instead of require get
269:00 - conversion rate of message dot
value, we can now do message dot
269:05 - value dot get conversion rate.
And compile that you'll see that
269:11 - here we're not passing a
variable, even though our get
269:14 - conversion rate function says
hey, I'm expecting a variable.
269:17 - Again, the reason for this is,
is this message add value is
269:20 - considered the first parameter
for any of these library
269:23 - functions. And that's how it
works. If we wanted another
269:26 - variable in here, like you went
to 56, something else. Now we
269:32 - would want to pass something
else in here 123. And this 123
269:37 - would get assigned to this
something else. But we're going
269:39 - to delete that for now. Okay,
great. And in doing that, we've
269:44 - minimized our Funmi contract a
lot by moving a lot of that math
269:48 - and price conversion stuff into
our price converter library dot
269:52 - Sol. One of the most common
libraries that was used for the
269:57 - longest time was this library
called Safe math dot Sol. And
270:02 - you'll probably see it a lot of
different places, we're gonna go
270:05 - off on a quick little tangent
here and teach you about safe
270:08 - math. So let's close Funmi close
price converter. And let's
270:11 - create a new file called Safe
math tester. That's all. And
270:17 - let's start with some basic
stuff in here. Safe math was all
270:20 - over the place before version
0.8 of solidity. And now it's
270:24 - almost in no contracts. What
happened, why is safe math no
270:28 - longer used as much? Well, let's
create a sample contract. This
270:32 - is a section that you don't have
to follow along if you don't
270:34 - want to code along with me. But
if you want to you absolutely
270:38 - still can. This is going to be a
contract we are going to deploy
270:40 - on a JavaScript virtual machine,
we can use any version of
270:44 - solidity before version 0.8 of
solidity. So for example, we use
270:48 - pragma, carrot, zero, point 6.0.
And we'll create contract safe
270:54 - math tester, dot Sol. Now if I
create a you int eight, I set it
271:00 - to public big number. And I set
this to 255 Oops safe math
271:06 - tester. Let's go ahead and
compile safe math tester with
271:11 - zero point 6.7 pragma, solidity,
the maximum size of a Yewande
271:17 - eight is going to be 255. This
is going to be the biggest
271:21 - number that we can fit in the
new int eight. And if I were to
271:24 - deploy this to a JavaScript VM
or even a test network, safe
271:29 - math tester, let's go ahead to
play up. If I hit big number,
271:34 - we're gonna get 255. Well, what
happens if I create a function
271:39 - called ADD? That sets big number
equal to big number plus one?
271:46 - Let's save that. Delete that old
contract and deploy. All right
271:50 - now big numbers 255 What happens
when we add one two? big number.
271:56 - When 255 is the max size a, UNT
eight can be? Well, let's hit
272:01 - add. Now let's check what big
number is. Big number gets reset
272:06 - to zero. So what's going on?
Well, prior to version 0.8, of
272:10 - solidity, unsigned integers and
integers ran on this concept of
272:14 - being unchecked, which means
that if you passed the upper
272:18 - limit of a number, it would just
wrap around and start back from
272:22 - the lowest number it could be.
So if I call add a whole bunch
272:25 - more times, and hit big number,
now let's say if I were to hit
272:28 - this add button a ton more times
and get it back to two and a 55.
272:33 - It would then continue to wrap
over to zero. So one of the most
272:36 - popular libraries that was out
there was this safe math
272:39 - library, which would basically
check to make sure that you
272:43 - weren't wrapping around a un 256
or an intuitive six, basically,
272:47 - it was a way to say, hey, you've
reached the max this number can
272:50 - be and now your transaction is
going to fail. If we switch this
272:54 - to 0.8, of solidity, delete the
old contract, go switch this to
273:00 - 0.8. We'll go ahead and compile
it. And now we deploy this to
273:05 - JavaScript VM.
273:07 - If I hit big number, we get to
under 55. But if we hit Add, it
273:11 - actually fails. And we still get
to under 55. In version 0.8, in
273:16 - solidity, they added this bit,
where it automatically checks to
273:19 - make sure if you're going to do
what's called overflow or
273:22 - underflow on a variable, we can
actually revert back to the
273:26 - unchecked version by using an
unchecked keyword. So if we wrap
273:30 - this big number equals big
number plus one in this
273:33 - unchecked bracket, let's delete
our old contract will compile
273:38 - will redeploy. We had big
numbers to 55. Now we hit add,
273:42 - we hit big number again, it
reverted back to zero. So that's
273:47 - a little bit more about safe
math, checked and unchecked. So
273:50 - in version 0.76, and below this
code that you see in front of
273:54 - you, is going to be the exact
same as this code in 0.8. And
274:00 - above with this unchecked
keyword. Now you might be
274:02 - thinking in newer versions of
solidity, why would I use this
274:06 - unchecked keyword? Well, you'll
find out later that this
274:10 - unchecked keyword makes your
code a little bit more gas
274:14 - efficient. So if you're
absolutely positive that your
274:16 - math is never going to reach the
top or bottom limits of a
274:19 - number, that it might make sense
for you to use the unchecked
274:22 - keyword. Let's head back over to
our Funmi contract, where we are
274:26 - now using the price converter
library that we just created.
274:31 - Alright, great. So now we've got
a pretty minimalistic contract
274:34 - here for actually doing the
funding. And we have all of our
274:37 - math for getting conversion
rates done in our library price
274:42 - converter, which we're going to
import at the top of Funmi.
274:45 - Cool. So at this point, we've
got our fun method. Awesome. And
274:49 - so we can allow anybody to go
ahead and fund this contract and
274:53 - send this contract Aetherium, or
any native blockchain currency
274:58 - to this contract. Well, now what
do we want to do? Well, once all
275:01 - the funders have gone ahead and
funded, we're going to want the
275:04 - project to be able to withdraw
the funds out of this contract.
275:08 - So they can actually go ahead
and use those funds to buy
275:12 - things for this project. So
let's go ahead and create a
275:16 - withdrawal function. So we'll
create a function withdraw. And
275:20 - we'll make this public. Since
we're going to be withdrawing
275:23 - all the funds out of this
contract, we probably also want
275:26 - to reset our funders array, and
our address to amount funded.
275:31 - Since we'll be withdrawing all
the funds, those amounts should
275:35 - go back down to zero. So let's
go ahead and loop through the
275:39 - funders array and update our
mapping object so that each of
275:42 - these funders now has zero,
because in just a second, we're
275:46 - going to withdraw all the money
from them. So to do this, we're
275:51 - going to use something called a
for loop. So what is a for loop?
275:54 - A for loop is a way to loop
through some type of index
275:57 - object or loop through some
range of numbers or just do a
276:01 - task a certain amount of times
repeating. So for example, let's
276:05 - say we have an array or list.
And on that list, we have 1234.
276:12 - If we wanted to get all of the
elements in this array, or in
276:16 - this list, okay, 1234. How do we
get all the elements in this
276:22 - list? Well, we would use a for
loop to loop through each one of
276:28 - these objects. So at zero with
index would be one at the first
276:33 - index would be two, and at the
second index would be three, at
276:37 - the last index would be four. So
we would loop through the
276:40 - indexes zero through three to
get all these elements. Or maybe
276:45 - another example is if this was
A, B, C, D, A is at the zero
276:51 - with index B is at the first
index sees the second Indy's at
276:55 - the third and we will loop zero
through three. To get to each
276:59 - one of these elements, we're
gonna do that exact same thing.
277:02 - But with the funders array. So
how do we actually do that?
277:06 - Well, we first start with the
for keyword, the for keyword
277:11 - says, Okay, we're about to start
a loop. And inside of these
277:14 - parentheses, we define how we
want to loop through it. Also
277:18 - backslash star, and star
backslash is sort of like
277:21 - brackets for comments. Anything
in between these two will be a
277:26 - comment. So in a for loop,
first, we give it the starting
277:29 - index, then we give it the
ending index, and then we give
277:34 - it the step amount. For example,
maybe we want to start with
277:39 - zero, we want to go to 10. And
we want to go up by one each
277:43 - time. So we would go
01 234-567-8910. Or maybe we
277:47 - start at zero, we want to end at
10. And we go up by two each
277:51 - time. So we'd go 02468 10. Or
maybe we want to go from zero to
277:57 - five, we want to go from two to
five, with a step of one, we'd
278:02 - go 2345, etc. So this is what's
going to go inside of this four
278:08 - bit here. So for our starting
index, and let me even just put
278:12 - this above so that you can
reference it. So our starting
278:14 - index is going to be you in to
VT six variable, and we're going
278:17 - to call it funder index. And
we're going to start with
278:21 - thunder index being equal to
zero. So we're starting with
278:25 - zero here. And we're going to
end with the length of our
278:30 - funders array, since we want to
loop through all of the funders.
278:33 - So we're going to say, funder
index needs to be less than
278:40 - funders dot length. So our
ending index is going to be
278:44 - whenever funders index is no
longer less than funders dot
278:49 - length. And then finally, we're
gonna say funder index equals
278:54 - funder index, plus one, which
means that every time the code
279:00 - inside of this loop finishes,
we're going to increase funder
279:03 - index by one. That's how we go
from zero to one to two to three
279:07 - to four to five, etc. Another
way you can type funder index
279:11 - equals funder index plus one is
you can just do funder index
279:15 - plus plus, this plus plus syntax
means funder index equals itself
279:21 - plus one. So let's start looping
through our funders array to
279:25 - access the the zero with element
or the first element, we're
279:28 - going to say, funders of funder
index. So we're saying we want
279:34 - to access the zero with element
of our funders object. And this
279:38 - is going to return an address
for us to use, we're gonna go
279:41 - ahead and say address under
equals funders at the funder
279:48 - index. So now we have this
funder address. And we want to
279:52 - use this to reset our mapping.
So we're going to say, address
279:58 - to amount funded at at the
funder key is now equal to zero.
280:07 - Because remember, in fund we
update the amount. Whenever we
280:13 - fund the contract, when we
withdraw the money from the
280:17 - contract, we're going to reset
it back to zero. Now let's walk
280:21 - through this funder index starts
from zero. So we're going to get
280:25 - the zero with funder, we're
going to grab that funder at the
280:29 - zero with index and we're going
to reset the address to male
280:32 - funded of that funder to zero,
then this for loop is going to
280:36 - update by one, it's going to
move from zero to one, it's
280:40 - going to check then if funder
index is less than the length,
280:44 - let's say funders has 10 people
in it. If funders has 10 people
280:47 - in it, it'll still be less. So
now funder links will be one
280:51 - address funder will equal
funders of one now instead of
280:55 - zero, and we'll grab that
address, and we'll reset that
280:59 - addresses about funded to zero,
then we'll continue to two to
281:03 - three to four all the way up to
the length of our funders array.
281:07 - And this is how we can loop
through our objects. So saying
281:10 - this middle one is the ending
index isn't exactly right, since
281:14 - we're really checking for a
boolean to see if this is still
281:17 - true, but hopefully you get the
idea. So we've reset the
281:21 - balances of the mapping.
However, we still haven't done
281:24 - two things, we still need to
reset the array to make the
281:28 - funders a blank array. And then
we also need to actually
281:33 - withdraw the funds. Since when
we funded this, we sent message
281:39 - dot value along with calling
this fund function. However, we
281:45 - didn't actually withdraw the
funds. So to reset the array, we
281:48 - could loop through it and delete
objects from this address array.
281:54 - Or we could Just totally refresh
281:57 - this variable. So instead of
looping through the array and
282:03 - deleting objects, we're just
going to say funders equals a
282:08 - new address array, we're going
to completely reset the array by
282:13 - saying this font is variable now
equals a brand new address array
282:19 - with zero objects in it to
start, if we were to put a one
282:23 - here, this would be there'll be
one element to start in the
282:26 - array, two would be two, three
would be three, etc, we're just
282:30 - going to start it as a
completely blank new array. So
282:43 - great, we've gone ahead and
reset the array. But how do we
282:46 - actually now with draw funds
from this contract? How do we
282:50 - send the funds back to whomever
is calling this now to actually
282:55 - send ether or send native
blockchain currency, there are
282:59 - actually three different ways to
do this, we're going to look at
283:02 - all three, and say what the
differences between the three of
283:06 - them are, the three different
ways are going to be transfer,
283:10 - send, and call. Let's go ahead
and start with transfer. Since
283:15 - transfer is the simplest and at
surface level makes the most
283:19 - sense to us. So if we want to
transfer the funds to whomever
283:23 - is calling this withdrawal
function, we would do we would
283:27 - say message dot sender, dot
transfer. And then we'd get the
283:32 - balance of our contract here by
saying address this, this
283:39 - keyword refers to this whole
contract dot balance, and we can
283:44 - get the native blockchain
currency or the Aetherium
283:46 - currency balance of this address
like this. And we can just do
283:49 - that only thing that we need to
do is we need to cast we need to
283:53 - typecast message dot sender from
an address type to a payable
284:00 - address type. So message dot
sender is of type address.
284:08 - Whereas payable, message that
sender is of type, payable
284:14 - address, and in solidity in
order to send the native
284:17 - blockchain token like Aetherium,
you can only work with payable
284:21 - addresses. To do that, we just
wrap it in this payable type
284:25 - caster. So this is the first way
that we actually send Aetherium
284:29 - or send tokens from different
contracts to each other, we wrap
284:33 - the address that we want to send
it in, in this payable keyword,
284:37 - we do dot transfer, and then we
say exactly how much we want to
284:41 - transfer. But there are some
issues with transfer. Here we
284:45 - are on solidity by example, for
sending ether, which, again is a
284:50 - fantastic resource to refer to,
if you get lost, the method that
284:54 - we just looked at was this
transfer method. Now we saw way
284:59 - earlier in the course, that if I
sent Aetherium, from one address
285:04 - to another, it cost about 2100
gas or 2100. Gas, our transfer
285:10 - function is capped at 2300 gas.
And if more gas is used, it
285:16 - throws an error. The next one
that we're using is going to be
285:19 - sent which is also capped at
2300 gas. And if it fails, it'll
285:24 - return a Boolean. So with
transfer, if this line fails,
285:28 - it'll air and revert the
transaction with send, it won't
285:32 - air, it'll return a boolean of
whether or not it was
285:36 - successful. So using send will
do payable message that sender
285:42 - that send address this balance.
But we don't want to finish our
285:50 - call here. If this were to fail,
the contract wouldn't revert the
285:54 - transaction, and we just want to
get our money sent. So we want
285:58 - to do Boolean send success
equals this whole bit here. And
286:05 - then we want to require success.
And if this send fails will
286:11 - throw an error saying sin
failed.
286:15 - This way, if this fails, we will
still revert by adding our
286:20 - require statement here. Transfer
automatically reverts if the
286:23 - transfer fails, send will only
revert the transaction if we add
286:28 - this require statement here. So
great. What's the third way that
286:32 - we can actually send Etherium or
native currency wallets with
286:36 - this call command. Now call is
going to be one of the first
286:40 - lower level commands that we
actually use in our solidity
286:43 - code, because this call function
is actually incredibly powerful.
286:48 - And we can use it to call
virtually any function in all of
286:53 - Aetherium without even having to
Have the API we'll learn the
286:57 - advanced ways to use this call
much later. For now, we're just
287:00 - going to learn how to use it to
send Aetherium, or your native
287:03 - blockchain currency call is
going to look very similar to
287:07 - send, we're going to do payable,
message dot sender, dot call.
287:14 - And this is where we will put
any function information or any
287:18 - information about the function,
we want to call on some other
287:21 - contract, we actually don't want
to call a function. So we're
287:24 - going to leave this blank, we
can show that we're leaving it
287:27 - blank by just putting in these
two quotes here, we instead want
287:30 - to use this like a transaction.
And as we saw in our deployment,
287:34 - there's always this message dot
value bid, we're going to use
287:38 - this call function as if it's a
regular transaction, and we can
287:41 - add stuff like message dot
value. So in here, we're going
287:45 - to add these squiggly brackets.
And we're going to say, value
287:52 - address this dot balance, this
call function returns actually
288:00 - two variables. And when a
function returns two variables,
288:03 - we can show that by placing them
into parentheses on the left
288:07 - hand side, the two variables, it
returns are going to be a
288:10 - Boolean, that we're going to
call call success. And also a
288:15 - bytes object called data
returned, since call allows us
288:20 - to actually call different
functions. If that function
288:23 - returns some data or returns
value, we're going to save that
288:28 - in the data returned variable.
It also returns call success,
288:32 - where if the function was
successfully called this will be
288:36 - true. If not, this will be
false. And since bytes objects
288:41 - are arrays, data returns needs
to be in memory. Now for our
288:46 - code here, we're actually not
calling a function, so we don't
288:49 - really care about data returned.
So similar to what we saw with
288:53 - the price contract, we can just
go ahead and delete that and
288:57 - leave the comma to tell solidity
Yeah, we know this function
289:00 - returns two variables, but we
only care about one. And then
289:03 - similar to the centerpiece
above, we're going to do require
289:08 - cost access call failed, meaning
that we're requiring cost
289:12 - accesses true. Otherwise, we'll
revert with an error that says
289:16 - call failed. Now of learning the
difference between these three
289:19 - is a little complicated for you
right now. Don't let that slow
289:22 - you down. Feel free to come back
to this after you've learned
289:26 - more about how some of these
lower level functions work. And
289:28 - a little bit more about how
gasworks solidity by example,
289:32 - does a fantastic job though of
saying what the difference is
289:35 - between all three, our transfer
has a maximum of 2300 gas and
289:39 - throws an error if it fails,
send has a maximum of 2300 gas
289:44 - returns a Boolean, if it fails,
call forwards all gas so doesn't
289:48 - have a capped gas. And similar
to send returns a Boolean, if it
289:54 - is successful, or if it fails,
As of recording right now using
289:59 - call is the recommended way to
actually send and receive
290:04 - Aetherium or your blockchain
native token for now, if this
290:07 - part's a little bit confusing
for you, for now, just look at
290:10 - this and see ah, that's how we
send and transfer Aetherium or
290:14 - native blockchain currency
tokens. And I'm going to delete
290:18 - this part for the video, but
I'll keep those comments in the
290:21 - code repository associated with
this course. And okay, perfect.
290:28 - If we hit compile a fun meat
outsole, we do indeed see that
290:32 - it's passing compliation.
However, there's a bit of an
290:36 - issue here, right now,
290:38 - anybody can withdraw from this
contract. So anybody can fund,
290:43 - which is what we want. But we
don't want anyone to be able to
290:46 - withdraw. We only want the
person who's collecting the
290:50 - funds to be able to actually
withdraw the funds. So how do we
290:53 - set this up so that the withdraw
function is only called by the
290:58 - owner of this contract? Well, to
do that, we're going to set up a
291:01 - couple new functions. So when we
deploy this contract, we want to
291:05 - automatically set it up so that
whomever deploys this contract
291:09 - is going to be the owner of this
contract. And then we can do
291:12 - some parameters to set it up so
that only the owner of this
291:16 - contract can call the withdrawal
function. So how would we do
291:18 - that? Well, maybe we can create
a function called like, call me
291:23 - right away. And right after we
deploy this contract, we call
291:28 - this call me right away
function, which will set up us
291:31 - as the owner. Now that's going
to take two transactions. And
291:35 - that would be really annoying if
we had to do that. So instead,
291:38 - solidity has something called a
constructor. And if you're
291:44 - familiar with other programming
language, a constructor is
291:46 - exactly the same as other
programming languages.
291:50 - constructor is going to be the
function that gets called when,
291:53 - immediately whenever or you
deploy a contract. So if I were
291:57 - to deploy Funmi, dot Sol, and I
were to say, minimum USD equals
292:03 - to minimum USD would no longer
be 50 times one e to the 18th,
292:08 - it would be immediately updated
to two. Because constructor is a
292:12 - function that gets immediately
called in the same transaction,
292:16 - that we create this contract,
this constructor function is
292:20 - going to be incredibly helpful
for us, because it allows us to
292:23 - set up the contract the way we
want it to be. So for example,
292:27 - if we want the withdrawal
function to only be able to be
292:30 - called by the owner of this
contract, we can have the
292:34 - constructor set up who the owner
of the contract is. So let's
292:38 - create a global variable called
address, public owner. And then
292:43 - in our constructor, we'll say
the owner is going to be equal
292:47 - to the message dot sender. The
message that sender of the
292:52 - constructor function is going to
be whoever is deploying the
292:56 - contract. So owner is now going
to be whoever deployed this
293:00 - contract. And don't worry, we're
going to demo all this very soon
293:04 - and show you everything that's
going on with ether scan
293:07 - everything, demoing this all
right now might take a little
293:10 - bit of time, because we're using
a test net. So if you want to
293:13 - test it all right now,
absolutely go for it, but just
293:16 - know, it'll take you a little
bit longer to do so. Now that we
293:21 - have the owner setup, we can
modify our withdrawal function
293:25 - to make it so that only the
owner can actually call this
293:29 - withdrawal function. So at the
top of the withdrawal function,
293:32 - maybe we want to add a section,
maybe we want to say require
293:37 - message dot sender equals the
owner, a note about double
293:44 - equals versus equals, you can
think of this single equals as a
293:48 - set parameter. So when I say
owner, is now set to message dot
293:53 - sender, double equals is how you
check to see if these two
293:58 - variables are equivalent. So
we're saying is message dot
294:02 - sender, the same as owner. So
this is checking to see
294:06 - equivalence. This is setting
checking to see equivalence
294:10 - setting. So we're gonna say
require message dot sender is
294:14 - equal to owner, otherwise, we're
gonna throw an error, saying,
294:18 - sender is not owner. Perfect.
Now we have a quick way to make
294:23 - sure the withdrawal function is
only called by the owner of this
294:28 - contract. Now, let's say that
there's a lot of functions that
294:31 - we have in this contract that
are going to be required to be
294:35 - the owner, maybe there's a lot
of functions in this contract
294:38 - that need a whole lot of
different requires, we don't
294:40 - want to have to copy paste this
line to every single one of our
294:43 - functions. So what can we do?
Well, this is where something
294:46 - called modifiers come in. So for
now, we're gonna go ahead and
294:50 - delete this line. And below,
we're going to create something
294:54 - called a modifier, our modifier
is going to be a key word that
294:59 - we can add right in the function
declaration. To modify the
295:03 - function with that
functionality, we're going to
295:05 - create a modifier and call it
only owner. And we're going to
295:10 - paste that line that we just
made in withdraw. And underneath
295:15 - that, we're going to put a
little underscore, what I can do
295:18 - now is I can take this only
owner modifier, and stick it in
295:21 - the function declaration of my
withdrawal function. So what's
295:25 - happening with this modifier
with only owner in this function
295:29 - declaration,
295:30 - we're saying, hey, for this
withdrawal function, before you
295:33 - read all this code inside of it,
look down at the only owner
295:37 - modifier and do whatever is in
there first, and then do
295:42 - whatever's in the underscore,
this underscore represents doing
295:45 - the rest of the code. So now,
when we go call the withdraw
295:48 - function, we actually do this
require statement first, and
295:53 - then call the rest of the code.
If this require statement, we're
295:57 - below the underscore, this would
tell our function to go ahead
296:02 - and do all this code first. And
then run the require. Because
296:06 - again, we have this only only
keyword, we're saying, Great,
296:09 - we've got a function, it's
withdraw its public, oh, only
296:12 - odor modifier. Let's look at how
that works. Okay, it tells us
296:16 - how to do all the code of the
original function first. So
296:19 - let's go ahead and do that.
Okay, now we're done. Now, what
296:22 - do we do? Okay, now we'll run
the require, we want to go ahead
296:25 - and put the require here first.
So this is how modifiers work,
296:30 - and how we can use them to
improve our functionality. All
296:35 - right, awesome. We have all the
basic functionality of our
296:39 - contract that we need here. Now
we're finally actually going to
296:42 - run everything on a test and see
everything happened live before
296:46 - our eyes. Are you ready? Let's
do this.
296:49 - So let's go over to the deploy
tab. And we're going to switch
296:52 - of course to injected web three.
Remember But we're using
296:55 - injected web three, because our
price converter dot soul is
296:59 - using chainlink Oracle's that
actually exist and are actually
297:02 - monitoring the Rinkeby network
for us. Now we're going to
297:05 - scroll down to, and we're going
to choose the Funmi contract.
297:09 - And we're going to go ahead and
deploy. Once again, we want to
297:12 - make sure we're on the Rinkeby
test net. And we have a little
297:16 - bit of rinky eath in our wallet,
let's go ahead and deploy,
297:20 - confirm. And we'll wait a little
bit. And I'll pull up our log
297:24 - here. And we'll wait a little
bit for our contract to get
297:28 - deployed. Alright, great. It
looks like our contract has
297:31 - indeed been deployed. If we
scroll down, we can see all of
297:35 - our functionality, minimum USD
is going to be that $50. But
297:40 - with 18 zeros so that the units
are the same as Aetherium, the
297:44 - owner of our contract was set to
our address, the instant we
297:49 - deployed this contract, it was
deployed by calling our
297:53 - constructor function. So this
address 0x 106 x is going to be
297:58 - the same as the address in our
meta mask, your address here, of
298:02 - course, is going to be a little
bit different than mine, we have
298:05 - our funders array, which, of
course is going to be blank, we
298:08 - have our address array, which is
also going to be blank. And then
298:11 - we have two functions that we
can use to modify the state of
298:14 - the blockchain withdraw is going
to be orange, because we're not
298:18 - paying any Aetherium we're
actually gaining Aetherium or
298:22 - whatever native blockchain
currency fund is going to be
298:25 - read, because fun is a payable
function that we are going to be
298:29 - sending Aetherium to or sending
whatever native blockchain
298:33 - currency that you're working
with. So let's go ahead and see
298:35 - how this all works. So first,
let's go ahead and fund this
298:39 - contract. Again, funding, we got
to do a little bit of math,
298:43 - right now, since the price of
eath is around $3,000. And we're
298:47 - looking for $50. Minimum, we do
50 divided by 3000. We can do
298:53 - 3000 divided by 50, we can do 50
divided by 3000. So we know that
298:58 - around 0.02 Aetherium, should be
enough for this contract to
299:04 - work. So 0.02 Aetherium is this
much way, we can copy that,
299:12 - paste that into here. So when we
hit fund, it should actually
299:16 - pass. And we do indeed see meta
masks pop up. And we'll go ahead
299:20 - and confirm. Once this
transaction goes through, we'll
299:23 - be able to see this contract on
ether scan with the funds in it.
299:28 - Now if we don't add way here, if
we don't add a value, once
299:31 - again, we had fund will say gas
estimation failed because we're
299:35 - not sending enough here. And in
fact, we even see execution
299:39 - reverted didn't send enough, we
can absolutely send this
299:42 - transaction however, it's going
to fail. Great. So now that our
299:46 - transaction has gone through, if
we go on to the rink the ether
299:49 - scan, once we wait a little bit
for it to finish indexing here
299:53 - on the Rinkeby ether scan, we
can see that transaction
299:56 - actually went through for doing
the funding, we can actually see
300:00 - a lot of different details going
on with this transaction as
300:03 - well. And if we scroll down, we
once again, you can see all the
300:06 - information about us calling
this fun function, gas limit
300:10 - gas, you should the gas fees,
gas price, and we can see the
300:15 - input data as well, we can see
that we called the fund function
300:20 - down here. We'll learn more
about the input data later. If
300:23 - we go to the contract that we
deployed, we can now see two
300:27 - transactions, we can see our
contract created transaction.
300:32 - And we can also see we called a
font method. And if we look at
300:36 - the balance of our contract, and
now has 0.02 ether, which makes
300:40 - sense, since we just sent it
0.02. If we put that 0.02 eath
300:46 - in terms of way back into the
value section, and we call font
300:51 - again, after this transaction
goes through, we should see this
300:57 - number go from 0.02 to 0.04. Now
after we wait a brief delay, we
301:04 - do indeed see the balance has
gone up to 0.04, which is
301:09 - exactly what we'd expect.
Awesome. So our funding
301:12 - mechanism is working correctly.
And if we go down into our
301:16 - array, and our mapping
301:20 - to do address to array, and we
paste our address, we should see
301:25 - the phone number show up. And if
we go to funders of zero, we see
301:29 - our address. And if we go to
funders of one, we also see our
301:33 - address and we see that and we
see this call going through if
301:37 - we go to funders have to in our
log over here, we actually see
301:41 - that we get an error an
optimization that we could make
301:44 - to our contract in the future is
to check to see if an address is
301:48 - already in the funders array and
then not add it if it's already
301:51 - there. Now let's go ahead and
try to call this withdrawal
301:54 - function. But let's try to call
it with a different address than
301:58 - the address we originally
deployed this contract with. So
302:00 - to do that, scroll all the way
to the top of this here. And I'm
302:05 - going to go to my Metamask. And
I'm going to switch to a second
302:11 - account and hit connect. Now,
our remixes should be updated
302:16 - with the new account that's in
here, you'll see that if I
302:19 - switch back to account one, it
switches back to account one, so
302:24 - long as they're both connected,
you can see which accounts are
302:27 - connected to applications by
clicking this connected button
302:31 - and see which ones are
connected. If you ever want to
302:33 - disconnect that account, you can
click the three little dots and
302:36 - it disconnect the account. And
now we can see that this account
302:40 - is not connected. However, count
two is connected. Let's go back
302:45 - to account one and Connect
account one so that both of them
302:49 - are now connected. But we'll
switch to account two, let's
302:53 - switch to account two, because
again, account two isn't the
302:57 - owner of this contract. We
scroll down to owner, we can see
303:02 - owner's 0x 1066 Something
something and account two is
303:07 - 0x 043. Something something
awesome. So what do you think
303:11 - will happen when we hit withdraw
here? Well, our modifier only
303:15 - owner should kick in. And we
should get notified that if we
303:19 - send the transaction, we'll get
this error sender is not owner.
303:23 - So let's try it. Ah gas
estimation failed, we do get
303:27 - this error. Sender is not owner,
which is perfect. This is
303:31 - exactly what we want, we could
absolutely send this transaction
303:34 - if we wanted to. But that would
just be a waste of gas because
303:37 - this transaction is going to
fail. However, if we switch back
303:42 - to account one, and we hit
withdraw, meta mask will pop up,
303:48 - enabling us to confirm and
withdraw the ether out of this
303:53 - contract address. Now if we look
at this contract address on
303:57 - ether scan, after a brief delay,
we'll see the balance go from
304:01 - 0.04 back down to zero. And
we'll see our wallet balance go
304:07 - up from what it is back to 0.04
plus what it was. And after a
304:12 - brief delay, you can see our
balance is indeed back down to
304:15 - zero in our contract. Now, if we
do address to amount for our
304:20 - wallet address that was doing
the funding, it's back down to
304:22 - zero. And if we try to check the
address of funders at index
304:27 - zero, we get called to funders
that fund me errored execution
304:30 - reverted.
304:40 - We've completed all the basics
of this section that I wanted to
304:43 - go through. And you should be
incredibly proud of yourself for
304:46 - getting this far, you've just
deployed a really advanced smart
304:49 - contract, we're using a library
and chainlink contracts to build
304:53 - some of the most powerful
applications in the planet,
304:55 - we've learned to use a library
for any type we want in our
304:59 - smart contracts. We've learned
more about multiplication, and
305:03 - then units of measure in
solidity and smart contracts.
305:06 - We've learned about mappings
more about arrays what the
305:09 - constructor does, we've learned
how to send money we've learned
305:12 - about for loops, we've learned
about the different ways we can
305:15 - actually send money, at least
from a low level. And we've
305:18 - learned about modifiers. This
section is one of the tougher
305:20 - sections in this course. So if
you completed this, you should
305:23 - be incredibly excited. We're
going to go through our code
305:26 - now. And we're going to make a
number of tweaks. Now this
305:29 - section, we are going to do a
little bit more advanced
305:32 - solidity here. So if you get a
little bit lost, don't sweat it
305:36 - too much. And feel free to try
some of this stuff in the future
305:39 - on your own. We're going to
modify this contract to make it
305:44 - a little bit more professional.
It's not going to be end to end
305:47 - amazing, but it's going to be a
little bit better. And you'll
305:49 - see why in a minute. So the
first thing that we're going to
305:51 - do is we're looking we're going
to look at some of these
305:53 - variables here. In particular
owner and minimum USD, owner
305:58 - gets set one time in our
contract here. And then it never
306:02 - changes. Again, minimum USD gets
set one time, even outside of
306:08 - the constructor. If we have
variables that only get set one
306:12 - time, we can actually use some
tools in solidity to make them
306:16 - more gas efficient. For now
let's compile our Funmi
306:19 - contract, and then deploy it to
a JavaScript virtual machine.
306:22 - Remember, we can go ahead and
deploy it right now. However,
306:26 - funding and withdrawing and
doing in the money stuff isn't
306:29 - going to work. Because again, we
don't have a chain link network
306:33 - on our JavaScript VM. So those
aren't going to work so well.
306:36 - But for what we're gonna do
right now, we don't really care
306:38 - so much. Here's what we do care
about. You do care about how
306:42 - much gas this costs to actually
send. We do care about how much
306:46 - gas is costs to create right now
creating this contract costs
306:50 - about 859,000 gas and we're
going to Add a couple of tricks.
306:56 - Right now to bring this number
down, we're going to add some
306:59 - stuff back in in the bid, which
will bring it back up. But for
307:02 - now, we're going to learn some
tricks to bring this number
307:04 - down. The two tricks that we're
going to learn are the constant
307:07 - keyword and the immutable
keyword, in their solidity.
307:10 - There are two keywords that make
it so that your variables can't
307:14 - be changed. And those keywords
are constant and immutable. You
307:18 - can learn more about them in the
solidity documentation, if you
307:21 - assign a variable once outside
of a function, and then never
307:24 - change it, so if if it's
assigned at compile time, you
307:28 - can go ahead and add this
constant keyword. We'll learn
307:32 - later about storage. But when
you add a constant keyword, this
307:35 - minimum USD no longer takes up a
storage spot, and is much easier
307:40 - to read too. So now we recompile
this, and we deploy this new
307:43 - contract. Let's see if we saved
any gas. We look in the
307:48 - transaction logs, now, we can
grab the transaction cost of how
307:52 - much this cost to deploy, let's
compare it to how much it was
307:55 - before. Well, we saved almost
19,000 gas, that's almost as
308:00 - much gas as a cost to send
Aetherium. Typically, constant
308:03 - variables have a different
naming convention. Typically,
308:06 - you'll want to do them all caps
like Min imaam. Underscore, who
308:11 - is the CIO all caps with
underscores. So now let's just
308:15 - find minimum use D, and replace
that with all caps as well. With
308:18 - this interaction, we know that
this variable is a constant
308:22 - variable, and it's much cheaper
to read from now, if we go ahead
308:25 - and compile this and redeploy.
In our Funmi contract, even
308:30 - though this is a view function,
remember, view functions do have
308:34 - gas costs when when called by
contract as a constant variable,
308:38 - we can see the execution cost of
this variable 21,415 gas. So
308:44 - let's put a little note rather
Nathan.
308:47 - If we remove the constant
variable, we delete this
308:50 - contract. And we redeploy, like
Funmi. And we hit minimum ust
308:56 - again, we can now see how much
gas this was cost. If it wasn't
309:00 - a constant variable, we can see
the gas cost did indeed go up.
309:03 - Now on chains that are much
cheaper, this gas difference
309:06 - probably won't make that much of
a difference. But on more
309:08 - expensive chains like Aetherium,
this is going to make a big
309:11 - difference. For example, on
Aetherium, we can actually see
309:15 - current gas prices on Aetherium.
Here, we can see the current gas
309:19 - price of Aetherium is about 141
way, so we'll go to our
309:23 - converter, way to way we'll copy
the way price times this will
309:28 - get the gas price of calling our
minimum USD, which is this
309:32 - number here, which if we put
back in our Aetherium
309:36 - uniconverter, we can see cost
this much gas. And if we times
309:41 - that by the approximate current
price of Aetherium, which is
309:45 - around $3,000. Calling minimum
use D as a constant is going to
309:49 - cost $9 on the inside is at a
nonconstant is going to cost
309:54 - almost an entire dollar more,
you can see how all these little
309:58 - gas optimization tricks are
going to make your life a lot
310:01 - better. So let's keep this
constant keyword in here. We'll
310:04 - learn more about constant and
storage in later sections of
310:07 - this course. Now, as you're just
getting started with this
310:10 - course, and with slip the Do not
struggle. And do not worry about
310:15 - making your contracts as gas
efficient as possible in the
310:19 - beginning, and especially right
now. Just write your contracts
310:22 - as best as you can. Once you get
really good at gas. And once you
310:26 - get much later on in the course,
and much more advanced with
310:30 - solidity, then you can start
going back and working on gas
310:33 - optimizations. But do not let
gas optimizations hold you back.
310:37 - Or if you start stressing over
it, just let it go. Don't worry
310:41 - about it and just write your
code as best you can. So long
310:44 - story short, Do not stress about
gas optimizations right now. Now
310:48 - another variable we only set one
time is going to be our owner
310:51 - variable. Owner equals message
dot sender. We set this one time
310:56 - in the constructor variables
that we set one time but outside
311:00 - of the same line that they're
declared. And we set them for
311:02 - example, in the constructor, we
can mark as a mutable typically
311:06 - a good convention for marking
immutable variables is going to
311:09 - be doing I underscore so that we
know that these are immutable
311:13 - variables, they have very
similar gas savings to the
311:16 - constant keyword. Owner, of
course, is a variable that we
311:19 - can't set on the line here
because inside the global scope,
311:23 - there's no function going on.
However, inside functions,
311:27 - because inside the global scope,
there's going to be no message
311:29 - that sender, there's only going
to be a message dot sender when
311:32 - we're inside of a function. So
inside here, we might say I
311:36 - owner equals message dot sender.
And then of course, we'll scroll
311:39 - down and we'll change this
require only owner now equals i
311:44 - owner. Now if we compile that
deploy up, we can see how much
311:50 - gas we can see how much gas
calling I owner is going to be
311:53 - by with immutable notice, we get
21,508, which we'll go ahead and
311:59 - copy for now. And we'll put
right here, we'll say,
312:02 - immutable. Now, if we remove the
immutable keyword, let's close
312:08 - this redeploy. If we scroll down
to I owner, screw up the logs,
312:13 - we go down to the call, scroll
down, we see the execution cost
312:17 - was much more. So we'll do the
backslash, a seven here, yes, or
312:24 - non immutable. So you want to
keep some of these tricks in
312:28 - mind, when it comes to storing
variables. The reason that these
312:32 - two save gas is because instead
of storing these variables
312:36 - inside of a storage slot, we
actually store them directly
312:39 - into the bytecode of the
contract. And like I said, don't
312:41 - worry too much about that for
now, later on in the course,
312:44 - we'll teach you more about
storage and a lot of this low
312:47 - level stuff that comes to these
contracts. But for now, just
312:50 - know that these exist. And
they're nice gas savers, if
312:54 - you're only setting your
variables once. Alright, great.
312:59 - So we've just made our contract
a little bit more gas efficient,
313:02 - little gas efficiency
improvements are going to be
313:04 - concept I sprinkled throughout
this course. And when we get to
313:07 - the more advanced section, I'm
going to break down exactly
313:10 - what's going on and why all
these gas efficiencies exist and
313:13 - what's going on behind the
scenes for these gas
313:15 - efficiencies to occur. It's a
little bit in the weeds, which
313:18 - is why I'm going to gloss over
it right now.
313:20 - So if it's confusing, don't
worry, I wouldn't let these gas
313:23 - efficiencies be the thing that
slow you down. Awesome. So we
313:26 - have these two gas
optimizations? How else can we
313:29 - make this contract a little bit
more gas efficient? Well, one of
313:32 - the ways we can make this more
gas efficient, is by updating
313:35 - our requires right now with our
require statement, we actually
313:39 - have to store this sender is not
an owner as a string array,
313:44 - every single one of these
characters in this errorlog
313:46 - needs to get stored
individually, this string may
313:49 - not seem very big, but it's a
lot bigger than the alternative
313:52 - with what we can do. As of zero,
point 8.4 of solidity, you can
313:56 - now actually do custom errors.
For our reverts, we declare them
314:01 - at the top and then use ifs,
instead of require and then just
314:05 - add a revert statements. This
ends up saving a lot of gas,
314:09 - since we just call the error
code, as opposed to calling the
314:12 - entire string associated with
the air. So for example, with
314:17 - our require down here, and with
actually with all of our
314:20 - requires, well we could do is
instead of having this require
314:23 - we could create a custom error.
So at the top, what we could do
314:28 - is we could say error, not
owner. And you'll notice that
314:35 - this is actually outside of the
contract here. Now what we can
314:39 - do is we can take this error not
owner scroll down into our only
314:42 - owner, instead of doing a
require we'll do an if
314:45 - statement, we'll say if message
dot sender is not owner, then
314:53 - we're going to go ahead and
revert with a non owner error.
315:00 - This ends up saving us a lot of
gas, since we don't have to
315:03 - store and emit this long string
here. Now in a lot of code
315:07 - today, you'll still see require
a lot of places because these
315:10 - these custom errors are pretty
new in solidity. So you'll want
315:13 - to get used to writing in both
ways. I wouldn't be surprised if
315:16 - in the future, the syntax for
some of these errors looks like
315:19 - this so that it's more readable.
But for now, if you want to do a
315:22 - more gas efficient way than
required, you can use something
315:25 - like this, we could update all
of our requires here for these
315:28 - customers. But for now, I'm
going to leave both in just to
315:31 - show you the differences. This
revert keyword does the exact
315:34 - same thing that required us
without the conditional
315:37 - beforehand. So you can actually
go ahead and revert any
315:40 - transaction or any function call
in the middle of the function
315:43 - call. Now let's look at one more
way to improve this contract.
315:49 - Sometimes people will try to
interact with the contract that
315:51 - takes Aetherium or the native
blockchain token without
315:54 - actually going through the
required function calls that
315:57 - that are needed. For example, on
a JavaScript EVM here, I could
316:01 - actually try to send this
contract money without calling
316:04 - the fund function. However, if I
were to do that, what would
316:08 - happen with our fund function
get triggered? No, it wouldn't
316:11 - get triggered, we wouldn't keep
track of that funder, we
316:14 - wouldn't have that person's
information updated in this
316:17 - contract. So if later on we want
to give rewards or something we
316:20 - wouldn't know about those
funders. And this wouldn't be
316:23 - great because people would send
our contract money without us
316:26 - ever knowing and we wouldn't be
able to give them any credit or
316:28 - anything. Additionally, maybe
they called the wrong function
316:32 - by accident, and they they
weren't using Metamask. And they
316:35 - weren't using a tool to tell
them, hey, this transaction is
316:38 - likely going to fail. So what
can we do in this case? What
316:41 - happens if someone sends this
contract, ether without calling
316:49 - the fun function? Right now, if
we were to send this Funmi
316:52 - contract, ie it would just go to
the contract Right, and this
316:55 - contract just wouldn't keep
track of those people. But
316:58 - there's actually a way for when
people send money to this
317:00 - contract, or people call a
function that doesn't exist for
317:04 - us to still trigger some code.
And now there are two special
317:07 - functions in solidity one is
called receive, and one is
317:12 - called the fallback. Now in
solidity, there are actually a
317:16 - number of special functions and
two of these special functions
317:19 - are the receive special
function. And the fallback
317:23 - special function, a contract can
have at most one receive
317:26 - function declared using the
received external payable.
317:29 - Without the function keyword.
This function cannot have
317:32 - arguments cannot return anything
and must have external
317:34 - visibility, and a payable state
mutability. What does that
317:38 - actually mean? And or look like?
Well, let's create a separate
317:42 - contract to go ahead and play
with this. So in here, we're
317:44 - going to create a new file
called fallback example, dot
317:48 - soul. And in here, we're going
to add our basic pieces, SPX
317:52 - license identifier, MIT pragma,
solidity zero, point 8.7. And
318:00 - we'll do contract fallback
example, like so, feel free to
318:06 - pause the video to catch up to
this point, let's recreate our
318:09 - fallback contract, let's create
a variable to go ahead and try
318:12 - to test this function, we'll
create a un 256 public result
318:17 - variable. And let's create this
receive function. So we'll say
318:20 - receive, it's going to be an
external payable.
318:25 - function, we don't add the
function keyword for receive,
318:30 - since solidity knows that
receive is a special function
318:34 - whenever we send Aetherium or
make a transaction to this
318:38 - contract. Now, as long as
there's no data associated with
318:41 - that transaction, this receive
function will get triggered.
318:45 - What we can do in here now is we
can say result equals one. So
318:50 - let's go ahead and test this out
on the JavaScript virtual
318:53 - machine, we compile this, so
we're gonna go ahead and compile
318:56 - this. And we'll go deploy it on
the Java Virtual Machine, we're
319:00 - going to deploy our fallback
example. And we're going to see
319:04 - what result is initialized to,
since we haven't set anything
319:07 - for result, result, of course,
is initialized zero. But what if
319:12 - we were to send this contract
some Aetherium? Well receive
319:16 - would go ahead and be triggered
here, we can actually send this
319:19 - contract some material directly
by working with this low level
319:22 - interactions. But here, don't
worry about what call data means
319:25 - for now, just know that this
area down here is a way we can
319:28 - send and work with different
functions. And we can add
319:32 - parameters to this transaction,
by going up here and adjusting
319:35 - the variables up here. If we
keep called Data blank, it'll be
319:39 - the same as if we were in
Metamask. And just hitting send
319:42 - in the choosing this contract
address. Again, we can't
319:45 - actually use Metamask, since
this is a virtual machine, and
319:48 - not one of the networks that
we're working with. So if I do,
319:51 - for example, I change this value
to one way, and I keep
319:55 - everything blank. And I go ahead
and hit this transaction button,
319:59 - which again, is going to be the
same as hitting this Send
320:02 - button, but only sending one
way. What do you think will
320:05 - happen? Well, let's try it. We
can see in the log area that we
320:10 - did indeed send a transaction.
And if you look at the
320:14 - description here, you can even
see it says from so and so to
320:17 - fall back example, dot receive,
it looks like it called our
320:22 - received function, which should
have updated our result to one.
320:26 - So if we hit result, now we can
indeed see that result has been
320:30 - updated to the value of one.
Well, let's go ahead and delete
320:33 - this. Let's deploy this contract
again. And this time, let's have
320:38 - this value be zero, does receive
get triggered this time. So
320:42 - let's pull this down. Let's hit
transact. Let's leave the call
320:45 - data blank, we'll leave value at
zero. So this will be the same
320:50 - as if we had sent zero Aetherium
to this contract. Let's hit
320:55 - transact. It looks like that
went through, do you think
320:58 - result is going to be one or
zero? You thought one you were
321:02 - correct or receive function gets
triggered anytime we send a
321:05 - transaction to this contract
now, and we don't specify a
321:09 - function. And we keep the call
data blank when working with any
321:13 - other contract like Funmi. For
example, when we call one of
321:16 - these functions, we're actually
just populating this call data
321:19 - bit with certain data that
points to one of these functions
321:22 - up here. If we send a
transaction and we add data to
321:26 - it, we could actually call one
of these functions. Now let's
321:29 - try this again. Let's delete the
contract again we'll redeploy
321:32 - open this up result is currently
zero receive like I said only is
321:36 - triggered if our call data to it
is blank. Now this time if I had
321:41 - some call data to this
transaction, do you think
321:44 - receive will be triggered this
time? If we hit transact and
321:46 - remix we actually get a pop up
saying fallback function is not
321:50 - defined. This is because
whenever data is sent with a
321:53 - transaction solidity says, Oh,
well, since you're sending data
321:58 - you're not looking for receive,
you're looking for some
322:00 - function. So let me look for
that function for you. Hmm, I
322:04 - don't see any function that
matches the 0x 00. So I'm going
322:08 - to look for your fallback
function. Remix is smart enough
322:11 - to know that we don't have a
fallback function. The second
322:14 - special function in solidity is
called the fallback function.
322:17 - This is very similar to the
receive function, except for the
322:21 - fact that can work even when
data is sent along with
322:24 - transaction. So our fallback
will look something like this
322:27 - callback,
322:29 - external payable. result equals
to Fallback is another one of
322:38 - these functions where we're not
going to put the function
322:40 - selector because solidity is
expecting this, actually, you're
322:44 - already familiar with one other
special function, we go back to
322:48 - our Funmi. Our constructor, for
example, is a another type of
322:52 - special function. There's no
function keyword. solidity knows
322:56 - that this constructor is
immediately called when we
322:58 - deploy this contract. So now we
have our fallback function.
323:02 - Let's go ahead and compile this.
Let's delete our old contract.
323:06 - Let's go ahead and deploy this
new contract. Like here, we hit
323:11 - result, we do indeed, see, it's
set to zero. Now, if I add this
323:15 - 0x 00, and I send this, and I
hit transact, this is equivalent
323:21 - to calling our contract here
without a valid function. So our
323:25 - contract goes, Huh, I don't
recognize what you're trying to
323:27 - tell me here, I'm going to refer
you to our fallback. And now if
323:30 - we hit result, we see that it's
been updated to two. If we take
323:34 - this away, solidity will go,
Hmm, it looks like you're trying
323:38 - to send some Aetherium, or call
this contract without specifying
323:40 - what you want to do. Well, I
have a receipt function. So I'm
323:43 - just gonna go ahead and forward
you to that. So if we call
323:46 - transact, we hit result, we see
it updates back to one, add some
323:50 - data, hit transact, we see it
updates to to no data, updates
323:56 - to one slowly by example, that
org has a wonderful little chart
324:00 - that we can use to figure out
whether or not receive is going
324:03 - to get triggered, or Fallback is
going to get triggered. If it is
324:06 - empty, and there's a receive
function, it'll call the receive
324:09 - function. If it is data, and
there's no receive function,
324:13 - it'll just go to the fallback
function. And if there's no
324:16 - fallback function, it might just
it might air out. So this is a
324:19 - lot of really fantastic
information here. How can we
324:22 - apply this to our fund mi
contract here, or what we can do
324:26 - now in our Funmi is we can add
these fallback and receive
324:30 - functions, just in case somebody
actually sends us contract money
324:34 - instead of calling the fund
function correctly. So what we
324:36 - can do is let's add a receive
function. So if somebody
324:40 - accidentally sends it money, we
can still process the
324:42 - transaction will say receive is
going to be external payable.
324:48 - And we'll just have the receive
function call fund. And we'll do
324:52 - the same thing with our fallback
function will have fallback
324:57 - external payable. We'll just
have it automatically call fund.
325:04 - Now, if somebody accidentally
sends us money without calling
325:07 - our fund function, it'll still
automatically route them over to
325:12 - the fund function. This means to
that if somebody doesn't send us
325:16 - enough funding, it'll, that
transaction will still get
325:19 - reverted. So let's go ahead now.
And let's switch to rink B to
325:22 - test this on a real test net,
Amman rink B and my Metamask.
325:26 - Let's switch over to injected
web three. And we'll scroll down
325:31 - we'll choose our Funmi contract.
And we'll go ahead and deploy
325:34 - this Metamask pops up, I'm gonna
go ahead and confirm the
325:38 - transaction. And we see our
Funmi contract here right now we
325:42 - can see the owner we can see I'm
the owner, we can see minimum
325:45 - USD. And we can see of course
that it's a blank contract, and
325:49 - there's nothing funded in here.
If we the copy the address, and
325:52 - then go to rink the ether scan,
paste the address in, we can see
325:58 - that there's no ether in here.
And the only transaction
326:01 - associated with this has been
the contract creation. We saw
326:03 - what happened before when we hit
the fun function, our contract
326:06 - was updated with a new balance,
and that funder was added to our
326:11 - an array. Let's see what happens
now if we just directly send
326:15 - this contract money without
calling the fund function here.
326:19 - If we did this right, our
receive function should pick it
326:23 - up and kick the transaction over
the font. So let's copy this
326:28 - address. We'll go to our meta
mask. We'll hit send, paste the
326:33 - address in here with 0.02 eath.
Again, because this should be
326:38 - more than the minimum amount in
USD, we'll hit next. I'll go
326:43 - ahead and confirm this. After a
slight delay, if we did this
326:47 - right, we should see the
transaction having called the
326:51 - fund function here, now that our
transaction has gone through
326:55 - After a brief delay in waiting
for ethers can update, we do
326:58 - indeed see that our balance has
updated to 0.02, which of
327:02 - course, this makes sense. And we
see in the transactions list
327:06 - here, we see that this actually
went through as a, as a transfer
327:09 - instead of us calling the fund
function. Let's go ahead and
327:12 - remix and see if our funders was
updated.
327:16 - It looks like it was at the zero
with position of funders, we
327:20 - have our address. And if we take
our address and pop it into
327:23 - address to amount funded, we can
see exactly how much we had
327:27 - funded. This means that since we
added this receive function in
327:30 - here, we automatically had to
call our fun function up here.
327:34 - So awesome work, we were able to
add a receive function to help
327:38 - people who accidentally call the
wrong function or accidentally
327:42 - send this contract money,
instead of correctly calling the
327:45 - fun function. Now, if they had
directly called the fun
327:48 - function, it would have cost
them a little bit less gas, but
327:51 - at least this time, they're
gonna get credit and add it to
327:54 - our funders array for having
sent our funding contract money.
327:59 - We've even learned some advanced
sections of solidity. And this
328:03 - is going to be the last time
that we start our projects in
328:05 - remix, we're going to be moving
over to a code editor now, where
328:10 - we can get even more advanced
with our solidity on our setups.
328:13 - For the most part, you've gone
over the vast majority of
328:16 - solidity basics, there are a
number of things that we still
328:19 - haven't learned yet. And the
reason we haven't gotten into
328:21 - them is because they get more
advanced. And understanding the
328:24 - real use doesn't really make too
much sense until a little bit
328:27 - later. Some of the things that
we're going to go over are itams
328:30 - events, try catch function
selectors, abi encoding,
328:34 - hashing, and then you will slash
and then you will slash
328:36 - assembly. However, if you've
gotten this far, you probably
328:39 - can read most solidity code and
understand what's going on,
328:42 - which is absolutely fantastic.
So you should give yourself a
328:45 - huge round of applause for
getting this far. And doing
328:48 - this. Let's do a quick summary
of this more advanced section
328:51 - and make sure we understand what
we learned in solidity there are
328:54 - a couple special functions. Some
of them are receive fallback,
328:58 - and Constructor. These functions
don't need to have the function
329:03 - keyword. And instead it can just
be called like so. Receive and
329:07 - fallback are two very special
functions. If data is sent with
329:10 - a transaction, and no function
was specified, the transaction
329:14 - will default to the fallback
function if that fallback
329:17 - function exists. If data is
empty, and there's a receive
329:20 - function, it'll call the receive
function. There are a couple of
329:24 - keywords that can help us save
gas in the long run. Some of
329:28 - those keywords are going to be
constant and immutable. Constant
329:31 - and immutable are for variables
that can only be declared and
329:34 - updated once. Once we say
minimum USD is 50 times 118.
329:39 - This minimum USD can never be
changed again. And this helps us
329:43 - save gas. Immutable can also
save gas similar to constant.
329:47 - However, immutable variables can
be declared one time in the
329:50 - constructor, once an immutable
variable is declared, it can't
329:55 - be changed later on. In fact, if
we even tried to update an
329:58 - immutable variable or constant
variable, and we compiled, a
330:02 - compiler would give us an error
saying, Can't write to a mutable
330:06 - here. Or if we tried to change a
constant variable. Our compiler
330:11 - would say, Hey, you can't assign
to a constant variable, sorry.
330:14 - In remix, if we want to send
ether to a contract that's on
330:17 - the JavaScript virtual machine,
we can deploy that contract. And
330:21 - then in the contract, we can
just hit the transact button
330:24 - without any call data and update
the value that we send with the
330:27 - transaction. If call data is
blank, it will trigger the
330:30 - receive function if it exists.
But if there's data that doesn't
330:34 - specify any of the other
functions, it'll trigger the
330:37 - fallback function
330:47 - Awesome, you've done
fantastically to get this far.
330:50 - And for this section before we
get started actually moving over
330:54 - to Hardhead. And moving over to
JavaScript and understanding why
330:57 - we need to do that. Let's
understand a little bit about
331:00 - getting help and running into
problems. So let's say we have
331:03 - our Funmi contract here that we
just worked on. And we run into
331:07 - an error. Let's say for example,
we forgot the payable keyword,
331:11 - right, and we go ahead and
compile this compile fund, we
331:15 - did so. And we scroll down. And
we see obviously, we have two
331:18 - errors here, right, we're
getting some errors, and we
331:20 - scroll down. And we see type
error message dot value and call
331:25 - value can only be used and
payable public functions, make
331:28 - the function payable or using an
internal function to avoid this
331:31 - error. And then it goes ahead
and gives the line that's
331:34 - airing. Now this error is pretty
clear, this error code is pretty
331:38 - clear. It's saying Hey, make the
function payable, or using an
331:41 - internal function to avoid this
error, right? This should be
331:44 - pretty easy to to add payable,
and then recompile and be good
331:48 - to go. And this is actually a
good example of what to do when
331:51 - you run into errors. When you
run into errors. The first thing
331:53 - you want to do is you want to
try to figure out exactly what's
331:56 - going on yourself based off of
what the error says. This one's
332:00 - pretty straightforward, but some
of them can be a little bit more
332:02 - obscure step one when trying to
get unblocked trying to tinker
332:06 - and figure out errors yourself,
right? Because maybe you go
332:10 - okay, I'll make this payable,
right? And you go to save. And
332:14 - then it gives a different error
saying, hey, you know, payable
332:17 - doesn't go here. You resave you
recompile it goes, Hey, we're
332:21 - still missing that payable
thing. First step is always
332:24 - going to be trying to tinker and
figure it out yourself. For this
332:27 - course, I want you to limit
tinkering, slash triaging to 20
332:31 - minutes, if you take more than
20 minutes to tinker and triage,
332:36 - then move on to the next step.
But I also want you to take at
332:40 - least 15 minutes yourself or be
100% Sure, you exhausted all
332:48 - options, you're completely out
of ideas. So typically try to
332:51 - tinker try some stuff for 15
minutes. And if you're under 15
332:55 - minutes, and you're saying, Hey,
I'm 100% Certain I've tried
332:58 - everything that I can think of,
then you can move on to the next
333:01 - step. So step one, when you run
into errors is always going to
333:04 - be tinker and try to pinpoint
exactly what's going on. Try to
333:11 - pinpoint exactly what's going
wrong. Step two, let's say you
333:14 - tinkered and you tried payable
all over the place, and you
333:16 - couldn't figure out what this
error was and how to debug this
333:19 - here. Step two is always going
to be Google the exact error and
333:24 - see if you can learn from that.
So zoom out a little bit, I'll
333:27 - roll my mouse over this, grab
this, copy it, or quotes around
333:32 - it, and do exactly that, in
Google search that exact error
333:36 - and take some time going through
Google going through Stack
333:38 - Overflow going through Stack
Exchange eath, and look to see
333:41 - if somebody has asked this
question already. And it looks
333:44 - like down here looks like
somebody has type error missed a
333:47 - value and call though can only
be used on PayPal public
333:49 - functions. And if we scroll
down, we see that somebody ran
333:53 - into exactly this. And they went
ahead and solved it. They go, I
333:56 - realized my mistake, I needed to
add the PayPal keyword to my own
333:59 - implementation. And they go
ahead in this question, they've
334:02 - added the payable. And hopefully
this would give you the insight
334:05 - to say, Ah, okay, great. I do
need to come back here and add
334:08 - payable. Let's say this
StackOverflow question didn't
334:11 - show up. Right? This forum
wasn't here. What do we do next?
334:14 - So step one, tinker. Step two,
Google the exact error, I'm
334:19 - going to do a step 2.5 That only
is for this class, go to our
334:25 - GitHub, repo discussions, and or
updates for this course,
334:30 - specifically, go to this GitHub
repo, full blockchain solidity
334:34 - course, Jas, it'll look a little
bit different when you all get
334:36 - to it. But come to this repo,
and look in this chronological
334:39 - update section to see if there's
an update on that section that
334:43 - you're doing. Obviously, since
I'm recording right now, there's
334:46 - no update. And if you don't get
anything, feel free to jump into
334:50 - the discussion section. And ask
a question in here, right,
334:52 - there's going to be a community
of people looking to help each
334:55 - other out and looking to make
this a lot of fun. And the
334:58 - reason I say 2.5 is because in
the real world, you're not going
335:02 - to have our GitHub repo, when
working on stuff outside of this
335:05 - course, you're not going to have
this GitHub repo. So instead, in
335:09 - the real world, I'm still going
to give you the keys, I'm going
335:11 - to give you what it takes to
still unblock yourself on
335:15 - anything. Okay. So number three
is going to be asked a question
335:19 - on a forum, like stack, exchange
eath and Stack Overflow. Stack
335:27 - Overflow is a question and
answering tech forum like this,
335:31 - right? You can ask tech
questions, and then you can
335:35 - answer them as well. And as you
can see, when you search for
335:38 - these issues, they'll show up so
Stack Overflow is more for
335:41 - general Role programming
questions and Stack Exchange
335:45 - Aetherium or Stack Exchange eath
Aetherium Stack Exchange, this
335:50 - is for more Aetherium or EVM
based question and all the
335:53 - solidity code that we're gonna
be working with, whether it's
335:56 - polygon, whether it's avalanche,
whether it's whatever, those
335:59 - questions are going to be valid
here, and you can ask here. So
336:03 - what you'd want to do is you'd
want to sign up or log in, and
336:06 - ask and format your questions on
these forms, you'll want to sign
336:09 - up for GitHub, you want to sign
up for Stack Exchange, you'll
336:11 - want to sign up for Stack
Overflow, so you can participate
336:14 - in these forums. In fact, if you
haven't already, let's sign up
336:17 - for GitHub right now. And let me
walk you through formatting one
336:20 - of these questions, because the
better you format your
336:22 - questions, the better chance you
have of actually getting the
336:25 - answer. And remember, when
asking questions on these
336:28 - forums, when asking questions,
in these discussion communities,
336:31 - people answer these questions
out of the goodness of their
336:34 - heart, right? So if you don't
get a response, there's a chance
336:37 - that maybe nobody knows, maybe
it's your question isn't
336:40 - formatted very well, and etc. So
we're going to learn how to ask
336:43 - really good questions here. And
if you're new to blockchain, do
336:46 - not skip this section. Okay,
this is going to be that piece
336:49 - that's going to give you the
superpower to unblock yourself
336:51 - from any coding issue you run
into. So don't skip this
336:54 - powerup. Be sure to follow
along. Okay. So if you don't
336:57 - have a GitHub already, you do
need an email to get started. So
337:00 - I'm going to go ahead and sign
in, I made a burner account just
337:03 - for this video. So what we're
gonna do, we're gonna go ahead
337:05 - and sign up GitHub, enter your
email
337:16 - and we hit Create Account,
they're going to send us an
337:18 - email. So we're going to come
back to our email, and we got
337:20 - our launch code here, paste it
in. And so a little bit of
337:25 - information. We're going to
choose the free version. and
337:32 - fantastic. We've now created a
GitHub profile. Now back over in
337:35 - the smart contract kid full
blockchain solidity course, Jas,
337:39 - I'm going to create a new
discussion, a new thread, and I
337:41 - want you all to comment on to
make sure you understand how to
337:44 - format and how to ask questions.
Okay, general thread for
337:47 - practicing. Question formatting.
Oops. And so let's go back here.
337:53 - So first, I'm going to format
this question poorly, two ways,
337:57 - and then we're gonna format it
really, really well. So the
338:00 - first way we're going to format
it poorly, is by not giving
338:03 - enough information. So what
we're going to do is I'm gonna
338:07 - just copy this issue we're going
to do is we'll just say like,
338:11 - Hey, I'm having trouble with
remix and an error. Can someone
338:19 - help me? Why is this not a well
formatted question? If this is
338:23 - my question, there's not nearly
enough information here, I, as a
338:27 - helper, have no idea what this
person's asking. So let's do
338:30 - something else. What I'm going
to do is I'm going to copy this
338:34 - entire contract all the fun,
read outsole, paste it in here,
338:39 - and go, Hi, I'm having issues
here. Can someone help? I'm
338:46 - gonna head start discussion here
want to hit start discussion, it
338:49 - formats this all weird. And once
again, there's not really enough
338:52 - information here. I don't know
what the issue is. But at least
338:56 - with this one, we have some
code, we have some way to
338:58 - actually debug. So this is a
little bit better. But it's
339:00 - still not that good. Let's go
ahead and edit this. To make
339:03 - this even better. We hit three
dots, we can hit edit, what we
339:06 - can do is we can use something
called Markdown syntax, and
339:10 - highly recommend learning a
little bit of markdown, it's
339:13 - basically some syntax help make
discussions on GitHub. And also,
339:17 - questions on Stack Overflow and
Stack Exchange a lot easier. So
339:21 - we're going to format this code
by adding these three backticks
339:25 - at the start, and then also at
the end of our code. And then
339:31 - additionally, next, the first
three backticks, we're going to
339:34 - type so lid did T which tells
the format or to to use solidity
339:40 - to format this code here. Now if
we update discussion, we notice
339:44 - we get some nice highlighting
here. So this becomes much, much
339:49 - easier to read. Right? This is
way easier to read now than than
339:53 - it was before. However, it's
still not specific enough. We've
339:57 - given a ton of code here, and we
haven't given the specific
340:00 - answer. So this is gonna be
really hard for somebody to
340:03 - answer. So let's make this more
specific. So let's edit this
340:06 - question again. And let's
specify, so we see here, our
340:10 - issue is specifically on this
function. We're going to copy
340:15 - this function and we're going to
delete everything else in here.
340:19 - And now we have just this code
inside of here. Now we're going
340:23 - to make this really specific.
We're going to say, on this
340:26 - function, I'm running into an
error. And then what we're going
340:31 - to do is we're going to come
back here, we're going to roll
340:33 - the over this. We're going to
copy this we could have pull our
340:36 - code if we want but we're going
to format this error like this.
340:39 - And then we're gonna say Can
someone tell me What's going on?
340:44 - Update? Now this is a much, much
easier question to debug. Right?
340:49 - We have some minimalistic code,
we have the error that we're
340:52 - getting. And we have Can someone
tell me what's going on?
340:56 - Obviously, the answer to this
would be to add payable to this.
341:00 - And that's what somebody would
say, hey, like, you need to add
341:02 - payable to this, I want you all
to practice doing some
341:04 - formatting, go ahead and add a
comment on this with your own
341:08 - formatted question. So that you
understand how to actually do
341:11 - the formatting. And this
markdown format. It's this
341:14 - format here, that's gonna be the
exact same for asking questions
341:17 - on Stack Overflow, or Stack
Exchange for this course, go
341:21 - ahead and practice if you want
to create more new discussions,
341:24 - feel free to create new
discussions. If you want to use
341:27 - Stack Overflow or Stack Exchange
eath actually highly recommend
341:31 - you Stack Overflow or Stack
Exchange eath as well, because
341:33 - those are gonna get indexed a
lot better than GitHub here.
341:37 - However, feel free to ask
questions, obviously, in this
341:39 - GitHub as well. Now that I've
given you kind of the basics
341:42 - rundown, we're going to watch a
video that I made that goes even
341:45 - deeper into why and how to
format all these questions and
341:48 - what to use. So let's go ahead
341:50 - and watch that. Every developer
has run into this. Something
342:00 - breaks or maybe you don't know
something, but you don't have
342:01 - time to let these stop you.
There are a series of steps that
342:04 - one should take to maximize
one's chances of solving any
342:08 - coding problem, but you'd be
surprised at how few developers
342:11 - currently use the superpower
effectively, our first one we'll
342:14 - spend the least time on, because
it's just tinker and experiment.
342:16 - When you run into an issue. Keep
trying different things you
342:19 - think might work, maybe try
doing print statements
342:21 - throughout the file, learn some
debugging tips, but don't be so
342:23 - cocky that you only do this
first step. And this shouldn't
342:27 - just be random running around.
This should be trying to
342:30 - pinpoint exactly what's going
wrong in your code, so that you
342:33 - can either ask an effective
question, or figure it out
342:36 - yourself. So pinpoint exactly
what's going wrong, because
342:39 - you'll need it for the next
steps. Anyways, next, check the
342:42 - documentation. Not all tools
have good documentation. But
342:46 - taking some time to explore
documentation can be a quick way
342:49 - to find your answer, you'll want
to learn how to search a webpage
342:52 - with Command F or Control F.
That way, you can look for
342:55 - specific keywords on a page, or
hopefully they have a good
342:58 - search bar that works well.
Sometimes documentation can be
343:01 - really dense. So maybe you'll
move to the next step, which is
343:03 - doing a web search. At the end
of the day, good software
343:06 - engineers are secretly just
professional Googlers. And this
343:09 - is one of their most powerful
tools, being able to search the
343:12 - web for somebody else who has
already run into the problem
343:15 - that you've just run into, and
then solved it. Most search
343:17 - engines like Google have tools
you can use to get even more
343:20 - specific about what you're
looking for. Often for specific
343:23 - errors, the best thing to do is
actually just copy the exact
343:26 - error and paste it in the search
bar with quotes or use the
343:29 - Asterix in spots, your error
might be too specific. Most of
343:32 - the results you'll get will be
from forums and q&a sites, which
343:36 - leads us to our next step,
asking questions in these forums
343:38 - and q&a sites. Just make sure
that before you ask a question,
343:42 - you've done some ample Googling
around yourself beforehand. This
343:46 - way you don't waste yours and
anybody else's time. And by
343:49 - asking questions that you swear
you will promise me that at some
343:52 - point, you will go back and help
other people learn as well got
343:56 - it good. Before even asking your
question though, we should learn
343:59 - where is going to be the best
place to ask. This is why I've
344:03 - categorized for different types
of forums and QA sites, feel
344:07 - free to pause to read them over.
And here's some specific
344:10 - examples of each one of these
index code base forms like Stack
344:13 - Overflow, index repositories
like GitHub issues, index
344:17 - technology, specific forums,
like our slash eat dev or
344:21 - unindexed discussion platforms
like chainlink discord, one of
344:24 - the key differentiators in these
categories is the index keyword.
344:28 - We typically want to ask
questions on forums that web
344:31 - crawlers have gone through and
stuck them in their database or
344:34 - index them this way. And three
weeks when we look back at the
344:37 - code that we wrote, we can just
Google what was going on when we
344:40 - forget what it does. And this
will help out other developers
344:43 - who run into the same problem,
which in turn, they might go
344:46 - ahead and help you out later.
Ideally, most of your questions
344:49 - should be asked on one of these
index forms for this reason for
344:52 - their searchability and
discoverability. However, at
344:54 - some questions are a better fit
for DMS, Twitter or discord that
344:58 - aren't index and we made a
little chart here to figure out
345:00 - where's the best place to post
your questions, feel free to
345:03 - pause the video take a look or
read our blog and the
345:05 - descriptions with the picture as
well to take another look at it.
345:07 - And of course, before actually
posting that in one of these
345:10 - forums, be sure to read their
rules as they might state that
345:13 - some kind of questions are
specifically for Ben. But
345:15 - basically the breakdown looks
like this. Theoretical big
345:19 - picture or opinionated questions
can go great on general q&a
345:23 - forums like Quora or specific
technical forums like specific
345:27 - subreddits or discord forums,
specific coding questions can go
345:31 - on these forums as well, but
will often get more eyes on
345:35 - coding forums like Stack
Overflow or Stack Exchange
345:38 - communities often the question
of Oh, should I post this on
345:41 - stack URL? flow or maybe a Stack
Exchange community is incredibly
345:45 - blurry. And sometimes it doesn't
really matter which one you post
345:47 - on. Now, if you run into a bug
or an issue with a technology
345:51 - you're really familiar with, and
you think it shouldn't be
345:54 - breaking, this is your chance to
pop an issue into their open
345:57 - source code repository and
potentially improve the tool.
346:00 - They don't have an open source
code repository, you throw that
346:03 - closed source piece of shit into
the garbage, but just kidding
346:06 - closed source Tech has its place
in our lives, too. Additionally,
346:09 - if you're following a tutorial,
and they have a Git repo
346:12 - associated with it, like all of
my videos that do, that's gonna
346:16 - be the best place to leave your
issues. So as much as I hate to
346:19 - say it, putting your issues onto
my GitHub repositories is going
346:22 - to be much more effective for us
answering your questions than
346:25 - posting it in the YouTube
comments. Now finally, Discord,
346:29 - element, email, text message or
any other these unindexed chats
346:33 - are still good places to ask
questions, but please try to use
346:36 - them as a last resort. And if
they do end up answering one of
346:39 - your questions, maybe go back
and add that question and answer
346:42 - to one of the other forums that
we were talking about this way
346:44 - it will be indexed next time you
or somebody else, Google's it
346:47 - now these quicker chat forums
are places more for the
346:50 - community to congregate and have
quick conversations with each
346:53 - other. They're places to theory
craft, talk about new things
346:56 - coming out new ideas, events,
and other things that shouldn't
347:00 - be indexed by web crawlers.
They're also great places to
347:03 - meet and network with people
that you might be able to bounce
347:06 - ideas off directly as you get to
know each other, which leads
347:09 - into our last section. But
before we do that, Oh, do you
347:12 - hear that? Oh, that's the video
inside another video alarm
347:17 - ringing. When you ask a question
in one of these forums, the
347:20 - better you format your
questions, the better chance
347:22 - you'll have of getting an
answered. Now there's no bad
347:25 - questions out there. But there
are poorly formatted questions.
347:28 - So let's teach you how to always
ask questions as format as best
347:31 - as possible to give you the
highest chance of making sure
347:34 - they get answered. Number one,
before asking your question,
347:37 - make sure you followed all the
steps in the parent video. And
347:40 - you've done some research on
this already and make sure the
347:43 - question hasn't already been
asked. Number two, make a title
347:46 - that summarizes the specifics of
the question three introduced
347:50 - the problem before you write any
code, add minimalistic,
347:53 - reproducible code minimalistic
code means it's not just a copy
347:57 - paste your entire file. If
you're having problems on one
348:00 - line, maybe just post that one
line reproducible code means
348:04 - that others should be able to
run to the exact same error that
348:07 - you're running into, or at least
post the steps for them to do
348:11 - it. This doesn't mean that you
should put I was following along
348:14 - Patrick's video and on our five
I ran into this problem, just
348:17 - watch his video and you'll get
there. As flattering as this is
348:20 - it's not reasonable that
everyone is going to have
348:22 - watched my videos, even though
they should you want to give the
348:25 - technical steps to reach the
error that you've reached. For
348:28 - those of you watching my Free
Code Camp video, you're kind of
348:30 - exempt from this, but you can
only say, Hey, I was on our Five
348:34 - on this part of your video
inside of our discussions tab of
348:37 - the GitHub repo associated with
this course. So you can do that.
348:41 - But only in that GitHub repo
associated with this course,
348:44 - learning markdown to format your
code, especially using these
348:48 - three backticks and labeling of
the language. This is a critical
348:53 - piece of formatting your code
and will drastically improve on
348:56 - the number of people who answer
your questions. Any errors or
348:59 - code should be formatted with
this three backticks syntax. And
349:03 - finally, often people who care
about certain technologies,
349:06 - monitor specific tags and
monitor specific questions being
349:10 - asked about the technologies
that they like. And then
349:12 - finally, again, be sure to read
the forum's guides before
349:15 - posting different forums have
different rules about what they
349:18 - want and what they don't want.
So being familiar will increase
349:21 - your chances of getting an
answer. All right. So now back
349:24 - to the main video. Now a note
about Stack Overflow, in
349:26 - particular, Stack Overflow can
be a little aggressive, which is
349:30 - why sometimes posting on
specific community forums might
349:32 - be better for your specific
technology questions. If you
349:35 - post on Stack Overflow, and you
get a ton of down votes on your
349:38 - questions. Don't let that bother
you. Just take it as a learning
349:41 - opportunity to learn about what
Stack Overflow likes and doesn't
349:44 - like and just keep going but do
not let that discourage you.
349:48 - Okay, well, now that we know
where things should go, where
349:51 - questions should go and how to
actually format them. Let's
349:55 - practice let's look at some
sample questions that you might
349:57 - have. And we'll figure out where
we want to put them. So the
349:59 - first one, where does this one
go? Feel free to pause and guess
350:02 - yourself. So a question like
this is going to be great for a
350:05 - Reddit or a discord? Probably
more a discord. Now, this is
350:09 - definitely something that you
can search for. Right? So you
350:12 - probably could search for this,
find an answer and go from
350:15 - there. But maybe you want to ask
a buddy or maybe you want to ask
350:17 - a very specific community like
our slash eat Dev. Now, of
350:20 - course, if you see this
question, you obviously want to
350:22 - recommend Patrick Collins his
YouTube channel. Now how about
350:25 - this question. Notice its
formatting right? The title is
350:28 - nice and big. They have a
technical command that is
350:32 - formatted properly. They have
Git commit which is formatted
350:34 - properly, where would this go
like this would definitely do
350:37 - very well on a Stack Overflow or
an index code based forum to
350:41 - very clearly try had to do
something technical. The problem
350:44 - is laid out very clearly. And
they've given the command that
350:47 - they're looking to do. Now, how
about this one, something like
350:50 - this could go on either
StackOverflow. But it's probably
350:52 - more likely going to go on a
GitHub issue for this brownie
350:56 - package. A big difference
between code forums and and Git
351:00 - repos like GitHub is that when
you make an issue on a GitHub
351:03 - repository, especially when you
think there's a problem, you do
351:06 - want to be as in depth as
possible. So oftentimes, when
351:09 - making an issue on these repos,
they'll even ask, what version
351:12 - are you using? Can you post all
your code? Can you post all your
351:15 - files and just be much, much
more explicit? So how about
351:18 - something like this. So this is
going to be really good for the
351:21 - GitHub repo associated with this
tutorial, it looks like this
351:25 - person is asking about a very
specific tutorial. So posting
351:28 - this, there is going to be best.
Now if your question is on a
351:32 - tutorial that doesn't have a
GitHub repo, well, they probably
351:35 - should. But then maybe this is
better in the comment section.
351:38 - Now, again, this is where this
all becomes a little bit more
351:42 - art than science, because maybe
the specific error that they're
351:45 - running into is a generic error
that a ton of people run into,
351:48 - and maybe it is better on
StackOverflow. Or maybe there's
351:51 - an issue with the package. So
maybe it is better on GitHub. Or
351:55 - maybe the solution to this is
opinionated. And finally, what
351:58 - about this? Yep, this is going
to be much better for a discord
352:01 - or a DM with your buddy. And
away, it's our last step on
352:04 - blocking you from any question
is going to be join and
352:06 - strengthen the community of your
tool. Now at the start, it's
352:09 - going to be hard for you to give
back since you're not going to
352:11 - be very knowledgeable on these
tools. But as you get better at
352:13 - these technologies, you'll want
to try to answer some of these
352:16 - new questions that do come in.
The reason is because this will
352:18 - give you a chance to actually
learn more about the tools that
352:21 - you like, it'll strengthen the
community of your favorite
352:24 - tools, meaning if you help
answer questions on tool, it'll
352:27 - actually encourage other people
to use the tool because there's
352:30 - a strong following there. And
likely, they might actually help
352:33 - you sometime in the future, you
helping people will make you
352:35 - look like a good person. And
then you'll also feel like a
352:38 - good person. Additionally, in
many forums like Reddit,
352:41 - oftentimes, mods will actually
look at how often you post
352:44 - versus how often you help others
and comments on others people
352:47 - posts and some mods may actually
start blocking your posts for
352:50 - abusing the forums and not
giving back to the community and
352:53 - only trying to take knowledge
you in the community will be
352:55 - more successful if you join in
and help others and not just try
352:59 - to extract things from other
people. Additionally, by
353:02 - engaging with the community, I
can't tell you how many people
353:05 - I've met and I've learned and
been able to brainstorm with.
353:09 - And then the final step is going
to be iterate through these
353:11 - steps. Maybe you get to the end
of these and you say, Oh, I'm
353:14 - still blocked, but you'll likely
be much, much more
353:18 - knowledgeable. So you want to go
back and try these steps again.
353:21 - Now this is where this whole
process is a little bit more art
353:24 - than science. Because some
questions might not have been
353:27 - discovered yet. Only very few
people know not enough people
353:30 - understand the importance of the
questions, or maybe people don't
353:33 - understand your question. And
this is why it's important to go
353:36 - back and iterate on these steps.
Now that you have the basic
353:39 - building blocks of this
incredible superpower, I
353:41 - encourage all of you to go out
there and try this and then let
353:44 - me know how it went.
353:48 - Alright, awesome. So now that we
know more about how to get
353:51 - unblocked, we can move on. The
reason it's so important to
353:54 - learn how to get unblocked is
because blockchain and web three
353:57 - is more than just everybody on
their own. It is a very
354:00 - collaborative space. So as you
get better, and as you learn
354:04 - more a massive way to test how
much you've learned and give
354:07 - back to the community is to
going to Stack Overflow and
354:09 - going to stack exchange them and
trying to answer some questions
354:13 - yourself. So I highly recommend
you all go to Stack Overflow,
354:16 - and then you go to the GitHub
repo associated with the scores,
354:19 - you try to answer some
discussions, try to answer some
354:22 - issues and help other people out
because it's going to help you
354:24 - become a much better software
engineer. The other reason I
354:28 - want to do that part is because
when we install some of the
354:31 - tools that I'm about to show
you, sometimes the installation
354:34 - process is the hardest piece
there. Once you get past the
354:38 - install process, it generally
becomes much, much easier. But
354:41 - this can often be the hardest
part of the course is just
354:44 - installing some of these tools
that we're going to give you.
354:47 - And that's what we're going to
learn about right now. So we
354:50 - have been working so far with
remix, remix IDE, or integrated
354:54 - development environment. As
we've seen, it's this wonderful
354:57 - place where we can try out code
we can try solidity out, we can
355:00 - compile we can deploy, we can
pretty much do everything that
355:02 - we need to do. It's web based.
It can do testing, debugging,
355:05 - deploying local JavaScript VM,
it's very quick and easy to
355:09 - create and test our smart
contracts. However, it does have
355:12 - some limitations. It can really
only deal with smart contract,
355:15 - it can't really integrate with
other parts of projects. It has
355:18 - limited support for tests or
custom deployments. And you need
355:21 - an internet connection to even
work with remix and it can be
355:25 - tricky to do a lot more advanced
functionality. So it's a
355:28 - phenomenal tool and absolutely
if you're looking to do
355:30 - something very quickly, I
absolutely recommend everybody
355:32 - just go to remix to go ahead and
try something out how are now
355:35 - we're going to move over to a
more professional smart contract
355:38 - developer setup. And this is
with hard hat. This is known as
355:42 - a smart contract developer
framework similar to brownie or
355:45 - foundry or, and likes, there's a
number of these frameworks. And
355:49 - the reason that we're going to
do hard hat is because hard hat
355:51 - is JavaScript based. It's a
JavaScript based development
355:55 - environment. It's got JavaScript
based compilation, environment,
355:58 - deploying, testing, debugging.
Now, for those of you who love
356:02 - TypeScript, we will also have
TypeScript editions of every
356:06 - single one of our code examples
for you. So if you love
356:09 - JavaScript, we got you, if you
love TypeScript, we also got you
356:12 - we're not always going to walk
through us doing the TypeScript.
356:16 - But we will sometimes, and all
of the code for the TypeScript
356:20 - will be available in the GitHub
repo. Now, before we can
356:23 - actually learn hard hat, we have
to learn another package first.
356:26 - So we're going to learn how to
do everything with ethers. Jas,
356:30 - which is a JavaScript based
library for working with smart
356:33 - contracts. And it's also what
powers the next tool that we're
356:36 - going to be working with, which
is hard hat under the hood of
356:39 - hard hat. There's a lot of
ethers Jas. So it's important
356:41 - for us to learn ethers Jas so
that we can understand what hard
356:45 - hat is actually doing. Now for
the rest of the course, I'm
356:47 - going to be using a code editor
called Visual Studio code. This
356:51 - is one of the most powerful code
editors on the planet. And if
356:54 - you've already got it set up,
feel free to go ahead and skip
356:57 - this part. If you already have a
professional coding setup with
357:00 - no GS and VS code, and Git and
everything, feel free to use the
357:03 - timestamps in the GitHub
repository. To skip over this
357:06 - setup section. You'll often hear
people refer to this as VS code,
357:11 - or Visual Studio code or just
Visual Studio. However, it's
357:14 - important to note that Visual
Studio code this is different
357:18 - than Visual Studio, which you
might see look like this. So
357:22 - Visual Studio code is what you
want, not Visual Studio, Visual
357:26 - Studio is a different
application, make sure you're on
357:29 - Visual Studio code. Now, if you
choose so and you're a total
357:33 - Harto, you can absolutely work
just with your terminal, or just
357:37 - with PowerShell, or just with
whatever coding environment that
357:40 - you want, like atom or Sublime.
However, for us, we're going to
357:44 - be working with Visual Studio
code. And I'm going to be going
357:47 - through setting up Visual Studio
code the way that I like to set
357:51 - it up, you can actually set it
up whatever way that you feel
357:54 - comfortable. And of course, in
our lesson six here, we have a
357:58 - link to installation and setup.
And I'm going to be adding more
358:01 - links as we go about here. And
once again, all the code that
358:04 - we're going to be working with
is in this GitHub repository
358:08 - down here where it says code.
Now we're gonna go through three
358:10 - different installation processes
and pick the one that's most
358:13 - appropriate for you. The first
one is going to be for Mac and
358:17 - Linux users. The second one is
going to be for Windows users.
358:21 - And then our third one is going
to be a last ditch effort. If
358:24 - for whatever reason, you can't
get Windows or Linux or the Mac
358:28 - instructions to work, we're
going to use a Git pod
358:31 - installation. Now, I highly,
highly recommend that you try to
358:34 - get everything working locally
without using Git pod. However,
358:38 - if for whatever reason, you
can't get those installation
358:42 - pieces to work, we will have Git
pod instructions for all of the
358:46 - repos that we work with here.
But to get started, we'll start
358:48 - with the Mac and Linux
installation instructions.
358:54 - The first thing you're going to
want to do is download the Mac
358:57 - or if you're working with Linux,
download the Linux installation
359:01 - of Visual Studio code. Once you
have it installed, it'll look a
359:04 - little something like this. And
if it's a fresh installation,
359:08 - It'll even give you some tips
and tools to actually get
359:11 - started. If you've never worked
with Visual Studio code before,
359:14 - I highly recommend going through
any get started or getting
359:17 - instructions tips that come with
opening Visual Studio Code.
359:21 - Additionally, we have a Visual
Studio Code crash course in the
359:25 - GitHub repo associated with this
course. Once you have Visual
359:28 - Studio code installed, the next
thing that we're going to want
359:31 - to install is going to be node j
s. And again, we have links to
359:34 - all of these in the GitHub repo
associated with this course, you
359:37 - can just go ahead and click
download for Mac OS or download
359:40 - for Linux, I recommend using the
LTS version. lts stands for long
359:45 - term support, which means that
they will be supporting this
359:48 - version for a long time. So go
ahead and download Node js. I've
359:53 - already downloaded this, so I'm
not gonna go ahead and
359:55 - redownload this now one of the
awesome things about Visual
359:58 - Studio code is it has this thing
called terminals, which are
360:01 - command line prompts that allow
us to run scripts, basically,
360:05 - it's where we're going to be
running all of our code where we
360:07 - can open up the terminal is we
can go ahead and hit terminal
360:10 - and select new terminal and
you'll get something like this.
360:14 - Now you might have bash or Z ca
or some other type of shell type
360:18 - that you have doesn't really
matter because on Mac and Linux
360:21 - it's going to be Linux based we
can now test our no Jess
360:25 - installation has been done
correctly by running Node dash
360:29 - dash version, and you should see
something that looks like this.
360:33 - The exact version of node that
you have doesn't really matter
360:37 - here. But ideally you're at
least on Node version 14 or
360:40 - higher. And if something like
this doesn't show up, remember
360:43 - to go ahead and start looking at
Stack Overflow looking on the
360:46 - GitHub repo in the discussions
tab, looking on the updated
360:49 - section, etc. And like I said,
sometimes installing this can be
360:52 - the hardest part of this entire
course so, so don't get
360:55 - discouraged. And please use
Stack Overflow Stack Exchange
360:58 - Etherium, and the GitHub repo to
move past any issues you run
361:01 - into. Now, if you're on Mac or
Linux, you can actually hit Ctrl
361:05 - back tick, to actually toggle
your terminal mode, this will
361:08 - pull the terminal up and down
for you getting familiar with
361:11 - keyboard shortcuts will actually
make your life a lot easier.
361:14 - Because you'll be able to move
around Visual Studio code much
361:17 - more effectively, we have a link
to a list of keyboard shortcuts.
361:21 - Additionally, in the GitHub
repository associated with this
361:24 - section, as we move along, I'll
give tip on different keyboard
361:27 - shortcuts that you can
optionally use otherwise, you
361:29 - can just go ahead and click as
well, you can click the trash
361:32 - can to delete the terminal, go
back up Terminal new terminal to
361:36 - pop it back up. Now the next
thing that we're going to need a
361:38 - little bit later, we're not
going to need it for this
361:39 - section, but it's good to
install it now is going to be
361:42 - git no jazz is known as a
JavaScript runtime. And it's a
361:46 - tool that we're going to use to
help run JavaScript code in our
361:49 - Visual Studio Code slot exactly
JavaScript. And the difference
361:52 - between no Jas and JavaScript
can be a little bit confusing,
361:55 - but don't let that stop you for
now. Next, we're actually going
361:58 - to go ahead and install Git, we
will have links to the
362:00 - installation instructions in the
GitHub repository, installing
362:03 - git on Linux, you're going to
use one of these two commands
362:06 - and on macOS, if you just type
git on the command line, it
362:10 - should go ahead and prompt you
to install it. So we're back in
362:12 - our command line, and we just
type git, it should prompt you
362:15 - to go ahead and stall it. And if
you do get dash dash version,
362:18 - you should get something that
looks like this. You can also
362:21 - use a Mac OS get installer by
clicking this link here and
362:24 - running through the installation
process. Alright, now that you
362:26 - have no JS yet in Visual Studio
code installed, we can continue
362:31 - on to the next section. Awesome.
If you're not planning on using
362:35 - Windows or get pod, feel free to
skip the next two sections.
362:41 - I'm running this on Windows 11.
However, it should work on most
362:44 - editions of Windows. So the
first thing that we're going to
362:47 - want to install is Visual Studio
Code, which looks something like
362:53 - this, it should auto detect it.
And we're gonna go ahead and
362:56 - download this for windows in a
walk through all the
363:00 - installation process. Go ahead
and create a desktop item, we'll
363:04 - add this just in case we want to
open with code. And we'll go
363:08 - ahead and install. And then
we'll go ahead and finish. Once
363:12 - you've installed Visual Studio
code, you'll see something that
363:14 - looks a little like this, it'll
go ahead and give you this get
363:17 - started with VS Code section
where you can choose some
363:19 - themes, and you can choose kind
of the way it looks feel free to
363:22 - customize it the way that you
want. If you want to learn a
363:24 - little bit more about Visual
Studio code, I highly recommend
363:27 - you walk through this section to
learn more about the shortcuts
363:30 - and making your development
experience more efficient. When
363:33 - you're done, you can just go
ahead and close the tabs at the
363:36 - top. And it'll look a little
something like this. Once we
363:38 - have Visual Studio code
installed. The next thing that
363:41 - we're going to want to install
is node j s. And of course, we
363:44 - have a link to installing this
in the GitHub repository
363:46 - associated with this course,
what we're going to do is we're
363:48 - going to go ahead and come to
node j s.org. To download this
363:52 - for Windows node. JS is a
JavaScript runtime environment,
363:55 - it's not exactly JavaScript. And
the distinction can be a little
363:58 - bit confusing, but just know
it's going to help us run our
364:01 - JavaScript code for our
development environment. Let's
364:03 - go ahead and download the LTS or
the long term support edition of
364:08 - no GS. We'll go ahead and we'll
run through the setup wizard.
364:15 - And we'll go ahead and make sure
that this is clicked just in
364:18 - case we ever want to use some
different tools with our setup.
364:21 - And then we'll go ahead and
click Install, you'll get a pop
364:24 - up asking if you really want to
install this on your device. And
364:27 - we'll go ahead and hit yes. And
then we'll hit finish, you might
364:30 - get a pop up that looks like
this, go ahead and click any
364:33 - button to go ahead and install
the tools, go ahead and press
364:35 - any key again. And you'll likely
get a Windows PowerShell screen
364:39 - pop up asking you to go ahead
and install a whole bunch of
364:42 - different projects and files. If
you chose not to install this,
364:45 - that's totally okay. But in the
future, this will be really
364:47 - helpful since we are going to
use a lot of tools that this
364:50 - package installs anyways, this
might take some time to install.
364:54 - So go ahead and be patient. And
if it gets stuck, it might just
364:56 - be waiting for you to go ahead
and hit enter. So go ahead and
364:59 - hit Enter for any prompts. But
yes, please be patient with
365:02 - this, it can be a little bit
slow to go ahead and install
365:04 - everything. Once you have all
that installed, you can come
365:06 - back to Visual Studio code. And
we're going to go ahead and open
365:10 - up a terminal. To do that we hit
terminal and we hit new terminal
365:13 - terminal is going to be our
command line prompt where we're
365:16 - going to basically run all of
our scripts to work with our
365:19 - code. And if you run Node dash
dash version, you should see
365:23 - something that looks like this
to know that you've installed
365:26 - Node js correctly. Now this
command line is known as Windows
365:30 - PowerShell. If you want to work
with Windows PowerShell, you
365:33 - absolutely can. In fact, if you
want to be a total Harto, and
365:36 - write all your code through
Windows PowerShell, you can
365:38 - absolutely do that as well.
However, we're actually not
365:40 - going to be working with
PowerShell We're going to be
365:42 - using a tool that makes our
Windows environments more like
365:46 - Linux. The reason that we're
doing this is Linux is the
365:48 - standard for most development
environments. And having
365:51 - everybody work on a very similar
setup will make the rest of this
365:54 - course a lot easier for everyone
to interact with each other, no
365:57 - matter what coding environment,
they're working on. WsL stands
366:01 - for Windows subsystem for Linux,
and allows Linux programs to run
366:05 - natively on our Windows
environments. To get this setup,
366:09 - we're gonna go ahead, go to the
WsL install. And we'll have a
366:14 - link for this as well in our
GitHub repository. So what we're
366:19 - going to do, you must be running
a Windows 10, version 2004 or
366:23 - higher, or Windows 11. If you're
using an older version of
366:25 - Windows, you can absolutely
continue with PowerShell. But
366:28 - you might run into some issues
where all the commands don't
366:31 - work exactly the same. So I
highly recommend working on a
366:34 - newer version of Windows. To
install this back in your Visual
366:40 - Studio Code, PowerShell, or just
the PowerShell app, or running
366:43 - WsL dash dash install. Now if
you get this error, the
366:48 - requested operation requires
elevation, it means that we have
366:52 - to run our Visual Studio code or
our PowerShell application as
366:55 - administrator. We close out our
Visual Studio code. And right
367:03 - click it and say, Run as
Administrator, we get a little
367:07 - pop up saying Do you want to
allow this app to make changes
367:09 - to your device, we'll go ahead
and click Yes. And then we'll
367:13 - reopen the terminal. And then we
can run WsL space dash dash
367:18 - install. And we'll go ahead and
install WsL. This may take a
367:23 - little bit so please be patient.
367:25 - Once it's completed, you'll see
something that looks like this,
367:28 - we're going to be working with
Ubuntu. And we have a list of
367:31 - different commands to change
your Linux distribution. If you
367:34 - choose to do so. And you'll see
the request set operation is
367:36 - successful changes will not be
effective until the system is
367:40 - rebooted. So you'll want to go
ahead and restart your computer.
367:43 - There's also a troubleshooting
guide in the GitHub repository.
367:46 - If you run into issues after you
restart your computer, you'll be
367:49 - prompted for a name for your new
system and a password. This can
367:52 - be different from your Windows
name and password, and then just
367:55 - follow through with all the
prompts. And then once you're
367:57 - done, you'll be dropped into a
Ubuntu shell, and you can run
368:00 - Linux commands. Now you'll have
a Ubuntu instance, on your
368:04 - machine. And you'll be able to
run Linux commands in your
368:07 - terminal. Now that we have WsL
set up correctly, we're going to
368:11 - head back over to Visual Studio
code. Once we have WsL, we'll
368:15 - want to go ahead and install an
extension. So in our Visual
368:18 - Studio code, we'll go to
Extensions, and we'll look up
368:21 - remote development you can
install the whole thing or just
368:28 - remote WsL we're gonna install
the whole thing you can follow
368:33 - along to get started with remote
WsL if you like, or you can just
368:37 - follow along with me right now.
Right now if I go to the
368:40 - terminal and hit new terminal,
I'm still gonna get PowerShell
368:45 - we actually want this to be our
Linux shell. So there are a
368:48 - couple ways to open Visual
Studio code up in our Linux
368:51 - environment. One way is you're
gonna hit Ctrl, Shift P and type
368:57 - WsL. And then click remote WsL
new WsL window, and you'll get a
369:03 - new window that looks like this,
you can also click the bottom
369:06 - left and choose New WsL window.
Now if we go to our terminal and
369:12 - hit new terminal, we'll be
dropped into a bash shell and we
369:15 - can run Linux commands in here.
Awesome. Another way we can open
369:18 - up Visual Studio code with WsL
on is we can go into our your
369:22 - boon to application, we can make
a folder by typing MK dir
369:29 - folder, we'll CD or change
directory into folder and type
369:34 - code period. We'll go ahead and
trust the authors in here. And
369:38 - this will open up Visual Studio
code already connected to the
369:42 - folder that we're in. And we can
create files in this folder like
369:45 - hi dot txt, and those will get
created inside the folder in our
369:50 - WsL. Now that we're inside our
WsL environment, you'll notice
369:53 - that node dash dash version
doesn't work anymore. That's
369:56 - because we installed it on our
regular Windows machine and not
370:00 - on our WsL or Linux environment.
The reason we installed it on a
370:04 - Windows environment first is
that just in case you wanted to
370:07 - go ahead and use PowerShell or
user Windows environment to run
370:10 - everything you still can just
remember if you use the Windows
370:12 - environment and PowerShell all
the commands that we use might
370:15 - not work for you. So we're gonna
go ahead and install Node js on
370:20 - our Linux environment. Now, all
the commands that we're going to
370:22 - write are going to be in the
GitHub repo associated with this
370:25 - course. We're going to do a curl
command to the nvm repository,
370:31 - which stands for node version
manager.
370:44 - And we're going to pipe the
install script into bash. And
370:47 - this will go ahead and install
and VM. After running that, go
370:52 - ahead and trash the terminal,
and then reopen it. And then we
370:57 - can type MBM dash dash version
to see if it actually installed
371:02 - correctly. Once we've installed
nvm, we can go ahead and install
371:05 - no GS using nvm. Just type npm
install, and we'll do 16 point
371:13 - 14.2 Is that same long term
support version we installed on
371:16 - our Windows machine. Once we
have it installed, we can type
371:20 - in Node dash S version. And now
we have no JS installed. Now I
371:24 - know there was a lot here, but
if you made it this far, this is
371:27 - fantastic. You've done a great
job to push through to this
371:31 - point and get everything set up
so you can code in the best
371:34 - environment there is. So if
you've made it this far, huge
371:36 - congratulations. Now the next
thing that we're going to
371:39 - install is Git. And now we're
not going to use Git for this
371:42 - lesson. However, we will
definitely be using it in the
371:45 - future. See if gets installed
type git dash dash version,
371:49 - sometimes Linux will
automatically come with Git
371:51 - installed and you'll see
something output like this. If
371:54 - you don't have Git, we can just
look up the get install. Which
371:58 - again, link to this is in the
description. And you'll actually
372:01 - run the installing on Linux. Now
again, now if you want to use
372:06 - PowerShell, and you want to do
everything with Windows, you can
372:09 - absolutely follow the installing
on Windows instructions here
372:11 - instead, when you're working in
WsL, you'll want to use the
372:15 - Linux commands instead of the
windows commands even though
372:18 - you're on a Windows because WsL
makes it so that you're
372:21 - basically running in a Linux
environment. And now if you've
372:24 - made it this far, you should be
able to follow along with the
372:27 - Mac and Linux instructions as if
you're running on a Mac and
372:30 - Linux even though you're running
on Windows. Just be sure that
372:33 - whenever you're in your VS code,
you take a look at the bottom
372:36 - left and make sure you're on WsL
Ubuntu. Like I said before, if
372:40 - you want to run in PowerShell,
or in a Windows environment,
372:42 - you're more than free to do so.
But like I said, if you've made
372:45 - it this far, huge
congratulations. Awesome work.
372:51 - And then finally, our last setup
is going to be using a tool
372:54 - called Git pod starting from
Lesson five. The lesson that
372:57 - we're on right now, ethers,
jazz, simple storage, all of our
373:00 - code repos are going to come
with a button in the repo scroll
373:04 - down, they'll come with this
open in get pod button. Now git
373:08 - pod is a cloud development
environment where you can
373:11 - actually run your code on a
remote server, it's kind of
373:16 - similar to remix IDE, but it
allows you to run Visual Studio
373:20 - code in the browser or connected
to another server. This is good
373:25 - because then you don't have to
do any installation on anything.
373:28 - Since all the tools that you can
want to use are just going to be
373:31 - running on this remote server.
This has its downsides, though,
373:34 - obviously, since you'll only be
able to code if git pod is up
373:39 - and working for you.
Additionally, when it comes to
373:41 - private keys, you absolutely do
not want to run any code with a
373:45 - private key that has real money
in good pop. Why? Well, once
373:49 - again, since you're running your
scripts on a remote server,
373:53 - those servers have access to
your private keys. But since
373:57 - you've Pinky promise that for
this course, you're not going to
374:00 - be using a meta mask or a
private key with actual money in
374:03 - it, it should be fine. The other
downside is that these often
374:07 - cost money to use and get pot
isn't free. But it's an option
374:11 - if you absolutely cannot get any
of the installation working. So
374:15 - if you go ahead and you hit this
opening get pod button, you'll
374:18 - get a welcome to get pods
showing up. We're gonna go ahead
374:20 - and continue with GitHub. Since
you've signed up for GitHub
374:24 - here, you want to go ahead and
authorize get pod. And it'll go
374:29 - ahead and start creating this
workspace for you. And you'll
374:32 - notice it looks exactly like
Visual Studio Code. Since I
374:36 - opened the repo up in Git pod,
it came with all the code, and
374:41 - you can even open this workspace
up in VS code desktop. So this
374:47 - is might be a little bit
confusing. But basically, you
374:50 - can run off of Git pod using
your local Visual Studio code.
374:54 - And if you see git pod here,
that's how you know that you're
374:57 - running off of Git pod. If you
see this pop up, do you want to
375:00 - open this workspace in VS code
desktop, you can hit Open. And
375:04 - it'll ask you if you want to
open up Visual Studio Code,
375:07 - which I'm going to go ahead and
hit yes. And you'll get
375:10 - something that looks like this
on your Visual Studio Code.
375:13 - It'll tell you that it wants to
install the Git pod extension,
375:16 - and then open that Git pod URL.
So you can go ahead and install
375:20 - it. Reload window and open and
it's going to go ahead and start
375:25 - connecting to our the Git pod
workspace. And this is going to
375:29 - be the same as running git pod
in the browser here. Or you can
375:34 - also do it manually by hitting
the Git pod in the bottom left,
375:38 - and then type in open in VS code
375:43 - And then you should be able to
run it in your Visual Studio
375:45 - code. For now, I'm going to
recommend that if you're using
375:48 - Git pod, just stay in the
browser, just so that you know,
375:51 - okay, I am running this on a
remote server. And just as a
375:55 - reminder for you that you're not
actually locally developing. And
375:59 - hopefully, this will be a
trigger to not actually put any
376:02 - special private keys or anything
like that. But you can make
376:05 - workspaces, you can make new
folders, and you should be able
376:08 - to run all the commands on here,
as if you are running locally
376:11 - with Visual Studio code. To open
up the terminal, you can hit
376:14 - this little bar at the top left,
go to terminal, new terminal, or
376:20 - use CTRL tilde exact same as Mac
OS and Linux keyboard shortcuts
376:25 - to create a new folder, we can
change directory, CD, dot.mk,
376:30 - dir, new folder, MK dir makes
make directory called New
376:36 - Folder. And then we're going to
change our directory into a new
376:39 - folder, and hit enter. And now
we're in that new folder. For
376:42 - each section, you can either
open up the entire source code
376:46 - right into GitHub, or you can
create a new folder for each
376:50 - section yourself and start from
blank. And then you would just
376:53 - type code period. And you'd be
in a brand new folder. All
377:01 - right, this is fantastic. At
this point, you should be set up
377:04 - with Visual Studio Code no Jas
and get. And I'm going to be
377:09 - working out of a folder called
Hard Hat Free Code Camp at this
377:12 - point, you should have node,
dash dash version, get dash dash
377:18 - version. And if you're using
Windows, this should say WsL or
377:22 - your boon to or something like
that. And if you have all that,
377:26 - that means we're ready to go.
Now a quick note something that
377:29 - you'll see me do a lot. And you
can do this as well. Oftentimes,
377:33 - when my terminal gets really,
really big, or there's a ton of
377:36 - commands in here gets a little
bit overwhelming for me. So one
377:39 - thing that you can do is you can
type clear, and hit Enter to
377:42 - clear it. Or what you can do is
you can hit Command K, if you're
377:47 - on a Mac, or Ctrl K, if you're
on a Linux or a Windows, and
377:52 - it's one of my favorite keyboard
shortcuts that I use all the
377:54 - time. Additionally, the trash
can and the X here are very
377:58 - different. If I go to a couple
of enters here, and we're down
378:02 - here, if I hit the trashcan, and
then pull my terminal back up,
378:06 - by doing the toggle, or by doing
terminal new terminal, you'll
378:10 - see all those lines are still
here. But if I hit the trashcan,
378:14 - and then pull the terminal back
up, you'll see it actually
378:17 - refreshes mine a special command
that prints stuff out. trashing
378:22 - your terminal is basically
deleting whatever's running in
378:24 - it, and the x is just hiding it.
And as hitting Ctrl tilde or
378:29 - toggling our terminal or
whatever command it is on your
378:32 - environment, that's equivalent
to hitting the hide, not the
378:35 - trash. So if we want to remove
and start a terminal over, we
378:38 - hit the trashcan, and then we
pull it back up. Alright, so now
378:42 - we're gonna start working with
ethers. And we're going to start
378:44 - learning to code, our
transactions and our contract
378:48 - deployments and everything
programmatically at a relatively
378:51 - low level. And we're gonna learn
how to deploy and interact with
378:54 - the contracts using the ethers
JS package. Now to get started,
378:58 - I'm going to recommend you
create a folder where you're
379:00 - going to put all of your
projects in it, I'm going to
379:02 - create a new directory called H
H. hyphen, FCC, which stands for
379:07 - hard hat Free Code Camp. And
once we run that command, we can
379:11 - cd into hh FCC. And this is
where we'll create all of our
379:15 - projects for this course moving
forward, so that we have them
379:18 - all in one place. Now to get
started, whenever you create a
379:21 - new project, you always want to
create a new folder. So to
379:25 - create a new folder, we're going
to do MK dir, and we're going to
379:28 - call this ethers, simple
storage, like that. And now, if
379:35 - you type ls, you'll see that
there is one folder named
379:40 - ethers, simple storage. ls is
how you list all the contents of
379:45 - your folder. You might have a
lot of other folders in here, I
379:49 - only have the one since I
created this new folder for
379:52 - this. Now what you can do, you
can type code, ethers simple.
379:57 - And then if you hit tab, it
should autocomplete for you. And
380:01 - if you enter, Visual Studio code
should open up a new Visual
380:06 - Studio code for you. That is
inside of either simple storage
380:13 - if you open up your terminal
now, your home directory for
380:16 - this workspace is going to be
through simple storage as this
380:19 - is what pops up. If that doesn't
work for you, we can also do is
380:23 - you can hit File, Open folder
and then open the folder that
380:28 - you just created or that you
want to open this again we'll
380:32 - open up VS code. And if we open
up our terminal we see we're
380:35 - inside of ether simple storage.
This is so powerful because as
380:38 - we create files
380:41 - we'll be able to See those files
in our Explorer here, this
380:45 - button here stands for the
Explorer. If we click it, we can
380:48 - see the different files in here.
And I'm going to go ahead and
380:51 - actually delete this file dot
txt, because we're not actually
380:54 - going to use that. Now it's this
part of the course, where we're
380:57 - actually going to start jumping
into some JavaScript. Since this
381:01 - course is in JavaScript course,
if you're unfamiliar with
381:04 - JavaScript, it might be a little
bit tricky. If you want to come
381:07 - into this with a better
understanding of JavaScript and
381:10 - Node js, there is a Free Code
Camp YouTube video teaching No,
381:14 - Jas for beginners. And a link to
this will be in the GitHub repo
381:17 - associated with this course.
There's also a JavaScript Free
381:20 - Code Camp video that I'm also
going to put in the description
381:23 - for this course, keep in mind
that JavaScript and Node js are
381:26 - slightly different. And we are
going to go over some of the
381:29 - differences as we code along
here. But for the most part,
381:33 - learning one means you've
learned the majority of the
381:35 - other. So if you want to pause
and go through these videos,
381:38 - before continuing here, please
feel free to do so you don't
381:42 - have to, you can absolutely
continue on with the course as
381:45 - is. And if you get confused or
stuck on some JavaScript piece,
381:50 - feel free to pause, Google it
and come back. But just to
381:54 - reiterate, you can check out the
JavaScript programming full
381:56 - course. And also the Node js
full course, as those are both
382:00 - going to help you. Like I was
saying before, Node js is a
382:03 - JavaScript runtime. So it's not
exactly JavaScript. But we're
382:08 - going to write our code in
JavaScript. And if that's
382:10 - confusing, just don't worry
about it right now. And as we go
382:14 - through this course, I'll show
you where the differences are.
382:17 - But basically, you can think of
no Jas and JavaScript kind of
382:20 - being the same thing. The big
thing about Node js is it allows
382:23 - us to write JavaScript code in
the back end, as opposed to
382:28 - running JavaScript on the front
end, JavaScript is made to be a
382:31 - browser run language, like
running inside of, you know,
382:35 - Chrome, brave Firefox, etc. No,
Jas allows it to become a a
382:40 - scripting language, a back end
language, which is why the
382:43 - syntax between the front end
JavaScript and the back end
382:46 - JavaScript or the no JS
JavaScript are going to be a
382:49 - little bit different.
Additionally, as we go along in
382:52 - this code, if you're familiar
with TypeScript, all of our code
382:56 - is going to come with a
TypeScript edition. TypeScript
382:59 - is what's known as a statically
typed version of JavaScript. And
383:03 - it'll be it'll be this one.
It'll be TypeScript, not
383:05 - TypeScript edition. I'll go
ahead and fix that and remove
383:08 - this one to make it clear.
TypeScript is a type safe
383:11 - version of JavaScript, which is
that's confusing, don't worry
383:14 - too much about that. But we are
going to do all of our
383:17 - programming in JavaScript. And
then if the code is different
383:20 - enough, I'll show you how to do
it in TypeScript as well.
383:22 - However, for most of them, we're
not going to show you the
383:24 - TypeScript editions, because
it's going to be really similar.
383:27 - But you can always refer back to
the GitHub repository to see all
383:30 - the code for the TypeScript.
Now, if you're new to this
383:32 - space, I actually do recommend
you go ahead and start with
383:36 - JavaScript and learn how to do
TypeScript later on. TypeScript
383:40 - actually catches bugs early on,
making it a lot easier to code
383:45 - your projects in the long run.
However, it does take a lot of
383:48 - extra typing. And it can be a
little bit frustrating learning
383:52 - how types work for beginners,
JavaScript is a little bit more
383:55 - loose as a language and lets us
kind of do whatever we want, but
383:59 - it can cause a headache later
on. So if you do run into some
384:01 - issues, and you do run into some
bugs, it might be a good idea to
384:04 - try TypeScript on for size, and
see how that fares. Well. Let's
384:08 - go ahead and begin working on
our local development
384:11 - environment and getting set up
to do everything in ethers Jas
384:14 - and in JavaScript. Oops. And I
actually went and renamed this
384:17 - folder to ether symbol storage
dash, FCC. Reason I added this
384:22 - dash FCC is all the GitHub
repositories associated with
384:26 - this course, all the GitHub
repos that have this dash FCC to
384:30 - know that it is part of this
hard hat JavaScript course.
384:33 - Awesome. Let's jump in. Let's
start working with solidity and
384:36 - our smart contracts locally in
Visual Studio code, as you can
384:39 - probably tell by the name of
this folder. And of course, if
384:43 - you looked at the code, this
project is going to be our
384:46 - simple storage project, but
developed locally using ethers.
384:52 - So the first thing that we want
to do is want to get in that
384:54 - smart contract code. So what we
can do is make sure we have the
384:57 - Explorer selected, we can go
ahead and right click and select
385:01 - new file and do simple storage.
So just close this for now. And
385:10 - we can copy paste our simple
storage code from our last
385:13 - section into VS code.
385:15 - If you closed remix or you
forgot where it is, you can just
385:18 - go to the ethers simple storage
FCC repo, it's simple storage
385:23 - dot Sol, and we can just copy
all the code in here and then
385:27 - come back over select Symbol
storage that Saul and paste it
385:31 - in. Now an important note about
Visual Studio code is that when
385:35 - you see this little white.up
here, it means that this file
385:39 - isn't saved to save your Git
file. To save, and it'll go away
385:45 - like that. Or what you can do is
you can hit command S or Ctrl S,
385:51 - depending on if you're on a
Windows, Mac, or Linux. Now
385:55 - you'll see here that this code
is a little bit hard to read the
385:58 - simple storage dot salt, it
doesn't have the syntax
386:01 - highlighting that we saw in
remix. So we want to go ahead
386:04 - and add a Visual Studio Code
extension to give this syntax
386:08 - highlighting. So what we can do
is come over to this bar over
386:11 - here looks like this. And if you
don't see it on the left hand
386:14 - bar, you should click these
three dots, and it should be in
386:17 - here. But we'll go ahead and
click Extensions. And what we're
386:20 - going to do is we're going to
look up, solidity plus hard hat.
386:27 - And we're going to install this
solidity plus hard hat
386:30 - extension. For VS code. Now that
we have this installed, if we go
386:35 - back over to our simple storage
dot sole, you'll see that all
386:38 - the highlighting is back in. And
now it's much easier to read.
386:42 - Right? So this is good. We have
our code in here we have our
386:45 - syntax highlighting. Now let's
add an auto format or or default
386:49 - format or right now our code is
pretty good with the way that
386:52 - it's formatted. But what if we,
we accidentally do some stuff
386:57 - like this or like this, or maybe
even like this, we add a ton of
387:05 - new lines, etc, our code can
start to look pretty gross. And
387:08 - even though the code itself is
fine, and it'll run the exact
387:12 - same way, with all this extra
whitespace, it doesn't look very
387:15 - good, right. And due to that, it
can be a little bit hard to
387:18 - read. What we want to do, then,
we want to open up our settings
387:22 - and adjust our vias code so that
it auto formats whenever we
387:26 - save, so whenever we save, so
that whenever it goes from the
387:30 - little white dot here to no
white dot, this whole thing gets
387:34 - automatically formatted to some
looks really nice. Okay. So what
387:38 - we can do is we can open up our
command palette to open up our
387:42 - command palette, you can hit
View command palette, and we'll
387:46 - get a little pop up that looks
like this. Another way to open
387:50 - up your command palette is
you're gonna hit Command, Shift
387:52 - P, or Ctrl, Shift P, depending
on your Mac, or Linux or
387:57 - Windows. And what we want to do
is we want to type in settings,
388:00 - and we're going to open Settings
JSON, we don't want to open the
388:03 - default settings JSON. We don't
want to touch these. But we want
388:07 - to open our JSON settings.
You'll also notice there are
388:10 - user settings and workspace
settings. These are pieces that
388:13 - we can adjust as well. But we're
going to just go right into the
388:16 - JSON settings. So So I already
have some stuff in here, but
388:20 - yours might be blank. Or you
might have some stuff in here as
388:23 - well. So what we're going to do
is if you have stuff in here
388:25 - already, we're going to add a
comma, then we're going to do
388:29 - quotes, solidity. Close the
brackets, we're gonna do a
388:36 - little colon and something like
this. This means that we're
388:39 - going to apply some settings to
our Visual Studio Code. Whenever
388:43 - we're working with solidity, one
of the things we're going to add
388:45 - in here is going to be an
editor, Doc's default, for
388:50 - matter. And you might even get a
pop up that tells you some
388:55 - different things that we can use
for a default format or our
388:58 - default format, or is going to
be Nanak, foundation, dot hard
389:03 - hat, hyphens solidity. This will
mean that any time we go to
389:09 - format our code, it'll use the
hard hat solidity plug in, as
389:13 - its default format, or the hard
hat solidity plugin comes with
389:18 - some formatting, and a lot of
other really useful tools for us
389:22 - writing our code. So now that we
have this part in, the next
389:26 - thing we're going to do is add
format on Save. If we haven't
389:29 - already, we could add it in here
in our JSON, but I'm going to
389:33 - add it not in the JSON file, I'm
going to add it in the overall
389:36 - file. So if we open that command
palette back up, and we type in
389:40 - settings, open user settings,
this is another really good
389:45 - place where we can look in add
settings with the UI. So these
389:48 - two do essentially the same
thing. It's just that this one
389:51 - has dials and a little bit more
context versus settings that
389:54 - JSON just says Okay, give me the
raw code for it. This tells us a
389:57 - little bit more. So you can use
either one. But we're going to
390:00 - look for format, on save. And
you're going to want this
390:05 - checked if you haven't already.
This means that every time we
390:09 - save VS code is going to try to
format our code for us. So now
390:14 - that we have this checked, we
have settings dot JSON added in.
390:16 - And remember, we want to save
this. Remember, if you see this
390:19 - white dot, that means not saved.
So you're gonna want to save it
390:22 - and close it out. Let me close
this out too. If we come back in
390:25 - here and we add a bunch of
random new spaces or whatever,
390:28 - you want to make it look a
little bit ugly, and then we
390:31 - save it. It should automatically
reformat to look much nicer,
390:36 - right. So if we do something
like this, we'd save it
390:40 - reformats it to look much nicer
this one make them more readable
390:43 - for you, and more readable for
anybody else who looks at your
390:46 - code. And it's just really nice.
And this line of code for your
390:50 - settings dot JSON is located in
the full blockchain study
390:54 - course.js. So you can also just
copy paste it, we are going to
390:57 - end up overriding that default
format or with another format
391:01 - are called prettier pretty soon.
But it's great to have a default
391:05 - format or so that if you don't
feel like adding the prettier
391:08 - code sometime in the future, you
can just rely on your default
391:12 - formatter. Awesome. While we're
doing formatting, let's also add
391:16 - a default format or for our
JavaScript code. And just to
391:19 - test it out, let's go ahead and
create our new file, we'll call
391:22 - it deploy dot Jas. And in here,
we can do something like
391:28 - function Hi,
391:30 - console dot log, hi, and then
just add and then just make it
391:37 - look kind of gross, maybe
something like this. If you hit
391:40 - save, and it does some auto
formatting, that's great, you
391:43 - can actually turn that off by
going back to your command
391:46 - palette, and saying, Save
without formatting. And that way
391:51 - it will be saved and not
formatted. The way we can add
391:54 - some other formatting here is
we're gonna install another
391:56 - extension, this one is going to
be called prettier. So we can
392:01 - just look up prettier and
extensions here. And you'll want
392:04 - to install this prettier code
formatter. So we're gonna go
392:08 - ahead and install this. And
great, now it's installed
392:11 - prettier is a form is a code
format, or that works for many
392:15 - languages like Python,
JavaScript, and even solidity.
392:19 - And pretty soon we're going to
use prettier for both JavaScript
392:22 - and solidity. But for now, we're
just going to use prettier for
392:25 - JavaScript, we can enable this
by opening back up our command
392:28 - palette, we'll go to
preferences, open Settings. And
392:32 - the same way we added a solidity
section, we're going to add a
392:36 - JavaScript section. So we're
going to add a comma here, some
392:41 - quotes, brackets, we're going to
type in JavaScript, close that
392:46 - colon brackets. And we're going
to do the same thing at the door
392:51 - dot default, or matter. Net
we're going to do and then in
392:58 - here, we're going to do e s
BENP, that prettier, hyphen VS
393:04 - code. And this will make
prettier the default editor for
393:08 - JavaScript. Now, like I said,
pretty soon, we're going to have
393:11 - prettier override both of these
for solidity and JavaScript. And
393:15 - we're going to give prettier
some parameters so that no
393:18 - matter who uses your code, they
will always have the exact same
393:21 - formatting. But now that we have
prettier in here as the default
393:25 - editor, if we come back to
deploy dot j s, and we hit save,
393:29 - it should format to look a
little something like this. Now,
393:33 - we go ahead and we do something
like this. If we go ahead and do
393:36 - something like this, it'll
reformat to look like look like
393:39 - that. And then additionally, if
you want to go back to the
393:43 - command palette, open user
settings, not in JSON mode, and
393:47 - we go to default format, or you
can actually even select the
393:52 - default format or for all
languages, if you want to use
393:56 - prettier for all formatters.
Feel free to go ahead. Alright,
393:59 - great, got our JavaScript
format, or in as well, let's
394:02 - start writing some JavaScript
code.
394:07 - Awesome. So now that we have our
code in here, it's time for us
394:10 - to learn how to actually deploy
our contract using JavaScript.
394:15 - This is going to teach us a lot
about transactions and what's
394:17 - going on under the hood, and
even what's going on under the
394:21 - hood in remix, and remix, we
usually just hit a compile
394:24 - button, and then hit a Deploy
button. And that's really it. In
394:28 - JavaScript, we're actually going
to create our own functions that
394:31 - are going to help us do both of
those. And as I mentioned, this
394:33 - is the part of the course we're
going to start working with
394:35 - JavaScript, and optionally,
TypeScript if you like. Like I
394:39 - said, all of these sections come
with a TypeScript edition as
394:42 - well. So let's set up our
deployed out js script to
394:47 - actually deploy our simple
storage dot soul. So how can we
394:50 - get started here? Well, let's
first learn how to run a script
394:53 - using JavaScript and Node J S.
So if you want to do a print
394:57 - line, or just print something
out to your terminal, we can do
395:00 - something called a console dot
log. And if I do console dot
395:04 - log, hi, I hit Save. And I open
up my terminal. I can now run
395:10 - Node deploy.js. And it'll print
out high node is how we say hey,
395:16 - we want to run this JavaScript
code using Node js. Other
395:21 - languages you might be familiar
with, sometimes we'll do Python,
395:24 - you know, deployed up py, or
Java, C deploy dot Java, you
395:30 - know, etc. But with JavaScript,
since the front end and back end
395:34 - JavaScript are different. We run
code on the back end with node.
395:37 - And with JavaScript, you can do
a lot of things that you'd see
395:40 - in something like solidity with
a little bit looser have a
395:43 - structure. If I wanted to create
some variable, I could say let
395:46 - variable equals five, this kind
of similar into solidity like
395:51 - you and 256, variable equals
five. But in JavaScript, we use
395:57 - let or var or const. And then I
can print this out, I can do
396:01 - console dot log variable. And I
had saved JavaScript is optional
396:08 - on whether or not you actually
want to have semicolons. Here, I
396:11 - think prettier, defaults to
putting semicolons. And we'll
396:14 - get rid of those in the near
future in your terminal. Once
396:17 - you start typing the name of a
file, if you hit tab, it could
396:22 - autocomplete the rest of the
file name for you node deploy
396:26 - hit Tab, it'll autocomplete and
if we hit enter, now, we get Hi,
396:31 - and then we get five. Since this
prints out Hi, and then it
396:34 - prints out five. JavaScript
automatically starts with
396:37 - whatever code you have at the
top of the file. So it does
396:40 - console dot log first and
variable. And then this one as
396:43 - well. However, a good practice
is to actually wrap everything
396:47 - you want to do in a main
function, and then run that main
396:51 - function. But what we could do
is up at the top here, we'd say
396:55 - function, mean, add parentheses
and some brackets, a closing
397:01 - bracket at the bottom, and hit
save for its auto format. Right
397:05 - now, if we run this, nothing
will happen, because we've
397:07 - wrapped all of our code in a
main function. So if I run it
397:11 - now node deployed to Jess,
nothing happens, because I need
397:15 - something to call the main
function. So if I then take
397:19 - this, this main function down
here, and I call main, our jobs
397:24 - from code is actually going to
say, ah, the first line of the
397:26 - script is actually this main
function here. So now if I do
397:30 - node deploy dot j, s, it'll run
high and five, which is what we
397:33 - want. Now, this is going to be
the setup for most of our
397:36 - scripts moving forward,
including the scripts that we
397:39 - write, when we get to hard hat,
however, there is going to be
397:41 - one major difference. Instead of
regular functions, we're
397:45 - actually going to use something
called async functions. And
397:48 - we're going to do something
called asynchronous programming
397:50 - to do this. Now, if what I say
next is really confusing for you
397:54 - don't let it slow you down, feel
free to go ahead and watch that
397:57 - JavaScript course to learn more
about this. But I'll also let
398:00 - you know, hey, this is an async
function. Here's what we need to
398:03 - be aware of when working with
it,
398:05 - okay. But I do want to give you
a quick bit background on
398:16 - asynchronous programming. So
far, the programming that we've
398:19 - done has been synchronous. And
solidity is an example of a
398:22 - programming language, that
synchronous, Synchronous means
398:25 - it just goes one line after
another. If our code looks like
398:28 - this, this is synchronous write,
our main function is the first
398:32 - thing that actually gets called.
Then we do console dot log, that
398:36 - variable equals five, and then
console dot log. Again, this is
398:38 - synchronous programming in
JavaScript, all of our solidity
398:41 - is synchronously programmed.
There will be some exceptions to
398:44 - this when working with oracles.
But for now, everything is
398:46 - synchronous. JavaScript can be
asynchronous, meaning that we
398:50 - can actually have code running
at the same time. A good example
398:54 - I like to use to understand the
difference is with cooking. In
398:58 - synchronous programming, for
cooking, you might put popcorn
399:02 - in microwave, wait for popcorn
to finish. And then, and then
399:08 - maybe you'll pour drinks for
everyone. And now this is
399:11 - synchronous programming. Now, it
might be a little bit weird for
399:14 - you just to put the popcorn in
the microwave, and then just
399:17 - stare at it, waiting for it to
finish. And then pour the
399:19 - drinks, you typically can pour
the drinks while your popcorn is
399:24 - in the microwave. And this is
where asynchronous programming
399:27 - comes in. If setting up for this
movie night, we're asynchronous,
399:30 - what you would do is you'd put
popcorn in the microwave. And
399:34 - while the popcorn is in the
microwave, or drinks for
399:37 - everyone, and then you'd wait
for popcorn finish, since
399:42 - there's nothing left for you to
do, but it doesn't make sense
399:45 - for you to wait for the popcorn
to finish to pour your drinks,
399:48 - you can just go ahead and pour
the drinks right away and then
399:51 - wait for the popcorn to finish.
So asynchronous programming is
399:54 - way for us to do stuff without
waiting around for things to
399:57 - finish. And this is really
advantageous in JavaScript by
400:00 - default allows us to do this
asynchronous programming,
400:02 - however, sometimes we do want to
wait for our popcorn to finish.
400:05 - For example, if instead of just
pouring drinks, maybe the next
400:09 - thing instead of pouring drinks
was placed salt on popcorn. Of
400:14 - course, if we want to play salt
on our popcorn, we do have to
400:17 - wait for the popcorn to get out
of the microwave. So even though
400:20 - placing popcorn in the microwave
has this wait time we need to be
400:24 - able to tell our code I want you
to actually wait for it or No,
400:27 - you're good. You can go on and
do another task. So that's kind
400:31 - of the difference here. And I'll
leave some links in the GitHub
400:34 - repo associated with this course
to understand this a little bit
400:36 - better functions that have
functions that come with this
400:39 - waiting period return something
called a problem. This, if put
400:43 - popcorn in the microwave was a
function in JavaScript, it would
400:46 - be a promise based function. A
promise can be either pending,
400:51 - fulfilled, or rejected. And this
is how we know if our popcorn is
400:55 - done. If our popcorn was a
method, putting popcorn in the
400:58 - microwave, were a function in
JavaScript, when we're waiting
401:01 - for the popcorn to finish, it's
in a pending state. When it's
401:04 - when the popcorn is finished, it
would be fulfilled. And if we
401:08 - aborted halfway through, and we
stopped waiting, it would be
401:11 - rejected. So putting the popcorn
in the microwave returns a
401:14 - promise. With this promise, we
have to tell our code, hey, we
401:18 - want you to wait for the popcorn
to finish or you can go ahead
401:22 - and you can just keep doing
stuff. So let's put this all
401:24 - together with some JavaScript
syntax here. Let's say again,
401:27 - we're going to be setting up
this movie night. And we need to
401:30 - cook popcorn, pour drinks for
everybody. And then we need to
401:34 - start a movie. So let's write
some pseudocode to pretend what
401:37 - this code would look like if
this was actually a function. So
401:40 - we create some function called
setup, Movie Night. And in here,
401:45 - we would say okay, what's the
first thing we need to do? Okay,
401:48 - we need to cook popcorn. So
let's say we have some cook
401:50 - popcorn function. So we'll say,
okay, cook popcorn, then the
401:54 - next thing we're gonna have to
do is we're gonna have to pour
401:55 - drinks, or drink. So we'll call
some pour drinks function. Now
402:00 - here's the thing, we only want
to start the movie once our
402:03 - popcorn has been cooked. And
once our drinks have been
402:07 - poured, so if either one of
these returned a promise, so if
402:11 - either one of these returns a
promise, like cook popcorn, for
402:14 - example, we would need to tell
our code here to actually wait
402:18 - for the popcorn to finish
because cook popcorn is going to
402:21 - be a function where we could say
let status equals cook popcorn.
402:25 - And while the popcorn is being
cooked, the status is going to
402:29 - be ending. Once the popcorn gets
cooked, it'll be fulfilled. If
402:33 - the popcorn breaks, the
microwave explodes, the status
402:35 - would be rejected. But we don't
want the status to be in a
402:39 - pending situation. Before we
move on, we only want to start
402:42 - our movie once these two
functions have completed. And
402:45 - let's say both of these return
these promises things. So we
402:48 - need to tell our code, hey, you
have to wait. Or you have to
402:52 - wait for cook popcorn and for
poor drinks to finish. So what
402:56 - we can do now without getting
too deep into the weeds on how
402:59 - all this works, one of the
easiest things that we can do
403:01 - and you'll see us use this
syntax quite often is we'll turn
403:04 - this function into an async
function. When our functions are
403:08 - async, we get access to a
keyword called await the await
403:12 - keyword tells any promise based
function to wait for that
403:17 - promise to be fulfilled or
rejected. So we say okay, we
403:20 - want to await for our popcorn to
cook. And then we want to await
403:24 - to pour drinks. And then we can
just go ahead and start the
403:27 - movie. And we only start the
movie here once these two have
403:31 - been completed. And this is why
throughout all of our code,
403:34 - you'll see this await keyword
used a lot. But it can only be
403:37 - used in async functions. So
basically, whenever you see this
403:40 - await keyword just now Ah, okay,
the function that's being called
403:44 - is promise based. And we don't
want to move on to the next step
403:48 - until that function has
completed. So that's a little
403:50 - bit more about promises and
asynchronous programming.
403:53 - Hopefully, that's clear. If not,
like I said, there's some links
403:56 - in the description to learn more
about asynchronous programming.
403:59 - The reason I wanted to go
through this is because most of
404:01 - the functions that we're going
to be working with are going to
404:03 - be asynchronous. For example,
when we deploy a contract, what
404:07 - do we have to do? Well, we have
to wait for it to be deployed.
404:14 - If we don't use synchronous
programming, and we just leave
404:16 - our function main like this,
what would happen is we would
404:20 - write some code like contract
dot deploy, and we wouldn't wait
404:24 - for it to finish. Obviously, if
we don't wait for it to finish,
404:29 - and we try to run some code on a
contract that hasn't finished
404:32 - deploying it, it's not going to
work. So we want to do this, we
404:35 - want to have our main function
be an async function, so that we
404:38 - can we can wait for our
contracts to deploy, we can wait
404:42 - for things to happen, we can
wait for our popcorn to finish,
404:45 - we can have the flexibility to
tell our code to either wait for
404:48 - our popcorn to finish or
continue on. So now that we have
404:51 - our main function as an async
function, we're going to add
404:54 - some code to our main function
down here. And the code that's
404:57 - added here is some syntax for
working with asynchronous
405:00 - functions. And if this part is
confusing, I'm just going to say
405:02 - for now, absolute, don't worry
about this. If you want to try
405:05 - to understand that later. That's
fine. But for those who are
405:07 - following along, we're just
going to add an add
405:09 - then catch air air you can
follow along typing this
405:25 - yourself or you can just copy
paste it into your code.
405:28 - Basically what this allows us to
do is we have our main function,
405:31 - that's an asynchronous function.
So when we call the main
405:34 - function, this is some other
syntax for waiting for it to
405:38 - basically finish and then
printing any errors it gets. And
405:41 - that's why we do this but Again,
if this big lump of code, if
405:44 - you're like what is going on
with this big clump of code,
405:46 - honestly, for now, just copy
paste it. So great. We have our
405:49 - asynchronous function main, we
have some code. And then we have
405:52 - this lump of code, which
basically just calls our main
405:55 - asynchronous function. Okay,
great. I'm gonna delete all this
405:58 - for now. But you can still find
that common in the GitHub repo
406:01 - associated with this course.
Awesome. Okay, so now that we
406:04 - have our real basic setup, let's
go ahead and start coding. And
406:08 - if this set apart is confusing,
and the async await stuff is
406:11 - confusing, don't worry too much
about it. It'll make more sense
406:14 - as we progress. All of our code
basically is going to be inside
406:19 - of this async function main,
which is going to be our main
406:22 - script for deploying our simple
storage dot soul store deploy
406:25 - script is going to replicate
exactly what goes on in remix,
406:29 - in remix, what was the first
thing that we always did? Well,
406:32 - the first thing that we would do
is actually compile all of our
406:35 - code. So we're going to want to
compile our code in our
406:38 - JavaScript project as well. In
order for us to compile our
406:42 - simple storage contract, we're
going to use a tool called Silk
406:45 - Jas, and JavaScript actually has
a way to install projects
406:48 - directly into our setups and
into our folders. If we scroll
406:52 - down this silk Jas is exactly
what we're looking for. Because
406:55 - it has a way to compile a
contract that imports other
406:58 - contracts via relative paths,
you can see a section in this
407:02 - readme and most documentation
will have something like this,
407:05 - if it's JavaScript compatible.
For Node js usage, it says to
407:09 - use the latest stable version of
the solidity compiler via Node
407:11 - js, you can install it via NPM
npm install. So NPM is what's
407:17 - known as a package manager. And
we actually installed NPM just
407:22 - by installing no Jess, right, if
we do no dash dash version, you
407:26 - should also be able to do NPM
dash dash version. Another tool
407:30 - that it comes with is something
called core pack. And you can
407:33 - type core pack dash dash
version, now we can install with
407:36 - NPM using npm install silk,
however, I like the yarn package
407:40 - manager a little bit better. So
we're actually going to install
407:44 - the yarn package manager instead
to do all of our package
407:47 - management. If you go to the
installation page, the newer way
407:51 - to install yarn is just by
running core pack enable. And
407:54 - the older way is to install with
NPM. If you go ahead and run
407:58 - core pack enable after that
finishes, you should be able to
408:01 - run yarn dash dash version.
Alternatively, you can just run
408:07 - NPM i dash g core pack, and then
you can run core pack enable.
408:13 - The last option you have is you
can run NPM i dash g
408:17 - yarn. This will install yarn
globally for your system. But
408:21 - this is considered the outdated
way to install yarn. And ideally
408:25 - you run core pack enable. But in
any case, after you run those,
408:29 - if you run yarn dash dash
version, you should get
408:31 - something that looks like this.
Now that we have yarn, we can
408:35 - actually use yarn to install all
of our projects, instead of NPM.
408:39 - Back in silk Jas where it says
npm install soak, we can do the
408:44 - yarn equivalents of NPM install
sock, which is going to be yarn,
408:49 - add sock, this will actually go
ahead and install solc to our
408:55 - project. If we open up our
folders, you'll actually see
408:59 - that this added a couple of
different folders, it first
409:01 - added a package dot JSON package
dot JSON is a file that tells us
409:06 - a lot about our project and the
dependencies that it works with.
409:09 - For example, we've installed the
soap package of 0.8 point 13.
409:15 - Our yarn dot lock tells us the
exact version of all the
409:18 - different packages of our
project. For example, the reason
409:22 - this is so important too, is
solc has a ton of dependencies
409:25 - as well. So yarn dot lock tells
us exactly what version of solc
409:30 - and all the different
dependencies of solchen. Any
409:32 - other project that we add. This
is autogenerated file, don't
409:36 - edit the file directly. The
final bit is we got this node
409:39 - modules folder. This node
modules folder is going to be
409:44 - where all the installed code
that we just downloaded is, for
409:47 - example, if we look at node
modules, we can see there's a
409:51 - sock folder. And inside this
sock folder is all the code
409:55 - associated with this soap
package that we just installed.
409:59 - And since we're working with
zero point 8.7 of slowly, we
410:03 - actually want to install that
specific version. So we're going
410:06 - to do yarn add solc at zero
point 8.7 Dash fixed and you'll
410:17 - see in our package dot JSON you
can now see zero point 8.7 Dash
410:21 - fixed in our dependencies
section for sulk. Normally you
410:25 - can just add your salt version
like yarn add zero point 8.7 But
410:29 - there was an issue with zero
point 8.7 So we had to do zero
410:33 - point 8.7 Dash fixed.
410:36 - You can find the different
releases and the different
410:38 - versions if you go to sulk Jas
releases and then to tags
410:42 - Alright, great. Now that we have
sold, we have the ability to
410:45 - actually compile our contracts,
we could either compile them in
410:50 - our code and have it
automatically run whenever we
410:54 - hit Deploy, or, or we could
compile them separately. If you
411:00 - want to go back after this
section is an example in the
411:03 - sculpt Jas repository that shows
you how to actually compile silk
411:07 - right in your code. We are
actually going to compile them
411:09 - separately using a soap Jas
command. The yarn command is
411:14 - both used to install
dependencies and it can be used
411:17 - to run scripts. If you go to
sulk Jas and you scroll down, it
411:21 - says in order to use the command
line, you actually need to
411:24 - install it globally. If you want
to install this globally using
411:27 - yarn Global Add solc at zero
point 8.7 Dash fixed you can
411:33 - absolutely go ahead. However,
since we're inside of this
411:36 - folder here, which has the yarn
dot lock the package json and
411:40 - the node modules yarn will be
smart enough to know i You're
411:44 - looking for the soak in this
folder. So we can actually go
411:48 - ahead and compile our contract
using yarn and solc Jess if you
411:52 - want to see all the different
commands soak Jas allows we can
411:55 - just run yarn. So Jas dash dash
help, and you'll see it'll spit
412:00 - out a list of all the different
options that soft Jas has. You
412:06 - can also run yarn, so Jas dash
dash version to just make sure
412:11 - that we're on the correct
version, which is indeed zero
412:14 - point 8.7. Now to actually
compile our simple storage at
412:18 - soul, let's run the compliation
command we will run yarn, so J
412:23 - S, dash dash bin since we want
the binary dash dash ABI since
412:29 - we also want the ABI dash dash
include path node modules. Since
412:37 - we want to include any contracts
or files in our node modules, we
412:41 - aren't using any for this
project, but in the future, you
412:43 - will need to include this dash
dash include path node modules
412:47 - do dash dash base path of
period, this period means that
412:52 - the base path is going to be
this folder dash O period, which
412:56 - means we're going to output the
compiled binary and ABI to this
413:00 - folder. And then finally, simple
storage dot soul. Since this is
413:05 - the contract that we want to
compile, auto completed it from
413:08 - simple storage to simple
storage. So by typing simple,
413:12 - and then hitting Tab, but let's
go ahead and hit enter, you'll
413:15 - see it's running this command to
compile this contract. And
413:19 - you'll see two files get output.
One called Simple Storage soul
413:24 - underscore simple storage that
API in simple storage Sol
413:27 - underscore simple storage dot
bin, the ABI is obviously the
413:31 - ABI of this contract, which will
need in the future. And then the
413:35 - bin is going to be the binary,
or the really low level of this
413:39 - code back and remix. If you
compile simple storage, that
413:42 - soul, you can actually look at
compliation details, like the
413:46 - ABI which we just got, or the
bytecode, which if you look at
413:51 - this object 60806 That's the
same as the binary here 60806.
413:59 - Alright, great. So now we've
compiled our contracts here.
414:02 - Now, obviously, now if you hit
up on your keyboard, you can
414:05 - actually cycle through your most
recent terminal commands. And if
414:09 - you hit up enough, we can see
this command that we just ran
414:12 - typing this out or hitting up a
whole bunch every single time,
414:15 - it's going to be really annoying
to do anytime we want to
414:18 - recompile. So what we can do is
we can add a script section in
414:22 - our package dot JSON to shorten
some yarn scripts for us. So
414:26 - what we'll do is back in our
package, dot JSON, a lot of
414:29 - comma, and we'll add a section
called scripts, add the colon
414:34 - and the brackets. And in here,
we'll say anytime we say
414:37 - compile, we will run this long
command. So I'd compile we'll
414:42 - put some quotes. And we'll paste
that in there. So now instead of
414:46 - typing that whole thing out, as
long as we're in the same folder
414:49 - that our package json is in, we
can run yarn compile. And this
414:54 - will run that whole script for
us without us having to type the
414:57 - whole thing out scripts are a
really useful way to make it
415:00 - easier for us to run long
commands. All right, great. Now
415:03 - we have our code compiled, this
is going to be equivalent to US
415:07 - hitting this compile button for
us to actually go ahead and
415:10 - deploy.
415:13 - So now we have our simple
storage. That's all compiled,
415:16 - let's learn how we can actually
deploy this thing. Remember, in
415:19 - remix, we actually deployed it
to one of two different places,
415:22 - we deployed it to either a
JavaScript VM, or with our
415:27 - injected web three, with our
Metamask. Let's learn first ad,
415:31 - do the JavaScript VM. And then
we'll learn how to use the
415:34 - injected web three, or a meta
mask or some connection to an
415:38 - actual test net. So in order to
deploy this to a JavaScript
415:41 - virtual invite I'm in or kind of
a fake blockchain, we're gonna
415:44 - need to get a fake blockchain.
Now in the future, we're going
415:48 - to be using the Hardhead runtime
environment as our JavaScript
415:51 - virtual machine or aka our fake
blockchain. But for this
415:55 - section, I want us to use a tool
called ganache. There's a link
415:59 - to this in the GitHub
repository. Ganache is similar
416:02 - to a virtual machine in remix.
It's a fake blockchain that we
416:06 - can run locally to actually
test, deploy and run code. It's
416:10 - also a nice way to see things
that are going on in a
416:14 - blockchain. Let's go ahead and
spin up the ganache application
416:17 - after you install it, the
ganache application will look a
416:20 - little something like this. And
to spin up a fake blockchain
416:24 - really quickly, you can just go
ahead and click Quickstart. This
416:28 - will spin up a fake blockchain
that's running locally on your
416:31 - computer right here, which is
fantastic. It comes with a whole
416:35 - bunch of fake accounts exactly
like how remix comes with a ton
416:39 - of fake accounts with 100 ether
each ganache comes with a bunch
416:42 - of fake accounts with 100 ether
each. They also come with the
416:46 - private keys that we can use in
our applications to actually
416:50 - take control of these fake
accounts. Remember, don't use
416:54 - these private keys on a public
blockchain. They're for
416:56 - development purposes only
because a lot of people know
416:59 - these private keys in our code.
One of the first things that
417:02 - we're going to need to do is
actually connect to our
417:05 - blockchain remix does this a
little bit behind the scenes, if
417:09 - we're choosing JavaScript
virtual machine remix chooses
417:12 - its own fake blockchain that it
runs. If we choose injected web
417:15 - three, as we know, meta mask
pops up, and it connects to our
417:19 - meta mask, this connection that
remix does, is actually doing
417:22 - something really interesting.
It's not just connecting to our
417:25 - meta mask by some magical
powers. It's actually connecting
417:29 - to our meta mask, which has a
connection to the blockchain
417:32 - behind the scenes. If you open
up your meta mask, and you go
417:36 - down to you select the networks
and you select ad networks,
417:40 - you'll get popped up into a UI
that looks like this. If we go
417:43 - back and hit select networks
over here, we can actually see
417:47 - information about these
different networks. One of the
417:50 - main things that we can see is
that all these networks have
417:53 - something called an RPC URL. RPC
stands for remote procedure
417:58 - call. And then URL is uniform
resource locator. This RPC URL
418:04 - stands for a connection to a
blockchain node that somebody is
418:07 - running this this URL connects
us to make API calls and to
418:12 - interact with a blockchain node.
Blockchain nodes run with
418:15 - software, and some of them
expose an API call. If you look
418:19 - at the NGO Aetherium website,
there actually are instructions
418:23 - for you to run your own
blockchain node for a real
418:26 - blockchain like Aetherium. Most
of these have flags like dash
418:30 - HTTP dot ADR to expose these RPC
endpoints. So if you ever want
418:36 - to run your own node, your own
real blockchain node, instead of
418:39 - using meta masks or any other
the providers that we're going
418:42 - to go through, you can use go
Aetherium, or whatever
418:44 - blockchain you're working with
software to run your own notes.
418:47 - But it's this RPC URL that
allows us to connect to Rinkeby,
418:50 - if on Rinkeby ropsten, if we're
on ropsten main net if we're on
418:54 - Main net, etc. And it's going to
be the way that we're going to
418:57 - connect to our ganache
blockchain that we're running
419:01 - inside of this application. So
if you look at the top of your
419:04 - ganache here, there's a section
called the RPC server. And this
419:08 - is the endpoint of our ganache
node right now. So what we can
419:11 - do is we can copy this and go
back to our VS code, and paste
419:16 - it in here to see if we can
connect instead of HTTP. With
419:20 - these capitals, we're gonna have
a B lowercase instead of the
419:22 - uppercase, because the lowercase
is more correct, and it looks
419:25 - nicer. But now we have the
endpoint. Hypothetically, with
419:27 - just this, we can start making
calls and API calls to this
419:31 - endpoint, go to this JSON RPC
specification. Again, link will
419:35 - be in the GitHub repo, we can
actually see different calls we
419:38 - can make directly to our node to
get different information. eath
419:42 - get blocked by hash eath get
blocked by number. And all of
419:45 - these wonderful pieces in here.
Making these API calls directly
419:49 - is is a little bit annoying to
do ourselves. If you want to do
419:52 - it yourself, you absolutely can
using an API endpoint like Axios
419:56 - or fetch. However, we're going
to use a rapper to interact with
419:59 - our node and do things like
deploy and interact and other
420:02 - such things with our blockchain
node. This is finally where
420:06 - ethers comes
420:07 - into play. Ethers js is one of
the most popular JavaScript
420:13 - based tooling kits, that allows
us to interact with different
420:16 - blockchains and has all these
rappers that make all these API
420:20 - calls and do all these things
with Aetherium, and polygon and
420:24 - avalanche and any EVM compatible
chain. The other incredibly
420:27 - popular package that does the
same thing is going to be web
420:30 - three.js. And you've probably
heard about this and you'll
420:32 - probably see it a little bit
more throughout this course and
420:34 - throughout your web three
journey. The reason that we're
420:36 - using ethers is that ethers is
the main tool that powers the
420:40 - hard hat environment and I
really enjoy it myself. And
420:43 - remember, if you ever get lost
with any of this, you can always
420:46 - come back to their documentation
to install it. As you can see
420:49 - here, you can just run npm
install ethers, we're just going
420:52 - to do yarn, add ethers.
420:56 - And now you should see in your
package json, we now have ethers
421:01 - added in here. Awesome. Now back
in our code, we're going to
421:04 - import ethers into our
deployed.js script so that we
421:07 - can use all the wonderful tools
that comes with so we'll say
421:09 - const ethers equals require
ethers. For those of you doing
421:16 - the TypeScript edition of this
course, this will be import
421:18 - instead of require now that we
have ethers in here, we can
421:21 - create our provider object in
our main function. The reason we
421:25 - we pull ethers outside of the
main function is because we do
421:28 - want to pull our package into
our script. Before we call main,
421:32 - we want to make sure all of this
is done first. So you'll see
421:35 - this is kind of the the normal
setup of our scripts. At the
421:38 - top, we import any dependencies
or external packages, we'll have
421:42 - our main function, and then
we'll call our main function at
421:45 - the bottom. const is a keyword
similar to let the const keyword
421:49 - makes it so that ethers can't be
changed. So we can't change
421:52 - this. Our ethers variable,
anytime we use const require is
421:56 - a function for us to import the
ethers package. Now remix does
421:59 - all this behind the scenes. But
the way we're going to do it in
422:02 - our code here is we're going to
say const provider equals new
422:08 - ethers dot providers dot JSON
RPC provider. And then we're
422:15 - going to pass this string as our
provider. So we're saying hey,
422:20 - we're going to connect to this
URL right here. Awesome. So this
422:24 - is the way that our script is
going to connect to our
422:27 - blockchain, our local
blockchain. Now let's get an
422:30 - actual wallet here. With a
private key and a balance and
422:33 - everything, we can see all of
our wallets and private keys in
422:37 - our ganache here. So the way to
get this set up is we can say
422:40 - const. Wallet equals new ethers
dot wallet. And this wallet
422:47 - function takes in a couple of
input parameters, like a private
422:50 - key, and a provider, the private
key will go to Kenosha and just
422:55 - choose one of these private
keys. And we're going to paste
422:57 - this right into our code. And
then we're gonna do comma
423:00 - provider and save that. Now
pasting your private key
423:04 - directly into your code is a
huge nono. And we're going to
423:08 - learn how to avoid this in the
future. It's okay right now,
423:11 - since we're just using one of
the ganache private keys, and
423:14 - you have no risk of having any
money associated with this
423:17 - account. These two lines alone
give us everything that we need
423:20 - to interact with smart contract,
they give us our connection to
423:24 - the blockchain, and they give us
a wallet with a private key so
423:28 - we can sign different
transactions. If you remember
423:30 - back to our blockchain basics
section. This is the private key
423:34 - that we're using to sign all of
our transactions to encrypt our
423:37 - transactions. Now that we have a
provider and a wallet, let's go
423:40 - ahead and grab our contract
objects from these two files
423:44 - here. In order to deploy our
contract, we're gonna need the
423:47 - ABI and we're going to need the
binary compiled code of the
423:52 - contract. So we're going to need
to read from these two files to
423:55 - read from these two files, we're
going to need to use a package
423:58 - called Fs. So back at the top,
we're gonna do const Fs equals
424:03 - require Fs extra I autosave, all
the time, you'll see like, I'll
424:08 - do something and then my white
dot will go away a lot. It's
424:11 - because my fingers have a habit
of pretty much anytime I stop
424:14 - typing I save so so please
remember to save early and
424:18 - often, this Fs extra should come
directly with your node project.
424:22 - But if not, you can always add
it with yarn, add Fs extra, and
424:26 - you should see it in our package
dot JSON. Now we can get the ABI
424:31 - and the binary, we can say
const, abi equals Fs dot read
424:38 - file sync, which means we're
going to synchronously read from
424:42 - this file, we could do it
asynchronously. But we want to
424:46 - wait for this file to get done.
So we're gonna say read file
424:48 - sync. And depending on your VS
code, if you scroll over, you
424:52 - might even get some information
about this function popup like
424:55 - this, which can be really
helpful, we can see that we need
424:58 - the path for the file we want to
read. And then any options as
425:01 - well path the file that we want
to read the at the ABI located
425:04 - at dot slash simple storage,
underscore soul underscore
425:11 - simple storage dot AVI and then
we're going to do a comma of U
425:18 - T, F eight is UTF. Eight is the
encoding that we do for this
425:22 - file here. Don't worry too much
about what that means for now.
425:24 - So we need the ABI. And we also
need the binary, which is in
425:29 - this second file. Simple Storage
underscore soul underscore
425:34 - simple storage dot bin. So we're
gonna say const binary equals Fs
425:38 - dot read file sync. We're gonna
give it the path Hear, which is
425:43 - going to be dot slash, simple
storage soul, simple storage dot
425:51 - bin, and then the encoding
option, which again is going to
425:54 - be, and it should look like
this. Now that we have the
425:57 - binary, we have the ABI, we can
create something called a
426:00 - contract factory, which is not
to be confused with the factory
426:04 - pattern in ethers. A contract
factory is just an object that
426:07 - you can use to deploy contracts.
So we're gonna say const,
426:11 - contract factory equals new
ethers dot contract, factory.
426:21 - And we're going to pass it, the
API binary. And the wallet, we
426:28 - pass the ABI so that our code
knows how to interact with the
426:31 - contract the binary, obviously,
because this is the main
426:34 - compiled code in our wallet so
that we have a private key we
426:37 - can use to sign deploying this
contract, then I usually like to
426:41 - write a little console dot log,
saying something like deploying
426:45 - these wait. And we can actually
deploy this contract with ethers
426:50 - by doing const. Contract equals
await, contract factory dot
426:59 - deploy. Now, this is the first
time we've seen this await
427:02 - keyword and you can only use the
await keyword inside of an async
427:06 - function. The reason we want
this await keyword we're telling
427:10 - our code to stop here, wait for
contract to deploy. And this
427:16 - await keyword means that this
will resolve the promise
427:19 - contract in this contract
factory dot deploy with the
427:22 - await here returns a contract
object. So now I could do
427:26 - something like console dot log
contract. Let's see what happens
427:30 - when we run this code node
deploy dot j s, we scroll up, we
427:37 - see deploying, please wait. And
then we see this massive object
427:42 - that gets printed out. This is
the contract object that we just
427:45 - deployed. And in fact, if we go
over to our ganache, we can see
427:50 - that the address that we're used
for our wallet has a little bit
427:54 - less balance and has a
transaction count of one. If we
427:57 - were working with truffle, we'd
be able to see the contracts
428:00 - here we're working with hard
hat, so you won't be able to see
428:02 - the contracts in here. But if
you go to transactions, we can
428:05 - indeed see the transaction that
we just created. This is similar
428:09 - to ether scan. But for our local
blockchain, we can see the
428:12 - sender address, the creation
address, the value, gas price,
428:16 - all this stuff associated with
this contract. You can also see
428:19 - the different blocks. Since
we've only made one transaction
428:22 - only one block has been mined.
And this is awesome. We have all
428:25 - this other stuff associated with
it. Great job. You just deployed
428:30 - a contract to your own local
blockchain with ethers. Jas.
428:35 - This is fantastic, Awesome work.
Now let me show you what happens
428:41 - if we don't use the await
keyword here. We're not telling
428:45 - our code to stop. We're saying
hey, deploy this contract and
428:48 - then just keep going. So we
never actually checked to see if
428:51 - this deploy function finished.
So let's see what happens when
428:53 - we run this instead. Instead of
that big contract object, we get
428:57 - this promise in its pending
state because our code actually
429:01 - finished before our contract
could finish deploying. So we
429:05 - see promise pending here
instead, this is why the await
429:09 - keyword is so important. We're
saying hey, wait for this to
429:12 - finish the await keyword also
resolves a promise. So it'll
429:17 - wait for the promise to exit
it's pending state. And then
429:21 - it'll return whatever the
pending promise returns. So
429:25 - contract factory to deploy
returns a promise that returns a
429:29 - contract. In fact, if we go to
the ethers documentation, we
429:32 - look up deploy. And here we can
see contract factory methods
429:36 - contract factory dot deploy. If
we look at the definition of the
429:40 - function, it says contract
factory dot deploy takes a whole
429:43 - bunch of arguments and some
overrides this arrow is saying
429:47 - this is what it returns, it
returns a promise that resolves
429:52 - to a contract. And that's why we
need this await keyword because
429:55 - contract factory to deploy by
itself just returns a promise.
429:59 - But if we do await contract
factory dot deploy, we're saying
430:03 - it returns a promise that
resolves to a contract. And
430:06 - we're waiting for it to finish
deploying to resolve to a
430:09 - contract object. So that's gonna
be a major difference here.
430:12 - Awesome work. So that's gonna be
why this await keyword is so
430:15 - important. And again, you can
only do that in asynchronous
430:18 - functions. So you need this
async keyword at the top of your
430:21 - function names. Awesome work. So
we've deployed a contract to our
430:28 - ganache. Shane, this is
fantastic. Let's play with this
430:31 - a little bit more. So what else
can we do? Remember how in remix
430:34 - and in Metamask, we could add a
whole bunch of stuff. We could
430:38 - add a gas limit, we could add
some value when we were doing
430:41 - our trends. that we could press
the transact button. We know
430:44 - that when we're working with
Metamask, and we want to send
430:47 - some money between our accounts,
430:50 - we can actually choose our gas
price, our priority fee, all
430:53 - this other stuff, we can
actually do all that in ethers
430:56 - as well. So if we wanted to
await contract factory to
431:00 - deploy, but with a certain gas
price, we can add these
431:03 - overrides in this deploy
function here. Another really
431:06 - neat trick that your Visual
Studio code might have is if you
431:09 - click Command or Control,
depending on your setup, you can
431:13 - actually click into a function
and see where it's defined and
431:17 - see everything about this
function. So if I command
431:20 - clicked, I could see that I'm
now in Node modules ethers
431:23 - project contract source of Ts,
all this stuff. And I can see
431:28 - exactly the function definition
of this deploy function on the
431:33 - contract factory object, which
shows us the same code as what
431:36 - we saw in the documentation. We
see we have a deploy function,
431:40 - it takes some arguments, and
then it returns this little
431:44 - semicolon means it returns a
promise that resolves to a
431:47 - contract, which is really nice.
These are in here are actually a
431:50 - list of overrides that we can
specify with some brackets. So
431:54 - what we can do is we can put
some brackets in our deploy
431:57 - function here and specify
certain things like for example,
432:01 - we can specify the gas price to
being some number. And now if we
432:06 - were to run this, we would
deploy this contract with a gas
432:09 - price of this, we could add a
gas limit, we can add a whole
432:12 - bunch of different overrides in
our deploy function here. Well,
432:18 - what else can we do? Well, we
can wait for a certain number of
432:21 - blocks for our contract finish
with so we've deployed the
432:25 - contract. But maybe we want to
wait one block to make sure it
432:28 - actually gets attached to the
chain. So we can say const.
432:33 - Deployment received equals
await, contract dot deploy
432:40 - transaction dot Wait, and
specify the number of
432:43 - confirmations that we want to
actually wait. So we'll wait one
432:46 - block confirmation to make sure
that this happened. And then we
432:50 - can do console dot log, this
deployment receipt option. So if
432:55 - we run the code now, we can see
all this information about our
433:01 - transaction, and we can see
exactly what our transaction
433:04 - looks like, we can see there's
two is no because we're creating
433:09 - a contract from is going to be
this ganache address that we got
433:13 - the private key for, we see the
contract address that we created
433:17 - transaction index, we can see
gas use gas use log bloom block
433:21 - hash transaction, and we can see
all this information about our
433:24 - transaction, something I want
you to take note of is the
433:27 - deployment receipt and the
deployment transaction, I want
433:31 - you to separate these two
because it's going to make your
433:33 - life a lot easier. So we're
going to do quick console dot
433:36 - log, here is the deployment
transaction. And then we'll do
433:43 - console dot log contract, dot
deploy transaction. And then I'm
433:50 - going to copy this whole line by
just typing Command C or Ctrl. C
433:54 - right there. And then here is
the deployment. Here is the
433:59 - transaction receipt. And then
this deployment is receipt is
434:04 - the transaction receipt. So I'm
just going to rename this to
434:07 - transaction receipt. To make it
a little bit clearer, which ones
434:10 - which, and we'll run this one
more time. You only get a
434:15 - transaction receipt, when you
wait for a block confirmation.
434:19 - Otherwise, you're gonna get the
contract object, which has the
434:21 - deploy transaction with it, this
distinction will be more
434:24 - important later on. But I wanted
you to know what the difference
434:27 - between the two transaction
receipt is what you get when you
434:30 - wait for a block confirmation,
the deployment transaction or
434:34 - the transaction response,
transaction response is what you
434:38 - get just when you create your
transaction. So transaction
434:41 - receipts transactional response,
they're different receipt is
434:44 - what you get when you wait for a
transaction to finish. And then
434:47 - response is just what you
initially get. Make sense? Okay,
434:49 - great. We're gonna go ahead and
delete those. But those lines
434:52 - will be in the code associated
with the GitHub. Now you saw
434:58 - when we actually printed out
those receipts, we got all this
435:01 - stuff in here, because deploying
a contract is actually just
435:04 - sending a transaction, as we've
said before, so if we want to
435:08 - see what's really going on under
the hood, we can actually create
435:12 - a transaction ourselves and
create a contract ourselves just
435:16 - by specifying the transaction
information. So how will we do
435:20 - that? Let's deploy this contract
again, but only purely using
435:24 - transaction data. So we'll do a
console dot log.
435:28 - Let's deploy with only
transaction data. And this is
435:34 - going to be the way you can
actually deploy or send
435:37 - transactions purely with
transaction data you can send
435:39 - any transaction this gives you
unlimited flux. ability with the
435:43 - transactions you want to send,
what we can do is we can say
435:46 - const, or let TX which is going
to stand for our transaction
435:51 - equals, and we can just add all
of our transaction information
435:54 - in here. So the first thing that
we're going to need is our nuts,
435:57 - or the number that we only use
once we go back to our
436:01 - transaction count, we're on four
transactions here. So we'll use
436:05 - the nonce five, because that's
going to be a nonce that we
436:07 - haven't used before. Every time
you send a transaction, it comes
436:11 - with one of those nonces. Right,
so the nonce is a bit of a over
436:15 - overused term, we saw it back in
our blockchain basics that we
436:18 - use the nonce to solve that hard
problem. nonces are also used in
436:23 - wallets and in signers, to send
transactions and they use a
436:26 - different nones for every
transaction. So nonce, when
436:30 - we're talking about wallets
talks about a number associated
436:33 - with a unique transaction.
nonce, when we're talking about
436:36 - blockchain mining is a value
used to solve that hard problem,
436:40 - they both mean the same thing.
They both mean a number only
436:42 - used once. But they're different
in these different contexts. So
436:45 - we're going to use this number
only use once this unique number
436:48 - for a transaction to send this,
so we're going to say nonce is
436:51 - going to be five, we're going to
pick a gas price of, of this
436:55 - right here, we're just going to
use the gas price of ganache
436:59 - like that, we're going to pick a
gas limit of some big number,
437:02 - we'll use 1123456, we'll just
use that we're gonna say two is
437:08 - going to be no, right, exactly
like what we saw in our receipts
437:13 - and responses down here. Since
we're creating a contract value
437:17 - is going to be zero. Since we're
creating a contract, we don't
437:20 - want to send an ether polygon or
avalanche. And then data is
437:25 - going to be that massive binary
object in our binary bit. So in
437:30 - the binary section, we're gonna
copy this massive binary piece,
437:34 - and we're going to put some
quotes in here, we're gonna do
437:37 - 0x, and paste that in here. So
this massive, massive data piece
437:42 - is the binary that we're
sending. Whenever you send a
437:44 - transaction, you have this this
data object that you can fill
437:47 - this stuff, we're filling our
data object with the binary with
437:51 - the code that tells the theory
that tells our blockchain to
437:54 - deploy our smart contract that's
going to look exactly like this.
437:58 - And then finally, we want to add
the chain ID.
438:02 - As we've seen before with
Metamask, if we go back over to
438:05 - our networks, each one of these
EVM chains has a different chain
438:09 - ID Etherium. Main net is one
ropsten is three Rinke, B is
438:13 - four COVID is 42, etc. And other
EVM chains like avalanche like
438:18 - polygon, are going to have their
unique chain IDs as well, or
438:22 - ganache, we can see the network
ID appear is 1337 in some
438:27 - people, so we can just paste
that in here. Some people have
438:30 - run into some issues where the
chain ID and the network ID are
438:33 - different. And the chain ID is
actually 31337. So if you have a
438:38 - problem with this, try 31337
instead, but it should be 1337.
438:43 - Now this is a transaction with
all this information propagated,
438:46 - which is awesome. However, this
transaction isn't signed. So
438:50 - nobody's sending this
transaction right now this is
438:52 - just the transaction details of
what somebody wants to do, we
438:55 - actually need to sign this
transaction, and then send it to
438:59 - our blockchain. Cons sign, TX
response equals await, wallet
439:09 - dot sign transaction, and we can
pass that TX object. And then
439:15 - we'll do a console dot log of
the sign TX response in
439:20 - JavaScript. Same as solidity. If
you type two backslashes, before
439:25 - some code, it won't run that
code. So I'm gonna go ahead and
439:29 - comment out the three lines
above. And the way that I'm
439:33 - doing it is by highlighting the
sections and hitting Command
439:35 - backslash, or you might hit Ctrl
backslash, but this is a
439:39 - keyboard shortcut you can use to
quickly comment out entire
439:42 - sections. And the reason I'm
doing this is because I want to
439:45 - show you what happens when we
just run scientex response
439:49 - wallet that signed transaction
back in nosh, we see that we
439:53 - have four blocks in here. Let me
ask if we do this sign
439:56 - transaction and we get the
signed transaction response,
439:59 - will we propagate another block?
Well, let's find out run no
440:03 - deploy.js, we get this massive
thing here. But if we go back to
440:08 - ganache refresh, we actually
don't see another transaction
440:13 - sent. That's because we're only
signing a transaction here,
440:17 - we're not actually sending it.
So the signed transaction
440:20 - response. This big number here
represents a signed transaction
440:25 - but not a cent transaction,
which is different. You can
440:28 - actually send one of these
transactions by changing this
440:31 - line a little bit. So instead of
scientex response, we'll change
440:35 - this to send TX response equals
await wallet dot send
440:39 - transaction TX then once We send
the transaction here, we can do
440:44 - a wait, send transaction
response, that Wait, one, we're
440:50 - gonna wait one block
confirmation to make sure this
440:53 - transaction actually goes
through. And we can run node.js.
440:58 - And it looks like it's done. But
if we actually scroll up, we
441:01 - actually got an error here. So
there's this huge, massive thing
441:05 - here. And if we scroll up, we'll
eventually see TX reject error,
441:10 - the TX doesn't have the correct
nuts, which just for some
441:13 - practice, let's go ahead, type
this into Google and see what we
441:18 - get. We actually get a web three
Jas from four years ago, trying
441:22 - to call leaf picked, blah, blah,
blah, blah, blah, blah, blah,
441:25 - blah. It looks like this is a
meta mask issue that they ran
441:29 - into. And they said, you have to
reset your account in meta mask,
441:32 - which we could do. But let's
make this a little bit more
441:35 - specific. Let's say ethers. JS
looks like we don't get it looks
441:40 - like as of right now, from this
recording, we don't get a Stack
441:44 - Exchange eath or a Stack
Overflow question for this
441:46 - trolley, because this is pretty
straightforward. We don't have
441:49 - the correct nonce for our
transaction. But this would be a
441:51 - good time to actually make this
a question on Stack Overflow or
441:55 - Stack Exchange Aetherium so that
it shows up first. So we
441:58 - actually don't get the correct
nuts, we're going to want to
442:00 - make this a nonce of four you
can see here account has a nonce
442:03 - of four TX has a nonce of five.
So we actually would want this
442:07 - to be four. Now an easier way to
always get the correct nonce
442:10 - here is going to be actually
just calling the transaction
442:14 - count from the wallet. So back
in the ethers documentation,
442:16 - there's actually some good
samples here on how to assigning
442:19 - a message and then how to
actually send these messages. So
442:23 - we can do a weight wallet dot
get transaction count to get the
442:26 - nuts. So back in our code, we
could do const nuns equals
442:32 - await, oops, copy pasted, await
wallet dot get transaction
442:37 - count. And then we can just
place the nonce right here.
442:40 - Now, let's try running this
again. And it looks like this
442:44 - one did indeed go through. We
can verify on ganache here. We
442:48 - do indeed see we're currently on
block five now and we have one
442:51 - extra transaction. Now we could
go ahead and just run this
442:54 - again. And we'll never have to
worry about actually updating
442:57 - this nonce ourselves. Since
we're just calling wallet dot
443:00 - get transaction count to keep
updating it current block is six
443:03 - and the our additional
transaction has indeed gone
443:06 - through awesome. I showed you
how to actually sign the
443:09 - transaction. But we didn't sign
the transaction for our central
443:12 - injection. Well, why not? If you
command click or control click,
443:16 - or you go to the documentation
for ethers, we can see the code
443:20 - for send transaction. So first,
it does some check provider
443:23 - stuff. There's some stuff to
populate the transaction. But we
443:25 - can actually see that before it
sends the transaction even in
443:29 - ethers, it signs the transaction
first, and then calls this dot
443:34 - provider dot send transaction.
So if you just call send
443:37 - transaction with the transaction
details like we did here, it's
443:41 - the same as signing it first and
then sending it with the
443:44 - provider. Okay, great. So we've
learned how to send a
443:47 - transaction using pure
JavaScript and using pure
443:50 - ethers. One of the main
takeaways from this is that
443:53 - every time we change the
blockchain, every time we change
443:56 - state, every time we use gas,
we're sending a transaction that
444:00 - looks pretty much exactly like
this, the data is going to be
444:04 - the differentiator, the data for
us here was data saying to
444:07 - create a new contract, when we
make transactions, like adding
444:11 - people or storing the data that
we're going to be passing in our
444:14 - transaction is going to be data
associated with calling these
444:17 - functions. And when we actually
call functions in ethers, or in
444:21 - Hardhead. We're not going to do
this kind of raw const, TX, and
444:24 - list out all the stuff like here
and list out the raw data,
444:27 - right? Because that's really,
really hard ethers and hard hat
444:30 - are going to make this process a
lot easier. So for now, let's go
444:33 - ahead, comment out this whole
section, which again, if we copy
444:36 - this whole thing, and then hit
Command, slash, or control
444:40 - slash, or whatever the shortcut
is on your environment, that'll
444:42 - actually comment this out. Let's
go ahead and uncomment this
444:45 - section so that we deploy our
contract using kind of the ether
444:48 - is much easier to read way than
this weird TX stuff. Oh, cool.
444:52 - So we've changed our script back
to deploy our contracts like
444:55 - this. Now that we've actually
deployed our contract, we can
445:00 - learn how to interact with our
contract through code as well,
445:03 - the same way that we click these
buttons in remix, we're going to
445:06 - code it out for ourselves here.
So if we look at symbol storage,
445:10 - we have a button for add person
for store. And then we have
445:14 - these view functions as well.
The easiest one is going to be
445:16 - the Retrieve function, which
grabs our favorite number,
445:19 - retrieve returns favorite
number. So we can call that in
445:23 - ethers by doing const. current
favorite number equals await.
445:31 - contract.we retrieve. The
contract object that we have is
445:37 - what's returned from our
contract factory as long as
445:40 - we've awaited it the contract
object is going to come with all
445:43 - the functionality described in
our API. That's why we had to
445:46 - pass the API to our contract
factory. If we look inside our
445:51 - API piece here, we can see it
has a ton of information on the
445:55 - different functions that we can
call and the types that it has
445:58 - and the return types and
everything like that. For
446:00 - example, if I look up retrieve,
I can see down here, we have
446:05 - retrieve, we can see that the
name of this function is going
446:08 - to be retrieved. And the outputs
are going to be a un 256, of
446:13 - type Nuun 256. Now, this is a
little bit difficult to read
446:16 - because it's not formatted.
Since we call this dot API, it's
446:19 - going to be a little bit hard to
read. But we could change it the
446:22 - dot JSON. And then you'll see
it's highlighted a little bit, I
446:27 - can even do format document with
prettier. And you'll see it
446:32 - actually formats to be a lot
easier to read now and go back
446:35 - to retrieve. And we can see,
this block of code here defines
446:40 - what the Retrieve function can
and can't do. I'm going to
446:43 - change it back to abi. And it
looks like my formatting has
446:46 - stayed, which is great. This is
much easier to read than it was
446:49 - before. As I said, the ABI or
the application binary interface
446:52 - is incredibly important for
working with our contracts. If
446:55 - we give our code just this huge
bytecode thing, it's gonna be
446:58 - really hard for any processor to
decompile this or understand
447:03 - what exactly what the functions
are that are going on here.
447:05 - There are decompiler options out
there, like ether VM, that IO
447:09 - slash decompile. That can
decompile some bytecode into the
447:13 - solidity. But it can be really
tricky to get it exactly right.
447:17 - So it's much easier just to have
the ABI to say, hey, this lump
447:20 - of code, this lump of numbers
and garbled nonsense is this.
447:25 - When we deploy this bytecode to
the blockchain, and we call
447:28 - functions on it, the code will
automatically allow those
447:30 - functions to get called if they
do exist. But in order for our
447:33 - code to know that they exist,
it's much easier just to give it
447:36 - the API. So we can get our
current favorite number like
447:39 - this. Let's go ahead and console
dot log, the current favorite
447:44 - number. Now that we've edited
this code, we're going to let me
447:48 - zoom out a little bit. Now that
we've edited this code, we're
447:51 - going to connect organ nosh
instance, we're going to connect
447:54 - a wallet with a private key that
we got from the top of our
447:58 - ganache here, we're gonna grab
the ABI and the binary of our
448:01 - contracts, and connect them to a
new contract factory object,
448:05 - which is connected to that
wallet. So that wallet will be
448:09 - the one to actually deploy the
contract, we'll deploy the
448:12 - contract with const contract
equals await contract factory
448:15 - dot deploy, we will wait one
block for that transaction to
448:18 - finish. And in fact, we're not
going to use transaction
448:20 - receipt. So for now, we're just
going to delete that part. We're
448:24 - not going to do any of this
here. So I'm going to delete it
448:27 - for now. However, I'll leave
this section commented out in
448:29 - the GitHub repo. And then we're
going to call contract retrieve
448:33 - which should return our current
favorite number. Since this is a
448:36 - view function, this contract
call won't cost us any gas. If
448:40 - we look at simple storage, that
soul we can see retrieve is a
448:44 - view function. And remember view
and pure functions, if called
448:48 - outside of a contract function
call don't cost any gas, we're
448:52 - just reading up the blockchain,
we're not changing any variables
448:55 - on chain, we're not changing the
state of the blockchain. So this
448:58 - won't cost any gas. So let's go
449:00 - ahead and run this. Perfect, we
get deploying, please wait. And
449:06 - then we get this big number
response. So what's this big
449:09 - number response here? Big number
is a library that comes with the
449:13 - ethers application that helps us
work with numbers. If you
449:16 - actually scroll down, they even
have a section saying why can I
449:20 - just use numbers, you'd expect
current favorite number to just
449:23 - be zero, but it returns this
weird hex thing that says his
449:25 - big number true this weird, big
number thing. So solidity can't
449:29 - use decimal places, and
JavaScript has a hard time with
449:32 - decimal places. And this is kind
of the more specific rationale
449:35 - for why not to use numbers, what
you'll see a lot of the time
449:38 - instead of numbers is you'll see
strings like zero, you'll see
449:42 - JavaScript use strings like
this, or big numbers. Now, if I
449:47 - were to try to pass a number
like this in JavaScript, this
449:51 - number would be too big for
JavaScript to understand. So we
449:53 - want to use big numbers or
strings when working with
449:56 - ethers. Now we can make this
more readable by adding.to
449:59 - string at the end and printing
out the string version of this
450:03 - big number. Now, if I rerun this
code, we can see we get zero,
450:08 - which makes sense again, because
our favorite number gets
450:11 - initialized to the zero value,
if not specified, and we haven't
450:16 - called store yet. So awesome. So
that is, that's working
450:19 - perfectly. So this is what our
current favorite number is.
450:22 - Let's make this console dot log
a little bit more syntactical.
450:25 - We're going to use something
called string interpolation. So
450:28 - we can interpolate our string
here with variables. Typically
450:32 - in JavaScript when working with
strings, use double quotes.
450:34 - However, if you want to mix
variables with actual strings,
450:39 - you can use backticks instead.
So we're going to use some that
450:42 - backticks here, and we're gonna
say current favorite number to
450:47 - call in here. And to tell
JavaScript that this is a
450:50 - variable that we want to read,
we put a little dollar sign and
450:54 - a bracket around it, like this.
Now, if we run this code again,
450:59 - it's saying deploying, please
wait, and we get current
451:02 - favorite number is zero, because
JavaScript goes, Okay, this is a
451:05 - string, ah, dollar sign, curly
brace looks like this is going
451:09 - to be some variable or some
JavaScript that you want me to
451:12 - interpret and close it off, and
then backtick. Cool. So our
451:16 - current favorite number is going
to be zero. Great. So let's
451:18 - update on the contract the
number by calling the store
451:21 - function. So we'll say const,
transaction response equals
451:27 - await, contract dot store, and
we'll add seven. Now since seven
451:32 - is a small number, you can just
pass it like seven. But passing
451:35 - it like seven in a string also
works. Again, this is because if
451:39 - we want to pass some crazy
massive number, JavaScript would
451:43 - get confused. So it's usually
best practice to pass variables
451:47 - to contract functions as
strings, even though that might
451:49 - be a little bit confusing ethers
is smart enough to know that
451:53 - this seventh string is actually
seven the number then we can do
451:56 - const. Transaction received
equals await transaction
452:03 - response that Wait, one. So
we'll wait one block here. This
452:09 - is similar to us doing contract
dot deploy transaction dot Wait,
452:13 - the syntax here is a little bit
different than what we saw up
452:16 - here. Because this is using a
contract factory. And this is
452:18 - calling a function on a
contract. So when we call the
452:22 - function on the contract, we get
a transaction response. When we
452:25 - wait for the transaction
response to finish, we get the
452:27 - transaction receipt. Now I can
do const, updated, favorite
452:32 - number two equals await on track
dot retrieve. And then console
452:39 - dot log updated. favorite number
is, and we'll do a little string
452:46 - interpolation, updated, favorite
number like that? Now let's go
452:51 - ahead and run this. So in this
process, what are we doing,
452:54 - we're deploying the contract,
we're getting the initial value,
452:57 - we're going to update our
contract by calling store which
453:01 - is going to cost gas. So this is
a transaction, we're going to
453:05 - get the transaction response,
then we're gonna get the
453:07 - transaction receipt, we're not
going to do anything with the
453:10 - transaction receipt, I want to
ingrain in you all that these
453:13 - two are different transaction
response and transaction
453:16 - receipt, and you'll see why in
the future. And then we'll get
453:19 - the updated favorite number, and
then we're just going to print
453:21 - it out. So let's do this. Boom,
and perfect. Deploying, please
453:26 - wait, current favorite number is
zero, updated favorite number is
453:30 - seven. And if we go to our
ganache instance, we go to
453:33 - transactions, we can see, we now
have a contract call at the top,
453:38 - we have the sender, the contract
address, the gas price, all this
453:42 - stuff, and we see our
transaction data right here. So
453:46 - this transaction data is what
gets sent in that data slot of
453:49 - our transaction object. Ethers
is just doing that on the back
453:53 - end for us so that we don't have
to make that big transaction
453:56 - object there. All right,
awesome. You've successfully
453:59 - deployed a contract to your own
local ganache instance, or your
454:04 - own JavaScript virtual machine.
This is great.
454:09 - Now let's clean this up a little
bit. Because if we look up here,
454:12 - we have both our connection to
the blockchain and our private
454:17 - key stored directly in our code,
we were to push this code up to
454:21 - a GitHub or some other code
repository, if you will, will be
454:24 - able to see our code. If we look
into ploy dot j s of my code,
454:28 - ah, there's something else in
here, we don't actually see the
454:31 - private key or the RPC URL in
here. So what's going on?
454:34 - Remember, if you give out your
private key, whoever has your
454:37 - private key owns your funds. So
even though this is a fake,
454:40 - private key that doesn't have
any real money in it, we still
454:43 - don't want to have to hard code
our private keys into our code,
454:46 - just in case we accidentally
share code with somebody. So
454:49 - what can we do? Well, one of the
most popular methods is actually
454:52 - creating something called a dot
EMV file or an environment
454:55 - variable. And if you're familiar
with environment variables, you
454:58 - can actually set them right in
your terminal, but we're gonna
455:01 - set them in our dot env. So what
you want to do is you're gonna
455:04 - want to create a dot env file.
And this is going to be a file
455:07 - where you store its sensitive
information. And this is going
455:10 - to be a file, we're never going
to share this with anybody. This
455:13 - dot env file will stick
variables of our choosing into
455:16 - the environment of our code. So
for example, if I pull up my
455:20 - terminal here, and I do echo
cat, this is going to reflect
455:25 - what the cat environment
variable is for us. Right now
455:29 - there is no cat environment
variable. However, if I do
455:32 - export, cat equals dog, and now
I do echo dollar sign cat, I get
455:41 - dog output. This is what an
environment variable is, it's a
455:45 - variable in our terminal or in
our scripting environment, since
455:48 - I don't want to have to type
export, private key equals blah,
455:52 - blah, blah, every time, what
we're going to do instead is
455:55 - we're going to stick them into
this dot env file. So when this
455:58 - dot env, we can put private key
equals. And we can grab this
456:04 - private key from our script, and
paste it in like this. And a
456:08 - note, some tools look for the
0x, at the beginning of the
456:11 - private key ethers, and hard hat
is smart enough that either one
456:14 - works, but if you run into some
issues, just know that sometimes
456:18 - you might have to put your 0x at
the front of this. Great. So now
456:21 - we have a private key in an
environment variable. What do we
456:23 - do now? Well, in our deploy.js,
we want to grab this environment
456:28 - variable and stick it into our
script here, so that our script
456:32 - can then stick it into our
environment. So we're going to
456:34 - add a tool called dot env. To
make this easier, so we're gonna
456:38 - do yarn, add dot env. And if we
look at the dot env package, can
456:44 - read more about it and read
about how to add it with NPM.
456:47 - Again, we're just using yarn
add. But then we can just call
456:51 - this require dot E and V dot
config. And this will pull in
456:54 - all our environment variables.
So we can just do require
456:59 - dot EMV config, we should see
this on our package that JSON,
457:04 - we do. Excellent. Now that we
pulled it in, we actually get
457:07 - access to our private key
environment variable, you can
457:11 - access environment variables in
JavaScript, are using process
457:14 - dot EMV. So instead of putting
our private key here, we're
457:17 - gonna delete that whole thing
and substitute it with process
457:21 - dot EMV, that private key, and
we'll save and it'll reformat
457:26 - for us to make sure this is
actually working, we can just
457:29 - hit up after we save up, up up
up up a bunch and go back to no
457:34 - deploy to Jas. And we see we get
the exact same setup. And if we
457:38 - scroll back, you can see a
transaction has indeed gone
457:41 - through. If you want to double
check that this is actually
457:43 - printing out your private key,
we could do console dot log,
457:47 - press study and via private key
we run, we see that that is
457:51 - indeed the private key coming
from our environment variable
457:54 - here. Awesome. Now our RPC URL
here is isn't really something
457:59 - that we need to secure however,
maybe we're going to use a
458:01 - certain API key or maybe a
certain endpoint that only we
458:05 - want to have access to. And we
don't want anybody else to be
458:07 - using our RPC endpoint. So we're
going to add this to our dot env
458:11 - file as well. So in our dot env.
When I copy this here, I'm gonna
458:16 - say RPC URL equals, and I paste
that in there, just like that.
458:22 - And we're gonna delete here. And
we're gonna do the exact same
458:25 - thing, say process dot e NV dot
RPC URL. And now we're going to
458:30 - run this again. And I'm going to
take out that console dot log.
458:33 - And we should get the exact same
response because all we did was
458:37 - swap out our RPC URL with our
environment variable, which is
458:41 - going to be exactly what it was
before. So we go ahead and run
458:43 - this, and we get the exact same
response. And if we go to
458:46 - ganache, we see that we do
indeed get a transaction here,
458:50 - which is perfect. Awesome. So
we've learned how to add
458:54 - environment variables to our dot
env file. So that so that just
458:58 - in case, we want to share our
code, or we push our code up to
459:00 - GitHub, which we'll do in later
sections, we don't accidentally
459:03 - expose our private keys or our
RPC URLs. Now all the code that
459:07 - we have in our project here, if
we push it up to GitHub, or
459:11 - share it with somebody else, all
this code will get pushed up,
459:14 - including our dot env file.
However, if you look at my code
459:17 - samples here for this course, we
don't see a dot env file in
459:22 - here. So how is that possible?
Well, what we want to do
459:25 - whenever we have a project is
create a dot Git ignore file.
459:30 - And in here, we want to put in
v. And we also want to put in
459:34 - Node modules. This means that
when working with Git and
459:38 - working with version control,
which we're going to do a little
459:40 - bit later, we won't push our dot
env file up to GitHub. And we
459:44 - also won't push up known
modules. So if we go back to my
459:47 - example here, we don't see, we
don't see a dot env file, but we
459:52 - do see a dot env dot example,
just to show you what one would
459:56 - look like. So it doesn't really
matter that I have them in here.
460:01 - Now, if you're really paranoid,
there's something else you can
460:03 - actually do when running your
scripts and running your
460:05 - commands. Let's say you didn't
want to put your private key
460:08 - into a dot env file because you
were nervous that you would
460:11 - accidentally push it up or
something. What you can do is
460:13 - you can add your private key in
your RPC URL as environment
460:16 - variables right in the command
line. So before you run Node
460:20 - deploy, that's as well you can
do, you can say RPC URL equals,
460:25 - paste your RPC around. And then
you can say private key. equals
460:32 - and then paste your private key
and then do node deploy.js.
460:37 - Setting these right before we
run our script is the exact same
460:40 - as if we had set them into dot
env. Here If we hit run, we see
460:43 - the exact same output, which
means that our RPC URL and our
460:46 - private key went through
successfully. This way for key
460:49 - management is fine. But our
rights doing this, it's going to
460:52 - be much better. But it still
makes me a little bit nervous in
460:55 - our development environments
with our fake private keys,
460:57 - having our code in the dot env
file like this is, is okay,
461:01 - right? Because we don't really
care if this key gets hacked,
461:04 - like nobody's using it. But when
we move to a more professional
461:06 - setup, this can be a little bit
scary. So how can we make this
461:10 - even more secure? Well, what we
can do is actually we can
461:14 - encrypt our private key and
store our encrypted key locally.
461:17 - That way, if for some reason
somebody does get into our
461:20 - account, our private key isn't
just sitting around in plain
461:23 - text, it's encrypted. And you'll
need to know a password that
461:26 - only you know to get into it. So
how do we add that? Well, first,
461:29 - we're going to create a new file
called encrypt key.js. And this
461:36 - is some code that we're going to
use to actually encrypt a key.
461:39 - And we'll store that locally
instead of our private key in
461:41 - plain text. This will make us
even more secure so that we
461:45 - don't have our private key just
hanging around in plain text
461:47 - here. So let's go ahead and
build the script to encrypt our
461:50 - private key. So we're going to
use the exact same setup as we
461:52 - did for our deploy script. We're
going to do an async function
461:55 - main.
461:57 - And then down here, I'm just
gonna go ahead and copy from
461:59 - deployed J S. We're gonna use
this exact same setup, and paste
462:03 - it. Okay, great. We're gonna be
using ethers J, s, and r dot E
462:07 - and V again. So we're going to
add these in const ethers equals
462:10 - require ethers const, FS equals
require Fs extra. And then
462:20 - require dot env. Config.
Alright, so right now, in our
462:27 - dot env, we do have this private
key. And again, if you don't
462:30 - want to have the private key in
their way you can just do is you
462:33 - can do private key equals and
then you know, node, whatever
462:36 - script you want to run. So we're
going to set this script up to
462:39 - run our encrypt key one time.
And then we can remove our
462:43 - private key from anywhere in our
workspace so that it's no longer
462:46 - in plain text anywhere. So what
we want to do is we want to say
462:48 - const wallet, and we're gonna
create a new wallet, but a
462:53 - little bit differently. We're
gonna say equals new ethers dot
462:56 - wallet, process dot E and V dot
private key. So we do need our
463:03 - private key to stick in here.
But then once we create this
463:06 - wallet, we're gonna say const.
Encrypted JSON key equals await
463:14 - ethers dot encrypt, this encrypt
function is going to return an
463:19 - encrypted JSON key that we can
store locally and that we can
463:23 - only decrypt it with the
password. And it takes two
463:26 - parameters. It takes a private
key password and a private key.
463:30 - So in our dot EMV, just for
right, now we're going to create
463:33 - a private key password. And I'm
going to say it's password. But
463:38 - obviously, this is a terrible
password. And you should never
463:40 - use password as your password.
But for now, we're just going to
463:43 - leave it as password since I'm
encrypting this big key anyways.
463:46 - So we're going to encrypt it by
passing the password process
463:49 - study and v dot private key
password. And we're also going
463:53 - to pass the private key, it's
going to be ethers, it's going
463:56 - to be wallet dot encrypt. We're
also going to pass it process
464:00 - dot EMV dot private key. Now
let's go ahead and run this
464:04 - right now. And then we'll
console dot log out this
464:08 - encrypted JSON key and see what
happens when we run this. So to
464:12 - run this, we're going to do
node, encrypt key.js. And hit
464:16 - enter. And we'll see what
happens when we console log it
464:19 - out this JSON object here is
what our key looks like,
464:23 - encrypted. So it's got the
address this ID version, all
464:27 - this other stuff. And all this
other stuff is the encrypted
464:31 - version of this key. If somebody
gets into our account and they
464:34 - see this, they'll have to know
the password to decrypt this
464:38 - private key, they'll need to
know the password to decrypt
464:40 - this JSON object back into a
private key. So what we're going
464:44 - to do, now that we've encrypted
it, we're going to save it. So
464:47 - we'll do Fs dot write, file
sync, we're going to pass it to
464:52 - dot slash dot encrypted key dot
JSON, comma encrypted JSON key.
464:59 - So we're saving it to a new file
called dot encrypted key dot
465:02 - JSON. And we're passing it this
encrypted key that we just made.
465:06 - So if we open up our file
explorer, and we run this
465:09 - command,
465:12 - you'll see we get a new file
called dot encrypted key dot
465:15 - JSON. And it's this encrypted
key here, which is awesome. So
465:19 - now what we want to do in our
dot Git ignore is add dot
465:22 - encrypted key dot JSON, so that
we don't accidentally push this
465:28 - up to GitHub. And now we have an
encrypted key and we can go to
465:31 - our private key and delete this
from our dot env file. We can
465:35 - also delete our private key
password from our WMV file so
465:39 - that the password isn't just
hanging around in plain text.
465:41 - Now that We have an encrypted
key. Back in our deploy script,
465:45 - we can change the way that we
actually get a wallet. So at the
465:49 - top, we're getting our wallet
just by passing in the private
465:52 - key like this, we're not going
to do that, we're going to use
465:54 - our encrypted key that we just
created. So we're going to do is
465:58 - we're going to say const
encrypted JSON equals Fs dot
466:03 - read file sync. That slash dot
encrypted key dot JSON, comma
466:12 - UTF eight, this Fs dot read file
sync is just going to read from
466:16 - our encrypted key dot JSON into
this encrypted JSON variable
466:20 - here. Next, we're going to
create a wallet from this
466:24 - encrypted key. We're gonna say
let wallet equals new ethers dot
466:30 - wallet, dot from encrypted JSON
sync. And all these commands
466:38 - that we're working with ethers,
we can of course, find them in
466:42 - the documentation from encrypted
JSON sync takes the encrypted
466:46 - JSON and a password and returns
a Wallet Object. So we're going
466:49 - to pass it that encrypted JSON
that we just read. And then
466:53 - we're going to pass it password
which we're going to do process
466:57 - dot EMP dot private key
password. And then finally, the
467:03 - reason I use let here is because
now we have to connect this
467:06 - wallet back to our provider. If
you look here, we're not
467:09 - connecting our wallet with a
provider. When we make our
467:11 - transactions with our contract
factory, we need to make sure
467:14 - the wallet knows about the
provider here. So we can just
467:17 - say wallet equals await wallet
dot connect provider. Now, if we
467:24 - run our deploy dot j s with our
private key password as an
467:28 - environment variable, it should
still deploy. So we can do
467:31 - private key password equals
password, which yes, we know is
467:34 - terrible. But that's what we're
using for now node deploy dot j
467:38 - s, we should get the same output
we've been seeing this whole
467:41 - time and we do we're able to no
longer have our private key in
467:47 - our dot env file not in
plaintext anymore, it's in this
467:49 - encrypted key. So that just in
case somebody hacks our
467:52 - computer, they still won't be
able to send in new transactions
467:55 - unless they know the password.
This is awesome. One more thing
467:58 - to know, if you type history, if
somebody got into your computer,
468:02 - a hacker could actually see
private key password equals
468:05 - password in your bash history.
If you run history, dash c, you
468:10 - actually will clear your
history. Now if I type history,
468:14 - I can just see that the most
recent command I wrote was
468:16 - history, this is really just
some of the bare minimum for
468:19 - encryption and keeping your key
safe. And it might seem
468:21 - ridiculous that somebody might
be able to hack your computer
468:24 - and read your encrypted private
keys and everything. But as your
468:26 - projects get bigger and bigger,
it is really important to know
468:29 - about private key security and
private key safety and, and for
468:32 - this course really just giving
you the bare minimum here and
468:35 - showing you how to encrypt keys
and how to be a little bit safer
468:38 - here. Now for the rest of this
course, we are going to be just
468:41 - using this syntax with our
private key in a dot env file.
468:46 - The reason why we're doing like
this for the rest of the course
468:48 - is it is a little bit easier,
I'm really hoping Hardhead add
468:51 - some additional features to make
private key encryption much
468:53 - safer and also easier to use in
the future. And they probably
468:56 - will. And the other reason that
we're okay to do this here is
468:58 - because you've solemnly sworn
that you're not going to use an
469:01 - account that has any real money
in it for the duration of this
469:03 - course, you're only going to use
private keys that have tests on
469:06 - Aetherium or are fake private
keys like this one that we got
469:08 - from ganache. In fact just to
really hone this in in the smart
469:12 - contract kit slash full blocked
in solidity course, Jas GitHub
469:16 - repo in the discussions tab, you
go to announcements, I've
469:20 - created one called the dot end
pledge. Because recently I've
469:23 - seen too many people follow a
tutorial that doesn't tell them
469:27 - about the security risks of
doing this. And I've made this
469:30 - dot EMV pledge, I would love
everyone to jump on and read.
469:33 - And if you agree, at the bottom,
leave a comment saying I will be
469:37 - safe, I will be safe, make sure
you read and you understand
469:41 - what's going on in here. And I'm
not doing this to scare you.
469:44 - Because again, at the end of the
day, if you use a Metamask that
469:47 - only has tests that funds for
the duration of this course, you
469:50 - will never have to be worried
because of your key gets
469:52 - compromised. It's just test it.
So who cares? This is if you're
469:56 - using a meta mask or you're
working with a meta mask that
469:58 - has real funds. So I'm going to
read up the pledge because it is
470:02 - really important. You understand
this when you're working with
470:05 - real funds. And if you're like,
Hey, I'm not working with real
470:07 - funds, I don't care, great move
past this, whatever. But when
470:11 - you do work with real funds,
when you do decide, hey, I
470:14 - actually want to deploy this to
a real network. Now I need real
470:17 - money to do that. Come back to
this pledge. Scroll the bottom
470:21 - say I will be safe and make sure
you read and you understand
470:24 - this. Okay, so the pledge is, I
solemnly swear that I will never
470:28 - place a private key or secret
phrase or pneumonic in a dot env
470:32 - file that is associated with any
real funds. Basically, you
470:36 - basically never have your
private key or your pneumonic
470:39 - phrase, in plain text, anywhere.
You'll all only place private
470:43 - keys in a web file that only
have tested e FF link or other
470:48 - cryptocurrencies. Because again,
if your private key has only
470:51 - test net funds, then that's
great. I don't care, we are
470:54 - aware that if we forget a dot
Git ignore, and we push our key
470:58 - phrase to GitHub, even for a
split second, or even show our
471:02 - key slash phrase on the
internet, wherever it may be for
471:05 - a split second, it should be
considered compromised. And you
471:08 - should remove all funds
immediately. So even if you
471:11 - deploy your private key to a
website, and then immediately
471:14 - delete your website and think,
Oh, nobody probably got to it,
471:17 - you should consider that private
key compromised, and you should
471:20 - remove all your funds. And
again, this is just for real
471:23 - funds. If your private key was
only tested, funds gets
471:25 - compromised. Well, who cares? I
do that all the time, you've
471:28 - been seeing me do that all the
time, because it only has tested
471:30 - funds in it. If at the end of
this course, you want to steal
471:33 - all of my tests that funds I
mean, have a blast, it would be
471:36 - annoying to me at worst. If I'm
unsure if my account has real
471:39 - funds in it, I will assume it
has real funds in it. So if you
471:43 - don't know if it has real funds,
assume it has real funds, and
471:46 - you will not use it for
developing purposes. And then
471:48 - finally, I am aware that even if
I hit Add Account on my meta
471:52 - mask or other eath wallet, I
will get a new private key, but
471:55 - it will share the same secret
phrase slash pneumonic of all
471:59 - the other accounts generated in
the meta mask or other eath
472:02 - Wallet. So if I'm in my meta
mask here, and I hit Create
472:06 - account, I will get a new
private key with the new
472:09 - account. However, all of these
accounts that I've created with
472:13 - this Create Account button have
the exact same pneumonic phrase
472:16 - or secret phrase. If I import an
account with a private key, it's
472:20 - going to have a different
pneumonic phrase. But all of the
472:22 - ones that I generate inside the
wallet are all going to have the
472:25 - same phrase. Okay, great.
Hopefully that'll make sense. I
472:28 - have some pledge additions here.
For this course, I will only use
472:31 - funds associated with a brand
new never before use meta mask
472:34 - or other eath wallet. Again,
this is not to scare you, if you
472:37 - just work with a brand new meta
mask, you don't have to worry
472:40 - about any of this and just refer
back to this when you start
472:42 - looking at real money and real
private keys. I'm aware that my
472:46 - account associated with my
private key is the same on test
472:49 - nets that it is on Main nets. So
like I was showing you, my
472:53 - private key on Rinkeby is going
to be the same as my private key
472:55 - I'm on a main net, if I must use
a private key associated with
472:58 - real funds in the future, until
I am 100% sure what I am doing,
473:02 - I will always either use one of
the encrypted methods that
473:06 - Patrick showed you some better
encryption stuff that I didn't
473:09 - show or use the command line way
to pass private keys and then
473:13 - delete the command line history
right after. If I'm never
473:16 - actually deploying anything to
make that myself or work with a
473:18 - private key with real funds. I
do not need to be concerned.
473:21 - Take a look at this. Read this
internalize it, it should make
473:24 - you confident. Now again, I'm
not saying this to scare you.
473:27 - I'm saying this to instill
confidence in you that these are
473:30 - some of the things that we want
to think about. Okay, great. In
473:33 - here, I will be safe.
473:37 - Boom, I will be safe. And if you
want to copy paste this on
473:41 - Twitter, put this in a huge
tweet thread. Go for it. The
473:44 - more people who know about this,
the more people who understand
473:48 - the security risks of their WMV
files and their private keys,
473:51 - the better. So thank you for
listening to this. I know I
473:54 - definitely belabor the point,
but it is really important.
473:57 - Let's continue with the course.
Alright, so we're just about
474:02 - done here. However, there's one
or two more things we want to do
474:05 - just to clean this all up right
now when we're auto saving
474:07 - reason, the VS code plugin for
us to auto format. However, in
474:11 - the future, if anybody else
comes across our repository,
474:14 - they might not have the Vyas
code auto format or on. So we
474:18 - want to give users a way to
format their code. So it matches
474:21 - the styles that we use. So we
have prettier the extension
474:25 - installed. We can also add
prettier as a Node js module
474:31 - that can tell other users who
don't have a Vyas code exactly
474:35 - how to format both their
JavaScript and the solidity.
474:38 - There is a prettier plugin
solidity located here, there
474:41 - will be a link to it in our
GitHub repo. And if we scroll
474:44 - down, we can see how to install
with npm install dash dash save
474:47 - Dev, which again, we're just
going to use yarn, so we're
474:50 - going to do yarn, add prettier,
and then prettier plugin
474:58 - solidity. So we're installing
both prettier, and the solidity
475:03 - plugin for prettier. And if we
check our package, JSON, we can
475:07 - see that these two have been
added. And what we can do now is
475:09 - we can create a new file called
dot prettier, R C. And in this
475:17 - file, we can define some little
curly braces. And here, we can
475:22 - define what we want for both our
solidity and for a JavaScript,
475:26 - so for example, our simple
storage has a tab width of
475:30 - 412344 spaces. Maybe we want to
change that. We want tab width
475:38 - to be two. So we would save it
here and come back to simple
475:41 - storage To save it here, and it
would get auto formatted to r
475:45 - dot prettier RC. So in our
settings here, we have the
475:51 - default editor for solidity, our
hard hat, solidity plugin, and
475:55 - the default for meta for
JavaScript being the prettier
475:57 - vs. Code one, when we add
prettier RC in here, this file
476:01 - will take precedent over the
default configuration, so long
476:05 - as we have downloaded the module
in our node modules, which we
476:09 - can see it right here. And we
have this dot prettier rc file.
476:14 - I'm going to keep the tab with
form. So we're going to update
476:17 - it to that one thing that we
currently do have that I do not
476:20 - like is these semicolons at the
end, so we're going to do semi
476:27 - boss, and I'm going to save
this, come back to deploy it
476:31 - save and you'll see the
semicolon automatically goes
476:34 - away. I'm also going to add use
tabs false, since I want to use
476:38 - spaces or spacing, and then
single quote, false. This way,
476:43 - we'll always use a double quote,
instead of a single quote, in
476:46 - JavaScript, you can actually use
the single quote or double
476:49 - quote, to define strings, but
we're going to make it so that
476:52 - no matter what quote you use,
it'll always be double quote.
476:55 - And then for all your open
source repos, and for all your
476:58 - projects that you make, you want
to make a readme.md readme files
477:02 - are generally where people put
instructions or information
477:05 - about your project or anything
like that. This way, whenever
477:08 - anybody comes across your
project, they'll know what it's
477:11 - about your readme dot MDs, our
Markdown syntax again, remember
477:15 - how when we made that trial
discussion, we use some
477:19 - interesting tips to format our
solidity in our code here. Well,
477:23 - that formatting process is the
exact same for.md files for
477:27 - markdown. They're both going to
use markdown. In fact, if we hit
477:31 - Ctrl, Shift V, you'll enter
preview mode for the markdown
477:35 - you'll see pound sign here in my
preview of the hard hat. This
477:38 - ethers simple storage FCC is
huge. And it looks like a
477:42 - heading at the top. So Command
Shift V to view your.md files or
477:47 - or MIP Ctrl, Shift V for Windows
and Linux users.
477:53 - The last thing that we're going
to do is we're going to deploy
477:56 - this to a test net and interact
with this on a test net, we're
478:00 - going to use the Rinkeby test
net. But be sure to use whatever
478:03 - recommended test net the GitHub
repository for this coerce
478:07 - recommends. Now looking at our
code, you might already have a
478:10 - good idea of how to actually
make this slight change. Based
478:15 - off of our last section, we know
that all we need is an RPC URL
478:18 - and a private key and we can
begin making transactions on a
478:21 - blockchain. So we're probably
going to need a rink B RPC URL,
478:26 - and a rinky private key. Where
can we find both of those, if
478:29 - you want to do everything on
your own, and in full
478:32 - decentralized context, we could
run a rink B version of geth, we
478:37 - could run it locally, and then
just connect to our guest node,
478:39 - we're not going to be showing
how to do this here. However,
478:42 - this is 100%, something that you
could do. Instead, we're gonna
478:45 - use a third party RPC URL in the
GitHub repo associated with this
478:49 - course. Go to Lesson five, we
can scroll down to get a link
478:55 - for alchemy. Alchemy has a node
as a service and allows us to
478:59 - connect to any blockchain that
they have support for two
479:02 - alternates might be quick node,
Morales, or infura. These all
479:06 - have node as a service options.
But we're going to work with
479:09 - Alchemy, because it's the one
that I liked the best, we can go
479:11 - ahead and get started for free
or login or create a new
479:14 - account, I'm going to go ahead
and sign up with our hard hat
479:18 - Free Code Camp user. And we're
going to select the Ethereum
479:22 - blockchain ecosystem. Let's go
ahead and create our first app.
479:25 - This is going to be we'll call
it Free Code Camp. RT hat. Our
479:29 - app name will be ethers, simple
storage, FCC, and the network is
479:36 - where we're going to choose rink
B. But you can see in here, we
479:40 - can actually choose more than
just rink B, we can choose
479:43 - really Kovan, rink B, ropsten.
And layer twos like arbitrage
479:48 - and optimism, we're going to be
using rink B. So let's go ahead
479:51 - and create this app. We're going
to choose the free plan and hit
479:55 - Continue. We're going to skip
adding payments. If you want to
479:59 - tweet your referral code, feel
free to tweet your referral
480:02 - code. We're going to skip for
now. And we're going to keep it
480:05 - at capped capacity. Since we
don't have a we don't have a key
480:08 - in here. And then how did you
hear about us go ahead and give
480:11 - me that shout out at Patrick and
Free Code Camp and then hit
480:13 - Let's go. Now we get to the
alchemy dashboard, where we can
480:16 - see a ton of information about
our node and different ways to
480:20 - connect to the nodes and and
stuff like that. This is going
480:23 - to be really similar to to this
RPC server endpoint of ganache,
480:29 - except it's going to be a
connection, except it's going to
480:31 - be a connection to a real test
net or real main net. What we
480:34 - can do now is we can select our
our app that we just made. And
480:39 - we can hit View key. And we can
see here we get an API key Key,
480:43 - we add an HTTP endpoint and we
also get a WebSocket. We're only
480:46 - concerned with the HTTP
endpoint. This is going to be
480:50 - our RPC URL that connects to
rink B. So what we can do now is
480:54 - we can copy this and come over
to our Visual Studio code. And
480:58 - in our dot env, we can
substitute these out for their
481:02 - actual tests and values. So for
RPC URL, we're going to delete
481:06 - this and replace it with our
Rigby RPC row. And now how do we
481:10 - get a private key for an actual
test set that has actual rank be
481:14 - on it? Well, here is where we
can use our meta masks. So back
481:18 - in your browser, go over to your
meta mask, select the three
481:21 - dots, go to Account Details,
export private key. And this is
481:27 - where you can export your
private key, type in your
481:31 - password and boom, you now have
your private key for your
481:34 - account on meta mask. Now
remember, please, please, please
481:38 - don't continue with a meta mask
that has actual money in it. A
481:43 - quick way to check is by going
to your networks tab and seeing
481:46 - if on any of the main nets or
the networks with actual money
481:50 - in it, you see any money, I
don't have any money in this. So
481:53 - I know I'm good to go. If you
have tests that money, that's
481:55 - fine, because that's fake money
anyways. And again, most
481:58 - browsers have a profile
mechanism where you can create a
482:01 - new profile for you to use. But
here now that I've copied my
482:05 - private key, we can come back to
our Visual Studio code, paste
482:08 - the key in here. And now I have
a private key that has actual
482:12 - rink be in it. Awesome. And
remember, if you ever get low,
482:16 - just come over to faucets dot
chain dot link slash Rigby get
482:20 - some tests eath I'm not a robot
will send the request. Now that
482:25 - we have our private key in our
rink being here, we can now try
482:29 - to run this on an actual test.
Net, we look at our code, we see
482:33 - we're grabbing an RPC URL, which
is going to be from r dot end,
482:37 - we're grabbing a private key
which is going to be from our
482:38 - daughter Yun V, which points to
our rink D Metamask. And our
482:42 - rink B blockchain. So let's just
add a console dot log under our
482:47 - contract deployment so that we
know what address it's at. So
482:50 - we'll do console dot log, we'll
do some string interpolation,
482:55 - contract, address,
482:59 - contract dot address. All right,
great. Now let's go ahead and
483:04 - run this. So we'll do node
deploy dot J. S deploying Please
483:09 - wait, you'll notice this takes a
lot longer. Because we're
483:12 - deploying to a test net instead
of our own fake local
483:15 - blockchain, test nets and real
networks often will take a
483:19 - little bit longer because they
need to wait for the blocks to
483:21 - propagate the transaction to go
through, etc. But after a brief
483:25 - delay, we will indeed see that
we get a contract address here.
483:29 - And we have a current favorite
number. And it's being a little
483:31 - slow again, because we're
waiting for our next transaction
483:34 - to go through to update the
number and boom, looks like
483:37 - we've successfully updated it.
Now something that's important
483:40 - to know if ever you run command,
and you want to kill it, you can
483:45 - do Ctrl C, and that will stop
it. So any command in the
483:49 - terminal that you want to just
abort Ctrl. C is your Get Out of
483:54 - Jail Free card and that will
kill it. That'll stop it
483:56 - wherever it is. So we'll use
Ctrl C a lot in the future. So
484:00 - now let's grab this contract
address and go over to Frank V
484:04 - ether scan and paste it in, we
can see our two transactions
484:12 - here, we can see we have a
contract creation. And we can
484:15 - also see we call a store
function. This is awesome. We've
484:19 - successfully deployed a contract
to the wrinkly chain using our
484:24 - own code. Congratulations, this
is massive. Now on ether scan,
484:31 - we actually can verify and
publish our contract code. What
484:34 - is verifying and publishing your
code? Well, right now, our code
484:39 - looks like a huge gerbil of
bytecode. And anybody looking at
484:42 - our contract directly on chain
will just see this huge jumble
484:45 - of bytecode, we can use a
decompiler to try to decompile
484:49 - the bytecode into what it looks
like in solidity. But this can
484:51 - often take a long time and, and
a lot of processing power. So
484:55 - instead, we can just make it
much easier by verifying and
484:58 - publishing the code ourself, you
go ahead and hit verify and
485:02 - publish. We can scroll down and
we can add compiler information
485:06 - to compile this on ether scan
and other block explorers. This
485:09 - is a single file compiler
version is zero point 8.7. And
485:14 - it's open source is licensed is
MIT. Let's go ahead and
485:17 - continue. And we're going to
copy paste our solidity code
485:22 - into this large section. Paste.
We don't have any constructor
485:26 - arguments so we can skip this
section. We don't have any
485:30 - libraries or any other
miscellaneous settings. So we'll
485:33 - select I'm not a robot and we'll
hit verify and publish. You
485:38 - might have to wait a few
minutes, but awesome. Our
485:41 - contract was successfully
compiled. Now if we go back to
485:45 - contract source code, we can see
all the code in here. And if we
485:50 - grab our contract address, place
it into place into the search
485:54 - now, and we go to contract, we
get a little green checkmark.
485:58 - And we can see, anybody can now
read our source code.
486:02 - Additionally, those buttons that
we saw and remix for reading
486:05 - from our contract, and writing
to our contract, are in this
486:08 - read contract and this write
contract. If we read the
486:11 - contract, and we retrieve the
most recent number, we do indeed
486:15 - see that we have seven here
because we recently stored
486:17 - seven. Awesome, quick note, this
might already be verified for
486:21 - you, since ether scan might get
smart enough to notice that a
486:24 - lot of people are deploying the
same bytecode it's already
486:27 - verified for you just go ahead
and walk through these steps
486:29 - anyways. Now the code
verification we just did was
486:32 - pretty simple and
straightforward, because our
486:34 - code was pretty simple and
straightforward. Using larger
486:37 - and more complex code can make
the verification process a
486:41 - little bit harder. Additionally,
we don't always want to have to
486:44 - click buttons on ether scan. To
verify our code, we want to do
486:47 - it programmatically. So in later
sections, we'll learn how to
486:50 - verify all of our code directly
through our code editor, you can
486:55 - imagine the process is this easy
for deploying to any EVM chain
486:59 - in our alchemy, we could easily
create a new app and change our
487:02 - network. And you could see how
easy it would be to just switch
487:05 - out this RPC URL and your
private key to work on a
487:08 - different chain. This process is
also the same for harmony
487:12 - Phantom, avalanche, etc. And if
we wanted to switch chains, we
487:16 - would just switch the RPC URL
and switch the private key, and
487:20 - everything else would stay
exactly the same. Now, Alchemy
487:26 - also shows us and can teach us a
lot about transactions and about
487:30 - things that are going on behind
the scenes, including a concept
487:33 - called the mempool. To help us
understand a little bit more
487:36 - about those transactions that we
just sent, and how to work with
487:39 - Alchemy. To see more about our
transactions, we have Albert
487:42 - from the alchemy team to give us
a little demonstration.
487:45 - Hello, Albert here from alchemy,
I'm that guy in tech on Twitter,
487:51 - feel free to follow if you want
to engage and ask any questions
487:53 - about this section of the video.
But super excited to join
487:56 - Patrick here to explain a little
bit of what goes on behind the
487:59 - scenes when you are using
alchemy to submit a transaction.
488:02 - And we have a ton of tools to
actually provide a window of
488:05 - visibility into what's going on
so that you can actually debug
488:09 - in case there are usage errors
on your website, or there are
488:13 - pending transactions that are
stuck. Whatever it is, we
488:16 - provide that window into the
data that you control. Remember
488:20 - that all the transactions that
you submit are recorded on the
488:22 - blockchain. They're not
controlled by alchemy, they're
488:24 - not controlled by any other
service provider. We are just a
488:27 - window, we're just the plumbing
the piping to be useful to you.
488:32 - So let me show you exactly what
that means. Right now I have a
488:35 - bunch of applications in my
dashboard. You can see here that
488:37 - there are different projects
that I've used over time. This
488:40 - one is the most recently active,
and it is the one that I have
488:43 - currently set up to connect to
my meta mask. So actually use a
488:46 - custom RPC provider here. And
let me make my face a little
488:49 - smaller. And you can see here,
I've misspelled Rinkeby. But
488:53 - this right now, my my network is
actually connected to the
488:56 - Rinkeby test network via
alchemy. So this is actually
489:00 - this application. So if I click
into here in the dashboard, you
489:02 - can see here, a bunch of really
interesting statistics, this is
489:05 - the first thing that you'll
probably use. If you're trying
489:08 - to understand more about your
application, you'll go here and
489:11 - you can see how many compute
units per second your
489:15 - application is currently using.
And this is kind of great for
489:18 - specifically alchemy usage,
understanding. But then this is
489:22 - also really useful to see like,
what's the median response time,
489:25 - and so 33 milliseconds is pretty
good. If that starts to
489:29 - increase, then you might want to
figure out, you know, what's
489:31 - going on here, success rate, it
has been kind of low. So that is
489:35 - a clue for me to click on this
tab to view recent invalid
489:39 - requests. And that I can
actually see oh, there's a bunch
489:42 - of
489:44 - failed transactions where the
transaction has already been
489:47 - sent or the nonce is too low, or
whatever it is, I can actually
489:51 - use this tab to debug. So that
success rate is pretty useful.
489:54 - Throughput that's been limited.
So if you are sending too many
489:58 - requests or your website is
getting spammed, you might start
490:00 - getting some requests blocked.
So that's what's useful to view
490:05 - their concurrent requests over
here, success rate in the past
490:09 - 24 hours versus the past one
hour, the total number of
490:12 - requests in the last 24 hours.
And this is different than
490:15 - compute units, because each
request can have a different
490:18 - level of computing cost. And
computing cost as measured by
490:22 - compute units. Total requests is
just the actual number of
490:26 - absolute requests. And then of
course, the number of invalid
490:29 - request. Cool. So one thing I do
want to show you that's
490:33 - interesting is when I do submit
a transaction, and I actually
490:36 - have one right here, I want to
send so let's transfer between
490:40 - my accounts, and I'm just gonna
send it to tiny amount of
490:43 - Rinkeby eath. But I'm going to
purposefully edit my gas fees to
490:47 - be super, super low so that the
node will actually not muck send
490:53 - the transaction to be mined, or
there are no miners that will
490:55 - actually pick it up. So you can
see here I've divided the the
490:58 - priority fee and the max fee by
a ton. So it's super low. And it
491:02 - might confirm that in the MME
Max UI, you'll see that the
491:05 - transaction has been pending for
a bit. And we'll go over to this
491:08 - mempool tab. This is another
really useful visualization. And
491:12 - what the mempool is, is a kind
of a holding ground, I like to
491:17 - think of it as the waiting room
of a restaurant, where if you're
491:20 - a transaction, and you're
waiting to get mined, the
491:23 - mempool is kind of like the
waiting room where you're
491:25 - waiting to get seated. So there
are different statuses for your
491:29 - each of your transactions, the
ones that you always want to see
491:32 - are the mines transactions,
because that says that your
491:35 - transaction is successful. And
it's now part of the blockchain.
491:38 - Now, the mempool, every node has
its own, you know, holding
491:42 - ground. So I can actually show
you this quick visualization.
491:44 - Remember, blockchains are run by
a network of nodes. And each
491:48 - node or each computer that's
running the theorem, software
491:51 - maintains a copy of the
blockchain. And as a developer,
491:55 - you have to use these nodes to
make requests to the blockchain.
491:58 - Now you can use alchemy, you can
use another RPC provider, you
492:01 - can spin up your own node if you
want to. But regardless, you
492:04 - need to use a node to
communicate with the chain. Now
492:07 - each node beyond having a copy
of the entire blockchain state,
492:11 - it also has a local memory of
transaction. And that's called
492:16 - mempool. So if there are pending
transactions that are waiting to
492:19 - be mined, you can consider them
as being in the mempool. Now
492:23 - that's what we're looking at
right here. If we click on the
492:25 - app that I am currently using
for my Metamask RPC, then you
492:29 - can see here that there are,
this is not the right one, this
492:34 - one is the right one for
wrinkling. For all the
492:37 - transactions here, you can see
some more drop in placed
492:39 - somewhere mind and there's one
that's pending, and this
492:42 - pending, one actually matches up
with the one that is pending,
492:45 - here, it's being sent to 0x, C,
BB. And if we click on this
492:49 - transaction hash, you get all
the information that you need to
492:52 - debug. So you can see here that
it's from my current address,
492:56 - 0x, five F, and then it's two
0x, C, BB. And here's the value
493:01 - that I'm trying to send. Here's
the gas fee that I've attached
493:05 - to this transaction. And you'll
notice that that is super low,
493:08 - even for the Rinkeby test
network. So knowing this, and
493:11 - seeing, wow, this transaction
has been pending for one minute
493:14 - and 46 seconds, it was sent at
this time, I should probably fix
493:18 - that. And so over here, you can
actually use the metamath RPC,
493:23 - meta meta mask API. And speeded
up. And then I'm just going to
493:27 - use the auto high speed up to
update the gas fees. And then if
493:31 - we go back to our dashboard back
to our application, you can see
493:36 - that there are some new recent
invalid requests. And this is
493:39 - because we've resubmitted a
transaction, and then in their
493:43 - recent requests we have, let's
refresh that real quick. You can
493:47 - see that we are sending a raw
transaction, this one's already
493:50 - known. And there's another one
before, but it that's resulting
493:54 - in a get transaction receipt
that is successful. And then if
493:57 - we go back to the mempool, you
can see boom, no more pending
494:00 - transactions only dropped and
replaced and mined. So this
494:04 - transaction nonce number five is
now successful, and you're on
494:07 - your way to developing and
maintaining the rest of your
494:10 - application. So yeah, thanks
hope that was useful. Let me
494:13 - know if you have any questions.
494:19 - Now, other than the TypeScript
portion, which I'll do at the
494:22 - end, you've successfully
completed this section. And wow,
494:26 - you've learned a ton. Let's do a
quick review of everything that
494:29 - we've learned. Well, first,
we've learned how to create new
494:32 - projects with Node js, we've
learned what the node keyword
494:35 - does and how we can use the node
keyword. To run JavaScript in
494:39 - our local development
environment, we learned that we
494:42 - can add different dependencies
of external packages into our
494:45 - local package using yarn or NPM.
And we can see those
494:49 - dependencies added in package
dot JSON, we know that they've
494:52 - been installed because they get
installed into the node modules
494:55 - folder, we can also create a
script section where we can
494:58 - minimize long commands that we
need to run into a single
495:01 - keyword, like compile for
example, we can just run yarn
495:04 - compile. To compile all of our
code, we learned the basic setup
495:08 - of our JavaScript scripts, we
import our packages at the top,
495:12 - we have some main executor
function at the bottom. And then
495:15 - we have our main function in the
middle, we use the async keyword
495:19 - so that our function can use
asynchronous programming, and we
495:23 - get access to the await keyword,
which basically means Hey, wait
495:27 - for this promise to finish doing
its thing. We're able to connect
495:31 - to any blockchain we want using
an RPC URL, and then we're able
495:35 - to connect our provider to a
wallet or a private key in
495:39 - ethers by doing something like
this. Speaking of So we've
495:42 - learned about the ethers
package, which is a tool that
495:45 - makes our life a lot easier to
interact with the blockchain in
495:48 - JavaScript, if we decide to,
we've also learned we can
495:51 - encrypt our private keys so that
even if our computers get
495:55 - hacked, our private keys aren't
lying around in plaintext. And
495:58 - we've learned how to run scripts
from our encrypted keys. We've
496:02 - learned how to get the ABI or
the application binary
496:05 - interface, and the binary of our
code to deploy to a blockchain,
496:08 - we've learned how to deploy our
contracts to a blockchain
496:11 - programmatically. And then we've
learned how to interact with our
496:14 - contracts programmatically as
well. Additionally, we've
496:16 - learned how to add a default
editor in our settings dot JSON
496:20 - of our VS code. But we've also
learned how to override those
496:24 - settings by adding prettier
using a dot prettier rc file
496:28 - this way, we can auto format our
code to make it look a lot nicer
496:31 - and much easier to read.
Finally, we learned how to
496:34 - deploy one of these contracts to
a real test net or a real
496:38 - network. And then we finally
learned the manual way to verify
496:42 - our contract source code. Like I
said, we're going to learn a lot
496:45 - of shortcuts. And a lot of ways
to make this all a little bit
496:47 - easier in coming sections. Oh,
you have done a phenomenally to
496:51 - reach this section, give
yourself a pat on the back, take
496:54 - a break, go for a lap, and feel
really proud about yourself that
496:57 - you made it this far, we've got
a lot more to go. But you have
497:00 - come a phenomenally long way.
Congratulations. Or take that
497:04 - five to 10 minute break and come
back when you're ready.
497:09 - Now the one thing left I want to
show you all is the TypeScript
497:12 - addition to this. However, if
you're not interested in the
497:15 - TypeScript edition, which you
don't have to be, then you're
497:17 - done, there's only a couple of
changes we need to make to make
497:20 - this TypeScript compatible.
First, of course, we're going to
497:23 - change our deploy.ts and encrypt
key, we're going to change our
497:28 - deploy and our encrypt key from
dot j s two.ts. And then we're
497:33 - also going to swap these
requires out for imports. So
497:37 - we're going to import ethers
from ethers, we're going to
497:43 - import star as Fs from Fs extra.
And then we're going to import
497:51 - dot TMP slash config. And then
we're just going to copy these,
497:55 - and we're gonna come over and
paste them into here, deleting
497:59 - or commenting out the requires,
okay, great. Now, if we try to
498:03 - run Node deploy.ts, we're going
to get cannot use input
498:07 - statement outside of a module.
In JavaScript, if we'd want to
498:11 - use an import statement outside
of a module, we'd come in here
498:14 - and do some like type module
like that. But in TypeScript, we
498:19 - actually don't even need that.
All we need to do is run this in
498:23 - TypeScript note. So to add
TypeScript, we're going to do
498:27 - yarn, add TypeScript. And we're
also going to add TS node. TS
498:32 - node is the TypeScript edition
of node. So now that we've added
498:36 - that we can try a TS node
deploy.ts. And we're still going
498:40 - to run into an error. And if you
scroll up, we're gonna get a
498:44 - couple errors here. We're gonna
say, could not find a
498:47 - declaration file for Module Fs
extra, we need to add the
498:51 - TypeScript version of them. So
we're gonna do yarn at types
498:56 - slash Fs extra. That, and if we
run it again, it still shouldn't
499:01 - work. But for a different
reason. Yes, we're gonna get
499:03 - something like this type.
Undefined is not assignable to
499:06 - type bytes. Like the reason we
get this is because process dot
499:10 - EMV private key in TypeScript
technically, is type string, or
499:15 - undefined. So we need to tell
Typescript and and the Wallet
499:20 - Objects. And the Encrypt
function is looking for a type
499:22 - string, not string or undefined.
So we just need to tell
499:26 - TypeScript that this will not be
undefined. So we can just put a
499:29 - bang here. And everywhere that
we use process, study and be,
499:33 - oops, I got to do that on
deploy, as well. Bang, looks
499:38 - good. Now that we've added
everything in here, we run TS
499:41 - node deploy.ts, we're gonna see
the exact same output as we saw
499:45 - with just using regular node.
And as long as our private key
499:48 - password is in our dot env file.
If we run TS node and crypt
499:52 - key.ts, we're gonna get the
exact same setup as before. And
499:56 - we're gonna get a new encrypted
key dot JSON. And that's all you
499:59 - need to do to make this
TypeScript compatible. And you
500:02 - should give yourself a huge
round of applause for getting
500:04 - this far and learning what's
going on underneath hardhat. The
500:08 - next tool that we're going to
learn and learning all about
500:11 - these transactions and how to
interact with these blockchains
500:14 - this is absolutely massive, so
huge. Congratulations.
500:19 - Alright, so now that we've
learned about ethers js and how
500:22 - to do some more raw JavaScript
coding, we're now going to move
500:26 - into hardhat. We saw with our
ether symbol storage that
500:29 - deploying a contract can take a
lot of code. And there's a
500:32 - number of things we didn't even
do in here. Like we didn't save
500:35 - where this contract was
deployed. So we'd have to go
500:38 - remember where it was deployed
every time. Instead of having it
500:41 - just added programmatically. We
didn't write any tests here, and
500:44 - we'd have to build our own
testing infrastructure. Maybe we
500:46 - want to make this a cross chain
application. And we want more
500:49 - than just one private key and
RPC URL, you can absolutely work
500:52 - with your smart contracts in
JavaScript purely through ethers
500:55 - and small scripts like this. But
we want a more robust framework
500:59 - for doing all this. And that's
where hard hat comes into play.
501:03 - Hardhead is easily one of the
most, if not the most popular
501:06 - smart contract development
framework out there. It's used
501:09 - by massive several billion
dollar protocols like Ave
501:13 - uniswap, sushi swap, and more.
In fact, I recently did a poll
501:16 - on Twitter. And even though a
lot of my content has been more
501:19 - brownie and Pythonic, Hardhead
was well and beyond the most
501:23 - popular framework, and Hardhead
has quickly become one of the
501:26 - most advanced frameworks out
there. Hardhead is a development
501:29 - environment, which allows for
JavaScript based development,
501:31 - kind of like what we saw with
ethers, it gives us even more
501:34 - tools to integrate our code with
common things that we want to
501:38 - do. It's incredibly extensible,
and it has really nice debugging
501:41 - features as well. And it's just
an overall fantastic tool. So
501:44 - let's go ahead and let's jump
in. If you want to follow along
501:47 - with the code, come over to the
GitHub repo and scroll down.
501:50 - Lesson Six heart had simple
storage, and all the code is
501:53 - located here. And a quick note
for the future ever, you want to
501:57 - just download all the code from
one of these repositories, the
501:59 - way you can do that is by doing
a git clone, what you do is you
502:03 - come to the folder that you want
to put this code in, and you run
502:06 - git clone. And then you grab the
URL that you want to clone,
502:10 - paste it in. Now, you can CD
into your new folder here that
502:16 - has everything downloaded
directly from GitHub, but only
502:20 - do that as a backup or to just
download the code yourself. But
502:23 - for now, just follow along with
me. Right, so let's do this.
502:26 - Let's create our next project
using hard hat. The project that
502:30 - we're going to be making is
called Hard Hat, simple storage
502:33 - dash FCC or Free Code Camp. This
is going to be us working again
502:37 - with that simple storage
contract. But in hard hat, we're
502:40 - going to show you a ton of the
fantastic tools that we can use
502:44 - to make our coding life way
easier. So I'm in a brand new VS
502:50 - code, and we're going to create
a new folder for us to run all
502:53 - this. Now what you can do to
create a brand new folder is you
502:56 - once again you can do MK dir,
hard hat, simple storage of CC.
503:04 - Now we can cd into hard hat
simple storage of CD, and type
503:08 - code, period. And this will open
up a new Visual Studio code
503:13 - inside of that folder. Now if we
open up our terminal, you'll see
503:18 - that we are indeed inside that
folder. Now if that doesn't work
503:22 - for you, you can still of course
to File, Open folder and select
503:26 - the folder you'd like to open.
And you'll be inside of that
503:29 - folder. Now that we have our
folder setup for working with
503:31 - hard hat, we can begin setting
up our environment to be
503:34 - incredibly professional using
the hard hat framework got a
503:37 - link to the hard hat
documentation inside our whole
503:41 - blockchain solidity course, yes,
the hard hat documentation is
503:44 - phenomenal. And I highly
recommend everybody have it up
503:47 - as they go through the section.
Because it's going to give you
503:49 - pretty much everything that you
need to know for working with
503:52 - hard hat, you can simply go
ahead over to tutorial and get
503:55 - started. If you want to pause
the video here and read through
503:58 - the tutorial, I recommend doing
so it'll give you a lot of
504:01 - information about how to work
with hardhat. And more about
504:04 - hardhat. However, we're just
going to jump right into setting
504:06 - up the environment. We've
already installed no Gs on
504:09 - Linux, or Mac OS. And those of
you who are using Windows, I set
504:14 - you up with WsL. So you can just
follow the Linux instructions.
504:19 - Now to create a new hard hat
project, you can actually just
504:21 - go ahead and run these steps
right here. Instead of NPM,
504:24 - we're going to be using yarn,
but if you want to use NPM, you
504:27 - can absolutely do so the hard
hat Doc's say run npm init dash
504:31 - dash, yes, we're just going to
run yarn in it, which is going
504:34 - to create a new project for us
in this folder. So let's give it
504:38 - a name, which if we want it set
to this hard hat symbol storage
504:42 - FF FCC, we just hit enter, we'll
give it a version. And when if
504:45 - we want it 1.0 point oh, we just
hit enter. We're going to skip
504:49 - the description for now just by
hitting enter. And we're just
504:52 - going to hit Enter for this as
well. And for this as well enter
504:55 - for this as well and for this as
well and over this as well. Just
504:59 - to keep those as blanks. And if
we look in package json, we now
505:03 - see we have a name Hardhead
symbol storage that FCC we have
505:06 - a version we have a main which
we're actually going to delete
505:09 - the main and then we have a
license as well. yarn in it just
505:12 - sets up this package json for
us. Now we're going to do yarn,
505:15 - add dash dash dash
505:17 - of our app. So far, we've just
been running yarn add, and then
505:25 - whatever our package name is.
But for most of what we're
505:27 - doing, we really want to do yarn
add dash dash Dev. The reasons
505:31 - for this is a little bit
nuanced. But we can see some of
505:34 - the information on this
StackOverflow question here. The
505:36 - main difference is that
dependencies are required to run
505:39 - your project. Whereas dev
dependencies are required only
505:43 - to develop. For the most part,
we're going to be doing just
505:45 - dash dash Dev, when we get to
the front end portion of this
505:48 - course, we'll be installing more
packages that we don't need just
505:51 - for development. Now in the same
directory where we install hard
505:53 - hat, you can run MPX hard hat.
So a quick note about MPX is
505:58 - that the yarn equivalent of NPM
is just yarn. So yarn goes NPM,
506:03 - the yarn equivalent of MPX is
also yarn. So pretty much
506:07 - anytime you see MPX, do
something, you can just replace
506:11 - that MPX with yarn, and it'll do
the exact same thing. If you
506:14 - want to run this with NPM or
MPX, you can absolutely do that
506:17 - as well. So for us, we're going
to run yarn hardhat. And we'll
506:21 - see we'll get prompted to
actually start creating a
506:23 - hardhat project, run yarn
hardhat. And we'll get this
506:27 - wonderfully cute prompt right
here and saying welcome to
506:30 - Hardhead. What do you want to
do, create a basic sample
506:32 - project, create an advanced
sample project can advance some
506:36 - project uses type script or
create an empty
506:38 - hardhat.config.js. For us, we're
just going to select create a
506:41 - basic sample project. And this
is going to give us all the
506:44 - boilerplate for a really simple
hardhat project. The hard hat
506:48 - project route is going to be
this folder that we're in right
506:50 - now. Do you want to add a Git
dot Git ignore? Yes, we
506:53 - absolutely do. Because we're
going to be using dot env files.
506:56 - Do you want to install this
sample projects dependencies
506:59 - with yarn at nomic labs hard hat
at a theory and waffle at Chai?
507:04 - We're going to go ahead and say
yes, and I'll explain what all
507:06 - these dependencies are in a bit.
Let's go ahead and say yes for
507:09 - now. And we're going to install
all these dependencies. Now, if
507:15 - we look in our package, JSON, we
can see we've added a number of
507:18 - dependencies like nomic labs,
Hardhead ethers, not MacLeods,
507:22 - Hardhead, waffle, Chai,
Aetherium, waffle, and ethers.
507:26 - Obviously, we're already
familiar with ethers, but the
507:28 - rest of these might be a little
new. We'll talk about those
507:30 - later. And great, we now have a
sample hardhat boilerplate
507:35 - project. Let's walk through what
we just installed here. The
507:38 - first thing we have is a
contracts folder, which comes
507:41 - pre populated with greeted
outsole is really minimalistic
507:44 - contract here. Next, you'll see
node modules, which of course is
507:48 - our installed JavaScript
dependencies. Something I want
507:50 - to know because it was really
confusing to me when I first
507:53 - started working with this is
some of these node modules start
507:56 - with an add sign, and then a lot
of them don't. What's the
507:58 - difference between those two,
these outside node modules are
508:01 - known as scoped packages, which
effectively allow NPM packages
508:05 - to be namespace or yarn
packages. This allows
508:08 - organizations to make it clear
what packages are official and
508:11 - which ones are not. For example,
if a package has a scope at
508:15 - Angular, you know, it's
published by the Angular core
508:17 - team. So it's the same thing
with this anything with AP ens
508:20 - domains we know is by the ens
domains team, anything with
508:23 - abnormal Labs is going to be by
the team that created hard hat.
508:27 - So that's why this at nomic
labs, hard hat ethers and at
508:30 - nomic labs, hard at Waffle has
this at sign, because we know
508:33 - it's published by the nomic labs
team, then we have a scripts
508:37 - section. This is going to be
where we're adding any and all
508:40 - of our scripts that we want to
write like deploying contracts,
508:43 - interacting with contracts, etc.
And then we have a test folder.
508:46 - We haven't started building any
tests yet. But tests are
508:49 - incredibly important for working
with smart contracts. And this
508:52 - sample test folder gives us a
minimalistic test for testing
508:56 - our smart contracts. We of
course have Git ignore, which of
508:59 - course comes pre populated with
some important things to ignore
509:02 - like Dotty and V. And also node
modules because node modules
509:06 - might get too huge push up to
GitHub. And one of the biggest
509:09 - changes here is it adds this
hard hat.config.js. This file
509:14 - even though it's minimalistic,
right now, you can think of as
509:17 - the entry point for all the
scripts that we write, it's the
509:20 - configuration file that
determines how the rest of our
509:22 - code is going to work and
interact with the blockchain.
509:25 - Then of course, we have package
dot JSON, we get started with a
509:28 - readme. Remember how the first
time we ran yarn hard hat, we
509:31 - were prompted with this Getting
Started piece. Now if we run
509:35 - yarn Hardhead, we're actually
going to get output of all the
509:38 - different options and commands
we can use
509:40 - with running hard hat. Now, if
you run into an issue where you
509:46 - run yarn, hard hat, and this
pops up, but you don't see a
509:50 - hard hat.config.js in your
folder, it likely means that
509:53 - there's a hard hat dot config
dot j s in a higher level
509:57 - folder, or there's a node
modules with hard hat in a
510:00 - higher level folder. So if that
happens, maybe CD down a
510:04 - directory and do a little LS and
look to see if you've got a hard
510:07 - hat.config.js or node modules in
earlier folder. And because I've
510:12 - actually seen a number of
engineers have a couple of
510:14 - different problems here. My
friend CAMI is going to explain
510:17 - A couple of different
troubleshooting tips you can
510:19 - take to try to avoid these
common errors.
510:21 - As a developer the most annoying
thing to deal with our
510:23 - environment set of issues. My
name is Camila Ramos. I'm a
510:26 - DevRel engineer at edge node
supporting the Graph Protocol.
510:30 - And I'm going to show you how to
solve two common problems that
510:32 - you might see when working on
this project. After installing
510:35 - hardhat. And running the command
and px hard hat in your new
510:38 - project folder, you're going to
expect to get back a menu of
510:40 - options like this, but sometimes
you're not going to get that
510:42 - back. And when you run into this
error, there is a solution for
510:46 - you. And it usually just means
that you have a config file
510:48 - somewhere that it shouldn't be,
and deleting it will get rid of
510:51 - that error. What you're going to
do in order to find this file
510:53 - that you need to delete is run
the command MPX hardhats space,
510:57 - hyphen, hyphen verbose. And this
is going to spit out where this
511:00 - file is if you have one, and
it's going to tell you exactly
511:03 - where it is so that you can
delete it. After you've deleted
511:05 - this config file, you should be
able to run MPX hardhat in your
511:08 - project folder and get back that
many that we were expecting.
511:12 - Another problem that is pretty
common. And I still run into all
511:15 - the time is forgetting to npm
install, whenever you're working
511:18 - with a repo that other people
have been working on on GitHub.
511:21 - So let's say you're pulling down
some code that you and some
511:24 - collaborators were working on
together, and then suddenly,
511:27 - it's not working for you, you
probably just need to npm
511:29 - install. So in your terminal, go
ahead and navigate to where this
511:32 - project is located and then run
the command npm install. If
511:36 - there are any new packages that
were installed in the time that
511:39 - you weren't working on the code,
those will get installed locally
511:41 - for you so that when you run the
code, it will be able to run
511:43 - successfully.
511:50 - What are some of the main things
we can do with hardhat in its
511:53 - raw state here, these are some
of the main tasks that we can
511:56 - run with hardhat different tasks
or just different commands, we
511:59 - can run with hardhat. For
example, we can do yarn hardhat
512:02 - counts, which will print out a
list of fake accounts we can use
512:07 - with Hardhead. Similar to the
list of fake accounts that we
512:10 - used with ganache, we can
compile our contracts by running
512:13 - yarn Hardhead compile. Very
similar to what we did with
512:19 - ethers Jas and soap Jas, you'll
see when we run compile, we get
512:23 - a cache, which is just going to
be a quick way to access
512:27 - solidity files, and we also get
an artifacts section. This
512:30 - artifacts folder contains all
the information about our
512:34 - compiled code we look in here
now we can, for example, look in
512:38 - the build info and see a ton of
information about our compiled
512:42 - contract. If you're looking
contracts, we can see more
512:45 - compiled information. And then
if we look in the hardhat, slash
512:49 - console.so, we can see more
compiled information. So all of
512:52 - our compliation information is
going to be in this artifacts
512:55 - folder. And whenever you want to
look to see what's going on on
512:59 - the lower level when you compile
this artifacts folder is what
513:03 - has everything. There are a
number of other hard hat tasks
513:05 - that we can run as well. But
we'll get to them as we go. So
513:11 - now that we have some of the
basics of hard head down, let's
513:14 - go ahead and try doing some of
the same things we did with
513:16 - ethers before but with hard hat.
So one of the first things we
513:20 - want to do is we want to write
and interact with our smart
513:23 - contracts. So let's go ahead and
rename greeter dot soul to
513:28 - simple storage dot soul, you can
click on the file and hit enter
513:33 - and should be able to rename it.
Otherwise, you can go ahead and
513:35 - right click, delete it, and then
create a new file and call it
513:39 - simple storage dot soul. We're
going to copy paste all of our
513:43 - code from our previous simple
storage that saw into this file,
513:47 - we can make sure that our simple
storage is compiling correctly
513:50 - by running yarn hardhat compile.
Whoa, it looks like we ran into
513:55 - an issue project cannot be
compiled. See reasons below the
513:59 - solidity pragma version of the
file. It doesn't match any of
514:01 - the configured compilers in your
config. Hmm, well, what's going
514:05 - on contracts slash symbol
storage that's Sol zero point
514:09 - 8.8. Ah, okay, let's go ahead
and fix them. So we can open up
514:13 - our hard hat dot config dot j s.
Now a quick note on opening
514:17 - files. If you're on Mac and you
hit Command P, you can actually
514:21 - start typing in the names of
files to get them to them
514:24 - quicker. Or if you're on Linux
or Windows, you can type Ctrl p,
514:29 - this will bring up and
interestingly if you type man P
514:32 - or ctrl p and then you hit the
greater than key. This will drop
514:36 - you into the command palette,
know command palette, command
514:39 - palette, search for files,
search for commands in our
514:43 - Hardhead dot config. Jas, I'm
gonna scroll down to module dot
514:46 - exports and change this to zero
point 8.8. So that the version
514:52 - that we're going to compile for
simple storage, it's gonna be
514:54 - the same version and that hard
hat is looking for. Let's run
514:58 - that same command by just
hitting up yarn Hardhead
515:00 - compile, and awesome we see
compiled one solidity file
515:03 - successfully. We should now see
this in artifacts. If we go to
515:07 - artifacts and contracts. We now
see two contracts in here,
515:10 - greater and simple storage and
we can see a ton of the
515:13 - information about simple storage
we can also see some more lower
515:16 - level in Information and build
info. Alright, so now that we
515:19 - have our simple storage contract
in here, the next thing we
515:22 - probably want to do is learn how
to deploy it. This is where
515:24 - we're going to write our deploy
script. Now, for this section,
515:28 - I'm going to be showing you how
to write a deploy script. But in
515:30 - the next section, we're going to
do it a little bit differently.
515:33 - But this is still going to teach
you how to write scripts and
515:35 - worked with scripts in heart
app. So we're going to come to
515:38 - our sample script dot j s, and
we're gonna go ahead and hit
515:41 - enter and renamed it to deploy
dot j s. And if you want to read
515:46 - all the comments in here, you
absolutely can, we're just gonna
515:48 - go ahead and delete them all. A
quick keyboard shortcut is if
515:52 - you hit Command A or Ctrl, a,
you'll highlight all the text in
515:56 - your file, and we're going to go
ahead and delete it all. So now
516:00 - we're just going to start from
scratch here. Now the setup for
516:02 - our deploy script in here is
going to look really similar to
516:04 - the setup of our deploy script.
From our previous section, we're
516:07 - going to do imports at the top,
we're going to have our async
516:10 - main function, and then we're
going to call the main function.
516:13 - So let's go ahead and define our
main function, we'll call it
516:16 - async. function main, like that,
and then we'll call our main
516:20 - function. And if you want to
just copy paste this from the
516:23 - last section, you absolutely
can. So we'll domain that then.
516:42 - Boom, just like that. And
because of these semicolons are
516:45 - going to drive me absolutely
insane. We're also going to add
516:48 - prettier, and our solidity
prettier plugins. So we'll do
516:52 - yarn, add dash dash Dev,
prettier and prettier, plug in
517:02 - solidity. Then we can go ahead
and create our dot prettier, rc
517:09 - file, we're going to add tab
with four, use tabs, false, semi
517:19 - false, and then single quote,
also false. Now we're going to
517:24 - be using this prettier rc file
setup a lot. So in future
517:28 - sections, if you want to just
copy paste it, you can
517:30 - absolutely do that as well.
We're also going to add a dot
517:33 - prettier, ignore, which tells
prettier not to format some
517:37 - files, which we want, we don't
want prettier to spend a ton of
517:40 - time formatting all of our
files, I'm just going to copy
517:42 - paste from the GitHub repo. So
feel free to copy paste from the
517:46 - GitHub repo as well, you'd find
all the code for this section,
517:49 - like I said, in the GitHub repo
associated with this course.
517:51 - Now, unlike in our last section,
where we had to grab our
517:54 - contract code a little bit more
manually, with hard hat, it's
517:58 - actually a number of different
ways to grab compiled contracts.
518:00 - The first way we're going to do
it, we're actually going to use
518:03 - ethers. And now this is where
one of the first confusing
518:06 - changes actually comes in.
Previously, we did const ethers
518:11 - equals require ethers. And that
was how we went ahead and worked
518:16 - with ethers. However, you'll
notice in our dev dependencies,
518:21 - we have this dependency called
Hard Hat ethers. Hard Hat ethers
518:24 - is a package that actually wraps
hard hat with its own built in
518:28 - ethers. This is really
advantageous because it allows
518:31 - hard hat to keep track of
different deployments at
518:33 - different scripts and all these
other things for us. So instead
518:36 - of importing ethers directly
from ethers, we're actually
518:39 - going to import ethers directly
from hard hat instead. This
518:43 - might seem a little confusing at
first, but just know if we want
518:46 - to work with ethers and heart
it, it's usually much better to
518:49 - pull it in from heart and you
can still do this and ethers
518:52 - will still work the same. But
hard hat won't necessarily know
518:56 - about different contract
factories in different pieces
518:58 - and, and you'll see that in
action in a second. Now that
519:00 - we're pulling in ethers, we can
actually immediately grab a
519:04 - contract factory using ethers.
We can say const simple storage
519:10 - factory equals await ethers dot
get contract. Factory simple
519:22 - storage. So in order to get a
simple storage, contract
519:26 - factory, we can just do await
ethers dot get contract factory.
519:29 - Now if we pulled right from
ethers, the package ethers
519:33 - doesn't know about this
contracts folder and ethers
519:35 - doesn't know we've already
compiled simple storage dot
519:38 - soul. And it's in our artifacts.
Hard Hat, on the other hand,
519:42 - does know about the contracts
folder and does know that it's
519:45 - already compiled, which is why
this simple storage factory
519:48 - grabbing work so well. Once we
have our factory here, we can do
519:51 - the same thing that we did in
our previous section and deploy
519:54 - the contract. So we'll do a
quick console dot log. Deploy
520:00 - flooring, contract done, and
then we'll do Kant's simple
520:06 - storage equals await simple
store edge factory dot deploy
520:17 - And boom, with that little bit
of code, we're already able to
520:20 - deploy our simple storage
contract, then to wait to make
520:25 - sure it gets deployed, we can do
await, simple storage, deployed.
520:30 - And that's it. Now let's see
what happens when we go ahead
520:33 - and run this deploy script. As
you know, in our last section,
520:37 - we had to put in a private key,
and we had to put an RPC URL.
520:40 - Right now, we don't have either
one of those defined. So what do
520:44 - you think should the script
actually work? Or do you think
520:46 - it'll break because we, we
didn't define what blockchain
520:49 - we're going to deploy you. We
also didn't find a private key.
520:52 - Well, let's go ahead and try
this out. We can run the script
520:56 - in our terminal by running yarn,
hard hat, run, scripts slash
521:04 - deploy dot j, s. And again, I'm
hitting tab here to do a little
521:07 - auto completion and see what
happens. Well, we got deploying
521:11 - contract, it says done, but
that's really it. So what really
521:15 - happened? Well, let's add one
more line in here.
521:18 - Let's do console dot log. We'll
do some string interpolation
521:24 - deployed, contract to. And then
we'll add simple storage. That
521:31 - address. Let's run this now. We
get deployed contract, and then
521:36 - we get deployed contract to, and
then we get a contract address.
521:40 - Hmm, what's going on here.
Hardhead has this fantastic tool
521:47 - built in called The Hard Hat
Network hard hat comes built in
521:51 - with Hard Hat Network, a local
Aetherium network node designed
521:54 - for development, akin to
ganache, that allows you to
521:58 - deploy your contracts and run
your tests and debug your code.
522:00 - Whenever we run a command in
hard hat, or a script and hard
522:04 - hat or a task and hard hat, we
by default deploy to this fake
522:08 - Hard Hat Network. This Hard Hat
Network is very similar to
522:11 - ganache, except for instead of
having this UI, it runs in the
522:15 - background for our scripts. In
fact, if we go to our hard
522:18 - hat.config.js, we can scroll
down to the bottom to this
522:22 - module that exports section and
add more information about our
522:26 - default networks. So right now,
if we don't have anything in
522:29 - this module that export, by
default, it adds this piece
522:32 - called default network hardhat.
So anytime we run a script,
522:39 - without specifying a network, it
automatically uses this fake
522:42 - Hard Hat Network. And this fake
Hard Hat Network comes
522:45 - automatically with an RPC URL
and a private key for you. So
522:49 - you don't even have to add one
in. This is one of the major
522:52 - advantages of working with
Hardhead. It just automatically
522:56 - gives you this fake blockchain.
And these fake private keys, if
522:59 - you want to be a little bit more
explicit. And I always recommend
523:02 - being more explicit, we can add
the default network in to the
523:06 - module that are experts. So now
our default network is
523:09 - explicitly stated as hard hat.
However, in any script, you run,
523:13 - you can choose whatever network
you want to work with. So if I
523:16 - want to explicitly say I want to
run our deploy script on our
523:20 - fake Hard Hat Network, I can do
yarn, hard hat, run scripts,
523:25 - deploy dot j s, dash dash
network, hard hat, this is us
523:31 - telling her that, hey, we want
to run this script on the Hard
523:34 - Hat Network. Hopefully, you
might be able to see where this
523:37 - is going. Having this network
flag makes it incredibly easy to
523:41 - switch across different chains,
different block chains,
523:44 - different private keys, etc. So
we have our default network set
523:48 - the hard hat here, we can add
other networks in here as well.
523:51 - The way we do that is we're
going to add a networks section.
523:56 - And we're going to define any of
the network sections that we
523:58 - want. And remember to put a
comment there so that your
524:01 - Visual Studio code doesn't get
mad at you. So recently, we
524:04 - worked with Rigby so let's go
ahead and add a Rinkeby network
524:08 - in here. So we're gonna say
another network is gonna be
524:12 - really cool. So I should just be
able to change the network flag
524:16 - to Rigby now, right? Well, not
quite. If you try to run that,
524:24 - you're gonna get invalid value
undefined for hardhat config
524:28 - networks. Rigby, that URL, it's
expecting you to tell it, hey,
524:32 - what the URL is, since this
isn't the hard hat network, we
524:35 - need to tell hard hat exactly
how we're going to connect to
524:38 - rink B. And this is where a lot
of what we learned before is
524:41 - going to come in handy, again,
exactly the same as what we did
524:44 - before. We're going to create a
new Dotty v file, and we're
524:48 - going to add our Rigby URL in
this dot env file. Just
524:52 - remember, dot env is an r dot
get ignore just in case. So in
524:56 - our Dotty env, we're going to
add that RPC URL from alcmi back
524:59 - in here before we just said RPC
URL. But since we might want to
525:04 - work across multiple networks,
it's usually good to specify
525:07 - exactly what network each URL
stands for. So we're gonna say
525:12 - Rynkeby RPC URL equals and then
paste that URL in here. Now, as
525:18 - you probably have guessed, we
can add our URL to our Rinkeby
525:22 - network here. for readability, I
usually like to add them as
525:25 - variables right above the module
that experts. So I'll say const
525:29 - Rynkeby. RPC URL equals process
dot E and V dot Rynkeby RPC URL.
525:40 - And once again, we're going to
be pulling that Rinckey RPC URL
525:44 - from our environment variable.
Of course, in order to pull that
525:47 - environment variable in, we're
going to need to use that dot
525:50 - env package again. So to add
that in, we're going to yarn add
525:54 - dash dash dev dot EMV. And at
the top of our Hardhead config,
526:00 - we're going to add require dot
EMV, and then do dot config to
526:08 - enable the config. Now this
means we should be able to pull
526:11 - our rink the RPC URL from our
dot env. Now that we have that
526:15 - in our Rinkeby network, we can
add URL Rinckey RPC URL.
526:21 - Awesome. So we have an RPC URL
for different network. But what
526:24 - else do we usually need? Well,
we usually need a private key to
526:27 - work with an actual network, or
that doesn't automatically give
526:30 - us a private key for rugby,
because Hardhead can't just give
526:33 - us test and the Etherium, we
need to have an actual account
526:36 - an actual test nets. Hardhead
doesn't control those. So we
526:40 - have to actually give it a real
URL and a real private key. So
526:43 - to add private keys, you
actually add something called
526:46 - accounts, you add a list of
accounts that you want to give
526:50 - to hard hat for us, we're only
going to add one, which is going
526:53 - to be our private key. And for
our private key, we're going to
526:55 - do the exact same thing. We're
gonna say const private key
526:59 - equals process dot e NV dot
private key. And since this
527:05 - private key is going to be a
real private key for a real test
527:09 - net, again, we are going to have
to grab this from our meta mask.
527:12 - So it will go to our meta mask,
three dots, account details,
527:15 - export private key, and we'll
add our password in here.
527:20 - And then in our dot env will add
private key equals and then add
527:25 - our private key. Now I know I've
said this 100 times, but please,
527:28 - please, please, for learning
this, do not use a real key that
527:33 - is connected to any real money
just in case, please use a new
527:37 - meta mask. I've know I've said
it a bunch. But some people go
527:40 - no, I'm going to be okay, I'll
be safe. Just to be super, super
527:43 - safe here, please use a brand
new meta mask. So now that we
527:47 - have a private key, we're going
to add it in here account
527:50 - private key. And now we have an
account here. One more thing I
527:53 - like to do is I like to give the
chain ID of the network, which
527:58 - for Rigby is going to be for
every single EVM base network as
528:02 - a new chain ID and EVM network
basically just means solidity
528:06 - works on it. This includes all
test nets, there's a good site
528:10 - called chainless.org, which may
or may not be going down at some
528:13 - point, it has a list of all
these different networks. For
528:16 - example, you can see on here a
theory main net has a chain ID
528:19 - of one byte and smart chain is
56, avalanches, 4311 for
528:24 - Phantom, opera 250, Polygon,
137, etc. Each one of these EVM
528:29 - compatible chains has their own
chain ID, rank V, the chain ID
528:33 - is for adding the chain ID is
helpful here for later on. And
528:38 - we'll get to that in the future.
But for now, just go ahead and
528:40 - make sure to add your chain IDs.
Okay, now that we have the RPC
528:43 - URL, we have the private key, we
can go ahead and test deploying
528:47 - this to an actual test net, and
actually did something incorrect
528:51 - here. And we're gonna get an
error here. And I want you to go
528:54 - ahead and try to figure out and
debug this error yourself.
528:58 - You're ready. Alright, let's do
it. We'll do yarn, hard hat, run
529:03 - scripts, deploy dot j s, dash
dash network Rinkeby. And we get
529:11 - this wonderfully weird error,
which we see we have deployed
529:16 - contract. So we know that in our
deploy script, we get to at
529:20 - least this line, but then we're
getting an error, I highly
529:23 - likely hear what's going on
saying cannot read properties
529:26 - have no reading send
transaction, if you want, you
529:30 - can absolutely go to this spot.
But it basically it looks like
529:33 - it's having a hard time
understanding what the private
529:36 - key or what the account of this
is. And what do you think I'm
529:40 - going to recommend we do? Well,
if it's not clear, after doing a
529:43 - little bit of triaging and
debugging, we're going to copy
529:46 - this air. And we're going to
come on over to Google and paste
529:49 - that right in. It looks like we
do get a question here from
529:54 - stackexchange Etherium. And it
looks like it's really similar
529:57 - to what we're doing. We scroll
down. They're running nearly the
530:01 - exact same script that we're
running, they're using MPX
530:04 - instead of yarn. They've got a
pretty minimalistic deploy file.
530:08 - Let's scroll down and see what
the answers have to say. I've
530:11 - seen this error where my private
key wasn't properly populated. I
530:14 - would also use an environment
variable I'm pretty sure Are
530:17 - environment variables good. But
we have a second one saying in
530:20 - your heart head, I can think
that Jas, it should be accounts
530:24 - instead of account, it works for
me, let's go back to our head
530:27 - config and see if that's what's
going on. Uh huh, we put account
530:32 - in this should be accounts. So
let's swap that over to
530:34 - accounts. We'll clear our
terminal. And we'll run this
530:37 - again. Uh huh. And now it's
reading a little bit longer,
530:41 - which is good. This means that
we're probably deploying this to
530:44 - rink B, which is what we want to
see. Awesome. And now we can see
530:47 - deployed contract to, and we
have a contract address here. So
530:51 - we'll grab this contract. And
we'll pop on over to bring the
530:54 - ether scan, that's numbering the
ether scan. And we'll go ahead
530:57 - and we'll paste this in.
Awesome. And we see our contract
531:00 - was created about 26 seconds
ago. Perfect. Now for this part,
531:04 - you don't have to deploy this to
rink be with me, if you follow
531:07 - along here. That's good enough.
So remember, the flying to test
531:10 - that's can take a long time. So
for this one, you don't have to
531:13 - deploy with me. Alright, great.
So we've deployed to rink be
531:19 - using hard hat. This is
fantastic. Now something that we
531:22 - notice, once again is oof, our
contract isn't verified? Do we
531:26 - have to go back through and do
this verify and publish and all
531:29 - that stuff again? Luckily for
us, we actually don't need to do
531:33 - that. So what can we do? Well,
back in our deploy script, we
531:36 - can add some code to
automatically verify right after
531:40 - we deploy. So let's go ahead and
do that. Right below our main
531:43 - function, we're gonna create a
new function called verify,
531:47 - we're gonna say async function,
verify. And we're gonna have
531:52 - this function get past some
arguments, we're gonna have to
531:55 - get past a contract, address,
and some arguments or the
532:00 - contract. Since our simple
storage doesn't have a
532:02 - constructor, the arguments for
simple storage are just gonna be
532:05 - blank. But in the future, when
we have contracts that do have
532:09 - constructors, the arguments are
going to be populated. And when
532:12 - we get there, you'll see what I
mean, we need at least the
532:15 - contract address, and we're
going to add some code in here
532:18 - to automatically verify our
contracts after they've been
532:20 - deployed. This auto verification
process works on block explorers
532:25 - like ether scan, it might not
work on block explorers like
532:28 - eath, pler, or other block
explorers. But if you want to
532:31 - verify on these other block
explorers, I'm sure they have an
532:33 - API to allow you to do that as
well. Now, ether scan in most
532:37 - other block explorers have a
section on their website called
532:41 - API documentation, or something
to do with API's. These are ways
532:45 - for us to programmatically
interact with ether scan, and do
532:48 - stuff with them. One of the main
things that we can do is we can
532:51 - actually verify our contracts
through this API. Ether scan
532:56 - even has a tutorial in here
called verifying contracts
532:59 - programmatically. And the link
to this will be in the GitHub
533:01 - repo, they have an API endpoint
that we can make some requests
533:04 - to to go ahead and verify our
contracts. Now, we could
533:08 - absolutely make the raw API
calls and follow the tutorial
533:11 - here. But there's actually an
easier way than even going
533:14 - through this tutorial here.
Hardhead is an extensible
533:17 - framework, meaning you can add
something called plugins to it.
533:21 - There's even an advanced section
in the documentation called
533:24 - Building plugins. If we scroll
down to the bottom, we can see
533:27 - some popular plugins that the
nomic labs team or the Hardhead
533:31 - team has created. And also a
number of community plugins as
533:34 - well. One of the most used
Hardhead plugins is going to be
533:36 - this hard hat ether scan plugin
that makes this verification
533:40 - process much, much easier.
Install it, you can just run npm
533:44 - install bash, just save dev at
nomic labs harden ether scan,
533:48 - and then add it to our hard hat
dot config. Since we're using
533:51 - yarn, we're just going to go
ahead and use yarn. So back in
533:54 - our code, we'll do yarn, add
dash dash Dev, at nomic, labs,
534:02 - slash hard hat slash hyphen,
ether scan. Now that we have
534:08 - this plugin, we can go to our
hard hat dot config, scroll to
534:12 - the top and add this plugin do
require at nomic labs slash hard
534:22 - hat, ether scan. Now that we
have this plugin, the hard hat
534:26 - documentation has some more
information about the usage, how
534:29 - to actually use this plugin, and
how to run different commands
534:33 - with it. In order for us to use
this verification, we actually
534:36 - need an API key from ether scan.
This is basically a password for
534:40 - allowing us to use the ether
scan API. So we're going to come
534:44 - to ether scan. And we're going
to go ahead and sign in. And
534:47 - actually we're going to click to
sign up and create an account.
534:51 - And we'll go ahead and create an
account. We'll go ahead and
534:54 - verify our registration by
clicking the verification link.
534:57 - And we'll click the Login. Now
that we're logged in. On the
535:00 - left hand side, we can scroll
down to API keys. And we can go
535:03 - ahead and create a new API key.
We call this H H hyphen sec,
535:09 - which stands for hardhat Free
Code Camp. Great, this new API
535:12 - key will copy this and we'll go
back to our code and we'll add
535:16 - this somewhere since the API
keys basically considered a
535:18 - password. Where do you think we
should add this? That's right in
535:21 - our dot env. So in our dot env,
we're going to add a new entry
535:25 - called ether scan API key. And
we're going to add that API key
535:31 - that we just got. Now that we
have our API key, back in our
535:34 - Hardhead, config, we're going to
create a new section in a module
535:38 - dot exports, tell hardhat that
we have this ether scan API key,
535:42 - or new section is going to be
called ether scan.
535:46 - And in here, we're gonna say API
key is going to be ether scan
535:50 - API key that we're going to
define up here the same way we
535:55 - define these other keys. So
we'll say const, ether scan API
535:59 - key equals process dot e NV dot
ether scan API key. And if
536:05 - something like this pops up, you
can generally just hit enter,
536:08 - and it will autocomplete it for
you, which is awesome. Great. So
536:12 - now we have an ether scan API
key back in the heart had
536:14 - documentation, it tells us by
adding this, we actually get a
536:18 - new task called verify. Let's
try that out. So open our
536:22 - terminal back up. And we'll do
yarn, RT hat. Let's see what
536:27 - pops up. Wow, we did get a new
verification here. When we run
536:32 - yarn hard hat harder, it
actually looks into our hard
536:35 - hat.config.js and checks for any
plugins. If there are new
536:38 - plugins there, it'll add them as
a new task that we can do. You
536:42 - can manually verify your
contract by doing yarn or MPX
536:46 - Harnett verify dash dash
network, the deployed contract
536:50 - address and any constructor
arguments yourself. But we want
536:53 - to be a little bit more
programmatic than this. So what
536:56 - we're going to do is we're going
to go back and create this
536:58 - verification function, it is
good to know how to do it via
537:01 - command line so that if you want
to verify something in the
537:03 - future, manually, you can, let's
build this verify function
537:07 - though. So we're going to take
the our contract address and
537:10 - some arguments. And for our
sake, we're going to do console
537:13 - dot log verifying contract that
that just so that we know we
537:18 - might have to wait for a little
bit. And in our code, we can
537:22 - actually run any task from hard
hat using a run package. So up
537:28 - at the top, we're actually going
to import run from hard hat as
537:32 - well run allows us to run any
hard hat task. So in our code
537:37 - here, we're going to do a wait
to run. And then we can do there
537:43 - it thought. Now part of that
allows you to add different
537:46 - parameters as well in this run.
And it's usually best that you
537:49 - go ahead and add them in here so
that we're really specific with
537:52 - what we're doing. If we do yarn
hardhat verify dash dash help,
537:58 - we can see what parameters we
can actually pass. Well, it
538:01 - looks like we can pass the
Verify parameter. So we'll do
538:04 - colon, verify. If you go to the
actual GitHub for the
538:08 - verification tasks, you can
actually see you can do more
538:11 - than just verify, you can do
verify, get minimum build,
538:14 - verify, get constructor
arguments, verify, verify, which
538:17 - is what we're going to be
working with, and a couple of
538:19 - other subtasks as well. The
second parameter that goes
538:23 - inside run is going to be a list
of actual parameters. This
538:26 - second parameter here is just
kind of the sub task, if you
538:28 - will, of our verify task. And
this is going to be an object
538:32 - that contains the actual
parameters. And this is where we
538:34 - pass in an address, which is
going to be our contract
538:40 - address, and then our construct
or arguments, which is going to
538:47 - be arcs. Now normally just this
right here should be enough for
538:52 - us to go ahead and use this
verify contract in our main
538:55 - function, but we're going to add
one additional thing to it.
538:58 - Because in practice, sometimes
there's some errors that can
539:00 - come up. One of the errors that
often comes up when running a
539:03 - wait is that the contract has
already been verified. And
539:05 - you'll actually likely run into
this, because ether scan will
539:08 - get smart enough by seeing
enough bytecode that is exactly
539:11 - simple storage that it will
start to just automatically
539:14 - verify any bytecode that looks
like simple storage. And then
539:17 - this await will throw an error,
which we want to avoid. So what
539:21 - we can do is we can add a try
catch onto this await. So
539:27 - outside of the way, we're going
to add a try. And we're going to
539:30 - add these little brackets that
wrap around our weight. And then
539:34 - we're going to put a catch. This
is known as a try, catch and
539:40 - solidity also has tried catches.
But basically, this e is going
539:44 - to be any error that this
section throws. So we're going
539:47 - to do is we're going to say if
this message is already
539:51 - verified, then we're just going
to continue. So we're gonna say
539:53 - if e.message.to lowercase, we're
going to make sure it's to
540:00 - lowercase that includes already
there. If five, then we're just
540:06 - going to console dot log already
verified
540:11 - like that. Otherwise, we're just
going to console dot log e. The
540:16 - reason we do This is because of
this errors, our verification
540:20 - function will break, and our
whole script will end. And we
540:23 - don't want our whole script to
end, we want our script to keep
540:25 - continuing if the verification
doesn't work, because it's not
540:28 - really a big deal. So I know
this might seem like a lot of
540:30 - code, feel free to copy and
paste it from the GitHub repo to
540:34 - just move along. But awesome. So
we now have a verify function
540:38 - using the Verify task in
hardhat. Let's go ahead and use
540:42 - this now in our main function,
right below our deploy, we'll do
540:45 - console dot log deployed
contract two, and then the
540:48 - contract address. But before we
call this main function, let's
540:51 - think for a quick second. What
happens when we deploy to our RT
540:57 - Hat Network? Well, remember, if
we deploy to our Hard Hat
541:01 - Network, will our contract need
to be verified I need to scan?
541:04 - Well, we know there's a we know
there's a rink ether scan, we
541:08 - know there's a COVID ether scan,
we know there's a main net easy
541:10 - scan. But is there a Hardhead
ether scan? No, of course not.
541:14 - Right? The hard at runtime
environment is a network local
541:18 - to our machine. So it doesn't
make sense for us to verify a
541:21 - hard hat network deployed
contract on ether scan. So we
541:24 - actually don't want to call this
verify function, when we're
541:28 - working with our local network.
This is where these chain IDs
541:31 - are going to come in quite
useful. What we can do is we can
541:34 - check to see if the network that
we're running on is a live
541:37 - network or it's a test net, or
it's a network that actually can
541:40 - be verified, we can actually get
network configuration
541:42 - information by importing a
network like this. And we can do
541:49 - something like console dot log
network dot config. Now, if I
541:56 - run yarn, art, hit run scripts
deploy.js. On our Hard Hat
542:01 - Network, since I'm not passing a
network flag, we get this
542:05 - massive output that looks like
this. Our network dot config
542:09 - contains a ton of information
about the current network that
542:12 - we're on, you'll see here that
the chain ID of the Hardhead
542:15 - network is actually 31337 gas
price, which gets set to auto
542:20 - block gas limit the current fork
of Aetherium that we're working
542:23 - with, and all these other pieces
here. This chain ID is really
542:27 - important. Because we can use
this chain ID to figure out
542:31 - which one is a test net, or
which one is a live network. And
542:33 - remember, running the script is
going to be the same as doing
542:36 - dash dash network, hard hat,
542:40 - you'll see our channel ID is
still 31337. Again, that's
542:44 - because the default network in
our heart had config, it's hard
542:47 - hat, which is the same as saying
every single time we run a
542:51 - script, we're secretly running
it with dash dash network hard
542:54 - hat. So now we only want to
verify on our test net. So what
542:57 - we can do is we can say if
network dot config, that chain
543:02 - ID equals equals equals four,
which is going to be rank B, ad.
543:08 - And a JavaScript equals equals
equals is nearly the same as
543:12 - equals equals, except no type
conversion is done, which just
543:15 - means in JavaScript, four equals
four, and four equals equals the
543:21 - string of four, but four, but if
you were to use four equals
543:26 - equals equals four, this is
false. This is true equals
543:30 - equals four equals equals would
be true, four equals equals to
543:34 - the string of four would also be
true, but four equals equals
543:38 - equals to the string of four is
going to be false. So you can
543:41 - kind of do whatever you want
here equals equals or equals
543:43 - equals equals. So we want to say
if the network dot config dot
543:46 - Trinity is four, so if we're on
Rinkeby, then we can go ahead
543:52 - and actually verify. But we also
want to make sure we only verify
543:57 - if our ether scan API key
exists. So we can also in here
544:01 - is site and this double
ampersand means and we can say
544:05 - process dot e NV dot ether scan
API key. This is some Boolean
544:12 - tricks that we're doing here,
basically, so our first
544:15 - conditional we're saying if
network dot config chinati
544:18 - equals equals equals four, this
section can be true or false,
544:22 - obviously, right? The chain ID
that we're running on can be the
544:25 - hardest network, which would
mean this doesn't equal four, or
544:28 - it would be Rinckey, which means
this does equal four. But
544:31 - there's no conditional on this
side. So how does this side
544:34 - work? In JavaScript, if an
object exists, and you try to
544:37 - cast it as a Boolean, it will be
converted to true. If it doesn't
544:41 - exist, it will be converted to
false. So in JavaScript,
544:44 - basically, if either scan API
key exists, if we have this in
544:49 - our data in VI, this will be
true. And if not, this will be
544:53 - false. So another way to read
this line here is saying if
544:57 - network dot config that Trinity
is for AKA, if we're on rink B,
545:01 - and our ether scan API key
exists, then do some stuff. And
545:07 - that's what we're going to do
here. So in here, we'd want to
545:09 - run verify, or verify function
and pass it the contract address
545:15 - which is going to be Simple
Storage dot address and the
545:20 - constructor arguments which we
know are going to be blank. And
545:23 - since our verify function is an
async function, and it deals
545:27 - with promises and stuff, we want
to add the await keyword here.
545:31 - Awesome. So we've added a way to
actually verify our contract.
545:34 - But we're not quite done. See on
ether scan and all these block
545:38 - explorers the instant we deploy
the contract and the instant we
545:42 - send the contract, ether scan
might not know about the
545:46 - transaction yet, it might take a
hot second for ether scan to be
545:50 - up to speed with where the
blockchain is. So it's usually
545:53 - best practice to wait for a few
blocks to be mined, until you
545:57 - actually run your verification
process. We've actually learned
546:00 - how to do this already with the
deploy transaction. So before we
546:04 - actually verify we run, we want
to run a weight, simple storage.
546:10 - Deploy transaction Wait, six. So
we will wait six blocks, and
546:19 - then we'll run our verification
process. Now, if you want to go
546:22 - and test this out right now, you
absolutely can. I'm going to
546:25 - keep going, though, because
again, testing all these on a
546:28 - test net takes a little bit of
extra time. So I'm going to
546:31 - finish the rest of our main
function, and then I'm going to
546:34 - run everything all together.
Okay, cool. So we've deployed
546:39 - our contract, we've
automatically programmatically
546:42 - verified our contract. What's
next? Well, what did we do last
546:46 - time, we started interacting
with the contract. So let's do
546:50 - const. Current Value equals
await simple storage dot
546:56 - retrieve. To get the current
value, simple storage, that's
547:01 - all. We have a retrieve
function, which returns the
547:05 - favorite number, so let's get
the current value. And we'll do
547:09 - console dot log, the current
value is and then some string
547:18 - interpolation, current value.
And then we'll go ahead and
547:23 - update the current value by
doing cons. Transaction response
547:31 - equals await simple storage,
that store will store the number
547:39 - seven, and then we'll await
transaction response dot Wait,
547:45 - we'll wait one block for that
transaction to go through. And
547:49 - we'll grab the updated value by
saying const updated value
547:54 - equals await simple storage
547:58 - dot retrieve. Then we'll do
console log. The added value is
548:11 - updated value. Awesome. And this
is going to be our whole script.
548:15 - So if I can zoom out for a
little bit, I know it will be a
548:17 - little bit small here, we've got
this huge main function, which
548:22 - does what? Well it deploys our
contract. If we're on a test
548:26 - net, it then verifies our
contract. And then it updates
548:29 - the value to seven. And we have
our verify function down here.
548:33 - And we have a section of our
code that calls our main
548:37 - function. Now for run this on
the hard hat network. What do
548:40 - you think will happen? Well,
let's try yarn, or net run
548:44 - scripts. Deploy dot j s.
Alright, awesome, we get exactly
548:48 - what we saw before we get
deploying contract deployed
548:52 - contract to current value is
zero, update value seven. And
548:56 - there's nothing in here about
verification. That's exactly
548:58 - what we want. Now, moment of
truth. Let's try this on
549:02 - Rinkeby. We'll do yarn, RT hat
run scripts, deploy dot j s,
549:08 - dash dash network Rinkeby. And
it's gonna go a lot slower,
549:16 - because obviously now we're
deploying to an actual test net,
549:19 - where the blocks actually need
to be mined. And we see we
549:21 - haven't deployed the contract.
Now that our contract is
549:24 - deployed. We know that we're
currently waiting six block
549:27 - confirmations for us to go ahead
and verify. And actually I
549:30 - should add console dot log,
waiting for block the x's so
549:37 - that we don't get campus weird.
Oh, wait, what are we doing now?
549:42 - That it looks like we ran into
this error, no such file or
549:45 - directory, it looks like our
code might not have compiled
549:48 - correctly here. So here's what
I'm gonna do. We're gonna go
549:51 - ahead and delete our artifacts
to trash. We're gonna delete our
549:55 - cache as well. And we're going
to try rerunning this whenever
549:58 - you run a script with the hard
drive command Hardhead will
550:01 - automatically recompile it for
you, especially if there's no
550:04 - artifacts folder. So we're going
to rerun this command and
550:08 - heartbeat, it's going to compile
first and we can see that it
550:11 - does exactly that. And then it's
going to go ahead and redeploy.
550:15 - Hopefully this time, it should
be able to find the contract
550:17 - that had just compiled looks
like this time after I deleted
550:26 - the artifacts folder, we
actually did indeed get some
550:29 - successful compilation. And we
can see here successfully
550:32 - submitted source code for
contract or verification on the
550:35 - block explore waiting for
verification results,
550:38 - successfully verified contracts
simple storage on ether scan,
550:41 - and even gives us a link that we
can go ahead and Command click
550:45 - or control click into. And we
can see the contract indeed
550:48 - being verified. This is awesome.
This is perfect. We've now got a
550:55 - successful deploy dot j s script
that can deploy, verify, and
551:00 - then interact with our code.
This is fantastic. This hard hat
551:04 - thing seems pretty cool. What
else can we do with hard hat
551:06 - like I showed you before. Hard
Hat comes with these tasks. And
551:11 - the number of tasks that
Hardhead can come with can be
551:13 - extended by us writing plugins,
we can actually write our own
551:17 - tasks in hardhat. And in our
Hardhead dot config, it can
551:21 - defaulted with this task
account, we can see task
551:24 - accounts, prints the list of
accounts, and just prints a list
551:28 - of accounts here actually go to
the heart had documentation to
551:31 - learn more about creating our
own tasks, one of the ways that
551:34 - you can define tasks is directly
in our heart head.config.js. But
551:39 - typically, what people do is
they have a new folder called
551:43 - tasks where they put all their
tasks. So for now, I'm gonna go
551:47 - ahead and delete this section
here. And we're going to create
551:49 - our own task. You'll notice that
now that we've deleted that
551:52 - section, if we run yarn RDAP, we
no longer see the accounts task
551:58 - in here, because we've just
deleted that task. So let's
552:01 - create our own new task. We'll
call this block number.js. And
552:08 - we'll use this to get the
current block number or whatever
552:10 - blockchain that we're working
with. So let's create this task.
552:14 - First, we need to import the
task function, we can get it by
552:17 - saying const task equals require
arhat slash config. The hard hat
552:24 - slash config has the task
function. To define a task, we
552:28 - can now just say task, give it a
name and a description, the name
552:33 - is going to be blocked number.
552:36 - And then the description is
going to be prints the current
552:40 - block number. Now that we have
this task, there's a couple of
552:45 - things we can actually do with
it, we can add different
552:48 - parameters to it by using the
dot add command, which allow us
552:51 - to pass parameters to the task.
And then we could also set
552:54 - actions which define what the
task should actually do for us,
552:58 - we're just going to do dot set
action. And define what we want
553:03 - this function to do. So we're
going to make this an async
553:07 - function, that's going to take
as an input, the task arguments,
553:11 - which are going to be blank for
us, and the HR E, which I'll
553:15 - define in a second. Now, let me
explain the syntax really
553:19 - quickly. This might look a
little bit weird, but this is
553:22 - what's known as a JavaScript
arrow function. In JavaScript,
553:26 - you can actually define
functions without even using the
553:29 - function keyword. For example,
if we go back to our deploy
553:32 - function, we have our async
function verify down here.
553:37 - However, another way we could
have defined this is is without
553:40 - using the function word at all,
and actually turning this whole
553:43 - thing into a variable, we could
have said instead, we could say
553:48 - const verify is going to be an
async function that takes
553:54 - contract addresses and
arguments. And here's the
554:00 - function definition. These two
lines are essentially
554:03 - equivalent. There's some slight
differences between between
554:07 - using the function keyword and
having your function be a
554:10 - variable. But for the purposes
of this course, they're
554:13 - basically the same. Which means
though, that this by itself is a
554:17 - function, just not assigned to a
variable. But essentially, the
554:21 - two of these do are exactly the
same. And that's the syntax that
554:24 - we're doing here. You can
imagine this sort of being like
554:27 - const block task equals async
function, which takes the params
554:35 - and then runs that arrow
function. Or you can think of it
554:39 - as async. Function, block task
parameters, and then the
554:45 - function definition, these are
all essentially the same. The
554:49 - major difference is that we're
never giving our function a
554:53 - name, we never give it this
block task variable. This is
554:56 - known as an anonymous function
in JavaScript, because it
554:59 - doesn't have a name. Now that we
have our function in here, we
555:02 - can now call some function to
get the block number. Well, how
555:06 - can we get the block number when
we run tasks, we automatically
555:10 - pass our anonymous functions,
the task arguments, which in
555:13 - this one, we don't have any, but
we also pass this HR II object.
555:18 - This HRV is the heart hat
runtime environment. Back in our
555:23 - deploy script, this is basically
the same as this require hard
555:27 - hat in here. So this HRV can
access a lot of the same, this
555:32 - HRV can access a lot of the same
packages that the hard hat
555:37 - package can. So we can do Hae
dot ethers, just like how you
555:41 - can import ethers from hard hat.
And in our ethers package,
555:45 - there's actually a number of
functions we can use like dot
555:47 - Pro, biter dot get block number.
Let's save this to a variable
555:54 - const blocked number equals, and
this is going to be a
555:59 - synchronous, so we're going to
want to add a weight here. And
556:02 - then let's do console dot log
block number. Or better yet,
556:07 - we'll string interpolate this
and say current block number
556:12 - like this. Now though, if I try
to run this task, you'll notice
556:17 - it doesn't show up in the heart
Atlas of tasks, let's do yarn.
556:22 - Art app. Hmm, I don't see block
number in here. Well, this is
556:26 - because we need to add it to our
config dot config will add
556:31 - require dot slash tasks slash
block number.
556:39 - And in order for us to import
it, and let's add a module that
556:43 - exports I'll explain what this
does a little bit later. But now
556:47 - that we've required it, if I run
yarn hard hat, and now see
556:50 - blocked over is one of the tasks
that I can use. Now for a run
556:54 - yarn, art hat block number, we
get current block number is
556:59 - zero. And this makes sense
because this is defaulting to
557:03 - our Hard Hat Network, which gets
reset every time we run it. But
557:08 - if I run yarn, hard hat block
number A dash dash network
557:11 - Rinkeby, what do you think I'm
gonna get? Again, a much larger
557:15 - number, current block number is
right here. Because this is the
557:19 - actual block number of Rigby
versus the block number of our
557:23 - heart ad network is going to be
zero because it gets reset every
557:27 - single time, we run one of these
scripts now scripts and tasks
557:31 - both can basically do the same
thing. They both can interact
557:35 - with contracts, they both can
deploy smart contracts, they can
557:38 - both pretty much do everything.
I prefer scripts just as a
557:41 - general rule of thumb, because I
don't always think adding a
557:45 - special thing from the command
line makes sense. So I prefer
557:48 - scripts, but you'll see a ton of
tasks and examples out there as
557:51 - well. I think tasks are really
nice for specific use cases. But
557:55 - for the most part, we're pretty
much going to use exclusively
557:58 - scripts, but it is good to know
what a task looks like and how
558:01 - to use it. I think tasks are
better for plugins and scripts
558:05 - are better for your own local
development environment. But if
558:08 - you want to do everything with
tasks, you absolutely can. As
558:14 - you're starting to see, this
config piece is pretty powerful.
558:18 - And we can use it to modify our
entire code base and our entire
558:21 - project to give our project more
functionality. What else can
558:25 - this do? Well, right now, as you
can see, every time we work with
558:28 - a hard hat network, every time
we run a script, we run that
558:31 - script, and then the Hard Hat
Network is deleted, right? We
558:34 - can't interact with our
contracts anymore. Well, there's
558:36 - actually a way for us to run a
hard hat network. Similar to how
558:40 - we ran a ganache network with a
user interface. What we can do
558:44 - in hard hat is run yarn, RT hat
node. And what this will do is
558:51 - it'll spin up a node on a local
network, exactly the same as
558:55 - ganache but in our terminal. So
you see here started HTTP and
559:00 - WebSocket. JSON RPC server at
this address. And just like
559:04 - nosh, it comes packed with all
these different accounts and
559:08 - private keys, which is awesome.
You'll notice though,
559:11 - interestingly enough that this
node that we're running isn't on
559:16 - the Hard Hat Network, well, we
can actually create a new
559:18 - terminal to try to interact with
this just by hitting this little
559:22 - plus button and creating a new
terminal. Again, I'm using bash,
559:26 - but based off of whatever your
operating system is, you can be
559:29 - using a different shell. And
here, let's go ahead and run
559:33 - yarn arhat run scripts, deploy
dot j s, and see what happens.
559:39 - Well, our typical setup happens,
we deploy a contract, we get a
559:42 - contract address, we update the
value. But if we look at our
559:46 - node, it doesn't look like any
transactions went through what
559:49 - we don't see any locking here.
So what's going on? Well, our
559:53 - Hard Hat Network is actually
different from this locally
559:58 - running network here. This
locally running network we often
560:02 - want to refer to as our local
host. So it's slightly different
560:05 - than the Hard Hat Network. It's
still using the hard hat runtime
560:08 - environment, but it's just not
this default Hard Hat Network.
560:11 - It's considered its own separate
network when we're running a
560:15 - node that it's going to live. of
past the duration of a script.
560:19 - So we can actually interact with
this by adding a new network to
560:23 - our hardhead.config.js, we'll
create a new network and call it
560:27 - local host.
560:30 - And exactly as we did up here,
we'll give it a URL accounts and
560:35 - a chain ID. So for URL, we can
get that URL right from our
560:40 - terminal, I'll put a running
yarn hard hat node. by copying
560:44 - that and pasting it in here, we
can then do a comma, we'll give
560:48 - it a chain ID of 31337. Because
even though it's considered a
560:55 - different network, it actually
has the same chain ID as hard
560:58 - hat. Interestingly enough, I
know I just said we were going
561:01 - to give it accounts, but we
actually don't need to give it
561:03 - accounts. Because when we run
with this localhost hard hat
561:07 - will automatically give us these
10 fake accounts for us. So you
561:11 - can kind of think of the
accounts here for this localhost
561:14 - as, as hard had already placing
them in thanks, hard hat. But
561:19 - now, if we go back to our bash
here, let's clear the terminal.
561:23 - Let's rerun the script. And
we'll do dash dash network local
561:28 - host. Now we should be pointing
to this node. And when I run
561:33 - this script, we should see some
logging output at the end of
561:38 - this node. So let's go ahead and
hit enter. Well, we see our
561:42 - normal stuff on our deploy
script, we flip back to our node
561:46 - Wow, we see a ton of logging
here. Similar to ganache, we can
561:50 - see a whole bunch of different
logs on what just happened, we
561:53 - can see a contract was deployed,
we can see the address the
561:56 - transaction hash from value,
gas, and the block number and
562:00 - everything. We can also see our
contract call calling the store
562:05 - function to update the value of
our favorite number. This is
562:09 - incredibly powerful for quickly
testing and working with things
562:13 - on a local JavaScript VM or hard
hat network to be able to see
562:17 - how your contracts will interact
on a real test net. And this is
562:20 - much quicker than working with a
real test net. Now additionally,
562:24 - same as what we said before, any
process that's running in the
562:27 - terminal, we can kill it with
Ctrl C. So if you want to stop
562:32 - your node and then restart it,
you can hit Ctrl. C, to stop it,
562:37 - and then just up and then rerun
that same command to re spin up
562:41 - your node Ctrl C stops it. And
then you can up to start again.
562:45 - Another way you can stop it, of
course, is if you hit the
562:47 - trashcan, which deletes the
whole terminal, we pulled a
562:50 - terminal back up, we can run it
again. And just remember, if you
562:55 - hit the X that actually doesn't
delete the terminal, that just
562:58 - hides it. So our hard hat node
right now is still running
563:02 - because I just hit it. So I pull
it back up, I can see that it is
563:04 - indeed still running. But if I
trashed candidate, and then it
563:07 - pulled the terminal back up, I
can see that it is no longer
563:09 - running. So running scripts is
great. But what if I don't want
563:15 - to have to code an entire script
to do some things? What if I
563:19 - want to just tinker around with
the blockchain? Well, hard hat
563:23 - comes packed with this thing
called the console. The console
563:26 - is a JavaScript environment. For
us to run JavaScript commands to
563:29 - interact with any blockchain, we
can jump to the console by
563:33 - running yarn, hardhat, console,
and then whatever network flag
563:38 - if we want to work on rink B,
main net polygon, avalanche,
563:41 - etc. That's just network local
host. And now we're dropped into
563:45 - a shell him in the shell, we can
do everything that we do in a
563:49 - deploy script. And we don't even
have to run these imports,
563:52 - because everything with hard hat
is automatically imported into
563:55 - our console. So for example,
let's say I wanted to get a
563:59 - simple storage contract factory.
Well, I could run exactly this
564:02 - line here. I could say const,
simple storage, factory equals
564:08 - await ethers dot get contract
factory, have simple storage.
564:16 - And now I can go ahead and even
deploy this. So I can even just
564:19 - copy this line, paste it. And if
we flip back to our node, we'll
564:25 - see that we just deployed a
nother simple storage. And now
564:28 - we can do things like await
simple storage dot retrieve. And
564:36 - I get the return value which is
going to be a big number with a
564:39 - value of zero. I can also make
transactions so I can do a
564:43 - weight, simple storage. That
store let's do 55 If I hit up
564:52 - twice, I can go back to the
simple storage dot retrieve.
564:55 - call that function and I can see
my big number has a value of 55.
564:59 - Now, this is a great way to
quickly interact with any
565:01 - blockchain that we want. Now you
can exit the shell by hitting
565:04 - Ctrl C twice to get out. Or you
can also just you can also Trash
565:09 - Can your terminal if you get
confused. This console works
565:12 - with any network we can even do
yarn, hard hat console dash dash
565:18 - network hard hat. And we'll get
dropped into a hard hat network.
565:23 - Now this is not going to be the
same node that's running here,
565:26 - this is going to be one that
only runs for the duration of
565:30 - this command. So whenever we
cancel this command, this hard
565:33 - hat network gets cancelled. And
close out that too. We can also
565:37 - do yarn, hard hat, console, dash
dash network Rinkeby Rigby, or
565:45 - polygon or test net or main net
or whatever we want. And we can
565:48 - do things like ethers dot
provider that can do things like
565:54 - await ethers dot provider dot
get block number, see the block
565:59 - number of Rigby. We can also
deploy contracts, we can update
566:03 - contracts, we can do anything
that we want, you can do
566:06 - anything in these consoles, and
they're great ways to quickly
566:08 - test and tinker in interact
566:10 - with contracts. Now, there's a
couple other tasks that are
566:16 - really helpful. You'll see
before I went ahead and just
566:19 - deleted artifacts and deleted
the cache manually. Well, to do
566:22 - that yourself, you can also just
run yarn Hardhead, clean. And
566:28 - that'll delete the artifacts
folder and clear out your cache.
566:31 - We already know what compiled
does. But one of the biggest
566:34 - things that Hardhead is
fantastic for especially is
566:37 - running tests. Now we haven't
run tests yet so far. However,
566:41 - running tests is absolutely
critical to your smart contract
566:45 - development journey. And we're
going to spend a lot of time in
566:48 - the future writing really good
tests. The reason that writing
566:51 - tests are so important is
because we want to make sure our
566:55 - code does exactly what we want
it to do, especially in the
566:59 - defy, and the decentralized,
smart contract world, all of our
567:03 - code is going to be open source
for anybody to interact with,
567:06 - and potentially exploit. There's
sites like req dot news, which
567:10 - go through a ton of previous
hacks and how they actually got
567:14 - hacked and what happened in the
smart contract to enable these
567:17 - hacks to occur. So testing, so
writing really strong tests is
567:21 - always going to be our first
line of defense. And we have
567:25 - this sample test.js, that comes
default with the basic package
567:28 - of hardhat. But as you probably
already know, we're going to
567:31 - rename this and change it. So
we're going to rename this to
567:34 - test deploy dot j s. And we're
going to delete everything in
567:39 - here and start from scratch. We
want to be able to test all of
567:43 - our solidity code locally, so
that we know exactly what it's
567:46 - doing. And we can have a
programmatic way to make sure
567:50 - that our code does what we want
it to do. So let's write a basic
567:54 - test for our simple storage
contract. So that we can be sure
567:58 - that it's doing exactly what we
want it to be doing. Hard Hat
568:02 - testing works with the Mocha
framework, which is a JavaScript
568:06 - based framework for running our
tests, you actually can write
568:09 - tests directly in solidity, if
you'd like to, there's a bit of
568:13 - back and forth on whether
testing with pure solidity is
568:16 - better or testing with a modern
programming language. The
568:19 - argument goes that testing with
a modern programming language,
568:22 - you have more flexibility to do
more stuff to interact and test
568:27 - your smart contracts. But the
argument for testing with us
568:29 - with solidity is that we want to
be as close to the code as
568:32 - possible. At the time of
recording, most projects do the
568:35 - vast majority of their testing
in a modern programming language
568:39 - like JavaScript. So that's what
we're going to be using here. So
568:42 - to get started with our mocha
tests, we do, we're going to
568:45 - write a describe function.
Describe is a keyword that
568:50 - hardheaded mocha will recognize,
and it takes two parameters, it
568:54 - takes a string, which we're
going to just write simple
568:58 - storage for now. And then also
takes a function, we could make
569:03 - function, test func and then
write some stuff in here, and
569:09 - then pass it to our describe
here. But the common convention
569:14 - is going to be to do is to make
it as an anonymous function,
569:18 - which we can create by typing
function, putting an empty
569:22 - parameter here, and then some
brackets like that. So our
569:25 - describe function takes a name,
a string, and a function.
569:29 - Another way that you'll often
see functions in describe is
569:32 - using that anonymous function
syntax. So you might see just
569:37 - these parentheses, an arrow, and
then some brackets, the two of
569:41 - these are going to be basically
the same, there are some
569:44 - differences. And this second one
is actually best practice, but
569:47 - just know that you might see
this arrow syntax in other tests
569:51 - as well. We have described a
sample storage and then our
569:54 - function here, which is going to
have all of our tests in it.
569:56 - Inside each one of our describe
blocks. We're gonna have
569:59 - something called a before each,
and a bunch of It's Our before
570:03 - each function is going to tell
us what to do before each of our
570:07 - hits. So we're going to have a
ton of it and then we're going
570:09 - to have a before each. All of
our IDs are going to be where we
570:13 - actually write the code for
running our tests. And before
570:15 - each is going to be some code
that tells us what to do before
570:19 - each one of these hits, we can
also actually have describes,
570:25 - inside of describes, which again
have more before each and more
570:29 - before it's having these nested
describes can be really helpful
570:33 - for separating and modularizing
our tests. But for this one,
570:37 - we're just going to have a setup
that looks like this. And for
570:41 - this demo, we're only going to
have one it. So in order to test
570:45 - our smart contracts, before we
actually run our tests, we're
570:47 - probably going to need to deploy
the smart contracts first. So
570:50 - inside of our before each, we're
going to pass the our before
570:53 - each a function, that's going to
tell our testing framework what
570:56 - to do before each test. So we're
going to pass it an async
571:00 - function like this. And in here,
we want to deploy our simple
571:05 - storage contract. So to do that,
we're going to need to get the
571:08 - ethers framework and do exactly
what we did in our deploy
571:12 - script. So in here, we're at the
top we're gonna say const.
571:16 - Ethers, equals require art have
an import ethers from hard hat.
571:23 - Then in our before each
function, we'll say await ethers
571:29 - dot get contract factory of
simple storage. And we'll assign
571:37 - this to a const. Simple Storage
factory. And then we'll run
571:46 - away, simple storage factory dot
deploy. Cool. And let's also
571:52 - assign this to a variable cost
simple. Now, since right now,
571:58 - our simple storage and simple
storage factory are scoped just
572:02 - to inside the before each, we
actually need to stick these
572:05 - variables outside of the before
each, so all of our events can
572:09 - interact with them. So instead
of having simple storage,
572:12 - factory, and simple storage, be
constant variables, we're going
572:16 - to define them outside of them
for each with the let keyword.
572:20 - And we're gonna say let simple
storage factory and we're going
572:25 - to initialize it to nothing. And
then we'll say led simple
572:29 - storage. Now, if you have a
whole bunch of let's just
572:32 - initializing another way, you
can write them in JavaScript,
572:35 - just let simple storage factory
comma, simple storage. And that
572:41 - works exactly the same. And then
we can get rid of this const
572:43 - keyword. Because it's not a
constant since we are assigning
572:47 - it. And now we have simple
storage, factory and simple
572:50 - storage that we can use inside
of our init function. Now we
572:53 - have a before each section. So
before each one of our tests,
572:56 - we're going to deploy our simple
storage contract. So we have a
572:58 - brand new contract to interact
with for each one of our tests.
573:02 - Now, inside of the ID, this is
where we're going to say what we
573:05 - want this specific test to do,
and then describe the code
573:09 - that's going to actually do
that. So we're going to say it
573:13 - should start with a favorite
number of zero. So this is
573:20 - saying what this test should do.
And then we're going to add our
573:24 - async function to actually do
that. So we'll say async
573:28 - function. And in here, this is
where we'll actually write the
573:34 - code to make sure that our
contract does exactly this.
573:38 - We're say const. Current Value,
equals await, simple storage.re
573:46 - retrieve. And now in this test,
we want to say okay, now check
573:50 - to see that this current value
is indeed zero. So how do we do
573:54 - that? Well, we can say const,
expected value is going to equal
573:59 - zero. And what we can do is we
can do either we can use either
574:04 - the assert keyword, or the
expect keyword, which we're
574:08 - going to import both of these
from a package called Chai. We
574:12 - actually installed Chai
automatically when we downloaded
574:16 - the basic parameters when we
downloaded the basic packages
574:19 - for hardhats. So at the top,
we're gonna say const. Expect
574:23 - and assert
574:25 - equals require Chai, I'm a big
fan of using assert as much as
574:30 - possible, because I think the
syntax makes a little bit more
574:33 - sense. But there will be
scenarios where we need to use
574:36 - expect instead. Now, assert has
a ton of functions that are
574:39 - built in that help us make sure
this is what we expect it to be.
574:43 - So I can do assert dot equal
current value.to string, because
574:48 - remember, this is actually going
to be a big number, comma,
574:51 - expected value. So I'm saying
I'm asserting this retrieve to
574:55 - return zero, which is going to
be our expected value. Now to
574:59 - actually run this, we're going
to run yarn, art hat test. And
575:04 - we see we get an output that
looks like this should start
575:07 - with favorite number of zero,
and it's indeed passing. You'll
575:10 - notice that if I were to change
this to one, and this wasn't
575:14 - correct, it would break and it
would say art Pass or not
575:18 - passing assertion error expected
zero to equal one. It expected
575:23 - zero to equal one, which is not
what we want. We want zero to
575:29 - equal zero. So let's run this
again. Tada should start with
575:33 - favorite number zero, and it's
passing. Alright, fantastic. So
575:36 - that's how we wrote one of our
tests, let's write one more test
575:40 - just to make sure that things
are good. So let's say it should
575:43 - update when we call store,
because when we call the store
575:48 - function, we want our favorite
number to update. And we'll make
575:51 - this an async function as well.
And let's add our stuff in here.
575:56 - So we'll say const. Expected
Value equals seven, we're
576:01 - expecting that when we call
store it updates to seven. Now
576:05 - we can say const. Transaction
response equals await simple
576:11 - storage dot store. And we can
even just pass it the expected
576:16 - value here. And then we'll do a
weight transaction response that
576:21 - weight one. Now let's get the
current value. So we'll say
576:25 - const. Current Value equals
weight, simple storage,
576:32 - retrieve. And now we're going to
assert dot equal current
576:37 - value.to string, comma expected
value. And now we can run all
576:44 - these tests by running yarn
Hardhead test. And you'll see we
576:47 - ran both of these tests. And now
if I have 10,000 tests, and I'm
576:51 - only finagling with one test, I
can actually just run one test
576:55 - by running yarn, art app, test,
dash dash grep. And I can search
577:01 - for any keywords in any of the
text here. So I'm going to grep
577:06 - for the store function. Because
the store keyword isn't in this
577:10 - tax for this, it, it's only in
the text for this it. So if I do
577:14 - grep store, it should only run
our second test, which does
577:18 - indeed, one other way we can run
only specific tests is with the
577:22 - only keyword. So we can type it
dot only like that. And then we
577:28 - can run yarn, art hat test. And
it should only run, this should
577:33 - update when we call store. And
it does indeed, then we'll go
577:36 - ahead and delete this save, run
again, and it should run all
577:40 - too. Fantastic. Now the other
way you'll see these tests
577:45 - written is with instead of
assert, it'll use the expect
577:49 - keyword. So you'll see something
like expect current
577:52 - value.to string.to dot equal
expected value, the two of these
577:59 - lines do exactly the same thing.
And it's sort of up to you on
578:03 - which one you want to use. And
that's all we're going to do for
578:06 - our testing. Now. This is
fantastic, great job. Now that
578:12 - we have some tests, we can
actually start testing to see
578:15 - how much gas each one of our
functions actually costs. One of
578:19 - the most popular extensions for
hard hat is the hard hat gas
578:23 - reporter. This is an extension
that gets attached to all of our
578:27 - tests, and automatically gives
us an output that looks like
578:30 - this, that tells us
approximately how much gas each
578:32 - one of our functions cost. We
scroll down in here, we can read
578:36 - the instructions on how to
actually install this npm
578:38 - install Hardhead gas reporter
which we're going to use with
578:41 - yarn. So we're gonna say yarn,
add hard hat, gas reporter, dash
578:49 - dash Dev.
578:52 - And now that that package is
installed, we can go over to our
578:57 - config and add some parameters
in here so that we can work with
579:01 - this gas pit. But our neath our
ether scan section, we're going
579:04 - to add a new section called gas
reporter. To have it run,
579:09 - whenever we run our tests we're
going to do enabled is going to
579:12 - be true. And then up at the top,
we can add it by adding require
579:18 - hardhat gas reporter. Now that
we have it in here, we can do
579:23 - yarn hardhat test, and after we
run our tests, it'll
579:27 - automatically run this gas
reporter. So we see our tests go
579:32 - ahead and run. And then we get
this output that looks like this
579:35 - that tells us how approximately
how much our contracts and
579:39 - methods cost. So our store
function looks like It costs
579:42 - approximately this much gas and
our simple storage costs
579:45 - approximately this much gas.
This is incredibly helpful for
579:49 - figuring out how to optimize our
gas as best as possible. Now I
579:53 - usually like to take it a step
further though. Having the gas
579:56 - output it like that is nice, but
we can make it even better. I
580:00 - like to output it to a file by
doing output file. Yes, report
580:05 - dot txt and then my dot get
ignore like to add it in here,
580:10 - but doing gas report dot txt
sentence it's not really
580:15 - important for the gas report to
get pushed up to GitHub. Do no
580:18 - colors is true. The reason we
add this is because when we
580:22 - output to a file, the colors can
get messed up basically. And
580:26 - then the biggest addition we
could do is we can add a
580:29 - currency in here. So that we can
get the cost of each function in
580:34 - USD for a blockchain like
Aetherium. Now in order to get a
580:38 - currency here, we actually need
to get an API key from corn
580:43 - market cap, just like we did
with ether scan, you can go to
580:46 - coin market cap, corn market cap
API, get your API key now, and
580:52 - we'll go ahead and sign up.
Choose a basic plan. We'll agree
581:01 - and create my account, we'll get
an email verification. And we'll
581:05 - go ahead and verify. Now in the
coin market cap dashboard, we
581:10 - can copy our key. And yep, you
guessed it exactly what we're
581:14 - going to do with this key, we're
going to drop it into our dot
581:16 - env file, or say coin market
cap, API key equals and then
581:22 - paste it in there like that. Now
that we have our corn market cap
581:25 - API key in here, we can go back
to our header dot config and add
581:30 - it in this corn market cap
parameter. We're gonna do the
581:33 - exact same way we did above,
we'll do const, coin, market
581:38 - cap, API key equals process dot
EMV, that coin market cap API
581:46 - key, and then we'll take this
sticking in here. So what this
581:49 - is going to do is actually going
to make an API call to corn
581:52 - market cap, whenever we run our
gas reporter. This is why
581:56 - sometimes you'll see me comment
this out and uncomment it
581:59 - because I don't always want it
to make this API calls. But now
582:02 - what we can do now that it's
enabled, we have an output file,
582:05 - we can see the currency and we
have our API key, all we can do
582:08 - is run yarn hardhat test. And
after all our tests pass, we're
582:14 - going to see a gas report.tx T
that we can go ahead and read
582:18 - from which has that gas report.
And now it actually has the USD
582:23 - price of each one of these
transactions, it looks like at
582:26 - current prices, with Aetherium
being $3,000 per eath, and a gas
582:30 - price of 43 Gwei, the store
function would cost $6. And the
582:34 - simple storage function would
cost $64. The current the
582:38 - Hardhead gas reporter actually
comes with some different
582:40 - options, though, if you're going
to be deploying to different
582:42 - network, for example, with
binance, Polygon, Avalanche or
582:46 - hecho. For example, let's say we
wanted to deploy the polygon,
582:49 - let's see how much deploying the
polygon would cost well in our
582:53 - WMV UHD ad token,
582:57 - Matic And now we'd rerun this
test. And if we look at our gas
583:03 - report that takes T will now see
the gas price of polygon right
583:07 - now is around 37 Gray per gas.
And the cost of Matic is 147
583:12 - automatic and USD. Now we can
see the cost of calling the
583:15 - simple storage method is going
to be $0.00. Now this of course
583:20 - is rounded down, but it's going
to be really, really cheap to
583:23 - call store versus deploying the
contract is going to cost three
583:26 - cents, I make it a habit to
select false for my gas reporter
583:30 - whenever I don't want to
actually work with the gas here.
583:33 - Awesome. Now sometimes when
we're working with our code, if
583:36 - we don't have these environment
variables specified Hardhead
583:39 - might get a little bit upset
with us. So oftentimes, I'll add
583:43 - some code in here. So that these
variables are always populated,
583:47 - because we didn't specify our
rink prpc URL, ring P RPC URL is
583:52 - going to be undefined. And that
might throw some errors blow. So
583:56 - oftentimes, what we'll do is
I'll add an or parameter here,
583:59 - these double pipes mean or, and
in JavaScript, if we say some
584:03 - variable equals something or
something else, what is really
584:07 - happening is we're gonna say,
okay, rink, the RPC URL is going
584:10 - to be equal to process dot E and
V dot rink, the RPC URL. But if
584:15 - this rink, the RPC URL doesn't
exist, it's going to be whatever
584:18 - else is over here. And I might
write something like HTTPS eath
584:23 - Rinkeby. Example, or something
like this, just so that I don't
584:28 - make hard hat mad if I don't use
rank B. And we can do something
584:31 - like that for all these. So
you'll see this syntax,
584:36 - oftentimes in a lot of code
setups. Now the last thing that
584:42 - I'm going to show you before
going into the TypeScript
584:45 - edition of This is test
coverage. And as we progressed
584:48 - to this course, I'm going to
show you more and more tools
584:51 - that you can use to make sure
that our simple storage contract
584:54 - is safe and secure. And we take
all the steps we can to prevent
584:58 - any hacks from happening if we
deploy in real life. One of
585:01 - those tools is a tool called
solidity coverage. And this is
585:04 - also a hardhat plugin that we
can use for our code. solidity
585:07 - coverage is a project that goes
through all of our tests and
585:10 - sees exactly how many lines of
code in our sample store dot Sol
585:15 - are actually covered. And this
can be a Good tip off. If we
585:18 - don't cover some line of code,
solidity coverage will say, Hey,
585:21 - you don't have any tests for
this line, maybe you should
585:23 - write some tests for it. We can
add solidity coverage the same
585:26 - way we've been adding all of our
packages. npm install dash, just
585:29 - save Dev, or since we're using
yarn, yarn, add dash dash Dev,
585:34 - solidity coverage. And we can
then add this to our config, the
585:41 - same way we've been adding
everything to our config, go to
585:43 - our config, and we'll write
require solidity coverage. And
585:48 - there's some configuration
pieces we can add down here
585:50 - below for this, but we're just
going to use the default now we
585:53 - can do is run yarn, RT hat
coverage. And this is going to
585:58 - go through our tests and print
out a file that looks like this,
586:01 - we'll also get a file called
coverage dot JSON, which is
586:04 - basically this chart broken down
a little bit more often put my
586:08 - coverage dot JSON in my dot get
ignore. And I know we haven't
586:12 - actually seen dot Git ignore, do
what it's supposed to do. But we
586:15 - will soon we can see here that
about 50% of the code 50% of our
586:20 - statements in simple storage dot
soul are covered. About two
586:24 - thirds of our functions are and
50% of the lines, It'll even
586:27 - give us exactly what lines
aren't tested right now, which
586:30 - we can see exactly 31 and 32 of
simple swords, outsole aren't
586:34 - covered, which makes a lot of
sense, because 31 to 32 is this
586:38 - Add Person function, which we
didn't call and we didn't add to
586:41 - our tests. If you want to take
this time to pause and try to
586:45 - make this solidity coverage be
100% across the board, by
586:48 - writing some more tests, I
highly recommend you do so it'll
586:51 - be a great learning exercise.
We'll also add the coverage
586:54 - folder. So covered adjacent and
the coverage folder, which
586:57 - again, I'll explain what the dot
get ignore folder does a little
587:00 - bit later. Now the last thing
that we didn't talk about and
587:06 - here was what is this nomic labs
hard hat waffle. We talked about
587:10 - Daddy and V heart and ether scan
tasks gas reports. So today,
587:14 - what is this? Well, we can
actually Google search this and
587:18 - find out exactly what this is
Hardhead waffle is actually a
587:21 - plugin to work with the waffle
testing framework. waffle is one
587:25 - of these frameworks that allow
us to do some really advanced
587:27 - testing, we're going to be
working with some syntax that
587:30 - looks really similar to this
really soon. And we'll be
587:33 - showing you more and more of
this waffle tool
587:35 - as we continue. Alright, the
next part of this section, I'm
587:41 - actually going to go over the
TypeScript edition of this. But
587:43 - for all intents and purposes,
you've successfully created your
587:46 - first Hardhead project, you've
done a ton of amazing things. In
587:50 - this lesson, let's do a quick
refresher of what we've learned
587:53 - so far, we learned how to spin
up our own hard hat projects.
587:57 - And now we can run yarn, hard
hat and see a list of the tasks
588:02 - and different things that we can
do with hard hat. We learned
588:06 - that hard hat looks for this
hard hat.config.js. And this is
588:10 - sort of the entry point for any
task that we run that starts
588:13 - with hard hat, we learned we can
add our contracts to this
588:16 - contracts folder. And then we
compile it by running yarn, art
588:20 - half compile, we learned that
all the compliation goes into
588:24 - the artifacts and then the cache
as well. And if we want to clean
588:28 - reset, we can either delete
these two files or just run
588:30 - yarn, hard hat clean. So we
learned that we can use scripts
588:34 - or tasks to actually deploy,
interact and do things with our
588:38 - smart contracts. We also learned
that I'm going to be using
588:40 - scripts for the rest of this
course. But if you want, you
588:43 - could absolutely use tasks as
well. I've asked this question a
588:46 - million times what's the
difference? Nobody really seems
588:49 - to know what the main difference
is. But I think the main
588:51 - difference is that tasks are for
plugins. And scripts are for
588:54 - your local development Mart,
that is mind limiter, we learned
588:57 - that we can import a whole bunch
of things, including tasks from
589:01 - hard hat in our scripts, and we
can work with our async
589:03 - functions to grab our contracts
and deploy them, we actually
589:07 - then can programmatically verify
them using hard hat and using
589:11 - hard hat plugins. And then
additionally, we can interact
589:14 - with our contracts very similar
to how we did it with ethers. We
589:17 - wrote a wonderful verification
script. And we also wrote our
589:20 - own task, we wrote our first
test for this whole space. And
589:24 - we showed what our tests are
going to look like moving
589:27 - forward. And we talked a little
bit about their importance. And
589:30 - I really should stress that
writing good tests is going to
589:33 - be the difference between a
really professional environment
589:36 - and kind of a side project.
Whenever I audit smart
589:38 - contracts, or whenever I'm given
a project for someone to tell me
589:41 - to take a look at. The first
thing I look at is the readme,
589:45 - of course. And the second thing
I look at is the tests. And if
589:48 - tests aren't good, I usually
tell them, hey, you need to go
589:51 - back to the drawing board, and
you need to level up your tests.
589:54 - So tests are really really
important, especially for this
589:57 - space, we learned about a couple
of more environment variables we
590:00 - can use. We learned about a
couple of tools to see how good
590:03 - our tests are one of them being
coverage. We also learn about a
590:07 - gas reporter to see how much
it's going to cost us when we
590:10 - actually deploy to a real
network. We learned a ton about
590:13 - the hard hat config, and how
there are multiple networks that
590:16 - we can add add to our hard
heads, we can make our project
590:19 - our EVM code, work with any
network out there, we started
590:23 - working with dev dependencies
instead of regular dependencies.
590:26 - Now, READMEs are something that
I'm not really going to go over
590:29 - too deeply in here. But READMEs
are sort of like the welcome
590:33 - page of your GitHub repository,
and really should give you an
590:36 - understanding of what your code
does. Being a part of the web
590:39 - through space. And being a part
of the blockchain ecosystem is
590:42 - really more than just you coding
your stuff by yourself. You want
590:45 - other people to interact and
engage with your code and engage
590:48 - with your projects. I haven't
showed you how to use GitHub
590:50 - yet. But don't worry, we're
going to but if you look at my
590:53 - heart had simple storage readme.
If you scroll down, usually, you
590:56 - really want to have a Getting
Started section where you define
590:59 - how to set up all the code and
how to set everything up a
591:02 - Quickstart section, and maybe a
usage section and some testing
591:06 - section, which teaches people
how to actually use and interact
591:09 - with your code. Since we're just
learning more of the code part
591:12 - and not so much the readme part.
For now, we're not going to go
591:15 - over how to make a fantastic
readme. However, I will leave a
591:18 - link in the GitHub repository
associated with this course,
591:20 - link to this best readme
template. It really is a
591:23 - fantastic readme template that
you can copy to any of your
591:26 - projects to make them look
really good and give them a
591:29 - really good setup, so that other
developers can come to your
591:32 - project, and learn and
participate with what you're
591:35 - coding. But all right, you have
learned an absolute ton, you
591:38 - should be incredibly proud of
yourself, and incredibly excited
591:41 - that you've made it this far.
Now I'm going to jump into the
591:44 - TypeScript section here. So for
those of you who are coding
591:46 - along with TypeScript, feel free
to follow along. For those of
591:49 - you who are not, you just
finished the Basic section on
591:52 - hard hit, but stick around the
next to heart out sections are
591:55 - going to be the ones that really
fine grain and hone your skills,
591:58 - and give you all the
fundamentals for working with
592:01 - these frameworks. So be sure to
follow along with the next two
592:04 - sections, we've got a ton more
fantastic content for you, we
592:07 - are just beginning to get deeper
into the smart contract
592:10 - ecosystem. So take that lap, get
that coffee, and I'll see you
592:14 - soon. Alright, also now let's do
this with TypeScript. So I am
592:20 - going to go ahead and just start
this from our JavaScript
592:22 - section. However, if in the
future, you want to start a new
592:25 - Hardhead project, you can
actually start a new project
592:29 - with yarn, hard hat. And then do
great and advanced sample
592:34 - project that uses TypeScript,
you'll add a ton of plugins. And
592:38 - you'll wait a while for
everything to get uploaded. And
592:41 - you wait, and you wait a little
bit for everything to get
592:43 - downloaded. We're not going to
do that though, because I'm
592:45 - going to show you how to convert
this to JavaScript Anyways, if
592:48 - in future hearted sections, as
we're coding along with
592:51 - JavaScript, if you want to code
along with TypeScript, you
592:53 - absolutely 100% can. But let's
go ahead and show you what the
592:57 - main differences are. Now that
advanced TypeScript thing is
592:59 - going to add a whole bunch of
packages that you may or may not
593:01 - want, I will talk about some of
them in our next lesson. But
593:04 - there are going to be some that
you absolutely do need. Those
593:07 - are going to be at type chain
slash ethers, dash v five, at
593:14 - type chain, slash hard hat, at
TypeScript, at types, slash
593:20 - Chai, at types, slash node, at
types slash moko, TS node, type
593:28 - chain and TypeScript. And I have
a link in the GitHub repo
593:33 - associated with this course,
I've got this yarn ad that you
593:36 - can just copy paste, if you want
to just copy paste that into
593:39 - your project to run it. Oops,
and I should have added those as
593:41 - dev dependencies. So we're going
to actually just make them dev
593:44 - dependencies real quick, just by
deleting these two lines, and
593:47 - adding a comma here. Awesome,
that looks much better. And then
593:51 - of course, what we're going to
do is we're going to convert all
593:54 - of our JavaScript to TypeScript.
So anywhere where we have J S,
593:59 - we're going to put Ts,
obviously, if you're coding this
594:01 - from scratch with TypeScript,
you would do the.ts From the get
594:04 - go. This includes our hard hat
dot config, that's also going to
594:08 - be TypeScript now. And
additionally, we're going to add
594:10 - a TS config dot JSON. This is
going to be our TypeScript
594:14 - configuration. Typically, for a
setup, we're gonna go with
594:16 - something like this. And you can
copy this from the GitHub repo
594:19 - associated with this course.
It's basically telling
594:21 - TypeScript, what versions of
Typescript and what files to
594:24 - include for working with
TypeScript. Now let's go ahead
594:27 - and start with our deploy dot
TypeScript. For usual, instead
594:30 - of using require, we're gonna go
ahead and use import, we're
594:34 - gonna do the exact same thing.
We're gonna have import ethers
594:37 - run network, from hard hat. And
then in our verify function,
594:45 - we're going to add that we're
gonna add the types for these
594:48 - arguments. So contract address,
is going to be a string. And
594:52 - args is going to be an array of
arguments. So we're gonna say
594:56 - it's gonna be any array, because
it could be string, it could be
594:59 - numbers, it could be balloons,
it could be anything. We're also
595:02 - going to say for IE, it could be
any, even though this is
595:04 - technically an error type, we're
just going to put any for
595:08 - simplicity. For now. All of our
TypeScript scripts are included
595:12 - in our TS config, or any
TypeScript files are manually
595:15 - added here, which we have Our
entire scripts folder here,
595:18 - which is good. So now we need to
add ethers in here. Well, if we
595:22 - look at our hardhead.config.ts,
we're using require here still,
595:27 - and we need to swap this out for
import for Donnie V, you can use
595:30 - dot env slash config for it to
grab your dot env file. Now that
595:34 - we've imported everything, go
back to our deploy.ts, we can
595:38 - see that that linting has gone
away. If you want to be even
595:41 - more explicit, we can go ahead
and add import at nomic labs
595:45 - slash hard hat ethers like so.
reason we don't need to import
595:50 - it here is because these two
packages also work with Hardhead
595:54 - ethers, so they automatically
import it. But if you want to be
595:56 - super explicit, you can go ahead
and add it like so. Now, we're
596:00 - almost good to go. But remember,
our Harnett dot config is also
596:03 - importing our tasks. So we're
going to need to update our
596:06 - tasks or block number to be
TypeScript fide. So of course,
596:11 - instead of const require, we're
going to import task from our
596:16 - that slash config. And we're
going to be sure to export our
596:19 - task from lock number as the
default. So we're going to do
596:23 - export default task like so. And
now we should be good to run our
596:28 - scripts. So we can just do yarn,
art hat, run scripts,
596:34 - employee.ts. We can do network
hard hat if we choose. And
596:38 - awesome. Now, it's when we get
to the testing, that things get
596:42 - a little bit different here. So
let's go ahead and change this
596:45 - required to import. Just to make
it happy there. Let's try to run
596:50 - yarn, art head test, we get a
whole bunch of errors, and in VS
596:55 - code will actually go ahead and
get these errors right from the
596:58 - linter. One of the trickiest
things that you run into as a
597:02 - developer in this space is
calling functions on contracts
597:06 - where those functions don't
exist, or vice versa. We're not
597:09 - calling functions on contracts
that do exist. Right now the
597:12 - typing for our contracts is just
type contract, which isn't super
597:17 - helpful, because type contract
doesn't necessarily have all the
597:20 - functions that we want it to
have. We want our contracts to
597:23 - be of type contract, but we want
them to be of the type of our
597:27 - contract, because if they're the
type of our contract, they can
597:30 - have all the functions that we
want them to have. So to give
597:33 - our contracts the correct typing
here, we actually can use this
597:37 - tool called type chain, which
gives our contracts correct
597:40 - typing type chain has a hardened
plugin, which allows us to use
597:44 - type chain and TypeScript
natively together, type chain
597:47 - slash hard hat was one of these
things that we already
597:49 - installed. And to add it to our
hard hat, we got to just go to
597:53 - the hard hat config, and add it
in import at type chain slash
597:59 - arhat. Now once we import that
in to our config, if we run yarn
598:03 - hardhat, we now get a new task
here called type chain, you read
598:08 - the description, it says
generate type chain typings for
598:11 - compiled contracts, this will
enable all of our contracts to
598:15 - have their own typing. So we can
have a simple storage variable
598:18 - of type simple storage contract,
which is much better, because
598:22 - we're always going to know
exactly what we can do with each
598:25 - contract. To create this, we run
yarn,
598:28 - arhat type chain. And this is
going to create a new folder
598:35 - called type chain slash types.
With types for all of our
598:39 - contracts, you can even go into
our simple storage sub Ts, which
598:42 - is going to have all the
different functions and
598:44 - everything to do with our simple
storage contract automatically
598:48 - coded into Typescript and
JavaScript for us, which is
598:51 - incredibly helpful. And again,
no, I haven't shown you what
598:54 - this is yet. But in our dot Git
ignore, we usually want to add
598:57 - type chain and type chain dash
types into our dot Git ignore so
599:01 - we don't push them up to GitHub.
Now back in our test, we're
599:04 - going to add the exact types of
these different objects here. So
599:09 - we're going to import them from
that folder that we just
599:12 - created. So we'll do import
simple storage, comma, simple
599:17 - storage underscore underscore
factory from dot dot slash
599:24 - types, ain slash types, the
simple storage factory is going
599:29 - to be simple storage factory and
then civil storage of course, is
599:32 - going to be simple storage. So
now when do let simple storage
599:36 - factory which is going to be of
type, simple storage, underscore
599:42 - underscore factory, and then
simple storage, which is going
599:46 - to be of type simple storage
contract. And if we command
599:51 - clicked into simple storage,
once again, we can see all the
599:55 - contract functions that we know
and love, are here. In addition,
599:59 - we have all the functions of the
actual contract itself. Once we
600:03 - do that, we're pretty much good
to go we just need to have a
600:06 - couple of new things here. Get
contract factory returns a type
600:10 - ethers dot contract factory. So
what we just need to do is we
600:13 - need to wrap this in a simple
storage factory type. So We'll
600:17 - just do a little wrap like this.
And we'll say, as simple
600:21 - storage, I'm just going to sort
of factory. And that's good to
600:25 - go. Now that we've added all
this, we can run yarn, Hardhead
600:28 - test. And boom, our test run is
normal, but with TypeScript and
600:33 - with this additional typing that
makes our lives substantially
600:37 - substantially better. And that's
going to be all you need to know
600:39 - for TypeScript, reusable, all of
the branches have an optional
600:43 - TypeScript branch that you can
use to reference to work with
600:46 - TypeScript.
600:51 - We've learned really just the
basics of all the different
600:53 - things we can do with hardhat.
And these next few lessons
600:56 - Hardhead fun meme and hard hat
smart contract lottery are
600:59 - really going to be the basics
for all the fundamentals of all
601:02 - the tools that we're going to
learn in hardhat. Lesson Eight
601:05 - is going to be our introduction
to full stack and working with
601:07 - front end and building full
stack applications. Getting all
601:11 - the way through this course will
give you all the tools to start
601:14 - your web three journey. But if
you're looking to just learn
601:17 - just the basics, make sure you
absolutely get all the way to
601:20 - Lesson Nine. And if you get all
the way through lesson 18, you
601:24 - are going to know all of the
cutting edge tools for this
601:26 - space. And you're going to have
the knowledge to become easily
601:29 - one of the best developers in
the space. So hope you make it
601:32 - all the way through to the end.
Now one of the most important
601:35 - parts of this section of this
lesson is going to be pushing
601:38 - our code up to GitHub, and then
sending a tweet celebrating that
601:42 - we pushed our first smart
contract our first web three
601:45 - GitHub repository to GitHub. So
before moving on to the next
601:49 - lesson, be absolutely sure to
get to the end of this and push
601:53 - this code up to GitHub. And then
optionally, if you want to
601:57 - celebrate by sending a tweet,
but be absolutely sure to get to
602:00 - the GitHub section, because as
I've said, many times the web
602:02 - three space is this incredibly
collaborative community and
602:05 - working with GitHub or GitLab,
or any other version control
602:09 - tool is going to be essential
for your success in the space.
602:12 - So be sure to get to that part.
All right. Now, welcome back to
602:16 - the hard hat Fund Me section of
our course. This is the section
602:21 - where we're actually going to
upload our first code repository
602:24 - to GitHub if you've never done
this before, this is going to be
602:28 - the section where we're going to
learn even more about hardhat
602:31 - using a familiar contract base
we've already worked with, which
602:34 - is the fund me contract. And
again, if you're using the
602:37 - GitHub repo associated with this
course, you can scroll down to
602:40 - the Hardhead Funmi. And all the
code is located in our repo. If
602:46 - you'd like to do a quickstart,
you can go ahead and get clone
602:48 - it CVU into it, and then run
yarn, and then just run yarn
602:52 - hardhat deploy this, I'm going
to briefly show you what that
602:56 - looks like. So in your in your
VS code, you can do git clone,
603:01 - grab the package, cd into it,
and then type code period. To
603:08 - open it up in a new VS code.
Once you're in your folder, you
603:12 - can go ahead and run yarn. To
install all the dependencies for
603:15 - working with this project, you
plan on working with the test
603:17 - net or working with ether scan
or coin market cap, feel free to
603:21 - fill out your Dotty and V with a
private key RPC URL, corn market
603:25 - cap key and ether scan key. And
then you can just follow along
603:28 - with the readme to use this repo
to run yarn, hard hat deploy.
603:34 - And it'll show you deploying
some contracts and some mocks,
603:37 - etc. So let's get to building
this ourselves though. Now we're
603:43 - gonna make a new directory for
this project, it's gonna be the
603:45 - same setup we've seen before. MK
dir, hard hat. And me, FCC,
603:53 - we're gonna cd into heart at
Funmi, FCC, and then type code
603:56 - period. And if code period
doesn't work for you, you can
603:59 - absolutely open this up by
hitting File, Open Folder, like
604:04 - we showed you before. Now, we're
in a brand new folder here. And
604:07 - we're gonna go ahead and add
hard hat here. And we're gonna
604:10 - run yarn, add dash dash Dev,
hard hat. Now that we have hard
604:19 - hat, in our package, JSON, and
in our node modules, we can go
604:23 - ahead and run yarn, start app.
And this will say, What do you
604:27 - want to do? I'm going to choose
the advanced sample project
604:30 - here, just to show you what's
going on. And we're going to set
604:33 - this up in a way that I think
works best. So we'll go ahead
604:36 - and do the advanced sample
project. Yes, we're going to
604:38 - have that as the root. Yes, we
want to add a Git ignore. And
604:41 - there are a lot of sample
project dependencies that it
604:44 - wants us to add. We're gonna go
ahead and hit yes. But we're
604:47 - going to end up not using all of
these and I'll show you which
604:50 - ones we're not going to use and
why. But for now, let's go ahead
604:53 - and hit yes.
605:02 - All right, awesome. And now we
have an advanced project in
605:06 - here. Let me walk you through
the additional things that are
605:08 - in here. So we have a
traditional contract node
605:11 - modules, which is going to be
the same scripts is going to be
605:14 - the same test is going to be the
same. But this comes with a dot
605:18 - E and V dot example already
packed in for us. It also comes
605:21 - with.es lint files.es lint, RC
dot j s.es. Lint, ignore es Lint
605:28 - is known as a JavaScript linter,
which helps you find and
605:31 - automatically fix problems in
your code for the JavaScript
605:34 - that I work with. I'm not a big
fan of ES lint, so I typically
605:37 - don't use it. So I'm going to go
ahead and delete the two of
605:40 - these. If you want to keep them
in you absolutely can dot Git
605:43 - ignore. We're going to finally
understand what this file does
605:46 - in this lesson that NPM ignore
helps Ignore files if you want
605:50 - to push your project up to be an
NPM package, which we're not
605:53 - going to do. So if you want to
delete this, you can as well
605:56 - pretty or ignore it and pretty
DRC. We already know what these
605:58 - do small hint. And so hint
ignore, which we're going to
606:01 - talk about it in a minute, or
Hardhead config, which just
606:04 - comes already with a ropsten
network, a gas reporter and
606:08 - ether scan package dot JSON with
all the additional packages, the
606:11 - readme is a little bit more
robust. And then of course, our
606:14 - yarn dot lock. So this advanced
project looks pretty similar to
606:17 - what we're going to be working
with anyways. Now I do want to
606:22 - talk about this soul hint,
though. So what is solvent
606:25 - solvent is known as a solidity
linter that we can use to lint
606:30 - our code linting is the process
of running a program that will
606:33 - analyze code for potential
errors. It also does a little
606:36 - bit of formatting, oftentimes,
es Lint is a way to lint for
606:41 - JavaScript code. So hint is a
way to lint for solidity code,
606:45 - we use prettier to format our
code, and we can use soul hint
606:48 - to lint, our code, they are
often used a little bit
606:51 - interchangeably, even though
that's not exactly correct, as
606:54 - they are a little bit different.
We can run this linter on our
606:56 - code by running yarn, sole hint,
and then type the name of the
607:01 - files that we want to lint. So
we do contracts, slash and then
607:06 - you can just do start out so
everything looks okay, nothing
607:10 - will happen. Well, let's say we
have a variable that we don't
607:13 - explicitly say the visibility of
it is. This isn't the best
607:18 - practice because ideally, we
always say exactly what the
607:22 - visibility of some variable is.
This obviously gets defaulted.
607:25 - But it's usually better to be
more explicit. So now if we run
607:28 - yarn, so hint, contracts start
up so it'll give us a warning,
607:35 - saying we should explicitly Mark
visibility of state, this linter
607:39 - is a good way to check for some
best practices for running our
607:42 - code. So we're definitely going
to keep a small hint around. Now
607:48 - that we've got a repo here,
let's add a couple of our common
607:51 - setup pieces here. So in
prettier.rc, we're going to swap
607:56 - this out with what we've been
using so far. Tab of the form us
608:00 - tab is false, semi false, single
quote, also false. We're going
608:04 - to update our prettier dot
ignore node modules, package dot
608:08 - JSON image artifacts, cache
coverage ID v dot star, readme,
608:12 - and coverage and anything else
you want to add in here. And
608:16 - we're going to scroll up to our
contracts folder. And we're
608:19 - going to swap this greeter dot
soul out with our fund me dot
608:22 - soul. Now let's go ahead and add
our contracts in here. If you're
608:26 - following along with the repo,
you go to the contracts folder,
608:29 - there's actually another folder
in here and the contracts look a
608:33 - little bit different. So if you
have those contracts, steal from
608:36 - remix, let's actually grab them
from remix because we're going
608:39 - to make a couple of changes to
them. If you don't have remix up
608:42 - anymore, which you probably
shouldn't, because you should be
608:44 - taking breaks, you can jump back
over to Lesson four remix Funmi
608:48 - jump into the repo here and grab
the contracts from inside here.
608:52 - Just go to the fun v dash Free
Code Camp tutorial and grab the
608:55 - code from there. So we're gonna
grab just fun me and price
608:58 - converter dot soul. So go ahead
and delete that old file, create
609:02 - a new one and call it fund me
dot song. Paste it in there. And
609:07 - then we're going to create the
price converter. That's all. Now
609:13 - we have both our Funmi and our
price converter contracts in
609:17 - here. Now one of the first
things that we want to do one of
609:19 - the first things that we did
last time was we ran yarn
609:21 - compile to make sure that our
code is actually working the way
609:24 - we want to. And before we
actually hit Compile, one of the
609:27 - things that we're going to need
to do is come to our Hardhead
609:29 - dot config, we're going to make
sure we're on the correct
609:31 - solidity version. So we're going
to do zero point 8.8 here. And
609:35 - let's go ahead and try to
compile.
609:39 - So we can run yarn Hardhead
compile. And you'll see we
609:44 - actually get an error here.
Library at chain link slash
609:47 - contracts imported from
contracts slash fund me dot soul
609:50 - is not installed, try installing
it using npm. In remix, we went
609:55 - ahead and just imported at
chainlink slash contracts, right
609:58 - from our NPM and or GitHub. But
in our local code, we have to
610:02 - tell Hardhead specifically,
where to get this from, we want
610:07 - to download this specifically
from the NPM package manager at
610:11 - chainlink slash contracts, we
can download it simply by
610:14 - running yarn, add dash dash dev
at chainlink slash contracts.
610:23 - Now that we've downloaded it
into our file, we'll be able to
610:25 - see it in Node modules here.
Hardhead is now smart enough to
610:30 - know that at chain link slash
contracts is going to point to
610:32 - that node module that we have.
So we can now run yarn Hardhead
610:36 - compile boom, now we can see
compiled three solidity files
610:40 - successfully. So now we have our
contracts in here and our code
610:47 - is compiling successfully. We're
probably going Want to deploy
610:50 - our code? Now in our last
section, I know we use the
610:52 - scripts module. And we made our
own manual deploy script.
610:56 - However, something that you'd
notice, the more that you work
610:58 - with just raw ethers, or even
just hard hat is that keeping
611:01 - track of all our deployments can
get a little bit tricky. If you
611:05 - just use a deploy script, it's
not saving our deployments to
611:08 - any file. Additionally, having
everything in the deploy script
611:11 - for deploying can make the tests
and the deploy scripts, maybe
611:15 - not work exactly hand in hand.
And there are a couple of other
611:18 - things that might be a little
bit tricky to work on, we're
611:20 - actually going to work with a
package that makes everything I
611:22 - just mentioned, and a couple
other things way easier. And
611:26 - this package that I'm talking
about is going to be the hard
611:29 - hat deploy package. There's a
link to this package in the
611:32 - GitHub repository associated
with this course. It's a hardhat
611:35 - plugin for replicable
deployments and easy testing.
611:38 - And if we scroll down to
installation, we can see we
611:40 - install it basically the normal
way. They're using npm. And
611:44 - we're gonna go ahead and use
yarn. So for us to add it, we'll
611:48 - do yarn, add hardhat dash
deploy. And then of course,
611:53 - we're gonna do dash dash Dev.
Once done deploying this require
611:59 - statement to our hard
hat.config.js. Once again,
612:04 - basically the config is our
entry point. This is where we're
612:07 - gonna get started. And we can go
ahead and delete our deploy.js
612:11 - script. Now if we run yarn
hardhat, you see that we have a
612:15 - bunch of new tasks in here, with
one of them being this deploy
612:19 - task, this deploy task is going
to be the main task that we use
612:23 - to deploy our contracts. Instead
of writing our deploy scripts in
612:26 - the Scripts folder, we're
actually going to create a new
612:28 - folder, we can create a new
folder by just doing MK dir
612:32 - deploy. Or you can always right
click and hit New Folder. This
612:36 - deploy folder is going to be
where a lot of hard hat Deploy
612:39 - Module looks to deploy code. And
it's going to be where we are
612:42 - writing our scripts. To write
our scripts, we usually need to
612:45 - add one more thing in here.
Since we're going to be using
612:48 - ethers JS in all of our scripts,
we want to add Hardhead deploy
612:51 - ethers to our package here. Now,
instead of just doing yarn, add
612:55 - dash dev hard at deploy ethers,
we're going to do something a
612:58 - little bit weird. We're going to
do yarn add or npm install dash
613:02 - dash Dev, and we're going to
install it like this. So let me
613:05 - just copy this. And you can just
copy that from the repo. And
613:08 - we'll do yarn, add dash dash
Dev, and paste that in here.
613:12 - What we're doing is we're taking
at nomic labs, hard hat ethers,
613:16 - which we've used before, and
we're overriding it with hard
613:19 - hat deploy ethers. Remember how
in our last project, we used
613:23 - hard hat ethers. So that hard
hat could override ethers to use
613:27 - hard hat deploy. We use hard hat
deploy ethers, so that hard hat
613:30 - deploy can override Hardhead,
which overrides ethers, which is
613:34 - kind of funny. When you say like
that, this will enable ethers to
613:38 - keep track of and remember all
the different deployments that
613:41 - we actually make in our
contract. So if we look at our
613:44 - package, JSON, and now we can
see our nomic labs dashboard had
613:48 - ethers. Now the version of it is
going to be MPM. Hardhead deploy
613:52 - ethers. This is our package dot
JSON, basically saying the hard
613:56 - hat ethers package is now
overwritten by the hard hat
613:59 - deploy ethers package, which is
what we want. Alright, great. So
614:03 - now that we have that setup, we
can start writing our deploy
614:05 - scripts, the way that Hart had
to play works is all the scripts
614:08 - that get added to our deploy
folder will get run when we run
614:12 - yarn, hard hat deploy. So a good
practice is usually to number
614:16 - them so that they run in the
order that you want them to run
614:18 - in. So since we only have one
contract that we want to deploy
614:22 - the Funmi contract, we're going
to do 01 Deploy Funmi Jas, and
614:28 - in this script, this is going to
be where we define how to deploy
614:31 - the fundament contract. Alright,
so we're in our deploy Funmi
614:35 - scripts. Now traditionally, what
did we do, we did imports, we
614:39 - did the main function. And then
we did calling of main function,
614:44 - that Hardhead deploy is a little
bit different, we're still going
614:47 - to import our libraries and
packages, but we're not going to
614:49 - have main function. And we're
also not going to call the main
614:52 - function when we run Hardhead
deploy Harnett deploy is
614:56 - actually going to call a
function that we specify. In
614:59 - this script here. What we're
going to do is we're gonna
615:02 - create a function, we'll call it
deploy funk.
615:06 - We're going to export this
deploy function as the default
615:08 - function for Hardhead deploy to
look for, so we could say,
615:13 - module that exports dot default
equals deploy funk. To test it
615:20 - out, we can go ahead and do
console dot log, hi. And then in
615:25 - our terminal, run yarn, hard
hat, deploy. Oops, get rid of
615:31 - the parentheses here. Sorry. Run
it again. And we can see it went
615:37 - and ran our deploy func here.
Now if this syntax is easier for
615:41 - you to understand, go ahead and
use this syntax and we're going
615:44 - to be passing the heart at
runtime environment as a
615:47 - parameter to this function.
However, if we go to the heart
615:51 - hat deploy documentation, and we
scroll down to an example
615:55 - script, the syntax looks a
little bit different. And let me
615:58 - just explain what's going on
here and how we're going to be
616:01 - writing ours. So instead of kind
of defining everything like
616:04 - this, and defining the function
name, similar to what we were
616:07 - doing before, we're actually
going to using a nameless, a
616:10 - synchronous function, we're
going to make it an anonymous
616:13 - function, similar to what we've
seen before. So instead, we're
616:17 - going to say async parameters
like this, I'm going to pass our
616:21 - parameters our heart at runtime
environment in here. And it's
616:24 - going to be an arrow function.
And then we're going to wrap
616:28 - this whole thing in module dot
exports. So we're gonna say,
616:33 - module, dot exports, equals this
async function like this. This
616:40 - syntax here is nearly identical
to what's up here, we just don't
616:45 - have a name for our async
function. So this is how we're
616:48 - going to set it up instead. But
if this syntax is a little bit
616:52 - confusing for you feel free to
use this above as the two of
616:55 - these are going to be the same.
Now the next thing that most of
616:58 - the documentation does is it
pulls out the variables and
617:01 - functions out of the HRV that
we're going to use. HRV is the
617:05 - heart hat runtime environment.
Whenever we run a deploy script,
617:09 - heart hat deploy automatically
calls this function and just
617:12 - passes the hard hat object into
it similar to in back in hard
617:16 - hat simple storage. In our
deploy script. We had ethers run
617:21 - in network come from hard hat,
instead of coming from hard hat.
617:24 - We're coming from HRV, which is
basically the same thing as hard
617:27 - hat. For our script, we're only
going to use two variables from
617:30 - a jury when you use const. Get
named accounts. And deployments.
617:41 - This syntax might look a little
bit weird for you. But it's just
617:44 - a way to pull these exact
variables out of a tree. It's
617:47 - kind of the same thing as just
doing a tree dot get named
617:51 - accounts and HRA dot
deployments. But pulling them
617:56 - out like this means we don't
have to add a tree at the
617:58 - beginning anymore. And then
additionally, additionally,
618:02 - JavaScript has something called
syntactic sugar. So instead of
618:05 - doing this on two lines like
this, we can actually do that
618:09 - whole bit on one line. So
instead, we just extrapolate
618:14 - those two variables, right in
the function declaration. So
618:18 - this line is the exact same
thing as doing this line. This
618:22 - is an asynchronous, nameless
function using the arrow
618:25 - notation, or working with our
deploy scripts here. And we're
618:29 - default, exporting it with
module dot exports. I don't know
618:32 - that was a lot. And another is
kind of a lot of syntactic sugar
618:35 - here. But if that's really
confusing for you, just feel
618:38 - free to use the above. And
whenever we refer to get named
618:41 - accounts, you can also just do a
three dot get named accounts, or
618:48 - a three dot deployments. So
hopefully, that's clear that
618:53 - this top part is gonna be the
same as this bottom part right
618:55 - here, whichever one you feel
more comfortable working with.
618:59 - But alright, now that we've
gotten all that out of the way,
619:01 - let's continue with the script.
So we're using this deployments
619:04 - object, reason this deployments
object to get two functions,
619:08 - those two functions are going to
be the deploy function, and the
619:11 - log function. So we're gonna say
const, deploy log equals
619:14 - deployments. So we're going to
pull these two functions out of
619:18 - deployments. And then we're also
going to do const Deployer.
619:23 - Equals await, get named
accounts. So we are grabbing
619:28 - this new deploy function, this
new log function, and we're
619:31 - grabbing this deployer account
from this weird get named
619:34 - accounts function. What's this
get named accounts function,
619:38 - this get named accounts is a way
for us to get named accounts.
619:42 - When working with ethers we saw
when working with ethers, we can
619:45 - actually get our accounts based
off of the number in the Account
619:49 - section of each network. So for
example,
619:54 - in this list of private keys,
private keys zero private key
619:57 - one private key two, it might
get a little confusing to
620:00 - remember which ones which so
instead of working like that, we
620:04 - can add a section at the bottom
called named accounts where we
620:07 - can name each one of those spots
in the accounts array. So we'll
620:11 - do named accounts. And we'll say
one of the accounts that will
620:15 - name is going to be named
Deployer. And we're gonna say by
620:18 - default, the zero with account
is going to be Deployer. We can
620:23 - also specify which number is
going to be the deployer account
620:27 - across different chains. For
example, on Rigby we wanted the
620:31 - deployer account to be the first
position, we could do something
620:33 - like this or on hard hat, we
could do it like this. We can
620:37 - create multiple users. Like for
example, if we wanted to do a
620:40 - user for some test or something,
and we'll just say the default
620:44 - is one or whatever we wanted in
here. So back in our deploy fun
620:48 - me We're going to say we're
going to grab that deployer
620:51 - account from our named accounts.
And then finally, we're going to
620:54 - grab our chain ID for reasons
that will come clear pretty
620:57 - soon. So we'll do const, chain
ID equals network dot config dot
621:03 - chain ID. Now, how do we
actually deploy this fund me
621:09 - contract? Well, let's think
about this for a little bit.
621:12 - When working with remix, it was
pretty easy, right? We just
621:15 - deployed it to a test net. Ah,
that's kind of the issue there,
621:18 - isn't it deploying to a rink,
the test net is a little bit
621:21 - slow. We don't always want to
have to deploy to one of these
621:24 - slow test nets or even a main
net when tinkering and fiddling
621:27 - with our contracts, do we know
that's gonna be really bad, we
621:31 - really want to deploy to a test
net as a last stop after we've
621:34 - done all our testing locally. Or
we can deploy it to a test that
621:37 - to see some very specific code
work, like for example, with the
621:41 - chain link documentation. So
ideally, we deploy this to a
621:44 - local network first. But can we
just do that? Well, if we look
621:48 - in our price converter, dot
Seoul, we have this hard coded
621:51 - address in here, this 0x
address, if we go to Doc's dot
621:55 - chain that link EVM chains,
contract addresses for Aetherium
621:59 - data feeds. That address is the
eth USD, specifically for
622:03 - Rinkeby. What if we work on the
Hard Hat Network? Example?
622:07 - default network?
622:10 - Hard Hat. And then like I said
before, if you don't write this
622:13 - in part, it is automatically the
default network. But if we're to
622:16 - point to the Hard Hat Network,
harder network is a blank
622:19 - blockchain. And it gets
destroyed every time our scripts
622:21 - finish, or even if we're working
with a local node, this price
622:24 - feed contract won't exist, one
of the code there won't be
622:28 - updated with data. So what do we
do? How do we test and interact
622:31 - with our code locally? Is there
a way we can do this? Well, one
622:34 - of the ways that we can do this
that we'll learn a little bit
622:36 - later is actually forking a
blockchain, where you can keep
622:39 - stuff hard coded. But usually,
it's still better to figure out
622:42 - how to do everything with
something called mocks. There's
622:46 - a great Stack Overflow question
that just says, What is mocking
622:49 - and mocking is primarily used
for unit testing, which we'll
622:52 - talk about in a little bit. And
object under test may have
622:55 - dependencies on other complex
objects. To isolate the behavior
622:59 - of the object, you want to
replace other objects by mocks
623:03 - that simulate the behavior of
the real objects. In short,
623:07 - mocking is creating objects that
simulate behavior of real
623:10 - objects. Now, this might seem
like a lot of words. But
623:14 - basically, what we want to do is
we want to make a fake price
623:17 - feed contract that we can use
and we can control when working
623:20 - locally. So back here, I'm just
going to leave a note in here
623:23 - saying, When going for local
host or Hard Hat Network, we
623:30 - want to use a mock. Okay, great,
well, we can use a mock and
623:33 - we'll learn how to make one of
those in a little bit. Well,
623:36 - what happens when we want to
change chains, for example, back
623:42 - in dots dot chain to link EVM
chains, contract addresses,
623:46 - there are a ton of different
block chains that have price
623:50 - feeds on them. And on each one
of these blockchains, the eth
623:53 - USD price feed is going to be a
little bit different. For
623:56 - example, we're looking at ETH
USD, the address of eth USD for
623:59 - Aetherium main net is different
from the address of eth USD for
624:03 - Rigby, which makes sense,
they're totally different
624:05 - contracts on different chains,
they have very similar
624:08 - functionality. And they do
nearly the exact same thing. But
624:11 - they're still different. We're
also going to need a way for us
624:13 - to modularize or parameterize,
this address in here, so that no
624:18 - matter what chain we deploy to,
we don't have to change any of
624:21 - our code, we can always have our
code be exactly the same. And we
624:23 - don't have to come in here and
like flip values and flip
624:26 - variables and stuff. So let's
keep that all of that in mind as
624:29 - we write the rest of this. Now
in order to parameterize. This,
624:33 - we actually want to prioritize
and do a little refactoring of
624:36 - our fundamental soul.
Refactoring basically means
624:39 - going back and, and changing the
way your code works. Right now
624:43 - we have this constructor
function, right the constructor
624:46 - function is the function that
automatically gets called
624:49 - whenever we deploy our contract.
Right now it's not doing a whole
624:52 - lot right now it's just updating
the owner variable to be whoever
624:55 - sent in the contract. But we can
actually have a do much more
624:58 - than that. Since this
constructor is a function just
625:02 - like every other function, we
can actually have it take
625:04 - parameters, one of the
parameters that we might like
625:07 - for it to have is going to be
the address of a price feed. So
625:11 - let's go ahead and add this and
figure out how to refactor all
625:13 - this code. So we're going to add
constructor address, price feed
625:18 - for the constructor in here.
When we deploy our contract. Now
625:21 - we're going to pass it the eth
USD price feed address depending
625:24 - on what chain we're on. If we're
on rink B, we'll use this
625:27 - address if one polygon will use
a different one b&b, different
625:30 - one, Gnosis hecho, avalanche,
etc, you get the picture. So
625:34 - we're going to marginalize this
like so. Now that our
625:37 - constructor takes a parameter
for the price feed, we can
625:40 - actually save an aggregator v3
interface object as a global
625:44 - variable in our price converter,
we just create a price feed
625:47 - variable of type aggregator v3
interface, which again, we're
625:51 - importing from the chainlink
repo, which is an interface
625:54 - object which gets compiled down
to the ABI. If you match an ABI
625:57 - with up with an address, you get
a contract that you can interact
626:00 - with. So we're going to do the
same thing here. We're gonna
626:02 - say, aggregate Tor, v3
interface, public price feed,
626:10 - ration and call this price feed
address so that these don't have
626:13 - the same name. And in our
constructor, we're going to say
626:17 - price feed equals, and we're
going to do the exact same thing
626:21 - we did with our price converter
equals aggregate tore the three
626:26 - interface
626:28 - of price feed address. Like so
now, we have this price feed
626:36 - address that's variable and
modularized, depending on
626:40 - whatever chain that we're on.
Now, what we can do is we can
626:44 - grab this price feed address,
and we can use it for our price
626:47 - converter. So where are we using
our price converter? Well, just
626:51 - a quick reminder, we're using
using price converter for you at
626:55 - 256. We're using this as a
library on top of our unit 256
626:59 - type. So we're calling message
dot value dot get conversion
627:03 - rate. So we look at our price
converter, we have this function
627:06 - get conversion rate, which takes
an FML as its initial parameter,
627:09 - which again, since this is a
library, it automatically passes
627:13 - the message dot value into this
get conversion rate function.
627:17 - But we could also pass in this
price feed, and therefore we
627:22 - wouldn't need to hard code it in
the get price anymore. So let's
627:25 - go ahead and figure out how to
do that. Well, what we can do is
627:28 - we can do message dot value dot
get conversion rate, we'll stick
627:31 - price feed in here. And then
we'll have to update our get
627:34 - conversion rate to do a comma so
that it takes a second
627:38 - parameter, because remember,
again, the initial parameter is
627:41 - going to be message dot value.
And the second parameter is
627:44 - going to be what we define here.
So we'll do s amount, comma ag
627:50 - reg gate Tor v3 interface. And
we'll call this price feed. And
627:58 - now, when we call our get price
function, we can pass the price
628:03 - feed to the get price function.
And up here we can have get
628:07 - price. Take, you guessed it an
aggregate or the three interface
628:15 - called price feed. And now we no
longer need to hard code in the
628:22 - price feed. And we can just
delete those lines and have it
628:25 - compile like this, which is
awesome. So quick refresher,
628:30 - we're parameterizing that price
feed address and passing it in
628:33 - with a constructor that gets
saved as a global variable to an
628:37 - aggregator v3 interface type, or
passing it to a get conversion
628:41 - rate function, which passes it
to the get price function, which
628:45 - then just calls latest round
data. And we probably could have
628:48 - made this even easier, probably
could have just got rid of the
628:50 - get price function and stuck
this code in the get conversion
628:54 - rate. But we'll leave it there
for now. Now that we've done
628:56 - that refactoring, let's make
sure it works. Yarn Hardhead,
628:59 - compile, invalid value undefined
for hardhat dot config dot
629:03 - networks. Let's go to the let's
go to the config real quick.
629:07 - That's because the default
network needs to be outside of
629:09 - networks. My mistake. Let's try
that again. I spelled interface
629:14 - wrong and the price converter.
And a quick note, if gives you
629:17 - an error like this, oftentimes,
you can command click or control
629:20 - click and open that file up
right in the editor, which saves
629:23 - you some time, we're going to
have defined the line and find
629:26 - the file. But yeah, let's spell
that correctly. And let's try
629:29 - this again. And awesome. It
looks like it's compiling
629:33 - correctly. And we just have some
warnings, it looks like these
629:36 - warnings are just about this git
version, which is because we're
629:39 - shadowing this, we're creating a
new price variable down here,
629:42 - you've no we just created a
global price free variable.
629:46 - Let's just go ahead and delete
the get version function
629:48 - altogether since we're not even
going to really need it. And we
629:51 - only use the Git version to show
you how to actually start
629:53 - working with interfaces. And
then we'll compile it one more
629:56 - time for good measure. Boom
compiled successfully. Awesome.
630:01 - So now we've just refactored our
code. So we can pass a price
630:04 - feed address depending on the
network that we're on. Okay,
630:08 - great. With all that being said,
let's come back to our deploy
630:12 - Funmi script, and let's learn
how to actually deploy the rest
630:15 - of it. In order for us to deploy
a contract we remember from our
630:18 - last sections that we use the
contract factories, with heart
630:22 - hit Deploy, we can just use this
deploy function. And to use the
630:25 - deploy function, we'll say const
Funmi, which is going to be the
630:28 - name of our contract, equals
await. And we'll call this
630:32 - deploy function, the name of the
contract that we're deploying
630:36 - right now, and then a list of
overrides that we want to add
630:39 - here. So we're gonna say who is
actually deploying this by
630:42 - saying from, we're gonna say
it's from the Deployer. We're
630:45 - gonna pass any arguments to the
constructor In this args piece
630:49 - here, which we just added a
single Argh. So these brackets,
630:55 - we're going to make it a list of
arguments, we're going to put
630:57 - the price feed address in here,
which we'll show you how to do
630:59 - in a second, put price feed
address. And then we're also
631:03 - going to do some custom logging
here so that we don't have to do
631:06 - all that console dot log stuff
that we've been doing this whole
631:08 - time. And we need to put
something in here. We need to
631:12 - put an address in here. And you
can use this backslash star to
631:15 - put like a common in between
your code.
631:18 - We can't just do const address
equals, you know the address and
631:22 - stick it in here. Well, I mean,
we could but we're not really
631:24 - prioritizing now. Right? We're
kind of back to just hard coding
631:27 - it here. So what can we do
instead? Well, what we can do is
631:30 - we can actually use the chain ID
to do something like if chain ID
631:35 - is x, use address, Y, or if
chain ID is Z use address A. So
631:45 - we can do something that looks
like this. And to enable this
631:48 - functionality, we actually take
a page out of the Ave GitHub. So
631:51 - Ave is another protocol that's
on multiple chains and has to
631:54 - deploy their code to multiple
chains and work with multiple
631:57 - different addresses. So what
they do is they use a number of
632:01 - different useful tricks. But one
of the main ones is using this
632:04 - helper hardhat config. Now
they're using TypeScript with
632:07 - JavaScript, but it's gonna be
the same thing. With this
632:10 - config, they have different
variables, depending on what
632:14 - network that they're actually
on. And depending on the network
632:17 - that they're on, they use
different variables. So they use
632:20 - this network config almost to do
exactly what we're trying to do
632:24 - here. So what we want to do is
we're going to create a new file
632:28 - at the root directory, so just
click down here, new file. And
632:32 - we're going to call it helper,
hard hat config dot j, s. And
632:39 - this is where we're going to
define that network config. And
632:41 - this is where we're going to
say, hey, if you're on network,
632:43 - a, use this address network, be
this use this address, etc. So
632:48 - we're going to create an object
called const. Network config.
632:53 - equals and we're going to add a
bunch of stuff in here. So our
632:55 - main network that we're working
with right now is rinky. dinky
632:58 - has a chain ID of four. So we'll
say chain ID four is going to be
633:04 - named Rinkeby. And the eth USD
price feed address is going to
633:12 - be the price feed address of
rank B of the eth USD price
633:16 - feed. So we're going to copied
from the documentation or from
633:19 - the GitHub, whatever you want to
do, and paste it in here. Now we
633:22 - have a simple methodology of
keeping track of different price
633:26 - feeds a different contract
addresses across different
633:29 - chains. Let's say for example,
we wanted to deploy to Polygon
633:33 - as well. Well, first, what are
we going to need? Well, we're
633:36 - going to need the chain ID of
polygon. So a quick little
633:39 - Google Search brings us to the
polygon documentation. And we
633:43 - see the chain ID is 137. So I'll
do 137. What's a little brackets
633:48 - here, we'll say name, polygon.
Then we'll do a comma eth USD,
633:54 - price feed. And then we'll add
the price feed of eth USD on
633:58 - polygon. So docstoc, chain link,
polygon or Matic and then we'll
634:04 - look up eth, USD. And boom, we
see it right here. We've grabbed
634:09 - this address, and we paste it
in. Well, what about the
634:12 - Hardhead? Network? We'll get to
that in just a second, don't you
634:15 - worry. And then at the bottom,
we need to export this network
634:18 - config. So our other scripts can
actually work with it. So we'll
634:21 - do module dot exports equals
network config. And we're going
634:28 - to actually export a couple of
things from this file, which is
634:31 - why we're doing it like this
instead of that default way that
634:34 - I showed you before. So back in
our script, now, what can we do?
634:37 - Well, first, we want to go ahead
and import that network config.
634:41 - So we'll say const. Network
config equals require, and then
634:47 - we'll import it, we'll go down
and directory to help our
634:51 - Hardhead config and save. And I
just want to mention this one
634:54 - more time, just so that it
doesn't confuse anybody. This
634:57 - syntax here, constant network
config with the little curly
635:00 - braces around it is the same is
if I went const. Helper config
635:10 - equals this thing, which helper
config is now kind of this whole
635:13 - file. And then const network
config equals Hopper config dot
635:21 - network config. So again, this
index is just kind of an easy
635:24 - way to extrapolate or pull out
just the network config from
635:28 - this file. So that's how that
works. And that's why we export
635:31 - it at the bottom so that we can
do this, please use the GitHub
635:35 - repository to ask questions and
discussions especially about
635:39 - some of this JavaScript stuff.
Alright, great. So now that we
635:41 - have this network configured
here, we can now do this part of
635:44 - where we say if China d z use a
if chain ID is x use y. So Since
635:48 - our helper config is nicely in
this kind of dictionary, key
635:52 - value pair style, what we can do
is we can say const. eth USD.
635:59 - Price feed address equals
network config at the chain ID,
636:08 - because if Francina D, or it'll
be this object, French entity
636:12 - polygon, it'll be this object at
the eth USD price feed, we're
636:21 - going to save this to eth USD
price feed address. And now no
636:24 - matter what chain we're on,
whenever we run hard hat deploy,
636:28 - if I run yarn, hard hat deploy
dash dash network Rinkeby. This
636:34 - chain ID is going to be four.
And so it's going to use this
636:37 - price feed address. If I do dash
test network polygon, and I
636:42 - remember to add both ring P and
polygon to my networks, like
636:45 - here, the channel is going to be
137. It's going to use this
636:48 - price feed address. So this is
awesome. This is exactly what we
636:52 - want. But is it everything that
we want? Those of you who have
636:55 - been questioning while I have
been coding and talking, you
636:58 - might be thinking, Okay, well,
you talked about this marking
637:00 - thing. You talked about
localhost and hard hat. And how
637:03 - do we test this locally? Like
this is how we go to a test net
637:06 - and a main net. But what about a
local network? And that is
637:09 - exactly what we're going to talk
about now. So we've modularized,
637:13 - our code and parameterize our
code so that we're going to use
637:16 - the address based off of the
chain that we're on. But what if
637:20 - we use a chain that doesn't even
have a price feed address on it?
637:24 - What do we do there? This is
where we actually create those
637:27 - mock contracts. The idea of mock
contracts here is if the
637:32 - contract doesn't exist, we
deploy a minimal version of it
637:37 - for our local testing, or our
local testing. And deploying
637:42 - mocks is technically a deploy
script. So what we do actually
637:48 - is back in our deploy folder is
we're going to create a new
637:51 - file, and we're going to call it
00 Dash deploy mocks dot j s, we
637:58 - started with 00. Because this is
almost like the pre deploy
638:01 - stuff, we only do this,
sometimes we don't always deploy
638:05 - mocks, right, we don't need to
deploy mocks to Rinkeby, or
638:08 - polygon or or Aetherium main
net, because those already have
638:11 - these price feeds, we're
actually going to deploy our own
638:15 - mock price feed contracts. And
in our deploy Funmi script,
638:19 - we're going to use our own
contracts, instead of already
638:23 - established contracts. If we're
on a network that doesn't have
638:27 - any price, few contracts, like
hard hat or locos, for example.
638:30 - So let's write our deploy mock
script. So the setup of this is
638:34 - going to look nearly identical
to our deploy Funmi. And again,
638:37 - if you want to set it up like
this, you absolutely can. But
638:41 - I'm actually just going to copy
this, this part, paste it in
638:43 - here, because that initial part
is going to be exactly the same.
638:47 - Oh, and over here, I just
realized that we're calling this
638:49 - network thing without being
defined, JavaScript will kind of
638:52 - be smart enough to know where
this network thing is coming
638:54 - from. But it can be a little bit
confusing. So it's better to be
638:57 - really explicit, and say, const.
Network equals require hard hat,
639:03 - this network thing is coming
from hard hat. And we're going
639:07 - to grab this line. And we're
also going to use this at the
639:10 - top of our script here. And then
our top section is going to look
639:13 - exactly the same as well, we're
going to grab these three lines,
639:16 - and paste them in deploy
deployer chain ID, boom, it's
639:19 - all going to be the same here,
because we're setting up to
639:21 - deploy some stuff. Now we want
to deploy a new contract. But if
639:25 - we look at our contracts folder,
this is all we have right now.
639:28 - So we're going to need to add
this mock this fake contract to
639:32 - our contracts folder. Now what
we can do is in our contracts
639:35 - folder, we want to separate this
file from the rest of our file
639:38 - so that we know okay, this isn't
part of our project, but it is
639:41 - part of our testing. So we're
going to right click Create New
639:44 - Folder. And we can either call
it mocks, or test I like to call
639:49 - mine test. And inside of this
folder, we can go ahead and
639:52 - right click create a new file,
I'm going to create a new file
639:54 - and call it mock, v3 aggregate
tore that soul. And this is
640:01 - where we're going to define our
mock price feed aggregator
640:05 - ourselves. So how can we create
our own fake price feed
640:09 - contract, so we can test
everything locally? Well, one
640:12 - thing we could do is we go to
the chain link GitHub repo, and
640:16 - go through the contracts and
find one of these price feed
640:18 - addresses, source eight, or
maybe we'll go back to source
640:22 - we'll maybe we'll check in V
six.
640:26 - Looks like we could find some
stuff and look around and we
640:29 - probably copy paste all this
code, but it really seems like
640:32 - kind of a huge pain in the butt
to have to copy all this code.
640:35 - Now we absolutely could we copy
paste the code in here, but
640:38 - we're gonna do something a
little bit more clever. So the
640:40 - chainlink repo actually comes
with some mocks. If we go to
640:44 - contracts, SRC V 0.6 tests They
actually have a mock v3
640:52 - aggregator dot soul in here that
we can use as our mock. So we
640:56 - can copy paste everything, but
we'd have to revamp a little bit
640:59 - of it because it's doing some
dot dot stuff. It's talking to
641:03 - other contracts that are locally
in this file structure that are
641:06 - not going to be in our file
structure. So instead though,
641:10 - what we can do is we can use
this node modules package to our
641:13 - advantage, we can just say
pragma, solidity, carrot zero,
641:19 - point 6.0, we'll use the same
version that that package is
641:22 - doing. And then just do import
at a chain link slash contracts
641:28 - slash SRC slash v 0.6. Slash
tests slash mock, B, three egg,
641:35 - Reg, gay tore that soul. And
then we'll add, and then of
641:40 - course, we'll add spdx, license
identifier, MIT. And boom, this
641:46 - is actually all we need. If we
just import the code like this,
641:50 - remember, this is exactly the
same as copy pasting this
641:54 - contract into our project, of
course, with this path resolve
641:59 - to where it actually is in our
node modules. Now, actually, I
642:03 - can run yarn hardhat compile,
and it will also compile this
642:07 - contract. Except for of course,
we have an issue, hey, compiler
642:12 - versions don't match. Right?
What's What's up with that now,
642:15 - you're going to get into
situations where you will be
642:18 - working with contracts that are
not the same version of solidity
642:20 - as you why well because
contracts keep being deployed
642:23 - all the time. And there are a
ton of contracts that are in
642:26 - version 0.4, solidity,
0.5 0.678, and probably 910, or
642:32 - 15 billion, or however many
solidity versions will come to
642:35 - be. So in our config, in our
hard hat dot config, when you
642:38 - scroll to the bottom, we can
scroll to where we're defining
642:41 - our solidity version. And we can
actually add multiple solidity
642:45 - versions, so that our compiler
can compile multiple versions of
642:49 - solidity. To do that, we'll say,
so Lyd, did T. And we'll turn it
642:54 - into an object here, we'll make
sure to put this comma here. And
642:57 - inside our solidity object,
we'll put compilers and we'll
643:01 - have a list of compilers. Our
first one we'll say is version,
643:06 - zero, point 8.8. And we'll say
our second one is going to be
643:09 - version 0.6, point six, and then
we'll go ahead and save that.
643:15 - And it looks like mine wanted to
format it like this, which is
643:17 - fine. Now, we can go ahead,
rerun, yarn, Hardhead, compile,
643:22 - and boom, compiled five solidity
files successfully. This means
643:26 - that our Mark V aggregator
should also have been compiled.
643:29 - And if we look in artifacts, at
chain link, do indeed see this
643:34 - at chain link slash contract
slash SRC bid, and a v 0.6. In
643:38 - tests, we see this mock
aggregator dot soul, which has
643:41 - been compiled. Awesome. So now
that we have our mock contract
643:45 - compiled, we now have a contract
that we can use to deploy a fake
643:50 - price feed to a blockchain. So
how do we actually do this?
643:53 - Well, it's going to be the exact
same way that we deployed the
643:56 - Funmi contract. But we're going
to add a little if statement in
643:59 - here, we don't want to deploy
this mock contract to a test net
644:04 - or a network that actually has a
price feed on it, we could just
644:08 - do something like if chain ID
does not equal, you know, some
644:13 - chain ID, then deploy marks,
right. And then this is kind of
644:17 - pseudocode. Obviously, this code
won't actually work. But
644:19 - instead, what I like is I
actually like to specify which
644:22 - chains are going to be my
development chains, which chains
644:25 - are going to be the one that I
can deploy these mocks to, in my
644:29 - helper, hard hat config, I'll
define these chains. So I'll say
644:32 - const, development chains,
equals, and then I'll just say
644:38 - hard hat, and local host. I'll
export these. And back in my
644:45 - deploy mocks, I'll import these
with const. Development chains
644:51 - equals require dot dot slash
helper Hardhead config. And now
644:58 - I'll say if development chains
dot includes chain ID. This
645:06 - includes keyword basically is a
function that checks to see if
645:10 - some variable is inside an
array, then we're gonna go ahead
645:13 - and deploy Max, and which is
what we want to do. So we'll do
645:17 - log, which we're getting from
deployments, which is basically
645:19 - console dot log. And we'll say
local network detected,
645:25 - deploying mocks.
645:28 - And we'll do a weight ploy, and
we'll deploy our new mock v3
645:34 - aggregator mock v3 aggregator
will do a comma. There a little
645:40 - colons here. If we want to get
really specific, we can say
645:43 - contract v3 aggregator which
we're kind of already saying
645:47 - we'll say from deployer We'll
say logging is going to be true.
645:53 - And then we need to pass some
arguments, we need to pass the
645:56 - constructor parameters for the
mock v3 aggregator, which are
646:00 - what? Well, let's go to docs
chain to link to find out. Or
646:04 - you can also just go to Node
modules chainlink, SRC V 06,
646:10 - tests, and then all the way down
to mock V three, aggregated out.
646:13 - So where you could also find the
constructor in here, whatever
646:17 - one you like better, sometimes I
find it easier just to read
646:19 - GitHub Ctrl plus F or Command
plus F for constructor. We see
646:25 - it takes a decimals and an
initial answer. And if we read
646:29 - through the code, we'll learn
that the decimals object is
646:33 - going to be equivalent to the
decimals parameter is going to
646:36 - be equivalent to this decimals
function and the initial answer.
646:40 - And the initial answer is
basically just going to be what
646:43 - is the price feed starting at,
we actually get to pick the
646:45 - price of the price feed, which
works out really well, because
646:48 - that works out great for
testing. I usually like to
646:51 - define the decimals and the
initial answers somewhere
646:53 - outside of this function so that
I can access it later. One good
646:57 - place you can add it is once
again in our helper Hardhead
647:00 - config.js. So I might do const
decimals equals eight. And then
647:06 - const initial answer. Answer
equals, and we'll do 2000. So
647:15 - since we have a decimals, we'll
do 2000 And then 123456788
647:20 - decimal places, and then we'll
export these as well. Export
647:24 - decimals, and export initial
answer. We could of course, just
647:28 - do you know, const decimals
equals eight at the top and then
647:32 - initial answer and then use them
down here. But I like to do it
647:35 - like that. So Conce. So now we
have to import them in here.
647:39 - const development chains. It's
also grabbed decimals. It's also
647:43 - grabbed initial answer, we'll
save it. We'll take a look back
647:47 - at the constructor looks like
it's decimals first, initial
647:49 - answers second. So in our
arguments, we'll do decimals
647:52 - first, initial answers second,
and tada. And then we will be
647:57 - all done that we'll do a quick
log box deployed. And then I
648:01 - also like to do kind of like a
big line at the end of all of my
648:05 - deploy scripts just to be like,
hey, that's the end of this
648:08 - deploy script. Anything else
after this is going to be a
648:11 - different deploy script. All
right, great. Now our deployed
648:14 - mocks script is actually done.
But our deploy Funmi script
648:17 - isn't quite done. Is there a way
that we could run only our
648:21 - deploy mock script? Well, yes,
there is. Great, thanks for
648:25 - asking. What we can do at the
bottom of our deploy mock script
648:27 - is we can add a module that
exports dot tags, equals, and
648:35 - we'll say all and marks. Now
what we can do is if we run
648:40 - yarn, hard hat deploy, we can
add this flag dash dash tags.
648:46 - And it will only run the deploy
scripts that have a special tag.
648:50 - So we'll run our mocks tag,
which means it'll only run our
648:55 - deploy mock script. And, and
oops, actually, in our helper
648:59 - config development chains is
actually hard hat and localhost.
649:03 - And I said, we're going to try
to do with the chain ID, sorry,
649:06 - we're going to do this, we're
gonna do development chains dot
649:09 - includes network dot name.
649:15 - Because our helper config is
using names and not chain IDs,
649:19 - so if development chains that
includes that network the names,
649:23 - then we're gonna go ahead and
deploy the mocks. So let's go
649:25 - ahead and run this yarn here and
hit Deploy dash dash tags,
649:28 - mocks. And perfect we do indeed
see our mocks getting deployed
649:32 - here. This log true means that
it's going to spit out stuff
649:36 - like this. It'll say contract,
it's deploying, it'll say the
649:39 - transaction it's doing and it'll
say where it was deployed with
649:42 - how much gas and awesome This
means our deployed Mach script
649:47 - is working perfectly. So now we
have our deploy mocks script
649:50 - working perfectly. So how do we
apply that back to our deploy
649:54 - Funmi script? Well, we're gonna
do the exact same thing here.
649:57 - Instead of making eth USD price
feed address constant variable,
650:01 - we're gonna say let at USD price
you'd variable so that we can
650:04 - actually update it. And we'll
say, if development chains dot
650:09 - includes network dot name, what
we can do with hard hat deploy
650:15 - is we can just get the most
recent deployment using a
650:19 - command called literally get. So
we'll say const. eth USD
650:23 - aggregator equals await
deployments dot get. And then
650:30 - the name of the contract that we
deployed Mach v3 aggregator, and
650:34 - if you wanted to just do get
instead of deployments dot get,
650:37 - we absolutely could, just by
doing it like this. Those are
650:42 - exactly the same. So we'll get
the address like this and then
650:45 - we'll say eth USD price feed
address equals that eth USD
650:52 - aggregator contract dot address.
And then if we're not on a
650:56 - development chain, if we didn't
deploy a mock, we're just going
651:00 - to do exactly what we did
before. With using the network
651:04 - config. Oh, my goodness. Now,
now that we've done all of these
651:09 - steps, let's add a little log
thing at the bottom here with
651:13 - just a bunch of hyphens. Now, we
should have a very robust script
651:18 - to flip between a local
development chain, a test net
651:22 - chain, a main net chain, and
allow us to deploy literally
651:25 - everywhere without changing any
of our solidity. And then we
651:29 - just take this, this eth USD
price feed address and stick it
651:34 - into logs here. And then at the
bottom, we can do module dot
651:38 - exports, dot tags equals and
then we'll just do all and then
651:43 - we'll call this one Funmi. Oh,
now moment of truth. If we did
651:48 - all this, right, we should just
be able to run yarn, hard hat
651:52 - deploy. And it should work on
our local chain, our hard hat
651:57 - chain. And then it should also
work on any test net that we
652:00 - give it. So let's give this a
try. Yarn, Hardhead deploy.
652:04 - Let's see if this works.
Awesome. And we got this all to
652:07 - deploy locally to our Hard Hat
Network, we can see that we went
652:11 - ahead and we deployed mocks, we
did our little underline here.
652:15 - And then we deployed Funmi
deployed at this address with
652:18 - this much gas. Now, what are the
other awesome things about hard
652:21 - hat deploy? When we run our
local blockchain, our own
652:24 - blockchain node, hard hat deploy
will automatically run through
652:29 - all of our deploy scripts and
add them to our node. So now if
652:33 - I run yarn, hard hat node, we're
going to spin up a new
652:38 - blockchain node, but it's
already going to have all of our
652:41 - deployed contracts on it. So
every time we spin up a local
652:45 - node, now it's going to come
automatically packed with the
652:48 - contracts that we want on it. So
we are going to show us doing
652:54 - this on a test net on Rinkeby.
But before we actually test it
652:57 - on Rinkeby, I'm going to add a
little bit of the auto
653:00 - verification piece in here as
well, because we did that in the
653:03 - last lesson. And we wanted to
show how to do it in hard hat
653:06 - deploy as well. So right after
we deploy our Funmi, we can do
653:09 - something similar here, we'll
say, if developer chains
653:13 - includes network dot name, we'll
say if developer chains doesn't
653:17 - include network dot name,
because we don't want to verify
653:19 - on a local network. So we'll say
if not development chains dot
653:25 - includes network dot name, the
exclamation mark, aka the bang
653:29 - means not when we're talking
about booleans. So we're saying,
653:32 - if the name of the network isn't
a development chain, we want to
653:36 - go ahead and verify and same as
last time. And if process dot e
653:41 - NV dot ether scan API key,
653:46 - then we're going to go ahead and
verify. Now before we had our
653:50 - verify code, right in our deploy
code, we're gonna do something a
653:53 - little bit different here.
Instead of having our verify
653:56 - code in our deploy scripts here,
we're actually going to create a
653:59 - new folder called utils, which
stands for utilities. And this
654:04 - is where we're going to add
different scripts that we can
654:07 - use across different
deployments. Because let's say
654:09 - we have 50 Deploy scripts, we're
not going to make 50 Deploy
654:12 - functions, we're just going to
add them to our utils folder,
654:15 - and in our utils folder, or
create a new file called verify
654:19 - dot j s, we're going to add that
code from our last project in
654:23 - here. So if you want, you can go
ahead copy paste from our last
654:26 - project over to this one, or you
can pause the video to type it
654:30 - out yourself. Since we're using
the run command here, we're
654:33 - gonna do const run equals
require RT hat. And then at the
654:38 - bottom, we're going to do module
exports. Exports equals verify.
654:48 - Now that we have a verify script
in our utils folder, back in our
654:53 - deploy Funmi we're going to say
const. Verify equals require dot
654:59 - dot slash utils. Slash verify.
And since now in our verified
655:05 - Jas, we have a lot of this
trycatch stuff in here, we can
655:08 - just do a wait. Verify and a
verify once again takes a
655:15 - contract address and a list of
arguments. We'll say await
655:18 - verify, fund me dot address and
then the list of arguments. To
655:24 - make the list of arguments
easier to put in. You can go
655:27 - const args, equals and then
we'll just stick our eth USD
655:32 - price feed in here and then
replace this with args and then
655:37 - take this args and pop it on
down into the second parameter
655:42 - here. All right, great. Now
let's go ahead and deploy this
655:48 - to With the Rinkeby test net,
and what do we need to deploy
655:51 - this to the Rinkeby test net?
Well, let's jump into our hard
655:53 - hat config first. And let's
clean this up, we don't really
655:57 - need this accounts task, so I'm
just going to delete it, I don't
656:00 - really need this comment. So I'm
going to delete this too. And
656:03 - let's jump into the network
section, we're not going to be
656:06 - working with ropsten. So we're
gonna go ahead and dump that. We
656:09 - are however, going to be working
with rink B, the URL is going to
656:13 - be that same Rinkeby RPC URL. So
we're going to define that up
656:18 - here, like we did before. And if
you want to copy paste from your
656:21 - last project, feel free to do so
you can also follow along with
656:25 - me or fastforward me the counts
is going to be the same. I'm
656:38 - going to go ahead and just copy
paste the gas reporter with what
656:41 - we had from before. So we're
going to add this constant corn
656:44 - market cap API key equals
process dot EMV dot corn market
656:49 - cap API key. Do the same thing
with the ether scan API key
656:53 - Licious add everything in here.
Now. We have our ether scan
657:00 - section in here already, we're
gonna have our gas reporter be
657:04 - false, because I don't really
feel like using it right now.
657:07 - And then finally, we're going to
add one more thing in here.
657:10 - Remember how in our last
project, before we actually
657:12 - verified we waited some block
confirmations. That way ether
657:16 - scan could make sure to catch
up. Well, we can do the exact
657:19 - same thing in here in our hard
hat dot config, we can add a
657:22 - section for each test net for
how many blocks we want to wait,
657:26 - I'm going to add block
confirmations of six. Now back
657:33 - on our deploy Funmi. In a new
section, I can add wait
657:37 - confirmations of network dot
config. That block on for
657:47 - motions, or one is or one means
if no block confirmations is
657:53 - given in our Hardhead dot config
will just wait for one block.
657:57 - And again, the reason we want to
wait for approximately six block
657:59 - confirmations is we want to give
ether scan a chance to index our
658:03 - transaction. And I added a chain
ID 42 when it should be for my
658:07 - mistake. And of course, we're
going to need our dot env file,
658:11 - where we add all of our stuff
from the last session, the RIP
658:14 - ERP CRL private key ether scan
API and then coin market cap
658:18 - API. All right moment of truth.
Let's try this out. If we run
658:23 - yarn Hardhead deploy dash dash
network Rinkeby. It should not
658:30 - deploy any marks because we have
this if statement in our mock
658:34 - deployment. But it should deploy
our Funmi contract using the
658:39 - correct price feed address. And
then it'll go ahead and verify
658:43 - it. Since we're waiting for six
block confirmations, we can even
658:47 - be super secure by adding dash
dash tags and just running the
658:51 - funding tag. But we're just
going to do yarn hearted deploy
658:55 - network Rigby. And let's see
what happens. All right, and
658:59 - we're deploying funding. And we
can see the transaction that we
659:03 - have for fun me, this is that
logging feature, we have log is
659:08 - true for deploying Funmi. So it
gives us the transaction once it
659:12 - has a transaction, and it will
give us the address once we have
659:16 - the address. So we're going to
wait six block confirmations for
659:20 - this transaction to finish going
through. Now we see we've
659:23 - deployed this contract address
with X amount of gas. And now
659:27 - we're running the verification
process. While the verification
659:30 - process is running, we can pull
up Rinkeby ether scan, paste our
659:35 - address in here and see that we
have indeed created this
659:39 - contract. And now it looks like
we've successfully verified the
659:42 - contract on ether scan. So if we
hit refresh, we can indeed see
659:46 - that the contract has been
verified. Awesome. All right. So
659:50 - this is fantastic. Our deploy
script is looking great, we're
659:53 - able to deploy to a local chain,
we're able to deploy to a test
659:57 - that and if we wanted to, we
could deploy to any network that
660:00 - we wanted simply by updating our
hard hat config, and then
660:03 - updating our helper config. This
is fantastic.
660:07 - Great work so far. Now we're
about to jump in and level up
660:13 - our tests. But before we do
that, we're going to clean up
660:16 - our Funmi contract a little bit
to make it look a little bit
660:19 - more professional. And I'm going
to talk about some of the syntax
660:22 - and some of the reasons why some
conventions exist. We're not
660:25 - going to do this full force on
all the projects moving forward.
660:29 - But they are good to know and
they are good to keep in mind
660:31 - when moving forward and working
with our contracts. While we go
660:35 - through this we're going to
learn why some of these
660:37 - conventions exist including
learning a little bit of low
660:40 - level solidity. So don't skip
this part. When we get to later
660:43 - sections. We're going to be a
little bit looser and not be as
660:46 - strict with the code style
guides but That's basically what
660:49 - we're gonna go over now. And for
now, you might see this event
660:52 - funded thing here, please just
ignore that for now, in an
660:55 - earlier take, I'd introduced the
events much earlier. And now
660:58 - we're actually going to learn
about events a little bit later
661:00 - in the course. So please ignore
that event funded for now. So
661:04 - let's go ahead and tweak a
little bit of our contracts
661:06 - here. Now what I'm talking about
tweaking this to make it look
661:08 - professional, a little bit more
professional, I'm talking about
661:11 - the solidity style guide, there
are some conventions for naming
661:14 - and ordering that we can follow
to make our code look a little
661:17 - bit better. Now, like I said,
this is going to be a little bit
661:20 - more optional, because it can be
a little bit verbose. And it
661:23 - doesn't really make that big of
a difference. But it can
661:26 - increase readability of your
contracts by a lot and make your
661:29 - code look a lot nicer. So if you
want, you can go through this
661:33 - style guide to learn more about
what kind of makes solidity look
661:36 - nice, and what makes it not look
nice. But well, that's some of
661:39 - these style guides in here,
we're not going to follow the
661:41 - style guide exactly to a tee.
But we are going to make some
661:44 - best efforts to make our code
follow the style guide, we've
661:47 - got a link to the style guide in
the GitHub repository for this
661:50 - section, we can read some more
about the layout. But the main
661:53 - thing we want to look at is this
order of the layout, we want to
661:55 - start with our imports with our
pragma statement, our imports,
661:59 - interfaces, libraries, and then
contracts. And then inside each
662:02 - contract type declarations,
state variables, events,
662:05 - modifiers, and functions. So
let's go back here and make sure
662:08 - that we're up to speed, we want
our pragma first. Alright,
662:12 - awesome, we did exactly that,
then we want our imports. Okay,
662:16 - awesome, we have those too.
Something that's not in the
662:19 - style guide is going to be error
codes, which we definitely want
662:22 - next. So next is going to be
error codes. Now this is where
662:27 - we're going to bump into one of
our first updates here. As of
662:30 - recent, it's sort of becoming a
best practice to add the name of
662:34 - your contract, some underscores,
and then the name of your error.
662:38 - Whenever you're running into an
error. This makes it a lot
662:40 - easier to understand which
contract is throwing the error.
662:44 - So for this, we're going to say
error Funmi, two underscores not
662:48 - owner, then we're going to
scroll down to the our revert
662:52 - and set it like this. This way,
when if we ever run into this
662:56 - error, we know that the error is
coming from the Funmi contract,
662:59 - not from the aggregator v3
interface, or the price
663:01 - converter or some other
contract. So that's how we want
663:05 - to write our error codes here.
If we had any interfaces or
663:07 - libraries not imported, we would
add them here. But then finally,
663:11 - we add our contracts. In this
file, we only have one contract
663:15 - here. It's our Funmi contract.
Awesome. Now the next thing we
663:18 - want to learn about as far as
style guides go is this thing
663:21 - called natspec. natspec stands
for Etherium natural language
663:26 - specification format. And it's
basically a way of documenting
663:30 - our code inspired by Doxygen
uses Doxygen style comments and
663:34 - tags to help document our code,
you can click the link here in
663:38 - the solidity documentation to
learn more about Doxygen. If we
663:41 - scroll down in the
documentation, here, we can see
663:43 - an example of using natspec.
Whenever we have a contract or a
663:47 - function that needs
documentation, we can add some
663:50 - syntax that looks like this to
it. So for example, if we wanted
663:53 - to add this to our code, we
could add a comment explaining
663:57 - this funding contract to start a
piece of natspec, you can do
664:00 - three backslashes, or one
backslash, two stars, and then
664:05 - another ending star here.
Everything we put inside of this
664:09 - comment section basically gets
turned into a comment. For the
664:12 - start of our contract, we'll do
the Add sign title to explain
664:15 - basically, what this contract
is, it's fun, we contract is
664:18 - going to be a contract
664:20 - for crowdfunding, we'll add
another star. And we can add the
664:27 - author of it, which is going to
be your name, I'm going to put
664:31 - Patrick Collins, of course, then
we'll add a notice, which is
664:35 - just kind of a note to people we
can say this contract is is to
664:39 - demo a sample funding contract.
And we can also add apt Dev,
664:46 - which is a note specifically to
developers. And we can say this
664:50 - implements price feeds as our
library. The reason that we want
664:54 - to add these tags here is
actually because we can use the
664:58 - natspec to automatically create
documentation for us if we
665:02 - download so we can actually run
solc dash s user doc dash dash
665:06 - dev doc, and the name of our
file to automatically generate
665:10 - documentation. So this is also
really helpful for automatically
665:13 - creating documentation for other
developers who interact with the
665:16 - protocol later on. You can use
this natspec For as many or as
665:20 - few functions as you'd like.
Most of us probably aren't going
665:23 - to be making documentation. So
we really just want to follow
665:26 - those guidelines if we think
some function or some section of
665:29 - our code is a little bit tricky
for other developers. Now that
665:32 - we're inside of contract, we can
follow the order of our
665:34 - contract. We're first going to
start with type declarations
665:41 - which we don't really have any
except for the fact that we're
665:43 - using our price converter for
the UN 256 type. Okay, great.
665:48 - You Next, after our type
declarations, we're going to do
665:51 - state variables. And in this
state variables section, this is
665:54 - where we're actually going to
change the name of some of our
665:57 - state variables. So we'll do a
little common here state
666:00 - variables. Now in the solidity
style guide, kind of adhere to
666:04 - the naming styles, we use upper
and lowercase, we use total caps
666:08 - with underscores here. However,
these naming variables are going
666:12 - to change in the future in this
section. And if you're following
666:14 - along with the GitHub repo
associated with this course,
666:17 - these are going to be actually a
little bit different than what
666:19 - you see. However, for now, we're
going to leave them as they are,
666:22 - because the reason why we're
going to change them isn't going
666:24 - to be quite clear yet. Don't
worry. So these names are going
666:27 - to change soon, but not yet.
Alright, after state variables
666:31 - comes events, and modifiers. We
don't have any events, but we do
666:34 - have a modifier. So we'll copy
this. And actually, we'll delete
666:39 - this comment here. And we'll
paste our modifier here. Oh, and
666:46 - it looks like looks like we're
not auto formatting here. So
666:50 - we're going to uncomment
immutable actually, so that it
666:52 - automatically auto formats.
Okay, great. We're out of
666:55 - formatting now. And Cool.
Alright, so now we have our
666:57 - modifiers. Next, we have right
here, and then we have all of
667:01 - our functions. Great. We
actually want to group our
667:05 - functions in this order that I
just print here. So we want the
667:08 - constructor which we have
received and fall back, we do
667:11 - have fall back and receive. So
we're going to actually copy
667:14 - those and delete this comment.
We're gonna stick those veterans
667:20 - Heath here looks like receive
goes first. So we'll put that
667:24 - here. Then external functions,
then public, internal, private.
667:29 - So we have public public. And
that's it. And then we can
667:32 - delete this part down here.
Okay. Cool. And if we want, we
667:36 - can do that syntax up here from
the net spec for our functions.
667:40 - For example, for fund it, we
could even just copy paste, we
667:44 - would remove title, we would
remove author, and we just say
667:48 - add, notice, this function,
funds this contract. And we can
667:55 - even leave a little dev thing
here to talk about it. Now if we
667:58 - have parameters, you can do apt
puram. And say like what the
668:02 - parameter is. And then if we
have returns, we can say
668:06 - returns, or returns and then
what it returns for the
668:10 - documentation. Since this
doesn't have any parameters in
668:13 - here, and doesn't return
anything, we can just leave it
668:15 - like this. And great, we've just
revamped our contract here to
668:18 - make it a little bit more nicely
formatted. Great job. Now, like
668:21 - I said, we actually are going to
change the names of our state
668:24 - variables, and we're going to
add some functions in here and a
668:26 - little bit. So if we're
following with the GitHub repo,
668:29 - the state of the contract right
now is going to look a little
668:31 - bit different. But it'll make
sense why change this up in a
668:34 - little bit.
668:37 - Alright, so now that we've
cleaned this up, we've got to
668:40 - deploy marks, deploy Funmi.
Let's go ahead and start writing
668:43 - some tests. And after we write
these tests, we're actually
668:46 - going to run that gas estimator
and using that gas estimator,
668:50 - we're gonna go back, and we're
going to update this contract
668:52 - one more time to make this even
cheaper to use and work with.
668:56 - And remember, that's going to be
one of the advantages of writing
668:58 - these tests is how we can
optimize our contracts to be
669:01 - even faster, more gas efficient,
etc, we want to make sure that
669:05 - we write really good tests, and
this is going to be one of our
669:08 - first jumps into these more
professional test setups. So
669:13 - we're going to jump into our
test folder, we're going to
669:14 - delete this sample test.js. In
our last section, we went over a
669:19 - really minimalistic test, which
is great. However, when we get
669:22 - bigger and bigger projects,
we're going to want to start
669:24 - testing more and more different
things, we're going to get more
669:28 - and more into at least two
different types of testing. So
669:31 - if we cd into our test folder,
we're going to make one
669:33 - directory called staging. And
then we're going to make another
669:37 - directory called unit. And now
if we look in our test folder,
669:41 - we now have a staging folder,
and a unit test folder. Now
669:44 - we're going to talk about two
different types of tests. The
669:47 - first one is going to be
something called a unit test.
669:49 - Now what is a unit test? Unit
testing is a software testing
669:53 - method by which individual units
of source code are tested.
669:56 - Basically, what we want to do is
in our contracts, we want to
670:00 - test minimal portions of our
code to make sure that they work
670:03 - correctly. Then once our small
pieces of the test work, we want
670:07 - to do a staging test or maybe an
integration test. This might be
670:11 - where we run our code on a test
net or some actual network. You
670:15 - can think of a staging test,
it's kind of the last stop
670:17 - before you deploy to a main net.
They're not always 100%
670:21 - necessary, but they can be
really, really helpful.
670:24 - Remember, we do want to be
conscientious of how much we use
670:28 - our test nets, but we absolutely
would 100% want to make sure
670:32 - that everything works locally
and that we unit test and we run
670:35 - all of our code locally. Then we
can use staging tests on an
670:39 - actual test net to make sure
that our code will work with
670:43 - actual other contracts. Now unit
tests can be done with local
670:48 - Hard Hat Network or a forked
Hard Hat Network, we'll talk
670:52 - about this for tar Hat Network
very soon, right, now, let's
670:55 - build these unit tests, these
unit tests are going to be
670:58 - basically what we saw in our
last section. So let's go in and
671:02 - let's jump in and write some of
these unit tests. So let's
671:04 - create a new test, we'll call it
on me dot test dot j, s. And
671:10 - we'll start making our tests in
here. Now, we did test
671:13 - previously in our last section,
but our tests here are going to
671:15 - look a little bit differently,
we're actually going to use
671:18 - hardhat deploy, to automatically
set up our tests as if both of
671:22 - these deployed functions had
been run. So let's go ahead and
671:24 - get this started. So we're still
going to do that same setup that
671:27 - we're gonna do describe, we're
gonna say fund me. And this is
671:32 - going to have that async
function like so. And in here,
671:41 - we're going to have a before
each, and we're going to have
671:46 - some hits and some describes and
everything. Now since we want to
671:49 - unit test this, we're gonna go a
little bit heavier on the test
671:52 - here, and then with our last
project, but in the future,
671:54 - we'll go a little bit lighter
with some of the tests. So let's
671:57 - get started. If we run yarn
Hardhead test right now, we're
672:02 - gonna get zero passing. Now, if
we run yarn hardhat coverage,
672:08 - we're gonna get something that
looks like this, saying, Hey,
672:11 - you're missing a lot of stuff.
So let's try to cover some more
672:15 - lines with our tests. And one
way we can do that is actually
672:18 - we can group our tests based off
of different functions. So let's
672:22 - have our first set of tests be
around our constructor. To do
672:26 - that inside of our first
describe, we can add another
672:29 - describe, have this describe the
just the constructor, this
672:34 - larger scope will be for the
entire Funmi contract. And
672:37 - everything inside this one will
just be for the constructor. So
672:41 - this will also be an async
function. And these tasks will
672:45 - be just for the constructor. But
before we even work on this
672:48 - describe, we probably want to
deploy our Funmi contract. So
672:51 - let's learn how to do that. So
we'll do a before each, which
672:54 - will be an async function. And
we're going to deploy our Funmi
673:00 - contract using hard hat deploy.
Since we use hard hat deploy,
673:06 - our Funmi contract will come
even with our mocks and
673:09 - everything. So above the before
each,
673:11 - let's do let me HDMI. And then
here, we're going to deploy
673:18 - Funmi, where we're going to
deploy our Funmi contract is
673:21 - first by pulling in our
deployments object from Harnett
673:24 - deploy. So we'll do const
deployments equals require
673:29 - hardhat. And this deployments
object has, has a function
673:33 - called fixture with fixture does
is it allows us to basically run
673:38 - our entire deploy folder with as
many tags as we want. You'll
673:41 - notice I added this alt tag in
both of our scripts. This means
673:46 - that in this deployment stuff
fixtures, it's gonna be a wait
673:49 - deployment of fixtures. If I run
away deployments dot fixture,
673:53 - I'll run through our deploy
scripts on our local network and
673:56 - deploy all of the contracts that
we can use them in our scripts
674:00 - and in our testing, and we can
deploy everything in that deploy
674:03 - folder with just this one line.
isn't that helpful. Now, once
674:07 - all of our contracts have been
deployed, we can start getting
674:09 - them will say fund me equals
await ethers, and we'll pull an
674:15 - ether some hard hat as well. dot
and this is where hard hat
674:20 - deploy is helpful. Again, hard
to deploy rapt ether is with a
674:25 - function called Get contract,
this get contract function is
674:29 - going to get the most recent
deployment of whatever contract
674:32 - we tell it. So we'll say get
contract of fun to me. So this
674:36 - will give us the most recent Lee
deployed Funmi contract in just
674:40 - this one line. And now Funmi
will be equal to this line here.
674:45 - Now we're going to make a bunch
of transactions on our Funmi. To
674:48 - test it. Of course, we can also
tell ethers which account we
674:52 - want connected to fund me. So I
can say const deployer equals
674:57 - goes away get named accounts,
exactly like we did in our
675:03 - deploy scripts. And then we just
need to import it from our tap
675:06 - in our deploy scripts we
imported get named accounts
675:10 - inside of our input parameters
for our deploy function.
675:14 - Remember getting named accounts
and deployments was abstracted
675:17 - from if we look up here, from
the hard hat runtime
675:20 - environment, and like I said,
the hard hat runtime environment
675:23 - is basically the same thing as
hard hat. So we can just go
675:25 - ahead and import it like this,
actually like this. Because we
675:29 - actually need to abstract just
the deployer from getting named
675:32 - accounts. And now what we can do
is we can connect our Deployer
675:36 - to our Fund Me account. So
whenever we call a function with
675:39 - fund me, it'll automatically be
from that the player account,
675:43 - which is great. Another way you
can get different accounts
675:46 - directly from your heart had
config. Is you could take const
675:49 - accounts equals await ethers dot
get signers, ethers dot get
675:55 - signers is going to return
whatever is in this account
675:58 - section of your network. If
you're on your default network
676:01 - hard hat, it's going to give you
a list of 10 fake accounts that
676:04 - we can work with you then of
course, can do something like
676:06 - const. Account one equals
accounts. More correctly would
676:12 - be account zero equals account
zero and work like that. We'll
676:16 - leave that comment that out,
just in case you need a
676:17 - reference to it in the future.
Okay, great. So now we have our
676:20 - Funmi contract. Let's go ahead
and write some tests for testing
676:23 - the constructor. And we're
probably going to want to use
676:25 - this deployer object down here.
So we'll do let deployer above.
676:30 - And we'll do something a little
finicky here. But we'll say
676:33 - deployer equals Wait, get named
accounts, dot Deployer. And
676:39 - we'll just wrap this up so that
we can just grab this deployer
676:42 - object and assign it to declare
like so. Now in here, we'll
676:45 - create our first test, we'll say
it will say it sets the Agra
676:50 - Gator addresses correctly. Comma
will have this be an async
676:56 - function. And we'll say const
response equals await fund me
677:03 - dot, let's get this price feed
here, fund me dot price feed.
677:08 - And then we'll want to make sure
this price feed is going to be
677:10 - the same as our Mk V three
aggregator since we're going to
677:14 - be running these tests locally.
So we should get our mark three
677:18 - V three aggregator up top. Let's
do let mock v3 aggregate store.
677:25 - And we'll grab this address the
same way mockbee Three
677:27 - aggregator equals await ethers
dot get contract mockbee Three
677:34 - aggregator comma, we'll connect
this one to the deployer as
677:37 - well. So we'll want to say cert
dot equals cert dot equal
677:44 - response comma lock v3
aggregator dot address. And of
677:50 - course we'll want to say const.
Assert equals require gy. Import
677:58 - that from DJI. Okay, cool.
678:00 - Now, let's go ahead and try this
out. Yarn hardhat. Test. Oops, I
678:05 - spelled response wrong. Let's
try that again. Awesome. So this
678:10 - means that we are indeed
assigning the price feed address
678:14 - correctly to the Mach v3
aggregator. Okay, great.
678:18 - Awesome. I think for now, that's
all we really want to do for our
678:21 - constructor. Now these two are
kind of a nice to have, I showed
678:24 - them more just to kind of demo
what they look like, we're going
678:26 - to skip writing tests for them
for now. And we're actually
678:29 - going to go ahead and delete
them directly from the contract.
678:32 - If you want to go ahead and
write some tests for them and
678:34 - leave them in your examples for
your learnings. You absolutely
678:36 - can pause the video and write
some tests for it if you choose
678:39 - so, but we're going to skip
them. Next though, we are going
678:42 - to move on to fund and running
some tests for fun here. So
678:46 - let's go ahead and write
describe fund. This will be an
678:49 - async function. And in here,
we're going to do a number of
678:55 - tests. So if we're going to go
line by line here, what's the
678:58 - first thing that we should look
at? Well, we should look at this
679:01 - require line we should write a
test to see if this contract
679:04 - actually does fail? If not
enough, eath is sent. So let's
679:09 - go ahead and we'll say it fails,
if you don't send enough eath
679:17 - have this be an async function?
Now, how do we test to see if
679:23 - something fails? Right now we've
done assert equals, but if
679:26 - something fails, we might run
into an issue. So for example,
679:30 - if I run await fund me dot fund,
but I don't pass any value to
679:36 - this transaction. Let's see what
happens. I run yarn Hardhead
679:39 - test. Well, our test is actually
going to break VM exception.
679:44 - While processing transaction
reverted with reason string, you
679:48 - need to spend more eath. So our
tests are going to break which
679:51 - is good. We want this to break.
But we want to tell our test
679:56 - that this is okay. Right? Want
to tell that this is okay. So
680:00 - the way we can do this, and this
is where our waffle testing
680:04 - comes into play. With waffle and
with testing, what we can
680:07 - actually do is we can use the
expect keyword and expect
680:11 - transactions to be reverted and
for transactions to fail. So
680:15 - instead of using assert here,
we're actually going to run a
680:18 - wait expect fund me dot fun 2.2
dot B, that reverted and we've
680:28 - actually even be more specific
here by saying to be reverted
680:31 - with and then the exact reverted
error, you need to spend more
680:37 - eath. Now if we run our tests,
oops expect is not defined. So
680:42 - we need to import that from
Chai. Which chai is being
680:47 - overwritten by waffle, we see
that it does indeed Pass, which
680:52 - is perfect. So now we have a way
to both assert things and expect
680:57 - things to fail. Awesome, even
with the specific failure codes.
681:01 - Perfect. Let's write some more
tests here. Well, we probably
681:04 - want it to correctly update this
data structure. So we could say,
681:09 - it updates the amount funded
data structure, it's going to be
681:16 - an async function. In here,
we're going to need to call fund
681:20 - v dot fund. However, we're going
to need to actually pass some
681:25 - value with this transaction. And
for now, we'll just hard code
681:29 - the value that we're going to
send, say const. Send value is
681:34 - going to be
112345 678-910-1234 5678, which
681:40 - is going to be one eath. Another
way we can write this though, is
681:43 - we can use the ethers utility to
make this a little bit easier to
681:46 - read. Because all those zeros
are kind of confusing, and it's
681:49 - hard to tell at first glance
what this actually is. So we're
681:52 - gonna actually use ethers dot
utils dot parse ether, one, this
682:01 - parse ethers utility converts
this one into that one with 18
682:05 - zeros, which makes life a lot
easier. If you go to the ethers
682:08 - documentation, there's also a
parts units function where you
682:11 - can actually convert any unit,
either ethers or Gwei. Or really
682:16 - whatever you want to do, you
could convert any number to any
682:19 - other Aetherium you type. So
this is the set value that we're
682:22 - going to use for our fund. And,
and this is definitely going to
682:25 - be more than our minimum USD of
50. So after we call this fun
682:30 - function, we'll say const
response is going to be equal to
682:34 - a weight, fund me dot address to
Mt funded address to Mt funded
682:41 - for the deployer dot address.
Because remember, this is a
682:45 - mapping of each address and how
much they've actually funded. So
682:49 - if we use the deployer address,
it should give us the amount
682:52 - that we actually sent. So now we
can run assert dot equal
682:57 - response.to string, right,
because this response is going
683:00 - to be the big number version of
how much has been funded by that
683:04 - account. And that should be the
same as our send value.to
683:08 - string. Since send value, our
one should be the exact same as
683:14 - the amount that we funded, we
can run just this one test, or
683:17 - running yarn, art hat, test,
dash dash grep. And we'll put
683:23 - this in quotes allow funded for
this amount funded line. And it
683:28 - looks like we ran into an issue
here, because we don't need to
683:32 - do deployed at address, we can
just do deploy here. And great,
683:36 - it looks like we are indeed
passing. Now if we even run yarn
683:40 - Hardhead coverage will now see
we've got at least a little bit
683:44 - more coverage here. It's still
not going to be great. But we
683:47 - have much better coverage. We
have some statements, some
683:50 - branches, and at least some
functions covered. So this is
683:53 - awesome. Let's keep going. Are
we all done testing our fun
683:56 - function? Well, probably not.
What else can we do with our fun
684:00 - function? Well, we're also
adding funders to a funders
684:03 - array. So let's go ahead and
test for that. So it adds funder
684:09 - to array of funders has been an
async function. And we'll say
684:17 - await fund mean that fund value
is going to be send value. We'll
684:23 - say const response equals await
fund me dot calling the funders
684:30 - array at index zero. So this
will be funder equals await fund
684:38 - me dot funders zero. And then
we'll say assert dot equal
684:42 - funder should be the same as the
Deployer. So let's go ahead and
684:46 - run this test. We'll hit up a
couple times. And we'll change
684:49 - the GREP to under to array so
that it looks for this line. And
684:56 - perfect. It looks like that one
is also passing. Great. So the
685:00 - money's coming through, the
minimum amount is coming through
685:03 - and our data structures are
being updated. Awesome. Now we
685:07 - could be a little bit more
verbose and do even more testing
685:10 - with this fun function. But I
think for the most part, we've
685:12 - got the gist, right. So now
let's go ahead and move on to
685:16 - the withdrawal function. So
we're going to create a new
685:18 - describe or withdraw. This is
going to be an async function.
685:26 - And let's see what the
withdrawal function does. Only
685:29 - the owner of the contract is
going to be able to get the
685:32 - balance, get the money back. And
we're also going to reset all of
685:36 - the amounts that each one of
these users is done. So let's go
685:39 - ahead and do some withdrawing.
Now in order for us to test
685:42 - withdraw, we probably first want
the contract to actually have
685:47 - some money and so what we can do
actually is we can add another
685:51 - before each in the describe to
automatically fund the contract
685:55 - before we run any tests. So we
can say before each async
686:01 - function. We can say await, fund
me dot fund. Value, send value.
686:10 - Now for all of our tests in this
withdrawal scope, we're first
686:14 - going to fund it with eath.
Let's say it can withdraw,
686:19 - withdraw eath. From a single
founder, this would be an async
686:26 - function. And this is going to
be a little bit longer test. So
686:32 - I'm going to set it up to be an
arrange, act and assert test. So
686:39 - arrange act assert is just sort
of a way to think about writing
686:42 - tests, you want to arrange the
test, then you want to act. And
686:45 - then you want to run the
asserts, and you'll see what I
686:47 - mean in just a second. So we're
going to arrange this test,
686:50 - we're going to set this test up,
we want to actually check that
686:53 - we're correctly withdrawing the
ether from a single founder. So
686:56 - first, we're going to get the
starting balance of the
686:59 - fundraising contract and the
starting balance of the
687:01 - Deployer. So we'll say const.
Starting under me, balance,
687:09 - equals await, fund me dot
provider, dot get balance, fund
687:16 - me dot address. So we're gonna
start with the balance of the
687:20 - fund V contract after it's been
funded with some eath. And we're
687:24 - also gonna get costs start
starting, deploy your balance
687:30 - goes await, fund me dot
provider, dot get balance of
687:38 - deployed employer.
687:39 - So we're getting the starting
balance of the Funmi, we're
687:42 - getting to the starting balance
of the employer so that we can
687:44 - test later on how much these
numbers have changed based off
687:48 - of what happens when we call the
withdrawal function. Now that
687:50 - we've done a little bit of
setup, we can actually run this
687:53 - withdrawal function, we can do
the act here. So we're gonna say
687:56 - const, trans action response
equals await, fund me dot
688:02 - withdraw. And then we can say
const, transaction receipt
688:11 - equals await transaction
response. That Wait, one, and
688:19 - now we should be able to check
to see that the entire fund
688:22 - rebalance has been added to the
deployer balance. So now we can
688:26 - say const ending fund me balance
equals a weight on me that
688:33 - provider dot get balance of
Unreal dot address. Then we can
688:41 - say const ending deployer
balance equals await, fund me
688:49 - dot provider dot get balance
688:54 - of Deployer. And now we can just
check to see if the numbers work
688:59 - out here.
689:00 - So we can say assert dot equal
ending fund me balance is going
689:09 - to be zero, right, because we
just withdrew all of the money.
689:13 - So ending funding balance should
be zero. And we'll say assert
689:17 - dot equal starting fund me
balance plus starting deployer
689:25 - balance. So the starting funds
the balance plus the starting
689:30 - employer balance should equal
the ending employer balance.
689:34 - Since we're grabbing whatever
the starting deployer balance
689:37 - started with plus the starting
fund to be balanced, because we
689:40 - just withdrew all of the
starting fund, we balance that
689:43 - should equal the ending deployer
bots. Now a couple of notes
689:46 - here, since starting Funmi
balance is calling from the
689:48 - blockchain, it's going to be of
type a big number, we want to
689:52 - use big number dot add actually,
instead of the plus sign here,
689:56 - just because it'll it'll make
working with our big numbers a
689:58 - little bit easier. So instead of
starting Funmi balance, plus
690:02 - we're gonna be starting from the
balance dot add. Like that. And
690:06 - that should be good. One other
thing about this, though, is
690:09 - that when we called withdraw our
Deployer did what our Deployer
690:13 - spent a little bit of gas. So
this actually isn't accurate. We
690:20 - actually also need to calculate
in the gas cost, so we wouldn't
690:24 - need to do dot add gas cost.
We'd also have to do.to string
690:29 - because big numbers are objects
and so identities a little bit
690:34 - weird. So to test to see if
they're equal, we'll just make
690:37 - them both strings. Now we don't
have gas costs. So let's figure
690:44 - out how to get the gas cost from
this transaction. So we can add
690:48 - it to Are any deployer bounce,
so we can run this assertion
690:51 - here. So what we can do is we
can actually find the gas costs
690:54 - from our transaction receipt.
And I'm going to show you a
690:57 - couple of phenomenal tricks you
can use with VS code. And if
691:01 - using a different editor, then
don't worry too much about this.
691:04 - What we can do in VS code
actually is create something
691:07 - called breakpoints. unverified
breakpoint file is modified to
691:11 - please restart the bug session,
or let's put it right here, put
691:14 - it right in this line after
transaction receipt is created.
691:17 - But before ending Funmi belts,
what this breakpoint does is it
691:21 - stops the script at this line,
and allows us to drop into
691:25 - something called a debug console
and see all the variables that
691:30 - are happening. At this time, we
want to look at the transaction
691:33 - receipt and see if the total gas
cost is in there. This is also
691:37 - incredibly helpful for dropping
into tests and dropping into
691:40 - scripts and seeing exactly
what's going on that's wrong. So
691:44 - what we can do is we can move
down to this run into bug
691:47 - section. And if it's not there,
you can hit additional views.
691:50 - And we can click this JavaScript
Debug Terminal, which will
691:54 - create a new terminal in our
terminal section. Now, what
691:58 - happens here is if we run yarn,
hard hat test, it'll run our
692:03 - testing and everything. But when
it hits this breakpoint, it'll
692:06 - stop. Currently, there is no gas
cost. So we're just going to
692:09 - delete this for now. So that we
compile and we work in
692:11 - everything. But if we run yarn
Hardhead test, see, it's gonna
692:17 - say debugger has been attached
to start running our tests. And
692:21 - it's going to stop on this line
here. And if we look in this
692:25 - variable section on the left
hand side, we can actually see a
692:29 - ton of the variables that are in
here. And we can read a little
692:34 - bit more about what's going on.
And if we go over to our debug
692:37 - console, we can type in things
like transaction receipt, and we
692:44 - can see a ton of information
about that transaction receipt
692:47 - object, what we're looking for
is we're looking to see this
692:50 - transaction receipt, which we
could look in the debug console
692:53 - or over here, if there's
anything to do with gas in here.
692:57 - And it looks like there is
there's a gas used big number.
693:01 - And there's also an effective
gas price. So the amount of gas
693:05 - used times the gas price is
going to give us all the money
693:09 - that we paid for gas here. So
now that we've figured out
693:13 - there's a gas used and effective
gas price variables in this
693:17 - transaction receipt, which we
could have also found in the
693:20 - documentation here. However,
sometimes it's even quicker just
693:23 - to find it out yourself what we
can do, we can exit the debugger
693:27 - by clicking this little thing
here. Go back to terminal will
693:32 - trash can the JavaScript
debugger, we'll remove the
693:35 - breakpoint. And we'll grab those
two variables we can pull them
693:42 - right out of that transaction
receipt object by typing const.
693:48 - Yes, used comma effective gas
price equals transaction
693:55 - receipt. So again, with this
curly bracket syntax, we can use
693:59 - this to pull out objects out of
another object. And now that we
694:03 - have these two objects, we can
create a const gas cost or total
694:08 - gas cost is going to be equal to
the gas used times the effective
694:13 - gas price. Which again, since
these are both big numbers, we
694:17 - can use a big number function
called dot mol to multiply them
694:23 - together. Now that we have this
total gas cost, we can come down
694:27 - and we can say the ending
deployer balance plus that gas
694:32 - cost to string. Now the two of
these should be equivalent. I
694:36 - know there's a lot of math that
we're doing in this section and
694:39 - a lot of new things. So I want
to just quickly rego over what
694:42 - we just learned. So first off,
the font of the contract comes
694:46 - with a provider, we could have
also done ethers dot provider
694:49 - dot get balance, but we're using
fun v dot provider because we're
694:52 - using the provider of the Funmi
contract. It doesn't really
694:55 - matter what we use here. We just
wanted to use this get balanced
694:58 - function of the provider object
which gets us the balance of any
695:02 - contract. We do the same thing
with starting deplore balance.
695:06 - The reason that we needed the
starting balances is because we
695:08 - wanted to compare it to the
ending balances to see if all
695:11 - the money went to the right
places, we then call the
695:13 - withdrawal function. And from
the transaction receipt, we
695:17 - grabbed the gas used and the gas
price. If you want to debug your
695:22 - JavaScript code, you can add a
breakpoint like so go to run
695:26 - into bug, open your debug
JavaScript terminal, which is
695:30 - different from your regular bash
terminals. And when you run
695:35 - JavaScript commands in here,
they will stop where your
695:38 - breakpoints are. Then you can
read the different variables and
695:40 - see where different things are.
Using that knowledge. We pulled
695:43 - out the gas use and effective
gas price from the transaction
695:46 - receipt and used it to get the
total gas cost of this
695:49 - transaction, we then got the
ending fund, we balanced the
695:52 - ending deployer balance, and
used all those variables to make
695:55 - sure all the money went to the
right places. And we, we can
695:59 - check this by running yarn
Hardhead test dash dash grep
696:05 - withdraw eath in quotes, since
there's a space here, and we can
696:09 - see that our test does indeed
pass. Great job. If we didn't
696:14 - add the gas cost here, and we
just did.to string, we would see
696:19 - something like this, we would
see that the numbers are ever so
696:25 - slightly off, because we're not
anticipating we're not
696:28 - calculating the gas here. So we
always want to make sure we're
696:31 - using the gas if we're doing
calculations like this. Now
696:36 - another incredibly powerful
debugging tool that we're not
696:39 - really going to go over here.
But it's important to know about
696:41 - because it can be really helpful
is that you can actually use
696:43 - console dot log in your solidity
with hard hat. If you're inside
696:48 - of a heart hat project, you just
import hard hat slash console
696:51 - dot soul. And then right in your
solidity, you can do console dot
696:56 - log, and then type pretty much
whatever you want. When you
696:59 - execute these functions, similar
to how we do a console dot log
697:02 - in JavaScript, those will
actually console dot log out to
697:05 - your terminal. Here's an example
of if you run yarn, hard hat
697:09 - test and you have those console
dot logs, you'll see stuff like
697:12 - this get printed out. So in
addition to the Visual Studio
697:16 - Code debugger, importing hard
hat slash console dot Sol, and
697:19 - using console dot logs in your
solidity can also be an
697:23 - effective debugging strategy.
Feel free to give this video a
697:25 - pause, implement this in some of
our contracts and try it out in
697:29 - our tests. So we tested that
withdrawing eath when there's a
697:35 - single funder works perfectly,
let's test withdrawing eath if
697:38 - there are multiple funders, so
we'll do it, let's say allows us
697:44 - to withdraw with multiple
funders. Why would this be an
697:51 - async function. And let's do
this await Funmi not fun, but
697:59 - with a number of different
accounts. So we can create a
698:02 - whole bunch of different
accounts of course, by saying
698:04 - const accounts equals await
ethers dot get signers. And we
698:12 - can loop through these accounts
and have each one of these
698:15 - accounts call the fund function.
And we're going to do this with
698:18 - a for loop. So we're going to
say for let i equals we'll start
698:25 - with the first index of the
accounts because the zero with
698:28 - index is going to be the
Deployer. So we'll say let i
698:31 - equals one is going to be less
than let's say six. And we'll do
698:36 - i plus plus. And in here, we'll
say const. And me contract Funmi
698:43 - connected contract equals await.
And me dot connect two accounts,
698:51 - I, so we need to call this
connect function because right
698:55 - now if we scroll up back to the
top, our Funmi contract is
698:59 - connected to our Deployer
account. And anytime we call a
699:03 - transaction with Funmi, the
deployer is the account that is
699:08 - calling that transaction, we
need to create new objects to
699:11 - connect to all of these
different accounts. So we're
699:13 - gonna say fund me connected
contract, which is now connected
699:16 - to one of these different
accounts dot fund. And this is
699:20 - where we'll do value, send
value. Or excuse me, we'll do
699:25 - await. Great. So this is going
to be our our range section. And
699:29 - then same as we did above, we
need to grab those starting
699:33 - balances. So we can just copy
that, those two lines and paste
699:36 - that down here. Now we're going
to move into act, I'm going to
699:39 - call that withdrawal function
again. So let's say const,
699:43 - transaction action response
equals await and MI dot
699:50 - withdraw. And we're going to do
the exact same thing as we did
699:54 - above, getting the transaction
receipt and the gas costs so we
699:58 - can get everything correct. Once
we've done the act, we move on
700:01 - into assert. And we're going to
do some very similar things to
700:05 - what we did above, like this,
for example, this whole first
700:08 - part is going to be exactly the
same. We also want to make sure
700:12 - the funders are reset properly.
So we'll make sure that this
700:18 - funders array is reset properly.
So to do that, we can actually
700:22 - just check to see that if
looking at the zero with
700:25 - position throws an error so we
can run a wait expect fund me
700:30 - dot get on me dot funder on me
dot funders of zero. This should
700:36 - revert so we'll say await expect
Funmi dot funders dot two dot b
700:41 - dot reverted and then we want to
loop through all these accounts
700:47 - and make sure that it makes sure
or that in our mapping here, all
700:50 - their amounts are zero. So we'll
say, for I equals one is less
700:58 - than six,
701:01 - i plus plus, we'll say assert
dot equal. Wait, fund me dot
701:12 - address to amount funded, of the
accounts of I got address should
701:21 - be zero. So we're making sure
that all of these mappings are
701:26 - correctly updated to zero. So
let's go and test this. So we're
701:29 - withdrawing with multiple
founders, we're going to go back
701:32 - to our terminal, we're going to
hit up, we're going to change
701:36 - this GREP or this one. We'll see
if this passes. And it does
701:42 - indeed, so this means that our
withdraw function works really
701:45 - well even when there's multiple
funders and we can be happy and
701:49 - go to sleep knowing that. Now
the other thing we absolutely
701:52 - want 100% want to test is that
our only owner modifier is
701:55 - working, we want only the owner
to be able to withdraw the funds
701:59 - from here. So we'll create a new
session, we'll say it only
702:04 - allows the owner to withdraw
only allows you to withdraw.
702:10 - This will be an async function.
And in here, we'll say const.
702:17 - Accounts equals ethers dot get
signers again. And we'll say
702:20 - const attacker equals accounts
of one. So we'll say the first
702:27 - account will be some random
attacker will connect this
702:30 - attacker to a new contract,
we'll say const attacker
702:35 - connected contract equals await
on DB dot Connect. Attacker dot
702:44 - address, excuse me a dot connect
attacker. Since we're not just
702:49 - connecting the address, we're
connecting the account which
702:52 - attacker is an account object.
And then we'll do a wait expect
702:59 - attacker connected contract dot
withdraw dot two dot b dot
703:11 - reverted, they should not be
able to withdraw. So let's go
703:15 - ahead, we can even just copy
this whole thing if we want to
703:19 - hit up, we'll delete this
section here. We'll paste that
703:24 - in. And boom. This means that
when some other account tries to
703:29 - call withdraw, automatically
gets reverted, which is what we
703:32 - want. Now we can be more
explicit to make sure that the
703:36 - correct error code is being
thrown, not just that it's
703:39 - reverted. Right, it can be very
reverted because they sent ether
703:43 - did it they did something weird,
we want to make sure it's
703:45 - reverted with our specific error
code. So right now we have this
703:48 - not owner error code. But it's
actually a best practice to put
703:52 - the contract name to underscores
and then your custom error. This
703:57 - makes it a lot easier in the
future when you have a ton of
704:00 - different contracts, and you're
not sure where an error is
704:02 - coming from. So we're going to
just update this really quickly
704:05 - to be fund me underscore
underscore, not owner, now we
704:09 - can do is now that we have this
custom error, we can say
704:12 - withdraw that to be reverted
with, then we can add our custom
704:17 - error in here. Now, if we rerun
our test, with only allows the
704:22 - owner to withdraw, oops, we need
to do a wait here. My mistake,
704:26 - wait a Thursday, get signers.
And now let's try this again.
704:30 - And we are indeed passing
Perfect.
704:35 - Okay, great. We have some basic
unit tests here. And we're going
704:38 - to write some staging tests
pretty soon. But before we
704:41 - actually do that, let's go ahead
and add the gas estimator. And
704:46 - we'll see how much gas these
contracts in these functions are
704:49 - taking. It looks like the
Hardhead gas reporter is already
704:52 - here. So let's scroll down.
We'll do gas reporter true. And
704:57 - we won't do coin market cap
here. And we'll just look purely
705:01 - at the GUI. So you can just
comment it out like that. Now
705:03 - rerun all of our tests. So we'll
say yarn, our test. And in doing
705:09 - so we're gonna get that that gas
output in that gas report dash
705:13 - text here. So looks like all of
our tests are passing, which is
705:17 - perfect. Now we can look into
our gas report and see what's
705:21 - going on here. i Well, it looks
like the fundraising function is
705:25 - taking a decent chunk of gas,
the withdrawal function, take it
705:28 - some guests to we'd see the min,
the max and the average. Of
705:32 - course, we can see how much each
one of these contracts cost to
705:35 - actually output. We don't really
care about the MOQ aggregator of
705:38 - course, because we're never
actually going to use that.
705:40 - Let's say we look at the average
gas for these and we go hmm,
705:42 - this looks like it's actually a
lot more than what we originally
705:45 - expected. Is there a way for us
to make this a little bit cheap.
705:48 - If we go back to our funding
contract, we look at our
705:51 - withdrawal function. And we
noticed something, oh, there is
705:55 - actually a way to make this a
lot cheaper. And it has to do
705:58 - with something called storage
variables, or these global
706:02 - variables that we've been
working with this whole time.
706:05 - Let me let me paint you a little
picture here, we're gonna look
706:07 - at one of the first gas
optimization techniques you can
706:10 - take to drop these down. And it
has to do with an R Funmi.
706:14 - Contract these state variables
and how they're actually stored
706:19 - and how this contract actually
keeps track of all this stuff,
706:22 - this section is going to be a
little bit more advanced. So
706:25 - we'll have a note here saying
that this is an advanced
706:27 - section, if you want to skip
over it, you can, because now
706:30 - we're getting into gas
optimizations here, this
706:32 - information still is really good
to know. So if you want to skip
706:35 - it for now, and then come back
later, you absolutely can. But
706:38 - let's talk about what happens
when we actually save or store
706:43 - these global variables. Okay,
these storage variables. Now,
706:47 - everything I'm about to go
through is in the documentation.
706:50 - And there is a link to this, of
course, in the GitHub repo
706:52 - associated with this course,
whenever we have one of these
706:55 - global variables, or these
variables that stay permanently,
706:58 - they're stuck in something
called storage, you can think of
707:01 - storage as a big giant array, or
a giant list of all the
707:06 - variables that we actually
create. So when we say we have
707:08 - some contract called Son of
storage, and we have a variable
707:11 - called favorite number, we're
basically saying we want this
707:14 - favorite number variable to
persist, right, we saw in a lot
707:17 - of our examples, we had a
favorite number variable that we
707:20 - can always call to see what this
contracts favorite number was,
707:23 - well, the way it persists, is it
gets stored in this place called
707:27 - storage. A storage box is this
giant list associated with this
707:30 - contract where every single
variable and every single value
707:33 - in the storage section is
slotted into a 32 byte long slot
707:38 - in this storage array. So for
example, the number 25 in its
707:43 - bytes implementation is 000 with
a ton of zeros 19. This is the
707:48 - hex version of the yuan 256.
This is why we do so much hex
707:51 - translation, the bytes
implementation of a yuan 256.
707:56 - And each store saw increments
just like an array starting from
707:59 - zero. So for example, our next
global variable or next storage
708:04 - variable just gets slotted at
the next slot that's available.
708:09 - So bullions, for example, get
transformed from their bull
708:12 - version two, their hex and we
modified our some bool variable
708:16 - to be true and X edition of the
true Boolean 0x 001. Every time
708:22 - you save an additional global
variable, or more correctly, one
708:25 - of these storage variables, it
takes up an additional storage
708:29 - slot. And what about variables
that are dynamic in length, or
708:32 - that can change length? What
about something that's dynamic?
708:35 - Well, for dynamic values, like a
dynamic array, or a mapping
708:39 - elements inside the array or
inside the mapping are actually
708:42 - stored using some type of
hashing function. And you can
708:45 - see those specific functions in
the documentation, the object
708:48 - itself does take up a storage
slot, but it's not going to be
708:52 - the entire array. For example,
my array variable here at
708:55 - storage, slot two doesn't have
the entire array in storage slot
709:00 - two, what has actually is just
the array length, the length of
709:04 - the array is stored at storage
slot two. But for example, if we
709:07 - do my array dot push 222, we do
some hashing function, which
709:12 - again, you can see in the
documentation what that is, and
709:15 - we'll store the number 222. At
that location in storage, the
709:20 - hex of 222 is 0x 0000 D, so it
gets stored in this crazy spot.
709:26 - And this is good, this is
intentional, because 32 Bytes
709:29 - may not be nearly big enough to
store my array if our array gets
709:32 - massive. And it wouldn't make
sense for to put the elements
709:35 - inside the array at subsequent
numbers because again, the size
709:38 - of the array can change and
you're never going to be sure
709:40 - how many subsequence that you
need. So for my array, it does
709:44 - have a storage slot for the
length for mappings. It does
709:47 - have a storage spot as well
similar to array, but it's just
709:50 - blank. But it's blank
intentionally so that solidity
709:54 - knows, okay, there is a mapping
here, and it needs a storage
709:57 - slot for attaching functional
work correctly. Now
710:00 - interestingly, constant
variables and immutable
710:03 - variables do not take up spots
in storage. The reason for this
710:07 - is because constant variables
are actually part of the
710:10 - contracts byte code itself,
which sounds a little bit weird.
710:14 - But you can imagine what
solidity does is anytime it sees
710:17 - constant variables name is it
just automatically swaps it out
710:21 - with whatever number it actually
is. So you can kind of think of
710:24 - not in storage is just a pointer
to 123 and it doesn't take up a
710:28 - storage slot. Well when we have
variables inside of a function,
710:32 - those variables only exist for
the duration of the function.
710:36 - They don't stay inside the
contract. They don't persist
710:39 - they're not permanent. So
variables inside these functions
710:42 - like new var and other var do
not get added to storage. They
710:46 - get added in their own memory
data structure. Which gets
710:49 - deleted after the function has
finished running. Now you might
710:52 - be asking, Okay, well, why do we
need this memory keyword,
710:55 - especially when it comes to
strings, we saw before that we
710:59 - had to say String memory. The
reason we need it for strings is
711:02 - because strings are technically
this dynamically sized array.
711:06 - And we need to tell solidity,
hey, we're going to do this on
711:08 - the storage location, or we're
going to do it into the memory
711:11 - location where we can just wipe
it. arrays and mappings can take
711:14 - up a lot more space. So slowly,
just wants to make sure Okay,
711:18 - where are we working with this
is it storage is a memory, you
711:21 - have to tell me, I need to know
if I need to allocate space for
711:24 - it in our storage data
structure. And again, everything
711:27 - here you can read in the
solidity documentation. Now, in
711:29 - the GitHub repo associated with
this course, if you go to
711:33 - contracts, we've actually got an
example contract section called
711:37 - Fun with storage, where you can
play with and look at a lot of
711:39 - this stuff. And we even wrote a
little script called deploy
711:44 - storage fun, where it'll print
out the storage location of some
711:48 - of the different variables, feel
free to give it a run, if you
711:50 - want to try a challenge anybody
to write some functions that
711:53 - find the storage slots of the
elements of the arrays, and the
711:56 - mappings, and then find the data
inside of those as well. We use
712:00 - a function here called Get
storage app, which allows us to
712:03 - get the storage at any one of
these slots. And this is to
712:06 - reinforce that even if you have
a function as private or
712:10 - internal. Anybody can still read
it. Anybody can read anything
712:14 - off the blockchain. And you can
test it exactly what this if you
712:18 - go ahead and get clone that or
copy paste the code yourself.
712:21 - You can then run yarn part at
deploy dash test tags, storage.
712:27 - And you'll run the deploy script
for that storage.
712:30 - And you'll see printing out the
location of storage in each
712:33 - storage slot with a fun contract
that we made as an example. And
712:40 - you might of course be asking,
Okay, Patrick, why are you
712:42 - telling me all this? We're just
trying to get this gas price
712:45 - down? Why are you telling me all
about this storage thing? Well,
712:48 - the reason I'm telling you all
about the storage thing. Anytime
712:51 - you read or you write to and
from storage, you spend a ton of
712:55 - gas. Remember I said when we
compile our code, we compile it
712:58 - down to some crazy weird
bytecode. Well, let me show you
713:01 - on remix what this looks like.
We go to compliation details, we
713:05 - can go to bytecode. And we see
this weird hex object zero,
713:09 - blah, blah, blah. But we also
see these things called op
713:12 - codes. Now, this bytecode here
represents these op codes. Each
713:16 - one of these op codes represents
a small piece of everything in
713:20 - this bytecode. And in fact, in
our heart hat, we can go to
713:23 - artifacts, build info, and we
can see, we can see these op
713:28 - codes in the build info, we can
do a command F or Control F for
713:32 - opcodes. We can see op codes for
different contracts. These op
713:37 - codes represent what the machine
code is doing. And they
713:40 - represent how much computational
work it takes to actually run
713:44 - our code and do stuff with our
code. The way that gas is
713:47 - actually calculated is by these
opcodes. There are a couple of
713:50 - lists here. But here's one that
I'm going to use this EVM
713:53 - opcodes. And again, there's a
link to this in the GitHub repo
713:56 - associated with this lesson.
Well, if we scroll down, we can
713:59 - see exactly how much it costs
for each one of these op codes.
714:03 - So for example, anytime we add,
it costs three gas, anytime we
714:08 - multiply, that's five gas,
subtracting three gas, we have
714:13 - all of these op codes that cost
different amounts of gas in in
714:17 - our functions, here's kind of a
sample contract. If we're doing
714:21 - adding, anytime we add it's
going to cost three gas. Anytime
714:25 - we save to memory, it's going to
cost gas from some other
714:29 - opcodes. These op codes combined
show us how much gas we actually
714:33 - use. Now, let's look at a lot of
these op codes and how much they
714:36 - cost three 510, three, three,
balance is 700. So getting the
714:43 - balance is is a ton of gas.
Let's keep going. Getting the
714:47 - sides of an Accounts code is a
lot of gas copying and accounts
714:50 - code into memory. But oh my
goodness, what is this save word
714:56 - to storage costs a ton of gas
that is 20,000 gas and s load
715:03 - load word from storage cost 800
gas. These are two of the most
715:08 - important opcodes s load and s
store which stands for storage
715:12 - load and storage store. Anytime
one of these op codes fires,
715:17 - we're spending 800 or 20,000.
You know, there's a big asterisk
715:21 - there because that can change a
lot. But we're spending a ton of
715:25 - gas anytime we work with storage
as developers. Anytime we work
715:29 - with some stuff in storage, we
want to go boy, this is about to
715:33 - cost me a lot of gas and the
best convention or making sure
715:37 - we know that we're working with
a stored variable and we're
715:40 - about to spend a lot of gas is
to append an S underscore right
715:46 - before them which stands for
storage right So we're saying
715:49 - address to amount funded is
going to be a storage variable
715:52 - wonders is going to be a storage
variable. Owner is not going to
715:56 - be a storage variable. It's
immutable. The best practice for
715:59 - immutable variables is
prefixing. It with an I
716:02 - underscore constant values are
also not in storage. So for
716:06 - constant values, we want to keep
them capslock, like that
716:09 - aggregator v3 interface public
price feed. Yep, you know what
716:12 - that is going to be a storage
variable. So we want to append
716:15 - an S underscore with it. So
we're going to do a little bit
716:18 - more refactor, we've appended
these appropriately to update
716:21 - everything. So instead of owner,
it's going to be I underscore
716:25 - owner, and as a developer will
read this, and we'll go ah, this
716:28 - is going to be much cheaper than
a regular variable. Okay, that's
716:31 - great. I'm going to work with
this. This I underscore owner
716:34 - for my modifier. Awesome. Is
owner anywhere else in here?
716:38 - Okay, right in the constructor.
I own underscore owner is
716:42 - message dot sender. Price feed
is a storage variable. We should
716:45 - as developers, we should see the
s underscore when reading this
716:49 - and go, Okay, we're spending a
lot of gas to store this.
716:53 - Perfect. Okay, great. Let's keep
going. Great. We've updated all
716:57 - the owners. Okay, well, what
about address to amount funded?
717:01 - In VS code? If you do Command F,
or Ctrl, F, and you hit this
717:06 - little down arrow, you can
actually find and replace all of
717:10 - these address to amount funded
with s underscore address to Mt
717:14 - funded. Hit it like that. And
since I updated one, I got a
717:18 - backspace that one no. So now
these are all updated. Let's do
717:22 - the same thing with s funders.
Let's update everywhere. It has
717:26 - funders just to be s funders.
And we probably doubled up here.
717:29 - Yep.
717:30 - Let's undo that. We already
updated all the AI owners. So
717:33 - now it's updated all the price
feeds. So let's look for price
717:36 - feed, we'll update it with ES
price feed. And then we probably
717:39 - doubled up right here. So we'll
undo that. Okay, great. Now that
717:42 - we've updated everything in
here, we can scroll down and we
717:45 - can oops, sorry, doubled up
there too. Sorry. We can we can
717:49 - green through our code and go
okay, where are we reading and
717:53 - writing to storage way more
often than we probably need to.
717:57 - And that's when we get to this
withdrawal function, which seems
718:00 - rather suspect to reading and
writing to storage a lot. So
718:05 - let's take a look at what we're
doing here. Okay, so first of
718:08 - all, I can see that we're doing
a for loop here. And every time
718:13 - we do a for loop, we're just
constantly looping through all
718:16 - of this code. Every single time
we're doing a little compare
718:20 - option here we're saying, okay,
is our funder index less than s
718:24 - funders dot length? S funders
dot length, this means the
718:28 - longer our funders array is, the
more times we're going to be
718:32 - reading from storage, that's
incredibly expensive. We're also
718:36 - recalling this, oh my goodness,
we're reading from storage a lot
718:40 - and saving it to this memory
variable, and then updating our
718:43 - storage variable with it. Wow.
So we're reading from storage a
718:46 - ton here, and we're reading from
storage a ton here, okay, then
718:50 - we have to reset our funders
array, there's really no way
718:52 - around it. And that's pretty
much it for our reading and
718:55 - writing to storage, we could
probably create a withdrawal
718:58 - function, that's a lot cheaper.
So let's go ahead and create a
719:01 - function called cheaper
withdraw, function, cheaper
719:05 - withdraw. That's going to take
what we've just learned and make
719:10 - a cheaper withdraw, that's much
more gas efficient. So we'll
719:13 - keep this public payable. and
have it be only owner, we're not
719:18 - going to change anything there.
But what can we do for at least
719:23 - this part here, we don't want to
keep reading from storage here.
719:26 - And we don't want to always have
to keep reading from storage
719:29 - here. We're like doubling up the
amount of storage we're reading
719:32 - from. So instead, what we can
do, we can read this entire
719:35 - array into memory one time, and
then read from memory instead of
719:41 - constantly reading from storage.
And that's going to make our
719:43 - lives a lot cheaper. So we can
create an address array. Memory
719:49 - funders equals s underscore,
funders. And now it's going to
719:54 - start making sense why for
arrays and strings in our
719:58 - functions, it makes us say, hey,
is this memory is a storage?
720:02 - What is this? And we're telling
it, we want it to be memory
720:04 - because memory is going to be a
lot cheaper. So now that we're
720:07 - saving it into our funders, oh,
and a quick note mappings can't
720:12 - be in memory. Sorry. They're
just too weird and too wacky. So
720:16 - flooding just doesn't let you do
that right now. But now that
720:19 - we've saved our storage variable
into a memory variable, we can
720:24 - read and write from this memory
variable, much, much cheaper,
720:28 - and then update storage when
we're all done. So what we're
720:31 - going to do now is we're gonna
say for you into V six, fund or
720:35 - index equals zero, and we're
going to basically rewrite
720:38 - everything but just using this
memory array. instead. We're
720:43 - gonna say funder index is less
than funders dot length and
720:48 - instead of s funders dot length,
and then we're gonna say funder
720:53 - index plus plus. And then in
here we're gonna do nearly
720:57 - exactly the same thing, except
we're gonna say address funder
721:01 - equals funders, using our memory
array and not s funders have
721:08 - funder index. And then we're
gonna say s address to amount
721:13 - funded. funder equals zero. So
we're resetting our funders
721:20 - mapping here, we're using our
memory variables instead, then
721:24 - we're going to do the same thing
s underscore funders equals new
721:28 - address array of zero. And then
we're gonna do the same thing
721:33 - bool success, comma equals S
owner, dot call value,
721:41 - address this balance, and we're
going to send it nothing and
721:47 - then require success. Like that
actually, sorry, Iona on a sonar
721:53 - now that we have this function
that we think is cheaper, let's
721:56 - go back to our test. And let's
run this same multi test here,
722:01 - but with our cheaper function.
So I know this can be a little
722:05 - bit tricky to copy, paste, but
let's copy this entire massive
722:08 - test. Let's come down here,
paste it, and we'll change the
722:13 - name saying cheaper withdraw,
testing dot that done. And in
722:19 - here in in this giant it here,
all we're going to change is
722:23 - we're going to change withdraw
to cheaper withdraw, and the
722:27 - rest of the test is going to be
exactly the same. So with that,
722:30 - let's see if if we were
successful in making our
722:33 - withdraw function cheaper with
cheaper withdraw, we're gonna
722:36 - pull apart our terminal now. And
we do yarn, art hat test, which
722:40 - is going to run our gas
estimator because it's enabled
722:43 - right now. And of course, all of
our functions have been broken
722:45 - because we renamed everything.
So we'll do a quick final
722:49 - replace of funders, to change
funders to ask funders. And then
722:57 - we're gonna change price feed to
ask price feed. And then do we
723:02 - have owner anywhere? We don't
have owner or anywhere. We need
723:06 - to change this one. Address to
amount funded. Let's come in
723:10 - here. Address to amount funded.
S adderstone. well funded. What
723:15 - else do we need to change price?
We price feed funders. Okay, I
723:18 - think we changed everything.
Alright, so let's try our test
723:20 - now. Yarn Hardhead test. All
right, great. Everything's
723:24 - passing. And we ran our cheaper
withdraw testing. So now, if we
723:30 - go to our gas output here, our
gas report, zoom out just a
723:34 - hair, we can see the difference
between cheaper withdraw and
723:38 - withdraw, we see something
really interesting. Here we see
723:42 - our cheaper withdraw on average
was actually more expensive than
723:46 - our regular withdraw. And the
reason for this is because
723:49 - actually, if we go to our tests
are cheaper withdrawal, we only
723:53 - tested on the multi withdraw. So
we had to reset many, many more
723:57 - accounts. But this was also
technically its maximum as well.
724:01 - And if we compare the maximum of
the cheaper withdrawal, the
724:04 - maximum of the withdraw, it
looks like the cheaper
724:07 - withdrawal was indeed cheaper.
And if we go to our hard hat dot
724:11 - config, and we add our API key
back in, what we could even do
724:15 - is in our test, we could copy
withdraw eath from a single
724:18 - funder, copy that, paste it in
and just change withdraw to
724:23 - cheaper withdrawal, rerun it
with the key and now do yarn
724:27 - Hardhead test, we can see
exactly how many dollars we
724:30 - would save if we ran this on the
Matic blockchain. Now let's go
724:36 - back, we'll reopen up our gas
report. And we can see, in the
724:41 - minimum cheaper withdrawal was
actually a little bit more
724:43 - expensive. This actually does
make sense because if we look at
724:46 - funding, if we only have to
withdraw when there was one
724:49 - funder, well this loop only runs
one time. And our cheaper
724:53 - withdraw will do the exact same
but it will have this this extra
724:56 - thing here of loading them all
in, we see that the savings The
725:00 - more people our funders in our
contracts. So automatic, we can
725:04 - see we pretty much didn't save
anything. But if I change this
725:08 - one more time to eath run the
test again. Now we can see
725:14 - people withdraw saved a few
cents. This is how we can start
725:18 - optimizing our contracts will be
cheaper and cheaper. And this
725:21 - two cents was just in the
average. It's not even comparing
725:23 - the max to the max, which was a
lot more gas than their
725:27 - averages. We have just learned
an absolute ton here. Now, this
725:35 - next part is going to make some
of you mad because we're going
725:36 - to refactor our code one more
time if you don't want to
725:39 - refactor it and you want to
leave all your tests as s
725:42 - underscores you absolutely can
but to other users using our
725:45 - application. Dealing with this s
underscore is a little Little
725:48 - bit gross and actually can make
our code a little bit more
725:51 - confusing for those who use it.
And additionally, right now all
725:55 - of our state variables are
public. And actually internal
725:58 - variables and private variables
are also cheaper gas wise. And
726:01 - we don't need to make every
single one of our variables
726:03 - public, because anybody can read
them off the chain anyways. So
726:07 - one more refactoring that we're
going to do is we're actually
726:09 - going to set the visibility of
these to private or internal,
726:13 - based off of whether or not they
need to be private or internal,
726:16 - and then we'll create getters at
the bottom of our function here.
726:20 - So minimum USD, we can keep this
public because we want other
726:23 - people to know what the minimum
USD of our contract is, without
726:26 - having to go right through
storage, the owner of our
726:29 - contract isn't important for
others to know or other
726:31 - contracts to know. So we can go
ahead and make this private, and
726:34 - then at the bottom at a function
726:37 - get owner. That's a public view
that returns I owner, turns
726:49 - address as funders, as funders
can be private as well. So at
726:55 - the bottom, we're gonna say
function, get funder, and we're
727:00 - going to pass a un 236 index,
public U, turns, address, return
727:12 - as funders of index, the address
to Mt funded can also be
727:17 - private. So the bottom, we're
going to create function, get
727:22 - address to amount funded. And
this is going to take an address
727:29 - under the public view returns,
you went to 56. And we're going
727:36 - to return amount funded of the
funder did this one we did this
727:41 - one, we did this one. And then
price feed, function get price
727:46 - feed. This is going to be public
view as well, that returns
727:51 - aggregate tour of the three
interface that's going to return
727:55 - so I'm just gonna price feed.
Oh, okay. The reason why we did
727:58 - that is because we want to have
this s underscore so that we as
728:02 - developers can know, okay, this
is a storage variable, I want to
728:05 - be very careful about how I
interact with this. But we don't
728:08 - want people who interact with
our code to have to deal with
728:11 - this s stuff. And we want to
give them an API that makes
728:14 - sense, and that it's easy and
readable. So we add these getter
728:17 - functions at the bottom to do
that. And also changing the
728:20 - visibility can save us some gas
in the long run as well, because
728:24 - we're gonna be calling from
private variables or internal
728:26 - variables, which are cheaper gas
wise, of course, we do need to
728:29 - upgrade our test one more time.
And like I said, if you want to
728:31 - just leave them with the S
underscores, that's absolutely
728:34 - fine. So s underscore price feed
is now going to be replaced with
728:40 - get price feed, s underscore
amount to fund it is going to be
728:44 - now replaced with get address to
amount funded. For now going to
728:49 - change SW, underscore funders,
to get funder. We're going to
728:56 - change Iona, there's nowhere
else in their mind, we don't
728:59 - need to change them. And I think
that was everything. Let's just
729:01 - look for s underscore, we don't
see it, I underscore, we don't
729:05 - see that either. Let's just run
our tests one more time to make
729:08 - sure we refactor that correctly.
And it looks like we did
729:13 - awesome. Okay, we have just
learned a ton. we've refactored
729:17 - our code a ton. And everything
is starting to look really,
729:20 - really good here. One more gas
optimization we could make. And
729:24 - an optimization for errors as
well is we could update all of
729:28 - our requires to instead be to
instead be reverts. Because
729:33 - without requires, we're actually
storing this massive string,
729:37 - this massive array of text on
chain, these error codes are
729:42 - much cheaper. But that's
optional. If you want to do
729:44 - that. The whole reason we were
doing this is we were going
729:47 - through the style guide in
updating things here. So we have
729:50 - public internal private, and the
bottom is going to be our view
729:53 - slash pure functions, which they
are they're just all these
729:56 - getters that we just added.
730:00 - So now our style in here looks
good. We've learned a lot about
730:03 - gas, we've learned a lot about
storage. This is fantastic.
730:06 - Let's do a quick refresher on
everything we just learned
730:09 - because we went through a lot
right there. And like I said,
730:13 - this is one of the harder parts
of this course. Any variable
730:16 - that is changeable that we want
to persist across contract
730:20 - executions and transactions. We
save to a giant array called
730:24 - storage this array is
sequentially indexed starting at
730:27 - zero. So the first variable the
first value that we have in our
730:31 - contract gets stored to the zero
with index. The next one gets
730:35 - stored to one and so on and so
forth. Dynamic arrays and
730:39 - mappings and other dynamically
sized objects use specific
730:43 - hashing function that you can
find in the documentation to
730:46 - determine where the elements of
those dynamic Data Structures go
730:50 - memory variables, constant
variables and immutable
730:53 - variables don't go in storage.
And one of the main reasons
730:57 - talking about storage is so
important is because the op
731:01 - codes for loading from storage
and for reading from storage and
731:05 - writing to storage are
incredibly gas expensive. So in
731:09 - everywhere we can we want to
reduce the amount that we read
731:12 - and load from storage. And it's
one of the easiest ways to save
731:16 - gas and try to optimize our code
to be gas efficient. Like I
731:20 - said, some of this gas stuff can
be a little tricky and a little
731:22 - bit confusing. So if you don't
get this right away, it's okay.
731:25 - It is totally fine. If you're a
little bit confused, and you're
731:28 - like, What is he talking about?
Like I said, this is some of the
731:31 - more advanced stuff it'll come,
the more you work with solidity,
731:34 - and the more you work with
everything here. So don't let it
731:36 - stress you out. Don't let it
stop you from continuing. You're
731:39 - doing fantastic being here. So
far. We've written some really
731:45 - good unit tests. Let's now write
some staging tests. And these
731:50 - are the tests that we can use on
an actual test net. This is a
731:54 - test that we're basically going
to run after we've deployed some
731:57 - code just to see if everything
is working approximately the way
732:01 - we want it to. So let's go ahead
and we'll create a new file
732:03 - here. We'll call it fund me. Dot
staging dot test, dot j s. And
732:10 - it's going to look really
similar to what we were just
732:12 - doing with our unit tests. And
we're going to assume this is on
732:15 - a test net. So these are tests
that we're going to run, right
732:18 - before we deploy this to a main
net, this is the last step in
732:21 - your development journey, we
want to just make sure that
732:24 - everything is working
approximately correctly on an
732:27 - actual test net. So what we're
gonna do is we're gonna do the
732:29 - same thing describe, fund me,
and I'm gonna go a little quick
732:34 - through these tests here,
because we've basically written
732:37 - this type of test before, so
we're gonna say before each,
732:39 - it's gonna be an async.
function. We're gonna do the
732:44 - same thing as our unit tests. So
we're gonna have a Funmi
732:48 - variable, we're gonna have our
let Deployer, we're gonna have
732:51 - our constant send value equals
ethers.utils.rs ether of one,
733:00 - and in here, we're going to do
const. Get named accounts.
733:05 - Equals require hardhats, we're
going to say deployer equals
733:12 - weight, get named accounts,
we're going to wrap this up, dot
733:17 - Deployer. We're gonna say fun me
equals await ethers dot get
733:23 - contract.
733:25 - And me, comma, we're going to
connect it to our Deployer,
733:29 - we're not going to deploy this,
we're not going to do any
733:32 - fixtures like we did in our unit
tests, because in our staging
733:35 - tests, we're assuming that it's
already deployed here. And we
733:38 - also don't need a mock because
on a staging, we're assuming
733:43 - that we're on a test net, now we
can actually wrap this whole
733:46 - thing to make sure that we're on
a test net by using our helper
733:49 - config. And looking for our
development chains, we can say
733:53 - we only want to run our describe
bit if we're on a development
733:57 - chain. So first, we'll say
const. Development chains equals
734:04 - require, we'll pull that that
helper config in. And we'll say,
734:10 - development chains dot includes
network dot name. And we'll
734:15 - basically will say if developer
chains that includes network dot
734:18 - name, we're going to skip and we
can actually skip using this,
734:22 - we're going to use something
called a ternary operator is
734:25 - basically like a one liner if
statement. And you can think of
734:28 - this as a special type of F.
I've got a link to this and the
734:31 - GitHub repo associated with this
course. And here's some
734:33 - JavaScript documentation,
showing it in action. You say,
734:37 - Okay, return is member. And if
it's true, have it be $2.
734:43 - Otherwise have a B $10. And
that's pretty much it. So
734:47 - another way of thinking about is
like, you say, let variable
734:51 - equals true, then we could say,
let some var equals variable
734:57 - question. Yes? Or no? Some var
will end up being Yes. Because
735:03 - variable is true. If variable
was false than some var would be
735:07 - no. So it's literally saying, If
variable, if variable, then some
735:12 - var equals yes. Else. Some var
equals no, these lines are
735:19 - literally the exact same thing.
This one is just a little bit
735:21 - more succinct. That's really it.
So that's what this operator
735:24 - does. We're gonna say
development chains that includes
735:26 - network dot name. So if our
network is a development chain,
735:30 - which we're going to import
network as well from hard hat
735:33 - and ethers as well. Then we're
going to do describe that
735:37 - skipped and this tells our test
to just skip this whole
735:41 - describe, and then we're going
to put this little colon here
735:43 - thing and save and boom. So now
we're only going to run this if
735:48 - we're not On a development
chain, and we want to take this
735:50 - exact same syntax, we'll go to
our unit testing here, and we'll
735:54 - do the exact same thing, we'll
paste it will have this be the
735:58 - opposite by putting a little
knot here, sticking that colon
736:01 - in. So now, our unit tests only
run on development chains in our
736:05 - staging tests, only run on test
nets. Perfect. That's what we
736:09 - want, allows people to fund and
own and withdraw. And this will
736:15 - be an async function, of course,
and we probably can make this
736:18 - pretty robust, but we'll just
say await, fund me dot fund is
736:23 - going to be send a value. And
then we'll say a weight on me
736:28 - dot withdraw. CERT equals
require try. Now we'll do kind
736:36 - of a lame final one, we'll say
const ending balance equals a
736:40 - weight on me dot provider dot
get balance, fund me dot
736:47 - address. And then we'll say
assert dot equals ending
736:52 - balance.to string, comma zero as
a string, we're only going to
736:58 - run this on a test net, I'm just
going to give you this one more
737:00 - run to show you it in action.
Feel free to skip this part
737:04 - again, because we are going to
be working with a test net, I'm
737:06 - going to run yarn, hard hat
deploy dash test network
737:11 - Rinkeby. And it's going to run
through our deploy. And after
737:17 - it's all deployed, we're going
to run our staging tests to make
737:20 - sure that everything works even
with a price feed on a real test
737:24 - net, and I need to do const
development chains equals
737:28 - require dot dot slash dot dot
slash helper heart config. Now
737:34 - for run yarn, hard hat test,
we'll see just our unit tests
737:40 - get run. But if we run yarn hard
to test dash dash network
737:44 - Rinkeby, we're not going to run
nine tests, we're only going to
737:47 - run our singular staging test.
And of course, this is going to
737:51 - be a lot slower, because we're
on a
737:54 - test net. Net will we write
written all these tests, we can
738:02 - write a couple of scripts. And
then we're going to finish this
738:05 - out by pushing this up to GitHub
making this our first smart
738:08 - contract GitHub repository, when
it comes to the blockchain, when
738:11 - it comes to smart contracts,
interacting with community
738:14 - interacting with open source
being a part of GitHub, or git
738:18 - labs or whatever Git hosting
service you're using is
738:21 - essential to being successful
here. So let's write our
738:24 - scripts. And then we'll upload
this to GitHub to start building
738:27 - our portfolio. So first, we're
going to create a script to
738:30 - interact with our code called
fund dot j s. And this is going
738:34 - to be really similar to our
tests. And this way, in the
738:37 - future. If we want to just fund
one of our contracts very
738:39 - quickly, we can just run this
and we can do it, we're gonna do
738:42 - the same thing that we've been
doing, we're gonna do an async
738:45 - function main. And down below,
I'm just going to copy paste
738:49 - this because we're going to be
copy pasting in a lot. We're
738:51 - going to paste this little
syntax here. So let's write a
738:55 - script that allows us to fund
our contracts. So first, we're
738:59 - going to need const get named
accounts just like in our tests,
739:04 - equals require arhat we're gonna
say const Deployer. Equals await
739:15 - yet named accounts, just like
that. And then we're gonna say
739:20 - const fund me equals await
ethers dot get contract. From
739:27 - funding comm a Deployer.
Literally, almost exactly the
739:31 - same as our tests, then we'll do
a little console dot log funding
739:36 - contract that that and we'll do
const transaction response
739:43 - equals await funding dot fund.
And for the value, we'll do
739:49 - something like ethers dot utils,
that parse ether of 0.1 or
739:56 - something, whatever you want to
do here, we of course, need to
739:58 - import ethers, which it looks
like we already have. We'll do
740:01 - await transaction response dot
wait for one transaction. And
740:06 - then we'll do console dot log
funded, we can run this little
740:12 - script by running yarn, RT head
node will run a local node with
740:17 - all of our contracts deployed.
We'll see if our script looks
740:21 - okay by running yarn, hard hat
run scripts fund dot j s dash
740:27 - dash network localhost. And it
looks like it's funding Great.
740:32 - Let's now write a withdraw
script withdraw that J S. And we
740:37 - can even leave our localhost
Node running because we're going
740:41 - to withdraw the funds that we've
just funded it with. So we're
740:43 - going to do the exact same setup
here. We can even copy this main
740:47 - bit to our withdraw Ah, the top
will do async function main will
740:54 - say const deployer equals await,
get named accounts, which wow, I
741:00 - hit enter and my VS code auto
imported it, that's pretty nice.
741:03 - Maybe yours will too, maybe
won't if it won't, you just
741:06 - gotta write it out or copy paste
from the other one. And then
741:08 - we'll do cars Funmi equals await
ethers dot get contract on me,
741:13 - course. And this is going to be
the exact same. Now we're going
741:17 - to do console dot log funding
data dot, we'll say const
741:23 - transaction response equals
await on v dot withdraw, await
741:30 - transaction response dot wait
one, then console dot log. Got
741:35 - it? Back. And we can test this
out by running yarn, hard hit
741:42 - run scripts, withdraw dash dash
network localhost, we'll see if
741:46 - this works. And cool and our
script is working. Fantastic
741:51 - crushed out two scripts
incredibly quickly. And now we
741:54 - have a way to easily interact
with our code with our contracts
741:57 - if we want to via a script.
There's actually one more thing
742:03 - I want to show you before we
actually work and we push all
742:05 - this wonderful code up to GitHub
in our package dot JSON. I've
742:09 - shown you a little bit of this
before, but we can add this
742:12 - scripts section to make our
lives a lot easier and condense
742:17 - all these long tests into a yarn
script for us. So usually, what
742:22 - you'll see in common package dot
JSON is you'll see a list of
742:25 - these in here for people to look
and just automatically run, one
742:29 - of the most common ones is going
to be test. And to run test,
742:32 - we're going to do yarn, hard hat
test. So now instead of running
742:37 - yarn, Hardhead test, someone can
just come to your package once
742:40 - this is saved and just run yarn
test. And this will grab this
742:44 - test from your script section
and it will run yarn heart at
742:47 - test and Bada bing, bada boom,
742:49 - okay, cool. What else do we
probably probably want to do in
742:52 - here? Well, we probably want to
have a test staging section
742:55 - that'll run yarn Hardhead test
dash dash, network Rinkeby. I'm
743:02 - not going to run that. But
that's probably something we
743:05 - want to have in here, we're
probably going to want some
743:07 - linting. So we showed you
briefly that linting thing. So
743:11 - we'll have a yarn lint, which
will just run yarn, sole hint.
743:16 - And then we'll just have it so
hence the contracts folder. And
743:20 - anything that starts out soul.
So now if I run yarn, lint,
743:24 - it'll run soul hint, and all of
our code here and it'll give us
743:29 - some warnings here, which we can
pretty much all ignore. And
743:32 - Solon actually has an auto fix
and auto fix that we can add, by
743:36 - doing yarn lint fix, we'll say
yarn. So hint, contracts slash
743:42 - start out. So we'll do dash dash
fix. So now we run yarn, lint
743:48 - fix, it'll auto fix, which
there's nothing to auto fix. So
743:52 - nothing happens. But it's good
to have anyways. And then we can
743:55 - do our formatter, we're just
going to format our code format,
743:59 - that which will do yarn,
prettier, dash dash write to,
744:03 - and we'll just do a period to do
everything. And then we can just
744:06 - do yarn format. And it's gonna
fix all of our, it's going to
744:11 - fix everything for us, which is
great. And then we finally can
744:15 - have coverage. By running yarn
hardhat coverage, now we can
744:20 - just run yarn coverage, will
give us this wonderful little
744:24 - coverage report. Awesome. So our
packages looking fantastic.
744:28 - Maybe we'll even come into
package json. We'll give this a
744:31 - name. We'll call this hard hat.
And me give it an author, which
744:38 - is going to be your name. So I'm
just gonna say Patrick Collins,
744:41 - and we'll give it a version in
here. of 1.0 Point Oh, oops. And
744:48 - let's do icons instead of
spaces. Oh, and one more thing.
744:53 - We're not using ES lint. So all
this es lint stuff, we can dump
744:57 - and we could delete the yarn dot
lock and reinstall. But yeah,
745:00 - whatever. We don't have a
readme, but that's okay. If you
745:03 - want to go back, like I said, go
check out that best readme
745:06 - template and go update your
READMEs to make them look as
745:10 - awesome as this, you can do that
as well. But other than that,
745:12 - we've got an awesome code repo
here. What do we want to do with
745:19 - it? Well, we've been playing
around with GitHub so much,
745:21 - we've been looking at all these
good hubs. It's time for us to
745:24 - join GitHub with our own with
our first repository. Let's go
745:29 - ahead and let's make this happen
in the lesson seven full
745:33 - blockchain solidity course, yes,
there is a link to this GitHub
745:36 - Quickstart that we're going to
follow to set up our first
745:39 - repository. This is going to be
the moment where you are
745:42 - starting to build your portfolio
building and GitHub is
745:45 - borderline crucial for your
development journey. It's going
745:48 - to be your portal folio, it's
going to be where you say, Hey,
745:50 - look at all the cool products
that I'm engaging with, that I'm
745:53 - working with, that I'm
participating in. If you've
745:55 - already made GitHub before, I
highly recommend you still push
745:58 - this up to GitHub as proof that
you've done it. And then you can
746:01 - also tweet it at me saying, hey,
look how far I've gotten. Look
746:04 - where I've done, look at how
fantastic I'm learning smart
746:07 - contracts, and be incredibly
excited about now, this
746:10 - quickstart will walk you through
creating a repository, creating
746:13 - a branch and teaching all this
stuff, we're going to follow the
746:16 - instructions from the GitHub
documentation about adding
746:18 - locally hosted code to GitHub,
we already have a project, and
746:21 - we're just pushing it up. Since
the Windows users are using WsL,
746:25 - you can just follow the Mac or
Linux instructions here, the
746:28 - first thing that we're going to
do is in your GitHub profile, or
746:31 - your GitHub login, we're gonna
hit this little plus thing, and
746:34 - hit new repository, you can call
this whatever you want, let's
746:37 - call it hard hat, fund me b code
camp, you can put a description
746:43 - if you want, learning from
recode camp, and Patrick, about
746:49 - smart contracts.
746:52 - We'll make it public because we
want other people to see you
746:55 - being fantastic and learning
smart contracts. We'll leave
746:57 - this blank, and we'll hit Create
repository. Now, this is our
747:01 - public code repository. This is
our first one, if you've done
747:04 - these already, this will be your
first smart contract one. It
747:08 - even has some instructions in
here, too, that teaches us how
747:11 - to create a new repository from
the command line, you can follow
747:14 - this if you want, or you can
follow like so the first thing
747:18 - we're going to do is we're going
to initialize a git branch. And
747:23 - from way back when you should
already have Git installed.
747:26 - Remember, you can check by
running git dash dash version
747:29 - like this. Git is a little
different from GitHub, Git is
747:32 - known as version control. And it
allows us to make changes to our
747:35 - code, but keep a history of all
the code changes that we've
747:39 - made. GitHub is a place where we
can push all of these changes
747:43 - and keep track of all of our
code. So the first thing that
747:45 - we're going to do is we're going
to create a new branch. And I'm
747:48 - not going to explain Git and
working with Git too, too
747:51 - deeply. But if you want to learn
about Git Free Code Camp, of
747:54 - course, has a video on Git and
GitHub for beginners. So we're
747:58 - going to create this new branch
with git init dash b main, now
748:02 - your Visual Studio code might
automatically start formatting
748:05 - some stuff. And if it does,
that's great. And if it doesn't,
748:07 - don't worry about it. But what
you'll see here on the left is
748:10 - you'll see some stuff is green,
and some stuff is gray, open
748:14 - back up that dot Git ignore,
you'll see that all the gray
748:17 - stuff is the stuff that we have
in this dot Git ignore this is
748:21 - intentional, this is what we
want. This is just some some
748:23 - highlighting saying, hey, this
green stuff is what you're
748:26 - working with on GitHub. And this
gray stuff is what you're not
748:29 - working with and GitHub. And
that's what we want. You don't
748:31 - need to push artifacts, or cash
or coverage or node modules,
748:35 - people can install and compile
on their own machines, we
748:39 - definitely don't want to push up
our Dotty and V if we're using a
748:43 - Dotty and V. And we don't really
need to push up coverage dot
748:46 - JSON, either the rest of this we
do. So now what's next, after we
748:50 - initialize our main branch, you
now should be able to run git
748:54 - status in your terminal and see
this huge red output of all
748:59 - these things that are untracked,
and we don't have any commits
749:03 - for, what we can do now is we
can stage all of our code with
749:07 - git add period, and then commit
it with Git commit, we're going
749:11 - to run these one at a time
instead of together. Before I
749:14 - run git add, I'm going to add
deployments to this list too,
749:17 - because GitHub doesn't really
need to know about all the
749:19 - different deployments I make,
especially when I make a ton of
749:22 - deployments to my local hosts,
they don't need to know. So
749:24 - we're going to add that to, then
we're going to run git add dot.
749:29 - And if we do a git status, now,
we can see all of our code has
749:34 - been staged for being committed
for being a part of this history
749:38 - of our code. And then take a
quick look at all these files
749:41 - and make sure your dot E and V
file is not and never in here.
749:46 - So now we're going to run git
commit dash m and then this
749:49 - message for our commit, okay, so
we'll run git commit dash m, we
749:55 - can say, initial commit, or
whatever you want in this
749:59 - message here, first commit,
initial commit, who cares, and
750:02 - it's gonna say, create mode,
blah, blah, blah, for all of
750:04 - these files. And if we do git
status, now, it's blank on
750:08 - branch main, nothing to commit.
And then you might get something
750:11 - like this. If you've never
worked with Git before your name
750:13 - and email were added
automatically. We're a little
750:16 - bit confused here. We'll talk
about this in just a second. So
750:20 - next, what we can do is we're
actually going to copy the URL
750:23 - of our GitHub repo. So you can
grab that just by copying here
750:27 - or right at the top, that URL
right there. And what we're
750:30 - going to do is we're going to
add this as a remote repo. To do
750:33 - that. We'll do git remote add,
and we'll give this remote repo
750:39 - a name. For us. We'll say origin
and then we'll paste that URL
750:44 - there. We're now saying the the
origin remote repo is good.
750:48 - Gonna be at this URL, we run git
remote dash v, we can see that
750:54 - the origin repo for fetching is
at this branch. And the origin
750:58 - repo for pushing is also at this
branch. So when we want to get
751:02 - new code, a fetch code will
fetch it from here. And if we
751:06 - want to push code up, we want to
give code to the GitHub. We'll
751:09 - also get it from here. So now
we've set the new remote with
751:13 - that remote URL. Now we're going
to actually push the changes to
751:17 - github.com. And the way we do
that is with Git push, and we
751:22 - pick which remote we want to
push to, and we're going to push
751:25 - the origin. And then which
branch we want to push to which
751:29 - we're going to push to Maine,
it'll probably prompt you for
751:32 - your username and your password,
and maybe your email and
751:34 - everything. Now, if
authentication doesn't work for
751:36 - you, for some reason, you can
come over to Settings. Or if you
751:39 - scroll down to developer
settings, Personal Access Tokens
751:44 - and create generate new token,
some token,
751:48 - give yourself repo access, write
access, and hit Generate token.
751:52 - And try to use this token as
your password. Instead, be sure
751:55 - to use the GitHub documentation
and the GitHub discussion
751:59 - associated with this course, if
you get lost or if something
752:01 - doesn't work, as shown here. But
once it's done, once you add all
752:05 - that information in correctly,
you come back to your get up and
752:08 - you will have your first GitHub
repo with all the code and
752:11 - everything in it like this. And
once you complete this step,
752:15 - once you do this, you should
absolutely celebrate. If you
752:18 - like, you can shoot a tweet web
three community in the
752:21 - blockchain community is
absolutely this collaborative
752:24 - space. So Twitter crypto is
where a lot of these people
752:26 - congregate to share ideas. So
definitely be sure to celebrate
752:30 - and share this and be really,
really excited. And shoot a
752:33 - tweet out like this. Give your
friends a high five, share it on
752:35 - Twitter, share it on Discord
shared on Reddit, be excited for
752:38 - how far you've gotten, we've got
a lot more to go. But by
752:41 - completing this part, you have
done fantastically, and I'm so
752:44 - excited for you to start the
next section. Now, we're not
752:47 - going to go over the TypeScript
addition to this because there's
752:50 - nothing really new here.
However, again, if you want to
752:53 - see TypeScript, feel free to
jump into the GitHub repository
752:56 - associated with this course.
753:00 - Alright, awesome. You've just
completed Lesson Seven, the
753:03 - heart had fun me. And now it's
time to move on to lesson eight,
753:07 - which is going to be our HTML
slash JavaScript to fund me, you
753:11 - can find all the code for what
we're about to go through, of
753:13 - course, on my GitHub repo. And
for this section, we're now
753:16 - going to start to see some of
the differences between Node js
753:20 - between that back end
JavaScript, and JavaScript in
753:23 - the browser or front end
JavaScript. And if you come to
753:25 - the GitHub repo associated with
this lesson, our main version
753:28 - we'll be using what's considered
better front end JavaScript. But
753:32 - we'll also have a no JS
addition, as well, if some of
753:36 - the front end JavaScript is
really confusing, and you'll see
753:38 - what I mean with some of those
differences very soon. Now,
753:41 - people can programmatically
interact with our smart
753:43 - contracts at any time. However,
most of our users are not
753:47 - compete developers. So we need
to create a website, we need to
753:49 - create a user interface for them
to interact with our smart
753:52 - contracts and interact with our
protocols. And that's what this
753:55 - section is going to teach us,
it's going to be an introduction
753:57 - to building these fullstack.
building these front ends on top
754:00 - of our smart contracts. Now, I
wanted to show you what this is
754:03 - actually going to look like when
we finish it. Because here,
754:06 - we're actually going to make our
first front end our first
754:09 - website using the blockchain
using web three. And it's going
754:12 - to be an incredibly minimalistic
website. As you can see right
754:16 - here, we're not going to have
any styling, we're just going to
754:18 - show you how to get the
functionality. And additionally,
754:21 - we're going to do a couple of
things that aren't really
754:23 - recommended and are definitely
not best practices. The reason
754:27 - we're going to do it like this
is the same reason that in math
754:29 - class, before you learn the
tricks for derivatives, you
754:31 - learn what a derivative actually
is. We're teaching it like this
754:34 - first, so that you can
understand what's going on on
754:37 - the websites when you interact
with them. And when you work
754:39 - with them. We saw already with
Foston, touching the link where
754:42 - we can connect our wallets and
we can work with the faucets.
754:45 - All decentralized applications
have this website and have this
754:48 - setup where you connect your
wallet and then you interact by
754:50 - clicking buttons, which make
these function calls to the
754:53 - blockchain. And here's going to
be our minimalistic website that
754:56 - does exactly that. So this
section is just going to teach
754:59 - you what's going on under the
hood. So you can really
755:01 - understand how to build these
applications at a professional
755:04 - level. So for this section, if
you don't want to code along
755:07 - with me, you definitely don't
have to however, coding along
755:10 - with me will definitely ingrain
everything in your memory here.
755:13 - So here's what an application is
going to look like. We have our
755:17 - website here, which is connected
to our hard hat, our local
755:20 - blockchain, but it's gonna run
exactly the same as if it was on
755:24 - a real test net, the first thing
you'll notice is in our meta
755:27 - mask, we are not connected. And
we'll go ahead and hit Connect,
755:31 - and meta masks will pop up
asking us if we want to connect,
755:34 - we'll go ahead and connect to
it. And now we'll be able to
755:38 - interact with our heart at
Funmi. You'll notice two buttons
755:40 - here are functions that we're
familiar with, we have our
755:43 - withdrawal function, which is
going to be our withdrawal
755:45 - function that we just created.
And then of course, we also have
755:48 - our fund function here where we
push or we send Aetherium or
755:52 - Matic or whatever, native
blockchain token to our smart
755:56 - contract. So we can do it
through this user interface. So
755:58 - once we're connected, if we want
to see the balance, we can
756:01 - actually right click, hit
Inspect, come over to our
756:04 - console. And we'll print out to
the JavaScript console, the
756:08 - current balance of our smart
contract. So nobody has funded
756:12 - this yet, we can come down, we
can choose an amount we want to
756:15 - fund. So for example, maybe 0.1,
eath, we'll go ahead, we'll hit
756:19 - fund, meta masks will pop up,
we'll get a little council
756:22 - saying funding with 0.1. And
it'll give us all the
756:25 - transaction details that we need
to send 0.1 eath, to our smart
756:30 - contract, we can go ahead and
hit Confirm. And after it's been
756:33 - confirmed after it's been mined
on our local blockchain, we had
756:36 - get balance, we now see that
it's 0.1. We could call fund
756:41 - again, we could have multiple
funders, we could switch between
756:44 - different accounts and fund with
different amounts. And we can
756:46 - see that funding amount
increase, then we can call the
756:49 - withdrawal function. As long as
we're the owner, we can confirm
756:52 - and we can pull out all the
money out of our funding
756:54 - contract. And we'll get balance.
Now we'll see the balance is
756:57 - reset to zero. So this is what
we're going to be building. Are
757:00 - you ready? I sure am.
757:01 - Let's get into it. This is the
introduction to building
757:04 - websites with web three. All the
information here is available in
757:07 - our GitHub repo, so feel free to
follow along there. Alright, so
757:10 - if you're in your heart head
Funmi dash Free Code Camp repo,
757:14 - we're still going to want to
have this open as well. But
757:17 - we're also going to want to
create a new Visual Studio code
757:20 - for working with our new repo.
So let's go ahead and CD down a
757:24 - directory. We'll type MK dir,
we'll call this HTML, Fund Me
757:32 - Free Code Camp. We'll cd into
that. And we'll open this up by
757:36 - typing code period. You can also
do File Open Folder, but we just
757:40 - want to open this up in a new
Visual Studio Code. New VS code
757:45 - will pop up but before we flip
over to that, we do want to CD
757:49 - down CD back into hard hat fun
we Free Code Camp because we are
757:54 - still going to use everything in
here. We're still going to
757:57 - deploy In a smart contract using
this folder and using this repo,
758:01 - when you're building daps, or
websites that are connected to
758:04 - the blockchain, you'll usually
have two repositories or repos.
758:08 - One is going to be for the smart
contracts, like what we see
758:10 - here. This is our repo that has
all the code for our smart
758:13 - contracts. And then you'll also
have one for the front end slash
758:16 - website. And it's going to be
the combination of these two
758:18 - repos, which makes up the full
stack. So when people are
758:22 - talking about full stack,
they're talking about the smart
758:25 - contracts, which is going to be
our back end, plus, plus our
758:31 - HTML slash JavaScript slash
website stuff, which is going to
758:36 - be our front end. So smart
contracts are the back end, HTML
758:39 - slash JavaScript slash website
stuff is going to be our front
758:42 - end. So we have our back end
already. And now we're going to
758:45 - build our front end, we want to
keep this up because we're going
758:48 - to need it to test and interact
with our front end. Awesome. So
758:52 - we have this new folder now,
HTML Funmi, Free Code Camp. Now
758:56 - this course is not a how to
learn front end course, we are
758:59 - going to teach you a number of
front end concepts. But if you
759:02 - want to learn a full traditional
front end course, once again,
759:06 - you can check out Free Code
Camp, they've got a ton of
759:08 - fantastic tutorials, I'm
teaching you front end, if you
759:11 - go ahead and follow along with
me, though, you'll definitely
759:13 - get a basic understanding of
front end as well as front ends
759:17 - and how it relates to our smart
contracts. Additionally, you
759:19 - don't have to do the front end
parts or the full stack parts.
759:22 - If you only want to take this
course, to learn back end and to
759:25 - learn JavaScript, and to learn
solidity and learn how to do
759:28 - these smart contracts
programmatically, then you can
759:31 - absolutely skip these front end
parts. However, if you want to
759:34 - learn to build exciting
websites, and you want to have
759:36 - other people other than
developers interact with your
759:39 - protocols, you definitely want
to watch this part. Now before
759:41 - we actually jump in here and
start writing our code. We need
759:44 - to understand what exactly is
going on when work with one of
759:48 - these websites that use the
blockchain. So I actually made a
759:51 - video about this recently. So
let's watch a segment from that
759:55 - really quick, just so that we
can get up to speed with with
759:57 - exactly what's going on behind
the scenes of these websites
760:00 - that interact with the
blockchain. All right. So here
760:06 - we are, with a website or a
front end on top of some smart
760:10 - contracts that we've deployed,
doesn't really matter what it is
760:12 - right now. This is typically the
interface that you'll see boiled
760:16 - down to a really, really
minimalistic level. Typically,
760:20 - you'll see something like
connect function, right, and
760:22 - Metamask, or some other wallet
connector thing will pop up,
760:25 - we'll hit Next we'll connect
here might even say something
760:28 - like connected. And we can also
execute functions, we can
760:31 - interact with our smart
contracts, we can confirm, etc.
760:33 - Right? This is something you
might see something like Avi
760:35 - right, I'll hit Connect on the
application, it'll say, hey, how
760:39 - would you like to connect? I'll
choose Metamask. I'm going to
760:41 - change my Metamask to main net,
but you get the picture, right?
760:45 - This is a simple example of what
that would look like. So what is
760:48 - actually going on in the browser
when we connect what is actually
760:52 - going on? And what do we
actually need to do, we're going
760:55 - to right click, hit Inspect. And
on the right side, we're gonna
760:59 - see our debugger here. Now if we
go over to sources, on the top
761:04 - of our browser, you'll see a few
things. If you look down over
761:09 - here, right, we'll see this URL,
right, which right now is going
761:14 - to be my localhost. And we'll
also see meta mask and Phantom
761:18 - and a whole bunch of other
stuff. These other things that
761:20 - we see here are going to be
what's injected from our browser
761:24 - extensions. The reason we see
this meta mask thing here is
761:27 - because I've meta mask
installed, right? The reason I
761:30 - see Phantom here is because I
have the Phantom app installed.
761:33 - Meta masks, of course, being an
EVM, wallet and Phantom being a
761:37 - Solana based wallet. Now what
happens when we have these
761:41 - extensions installed is they
automatically get injected into
761:45 - a window object in JavaScript,
and in fact, we scroll down
761:51 - to here in the console, again,
you can find console, you can
761:54 - click here and click anything up
there. And we type in window.
761:59 - We'll see we have this big
window object with all this
762:02 - stuff, right? This window object
represents this our window
762:06 - basically right? Now if we
scroll all the way to the bottom
762:11 - and we do window dot Aetherium.
We also see an object here. Now
762:16 - this window dot Aetherium object
only exists if you have a meta
762:20 - mask or meta mask like browser
or if you want to look at some
762:25 - other web three wallet you do
window dot Solana. So Alana
762:30 - right and we see this window dot
Solana. Now let's look at a
762:33 - browser that doesn't have
Metamask or phantom installed.
762:36 - What do you think is going to
happen in the window now let's
762:38 - go ahead and right click hit
Inspect. We'll go to the
762:41 - console. Now let's see what's
going on in here. If we go to
762:45 - sources, we first off we don't
see that Metamask or that Solana
762:48 - source here. And if we go to
console, we still see window if
762:52 - I let me zoom in a little bit.
We still see window here. But if
762:55 - I do window dot Aetherium If we
get nothing, or if I do window
762:59 - dot Solana, we also get nothing.
So in order for our browsers to
763:04 - know that there's a Metamask, or
that there's a phantom, those
763:08 - extensions automatically add
these to our window objects, and
763:11 - that's something that we can
check for in our JavaScript. The
763:14 - reason these wallets are so
important is built into them
763:17 - underneath the hood, they have a
blockchain node connected to
763:21 - them. And in order to interact
with the blockchain, we always
763:24 - need a note. And you might have
seen URLs from alchemy, or in
763:28 - FIRA because you need them to
interact with the blockchain,
763:32 - Alchemy, and infura are examples
of third party blockchains that
763:35 - you can interact with and
basically rent, right. But you
763:38 - need them to create a provider,
or a node to send your
763:42 - transactions to. So you could do
it in JavaScript, like something
763:45 - like this is the alchemy
documentation where you take
763:48 - that alchemy URL, you stick it
into some object and use that to
763:52 - send your transaction. This is a
way that you could do it in the
763:56 - back end. But on the front end,
what you normally want to use is
763:59 - you just want to use the user's
Metamask, or their Solana or
764:03 - their wallet as the main wallet.
Now, there are a ton of other
764:06 - different types of wallets to
connect, like ledger, mu,
764:09 - Coinbase, wallet, connect, etc.
And there are different ways to
764:13 - set those up. But they all do
the same thing where they expose
764:17 - some URL, they expose some node
under the hood, they give us
764:21 - that URL. They give us that
provider. The way metamath Does
764:25 - it is with window dot Aetherium.
Boom, this is now our URL. This
764:30 - is now our connection. In fact,
if you go up to your Metamask,
764:35 - hit the little three dots,
expand view. hit Add Network,
764:42 - and then just hit the X so we
can get to networks. You can see
764:45 - all of these blockchains that I
have in here all have an RPC
764:49 - URL, this the HTTP RPC URL
connection of the blockchain No,
764:54 - that's running. I happen to have
one running locally right now.
764:59 - All of these also have a node
RPC URL and you can actually see
765:03 - them right in your meta mask
right. This is connected to in
765:06 - Fira, these are all connected to
in Fira. It's all the exact same
765:10 - thing. Meta mask just has a
really nice way of taking that
765:13 - URL, sticking it in the browser
for us in this window dot
765:16 - Aetherium or window dot Solana
you know or whatever. So this is
765:21 - the main thing that we need to
know we need. We always need a
765:23 - connection with the blockchain.
And these browser wallets are an
765:27 - easy way to do that. Make sense?
Great. Let's take this knowledge
765:31 - now. And let's
765:32 - apply it. So in here, let's make
a quick readme.md. Just so we
765:38 - can talk about what we're going
to be making here. So in this
765:40 - section, we're gonna be using
raw HTML slash JavaScript in
765:44 - conjunction with our smart
contracts to build this website.
765:47 - Later on. We will use next Jas
slash react, which is a more
765:52 - modern stack to build our
websites here. But learning
765:55 - understanding how to do
everything with HTML and
765:57 - JavaScript first, is going to
make our lives a lot easier come
766:01 - later on down the road. But as
we know, all websites use HTML
766:05 - as kind of their scaffolding for
what they look like. So let's go
766:08 - ahead and create our HTML for
our website, we'll call it index
766:12 - dot HTML. And this is going to
be the basic scaffolding or the
766:17 - basic bones of what our website
is going to look like. Now, in
766:21 - VS code, if you go ahead and
just type exclamation mark index
766:24 - dot HTML, and you click the
first thing that pops up, it'll
766:28 - automatically populate your code
your file here with some basic
766:32 - HTML setup. If it doesn't do
this for you, feel free to copy
766:36 - paste the basic setup from the
GitHub repository associated
766:40 - with this course, we have our
doctype. HTML, we have some HTML
766:43 - tags telling us that everything
in between here is going to be
766:46 - an HTML, which is great.
However, for simplicity, we
766:49 - don't need most of this. So
we're going to make this a
766:51 - little bit easier. We're going
to delete this line, this line
766:54 - and this line. And we're just
going to change the title to
766:57 - fund me app. And then inside of
our body, we can do something
767:01 - like or Hello. And now we have
the bare bones to create a
767:05 - website just with this. Now to
show this on a website, we can
767:09 - do one of two things. If you are
using Visual Studio code, I'm
767:12 - going to recommend you install
the extension live server. And
767:16 - it looks like this. And I'll
have the extension ID for this
767:18 - extension in the GitHub
repository associated with this
767:21 - course, this is going to allow
us to easily spin up an HTML
767:23 - website. So we'll go ahead and
install this. And if you're not
767:27 - using Visual Studio Code, I'll
show you a different way in just
767:29 - a second. Once this is
installed, you should have this
767:33 - little go live button at the
bottom. And if you don't, you
767:36 - can always open up your command
palette, which again, you can
767:39 - open up by hitting View command
palette, and you can type in
767:43 - live server and just say open
with live server but we're going
767:46 - to just click this go live
button. And it's going to say
767:49 - starting and it's actually going
to open up your browser with our
767:53 - index dot HTML. We can actually
see our website is being called
767:57 - Save on 120 7.0 point 0.1. This
is known as the loopback, or
768:02 - local host endpoint, we're on
port 5501. If you're not
768:06 - familiar with the ports, don't
worry about that for now, we
768:09 - have our index dot HTML here.
And if we change this to
768:12 - something like what's good, we
hit save. If it doesn't
768:16 - automatically refresh, we'd come
over here and refresh. And we'd
768:19 - see that being reflected here.
If you've never created a
768:21 - website before, you've
essentially just done it,
768:24 - congratulations, you might get
this.vs code folder. a.vs code
768:28 - folder allows you to make
settings specifically for the
768:32 - repo that you're working with,
for your code editor for VS
768:35 - code, but we're going to mostly
ignore it for now. Now, if
768:38 - you're not using Visual Studio
Code, what you can do is you can
768:41 - just run this in the browser. So
one thing you could do is you
768:45 - could right click it, and I'm
using a Mac. So I'm going to hit
768:48 - Reveal in Finder, aka reveal
where it's located. And you can
768:52 - just double click it, and boom,
now it's running right in your
768:54 - browser. Instead of pointing to
your localhost, it's going to be
768:57 - pointing directly to your local
file path. Now one final version
769:01 - that we could do that I'm going
to highly recommend you don't
769:03 - do. But it's another option,
we're actually going to download
769:06 - a package for you using no Jas,
which allows us to serve up
769:10 - HTTP. And we're gonna install it
the exact same way we've
769:12 - installed our other packages, we
can do yarn, add dash dash dev
769:17 - HTTP hyphen server. And you may
still want to add it anyways.
769:22 - But now, we'll get some node
modules for this HTTP server
769:26 - package, we'll get a package
json, and of course, a yarn dot
769:30 - lock as well. And what we can do
is we can stop this down here,
769:34 - stop that live server. And if we
go back to our website, refresh,
769:37 - it'll now be blank. And we can
run yarn HTTP server. And this
769:42 - will do the exact same thing.
And we get, and if we come over,
769:45 - and we refresh, we'll see what's
good. Now this one is a little
769:49 - bit more finicky. And after you
make a change, like, Hey, what's
769:52 - good, you might have to close
it, and then reopen it and then
769:56 - refresh. So I do recommend that
if you're on Visual Studio code,
770:00 - you definitely just use this
little go live button, because
770:02 - it'll reflect your changes a lot
nicer.
770:04 - So let's go ahead and hit the Go
Live button. Hey, what's good
770:07 - pops up. Okay, cool. Our HTML is
working perfectly.
770:12 - So the title, of course, is
going to be the Funmi app, which
770:15 - we see up here in the title
section. So let's update this
770:19 - HTML, so that it has those
buttons, and it can actually
770:22 - connect and work with our
blockchain and work with any
770:25 - blockchain. Something else that
you can do in HTML is you can
770:27 - actually write JavaScript inside
your HTML. And the way we can do
770:31 - that is by doing this script
tag, and then we'll do a closing
770:35 - script tag. And anything inside
here inside of our script tags
770:39 - is going to be JavaScript. So I
could do something like console
770:42 - dot log, hi, with a bunch of
exclamation marks, I'm going to
770:46 - save it. We'll go back to our
front end, we're going to right
770:49 - click, we'll hit Inspect, we'll
go to the console. And we can
770:53 - see that Hi prints it out, we
refresh, we can see the hi
770:56 - consistently printed out hi from
script tag, we'll save it, we'll
771:00 - move back, we see hi from script
tag printed out. I know it's a
771:04 - little bit small. So let me zoom
in. Alright, great. So we can
771:08 - type our JavaScript in here,
it's inside the script tag is
771:12 - where we're going to write our
JavaScript to write the
771:14 - functions that our front end is
going to interact with. Now, as
771:17 - we saw before, in this little
console, we can check for window
771:21 - dot Etherium, to see if Metamask
or is installed. And again, a
771:26 - lot of what we're working with
is actually right in the
771:28 - Metamask documentation. If you
go to their basic section, they
771:31 - talk a little bit about the
provider, which is this window
771:34 - dot Aetherium, you can read how
to actually interact directly
771:37 - with meta mask in the meta mask
documentation as well. Now using
771:41 - window dot Aetherium is just one
of the ways we're actually going
771:43 - to connect to the blockchain,
there's actually multiple ways
771:46 - because there's multiple
different kinds of wallets out
771:48 - there. But for now, we're just
going to pretend that window dot
771:50 - Aetherium and meta mask is the
only extension out there. So
771:54 - what we want to do is we want to
check to see if this wind of
771:56 - that Aetherium exists. This is
the first thing that we should
771:59 - be doing. Because if this
doesn't exist, this means that
772:02 - they can't connect to the
blockchain, one of the first
772:04 - things that we're going to want
to do is we're going to want to
772:06 - check to see if that exists. So
we can do something like if we
772:10 - can say type of window that
Aetherium does not equal,
772:17 - undefined. Then we'll do console
dot log, I see a meta mask. So
772:23 - now if we save, we come back to
our front end, we do see I see a
772:27 - Metamask. I've got a Google
Chrome up without Metamask that
772:31 - if we look in the console, and
we hit refresh it the same URL
772:35 - where our live server is
running. We don't see that I see
772:39 - a meta mask because it doesn't
see a meta mask. We can do else.
772:43 - console dot log, no Metamask
refresh, we still see ICD a meta
772:49 - mask where we have a meta mask.
You don't have to open up a
772:51 - browser without one but we see
no meta mask for Chrome because
772:54 - it doesn't see a meta mask. Now
what we could do is We can
772:57 - automatically try to connect to
meta mask if we see that there
773:02 - is a meta mask, right? Remember
how before, when we hit that
773:04 - connect button meta mask popped
up and said, Are you sure you
773:07 - want to connect? So what we can
do is, and you can, again, you
773:10 - can find this in the meta mask
docs, we can run this eath
773:13 - request accounts method, which
is basically going to be how we
773:17 - connect our Metamask. Now, this
is specified by a new EIP and an
773:22 - older documentations. And in
older tutorials, you might see
773:25 - Aetherium dot enable, which
essentially does the exact same
773:27 - thing. So what we could do here
is we could say, a cerium, or
773:31 - excuse me, window dot Aetherium
dot request. And we could put
773:36 - method F request accounts. And
we'll save that. Now if we go
773:43 - back to our browser, we'll
actually see, you'll actually
773:47 - see Metamask, go ahead and pop
up and say, let's connect so we
773:50 - can choose an account. And we'll
hit Connect, will automatically
773:54 - connect our meta mask to our
website. And now if we look at
773:58 - our meta mask, we can see this
little connected thing. It's
774:01 - saying that our account one is
now connected to our website.
774:04 - This means that the website can
now make API calls to our meta
774:08 - mask, we still have to be the
ones to approve them. But it can
774:12 - go ahead and connect and try to
run transactions, which is
774:15 - awesome, which is what we want.
If you want to disconnect, we
774:18 - can go ahead and click that
little button and hit disconnect
774:20 - this account. Well that we have
our code currently is anytime we
774:23 - hit refresh, this is going to
pop up which is going to be
774:26 - really annoying. So what we're
going to do instead is we're
774:29 - going to wrap this up into an
asynchronous function, the exact
774:33 - same as we've been doing, we'll
do we'll create an async
774:36 - function called Connect. And
we'll wrap it up these curly
774:40 - braces here. And then we'll just
format this a little bit to make
774:43 - it look nicer. And now if we
save, we go back to our website,
774:47 - and we refresh. And we go ahead
and disconnect.
774:51 - If we refresh Metamask won't
keep asking us Hey, do you want
774:54 - to connect Hey, do you want to
connect here do you want to
774:56 - connect, because we need to call
this connect function where we
774:58 - can do that is we can add a
little button here. So right
775:01 - underneath our script tag, we're
going to add a button tag. So
775:06 - this is the opening button tag.
And then here's the closing
775:08 - button tag. And inside the
opening button tag declaration,
775:12 - we'll give it an ID, which will
be Connect button. And we'll say
775:16 - on click equals the Connect
connects function. And we'll
775:23 - call this button connect in
between these little button
775:25 - tags, we'll call it connect will
say when we click it will call
775:29 - the Connect function. So if we
save, and we go back to our
775:32 - front end, we can now see we
have a little Connect button.
775:35 - And now if we press Connect,
Metamask is going to pop up,
775:39 - we'll hit next and connect like
that. And boom, now we are
775:43 - connected. And we can even do a
little await here so that we
775:47 - wait for this to finish before
moving on. And then after we
775:50 - connect, we can say console dot
log connected. So let's actually
775:56 - go ahead and test this out,
we'll go back to Metamask. we'll
775:59 - disconnect here, try to never be
on Main net if we don't have to
776:03 - be. And let's go ahead run
connect, we'll hit Next connect.
776:07 - And now we see a little console
dot log come out saying
776:10 - connected. Okay, great. We can
also update our website
776:13 - accordingly. So that we can let
users know that we're connected.
776:17 - So we can grab the connect
button element ID and say that
776:20 - we're connected once we're
connected. So after we await to
776:24 - be connected, we can go ahead
and do document dot get element
776:30 - by ID Connect button. And then
we'll say dot inner HTML equals
776:39 - connected like that. And then
instead of saying no minimize
776:42 - down here, we'll do just the
opposite. So we'll copy this
776:45 - line. And instead of connected,
we'll say please install meta
776:51 - mask. And we'll save we'll go
back to our front end, we'll hit
776:55 - connect. And now if we're
already connected, it'll just
776:58 - automatically go to connected.
If we're not connected, it'll
777:01 - pop up, we'll get connected. And
now we have this button that
777:03 - says connected, which is great.
So now we already know that
777:06 - we're connected. So we've
connected our Metamask to our
777:12 - front end. Now we want to
actually go ahead and do some
777:15 - functions here. And this is
where we want to create some
777:18 - more functions and some more
buttons that are going to use
777:21 - ethers that package that we
become so familiar with. Now, as
777:24 - we code, our script section is
going to get bigger and bigger
777:27 - and bigger. So oftentimes, we
actually want to put our code in
777:31 - a JavaScript file itself. So
we're gonna go ahead, come over
777:34 - here, we're going to create a
new file, and we'll call it
777:37 - index dot j s. And instead of
putting our JavaScript in these
777:42 - script tags, we're going to put
it in this index and then import
777:46 - this index file into our HTML.
And the way that we're going to
777:49 - do that is we're actually just
going to grab this function.
777:52 - We're going to copy it, delete
everything for now. We're going
777:55 - to paste it into our end ext dot
j s, and then in our index dot
777:59 - HTML, we're just going to tell
our script tag to use index.js.
778:06 - So we're just going to say the
source is going to be equal to
778:10 - dot slash index dot j s. And
then we're going to say, the
778:16 - type of this is going to be text
slash JavaScript. Now if we save
778:21 - that, and we save our index dot
HTML, we come back to our front
778:25 - end, we do a little refresh. And
we make sure that we go ahead
778:29 - and disconnect. And we do
another refresh, we can see that
778:34 - even with our index.js in a
different file, because we're
778:38 - doing src equals index.js, and
we're importing it into our
778:42 - HTML, when we hit Connect, it
still calls our Connect
778:46 - function. That's how we can kind
of separate our JavaScript into
778:49 - its own js file that we're a
little bit more familiar with.
778:52 - Now, if you look in the GitHub
repo associated with this
778:55 - course, and you look in the
index dot j s, you'll see our
778:58 - Connect function, we've added
some quality of life stuff,
779:01 - we've added some try catches
just to make handling errors a
779:05 - little bit better, you can go
ahead and add those try catches
779:08 - in yourself if you'd like. But
I'm not going to demo them in
779:10 - this video
779:11 - here. Now we want to create our
fun function. And then later on,
779:36 - we're going to create our
withdrawal function. And this is
779:39 - where front end JavaScript code.
And no Gs are a little bit
779:44 - different. In no JS, we've been
using this require keyword to
779:48 - import dependencies in front end
JavaScript, you can't use
779:52 - require, and it won't exactly
work. Now later on, we're going
779:56 - to use the Import keyword, which
is really the better way to do
779:59 - this. And this is where our
first differences going to be
780:02 - using the Import keyword for
front end is much better than
780:06 - the require keyword, especially
since the require keyword
780:09 - doesn't actually work. And for
those you who might struggle
780:12 - with this disconnect in this
change. Once again, in the
780:15 - GitHub repo associated with
this, we do have a Node js
780:18 - edition of this, where you can
use the require keyword, you
780:22 - just have to go through the
readme and download some
780:24 - packages and run some scripts
that basically transform your
780:28 - code that uses require into code
that works with imports. But
780:32 - we're going to teach you the way
to work with your front end code
780:35 - here using imports. Now you'll
see when we get to next Jas that
780:38 - we will still download code from
node modules and using a yarn
780:43 - lock and a package json etc. So
summary in future seconds, we
780:47 - are still going to do yarn add.
But outside of a framework when
780:51 - we're using this raw JavaScript,
this raw HTML setup, like what
780:55 - we're working with here, we're
not going to be doing yarn, add
780:57 - node modules will add node
modules for framework like next
781:00 - react. But for raw JavaScript,
we'll be using a different
781:03 - syntax, which I'll show you
soon. So let's go ahead and
781:05 - start building our fund function
here. To make our fun functions,
781:08 - what would we normally do? Well,
we'd create an async function
781:11 - called fund. And in this
function, we probably would want
781:14 - to take some ether mount as a
parameter, because we're going
781:18 - to want to fund it with some
amount of Aetherium. When we
781:21 - call this function, we might
want to run console dot log will
781:26 - do a little string interpolation
here. Funding with eth amount,
781:32 - dot dot dot, these semicolons
are going to drive me absolutely
781:36 - insane. So I'm going to add a
our dot prettier dot our rc file
781:40 - into this, and I'm going to go
ahead and add prettier in here.
781:43 - Otherwise, I'm going to lose my
mind. So we're gonna do yarn add
781:46 - dash dash Dev, prettier, just so
we can format our JavaScript
781:50 - with prettier come back to
index.js. I'm gonna hit command
781:53 - S, and it looks like it does
indeed, auto format with
781:55 - prettier now yay, no matter
semicolons, we can call this fun
782:00 - function the same way we call
connect. So in in our index dot
782:04 - HTML, maybe we'll create a new
button. Button. We'll give it an
782:08 - ID of fund will say on click
equals fund. And we'll say fund.
782:18 - And this will be our button
here, we save it, we're looking
782:20 - at our front end. Now the fund
button that if we call, we say
782:24 - funding with undefined because
we're not passing it an amount
782:27 - here. So back in our index
console dot log funding with and
782:31 - we'll just want to make sure
that we can actually call that
782:33 - Funmi function. So we'll copy
this line again and we'll say
782:37 - type of window dot Aetherium
does not equal undefined. We'll
782:40 - go ahead and try to fund here to
send a transaction. What are the
782:43 - things that we absolutely 100%
Always need? Well, we need a
782:47 - provider slash connection to the
blockchain. And we need a signer
782:51 - slash wallet, slash someone with
some gas to actually send it and
782:57 - then And we're probably going to
need the contract that we are
783:01 - interacting with. And to get
that contract, we're going to
783:04 - need ABI and address. And with
these all together, we can send
783:08 - any transaction. So to get our
provider, we're going to
783:11 - actually go ahead and work with
ethers again. Now, we're going
783:14 - to do it a little bit
differently, though, before, the
783:17 - way we worked with ethers is we
said const ethers equals require
783:23 - ethers, right. And this is how
we pulled ethers. And now like I
783:27 - just said to you, though,
require doesn't work in the
783:30 - front end. And we actually don't
want to install ethers with a
783:33 - node modules package. So what we
can actually do instead is let's
783:37 - go to the ethers documentation.
If you go to the Getting Started
783:41 - section, scroll down, they have
a section about importing using
783:46 - Node js, which uses require or
imports. And then they also have
783:51 - some documentation for working
with the web browser. So instead
783:55 - of us doing a node module, what
we'll do is we'll copy the
783:59 - ethers library to our own
directories and serve it
784:02 - ourselves. So what we do is we
can come in here, we can copy
784:06 - this massive file, which is
ethers, but in front end
784:10 - addition, and come back to our
file. And we'll make a new file
784:14 - in here.
784:16 - Called ethers. We'll do 5.6
point esm.min.js. And we'll
784:24 - paste that massive thing in
here. Now, since I have prettier
784:28 - when I save it, it's going to
auto format. And it's just this
784:31 - huge file, which has everything
ethers, but front end defied if
784:37 - you will. Now what we can do is
we can import this into our
784:41 - index.js. So instead of using
require in here, we'll say
784:46 - import ethers from and then
we'll just refer to that file
784:51 - that we just got ethers dash 5.6
point esm.min.js. Now, we only
785:00 - need to do this weird copy
pasting of the file import thing
785:05 - in this HTML JavaScript lesson.
In future lessons with Node js,
785:09 - we are going to do yarn, add
ethers, kinda like we've
785:12 - normally seen. The frameworks
like React and next Jas that
785:15 - we're going to use are going to
automatically convert those yarn
785:19 - added packages to their front
end to five versions. But for
785:23 - this section, this is how we're
going to actually import the
785:25 - ethers package. Now the other
thing we'll have to do is on our
785:29 - front end, we'll have to change
this from type text slash
785:34 - JavaScript to type module
changes. The type module allows
785:39 - us to import modules into our
code, which we're going to be
785:42 - importing this, and we're going
to import another module as
785:45 - well. Awesome. And now though,
if we go back to our front end,
785:50 - do a little refresh with the
connect button, we get Connect
785:53 - is not defined at HTML
button.on. Click, so instead of
785:57 - calling our Connect button from
the front end here, we're going
786:00 - to remove these on clicks from
our index dot HTML, and go into
786:05 - our index.js and add those
connect buttons in here. So
786:10 - we'll say const. Connect button
equals document, dot get element
786:18 - by ID, Connect button. And then
we'll say const. One button
786:27 - equals Doc, you meant dot get
element by ID. One button, the
786:35 - idea of the connect button is
Connect button. The idea the fun
786:37 - button is fun button. And then
we'll say connect button.on
786:43 - Click equals connect. And one
button.on Click equals fond. We
786:53 - go back to our front end, do a
little refresh. We'll hit
786:56 - connect now. And it's actually
working, we'll go to our
786:59 - Metamask will disconnect,
refresh, hit Connect, and boom,
787:05 - it's popping up again. This is
just due to that type being
787:08 - module, if it was text slash
JavaScript, that on click button
787:12 - adding in here, but since we're
doing module, we're going to add
787:15 - those on clicks right in our
JavaScript. But now that we've
787:17 - got ethers in here, what we can
do is we can even do like a
787:20 - little console dot log, just
paste ethers in here, or
787:25 - actually better yet. We'll add
it right above the Connect
787:28 - button. Go back to our front
end, we'll do a refresh and we
787:31 - see the entire ethers object
right in our front end which is
787:35 - perfect, which is exactly what
we want here. And since we've
787:38 - got these two variables here, we
might as well update this to
787:43 - just say connect button dot
innerHTML equals connected and
787:47 - here as well. Connects button
dot innerHTML equals please
787:50 - install meta mask because now
connect button is going to be
787:53 - the same as running this
document dot get element by ID
787:56 - right
787:56 - here. and great. Let's go back
to continuing our font function.
788:03 - So we'll say const provider
equals new ethers dot providers
788:09 - dot web three provider, window
dot Aetherium. Web three
788:14 - provider is an object in ethers
that allows us to basically wrap
788:18 - around stuff like Metamask is
web three provider is really
788:22 - similar to that JSON RPC
provider, which we use before,
788:25 - which is where we put in exactly
that endpoint, our alchemy
788:30 - endpoint, or when we're working
with Metamask. Here, whatever
788:33 - endpoint that we have in our
network section is web three
788:36 - provider takes that HTTP
endpoint and automatically
788:40 - sticks it in ethers for us. So
this line of code basically
788:44 - looks at our Metamask and goes,
Ah, okay, I found the HTTP
788:47 - endpoint inside there, Metamask.
That's going to be what we're
788:50 - going to use as our provider
here. Since our provider is
788:53 - connected to our Metamask. Here,
we can get a signer or we can
788:57 - get a wallet just by running
const signer equals provider,
789:05 - dot get signer, this is going to
return whichever wallet is
789:09 - connected from the provider,
which again, our provider is our
789:13 - Metamask. So if we're connected
with with account one, it's
789:17 - going to return account one as
the signer connected with
789:20 - account two, it'll return
account two, etc. Now, I'm going
789:28 - to add console dot log signer
here, and then flip to the front
789:31 - end now and show you what
happens when we hit the fund
789:34 - button. You can see in here we
have our JSON RPC signer, the
789:38 - signer is going to be the
account that we've connected to
789:42 - our front end. Now we have our
provider, we have our signer.
789:45 - Now, we're going to need our
contract by getting the API and
789:49 - the address. So we're gonna need
to say const. Contract equals
789:53 - what? How are we going to get
our contract? Well, this is
789:57 - where we're going to need to
know the ABI and the address of
790:01 - a working with typically, what
you'll see a lot of projects do
790:04 - since once a contract is
deployed, the addresses are
790:07 - going to change is they're going
to have some type of constants
790:10 - file. So they'll create a new
file called constants, dot j s.
790:17 - And in here, they'll add the
addresses and any API's and
790:20 - anything like that for us to use
in our fund piece here. Now, as
790:25 - we're developing, and as we're
building, this, the backend and
790:27 - the front end team are gonna
have to interact a little bit,
790:30 - or if it's just you doing the
full stack, you're gonna have to
790:32 - interact with their back end. So
this is why it's so important to
790:36 - have both your front end and
your back end code nearby. So if
790:40 - we go back to our Hardhead, fund
me project that we just made, we
790:45 - can find the ABI in here. Once
again, if we go to artifacts, go
790:49 - to contracts, we can go to fund
me dot soul, fund me dot JSON,
790:54 - we can find the ABI right here,
it's going to be this massive
790:58 - thing right here. So you can go
ahead, you can even copy this
791:01 - whole thing in this little non
squiggly bracket and this little
791:05 - bracket here, we can copy that.
And then we can come back to our
791:09 - constant.js. And we can just
save it as variable, we'll say
791:12 - Export const, Avi, e equals and
paste that in there. And then
791:23 - back in our index dot j s, we
can import it with import
791:28 - API from constants. Oops. Okay,
great. So we have the API. Well,
791:38 - what about the address, since
we're going to be running this
791:41 - locally, we want to get the
contract address of this locally
791:44 - run contract, we can do that a
couple of ways. One way is you
791:48 - can just have two windows open
one with your front end code,
791:50 - one with your back end code, and
the one with your back end code,
791:53 - you can run yarn, hard hat node,
which will spin up our
791:57 - blockchain node for us, and give
us the address in here. Or what
792:01 - we can do. And this will
probably be a little bit easier
792:04 - is in your window with your
front end code and create a new
792:07 - terminal. And now we'll have two
terminals running. And then this
792:10 - second one, we're going to CD
down CD dot dot, and then CD,
792:16 - hard hat on Me Free Code Camp.
And in here, we're going to run
792:20 - yarn, art head node. And this is
going to spin up our local
792:25 - blockchain in this second
terminal in here, where we have
792:30 - deploying fund me deploy that
address, blah, blah, blah, right
792:34 - here. And just a reminder, if I
hit this x, it just hides the
792:37 - terminal. I can always pull it
back up with terminal new
792:41 - terminal, and I can always hide
it, but this is still running
792:45 - inside of my terminal. So I'm
going to hide it. And what I can
792:48 - do is I can come back over to
our constants folder, and at the
792:51 - top, we can do export const
contract address. equals, we'll
792:59 - pull the terminal back up. And
we'll go grab, where it says,
793:04 - pulling fund me deployed at
right here. We'll copy that
793:08 - address, put some quotes, and
we'll paste it in. And now we're
793:12 - also exporting the contract
address, then in our index.js
793:17 - will import the contract address
with comma, contract address.
793:23 - And now we have both the ABI and
the contract address. So what we
793:28 - can do, we can say const
contract equals new ethers dot
793:33 - contract of, we'll pass the
contract address, pass the API,
793:38 - and we'll pass it the signer.
Now we have an ethers contract
793:41 - object that's connected to our
signer, and we have the contract
793:44 - address, and we have the
contract abi, now that we have a
793:47 - contract object, we can go ahead
and start making transactions
793:51 - the exact same way we've made
transactions before we can just
793:54 - run const transaction response
equals a weight contract dot
794:02 - fund. And then we'll pass a
value of ethers dot utils dot
794:09 - parse, ether ether mount. So
this is going to be how we're
794:14 - going to go ahead and create our
transaction. And if you take
794:18 - this right now, and we go to our
front, we give it a little
794:21 - refresh, make sure we're
connected and we hit fund, we're
794:24 - gonna get this error value must
be a string. That's because at
794:29 - the mount right now is being
passed in as nothing. Now
794:33 - normally, we'll pass parameters
directly to our functions. But
794:36 - what we're going to do is for
now is we're just going to hard
794:39 - code this. So we'll say const.
At the mount equals, we'll do
794:43 - like 77, or something we had
fun. Now, what do you think's
794:47 - gonna happen? Well, we get this
other air, insufficient funds
794:51 - for intrinsic transaction cost,
or you might get some other
794:55 - error, but you're gonna get a
weird error here. And that's
794:57 - because we're not actually
connected to our local hard head
795:01 - node right now. Well, if we look
at our Metamask, we're currently
795:04 - not connected to the right
blockchain, we're connected to
795:08 - rink B, or main net or whatever,
we need to get connected to our
795:12 - local host. If you look in your
networks, you'll actually have a
795:16 - local host object here already.
But let's just be super
795:19 - specific. And we'll add a new
network here, we're going to add
795:23 - something called our hard hat,
local host. And we'll hit Add
795:27 - Network and we'll add Hardhead.
Local host in here, the RPC URL,
795:30 - we can find from our node area,
which we scroll to where our
795:35 - node is running, we can copy
this URL and paste it into new
795:39 - RPC URL, chain ID is going to be
31337 currency symbol is going
795:44 - to be go or ether. Even though
this pop up says it might have a
795:48 - different currency symbol go,
we're just going to put eath in
795:51 - here. And there is no block
explorer, right? Because this is
795:54 - a local blockchain, we're not
going to have a block Explorer.
795:57 - So we'll go ahead and hit Save.
795:58 - And now we have an account here,
which is great. We're connected
796:01 - to our local blockchain. And if
we switch our meta mask, we can
796:04 - see we're on the local hard hat.
And we are connected. Awesome.
796:08 - Let's refresh. Let's run fund
one more time. And we'll see a
796:13 - transaction does indeed pop up.
This is great. But our account
796:17 - here doesn't have any money we
have, we're broke, we don't have
796:21 - any local Hardhead Aetherium. So
we're actually going to need to
796:24 - import one of our accounts from
hard hat into our meta mask,
796:29 - which we can do so and you can
actually do this for any account
796:33 - with a private key so hard that
gives us these accounts. And
796:36 - we're going to import the
private key of Count zero into
796:40 - our meta mask. So we're going to
copy the private key, we're
796:42 - going to come back to our front
end, click on our meta mask,
796:46 - we're gonna hit this big button,
we're gonna hit import account.
796:49 - It's like type private key, and
we're gonna paste our private
796:52 - key here. A quick note, if you
choose json file, remember how
796:57 - back in that ether section, we
encrypted our key into a JSON
797:01 - file with a password, you can
actually import accounts with
797:05 - that JSON file with the
password. So if you encrypt a
797:08 - key and you want to add it to
meta mask, you can go ahead and
797:11 - add it in just like this. But
for now, we're going to use
797:13 - private key, we'll paste the
private key in and we'll hit
797:16 - import. And we can see we now
have an account, a new account
797:21 - and account three, with a ton of
eath from our local blockchain.
797:26 - So we'll refresh one more time,
we'll go ahead and connect,
797:29 - we'll make sure that our account
three is connected. And if it's
797:33 - not, we'll go ahead and hit this
Connect button. So that now our
797:36 - account three is what's
connected here. And we'll go
797:39 - ahead and hit fund. And we now
see that we can fund this
797:43 - contract, we can go ahead and
hit Confirm. And if we look and
797:48 - nothing's going to happen on our
front end, because we didn't
797:50 - tell our front end to do
anything once we confirm, but if
797:52 - we go to our blockchain, we can
see our fun function was called
797:55 - we've just made our first
transaction on a blockchain from
797:58 - our own front end, this is
awesome, great work. But it's
798:02 - probably a little confusing to
the user. If nothing happens
798:05 - here, they're going to hit the
fun function. And it's going to
798:07 - be like, Oh, okay, cool. What,
what happens? Now, we probably
798:12 - want to make it a little bit
more obvious that something just
798:14 - happened. And one more thing I
want to show you, you don't have
798:17 - to follow along here, if I hit
fund, and then I hit reject,
798:20 - it's gonna freak out on us and
be like, hey, like, you hit
798:23 - reject, I don't know what to do
now. So we're going to make our
798:25 - code a little bit more robust by
adding a try catch. So we'll
798:28 - tell JavaScript to try running
this transaction. And then if it
798:36 - catches an error, just to
console dot log, that error. So
798:41 - now, if I hit fund, and I hit
reject, it's gonna, it'll still
798:46 - be a little bit mad, but at
least we're catching it and it's
798:49 - not going to break and destroy
everything. Okay, cool. We've
798:52 - got a transaction response here.
And when we hit fund, our front
798:55 - end goes great. You've funded me
I'm I'm super confused. Oh, one
799:03 - other point, something that
you'll probably run into
799:05 - multiple times. As we're doing
this. If you get an error that
799:09 - looks like this eath. JS query
while formatting outputs from
799:13 - RPC, nonce to high expected not
to be too but got form, you will
799:17 - definitely see this a whole lot.
Here's what you do to fix this.
799:20 - The reason this happens is
because you've closed your
799:23 - hardhat node and then restarted
it, and your heart had node
799:27 - goes, Okay, well, I'm starting
fresh, I'm starting from zero.
799:30 - But Metamask isn't smart enough
to know that, what we want to do
799:34 - is we want to come to our
Metamask, we'll hit this big
799:36 - button, we'll go down to
settings, we'll go to Advanced,
799:40 - and we'll go to reset account.
And yes, we're going to reset
799:44 - it. This isn't something ideally
that you'd like to do with an
799:48 - actual account with actual money
on a local network, this is
799:51 - fine. Now if you reset the
account, and you reset the node,
799:55 - we can go ahead and hit Confirm.
And it doesn't give us that
799:58 - error anymore. So that's kind of
the tip there, you want to reset
800:01 - the nuts so that our Metamask
and our blockchain are in sync
800:04 - with that nonce number.
800:08 - So we have this transaction
response. And we probably want
800:10 - our front end to give the user
some indication, hey, the
800:14 - transaction went through. So
what we want to do is we want to
800:17 - listen to the blockchain for
this to finish. So we can either
800:20 - listen for the TX to be mined.
Or we can listen for an event.
800:27 - We haven't learned about events
yet. But we will. So for now,
800:29 - since we haven't learned about
events yet, we're just going to
800:32 - listen for the TX to be mined.
Or to listen for the transaction
800:34 - to be mined, we're actually
going to create a new function
800:37 - called function, listen, or
transaction mine in this is
800:44 - going to take as input a
transaction response, and a
800:49 - provider. Now you'll notice this
isn't an async function. For
800:53 - this section. This is
intentional, we don't want this
800:56 - to be an async function. And
you'll see why in a second.
800:58 - We're going to be using
JavaScript promise JavaScript
801:01 - async functionality to its
massive advantage. And this is
801:04 - why JavaScript actually works so
well on the front end is because
801:07 - of how it's asynchronous. So
we're going to create this
801:09 - function listen for transaction
to be mined, we're going to
801:12 - await in our fund function. And
we're going to have this return
801:16 - a promise. Let's go ahead, and
let's learn how to build this.
801:19 - So we're gonna say console dot
log, string interpolation, we'll
801:22 - say mining. And then in here,
we'll say transaction, response
801:27 - dot hash. All of our transaction
response objects have a hash,
801:32 - which just represent that hash.
And we'll do a couple of data
801:36 - dot, we'll put in our console
here, we're waiting for the
801:39 - transaction to be mined, then
what we're going to do is we're
801:42 - going to return a new promise.
And the reason we're going to
801:47 - return a promise is because we
need to create a listener for
801:52 - the blockchain. We want to
listen for this event to happen.
801:55 - But we want to tell JavaScript,
hey, wait for this thing to
802:01 - finish looking, wait for this
thing to finish looking. Now
802:04 - here's where this gets a little
bit tricky. In our fund
802:07 - function. After we create the
transaction, we basically want
802:10 - to tell JavaScript Hey, wait for
this TX to finish. So our code
802:17 - is going to look as simple as
await listen for transaction
802:22 - mine. And we're going to pass it
the trans action response
802:29 - and our provider. So we're
saying hey, listen for this
802:32 - transaction finish. And we're
using this await keyword,
802:35 - because again, the await keyword
says okay, we're gonna stop
802:38 - right here. We're gonna stop
until this function is
802:40 - completely done. Now in this
listen for transaction in mind,
802:43 - we have to define how we're
actually going to listen for
802:46 - this. So we're going to say
listen for this transaction to
802:50 - finish. Ethers actually comes
with a way for us to listen for
802:54 - transactions and listen for
events, which again, we haven't
802:57 - learned About, but don't worry
about that yet. So we can go to
803:00 - the ethers docs. And we can look
up once. Contract dot once.
803:04 - There's a whole bunch of
listeners that we can use to
803:08 - listen for events and listen for
different things to happen, we
803:11 - can do this thing called
provider dot once where we
803:13 - listen for some event. And once
that event fires, we call some
803:18 - other function that we've
defined. Now, we haven't talked
803:21 - about events yet. And again,
don't worry about this quite
803:24 - yet. One of the events that we
can wait for is we can just wait
803:27 - for the transaction receipt to
finish, right, because once we
803:30 - get a transaction receipt, that
means that the transaction has
803:33 - actually finished going through.
So we're going to use this
803:36 - provider dot once syntax to wait
for the transaction receipt,
803:41 - which is going to be our event,
which isn't really an event, but
803:43 - don't worry about that yet. And
then we're going to call some
803:45 - listener function that we
defined, you can also do
803:48 - provider.on, which will trigger
anytime your event fires
803:52 - provider once just triggers one
time, we only care about this
803:56 - transaction going through one
time. So we're passing our
803:59 - provider object. So we're gonna
say provider dot once our event
804:04 - which is just going to be
transaction response, hash,
804:09 - provided on transaction response
dot hash. So once we get this
804:13 - hash, which will pretty much get
right away, we're going to call
804:16 - our listener function. Now we
can create a function listener
804:20 - like this, and then just pass
listener in here. But we're
804:23 - going to do an anonymous
function here, because that's
804:25 - typically what we see as the
syntax for these loops. And so
804:28 - far, we're doing provider dot
once to do this anonymous
804:30 - function, we're going to do just
two little parentheses here. And
804:34 - this arrow notation. So this by
itself represents an anonymous
804:39 - function. So we're saying, hey,
there's some function, it
804:41 - doesn't take any parameters, and
it doesn't have any code, this
804:45 - arrow function, this whole thing
is saying this is an anonymous
804:48 - function. So we're saying
provided at once transaction
804:51 - hash happens, here's the
function that you want to
804:53 - execute. It doesn't do anything
right now. But let's have a do
804:56 - something. So once this
transaction dot response
804:58 - finishes, we're going to take a
trans transaction received as an
805:05 - input parameter, or our our
callback function, or our
805:09 - listener function. And all we're
going to do is we're gonna say
805:12 - console dot log, completed with
a little string interpolation,
805:19 - transaction receipt, that
confirmations, confirmations,
805:24 - and then completed with
transaction receipt,
805:26 - confirmations, confirmations. So
once this provider dot once sees
805:30 - that there's a transaction hash,
it's going to give as an input
805:34 - rammer to our listener function,
the transaction receipt, kind of
805:37 - that same syntax that we've been
seeing this whole time, once a
805:40 - transaction response finishes,
we get the transaction receipt,
805:43 - and we can do stuff with it. And
we see how many block
805:45 - confirmations it has. For us,
this pretty much should always
805:48 - be one. Now if we save this, go
back to our front end, and we
805:52 - hit fund, it's going to work,
we're going to give the user
805:56 - some indication that it worked,
which is great. But it's not
805:59 - really going to work the way
that we want it to work. We have
806:02 - this console dot log done right
after we do the await, listen
806:05 - for transaction mine, and we
come back and we hit fund, we
806:09 - hit confirm, it actually doesn't
go in the order that we want it
806:13 - to go, it goes mining this thing
that it says Done. And then it
806:18 - says completed with one trip
confirmation what what's going
806:21 - on here, we should write
completed before we write done,
806:26 - because that's the order that we
have this in. But it looks like
806:28 - it's words, it's going out of
order. What what's going on
806:32 - here, what's going to happen is
when we call listen for
806:35 - transaction mine, or listen for
transaction, mine function is
806:40 - going to kick off, but it's
going to kick off provided on
806:44 - once as its own process. So
await listen for transaction,
806:49 - mine will kick off the listener,
but it doesn't wait for this
806:53 - listener to find the transaction
response. So this function will
806:57 - actually finish before provider
dot once finishes. So after it
807:04 - kicks off the listener, it'll
run to the next line of our
807:08 - code, which is console dot log
and done. Our front end we'll go
807:12 - oh, oh, you kicked off a
listener earlier. Let me go back
807:15 - down and let me recheck to see
if it's finished. And if it has
807:20 - finished, I'll go do what it
told me to do. And this is where
807:23 - what's known as the event loop
kicks in.
807:25 - We don't actually wait for this
provider that wants to finish,
807:28 - we add this provided at once
onto this queue called the event
807:32 - loop. And our front end is going
to periodically check back to it
807:36 - to see if it's finished. So we
want to adjust our code. So we
807:40 - wait for the listener to finish
listening, which is where we're
807:43 - going to get into promises here.
So what we want to do is we want
807:47 - to adjust this function to now
return a promise. And we're
807:50 - going to use this syntax a
couple of times in the future.
807:53 - So what we're going to do is
we're going to say hey, we want
807:55 - to wait for the listener To
finish listening, we're going to
807:59 - wrap this whole thing into a
promise. And we're going to say
808:02 - return, new promise. And a
promise takes a function itself
808:08 - as an input parameter. So again,
we'll use kind of this anonymous
808:12 - function notation. And it will
take two input parameters
808:15 - resolve and reject. So resolve
says, hey, if this promise works
808:21 - correctly, call this resolve
function. And for us, this
808:24 - promise is going to be done when
the listener finishes listening.
808:28 - And then we would reject if
there was some type of timeout,
808:31 - we're not going to write the
reject function. But in the
808:34 - future, if you were to do this
for production, you'd add some
808:37 - timeout as the reject parameter.
Basically, you're saying, hey,
808:40 - once the listener finishes
listening, we're going to
808:42 - resolve and if it takes too
long, we're gonna say ask for
808:45 - you, you took too long, and
instead of closing it off, here,
808:47 - we're going to close it off
around this provider thing. So
808:52 - we're gonna say return new
promise, resolve, reject. And
808:55 - only once this transaction gets
fired, are we going to resolve
809:00 - this promise, like so. So what
is happening here, so we're
809:05 - going to put the resolve inside
of this provider at once. So
809:10 - we're saying, once this
transaction hash is found, then
809:15 - we're going to call this
function, we're gonna say
809:18 - console dot log, and then we're
going to resolve so this promise
809:21 - only returns once a resolve or
reject is called. And we're
809:25 - telling it only resolve only
finish this function once.
809:31 - Transaction response dot hash is
found, because it's going to be
809:34 - inside of these little squiggly
parentheses for provider dot
809:38 - once, the promise right now only
resolves after it's fired. It's
809:43 - event here. If this was really
confusing, just copy paste this
809:47 - and move on, we're getting a
little bit deeper into front end
809:50 - stuff here. So hopefully, this
was clear, if not definitely
809:54 - jump in to the GitHub
discussions to start asking
809:56 - about this stuff. But now that
we've updated this, we can come
810:00 - back to our front end, we can
hit the fund button. And
810:03 - hopefully this time, everything
will go in order. We'll hit
810:06 - confirm, we see mining
completed, and then we see done.
810:10 - And the reason for this is
because again, our await keyword
810:14 - is now waiting, it says oh,
you're returning a promise, I
810:17 - need to await I need to wait for
it to resolve or reject. And we
810:21 - only resolve the promise once
our provider finds this
810:25 - transaction hash and this
transaction receipt, this is
810:27 - this listen for transaction
mine. In future sections, all of
810:31 - this is going to be abstracted
away for us. So life is going to
810:33 - be much easier, but it is
important to understand what's
810:36 - actually going on here. Awesome.
So now we're giving the front
810:39 - end some indication of what's
going on. Our fun function is
810:47 - done well, no, not really. Why
not? Well, because right now
810:52 - we're hard coding the eath
amount to 0.1. And on the front
810:55 - end, we probably don't want to
hard code it, we probably want
810:57 - to allow users to fund as much
or as little as they want. So we
811:02 - actually need to change this
from just a button to a input
811:05 - form. So to do this, we're gonna
go back over into our HTML. So
811:09 - we'll go back to index dot HTML.
And we're going to change this
811:13 - fun section here, we're going to
add some form information. So
811:15 - we're going to keep this button
as it is, or we're going to add
811:18 - like a little text box to input
as much eath as they want. So
811:22 - I'm going to create a label,
we're gonna say it's for, it's
811:26 - going to be fund and this label
we're gonna say, is eath amount,
811:30 - and then we're gonna close
label, this is basically just
811:32 - going to create a label. And if
we go back to our front end, we
811:34 - now just have this Etham out
label that isn't labeling
811:37 - anything. Now we're going to
create an input, and we're going
811:40 - to give it an ID of eath amount.
And we're going to give it a
811:45 - placeholder
811:47 - of 0.1. And then we're gonna
close the input. So now if we
811:53 - flip to our front end, we have
eath amount, labeling this
811:56 - little text box with a
placeholder of 0.1. And we can
811:59 - add stuff in here, you know,
blah, blah, whatever. And one
812:02 - more thing, if you have some
tags, but you don't put anything
812:05 - in between them, you can
actually shorten it by just
812:07 - putting the little closing thing
at the back of it like this. So
812:11 - if you don't have anything
between your tags, you can just
812:13 - close them like this, these two
are equivalent, boom, boom,
812:17 - boom, boom, those are the same
thing. Great. When we called
812:20 - fund right now we're calling
fund and we're not passing any
812:22 - parameters. Let's update our
fund to no longer be hardcoding
812:27 - eath amount in here, and we'll
have and we'll have our fund
812:30 - function populated by whatever
we put in this eath amount input
812:36 - box in our fund function,
instead of saying const eath
812:39 - amount equals 0.1. We'll grab it
from this eath amount ID and
812:45 - we'll say document dot get
element by ID eath amount, dot
812:53 - value. So we're going to grab
whatever value In this input box
812:59 - here, now, in our index.js, we
have console dot log funding
813:02 - with eath amount, if in our
front end, we do 1.7. And we hit
813:07 - fund, we now see in our console
dot log, it says funding with
813:11 - 1.7. And we'll get 1.7. And our
little fun section confirm, it
813:16 - will mine it, it'll complete it,
and then say, done. Awesome. So
813:20 - now we've added a little text
box here. So people can fund as
813:24 - much or as little as they want.
Perfect, this whole thing can
813:27 - kind of be considered a form.
There's also a form tag, but
813:31 - we're going to just use this for
now. All right, great. We're
813:36 - doing a lot of funding right,
and we keep funding our contract
813:39 - with more and more Ethan, we
keep adding more and more stuff,
813:42 - we probably want a button to
keep track of how much is
813:45 - actually in here. So let's just
add a really simple balance
813:48 - button. And let me actually just
move this down to the bottom
813:51 - here, much better. So we'll say
button, id equals balance
813:56 - button. We'll call it get
balance. Now we have a get
814:03 - balanced button. And it's not
going to do anything because we
814:05 - don't have a get balanced
function. So let's go back to
814:07 - our index.js. And we'll create a
get bounced function async
814:13 - function get bounce. And we'll
just do what we've been doing so
814:17 - far. If type of window dot
Aetherium does not equal,
814:23 - undefined, then we're going to
do const provider equals new
814:27 - ethers, ethers, dot providers
dot web three provider of
814:34 - window, that Aetherium then will
do const balance equals awaits
814:40 - provider dot get balance,
contract address, which again,
814:46 - we're importing way up at the
top, and then we'll just do
814:50 - console dot log ethers dot utils
dot format, ether, bounce this
814:59 - format ether function ethers
utils, which you can find in the
815:02 - documentation to make reading
ethers, formatted numbers much
815:06 - easier to read. Then same as
what we've been doing before,
815:10 - we're going to go up, we're
going to copy this fun button
815:13 - line, paste it will say balance
button equals document dot get
815:19 - element by ID, balance button.
And then we'll say balance
815:26 - button on click equals get
balance, we're gonna come back
815:31 - to our front end, we'll do a
quick refresh, we'll do get
815:34 - balance. And now we can see the
balance in the console, we can
815:37 - fund with more like 1.8, we'll
hit fund metamath pops up, we'll
815:42 - go ahead and confirm mining
completed done, we hit get
815:46 - balanced, and now we're at 3.8.
Fantastic. Alright, let's keep
815:53 - it going. What do we need to do
next, we're gonna go ahead and
815:55 - eat our withdrawal function
here. So let's create that this
815:58 - is gonna look really similar to
everything we've done so far. So
816:01 - on our index dot HTML, let's
create a new button that we can
816:04 - do by copying this whole line,
paste it underneath, call this
816:09 - withdraw button, we'll call
withdraw. And we'll call this
816:13 - withdraw. And then in our index,
do the same thing, we'll copy
816:18 - this, paste it below. So with
drop button was document get
816:25 - element by ID, withdraw button,
withdraw button.on Click equals
816:31 - withdraw. So let's make a
withdrawal function down at the
816:34 - bottom. We'll go ahead, say
async. Function withdraw,
816:40 - will do the exact same that
we've done above. And I can even
816:43 - just copy everything from the
get balance and just remove the
816:48 - balance section. If type of
window dot Aetherium does not
816:51 - equal to undefined, then we'll
grab the provider here. And same
816:56 - as the fund contract, we'll grab
the signer and the contract. So
817:00 - let's just grab those two lines.
Paste them down here called
817:03 - signer equals provider dot get
signer. Contract equals new
817:07 - contract, blah, blah, blah.
Okay, cool. Now we're gonna do
817:09 - the exact same here as we did
with the fun function. So we're
817:13 - gonna do a little try, catch,
and then we'll even add the
817:15 - catch here, catch error, console
dot log error. And inside of our
817:21 - try, we'll do const transaction
response equals await, contracts
817:29 - dot withdraw. We don't need to
put any parameters in here. Oh,
817:33 - then actually, let's do a little
console dot log, withdrawing,
817:39 - and then we'll get this
transaction response. And then
817:41 - we'll listen for this
transaction to get mined as
817:43 - well. By running a Wait, listen
for transaction mine transaction
817:52 - response comma, provider And
that's it, since we can reuse
817:59 - the functionality from our
listen for transaction mine. So
818:02 - now we'll refresh, we'll make
sure we're connected, check the
818:05 - current balance, which is 3.8.
Now we'll go ahead and withdraw.
818:11 - We see our little withdrawing
console dot log, we'll hit
818:14 - Confirm. And it looks like we've
completed it, if we look in our
818:19 - Metamask, our bounced will have
been increased by the amount
818:23 - that was added here. And now if
we hit balance, we do indeed see
818:27 - zero, we can even double check
that this is actually working,
818:30 - we can see our balance is 9.99.
Let's go ahead and even fund
818:34 - this with 99 eath. Good confirm,
looks like it's completed. Our
818:39 - meta mask now shows 99.00. And
if we go ahead and withdraw,
818:44 - confirm, that withdrawal has
gone through, we can see our
818:48 - balance is back up to 9999. And
now let's just go back and
818:55 - change. Hey, what's good. We'll
refresh our front end. And now
819:00 - we can see you've done it, we've
created a minimalistic website
819:04 - that allows us to connect to the
blockchain and call functions
819:07 - from a front end. And from a
website, this is absolutely
819:10 - massive, you should be
incredibly proud and incredibly
819:13 - excited with yourself. Now, this
is definitely a minimalistic
819:16 - version. And we're going to work
with more powerful and more
819:19 - modern front end frameworks. But
this will give you an idea of
819:22 - exactly what's going on behind
the scenes when we're working
819:25 - with those more advanced front
ends, and we'll style them up.
819:28 - So they look a little bit better
than this. But with that being
819:31 - said, you've just learned the
basics of how these front ends
819:34 - work. And now that you know how
to push things up to get, I
819:37 - highly recommend you start
pushing all of these projects up
819:40 - to your GitHub, they will be a
record that you've actually done
819:43 - the work and you've built these
smart contracts. And if you're
819:45 - looking to get an internship
down the line, if you're looking
819:47 - to help other GitHub projects,
this will be a record of hey, I
819:51 - can do this, what I can build
look at what I know how to do so
819:54 - congratulations on your first
full stack or your first front
819:57 - end application. Before we move
on, let's do a quick refresher
820:00 - of everything we've learned
here. So number one, typically,
820:03 - you want the repository or your
code base. For your back end for
820:07 - your smart contracts to be a
different repository than your
820:09 - front end, your front end code
is going to be a combination of
820:12 - HTML and JavaScript. When we
have a wallet like meta mask,
820:15 - we're injecting these browser
based wallets into the window
820:18 - object of our browsers like
window dot Aetherium. Each
820:21 - browser will have a different
extension here, reason we do
820:24 - this, we want to connect to the
RPC URL that's built into our
820:28 - meta masks. And in this way,
we're making the same API calls
820:31 - to an RPC URL as we do in hard
hat as we do in remix as we do
820:34 - in ethers, etc, we created our
first promise based function
820:38 - where we had a listener kickoff,
and we wrapped it in a promise
820:42 - to say, hey, we want to wait for
our listener to finish since
820:46 - this is a promise based
function, we set a weight listen
820:49 - for transaction mind and we
waited for this transaction to
820:52 - finish so that on our front end,
once our transaction finished
820:55 - going through, we can tell the
user it's finished going through
820:57 - and we can continue doing other
stuff. Give yourself that round
821:00 - of applause and let's move on to
the next section.
821:04 - All right, welcome to the next
section. We are now on Lesson
821:08 - Nine, our hardhat smart contract
lottery, which again, all the
821:11 - code for this section is going
to be available in the GitHub
821:15 - repo associated with this
course. Alright, so let me show
821:17 - you what we're about to build.
I'm going to show you the front
821:20 - end login, you don't have to do
the front end, if you don't
821:22 - want. But the front end does
give us a nice way to visualize
821:25 - the lottery that we're building.
Here, we're building an
821:27 - application that allows users
completely decentralized to
821:30 - allow us to engage in a fair, a
verifiably random lottery. This
821:35 - is the application that would
actually fix the McDonald's
821:39 - issue that we talked about much
earlier. So first, we got this
821:42 - Kinect Wallet button that we're
going to click to connect to
821:45 - meta mask. And here, we're
actually going to show you how
821:48 - to connect to more than just
Metamask wallet connect to trust
821:51 - wallet, math, wallet, any of
these wallets, and we'll show
821:53 - you how to customize even more.
So we're going to connect to
821:56 - Metamask. Here, we'll choose our
account that we imported in from
822:00 - Hardhead, we choose Next we're
gonna choose Connect. And
822:03 - remember, for our front end bit,
we're gonna go to Settings
822:06 - Advanced reset account, if we're
working with a brand new hard
822:09 - hat blockchain. Now, the front
end doesn't look super nice, but
822:12 - we have an enter raffle button.
And we have a little bit of UI
822:15 - talking about the current number
of players and then the most
822:18 - previous winner of a raffle. So
we can go ahead and enter the
822:22 - raffle and allow anybody to pay
0.1 eath. To enter our smart
822:27 - contract, we get a little
transaction saying transaction
822:30 - complete, and we get the current
number of players is one, we can
822:33 - continue to enter the raffle and
anybody can enter this raffle.
822:37 - And this, the smart contract
will keep track of all the
822:40 - players in here, we're going to
run this on a timer, the lottery
822:43 - is going to automatically
trigger somebody to win. And to
822:46 - do this, to get a pure
verifiable random number, we're
822:49 - going to be using chain link VRF
to get a pure verifiably random
822:53 - number. And then we're gonna use
chain link keepers to trigger
822:57 - the automation to automatically
have one of these winners get
823:01 - picked every time one of those
time intervals is up. Once the
823:04 - keepers kick it off, they will
pick a winner, our decentralized
823:07 - lottery will say the most
previous winner is so and so.
823:10 - And they will get all the money
from this lottery making a
823:13 - perfectly fair decentralized
lottery, we're going to call our
823:17 - contract, raffle dot soul but
you can call it lottery dot soul
823:20 - or really whatever you want. And
we're going to make it look
823:22 - really, really nice. So now
we're back in our Visual Studio
823:25 - code. This is going to be the
project. If you learn this, you
823:28 - have the skills to learn all the
rest of the smart contract
823:31 - concepts, and you are going to
be able to do great things in
823:34 - the space. This is going to be
your flagship project, this is
823:37 - going to be the one that you can
be the most excited and the most
823:40 - proud about for this tutorial.
So let's go ahead and let's
823:46 - create a new folder. So we're
gonna do MK dir, hardhat, smart
823:50 - contract lottery, FCC or smart
contract, raffle, whatever you
823:55 - want to call it, then we're
going to cd into our hard hat,
823:58 - smart contract lottery Free Code
Camp. And we're going to type
824:01 - code period, or we're going to
open this up in a new folder,
824:04 - however we choose to do. So now
that we're in our new folder,
824:07 - we're going to create our new
hard hat project. So we're going
824:11 - to do yarn, add dash dash dev
hard hat. And we'll get our node
824:19 - modules are package dot JSON and
our yarn dot lock. Now we'll do
824:23 - yarn hardhat. To get started
with a new project, and we're
824:26 - just going to select create an
empty hard hat dot config dot j
824:30 - s because we know what a basic
project looks like. And we're
824:32 - gonna give this project the
customizations that we want to
824:35 - see, we're going to create an
empty hard hat dot config. And
824:37 - now in here we have a blank
hardhead.config.js with almost
824:42 - nothing in here. So we're
starting completely from
824:44 - scratch. Now we're going to add
all of our dependencies in here.
824:47 - And oftentimes, you'll add these
sequentially as you build but
824:50 - we're just going to add them all
in one line, and there are a lot
824:54 - of them. So we've left a copy,
paste the whole section of the
824:57 - full blockchain solidity course,
J S, for you to just copy,
825:00 - paste, so you can install
everything in one go. So grab
825:03 - that line, and it's going to
have everything that we've been
825:05 - talking about. And we'll just
hit enter, and we'll install all
825:09 - of these.
825:10 - And as you create more and more
projects, you'll get the feel of
825:13 - what you like for your
dependencies and what tools that
825:16 - you like to use. Remember, at
the end of the day, the tool
825:20 - that's best for you and best for
the job is the tool that you
825:23 - like the most. There never
really is a one tool fits all,
825:26 - there's almost always going to
be trade offs. Alright, now that
825:30 - we have all those dependencies
installed, if we look at our
825:32 - package, JSON will have this
massive dev dependencies, we'll
825:36 - have everything in Node modules
will have everything in yarn dot
825:38 - lock. And of course, as we know,
in order for any of these to
825:41 - actually work, we need to add
them into our Hardhead config.
825:45 - Now, there's a lot of stuff to
add in here as well. So like
825:48 - once again, if you want to come
to the heart at smart contract,
825:51 - lottery, FCC, and go to the
Hardhead config, you can just
825:55 - copy paste everything and place
it into your project so that you
825:59 - don't have to always type
everything out yourself. Meclabs
826:02 - Hardhead waffle anomic labs
started ether scan harder to
826:05 - deploy slitted coverage, or had
gas reporter heart had contract
826:08 - sizer, which we haven't talked
about yet. But we will Don't
826:10 - worry. And then require dot env
dot config. And as you all know,
826:14 - all these little semicolons are
popping up and those are going
826:17 - to drive me absolutely crazy. So
once again, we can create a dot
826:20 - prettier, RC. And if you want to
copy this as well, from one of
826:25 - your previous projects are free
to do so. One thing that I added
826:29 - in here was a print width of
100. This just changes how long
826:33 - a line can be before it goes on
to a new line. That's the only
826:36 - difference here. Now if we go to
our config and hit save, they go
826:39 - away, thank goodness. Now if we
look at our solidity version,
826:43 - we're currently using zero point
7.3. Let's go ahead and update
826:47 - that to 8.8 or 8.7, or whatever
you want to use. Now that we
826:50 - have all the basic setup, we can
begin coding our smart
826:53 - contracts. So we first need to
create a new folder called
827:00 - contracts where we're going to
store all of our contracts. And
827:03 - let's go ahead and create a new
file called lottery dot soul or
827:07 - raffle dot soul or whatever you
want to call it. I'm going to
827:09 - call mine raffle dot soul. And
you might see this indexing
827:13 - thing happened from time to
time. It's our hard hat,
827:16 - solidity extension, indexing all
of our node modules. So it knows
827:20 - how to highlight things and
knows how to work with
827:22 - everything in our solidity
files. So that's what happens
827:25 - when that pops up. Now before we
jump in and create it, let's
827:28 - figure out what we're going to
do. So we're going to create our
827:31 - raffle contract. And what do we
want people able to do? Well, we
827:34 - probably want people be able to
enter the lottery, you know,
827:37 - paying some amount, we're
probably going to want to be
827:40 - able to pick a random winner.
But we want this to be
827:44 - verifiably random, we want this
to be untampered with a bowl.
827:47 - And we also want winner to be
selected every X minutes or
827:53 - years or months, aka we want
this to be completely automated.
827:57 - So we want to deploy the smart
contract and almost have no
828:00 - maintenance almost have nobody
ever have to touch it again. And
828:03 - it'll just automatically run
forever. This is the power of
828:05 - smart contracts. As we know,
since we're picking a random
828:08 - number, and we have some event
driven execution, we know that
828:12 - we're going to need to use a
chain link Oracle, since we're
828:15 - going to need to get the
randomness from outside the
828:17 - blockchain. And we're going to
need to have that automated
828:21 - execution. Because a smart
contract can execute itself, we
828:25 - need somebody to automatically
trigger these. So to trigger
828:28 - selecting a winner, we're gonna
have to use the chain link
828:31 - keepers. And that's pretty much
going to be our entire code.
828:34 - Now, I usually like to do this
before I start any project. And
828:37 - the reason that I do a little
bit of brainstorming is because
828:39 - we don't want to just jump in
and really do anything, we want
828:42 - to have a good idea of what
we're trying to build so that we
828:45 - can write tests for it, so that
we can know if we're going in
828:48 - the right direction, etc. Now
that we have a good idea of
828:50 - where we're going, let's build
it. So per usual, let's do spdx
828:55 - license identifier. And my team
will do pragma solidity little
829:01 - caret here, zero point 8.7, even
zoom out, just a hair will trash
829:05 - that and we'll say contract,
raffle, we can even make sure
829:09 - that we're not going crazy by
doing a little yarn Hardhead
829:12 - compile and compiled
successfully, we want it to be
829:15 - able to enter the lottery want
us to be able to enter it. So
829:18 - maybe we'll create a function
called enter raffle. What else
829:22 - do we want to do, we want to be
able to pick a random winner. So
829:25 - maybe we'll create a function
called pick a random winner, and
829:30 - boom. So let's comment out pick
random winner for now. And let's
829:33 - just work on this enter raffle
thing. In the past, we've
829:36 - created projects like Funmi,
where people can send ether to
829:39 - our contracts or send whatever
native blockchain token to our
829:42 - smart contracts using the
message dot value based off of
829:45 - some USD value. For this one,
we're just going to have the
829:48 - entrance fee instead be USD
based, it's just going to be
829:51 - that native asset. So for our
enter raffle, we don't have to
829:53 - set a USD price, we can just set
a minimum eath price. So up at
829:57 - the top, let's pick our minimum
price. So we'll do a un 256
830:01 - entrance fee. And now some of
our learnings from our last
830:05 - section should come in here, we
now know that this entrance fee
830:09 - is going to be a what, it's
going to be a storage variable.
830:12 - So let's prepend it with s
underscore let's make a private
830:15 - variable because we always want
to set our visibility. But let's
830:18 - have the entrance fee be
configurable. Well, let's create
830:21 - a constructor now. And we'll
have this entrance fee be
830:24 - settable in our constructor, so
our constructor will take a UNT
830:27 - two to the sixth entrance fee, s
underscore entrance fee equals
830:33 - entrance fee. Well, if we're
gonna only set this one time, we
830:36 - might as well make this a
constant or an immutable
830:38 - variable. So let's make this an
immutable variable so that we
830:41 - save some gas we'll change this
from S to I and now we're saying
830:46 - you interviewed six private
immutable I entrance fee equals
830:50 - entrance fee. Now we probably
are going to want other users to
830:53 - see the entrance fee. So down
below, we can create function
830:56 - get entrance fee, and this will
be a public view function which
830:59 - will returns a UN to the set
Next, and we'll just say return
831:04 - entrance fee. Now we have a
function that users can call to
831:07 - get the entrance fee. But we, as
developers can use this AI
831:10 - entrance fee to know this is an
immutable variable. This is
831:13 - pretty cheap gas wise for us to
read from in our enter raffle,
831:17 - we've done a ton of these
before, all we need to do is we
831:20 - just need to require the message
dot value is greater than that I
831:24 - underscore entrance fee, what
we've learned before about those
831:27 - error codes, so we could use
require message dot value, or we
831:32 - could do one of these customers,
which is going to be a lot more
831:35 - gas efficient, because instead
of storing this string, we're
831:38 - just going to store an error
code in our smart contract. So
831:41 - let's do that. Instead, we'll
say if the message dot value is
831:44 - less than our eye entrance fee,
831:48 - then we're just going to revert
the whole transaction with some
831:52 - error code. And we'll use a best
practice naming raffle
831:56 - underscore underscore not enough
eath entered. And we'll grab
832:02 - this arrow code. And we'll have
if the user doesn't send enough
832:06 - value will revert with not
enough eath entered now that we
832:10 - know they're calling into raffle
with enough value, we're
832:13 - probably going to want to keep
track of all the users who
832:16 - actually enter our raffle. That
way, when we pick a winner, we
832:19 - know who's in the running. So
let's create an array of players
832:22 - at the top error here. And then
just to make this look even
832:26 - nicer, we'll do a little comment
here. And we'll say state
832:29 - variables. And we'll combine
both our storage and are not
832:32 - storage variables just in this
state variable section. So we'll
832:35 - do address array players. Now
players, of course, is going to
832:41 - have to be in storage, because
we're going to modify this a
832:43 - lot, we're going to be adding
and subtracting players all the
832:45 - time. So we're going to do s
players will make this private
832:49 - as well. And we're going to make
this address payable players
832:53 - because one of these players
wins, we're going to need to
832:55 - have to pay them. So we'll make
this address payable private as
832:59 - players. And since we're going
to make this private, and it's
833:01 - probably good that we know who's
in the players array, we'll even
833:04 - do function it player. This will
be a public view that returns an
833:09 - address of one of these players.
And we'll just return s players
833:15 - of index will have this
function, take a un 256 index as
833:19 - an input parameter, we know that
players is going to be a storage
833:22 - variable. And we're going to add
it to our enter raffle Oh, and
833:25 - we definitely want our Inter
raffle to be public and to be
833:29 - payable. Since we're having
people send message dot value,
833:33 - and we want anyone to be able to
enter our raffle. So it'll be
833:36 - public, it'll be payable, it'll
be perfect. Now that we have our
833:39 - array, and someone's entered the
raffle, we'll do s players dot
833:43 - push message dot sender. Now,
this doesn't actually work
833:49 - because message dot sender isn't
a payable address. So we'll need
833:52 - to typecast it as a payable
address just by wrapping it in
833:56 - payable. So now we have a way to
keep track of all the players
833:59 - that are entering
834:00 - a raffle. Now one of the
concepts that we haven't gone
834:05 - over yet is actually going to be
events. And events are really
834:08 - important to our smart
contracts. Whenever we update a
834:11 - dynamic object, like an array or
a mapping, we always want to
834:15 - omit an event when we get to
less than 10. And then
834:18 - especially less than 15 with the
next Jas and if T marketplace,
834:22 - these events will make a ton of
sense, especially for front end
834:25 - developers. So right now events
might be a little bit of a weird
834:29 - thing for you as we explain it.
But as we continue on, they'll
834:32 - start to make more and more
sense. So we're going to start
834:34 - adding events to our smart
contracts. Whenever we update
834:37 - one of these dynamically sized
data structures. And to learn
834:40 - more about events and how to use
them. We're gonna watch another
834:42 - video that explains all about
events. You can actually follow
834:45 - along with this video as a side
project. But let's learn all
834:48 - about events. Now, if you've
worked with solidity, you've
834:50 - probably seen these things
called events before or maybe
834:54 - you haven't seen something like
events. But you've always
834:56 - wondered how chain link or the
graph or some of these other off
834:59 - chain protocols work under the
hood. And in this video, we're
835:02 - gonna learn about logging and
events in solidity, viewing
835:05 - those events on ether scan, and
then working with them in hard
835:08 - hat. Now it's the Ethereum
virtual machine, or EVM. That
835:12 - makes a lot of these block
chains tick, like Aetherium. And
835:15 - the EVM has this functionality
called a logging functionality.
835:19 - When things happen on a
blockchain, the EVM writes these
835:22 - things to a specific data
structure called its log, we can
835:26 - actually read these logs from
our blockchain nodes that we
835:28 - run. In fact, if you run a node
or you connect to a node, you
835:32 - can make a F get logs call to
get the logs. Now inside these
835:37 - logs is an important piece of
logging called events. And this
835:40 - is the main piece that we're
gonna be talking about today.
835:43 - events allow you to print
information to this logging
835:46 - structure in a way that's more
gas efficient than actually
835:49 - saving it to something like a
storage variable. These events
835:53 - and logs live in this special
data structure that isn't
835:56 - accessible to smart contracts.
That's why it's cheaper because
836:00 - smart contracts can access them
so that If the trade off here,
836:02 - we can still print some
information that's important to
836:05 - us without having to save it in
a storage variable, which is
836:09 - going to take up much more gas.
Each one of these events is tied
836:12 - to the smart contract or account
address that emitted this event
836:16 - in these transactions. listening
for these events is incredibly
836:19 - helpful. Let's say for example,
you want to do something every
836:22 - time somebody calls a transfer
function. Instead of always
836:26 - reading all the variables and
looking for something to flip
836:29 - and switch, all you have to do
is say, listen for event. So a
836:34 - transaction happened, an event
is emitted. And we can listen
836:37 - for these events. This is how a
lot of off chain infrastructure
836:40 - works. When you're on a website,
and that website reloads when a
836:44 - transaction completes, it
actually was listening for that
836:47 - transaction to finish listening
for that event to be emitted, so
836:51 - that it could reload or it could
do something else. It's
836:53 - incredibly important for front
ends. It's also incredibly
836:57 - important for things like chain
link, and the graph in the chain
837:00 - link network. A chain link node
is actually listening for
837:03 - request data events for to get a
random number, make an API call,
837:07 - or etc. Sometimes there are way
too many events. And you need to
837:11 - index them in a way that makes
sense that you can query all
837:15 - these events that happen at a
later date. The graph listens
837:18 - for these events and stores them
in the graph so that they're
837:21 - easy to query later on. So
events are incredibly powerful.
837:25 - And they have a wide range of
uses. They're also good for
837:27 - testing and some other stuff,
but you get the picture. They're
837:30 - really sick. Now that we know
what events are, let's look at
837:33 - what they look like how we can
use them and how we might use
837:36 - them in our smart contract
development suite. Now here's
837:39 - what an event is going to look
like. We have an event here
837:42 - called stored number. So we have
basically a new type of event
837:46 - called stored number. We're
saying, hey, solidity, hey,
837:49 - smart contract, we have this new
event thing, we're going to be
837:53 - omitting things of typed stored
number in the future. When we
837:57 - emit this event, it's going to
have these four parameters, it's
838:00 - going to have a unique 256. For
called old number. Are you
838:03 - interested? Is it called new
number are you intimidated six
838:06 - called add a number and an
address called center. Now for
838:09 - the astute people here, you
838:10 - might have noticed that there
was another keyword in here, the
838:13 - index to keyword and this is a
really important keyword. When
838:17 - we omit one of these events,
there are two kinds of
838:19 - parameters, there are the index
parameters and the non indexed
838:23 - parameters, you can have up to
three index parameters. And
838:27 - they're also known as topics. So
if you see a topic, you know
838:30 - that that's going to be an
indexed parameter. Index
838:33 - parameters are parameters that
are much easier to search for,
838:37 - and much easier to query than
the non index parameters. In
838:40 - fact, we recommend F get logs
function, it even has a
838:43 - parameter allows us to search
for specific topics. So it's
838:46 - much more searchable than the
non indexed ones. The non
838:50 - indexed ones are harder to
search because they get ABI
838:53 - encoded, and you have to know
the API in order to decode them.
838:56 - Now, this is told our smart
contract that there is a new
838:58 - type of stored number, a new
kind of event here, we need to
839:02 - actually emit that event in
order to store that data into
839:06 - the logging data structure of
the EVM. To do that, we need to
839:10 - do something that looks like
this. This is what it looks like
839:13 - when we emit an event, it looks
very similar to calling a
839:16 - function. So you call a mitt and
then the name of the event. And
839:21 - then you add all the parameters
in there that you like. Here's
839:24 - the full example of a smart
contract that has an event and
839:27 - is going to be the example that
we walked through in hard hat.
839:30 - Now in this smart contract,
whenever anybody calls the store
839:33 - function, we're going to omit
this event. Here's an example of
839:37 - a transaction where we call the
store function with a value of
839:41 - one, let's look into the logs to
see what this event actually is
839:45 - going to look like an event is
going to be broken down like so
839:49 - the address of the contract or
account, the event is emitted
839:52 - from the topics or the index
parameters of the event data.
839:56 - This is the ABI encoded non
index parameters of the event.
840:01 - What does this mean? This means
that we took those parameters
840:04 - that were non indexed, we match
them together with their API or
840:08 - application binary interface,
pumped them through an encoding
840:11 - algorithm, and boom, this is
what we got. If you have the
840:14 - API, they're very easy to
decode. If you don't have the
840:17 - ABI they are very hard to decode
these non indexed parameters
840:22 - cost less gas to pump into the
logs. Now in this particular
840:26 - contract, since we have verified
the code, we verified the
840:29 - contract ether scan knows what
the ABI is, and we can view this
840:33 - in Deke or decoded mode. Hex
mode is obviously the non
840:37 - decoded mode, or in its raw, hex
or hexadecimal or encoded mode.
840:41 - You can read more about the
layout of these events in the
840:44 - solidity docs. Now, so that's
the basic introduction of
840:50 - events. And for those of you who
want to watch the rest of that
840:52 - video, and who wants to actually
practice using events yourself,
840:55 - there's a link to these videos
and the code repository
840:58 - associated with that video, if
you want to play with it, and if
841:00 - you want to learn more, so feel
free Ready to refer back to the
841:02 - full blockchain solidity course,
Jas, if you want to go deeper
841:05 - into events now that we're back,
and we've learned a little bit
841:07 - more about events, let's add
some events to this contract.
841:10 - Remember, these events get
emitted to a data storage
841:13 - outside of this smart contract.
Let's create an event called
841:16 - raffle enter a good syntax for
naming events, name events, with
841:21 - the function name reversed. So
for enter raffle, we're gonna
841:25 - say raffle entered. So up at the
top below our state variables,
841:28 - but above our constructor, we'll
create a new section called
841:32 - events. And we'll create our
first event. So we'll do event,
841:37 - raffle, Enter. And we'll just
have this raffle enter take one
841:40 - index parameter, it'll be an
address indexed player. So in
841:45 - our Inter raffle, we're going to
say omit raffle enter. And we're
841:49 - just going to pass it message
dot sender. I'm going to remove
841:52 - these comments for now. But feel
free to leave them in as you
841:55 - code along. Now in this part of
my raffle coding or my lottery
841:59 - coding process, I probably would
start already writing some tests
842:02 - and already writing some deploy
scripts. The reason that we do
842:05 - this is it's good to test our
functionality as we progress.
842:08 - And oftentimes, when I'm writing
smart contracts, I'm constantly
842:11 - flipping back and forth between
my deploy scripts, my contracts
842:14 - and my tests to make sure
everything is doing exactly what
842:17 - I want it to do for the purpose
of this course. And just to make
842:19 - it easy for you to learn and
follow along, we're not going to
842:22 - do that. And we're just going to
keep writing our smart contract
842:24 - almost to complete and then move
to our deploy scripts and tests.
842:30 - So in its minimalistic sense, we
essentially have a way for
842:33 - people to enter our raffle. Now
we need a way to pick the random
842:37 - winner. And this is where we're
going to need chain link VRF and
842:40 - chain link keepers. So let's
again, watch some sub lessons
842:43 - about learning about chain link
VRF. And learning about chain
842:46 - link keepers. We've made some
videos about these before. So
842:49 - we're just going to play these
videos. So you can learn about
842:51 - how taling VRF version two
works, and also how chain link
842:54 - keepers works, then we're going
to come back and we're going to
842:56 - add them into our contracts
here. If you're already
842:59 - familiar, and you already played
with them, feel free to skip
843:01 - those sections. And we'll just
get to building them here.
843:04 - Hi, my name is Steven fluid. And
today we're going to be taking a
843:06 - look at chain links VRF. version
two, version two has a few
843:10 - different mental models that we
should be aware of. And I want
843:12 - to show you what it feels like
to be using it. The big
843:15 - important thing to know about
Vera version two is that instead
843:18 - of the Vera one model where
you'd be funding your contract
843:21 - with Link, instead, you're going
to be funding a subscription,
843:24 - which is basically an account
that allows you to fund and
843:27 - maintain balance for multiple
consumer contracts. Let's dive
843:31 - into the docs and see what using
Vera fie two looks and feels
843:34 - like. In order to show this off
a little bit. I'm going to dive
843:37 - right into the get a random
number guide in the chain link
843:40 - documentation. And so it's going
to go through a few the
843:43 - requirements of some of the
technology we're going to use
843:44 - today. And the first thing it's
going to ask us to do is to make
843:47 - sure that we are on the Rinkeby
test net. So let's go ahead and
843:50 - jump over to Rinkeby. Make sure
my meta mask is unlocked here.
843:54 - And now that I'm on Rinkeby,
great, I should be able to use
843:58 - the VIP version to test net. Now
we're going to jump over to
844:02 - subscription manager. And the
subscription manager is where
844:05 - we're going to manage our
subscription account. Basically,
844:07 - this is the place that you put
the funds in order to be able to
844:10 - use it across a bunch of
different chains. So we're going
844:13 - to go ahead and connect our
wallet here in order to use the
844:16 - subscription app. And then we're
going to go ahead and create a
844:20 - new subscription. So we'll just
use my address as the
844:22 - subscription address here. I'll
approve the creation. And as
844:27 - soon as that transaction is
confirmed, our subscription
844:29 - should be created. Alright, now
we have a subscription.
844:33 - Basically, this is the account
where we're going to fund it.
844:35 - And then we can use that account
for all of our random Miss
844:38 - requests. So I'm gonna go ahead
and just put in 10 link here,
844:42 - you can put in however much you
want. The price and link of
844:46 - every random number you request,
it's going to be based on the
844:49 - current gas rates on a given
chain, as well as the gasoline
844:54 - that you've chosen. On our funds
have been added, let's go ahead
844:57 - and add a consumer contract. So
it's asking us for consumer
845:00 - address, we don't actually have
a consumer address yet. So let's
845:02 - go ahead and jump over to the
documentation and create a
845:06 - contract that is going to
request a number. So if you
845:09 - scroll down, you're going to see
this Vera fee to consumer that
845:12 - soul contract that we can open
it in remix, let's just jump
845:14 - right there. We're gonna notice
a few different things in this
845:18 - contract at the top, we've got
some input. So now you've got
845:20 - VRF, consumer base version two,
we've got an interface for the
845:23 - VRF coordinator, and then also a
reference to the link token
845:27 - interface. So all of those are
specified for you on the Rinkeby
845:30 - network here in the example
code. And then you can refer to
845:33 - the documentation for whatever
chain you're going to be
845:35 - deploying to. And then you're
going to see a few new options
845:39 - here. So the key hash option is
the way that you specify that
845:43 - gasoline that was described in
the documentation. So depending
845:46 - on the key hash you choose for
the given chain you're on the
845:49 - gas limit will be set
differently for your random
845:53 - number requests. So for example,
on a theory main net, we have a
845:56 - 200 way key hash 500 Wiki hash
and 1000 graykey hash. You can
846:00 - also see in our contract Hear
that we have a callback estimate
846:03 - that you're in charge of. So
depending on how much gas you're
846:06 - willing to spend in the fulfill
random number, you should set
846:09 - this value appropriately. Next
up is request confirmations. So
846:13 - this was something in verify
would be one that you could not
846:15 - control. But here now, depending
on the chain you're on,
846:18 - depending on the request and the
type nature of the request you
846:20 - want to make, you can actually
change this number. And then one
846:24 - of the most important and useful
features that gives you a lot
846:26 - more flexibility and control of
your VRF is you can actually
846:30 - specify the number of random
numbers you want. And so you
846:34 - specify the number words, and
then that will specify how many
846:36 - random you went to 56 as you get
back from the network. All right
846:42 - here in the constructor, we're
gonna see a address for the
846:45 - coordinator and address for the
link token. And then you'll see
846:48 - that the subscription ID is
going to be created as we deploy
846:50 - the contract. And so I'm gonna
go ahead and get that. So if you
846:54 - remember when we created the
subscription after we found it,
846:56 - and we see this subscription ID,
and now when I deploy this, I'm
846:59 - going to use that subscription
ID. And we've got two methods
847:01 - that should look very familiar,
we've got fulfill randomness
847:05 - method that takes in randomness
is going to be fulfilled by the
847:07 - Bureau of Oracle, as well as you
got request random words, which
847:10 - is how we're actually going to
initiate the request to the
847:13 - Oracle. So I think we're
actually are already ready to go
847:15 - ahead and deploy this. So let's
jump to the deploy screen here
847:19 - and select the right contract,
which in our case, is your FB to
847:21 - consumer. And I'm going to make
sure that I am on injected web
847:24 - three so that we can actually
deploy to the Rinkeby network.
847:27 - And I'm going to paste in the
subscription ID here. And I'm
847:29 - going to deploy, let's go ahead
and pay for that transaction.
847:35 - And as soon as that is confirmed
by the network will show up
847:38 - here, and we'll be able to copy
this address, and then add that
847:41 - as a consumer and authorize this
contract to use my subscription
847:45 - account. So let's go ahead and
authorize this with them another
847:51 - Metamask transaction.
847:56 - Alright, we can have your
subscription, we can see how
847:58 - much link we funded it with. And
we can see our consumer
848:00 - contract. So now by doing this,
we've authorized our consumer
848:04 - contract to make requests for
randomness. So let's go ahead
848:08 - and make a request for
randomness here. So we're gonna
848:10 - go back to our contract that we
deployed here. And we're just
848:14 - gonna use the remix interface
here to keep things simple. And
848:16 - I'm going to request some
randomness. So obviously, this
848:19 - is going to use all of the
configuration that I specified
848:23 - in my contract, just kind of
hard coded here. So we're gonna
848:25 - get to words of random is here.
So we're gonna hit request
848:27 - randomness, confirm the Rigby
transaction. And then as soon as
848:32 - that transaction comes back, we
should notice that we actually
848:35 - have a request. And then what
we'll be doing is we'll be
848:38 - waiting for the Oracle to call
fulfill random words on our
848:41 - contract. And then we'll be
storing all of those random
848:44 - words in this s random words,
storage variable. Let's go ahead
848:48 - and check to see if our random
numbers come back from the
848:50 - Oracle. So I'll go in here into
random words. And let's request
848:53 - the zeroeth item of the array
looks like we've got a random
848:56 - number there. And because we
requested two random numbers, we
848:58 - should also have an item in
index one. All right, we we've
849:03 - got our randomness there. And if
we go back to the subscription
849:06 - manager app, you're going to see
that there's actually an event
849:09 - history item here, we'll see
that we spent about point three,
849:11 - three link to get those two
random numbers, we've just taken
849:16 - a journey to see what it looks
like and feels like to use Veera
849:19 - version two,
849:20 - now that we've learned a little
bit more about chainlink VRF, I
849:22 - hope that you took some time to
go to doxa chain link and play
849:25 - around with it a little bit so
that you understand what's
849:28 - really going on, we're going to
use this sample contract in here
849:31 - to create our function that's
going to pick our random winner.
849:34 - This is an on chain contract
that coordinates with a
849:36 - verifiably random chain link
node to give us a random number,
849:40 - you could look at the code
directly on chain, or you can
849:42 - come right to the chain link
GitHub and look at all the code
849:46 - for how this is actually
happening provably and randomly.
849:49 - And we'll have a link to this in
the GitHub repo associated with
849:51 - this course. So we're going to
create our function here called
849:56 - pick a random winner, this
function is going to be called
849:59 - by the chain link keepers
network so that this can
850:01 - automatically run without us
having to interact with it. And
850:04 - actually, while we're updating
this, I want to add some some
850:07 - stars here saying view slash
pure functions. Now our pick
850:11 - random winner function, we're
actually not going to make
850:13 - public we're going to make
external, external functions are
850:16 - a little bit cheaper than public
functions. Because solidity
850:19 - knows that our own contract can
call this, we're actually going
850:22 - to change the name of this
function, as well, very soon,
850:25 - but we'll get to that in a
little bit. So in order for us
850:27 - to pick a random winner, we
actually have to do two things,
850:30 - we first have to request the
random number. And then once we
850:34 - get it, do something with it. So
chainlink VRF is a two
850:38 - transaction process. And this is
actually intentional. Having
850:42 - random numbers in two
transactions is actually also
850:45 - much better than having it in
one. If it's just one
850:48 - transaction, then people could
just brute force tries
850:51 - simulating calling this
transaction and we'll learn how
850:53 - to simulate calls soon simulate
calling these transactions to
850:56 - see what they can manipulate to
make sure that they are the
850:59 - winner. We want to make sure
that this is absolutely fair.
851:01 - Nobody can manipulate our smart
contract into having them be the
851:05 - winner of the lottery, this
function is actually going to
851:07 - request it. And then in a second
func the random number is going
851:10 - to be returned. And in the
transaction that we actually get
851:13 - the random number from the chain
link network, that's when we're
851:16 - going to actually send the money
to the winner. And if we go to
851:19 - the chain link documentation,
the function that the chain link
851:21 - node calls is this function
called fulfill random words,
851:24 - this is going to be the
requesting one, which we could
851:27 - even change this to request
random winner to make it more
851:30 - clear, and then we'll make a
function fulfill random words.
851:36 - And this is going to be an
internal override, which we'll
851:38 - explain in a little bit, now
fulfill fulfill random words
851:42 - basically means we're fulfilling
random numbers. The word comes
851:45 - from a computer science
terminology, but you can
851:47 - basically just think of this as
fulfill random numbers, because
851:50 - we can get multiple random
numbers. Now in order to make
851:53 - our raffle contract VRF a bowl,
we have to import the chain link
851:57 - code, we can go back to the
documentation, and we're just
851:59 - going to grab this bottom line
and we'll grab the top line in a
852:02 - second. So we're going to do
import, I'm going to write it
852:06 - out. But if you want to copy
paste, you can at chain link
852:09 - slash contracts slash SRC slash
V 0.8, slash V RF, consumer
852:15 - base, b two dot Sol. And since
we're importing at chainlink,
852:20 - slash contracts, we're gonna
need to add that in by running
852:23 - yarn, add dash dash dev at
chainlink slash contracts. And
852:29 - now that we have this in here,
we should be able to import like
852:32 - so. And we're going to need to
make our raffle VRF consumer
852:36 - base double, we're gonna need to
inherit VRF consumer base go
852:39 - into our node modules at chain
link src, V 08 VRF, consumer
852:46 - base V two, it comes with this
function fulfill random words.
852:50 - And you can see it's an internal
virtual function, virtual means
852:54 - it's expecting to be
overwritten, the reason that
852:57 - it's in the sphere of consumer
base V two is so that the VRF
853:00 - coordinator, which we'll use in
a bit knows that it can call
853:03 - this fulfill random words
function. And this is the
853:06 - function that we're overriding.
So back in our raffle dot salt,
853:09 - we're going to inherit it by
doing is VRF consumer base V
853:13 - two. And now if we scroll down
to fulfill random words, we can
853:18 - add in the input parameters
fulfilled pill random words,
853:21 - which are going to be un 256,
Request ID and un 256, a memory
853:28 - array random words. And if we
hit Save Our linter will now
853:32 - notice, okay, this is what I'm
expecting, I'm expecting us to
853:36 - override the Fill random words,
which takes these parameters.
853:39 - Now if we look in our docs in
our constructor, we need to pass
853:43 - the VRF consumer base V TOS
constructor and pass that VRF
853:46 - coordinator. Again, this V RF
coordinator is the address of
853:49 - the contract that does the
random number verification. So
853:52 - right next to our constructor
will add the VRF consumer base V
853:57 - to constructor and we need to
pass the VRF coordinator v2
854:02 - address. So in our main
constructor, we'll add that as a
854:04 - parameter as well. So we'll say
address
854:08 - VRF core to Nate Torre v two,
and then we'll pass this as a
854:13 - parameter for the VRF consumer
basically till now that we have
854:17 - that we shouldn't see that
little underscore anymore. And
854:20 - we should be able to run yarn
aren't had compiled. Awesome.
854:25 - And we can see compiled two
files successfully and our code
854:28 - is working great. Now something
that I often do is I actually
854:34 - hate running yarn hard hat all
the time, because that's too
854:37 - many keys for my little brain to
work with. I would prefer to
854:40 - write as little keys as possible
hard hat also would like us to
854:43 - write as little keys as
possible. So hard hat comes with
854:46 - a shorthand and autocomplete
hard hat shorthand is an NPM
854:49 - package that installs a globally
accessible binary called H H,
854:53 - that runs the project's locally
installed hard hat and supports
854:56 - shell auto completion for tasks.
So what we can do is we're going
854:59 - to start with NPM, like this,
but we're gonna install it with
855:01 - yarn, we're going to run yarn,
global, add hardhat shorthand.
855:08 - And what this is going to do, we
can see here installed hard hat
855:11 - shorthand with binaries H, H,
and Hardhead completion. Now
855:15 - instead of running yarn,
Hardhead compile, which we can
855:19 - still run, we can just run h h
compile, running h h is going to
855:24 - be the same thing as if we had
just run the Hardhead command
855:27 - for our local directory. So now
we need to actually have our
855:33 - request random winner function
requests a random winner. So
855:36 - let's go back to the
documentation. And we'll see how
855:38 - to do that. We can look at this
function request random words
855:42 - and see exactly how it works. On
the Vera of coordinator address.
855:45 - We go ahead and call this
request random words function,
855:48 - we're going to need to call this
function on the coordinator
855:51 - contract to get the coordinator
contract. We're going to use the
855:54 - Vera v2 coordinator interface
and the Vir of coordinator
855:57 - address. So we're going to want
to keep track of those. We can
856:00 - do that once again in Arkansas.
factor, we have the address
856:03 - being passed to our Bureau of
consumer base. Let's also keep
856:06 - it as a state variable for us.
First, let's get the interface
856:09 - so we can interact with that
contract, we can import that
856:11 - from chain link as well by doing
import at chain link slash
856:14 - contracts, slash SRC slash fees
0.8, slash inter faces slash VRF
856:24 - cord to mentor V to interface
dot Sol. And now that we import
856:30 - this interface, same as we did
with price feeds, we can do VRF,
856:34 - coordinator v2, interface VRF
coordinator. And then we can
856:40 - save the sphere of coordinator
using the address so we can say
856:44 - VRF coordinator equals this
address VRF coordinator veto.
856:48 - And we're just going to wrap
that address around the
856:50 - interface so that now we can
work with this VRF coordinator
856:53 - contract. Now we're only going
to set our VRF coordinator one
856:56 - time right in our constructor.
So what's the best thing that we
856:59 - can do here, private, immutable,
you Gosh, darn. Right, let's do
857:03 - private, immutable, you have
coordinator and we'll change the
857:06 - name to I underscore the ref
coordinator so that we know that
857:10 - your coordinator is indeed an
immutable variable. In order to
857:14 - request the random word, we need
to give it a number of
857:16 - parameters, I'm gonna go ahead
and copy this line into our
857:20 - contract just so that we can
talk about exactly what's going
857:22 - on with it. And we don't need
the AES Request ID. And instead
857:26 - of coordinator we're going to do
I underscore fear of
857:29 - coordinator. So we're going to
call request random words on
857:32 - that VRF coordinator contract,
and we need to pass it the key
857:35 - hash or the gasoline, I prefer
calling it the gas lane, we go
857:39 - to the chain link, Doc's go to
contract addresses. And we
857:42 - scroll down we can see different
gas lanes a different
857:44 - configuration parameters for
different networks is key hash
857:47 - is going to be the gasoline of
the key hash, which tells the
857:50 - chain link node the maximum
price you're willing to pay for
857:53 - your guests and way if for
example, gas prices skyrocket,
857:57 - and it's going to cost you a ton
of money to get that random
857:59 - number setting a ceiling, we'll
make it so that random number
858:02 - doesn't come back. For us to
pick a gas lane, we're probably
858:04 - going to want to have this gas
lane or this key hash stored
858:07 - somewhere. So let's go ahead and
make that a parameter of our
858:10 - constructor as well. And we'll
save that as a state variable.
858:13 - So we'll do comma bytes 32,
gasoline or key hash or whatever
858:18 - you want to call it. And then
we'll make a new state variable.
858:21 - And we're only going to set this
once. So we'll make this a
858:24 - private, immutable. I underscore
gasoline, and then we'll say
858:33 - gasoline equals gasoline.
858:38 - So now, we can just swap this
out, or I underscore gasoline.
858:42 - Okay, what's next, we need a
subscription ID, the
858:44 - subscription ID is going to be
the subscription that we need
858:47 - for funding our requests.
There's actually a contract on
858:50 - chain, which we can use to fund
any subscription for any of
858:53 - these external data or external
computation bits. And in this
858:56 - contract, there's a list of
these subscriptions for people
858:59 - to make requests to. So we need
the ID of the subscription that
859:02 - we're using to request our
random numbers and pay the link
859:06 - Oracle gas, the subscription ID
is probably also going to be
859:09 - something we're going to pass as
a parameter to our lottery. So
859:12 - once again, let's scroll up to
our constructor, we'll add a new
859:15 - parameter. And our subscription
ID actually doesn't need to be a
859:18 - un 256, it can actually be a
little bit smaller with a un 64.
859:22 - So we'll pass a un 64 sub
scription ID, we'll make a UNT
859:28 - 64. Since we're only going to
set this once we'll make this a
859:31 - private, immutable. I underscore
sub scription ID down here and
859:37 - we'll say I subscription ID
equals sub subscription ID.
859:43 - Alright, awesome. So now we can
change this to our subscription
859:46 - ID. Okay, what's next? Request
confirmations request
859:50 - confirmations is a un 16, which
says how many confirmations the
859:54 - chain link node should wait
before responding. So if you
859:57 - make a request, and there's only
one block confirmation, maybe
860:00 - you don't actually send it
because you don't you're afraid
860:02 - of some type of blockchain
reorganization or something,
860:05 - we're not going to worry too
much about this. And we're
860:07 - actually just going to make this
a constant of three. So we're
860:09 - not even going to have this be
per amortizable we're gonna have
860:12 - this one be a constant. So we'll
say a you int 16 Private
860:17 - constant request, confirmations
equals three, and we're using
860:24 - the capslock and underscores for
our constant variables here. And
860:28 - now we'll grab request
confirmations and stick it in
860:31 - right here. What's next callback
gas limit callback gas limit is
860:34 - going to be the limit for how
much gas to use for the callback
860:37 - request your contracts fulfill
random words, this sets a limit
860:40 - for how much computation are
fulfilled random words can be
860:44 - this is a good way to protect
ourselves from spending way too
860:47 - much gas. If, for example, we
accidentally code our contract
860:50 - in a way where fulfill random
words is incredibly gas
860:53 - expensive. It'll block the
random number from responding.
860:56 - We are going to make this
parameter sizable because we
860:58 - want to change it depending on
how we code our fulfill random
861:01 - word. So in our constructor,
let's add one more, we'll add
861:05 - you int 32. Since the size of
this is a un 32, callback, gas
861:10 - limit, and we'll save the sub
top as a UNT 32, private,
861:17 - immutable, I underscore call
back. Yes limit. And we'll save
861:23 - this. I call back gas limit
equals call back Yes, limit. And
861:30 - then we'll take this, and we'll
stick it here. All right, we got
861:32 - one more number of words, this
is going to be how many random
861:35 - numbers that we want to get, we
only want one. So we're gonna go
861:38 - back up to the top, we're going
to create a you int 32. And
861:42 - we'll make this also a private
constant. Num words equals one,
861:47 - because we only want one random
number. And then that'll be the
861:49 - last thing we need to add for
our IVF coordinator dot request
861:54 - random words. Now this request
random words function returns a
861:57 - request ID a un 256 Request ID a
unique ID that defines who's
862:02 - requesting this and all this
other information. If we want to
862:05 - save it, we can do u and 256.
Request ID IVF coordinator
862:10 - requests random words. Now for
now, we are going to emit an
862:13 - event with this request ID. And
we'll go over why we're going to
862:17 - do that a little bit later,
create a new event at the top.
862:20 - And we're not going to follow
the naming convention here.
862:23 - Because we're going to change
the name of our functions a
862:25 - little bit, we're going to call
this requested raffle winner.
862:30 - And we're going to take a un 256
indexed Request ID. Down here,
862:37 - we're gonna do omit requested
raffle winner Request ID. And
862:42 - now we have a function that we
can use to request a random
862:45 - winner using chain link VRF. Now
again, we're going to set this
862:47 - up so that the chain link
keepers call this on an
862:50 - interval, but we'll do that in a
little bit. For now, let's
862:52 - figure out what to do once we
get that
862:54 - random number. Once we get that
random number, we're going to
863:02 - want to pick a random winner
from our array of players up
863:06 - here. So what do we do? Well,
let's go in here. And let's pick
863:10 - a random winner using something
called the module function. Now
863:14 - we're gonna get an array back of
random words, or random numbers,
863:18 - if you will, since we're only
requesting one random word, this
863:21 - random words array is going to
be of size one with one random
863:24 - word in it. Now this random word
is a un 256. So this random word
863:27 - could be something like this.
Well, obviously without the
863:31 - hyphens, but it could be
something absolutely massive
863:34 - like that our players array is
only going to be so big. So how
863:37 - do we get a random winner from
this potentially massive random
863:41 - number, we can use something
called the modulo function, the
863:43 - module operation, a mod N
yields, the remainder are after
863:48 - the division of an operand a by
the blah, blah, blah, blah,
863:51 - blah. So what does this mean?
Well, we can use the mod
863:53 - function to get a random number
out of our players array. So
863:57 - let's say our players array or
excuse me, our s players array
864:00 - is of size 10. And a random
number is 200. So how do we pick
864:05 - a random person out of this
players array, or, let's say our
864:08 - random number is 202. If we do
202, which is our random number,
864:12 - mod 10, we're gonna basically do
202 divided by 10. But instead
864:18 - of having the decimals, we're
just going to say, Okay, how
864:20 - many times is 10 evenly divide
into 202. And what's the
864:24 - remainder, what doesn't divide
evenly into 202? Well, 20 times
864:29 - 10 equals 200, with two
leftover, so two doesn't evenly
864:34 - divide, or multiply into 200. So
that means 202 mod 10 is going
864:40 - to equal to two. So that's how
the module function works. And
864:43 - we can use that so we're always
going to get a number between.
864:46 - So we're always going to get a
number here between zero and
864:48 - nine, which works out perfectly
because that which works out
864:51 - perfectly, because those are the
indexes of the 10 people in our
864:54 - array. So let's use that here.
We'll say a un 256 index of
864:58 - winner is going to be equal to
random words, at index zero,
865:04 - because we're only getting one
random word module, the S
865:08 - underscore players dot length.
So this will give us the index
865:12 - of our random winner to get that
address of the winner will do
865:14 - address payable, recent winner
equals s players at this index
865:24 - of winner so awesome. So now
we'll have the address of the
865:26 - person that got this random
number, the person's that's
865:29 - going to be our verifiably
random winner. Now, it might be
865:34 - kind of cool to brag to people
that you're the recent winner.
865:37 - So let's go ahead to the top and
we'll create a new state
865:40 - variable for our most recent
winner make this state variable
865:43 - in a new section called lottery
variables. We'll say address
865:48 - private s underscore recent
winner and it'll start out as
865:52 - nobody but as we get winners
update it with s recent winner
865:56 - equals recent winner and we'll
probably want people to know who
866:01 - this is winter is so down below,
we can do function get recent
866:05 - winner, it's going to be a
public view that's going to
866:09 - return that address. And then
we'll just say return s
866:14 - underscore recent winner, since
again, the recent winner is
866:17 - going to be a storage variable.
So now that we have a recent
866:19 - winner, what else are we gonna
do? Well, we're probably going
866:22 - to want to send them the money
in this contract. So we're going
866:24 - to do exactly what we did before
with sending the money, we're
866:27 - going to do that bull success,
comma, blank equals recent
866:35 - winner, call, I'm gonna say
value, it's going to be address
866:41 - of this dot balance, we're going
to send all the money in this
866:45 - contract, and we're going to
pass it no data. And now we
866:48 - could say require, you know,
success, whatever, we're going
866:52 - to be a little bit more gas
efficient here. And we're just
866:54 - gonna say, if not success, then
we're going to revert a new
866:59 - transfer failed error. So we're
gonna go to the top, or say,
867:01 - error name of the contract is
raffle, underscore, underscore,
867:05 - transfer failed, like that, then
go back down, and we can now do
867:10 - revert, raffle transfer failed
like that. And now that we've
867:14 - picked a winner, right now, we
don't have a way to actually
867:17 - keep track of the list of
previous winners. So we're just
867:20 - going to omit an event. So
there's always going to be that
867:23 - easily query double history of
event winners. So we're going to
867:26 - create a new event in the events
section called the event winner
867:30 - picked. And this is going to be
an address indexed winner. And
867:37 - we'll scroll down and we'll do
MIT winner picked the address of
867:43 - the recent winner. This looks
pretty good.
867:46 - This looks pretty good here. Now
you'll notice our request ID as
867:49 - this little underscore here and
saying, hey, it's an unused
867:53 - function parameter, since we
don't use this, but we still
867:56 - need fulfill random words to
take a request ID and a random
867:59 - words array. But we don't use
Request ID, we can just comment
868:02 - out just the request ID part
like this, this tells our
868:06 - function, hey, yes, we know that
you need a un 256. But we're not
868:10 - going to use the request ID. So
we'll leave it in here. But
868:12 - we'll leave it blank. Now let's
run a little compile here. We'll
868:16 - use yarn, hard hat, compile, or
hh compile, we'll see if we're
868:21 - coding things correctly. And
indeed, we don't see any errors.
868:24 - So perfect, we can continue. So
we've added the chain link VRF,
868:30 - where we have a way to
verifiably get a random winner.
868:34 - This is fantastic. Now let's
update this contract so that not
868:38 - only can it pick a verifiable
winner, but it can also do this
868:42 - all programmatically and
automatically trigger picking a
868:45 - random winner based off of some
time interval without us having
868:49 - to interact with it. And in a
decentralized context. In order
868:52 - for us to automatically trigger
smart contracts based off of
868:55 - some parameter be a time
parameter, maybe the price of
868:59 - some asset is some number, maybe
there's a certain amount of
869:02 - money in the liquidity pool or
really whatever trigger that you
869:05 - want, we can use chain link
keepers. To do this. Steven
869:08 - fluid has done once again, an
amazing introduction to chain
869:11 - the keepers. So we're going to
follow along with another sub
869:14 - video section of Steven
explaining chain link keeper
869:16 - sauce, he's going to be using
the COVID test net, but be sure
869:19 - to use whatever test net is in
the documentation. When you play
869:22 - with this and you try this.
869:23 - My name is Steven foon. Today, I
want to show you how to use the
869:26 - chain link keeper network in
order to automate your contracts
869:29 - and give them access to off
chain computation. Let's go
869:32 - ahead and dive in. So what we're
going to look at today is we're
869:34 - going to start on the chain link
documentation webpage. And if
869:37 - you just scroll down a little
bit, you're going to find using
869:39 - chain link keepers. Now there's
really two parts to building a
869:43 - chain link keeper up kept smart
contract. So the first thing is
869:46 - you need to write a smart
contract that's compatible by
869:49 - implementing these two methods.
And then second, you want to
869:51 - register that smart contract for
upkeep with the channeling
869:54 - keeper network. So let's go
ahead and do both of those
869:57 - things. So let's start off just
by copying and deploying this
870:00 - sample code that we've got. With
this one click to remix, what
870:04 - we're gonna see here is a very,
very simple contract. That is
870:07 - just a simple counter. So we can
see it's got a counter here. So
870:11 - it's got just a simple number.
And then you're able to specify
870:16 - when you create the contract and
update interval, and then the
870:19 - contract is going to verify Hey,
has enough time passed. And if
870:22 - it has, let's update the
counter. And you're going to
870:24 - notice that chinley compatible
or timekeeper network compatible
870:27 - contracts use two really
important methods that are part
870:30 - of this keeper compatible
interface. The first is check
870:33 - upkeep, and check upkeep is
special because this is where
870:37 - the off chain computation
happens. So this is a method
870:39 - that's not actually run on
chain. This is run off chain by
870:43 - a node from the channeling
keeper network. And so what's
870:47 - really nice about this is that
the gas used here isn't actually
870:50 - gas, it's on chains. This is
just being run by a chain link
870:53 - node. And then what happens is
if your check upkeep method
870:57 - returns, the upkeep is needed.
Then it's going to go ahead and
871:00 - perform upkeep. On chain, so you
can actually generate data off
871:04 - chain, and then pass that in.
That's called the check data.
871:07 - And then that becomes the
performed data that's passed
871:10 - into perform upkeep. And so the
PErforM upkeep method is where
871:14 - you're going to want to verify
that things are correct. And
871:18 - that things actually should be
modified and run on chain, and
871:22 - then actually make the state
change. And so let's go ahead
871:25 - and compile this contract and
deploy it to the COVID network.
871:28 - So let's go ahead and within
remix, we can do this
871:31 - compilation. And we're going to
compile and deploy directly to
871:35 - COVID. So the zookeeper network
is currently as of the filming
871:38 - of this, available on both COVID
as well as the theory of main
871:42 - net. And let's go ahead and play
the counter contract. And let's
871:45 - see what's not updating more
than every 30 seconds. And so
871:49 - let's go ahead and deploy. So
meta masks can ask for a little
871:52 - bit of payment, in order for me
to deploy this contract to the
871:54 - COVID network. And it looks like
that is live. So now what I'm
871:58 - going to do is I'm going to be
able to take this keeper
872:00 - contract, and copy its address.
And now we're going to register
872:04 - that contract for upkeep. So
we're going to jump over to the
872:07 - application that powers the
champion keeper network, there's
872:10 - a few different ways you can
use, you can interact directly
872:12 - with the registry contract. But
there's a very, very nice
872:15 - interface that lets you do this.
So let's go ahead and register a
872:17 - new upkeep and it's giving me an
error that says you need to
872:20 - connect your wallet. So let's go
ahead and do that. So I'm going
872:22 - to just connect wallet here, and
I'm gonna give it access to my
872:25 - account. And then from there, we
should actually be able to
872:28 - register. So I'm going to use an
email address here. I'll give my
872:33 - contract a simple name. I'll
paste in that address from the
872:36 - deployed contract, and then I'll
give it a gas limit. And then
872:40 - check data is this special thing
where you can actually register
872:42 - multiple upkeeps On the same
contract in passing data to
872:45 - specify how you want checkup
keep to be run of, we're just
872:49 - going to ignore that that is an
optional one. And then we'll
872:51 - give it a starting balance of
around 10 link, it's gonna go
872:55 - ahead and use Metamask again to
register that transaction on the
872:58 - network. And once it's
confirmed, my upkeep should be
873:02 - registered with the network and
funded with 10 Link To kick
873:05 - things off. Alright, if we go
ahead and view the upkeep, we
873:09 - can see it's registered. And as
soon as the next round of the
873:15 - keeper nodes executes, which
should be roughly about every
873:19 - block, we should see that the
check upkeep method is going to
873:23 - return that hey, upkeep is
actually needed because the
873:25 - timestamp is more than 30
seconds ago. And then we should
873:28 - go ahead and perform upkeep. So
as soon as I take a look at this
873:32 - in remix, I can actually make
this bigger here, we're going to
873:36 - be able to see from the methods
of the contract, if we check the
873:38 - counter, it's going to start at
zero. And as soon as that 30
873:41 - seconds has passed, we'll be
able to hit the counter again,
873:44 - we'll see that the channeling
keeper network has performed
873:47 - upkeep on my contract. Alright,
we just refresh and we see the
873:50 - balance of the upkeep has been
decreased by about point 01
873:55 - link. And we should also see
within our contract that our
873:59 - counter has now updated via
proof that perform upkeep method
874:02 - call. And now our counter is at
one showing us that our contract
874:07 - is being approved by the
chainlink keeper network. And
874:10 - everything is working exactly as
we expect. So as you can see, it
874:13 - is very, very easy to create a
contract that is compatible with
874:16 - the keeper network. And it's
very easy to register that
874:19 - upkeep and start seeing that
your contract automation and
874:23 - option computation are working
flawlessly.
874:25 - Now that we've learned a little
bit more about how chainlink
874:27 - keepers work if you want to take
some time to go through the
874:30 - documentation and open up way
down below this open and remix
874:33 - button. So you can actually work
with one of these and see these
874:36 - in action for yourself on a test
net, feel free to do so we're
874:39 - gonna be using a setup very
similar to this keepers counter
874:42 - setup in the chain link
documentation. So now let's
874:47 - update our code so that this
request random numbers
874:50 - automatically happens using
chain link keepers. And if we
874:53 - look at the example contract can
actually read more about what's
874:56 - really important for this to
work. And we need a check upkeep
874:59 - and a perform upkeep function in
our code. So instead of request
875:03 - random winner, this is going to
be the PErforM upkeep that we're
875:06 - going to change. But first let's
make this check upkeep checkup
875:09 - keep function is basically going
to be checking to see is it time
875:12 - for us to get a random number to
update the recent winner and to
875:15 - send them all the funds. So
let's go ahead and make that
875:17 - function. I'm going to add some
notes here, just so that it's
875:20 - clear what's going on. And maybe
I'll even do natspec To tell
875:23 - developers what's going on with
this function. So we're going to
875:26 - create this function check
upkeep. And if we look at what
875:30 - this needs, it needs to be
external override external
875:35 - override. And if we see this
override keyword, this means
875:38 - that okay, there's probably a
perform upkeep somewhere else.
875:41 - And if we scroll to the top, and
we're going to import this
875:43 - keeper compatible interface, so
that we make sure that we
875:46 - implement both check upkeep and
perform upkeep in our code here.
875:51 - If you want you can just import
keeper compatible in here or
875:54 - just the keeper compatible
interface in our code. We're
875:56 - going to do import at chain link
slash contracts slash SRC slash
876:04 - V 0.8 point two interfaces slash
keeper compatible interface that
876:13 - soul and now we're just gonna
say contract raffle is Veera of
876:16 - consumer base V two and keeper
compatible interface and this
876:19 - keeper compatible interface
inheritance just make sure that
876:22 - we add checkup keep and perform
upkeep, which we're going to add
876:25 - in a little bit. And if we look
back at the docs we can see
876:28 - checkup keep takes a bytes
called Data check data as an
876:32 - input parameter. So we'll do
bytes called data. Check data as
876:37 - a parameter. Now this check
upkeep bytes call data allows us
876:40 - to specify really anything that
we want when we call this check
876:44 - upkeep function. Having this
check data be of type bytes
876:47 - means that we can even specify
this to call other functions,
876:51 - there's a lot of advanced things
you can do by just having an
876:54 - input parameter as type of bytes
for us though, we're going to
876:58 - keep it a little bit simple. And
we're actually not going to use
877:00 - this check data piece. So
similar to how below we're not
877:03 - using Request ID, we can just
comment it out. However, we
877:06 - still need to make sure that
this parameter is type of bytes
877:09 - called data. Now anyways, let's
go ahead and annotate this check
877:12 - upkeep function, we'll say this
is the function that the chain
877:16 - link keeper nodes call they look
for the to return true. Look
877:25 - back at the documentation, we
can see that this check upkeep
877:28 - returns both and upkeep needed
and to perform data, which
877:33 - again, we're going to ignore
this upkeep needed is going to
877:36 - be true or false. If it's true,
that means it's time to get a
877:41 - new random number following
should be true in order to
877:46 - return true. So in order for it
to be time to request a random
877:50 - winner, what should happen, our
time interval should have
877:54 - passed, which we haven't defined
yet. But we will lottery should
877:58 - have at least one player and
have some eath. And then our
878:04 - subscription is funded with Link
similar to how with channeling
878:09 - Vir f your subscription needs to
be funded with Link, the same
878:12 - thing needs to happen for check
upkeep and keepers to run your
878:15 - subscription needs to be funded
with link. Now we're going to
878:18 - add one more additional piece
here, we're going to say for the
878:21 - lottery should be in an open
state, something that we want to
878:26 - avoid when we're waiting for a
random number to return. And
878:30 - when we've requested a random
winner. We're technically in
878:33 - this weird limbo state where
we're waiting for a random
878:35 - number to be returned. And we
really shouldn't allow any new
878:38 - players to join. So what we
actually want to do is create
878:40 - some state variable telling us
whether the lottery is open or
878:43 - not. And while we're waiting for
our random number to get back,
878:46 - we'll be in a closed or a
calculating state.
878:51 - Now what we could do at the top
of our contract, we can just say
878:54 - Boolean, private, s underscore
is open. And we can just set
878:59 - this to true if we're open
otherwise false. Well, what if
879:03 - we have a ton of different
states? What if we want it to be
879:05 - like pending, open, closed,
calculating, etc? What do we
879:10 - have a ton of different states?
Well, we could make this a U and
879:14 - 256. Private s underscore state.
And we could just keep track of
879:18 - the state having like zero b
pending a one reopen to be
879:21 - closed, three, be calculating,
etc. But this can be a little
879:24 - tricky to keep track of. So a
better way to actually keep
879:27 - track of all this in our code is
to use an enum enums, can be
879:31 - used to create custom types with
a finite set of constant values.
879:35 - So we can create, for example, a
state created locked inactive,
879:39 - and it's basically a new type
for a smart contract for us,
879:42 - we're going to create a new
type. And if we go back to the
879:45 - layout of variables, and our
smart contract types should
879:48 - actually be first thing in our
contract. So we're going to
879:50 - create an E new called raffle
state. And for now, and we're
879:54 - just going to have it be open,
we're just gonna have to be open
879:57 - or calculating. Now when we
create an enum like this, we're
880:02 - kind of secretly creating a un
256, where zero equals open, and
880:07 - one equals calculating. However,
this is much more explicit that
880:12 - we know what each one of these
numbers actually means. Now that
880:15 - we've created this new type
called raffle state, we can
880:18 - create a new lottery state
variable of type raffle state.
880:22 - So the exact same way we declare
any other variable, we'll name
880:25 - its type, which is going to be
raffle state. And this is going
880:28 - to be a storage variable. So
we'll go ahead and do private s
880:31 - underscore raffle state in our
constructor, right when we
880:34 - launched this contract, we
should open up this raffle. So
880:38 - we'll say s, raffle state equals
and we could use a un 256.
880:43 - Wrapped in type raffle state
like so. Or we can be more
880:48 - explicit and say raffle state
DOT open. Now we know that the
880:52 - raffle state is in an open state
and we only want checkup keep to
880:55 - work is if the lottery is
actually open. Additionally, we
880:59 - probably only want people to be
able to enter if the law
881:01 - battery's open. So let's go
ahead and create another if
881:04 - statement and revert if the
lottery isn't open. So we can
881:07 - say if s underscore raffle state
does not equal raffle state DOT
881:14 - open, then we're going to revert
with a new error, we're going to
881:19 - create raffle underscore
underscore, not open. And of
881:24 - course, at the top will create
error, raffle not open. Now
881:29 - additionally, let's go down when
we're requesting a random word.
881:34 - Let's update the state to be
calculating so other people
881:37 - can't jump in here. So right
above our VRF coordinator dot
881:41 - request, random words will do s
underscore raffle state equals
881:46 - raffle state DOT calculating so
that nobody can enter our
881:51 - lottery and nobody can trigger a
new update. And then once we
881:56 - fulfill after we pick our
winner, we'll say s raffle state
881:59 - equals raffle state DOT open
again. Something else that we
882:07 - forgot to do was after we pick a
winner from s players, we need
882:10 - to reset our players array. So
let's add that in here as well
882:14 - as players equals new address
payable. array of size zero. So
882:21 - we'll reset the raffle state.
And we'll reset our players
882:24 - array. Alright, great. So now
that we've learned about enum,
882:27 - let's add it to our checkup keep
here, we're going to check these
882:30 - four things. And if they all
pass checkup keys will be true
882:33 - and will trigger the chain the
keepers to request a new random
882:36 - winner. So first, we'll say bool
is open. It's going to be equal
882:41 - to raffle state. That open
equals equals s underscore
882:49 - raffle state. So you can think
of that as this boolean is open
882:53 - is going to be true if raffle
state is in an open state, and
882:58 - it will be false if raffle state
is in any other state. So great.
883:01 - We haven't is open Boolean that
we can check later on. What else
883:04 - do we need? Well, we need to
check to make sure our time
883:07 - interval is past well, we don't
have a time interval yet. So
883:10 - let's create a time interval. In
order to check the time we can
883:14 - use another one a solidity is
globally available variables
883:17 - with block dot timestamp block
that timestamp returns the
883:20 - current timestamp of the
blockchain to get the current
883:23 - timestamp, we're gonna need
block dot timestamp. But to get
883:26 - if enough time has passed, we're
going to need to get the current
883:28 - block dot timestamp minus the
last block timestamp, which we
883:33 - don't have yet. Let's go ahead
and create a state variable to
883:35 - keep track of the previous block
timestamp. So this is going to
883:39 - be a new state variable that
we're going to make. I'm gonna
883:41 - say u and 256. Private s
underscore last timestamp.
883:49 - And right when we deploy this
contract, we'll update this with
883:52 - the current timestamp s last
timestamp equals block dot
883:56 - timestamp. Alright, awesome. Now
we have a last block timestamp.
884:01 - But we're going to need to check
that the difference between the
884:04 - current timestamp and the last
timestamp is greater than some
884:07 - interval. So we also need to
create an interval. And this is
884:10 - going to be some interval, this
is going to be some number in
884:13 - seconds of how long we want to
wait between lottery runs. So
884:18 - let's go ahead and add this to
our constructor as well. And do
884:21 - a comma here. And we'll do u and
256. Interval. And we're going
884:25 - to create another global
variable u and 256 Private s
884:31 - underscore interval. And in our
constructor and we'll say s
884:34 - interval equals interval. Now
interval isn't going to change
884:38 - after we set it. So instead of
making a storage variable, let's
884:42 - make it an immutable variable to
save some gas. Okay, perfect.
884:46 - Now that we have all this, I'm
actually create a boolean to
884:48 - check to see if enough time has
passed. So we'll say Boolean
884:52 - time passed equals the current
block that timestamp minus s
884:59 - underscore last timestamp. And
we should check to see that this
885:05 - is actually greater than I
underscore interval. So we have
885:09 - a Boolean check to see if we're
open. It'll be true if we're
885:12 - open and we'll have a boolean to
see if enough time has passed.
885:15 - This will be true if enough time
has passed. What else should we
885:18 - check? While we should check to
see if we have enough players.
885:21 - So we'll do Boolean has players
equals and we'll check to see if
885:26 - s underscore players dot length
is greater than zero. If s
885:32 - players dot length is greater
than zero as players will be
885:34 - true, otherwise it'll be false.
And we'll also see if we have a
885:38 - balance so we'll do Boolean has
balance equals address. This dot
885:44 - balance is greater than zero.
Then finally, we're going to
885:48 - take all these booleans and turn
them into the return variable
885:52 - that we're looking for. We're
gonna say Boolean up keep
885:54 - needed. Equals is open and time
passed. And as players and as
886:06 - balance, like that, so all these
combined is gonna be this
886:11 - Boolean upkeep needed. And if
this returns true, it's time to
886:15 - request a new random number and
it's time to end the lottery. If
886:18 - this is false, it's not time
yet, it's not time to end the
886:21 - lottery up. Now again, if we go
to the chainlink, documentation
886:24 - upkeep needed, actually needs to
return that Boolean upkeep
886:28 - needed and some bytes memory
perform data. So we need to
886:30 - update we need to update our
function here. And say returns
886:35 - full upkeep needed, comma, bytes
memory, perform data star slash.
886:44 - And since we've initialized
Boolean up, keep needed up here,
886:47 - we don't need to say what type
of upkeep needed is down here.
886:52 - Since this will automatically
get returned performed data is
886:55 - something that we can use. If we
want to have checkup, keep do
886:58 - some other stuff. Depending on
how this checkup keep went. We
887:02 - don't really need it to do
anything else. So we can just
887:04 - leave it as such. Right. So now
we have a check upkeep, we have
887:07 - a way to check to see if it's
time to trigger picking our
887:11 - random winner of our lottery
887:12 - or our raffle. Now that we
learned how to actually do this
887:18 - trigger, let's write the
function that gets executed
887:21 - after this returns true. This is
going to be our perform upkeep
887:25 - function, which we can see an
example again in the chainlink
887:28 - documentation. Now when it's
time to pick a random winner,
887:31 - actually, what we're going to do
is just we're just going to call
887:34 - this request random winner
function. So instead of having
887:36 - this extra function, let's just
transform our request random
887:40 - winner function into this
perform upkeep. Since once check
887:44 - upkeep returns true, the chain
link nodes will automatically
887:47 - call this perform upkeep
function. So in function request
887:50 - random winner, let's rename this
to perform upkeep. And we'll
887:54 - have it take the input parameter
bytes called Data perform data
887:58 - bytes, called data, perform
data. In our checkup, keep we
888:03 - had to perform data, we would
automatically pass it to our
888:06 - performance keep, we're not
going to pass anything to
888:08 - perform upkeep, we can leave it
commented out like this. Since
888:11 - perform upkeep is actually
identified in the keeper
888:14 - compatible interface, this is
now going to have to override
888:17 - that function. Now we want to do
a little bit of validation
888:20 - before we continue here. Because
right now anybody can call our
888:24 - perform upkeep function. So we
want to make sure that it only
888:26 - gets called when checkup keep is
true. An easy way for us to do
888:30 - that is to actually call our own
checkup, keep function. Now
888:33 - right now, checkup keep it's an
external. So we actually can't
888:36 - call our own checkup keep
function. So let's change it to
888:39 - public so that even our own
smart contracts can call this
888:42 - checkup keep function. Now that
we've made it public in perform
888:45 - upkeep, we can call checkup,
keep passing nothing, and then
888:49 - return the upkeep needed and
perform data which we don't
888:52 - really care about. So we'll get
we'll get that ball up keep
888:57 - needed. And then we don't care
about perform data. So we'll
889:01 - leave that blank equals check up
keep. And we'll pass it a blank
889:06 - called data. Now, we want to
make sure that this is true in
889:10 - order to keep going with the
function. So we could write a
889:12 - require here, but we're going to
do if not up keep needed, then
889:19 - we're going to revert with a new
error that we create raffle.
889:24 - upkeep not needed. And we're
going to pass some variables to
889:29 - this error
889:29 - so that whoever was running into
this bug can hopefully see why
889:32 - they're getting this error. So
we'll pass the balance of this
889:34 - contract just in case there's no
ether in here. We'll add the
889:38 - players dot length, just in case
there's no players. And we'll
889:41 - add a un 256 s underscore raffle
state. Make sure that the
889:47 - raffles actually open. And then
of course, we'll need to create
889:52 - this air at the top air, raffle
upkeep not needed, which is
889:56 - going to take a un 256 current
balance un 256 non players and
890:03 - you went to fit six raffle
state. Our code is starting to
890:08 - look really professional. This
is awesome. Now something that
890:11 - we forgot to do back in the
fulfill random words because we
890:14 - actually forgot to reset
timestamp every time a winner is
890:17 - picked. We want to reset the
timestamp as well so that we can
890:21 - wait another interval and let
people participate in the
890:23 - lottery for that interval. So
we'll scroll down into fulfill
890:27 - random words. And right after we
reset players will also reset
890:31 - the timestamp. Okay great and I
think we're just about done
890:34 - here. Let's add a little bit of
natspec to make this look even
890:40 - more professional and and give
people who are reading our
890:43 - contract even more information.
So let's add title here at title
890:48 - and we'll say a sample raffle
contract will say an author is
890:52 - going to be me Patrick Collins
or you can put your own name
890:55 - there as well at notice. This
contract is for creating and
891:01 - untampered orrible decentralized
smart contract. And then we'll
891:05 - do add Dev, this implements
chain link VRF v two, and chain
891:12 - link keepers. Alright, awesome.
We've got our type declarations,
891:16 - we've got our state variables,
we've got lottery variables,
891:19 - which are still state variables,
we've got our events. Now it's
891:22 - time for our functions.
Afterwards, we've done a little
891:26 - bit of natspec, at least on our
check upkeep. If you want to add
891:29 - some more natspec on things like
enter, raffle, perform upkeep,
891:32 - etc, you can absolutely do so.
And then down at the bottom, we
891:35 - have our views slash pure getter
functions. Let's see, do we want
891:38 - any other getter functions here?
Well, we probably want to give
891:41 - people the chance to get a
raffle state. So we'll do
891:43 - function, get raffle state, this
will be a public, you returns a
891:50 - raffle state. We'll say return s
underscore raffle state, we
891:57 - probably want to give people the
chance to get the number of
892:00 - words. And this is going to be a
little bit interesting here
892:03 - running. So if we do function,
get num words, public view
892:10 - returns, you went to the six
return num words, you'll see
892:15 - something interesting happened
here. We pull up our compiler
892:19 - and run hh compile. Hopefully
everything works here. Oh, and
892:24 - everything doesn't work because
I didn't import this correctly.
892:28 - Let's fix that. Let's try again.
892:31 - Oh, there's a couple things I
missed. Let's fix es players.
892:35 - This is why it's good to compile
as you code as players dot
892:37 - length. Let's try again. And I
spelt interval wrong. I
892:42 - underscore inter vol strike to
compile again, see how many more
892:47 - spelling mistakes I made. And
there it is. I underscore in
892:51 - error go to paste that and we do
get another error here. Invalid
892:56 - type for argument in a function
call invalid implicit conversion
892:59 - from literal string to bytes
called data requested. Since
893:02 - we're passing this empty string
here. And checkup keep needs a
893:06 - call data called data actually
doesn't work with strings. So we
893:09 - need to make this bytes memory
instead. And our compiler is now
893:12 - happy with us. And I spell it
the timestamp wrong. That's a
893:15 - lowercase s so and you might see
some squiggles here on Check
893:20 - upkeep, we could make this a
view function since we're not
893:23 - actually modifying any state.
But I want to keep it public for
893:26 - reasons I'll show you a little
bit later. But finally we get
893:29 - the the yellow squiggly that I
was looking for here. And if we
893:32 - run hh compile, we should see a
warning in our compiler as well.
893:37 - Okay, so we see all those yellow
squigglies here. Unnamed return
893:39 - variable can remain unassigned.
We need this bytes memory in
893:43 - here because that's what the
keepers are looking for. Morning
893:46 - function state mutability can be
restricted to view for our
893:49 - function checkup key. You can
make a view if you want, but I'm
893:52 - going to keep it public for
reasons I'll show you a little
893:54 - bit later. And finally, function
state mutability can be
893:58 - restricted to pure this is what
I wanted to show you since num
894:01 - words is actually in the
bytecode, since it's a constant
894:05 - variable technically isn't
reading from storage, and
894:08 - therefore this can be a pure
function. Returning num words
894:13 - doesn't actually read in
storage, it literally will go
894:16 - and read the number one. So
doing get num words in solidity
894:20 - with num words being a constant
variable, it's going to
894:23 - literally be the exact same as
saying get one and we would
894:27 - return one here, we might also
want to get the number of
894:29 - players. So we'll create a
function get number of players.
894:35 - And this will be a public view,
returns a un 256. Turn s
894:42 - underscore players dot length.
We're also probably going to
894:47 - want the latest timestamp. So
we'll do function get latest
894:51 - timestamp. public view returns
you in 256. And we're just going
894:58 - to return s underscore last
timestamp. And maybe we'll want
895:05 - to do request confirmation. So
we'll do function GET request
895:09 - confirmations. Public pure since
request confirmations is also a
895:14 - constant function returns you
went to you went to 56 Turn
895:20 - request confirmations. All
right, we've got some wonderful
895:25 - getters here. Some views slash
pure functions, we have a way to
895:28 - get a random number we have a
way in a decentralized context.
895:33 - Automatic automatically execute.
picking a random winner we have
895:36 - a way for people to enter our
raffle to enter this lottery.
895:40 - And we have a bullet proof way
to solve creating a truly fair
895:46 - decentralized lottery. Oh my
goodness. Let's do one more
895:50 - compile for good measure H H
compile. And these are just
895:54 - warnings. So we're good to go
here. Our code is compiling
895:57 - successfully. Like I said
Normally, this definitely isn't
896:03 - going to be the way that you're
going to write your smart
896:05 - contracts, it's almost
impossible to write a full smart
896:09 - contract without making any
mistakes. And without flipping
896:11 - back and forth between
documentation, I have already
896:14 - written this contract many times
myself, and I still made a whole
896:18 - bunch of mistakes. So it is
totally reasonable and totally
896:21 - rational for anybody and
everybody to make mistakes going
896:25 - through this. And to use
resources and to write tests
896:28 - along the way. Now that we have
our raffle dot Seoul created,
896:31 - it's time to add everything
else. So we're going to come
896:34 - over here, we're gonna create a
new folder, and add our deploy
896:38 - folder per usual.
896:39 - And we're going to do exactly
what we've already done a couple
896:41 - of times, we're going to create
some scripts to deploy our
896:44 - raffle contract. Now with our
raffle contract, there's a
896:46 - couple of things in here that we
want to make note of first thing
896:49 - is that our constructor right
now is absolutely massive. There
896:53 - are a ton of parameters in here
that we need to account for.
896:56 - Let's take a look at our
constructors and see if there's
896:58 - any contracts that we're already
interacting with. Okay, VRF,
897:01 - coordinator v2. This is a
contract address, entrance fee,
897:05 - no gasline, no subscription ID
no callback, guestimate No, and
897:09 - interval. No. So knowing that
this is an address should be a
897:13 - tip that Ah, okay, we're
probably going to need to deploy
897:15 - some mocks. For this, since
we're going to need to interact
897:19 - with a VRF coordinator contract
that's outside of our project.
897:22 - But let's go ahead and start
working on our raffle deployment
897:24 - script first, and we know we're
going to have to deploy some
897:27 - mocks. So we'll just keep that
in mind. So let's create a new
897:30 - file. Oh, one, deploy raffle.js.
And let's get started deploying
897:38 - our raffle contract. Now, this
is going to look really similar
897:41 - to what we've done before. And
we're going to do it again here.
897:43 - If you want to use your previous
deploy scripts as a reference, I
897:46 - absolutely recommend you do so.
But let's get started with
897:49 - module that exports equals an
async function. That's going to
897:56 - take get named accounts and
deployments. As input
898:04 - parameters, then we're going to
do const. Deploy log equals
898:10 - deployments, then we're gonna
say const, Deployer, equals
898:15 - await, get named accounts. Let's
go to our config and update
898:21 - module that exports to to have
this I'm just going to copy
898:24 - paste, so that employer is going
to be defaulted to account zero
898:27 - and player is going to be
defaulted to account one, if you
898:30 - want to go ahead and write this
out, feel free to pause and
898:32 - write out your name accounts.
Right now, there's gonna be a
898:34 - lot of boilerplate in our heart
hat.config.js. So feel free to
898:38 - have the GitHub repo for this
lesson up with you or your
898:42 - previous scripts that you've
already written as a reference
898:44 - named accounts Deployer. And
we're also going to have a
898:47 - player named account so that we
can separate different users or
898:51 - different players who are
interacting with our contracts.
898:53 - But for now, we're gonna grab
our Deployer. And we're gonna
898:56 - get started. Now similar to last
time, we would just do const,
898:59 - raffle equals await ploy,
raffle, comma, and then add all
899:05 - of our stuff in here, right? So
this would be from Deployer.
899:10 - args, we're going to have a ton
of args. So we're going to come
899:14 - back to this. And then log is
going to be true. And then we're
899:19 - going to have wait
confirmations, there's a little
899:21 - bit more boilerplate we need to
work with here in our Hardhead
899:23 - config, we don't have a network
here. So let's add our network
899:26 - information. So we can get those
block confirmations will be
899:29 - specific in here, as well. And
we'll say default network is
899:33 - going to be hard hat. And then
we'll say
899:37 - networks, and we'll add our
network information that's going
899:40 - to be working with heart hub,
which has a chain ID of 31337
899:46 - miles, we'll put that in here as
well. And block confirmations
899:49 - were just set to one lot this
column here, we're also gonna be
899:53 - running some staging tests on
the Rinkeby network. So we'll
899:56 - add rink B in here with a chain
ID of four, block confirmations
900:02 - of six, and we need to add a URL
and then also some accounts for
900:07 - our URL. We've done this 100
times. We'll do const. rinky
900:12 - dink could be RPC URL equals
process study and v dot rake,
900:18 - the RPC URL, that's private key,
blah, blah, blah, we're going to
900:22 - add all these same variables
from our last projects. So I'm
900:26 - going to ask you to pause here
and just copy paste all those
900:28 - variables from our last project.
Boom, like so since running
900:32 - rink, prpc, URL, private key
corn market cap and ether scan,
900:35 - we're also going to want to make
sure you folder, excuse me, new
900:39 - file, dot env. And we're going
to drop all of our information
900:43 - in here our rink, prpc, URL,
private key, ether scan API key,
900:47 - and then our coin market cap API
key as well. Now that we have
900:50 - our private key or ring prpc URL
down in URL, B RPC URL, and for
900:56 - accounts, we're just going to
add that single private key. Now
900:59 - for weight confirmations is
going to equal For network
901:03 - config dot block con formations,
or one, we're gonna have to
901:10 - import network from Hardhead,
which looks like my VS code
901:13 - automatically did for me. Thanks
VS code. So this is how we're
901:16 - going to deploy a raffle.
Obviously, we have a ton of
901:19 - arguments that we need to
account for. So let's get to it.
901:22 - Let's look at our raffle
constructor to see what we need
901:24 - to get. Okay, well, the first
thing that we need to get via of
901:27 - coordinator v2, we're gonna use
the same strategy we used in our
901:30 - Funmi project with using mocks,
if we're on a development chain,
901:34 - and using the actual contract
address if we're on a test net,
901:37 - or a live network, so let's get
to it. So let's go ahead,
901:40 - recreate that helper, hard hat
config dot j s and create that
901:46 - const. Network. Config, say it
equals for hard hat, we're going
901:53 - to use a mock. So we don't need
to put that in here for now. But
901:56 - for rink B, let's go ahead, but
a foreign here, so the name is
902:01 - going to be Rinkeby. And we're
going to need to go to the chain
902:04 - link documentation, the VRF
contracts, and we're going to
902:07 - need to grab the RF coordinator
for the Rinkeby. Test net, we're
902:11 - going to grab this address here,
plop it in here, we'll say V RF
902:15 - core did an eight tour v two,
bam, right like that. So back in
902:20 - our deploy raffle, we're gonna
have to pick whether or not to
902:23 - use the V RF coordinator v two
in the network config or some
902:26 - mock that we deployed, which of
course, leads us to us having to
902:30 - deploy a mock, let's create the
new file 00. Deploy marks.js. So
902:37 - same thing module that exports
equals async function where it's
902:43 - taking, get named accounts, and
deployments, as its input
902:48 - variables from the heart at
runtime environment, or do const
902:52 - deploy COMM A log equals
deployments. And then const,
902:58 - Deployer equals await, get named
accounts, Excel, and then we're
903:05 - going to grab the chain ID as
well as we're going to only
903:08 - wants to deploy this on a
development chain. So we'll do
903:11 - const chain ID equals network
dot config dot chain ID. Now
903:17 - we're going to only want to
deploy mocks, if we're on a
903:19 - development chain. So once
again, we're going to go to our
903:22 - helper config, we're going to
add those development chains in
903:24 - here. We'll say const,
development chains equals hard
903:31 - hat, and localhost. And then
we're gonna want to export both
903:35 - of these. So module, dot
exports, equals network config,
903:42 - and development chance. Now in
our deploy mocks, we're gonna
903:47 - want to grab those are saying
const development chains, equals
903:55 - require dot dot slash helper
helper hardhat config. Now we
904:01 - can check to see if development
chains dot includes the network
904:07 - dot name that we're currently
on. If we're in a development
904:10 - chain, we're gonna go ahead and
log local network, the
904:14 - protected, deploying box. And
now we'll have to deploy a mock
904:20 - VRF coordinator, where do we get
a mock VRF to coordinator Well,
904:25 - let's go ahead and create one of
those.
904:29 - We go to the chainlink. GitHub
again, we go to contracts. So C
904:33 - 0.8, actually have a mocks
folder with VF coordinator v2
904:39 - Mach dot Sol, and we're just
going to use this as our mock.
904:42 - So in our contracts folder,
we're gonna create a new file
904:45 - called test new file called V RF
core, in a core, the two mock
904:53 - dot Sol, and we're just going to
import this mock and have it be
904:56 - our mock. So we'll do spdx.
We'll do pragma, solidity,
905:04 - carrot zero, point 8.0, or seven
or whatever we want to do, we'll
905:08 - do import at chainlink slash
contracts slash SRC slash v 0.8.
905:15 - Slash, mocks, slash VRF. Pour
did a tour B to mock that soul.
905:23 - And we'll just check to see if
it compiles with Hardhead
905:25 - compile, and it looks like it's
compiling as well. Awesome. So
905:28 - now that we have our mock
contract, we can actually go
905:31 - ahead and deploy it. So we'll do
a weight loi, the RF core de ne
905:38 - Tor V to Mach
905:41 - comma, and then we'll give it
our parameters in here. We'll
905:44 - say from Deployer. Log is going
to be true, and then we're going
905:49 - to do our arguments. Now, what
are the arguments of this VRF
905:53 - coordinator, v2 Mk. Well, if we
open the VRF coordinator v2
905:57 - Mock, right in our VS code, or
on GitHub, we can actually see
906:02 - We will roll over to the
constructor that it takes two
906:05 - things. It takes a base fee and
a gas price link. What are these
906:10 - first one? Well, the first one
is this const base fee. If we go
906:14 - back to the documentation, we
can see that there's this
906:17 - premium section of 0.25 Link
rink B, this means that for each
906:22 - request, there's a base fee of
0.25 link for every request. So
906:27 - anytime we want to request a
random number on Rinckey, it's
906:30 - going to cost us 0.25. Link, or
you can think of it as 0.25
906:35 - Oracle gas to make this request.
So back in our deploy mocks, we
906:39 - can say base V equals, we could
resemble Rinckey here and do 25,
906:44 - blah, blah, blah, or we could do
ethers dot utils dot parse eath,
906:49 - of 0.25. And I'll even put a
little comment here, say 0.25 is
906:55 - the premium, it costs 0.25 Link
per request. And remember, the
907:02 - reason that this cost 0.25 Link
per request versus the price
907:06 - feeds didn't cost anything is
because the price feeds. If we
907:09 - look back at a chain that link,
each one of these price feeds is
907:13 - being sponsored by a group of
protocols who are paying for all
907:17 - these requests already, since
there isn't a sponsor for this,
907:20 - we are the only ones requesting
the randomness, we get to be the
907:24 - ones to actually sponsor getting
this random number, then the
907:26 - second thing here is going to be
the gas price link. So let's
907:30 - create another const here to
const. gas price link. But what
907:35 - this is, is actually a
calculated value is a calculated
907:39 - value based on the gas price of
the chain. Here's an example if
907:44 - we were to request a random
number on Aetherium, and the
907:47 - eath price skyrocketed up to
like to like a billion dollars,
907:52 - gas would be incredibly,
incredibly expensive. Now when
907:55 - chain link nodes respond chain
link nodes pay the gas fees, who
907:59 - give us randomness, and do
external execution, the chain
908:05 - link nodes are actually the ones
that pay the gas when returning
908:07 - randomness or executing an
upkeep or etc. If we go to our
908:11 - raffle dot soul, and scroll down
to perform upkeep, or fulfill
908:15 - random words, it's actually the
chain link nodes that are
908:18 - calling these two functions and
paying the gas for it, they get
908:21 - paid in Oracle gas to offset
those costs. But if the price of
908:24 - eath, or any native blockchain
skyrocketed the chain that nodes
908:28 - itself to pay the gas fee. So
the chain link nodes have a
908:31 - calculated price have a
calculated variable called the
908:34 - gas price per link, which
fluctuates based off the price
908:37 - of the actual chain, so that
they never go bankrupt.
908:41 - Basically, the price of a
request changes based off the
908:43 - price of gas for that
blockchain, you can kind of
908:45 - think of this as the link per
gas, if you will, for now we can
908:49 - kind of just set it to whatever
we want. And we'll just set it
908:52 - to one e nine, which is going to
be equivalent to 1123456789. So
908:58 - now that we have the base fee,
and the gas price link, we'll
909:01 - grab this base fee, we'll have
these be the arguments for our
909:05 - VR chord, enter V to mock, so
we'll say and actually we can
909:08 - delete that will say const, args
equals base fee, and gas price
909:15 - link, then we can take this args
variable and just plop it in
909:18 - here. Now we can do log mocks
deployed, then we can do log
909:23 - that a little line like this to
let people know that this deploy
909:26 - script is done, then we'll just
do a module that exports dot
909:29 - tags equals all and mocks. So
now that we have a view of
909:35 - coordinator v2 Mock deployed,
we'll come back over to our
909:38 - raffle and make some code around
it. Similar to what we just did
909:42 - with our deploy mocks. We can
say if development chains that
909:46 - includes network dot name, we'll
do some stuff. And we need to
909:51 - import development chains from
our helper Hardhead config. And
909:54 - we need to import network from
hard hat. My VS code
909:57 - automatically added them Wow,
thanks VS code. Let's even just
910:00 - do const args and make this
variable down here. Stick it in
910:03 - args. Our first argument is
going to need to be this Vera fi
910:07 - to coordinator so let's make a
variable we'll say let VRF core
910:12 - need torby to address and if
we're on a development chain,
910:17 - we're going to grab that mock
contract. So we'll say const
910:21 - PRF, Cor de ATAR V to mock
equals await ethers dot get
910:28 - contract, the RF cord the cord
to NATO Tor v two MK, and then
910:35 - we can set the RF coordinator v
two address equals VRF core
910:40 - denater V two mach dot
910:43 - address. Cool. We have that
address here. Else if we're not
910:50 - on a local network, the VRF v2
coordinator address is simply
910:54 - going to be derived from our
network config. So let's import
910:58 - the network config as well from
our helper Hardhead config and
911:01 - we'll say else VRF coordinator
v2 address equals network config
911:07 - of our chain ID. Let's which
actually sorry, we do need the
911:11 - chain ID cons chain ID equals
network dot config dot chain ID,
911:16 - chain ID of VR coordinator V to
chain ID. You're a coordinator
911:23 - v2. Alright, perfect. We've got
the setup to work with our VRF
911:27 - coordinator v2 address. What
else do we need from our raffle?
911:30 - Well, we need an entrance fee,
we probably want to change the
911:33 - entrance fee depending on what
chain we're on, we're on a more
911:35 - expensive chain, we might want
to make this higher than others.
911:38 - So let's go ahead back to our
helper Hardhead config and make
911:42 - an entrance fee based off of the
blockchain, so for NP, maybe we
911:47 - want to make it 0.01 eath. So we
could say ethers dot utils,
911:52 - parse ether of 0.01. And once
again, thank you VS code for
911:58 - automatically dropping that in
for me. And we're also going to
912:01 - want an entrance fee for our
heart app, we can also set a
912:03 - default in here, but let's just
be a little more explicit. So
912:07 - we'll say 31337. The name of
this is Art app, we don't need
912:12 - to give it a veneer of
coordinator v2 address because
912:14 - we're going to deploy a mock.
But we do want an entrance fee.
912:17 - And let's just give it the exact
same entrance fee here. So we'll
912:20 - say ethers dot utils dot parse
ether 0.01 E. Alright, great. So
912:24 - on our deploy here, we can just
say const entrance fee equals
912:31 - network config. Chain ID of
entrance fee. Let's start
912:39 - populating our arcs here. So the
first one is going to be your Fe
912:42 - two coordinator address. Next
one is going to be our entrance
912:44 - fee. Got it? Got it. Now we need
our gas lane. On Rigby and other
912:49 - networks, there are different
gas lanes that we can choose
912:52 - from, let's grab the only gas
Lane from Rinckey, the 30, gray
912:56 - key hash, let's drop this, of
course into our network config
913:00 - as gasoline, pop it in here,
we're hard hat, our mock
913:03 - actually doesn't care what gas
line we're working on, because
913:05 - we're going to be mocking the
gasoline anyways. So we can just
913:07 - say gas lane, we can just go
ahead and use the same one or
913:10 - really anything here, it doesn't
really matter. Now here we'll
913:13 - say const, gasoline equals
network config.
913:18 - Chain ID, gasoline, and we'll
grab the gas lane. And we'll
913:23 - stick it into our argument
array, we've got this one, we've
913:26 - got this one, we've got this
one. Now it's time for the
913:28 - subscription ID. Now if you
haven't run through docstoc
913:32 - chain link for the chain link
VRF, I highly recommend you do
913:35 - so so that you can understand
what this subscription ID is we
913:38 - know that we can actually make a
subscription ID using that front
913:41 - end using that website VRF dot
chain dot link, which is great
913:45 - and all but what if we're on all
local chains, we can get a
913:48 - subscription ID no problem in
here. But it's a little bit
913:52 - harder on a local network. Now
I'm actually going to teach you
913:55 - how to create and fund
subscription it is completely
913:57 - programmatically. So you don't
even need to use the UI if you
914:00 - don't want to. However, for the
purpose of this course, we're
914:03 - still going to use the user
interface, we're still going to
914:05 - use that website for us to get
our own subscription IDs. But
914:08 - you could 100% automate the
process of creating a
914:11 - subscription ID and funding a
subscription ID. Because when
914:14 - you create and fund subscription
IDs, you're just calling create
914:17 - subscription and fund
subscription on that smart
914:20 - contract. So on our development
chain, we have our V RF
914:23 - coordinator v2 Mock, and what
we're going to do and on our
914:26 - development chain, we're going
to create that subscription. So
914:29 - we're gonna say const,
transaction, response equals
914:33 - await VRF coordinator v2 Mock
dot create sub scription. And
914:42 - then we'll run const transaction
receipt equals weight trends
914:48 - action response, dot Wait, wait
one block confirmation. And
914:54 - inside this transaction receipt,
there's actually an event that's
914:57 - emitted with our subscription
that we can get this is another
915:00 - place where emitting events is
incredibly helpful. So in fact,
915:04 - if we open back up a Vera v2
coordinator mark, and we look
915:08 - for create subscription, we see
we emit subscription created
915:13 - with the subscription ID, we can
actually get this event emitted
915:17 - from our transaction receipt.
Now to assign it, let's go ahead
915:20 - and create a sub subscription ID
up here. And then we'll say
915:24 - subscription ID equals
transaction receipt that events
915:31 - of zero dot args dot sub ID. And
again, be sure to watch that
915:37 - events video if you want to
learn more about how to work
915:39 - with events in hardware. Now
that we have a subscription, we
915:42 - need to fund the subscription on
a real network, you'd need the
915:45 - link token to actually fund the
subscription. The current
915:48 - iteration of the mock allows you
to fund a subscription without
915:51 - the link token. So what we can
do is we can just run a wait
915:54 - your F corps inator Mark, if
coordinator B to Mach dot fund
916:02 - subscription, and we'll give it
the subscription ID and we'll
916:07 - need to do some fundamental
this, we can just create some
916:09 - variable, we'll say const VRF,
subscription fund amount equals
916:15 - ethers dot utils, dot parse
ether, of, we'll say 30 VRF
916:22 - subscription, fundament. We'll
just paste that down here. We
916:26 - could do this as well for a real
test net or live networks. But
916:29 - just so that we become familiar
with the user interface, we're
916:32 - not going to do a test net
programmatically. And for a test
916:35 - net, we're just going to use
exactly what we've been doing so
916:37 - far. Or we can put a
subscription ID and our helper
916:40 - config. So we'll say
subscription ID, we'll put
916:44 - something in here right now,
we'll just leave it as zero. But
916:47 - later on, when we actually
create a subscription, we'll
916:50 - update our subscription ID. And
so we'll say subscription ID
916:55 - equals network config. Change ID
of subscription ID. Perfect. Now
917:04 - we can add this to our arguments
array. What else do we need
917:09 - subscription ID, we need a
callback gas limit or callback,
917:12 - gas limit is going to vary
network to network. So once
917:15 - again, we're gonna go into our
helper configure callback gas
917:18 - limit. And for us, we'll set a
pretty high limit of 500,000
917:23 - gas. So we'll say call a gas
limit of 5.123 500,000. Gas. And
917:29 - for hard hat, we'll do the same
thing. So we can say const,
917:32 - callback, gas limit equals
network config, chain ID,
917:39 - callback, gas limit, grab this,
put it into our argument array.
917:44 - What else do we need? All we
need now is the interval. So we
917:47 - can change this network to
network as well. Rigby will say,
917:51 - interval will ever just be 30
seconds for both hard hat and
917:56 - for Rigby. So we'll do the same
thing here. Say const.
917:59 - Interval equals network config.
Chain ID, interval, and we'll
918:07 - grab this, pop it in the end of
our array. All right, awesome.
918:12 - Now we have an argument array
and drop it right in here and
918:15 - perfect. Everything in our
constructor for our raffle
918:18 - contract. Great. This is looking
fantastic. We've got wait
918:21 - confirmations we got logging
arguments Deployer. Okay, well,
918:25 - what next? Well, let's go ahead
and add that verification piece.
918:29 - So once again, create a new
folder utils, new file
918:34 - verify.js. We can either copy
paste this from our last
918:38 - project, or we can grab this
from the GitHub repo associated
918:41 - with this course, once we have
our verify script in here, we're
918:43 - going to import it by saying
const. Verify equals require dot
918:51 - dot slash helper Hardhead
config. And then we can add that
918:57 - same bit of code down here to
verify our contract, we'll say
919:00 - if we're not on a development
chain. And we have process
919:11 - studying v dot ether scan API
key, then we're going to log
919:16 - verifying dot dot and then await
verify raffle dot address and
919:22 - the arcs. Now we'll just do a
log of a whole bunch of hyphens
919:26 - say that this script is done
module dot exports dot tags
919:31 - equals say this will be all and
raffle. All right, so let's test
919:36 - this out. We'll do hardhat
deploy, or yarn, hard hat deploy
919:41 - and see if this script works
correctly. Looks like we ran
919:45 - into an error network config not
defined. So let's spell this
919:49 - right. Network config. There we
go. And that looks much better.
919:52 - Let's try this again. It looks
like our deploy scripts are
919:55 - working well. local networks
protected, deploying mocks
919:58 - deployed VRF coordinator v2 Mock
mocks deployed and then we went
920:02 - ahead and deployed our raffle.
Awesome, this is massive. Now
920:08 - we're not going to test the
deploying this to a test net
920:11 - quite yet, because well, we
don't have any unit tests yet.
920:14 - We need to write unit tests
before we want to ever test
920:17 - running this on a test net. So
we have our deploy script, we
920:20 - have our contracts, that means
it's time for us to write some
920:23 - tests. We'll come over here
we'll create a new folder called
920:26 - test. And for now, we'll just
make our unit tests. So unit
920:29 - tests, and in here we create a
new file called raffle.test.js.
920:35 - And let's write some unit tests.
Now for these unit tests, we are
920:38 - going to be a little bit verbose
here, we're going to make our
920:40 - coverage really, really good
here. It's not gonna be perfect,
920:43 - but this is going to be pretty
verbose. So I'm gonna go pretty
920:46 - quickly here. So you can feel
free to pause, slow me down,
920:49 - speed me up whatever you need to
learn this section. It is really
920:53 - good muscle memory to go through
writing these tests and
920:56 - understand what you should be
thinking about when you're
920:58 - writing these tests. So feel
free to speed up the parts You
921:01 - already know and slow down the
new parts. Because we are going
921:04 - to go over some new information
here. writing tests may seem
921:08 - like a tedious process. But I
promise as you get better at
921:11 - writing these tests, you'll
realize that these are the
921:13 - things that you can rely on when
stuff doesn't work. And when
921:17 - you're not sure how to code,
something, getting this muscle
921:19 - memory down, writing these tests
is going to make you a fantastic
921:23 - engineer. So let's go through
and we'll write some of these
921:25 - verbose tests here to try to
make this really good and have
921:28 - this have really good coverage.
And if you want to go back later
921:30 - on, and see if you can give it
even more coverage, and even
921:33 - better tests, please feel free
to do so. But let's get started.
921:36 - Let's write some tests. So we're
going to start out pretty much
921:39 - the same way we've been starting
everything out, we're going to
921:41 - grab our development chains, so
that we only run our unit tests
921:44 - on a development chain. So we'll
do const development chains,
921:49 - equals require dot dot slash dot
dot slash helper, RD, hard hat
921:55 - config, and then we'll say not
development chains, that
922:00 - includes network dot name, and
describe that skip. Otherwise,
922:07 - we'll do describe, so this first
describe is going to be our
922:10 - raffle unit tests. And this is
going to be an async. function.
922:16 - So raffle unit tests so that it
comes on the next line, it looks
922:19 - a little bit better. Alright,
great. Now, what are some of the
922:21 - main things that we're going to
need to deploy? Well, we're
922:23 - gonna need to deploy a raffle,
we're probably going to want a
922:26 - VRF core to a tour be to mock
graded before each, that's going
922:31 - to be an async function, where
we go ahead and we get these
922:35 - will say const. Employer equals
await, get named accounts.
922:41 - So we're gonna need to import
get named accounts or require
922:44 - get name accounts from hard hat,
then we're going to want to
922:47 - deploy these using our fixtures.
So we can say await deployments.
922:51 - And then we're going to import
deployments as well from hardhat
922:55 - dot fixture, and we're going to
call all, we're going to deploy
923:00 - everything. And again, if we
look at our one, our raffle has
923:03 - the alt tag, and our Oh, our
mocks also have the alt tag,
923:07 - okay, perfect. Once we deploy
everything, we can say raffle
923:12 - equals await ethers dot get to
contract. And we got to import
923:17 - ethers from hard hat, like so.
And we'll say it will get the
923:21 - raffle contract and we'll
connect it to our Deployer. And
923:27 - then we're going to do the same
thing with VRF coordinator v2
923:30 - Mock equals await ethers dot get
contract, the RF coordinator, B
923:37 - to MK connect this to deployer
as well. Alright, great, our
923:41 - first set of tests describe,
they're going to be the
923:44 - constructor. And this is going
to be an async function. And
923:50 - let's do this. Let's create an
IT initial initializes the
923:55 - raffle correctly, this is going
to be an async function. Now I
924:02 - just want to make a note,
because ideally, we make our
924:06 - tests have just one assert, or
it just keep that in mind is
924:12 - that ideally, we want to have
just one assert for it. But
924:14 - we're going to have a bunch
because like I said, we're being
924:17 - a little bit loose here. So we
want to just make sure that our
924:19 - raffle is initialized correctly.
So we'll say const raffle state,
924:24 - and we'll get that raffle state
because we want to make sure
924:28 - that we start in an open raffle
state. So we'll say const,
924:31 - raffle state equals await raffle
dot get raffle state. And then
924:39 - we want to say assert dot equal
ope and then we need to import
924:43 - assert from Chai. So assert
equals require Chai assert dot
924:47 - equal raffle state.to string
because again, raffle state is
924:53 - going to be a big number. And
even though a raffle state is of
924:57 - type raffle state, it'll return
a zero if it's open and a one if
925:01 - it's calculating. So this gets
transformed just into a un 256.
925:06 - When we call it like this, a
raffle state variable here will
925:09 - be a big number. So we want to
just to string a file. So assert
925:13 - dot equal raffle state DOT two
string zero. We'll also make
925:16 - sure our interval gets set
correctly. So we'll do const
925:20 - interval equals await raffle dot
get interval. And I don't know
925:28 - if we have one of those it's
actually C inter ball see if we
925:32 - have one of those. We don't have
a good interval let's go ahead
925:35 - and add again interval function
so we'll do function get in
925:40 - trouble. We have public view
returns you went to six return I
925:48 - underscore interval will have
good interval will say raffle
925:53 - dot get interval and will also
say assert dot equal interval.to
925:58 - string. It should equal one Ever
is in our helper config, right?
926:04 - Because we're using the interval
and helper config. So we say
926:06 - interval.to string should equal.
So we'll import that as well.
926:11 - Network config. And we'll say
the interval should equal
926:16 - network config. Of let's also
make, get our chain ID up here,
926:22 - chain ID, say const. Chain ID
equals network dot config, a
926:29 - chain ID, network config of the
chain ID of interval. Alright,
926:35 - cool. So let's test this so far,
HH test or yarn, hard hat test.
926:41 - And cool looks like it passed.
And we have our little gas
926:44 - output here. Awesome. Let's go
to our Hardhead config, just so
926:47 - that it doesn't always print out
at gas, but there for now. So
926:50 - I'm going to copy paste the gas
reporter section from our last
926:54 - project, like so. And we're
going to have enabled gas be
926:57 - false for now. So now if we run
a Hardhead test, again, we
927:00 - shouldn't have that gas bid
printed out, we should just see
927:02 - the tests and perfect, that's
what we see. And our constructor
927:05 - test passes. Yay, what's next,
got our constructor. And we
927:09 - probably could have written more
tests for the rest of these. But
927:11 - let's just move on. Alright,
enter raffle, that's going to be
927:14 - our next describe block. So it
will do describe,
927:19 - enter, raffle. And this is going
to be an async function. And
927:24 - we'll say it reverts when you
don't pay enough, right, because
927:30 - one of the first things that we
check is that they're paying
927:32 - enough. So we want to make sure
that this actually reverts if
927:36 - they don't pay enough. So this
will be an async function. Where
927:40 - we're going to do that same
expect await thing. So we're
927:44 - going to import expect from
Chai, which comes from those
927:48 - waffle matchers. And we're gonna
say await, expect raffle dot
927:55 - enter a raffle. And we're not
going to pass any value here,
927:59 - we're going to expect it to dot
b dot reverted with. And if we
928:06 - look here, we want it to be
reverted with this raffle not
928:09 - enough eath entered. So we can
put that in quotes raffle not
928:14 - enough eath entered. Now we can
try this out. Make sure that it
928:17 - actually works. Ah ah test dash
dash grep. Put this in quotes
928:22 - that you don't pay enough. And
awesome. We're passing there.
928:26 - What else do we want to test?
Well, we want to test that if
928:29 - the raffle isn't open, we also
revert but we'll test that in a
928:31 - little bit. As we kind of test
the rest of the functionality.
928:34 - We want to see that it records
players when they enter. So this
928:40 - will be an async function. And
now we'll enter the raffle.
928:44 - First we're going to need that
raffle entrance fee. Let's go
928:47 - ahead and save that at the top.
So we'll say let raffle VRF
928:50 - coordinator be to mock raffle
entrance fee and then our before
928:54 - each will say raffle entrance
fee equals a weight ethers dot
928:59 - get entrance fee. This should be
raffle dot get entrance fee. So
929:05 - now we have this raffle entrance
fee, you can use it to enter the
929:08 - raffle we'll say a weight raffle
dot enter raffle with a value of
929:15 - raffle entrance fee. And we can
make sure that our Deployer here
929:20 - has been correctly recorded. So
since right now we're connected
929:23 - to the Deployer. We'll just make
sure that that deployer actually
929:26 - is in our contract. So we'll say
const player from contract
929:32 - equals await raffle dot get
player of zero, because we
929:38 - record them in our players array
and we have our get players
929:42 - function which pulls them out.
And then we'll say assert dot
929:46 - equal player, player from
contract should be the Deployer.
929:51 - So now we can grep for this in
our hard head test. Make sure
929:54 - this works. HH test dash dash
grep. Deployer is not defined.
930:00 - We've got it up here. But we
actually didn't save it
930:02 - globally. So we got to do let
common Deployer. And we'll say
930:07 - deployer equals await get named
accounts. And we'll wrap it like
930:11 - this to get the deployer
Awesome. Let's try this again.
930:16 - And awesome. What else should
this do? Well, it's also
930:22 - emitting an event. So let's make
sure it emits an event. So we'll
930:25 - say it emits event on enter.
This will be an async function
930:31 - as well. And this will be the
first time that we're testing to
930:34 - make sure a function emits an
event and the syntax is going to
930:38 - look really similar to what we
test for when we check to see if
930:41 - an error is fired. So we're
gonna say await expect raffle
930:47 - dot enter raffle with value of
raffle entrance fee dot two dot
930:57 - omit and this.to dot emit we get
from During woful, these chime
931:03 - matches for emitting events we
can do a wait expect to emit,
931:07 - and then the event that we're
expecting to emit. So we're
931:09 - saying to omit the raffle
contract to emit a raffle enter
931:15 - event. We can copy this, try to
test this in our terminal. So
931:19 - we'll say hard hat. Test dash
dash grep. Just put this in
931:24 - quotes. And that passes as well.
Great. Let's now go ahead and
931:32 - test to make sure that we can't
enter the raffle whenever this
931:35 - raffle is not open or it's
calculating. So we'll say it
931:39 - doesn't allow entrance, when
raffle is Cal cumulating. And
931:46 - this will be an async function.
And first we'll enter will say
931:51 - await raffle dot enter raffle
931:56 - value is raffle entrance fee.
Now what we want to do we want
932:03 - to get this raffle into a closed
state. So we want to get it out
932:07 - of its open state. Well, how do
we move this raffle from raffle
932:10 - dot open to raffle dot closed in
perform upkeep, remove the
932:14 - raffle from raffle that open to
raffle dot calculating but
932:18 - perform upkeep can only be
called if check upkeep returns
932:22 - true. Otherwise, it'll revert
with raffle upkeep not needed.
932:26 - So what we need to do is we need
to make check upkeep return
932:29 - true. And we will pretend to be
the channeling keeper network to
932:33 - keep calling checkup keep
waiting for it to be true. And
932:36 - once we make it true, then we'll
pretend to be the channeling
932:38 - keepers and call perform upkeep
to put this contract in a state
932:42 - of calculating. Now how do we
actually do that? Well, in order
932:48 - for checkup keep to be true, we
first need to see that we are
932:51 - indeed open, which we are. The
next thing that we need to do
932:54 - though, is we need to do this
time passed bit. We need to
932:57 - actually wait that 30 seconds
for time to pass. Now, that kind
933:02 - of sounds awful. Do we have to
wait 30 seconds for all of our
933:05 - tests? What if our interval was
10 days when we have to wait 10
933:09 - days to run our tests? It sounds
ridiculous. Well, hard hat
933:13 - actually comes built in with a
ton of functions for us to
933:17 - manipulate our blockchain to do
literally whatever we want it to
933:20 - do. In the hard hat
documentation. There's a section
933:23 - called Hard Hat Network
reference inside the Hard Hat
933:26 - Network section. And in here,
there's a ton of information
933:29 - about how the hard hat network
actually works and different
933:32 - configs that we can do with it.
If we scroll down low enough, we
933:35 - can see the JSON RPC methods
that we can use on this
933:38 - blockchain, we can do eath
accounts block number call
933:41 - chinetti. We can do all these
RPC methods that a normal
933:44 - blockchain has. Additionally, we
can do even more than that, we
933:47 - can use these things called Hard
Hat Network methods. Since this
933:51 - is our local Hard Hat Network.
And we're using this for
933:53 - testing, we want to be able to
test any scenario. And it's
933:57 - these methods that give us the
ability to do that, you can go
934:00 - through this and play around and
see all the different things you
934:02 - can do. One of them in
particular is going to be set
934:05 - storage set where you can set
storage at any place, which is
934:07 - really fun. But some of the
special testing debugging
934:10 - methods are going to be EVM
increase time, and EVM. Mine
934:14 - increased time allows us to
automatically increase the time
934:18 - of our blockchain and EVM. Mine
allows us to mine or create new
934:22 - blocks, because if we increase
the time, it doesn't do anything
934:26 - unless there's a new block
mined. So what we can do is we
934:29 - can run a wait network, and
we'll import network from Hard
934:34 - Hat Network await network dot
provider that send EVM in crease
934:46 - time, comma, we can send a list
of parameters to send with it,
934:49 - which for us are just going to
be our interval.to number. And
934:54 - then we'll do plus one. Now
right now, our interval isn't
934:57 - stored globally, so we're
probably going to want to do
934:59 - that. So let's go ahead and do
interval. And then in our before
935:03 - each, we'll do interval equals
await, raffle dot raffle dot get
935:09 - interval, I'm just going to copy
this and we're going to delete
935:11 - this whole line. Wait raffle dot
get interval. Since now we're
935:15 - just going to call it interval
at a global level, since we're
935:18 - going to use it a lot. Now we're
gonna say interval that to
935:20 - number plus one. So we want to
increase the time by whatever
935:24 - our interval is to make sure
that we can actually get that
935:27 - checkup keep to return true. So
additionally, we're going to
935:30 - want to do a weight network dot
provider. Dot send EVM mine with
935:39 - an empty array just because we
just want to mine it one extra
935:42 - block. You can also do network
dot provider that request with
935:46 - an await here, these two would
be basically the same, but this
935:49 - one's a little quicker, right?
So we've increased the time of
935:51 - our blockchain. We've mined a
block to move forward. It should
935:55 - be open time has passed. Do we
have a player? We do indeed,
935:58 - because we've entered the
raffle. We should have a balance
936:01 - because we've entered the right
Apple, check upkeep should now
936:03 - return true. So we should be
able to call perform upkeep and
936:07 - pretend to be a chain lock
keeper. So we're going to
936:09 - pretend to be a chain the keeper
and call await raffle dot
936:13 - perform upkeep. And we're going
to pass this some empty call
936:18 - data just by passing a blank
array like that. And now this
936:22 - should be in a calculating
state. So now that it's in a
936:26 - calculating state, we can say
our enter raffle reverts
936:30 - correctly if the raffle isn't
open. So now we'll say await,
936:34 - expect raffle dot enter, raffle.
And we'll send it value of
936:41 - raffle entrance fee. We're
expecting this.to dot b dot
936:47 - reverted with that raffle
underscore underscore not open
936:55 - error. Okay, let's try just this
in our tests now. So we'll run
937:02 - Hardhead test dash dash grep.
Put this in quotes. And perfect
937:07 - that passes as well.
937:11 - Now if we run Hardhead test,
let's just test everything
937:13 - together right now. And
everything is passing. Oh, this
937:17 - is wonderful. Awesome. Let's
keep it going. And if we run
937:20 - Hardhead coverage, we'll see our
coverage is bumping up, we are
937:24 - already drastically better than
where we were before. Let's keep
937:27 - going well, let's go ahead and
test our check upkeep now. So
937:31 - we'll do describe, check upkeep.
And this will be an async
937:34 - function,
937:36 - where we'll say it returns
false. If people have been sent
937:45 - an E, E, it's been a sync
function.
937:49 - So we'll have everything in here
be true except for the fact that
937:53 - nobody's entered yet. So we'll
do a weight network dot provider
937:57 - dot send EVM increase time,
comma interval.to number plus
938:09 - one
938:11 - will do a weight network dot
provider. That send UVM mine. No
938:20 - parameters. Now we're going to
call check upkeep. Now here's
938:27 - the thing, check. upkeep is a
public function.
938:31 - So if we just run await, raffle
dot check upkeep, and we pass
938:36 - nothing in this is going to kick
off a transaction, because hard
938:40 - had knows Oh, okay, it's a
public function, they're clearly
938:43 - trying to send a transaction
here. If this was a public view
938:46 - function, it wouldn't, it would
return that view. But the thing
938:49 - is, I don't really want to send
a transaction. But I want to
938:52 - simulate sending this
transaction and seeing what this
938:56 - upkeep needed would return.
Well, I can actually get that by
938:59 - using something called call
static, I can simulate calling
939:03 - this transaction and seeing what
it will respond. So instead of
939:06 - raffle dot, check upkeep, I can
do raffle dot cost static, that
939:11 - check upkeep. And this will give
me the return of upkeep needed
939:16 - and the bytes perform data, I
can extrapolate just the upkeep
939:19 - needed out of this return or
writing const upkeep needed
939:26 - equals this, and then I can do
assert not upkeep needed,
939:34 - because right now upkeep needed
to return false. So we'll say
939:38 - assert, not false, which is
true. If upkeep needed was true,
939:42 - then this would be false. And
this would break. So that's what
939:44 - we want to do. So let's go
ahead, we'll run this, see if it
939:48 - worked. Our hat test, dash dash
grep. And we're in passing, we
939:54 - are in business. Awesome. So
this is working perfectly. Well,
940:00 - and let's also test that it
returns false. If raffle isn't
940:07 - open. This will be an async
function. And we'll do
940:12 - everything except and we'll do
everything in here. But we'll
940:15 - make the raffle in the
calculating state. So do a
940:19 - weight, raffle dot enter, raffle
value, raffle entrance fee await
940:29 - network dot provider that send
and I'm just going to copy these
940:33 - two lines here. Because we're
going to go ahead and do those.
940:36 - We're also going to do a weight,
raffle dot perform upkeep. And
940:42 - another way to send a blank
bytes object is to do a string
940:45 - like 0x hardhat is smart enough
to know that this should be
940:49 - transformed into just kind of a
blank bytes object. So either
940:53 - one of these should work. Now
we're do const, raffle state
940:56 - equals await, raffle dot get
raffle state and we'll Get
941:01 - upkeep needed. So we'll say
const. upkeep needed, we'll do
941:05 - exactly what we did above raffle
dot call static dot check
941:11 - upkeep. Let's say excuse me a
weight, raffle dot call static.
941:16 - Now we can do assert dot equal,
say raffle state is going to be,
941:22 - or excuse me raffle state.to
string, it's going to be
941:25 - calculating, and I started dot
equal upkeep needed, it's going
941:30 - to be false. Let's run a GREP on
that. And perfect. That's also
941:38 - working correctly. Great. Now
I'm going to skip over these
941:41 - next two tests, because we
haven't really learned anything
941:44 - from them. So I'm just going to
copy paste them from the GitHub,
941:47 - we're going to return false if
enough time hasn't passed. And
941:50 - we're going to return true. If
enough time has passed, we have
941:54 - players Eve and is open. So
we're just asserting true down
941:58 - here. And we're starting not
true up here, you want to pause
942:00 - the video and copy paste these
and write these out, you
942:03 - absolutely can copy paste them
from the GitHub repo, you
942:05 - absolutely can't like I said,
going through this and making
942:09 - yourself write these and making
yourself understand these tests
942:11 - is going to make you a
substantially better coder. And
942:14 - let's just test that it all
looks good with hh test. Now, as
942:18 - I was recording this, I just
realized that for all of our
942:21 - describe blocks, I've been
making them async functions
942:24 - describe blocks actually don't
realize and can't recognize and
942:28 - can't work with promises. So
having the be async actually
942:31 - doesn't do anything. So in your
describe block, we want to get
942:34 - rid of the async word because
it's actually not helping us at
942:37 - all. In fact, it's just an extra
word, and it looks kind of
942:40 - gross. So now all of our
describe blocks, we're gonna get
942:43 - rid of that async keyword, and
just have them be functions. Of
942:46 - course, all of our it's, though,
are going to be using
942:49 - asynchronous functions, which is
what we want. So we've written
942:52 - some tests for a checkup keep.
Now let's go ahead to perform
942:56 - upkeep.
942:56 - Let's create a new describe,
block, ascribe or perform
943:01 - upkeep. This is going to be a
regular function. And in here,
943:05 - we're going to start and say it
can only run if check upkeep is
943:10 - true. And this will be an async
function. Because we only want
943:14 - to perform keep to work if
checkup keep is indeed true. So
943:18 - we'll say await raffle dot
enter. raffle we'll send it some
943:22 - value, raffle entrance fee, I'm
sorry, there should be curly
943:27 - braces instead. And we'll do a
weight network dot provider that
943:32 - send EVM increase time inter
vol.to number plus one await
943:43 - network dot provider that send
UVM mine an empty array there to
943:51 - the reason that we're moving
time forward and moving our
943:53 - block forward, of course is
gonna be the same thing as
943:55 - above, we want our check upkeep
to return true. And then we're
943:58 - gonna say const X or transaction
equals await raffel dot perform
944:04 - upkeep. We can either do a blank
array, or we could do 0x Doesn't
944:11 - matter. And we can assert the X.
Now if TX doesn't work, or this
944:15 - error is out or something, this
will fail. Right. So that's how
944:19 - we know that this actually can
work. So let's test this out. We
944:22 - want this only to work if
checkup keep is true. And we
944:26 - made checkup keep true by all
the stuff that we did above. So
944:30 - now we'll do yarn hardhat test
dash dash grep with our IT block
944:35 - here. And I spelled perform
upkeep wrong perform upkeep.
944:40 - Let's try spelling things
correctly. And let's run that
944:43 - test again. And great. That's
working. I will What else do we
944:47 - want to do? We want it to revert
with raffel. upkeep not needed
944:52 - if checkup keep is false. So in
here we're gonna say it reverts.
944:57 - When check up keep is false.
This will be an async function.
945:03 - And we're going to do that same
syntax await expect raffle dot
945:08 - perform upkeep empty bytes
object that to.be reverted with.
945:16 - And what do we want it to be
reverted with? Or hoping it's
945:18 - reverted with this with that, we
can run this test here Hardhead
945:24 - test dash dash grep paste that
in. And we see that is indeed
945:29 - passing now something that
you'll notice here is that our
945:32 - revert actually goes ahead and
reverts with all this extra
945:35 - stuff as well. Our test is smart
enough to know that if all we do
945:38 - is put the name of the error
that is getting reverted with
945:42 - then it's good enough. If we
want to be super specific, we
945:45 - can actually go ahead and make
this a string interpolation and
945:49 - add all of these in here. So we
can add the balance that we
945:53 - expect we can add the players
that we expect. And we can add
945:56 - the raffle statement for now
we're just going to keep it as
945:59 - we're expecting this but if you
want to be super specific you
946:02 - can have your tests expect for
exactly the specific values that
946:06 - you're looking for. But alright,
what is the last thing we should
946:09 - expect form? Well, we should
check to see that this actually
946:12 - gets called the raffle state
gets changed. And we admit this
946:16 - event. So let's go ahead and add
that. We'll say it updates the
946:21 - raffle state admits an event and
calls the VRF coordinator to be
946:30 - an async function as well. Let's
do this. So let's go ahead and
946:34 - let's make checkup keep true,
I'm just going to copy paste
946:37 - these first three lines, since
it's going to be exactly the
946:40 - same. We're going to enter the
raffle we're going to increase
946:42 - the time we're going to mind a
new block, then we're going to
946:44 - call perform upkeep. So we're
going to say const, TX response
946:49 - equals await raffle dot perform
upkeep with an empty bytes
946:55 - object, and we're going to do
const TX receipt equals await TX
947:02 - response dot wait for one block.
From this receipt, we're gonna
947:07 - get the request ID, we're gonna
say const Request ID equals, we
947:12 - can get the request ID. From
this omitted event. However, we
947:17 - should look at our VRF
coordinator mock again, when we
947:21 - call request random words, both
in the mock and then in the
947:25 - actual contract, you'll notice
that it also emits an event with
947:30 - random words requested. And if
you look in here, the second
947:33 - parameter that it has is indeed
the request ID. So in reality,
947:38 - US omitting the request ID is
redundant, we can just use the
947:42 - admitted Request ID from the VRF
coordinator for the purpose of
947:45 - this course and showing you what
an event looks like. We're going
947:48 - to leave it in there. But if you
want to go back and refactor
947:50 - this, you would definitely want
to remove this omit. But for
947:54 - this test, let's do TX receipt
dot events. And this is going to
947:58 - be the first event instead of
the zero with event because
948:02 - before this event gets emitted,
this function is going to emit
948:06 - an event. So instead of the zero
with event, this is the first
948:09 - event that gets emitted after
this one. So tax receipts dot
948:12 - events of one dot args dot
request, ID, and then we're
948:17 - gonna say cert request id.to
number is greater than zero. And
948:23 - then we'll also assert that the
948:26 - raffle state equals equals one.
So we're gonna do const, raffle
948:31 - state equals await, raffle dot
get raffle state. And this
948:37 - should actually be raffle
state.to Number, or to string
948:41 - and then you know, do whatever
we want to do. And this is a
948:44 - very big it, but we're going to
copy the whole thing anyways. HH
948:48 - test, dash dash grep, paste that
in there, we run it, excuse
948:52 - me.to string equals equals one,
transformer time and perfect, we
948:59 - are passing Great, now it's time
for fulfill random words. And
949:03 - this is where we're going to
learn a lot of fantastic stuff
949:06 - here. So we're gonna make a new
describe block zoomed out a
949:09 - little bit here. And this is
going to be our fulfill random
949:15 - words. It's going to be a
function, of course. And in
949:20 - here, we're actually going to
add another before each want to
949:23 - have somebody have entered the
raffle before we run any tests
949:26 - in here. So we're going to do a
before each, which will be an
949:31 - async. function. And we're just
going to run await, raffle that
949:37 - enter raffle with a value of
raffle entrance fee. And then
949:44 - we're going to do a wait network
dot provider dot send EVM
949:50 - increase time of interval, that
to number plus one, and then a
949:58 - wait network dot provider dot
send EVM mine. Comma. Before
950:06 - we've tried to do any testing of
or fulfilled random words, we're
950:09 - gonna have somebody enter the
lottery. And we're going to have
950:11 - increased the time and mined a
new block. Okay, cool. So the
950:15 - first thing we want to do is
want to see that fulfill random
950:17 - words can only be called so long
as there's a request in flight,
950:22 - so long as there's a requested
as long as request random words
950:26 - has been called. So we can
actually check that by running
950:28 - it can only be called after
perform. This will be an async
950:34 - function. And in here, we're
going to revert on some requests
950:38 - that don't exist. So we'll do
await, expect the RF core didn't
950:44 - a tour be to mock dot fulfill
random words. And if we look at
950:51 - our V RF, coordinator v2 Mark in
here has the fulfill random
950:57 - words function, which is what
the chain link node actually
951:00 - calls and inside Add this
function in the actual contract
951:03 - calls another contract that does
the random number verification.
951:06 - So we're basically checking this
part right here. If the request
951:09 - doesn't exist, we're going to
get this non existent request
951:13 - here. And as you can see, it
needs a request ID and a
951:16 - consumer address. So we're going
to guess zero. And the consumer
951:20 - addresses, of course, it's gonna
be raffled out at address, we're
951:23 - going to expect this to be
reverted, with non existent
951:31 - request. And then we're going to
do this exact same thing with a
951:35 - different Request ID or request
ID one. And hopefully, we're
951:39 - also going to get non existent
requests. Now ideally, no
951:42 - request here would ever allow
this fulfill random words to go
951:45 - through. Now, it obviously would
be really hard for us to test
951:49 - every single possible Request
ID, we're going to see a way in
951:52 - the future to actually test for
a ton of these variables with
951:56 - something called fuzz testing.
But we'll get to that in the
951:58 - future. And I spelt the scribe
wrong, let's let's actually
952:01 - spelled the scribe correctly, go
ahead and run this hh test dash
952:05 - dash grep.
952:07 - And great it passed. Now I'm
going to make just one more test
952:13 - here, that's gonna be way too
big. But right now the test that
952:17 - we're about to write is going to
be it's going to be a really big
952:19 - test. And we probably want to
split it up into different
952:22 - sections, but actually figured
that this was actually the best
952:25 - way to show this section. And
it's going to be exactly what
952:27 - we're going to do. When we get
to our staging test, we're going
952:30 - to write this test literally
almost exactly the same. So
952:33 - let's write it, this is
basically going to be the test
952:37 - that puts everything together.
So we're going to test that this
952:40 - indeed, so winner resets the
lottery, and sends money, which
952:47 - is kind of a lot for a single
it, we probably would want to
952:50 - split those into their own
pieces. But for this, we're just
952:53 - going to put them all into one,
and it's going to be an async
952:55 - function. Now we are going to
learn a couple of new tricks
952:59 - here. So definitely be sure to
follow along. Now for this one,
953:02 - we're also going to add in some
additional entrances additional
953:05 - people who are entering this
lottery. So we'll say const,
953:08 - additional, and trance equals
great. We're gonna have some
953:14 - more of those fake accounts from
ethers enter our lottery here.
953:17 - So we're gonna say const.
Starting account, index equals
953:23 - to, since deployer equals zero,
excuse me equals one, since the
953:27 - player is zero, so we're going
to have new accounts start from
953:30 - index one. And we're going to do
a little for loop or let i
953:35 - equals starting count index, i
is less than the starting count,
953:45 - index, plus additional and trend
sees there's gonna be entrance.
953:52 - i plus plus, we're gonna do a
little loop and connect our
953:56 - raffle contract to these new
accounts. And then we're going
953:59 - to have these new accounts,
enter our raffle contest. Count,
954:05 - connected raffle equals raffle
dot connect accounts of i and do
954:13 - we have accounts defined
somewhere we don't. So let's get
954:16 - accounts to find somewhere.
We'll say const accounts equals
954:20 - await ethers dot get signers.
And then we're going to do a
954:24 - weight account connected raffle
dot enter. raffle with a value
954:31 - of course of raffle entrance
fee,
954:34 - we're going to connect three
additional entrance to our
954:37 - raffle. So we're going to have a
total of four people connect
954:41 - into this raffle. Now that we
have them in here, we're going
954:43 - to keep note of our starting
timestamp. So we're gonna do
954:47 - const starting timestamp equals
await, raffle dot get last
954:54 - timestamp. And here's where
we're going to get a little bit
954:56 - tricky. What we want to do is a
couple of things we want to we
955:00 - want to perform upkeep, which is
going to mock being chainlink
955:05 - keepers, which will kick off the
chain link, which will kick off
955:09 - calling fulfill random words.
And we're going to mock doing
955:14 - that as well. Mock being the
chain link VRF. Once we do that,
955:19 - we can of course just check to
see okay, did the recent winner
955:22 - get recorded the raffle get
reset just play as we said as
955:26 - the timestamp is everything
reset. But we want to do this in
955:29 - a specific way. If we're doing
this on a test net after we call
955:33 - fulfill random words, we will
have to wait for the fulfill
955:37 - random words to be called. Now
since we're working with a
955:40 - hardhat local chain, we don't
really need to wait for
955:43 - anything, right because we can
just say okay, boom, snap our
955:46 - fingers and adjust our
blockchain to do whatever we
955:48 - want. But we're going to
simulate that we do need to wait
955:51 - for that event to be called. So
in order for us to simulate
955:55 - waiting for that event, we once
again need to set up a listener.
955:59 - Now if we set up a listener we
don't want this to Just to
956:02 - finish before the listener has
is done listening, so we need to
956:06 - once again create a new promise.
And this is going to be
956:09 - incredibly important, especially
for our staging tests. So we're
956:13 - going to do await, new promise.
And this is going to be exactly
956:17 - the same as we set it up before,
it's going to be an async
956:20 - function that's going to take
resolve and reject as
956:24 - parameters. And we're going to
use this little arrow syntax
956:27 - here saying, this is an async
function, basically, and we're
956:30 - going to set up once again, that
once syntax, we're gonna say
956:34 - raffle that once, what's the
event name, winner picked. So
956:39 - we're gonna say, Listen, for
this winner picked event, we're
956:42 - gonna say raffle dot once winner
picks happens, do some stuff.
956:46 - And again, this is just an
anonymous function. So we're
956:49 - gonna say raffle dot once the
winner picked event gets
956:51 - emitted, do some stuff. So we're
setting this up. Now it's in
956:56 - this function, we're going to
add all of our certs and
956:58 - everything because we want to
wait for winter to get picked.
957:01 - Now before the event gets fired,
though, we of course, need to
957:05 - actually call perform and call
fulfill random words. So this is
957:08 - going to seem like it's a little
bit backwards. But that's
957:11 - because we want to set up our
listeners so that when we do
957:14 - fire, the methods that will fire
the event, our listener is
957:19 - activated and is waiting for it.
So we're going to put all of our
957:22 - code inside of this promise.
Now, because we put it outside
957:27 - of the promise, we put all the
code outside of the promise,
957:28 - this promise will never get
resolved, because the listener
957:31 - will never fire into vent. So if
down here, you know we call
957:34 - fulfill random words with
something, you know which the
957:37 - spelling is bad. But let's say
we call the down here, this
957:40 - piece of code will never reach
this fulfill random words,
957:43 - because it's always going to be
waiting for this wants to get
957:47 - resolved. So we need to add all
of our code inside the promise.
957:51 - But outside this raffle dot once
now we don't want to wait
957:55 - forever, right? Maybe there is
an issue here. And we want to be
957:58 - able to reject this, if there's
an issue. Now what we can do is
958:02 - in our heart hat dot config, we
can add a timeout. So we can add
958:06 - this mocha section, we can give
ourselves a timeout of 200,000
958:13 - milliseconds, which is going to
be 200 seconds max, if this
958:17 - event doesn't get fired in 200
seconds, this will be considered
958:21 - a failure and this test will
fail, which is what we want. And
958:24 - I typically like to just wrap
this in a try catch because if
958:27 - something fails, it'll cause you
a whole bunch of headache catch
958:31 - E. And if anything fails, we'll
also reject, there's an issue
958:35 - with us calling some function,
we'll just say, Hey, okay,
958:38 - that's a failure. But you fail,
that way, our promise can get
958:41 - resolved in a timely manner,
we're going to add this code in
958:43 - a little bit. But let's keep
going. Let's keep going. And
958:47 - excuse me, the trycatch should
be in the ones, the ones above
958:50 - the results, excuse me, because
this is the listener. So sorry,
958:54 - we want the trycatch to be
inside the ones if this takes
958:56 - too long, we want to just go
ahead and throw an error.
958:59 - Otherwise, we're going to
resolve now outside the
959:01 - listener, but inside of the
promise, we're going to do this
959:04 - bit here, where we go const TX
equals await raffle dot perform
959:11 - upkeep, and we'll pass it the
empty bytes object, we'll get
959:15 - const TX receipt equals await TX
dot weight of one block.
959:21 - And then we're going to do a
weight VRF core didn't a tour be
959:27 - to mock dot fulfill random
words, CX receipt dot events of
959:35 - one dot args dot Request ID come
a raffle that address. So then
959:41 - the final thing that we're going
to do is we're going to get this
959:43 - veer off coordinator be to mock
we're going to have it call
959:47 - fulfill random words, which
takes the request ID and the
959:50 - consumer address. So we're going
to mock it, give it the request
959:53 - ID which we get from the
transaction receipt, and the
959:56 - consumer address here. All
inside this promise, we're
959:59 - setting up a listener for this
winner picked event. And then
960:02 - we're mocking the channeling
keepers and then we're mocking
960:05 - the chainlink VRF. And once this
function gets called this
960:09 - function should emit a winner
picked event. So this raffle
960:14 - that was set up that was
listening for this to get
960:18 - emitted will pick up and go Ah
okay, I found it I found the
960:22 - winner picked event. Now we can
go ahead and do some stuff. So
960:26 - once the winner picked event
gets fired, we'll do a little
960:29 - console dot log found the event
like this and we'll jump into
960:35 - our try catch and this trycatch
is going to be basically us
960:38 - doing all these asserts in here.
So first we want to say const
960:42 - recent winner equals await
raffle dot get recent winner and
960:48 - we're going to be checking just
everything in this raffle right
960:50 - we're gonna be checking that the
recent winners right that that
960:53 - the raffle state's been reset
the players have reversed, you
960:55 - know, players has been reset,
etc, etc. So we'll say const
960:59 - raffle state equals awaits
raffle dot get raffle state
961:06 - we'll say const. Ending
timestamp equals await, raffle
961:12 - dot get last timestamp. And
let's start doing some asserts.
961:17 - So first we should assert that
this es players array has been
961:21 - reset to zero. So if we call get
number of players it should be
961:25 - zero. So we can do const num
players equals await raffle dot
961:32 - get number of players like so.
And we can do assert dot equal
961:40 - nine players.to string is going
to be zero. What else can we
961:45 - assert? Well, we can assert dot
equal raffle state should be
961:52 - back to being open. So raffle
state.to string should be zero,
961:59 - we should assert that the ending
timestamp is now greater than
962:04 - the starting timestamp. Because
the last timestamp should have
962:09 - been updated. We also want to
make sure our recent winner is
962:12 - correct. But we'll do console
dot log recent winner. Now we
962:16 - can go to the VRF coordinator
mock. And we could simulate this
962:20 - and try to figure out who the
random winner is to console dot
962:22 - log accounts to. And then just
to show a bunch of them, we'll
962:27 - do 01 and three a raffle dot
once this needs to be an async
962:35 - function, not just a regular
function. Let's try that one
962:38 - more time, get latest timestamp
is the correct function. So
962:42 - let's update this with the
correct latest. Let's put latest
962:45 - in there. Because I'm spelling
something's wrong. I sure am
962:49 - looks like we're printing out
recent winner here when we
962:52 - haven't even initialized it. So
let's move it up. And then we'll
962:55 - do console dot log recent
winner. So I know this is a
962:59 - massive test here. But let's
give it a try and see if
963:03 - everything kind of does what we
think it should do. And it's
963:05 - slowing down here, which is good
because we're doing a lot of
963:08 - stuff. And uh huh, we finally
get this passing thing to come
963:13 - out. And we did a ton of console
dot logging so so there's a lot
963:17 - of stuff in here of the signers
are getting printed out. So
963:19 - let's just make this a little
easier to read. We'll add dot
963:22 - address to all these, we can see
who the winner is. So it looks
963:27 - like the winner is going to be
account number one, which is
963:30 - great. So what we can do now
that we know account number one
963:33 - is going to be the winner, we
can get that winners starting
963:35 - balance way down here before we
call fulfill random words. So
963:40 - we'll say const winner, starting
balance equals await accounts
963:47 - one dot get balance, yes, you
can just call get balance right
963:51 - like that. And now that we have
the winner starting balance back
963:55 - in our tests, we can say const
winner, ending balance equals
964:01 - await ounce one dot get balance.
And we can make sure that this
964:07 - winner got paid what they need.
So now we're going to do a big
964:11 - assert with some money stuff,
just trust me, this is what the
964:14 - math is. So we're going to do
assert dot equal winner
964:18 - balance.to string,
964:21 - excuse me winter ending
balance.to string should equal
964:26 - the winner starting balance dot
add the raffle entrance fee that
964:34 - multiplied by the additional and
trance that add the raffle
964:41 - entrance fee that we paid.to
string. So this math is
964:45 - basically saying the winner
should end with a balance of all
964:50 - of the money that everybody else
added to this contract. And
964:53 - that's it. So we can run this
test one more time. And Gosh,
964:57 - darn it, it passed. Okay, so
there was a lot of code here.
965:00 - And this might have been one of
the hardest pieces of this
965:03 - entire course is going to be
this part right here. So if you
965:06 - struggled a little bit with
this, don't let that bog you
965:08 - down. This is probably one of
the more difficult sections of
965:11 - this course, let's do a quick
refresher of just this test that
965:15 - we're doing. And then we'll see
in an action when we do it. In
965:18 - our staging test. What we did is
we're picking a winner resetting
965:21 - the lottery and we're sending
money. Basically what we're
965:23 - doing is we're testing that this
fulfill random words thing does
965:26 - what we want it to do a random
winner wins and they get the
965:29 - money. So how do we actually do
that? Well, we first started off
965:31 - by having a bunch of random
people enter the lottery. Great.
965:34 - Sounds good. Now what we wanted
to do was we want to call
965:38 - perform upkeep and fulfill
random words, we want to pretend
965:42 - that the random number was
drawn. And that's what this code
965:45 - down here does is it calls that
random number but and what we
965:48 - could have done was we could
have had all these assert and
965:51 - checked all the variables. After
we did this, right. We could
965:54 - have totally done that. However,
on a test net where we don't
965:58 - always know exactly when a
transaction is going to finish.
966:01 - We have to wait If we have to
listen for an event to be fired,
966:04 - before, we could call the
transactions that would end this
966:07 - whole thing, we needed to set
something up to listen for that
966:10 - event to be fired. And we said,
hey, only once this event is
966:14 - fired only once this transaction
is called, can we do our testing
966:18 - now for our local network, we
are mocking the VRF
966:22 - coordinators, we have control,
we know exactly when this is
966:24 - going to run. But on a test net,
we don't. So you'll see in our
966:28 - staging tests, we won't have any
of this here. And we'll have to
966:31 - rely on setting up a listener to
listen for the channeling VRF
966:37 - and the keepers to fire their
events. And that's why the
966:40 - staging test is going to be so
important to make sure that
966:43 - we're doing everything correct.
And that's why we set up our
966:45 - local tests like this, so that
it mimics what we're going to be
966:48 - doing on our statement test what
we're going to be doing on a
966:51 - real network here. And again,
we're setting up this listener
966:54 - and we're saying, Ah, once we do
here, this event, then we're
966:58 - going to try to actually check
all of the balances and check
967:01 - that everything is working as
intended. And if we don't see
967:04 - it, we're going to reject. And
if there's a timeout, if it
967:07 - takes more than 200 seconds,
we're going to say okay,
967:09 - something went wrong, we're
going to cancel it. And
967:11 - actually, I'm going to bump this
up to 300 seconds, because I
967:13 - think 200 seconds is not going
to be enough. And depending on
967:17 - how quick the rink B test that
is, you might have to bump this
967:19 - up even bigger. So just keep
that in mind. But who, okay, we
967:27 - have just built some fantastic
tests. Let's go ahead, and let's
967:30 - just run h h test to see if all
of our tests are going to pass.
967:36 - And well, 14 passing, everything
is passing here we are looking
967:40 - good.
967:41 - This is fantastic. Alright, so
now that we have our unit tests,
967:46 - let's go ahead and create a
staging test. Our staging test
967:50 - is going to look really similar
to that massive test that we
967:53 - just created down here. And the
reason we set up our unit test
967:56 - to do this a weight promise
thing with the raffle dot once
967:59 - was because this is actually how
we're going to need to wait on a
968:02 - test net or main net for a
winner to be picked. We cannot
968:06 - on an actual test net, pretend
to be the chain link V REF, we
968:09 - can pretend to be the chain link
keepers if we want. But we're
968:11 - not going to make sure that the
10 the keepers is actually
968:14 - working. But we are going to be
doing this because we want to
968:17 - listen for that event to be
fired, we want to listen for the
968:21 - chain link VRF to respond with
the winner. So let's create a
968:25 - staging test. And this is a test
that we're going to run on an
968:29 - actual test net here. Okay, so
we're going to create a new test
968:33 - called raffle dot staging dot
test dot Jas and this is where
968:38 - we're going to put our staging
test. Now we can actually code
968:41 - this pretty quickly because most
of our staging tests is gonna
968:44 - look real similar to our raffle
test here. So for now, let's
968:47 - just grab this whole first part,
and then we'll adjust it as we
968:51 - need. And then we'll close it
off. Because we're definitely
968:54 - gonna need a raffle, we're not
going to need a VRF coordinator
968:57 - mock because again, we're not
going to be using a mock. Since
969:00 - we're on an actual test net, we
will need the raffle entrance
969:02 - fee, we will need Deployer, we
will need a Deployer. And we
969:06 - might need the interval. But
let's delete it for now we
969:08 - probably won't need the chain
ID. So let's delete that as
969:11 - well. Awesome. Something that we
want to keep in mind is that
969:14 - when it comes to our staging
tests, we only want our steam
969:17 - test to run when we're on a
test. Net, we don't need to run
969:19 - our unit tests because our unit
tests aren't checking that
969:22 - compatibility with a test net,
we want our unit tests to only
969:25 - run on a local network. And we
want our staging tests to only
969:29 - run on a test network. This is
where again, in our test, we're
969:32 - going to check to make sure what
type of chain we're on. And
969:35 - oops, it looks like I already
imported the development changes
969:38 - here. So we're actually in our
staging tests, we're going to
969:41 - check before we run any test
what kind of network we're on.
969:44 - So we're gonna say, if our
development chains that includes
969:49 - network dot name, we're gonna
say if our development chains
969:52 - includes network to name, so if
the chain we're on is in the
969:55 - development chains, and again,
we're going to use this ternary
969:58 - operator where we say, if we're
on a development chain, do
970:01 - something. And then if we're not
on a development chain, do
970:03 - something else. If we are on a
development chain, what are we
970:06 - going to do? Well want to skip
this and we can actually skip
970:09 - this by putting in this describe
dot skip. And this will skip
970:13 - this whole section here. And
then we can say, if we are the
970:17 - development chain, go ahead and
do our thing. So this is some
970:20 - really nice syntax that allows
us to skip our staging tests if
970:23 - we're on a local network. And
additionally, we can grab this
970:27 - syntax, go into our raffle dot
test dot j s where we have our
970:30 - unit tests and add the bang
operator, which is the knot and
970:34 - hit Save. And now we're saying
if we're not on a development
970:38 - chain, skip it and only run this
if we aren't in development
970:41 - chain. So this says run this
only on a test net or main net.
970:44 - And then this has run this only
on a local network. Great. So we
970:47 - have a deployer which we're
going to need. We are not going
970:50 - to need to deploy any fixtures
because we're going to run our
970:54 - deploy script and our contracts
should already be deployed. We
970:57 - will need a raffle we won't need
a VRF coordinator mocks we can
971:00 - delete that We will need the
entrance fee, and we probably
971:03 - won't need the interval. So we
can go ahead and delete that
971:05 - too. Alright, awesome. So we
have our describe, we have our
971:08 - before each, let's make our
tests. And I'm just going to
971:11 - make one giant test to test kind
of everything end to end. And
971:15 - you can add more tests later on
yourself, if you want to our
971:18 - staging test is going to be
really similar to this massive
971:22 - test that we made down here. And
in fact, we're going to use most
971:25 - of this code here as our
boilerplate. So let's create a
971:27 - describe. And we'll say, and
we'll actually just copy this
971:31 - describe the four random words
and paste it in here. Because
971:34 - again, we're going to be using a
lot of the same code in our
971:36 - staging tests here. Great. So
now we'll say it works with live
971:42 - chain link keepers and chain
link VRF, we get a random
971:48 - winner, acing function. So this
is going to be our test in here.
971:53 - So in this test, we of course,
we want to enter the raffle. And
971:57 - we shouldn't have to do anything
else except for enter this
972:01 - raffle. Because the chain the
keepers and the only VRF are
972:03 - going to be the ones to actually
kick off this lottery for us,
972:06 - we'll do a quick grabbing of the
starting timestamp to have it
972:10 - before all this kicks off. So
we'll say const starting
972:13 - timestamp equals await raffle
dot get last to me get latest
972:20 - timestamp, get latest timestamp,
we're gonna grab this because
972:23 - later on, we're going to test to
see if the timestamp has indeed
972:26 - moved forward, we want to enter
the lottery, right, we want to
972:29 - run the command we've been
running over here all the time,
972:31 - we want to do you know await
raffle dot enter raffle, but we
972:35 - don't want to call it yet.
Because same as what we did over
972:39 - here, we want to set up our
listener first. Now in here, we
972:43 - probably should have set up our
listener before we entered the
972:46 - raffle. However, we controlled
the blockchain. So putting it in
972:50 - that order was is was okay. But
we want to set up the listener
972:54 - before we enter the raffle just
in case the blockchain moves
972:58 - really fast. And we're going to
set up the listener the exact
973:01 - same way, we did it over here.
So we're gonna say await new
973:05 - promise. And it's going to be an
async function that takes a
973:08 - resolve and a reject. And we're
going to use a little arrow
973:11 - notation here. And in here,
we're going to set up the
973:14 - listener, we're gonna say raffle
dot once, once that winner is
973:18 - picked, we're going to do
another async function using
973:21 - that Arrow.
973:24 - Arrow function syntax, we'll say
console dot log winner picked
973:30 - the event fired. And only once
we get this winner picked, can
973:35 - we start doing our asserts in
here, can we start making sure
973:38 - that there's a winner, there's a
verifiably random winner, it's
973:42 - been picked, the money has been
moved, etc. This is where we'll
973:44 - do our try catch. And if there's
any error, we're just going to
973:49 - automatically reject, we're
going to reject the promise. And
973:52 - if all goes well, of course,
we're going to resolve the
973:56 - promise. So our listener has
been set up here. We haven't
973:58 - added our asserts here. But we
will, let's just go ahead and
974:01 - write the rest of the test. And
then we'll go back and we'll
974:04 - update this listener so so our
listener has been added. And
974:08 - inside here is actually where
we're going to enter the raffle.
974:10 - So inside here, await, raffle
dot enter raffle value is going
974:17 - to be raffle entrance fee. And
really that's it. Right? So
974:23 - we're setting up the listener,
setting up the listener, then
974:26 - entering the raffle. And this
code won't complete until our
974:33 - listener has finished listening
because again, this whole SEC is
974:37 - in a wait. So we're gonna say
okay, cool setup, the listener,
974:40 - wait for this to finish. And
then when it gets here, it goes
974:43 - out okay, this is the end of the
code Are we all done executing
974:46 - Oh, no resolve or reject hasn't
been called yet. And that's
974:50 - because we're still waiting for
the listener to finish
974:52 - listening. Now, once we get this
winner picked event emitted in
974:56 - here, we're going to get that
recent winner so we'll say const
974:59 - recent winner equals await
raffle dot get recent winner
975:05 - will get the raffle state we'll
say const. raffle state equals
975:10 - await raffle dot get raffle
state, we'll get the winners
975:14 - balance. So we'll say const.
Winner balance equals await
975:21 - recent winner. And since we're
only entering with our Deployer
975:25 - we should check to see the
deployers balance at the end and
975:28 - we can't do it right with this
deployer object here. So we'll
975:31 - have to do the player account
equals await ethers dot get
975:38 - signers, no wrap this actually
actually will just say this is
975:43 - accounts here like that. And
then we'll just do a count of
975:46 - zero because it counts as zero
is going to be our Deployer. So
975:49 - our winner balance is going to
be accounts a zero dot get
975:52 - balance. And then we're going to
do const ending timestamp equals
975:57 - a weight raffle dot get latest
To timestamp, and we should also
976:04 - get the starting balance. So
we'll say winner ending balance,
976:08 - we should also get the starting
balance right after we enter. So
976:12 - we'll say const. Winner,
starting balance equals await
976:18 - accounts. Zero dot get balance,
so that now we can do some
976:23 - comparisons. All right, great.
Let's do the comparisons now. So
976:26 - we should first expect the
raffle to be reset. So we can do
976:30 - this a few different ways. Down
here. We did number of players.
976:34 - We can also say, await, expect
raffle dot get player 0.2 dot v
976:43 - dot reverted, right because Get
Player zero should get reverted
976:48 - because there's not even going
to be an object at zero. So
976:50 - that's another way we can check
to see if our players array has
976:53 - been reset. Next, we can do
assert dot equal recent
976:57 - winner.to string, this should
equal our account zero dot
977:04 - address. Okay, our Deployer What
else can we do? We will assert
977:09 - dot equal raffle state to zero.
We want this email to go back to
977:14 - open after we're done. And then
we finally want to make sure
977:17 - that the money has been
transferred correctly. So we'll
977:19 - do assert dot equal, this should
be a winner ending balance. That
977:25 - to string should be equal to
winner starting balance, add
977:34 - raffle entrance fee.to string.
So if we look down here, they
977:38 - enter the raffle we check their
starting balance right after
977:42 - they enter. And they basically
should just get that raffle
977:45 - entrance fee back right because
they are the only ones who have
977:48 - entered this raffle. And then we
can do one more assert, do
977:51 - assert that the ending timestamp
is greater than the starting
977:56 - timestamp. And then we'll of
course, say resolve. So this all
978:00 - goes well, we resolve. If
there's an issue with any of
978:04 - these asserts, we're going to
catch those errors and we're
978:07 - going to reject and this is
going to be false. And this
978:09 - whole test is gonna go ah, there
was an issue, we now have a
978:12 - staging test that looks really
good here. Let's try
978:15 - this out. Let's try our staging
test out from start to finish.
978:23 - So now in order for us to test
this staging test, from end to
978:27 - end, you first going to need to
get our sub ID for the
978:30 - channeling fear F then we're
going to need to deploy our
978:32 - contract using the sub ID, we're
going to need to register the
978:35 - contract with chain link VRF.
And it's somebody we're going to
978:39 - then need to register it with
chain link keepers. And then of
978:42 - course, we're going to run the
staging tests. So let's do it.
978:45 - So first thing we're going to
need to do is what? Get our sub
978:48 - ID for chain link VRF. Okay,
great. So we're going to come
978:51 - over to VRF dot chain dot link.
And we're going to need to
978:54 - create a new subscription. If we
don't have enough rink B eath.
978:58 - Let's we want to head over to
the full blockchain solidity
979:02 - course, here, we're going to
scroll down. And we're going to
979:05 - look for the recommended test
and here, which is ranked v. And
979:08 - we're going to use the faucets
link to get some Rigby link, run
979:11 - Fosses dot chain dot link, let's
switch over from COVID to a
979:15 - cerium. Rigby, we know we're
going to need some link and some
979:18 - eath. So let's just go ahead and
get both. Alright, great now
979:23 - that our transaction has gone
through, let's just double check
979:26 - our wallet here. And it looks
like we do indeed have Ethereum
979:30 - here. And if you don't see the
link, you can head over to link
979:33 - token contracts, Link token
contracts in the chain link
979:35 - documentation. We'll scroll down
to Rigby, we'll grab this
979:39 - contract address import tokens
and we'll paste it in here. Add
979:43 - Custom tokens, import tokens.
Great. Now I can see my eath and
979:48 - my link here, perfect. We have
some eath we have some link,
979:51 - let's head over to V REF
subscription management. And
979:53 - we're going to create a new
subscription. Again, we could
979:56 - totally do this
programmatically, because the
979:58 - user interface here is only
helping us facilitate call
980:02 - contracts to the registration
contract that's completely
980:05 - decentralized and on chain. So
let's go ahead and create
980:07 - subscription will create
subscription will confirm the
980:10 - transaction and Metamask on the
Rinkeby network will do a little
980:14 - bit of wading in great once it's
gone through, you can go ahead
980:17 - and click the add funds button.
I'm going to show you what it
980:20 - looks like if you accidentally
refresh and jump off though. So
980:23 - if you refresh and you go back
to veer off the chain dot link,
980:26 - you should have a new active
subscription. And you'll see
980:29 - this number here. If you click
on it, this is your subscription
980:33 - ID great. So we can actually
take this, come back to our code
980:38 - into our helper Hardhead config.
And we can paste our
980:41 - subscription ID under
subscription ID for our Rinkeby
980:45 - network here. Awesome. Now that
we have a subscription we can
980:49 - see it's not funded with any
link. So we don't have any
980:52 - Oracle gas here. And we don't
have any consumers. Right our
980:55 - consumer is going to be a raffle
or a lottery contract. So let's
980:59 - add some funds first and we
don't need to add A whole lot
981:02 - because we're only going to be
testing once. So let's go just
981:05 - go ahead and add to link here,
this number might change
981:08 - depending on different costs of
the test nets and how much link
981:10 - token there's available. So if
you're actually working on a
981:13 - main net, be sure to head over
Doc's touching that link EVM
981:16 - chains contract addresses, you
can read more about the costs
981:20 - some of these different chains,
so you can figure out exactly
981:22 - how much to put in here. And if
you go to the full blockchain
981:25 - solidity course, Jas, we can
scroll down to Lesson Nine,
981:29 - there's a recommended link
amounts or rinky saving tests
981:33 - for chain link VRF. For now
we're going to put two for
981:35 - keepers, we're going to put
eight, but feel free to refer to
981:37 - here so you know how much to put
in. So let's go ahead and
981:40 - confirm, we're going to approve
adding funds here, go ahead and
981:43 - confirm. And we're now funding
our subscription to so we can
981:47 - pay that Oracle gas to get our
random numbers. Great. And once
981:50 - we're funded, we can close it,
we'll do a little refresh. And
981:53 - we can see the balance is now to
link when we don't have any
981:56 - consumers perfect. So we've got
our sub ID, we funded it. Now
982:01 - let's go ahead and deploy our
contract. And we already know
982:05 - that we should be all good for
deploying our contract, we go to
982:08 - our Dotty and V will need to add
all of those same parameters
982:12 - from our previous projects,
we'll need to shrink the RPC
982:14 - URL, we'll need our private key.
If we want to verify we'll need
982:18 - our ether scan API key. And if
we want to do gas output, we'll
982:22 - need our coin market cap API
key. So let's make sure we have
982:25 - all that. And we'll look at our
deploy script. Once again, just
982:28 - real quick look at our helper
hardcat config just real quick,
982:31 - and it looks like we do indeed
have everything in here. And we
982:34 - should just be able to deploy it
in one command.
982:40 - So we should be able to do yarn,
hard hat or just h h again,
982:44 - ploy, dash dash network Rinkeby.
Let's go try this out. All
982:51 - right, it looks like we've
compiled successfully, we've
982:53 - deployed it successfully. And
we've even verified it, we can
982:57 - go and open it up on Rinku ether
scan. And we can see our code
983:00 - here has been verified. And it's
looking beautiful. We can read
983:04 - from it, which is great. We can
see all these commands here now
983:07 - that it's verified. And if we
look at the Git raffle state, we
983:09 - should indeed see that it's
open, right, and it's going to
983:12 - stay open until somebody ends
the raffle and updates the
983:16 - amount of eath that the contract
actually has. Now that we've
983:19 - deployed a contract using that
sub ID, we need to register the
983:22 - contract with chain link V REF.
And with chain link keepers. So
983:25 - we need to add this consumer
does tell chinley VRF. Hey, this
983:29 - is the contract that you're
looking for now. So we're gonna
983:31 - go back to V REF dot chain dot
link, and we're going to grab
983:34 - this contract address, and we're
going to add it as a consumer,
983:38 - your subscription is ready, you
can now add consumers we're
983:40 - gonna add consumer. And again,
this website is just here to
983:43 - help facilitate us interacting
with the contract. So we're
983:47 - going to approve that user,
we'll go ahead and confirm and
983:49 - the transaction is going
through. While we wait for this
983:52 - to go through, we can go to
keepers dot chain dot link, and
983:56 - do the same thing work with the
user interface to register a new
983:59 - upkeep. So we'll go ahead and
add our email Hardhead free code
984:04 - camp@gmail.com. We'll call this
raffle upkeep. We'll paste our
984:09 - upkeep address in here we have
our admin address, and you can
984:13 - ignore this bit right here. For
gas limit, this is going to be
984:16 - the gas limit of the PErforM
upkeep function. If we did our
984:19 - gas estimator, we could just
check to see how much that
984:22 - perform upkeep costs. But for
now, I'm just going to put
984:25 - 500,000 That's probably
overkill, but that's fine. Check
984:29 - data, we're going to keep blank
because again, our checkup keep
984:32 - doesn't take anything. And then
starting balance, we're going to
984:35 - put as eight. And if you forget
to put a starting balance here,
984:38 - you can always find it later. So
let's go ahead and register,
984:42 - we're gonna get a Metamask pop
up, we're gonna go ahead and hit
984:45 - Confirm. And we can go back to
our VRF and see that it's indeed
984:50 - been added and awesome, we now
have a consumer on our VRF. So
984:53 - now let's just wait for our
keepers to go through upkeep
984:55 - registration requests submitted
successfully on domain net, you
984:59 - might actually have to wait a
little bit for your request to
985:02 - go through, but I'll test that
it should automatically go
985:04 - through. Now if we go back to
keepers dot chain dot link, we
985:08 - should now see we now if we
scroll down to my upkeeps We
985:12 - have a raffle upkeep here and I
have to because I accidentally
985:15 - use the same account that I
tested on, you can ignore the
985:18 - two you'll have one but this is
the one that we just created.
985:21 - And we can actually see what our
balances and then what the
985:24 - minimum balance for this
actually is. So it looks like
985:26 - eight Link was a little bit too
low. So let's go back to Fosses
985:30 - dot chain dot link slash rinky.
Now that we have some more link,
985:35 - we can come back to our raffle
upkeep. And we go ahead and hit
985:38 - add funds. And we'll add just
three. And we'll go ahead and
985:43 - confirm we first need to give
permission to spend. We approved
985:47 - our link transfer now let's
actually transfer the link to
985:50 - the contract and alright funds
added successfully. So now let's
985:53 - do a little refresh. Now we no
longer see that message saying
985:56 - that it's underfunded and we
have our balance and we can see
985:59 - that it's more than the minimum
balance. We have See the history
986:02 - that we just funded this twice.
Once this actually kicks off,
986:05 - we'll see activity type will be
like perform upkeep or something
986:09 - got our sub ID, we've deployed
the contract, we've registered
986:12 - with chain link V REF, we've
registered it with chain link
986:14 - keepers. Now all we need to do
is run the staging tests. Now
986:18 - running our staging test is
essentially going to be the same
986:20 - as us calling this enter script,
right, because all we're doing
986:24 - in our staging test is entering
the lottery. And then we just
986:27 - have a whole bunch of validators
that we're running to make sure
986:29 - that things are doing as we
expect, since our contract is
986:33 - actually verified, what we could
do on Rigby ether scan is we can
986:37 - actually go to this right
contract section of the
986:39 - contract. And we could even
connect our wallets to it. And
986:44 - once this turns from red to
green, after a little refresh,
986:48 - we'll now see that it's green,
it's connected, we can even call
986:51 - functions on this contract
ourself, so we could enter the
986:55 - raffle ourself, we would add,
you know, however much eath to
986:58 - enter the raffle, and that would
kick off the keepers in the VRF,
987:01 - as well. So we could call it via
ether scan, we could obviously
987:03 - call it via our staging tests
here, we could call it via our
987:06 - scripts, we could call it via
the console, there's a ton of
987:09 - ways to actually do this. But
moment of truth here, we're
987:12 - gonna run our staging tests,
which is going to have us enter
987:15 - the lottery, and set up a
listener to make sure that
987:19 - everything works correctly. And
additionally, we'll see on our
987:23 - raffle upkeep history, we'll see
a transaction go through, and
987:26 - then we'll see a transaction on
our chain like VRF as well. Are
987:30 - you ready? I sure am.
987:32 - Let's do this. So we'll do h h,
test, dash dash network, rink B.
987:40 - And that should be all we need
to do. In our state and tests,
987:43 - we probably should have added
some console dot logs in here to
987:46 - tell us hey, to tell us what
steps that we're on with each.
987:49 - But we forgot to. So if you
follow along with the repo
987:52 - associated with this, we've
added the console dot logs in
987:55 - the test there. But all right,
if we go to the ether scan for
987:58 - this contract, we go back to the
rink the ether scan for this, we
988:01 - paste in that address, the first
step that we're doing in this
988:04 - test, of course, while we're
setting up this listener, the
988:08 - first transaction is going to be
entering the raffle that's going
988:11 - to kick everything off. Right.
So if we refresh a little bit on
988:13 - ether scan, we do indeed see
we've entered the raffle. And
988:17 - we've updated the balance of the
raffle. Okay, awesome. So raffle
988:22 - has been entered. Now then what
happens? Well, if the raffle has
988:26 - been entered, if we go to raffle
dot soul, if it's open, if
988:30 - enough time has passed, if
there's players and it has a
988:32 - balance, which we just checked
does, this will get kicked off
988:36 - by the keepers. So if we go to
the keepers, and we do a little
988:39 - refresh here, after a little
bit, we do indeed see checkup
988:43 - key passed and we see a perform
upkeep having gone through
988:46 - great, what does perform upkeep
to well perform upkeep calls the
988:50 - chainlink VRF. So now if we go
over to chainlink, VRF, we do a
988:55 - refresh here, go down to
history, we do indeed see one of
988:59 - the transactions has gone
through we can see the
989:02 - transaction hash, the link
spent, etc. And now if we go
989:05 - back to our tests, we do indeed
see raffle unit tests for friend
989:08 - fulfill random request winner
pick event fired. And this means
989:12 - that we just went through this
entire process of having a
989:16 - perfectly truly decentralized
raffle work on an actual
989:20 - Testament with our integration
tests working correctly.
989:22 - Absolutely massive, huge
congratulations if you've made
989:25 - it this far. And if you just
walk through the integration
989:27 - test with me now bounce over
contract has now been reset to
989:30 - zero because our wallet address
just won the lottery right and
989:33 - got the money back. Now you
might be wondering, Hey, I see
989:36 - the Create raffle function. And
I see enter raffle but I don't
989:40 - see didn't the chain link nodes
just call perform upkeep and
989:43 - fulfill random words, I'll come
no matter how often I refresh, I
989:46 - don't see those transactions
here. Well, those are actually
989:49 - going to be considered internal
transactions fulfill random
989:52 - words, it's actually called
through the VRF coordinator and
989:55 - the VRF coordinator contract
then calls for full randomness.
989:59 - So we can go to internal
transactions. And one of these
990:03 - transactions is going to be the
transaction to the VRF
990:06 - coordinator contract, which
calls our contract. Same thing
990:10 - with perform upkeep. Perform
upkeep, the chain link nodes
990:13 - actually call through the
registry contract and then the
990:16 - registry contract calls perform
upkeep. That's what we see here.
990:19 - And if we go through the
internal transactions, we'll see
990:22 - him there. Now let's look at
this enter raffle as well. And
990:25 - since we've learned about events
and logs, we can actually go to
990:28 - the logs section now. And we can
see our log or event being
990:33 - emitted here we can see the name
raffle, enter, we can see the
990:37 - topic zero which is going to
identify this entire event. And
990:40 - then we also see this number
here which is what which is
990:44 - index topic, one address player
and then there's no data
990:48 - associated with this right
because we only have index
990:50 - parameters which again show up
as topics so this is absolutely
990:54 - phenomenal. Wow, absolutely
massive and we can rerun a unit
991:01 - test Just by hh test in this
will only run our unit tests.
991:06 - And we can see that these are
all passing as well, things are
991:08 - looking fantastic here. And we
have just successfully created a
991:12 - verifiably random, autonomous,
decentralized, raffle and or
991:17 - lottery deployed on the
blockchain, you should be so
991:21 - excited right now. Now, I'm not
going to show you how to push
991:24 - this up to GitHub. However, if
you want to push this up to get
991:26 - up, and again, tweet at me,
tweet at chainlink tweet at Free
991:30 - Code Camp, please feel free to
do so because you just did an
991:33 - amazing job getting this far.
And if you're gonna want to push
991:36 - this up to GitHub, remember,
we're going to want to put a dot
991:38 - Git ignore. In here, we add a
ton of stuff like that VS code
991:42 - artifacts, cash deployments,
known modules, etc. Type chain
991:47 - types, all this stuff, you can
find a sample dot Git ignore, of
991:51 - course, in the GitHub repo
associated with this, this is an
991:54 - advanced project, we did a lot
of really advanced things here.
991:58 - And this is the section of the
course, where I think at this
992:03 - point, you've got most of the
fundamentals down. And now we're
992:06 - going to move into more front
end. And we're going to move
992:08 - into more industry specific and
more advanced topics that are
992:11 - really going to supercharge you
and make you one of the masters
992:15 - of the blockchain in the smart
contract realm. So huge
992:17 - congratulations, one more time,
definitely go celebrate,
992:20 - definitely go for that walk,
take a quick break, let
992:22 - everything we just learned
settling your brain and get
992:25 - ready for the next one.
992:39 - Alright, now we're gonna go over
the TypeScript edition of this
992:43 - lesson, we're gonna go a little
bit quickly here, because we're
992:46 - not learning too much new stuff
for this TypeScript edition. So
992:49 - if you want to just follow
along, you can open up the repo
992:51 - here and use the TypeScript
branch. One thing to note that
992:55 - is a little bit different is
when we do our promise in our
992:58 - tests, we're doing a weight
promise void, because we're not
993:01 - going to be returning anything
with our promise here. But the
993:04 - rest is going to be exactly the
same. We're going to have a hard
993:07 - hat dot config to TypeScript
that's going to use imports.
993:10 - Once again, everything else is
pretty much the same. We're
993:13 - going to export the config like
we did last time. In our package
993:17 - dot JSON. Of course, we're going
to have all of our TypeScript
993:20 - dependencies as well. And then
our deploy scripts are going to
993:23 - follow that same functionality
that we've used before. So now
993:26 - our deploy scripts use a type
deploy function on our variables
993:30 - that we export at the bottom.
And we also import the hard hat
993:34 - runtime environment type, which
where we pull the deployments
993:37 - get named account and networks
from in our tests. Of course,
993:40 - we're still importing the types
of these contracts from type
993:44 - chain slash types, like you see
here, like for example, raffle
993:47 - is going to be signed to raffle
VRF coordinator V to mock is
993:51 - going to be signed to type VRF
coordinator V to MK and if we
993:54 - wanted to deploy with these
contract factories, we could as
993:57 - well. So those are going to be
the main differences with
993:59 - TypeScript. There's not anything
really new there. But again, if
994:02 - you want to follow along with
TypeScript, and you want to code
994:04 - everything in TypeScript, and
example is here for you
994:10 - All right, welcome back. I hope
your break was absolutely
994:13 - fantastic because now we are
getting into more advanced full
994:18 - stack slash front end
development. We've done the back
994:21 - end development, we've created
smart contracts, we created our
994:24 - lottery. In our last section, we
have all this wonderful code
994:28 - that allows us to work with our
own provably decentralized
994:32 - lottery. In order for regular
everyday people to use our
994:35 - lottery, we're going to need to
build a front end. Now
994:39 - previously, we learned to build
a front end with raw HTML
994:42 - JavaScript, with our Funmi
project, we created a front end
994:46 - with just pure HTML and
JavaScript, just creating
994:49 - applications with HTML and
JavaScript is great. And if
994:51 - that's what you want to do, you
absolutely can. But doing it
994:55 - with those vanilla protocols has
some limitations. And working
994:58 - with a framework, like what
we're going to be working with
995:00 - in this section is going to make
our lives a lot easier, we're
995:04 - going to be able to develop
quicker, have more
995:06 - functionality, and do more in
less time. As you remember back
995:10 - to the project wasn't really a
fleshed out project, if you
995:13 - remember, it was just a bunch of
buttons. And that was really it.
995:16 - So working with a framework is
really going to enable us to put
995:19 - more features and add more
styling to our applications
995:23 - really easy. Once again, the
code for this entire section is
995:27 - located in our lesson and is
located in this GitHub
995:30 - repository associated with the
course. Now I have to put an
995:33 - asterisk here, as I've said many
times, the front end sections of
995:36 - this course are not required,
we're not going to learn
995:39 - anything new about the back end
in this front end section. So if
995:43 - you don't care about building
websites, all you want to do is
995:45 - learn the smart contract aspect
of this course, you can skip
995:49 - these sections. But if you do
want to learn how to build these
995:51 - front end applications, if you
do want to give users and non
995:55 - developers the abilities to
interact with our smart
995:57 - contracts, then please continue
to watch. Now I also have to put
996:00 - an asterix here, because if you
haven't worked with some of
996:03 - these frameworks before, the
learning curve can seem a little
996:06 - bit steep. And as I've said many
times, this isn't going to be a
996:09 - front end course that would take
several more hours than what we
996:12 - want to do for this video. So if
you've never done front end
996:14 - before, this is one of the
sections where I do recommend
996:18 - you follow along with one of
these optional sub lessons,
996:21 - we're not going to play them
here. But if you follow along
996:23 - with one of these sub lessons,
that will definitely be
996:25 - incredibly helpful. One of the
videos that I have for the sub
996:28 - lessons is this video right
here, how to connect your smart
996:31 - contracts to Metamask. And it
shows a number of ways
996:35 - connecting your smart contracts
and building kind of these these
996:37 - front ends. It does start with a
raw HTML and JavaScript edition.
996:41 - So you can really get some more
practice in here with HTML and
996:44 - JavaScript. And then it moves to
index js ethers and a few other
996:47 - next Jas based applications.
Doing it a few different ways
996:50 - will install a new some more
insight on what you should be
996:53 - thinking about when you're
approaching these. So this is
996:56 - absolutely a video to watch if
you're new to front end
996:59 - development. Additionally, for
this section, like I said, we're
997:01 - going to be using a framework.
And in particular, we're going
997:03 - to be using the next Jas
framework. Now. Next, Jas is a
997:07 - react based framework. React is
a framework for building front
997:11 - end and full stack applications.
Next, Jas is a framework on top
997:14 - of the React framework. So if
you already know react, most of
997:17 - this is going to come very
naturally to the reason that
997:20 - we're using React in next Jas is
because React is easily as of
997:24 - right now one of the most
popular frameworks and languages
997:27 - out there. And it's no surprise
why we've got a little article
997:30 - in the GitHub repo titled Why
you should use React js for web
997:33 - development, which we'll go into
a little bit more. Some of the
997:36 - biggest applications like
Facebook and Instagram use React
997:38 - js and a number of other Fortune
500 companies and React js
997:42 - especially in the blockchain
space is easily the most popular
997:46 - with protocols like uniswap, and
Avi also using React Jas. Now
997:49 - the reason we're using this next
Jas on top of React Jas is that
997:53 - next Jas, I think makes working
with react much easier. And I
997:58 - want us to work with the easiest
and most powerful framework out
998:01 - there. Next, Jas is also getting
a ton of steam has some really
998:04 - advanced but in my mind easier
to use features than just raw
998:09 - react. Now, like I said, if
you've never worked with React
998:11 - before, if you've never worked
with next Jas before, and you
998:14 - want to do a little brush up,
definitely watch my video six
998:16 - ways to connect your depth to a
wallet. And if you find yourself
998:19 - struggling with with this
section, because the front end
998:21 - stuff doesn't really make sense.
We also have a next Jas crash
998:25 - course in the GitHub repo
associated with this course.
998:28 - It's about an hour long and it
is absolutely phenomenal. Free
998:30 - Code Camp also has some next Jas
crash courses. So if you're
998:34 - struggling with the front of it,
go take it next Jas course, and
998:37 - then come back to this section
or skip the front end sections
998:40 - all together, do the rest of the
course of just the back end, and
998:42 - then come back and do these
front end sections. We're going
998:45 - to show you the cutting edge
ways to interact and work with
998:48 - your front end and then also
deploy them. And if you follow
998:51 - along correctly, by the end of
this, you'll have a website
998:53 - deployed that you can show off
and you can send a link of it to
998:56 - your friends. And now I know we
already showed you what this
998:59 - looks like but I'm going to show
you it one more time just so we
999:01 - can walk through and see exactly
what we're doing. So we're going
999:04 - to have this decentralized
lottery where we can go ahead
999:07 - with can connect our wallet if
not already connected. And we
999:10 - can switch, we can switch around
between networks. And our app
999:13 - will actually recognize it and
say, hey, the only supported
999:16 - chains that we're working with
here are going to be 31337,
999:20 - which is localhost, or four,
which is ring feed. And we'll
999:23 - learn how to add this validation
into our application so that our
999:26 - app only works when we're on a
chain that we want, then we can
999:30 - go ahead and interact with it.
Normally, we can click a button
999:33 - Metamask will pop up, we can go
ahead and confirm we'll get a
999:36 - little transaction notification
saying that transaction is
999:39 - complete. And we'll get our
front end updated. And then on
999:43 - the back end, we'll be able to
see the chain link nodes and the
999:46 - Chinuch V REF do their work. And
once they actually pick a
999:49 - winner, after a refresh, we'll
be able to see that the back end
999:52 - node was updated, we do indeed
have a previous winner. Awesome.
999:56 - Now, not only that, we're going
to show you how to build this,
999:59 - but also, we're going to show
you how to host it on an actual
1000:04 - site. So you'll be able to push
it up to your own blockchain.
1000:07 - And additionally, we're gonna
host it in a decentralized
1000:11 - context. So this site that we
have here is it's going to be
1000:14 - hosted on a technology that
allows us to host websites in
1000:18 - decentralized contexts as well
swore backends. And even our
1000:21 - front ends can be hosted in
decentralized context. So So I
1000:25 - hope you're incredibly excited
for this because we're going to
1000:27 - be showing you the cutting edge
tools that many of the top
1000:31 - blockchain projects use. And
let's just jump right into it.
1000:37 - Now, I'm currently in the
Hardhead smart contract lottery
1000:40 - project, the project that we
just did, we did this hard hat
1000:43 - smart contract lottery, which is
great. What we're going to do
1000:45 - now is we're going to create a
new folder, although we are
1000:48 - going to be coming back to this
folder from time to time to make
1000:51 - a couple of updates. So if you
want to keep it open, you
1000:53 - absolutely can. But for me, I'm
gonna go ahead and CD download
1000:56 - directory to kind of my main
directory for this whole course.
1001:00 - And we're going to create a new
directory called next Jas. smart
1001:05 - contract. Lottery, FCC, then
we're going to cd into next Jas
1001:11 - smart contract lottery FCC, and
go ahead and hit code period.
1001:15 - And like I said, if you want to
keep that one up and have this
1001:17 - new folder up, you absolutely
can. But basically, again, we're
1001:21 - just opening up our VS code in
this next Jas smart contract
1001:24 - lottery folder. Now for this
front end stuff, in particular,
1001:27 - if you want to be absolutely
sure you're using the same
1001:30 - versions as I am, what you can
do is you can git clone this
1001:33 - repo, and then copy the yarn dot
lock and package dot JSON, and
1001:37 - then run yarn, this will make
sure you're always using the
1001:40 - exact same packages that I'm
using, and you'll never run into
1001:43 - any weird issues. So if you do
run into an issue, one of the
1001:46 - first things to do, especially
for these front end parts is to
1001:49 - go back, make sure you have the
exact same yarn dot lock and
1001:53 - package that JSON that I do in
my examples here, and go from
1001:56 - there. Now we're here in our
front end project. And we're
1001:59 - going to create a website, we're
gonna create a front end for
1002:02 - application, like I said, we're
gonna be using next Jas, if you
1002:05 - want to follow along with the
next Jas documentation here,
1002:08 - they do have a great getting
started and walking through
1002:10 - this. So for us, we're going to
do yarn, create next app, and
1002:17 - then put a little period saying
we want our next app in this
1002:19 - directory. If you don't put this
period, it'll create it in a new
1002:22 - folder, and you'll have double
folders. Okay, awesome. So and
1002:26 - once we do this, in our little
files explorer section, we now
1002:29 - can see all the different files
that come boilerplate with this.
1002:34 - Now, let me just do a quick
walkthrough of what's going on
1002:36 - here. Again, we also go through
this in those two videos that I
1002:39 - recommended, but it doesn't hurt
to go over it twice. So node
1002:42 - modules, of course, is going to
be the package in the
1002:44 - installations pages is going to
be the different pages on our
1002:47 - site. Let me let me show you
what I mean by this. To run this
1002:50 - whole thing. Actually, we can
just run yarn, run Dev, and
1002:54 - we'll get started server on
blah, blah, blah, blah, blah,
1002:58 - you can command click it or copy
paste it into your browser. And
1003:01 - now you'll see on localhost
3000, we have our page up here.
1003:05 - Now what we can do, actually, so
index.js is going to be our
1003:09 - default page, which is, you
know, considered this slash
1003:12 - here. But what we can do is we
can create new pages. So I could
1003:16 - do new file, you know, dog dot
Jas. And then you know, just
1003:21 - copy paste index into dog to
Jas, paste it, delete everything
1003:25 - inside the div, you don't have
to follow along here and just go
1003:27 - Hi, save this, go back here. I
can now put in dog and get this.
1003:34 - So pages is going to be all kind
of these different routes to
1003:37 - these different spots on our
website. And index is going to
1003:40 - be our default, kind of like our
homepage. So I'm going to delete
1003:44 - Dardo. And inside these files is
going to be something called
1003:47 - react syntax or JSX. They come
as Jas but they're basically
1003:51 - reacts in text. Next, Jas is
based on React, you'll see these
1003:54 - pages are this weird combination
of both JavaScript and HTML. We
1003:59 - see some import stuff at this at
the top, which reminds us of
1004:02 - JavaScript and again, you'll see
some important stuff at the top
1004:06 - and then down here, you'll See,
like div head main h1 P, you'll
1004:11 - see all these like HTML tags
react index js allow us to do
1004:15 - this combination of JavaScript
and HTML. And it actually makes
1004:20 - life a lot easier. Now, you'll
also notice we're doing imports
1004:24 - in here. Remember, I told you
all this earlier, imports work
1004:27 - with our front end require does
not. So that's some of the
1004:31 - difference between node does not
equal JavaScript, right? This is
1004:35 - where the differences can start
getting a little bit confusing.
1004:37 - But the way that I usually like
to think about it is I just say,
1004:40 - no JS, excuse me, I'll just say
back end. I can J S is a little
1004:45 - different from front end. Yes.
So back end, Jas and front end
1004:49 - Jas are a little bit different.
That's kind of the way I like to
1004:51 - think about it. app.js is going
to be our entry point for
1004:54 - everything the way react and
next Jas work is everything is
1004:58 - what's called component based in
all of our files here, you're
1005:01 - gonna see this export default
function home or something along
1005:05 - those lines. What react and next
Jas do is they say, Hey, this
1005:10 - huge clump of HTML stuff that
has a hodgepodge of JavaScript
1005:15 - inside of it is considered a
component. And so all of our
1005:19 - pages get wrapped through this
underscore app.js page. So this
1005:24 - is a page but it's kind of like
the main entry point. And they
1005:27 - get stuck into this component
section of our app that Jas so
1005:31 - you can think of this on this
graph. The GS is kind of the
1005:34 - whole application or whole front
end. And on this homepage, this
1005:38 - component, we're sticking index
dot j s right in here, we're
1005:41 - swapping out component for index
dot J. S. Now API is what we
1005:44 - wanted to do if we wanted to do
like some HTTP, GET HTTP POST
1005:50 - requests, but we're not going to
do any of that. So we're going
1005:52 - to pretty much ignore API for
now public is just going to be
1005:56 - some public images like a
favicon or Versaille, that SVG
1006:00 - styles is going to be the CSS
for our project. CSS stands for
1006:05 - Cascading Style Sheets. And it's
basically a way to style your
1006:08 - HTML, we're going to change the
way we do styling and a little
1006:11 - bit, but that's basically what
these both do the ESLint I'm
1006:14 - dumping this right now we have
our dot Git ignore which we know
1006:17 - what it does. We have our next
dot config dot J. S. This is a
1006:21 - configuration file or next. Jas,
of course, we have our package
1006:24 - json, we have a readme, and we
have our yarn dot lock. So most
1006:28 - of what we're going to do is
actually going to be inside this
1006:31 - Pages folder. And we're also
going to create a couple other
1006:34 - folders that are going to be our
main stuff now, because I'm me,
1006:37 - and like I said, I love working
with prettier, I'm going to
1006:39 - automatically dump a prettier
RC, and a prettier ignore in
1006:43 - here, just so that I can format
my code a little bit nicer, you
1006:46 - can grab your prettier RC from
our last projects, you can grab
1006:49 - your prettier ignore as well. Or
you can just pause me right now
1006:53 - copy, paste them from the GitHub
repo associated with this
1006:55 - lesson, paste them in, and then
we'll do yarn, add dash dash
1006:59 - Dev, prettier, so that we can
auto format all of our code for
1007:02 - come back over to here, we can
save and boom, stuff gets auto
1007:06 - formatted. Now, again, we're
going to be using the multi
1007:08 - terminal feature. So right now I
have one running my front end.
1007:11 - So if I come back to the front
end, I hit refresh. It's still
1007:14 - running. And then I have one to
do, you know my scripts and
1007:16 - stuff. We have yarn run dev
running right now. And if we go
1007:19 - to our package, JSON, running
yarn, run dev just runs next
1007:23 - Dev. And actually, let me cancel
it and just do yarn dev yarn is
1007:27 - actually smart enough that don't
need to do run Dev, but it just
1007:30 - runs next Dev. And this next
command comes built in once we
1007:34 - installed next, which we did
when we did yarn create next
1007:37 - app. So next Jas comes with
these scripts already built in
1007:40 - for us, we want to build our
front end to enable people to
1007:45 - interact with our lottery in a
fair way, and connect with the
1007:48 - smart contract that's running.
Let's create some simple front
1007:51 - end pieces for this. So first
thing we're gonna do is we're
1007:53 - gonna go to Pages, and we're
going to go to index.js. All
1007:56 - this stuff in here is cute and
nice. And thank you next, Jas,
1008:00 - but we're going to delete it all
and delete everything except for
1008:03 - that headpiece, we're gonna
leave that up, we're just going
1008:05 - to change the name. But this way
down here, we're going to change
1008:08 - the name from Crate next app to
smart contract lottery or raffle
1008:15 - or whatever we want to do.
description will be our smart
1008:19 - contract, lottery. And then
right below the head, we're
1008:23 - going to write hello, blue, and
save. And if we look at our
1008:28 - front end, we now see that it
says smart contract lottery and
1008:31 - the top and I'm going to move
this all the way over here,
1008:33 - smart contract lottery and the
top and we see Hello, so smart
1008:37 - contract lottery. Hello, the
description here, we're not
1008:39 - going to see this is going to be
something that web scrapers and
1008:41 - stuff we're going to find.
1008:45 - Now one of the first things that
we're going to need to do is
1008:48 - we're going to need to create
that connect button. We've done
1008:50 - this in the past with raw
JavaScript, but now we're going
1008:53 - to do it with next js and react.
The one that we made previously
1008:57 - was pretty minimalistic. In
fact, we bring it back up it
1009:00 - checked to see if there was
windows that Aetherium and then
1009:03 - went and requested and connected
and said okay, cool. You're
1009:06 - connected. Now what did didn't
do was a lot of things that we
1009:09 - would want an application to do.
When we change networks, our
1009:13 - application didn't detect that
when we change users or
1009:15 - application didn't detect that
it was really stringent in the
1009:19 - functionality that it actually
had for connecting to a wallet.
1009:22 - So we're going to make our
wallet connect button,
1009:25 - incredibly powerful, so that you
can connect with the button, you
1009:28 - can switch networks, you can
switch accounts, you can pretty
1009:30 - much do anything in our
application will know our
1009:33 - application will be responsive.
So that's gonna be one of the
1009:36 - first things that we're going to
do, we're going to create a
1009:38 - header and connect button nav
bar one a little navbar here,
1009:42 - saying, hey, you know, you can
connect with this button. So
1009:45 - that's gonna be the first thing
that we're going to do. Now we
1009:47 - can build our whole connect
button in this index dot j s and
1009:50 - stick it in here. But instead,
what we're going to do is we're
1009:52 - going to make it a what's called
a component. So we're going to
1009:55 - create a new folder called
components. And we're going to
1009:59 - create a new file in here called
header.js. And you might also
1010:03 - see a lot of people do
header.js x.js and.js x do
1010:08 - literally the exact same thing,
you can do either one, I'm going
1010:11 - to do dot JSX, just to remind me
that this is a React file that
1010:16 - we're creating. This is a
component that we're creating.
1010:18 - But yeah, you can do J S JSX. If
you want to learn a little bit
1010:21 - more about components, we've got
a link to learning about
1010:24 - components. They're basically
independent and reusable bits of
1010:27 - code. They serve the same
purpose as JavaScript functions,
1010:30 - but work in isolation and return
HTML. So basically, we're going
1010:33 - to create like a little chunk of
HTML that we're going to export
1010:37 - into our index such as like what
we've done in the past, this
1010:40 - just helps modularize and reuse
this header component, you know,
1010:43 - across our project. Now, we're
only going to be using our
1010:46 - header in one area. However,
it's still nice to modularize
1010:49 - the project regardless. And to
get start, this is going to be
1010:52 - what's called a functional base
component. So we're going to
1010:55 - create basically a function
called home write really pretty
1010:59 - much exactly like what we see in
JavaScript, except it's going to
1011:02 - return some HTML. So we can do
like a little div. And my VS
1011:09 - code auto created the closing
div here. And in here, I'm going
1011:12 - to be like hi from header. This
is going to be a real
1011:15 - minimalistic component like this
is a valid component here. Now
1011:19 - we have this function that
returns HTML. And to give other
1011:23 - applications, the ability to use
this component will do export
1011:27 - default function home. And then
in our index.js, we can import
1011:32 - it with imports. Home actually,
excuse me, I'm not going to call
1011:36 - it home, we're going to call it
header, header, excuse me,
1011:39 - export default function header,
and then import header from the
1011:44 - down directory components slash
header, like so. So now we've
1011:49 - imported our header in index
such as if we go back to our
1011:53 - front end, which is still
running, we don't see it in
1011:56 - here, right? Remember,
everything goes through our app.
1011:59 - And when we're on the slash
page, that's going to go to our
1012:03 - index.js. index js is importing
our header, but it's not
1012:08 - returning our header, right, we
see. And here, we see it
1012:11 - returns. And this is the HTML
that it's returning. And as you
1012:15 - can see, there's clearly no
header in here. So now that
1012:17 - we've imported our header, we
need to actually add our header
1012:20 - in here. So we'll do header, and
then adds the closing tag right
1012:24 - here. If you don't add any
stuff, you know, in between two
1012:27 - tags, you can go ahead and just
do this one liner here, with a
1012:30 - backslash at the end saying,
Hey, this is an open and closed
1012:34 - tag here. Now that we've
imported it, what do you think
1012:36 - we'll see on the front end, now
that we've added it to our index
1012:39 - js, you're right, we see hi from
header, because we added our
1012:43 - header here. And then we see
Hello. So high from header,
1012:47 - hello, boom. Now, anything that
we do, obviously now in our
1012:51 - header.js, will see reflected on
our front end. So we can do hi
1012:55 - from header, blah, blah, blah,
you know, just a bunch of
1012:58 - dribbles, and we'll see it on
our front end. So this is going
1013:00 - to be our section where we're
going to make our header or a
1013:03 - navbar or all the functionality
for the Connect button. Now I'm
1013:05 - going to tell you something, and
some of you are going to love
1013:07 - this summer, you're going to
hate this. I'm going to show
1013:09 - you. I'm going to show you the
hard way first, then the easy
1013:13 - way. Why am I going to show you
the hard way first? Well,
1013:16 - because I want you to become
familiar with what's actually
1013:18 - going on behind the scenes and
what's actually going on with
1013:21 - some of these components because
it is really helpful when
1013:23 - building these front ends to
understand, Okay, here's what's
1013:26 - going on. If you don't
understand what's going on
1013:28 - behind the scenes, you're gonna
go to try to build more advanced
1013:30 - applications, and you're gonna
have no idea what to do because
1013:33 - you've just learned the
shortcut. I like to think of it
1013:35 - as like calculus, like we're
going to learn how to calculate
1013:38 - a derivative first, and then
we're going to learn the
1013:40 - shortcut to quickly getting
derivatives. So don't skip this
1013:44 - part, because this is going to
help you well and beyond down
1013:47 - the line. Okay, we're going to
learn this the harder way to set
1013:51 - everything up in our HTML Funmi.
We just use raw ethers to kind
1013:55 - of do everything and you
absolutely can use raw ethers to
1013:58 - do everything. However, there
are some packages especially for
1014:01 - React that make life developing
a front end substantially better
1014:05 - and in our full blockchain
solidity course, Jas. We have a
1014:08 - number of other packages that
you can use will stack
1014:11 - development and other libraries.
And if you watch this six ways
1014:13 - to connect your depth to a
wallet, you'll actually
1014:15 - understand some of the
differences. So if you haven't
1014:18 - watched that video, go back,
watch that video. But there's a
1014:21 - whole bunch of libraries that we
can use that are going to make
1014:24 - our lives a lot easier. We've
listed some of them here. React
1014:27 - Morales is the one that we're
going to be using today, they
1014:30 - have some additional plugins,
and they have probably my
1014:32 - favorite thing on the planet,
which I'm going to show you how
1014:34 - to do very soon. But these are
also open source, Ross also
1014:38 - comes with some optional
functionality to hook into your
1014:41 - own back end to give your app
even more features and even more
1014:44 - functionality. And that's the
other reason that we're doing
1014:46 - it. So and we're gonna go over
that later. And if you want to
1014:49 - use pure ethers, you absolutely
still can. A lot of these
1014:52 - packages that we're using do
rely on ethers, but we're not
1014:55 - going to use just ether. So we
go to the React Morales page.
1014:58 - And to get started, we can just
do this bit right here. So we're
1015:02 - literally going to copy this and
bring it into our project. And
1015:05 - if you go to our package that
JSON, we actually already have
1015:08 - react and react DOM. So we can
just do yarn, add Morales, and
1015:13 - react oralis. Now you'll notice
I'm not doing these as dev
1015:19 - dependencies, I didn't do yarn,
add dash dash dev here. The
1015:23 - reason is, because for our
production builds, when we
1015:26 - actually create the website
here, you will need Morales and
1015:29 - you will need react Morales we
don't need prettier to create a
1015:33 - website prettier is a tool that
we're using as developers. So in
1015:37 - all of our projects, so far,
we've been using just dev
1015:40 - dependencies. That's because
we've only been building our
1015:43 - projects for developers, our
GitHub repos, they haven't been
1015:47 - made to build a website, they've
only been to do things on the
1015:50 - back end, for our website, we're
actually going to be building a
1015:53 - front end. So we need to put
this in the dependencies
1015:56 - section, because we need to say,
Hey, these are the ones that we
1015:59 - need to bundle up together for
the front end, and you can
1016:02 - ignore these ones. And if it's
just like a tool to make our
1016:05 - lives better, it's gonna go in
dev dependencies. So we're
1016:07 - adding Morales and react
Morales. And a lot of the syntax
1016:11 - that we're going to do for our
header is actually going to be
1016:13 - really similar to what we've
been seeing so far. So let's do
1016:16 - this. And then actually, we're
just going to change this name
1016:18 - to manual header, manual header
update imports for manual
1016:21 - header, you can go ahead and hit
yes to man you all header here,
1016:25 - we're gonna copy manual header,
make sure it's in our index.js
1016:29 - it we're gonna change header to
manual header, and we're gonna
1016:31 - change how to manual header
here. And the reason we're doing
1016:34 - this is because like I said,
we're going to create a much
1016:36 - simpler header after we create
this kind of harder one. And
1016:40 - we're going to want to create
that connect button, which
1016:42 - again, we made in HTML Funmi. By
calling eath request accounts,
1016:46 - what we can do actually with
Morales is we can just do this
1016:49 - thing called Enable Web three.
So at the top, we're going to
1016:53 - import, use mirallas.
1016:57 - From react ralis. And if you go
to the React Morales page here
1017:03 - or to their GitHub, you'll learn
how to set all this up too and
1017:06 - learn more about the
documentation. So we're going to
1017:08 - import use Morales from react
Morales, and inside our function
1017:11 - here, but outside of our return,
we're going to say const, Enable
1017:17 - Web three equals use mirallas.
Now use Morales is what's known
1017:23 - as a hook as a React hook. And
it's a way to keep track of
1017:27 - state in our application. Now,
in order to use mirallas, our
1017:30 - entire application needs to be
wrapped around what's called a
1017:33 - Morales provider, which is going
to be a context provider for us.
1017:37 - And I'll explain what that means
in a minute. But basically, what
1017:39 - we need to do is we need to add
this Morales provider to our
1017:43 - app.js. So in here, we're going
to import oralis provider from
1017:50 - react oralis. And we're going to
wrap our entire app around this
1017:55 - Morales provided so we're going
to do some little parentheses
1017:58 - here. New Line, we're going to
paste morass provider like this,
1018:04 - it's going to give us the
closing tag, copy it, paste it
1018:07 - like this and save. And then in
here, we're going to write in
1018:12 - the sheet allies on Mount equals
false. This initialize on Mount
1018:19 - piece here is the optionality to
hook into a server to add some
1018:23 - more features to our website. We
don't want to hook into a server
1018:26 - for this application, we want
everything just to be open
1018:28 - source, and we don't need any of
this additional functionality.
1018:30 - So we're just going to do
initialize on Mount equals
1018:33 - false. Now that the whole thing
is wrapped in this Morales
1018:35 - provider, we go to the front end
we should be able to refresh
1018:38 - everything looks pretty much the
same. And we can start using
1018:41 - these hooks. Now this use
Morales is what's known as a
1018:47 - hook and hooks can be a little
bit confusing to understand at
1018:51 - first glance, but they're
incredibly powerful and they are
1018:55 - the de facto way for us to build
react projects. And if you're
1018:58 - familiar with class components,
we're not gonna be using class
1019:01 - components because hooks are
much better hooks allow function
1019:04 - components to have access to
state and other react feature
1019:07 - ers state being probably one of
the biggest ones and the most
1019:10 - popular ones, we want our
application to be different if
1019:13 - we're connected to Metamask,
versus if we're not, right, if
1019:16 - we go back, if we go back to our
example website here, right, if
1019:20 - we're not connected, we want to
say, Please connect to a wallet.
1019:23 - And then when we are connected,
we want to go ahead and be
1019:25 - connected. If I have, let's say,
I have some variable like, and I
1019:28 - don't have this hook here, I
have like, let connected equals
1019:32 - false, right, or enable Web
three, or is web three enabled,
1019:35 - let's say I've led connected
equals false. And then I have,
1019:38 - you know, let's say have some
button that connects us and
1019:41 - changes connected to be true,
changing connected to be true is
1019:47 - great and all but it won't
rerender our application, you
1019:51 - see, when I disconnect and I
reconnect here, our application
1019:54 - actually changes based off of
whether or not we're connected.
1019:57 - And this is what we want, we
want our front end to rerender.
1020:01 - When we're connected, if I just
use a variable like this inside
1020:04 - of our component, our front end
isn't going to rerender. Or even
1020:08 - worse, if I use it outside, our
component doesn't even know
1020:12 - anything about this changing. So
hooks are a way for us to
1020:15 - actually work with state
especially and automatically
1020:19 - rerender when something changes
and enable Web three is going to
1020:22 - be a function that we get from
this use Morales hook to do
1020:25 - that. So for a lot of our
components, instead of just
1020:28 - saying like, let web three
enabled equals true, like we did
1020:32 - in normal JavaScript, we're
going to be doing a lot of this,
1020:35 - these hooks. For the most part,
we usually want our website to
1020:38 - change based off of if some
variable has changed and enabled
1020:42 - web three is a function that we
get from this hook that says,
1020:46 - Okay, go ahead and connect
Enable Web three is basically
1020:48 - the equivalent of saying try
await Aetherium dot request,
1020:52 - like this. Now enable Web three,
the way we're going to use it
1020:55 - here only works on Metamask. But
we will show you how to get this
1020:58 - kind of this cool little module
up where we can choose between
1021:01 - different ways to connect our
app.
1021:05 - We have our enabled web three,
let's go ahead and create a
1021:08 - button, that's going to do the
same as what we did in our HTML
1021:12 - Funmi in our return, but here,
instead of hi friend header,
1021:15 - we're going to add a new
component, or we're going to add
1021:17 - a new tag, we're gonna add the
button tag, and for me it
1021:20 - automatically close to, and I'm
just gonna call it connect, I'm
1021:24 - gonna go ahead and save. Now we
see a little button that says
1021:26 - connect. And obviously, it
doesn't do anything, we're gonna
1021:28 - give this some functionality,
we're gonna say on click now
1021:32 - since again, this is a JSX
component. This isn't raw HTML,
1021:37 - in raw HTML, we can't just kind
of stick JavaScript wherever we
1021:41 - want. But in JSX files, we can
stick JavaScript kind of
1021:45 - wherever we want. So inside of
this, inside of this block of
1021:49 - HTML, we can actually stick
JavaScript in here by adding
1021:52 - these little brackets. So adding
these little brackets in our
1021:55 - jobs can return. But here, we
can add JavaScript. And what we
1021:58 - want to do is we want to have
our On Click Call Enable Web
1022:02 - three, we're going to call an
async function, we're going to
1022:06 - use the arrow syntax here, one
click, we're gonna call this
1022:08 - async function, which is just
going to be await, Enable Web
1022:12 - three, await Enable Web three,
let's add the little parentheses
1022:16 - here. And essentially, with just
this, we've done pretty much
1022:19 - everything that we had back in
this big connect function here.
1022:23 - Now if we go back to our front
end, do a little refresh, we can
1022:26 - see that right now, we can see
that I'm actually connected, I'm
1022:28 - gonna go ahead and disconnect.
I'm still connected from some of
1022:31 - the last applications I was
doing, we can hit Connect, and
1022:34 - now we see metamath does indeed
pop up, we'll hit Next connect,
1022:38 - and boom. And that's all we need
to do. Now, if we look at our
1022:40 - Metamask, it says connected.
Great. Okay, cool. So now we
1022:43 - have a way to actually connect
here, let's add some
1022:46 - functionality and make our
application smart enough to have
1022:48 - the connect button if we're
connected. And if we're not
1022:51 - connected, not have that button.
So what we'll do now is use
1022:54 - Morales comes with another hook
called is web three, enabled,
1022:58 - which is just a variable part of
our hook that keeps track of
1023:01 - whether or not our Metamask is
connected. But we can actually
1023:04 - do one better, we can actually
check to see if there's an
1023:08 - account because maybe web three
is connected. But but they
1023:11 - didn't connect it to an account.
So let's go ahead and we'll
1023:15 - import count from us. Morales
will check to see if there's an
1023:19 - account. So what we'll do is
inside of our div tags, we'll do
1023:22 - a little JavaScript, we'll do
that ternary operator again,
1023:25 - we'll put a count here with a
question mark. And we'll do that
1023:28 - that same syntax that we've seen
before, we'll say account, if
1023:32 - account exists, do this. If
there's no account, do this. And
1023:35 - if there's no account, we want
to add this Connect button. So
1023:39 - we'll go ahead and we'll stick
this in here. If there is an
1023:42 - account, we'll just show that
account, right. So we'll do div
1023:45 - backslash div in here, we'll
just say connected, like that.
1023:50 - Now if we go back to our front
end, we see connected. If we do
1023:53 - a little refresh, it'll go away.
So we'll we'll re hit Connect,
1023:57 - and now we're connected, which
is great. Let's make it even
1024:00 - smarter. We'll have it show our
account here. So instead of just
1024:04 - saying connected, we'll say
connected to I'll put some
1024:08 - JavaScript, we'll put some
JavaScript inside of our
1024:10 - JavaScript. But since this is
that HTML stuff, we got to use
1024:14 - these brackets to say JavaScript
again. So we'll put JavaScript
1024:17 - inside of the JavaScript, we'll
say connected to, we can just
1024:20 - say account. Now go back to our
front end, we see connected to
1024:23 - blah, blah, blah, blah, blah,
you'll notice if you hit
1024:25 - refresh, you'll have to
reconnect, we'll get to that in
1024:28 - a minute, what a lot of people
do is they'll do a count dot
1024:30 - slice, zero, comma six. And then
outside of the brackets, they'll
1024:35 - do dot that dot, another set of
brackets account, that slice,
1024:42 - count dot length minus four,
close that off like that, we
1024:46 - have our account, when we hit
Connect, now it says connected
1024:49 - to blah, blah, blah, hello. And
because of these hooks, when I
1024:52 - switch accounts, and I connect
with these new accounts, it even
1024:56 - automatically re renders
switching accounts. So these
1024:59 - hooks are really good for re
rendering our websites whenever
1025:02 - some value changes. For example,
if I said like, let count number
1025:07 - equals seven, and we had a
button, that updated account
1025:10 - number, our front end wouldn't
rerender unless we told it
1025:13 - specifically to rerender, which
gets really annoying. So hooks
1025:16 - kind of help us a lot with doing
that. And it allows us to keep
1025:19 - track of states between renders.
1025:24 - Now, here's something that right
now it doesn't do, if I hit
1025:27 - refresh, I have to re hit this
connect button, even though my
1025:31 - Metamask says, Hey, we're
connected. But if I refresh, I
1025:34 - have to re hit this Connect
button. Why is this happening.
1025:36 - Or when I hit refresh, our
website doesn't know that we've
1025:39 - hit enable Web three already,
right, because we basically go
1025:42 - back to blank when I refresh,
and then I have to hit Connect,
1025:45 - which is really obnoxious and
really annoying. So we want to
1025:48 - add some functionality, so that
automatically the instant we
1025:52 - render, we go ahead and we check
to see if we're already
1025:55 - connected. And if we're
connected to show this. Now to
1025:58 - do that, we can use another hook
called use effect. And this is a
1026:03 - core react hook. So we'll do
import use effect from react
1026:11 - like this. This is a core hook
directly from react. And it's
1026:15 - one of the most popular out
there along with use state. And
1026:18 - we've left some links to
learning more about the effect
1026:21 - hook in the GitHub repo
associated with this course, I'm
1026:23 - gonna give you my summary of
basically what this use effect
1026:27 - does, we basically have this
function called use effect,
1026:29 - which takes two parameters, it
takes a function as its first
1026:32 - parameter, and then second, it
optionally takes a dependency
1026:36 - array. And what this use effect
is going to do is it's going to
1026:40 - keep checking the values in this
dependency array. And if
1026:44 - anything in this dependency rate
changes, it's going to call some
1026:48 - function, and then rerender, the
front end. So for example, using
1026:52 - Morales comes with this function
called is web three enabled or
1026:56 - this variable called is what
three enabled. If we add this to
1026:59 - our dependency array, what we
can do in our use effect is do
1027:03 - console dot log, hi. And then we
can do console dot log is web
1027:10 - three enabled, what this use
effect is going to be doing is
1027:13 - it's going to constantly be
running, this is running all the
1027:16 - time. And it's going to be
listening to see if is web three
1027:20 - enabled changes, right? And
anytime we run Enable Web three
1027:23 - is web three enabled becomes
true. So so now if we go to the
1027:27 - front end, we do a little
refresh, we see high false, high
1027:31 - false. Now why do we see this
twice is web three enabled only
1027:34 - changed once? Well, this is
because of how use effect works,
1027:38 - it will automatically run on
load or right or the first time
1027:43 - it does and then it'll run
checking the value. So we're
1027:48 - basically seeing this run twice,
it runs the first time we load
1027:50 - it, and then it'll check the
value and run again. So we see
1027:53 - go twice, even though it's
really just once. But if we go
1027:55 - back here, sorry, let me just do
a quick reload again. We hit
1027:59 - Connect, we now see Hi is now
true, because it saw is what
1028:04 - three enabled change to true
because enabled web three made
1028:07 - is what enabled return true. And
it ran this again, right. So
1028:11 - that's how that actually works.
And there's a couple of
1028:14 - different ways to think about
this. Actually, we actually
1028:17 - don't even need to give this an
array. And what happens if we
1028:19 - don't give this an array? Well,
let's refresh. We'll hit
1028:23 - Connect, and we'll see it's
still ran a couple of times. So
1028:26 - if we don't give it array, no
dependency array, it'll run any
1028:31 - time something re renders. And
you need to be careful with
1028:34 - this. Because then you can get
circular renders, if you have
1028:38 - some use effect that changes
some value. And you have another
1028:42 - use effect that re renders when
that value changes while they're
1028:44 - both just going to keep changing
back and back and forth. So no
1028:47 - dependency array like this. It
will run anytime something re
1028:50 - renders we'll give it a blank
dependency array. It'll just run
1028:54 - once on load, just run one time.
So now like we have a blank
1028:57 - dependency right in here, we
reload. Right? We see that it
1029:01 - runs twice. That's actually
because we're basically re
1029:04 - rendering once in the
background. So it really is just
1029:07 - running Once but there's
something else going on in the
1029:09 - background. So it looks like
it's running twice. Now if we
1029:11 - just add is web three enabled,
do a little refresh, it'll do
1029:16 - the exact same thing, it'll run
the same amount as if this was
1029:19 - blank. But when we connect,
it'll add here. If this was a
1029:22 - blank array, when we refresh,
we'll see kick out twice, which
1029:27 - should be ones. But like I said,
there's something going on in
1029:29 - the background. If we hit
connect. Now, we don't see
1029:32 - anything here, because the blank
dependency array says, Hey, I'm
1029:36 - only going to run one time on
load. Now, if there's our stuff
1029:39 - in this array, like is web three
enabled, it's going to run
1029:42 - anytime something in this array
changes, right. So again, we'll
1029:45 - refresh will connect, we see it
ran again, after a hit Connect
1029:50 - will refresh. Hi, hi connected,
ran one more time. So so that's
1029:55 - kind of the cheat sheet here. If
we give it no dependency array,
1029:58 - it's going to run any time
anything in this project re
1030:01 - renders, if we give it a blank
dependency array, it's just
1030:04 - going to run one time, or like
we saw, it ran twice. But that's
1030:08 - because there's something else
we render in the background. And
1030:10 - if we give it dependencies in
this array, it's going to run
1030:13 - anytime something in this array
changes. And this is really
1030:16 - helpful, because oftentimes,
we're going to want our front
1030:19 - ends to rerender, this use
effect will say, oh, cool, some
1030:23 - value changed, I'm going to run
this function, and then I'm
1030:26 - going to rerender, your front
end.
1030:30 - And now we're going to use this
use effect thing to make sure
1030:33 - that when we refresh, it
remembers that we're actually
1030:35 - connected. So how do we do that
inside here, we are going to use
1030:38 - this is web three enabled thing.
And the first thing that we want
1030:41 - to just do is we want to say if
is what three enabled, then
1030:46 - we'll just return. Because if
we're already connected to web
1030:49 - three, then we don't need to do
anything. Now, if we're not
1030:52 - connected to web three, and we
don't have an account, we'll
1030:55 - want to go ahead and call Enable
Web three, right want to
1030:58 - automatically enable Web three.
So now if I go back, you'll see
1031:02 - with just this code, I'm just
always automatically calling
1031:06 - Enable Web three. But this can
get really annoying. Because if
1031:09 - I disconnect, right, let's go
disconnect everything. Now
1031:13 - refresh, it's going to always
call Enable Web three, right,
1031:18 - every time we refresh, it's
going to automatically call
1031:20 - enabled through without us even
hitting the Connect button. So
1031:23 - that's no good to we want to
actually see if we're connected.
1031:26 - So the way we do this, like I
said, we want to use our local
1031:29 - storage, again, application, or
these little, this little thing
1031:32 - here go to Application, we want
our we want our application to
1031:37 - remember that somebody hit this
connect button, and they went
1031:40 - and connected to us. So what
we're going to do is in our
1031:43 - little onClick function down
here, we're not just going to
1031:46 - call await Enable Web three,
we're also going to store a
1031:49 - little remembrance here saying,
Hey, we actually did connect
1031:53 - recently. So below this, we're
going to run window, dot local
1031:57 - storage, dot set item,
connected, comma injected. I'm
1032:07 - actually going to comment this
out for now, because my friend
1032:09 - is just going to keep popping up
like that. So what this does is
1032:12 - we're saying, okay, in our
window, because again, if you go
1032:16 - back to the window, you go to
console, a type window, you're
1032:20 - actually going to see this giant
window thing here, right, which
1032:23 - we showed you before, there's
always this window object in
1032:26 - here. And we're going to do
window dot local storage, which
1032:29 - relates to if we go to this
application section, this local
1032:34 - storage section here, that set
item connected to inject it. So
1032:38 - we're going to set a new key
value in here, we're doing it
1032:41 - like this because in the future,
maybe you want to do you know
1032:44 - connect it to Wallet connect or
connected to Coinbase wallet or
1032:48 - something, right, but we're just
gonna say injected, meaning
1032:51 - we're connected to that meta
mask. And in some versions of
1032:54 - next, Jas next, Jas has a hard
time knowing about this window
1032:56 - variable. So we can just do if
type of window does not equal
1033:02 - equal, undefined, then we're
going to do this. So we're just
1033:07 - making sure that window doesn't
equal undefined that there is a
1033:10 - window. So now if I go back to
the front end, and I hit
1033:13 - Connect, and we go ahead, and we
connect here, we'll see now in
1033:18 - our application, local storage,
we'll see we've added this
1033:23 - connected injected bit here,
we're storing in the browser
1033:26 - that we are indeed connected to
this. Now that we've added this
1033:29 - into our browser, we can roll
back up to our use effect here
1033:33 - and say, Okay, if they're
already connected, great, we'll
1033:36 - be done. But before we do
anything, let's check to see if
1033:39 - they have this here. And if they
already are connected, let's
1033:41 - just run that connect bit. So
we'll say if type of window does
1033:47 - not equal, undefined, right,
because we want to check for
1033:51 - that window object. Again, we'll
say if window dot local storage
1033:57 - dot get item connected,
connected, so if that connected
1034:02 - key exists, then we'll just run
Enable Web three. So now We have
1034:07 - some functionality in here,
which even when we refresh, it
1034:11 - will automatically run enable of
three for us. So now if I go
1034:14 - ahead and refresh the front end,
we don't have to press that
1034:17 - connect button anymore, because
it goes, Oh, I see that locally,
1034:21 - we stored this connected key
whenever you refresh. Now, it
1034:25 - checks for this first it sees it
and then runs enabled web three.
1034:28 - Now on the other side, though,
if we're in here, and now we
1034:32 - disconnect, and then we refresh.
This will show up, which is
1034:35 - really annoying. And every time
we refresh, it'll keep showing
1034:38 - up, which we don't want. We want
it to be that when we
1034:40 - disconnect, we tell it hey,
we've we've gone ahead and
1034:44 - disconnected here. So back in
our application, we can add
1034:48 - another use effect to check to
see if we've disconnected. So
1034:52 - let's create another use effect.
That's going to costly just look
1034:56 - for us being connected, we'll
say use effect, do a little
1034:59 - arrow bracket thing here. And
we're going to do this anytime.
1035:04 - And oh my goodness, anytime I
save, it's going to keep popping
1035:06 - up. So I'm just going to just
going to comment that out for
1035:08 - now. So in here, we want to say
okay, whatever, there's a
1035:11 - rerender we want to run if any
account has changed. And Morales
1035:15 - has some functionality for us to
do this as well. So from user
1035:18 - morass, we're going to import
more Alice, and then down here
1035:22 - in our use effect. Inside the
little function, we're gonna say
1035:26 - mirallas.on account, changed
1035:31 - of account, we're gonna do some
stuff. So on account changed,
1035:36 - takes a function as an input
parameter. So we'll say console
1035:39 - dot log, account, change to
account. And what we can do is
1035:47 - we can check to see if this
account is not. And we can say
1035:50 - if account equals equals no,
then if the account is null, we
1035:55 - can assume they've disconnected.
So we can say window dot local
1035:59 - storage, dot remove item,
connected, we'll also run a
1036:05 - deactivate web three function.
So from Ross, deactivate, web
1036:10 - three will also run, deactivate
web three, which is going to set
1036:17 - is web three enabled to false.
So we're going to disconnect the
1036:20 - web three, and then we're going
to say console dot log.
1036:25 - No
1036:27 - count found. So let's try this
out. Now. Let's go back to our
1036:30 - front end, we'll do a little
refresh here. So right now it
1036:33 - says we're connected. Even
though in my meta mask, we're
1036:36 - not connected, right? And to
start from scratch here, you can
1036:38 - go ahead and disconnect it. But
but my browser says, Hey, we're
1036:41 - connected, right? So now we'll
connect. And we'll actually be
1036:44 - connected right, next connect,
and it and it just overrode
1036:48 - connected, you know, with
inject, let's, let's make this
1036:50 - injected. And then we'll remove
Yep, okay, injected, we'll
1036:55 - refresh, like, connect, and now
it says injected. Okay, cool. So
1036:58 - now we're connected here. If in
here, if I just switch accounts,
1037:03 - right, let's go to Account
three, I'll connect. If we go
1037:07 - back to our console real quick,
we'll say account change to
1037:10 - blah, blah, blah, I can change
back, right, we'll go change
1037:14 - account change to blah, blah,
blah. Now, if we go back to our
1037:17 - application, go in here. And we
disconnect. Now let's disconnect
1037:22 - both of these disconnect. And
disconnect. We'll see it's now
1037:27 - been removed from local storage.
And if we go to our console,
1037:31 - it'll say, no account, change
the No, no account found and
1037:36 - removed it. Now if I hit
refresh, nothing happens here, I
1037:39 - can go ahead and connect. Right
next connect, I can refresh.
1037:44 - Oops, I need to go back in here
and re enable this. So sorry,
1037:47 - let's add this back in here. But
now it can refresh. Let's go
1037:51 - ahead and disconnect here. Let's
connect. Let's go back to the
1037:56 - console, we can connect thing
will pop up next connect, I can
1038:02 - refresh. It stays connected for
me, I can switch accounts, I can
1038:07 - go ahead and here, I can switch
accounts, I can even disconnect.
1038:12 - And it will automatically update
for me, which is what we want.
1038:15 - So now we've essentially made a
way more robust connect button,
1038:19 - where it goes back and forth
with when we're connected now.
1038:24 - Now one more thing that we might
want to do, or application is
1038:28 - when we hit Connect, we want to
maybe disable this button,
1038:30 - right? We don't want it to allow
it to be able to be pressed. So
1038:34 - I'm gonna hit Cancel, we're just
gonna add one more bit of
1038:36 - functionality here, we're going
to add this is web three enable
1038:42 - loading. And what this does is
it just checks to see if
1038:46 - Metamask has popped up. And so
what our button after the on
1038:49 - click section, we can add
disabled. Equals is web three
1038:55 - enable loading, so it'll be
disabled if we're loading here.
1038:58 - So let's go ahead and we'll
disconnect disconnect. Now we'll
1039:02 - hit Connect, and you'll see the
button can be clicked. So that
1039:05 - just makes it a little bit nice.
Turn, Next connect Bada bing,
1039:09 - bada boom, awesome, we have just
made a way more robust front end
1039:14 - than what we had before this
connect button is super slick.
1039:17 - And it allows us to kind of flip
back and forth. And our
1039:19 - application is incredibly
powerful and knows how to handle
1039:23 - all these different changes. Now
that we've learned how to do it
1039:28 - the manual way, let me give you
the Chiti way, in our
1039:31 - components, we're gonna create a
new file header dot j s, and
1039:34 - what we're going to do is we're
going to install this web three
1039:38 - UI kit, it's a front end kit,
and it has a whole bunch of
1039:40 - these components already built
for us. So we can build like a
1039:43 - header component and a connect
button component just by using
1039:47 - this. So to install, install it,
we're gonna come back here,
1039:50 - we're gonna stop our front end.
And we're just going to run
1039:53 - yarn, add web three UI kit, like
that. And again, we don't want
1039:58 - this to be a dev dependency,
because it is going to be a part
1040:01 - of our website, and then we'll
do in our header.js, we'll do
1040:05 - import connect button from web
three UI kit. And then we'll do
1040:12 - export default function header.
And then all we'll do is return
1040:19 - do like a div. And then inside
this div, we'll do next button.
1040:24 - With a little backslash here, we
aren't going to need this for
1040:27 - this project. But if we want to
be super explicit, we'll say
1040:29 - Morales off equals false. Just
again, to reiterate, hey, we're
1040:34 - not trying to connect to a
server here just to make that
1040:37 - super explicit. But this connect
button does everything, this
1040:40 - manual header thing that we just
created, does. So back in our
1040:44 - index.js, we can comment or
delete this line will do import
1040:50 - header from dot dot slash
components slash header. And
1040:56 - then instead of manual header,
we'll just do header. We start
1041:01 - our app back up with yarn dev
again,
1041:04 - we go back to the page, we do a
little refresh here, we now see
1041:08 - we have this connect Wallet
button. And it's even looks a
1041:10 - lot nicer. It's got some nice
styling to it as well, we can
1041:13 - hit Connect wallet. And it'll
give us this little ngModel
1041:17 - asking us which wallet we want
to connect to. So asking us
1041:20 - which wall we want to connect to
is kind of similar in our manual
1041:23 - header to this or set item
connected, injected, right or
1041:28 - wallet connect, it would do
connected wallet Connect for
1041:31 - trust wallet, it would it would
set item as connected wallet
1041:34 - connect, etc. So it allows us to
connect in different ways. And
1041:38 - we if we hit Metamask, we go
ahead and connect like so even
1041:41 - had some nice styling here where
it gives us our wallet address
1041:45 - here. But it also gives us our
wallet balance as well. And
1041:49 - again, if we go ahead and
disconnect, we'll see it
1041:51 - automatically disconnect. We
connect like so we can reconnect
1041:54 - like so boom, boom. If we switch
accounts, it's smart enough to
1041:57 - know that we're switching
accounts. So I know I showed you
1042:00 - kind of the hard way. But I
wanted to show you kind of
1042:02 - what's going on. It's setting
this local storage in the
1042:05 - background so that it knows
which where it's actually
1042:08 - connected. But for headers
moving forward, this is all you
1042:11 - need. And your life will be
drastically drastically easier.
1042:14 - And let's just add a centralized
lottery or decentralized raffle
1042:19 - or whatever you want to our
header as well. So it says
1042:22 - decentralized lottery, you know
the button Hello. Now that we
1042:27 - have that, what else do we need?
Well, well, the main thing that
1042:30 - this app needs to do is just
have a big button that says
1042:33 - enter the lottery. And then
ideally, you know, show how many
1042:36 - people are in the lottery and
then the recent winner as well.
1042:38 - So let's go ahead, we'll create
a new component called lottery
1042:41 - entrance. And we'll grab that
component similar to like what
1042:44 - we did with our header, we'll
drop this component right here.
1042:49 - And then our app will pretty
much be done. So let's create
1042:51 - this lottery entrance component,
lottery entrance, that Jas,
1042:57 - right and again, in the reason
we're putting these in
1042:59 - components, we could 100% Stick
it all, you know all our code in
1043:02 - here to make it more modular so
that we in the future, if we
1043:05 - want to have more pages or do
other stuff, I'm going to zoom
1043:08 - out a little bit just so that we
can see all of our code a little
1043:11 - bit easier. This is our whole
index j s. This is our whole
1043:14 - header. Let's create a new
lottery entrance app just for
1043:18 - the boilerplate code here we're
going to export default lottery
1043:24 - entrance, excuse me, export
default function, lottery
1043:28 - entrance, and this is just going
to be you know, another
1043:31 - component where we're going to
return some that JSX HTML stuff,
1043:35 - right? So we're gonna do div and
do like hi from lottery
1043:40 - entrance, Excel. And now that we
do that, we can go back to our
1043:45 - index.js. We can do import
lottery entrance from dot dot
1043:51 - slash components. Slash lottery
entrance, will stick it right
1043:57 - underneath the header like that.
And if we go back to our
1044:01 - website, we see high from
lottery entrance so our lottery
1044:05 - entrance is going to be right
underneath the header would
1044:07 - Here's what we want. And then
we'll delete this line that
1044:09 - says, Hello. So lottery
entrance, what is the what is
1044:12 - the first thing that we really
need to do in here? Well, we're
1044:15 - going to want to have a function
to call the lottery to enter the
1044:21 - lottery. Let's go ahead and do
this. Now let's go back to how
1044:24 - we did this with HTML fund me
recall that old fun function
1044:28 - like this, but doing it like
this won't rerender. And there's
1044:31 - a whole lot of other
functionality that doing it like
1044:33 - this won't give us so we're
going to use Morales to actually
1044:37 - call some of these functions,
because mirallas has in React
1044:40 - mirallas. Again, they have hooks
for us to do pretty much
1044:43 - anything we want to do. And one
of these hooks is called use web
1044:47 - three contract. And what this
does is it gives us a hook that
1044:50 - will give us the data returned
from a function called an error
1044:55 - returned, a little function that
we can use to call any function.
1044:59 - And then we also have these
really helpful is fetching in is
1045:02 - loading. So if we want everyone
to have our UI or our website,
1045:06 - do something while it's fetching
or while it's loading the
1045:09 - transaction, we can use these
two variables to do that. And
1045:12 - then all we need to do is we
just need to pass it the
1045:14 - contract information, which
similar to ethers is going to be
1045:17 - the ABI contract address, we'll
pass the function name, and then
1045:21 - any parameters for that
function. So we're going to use
1045:24 - this syntax here to make that
transaction to the blockchain.
1045:28 - And to call these functions. So
what we're going to do is we're
1045:30 - going to import us web three
contract
1045:35 - from react mirallas. And inside
our function, but before I
1045:40 - return, of course, we're going
to say const. And then we'll do
1045:44 - kind of exactly what we see in
here. For now, let's just get
1045:47 - the function, let's just get
this run contract function,
1045:50 - because this is going to be the
function that we can call to
1045:53 - actually enter the lottery. So
we'll say const, run contract
1045:57 - function, and we're actually
going to call this enter raffle.
1046:00 - And we'll say equals, use web
three contract, and we need to
1046:05 - pass the ABI, we're gonna need
to pass the contract address,
1046:11 - we're gonna need to give it the
function name, we'll need to
1046:14 - give it the params, which
actually we do know it's going
1046:17 - to be blank. But then finally,
we will need the message value.
1046:20 - Because if we remember back into
raffle doesn't take any
1046:23 - parameters, all it takes is this
message dot value bit. So that's
1046:27 - all we're going to need to pass.
So how do we get all this stuff,
1046:33 - and I'm going to leave this in
here. But we're going to comment
1046:35 - it out for now, because this is
what we need to do. But we need
1046:39 - to get all of this stuff into
our code here. So how do we
1046:42 - actually get all that stuff?
Well, ABI is easy, right? Abi
1046:46 - isn't going to change at all, no
matter what network or on ABI is
1046:49 - always going to stay the same.
Now if you've already deployed
1046:52 - your smart contracts, and you
know exactly what address it is,
1046:55 - because you've deployed to a
main net, or you've deployed to
1046:57 - a test net, all this stuff isn't
really going to change. And we
1047:00 - can just hard code it all right
into here. Or we can do what a
1047:04 - lot of people do is they'll
create a constants folder. And
1047:06 - in here, they'll add like an API
dot JSON, maybe they'll add a
1047:12 - contract addresses dot JSON. And
then they'll add maybe like an
1047:16 - index dot j s or something,
we're gonna build our
1047:19 - application in a way we can
actually test locally using our
1047:23 - own Hard Hat Network, and then
compare it to what it looks like
1047:26 - on the actual test net as well.
So we're going to make it
1047:28 - network agnostic. So the front
end works exactly the same no
1047:31 - matter what network that we're
on. And we can go back, download
1047:34 - a directory back into our CD,
hard hat smart contract lottery
1047:39 - Free Code Camp, and spin up our
node here, right with hh node or
1047:44 - yarn hard hat node. And we'll
use this as the blockchain that
1047:48 - we're going to connect to. The
thing is, if I go back here, and
1047:51 - I'm building the front end, and
I go, ah, like this would be
1047:53 - better if we did X, Y, or Z. And
maybe I changed the name of some
1047:57 - functions, you know, blah, blah,
blah, something else, I want
1048:00 - that change to be reflected on
my front end. And I want to be
1048:04 - able to code my front end as
such. So since we are the only
1048:07 - developer right now, we kind of
have the ability of where we
1048:10 - both know, the back end code and
the front end code. So something
1048:13 - that I like to do to make my
life a little bit easier is I
1048:16 - like to create an update front
end deploy script. So after we
1048:20 - deploy stuff, we run a little
script that will create this
1048:24 - constants folder for us with a
whole bunch of stuff, right?
1048:27 - It'll give an ABI, it'll give
contract addresses and anything
1048:30 - else we might need in our front
end from our back end. So what I
1048:34 - like to do is I like to come
back to my original code and an
1048:38 - update this for a new script. So
I'll come in here in this deploy
1048:42 - script, I'll create a new file,
and I'll call it oh two or even
1048:46 - like 9999, up, date, front, and
dot Jas. And the reason I do 99,
1048:54 - obviously, is because we want
this to be always the last
1048:57 - script in our deploy folder. And
then we can just write a little
1048:59 - script that's connected. We just
write a little script that's
1049:03 - connected to our front end here
so that whenever we deploy
1049:06 - contracts, no matter what chain,
we can update that constants
1049:09 - folder on our front end. So
let's go ahead and create that
1049:12 - script right now we'll do module
dot exports, equals async
1049:17 - function. And we'll add all our
stuff in here, we don't really
1049:21 - need to deploy any contracts,
because we're just updating the
1049:24 - front end. So we can just leave
the parameters of this one
1049:26 - blank. And the other thing I
like to do, because sometimes I
1049:30 - don't care about the front end,
what I'll do is I'll only update
1049:34 - the front end if we've specified
a dot env variable. So I'll
1049:38 - create a dot env variable called
up date, front end. And then
1049:43 - I'll set this to true. And now
in our script here, we can say
1049:47 - if process dot E and V dot
update, front end. And we can
1049:53 - just say like console dot log,
updating front end. And now back
1049:58 - in here, right, if a mat if I'm
in the correct directory in
1050:01 - here, if our own hard hit
Deploy,
1050:05 - you know, get this little
updating front end. And now we
1050:07 - can update front end. So let's
do it. So I'm actually going to
1050:10 - create one function called
Update contract addresses. And
1050:15 - this is going to be our function
that we're going to use to
1050:17 - update contract addresses, then
I'm going to make one called
1050:19 - Update API, where we just update
the API's and the front end so
1050:23 - so we're going to call this
update contract addresses. So
1050:25 - I'm going to create a new
function async function, update
1050:29 - contract addresses. And first,
we're going to get that raffle
1050:35 - contract since we're going to
need to get its address. So
1050:37 - we're gonna say const, raffle
equals await. And we're gonna do
1050:40 - the same thing we've been doing
ethers dot get contract, raffle,
1050:45 - and then my VS code auto
imported, it doesn't const
1050:48 - ethers equals require Hardhead,
like so. So we have raffle in
1050:51 - here. And we're gonna want to
pass this raffle address to our
1050:55 - front end, since this is going
to be a variable that we might
1050:58 - use a lot of places, we can just
add it like const, front end
1051:03 - location, addresses file,
equals, and we're going to give
1051:07 - it the relative path to where we
are now, which is going to be
1051:10 - you know, if we see the download
directory to next year's smart
1051:15 - contract lottery, FCC, I can
even just copy this, paste that
1051:20 - in here. And then it's in the
constants folder, and it's going
1051:23 - to be contract addresses dot
JSON. And let's get the ABI
1051:28 - file, we'll say const. Front and
a bi file is going to equal and
1051:35 - this is going to be nearly the
same thing. So we can just copy
1051:38 - paste that. And then we'll do
slash API dot JSON. And now in
1051:44 - our update contract addresses
function, we can say const,
1051:48 - current addresses, equals and we
can read again, in our front
1051:55 - end, we can read from this file.
So I'll usually start out with
1051:58 - just two brackets. So that's
like JSON compatible in both of
1052:01 - these files. And so to read it,
we're gonna say JSON dot parse,
1052:05 - FS dot read file sync, we're
gonna have to import, say const.
1052:11 - FS equals require, I know we've
used Fs extra in the past, but
1052:16 - this one, we're just gonna use
Fs, which is going to be our
1052:19 - front and addresses file, we're
going to read it in with UTF
1052:27 - eight encoding. So now this is
going to be our current
1052:29 - addresses. And we're going to
update the list of current
1052:32 - addresses with some new
addresses. Because our contract
1052:35 - addresses we want this to be
chain agnostic, we would do
1052:37 - something like for you know, and
then the addresses on rink B, we
1052:40 - could do 31337, and then the
addresses on our local host,
1052:45 - right, we want to be able to
keep track of all the different
1052:48 - addresses across all the
different chains. So back in our
1052:51 - function here, then we'll say if
if network, dot config dot chain
1052:58 - id.to string in contract
addresses that were config ideas
1053:05 - in there, then we're just gonna
go ahead and add this new
1053:08 - contract address in there. But
before we add this new address
1053:11 - in there, let's just check to
make sure it's not are already
1053:13 - in there. So we're just gonna
say if contract addresses of
1053:18 - network dot config dot chain
id.to string, this is so long, I
1053:23 - don't want to keep writing that
I'm gonna say const chain ID
1053:25 - equals network, config that
chain id.to string, and we're
1053:31 - just gonna use chain ID. If
chain ID and contract address
1053:36 - then if we don't already have
that includes raffle dot
1053:41 - address. We're gonna go ahead
and add this new address and
1053:51 - then if the chain ID doesn't
even exist, we're gonna go ahead
1053:54 - and do contract addresses
current addresses, equals or
1054:01 - assuming current addresses of
chain ID equals and then we'll
1054:05 - just create a new array, raffled
that out address. So we're
1054:08 - saying if the chain ID doesn't
exist in current addresses,
1054:10 - we're just going to add this new
array in there. And then
1054:13 - finally, now that we've updated
its object, we're gonna write it
1054:16 - back to this file, we'll say Fs
dot write, file sync, front and
1054:22 - addresses file. And then we're
gonna do JSON dot string of
1054:26 - five. So we're going to
Stringify this JSON object, so
1054:29 - we're just gonna go ahead and
write it back. And then bottom
1054:32 - module that exports that tags
equals all and then front end. I
1054:39 - cool. So we have a function to
update the contract addresses,
1054:41 - but we also need the ABI. So
we're gonna do date API, and
1054:46 - we're gonna create another
function async function, update
1054:50 - API. And in here, we're gonna do
the exact same thing on raffle
1054:54 - equals await ethers that
contract,
1055:00 - raffle FX dot right file, sync,
front and abi. It's just going
1055:08 - to copy paste it front end, AVI
file. And then to pass just the
1055:13 - ABI, we can actually get it
directly from this raffle
1055:16 - object, we can actually just do
raffle dot interface that format
1055:23 - ethers dot utils, dot format
types, dot JSON. If you look in
1055:29 - the ethers, Docs, ethers has
this contract dot interface
1055:32 - thing which returns an interface
which is different from a
1055:35 - solidity interface. But it
allows us basically just to get
1055:38 - the API with this one line of
code. So in our back end code
1055:41 - here, now if you run h h deploy
or H H node, we should
1055:46 - automatically update our
contract addresses in our API
1055:50 - dot JSON. So let's go and try
this. So we'll run h h node. So
1055:55 - we'll start a node, right in
this terminal over here, we'll
1055:58 - flip back to the front end. And
if we open ABI to JSON, we do
1056:03 - indeed, now see, we have the
raffle API in this file. And if
1056:07 - we go to contract addresses, we
see on network 31337, here's our
1056:12 - first address, right. And if we
deploy to different chains, this
1056:15 - will get populated with
different network IDs, and then
1056:18 - a list of addresses associated
with them. So it helps make our
1056:21 - front ends a lot easier to
maintain, and bounce around and
1056:25 - kind of test and work with. Now
that we've done all this, we can
1056:27 - actually close our hardhat smart
contract lottery Free Code Camp,
1056:31 - the hard hat project for this,
and we're just going to have all
1056:33 - of our terminals be in here. So
what we're gonna do is we're
1056:37 - gonna go down and directory CD
dot dot, and we're going to cd
1056:40 - into Oh, sorry, we're actually
we're already in their CDs, hard
1056:44 - hat, smart contract, lottery
Free Code Camp. And then in this
1056:47 - one, we're going to run hh node
or yarn hardhat node. Now we'll
1056:51 - have a local blockchain running
so we can test everything that
1056:55 - we're doing in the front end,
actually, I'm gonna move this up
1056:57 - one. So now in our first area,
here, we have our front end code
1057:01 - running, then we have our
blockchain running. And then in
1057:05 - this one, we're just going to
add, you know, whatever we want
1057:07 - to add. Now, we can actually go
ahead and hit this little X
1057:09 - button here to close the panel.
So that's just hiding the panel,
1057:13 - these are all still out, they
only get trashed when you
1057:15 - actually hit the little
trashcan. So we're just going to
1057:17 - close the panel. But all those
terminals are still running, I
1057:20 - promise back. So where were we?
Okay, back to our function here.
1057:24 - So we just automated the process
of updating our API's and then
1057:28 - updating our contracts as well.
And now we can import these into
1057:31 - our files. Now we can import
them one at a time, it'd be like
1057:34 - import API, from dot dot slash
constants, slash API, or we
1057:41 - could do something a little bit
clever is we could export these
1057:44 - in the same file. So if we
create a new file, a new
1057:47 - index.js, in here, we can import
them and then export them in
1057:51 - this one file. We can say const,
contract editor says equals
1057:55 - require dot slash contract
editor dot JSON, and then const
1058:02 - API equals require dot slash API
dot JSON. And then we'll do
1058:08 - module dot exports equals API
and contract addresses. So now
1058:14 - once we export them like this
back in our lottery entrance, we
1058:17 - can import them just in one
line. So we'll say import API
1058:22 - comma contract addresses from
dot dot slash constants. So we
1058:29 - can just specify the folder
instead of each individual
1058:32 - files, because we have this
index dot j s here, which
1058:35 - basically represents this whole
folder. Back in here, what do we
1058:40 - have now? Let's uncomment this
abi. Okay, great. We have the
1058:44 - ABI we're importing it from our
constants, folder, contract
1058:48 - addresses, we have our contract
addresses. And we're going to
1058:51 - need to specify the network ID
in just a second here. We have
1058:56 - the function name here, which is
going to be what enter the
1058:59 - raffle. There are no params. So
all we need to do so how do we
1059:04 - get both the chain ID and then
Also the message dot value will
1059:09 - change, it is something that we
can get really easily with
1059:11 - Morales, let's comment this
whole section out one more time,
1059:14 - just so I can show you something
we can do import. Once again,
1059:18 - we're going to get that use
Morales book from react Morales.
1059:25 - And what we can do is we can say
const.
1059:29 - Chain ID equals use ralis. Now,
the reason morality knows about
1059:37 - what chain we're on is because
back in our header component,
1059:40 - the header actually passes up
all the information about the
1059:44 - Metamask to the Morales
provider. And then the Morales
1059:48 - provider passes it down to all
the components inside those
1059:52 - Morales provided tags
concentrated equals use Morales.
1059:56 - And I'm just gonna do a little
console log chain ID because I
1059:59 - want to show you what it looks
like. So if we do a little
1060:02 - refresh, and we're in the
console here, we can ignore some
1060:05 - of these warnings here, but we
see the chain ID is actually 0x
1060:09 - Five, well, because I'm on the
rink B chain or the Grilley
1060:12 - chain excuse me, if I switch
back to hard hat localhost,
1060:15 - which you should know how to do
from a SEMA fun we bet if you
1060:17 - don't have hard hat localhost
and your Metamask go back to
1060:20 - that HTML font we bit follow
that along. Okay, great. Now
1060:23 - it's going to print this Oh x
bla bla bla bla bla. So that
1060:26 - might be a little bit confusing.
But this is the hex version of
1060:30 - our chain ID. Right. So let's
switch to Etherium main net. Now
1060:34 - we pronounce Oh x one, right?
Oh, x one is the hex version of
1060:37 - the number one. So chain ID
gives us the hex addition of the
1060:42 - chain ID. So I don't want the
hex addition, I want the actual
1060:45 - number. So what I'm going to do
is I'm going to say Okay, chain
1060:48 - ID, your name is actually going
to be chain ID hex. And we can
1060:52 - do console dot log chain ID hex,
but I want the number. So what
1060:55 - we can do is parse a built in
JavaScript parse int, CIN ID hex
1061:02 - like that. Now if I go back,
we'll do a little refresh here.
1061:06 - Scroll away from the warning, we
can see the one here. Now let's
1061:09 - switch to hard hat, localhost.
We'll scroll down we see 31337.
1061:14 - So use Morales chain ID returns
the hex we parse it with Parson
1061:18 - to get the actual number. Okay,
great. So we can stick the chain
1061:21 - ID into here. Now this raffle
address is something that we're
1061:24 - actually going to use a lot, we
might as well have it be at the
1061:26 - top of our code here, we aren't
going to be changing the raffle
1061:30 - address. So we don't need to put
it in a hook. We are going to
1061:32 - technically be changing the
address when we change networks.
1061:35 - But our header app takes care of
re rendering and dealing with
1061:39 - all that. So we can just make
this a constant variable. So we
1061:41 - can say const, raffle address
equals, first let's check the
1061:47 - chain ID hex and if there's a
chain ID hex and if there's not
1061:50 - a chain ID hex we're gonna do
something else. Excuse me, we're
1061:52 - gonna say chain ID hex in
contract addresses. And
1061:56 - actually, there's never gonna be
a chain ID hex. So we'll do
1061:58 - const chain ID equals Gen ID hex
parsed, Parsons, chinati hex,
1062:04 - and you might be thinking, hey,
this, these are both the same
1062:06 - name. Well, what we're doing up
here in use Morales is we're
1062:09 - saying hey, pull out the chin ID
object, and then rename it to
1062:13 - chain ID hex and down here,
we're saying, Hey, we're going
1062:15 - to create a new variable called
Chain ID. So we'll say contract
1062:19 - addresses of chain ID at zero.
So in here, we're saying this
1062:26 - network ID and this address,
otherwise, we'll just say no.
1062:30 - Okay, we're getting there. Let's
uncomment this, now we have the
1062:34 - raffle address, and we can just
stick it in here. All we do now
1062:37 - is the message dot value. If we
remember back to our raffle, we
1062:42 - actually set that fee
dynamically. So we have in here
1062:46 - we do entrance fee equals
entrance fee, which is the
1062:48 - parameter in the constructor. So
we want to call this get
1062:51 - entrance fee function. This is
one of the ways we can send a
1062:54 - transaction. And we can also
send functions, one of the ways
1062:57 - that we're going to do it right
when our lottery entrance loads,
1063:01 - we're going to run a function to
read that entrance fee value. So
1063:05 - how do we do that? Well, we can
use one of our hooks again,
1063:08 - right use effect use effect can
run right when something
1063:11 - changes, we're only going to
want to try to get that raffle
1063:13 - entrance fee if web three is
enabled. So what we can do is
1063:17 - back up in here and use Morales
will pull in that is web three
1063:21 - enabled. And we'll have our use
effect in our function, we'll
1063:25 - just say if this is web three
enabled, then we'll try to read.
1063:32 - So we can go ahead and use this
use web three, contract Wagan.
1063:36 - Let's go ahead and just copy
paste this. And we'll use the
1063:38 - same setup here. Except instead
of enter raffle, of course,
1063:44 - we're going to be doing get
entrance fee. So we're going to
1063:48 - get entrance fee. We need the
API we got it raffle address got
1063:52 - it. This is going to be the
function name is going to be get
1063:55 - entrance fee params nothing
message that value, nothing.
1063:59 - We're going to be calling this
get entrance fee function. And
1064:02 - now I finally show you how to
actually call one of these in
1064:05 - our contracts here. Use web
three contract, download our use
1064:09 - effect, we're actually going to
call get entrance fee. Now if we
1064:12 - just call get entrance fee like
this, and we say like, you know,
1064:15 - const something equals get
entrance fee and then console
1064:19 - dot log something, what do you
think's going to happen? And
1064:22 - oops, I need to import, I need
to import use effect from react.
1064:27 - There we go. We look or logs, I
don't see console dot log,
1064:33 - something won't get entrance fee
is going to be an async
1064:36 - function. Once again, we need to
wait we would need to do a wait
1064:40 - get into T, right? There's an
issue we can't call await in our
1064:43 - use effect. So what can we do?
Well, we can actually make an
1064:47 - async function, call it update
UI. And then we can stick this
1064:52 - inside of the async function
here. And we can call update UI
1064:57 - right outside of it like this.
So now we go back to our front
1065:00 - end, we do a little refresh. And
if we scroll up, we still see
1065:03 - nothing. Well, is web three
enabled actually changes. So the
1065:07 - first time that this runs, is
web three enabled probably is
1065:11 - false. But when it turns to
true, we want to we want to run
1065:15 - this section in our little
dependency array. We're going to
1065:18 - add this in here, right? And the
reason that it's false to start
1065:21 - with is because of exactly what
we showed in that manual header,
1065:25 - right? What does it do? Well,
first, we check to see after we
1065:28 - do a refresh, if window dot
local storage get item is
1065:31 - connected, then we call Enable
Web three, which will make this
1065:34 - enabled. So in our lottery
entrance, is what they're
1065:38 - enabled starts off as false when
we do a refresh. And then the
1065:42 - browser checks the local storage
says, oh, web three should be
1065:45 - enabled, let's enable it and
turn to true. So now if we hit
1065:48 - save, and we do a little refresh
in our console, we can now see
1065:52 - the logged out entrance fee. So
then we'll switch this to
1065:56 - entrance fee from contract. Now,
we also probably want to show
1066:03 - this entrance fee on our UI, if
we do let entrance fee, we'll
1066:08 - say equals blank. And we'll take
this and we'll update, you know,
1066:14 - and we'll update this just
saying entrance fee equals await
1066:16 - entrance fee. Cool. Now we have
this as kind of a global
1066:19 - variable, we can add it in here.
And then let's even do a weight
1066:22 - entrance fee. But this whole
thing in parentheses, and then
1066:26 - do.to string, and we can even
console dot log entrance fee.
1066:33 - Now we're adding in a new
browser. But there's still an
1066:36 - issue here. Let's see if you can
spot it, we'll do a little
1066:39 - refresh.
1066:41 - We don't see the entrance fee in
the UI here. But we do see it
1066:45 - good console dot log out, right.
And again, this is going to be
1066:47 - in a way here, what is going on
here will use effect is going to
1066:51 - rerender our browser, right? And
that's what we want is what
1066:54 - three enable goes from false to
true, our browser re renders
1066:57 - watch, once we get our entrance
fee, does our browser rerender?
1067:02 - No, it does not because entrance
fee is just one of these normal
1067:06 - variables, right. So we want to
actually change this from being
1067:09 - just a normal variable to being
a hook because entrance fee does
1067:12 - get updated, but it's not
triggering a rerender. So we
1067:16 - actually want to change this to
being what's called a use state
1067:19 - hook. So you can read some more
on the documentation about the
1067:22 - using the state hook, it's kind
of the same as doing let
1067:24 - entrance fee, you know, equals
blah, blah, blah, and setting it
1067:28 - below. But it also will trigger
a rerender for us. And to do it,
1067:32 - we actually do const entrance
fee, comma, set entrance fee
1067:38 - equals use state zero import use
state from react as well. So
1067:44 - basically, entrance fee is going
to be our value, right, so if we
1067:47 - do console dot log entrance fee,
it's going to print out the
1067:50 - entrance fee entrance fee is
going to be the variable we call
1067:53 - to get the entrance fee, the
entrance fee is going to be the
1067:57 - function we call to update or
set that entrance fee. And
1068:01 - whatever that this entrance fee
variable is set, we trigger a
1068:04 - rerender. From the front end, we
have the state or the actual
1068:08 - variable in the function to
update it. And then in the use
1068:11 - state here, we just give it its
starting values we're saying
1068:14 - entrance fee is going to start
out as zero. So now that we know
1068:18 - that, let's go back down here,
and instead of saying entrance
1068:22 - fee equals this, we can say
const entrance fee from call
1068:28 - equals away entrance fee.to
string and then we can say set
1068:32 - entrance fee to this entrance
fee from call. And now when we
1068:37 - set the use state, we're going
to trigger a rerender. So
1068:40 - entrance fee will actually be
populated. Now if we go to our
1068:43 - browser, do a little refresh
here. We can see that the
1068:49 - entrance fee has indeed been re
rendered here and we can
1068:51 - actually see it here. We see the
console dot log of zero here
1068:54 - even though we're doing console
dot log entrance fee because
1068:56 - this set entrance to function
hasn't finished running it
1068:59 - basically. So we're just gonna
get rid of that line will
1069:02 - refresh and Bada bing bada boom,
this huge number is kind of
1069:06 - gross. We might even want to
update it so that it looks a
1069:10 - little bit nicer. So once again,
we can import ethers, ethers
1069:16 - from ethers. And down below,
we'll do a little ethers dot
1069:23 - utils dot format units. And
we'll do entrance fee from call
1069:32 - and we'll do a comma and type
in. And if we refresh on the
1069:36 - front end, now we can see,
entrance fee is 0.1. So we can
1069:40 - even label this we'll say
entrance fee, blah, blah, blah.
1069:45 - Now if we do a little refresh on
the front end, entrance fee 0.1
1069:49 - E.
1069:52 - Finally, we have the entrance
fee, and now uses finally on our
1069:56 - function to enter the lottery.
So let's finally uncomment this
1069:59 - out. And for message value,
we're going to want to use this
1070:02 - entrance fee. And I'm realizing
it's actually better to store
1070:04 - this in its raw to string
format. So we're going to undo
1070:08 - this part that we just did.
We're going to add it down here.
1070:11 - So we're going to ethers, that
format units, entrance fee,
1070:15 - comma, ether, like that. So that
like that, and let's comment
1070:19 - this back out real quick. So
that at least in the UI, it
1070:22 - shows up at 0.1. But on the back
end, we're actually going to
1070:26 - save it as its raw, and have way
value. So we're saying that we
1070:30 - have this entrance fee and what
we can do uncomment, this, we
1070:34 - can just grab this entrance fee,
and plop it in here. So we need
1070:38 - to make a button that's gonna do
that. Now again, we want to make
1070:41 - our code that all this works,
even if we're connected to a
1070:44 - supported chain, though. So
before we even add this, right,
1070:47 - if we switch from hard hat to
like, Aetherium main net, do a
1070:50 - little refresh. We're getting
kind of get an error here,
1070:53 - because we're calling get
entrance fee.to string on an
1070:58 - address that doesn't exist,
right? So it's gonna get really
1071:01 - confused and be like, hey, what,
what are you doing here? Let's
1071:04 - add a little button here so that
we can actually enter the
1071:07 - raffle. Before we actually do
that, let's make sure that we
1071:11 - can only call the function so
long as there actually is a
1071:14 - raffle address. So we'll do
raffle address. And we'll do
1071:18 - this ternary operator once
again. So that only if this
1071:22 - raffle address is valid, right?
And it's not, no, we'll add all
1071:26 - this code here, right. So we'll
say if the raffle address
1071:28 - exists, we're going to do some
stuff. And for now, we can
1071:31 - actually just copy paste this
line, stick it in here. And then
1071:36 - otherwise, we'll say div.
Excellence div, close it off.
1071:41 - We'll save reformat, great.
We'll say no raffle address,
1071:46 - detected. Now we'll just do all
of our code in this section up
1071:50 - here. So we have this little div
here, which is great. Inside of
1071:53 - this div, let's add a button.
Button button, we'll save it got
1072:00 - a little button here, we'll have
it say, enter raffle. And we'll
1072:05 - say on click, well, we're going
to do some JavaScript. So let's
1072:09 - do some JavaScript, we want to
call an async function async
1072:13 - function. So I know the double
brackets is going to be
1072:16 - confusing, right. But these
brackets allow us to do
1072:19 - JavaScript in our HTML, or JSX,
or whatever. And these brackets
1072:23 - represent this function, it's
going to an async function. And
1072:27 - we're gonna say, await, enter
raffle. And that's it. So let's
1072:33 - go back to the front end. Now we
have a little enter raffle
1072:35 - function. If we do refresh,
let's just make sure our account
1072:40 - is reset here. So we're gonna go
down to settings, advanced,
1072:44 - reset accounts, yes. I hit ENTER
raffle. metamath does indeed pop
1072:48 - up. And we can go ahead and
confirm. Awesome, okay, we can
1072:53 - now enter our raffle. We're
doing incredibly well with this.
1072:59 - As you saw, we just got that pop
up. And that was pretty much it,
1073:02 - right? It's not very helpful for
the users who are following
1073:05 - along with this to look at this
and go, Okay, did it go through?
1073:09 - Or we did it fail, like, what,
what just happened? So what we
1073:12 - want to do is create what's
called notifications, right? We
1073:15 - want a little pop up saying,
Hey, you sent your transaction,
1073:18 - great job, we're going to use a
library. Again, we're going to
1073:22 - use the web through UI Kit,
which comes with some
1073:24 - notifications that we can go
ahead and use. So if you come to
1073:27 - this little interactive thing,
which is right in their GitHub,
1073:31 - there's a whole bunch of stuff
in here. And you can actually
1073:34 - click around and play with
different buttons and different
1073:36 - things. And you can actually go
ahead and even go to docs for
1073:39 - each one of these. And you can
go show code. And you can
1073:43 - literally like copy paste code
into your project, like whatever
1073:45 - you want to do styling and
everything for us. So back in
1073:49 - our app dot j s, we're going to
add import, no to vacations
1073:54 - provider from web three UI kit
and inside of the Morales
1074:01 - provider, but outside of the
components, we're gonna do
1074:04 - notification provider
notification provide Add it like
1074:07 - this. So it goes Morales
provider notification provider
1074:10 - component. So wrapping our
component in this notifications
1074:13 - thing, and that's notification
provider not notifications. And
1074:18 - this is going to allow us to
actually make notifications back
1074:22 - in our lottery entrance. Back in
our lottery entrance, we're
1074:24 - gonna scroll up to the top,
we're going to import a hook
1074:28 - those notifications called us
know, to the occasion from web
1074:34 - three UI kit. And this use
notification gives us this thing
1074:39 - back called a dispatch. So I'm
gonna say const, dispatch,
1074:43 - equals use notification. So use
notification returns this
1074:47 - dispatch, and this dispatch is
like a little pop up that will
1074:49 - give us so down here, when we
call this enter raffle, we're
1074:54 - gonna give it a little some
parameters in here, we're gonna
1074:56 - say on success, these functions
come with onsuccess, they come
1075:00 - with onComplete, they come with
an error, all this stuff. And
1075:05 - when this function is
successful, we'll do handle
1075:09 - success, we'll create a new
handle success function that
1075:12 - will handle the success. And
this is Patrick from the future
1075:16 - coming back to show one
additional point. I know I
1075:18 - mentioned it, but it is really
good to add this on error, colon
1075:24 - error console dot log error for
any run contract functions, even
1075:29 - the reads, If any of your run
contract functions break, you
1075:33 - won't know. So definitely want
to add this on error error
1075:36 - console dot log error to all of
your run contract functions. So
1075:40 - up here, before the return,
we'll create a new const handle
1075:45 - success. We'll say this is an
async function async function
1075:51 - that takes the transaction as
input parameters. And remember,
1075:55 - you can turn functions into
constant variables. And we'll
1075:59 - say await TX dot Wait, one, so
we'll wait for that transaction
1076:05 - to go through. And then we'll
create another function called
1076:08 - handle new notification, dx. And
you'll see why I'm doing it like
1076:13 - this in a minute. And we'll say
const and Linoone notification,
1076:17 - this is just going to be a
synchronous function because we
1076:19 - don't need it to be async. And
we're just going to call this
1076:22 - dispatch, we're going to set up
this notification basically. So
1076:26 - we'll say notify, or dispatch,
and then we'll add the
1076:28 - parameters in here. So it takes
an object as a parameter, we'll
1076:31 - say type info. Message, it's
going to be transaction
1076:38 - complete, the title is going to
be TX notification. Jose, Shawn,
1076:50 - we're going to say, top are and
then icon, we're going to say a
1076:55 - little bell.
1076:58 - And you can find all this stuff
right in here, type icon
1077:01 - position, you can read all about
the different parameters you can
1077:05 - kind of set this up with so
handle new notification handle
1077:07 - success. So we're saying, enter
raffle once this transaction is
1077:12 - successful, call this handle
success function, which is going
1077:16 - to call handle new notification.
Okay. And you'll see why we
1077:19 - split this into two instead of
just having handle success. Also
1077:22 - do the dispatch. When we press
our enter raffle button, we're
1077:26 - going to call enter raffle is
successful, we're going to call
1077:29 - handle success. We're going to
wait for that transaction to
1077:32 - finish Yes, it passes a
parameter to our handle success
1077:35 - function. And then all we're
going to do is we're going to
1077:38 - call handle new notification.
And we're going to dispatch
1077:41 - we're going to launch one of
these notifications. So back
1077:44 - here, let's hit enter raffle.
metamath pops up will confirm.
1077:49 - And after it completes, we get
this wonderful transaction
1077:52 - notification transaction
complete, right. So we've let
1077:55 - the user know, great job, you've
submitted a transaction. Great
1077:59 - work. So this is great. We're
giving our users some helpful
1078:03 - pieces here. Now let's add a
little bit more here so that the
1078:08 - users know what else is going on
with this lottery. But we need
1078:11 - to display a little bit more
data, right, let's display how
1078:13 - many people are in this lottery.
How many people are in this
1078:17 - game. And we can do that. Of
course, because we have a number
1078:21 - players command. We also
probably want to get the recent
1078:24 - winner. And we can do that as
well. Up here, we're going to
1078:27 - copy this get entrance fee,
we're going to create another
1078:30 - one called Get num players. And
this is going to call go back to
1078:36 - raffle dot soul. It's going to
call get number of players
1078:39 - actually so let's just call it
call it the same thing. Get
1078:43 - number of players and we're
going to call and get number of
1078:46 - players. And to store this
value. Once again up at the top.
1078:50 - We're going to copy this line,
paste it right and we'll do non
1078:55 - players. And then we'll do set
num players. And then we'll copy
1079:00 - this line again. A recent winner
so we'll do recent Winner.
1079:05 - Winner will do Set, recent
winner, then we'll copy this
1079:11 - again, instead of getting number
players will do get get recent
1079:16 - winner. So we'll call it get
recent winner get recent winner
1079:20 - in our use effect, let's do more
than just get the entrance fee,
1079:24 - let's get everything. So we can
say const num players, from call
1079:30 - equals, we'll do a weight, get
number of players.to string, and
1079:37 - then we'll do set set num
players do like that. So we'll
1079:42 - do set num players, num players
from call. And then we'll also
1079:47 - do const recent winner from call
this is going to be await get
1079:54 - recent winner. And we might need
to wrap this to string but I
1079:57 - think I don't think we need to.
So we'll do set recent winner
1080:01 - paste that in here. So now we've
had a number of players, we've
1080:04 - added a recent winner. Let's
come back down here. We have an
1080:07 - entrance fee. Let's go ahead and
do number of players. And we'll
1080:14 - add number of players or what
did we call it? Oh my god, we
1080:19 - called setting employers twice
oops, it's called non players,
1080:23 - scroll down players gonna be non
players, and then we'll do
1080:27 - recent winner.
1080:30 - And then we'll add in the recent
winner. Awesome. Okay, entrance
1080:35 - fees 0.1 eath number of players
to recent winner is nobody here.
1080:40 - And if we go ahead and we enter
the raffle metamath pops up.
1080:45 - We'll go ahead and confirm. Once
a transaction goes through,
1080:48 - we'll get transaction complete.
And if we do a refresh, we see
1080:53 - the number of players has
updated. But we had to refresh
1080:56 - which is kind of annoying,
right, let's enter the raffle
1080:58 - again, we'll go confirm
transaction complete. But this
1081:03 - didn't rerender. Right. So we
want to set something up so that
1081:06 - we automatically rerender. And
guess what's going to do that
1081:09 - the handle success that we were
talking about before. That's
1081:11 - right, all of this update UI
stuff, we can actually pull out
1081:15 - of the use effect. So we're
going to copy it all deleted
1081:19 - there. And we're going to have
it be its own standalone
1081:22 - function like this. And then in
our handle success, whenever
1081:26 - this successful transaction goes
through, we're going to update
1081:29 - the UI, right? So handle success
handled new notification, and
1081:33 - we're going to update the white.
So now if we go back here, let's
1081:37 - enter the lottery. Let's
confirm, we see we get the five
1081:41 - and we get transaction
Notification. Now we want to
1081:43 - test getting a recent winner
here. So what we can do,
1081:47 - actually back in our hard hat
project is we want to create a
1081:51 - new script. And I actually
already created it for you,
1081:54 - that's going to mock the
channeling VRF. And that's going
1081:56 - to mock being a keepers. So all
this is really doing is pretty
1081:59 - much exactly what our tests were
doing. If you want to pause
1082:02 - right now and look through this
yourself, pause here and add
1082:05 - this mock off chain, which is
both keepers and VRF. Or you can
1082:09 - just go to the GitHub repo here.
Just go to the GitHub repo for
1082:13 - Lesson Nine. It's already in
scripts go down to scripts
1082:17 - Markov chain, you can just copy
paste it here. Because I want to
1082:21 - test that that recent winner. So
in my hard hat, smart contract
1082:24 - lottery, so we'll do yarn,
hardhats run scripts, slash mock
1082:30 - off chain dash test network
local host, we're going to mock
1082:34 - you know, basically picking a
winner from an upkeep with
1082:37 - Request ID one, we're on a local
network. Okay, let's pretend the
1082:40 - recent winner was so and so. And
what we can do is we can do a
1082:43 - little refresh here, we can see
we have a winner updated. Boom.
1082:48 - Now we're gonna clean up the UI.
But I want to talk about a
1082:51 - couple of things. Before we do
that, because we're almost done
1082:53 - with this section. Something I
want to make really clear
1082:59 - because it confused me a little
bit is that this onsuccess isn't
1083:02 - checking that the transaction
has a block confirmation, it's
1083:05 - just checking to see that the
transaction was successfully
1083:09 - sent to Metamask. So onsuccess
checks to see a transaction is
1083:14 - successfully sent the Metamask.
And that's why up in that other
1083:17 - function, we do TX dot wait one
because that's the piece that
1083:20 - actually waits for the
transaction to be confirmed.
1083:25 - Right now we're using Morales to
make once we call that mocking
1083:29 - script, I had to refresh the
browser to see the winner here,
1083:32 - right and number of players
obviously got reset to zero,
1083:35 - which is great. That's not
ideal. Ideally, we want our UI
1083:39 - to just automatically update
when some event gets fired. In
1083:43 - our raffle contract, we get this
event emitted. Instead of in our
1083:47 - code doing this await success
here. What we could do is we
1083:51 - could set up a portion to listen
for that event being emitted and
1083:57 - update the front end
accordingly. With that knowledge
1084:00 - we can also listen for the
winner event being emitted. We
1084:03 - could update our front end
instead of having to refresh
1084:06 - it's your cue Yes, and you want
to see if you can add to this
1084:09 - right now, I highly recommend
you do. So
1084:14 - we've pretty much finished all
the functionality. And wow,
1084:17 - you've learned a ton in this
little bit, right? We've learned
1084:20 - about use effects use Morales,
all these hooks, all this stuff,
1084:23 - and we've got a front end that
very nicely handles interacting
1084:27 - with our smart contract. The
only thing is, is it looks
1084:29 - really ugly. This is kind of
gross. So let's make this look
1084:34 - at least a little bit nicer.
There's two things to think
1084:37 - about when it comes to building
these front ends. There's
1084:39 - component libraries, like web
three UI Kit, which we're using,
1084:42 - which gives us kind of like
components that give us, you
1084:45 - know, blocks of code, like this
connect button that are already
1084:48 - formatted for us. And then
there's CSS libraries that
1084:52 - actually will help us format the
rest of our stuff here. So we're
1084:55 - using one of these component
libraries. We're also going to
1084:58 - use one of these formatting
libraries, and the library that
1085:01 - we're going to use is tailwind.
And the reason that we're going
1085:03 - to use tailwind CSS is because
it's really popular. If you want
1085:07 - to learn CSS, there's some
wonderful resources that you can
1085:09 - use to learn CSS web three
schools is one that I've used a
1085:12 - ton. So there's going to be a
link to that in the GitHub repo
1085:16 - associated with this course so
that you can make your websites
1085:19 - look pretty when formatting
stuff but we are actually going
1085:21 - to work with tailwind because
it's going to make us doing CSS
1085:24 - stuff a lot easier. Since we're
using tailwind with next Jas.
1085:28 - There's actually a wonderful
little guide here for installing
1085:31 - tailwind with next Jas. And
we're gonna go basically go
1085:34 - ahead and follow along with
this. This link is available in
1085:37 - the GitHub repo associated with
this course with this lesson. So
1085:40 - we've already created our
project we've seeded into our
1085:42 - project. Now we're gonna go
ahead and install tailwind npm
1085:46 - install dash D instead, since
we're using yarn, we're going to
1085:49 - do yarn or pop this open, green
new yarn, add dash dash Dev,
1085:56 - paste those three in tailwind
CSS, post CSS and then
1085:59 - autoprefixer and it's the three
of these that are going to
1086:02 - basically make up tailwind with
next Jas. Once we have those
1086:06 - we're going to basically init
tailwind and make a config file
1086:09 - for tailwind. So we're gonna do
yarn tailwind CSS and it does p
1086:13 - yarn tailwind CSS init dash P
will run that. This is going to
1086:18 - give us this post CSS dot config
dot j s and this tailwind dot
1086:23 - config dot j s and what we're
going to want to do is literally
1086:26 - just hit this copy button, and
we're going to update our
1086:29 - tailwind.config.js tailwind Jas
so that it says okay, all of
1086:35 - this stuff, anything in Pages
anything with.js.ts dot JSX or
1086:40 - TSX. And anything in these
components, anything in those
1086:43 - two folders is going to be
considered tailwind double. We
1086:47 - want to use tailwind on these
two folders. Then we're going to
1086:49 - add the tailwind directives to
our global CSS files. So if we
1086:54 - go back, we're going to styles
Global's we're going to
1086:57 - overwrite everything in here
with ADD tailwind base and add
1087:01 - tailwind components at tailwind
utilities. And this makes it so
1087:03 - that our global CSS file uses
tailwind. Now, you'll see like
1087:07 - unknown rule at tailwind, what
we can do is we can go to
1087:10 - components, what we can do is we
can look up this post CSS
1087:14 - language support extension,
paste that in here, boom, let's
1087:18 - go ahead and install this. And
now we get those little
1087:20 - underscores to go away, which is
really nice. Now, per usual, we
1087:24 - can just do NPM, run Dev and
start adding tailwind to our
1087:27 - divs. Now what tailwind does is
allows us in our divs to set
1087:32 - everything as a class name, and
then just set some real
1087:35 - minimalistic text in these class
names here. So let's look at our
1087:38 - smart contract lottery here.
We've just tailwind did it. So
1087:41 - it already has been updated a
little bit. Let's update our
1087:44 - header here. Well, let's see. We
want to give our header a border
1087:46 - from the tailwind. We'll do a
quick search. Look a border we
1087:52 - can see all this border stuff
like border width border this
1087:55 - border that say we want a border
on the bottom, we can see we can
1088:00 - get a border on the bottom with
something like this. Let's do
1088:03 - border on the bottom with a
width of two pixels. We just do
1088:07 - border b two. So I'm going to
copy border B to do border b
1088:11 - two, I'm going to save it and
what we need to do for our CSS
1088:14 - and everything to take effect.
Go ahead and kill the front end.
1088:18 - And then we'll rerun it with
yarn Dev. Go back to our front
1088:20 - end now. Give it a little
refresh and Okay, cool. Now we
1088:24 - have a little border here. So
we're starting to add some stuff
1088:27 - and it's just not a whole lot
yet. Oh, and then we can also
1088:31 - add tailwind to me go to
Extensions. We can also look up
1088:35 - tailwind. There's a tailwind
extension here. So I'm just
1088:38 - going to add a whole bunch of
stuff in here. We're gonna do
1088:40 - flex, flex row.
1088:44 - We're gonna make our
decentralized lottery and h one
1088:48 - which stands for like header
one. Do class name equals, we'll
1088:53 - do the y dash force. We'll give
it padding the top of form the X
1088:59 - padding on the x axis of four.
We'll make it bold font and
1089:03 - we'll make the text three XL
size. So we'll make everything
1089:06 - bigger. Cool. Then we'll do one
more, we'll wrap our Connect
1089:11 - button in a div. So we'll say
div class name equals, and we'll
1089:16 - give it a an automatic left
margin. We'll do py too. So some
1089:21 - y padding, some x padding. See
what we have done. Okay. Now if
1089:27 - we zoom out a little bit, we can
see, if we close this too, we
1089:31 - can see now our Connect button
is on the side here. And they're
1089:34 - kind of separated like that. And
I think that looks nice. So
1089:36 - we're going to keep that now
we're going to go back to our
1089:39 - lottery entrance, we're going to
change this up just a hair,
1089:42 - we'll say div class name equals
P. Five, we'll make our button
1089:48 - look really nice. We'll say
class name equals background
1089:53 - blue 500. When we hover over, it
will say, background blue 700.
1090:00 - So now if I just say that, and
when we hover over it, it looks
1090:03 - a little different, that's
really nice. We'll say text is
1090:07 - white, we'll say the font is
bold, we'll give it some white
1090:12 - padding, I'll give it some x
padding, we'll have the bunbee
1090:16 - rounded, and we'll give it a
margin left auto, now looks a
1090:20 - lot better, right? That's a lot
prettier. We're just going to be
1090:22 - doing some basic CSS here just
to make it look a little bit
1090:25 - nicer, right, but just that by
itself already made this lottery
1090:28 - button look a lot cooler. Now
some functionality that we
1090:31 - didn't add here. So we need to
add a disabled, kind of like
1090:34 - what we did before. And in our
enter a raffle it comes with,
1090:39 - like I said, is loading and it
is fetching. None of our
1090:43 - transaction is loading or
fetching, we'll just make this
1090:45 - disabled. So we'll say is
loading or is fetching this will
1090:50 - be disabled. Right? Now, if we
go back to the front, we hit
1090:52 - enter raffle, go ahead and hit
confirm, we can add a CSS for
1090:57 - it. But when a transaction is
loading, they will not be able
1091:00 - to click that button anymore,
which that's something else
1091:02 - pretty that we want to do
speaking of is loading and is
1091:05 - fetching. When it's loading or
fetching, we probably want it to
1091:09 - have that like little spinny
thing right when we hit it right
1091:11 - now. And mash is pops up. And we
can confirm but it would be cool
1091:15 - if it had like a little spinny
thing here, right. So you can
1091:18 - usually just Google like how to
add spinny thing or stuff like
1091:22 - that, and you'll get something.
But you can again, you can just
1091:25 - copy paste this from my code,
I'm going to show you what I
1091:27 - ended up doing for this section.
And we're gonna say is, if is
1091:31 - loading or is fetching. And
we're going to use that ternary
1091:35 - operator all the time, then in
here, we're going to do a little
1091:39 - div. And otherwise, we're going
to do a different div for
1091:43 - loading or for fetching, we're
going to add like a little
1091:44 - spinny thing in here. So we're
going to add class name equals.
1091:54 - If we're loading, we're going to
add this little spinny thing,
1091:56 - which I'll show you what it
looks like in a second. And if
1091:59 - we're not loading, we're just
gonna do enter, raffle like
1092:02 - that. So we'll come back to the
front end, see answer raffle,
1092:06 - we'll click the button. Now we
get this cute little spinny
1092:08 - thing, confirm transaction goes
through. So anything goes away.
1092:12 - Nice. Well, let's put these on
different lines. So we'll just
1092:15 - do
1092:23 - so those will be on different
lines. Now boom, entrance fee,
1092:26 - number players recent winner,
once a lottery now will confirm
1092:32 - transaction complete number of
players has gone up and we have
1092:35 - done it. Now this looks a lot
nicer. It's clearly not perfect,
1092:38 - but it's much easier to read
than kind of that lump that we
1092:41 - had before. And the reason I
wanted to show you this was
1092:43 - really just kind of giving you
your footholds for making these
1092:46 - look a little bit nicer. This
definitely isn't a CSS course.
1092:52 - Oh, wow. Okay, this is
phenomenal. We have an app that
1092:56 - we really like. And we're like,
you know what, we want to deploy
1092:59 - this bad, Larry, let's talk
about how we can deploy this,
1093:02 - this section is going to be
optional, okay, because I'm
1093:04 - going to deploy something to
rank B and deploying to test
1093:06 - sets can take a long time. So
we're going to deploy our
1093:09 - contracts to rink B. And then
we're going to deploy our
1093:12 - website to a hosting provider.
So first, let's talk about
1093:16 - hosting providers for a quick
second, if we want to host our
1093:19 - beautiful website that we just
created, there are ways to
1093:22 - deploy it using things like for
cell or Google Cloud, or AWS.
1093:26 - Nettle. Phi is another really
popular one there, all these
1093:28 - different places that we can
deploy our application. Now, the
1093:31 - thing about these though, is
that these are all centralized
1093:34 - deployment places, having a
centralized deployment
1093:37 - application can still be
incredibly important, right? If
1093:40 - we look at ether scan for a
second ether scan is a
1093:42 - centralized application right at
the end of the day, but it's
1093:45 - still one that we've been using
a lot. However, if we want to
1093:48 - have a front end that's
decentralized. Well, that's a
1093:50 - little bit harder. The more
important thing for us is that
1093:53 - our back end, our smart
contracts are decentralized,
1093:56 - right? That's the most important
thing because that will give
1093:58 - users the ability to interact
with our logic in a
1094:00 - decentralized way. But maybe we
also want our front ends
1094:03 - decentralized. Now at some point
we will still use a centralized
1094:07 - service Like VSL to deploy an
application, and I'll show you
1094:10 - why when we get there, there's
some features that right now,
1094:14 - they're really just hard to do
without like a really solid
1094:16 - centralized back end. What's
important to keep in mind is
1094:20 - that our back end, the logic of
our contract is on a
1094:24 - decentralized blockchain. So
even if we host the front end on
1094:28 - a centralized hosting provider,
using some type of centralized
1094:32 - database to make the front end
easier to work with, the logic
1094:36 - of the application is
decentralized. And that's the
1094:39 - most important piece. So I'm
going to give you some tools
1094:42 - later on, and how to introduce
more of these feature richness.
1094:46 - If you choose to do so doing so
will add a centralized component
1094:50 - on your front end. And it's
something to keep in mind,
1094:53 - depending on how you want your
architecture. So when doing that
1094:56 - just be absolutely sure that the
smart contracts on the back end
1095:00 - are deployed are decentralized
on one of these blockchains.
1095:04 - Now, we'll learn about some of
those centralized ways to do
1095:07 - that in a later section. For
now, let's learn how to deploy
1095:11 - this front end in a more
decentralized way.
1095:16 - And the tool that we're going to
use is a tool called IPFS. Now,
1095:20 - let me explain a little bit
about how IPFS works. It's this
1095:24 - distributed decentralized data
structure. That's not exactly a
1095:29 - blockchain. But it's similar to
a blockchain. There's no mining,
1095:32 - though. But there is pinning
data, you can add data to this.
1095:35 - So let me explain how this
actually works. And you can read
1095:38 - how this works on the site,
there's going to be a link to
1095:40 - this and the GitHub repo
associated with this course. But
1095:42 - we give you my basic take on it.
So we have our code, or our
1095:46 - file, or whatever it is, right,
we have some piece of data. Now
1095:50 - as we know, when you really have
anything, you can hash that
1095:53 - thing, you can hash that data,
right, so you can get a unique
1095:57 - output. So and that's actually
the first thing that IPFS does.
1096:00 - It hashes our data to get a
unique hash, that only points to
1096:04 - that data. Yes, a massive code
file a ton of text. Yes, you can
1096:09 - encode all of that into a single
hash function, your IPFS node
1096:13 - does this hashing for you. And
every single IPFS node on the
1096:17 - planet has the exact same
hashing function, kind of like a
1096:21 - blockchain, right, they all kind
of run this same spec, the same
1096:25 - specification. So we can hash
our data on our IPFS node and
1096:29 - get this unique output. What we
can do then is we can pin that
1096:32 - data or pin that code, or pin
that file or pin that whatever,
1096:36 - to our node, we have some data,
we get a unique hash of it, all
1096:40 - it does is host this data and
have these hashes. That's it,
1096:43 - our node is connected to a
network of other IPFS nodes. So
1096:48 - there's a massive network of
people running IPFS nodes,
1096:51 - they're incredibly lightweight,
way lighter weight than any
1096:54 - other blockchain node. And they
all talk to each other. So if I
1096:57 - asked the network, hey, I want
to get this hash. All these
1097:00 - nodes would talk to each other.
And eventually they'd reach up
1097:03 - at our node saying, Oh, I found
a node that has that hash.
1097:07 - Here's the file associated with
it. Now, you might be thinking,
1097:09 - Okay, well, that's kind of
centralized, because we have the
1097:12 - data on one node here, right?
Well, you're right, well, here's
1097:15 - the thing, what other nodes can
do is they can say, oh, that
1097:20 - data looks really cool, I want
to have that persist, what they
1097:24 - can do is they can pin your
hash, they can pin your data,
1097:27 - and they'll get a copy of your
data on their node. And you can
1097:31 - keep doing this. And so you
easily allow an entire network
1097:36 - to easily replicate any code or
any data in a decentralized
1097:40 - sense. And they're incredibly
easy to spin up. And they're
1097:42 - incredibly easy to work with
something about IPFS, that makes
1097:46 - it drastically different than a
blockchain is the can't do smart
1097:49 - contract, there's no execution,
it can really only store it's
1097:52 - just decentralized storage that
IPFS can do. Now, the issue here
1097:57 - is that in order for our data to
really be decentralized, another
1098:00 - node does need to pin our data,
right? Because if we're the only
1098:04 - IPFS node that's got this hash,
it's kind of centralized on our
1098:08 - node, if our node goes down,
that data is gone, and the
1098:11 - network won't be able to access
that data anymore. So we'll talk
1098:14 - about strategies in the future
about having other people pin
1098:17 - your data. But for now, this is
a way we can host data, we can
1098:21 - send code and have it be in a
decentralized context. So unlike
1098:25 - a blockchain, where every single
node in a blockchain is going to
1098:29 - have a copy of the entire
blockchain IPFS nodes get to
1098:33 - optionally choose which data
they want to pin, and they can't
1098:37 - do any execution. So you could
have an IPFS node, half a
1098:39 - megabyte, and you could have an
IPFS node, that several
1098:42 - terabytes, it's up to the node
operators, how much data and
1098:46 - what data they want to pin. Now
that we know about IPFS.
1098:52 - Let's actually deploy our
wonderful application to IPFS so
1098:57 - that anybody can use it and
anybody can connect to it. So
1099:00 - long as our node is up. Are you
ready? Okay, get excited here.
1099:05 - We're first going to do this
kind of the Manuel Wait, because
1099:08 - I'm going to show you how to
install IPFS. And work with
1099:10 - IPFS. Hit get started, there's a
number of ways to install and
1099:14 - work with IPFS, you can get it
with a desktop application, get
1099:18 - a command line. And then we can
also add IPFS to our browser
1099:23 - using something like brave or I
think Firefox to some this IPFS
1099:28 - router is automatically built
it. But if using something like
1099:30 - Chrome, you might have to add a
little companion, because what
1099:33 - we want to do is we can actually
use those little hashes as URLs
1099:37 - for websites, right, and so we
want to be able to put that URL
1099:41 - in our browser and connect to
that node or that piece of code.
1099:45 - So what we're gonna do is we're
gonna have you install the IPFS
1099:48 - desktop, so you're gonna hit
that. And when you do that, you
1099:51 - should be able to open up IPFS.
Now, if you install it, you
1099:54 - might get this little guy, this
little box here in your upper
1099:58 - section. Otherwise, you might be
able to open it up with with
1100:01 - IPFS desktop and see it as a
regular desktop app. Well, once
1100:04 - you install it, you might see
IPFS is running, you can restart
1100:08 - stop, you can do all this stuff,
we're gonna go to the file
1100:11 - section, and we're gonna get a
little pop up that looks like
1100:15 - this. Now, I've got a ton of
stuff in here, because I've been
1100:17 - using IPFS for some time in
here, right now, you might have
1100:20 - no data. So let's just go ahead
and import some file. And maybe
1100:24 - for now we'll just import, you
know, our next dot config dot j
1100:27 - s, right? It doesn't matter,
just import something. And now
1100:30 - in here, we have this next dot
config dot j s or whatever file
1100:34 - you import it. So what we can do
with this is we can actually
1100:37 - copy the CID. And we can view
this in our browser. So if we do
1100:43 - IPFS dot dot slash slash, and we
paste it in, we hit enter, we
1100:47 - can give our browser access to
actually rendering IPFS URLs. If
1100:53 - using brave, you can just do use
a brave local IPFS node or let's
1100:57 - go ahead and download this IPFS
companion. So we'll get IPFS
1101:00 - companion, there's a Firefox
install for Chrome brave, blah,
1101:04 - blah, blah. So I'm gonna go to
the Chrome store to get it for
1101:07 - brave, we're just going to hit
Add to brave add extension. But
1101:11 - once you download it, you'll get
something that looks like this.
1101:13 - Even on a little browser
companion, we can see like
1101:16 - import, we can see stuff about
our node, if we click our node,
1101:19 - we will see a very similar
setup. But now that we have the
1101:22 - companion in our browser, we can
copy that Cid that hash. Now
1101:27 - brave, we can just do use brave
local IPFS node, and will
1101:30 - automatically get dropped into
the file. Now, if IPFS companion
1101:35 - doesn't work for you, and you
can't see the URL inside of
1101:38 - something like Google Chrome or
some other browser, what you can
1101:42 - do is you can use something
called the IPFS gateway. Now
1101:45 - using a gateway, you're not
actually directly requesting the
1101:49 - data through IPFS requesting the
data through another server,
1101:53 - which is requesting it through
IPFS. But if you are having some
1101:56 - trouble accessing these files,
you can use the gateway. So what
1102:00 - you'll do is we'll do HTTPS,
1102:05 - slash IPFS, slash and then paste
the hash code there. And you'll
1102:11 - be able to see your file. Now if
you do it like this, you won't
1102:14 - even need IPFS companion at all.
So we're going to deploy our
1102:17 - website to IPFS. So that anybody
else who wants to pin this can,
1102:22 - and we will now have the ability
to have an incorruptible, in
1102:26 - unputdownable website, which is
just awesome. We're going to
1102:29 - learn how to do this the wrong
way first, and then we're going
1102:32 - to use a tool that's going to
make it a lot easier for us.
1102:34 - Okay, so first, let's go to our
website here. And, and if you
1102:39 - want to deploy to rink B, go
ahead and feel free. Just
1102:41 - remember to make sure that your
contract addresses file updates
1102:46 - accordingly. Okay. Now, next,
Jas has the ability to create
1102:50 - static websites. And that's
going to be an important term to
1102:54 - know we're going to make a
static website. At the moment,
1102:57 - we don't want our website to be
tangled with any server stuff.
1103:02 - And the reason we we don't want
it to be tangled with any server
1103:05 - stuff is because if our website
runs with server stuff, and we
1103:07 - deploy it to IPFS, will IPFS
doesn't have the ability to run
1103:11 - any code, it just hosts code. If
our front end has any server
1103:14 - stuff, it won't work. Now, in
its current state IPFS can't
1103:18 - come to our project and know
what to do, right, it doesn't
1103:21 - know how to do yarn dev can't do
yarn Dev. So we need to put all
1103:24 - of our code into its static
equivalents. So to do that,
1103:28 - we're gonna do yarn build. And
if again, if we look at our
1103:32 - package dot JSON, it comes with
this build, which just runs next
1103:36 - build. And running this build
command is going to build our
1103:39 - code, what's called like a
production build, creating an
1103:42 - optimized production build here.
And we'll get something that
1103:46 - looks like this. And we can see
this point down here. Static,
1103:49 - automatically rendered as static
HTML uses no initial props.
1103:53 - There's some server based
applications that next Jas comes
1103:57 - with that if we use them. Our
static build won't work. And
1104:00 - actually, you'll see when we run
yarn, next export, it'll fail if
1104:05 - you have any that non static
stuff. So let's Go ahead and try
1104:08 - yarn next export. And let's see
if it fails, it didn't fail, we
1104:11 - now have a new folder called
out. And this is our folder,
1104:15 - that's just pure static code and
that we can use on IPFS. In a
1104:19 - later section, I'll show you
what it looks like when you
1104:22 - don't use some of those static
things. Both Morales and next
1104:25 - Jas have the optionality to not
have static code. So we'll just
1104:28 - want to keep that in mind. So
now that we have this out
1104:31 - folder, we can go back to IPFS.
And we can import a folder,
1104:35 - we're going to import that whole
folder in here. So hit that hit
1104:39 - that import button and go to the
folder. Where that is mine is in
1104:43 - next year smart contract lottery
out. So now we're going to
1104:47 - upload this to our IPFS node.
Once it's done, we'll get this
1104:50 - little checkmark. And we can go
through IPFS files and see our
1104:54 - output here. What we can do,
let's go ahead and pin this to
1104:58 - our node, we'll pin it to our
local node here. And now once
1105:01 - it's up, we can copy the CID and
go back to brave or chrome or
1105:05 - whatever. You type in IPFS colon
slash slash, paste that in
1105:11 - there. And we immediately get
dropped into our smart contract
1105:15 - lottery in a browser. And we see
hi from lottery, no raffle
1105:19 - address detected, because right
now the way I set mine up Was it
1105:22 - only works with, you know, our
local hard hats, let's connect
1105:25 - our Metamask we'll hit the
connect button, connect, and
1105:29 - voila, we are right back where
we were. But with our data
1105:33 - stored in IPFS, we can enter
raffle as long as our node is
1105:37 - running a confirm. And we see
exactly what we get in our local
1105:41 - browsers. So this is phenomenal.
1105:46 - Now that I've shown you how to
do this, this is the manual way
1105:49 - of adding our code to IPFS. Let
me show you the easier way of
1105:54 - adding your code to IPFS we're
gonna go to this site called
1105:57 - fleek HQ. Go to fleek.co. And to
get to it, I'm going to turn my
1106:03 - my IPFS companion note off
because of some of the oddities
1106:06 - with working with brave but now
we're here@flickr.co fleek.co
1106:10 - makes it easy to to deploy
websites and apps to the new
1106:13 - open web permissionless,
trustless, censorship resistant,
1106:16 - etc. I like to think about it as
kind of like an auto deployment
1106:19 - for our websites. And
additionally, it does some
1106:22 - things to help out with that
problem. I was talking about how
1106:25 - we want to get other nodes to
pin our data. So it helps us out
1106:29 - with that. So let me show you
what it does. So let's go ahead,
1106:32 - we'll sign up. And why don't you
know, you can sign in with
1106:35 - GitHub. So if you have your
GitHub, definitely want to sign
1106:38 - in with GitHub here. Because
we're going to use GitHub to
1106:42 - actually help us automatically
deploy. So we'll authorize fleet
1106:46 - to work with our GitHub. You've
authorized your GitHub, let's go
1106:49 - ahead and add a new site or add
new site. Now we can use fleet
1106:52 - to just automatically deploy
websites, once we push them to
1106:55 - our GitHub. So we can come to
our GitHub once again. And click
1107:00 - the little plus button, we'll do
a new repository. We'll call
1107:03 - this next Jas smart contract,
lottery Free Code Camp. We'll
1107:09 - make it public create the
repository. Let's push all this
1107:15 - code to GitHub. We did it once
before, let's do it again. We'll
1107:18 - do git add, we'll do a little
dot, then we'll do git commit
1107:22 - minus m, say like initial commit
or whatever. We'll do git
1107:31 - remote, add origin, and then
we'll grab that URL, paste it
1107:39 - right here. And then we'll just
do git push origin, main. Now we
1107:45 - go back to our application we
see it in here we can do is back
1107:48 - in our fleek. We can connect
with GitHub, we're going to say
1107:52 - only select repositories, we're
only going to do this next js
1107:56 - application, this next JS get
we're going to install an
1107:59 - Authorize. Authorize Great. So
now we're going to pick a repo
1108:04 - we've picked a repo, we're going
to choose this application. And
1108:08 - we're going to use IPFS as our
hosting service. And now we're
1108:11 - going to add our information in
here. So we're going to use the
1108:14 - main branch. Here's the repo.
There's gonna be our framework
1108:18 - is gonna be next Jas. So we're
do fleek next. Jas, we're using
1108:23 - yarn. So we're gonna do yarn
install, and yarn, run build,
1108:28 - and then yarn run export. If you
want you could also just do
1108:32 - yarn, yarn build and yarn run
export, those are gonna be the
1108:35 - same thing. Publish directory is
going to be out and then we just
1108:38 - hit Deploy site, yarn, next
export as the last command, not
1108:43 - yarn, run, export. The accident
did the wrong one, you go over
1108:47 - deploys. Click on this, go to
deploy settings and then Edit
1108:51 - Settings and then just change it
to yarn. Next, export save. Then
1108:57 - we'll go back to deploys and
trigger deploy, if you did the
1108:59 - wrong one that was just a
learning opportunity for you to
1109:02 - learn where the settings are
after you deploy. And what this
1109:05 - is going to do is we're going to
do to deploy, it's going to run
1109:08 - those three commands yarn build,
yarn export, it's going to run
1109:11 - everything. And then it's going
to deploy a site for us both on
1109:14 - IPFS. And it's going to give a
regular URL that we can use for
1109:20 - normies, if you will. And while
this deploys, you'll actually
1109:24 - see down here we have this thing
called file coin di D in deal
1109:28 - proposal, Cid IPFS. Like I said,
we need other people to host our
1109:32 - node. File coin is actually a
blockchain that helps you pin
1109:36 - your data and uses decentralized
storage to do so. And fleek
1109:40 - helps you create those deals and
helps you pin your data with
1109:44 - this filecoin Blockchain
filecoin is one definitely to
1109:46 - take a look at. And then after a
while, you might have to wait a
1109:49 - little bit. And once it's done,
get a little deployed website,
1109:53 - we go back to hosting, we click
on our thing we can see we have
1109:58 - like a little website here. And
if we click it, we get a normal
1110:02 - URL for connecting and
interacting with our website,
1110:06 - you might even see this little
IPFS thing which will connect to
1110:09 - your IPFS node. And
additionally, we scroll down in
1110:12 - here we can see current IPFS
hash, so we can just stick that
1110:16 - in, um, and Bada bing, we have
an IP Fs deployed application.
1110:22 - Now what's cool is let's say I
make some changes, you know,
1110:25 - I'll go to lottery entrance. And
I'll do, I'll scroll on the
1110:29 - bottom to recent winner, I'll
make a new div. What a close the
1110:35 - div off, we'll save git add dot
Git commit minus m, add a dot
1110:42 - git push origin mean.
1110:46 - In our GitHub, we'll do a little
refresh, add a.as, the most
1110:50 - recently added one, go back over
to fleek. Go back to hosting
1110:54 - click on the section that we
just made go to deploys, and
1110:58 - you'll see there's a new deploy
going through. So it
1111:02 - automatically deploys your new
site, it'll automatically create
1111:05 - a new IPFS hash for your new
data. However, it'll still be on
1111:08 - this holy bird, you know, or
whatever your URL is here. And
1111:12 - this is kind of just a router
for IPSs. So that people without
1111:16 - IPFS connected can also connect
to this still. And now that my
1111:20 - application is done, pushing
automatically, with fleek, we
1111:23 - can see what's up being post in
my application here. Now, like I
1111:29 - said, filecoin isn't going to be
a technology, we're gonna go too
1111:32 - deep into introduce ourselves.
But like I was just saying IPFS
1111:36 - does have this limitation. It
doesn't have data persistence,
1111:41 - you have to have people pin your
data, in order for it to stay
1111:44 - distributed, and stay
decentralized. File coin is a
1111:48 - blockchain dedicated to keeping
this data, both decentralized
1111:52 - and persistent. And to give us a
better understanding of
1111:55 - filecoin. We actually have Ali
here to give us an overview.
1111:58 - Take it away, Ali. Hello, I'm
1112:00 - Ali, and I'm a developer
advocate here at the filecoin
1112:03 - Foundation, which works closely
with protocol labs and IPFS.
1112:07 - Just a quick note, protocol Labs
is our r&d arm. So it works on
1112:13 - creating tooling and technology
for a truly open and democratic
1112:17 - internet and web. And it's
building out some of the
1112:20 - foundational tooling like IPFS,
and filecoin, which are two
1112:23 - separate projects to enable
that. And hopefully, today,
1112:27 - because you're here to build, I
want to impart on you the
1112:30 - knowledge and tools you need to
get started with both of those
1112:32 - projects. So as anyone that's
kind of played around in this
1112:36 - ecosystem, or tech, in general
would know, data is an
1112:39 - absolutely essential part of our
daily lives. And not
1112:42 - surprisingly, it's also a super
fast growing field in web three,
1112:46 - and one, that's fundamental one,
and it's one of the fundamental
1112:49 - necessities of the decentralized
web stack as well. So the
1112:52 - current model of centralization
that's grown up, and basically
1112:56 - out of a lack of an identity
layer on the internet, is one
1112:59 - where only a few big companies
offer storage, and only a few
1113:02 - entities hold our data for
authorization purposes. And this
1113:05 - is an obvious problem, both in
terms of being an attack vector
1113:08 - for data mining, so without
data, getting leaked through
1113:12 - insecure service to third
parties, and also creating a
1113:17 - data resilience problem. So
whole services go down every
1113:20 - time one of these companies
servers does and we've
1113:22 - definitely seen that. So it
really leads to the question,
1113:26 - why aren't we designing the web
for the autonomy and resilience
1113:29 - we need in the first place? And
how do we store data in a way
1113:31 - that aligns with both the
original vision of the internet
1113:35 - as an open place for knowledge
sharing and collaboration, and,
1113:38 - and, and in a way that agrees
with the web three mission as
1113:43 - well. So these are the core
problems we're solving with IPFS
1113:46 - and file coin. Firstly, IPFS is
a distributed system for storing
1113:50 - and accessing files, folders,
websites, applications and data.
1113:54 - And it's designed to be able to
work even when the networks
1113:56 - between planets, so it's a
distributed by design, it has no
1114:00 - central authority servers, and
it's designed to be offline
1114:03 - first for resilience. And it's
not just a fancy name for
1114:05 - another peer to peer network
either. Because the nice thing
1114:08 - about the IPFS protocol is the
standard it uses for addressing
1114:12 - content on the network. IPFS is
unique because rather than using
1114:16 - traditional methods we might be
with familiar with from the web,
1114:20 - like those are location parts
that point to a particular HTTP
1114:24 - address where your content may
or may not be available and
1114:28 - stored. IPFS uses content
addressing so content addressing
1114:32 - means that each piece of data,
each meme or even full file
1114:36 - system has its own unique
cryptographically verifiable
1114:39 - fingerprint, you might call it.
So if you change even one pixel
1114:43 - of your main image, for example,
then the content ID or Cid
1114:47 - associated with it also changes.
So importantly, this hash
1114:52 - function is also upgradeable. So
let's say quantum computing
1114:55 - breaks out current secure hash
algorithms, we can upgrade the
1114:58 - standard we use. And it means
you will always get the same
1115:02 - content returned by an IPFS. Cid
as what you expect. So this is
1115:07 - fundamentally important, because
when you don't have to care
1115:10 - where the data comes from, you
open up the web to massively
1115:14 - distributed storage systems.
Hello, decentralization. So now
1115:18 - we have a really important and
valuable protocol that enables
1115:21 - distribution at scale. And it
provides verifiability of data
1115:25 - to serve and retrieve content on
the web. And not just for web
1115:28 - three, either, but also for all
web, or tech use cases. The
1115:33 - problem is, and it's one that
the early internet also faced,
1115:36 - who's going to ensure the
persistence and permanence of
1115:39 - all this data on the network. So
unless you're running your own
1115:42 - nodes 24/7, or your content is
really popular or other nodes
1115:46 - decide to altruistically store
your data. Because I think it's
1115:49 - important, then this data can
become unreliable because
1115:53 - they're no longer actively
hosted on any nodes on the
1115:55 - network's. So to avoid this, you
could also turn to a pinning
1115:58 - service that you pay to keep a
copy of your content around.
1116:02 - Unfortunately, the problem with
this though, is that we're
1116:04 - heading back towards
centralization of data. And
1116:07 - we're creating new data silos
with this solution and losing
1116:11 - the trust lessness and
resilience we're looking for.
1116:13 - And these one a bad solution
prior to file coin, and it's why
1116:18 - they sprung up initially, but we
want a better solution. So this
1116:22 - is where file coin comes in. So
far coins architecture, then
1116:26 - designed to leverage a crypto
economic incentive model
1116:29 - together with cryptographic
proofs in order to ensure data
1116:33 - is stored persistently, highly
reliably and verifiably. It uses
1116:38 - these cryptographic proofs to
also enable smart contract based
1116:41 - permanence. And that means that
it's designed to be as permanent
1116:45 - as you, the data owner want it
to be. It's your data, so it's
1116:48 - your choice. It's also designed
to enable internet scale
1116:52 - capacity. It's currently the
largest distributed storage
1116:55 - network in the world with over
18 million terabytes of capacity
1117:00 - available, which is apparently
about 135 copies of the European
1117:05 - Union's nuclear program, CERN's
data which, which is kind of a
1117:09 - fun fact. It's also file coins
also designed to be and stay
1117:14 - hyper competitive on pricing due
to its market economics. And
1117:19 - this comes down to storage
deals. So to make this network
1117:23 - feasible, filecoin uses storage
deals. And these include two
1117:27 - main consensus mechanisms that
ensure both rewards for good
1117:30 - actors in the system, and
penalties for bad actors. So
1117:33 - when you make a deal with one or
more storage providers to store
1117:36 - your important data, the
provider generates a proof of
1117:39 - replication. So this proves that
the storage provider is storing
1117:43 - a unique copy of your original
data over time to make sure that
1117:48 - this data is persisted. These
storage providers must prove
1117:53 - that they still have random
subsets of this client data and
1117:56 - they create proof of space
times. And these proof this
1117:59 - proof of space time is something
that is stored on the
1118:04 - blockchain. So anyone at any
time can also check that this is
1118:07 - true. And it also makes up the
mechanism by which miners are
1118:11 - rewarded or penalized because
you have to stake Phil on the
1118:15 - network in order to become a
storage provider. So when a
1118:19 - storage deal comes to an end, or
user can you can opt to let it
1118:24 - expire or renew the deal. If you
opt for renewal, then the
1118:27 - providers again bid to host this
content. So this creates an
1118:31 - efficient market for pricing a
continual efficient market for
1118:34 - pricing as well. It can even go
negative. So the storage
1118:38 - provider can even pay you to
store your data if it's an
1118:40 - important data set due to some
of the block rewards that are
1118:43 - being offered by the filecoin
Foundation as well. So these
1118:48 - mechanisms are what built in not
just data permanence, but data
1118:52 - timeframes, sovereignty, too so
it's your data, it's your
1118:55 - choice. You can decide you want
to store your data for five
1118:57 - minutes or 500 years. It's also
your choice over how much
1119:01 - resilience you want to have that
data so or how many copies of
1119:05 - that data you want to have and
with what store to providers. So
1119:08 - this allows you to comply with
regulations like GDPR. And
1119:13 - there's a growing number of
tools in the ecosystem like
1119:15 - murmurations bit screen that are
allowing for you to do this
1119:19 - filtering. But it also gives you
some guarantees that your data,
1119:24 - you know, if one storage
provided goes down, you know,
1119:27 - surely not 10 of them are going
to go down. So that's a
1119:30 - guarantee for your resilience
there as well.
1119:34 - And this is why IPFS and
filecoin are great complements
1119:36 - of each other. So IPF s gives
you that benefit of content
1119:40 - addressing file coin gives you
persistent guarantees that even
1119:43 - if your computer or your
favorite IPFS pinning service
1119:45 - where to go away, the content
persists. Just as a quick final
1119:50 - note on these concepts as well,
IPFS and file coin is separate
1119:53 - projects, as I mentioned. So
IPFS is a protocol much like
1119:57 - HTTP, whereas file coin is a
blockchain. So IPFS is also
1120:02 - storage layer agnostic, you can
combine it with the storage
1120:05 - layer of your choice. And while
file coin was specifically
1120:08 - designed to complement it, and
we think is a great choice, you
1120:11 - can also store your IPFS data in
the cloud or an other storage
1120:15 - solutions as well. So hopefully,
you've got a good baseline for
1120:19 - why you'd want to use IPFS, and
filecoin. And for those
1120:22 - engineers out there that like a
challenge, and are interested in
1120:25 - working on the base protocols
and code of IPFS, and file coin,
1120:30 - which isn't always easy for the
average user, I'd encourage you
1120:33 - to go and take a look at the
project docs and get hubs and
1120:36 - some of the associated grants
available for extensions to
1120:39 - these open source projects. And
this is a great site here if you
1120:42 - want to get more information
into the nitty gritty and really
1120:45 - dig into the code behind IPFS
and filecoin. And extend some of
1120:49 - that. For those of you that just
want to build out of the box
1120:52 - though. And this is definitely a
camp that I often fall into. I
1120:55 - want to talk about some of the
dev tooling and storage helpers
1120:57 - that make it easy for you to get
started. So firstly, Flake Flake
1121:01 - is one of my favorite IPFS dev
tools. And projects Flake is a
1121:04 - CI CD tool that you can use to
deploy your apps for free as
1121:09 - simply as easy as you would with
some of the web tools you might
1121:12 - web to tools you might be
familiar with like Netlify
1121:16 - oversell. The big difference,
though, is fleek uses IPFS to
1121:20 - host your site or app. And it
even offers an AES domain
1121:23 - routing on their platform. So if
you're deploying a front end
1121:26 - app, I would encourage you to
use fleek to make it more
1121:29 - distributed instead of some of
the traditional web two tools.
1121:33 - It's just as easy, I promise. So
another one of my favorite tools
1121:37 - is NFT storage, storing your NFT
metadata immutably and
1121:41 - persistently, as you already
probably know, is integral to
1121:45 - keeping the main value
proposition of NF Ts, then on
1121:48 - fungibility. So if you're not
storing this data on chain,
1121:53 - which obviously can become
pretty financially unviable for
1121:57 - large files, then this is
exactly where NF T storage comes
1122:00 - in. So it was specifically
created as a public good to
1122:03 - archive and persist NF T data.
So it's free. And it takes care
1122:07 - of the complexity around firstly
creating an IPFS Cid for this
1122:11 - metadata, and then making
automatic deals with filecoin
1122:15 - storage providers. So it does
this with at least eight storage
1122:19 - providers. So eight times
redundancy and it does it with a
1122:21 - multigenerational timeframe. So
it automatically renews those
1122:25 - deals. Because it's a public
good, it's all free as well. And
1122:28 - it's also super easy to use,
because you just need because
1122:31 - it's a JavaScript service. So
you just need to say import that
1122:36 - as an NPM package or JavaScript
library and then call the API
1122:39 - and NFT dot storage takes care
of the rest. For data that isn't
1122:45 - NF T metadata as well, we built
web three dot storage, web three
1122:48 - storage is designed to give you
those same web two benefits. So
1122:53 - similar to NF T dot storage,
make it super easy for you to
1122:56 - use. And it's got JavaScript and
go client libraries.
1123:02 - While giving you you know the
power of IPFS and filecoin of
1123:05 - decentralized storage and IPFS
content addressing so it's got
1123:09 - one terabyte after terabyte, one
terabyte of free storage with
1123:12 - that. So try that out if you're
not just like trying to store
1123:15 - and obtain metadata. The next
tool is a bit more advanced.
1123:20 - It's called textil Palghat gate,
and it's for you know, more
1123:23 - advanced developers or those
looking for more flexibility to
1123:27 - interact with IPFS live peer to
peer and filecoin. It's a Docker
1123:31 - container wrapped around
filecoin and IPFS nodes. And it
1123:35 - gives you a lot of options to
configure it's a minor
1123:37 - selections and extend
functionality. It also offers
1123:40 - some bridges to several layer
ones which might be of interest
1123:43 - to developers out there. Another
one here and I'll preface this
1123:49 - by saying you need an invite to
this is ESRI tech. So it's for
1123:52 - people looking to store really
meaningful public data. It's
1123:56 - currently in alpha mode and like
I said, it requires an invite
1124:00 - because it's been built as a
public goods specifically to
1124:03 - store important information. If
you are I do have Use case
1124:07 - around this slide, please feel
free to reach out to us on this
1124:11 - project. Other final tool I'll
mention is orbit dB. So many
1124:16 - people coming to the web three
space from web two are often
1124:19 - looking for the same sort of
relational databases that we're
1124:22 - so used to in traditional
computing except in a
1124:25 - decentralized or distributed
format. And this isn't an easy
1124:30 - problem. So Oba to me is
currently in active development.
1124:33 - And because this isn't an easy
problem to solve, this isn't an
1124:37 - ideal solution for those of you
looking for an out of the box
1124:40 - experience. But if you are
looking for something like that,
1124:44 - try out orbit dB. And there's
also several other tools in the
1124:47 - ecosystem leveraging IPFS and
filecoin, including ceramic,
1124:51 - which is similar to textil power
gate, except it uses
1124:55 - decentralized identities.
Lighthouse is file drive, and
1124:58 - there's even Morales has an IPFS
API, so check those out as well.
1125:04 - So storage is really a
fundamental component on one
1125:07 - technology system. So and
there's so many use cases you
1125:10 - could dive into here. And so
hopefully, I've provided you
1125:13 - with some of the knowledge and
tools you need to get started
1125:15 - with IPFS and file Goyt. Coin
and really make powerful
1125:19 - distributed applications. And
there's just one more tool
1125:23 - that's also in active
development now. So if you look
1125:26 - closely at this diagram, you'll
notice probably unfamiliar logo
1125:29 - right at the end of the logic
layer. And that's the logo for
1125:32 - the filecoin virtual machine. So
FBM will be launching at the end
1125:36 - of this year. And we're super
excited about it. And it's going
1125:40 - to allow smart contracts,
contract use combined with like
1125:44 - colocation of storage data,
loads, so computing capabilities
1125:48 - with storage capabilities, and
will also be EVM compatible. So
1125:51 - as I said, we're super excited
for the kinds of use cases that
1125:54 - we're going to see come out of
this project as well. And you
1125:58 - can follow along here on the
website here as well. So
1126:02 - hopefully, I've given you all
the tools you need to get
1126:04 - started with IPFS. And file
coin. If you do need more
1126:08 - resources or want to get
involved, we have proto School,
1126:11 - which is interactive tutorials
on decentralized web protocols.
1126:14 - There's also NFT, school dot
Dev, or join a hackathon, check
1126:19 - out our hackathons.filecoin.io
page for all the latest
1126:22 - hackathons we're involved in.
And if you do really want to dig
1126:25 - deep and build tooling in IPFS,
and file coin or build a cool
1126:30 - project, check out our grants
options as well for that, in the
1126:34 - meantime, all please learn long
build and prosper.
1126:42 - So we've learned a ton in this
section. And that is it. So
1126:46 - let's do a summary of all the
amazing things that we've
1126:49 - learned. And then we'll go into
the TypeScript edition of this
1126:52 - because the TypeScript edition
is definitely a little bit
1126:55 - different. So let's talk.
Alright, so first, we learned
1126:58 - more about next Jas. And we
learned we can have an
1127:00 - application using next Jas. And
it's a framework that's gonna
1127:04 - allow us to build really
powerful front ends and full
1127:06 - stack applications really
easily. We learned about the
1127:10 - layout of our next JS project,
we add components in a
1127:13 - components folder, which are
basically minimalistic blocks of
1127:17 - JavaScript and HTML that we can
use to modularize and create our
1127:21 - website out of these components.
Constants is a folder that we
1127:24 - can put constant variables, Node
modules is node modules. And out
1127:29 - folders. What happens when we
export all of our code to a
1127:32 - static example, pages are going
to be basically the routes or
1127:35 - the different pages of our
website, everything goes through
1127:38 - app.js. Public is just some
public stuff styles is for any
1127:43 - CSS or styling of our
application. And then we have
1127:47 - our basic files here. In our
pages section, we have our app,
1127:52 - which is surrounded by both this
notification provider and our
1127:55 - Morales provider, all of our
components run through this app
1127:59 - on all of our pages run through
this app. So this is kind of
1128:03 - considered the entry point for
our entire application. Having
1128:07 - this Morales provider wrapped
around our notifications in
1128:10 - component means that we don't
have to pass parameters between
1128:15 - our components. And our lottery
will just know what chain ID
1128:18 - that we're on, because our
header is going to pass it up to
1128:21 - Morales provider and the Morales
provider is going to pass it
1128:23 - back down to our lottery
entrance. And we saw with our
1128:27 - manual header, the way that that
connect button works behind the
1128:30 - scenes. So it's doing some local
storage, where we're storing
1128:33 - whether or not we're actually
connected, we learned about use
1128:35 - effect, and you state and these
different hooks in our front
1128:39 - ends were one of the main
reasons we want hooks is we want
1128:42 - we want our websites to
rerender. When stuff changes, we
1128:45 - want our components to be able
to talk about the state of the
1128:49 - blockchain with each other. And
they're incredibly powerful for
1128:52 - building our React applications.
Use effect is one of the most
1128:55 - popular ones where if we don't
have a dependency array, our
1128:58 - function inside of our use
effect will run anytime
1129:02 - something re renders a blank
dependency array means it'll
1129:06 - just run once on load. And if
there are dependencies in the
1129:09 - array, it'll run any time any of
the variables in those change.
1129:14 - We also learned about the use
state hook, which is really
1129:18 - similar to saying like, let
variable equals x. But it also
1129:21 - comes with the RE rendering
ability. And it comes with some
1129:24 - other nice abilities that we
didn't really discuss here, we
1129:26 - learned how to call different
contract functions with
1129:29 - mirallas. Not only sending
transactions, but also calling
1129:33 - data. Morales is smart enough to
know that when it sees get
1129:36 - entrance fee that this is going
to be a view function. And this
1129:40 - is going to be a transaction, it
can tell the difference between
1129:42 - the two. So this one's going to
populate Metamask to pop up. And
1129:45 - this one just going to return
kind of normally like a view
1129:48 - function, what we can actually
use the same syntax between
1129:51 - sending transactions and then
calling view functions on our
1129:54 - contract, we added a button,
calling one of these Morales
1129:57 - pieces and then had an onsuccess
section where when our
1130:01 - transaction completed, we update
the UI and we add a little pop
1130:05 - up for notifications, we learned
how to deploy our code directly
1130:08 - to IPFS. And use that IPFS hash
to interact and see our code, we
1130:14 - also learned about fleek and how
fleek automatically deploys to
1130:18 - IPFS. Whenever we do a git push
to our GitHub repository, and it
1130:22 - makes continuously updating our
websites much easier. It also
1130:26 - gives us a regular canonical URL
as well. And then finally, we
1130:30 - learned about IPFS and
decentralized database storage.
1130:33 - Now you might be asking, Okay,
well, why don't we just store
1130:36 - all the data for this website on
Aetherium, or polygon or
1130:39 - avalanche, etc? And the answer
to that is that can get
1130:41 - incredibly expensive storing
data, storing a ton of data on
1130:45 - the blockchain costs a ton of
gas, whereas this is a much
1130:50 - cheaper alternative. Aetherium
avalanche and the smart contract
1130:53 - platforms aren't really meant to
be data storage layers, they're
1130:57 - meant to be logic layers, right?
Decentralized logic,
1131:00 - decentralized smart contracts,
oftentimes, yes, we're gonna
1131:03 - have to store data in them. But
when it's a ton of data, there
1131:06 - are better solutions. And there
are different solutions out
1131:08 - there for storing our data, like
IPFS and filecoin, you should be
1131:12 - incredibly proud of yourself, if
you've made it this far, because
1131:15 - you've just made a really solid
app, a really solid front end
1131:18 - application. And you've learned
how to really easily add
1131:21 - functionality for interacting
with your smart contracts. So
1131:24 - give yourself a pat on the back,
maybe even tweet this out, share
1131:27 - this really cool application
with your friends and family.
1131:30 - Take a break. And I'll see you
in the next lesson.
1131:38 - All right, welcome to one of the
fastest lessons that we're going
1131:41 - to have here. And in this
lesson, we're going to talk
1131:43 - about the hardhat starter kit.
Really quickly, I'm going to
1131:46 - walk you through it and show you
how to use it. Now we've learned
1131:49 - a lot about projects, we've
learned a lot about different
1131:51 - repos, learnt the basics of
smart contracts. And we've
1131:54 - learned a lot about front end as
well and building front ends for
1131:57 - applications. So this smart
contract kit repo comes packed
1132:01 - with a ton of starter kits that
you can use to start deploying
1132:06 - your projects right away. And as
you can see, that hard hat
1132:09 - starter kit is easily one of the
most popular ones with the most
1132:12 - stars the most forks out there.
The smart contract kit repo
1132:15 - actually comes with a ton of
frameworks, like if you want to
1132:18 - work with SWANA, if you want to
work with Python and Brownie, if
1132:21 - you want to work with foundry,
truffle, really any other
1132:25 - framework out there, you can get
started, clone one of these
1132:27 - repos, work with one of these
repos and build your project and
1132:30 - get started right away, we're
going to show you how to use the
1132:32 - hard hat starter kit. So you can
just grab the repo and go and
1132:37 - already have some boilerplate
code and a boilerplate really
1132:40 - good looking repo to start your
projects with, we come to the
1132:43 - smart contract kit, hard hat
starter kit repo here. And if
1132:46 - you're working with GitHub, you
can just go ahead and use this
1132:48 - template and it will
automatically generate you a new
1132:51 - GitHub repo with the hardest
starter kit. So let's go ahead,
1132:54 - we'll click use this template,
we come up with our own name
1132:57 - here, we'll call it make it
public create repository from
1133:02 - Template. it'll generate our
repository. And now we
1133:06 - automatically have it in our own
repo here. And we can get
1133:10 - started working with it. And we
can get started working with it.
1133:12 - If you don't want to click the
use that template button, we can
1133:15 - also just copy the URL. And in
our code editor, we can just do
1133:18 - git clone and paste that in
there. So for now, I am going to
1133:21 - get clone, but I'm going to get
clone with this repo that we
1133:24 - just created. Come back in with
the git clone, hard hat play FCC
1133:30 - or hard hat starter kit. We're
going to cd into our head play
1133:34 - FCC, and then open that up in a
new code editor. And awesome.
1133:38 - Now you'll see in this repo, it
comes packed with a ton of
1133:41 - contracts, deployments, scripts,
tasks, test, everything, you
1133:45 - name it to really get started in
a professional environment. We
1133:48 - look in the contract section, we
can see we have a couple of
1133:52 - sample contracts. We have a
contract for making an API call
1133:56 - to a chain link node, working
with keepers working with price
1134:00 - feeds, and then working with
chain link Vir Fe two. We've got
1134:03 - some test contracts and we
additionally have this fuzzing
1134:06 - folder, which we'll talk talk
about in a much later section of
1134:09 - this course, we have deployed
scripts where we start with
1134:11 - deploying mocks, then we deploy
each one of those contracts, we
1134:14 - have a sample script to read the
price from one of these
1134:17 - contracts. And we have a whole
bunch of sample tasks. Now at
1134:21 - the time of recording, instead
of scripts, this repo uses
1134:23 - tasks. But again, they're a
little bit interchangeable. And
1134:26 - of course, we have some unit
tests and some staging tests as
1134:29 - well, that you can go through
and take a look at, once we're
1134:32 - in this repo, we can run some
familiar commands here, we'll do
1134:35 - yarn, of course, to install our
all of our packages. And then
1134:39 - everything that we're going to
do, if you get lost, you can
1134:42 - always come back to this repo.
And you can follow along with
1134:45 - getting started and the
Quickstart. So we just did the
1134:47 - git clone. Now we're doing the
yarn, and then we're gonna go
1134:51 - ahead and run yarn hard hat
test. This hard hat starter kit
1134:53 - repo is very consistently up to
date, we did the last push being
1134:57 - just a few days ago, and will
constantly have some best
1135:00 - practices for building our smart
contracts and having a really
1135:03 - professional coding environment.
And it's got this really cute
1135:06 - logo. Once we've installed all
the dependencies, we can run
1135:09 - yarn, art hath test, we can run
all of the tests in the test
1135:14 - folder, which also will show us
how to interact and how to use
1135:17 - all these different contracts in
here. And they each have some
1135:20 - console dot log, so you can see
more about what's actually going
1135:23 - on when these tests actually
run. If we look in the Hardhead
1135:28 - config.js, it's got some really
familiar code in here, we have
1135:31 - all our imports at the top, we
grab a whole bunch of
1135:35 - environment variables, we've got
the ether scan plugin, we've got
1135:38 - the gas reporter, the contract
sizer, which is a plugin that
1135:42 - tells you how big your contracts
are. So named accounts,
1135:45 - different solidity versions, and
then mocha timeout as well. We
1135:48 - can of course, do yarn hard hat
node, which will run through our
1135:53 - deploy scripts, and then spin up
a new note for us, which has
1135:57 - mock chainlink tokens, mock
Oracle's mock aggregators, and
1136:01 - mock up VRF for us to go ahead
and interact with once that's
1136:04 - up, we can then of course, to
hard hat, console, dash dash
1136:09 - network localhost, and begin
interacting with contracts on
1136:13 - localhost. So we can kind of
follow along with price feed,
1136:16 - for example, and do const price
consumer B three equals await
1136:22 - ethers dot get contract, price,
consumer V three.
1136:29 - And then we can do await price
consumer B three dot get latest
1136:34 - price. Let's wrap that in a to
string. And we can see a mock
1136:40 - latest price from a contract
that uses channeling price
1136:43 - feeds. And we can interact with
any of our contracts and work
1136:47 - with any of the mocks as well in
here. If we want to deploy this
1136:50 - to an actual test net like
Rinckey, or main net will just
1136:53 - pop in our dot env file, we'll
close our node terminal, and we
1136:57 - can run yarn hardhat or just hh
deploy. And then we'll add
1137:03 - whatever tags we want to do
here. So let's just deploy our
1137:05 - price feed contract. If we go to
the price feed deploy, we scroll
1137:08 - down, we'll get the tags. Okay,
great, we'll use the feed tag,
1137:13 - dash tags feeds dash to or feed
dash dash network brings beam.
1137:18 - And while we're waiting for this
to deploy, we can go back to the
1137:21 - actual repo. And just make sure
to follow along with the
1137:24 - documentation here and the
Quickstart in all the usage and
1137:26 - everything so that you make sure
that you're working with the
1137:29 - most up to date version. There's
even documentation on running a
1137:32 - local network using a test net
or live network working with
1137:36 - Aetherium. Rigby adding your
private keys and dotting envies
1137:39 - all this stuff that you already
know, forking, which we'll learn
1137:42 - a little bit later, auto funding
your contracts for working with
1137:45 - chain link API running tests,
you can additionally run your
1137:49 - tests in parallel by adding the
dash dash parallel flag to our
1137:53 - tests. We can interact with our
deployed contracts with those
1137:56 - different tasks that we've
created linting code formatting,
1137:59 - estimated gas code coverage
fuzzing, we'll talk about later.
1138:02 - And then contributions. PRs
issues are always welcome here.
1138:06 - And once it's outputted, and
even verified, if you have
1138:09 - verification turned on, you'll
get a little task that we can
1138:12 - run to just go ahead and read
the price feed or interact with
1138:15 - the contract. So we can copy
that task out. Yarn hardhat.
1138:18 - Read price feed since it's a
task here, contract the contract
1138:22 - data which we just deployed
network Rigby. And we'll get
1138:25 - reading data price feed from
consumer contract on network,
1138:28 - Rigby price is here, which of
course, we're saying the price
1138:31 - of Aetherium is $3,033, because
it has eight decimal places. So
1138:36 - if you're ever looking to start
a new project, and you want some
1138:39 - boilerplate code, this hard hat
Starter Kit is a great place to
1138:42 - get started. And of course, you
can open it and get pod if you
1138:46 - want to just test it out and try
it and get pot in a Cloud Shell.
1138:49 - So that's it for this lesson.
Wasn't that fast. This was the
1138:52 - fastest lesson ever. So if you
want to do a little extra
1138:55 - learnings here, I would fork
this I would clone this I would
1138:58 - use this template, try to play
around with the repo a little
1139:00 - bit yourself and see what you
recognize, see what you don't
1139:03 - recognize and keep that prepped
in your mind for later so
1139:07 - Questions in the course. And
then for everyone here who is
1139:09 - TypeScript, there is, of course,
a TypeScript version of this as
1139:13 - well that you can get cloned.
And it has a nice blue logo here
1139:17 - to show that it's a little bit
different. So, that being said,
1139:20 - use the repo, have fun. Let's
get to lesson 12.
1139:29 - Alright, now we're moving on to
the hard hat ERC. 20s are the
1139:33 - section where we're going to
learn how to create our own ERC
1139:36 - 20 or EIP 20 Or B E P 20 or AEP
20 any of these tokens on the
1139:42 - blockchain before we can
understand what an ERC 20 is, or
1139:45 - even what one of these tokens
are, we first need to understand
1139:48 - what is an ERC. And then also
what is an EIP in Aetherium, and
1139:53 - avalanche and finance and
polygon. All these blockchains
1139:56 - have what's called improvement
proposals. And for Aetherium,
1139:59 - they're called Aetherium
improvement proposals, or E IPs.
1140:03 - And what people would do is they
come up with these ideas to
1140:07 - improve Aetherium or improve
these layer ones like polygon,
1140:11 - Matic avalanche, etc. And on
some GitHub or some open source
1140:15 - repository, they'll add these
new EIP is they'll add these new
1140:18 - improvement ideas to make these
protocols better. Now, these
1140:21 - improvements can really be
anything, they can be anything
1140:23 - from a core blockchain update to
some standard, that is going to
1140:27 - be a best practice for the
entire community to adopt. Once
1140:31 - an EIP gets enough insight, they
also create an E RC, which
1140:35 - stands for Aetherium request for
comments. So EIP a theory and
1140:39 - improvement proposals ERC a
theory and request for comments.
1140:43 - And again, these can be like BP,
Pep, you know, etc. For all
1140:48 - these different blockchains.
Both the improvement proposals
1140:51 - and the Request for Comments,
all have these different tags,
1140:54 - now they're numbered
chronologically, so something
1140:56 - like an ERC 20 is going to be
the 20th ERC slash EIP, the ERC
1141:03 - is and the EFPs share that same
number. And there are websites
1141:06 - like EIP is that aetherium.org
That keep track of all of these
1141:10 - new Aetherium improvement
proposals, and you can actually
1141:12 - see them real time go through
the process of being adopted by
1141:15 - the community. Now, one of these
e IPs or ERC is, is going to be
1141:20 - the ERC 20 or the token standard
for smart contracts. This is an
1141:24 - improvement proposal that talks
about how to actually create
1141:28 - tokens and create these smart
contract tokens. I made a video
1141:31 - about this recently. So in the
GitHub repo associated with this
1141:33 - course, we're going to have a
sub lesson, and we're going to
1141:35 - watch a quick video that
explains more about these
1141:38 - different tokens. Now first,
let's define even what are ERC
1141:44 - 20s So ERC 20s are tokens that
are deployed on a chain using
1141:49 - what's called the ERC 20 token
standard, you can read more
1141:52 - about it in the year 20 token
standard here link in the
1141:54 - description as well. But
basically, it's a smart contract
1141:56 - that actually represents a
token. So it's token or the
1142:00 - smart contract. It's both it's
really cool tether chainlink
1142:03 - unique token and dye are all
examples of ERC 20s Technically,
1142:07 - chain link is in the ERC. 677 as
there are upgrades to the ERC 20
1142:11 - that some tokens take that are
still backwards compatible with
1142:15 - ERC. 20s And so basically, you
can think of them as ERC 20s
1142:18 - with a little additional
functionality. Now why would I
1142:21 - even care to want to make an ERC
20 Well, you can do a lot of
1142:23 - really cool stuff with it. You
can make governance token, you
1142:26 - can secure an underlying
network, you can create some
1142:28 - type of synthetic acid, or
really anything else. In any
1142:32 - case, how do we build one of
these ERC? 20s How do we build
1142:35 - one of these tokens? Well, all
we have to do is build a smart
1142:38 - contract that follows the token
standard, all we have to do is
1142:41 - build a smart contract that has
these functions that has a name
1142:45 - function, symbol function,
decimals function, etc. All
1142:48 - these functions we need to be
able to transfer it, we need to
1142:50 - be able to get the balance of it
etc. And again, if you want to
1142:53 - check out some of the
improvements that are still ERC
1142:56 - 20 compatible, like the ERC 677
or the ERC 777. Definitely go
1143:01 - check those out and build one of
those instead. All right,
1143:06 - awesome. Now that we know what
one of these ERC 20s is, we can
1143:10 - go ahead and create our own per
usual in the GitHub repo
1143:14 - associated with this course. We
have all the code available
1143:16 - here. If you want to just get
clone. This is going to be again
1143:20 - another one of our quicker
lessons here. So we're in our
1143:22 - terminal. We're in our VS code
here. We're going to make a new
1143:25 - directory. I'm going to call it
hard hat ERC 20 FCC will cd into
1143:31 - hard hat, your C 20 sec. And
we're going to create a new hard
1143:35 - hat project the exact same way
we've been doing it yarn add
1143:38 - dash dash dev or tab. Let's
actually open it in its own VS
1143:43 - code will do code.or file open
this folder. And okay, we're in
1143:49 - our project now. Let's create a
new hard hat project. We'll do
1143:52 - yarn, art hats.
1143:55 - We'll do create an empty hard
hat dot config dot j s here and
1143:59 - great. We've now got an empty
hard hat dot config dot j s. If
1144:02 - you want to copy paste your hard
hat dot config from a previous
1144:05 - projects you want to copy paste
your heart Have dot config or
1144:08 - your dot EMV file, because you
know we're going to need those
1144:11 - feel free to do so now, I'm just
going to update this to 8.7.
1144:15 - I'll add the rest of my stuff
later. So as we've heard this
1144:19 - EIP 20, or this ERC 20. All it
needs is to have these functions
1144:23 - in its token standard so that we
can transfer tokens, we can do
1144:26 - all the stuff in the ERC 20
contract itself, it really is
1144:29 - just keeping track of how much
of each token people have. So
1144:33 - the smart contract, kind of in a
weird way it keeps track of
1144:36 - itself. To get started, we're
going to do this kind of the
1144:38 - manual way. First, we're going
to create our own manual token
1144:42 - here, or a really minimalistic
one anyways, so let's create a
1144:45 - new folder. contracts will
create a new file called manual
1144:52 - token dot soul. Yes, I'm going
to show you kind of the hard way
1144:56 - to make it and then I'll show
you a much easier way to make
1144:59 - it. So to get started here are
usual we can do pragma, solidity
1145:05 - to carrot zero, point 8.7. And
then we'll even do spdx, license
1145:11 - identifier, MIT do contract,
manual token, and boom, let's
1145:18 - get started. The main reason
this token smart contract works
1145:22 - is that there's some balances
mapping. So we have a mapping of
1145:28 - addresses to you in 256. And
it's usually public called
1145:34 - balance of and all this does is
this mapping is obviously the
1145:38 - key is going to be every single
address on the planet, and then
1145:42 - how much they have. And
basically, when we transfer
1145:45 - tokens, transfer tokens, we're
basically just subtract from
1145:50 - address, amount, and add to to
address. So a really
1145:56 - minimalistic way to implement
this would be to create this
1145:59 - transfer function first. So
we'll create this function, I'm
1146:02 - going to call it underscore
transfer, we can do an address
1146:05 - from address to you into fifth
sixth mount. And now we'd
1146:12 - probably put some requirements,
we probably omit some events,
1146:15 - and let's make this public as
well. And really, at the end of
1146:17 - the day, is we're gonna say
balance of from minus equals
1146:27 - value, which is the same as
saying bounce of from equals
1146:31 - bounce from minus value, or
excuse me, amount, and then
1146:35 - we're gonna say balance of two,
excuse me, plus equals, which is
1146:40 - the same as saying, you know,
balance of two plus. And
1146:43 - technically, that's really all
we need, right, we probably want
1146:46 - to do some asserts ins here,
some requires to make sure all
1146:49 - of our numbers make sense. But
really, at the end of the day,
1146:52 - this is all that this function
is doing. Transfer works when
1146:56 - the caller is sending money
directly into another address.
1147:00 - But what happens if we want to
allow some smart contract to
1147:03 - work with our token, or we want
to allow somebody else to work
1147:06 - with our token, you know, maybe
to deposit it into a protocol,
1147:10 - or do some more functionality
with it, there will be some
1147:13 - approved function that will
approve that contract to do
1147:15 - that. And then we'll have a
function transfer from and this
1147:21 - function will, you know, it'll
just implement taking funds from
1147:24 - user and this will be public as
well. And then at the top will
1147:27 - be some type of allowances
mapping that will tell who's
1147:31 - allowed which address to take
how much token, which sounds a
1147:35 - little confusing, but let me
just add the mapping. So it'll
1147:36 - be a mapping of addresses to a
mapping of addresses to an
1147:42 - amount to a unit tivity sex and
this will be public allowance,
1147:47 - we're gonna say address, Patrick
is going to allow address of
1147:52 - Patrick's brother to use 25
tokens. And that's how this
1147:56 - allowance works. And in our
transfer from transfer from will
1148:00 - check this allowance mapping and
save Hmm. Did Patrick give you
1148:04 - authorization to borrow those
tokens? Oh, yes, you did. Okay,
1148:08 - we'll let you transfer from. And
I'm just, I'm just going to copy
1148:11 - paste an implementation of it,
you can check out the GitHub
1148:13 - repo as well. And it would look
something like this is we check
1148:16 - the allowed amounts, update the
allowance, and then transfer the
1148:20 - tokens. So those are some of the
main functions. So we need an
1148:22 - approved function, obviously, to
update the allowances here. And
1148:26 - usually, you'll have like a un
256 initial supply. And this
1148:33 - will be like how many tokens
there are starting with how many
1148:37 - tokens there are total,
sometimes you'll add a mint
1148:39 - function to add more functions.
But you can basically start to
1148:42 - see this contract ramping up.
One thing we could do is we
1148:45 - could go ahead go through this
spec and just line by line, you
1148:49 - know, build our token ourself.
And after we do that, it might
1148:52 - look something like this. So I'm
just copy pasted the code from
1148:56 - the GitHub repo. If you go to
contracts, manual token, I just
1148:59 - copy paste this code in here.
This is what a contract a token
1149:03 - contract might look like. Okay.
So we have all these functions,
1149:06 - we have all these arrays. We
have all this stuff. And you can
1149:09 - see in the constructor, we're
taking initial supply, and then
1149:12 - a token name and a token symbol.
The name, you know, might be
1149:16 - something like dy token. And
then the symbol might be
1149:18 - something like dy, just so that
it's easily recognizable just by
1149:22 - its name and its token.
1149:25 - coding it all from scratch, like
that is definitely something
1149:28 - that we can do. But as
engineers, we know that that's
1149:31 - probably really annoying. And we
don't actually want to do that.
1149:33 - So what can we do instead? Well,
we can use an open source
1149:37 - library, like open Zeppelin, to
actually get some boilerplate
1149:42 - code work with open Zeppelin is
almost considered kind of the
1149:45 - standard library of solidity.
They have a list of open source
1149:48 - contracts that anybody can use
and import into their contracts
1149:52 - that have a ton of boilerplate,
so that you don't have to
1149:55 - manually write everything out,
we can see all their code in
1149:58 - their GitHub repository, open
Zeppelin slash open Zeppelin
1150:00 - contracts, and we're going to be
using them a lot moving forward.
1150:03 - So for example, you can see kind
of on the left side of their
1150:06 - documentation, they have this
tokens section, and they have an
1150:09 - ERC 20, which is one of those
tokens standards. If you scroll
1150:13 - on here, they even have some
minimalistic examples of how to
1150:17 - create your own ERC 20 token.
And that's what we're going to
1150:20 - be using to build our token.
Because you see how much smaller
1150:23 - this is how much less code this
is to maintain. Let's go ahead
1150:26 - and let's use open Zeppelin for
us to create our token. So let's
1150:29 - create a new file. We'll call
our token dot soul. I'm going to
1150:33 - create our own token here. So
let's do spdx. License
1150:38 - identifier, MIT, we'll do
pragma, solidity carrot zero,
1150:45 - point 8.7, we'll do contract our
token. Now, what we're going to
1150:50 - do, we're going to import
openzeppelin contracts into our
1150:53 - hard hat project. And we're
going to do it the same way we
1150:56 - did with chain link and any
other packages in the future. So
1150:58 - we'll do yarn, add dash dash
Dev, at open Zeppelin slash
1151:04 - contracts. And this is going to
add the open Zeppelin slash
1151:07 - contracts NPM package to our
project. And one of the code
1151:10 - pieces that they have is this
ERC 20 contract that we can use
1151:14 - and we can have our token
inherit all the functions. So
1151:17 - we'll go ahead and import it
with import at openzeppelin.
1151:22 - Slash contracts slash tokens
slash ERC 20 slash ERC 20
1151:27 - ditzel. And just by importing it
like this, all we have to do is
1151:31 - have our token inherited now. So
we'll say contract. Our token is
1151:35 - ERC 20. Boom. And just like that
our token is almost done. Now
1151:39 - you might get this little wiggle
this little red line here saying
1151:42 - our token should be marked
abstract. And that's because if
1151:45 - we look into the ERC 20 dot soul
of openzeppelin We'll see that
1151:50 - it has a constructor. So in
order for us to inherit your C
1151:53 - 20 token, we have to use the ERC
20 constructor and we just need
1151:58 - to give our token a name and a
symbol. But we can say in our
1152:01 - constructor, we can leave it
blank. And then right next to
1152:05 - our constructor, we'll add the
ERC 20 constructor and our name
1152:09 - will be our token. And then our
symbol will just be OT and then
1152:14 - this ERC. 20 token also comes
with something called a mint
1152:18 - functionality, which is
essentially a function that
1152:21 - allows us to create tokens,
right because right now we
1152:24 - actually get initialized with
zero tokens, right. So nobody's
1152:27 - actually allowed to have any
tokens. So we want to mint the
1152:31 - initial amount of tokens and
then who owns all those tokens
1152:35 - to start with. So usually what
you'll see is you'll see a mint
1152:37 - function like this, it'll be
passed in message that sender,
1152:41 - so whoever deploys this contract
will own all the tokens to
1152:44 - start. And then we'll give it
like an in their soul supply.
1152:49 - And then we could do like, you
went to 56 initial supply equals
1152:52 - like seven, or whatever. But
instead, a common practice is
1152:56 - just to add it to the
constructor. So you and 256
1152:59 - initial supply like that, as we
know about solidity decimals
1153:02 - don't work so great. So if I say
my initial supply is 50, that 50
1153:09 - is going to be like 50 way, and
there's all these ERC 20s come
1153:13 - with a decimals and decimals
function, which tells us how
1153:16 - many decimals we should expect
with our ERC 20. The default is
1153:21 - 18. And we can override this
function if we want a different
1153:24 - amount of decimals. And if we
know the default is 18. And we
1153:28 - want to deploy 50, we might want
to do our initial supply of 50 e
1153:32 - 18. Or you can also say like 50
times 10, raise the 18th or
1153:38 - whatever you want there. And in
our code when we deploy this
1153:41 - now, this is actually where
we're going to finish the
1153:43 - project. Because everything else
that we would do here, we've
1153:46 - already done, all we need to do
is make a deploy script and
1153:50 - write some tests. That's really
it. Because right now you have
1153:52 - all the skills that you need to
write a deploy script and then
1153:55 - optionally write some tests for
this project. So I highly
1153:59 - encourage you to pause the video
here and try to write your own
1154:01 - deploy script. And even if you
want to write your own tests,
1154:05 - you can always refer back To the
GitHub repo associated with this
1154:09 - lesson, as we do have a deploy
script in here, we also have a
1154:13 - TypeScript edition in here as
well that we're additionally not
1154:16 - going to go over. And of course,
if you get totally lost, there's
1154:19 - a ton of instructions in here to
help you learn more and help you
1154:22 - work with this specific
repository.
1154:27 - So let's do a quick review of
what we just learned. So ERC 20
1154:31 - tokens, or EIP 20 tokens or or b
p or p p, or any of these dash
1154:37 - 20. Improvement proposals are
what's known as the token
1154:41 - standard. And the token
standard, these tokens on chain
1154:45 - actually just tokens that are
smart contracts. Now, these
1154:48 - tokens are obviously different
than the layer one tokens like
1154:51 - Aetherium, or polygon or
Avalanche or arbitration, those
1154:55 - are not going to be smart
contracts, those are going to be
1154:57 - blockchain native tokens, and
you'll hear me refer to it as
1155:00 - blockchain native tokens a lot.
versus these tokens, these ERC
1155:04 - 20, these smart contract tokens,
which are just smart contracts.
1155:08 - And they're just kind of a
combination of these functions
1155:10 - that represent how many tokens
each address has, we can create
1155:14 - our own token with all the
specifications added. Or we can
1155:19 - just use openzeppelin to import
a token in now another popular
1155:22 - repo like open Zeppelin is going
to be this one from Rory capital
1155:25 - called soulmate. And they're
both aimed to be standard
1155:29 - libraries for solidity. And one
of the important things to keep
1155:32 - in mind is that these tokens
have this allowance mapping. And
1155:35 - you can allow other addresses to
have access to your tokens and
1155:39 - move your tokens around. This is
important, especially when we
1155:42 - get to later on when working
with defy when we want to give
1155:45 - some smart contract access to
our tokens so that they can
1155:48 - input it into their defy
protocol. It's also a little bit
1155:51 - tricky. And you want to make
sure you're not allowing
1155:54 - malicious contracts to interact
with your tokens. And we'll also
1155:58 - see that when we start to
interact with these tokens more
1156:01 - before any contract can interact
with our tokens, we need to
1156:04 - approve them to interact with
our tokens. And that's it. Now
1156:07 - you're a token wizard, and you
can deploy your own tokens. Take
1156:10 - a break, get that coffee, and
I'll see you in the next one.
1156:18 - All right, welcome to the next
session, we are going to be
1156:22 - learning about defy in this
session and going to be
1156:24 - programmatic, and going to be
programmatically interacting
1156:28 - with the defy protocol. I am
incredibly excited for you for
1156:31 - this session, because defi is
one of the best use cases for
1156:35 - smart contracts. And one of the
use cases that I am specifically
1156:39 - most excited for now, as I've
mentioned, the past defy stands
1156:43 - for decentralized finance, we've
left some links in the GitHub
1156:46 - repository for you to learn more
about Defy. One of the main
1156:50 - reasons we're so excited about
defy is because we move away
1156:53 - from this area of traditional
agreement. And that's what smart
1156:56 - contracts are all about. They're
about removing this centralized
1156:59 - entity, from our financial
world, and especially from these
1157:03 - financial institutions that have
a conflict of interest. They're
1157:06 - in business to make money not to
keep our money safe not to make
1157:08 - us money. And we want to work
with a system where everything
1157:12 - is transparent, especially when
it comes to our financial
1157:15 - services. So we want to move to
this world of smart contracts,
1157:19 - especially when it comes to our
money. And in my mind, defi is
1157:22 - going to be the industry that
affects the masses, the quickest
1157:26 - because of how much fair how
much better decentralized
1157:29 - finance is than centralized
finance. And at the moment, the
1157:33 - rates and the yields and the
interest that you gain in defy
1157:36 - is much better than centralized
finance, because remember, will
1157:39 - go away from these centralized
protocols, saying, hey, trust
1157:41 - us, we'll give you access to the
markets or hate trust us put
1157:45 - your money in us will keep your
money safe to this cryptographic
1157:49 - math base guarantees instead of
having to trust these companies
1157:52 - and these entities, which is
what we want. And additionally,
1157:55 - the more our Oracle networks get
better, and the more Oracle's
1157:58 - networks work with these smart
contract platforms like
1158:00 - Aetherium, like polygon, like
arbitrage them, the more data
1158:03 - and the more complex financial
products that we can do. Now,
1158:06 - one of the other reasons I'm so
crazy excited about defy is if
1158:10 - you look at this little chart
right here, it shows the
1158:13 - different markets by size. Now
this this image is a little bit
1158:16 - outdated, but it still shows you
the relative sizes of all these
1158:19 - different industries defy right
now is a $200 billion market,
1158:24 - there's about $200 billion
locked in the defy industry. And
1158:27 - I'll show you that in a minute.
Cryptocurrency actually, at the
1158:30 - time of recording isn't 360
billion. It's actually like 1.8
1158:35 - trillion. So it's a lot more
than this. But still, it's a
1158:38 - massive subset of all these
other areas like gold is a $10
1158:42 - trillion market. The stock
market is almost $100 trillion
1158:46 - global real estate, almost $300
trillion derivatives as
1158:50 - quadrillion dollars. So the FBI
is a super tiny, tiny, tiny,
1158:55 - tiny subset right now and in my
mind, all of these areas can be
1158:59 - re landscaped with Defy. So
we're ramping up, we're getting
1159:03 - there. So it's gonna be up to us
to make some of these protocols
1159:06 - and make it Much easier for
people to get into the space
1159:09 - where their finances are going
to be more fair, more
1159:12 - accountable and more
transparent. And with better
1159:15 - yield rates, we can actually see
a pretty good summary of what's
1159:19 - going on in defy this site
called defy llama. It shows
1159:23 - total value locked in all these
different decentralized
1159:27 - protocols. And we can see a lot
of these are across multiple
1159:31 - chains, right. And a lot of
these are EVM compatible chains,
1159:34 - Aetherium, Biden, smart chain,
avalanche, Fanta, drawn polygon,
1159:39 - all these are EVM, compatible
blockchains, where we can see
1159:43 - exactly how much money
independent users have put into
1159:46 - these protocols. The time of
recording Ave is the number one
1159:50 - protocol for total value locked.
So there's $22 billion locked in
1159:54 - Ave, which is the protocol that
we're going to be going over
1159:57 - today.
1160:00 - So what is Ave So are they is a
borrowing and lending protocol,
1160:04 - it allows us to borrow and lend
cryptocurrencies. So we can
1160:07 - actually put down a token as
collateral, it's kind of similar
1160:10 - to like putting money in a bank,
and earn yields on other people
1160:14 - borrowing that collateral from
us almost exactly what a bank
1160:17 - does, except for the fact it's
what's called noncustodial. To
1160:21 - the Ave team never touches our
money. Nobody ever touches the
1160:24 - money. It's all just a smart
contract. It's all just this
1160:27 - programmatic code. So we can be
rest assured, no one's going to
1160:30 - run off with our money, no one's
going to do anything bad. And we
1160:33 - also gain these higher yields.
borrowing and lending is a
1160:35 - critical piece for creating
really any interesting financial
1160:39 - applications. If you want to
short sell something, if you
1160:42 - want to leverage up on some
asset if you want to. If you
1160:44 - want to do more complex
financial products, you need
1160:48 - borrowing and lending. Now a lot
of the typical FinTech or
1160:51 - financial technology or finance
terms do apply here. And this
1160:55 - course isn't going to be a deep
dive into exactly how these
1160:58 - financial products work. And
it's also not going to be a
1161:00 - course on finance. If you want
to learn more about finance,
1161:03 - we'll leave a number of links in
our GitHub repo associated with
1161:06 - this course. So you can learn
more about finance and become
1161:09 - what I like to call a defy
quant, quantitative defy
1161:12 - engineer. And I am so excited
for more defi quants to get into
1161:15 - this space. Alright, so here we
are in the Ave application. It's
1161:19 - at testament dot Ave dot
markets, we are in the testament
1161:22 - of Avi now, everything that
we're going to do here is going
1161:24 - to work on Main net as well, but
we're going to use it on their
1161:27 - test net. Now this is actually
obvious older UI, and they have
1161:30 - a new website that looks even
better than this. But we're
1161:33 - going to be going through a lot
of the basic functionality
1161:35 - depositing taking out a loan,
potentially even shorting an
1161:38 - asset, if we want, I don't
recommend going to the site
1161:41 - because it might not work and
COVID the way you'd expect it
1161:43 - to. So for this, just sit back,
relax and watch. In order for us
1161:46 - to actually short sell or margin
trade. The first thing that
1161:49 - we're going to need to do is
actually deposit some
1161:51 - collateral, we need to deposit
some collateral in order to
1161:54 - borrow this way. If we never
repay back the loan that we took
1161:57 - out or the the amount that we
borrowed, Ave, we'll just go
1161:59 - ahead and take the collateral
that we put in here, we'll do
1162:02 - what's called a liquidation
call. And that's why this is
1162:04 - actually a little bit safer than
short selling in traditional
1162:06 - markets. Because if your
collateral is less than how much
1162:10 - you have borrowed, you'll just
immediately get liquidated, but
1162:12 - you still lose a bunch of money
so like don't get liquidated. So
1162:15 - what we want to do now is we're
gonna scroll to Aetherium, we're
1162:17 - going to connect our wallet
here, we're going to move to
1162:21 - COVID test network browser here.
And we're gonna go to this
1162:26 - deposit piece. So it already
shows our balance here we have
1162:29 - point two COVID eath. Let's
deposit 0.1.
1162:34 - We're gonna hit deposit Metamask
can pop up, confirm. But once
1162:39 - this goes through, this means
that we've have it deposited and
1162:41 - we go to our dashboard, we can
see we have some eath here,
1162:45 - point one eath got some API,
this is kind of like that
1162:49 - percentage return that we're
gonna get back for, for
1162:51 - depositing into Ave. And yes, we
can use it as collateral here,
1162:55 - we have this, this marked as yes
here. So that's exactly what
1162:59 - we're going to do. And it says
nothing borrowed. Yep, we can go
1163:02 - ahead and hit this borrow now
button. And we're gonna get
1163:04 - brought to the borrower screen,
and we're going to choose which
1163:07 - asset we want to borrow. Now,
whenever we borrow one of these,
1163:11 - there are these API's, right?
This is the percentage that over
1163:15 - the course of a year that we're
gonna have to pay, in order to
1163:17 - actually borrow this asset. The
stable one means it'll always be
1163:20 - for or variable means it
actually changes depending on
1163:23 - kind of how much liquidity the
protocol has, you can kind of
1163:27 - pick which one you want to do
stable is you're always gonna be
1163:30 - a 4% variable is going to be a
little bit riskier, but you
1163:33 - might get a lower fee. So we're
actually going to borrow some
1163:36 - dye right, because dye is a
stable coin. It's worth $1. In a
1163:40 - way, you could call this taking
out on margin because we're
1163:43 - taking out dye to borrow and
another way we could say we're
1163:46 - shorting dye which is kind of
funny to think about, but you
1163:49 - get to choose how much you want
to borrow here and you'll see
1163:52 - this this thing called Health
factor I'm going to zoom in a
1163:54 - little bit this thing called
Health factor here as we as we
1163:56 - scroll this thing. So this
health factor is how close to
1164:00 - being liquidated you are
remember how I said you can get
1164:03 - liquidated this health factor
represents how close we are to
1164:06 - getting liquidated. This means
means how close we are to always
1164:08 - saying, You know what fu we're
taking your funds. If it goes
1164:12 - below one at any time, somebody
can liquidate you and take a lot
1164:15 - of that deposit that we put in,
there's some math behind
1164:18 - actually what the health factor
actually is, you can head over
1164:21 - to the Ave documentation, which
I will leave a link in the
1164:24 - description to kind of read more
about the health factor. So
1164:27 - we're going to borrow 29 die
we're buying, we're borrowing
1164:30 - basically 30 bucks. Gonna hit
continue, I'm gonna do a
1164:33 - variable, zoom back out,
continue, we're gonna borrow
1164:37 - metamath pops up, confirm
transaction that's pending. And
1164:41 - we're gonna go to the dashboard.
And now we can see kind of our
1164:44 - new balance here, right, we can
see the point one eath,
1164:48 - deposited and 29 die. And we can
see our health factor up here,
1164:53 - you can even click this little
button, saying, hey, it
1164:55 - represents how close you are to
being liquidated, we can see the
1164:59 - value here, our eath is worth
like $200, or die is worth 30
1165:03 - bucks. So we're good. We're
pretty healthy here. In order
1165:05 - for Avi to understand and under
to price the underlying
1165:09 - collateral, so it knows how much
it can lend out. Obviously
1165:12 - another one of these protocols
that uses changing price feeds
1165:15 - to price, the underlying
collateral, many of these
1165:17 - billion dollar defy protocols
use chain link on the back end
1165:21 - to do all their pricing
mechanisms. And that's
1165:24 - essentially it, we could then
repay our debts, we could borrow
1165:27 - more assets, we could swap
assets around. And the interest
1165:30 - return, we get onto pausing our
assets is amazing. So now that
1165:35 - we learned a little bit about
how to use their UI, which is
1165:38 - hosted on IPFS, by the way,
let's go ahead and let's learn
1165:41 - how to do all this and do even
more programmatically so we can
1165:45 - become defy quanta engineers.
1165:50 - Now, like I said, we're going to
be working with the Ave v two
1165:53 - protocol, if you want to try out
the v3, you absolutely can, if
1165:56 - you can go there and play with
it right now, it still has more
1165:59 - money locked in it, which is
great. But the v3 protocol is
1166:01 - obviously the latest addition.
So we're gonna be flipping back
1166:04 - and forth between the
documentation and our code base.
1166:06 - So I recommend that you have the
documentation up as well. And
1166:09 - per usual, all of the code that
we're going to be working with
1166:11 - is in this hard hat defi Free
Code Camp repository. So let's
1166:15 - jump in. I'm in by VS code, I'm
in my folder with this course,
1166:19 - we're going to make a new
folder, we're going to call it
1166:21 - hard hat, defy FCC, we're going
to cd into it. And then we're
1166:26 - going to open it up with code
period. Or you can also do per
1166:30 - usual, File Open and then open
that folder. Now we're in a new
1166:34 - project, we're going to do yarn,
add dash dash Dev, aren't hat.
1166:38 - And we're going to add hard hat
and start up our minimalistic
1166:41 - hard hat project. Once again,
for starting up your
1166:43 - minimalistic hard hat projects,
I usually just copy paste from
1166:45 - another folder, or I just used
that hard hat starter kit that
1166:48 - we saw in the smart contract
code repo. But whatever works
1166:51 - best for you to get your project
started, you can use now that
1166:54 - we've got this, we can run yarn
hardhat. And we'll just create
1166:58 - an empty hardhat.config.js. Now
to save us some boilerplate
1167:01 - time, I am going to copy paste
my hard hat.config.js from a
1167:05 - past project into this one, just
to make it so we don't have to
1167:07 - go through that boilerplate
setup again. And I'm also going
1167:10 - to copy paste this line from our
heart at smart contract lottery.
1167:13 - Again, if you want to use your
package JSON or your yarn dot
1167:15 - lock to install dependencies,
you absolutely can. But I'm just
1167:18 - going to paste that in here and
run it. And then I'm going to
1167:22 - copy paste over my prettier
files, so that all my JavaScript
1167:26 - can be formatted the way I want
it to be. Okay, great. Now we
1167:28 - have a minimalistic project spun
up, let's go ahead and get
1167:31 - started learning how to interact
with the AVI protocol here. So
1167:33 - let's make a quick readme and
talk about what we want to be
1167:36 - able to do. So first, we're
going to want to be able to
1167:38 - learn how to programmatically
deposit collateral. And if we
1167:42 - stopped right there, that might
be enough, we'd be able to
1167:44 - programmatically deposit
collateral, and in doing so we
1167:47 - earn yield, we'd earn that
percentage return just on our
1167:51 - deposited collateral. So
accomplishing this by itself is
1167:54 - already a feat. But let's say we
want to go one step further, we
1167:57 - want to get into these more
interesting financial products.
1168:00 - So after we deposit some
collateral, we're going to learn
1168:03 - how to programmatically borrow
and other asset, the deposited
1168:07 - collateral is going to be eath,
slash wrapped eath, which we'll
1168:10 - talk about in a little bit,
we're going to borrow another
1168:12 - asset, which for this demo is
going to be dye. And the reason
1168:16 - that we're using dye is because
dye is what's known as a stable
1168:19 - coin. So dye is actually a token
on the blockchain created by
1168:23 - this maker Dow where the price
of the dye token is always
1168:26 - pegged to $1. So we're putting
down eath as collateral and
1168:30 - we're borrowing cryptocurrency,
US dollars, sort of, we're
1168:33 - borrowing this token, which
represents a US dollar and then
1168:36 - we'll just repay that I will
repay almost everything back and
1168:40 - you'll see why we don't repay
everything back in a minute. One
1168:43 - other protocol that I want to
talk about quickly is the
1168:45 - uniswap protocol. And the
uniswap protocol has become this
1168:48 - haven for trading. It's a
decentralized application that
1168:52 - allows us to trade assets and
tokens with each other on
1168:56 - something called an automated
market maker. It ends basically
1169:00 - a decentralized Stock Exchange,
but with tokens and again,
1169:02 - tokens aren't exactly stocks,
they're very different. So when
1169:05 - looking to get some of these
assets It's like wrapped
1169:08 - Aetherium or dye or link token.
On a main net, oftentimes,
1169:12 - you're going to use one of these
decentralized exchanges. And
1169:15 - obviously, these decentralized
exchanges are much fairer,
1169:18 - because everything that happens
on them is transparent, much
1169:21 - fairer than centralized finance,
everything that happens on them
1169:24 - is transparent. You can see
everything that's going on on
1169:27 - chain, which is absolutely
phenomenal. So let's go ahead
1169:31 - and get started here. And let's
just create our scripts folder.
1169:34 - Because in this project, we're
actually not going to create any
1169:36 - contracts ourselves, we're just
going to learn how to interact
1169:39 - with these protocols. If you do
want to learn how to build some
1169:41 - of these protocols, at the end
of this session, we will give
1169:45 - you a ton of links. And we'll
have a special guest explain a
1169:48 - few different ways to learn how
to build more of these
1169:50 - decentralized protocols.
Although we've already built one
1169:53 - with our decentralized lottery,
which is fantastic. Let's create
1169:56 - some scripts here. And for all
of these things, deposit
1169:59 - collateral, borrow and repay.
We'll just put this all in a new
1170:02 - script called Ave borrow dot
Jas. So we're gonna do
1170:06 - everything in here. And since
this is a script, it's going to
1170:09 - have the same setup, as we've
seen before, right, so we're
1170:12 - gonna have this main thing
around an async function. Main,
1170:17 - and then we'll have our imports,
of course at the top. Now
1170:20 - something that's important to
note, go to avi, we go to the
1170:23 - protocol, we kind of read
through the docs, and eventually
1170:26 - we would find out the protocol
treats everything as an ERC 20
1170:32 - token. And but we know that
Aetherium or the native
1170:35 - blockchain token that you're
using, isn't an ERC 20 token.
1170:40 - And the reason that treats
everything like an ERC 20 token
1170:42 - is that it's just much easier,
right? If everything's using
1170:45 - this ERC 20 token standard, it's
much easier to send in and
1170:48 - interact with stuff.
1170:52 - On a lot of these protocols,
when we go to deposit Aetherium,
1170:55 - or polygon, or arbitrary marks
cetera, what actually happens is
1170:58 - they send your Aetherium through
like what's called a web
1171:01 - gateway, and swaps it for weath,
which stands for rapt ether. And
1171:07 - it's basically Aetherium. But in
an ERC 20 token contract, so
1171:12 - what we want to do is going to
do that same thing, we're gonna
1171:14 - skip kind of using this web
gateway. And we'll just get the
1171:18 - Web Token ourselves, and we'll
use that as collateral. So in
1171:21 - our script tag, I'm going to
make another file called Get
1171:25 - weath.js. And in here, we're
actually going to go ahead, and
1171:29 - we're going to build a script
that will deposit our token for
1171:34 - web token. Okay, so let's create
the script. And there's a link
1171:37 - to the web token on ether scan,
and on Main net in the GitHub
1171:40 - repo. And the way it works, is
you actually deposit Aetherium.
1171:44 - And in return, it'll give you
the web token on Rigby right
1171:47 - now, by deposit 0.05. Go ahead
and write I'm connected to ether
1171:53 - scan, I'll go ahead and write
this transaction, I'm gonna
1171:55 - drink pee. So I don't really
care if it's if it's the actual
1171:58 - contract or not, because it's
not real money. But I'm going to
1172:01 - deposit 0.05 eath. And after our
transaction goes through, we
1172:05 - copy the contract address, we
add this token to our Metamask
1172:08 - the same way we added link will
import tokens, paste the address
1172:12 - in here, add custom token,
import tokens will now see we
1172:16 - have some wet token in here, I
deposited 0.1 before so 0.1 plus
1172:21 - 0.05, which is why it shows 0.15
Because I did it twice, well,
1172:26 - while I wasn't recording. So um,
but this is how you can get this
1172:29 - wet token into your contract.
And then anytime you want, you
1172:32 - can call this withdrawal
function. And you can withdraw
1172:35 - your Aetherium out of this and
do what's called Burn your wet
1172:38 - token. So when you swap back
from weath to Aetherium, you hit
1172:42 - this withdraw and boom, you
basically swap them back because
1172:45 - this contract itself right now
is holding your Aetherium token.
1172:49 - Pretty cool, right? So in our
get wet function, we're not
1172:52 - going to add this main thing
here, we're going to create get
1172:54 - West here just as kind of a
module and we're going to import
1172:57 - it into our Ave borrow. So we're
not going to do this this main
1173:00 - thing that you see here.
Instead, we're going to create
1173:03 - an async function called Get
Wes. And then below, we're going
1173:08 - to export it. So we'll do module
dot exports equals get weath.
1173:14 - And we're going to export it so
our Avi borrow can use this get
1173:18 - West script that we're creating
right now, let's add let's go
1173:21 - ahead and do this. Well, in
order to interact with a
1173:23 - contract, we're going to need an
account. So we can do const
1173:27 - deployer equals await get named
accounts, per usual. We'll do
1173:34 - const get name accounts equals
require hardhat. My VS code
1173:37 - automatically imported that
thank you VS code now. And now
1173:39 - we want to call the deposit
function on the west contract.
1173:46 - How do we call this deposit
function on the west contract?
1173:49 - Well, how do you call any
contract? Well, what do you
1173:52 - need? You need the ABI and then
you need the contract address.
1173:56 - Drill this in. You're always
going to be the API and the
1173:59 - contract address to interact
with the contract. We know that
1174:02 - if we give we know that if we
give our project the whole
1174:04 - contract, it'll get the API but
we also know If we just do the
1174:08 - interface, that's just as good,
it won't give us all the
1174:11 - functionality, but it will tell
it will give us the API, it will
1174:14 - tell our ethers, what functions
it can use. So we're going to
1174:18 - create a new folder, create our
contracts folder. And in here,
1174:22 - we're going to create a new
folder inside of that called
1174:24 - interfaces. And this is where
we're going to create our web
1174:27 - interface. Now a web interface
is going to be really similar to
1174:31 - an ERC 20 interface. So if you
want to go ahead and try to add
1174:34 - it yourself, feel free to do so.
Or what you can just do is you
1174:38 - can come to the GitHub repo
associated with this lesson,
1174:41 - come to iOS and just copy paste,
right, you'll see the functions
1174:45 - in here are exactly the same as
an ERC 20, allowance approved
1174:49 - balance of decimals named blah,
blah, with these additional
1174:53 - deposit and withdrawal
functions. So I'm going to copy
1174:56 - all this, move back over to my
hard hat project, we'll create a
1175:00 - new file, we'll call I left dot
soul. And just to note,
1175:05 - oftentimes, a good best practice
is to have interfaces, start
1175:09 - with eyes so that you know what
to interface and then we'll
1175:12 - paste it in here. Now in order
for this to compile, we'll need
1175:16 - to use 0.4 point 19 version of
solidity. So what we can do is
1175:21 - we can come over to our, our
head.config.js. We have solidity
1175:25 - compilers, version 0.07, or
whatever versions that you have
1175:29 - in here, we can add or just
replace. So I'm going to put a
1175:32 - comma here, version 0.4 point
19. Save. And now in order to
1175:40 - make sure we can get that API,
do yarn, hardhats compile, or hh
1175:45 - compiled, and great, we compile
this interface. So now we have
1175:48 - the ABI to interact with. Now
that we have the ABI, a little
1175:52 - check mark here, let's go ahead
and get the contract address.
1175:55 - But for reasons that we're going
to learn about very soon, we're
1175:58 - actually going to work just with
main net set of getting the
1176:01 - Rinkeby test and address, I'm
going to look up with main net,
1176:04 - we're going to find the web
token on Main net. So I'm going
1176:08 - to copy the address of main net.
And again, you can just grab
1176:11 - this address from the GitHub
repo associated with this lesson
1176:15 - as well. And for now, we're
gonna say check a little check
1176:18 - mark here, and paste the address
there. So now we're have the ABI
1176:23 - compiled from an interface, and
we have the contract address for
1176:25 - main net. But let's go ahead and
create this contract now. So we
1176:28 - can say const, iOS equals await
ethers dot and then we'll need
1176:34 - to import ethers from Hardhead
as well. Ethers dot get contract
1176:38 - at this is another one of these
functions on ethers, it allows
1176:43 - us to get a contract at a
specific address, we'll say get
1176:46 - contract app, we use the iOS ABI
for now, we'll just hard code
1176:51 - this address in here. And then
we'll connect it to the
1176:54 - Deployer. So we're saying let's
get this web contract with the
1176:57 - ABI of iOS at this address
connected to Deployer. So we
1177:02 - could go ahead and run await AI
with dot deposit. And we'll set
1177:08 - value which will be some
amounts. Let's go ahead and at
1177:11 - the top, we'll say const amount
equals let's do ethers dot utils
1177:17 - dot parse, ether, and then we'll
do 0.0 0.02. So we'll deposit
1177:24 - 0.02 will say const TX equals
that will do await TX dot wait
1177:30 - one wait for one block to go
through. And then we'll just get
1177:33 - the balance will say const. With
balance equals await I with that
1177:40 - balance of employer. So we're
going to call the balance of
1177:44 - function on our iWeb ERC 20
token. And then we'll just do
1177:48 - console dot log got West
balance.to string.
1177:56 - So we're using the main net
address in here. And we're gonna
1177:59 - say okay, we're going to deposit
some amount, we're going to
1178:01 - wait. And then we're gonna go
ahead and get the balance right,
1178:04 - so we're just depositing our
Aetherium so that we can get
1178:07 - that ERC 20 version of
Aetherium, that West token here.
1178:13 - Now, you might be thinking,
Okay, why are you putting the
1178:16 - main address in here? Let's
Patrick, slow down. Let's go
1178:19 - ahead and let's create a mock
Web Token contract address.
1178:23 - Let's deploy the mocks first,
and then we'll go ahead and use
1178:27 - that same setup that we've been
doing this whole time, why you
1178:29 - why you directly hard coding
this in here. Well, I've been
1178:32 - alluding to this for some time.
But there's another way that we
1178:36 - can run tests in our smart
contracts. And this is with
1178:39 - something called main net
forking, we can actually do
1178:42 - something where we fork the main
net, and run a local hard hat
1178:46 - node. That's pretending to be a
main net node. And all we have
1178:51 - to do is update our hard head
config to do so. So let's talk
1178:55 - about forking for a minute. So
on the left here, we have a
1178:58 - blockchain an example of
blockchain it's going to be
1179:00 - something similar to a test net
or main net like Rinkeby, eath,
1179:05 - main net polygon etc. This is
going to be a blockchain that we
1179:09 - deploy to. Now there are a whole
bunch of blocks in here, right?
1179:12 - We have this huge chain that we
can work with. And all this
1179:15 - information on the blockchain is
public information, like this
1179:18 - block is going to have
transaction transaction
1179:22 - transaction, each one of these
blocks is going to have a whole
1179:25 - bunch of transactions. And all
this information is on this
1179:28 - public blockchain. In addition
to all these transactions, it's
1179:31 - going to have things like price
feed contracts, it's going to
1179:34 - have things like Ave contract,
the Web token, contract, etc.
1179:37 - All this contract information is
public. So hypothetically, if
1179:42 - it's already there, we should be
basically able to copy this to
1179:46 - our local environment and do
some simulations ourselves. And
1179:50 - that's exactly what forking
does. A fork blockchain
1179:54 - literally takes a copy of an
existing blockchain like on the
1179:58 - left here and brings it on our
local computer. We actually have
1180:02 - control over our blockchain
that's running locally, because
1180:05 - it's gonna run on a local
computer, similar to hard hat.
1180:08 - Now, everything we do on this
local forked blockchain is not
1180:12 - going to affect main them,
because it's a simulated
1180:15 - blockchain. It's just running in
our local environment. So we can
1180:18 - actually interact with this
forking this kind of local
1180:21 - blockchain that resembles that
mimics the actual blockchain.
1180:24 - And here's what forking doesn't
do, it doesn't download the
1180:27 - entire blockchain into our local
setup. Anytime we reference an
1180:30 - address. Anytime we reference,
hey, there's something at a
1180:33 - specific address, we make an API
call to our Aetherium node,
1180:37 - which again, we're using alchemy
and say, hey, oh, what's at this
1180:41 - address, and it'll return just
that specific contract for us.
1180:45 - This way, we don't have to
download the whole blockchain.
1180:47 - And it's a lot quicker. And we
can also do this forking to run
1180:50 - our tests to run our scripts to
do everything. And now you might
1180:53 - be thinking, wow, Patrick, this
sounds awesome. Well, why don't
1180:55 - we just do this for everything?
Well, there's some trade offs.
1180:58 - The pros are that it's quick,
it's easy, and a test will
1181:01 - resemble what's on Main net. Now
the cons are that we need an
1181:04 - API, and we can't do everything
locally. Some contracts, some
1181:08 - contracts are complex to work
with, and mocks might just be
1181:11 - better. But using a forked
network might be a good way to
1181:14 - run your tests, it might be a
good alternate to just using
1181:16 - mocks. So it really depends on
what's right for you and right
1181:19 - for your project. But it is a
fantastic tool, especially for
1181:23 - something like Avi, where we
want to quickly test some
1181:25 - things. Now the hard forking
also will give us a bunch of
1181:29 - fake accounts. So we'll still
get a bunch of fake accounts on
1181:32 - Main net that will be given a
theorem. So we'll get fake main
1181:36 - net accounts for this forking.
So for the rest of this, we're
1181:38 - going to be using this forking
to run our scripts and run our
1181:41 - tests. If you want to go back
after this and try this all out
1181:45 - on COVID. We've got a whole
bunch of different addresses for
1181:48 - the COVID network so that you
can run these scripts directly
1181:50 - on COVID. And you can see the
transactions yourself. Just note
1181:53 - that when using COVID, you'll
want to make sure that you're
1181:56 - using the same addresses, as are
in the AVI docs for the COVID
1181:59 - network, because they do change
sometimes. Great, let's go
1182:03 - ahead, we'll go to our RT head
dot config dot j s. And now
1182:06 - we'll go to our networks, which
right now, I don't have
1182:09 - anything, I only have ranking.
And we'll add hard hat in here,
1182:15 - we'll add a little comma down
here. And we'll say, you know,
1182:18 - the chain ID of course is going
to be 31337. We'll add this
1182:22 - forking keyword. And in here,
we'll say the URL for a Forking
1182:26 - is going to be our main net RPC
URL. And this is another reason
1182:30 - why we're using alchemy. Alchemy
is fantastic at these forked
1182:34 - blockchains, and has really good
pieces here. So what we can do
1182:37 - is we can come back to our
alchemy dashboard, we'll create
1182:40 - a new app. This one will be for
Aetherium main net, and we'll
1182:44 - say forking chain. We'll say for
forking, we'll go ahead and
1182:50 - create this on a theory and main
net. Now that we have this
1182:53 - forking chain, we can do the
same thing. We'll grab our API
1182:57 - key, we'll come back to our
project, create this new file,
1183:02 - we'll create our dot env. And
we'll do main net RPC URL equals
1183:07 - and paste that in there. In our
Hardhead config, we are now
1183:10 - going to be forking from mainnet
RPC URL whenever we work with
1183:14 - the heart at blockchain. So now
that we have this in here, let's
1183:18 - go ahead and try to run this get
wet function. Because since
1183:22 - we're forking the blockchain, we
should be able to go ahead and
1183:26 - simulate this. So backing off a
borrow, we'll go ahead we'll do
1183:29 - const, get weath
1183:33 - equals require and then we'll
pull this script that dot dot
1183:37 - scripts slash get weath. And
then, in our main function,
1183:43 - we'll just run await yet. So to
run our script here, we'll do
1183:48 - yarn hard hat, run scripts
avevamo.js. And our default
1183:55 - network is hard hat. So we could
either do dash dash network hard
1183:57 - hat or just run it. And
remember, since in our config,
1184:01 - we're saying, hey, when we run
the hard hat chain, use this
1184:04 - forking, we're going to be
forking, so let's go ahead Run
1184:07 - this ran to air main. Net RPC
URL is undefined. Well, that
1184:11 - makes sense. Let's go ahead and
add this consummated RPC rel
1184:15 - equals process study and v dot
made it RPC URL. Let's try this
1184:21 - again. And we now see we got,
you know, this much weath,
1184:26 - which, again, that much wealth
is gonna be
1184:28 - 1-234-567-8910 1234567 0.02
wealth, which is exactly what we
1184:35 - want. So now we have a way to
interact with main net locally,
1184:39 - which sounds kind of crazy. But
he's incredibly powerful for
1184:42 - exactly what we're doing right
here. So we have a way to fork
1184:45 - main that eath and run our
scripts and kind of test to see
1184:48 - and simulate what it would be
like to actually run these
1184:51 - transactions. So we're gonna do
like that, our get with function
1184:55 - looks good. And obviously, we
would still modularize this, we
1184:58 - put this in our helper Hardhead
config, but we're going to skip
1185:01 - doing that for now. So let's go
head back to the AVI borrow. And
1185:04 - let's go ahead and flesh the
rest of this out. Now, let's go
1185:07 - ahead and set up the rest of the
boilerplate here. So we'll do
1185:09 - const Deployer, because we need
an account, obviously equals
1185:13 - await, get named accounts. And
then we'll do const get named
1185:17 - accounts equals require. Now we
want to start interacting with
1185:24 - the ABI protocol, well, what do
we need, we're gonna need the
1185:26 - ABI and the address, nothing
changes, we're gonna need these
1185:30 - two. So what we can do is we can
go to the Ave docs. And again,
1185:33 - we're going to be on V two. And
we can go ahead and find the
1185:37 - contract address in here. Now
the way it works is they
1185:41 - actually have a contract, which
will point us to the correct
1185:44 - contract. The contract that
we're going to be doing all the
1185:46 - lending with is this lending
pool. And there's actually a
1185:50 - contract to get that contract
address. And to get the lending
1185:55 - pool address, we have to go to
the lending pool address
1185:58 - provider. It's this contract
that will tell us what the
1186:00 - address of the lending pullets.
And we can actually see the
1186:03 - deployed contract section, we
can see the address of this
1186:06 - contract. And we can see the
address of all the main ones and
1186:08 - the COVID. Once again, if you
want to play with this on COVID.
1186:11 - But we can see lending pool
address provider is going to be
1186:14 - located right here, we can copy
this address. And we'll just
1186:18 - take notes of this.
1186:21 - And that lending pool, we're
going to get from the lending
1186:24 - pelagics provider. So let's
actually create a function that
1186:28 - will get us the lending pool
address from the lending pool
1186:30 - address provider. So down here,
we'll create async function, get
1186:35 - lending pool. Now in order to
interact with this lending pool
1186:38 - address provider. Same thing,
we're going to need its address
1186:41 - and its API, we have its
address. So let's go ahead and
1186:44 - get its API, you can go ahead to
the GitHub repo associated with
1186:48 - this lesson. And just copy paste
it from the interfaces section.
1186:51 - You could also look directly on
the blockchain to see what this
1186:55 - contract looks I can create your
own interface. Or we can go
1186:58 - ahead and use the interface
right in the documentation. So
1187:00 - we have islanding Palach.
Provider, I'm just going to copy
1187:03 - this from the ABI docs. But
again, you've got a number of
1187:07 - options. And so in our contracts
in our interfaces, let's let's
1187:10 - stick iwth in interfaces here.
Let's create a new file. And
1187:14 - we'll call it I lending pool
address provider, dot soul. And
1187:20 - we'll paste it in here, we just
see we're using 0.6 point 12. So
1187:24 - be sure to in our Hardhead
config to make sure we have that
1187:27 - we don't so we're just create a
new one 0.6 point 12 And then
1187:33 - we'll compile yarn Hardhead
compile and compiles so awesome.
1187:38 - We now have the ABI here, we'll
get this contract by saying
1187:42 - const lending pool address
provider equals await ethers dot
1187:50 - get contract at will say I
lending pool address oops
1187:59 - address as I lending pool
addresses excuse me, I'm going
1188:03 - to update the name I Lenny pull
addresses provider islanding
1188:06 - pool addresses provider, we're
going to pass in that contract
1188:11 - address that we got from the
Ovid docs here. Paste that in.
1188:16 - And then we're going to connect
it to our Deployer. So we're
1188:19 - going to have our get lending
pool, get past that account
1188:22 - variable and then we'll just use
the account here to connect it
1188:25 - and the account that we're going
to pass is of course going to be
1188:28 - our Deployer. In our lending
pool address provider. There's a
1188:32 - function called Get lending pool
which returns the address of the
1188:37 - lining pool and this is going to
be the function that we're going
1188:39 - to call so we're gonna say const
lending pool address equals a
1188:44 - weight lending pool address says
probes address any pool address
1188:51 - says provider dot get lending
pool and that's it we'll have
1188:56 - the lending pool address and
then we'll have this contract
1188:59 - give us the lending pool
contract by doing const lending
1189:03 - pool equals await ethers dot get
contract Add. And we need to do
1189:10 - the same thing, the interface,
the interface, the address, and
1189:13 - then the account. So back in the
docs, we can grab the I lending
1189:17 - pool by copying this like this.
We'll go back to our contracts
1189:22 - interfaces, new file, I lending
pool, that's all. And we'll
1189:27 - paste it in. Now with this one,
if we scroll to the top, we
1189:30 - noticed that we're importing
from some local places that we
1189:34 - actually don't have in our
contracts area, we can once
1189:38 - again go ahead and add the AVI
protocol v2 from NPM. And just
1189:44 - use this as our imports. So
we'll do yarn, add dash dash dev
1189:49 - apt have a slash proto call
hyphen V two. And now that we
1189:55 - have the Add Ave protocol in our
node modules, we can update
1190:00 - these imports to point to our
node modules instead of our
1190:03 - local files. So I'm just gonna
go ahead and tell you that the
1190:07 - islanding pledge provider is
that Ave slash protocol hyphen V
1190:12 - to slash contracts slash
interfaces. And then data types
1190:17 - dot soul is gonna be at of a
protocol hyphen v2 slash
1190:22 - contracts slash, proto call
slash libraries, slash types,
1190:28 - data types, that's all again to
make sure this is right, yarn,
1190:32 - Hardhead compile or hh, compile.
And Cool. Looks like I did that
1190:36 - right? Lending pool equals await
ethers dot get contract at,
1190:41 - we're going to be using lending
pool, I lend the pool here,
1190:44 - we're going to use this lending
pool address got from the
1190:47 - addresses provider. And then the
account, which is going to be
1190:51 - our Deployer. And now we can do
return lending pool. And if we
1190:57 - want, and now that we have this
function get lending pool backup
1191:03 - in our main function, we can say
const lending pool equals a
1191:08 - weight, get lending pool and
then pass the Deployer. And then
1191:12 - we can even do a little console
dot log,
1191:15 - lending pool address and then do
lending pool dot address. And
1191:22 - since we're making it forking,
we can kind of just keep running
1191:24 - this right. So we'll do yarn
hardhat run scripts. Ave Baroda
1191:30 - Jas, there are multiple
artifacts for contract II
1191:33 - lending pool addresses provider.
And this is because in our node
1191:37 - modules, import all this stuff
from contracts and in here, and
1191:42 - there's already in islanding,
pool addresses provider in those
1191:45 - add ons slash contracts. So
actually, we don't even need
1191:48 - this, I lending pool added
service provider, we can go
1191:51 - ahead and delete it. Our time
right now is getting confused.
1191:54 - It's saying Oh, are you
referring to the one that you
1191:57 - downloaded from NPM or the one
that you made, which which one
1192:01 - do you want to use. So we'll
just make it easier for hardhat.
1192:04 - And we'll say okay, well, we'll
delete the one that we created,
1192:07 - we'll use the one that we've
downloaded here. And now we
1192:09 - should be good to run this
again. Because now there's only
1192:12 - one for to pick from, which is
the one we downloaded from NPM.
1192:16 - And perfect, we get our get
weath printout here, and then we
1192:20 - get lending pool address is
here. And this is going to be
1192:22 - the actual lending pool address
on ether Aetherium main net. So
1192:26 - if we go back to ether scan,
copy that address and paste it
1192:29 - and ether scan, we can see it's
even labeled Ave v two, and we
1192:34 - can see a ton of transactions
going through all the time. And
1192:38 - ether scan is having a hard time
keeping up with all the
1192:39 - transactions. So we've got the
lending pool address, we've got
1192:42 - some web token, what do we need
to do? Now we want a deposit of
1192:47 - what do we need in order to
deposit the token? Well, if we
1192:50 - look at the deposit function in
the avec GitHub, we can scroll
1192:54 - in here and we see it eventually
we'll call this safe transfer
1192:58 - from which is basically going to
be this transfer from function,
1193:01 - since we're calling transfer
from it's going to be this
1193:04 - contract, that's actually going
to pull the money out of our
1193:08 - wallet. So in order to give the
Ave contract, the ability to
1193:12 - pull the money out of our
wallet, we need to do what we're
1193:15 - going to need to approve the
contract. So first, before we
1193:19 - can even deposit we're gonna
need to approve it to get our
1193:22 - web token, we're gonna have to
get the Web Token first. So
1193:25 - let's get the Web Token address
we'll say const Web Token
1193:29 - address, equals and this is
where we marginalize it and get
1193:33 - it from our hard head helper
config. But for now, we can just
1193:36 - hard code it, the Web Token
contract address is going to be
1193:39 - the exact same thing as what's
in get web and then want to
1193:42 - approve. So let's write an
approved function because we're
1193:46 - going to use this a couple
times. So we'll make an async
1193:48 - function and approve ERC 20
1193:54 - And we'll take a contract
address a spender address, which
1194:00 - is going to be the contract that
we're going to give the approval
1194:03 - to to spend our token and amount
to spend so exactly how much we
1194:08 - want to prove it. And then an
account to do all this on. So in
1194:13 - here we'll say const ERC 20
token equals await ethers dot
1194:19 - get contract at. And we could
say I WEF but maybe we just want
1194:24 - like a simple ERC 20 token
interface. And we're going to
1194:28 - grab that by cheating a little
bit coin to our hard head defy
1194:31 - FCC. We're going to go to
interfaces and grab this
1194:34 - interface from here. So we're
going to copy this, paste it in
1194:37 - here New File IO ERC 20 dot som
paste and now we have an ABI for
1194:43 - ERC. 20s So we'll do get
contract that ERC 20 Actually
1194:48 - let's change this name to ERC.
20 address so we're going to get
1194:51 - the contract with the ABI of IRC
ERC 20 at contract address ERC
1194:57 - 20 address and then we'll
connect it to our account here.
1195:01 - So and once we have the ERC 20
We can do const TX, we're going
1195:06 - to do that approve transaction
we'll do a weight ERC 20 token
1195:11 - dot approve spender address, and
then amount amount to spend.
1195:18 - We'll do we'll do a wait TX dot
wait for one block. And we'll do
1195:22 - a little console dot log saying
approved. Now if you don't run
1195:27 - this function before you try to
deposit you'll just get an error
1195:30 - saying hey, token is not
approved, which is a pretty
1195:32 - common error. So if you ever see
that just know, I forgot to
1195:36 - approve my token. So backup in
our main script, we'll go ahead
1195:39 - and run this function. We'll say
await approve ERC 20 with the
1195:44 - Web Token address lending pool
dot address because we want to
1195:48 - give the len pool the approval
to pull our web token from our
1195:53 - account. And then we'll give it
some amount to actually will
1195:57 - import a mount from get weath as
well. Mount we gotta go back to
1196:01 - get with an export it so we can
actually import it. So get with
1196:05 - exporting that amount that 0.02.
So we'll prove the amount and
1196:10 - then we'll connect we'll have
our Deployer do it obviously
1196:12 - because we're doing everything
with the Deployer. So we'll
1196:14 - approve the ERC 20. And then
once we approve, we can go ahead
1196:18 - and deposit it. So we'll say
console dot log, depositing
1196:22 - that. And then we'll run await
lending pool dot deposit. If we
1196:28 - look at the deposit function, we
can see all the parameters that
1196:33 - the deposit function takes. We
can also see it in the Ave v2
1196:37 - documentation and we just look
forward the posit. And we can
1196:40 - see it takes the address of the
asset that we're going to
1196:42 - deposit how much of that asset
we're going to deposit address
1196:46 - on behalf of we're going to do
it on behalf of ourself and then
1196:49 - a referral code, which right now
is just always going to be zero
1196:52 - because the referral code has
been discontinued. So we're
1196:55 - going to deposit the wet token
address, we're going to deposit
1196:58 - our web token, we're going to
posit 0.02 of that web token.
1197:04 - And then we're going to use a
deployer ash and then referral
1197:07 - code is going to be zero. And
then we'll do a little console
1197:09 - dot log the positive. So let's
try this script. Let's see if it
1197:14 - works. I'm just going to hit up
to go ahead and rerun this
1197:18 - script to rerun this command I
just ran into doing a little
1197:21 - compiling that ERC 20. That song
was compiled one solidity file,
1197:25 - got a bunch of wrapped Aetherium
lending pool address. We
1197:29 - approved it, we deposit we were
depositing it and then we
1197:32 - deposited it. So if we're
looking at our little readme
1197:37 - here, we get a little checkmark.
1197:42 - We've done step one, we've
deposited our collateral.
1197:46 - Awesome. So now we have some
collateral to use to borrow
1197:49 - other assets. Great. So now
we've deposited let's go ahead
1197:53 - and learn how to borrow now
through a couple of new lines,
1197:56 - and we'll say borrowed time. So
in order for us to borrow, we
1198:01 - probably want to know how much
we can borrow. And we want to
1198:05 - know more about our account,
right? We want to know how much
1198:09 - we have borrowed, how much we
have in collateral and how much
1198:14 - we can borrow. So there's a
function that Avi comes with
1198:18 - called Get User account data,
which will return the user's
1198:21 - account data across all
reserves, how much collateral we
1198:24 - have down the total value it in
its eath price, we have the
1198:28 - available borrows and eath
current liquidation threshold,
1198:32 - loan to value etc. Now these are
really important metrics. If we
1198:36 - have one, eath and collateral
that doesn't mean we can borrow
1198:39 - one eath of assets. Each one of
these tokens have some different
1198:43 - values like loan to value. For
example, if you have one eath
1198:48 - you can only borrow zero point
75 for the dye token, this is to
1198:53 - reduce risk of the collateral
and reduce risk of people not
1198:57 - having enough collateral down as
prices fluctuate. There's a
1199:01 - liquidation threshold of 80% if
you have one eath as collateral
1199:06 - and point 81 eath borrowed,
you'll get what's called
1199:10 - liquidated. So what is
liquidation? When you put down
1199:14 - collateral and you borrow, if
the amount that you have
1199:16 - borrowed past this liquidation
threshold is passed that 80% Or,
1199:20 - or depending on different
assets, it's different people
1199:23 - can do what's called liquidate
you. This is when they pay back
1199:26 - some of your loan that you took
out. And they also get to buy
1199:31 - some of your collateral at a
cheaper price. This keeps the
1199:35 - Ave platform solvent, and it
makes it so that there's never
1199:39 - more borrows than there are
collateral in order to borrow
1199:43 - assets, we still need that
collateral down. So basically,
1199:46 - if you borrowed more money than
you've put up, other users can
1199:49 - can take the money that you've
put up in return for them paying
1199:52 - for your loans. So we obviously
don't want this to happen. And
1199:56 - the audit protocol
programmatically doesn't want to
1199:58 - have not enough money to do
this. So they incentivize users
1200:01 - to liquidate, in case of these
failures is the protocols come
1200:04 - with this thing called a health
factor, which if this health
1200:08 - factor is below one, you go
ahead and you get liquidated,
1200:11 - the actual function to liquidate
somebody is called liquidation
1200:15 - call. So you can actually build
a bot and you can liquidate
1200:18 - users who go insolvent and you
can make a fee, you can make a
1200:21 - reward for actually doing this.
These protocols need to stay
1200:25 - solvent, they need to have
enough money to lend out. And
1200:28 - they programmatically enforced
this, which is why it's so
1200:30 - great. You can learn more about
liquidations in the liquidation
1200:33 - documentation. So this get us
account data will tell us how
1200:37 - much we have collateral, how
much we have in debt, and how
1200:40 - much we have available to borrow
based on how much collateral we
1200:43 - have. We can see the current
liquidation threshold we can see
1200:46 - the loan to value and then we
can see our health factor, which
1200:49 - is obviously really important.
If our health factor ever falls
1200:53 - below one, we get liquidated. So
we never want this hell factor
1200:56 - to fall below one when we're
borrowing assets. So let's
1200:59 - create a function that can grab
that first. So let's create a
1201:01 - new function called async.
Function get it borrow user
1201:08 - data, and we'll pass in the
lending pool contract, we'll
1201:12 - pass in the lending pool
contract and the account that we
1201:15 - want to get the data for. So we
can say const. And actually, we
1201:18 - can pull out just the values
that we want, we could pull out
1201:21 - the total collateral eath total
debt eath and the available to
1201:24 - borrow. Let's just pull out the
total collateral eath the total
1201:31 - debt if and the available,
borrows. So this equals await,
1201:41 - lending pool dot get user
account data of account. And now
1201:49 - we'll even just kind of logged
us out we'll say console dot log
1201:54 - you have total collateral eath
worth of eath the positive
1202:04 - console. Log you have total debt
eath worth of eath borrowed and
1202:19 - then console dot log you can
borrow
1202:24 - available borrows eath worth of
eath. And then we'll just return
1202:32 - available to borrow will turn
available borrows eath. And
1202:36 - we'll return or total debt, we
don't really need to return
1202:39 - total collateral we could if we
want we really just want to
1202:41 - print it out here. So now back
in our function, we can do in
1202:46 - our main function, we can run
let, I'm going to do that
1202:50 - because we're going to be
calling this a few times
1202:53 - available borrows eath. And
total debt eath
1203:00 - equals await, get borrow user
data of lending pool and
1203:05 - Deployer. And if we run this,
we'll see how much we can
1203:08 - actually borrow yarn hard hat or
just h h run scripts on a
1203:14 - borrowed.js and work on our
forked blockchain here. And
1203:18 - remember, it is going to be a
little bit slower. And this is
1203:20 - kind of one of the disadvantages
too because it does have to make
1203:23 - API calls whenever we want to
interact with these chains. And
1203:26 - then we got total collateral
eath is not defined. And that's
1203:29 - because I spelt total wrong. So
let's spell total correctly. And
1203:34 - we'll run this again. But okay,
great. So you have this month's
1203:38 - worth of eath deposited, you
have zero worth of eath borrowed
1203:42 - because we haven't borrowed
anything, and you can borrow
1203:44 - this much worth of eath.
Remember, the amount that we can
1203:47 - borrow is always going to be
less than the total amount that
1203:50 - we have as deposited. That's why
we see this lower number here.
1203:54 - So cool. So that's how much we
can borrow. Let's use that to go
1203:57 - and borrow some time. So we have
this total amount we can borrow
1204:01 - an eighth and we're gonna get to
borrow time. I promise we're
1204:04 - gonna get to borrow time, but we
need to figure out What's the
1204:07 - conversion rate of diets? We're
gonna get how much we can borrow
1204:10 - in eath. But we want to borrow
dye. So how much of dye can we
1204:14 - borrow based off of the value of
eath? And to do that, we're
1204:17 - gonna have to get the dye price.
And how are we going to do that?
1204:20 - Well, you guessed it, we're
going to use chain link price
1204:22 - feeds. If you look in the AVI
documentation, you can find
1204:25 - price Oracle, which is a
contract that you could actually
1204:28 - use right directly from Avi. But
the first thing it does is check
1204:32 - from a chain link aggregator,
which we already know how to do.
1204:34 - So we're gonna go ahead and just
call directly from the chain
1204:37 - link aggregator. So let's create
a new function function, we'll
1204:40 - call it get dye price is first
we're going to need to get that
1204:44 - interface, same thing. So you
can either go right to Hardhead
1204:48 - defy and just grab the interface
right from here, we could swap
1204:52 - this out with just an import
from chainlink NPM, as well. But
1204:56 - I'm just going to go ahead and
copy paste a new file, this is
1204:59 - going to be the Ag reg gate, Tor
v3 interface. Dot saw that we've
1205:04 - worked with so many times. Now
that we have this interface,
1205:07 - this will compile, we're
obviously looking for latest
1205:10 - round data, which will give us
this answer here, which is going
1205:13 - to be the price. So let's go
ahead and grab that. So we'll
1205:15 - say const di eath price feed
equals await ethers dot get
1205:21 - contract at and we'll use the
air, Greg a Tor v3 interface
1205:27 - will get the dye eath price feed
right from the chain link Docs.
1205:30 - So we go to docs dot chain dot
link UVM chains will go to
1205:35 - contract addresses on Aetherium.
Or look for di eath on Main net.
1205:40 - And we see di eath is right
here. So we'll grab this and
1205:43 - again, we're just hard coding it
in the GitHub repo associated
1205:46 - with it. With this, we put it in
a little config file, but we can
1205:50 - just go ahead and hard coded in.
And for this one, we don't need
1205:53 - to connect this to the deployer
account. Since we're not going
1205:56 - to be sending any transactions,
we're just going to be reading
1205:59 - from this contract, right. So
reading don't need a signer
1206:02 - sending me to signer. Now we can
say const price equals a weight
1206:08 - dye eath price feed dot latest
round data. Now latest round
1206:15 - data, as we know is going to
return us this huge thing. And
1206:19 - we only want the answer at the
first index. So another way we
1206:23 - could do this, we could just
wrap this whole thing up. And
1206:25 - then once this returns, we're
gonna say okay, just grab that
1206:28 - first index here, which will be
that price. And then we could do
1206:31 - a little console dot log, the dy
eath. Price is in price dot two,
1206:40 - like that, and then return
price. So we can go ahead and
1206:43 - run this as well test this out,
just by hitting up and then
1206:46 - enter. Depositing we deposited
this is how much we can deposit.
1206:51 - Nothing Oh, and I forgot to call
it oh, excuse me, let's go up.
1206:54 - This, let's say const dye price
equals await get dye price. And
1207:01 - tada. The dye youth price is
this big number, which of course
1207:05 - we know is going to be $3,289
which is which of course is
1207:09 - gonna be 3289 di per eath. Now
that we have the dye price, we
1207:15 - can figure out how much dye we
want to borrow. So great, we
1207:18 - have the price. Now let's figure
out the amount that we can
1207:21 - borrow in dye, we have the
amount we can borrow eath, we
1207:25 - need to convert it to die. So
we'll say const amount die to
1207:29 - borrow equals available, be the
available borrows in eath.to
1207:36 - string. And then in JavaScript,
we can do this.to string but
1207:41 - still do math. So times 0.95
times and then we'll do the
1207:47 - reciprocal of that die. So one
divided by die price.to number.
1207:53 - So this will give us the amount
of die that we can borrow. And
1207:58 - then we'll want to get this in
way. So if we print this out
1208:01 - right now, console dot log, you
can borrow.
1208:08 - Run this now, you can borrow
amount die to borrow. Not in way
1208:14 - units, which we need in way
units, but you can borrow 48
1208:17 - Die, which based off the price
looks about right. So to get the
1208:21 - correct units, we'll say const
amount, di to borrow way. That's
1208:27 - going to equal ethers dot utils
dot parse ether, MT di to
1208:33 - borrow.to string. This is just
purely the amount of dye to
1208:37 - borrow right so we get 48.79
die. But again, we want that in
1208:42 - way the die token has 18 decimal
places similar to Aetherium. So
1208:47 - we need that amount in way and
then we can go ahead and start
1208:50 - actually borrowing now. So we'll
create a new function called
1208:53 - borrow die async function,
borrow die will take the die
1208:58 - address. Take the lending pool,
take the amount die to borrow
1209:05 - and weigh in Then of course,
we'll take the account. And all
1209:09 - we'll do is we'll do const.
Borrow TX is going to be a
1209:13 - weight, lending pool dot borrow,
die address, amount die to
1209:20 - borrow. And again, we can go
right to the documentation, if
1209:25 - we want, it takes the address of
the asset, the amount, we want
1209:28 - to borrow the interest rate
mode, which is going to be
1209:30 - variable or stable, the referral
code and then address on behalf
1209:34 - of, we're going to say one for
the interest rate mode, where
1209:37 - one is going to be stable. And
then we're going to do zero or
1209:41 - this referral code because
that's debunked now, and then
1209:44 - we'll do a count, then we'll do
a wait, borrow TX dot Wait, wait
1209:49 - one transaction, and then we'll
do console dot log you've
1209:56 - borrowed. Well, and that's it.
So we now have this borrowed I
1210:00 - function. So back up in our main
function, right, now, we can
1210:04 - finally do the borrow time. So
we'll do a wait, borrow die. And
1210:09 - we'll pass those parameters in
here. So we're going to do
1210:12 - const, die token address, equals
and we're just going to hard
1210:16 - code this from main net. So we
can look up die token address,
1210:21 - main net, we'll grab this
address here, this looks like
1210:24 - this is indeed the DI token, we
check right on the object get
1210:27 - up, we could check right on the
ABI of actual code, since we're
1210:30 - just testing, we're just gonna
go ahead and grab from ether
1210:32 - scan here. So for borrow dye,
we're gonna need the dye token
1210:36 - address, we're gonna need the
lending pool contract the amount
1210:41 - of dye to borrow in way, and
then our Deployer. And then
1210:46 - we'll await borrow dye. And then
we will run this get bar user
1210:51 - data again, just print out the
information about where we are
1210:55 - after we do that. So when we can
run this, again, we should see
1210:58 - the amount that we have
borrowed, updated, our first
1211:02 - call to that function is gonna
say, Hey, you have this much eat
1211:05 - the positive Do you have nothing
borrowed, you can borrow this
1211:08 - much eath, we get the price, we
get how much we borrowed, we
1211:11 - borrow. And now it says you have
this much where the eath
1211:15 - deposited and you have this much
worth of eath borrowed and you
1211:18 - can borrow this much eat. So we
actually now have bought a bunch
1211:23 - of this dye actually borrowed.
And the reason we're doing times
1211:26 - zero point 95, we don't want to
hit that cap of the maximum
1211:29 - amount that we can borrow. So
we're saying hey, let's get 95%
1211:33 - of the amount that we actually
can borrow. So we're not going
1211:35 - to borrow everything, we're just
gonna borrow 95%. And you can
1211:39 - see that the amount of eath we
have deposited is actually
1211:41 - higher. This is because we're
actually gaining interest just
1211:46 - by having this eath deposited.
And now that we have some dye
1211:50 - borrowed, we borrowed 48 dye,
which is equivalent to this much
1211:54 - Aetherium. And then we still
have a little bit more we can
1211:56 - borrow because we only borrowed
95%, which is great.
1212:03 - Awesome, we've taken out a
borrow programmatically, let's
1212:07 - repay at least some of it here.
So we're gonna have to create a
1212:10 - new function that's going to use
the repay function in the
1212:15 - contract. So we're gonna do
async function repay, and this
1212:19 - is going to take the amount that
we want to repay the dye address
1212:24 - that we're going to repay the
lending pool and then the
1212:27 - account now to repay once again,
we're going to have to approve
1212:32 - sending our dye back to Ave So
in here, the first thing we need
1212:36 - to do is we actually need to
call wait prove ERC 20 with the
1212:43 - dye address, lending pool dot
address, mount and then
1212:49 - accounts, right because approve
ERC 20. That's the input
1212:53 - parameters it takes, and we need
to approve sending the dye back
1212:56 - to the contract. So we borrowed
it, and we're gonna send it
1212:59 - back. Now we're actually going
to send it back. So let's say
1213:02 - const, repay TX equals await,
lending, cool that repay the
1213:08 - address, amount, one account.
And then we'll say await repay
1213:14 - TX dot Wait, that will do
console dot log repaid up in our
1213:21 - main function, we're going to do
a weight repay, and we're going
1213:25 - to give it the amount dye to
borrow in way. We're gonna give
1213:30 - it the dye token address, give
it lending pool, and then we'll
1213:34 - give it deployer get you borrow
user data one more time just so
1213:38 - we can print out the final
amounts. Now, you'll notice
1213:41 - something though, we're going to
give back all of the dye that we
1213:45 - borrowed. However, we're still
going to have a dye balance,
1213:48 - you'll see that when I run this
that we're still have a little
1213:51 - bit of Aetherium borrowed,
basically, we'll still have a
1213:54 - dye balance because we'll still
have a little bit of die borrow
1213:56 - and try to figure out why before
I answer it actually. So we have
1214:01 - this tiny, tiny tiny amount of
eath borrowed here and we have a
1214:05 - much larger amount of eath
deposited so Why do we still
1214:08 - have this tiny, tiny amount of
eath borrowed? Well, the reason
1214:12 - is because as we borrow dye, we
actually accrued interest. So we
1214:16 - still owe dye back. Now what we
can do is we can do something
1214:20 - like uniswap, to actually swap
our Aetherium, for dye to repay
1214:25 - the rest of our debt here. And
that's how we could actually
1214:27 - finish repaying all the debt is
to get a little bit more dye to
1214:31 - pay off that interest that we
had accrued. And if you want,
1214:34 - you can go back and you can do
the exact same thing we did here
1214:37 - to grab the uniswap code, place
it in here to programmatically
1214:41 - repay your debt as well. But at
this point, you have just gone
1214:45 - through the entire lifecycle
here. And that is absolutely
1214:48 - massive, huge congratulations.
You've just deposited borrowed
1214:53 - and repaid tokens from the AVI
protocol. Now I'm going to go
1215:00 - briefly show you what some of
these transactions are going to
1215:03 - look like on an actual test net,
on an ether scan, you'll see
1215:08 - that when we deposit our
collateral, we actually get back
1215:12 - what's called an A token, or an
interest bearing token, these
1215:16 - tokens keep track of how much
collateral or in our case how
1215:20 - much web token we have deposited
in the AVI protocol. And when we
1215:25 - want to withdraw our wealth
back, we burn these eight
1215:29 - tokens, we remove these eight
tokens, you can see that our
1215:32 - first transaction is going to be
deposit and I wanted to show you
1215:35 - what it looks like when you
actually deposit one of these
1215:37 - tokens, this transaction
associated with this lending
1215:40 - pool, that deposit right here,
if you look at tokens transfer
1215:43 - down here, you can see we
actually we deposited, you can
1215:47 - see that we actually sent rapt
ether to the ARB a contract. Now
1215:52 - you'll also see this a weath
stuff here. So what is this a
1215:56 - with stuff. So to keep track of
how much you've actually
1216:00 - deposited into Ave, Ave will
give you your own a wealth token
1216:05 - or a token to keep track. And
this is this interest bearing
1216:09 - token, you actually can see up
here a little bit of interest
1216:11 - already for actually depositing
these tokens into the protocol.
1216:15 - And it's this token, that will
keep going up, the more people
1216:19 - borrow and the more people use
the protocol. So you can
1216:21 - actually grab this token
address, interest bearing token
1216:24 - this a token, I can import it
into my meta mask. And I can see
1216:29 - that I have 0.1, which
represents my initial deposit
1216:32 - 00517 dot that dot A with and if
you keep this up long enough,
1216:39 - this number will slowly go up as
you get more and more. Because
1216:44 - the interest keep out and you
can see just went went up right
1216:48 - there, the interest will keep
changing and keep going up.
1216:51 - Obviously, we have so little
deposited that the interest
1216:53 - isn't gonna go up very quickly,
but it will go up, the more
1216:56 - people use the protocol. And
since I'm using a test net, the
1216:59 - actual usage of the protocol
isn't very high, but you get the
1217:03 - picture.
1217:06 - Awesome, you've done phenomenal
to get this far. Let's do a
1217:09 - quick recap of everything that
we've learned. And then we'll
1217:12 - head on to the next section. So
first, we learned about the web
1217:16 - token or the wrapped Aetherium
token, it's a way to tokenize
1217:20 - our Aetherium or layer one
blockchain native token. Then we
1217:24 - learned a little bit about the
AVI protocol, and how it's this
1217:27 - defy primitive for borrowing and
lending assets. And we can
1217:30 - actually gain interest by
depositing our tokens and our
1217:34 - assets into Ave we learned a
little bit of also about
1217:37 - uniswap, which is another
incredibly important defy
1217:40 - protocol, which allows us to
swap tokens between each other
1217:43 - in the decentralized context,
then we learned that we can
1217:47 - actually deposit some of our
tokens into the AVI protocol,
1217:51 - which is a decentralized
borrowing and lending platform
1217:53 - and similar to a bank will
actually gain interest on our
1217:57 - deposited tokens. But first, we
have to approve them. Because
1218:00 - anytime you want a contract to
interact with your tokens, you
1218:04 - need to approve the contract to
do so. And then we go ahead and
1218:07 - deposit once we deposited we got
the dye price. And then we
1218:12 - learned that we can actually
borrow dye we can borrow an
1218:16 - asset based off of how much
collateral we put down. And then
1218:19 - we learned how to repay it back.
We learned about forking a
1218:22 - blockchain as opposed to using
our own main blockchain. Another
1218:26 - thing to know if you are using
an RPC URL like something from
1218:29 - alchemy so awesome you've
learned a ton about defy now
1218:32 - defi is an absolutely massive
powerhouse when it comes to the
1218:36 - blockchain. And it is one of the
most important things
1218:39 - blockchains can do. If you want
to learn more about defy and
1218:42 - read more on Defy. I've got some
more links in the GitHub here so
1218:46 - that you can learn more about
defy and one of them in
1218:48 - particular that I want to show
you is this one called speed run
1218:53 - Etherium. Not only does it give
you a ton of defy examples, but
1218:56 - it gives you a whole bunch of
other examples as well. And this
1218:59 - will be a good test of
everything that you've learned
1219:01 - after you pass this course. Or
even right now if you want to or
1219:04 - whenever you want and to talk
about it a little bit more, we
1219:08 - actually have Austin Griffiths
here to talk a little bit more
1219:10 - about speed run Aetherium
himself, I'll pass it over to
1219:13 - Austin.
1219:16 - Hey, what's up, I'm Austin
Griffith, I want to show you
1219:18 - speed run Aetherium. speed run
Aetherium is a great way to get
1219:21 - started in Aetherium. If you are
a developer, it's targeted at
1219:25 - web two developers becoming web
three developers speed run a
1219:28 - theory. m.com is the website. It
takes you through both getting
1219:32 - started and kind of getting
getting an idea for the language
1219:35 - and the syntax. But that's just
the start. Just understanding
1219:39 - the language is just the start,
you feel like you're you can do
1219:42 - anything. And you're on the top
of the world when you finally
1219:44 - get the syntax of solidity
together, and you can jam
1219:46 - through a smart contract. But
really getting context with the
1219:49 - space and figuring out what
works and what doesn't, that's a
1219:52 - whole nother battle. And that's
where speed run aetherium.com
1219:55 - comes in. So let's speed run the
speed run. First, you will get
1220:01 - scaffold e down speedrun
Aetherium kind of revolves
1220:05 - around scaffold eath and uses
scaffold eath as a base, you'll
1220:09 - want to tinker around with some
ideas within solidity. And let
1220:12 - me show you what I mean by that.
So with scaffold eath, you have
1220:16 - a front end and you have your
smart contract. So scaffold eath
1220:20 - comes with hard hat out of the
box. And you will use the
1220:24 - combination of hard hat and
react to build a DAP where
1220:28 - you'll deploy both the smart
contract and the front end. And
1220:32 - this, this ability to edit your
smart contract and have your
1220:37 - front end auto adapt to it is
kind of the key to scaffold
1220:41 - ease. I just added some extra
extra exclamation points. But
1220:44 - we'll see that show up over
here. Once this contract
1220:46 - deploys, there we go, there's
that. So just real quick, again,
1220:50 - if I create like a un 256 public
counter, and we set that equal
1220:55 - to five, and then I build a
function called increment,
1220:59 - that's public that does counter
public, there we go, that does
1221:04 - counter plus, plus, you can
imagine what's going to happen
1221:07 - here. So you, you edit a little
bit of solidity, you deploy your
1221:11 - contract, and then your front
end auto adjust to that. And it
1221:14 - gives you the ability as a
developer to call those
1221:19 - functions tinker with your smart
contract to play around, you can
1221:22 - even have a console log in
there, where it you know, sets
1221:27 - says the count now is there we
go something like this. And
1221:32 - let's go ahead and deploy that.
Notice I'm doing these quick
1221:35 - iterations, I'm making small
changes in solidity, and I'm
1221:38 - seeing those changes show up in
the front end. And I'm tinkering
1221:41 - with those in the front end and
testing my assumptions. Here, if
1221:45 - we go look at our hard hat node,
when I make this increment call,
1221:50 - we should see that nice console
log there, you know, this
1221:53 - address, set the count to eight,
right? Very, very cool. So this
1221:58 - is scaffold eath. This is what
speed run Aetherium is built on
1222:01 - top of, you'll get in here,
you'll edit your smart contract,
1222:04 - then you'll edit your front end,
you'll point your front end at
1222:06 - some particular network, you'll
deploy your smart contract,
1222:09 - you'll deploy your app, it just
gives you the ability to have a
1222:12 - front end along with your smart
contract. And you'll have that
1222:16 - as you're building your smart,
smart contract. So to have this
1222:19 - front end, to tinker with your
smart contract is going to help
1222:22 - you kind of figure out how you
want to write your solidity,
1222:25 - like, is this going to be a
mapping? Is this going to be an
1222:27 - array? How am I going to track
this struct, you can kind of do
1222:31 - this in an iterative process by
just throwing it in here into
1222:34 - your smart contract and
tinkering with it on the front
1222:36 - end and trying it out and seeing
what you need to build. So
1222:40 - that's scaffold eath. And that's
the base that you'll need to get
1222:43 - started with speed run Ethereum.
Once you've you're able to have
1222:47 - this all installed, you'll
you'll have your kind of react
1222:49 - front end here with yarn start,
you'll have yarn chain, which
1222:52 - will run your your hard hat
node, then you'll do yarn
1222:54 - deploy. Once you have that setup
locally, you're ready to go with
1222:59 - speed run Aetherium. And you can
also do this right here and
1223:02 - challenge zero. So challenge
zero, gotta go zero index,
1223:06 - right, we got to be nerdy
challenge zero sets you up with
1223:09 - just getting the environment
setup, you'll you'll quest on
1223:13 - building a simple NFT example.
It's going to come with an NFT
1223:17 - smart contract. And it's going
to come with an NFT front end a
1223:20 - little kind of like minting
view, it'll come with all of
1223:24 - this stuff to do that. And it'll
walk you through basically
1223:27 - challenge the row is going to
hold your hand, it's going to
1223:29 - take you through every step
you'll have to get get you have
1223:32 - to have a certain version of
node E, L some some correct
1223:37 - range of node and yarn
installed. Watch out yarn has an
1223:40 - executable on Linux, make sure
you have the yarn, the package
1223:44 - manager. But after you have get
your node and yarn, you'll run
1223:48 - through cloning down each
challenge. You'll do an install,
1223:53 - you'll fire up the chain and
you'll fire up your front end.
1223:55 - And you'll have a working app
that lets you interface with
1223:58 - your NFT smart contract. You'll
go through here and you'll learn
1224:02 - about wallets. Then you'll start
minting NF Ts and you'll send
1224:06 - those NF T's are Round. And
that's challenge zero, it's just
1224:09 - getting you started. Here even
in challenge zero, you'll deploy
1224:14 - this NFT to Rinkeby. And you'll
also deploy an app and allow
1224:18 - your friends to go to your app
and mint in FTS on Rinkeby. So
1224:22 - that's the first challenge, it
looks like we even like dive
1224:25 - into open see and play around
with some of those mechanics.
1224:28 - The second challenge challenge
number one challenge one of
1224:32 - speed runner theory is like
where it all really starts. This
1224:36 - really shows off the superpower
of Aetherium. It sets it up. So
1224:40 - you need to build an app where a
bunch of people that don't
1224:44 - necessarily trust each other,
can coordinate and stake into a
1224:49 - smart contract. And this is
like, this is the superpower of
1224:51 - Aetherium. The ability for you,
the developer to write a few
1224:55 - simple rules to allow jerks to
coordinate financially, and not
1225:00 - greet each other and steal each
other's money, right? You're
1225:03 - we're building these financial
systems, there's, you know, game
1225:06 - theory and economics and so many
other things going on here. But
1225:09 - you as the developer, you're
writing simple rules, and you're
1225:12 - building a system that allows
people to coordinate. So
1225:15 - challenge one, we'll take you
through how to get set up with
1225:19 - your steak or docile, smart
contract, you'll install
1225:22 - everything exactly the same way,
you'll fire everything up. And
1225:25 - then it's just going to walk you
through the kinds of things that
1225:27 - you will need in your smart
contract. But you'll have to
1225:29 - write the solidity yourself. So
this is this is not going to be
1225:33 - a handheld tutorial, hell thing,
you're going to have to write
1225:38 - the smart contract yourself. And
there's some guidelines and some
1225:41 - rails that kind of help you out,
but it's not going to do it for
1225:44 - you. Okay, so that's, that's
Quest One is or that's
1225:47 - challenge. One is building a
decentralized staking app. Then
1225:51 - challenge two is building a
token vendor this so in
1225:55 - challenge one, you'll learn
things like how to send money
1225:58 - into a contract, how to have a
contract, keep track of
1226:01 - mappings. In challenge two,
you're going to learn contract
1226:04 - to contract interaction, you're
going to learn about ERC 20s,
1226:08 - you're going to learn about
specifically the approved
1226:11 - pattern, which is kind of a
jerk, it's, it's hard, it's a
1226:14 - hard thing to deal with is the
approved pattern, you need to go
1226:18 - to your token contract and
approve the vendor to take some
1226:21 - money, then in a second
transaction, you need to go to
1226:23 - the vendor and have the vendor
grab the money from the token
1226:27 - contract and do something else.
So that's that's challenge two
1226:31 - is learning about tokens and
vendors, and is starting to
1226:35 - really like get you kind of
exposed to the idea of this like
1226:39 - massive multiplayer game that is
Aetherium. And also kind of like
1226:43 - how to build these vending
machines that anybody can get
1226:46 - to, then you'll build a Dex. Now
once you've once you're done
1226:49 - with 01. And two, you're really
kind of you have a license to
1226:53 - learn at this point, you're
you're ready to really like go
1226:55 - do some damage and build some
cool things, maybe go build a
1226:58 - couple other things, but come
back and come come hit challenge
1227:01 - three, challenge three is going
to be a little bit more open
1227:04 - ended, there's going to be a
cohort of other people that are
1227:08 - also building this. And you have
to get through the first three
1227:11 - challenges to even get to
challenge three to even get to
1227:14 - this chat room. But there's a
chat room where other developers
1227:17 - that are also building their own
decks are all there together,
1227:20 - and you can kind of learn with
them and chat with them. But
1227:23 - you're going to build an
exchange. And you're going to
1227:25 - build an exchange that works in
a smart contract in a
1227:28 - decentralized way with no
centralized breaking points. And
1227:33 - what that's going to mean is
you're going to have to have
1227:35 - reserves of both eath and tokens
and you're gonna have to have a
1227:37 - pricing function and LP tokens
and all sorts of other things
1227:41 - that you'll have to learn about
as you get to it. Then challenge
1227:44 - five is a multi SIG wallet. Such
a fundamental important thing
1227:49 - about how to store your eath
safely is going to be in a multi
1227:52 - SIG wallet and how you can have
multiple identities even even
1227:55 - like the the base of like what a
Dow is, is sort of like starting
1227:59 - with a multi SIG wallet. And
you'll need to build one of
1228:02 - those you'll need to understand
call data call data is super
1228:05 - weird and complex. And
everything's a transaction even
1228:08 - when you're just poking a
contract. It's a transaction,
1228:10 - and you have to craft that call
data correctly to say, I would
1228:15 - like to call this specific
function on this specific
1228:17 - contract. So that's multisig
wallets and then it kind of ends
1228:21 - up we've got more challenges in
the pipeline, but it kind of
1228:23 - ends on build an SVG NFT so much
fun to build an NF t that crafts
1228:28 - the actual drawing in the smart
contract and renders it. So
1228:32 - that's the speed run, go speed
run Aetherium checkout scaffold,
1228:36 - eat start building, build
something awesome on Aetherium.
1228:39 - hearts, hearts, hearts, go get
them.
1228:41 - Austin Griffith is one of the
OGS when it comes to helping
1228:45 - engineers get caught up and up
to speed in the blockchain world
1228:48 - so massive thank you to Austin
for all he's done so far.
1228:56 - All right now we're gonna get
into NF T's. Let's do this. Now,
1229:01 - I've already made a number of
videos on what NF T's are and
1229:04 - how to start working with NF
T's. So we're going to watch a
1229:06 - portion of the previous Python
edition of this course where I
1229:10 - explain and a piece from a high
level and then of course, we're
1229:13 - gonna get into the ultimate NFT
tutorial. So let's learn about
1229:17 - NF T's look, NF T's are hot
right now. Nf T's also known as
1229:20 - ERC 720 ones are a token
standard that was created on the
1229:24 - Ethereum platform. Nf T stands
for non fungible token is a
1229:28 - token standard similar to the
ERC 20. Again, ERC 20 is like
1229:32 - link of a maker, all those
goodies that are found on the
1229:36 - Etherium chain. An NF T or a non
fungible token is a token that
1229:41 - is non fungible, this means that
they are starkly unique from
1229:44 - each other. And one token isn't
interchangeable with any other
1229:48 - token of its class. A good way
to think about it is $1 is
1229:51 - interchangeable with any other
dollar $1 is going to have the
1229:54 - same value of another dollar.
Those are fungible tokens that's
1229:57 - like ERC 20s one link is always
going to be equivalent to one
1230:01 - other link, by contrast is going
to be NF T's those of you nerds
1230:05 - out there, we know like a
Pokemon would be a good example
1230:08 - of an NFT you're one Pokemon is
going to have different stats,
1230:11 - different moves, sets, and isn't
interchangeable with any other
1230:14 - Pokemon, or maybe a more
relatable one. It's like a
1230:16 - trading card, or unique piece of
art or the like. So that's what
1230:20 - these NF T's are there non
fungible, non interchangeable
1230:24 - tokens that for the moment are
best represented or thought
1230:28 - about as digital pieces of art
that are incorruptible and have
1230:32 - a permanent history of whose own
them who's deployed them, etc.
1230:35 - Now, like I said, NF T's are
just a token standard. So you
1230:39 - can actually make them do much
more than just be art. You can
1230:41 - give them stats, you can make
them battle, you can do really
1230:44 - unique things with them, you can
do pretty much whatever you want
1230:47 - with them. But right now, the
easiest way to think about it,
1230:49 - and the most popular way to
think about it is by calling
1230:51 - them ah, ah, ah it's odd, or
some type of collectible or just
1231:00 - anything that's unique. Now,
they've been getting a ton of
1231:03 - buzz recently, because we've
been seeing more and more of
1231:05 - these being sold at insane
prices, like we saw x infinity
1231:09 - sell nine plots of their land
nine plots of their unique land
1231:13 - for $1.5 million. We also saw
the original creator of the Nyan
1231:18 - Cat, you know, this cat
1231:22 - sold for like 300 eath. So
apparently people really value
1231:26 - these things. So like I said,
they're just tokens that are
1231:29 - deployed on a smart contract
platform, and you can view them
1231:32 - on different NFT platforms like
open sea or wearable. And these
1231:35 - are the NFT marketplaces that
let people buy and sell them.
1231:38 - You obviously can do that
without these marketplaces,
1231:41 - because it's a decentralized but
they're helping give a good user
1231:44 - interface. Now, like many of you
out there, my initial thought to
1231:46 - NF T's was okay, this sounds
pretty dumb. But I think that
1231:49 - that was dumb. I think art does
have a lot of value. And I think
1231:52 - that artists are not always paid
fairly for what they do. And
1231:55 - this is actually a huge issue
right now in the modern day
1231:57 - world where an artist can make
some type of art people just
1232:00 - copy paste it, you know,
everywhere and, and they never
1232:03 - get attribution for what they
make. So having a really easy
1232:06 - decentralized royalty mechanism,
or some type of mechanism where
1232:10 - these artists can get accurately
comped for what they're doing, I
1232:13 - think, is really important. I
love music. I love movies, those
1232:16 - are pieces of art that I digest.
And I really like and I think
1232:19 - it's fair for them to get comped
appropriately because they are
1232:22 - providing value to my life. I
think NF T's are a great way to
1232:24 - solve this issue as kind of
having these decentralized audit
1232:27 - trails and, and royalty trails
that we can set up and, and see
1232:30 - really transparently without
having to go through some
1232:32 - centralized service. So that's
the basic gist of it. Let's talk
1232:35 - some more about the standards
ERC 721 standard are the NFT
1232:40 - standard. This is the basis of
it all there is another standard
1232:43 - that's semi fungible tokens, the
1155 We're not going to talk
1232:47 - about that here. But you can
check it out the main
1232:49 - differences between a 721 and
the ERC 20 and ERC. 20 is they
1232:53 - have a really simple mapping
between an address and how much
1232:56 - that address holds. 720 ones
have unique token IDs, each
1233:00 - token ID has a unique owner. And
in addition, they have what's
1233:03 - called a token URI, which we'll
talk about in a minute. Each
1233:06 - token is unique. Each token ID
represents a unique asset. So
1233:11 - since these assets are unique,
and we want to be able to
1233:13 - visualize them and show what
they actually look like we need
1233:15 - to define those attributes of
the object. If it's a piece of
1233:18 - art, we needed a way to define
what that art looks like. If
1233:21 - it's some type of character in a
game, we need to wait define
1233:24 - that character stats in the NFT.
This is where metadata and token
1233:28 - URI has come in. So if you know
anything about Aetherium, you
1233:30 - know that sometimes gas prices
getting pretty high, especially
1233:33 - when it comes to storing a lot
of space, it can get really,
1233:36 - really expensive. So one of your
first questions might be Well,
1233:38 - are they storing these images?
And these are pieces on chain?
1233:42 - And the answer is sometimes back
when they were coming up with NF
1233:45 - T's and artists were deploying
stuff, the eath devs and the
1233:48 - artists were like yeah, art,
let's do that art. I'm just
1233:50 - gonna deploy This one megabyte
image onto the Etherium chain.
1233:54 - And Oh god, it's so much gas
expensive, delete button.
1234:00 - Otherwise, it's not, it's not
good. And they realized that if
1234:05 - they put all this art on chain,
it's going to be incredibly
1234:07 - expensive. So to get around
this, what they did is they put
1234:10 - in the standard, what's called
the token URI. This is a
1234:12 - universally unique indicator of
what that asset or what that
1234:16 - token looks like and what the
attributes of the token are, you
1234:19 - can use something like a
centralized API, or IPFS. To
1234:23 - actually get that token URI.
Typical token URI has to return
1234:26 - something in this format like
this, where it has the name, the
1234:29 - image, location, the
description, and then any
1234:31 - attributes below, there is often
this talk of on chain metadata
1234:35 - versus off chain metadata.
Because it is so much easier and
1234:37 - cheaper to store all your
metadata off chain, a lot of
1234:40 - people will use something like
IPFS that is decentralized, but
1234:44 - does take a little bit of
centrality to keep persisting,
1234:46 - but they can also use their own
centralized API. However,
1234:49 - obviously, if that goes down,
then you lose your image, you
1234:52 - lose everything associated with
your NFT. Because of this most
1234:54 - NFT marketplaces actually can't
and won't read off on chain
1234:57 - attributes or on chain metadata,
because they're so used to
1235:00 - looking for the token URI.
Obviously, if you do off chain
1235:03 - metadata, you can't do anything
really cool or really
1235:06 - interesting or have any gains
with your NF T's. For example,
1235:09 - if you wanted to create an on
chain Pokemon game, all your
1235:11 - attributes would need to be on
chain in order for your Pokemon
1235:14 - to interact with each other.
Because if it was off chain,
1235:17 - then that becomes a lot harder
to cryptographically prove. So
1235:20 - if you're new with NF T's and
you're like wait, this is kind
1235:22 - of a lot of information, I'll
make it easy for you. If you're
1235:24 - looking to render an image, I'm
an NFT, add your image to IPFS,
1235:28 - add a metadata file pointing to
that image file on IPFS. And
1235:31 - then grab that token URI and put
it and set it as your NFT. The
1235:35 - chain link DND article does a
great job of walking you through
1235:38 - this and showing you how to do
this. So be sure to read that if
1235:40 - you're looking to learn how to
do that we're not going to cover
1235:42 - that in this video, but we will
be deploying our first NFT with
1235:45 - some on chain attributes. Again,
having your attributes on chain
1235:48 - is really going to allow you to
build really creative NF T's
1235:52 - that build games or have
interesting properties and and
1235:55 - really makes the authenticity of
your NFT guaranteed because
1235:58 - those attributes are always
going to be on chain.
1236:02 - Alright, so now that we know the
basics of approximately what an
1236:06 - NF t is, and similar to the ERC
20 You can see the E IP 721 or
1236:11 - the ERC 721 non fungible token
standard on the Aetherium, ie
1236:16 - IPs. And once again, if you
scroll down, you can see all the
1236:19 - different events and the
different functions that come
1236:22 - with creating this token. And
now everything that we're going
1236:26 - to do is going to be available
at this GitHub repo. This hard
1236:30 - hat NFT FCC, we're going to
actually go through all the code
1236:33 - down to deploying and creating
our own customized NFT. And I've
1236:39 - labeled this the ultimate NFT
repo as part of this course,
1236:42 - because we're going to go
through a lot here, we're gonna
1236:45 - go through a basic NFT, a real
minimalistic NFT and then an
1236:50 - IPFS hosted NFT. That is
dynamic. And it uses randomness
1236:54 - to generate unique NF T's so
that we can have provably rare
1236:59 - and appease or provably rare
cards or provably rare tokens or
1237:03 - stats or whatever you want. And
then we're going to do what's
1237:07 - called an SVG NFT. These are
entities that are 100 percent hosted on
1237:12 - chain, so you don't need an off
chain. So you don't need IPFS,
1237:15 - you don't need an off chain
database. And this one's also
1237:18 - going to be dynamic, where it's
going to use price feeds in
1237:21 - order to fluctuate what the
image of the entity actually
1237:24 - looks like based off the price
of some asset. And here are the
1237:27 - images that we're going to be
using. And we obviously have
1237:30 - these three adorable doggies
here. If you want to follow
1237:33 - along with the Quickstart, you
absolutely can. And I'm going to
1237:35 - do a quick overview of just
running the code to show you
1237:38 - what it's going to look like at
the end. Basically, what we're
1237:42 - going to do is we're going to
have our code, we're going to
1237:44 - run hardhat deploy dash dash
network, rink B, dash dash tags
1237:50 - main. And this is going to
deploy all of our contracts and
1237:53 - everything. And then finally, if
we go to test nets dot open c.io
1237:58 - And we grab the address of one
of these NF T's we should be
1238:02 - able to put it in here see our
actual NFT as a collection with
1238:06 - an item. Or Additionally, we can
just go right to the contract.
1238:10 - We can read the contract, we can
get the token URI, and then we
1238:14 - can copy this token here, I
paste it into our browser or any
1238:18 - IPFS is into our browser, and
then grab the image attribute
1238:22 - and see what this actually looks
like on chain. So with all that
1238:26 - being said, let's learn how to
build this ultimate NFT repo and
1238:30 - build all of these different
customizable NF T's let's jump
1238:34 - in. So once again, we're in our
terminal I'm going to create a
1238:39 - new directory. We're gonna call
it hard hat and a T for FCC.
1238:44 - We're gonna cd into that. And if
T FCC and we're going to open
1238:47 - that up with code.or, you can
hit File, Open Folder At this
1238:52 - point, you'll have gotten pretty
familiar with the setup of our
1238:55 - code bases here, feel free to
copy over or do whatever you
1238:58 - want to do for our setup, we'll
do yarn, add dash dash dev hard
1239:02 - hat. And then while that's
loading, I'm going to copy over
1239:05 - my prettier files. Because I
want to use prettier, I'm going
1239:08 - to copy over my hard
hat.config.js. And I'm also
1239:12 - going to grab my package that
Jason copied over here, I'm
1239:16 - going to delete this old package
dot JSON. And I'm just going to
1239:20 - hit Enter on this and rename the
one I just copied over from
1239:23 - package copy to package json.
And the reason I'm doing this is
1239:26 - so that I can just go ahead and
run yarn and install all this
1239:30 - stuff for me. Or we can just
come back over here and just
1239:33 - grab this lesson nine hard hat,
smart contract lottery, all that
1239:36 - stuff, again, just run that
massive piece as well. Or you
1239:40 - can copy over your package json,
and then just run yarn that will
1239:43 - do the same thing. Now we don't
have to keep doing this
1239:45 - boilerplate over and over and
over again. And then while
1239:48 - that's loading, I'm also going
to grab my Dotty and v file that
1239:51 - we've been using on a past
couple of projects, the
1239:53 - readme.md. And we'll just do
what we're gonna be doing here.
1239:56 - So we're going to make three
different contracts. One is
1239:58 - going to be a basic NFT, using
that ERC 721 standard, then
1240:04 - we're gonna do a random IPFS
hosted NF t. And then finally,
1240:09 - we're going to do a dynamic S V
G NFT. So our random NF T is
1240:15 - going to be random at creation
time, this is going to give some
1240:18 - true scarcity and some true
randomness to our NF T. And it's
1240:22 - gonna be hosted on IPFS. Our
dynamic SVG NFT is going to be
1240:27 - hosted 100 percent on chain, and the
image of it's going to change
1240:32 - based off of some parameters.
That's what makes it a dynamic
1240:35 - SVG NFT.
1240:39 - Let's go ahead and we'll create
a new folder, we'll create our
1240:41 - contracts folder, and we will
create our first NF t this is
1240:45 - going to be our basic NFT. And
I'm going to go a little bit
1240:49 - quick here, because most of what
we're going to be doing is
1240:52 - actually things that we're
already familiar with. So we'll
1240:55 - do basic NF T dot soul in a new
file. And let's go ahead and
1240:59 - let's do it. Let's go ahead and
we'll do spdx license
1241:04 - identifier, it's gonna be MIT.
We'll do pragma, solidity,
1241:10 - carrot zero, point 8.7 pragma,
solidity, and then we'll do
1241:15 - contract, basic NF t. Let me
just basic, get a t.so, like
1241:21 - that. And we'll say contract
basic NF t. And then we'll just
1241:25 - run hard at compile or yarn
hard, hit compile, and it looks
1241:28 - like we're doing well here so
far. Okay, perfect. Based off of
1241:31 - that NFT token standard, we go
back that EIP, we're going to
1241:35 - need a whole bunch of different
functions here, we're going to
1241:38 - need transfer events, we're
going to need owner events
1241:41 - bounce up, we're going to all
these different functions. And
1241:44 - we could 100 percent implement these
and transfer them exactly like
1241:48 - the ERC 20 did, or once again,
so we can use, you guessed it,
1241:53 - we're gonna be using open
Zeppelin contracts for this as
1241:56 - well. So we come back over to
open Zeppelin, we go over to
1241:58 - contracts. And we're gonna go
ahead and add this with yarn,
1242:01 - add dash dash Dev. So yarn, add
dash dash dev at opens up on
1242:07 - contracts, like so. And while
that's going through, we can
1242:11 - look at the ERC 721 of this and
we can see what creating a
1242:16 - minimalist ERC 721 looks like.
Now there's a number of
1242:19 - extensions that come with its
ERC. 721 In this example that
1242:23 - they give us. They're using ERC
721 Uri storage, which we'll
1242:28 - talk about in a little bit. So
we've added it in here. And now
1242:31 - we can actually import that ERC
21 from opens up when in our
1242:34 - contract. So we'll do import at
open Zeppelin slash contracts
1242:39 - slash token slash your C 721
slash ERC. 721 does so they use
1242:46 - a different one in the demo, but
don't worry about that. And same
1242:49 - as the ERC. 20 we're gonna say
our basic NFT is ERC 721. So
1242:56 - we're doing this inheritance,
you find the constructor, we can
1243:00 - see this has a constructor,
where it takes a name and a
1243:03 - symbol. So we're gonna want to
use this constructor and our
1243:07 - contract. So we're gonna say,
construct door.
1243:12 - And our constructor is just
going to be blank. But we'll do
1243:16 - the ERC 721 constructor and
we'll call this a doggie. And
1243:21 - the symbol will be dog just like
that. Our basic NFT we're just
1243:25 - going to have it be this doggy
here, right so it's going to be
1243:27 - an NF T of just a purely this
dog here. The name is going to
1243:31 - be doggy and the symbol is going
to be dog. Now in order to
1243:34 - create new dogs. What we're
going to do is openzeppelin code
1243:39 - comes with something called a
mint function exactly the same
1243:43 - as the ERC 20 So we're going to
create a function called mint
1243:48 - NFT this will be a public file
function that's going to return
1243:53 - you activity six. And we'll use
the safe mint function of this
1243:58 - ERC 20 or underscore safe mint
message dot sender will mint the
1244:05 - token to whoever calls this mint
function. And then we need to
1244:09 - also give this a token ID, if
we're looking back at the code
1244:13 - for the ERC 721. And again, you
can see this on GitHub as well,
1244:17 - we're gonna look at this safe
mint function, it takes an
1244:19 - address to who is going to own
the NFT. And then a token ID,
1244:24 - what is the ID of the token
based off of this address. So if
1244:28 - you have a collection of tokens
on the same smart contract, each
1244:32 - one of them needs their own
unique token ID. So what we're
1244:35 - gonna do is we're gonna create a
un 256, private variable called
1244:39 - S underscore token counter, and
it's gonna get initialized in
1244:44 - our constructor to zero, but
we'll just be explicit and say
1244:47 - es token counter equals zero.
And then in here, we'll just
1244:51 - have the token ID of this new NF
t be that token counter. And
1244:56 - then of course, we'll say s
token counter equals s token
1245:00 - counter plus one. So every time
we meant a new NFT, we up the
1245:04 - token counter, and then we'll
just return, we'll just return
1245:08 - the new tab counter. Right. And
then obviously, at the bottom,
1245:11 - we could do like function, get
token counter, this would be a
1245:14 - public view returns you in 256.
And I'm gonna go a little quick
1245:19 - here, because you've seen this
before, return s underscore
1245:22 - token counter, right, since it's
a private variable up here, the
1245:26 - public function down here to get
that token counter. So this
1245:30 - technically, is it. This is
technically an NF T. But what
1245:33 - does this look like? Well, right
now, this NF T isn't going to
1245:36 - look like anything at all, in
this EIP token standard. It has
1245:41 - this thing called a token URI.
And this is the important
1245:44 - function that tells us exactly
what this token is going to look
1245:48 - like. Like what we said in the
mini lesson here. This token URI
1245:52 - returns some type of URL or
universal resource identifier
1245:56 - that returns some JSON that
looks like this. And in this
1246:00 - JSON, we're going to have this
image part. And this image is
1246:03 - going to be a URL that's going
to point to what this image
1246:07 - actually looks like. Now this
URL can be hosted on chain, it
1246:10 - can be hosted on IPFS, it can be
hosted really wherever. But
1246:13 - ideally, we're not going to use
a centralized server to host it.
1246:16 - If this is hosted on a Google
Cloud or a centralized server or
1246:19 - whatever, and our centralized
server goes down. Well guess
1246:22 - what this MC is gonna look like,
it's not gonna look like
1246:24 - anything. So we want to use some
type of decentralized storage,
1246:28 - to get a URL, or URI to store
what this looks like. To make
1246:32 - this section a little bit easier
for you, I've actually already
1246:35 - gone ahead and hosted an image
to IPFS. For you, it's going to
1246:40 - be at IPFS dot dot slash slash,
it's going to look like this,
1246:44 - this is going to be the image
that we're going to use for our
1246:47 - dog here. If you create just
this image, though, as the token
1246:51 - URI, that's not going to work,
we need a URI that returns this,
1246:56 - with the image inside of it. Now
for this first section, have
1246:59 - already gone ahead and done that
for you as well. And that's
1247:01 - going to be located here. This
is what our token URI function
1247:05 - needs to return. So it's going
to have the name, the
1247:07 - description, the image URI,
which then points to the dog,
1247:12 - and then some attributes, etc,
etc. Now, you'll notice that the
1247:15 - image here is pointing to HTTPS,
dot dot slash slash ipfs.io. The
1247:21 - reason I did this was again,
just in case you didn't have the
1247:24 - IPFS gateway, but this would be
a lot better if this was in its
1247:28 - IPFS form. Because if the
centralized server ipfs.io, goes
1247:33 - ever goes down, this NFT will
show what it'll show nothing. So
1247:38 - it would be much better. If it
was instead of ipfs.io. It was
1247:44 - IPFS, colon slash slash, like
that, instead of ipfs.io. But
1247:49 - for now, this is what we're
going to be using. And you can
1247:51 - just go to the GitHub for this,
just to grab this for this
1247:56 - section. Right? Just go to
contracts, basic NFT, you can
1248:00 - just grab this, this, this top
part, just copy it like that. So
1248:04 - we're going to paste that the
token URI up, up, up at the top,
1248:09 - like so. Oh, it should be
returns, return. There we go.
1248:14 - Okay, cool. So we're just going
to copy paste that in here like
1248:17 - this. Like I said, even though
the token URI here is pointing
1248:22 - directly to IPFS, which is good.
If you actually go to this file,
1248:26 - the file is actually pointing to
http.ipfs.io. Again, for your NF
1248:31 - T's don't do that for this NFT.
I just did that just in case,
1248:35 - but for your NF T's don't do
that. And we're going to make
1248:38 - this a public constant variable.
Why? Well, because this token
1248:42 - you write is never going to
change. We're going to make this
1248:44 - NFT so that everybody who meets
one will have this exact same
1248:48 - adorable little puck here. And
the way we do That now is we
1248:52 - need to identify the actual
token URI function. So I'm going
1248:56 - to do it above get token
counter, we're going to say
1248:59 - function, token URI. And these
always take a UNT 256 token ID,
1249:08 - we're going to make this a
public view, override returns
1249:14 - string memory. And this needs to
return the token URI. Now, this
1249:22 - is going to be the most basic
way to create this, right. And
1249:26 - if we wanted to make this
function a little nicer, we'd
1249:29 - comment out token ID as well,
since we're actually not using
1249:32 - token ID. But we're overriding
in our in the ERC 721 that we're
1249:38 - importing. This has a token ID
function or a token URI
1249:42 - function. And we're overriding
this, right, we're not using
1249:46 - this at all, we're saying, Hey,
we're just going to use our own
1249:48 - here. And that's all we need for
this to work. And now if you
1249:53 - were to deploy this to rink B,
if you were to jump over to open
1249:55 - C test net, and you would deploy
this, this dog, this adorable
1249:59 - little pop would be what shows
up for all the minutes. So let's
1250:03 - go ahead, and let's create a
little deploy function for this.
1250:06 - So we'll do a new folder, deploy
a new file, we'll call this a
1250:11 - one deploy basic NF T dot j s.
And this is going to look real
1250:17 - similar to everything that we've
done before. So I'm going to
1250:19 - move a little bit quicker here.
const network equals require
1250:25 - hard hats, const development
chains, equals require dot dot
1250:33 - slash helper, hard hats config.
And I don't think I added that.
1250:38 - So I'm going to copy paste my
helper Hardhead config from our
1250:42 - last project. And if you get
confused, you can always just
1250:45 - come to the GitHub here, and
just go to the helper Hardhead
1250:49 - config and grab it from here, we
have that const development
1250:52 - chains, or say const verify
equals require dot dot slash
1250:58 - utils. Slash verify. We're also
going to grab our utils, I'm
1251:03 - going to copy paste so utils
folder from alas project, once
1251:06 - again, you can copy paste from
your last project, or you can
1251:09 - just go straight to the repo,
grab the verified dot j s, we're
1251:12 - going to go over these two
functions a little bit later,
1251:15 - but at least grab the verified
for now. And then we're gonna
1251:17 - start the function. So we'll do
module that exports equals async
1251:21 - function. We're gonna get get
named accounts, and deployments.
1251:29 - And we're gonna say const.
Deploy, log equals deployments
1251:34 - against deployer equals await,
get named accounts. So we'll do
1251:41 - a little log here just to get
started to do our basic NFT
1251:47 - doesn't take any constructor
parameters. So we'll say const
1251:51 - args equals a little blank here.
Then we'll do const basic NFT
1251:58 - equals await, deploy basic NF T,
exactly what we've seen before a
1252:05 - number of times at this point,
we'll say from Deployer. args is
1252:10 - going to be args. And then log,
it's going to be true. And then
1252:14 - we'll also do weight
confirmations. It's going to be
1252:16 - network dot config dot block,
confirmations, or one. Then if
1252:25 - we want to verify this, we're
going to once again do if it's
1252:29 - not development chains, dot
includes network dot name, and
1252:37 - process that EMV dot ether scan
API key will say log verifying
1252:44 - dot the dot await, verify basic
NF T dot address arguments which
1252:51 - are going to be blank, grab this
little log here, stick it right
1252:55 - underneath. And then actually in
our basic NF T. This should be
1252:59 - args not arguments. Now we have
a deploy script. Now we have a
1253:03 - basic NFT here in test data
deploy script, or any hh deploy
1253:07 - or yarn Hardhead deploy. And
oops, let's go back to the basic
1253:12 - kind of tea or mint and have tea
needs to return a UNT 256. Try
1253:19 - again. Get token counter also
needs to return a UNT forget you
1253:23 - into anywhere else. Nope. Okay,
looking good. And looks like
1253:26 - we're compiling well compiled,
deploying Well, now if you want
1253:30 - to deploy this to rink B, you
can. I recommend holding off
1253:35 - though, because we're going to
do that at the end. Now that
1253:37 - we've written a deploy script.
We've written the contract, you
1253:40 - already know what's coming next.
Yes, neat. What's next is the
1253:44 - tests now because we're not
actually learning too much more
1253:47 - here. I'm not going to walk you
through writing this test. I'm
1253:50 - going to challenge you now. How
to pause the video and write the
1253:54 - test out yourself and see how
far in this test you can
1253:57 - actually get. Remember, to test
it, you're going to want to run
1254:00 - yarn, hard hat test,
1254:03 - right, let's see if you can
actually write the test
1254:05 - yourself, then come back to the
video, see if your tests were
1254:09 - just as good or not as good as
what we did here. And of course,
1254:13 - you can always go to the GitHub
repo test sections. And if you
1254:16 - get lost, you can look at the
basic nft.test.js To follow
1254:21 - along. All right, welcome back.
Hopefully, you wrote some
1254:33 - awesome tests, taking the time
to actually do some of those
1254:36 - exercises is really going to
make you a much better engineer.
1254:40 - Following along with me, it's
awesome. But tinkering yourself
1254:43 - and trying to do everything
yourself is really what's gonna
1254:46 - make this stick. So I hope you
did pause the video. And hope
1254:49 - you did go ahead and try to
write the test for this
1254:51 - yourself, you've technically
just created a really
1254:54 - minimalistic NFT.
1254:55 - Great job. Let's kick things up
a notch. Let's move now to a
1255:02 - random IPFS hosted NFT where
we're going to do everything
1255:07 - pretty much programmatically. So
let's jump in. In our contracts,
1255:11 - we're going to create a new file
random IPFS, NFT, dot soul. Same
1255:16 - thing. spdx license identifier,
gonna be MIT pragma, solidity
1255:24 - carrot zero, point 8.7, or
whatever version you want to
1255:27 - use, will do contract random
IPFS NF? T, like so. So what is
1255:35 - this one going to do? So instead
of just minting any NFT, when we
1255:39 - meant an NF t, we will trigger a
chainlink VRF call to get us a
1255:47 - random number. Using that
number, we will get get a random
1255:52 - NF t that we're going to decide
on. And the random n of t that
1255:56 - we're going to use, it's going
to be either a pug a Shiva in
1255:59 - you, or a St. Bernard. So
whenever anybody mints NF T,
1256:04 - they're gonna get one of these
random three dogs. And we're
1256:06 - going to make this so that each
one of these dogs have a
1256:09 - different rarity, we're going to
make these dogs rare by
1256:12 - different amounts, say we want
the pug to be super rare, the
1256:16 - Shiva to be sort of rare, and
then the St. Bernard to be
1256:20 - pretty common. So probably it's
gonna be super rare Shiva in us
1256:23 - is gonna be sort of rare, St.
Bernard is going to be pretty
1256:27 - common, right? Or the most
common, if you will. So let's go
1256:30 - ahead and start building this,
we're probably gonna have to
1256:32 - make a function called like
request NF t, because we're
1256:36 - going to know that we're gonna
need to kick off a channeling
1256:38 - VRF request, we're probably
gonna have to make a function
1256:41 - fulfill random words, that's
going to take a un 256 Request
1256:47 - ID and a un 256. Array, memory
random words, as we've seen
1256:53 - before, we've done fulfill
random words in the past. And
1256:57 - let's let's even go one step
further, we'll make it so that
1257:00 - users have to pay to mint an NF
t. So this is going to be they
1257:06 - have to pay a certain amount of
eath to get the NFT and then the
1257:10 - owner of the contract and
withdraw the eath. So we're
1257:14 - basically paying the artists
here, we're paying the artists
1257:17 - to create these NF T's. And then
they can be the ones actually
1257:20 - actually withdraw the payment
for all these NF T's. And we're
1257:23 - also going to need, of course, a
function, token URI, which takes
1257:28 - a un 256. And this is once
again, same as our basic NFT
1257:32 - gonna be what this token
actually looks like. So let's go
1257:35 - ahead and get started creating
this. Now, because these red
1257:37 - lines are going to draw me
crazy. We're going to add some
1257:40 - visibility here, we'll make this
request NFT public fulfill
1257:45 - random words, we actually know
from the past is going to be
1257:48 - internal token URI is going to
be public. Let's build this
1257:52 - request NFT. And again, to
request a random number, go back
1257:57 - to EVM. Chains, we go to using
randomness, we can follow along
1258:01 - with the Dr. chain link again,
to figure out how to get this
1258:04 - random number. So since we know
we're going to be working with
1258:07 - chain link, we want to add at
chain link slash contracts. So
1258:11 - back in in our code base, we'll
add that in yarn add dash dash
1258:16 - dev at chain link slash
contracts, like so which was
1258:21 - perfect. And we can go ahead,
and we're going to import that
1258:25 - VRF consumer base V two and the
VRF coordinator interface into
1258:30 - our code because we know we're
going to use both of these. If
1258:33 - you want to just copy paste from
the docs, you absolutely can go
1258:36 - to pause here. And since we're
going to be using this view of
1258:39 - consumer base, we want to
inherit it. We're going to say
1258:43 - random IPFS and f t is V RF
consumer base V two and this
1258:48 - little, little wiggly line will
show up here saying This seems
1258:51 - to be override. So I'm just
gonna go ahead and add override
1258:54 - here. And this little wiggly
line is gonna stay there for a
1258:57 - little bit until we implement
the rest of the functions. So
1259:00 - let's go ahead and implement the
rest of those functions. Request
1259:03 - NFT, of course, is going to be
public here. And in order for us
1259:07 - to request an NF T, we're going
to need to call the coordinator
1259:10 - dot request random words where
we pass all this stuff in.
1259:14 - Right, so let's go ahead and get
all this stuff for our V REF
1259:18 - coordinator in our constructor,
so let's create a new
1259:21 - constructor. struct door. And
we're going to use the VRF
1259:25 - consumer base, the two
constructor to use to create our
1259:30 - constructor, the VRF consumer
base V two needs an address in
1259:34 - here for the VRF consumer base.
So we'll go ahead and we'll do
1259:37 - address VRF. Or did Nate Torre b
two. And then we'll pass this to
1259:44 - the VRF consumer base
constructor here, just by adding
1259:48 - that that red squiggly line has
gone away from me perfect. And
1259:51 - we want to save that address to
a global variable. So we can
1259:55 - call request random words on it.
So we're gonna go ahead up here,
1260:00 - we're going to say I underscore
var F chord. To me, Tor, we're
1260:06 - going to make this immutable VRF
coordinator. And we're going to
1260:09 - do it by saying VRF v2
interface, it's gonna be
1260:13 - private, immutable, you have
coordinator and then in our
1260:19 - constructor here, we're gonna
say IVF coordinator equals VRF,
1260:24 - coordinator v2 interface wrapped
around this like so. So we know
1260:29 - we're going to need this, we
know we're actually gonna need a
1260:31 - ton of these. So let's just add
all these variables in here,
1260:34 - we're gonna need the
coordinator, we're gonna need a
1260:37 - UNT 64 private, immutable, I
underscore subscription ID,
1260:45 - we're gonna need a bytes 32,
private, immutable,
1260:50 - I underscore gas lane, we're
gonna need a you int 32 private,
1260:57 - mutable, I underscore callback
gas limit, we're gonna need a
1261:02 - UNT 16 Private constants,
request confirmations, we're
1261:10 - gonna say it's gonna be three,
and then a un 32. Private
1261:16 - constant equals num words, which
is going to be one, and we'll
1261:22 - get this red squiggly line
saying it's mad at our our
1261:26 - constructor here. So let's go
ahead and add all of our
1261:30 - immutable variables in our
constructor. So we'll get the
1261:33 - VRF coordinator v2 from our
constructor will get the UNT 64
1261:39 - subscription ID, we'll get the
bytes 32 Gas lane, aka the key
1261:45 - hash, we'll get the un 256.
We'll do a UNT 32 callback gas
1261:52 - limit, then we'll go ahead and
do I subscription ID equals
1261:58 - subscription ID will do I gas
Lane equals gas lane will do I
1262:06 - call back gas limit equals call
back.
1262:11 - Yes limit.
1262:13 - Okay, a lot of variables set up.
But those are the variables that
1262:15 - we're going to need for the
chainlink VRF. Now we have all
1262:18 - these variables down in our
request. And if t we can request
1262:22 - a random number to get for our
random n of t, we're going to
1262:26 - say and our returns a yuan
tivity six Request ID. So in
1262:32 - here, we'll say request, Id this
request ID that we just
1262:37 - initialized I underscore VRF.
Core didn't a Tor dot request.
1262:44 - random words. And this should
look pretty familiar to what we
1262:48 - did in our lottery. I underscore
gas Lane comma, I underscore
1262:54 - subscription ID, comma, request,
con for nations. I underscore
1263:03 - callback gas limit. And then of
course num words and we can just
1263:08 - literally copy paste this from
the documentation or from our
1263:12 - last project, whatever you want
to do. So we are requesting this
1263:16 - random NFT here. Now here's the
thing, though, we want whoever
1263:26 - called this request function it
to be there and have tea, right.
1263:30 - And if we saw in our basic NFT,
when we minted the NFT, we call
1263:34 - this safe mint which needed the
owner and the token counter.
1263:38 - When we request a random number
four are NFT. It's going to
1263:41 - happen in two transactions,
right? We're going to request
1263:44 - and then later on we're going to
fulfill and it's going to be the
1263:47 - chain link node that's calling
fulfill random words. So if it
1263:51 - In the fulfill function, we just
do this safe meant message that
1263:54 - sender, the owner of this NFT is
actually going to be the chain
1263:58 - link node that fulfilled our
random words. So we don't want
1264:03 - that, what we want to do is we
want to create a mapping between
1264:07 - request IDs. And whoever called
this so that when we call
1264:12 - fulfill random words, which
returns with that exact same
1264:15 - request, ID, we can say, Ah,
okay, your request ID X, you
1264:19 - belong to the person who called
this request and of team, we're
1264:23 - going to create a mapping
between people who call this and
1264:26 - their request IDs so that when
we fulfill random words, we can
1264:29 - properly assign the dogs to
them. So up at the top, right
1264:33 - underneath here, I'm going to
call them VRF helpers, we're
1264:36 - going to create a mapping of un
256. To an address, we'll make
1264:42 - this public which we should make
it private, but we'll just make
1264:44 - it public s underscore Request
ID to sender. And then when we
1264:50 - call this request, and F T, will
set the request ID to sender of
1264:56 - Request ID equals to message dot
sender. Now, when the chain link
1265:03 - node responds with fulfill
random words, what we can do is
1265:07 - we can say address dog owner or
the NFT dog owner is going to be
1265:12 - equal to s Request ID to sender
of Request ID. This way, it's
1265:19 - not going to be the chain link
nodes that are going to own the
1265:21 - dog, but it's gonna be whoever
actually called requests. NFT.
1265:26 - Okay, cool. So we have a way to
request a random number for our
1265:29 - random NF t. Now, let's go ahead
and mint this random dog, this
1265:34 - random NF T for this for this
user. So we have the user now
1265:40 - using this mapping, what else do
we need? Well, we're gonna need
1265:43 - the token counter here. Let's go
ahead and we'll create a token
1265:46 - counter variable. So we'll
scroll up and make a new
1265:49 - section. And we'll say, un 256.
And then again, we'll just make
1265:56 - a lot of these public just to
make it easier, but you might
1265:58 - want to make this private and
use that same syntax we were
1266:01 - doing before do s underscore
since this is a stored variable,
1266:05 - token counter. And we'll grab
this token counter. And we'll
1266:09 - say you went to 56. New token ID
equals as token counter, now
1266:15 - that we have the dog owner, and
the token ID, we can go ahead
1266:19 - and mint this MFT. So we'll do
safe mint.
1266:23 - Owner, new token, ID and then
safe man is going to be squiggly
1266:30 - because our code is gonna say,
what is this? What is the safe
1266:34 - mint function? Where did you get
this from? Well, we're gonna
1266:37 - need to get it from open
Zeppelin again. So we're going
1266:39 - to go ahead and do import at
open Zeppelin slash contracts
1266:44 - slash token slash ERC. 721 slash
ERC. 720 one.so We'll say a
1266:53 - random IPFS empty is Vera of
consumer base, and also ERC 721
1266:59 - In our constructor, right after
our V RF consumer base, we're
1267:02 - going to put the ERC 721. And
same thing, we need to give it a
1267:08 - name and a symbol. So we'll call
this random IPFS NF T. Comma,
1267:15 - we'll just do Rin for random
IPFS NF team. Now safe mint
1267:19 - actually works and then it's
gonna be mad at me for this. So
1267:22 - I'm gonna do override just let
it stop getting mad at me.
1267:24 - public view override turns
string memory. Just that
1267:31 - squiggly line goes way. Okay,
cool. So great. So now we can
1267:34 - safe mint to the dog owner this
new token ID Are we done with
1267:43 - this? Absolutely not. Why not?
Well, we don't know what this
1267:47 - token looks like. And what we
set above is we want to actually
1267:51 - make these dogs different
rarities. So how do we actually
1267:54 - create these dogs with different
rarities, all we could do is we
1267:58 - create a chance array an array
to show the different chances of
1268:03 - these different dogs here. So
down below, we're going to
1268:06 - create a function and it's going
to be a public pure function
1268:12 - called get chance array. And
this is going to return you went
1268:20 - to 46 of size three in memory.
And this chance array is going
1268:26 - to represent the different
chances of the different dogs.
1268:29 - So we're gonna say return
10 3100 Or we're gonna say Max
1268:35 - chance value.
1268:38 - And up at the top under empty
variables. We're gonna say you
1268:42 - went to 56 internal constant,
Max chance value equals 100. So
1268:48 - by making this array, we're
saying index Zero has a 10 percent
1268:53 - chance of happening. We're
saying index one has a 20 percent
1268:58 - chance of happening because it's
going to be 30 minus 10. And
1269:03 - then we're saying index two is
going to have a 60 percent chance of
1269:07 - happening, because it's going to
be 10 plus 30. minus this 100.
1269:12 - This array that identified the
percentages of the different
1269:15 - dogs. We're saying the pug is
going to have a 10 percent chance,
1269:20 - Shiva in you a 20 percent chance and
the St. Bernard a 70 percent chance,
1269:25 - we're going to use it to give
this token ID that we just
1269:29 - minted its dog breed. So we're
gonna create a new function
1269:32 - called Get breed from modded
RNG. And the reason we're
1269:37 - calling a get breed from modded
RNG is exactly the same way. In
1269:41 - our lottery. We got a random
number, we're gonna say you went
1269:44 - to 56 modded RNG equals random
words of zero mod Max chance
1269:53 - value, we're going to mod any
number we get by 100. Doing it
1269:57 - like this, we're always going to
get a number between zero and
1270:00 - 99. If random words zero mod Max
Chin's value is going to be
1270:04 - seven. That means we're gonna
get a pug. If we get 88. That
1270:08 - means we're gonna get a St.
Bernard, if we get a 45. We're
1270:14 - gonna get a what? That's right,
a St. Bernard, if we got a 12
1270:19 - We're getting a Shiva in you. If
the mod ID number that we get by
1270:24 - modeling this random word is
between zero and 10. It's going
1270:29 - to be pug between 10 and 30.
shiba inu between 30 and 100 St.
1270:36 - Bernard and that's how we get
these randomness values. So now
1270:39 - that we have this modded RNG, we
have this mod ID number that's
1270:42 - going to be between zero and 99.
Okay, this function called Get
1270:46 - breed from modded RNG. And this
is going to take the UN 256 mod
1270:53 - ID RNG will make this a public
pure function, and it's going to
1270:57 - return the breed of the dog. Now
the breed of the dog is going to
1271:02 - be an email similar to raffle
state that we did before. We're
1271:05 - going to do this right at the
top since this is going to be
1271:08 - what a type declaration or say
enum. Read, we're going to say
1271:14 - the zero with number is going to
the pug. The ones number is
1271:18 - going to be the Shiva in you.
And then the second one is going
1271:22 - to be the St. Bernard. So we
have the pug which is zero to
1271:27 - 10. Shiva in you 10 to 30 St
Bernard 30 to 100. So get breed
1271:33 - from modded RNG public pure
returns breed. So we're gonna
1271:38 - loop through this we're gonna
say you intuitive six cumulative
1271:40 - sum equals zero, we'll say you
went to 56. size three memory
1271:49 - chance array equals yet chance
array. So we're getting that
1271:58 - chance array. So we're going to
create a little for loop we're
1272:00 - gonna say for you went to 56 i
It's gonna start with zero is
1272:06 - going to be less than the chance
array dot length. i plus plus
1272:11 - ran through that for loop here.
And we're going to say if modded
1272:17 - RNG is greater than or equal to
this cumulative sum and modded
1272:26 - RNG is less than the cumulative
sum plus chance array plus
1272:34 - wherever we are on the chance
array, then return breed of AI.
1272:41 - And then outside of this, we're
gonna say cume cumulative sum
1272:44 - plus equals chance array of I,
let's say moderate orangey
1272:49 - equals 25. And if it's 25, it
should be a Shiva in you,
1272:54 - because that's between 10 and
30. So we're saying if mod RNG,
1272:58 - which is 25 is greater than or
equal to cumulative sum, which
1273:03 - right now is zero, and it's less
than n, the Moto G is less than
1273:07 - the cumulative sum plus the
chance array of I which is going
1273:12 - to be 10 Return breed of I
cumulative sum is currently zero
1273:17 - plus chance of I which is 10 is
going to be 10. And this is not
1273:24 - true because Morarji is 25. So
since this is not true, we're
1273:28 - going to move to the second step
which is just cumulative sum,
1273:31 - plus equals chance right? So
cumulative sum will now be equal
1273:35 - to 10. And then we reached the
end of the for loop. So we'll
1273:38 - restart i is now one, so let's
try this again mod RNG is
1273:42 - greater than or equal to
cumulative sum Okay, that is
1273:45 - true cumulative sum is 10. Mod
RNG is 25. And mod RNG is less
1273:52 - than cumulative sum plus chance
re of AI, which is 30. So we're
1273:57 - saying 25 is less than 10 plus
30, which is 40. Return breed of
1274:03 - AI, this is true. So breed of AI
would be true and AI at the
1274:08 - moment is one. And if we scroll
up, that's indeed the Shiva in
1274:12 - you. So that's how this function
is going to work, it's going to
1274:15 - get us the breed from that
modeling bit. And then if for
1274:19 - some reason, some really wacky
stuff happens here, we want to
1274:22 - just go ahead and add a revert,
right, because we should be
1274:25 - returning a breed. But if we
don't return a breed, we should
1274:28 - just revert. So we're going to
create a new error at the top,
1274:32 - random IPFS NFT underscore
underscore range out of bounds.
1274:39 - The down below, we're just going
to say if for some reason you
1274:42 - don't return anything, just do a
revert random IPFS NFT range out
1274:47 - of bounds. And now we have this
function. Okay, so now we can
1274:51 - get the brief from a modded RNG.
So pack in our fulfill random
1274:54 - words function. Let's go ahead,
and we'll say, we'll uncomment
1274:59 - this will say breed, dog breed,
equals get breed for modded RNG
1275:06 - pass the modded RNG here, and
let's move this safe mint down
1275:11 - below us getting the dog breeder
so we can mint and add the dog
1275:15 - breed at the same time. So we're
gonna go ahead and safe mint
1275:17 - here.
1275:23 - Now we can do a few things to
set this dog breed here, we
1275:26 - create a mapping between the dog
breed and the token URI, and
1275:30 - then have that reflected in this
token URI function. Or what we
1275:34 - could do is we could just call a
function called Set token URI
1275:38 - and the openzeppelin ERC 721 You
have to set this token your eye
1275:41 - function yourself. However,
there is an extension in the
1275:44 - open Zeppelin code called ERC.
721 Uri storage and this version
1275:50 - of the ERC. 721 comes with a
function called Set token URI
1275:55 - where we can just call set token
URI. And this will automatically
1275:59 - update that tokens token URI to
whatever you set it as. So we're
1276:04 - going to use this extension this
set token URI in our contract.
1276:09 - And the way that we do this is
instead of doing token ERC 721
1276:12 - Year C 721 that soul will do
token ERC 721 slash extensions
1276:21 - slash your C 721 Your arise
storage. That's all. And we'll
1276:27 - say random IPFS is ERC 721 your
rice storage. Now what's cool is
1276:35 - that our constructor will still
just use ERC. 721 Because ERC
1276:41 - 721 Uri storage is extending ERC
721. And then this contract just
1276:48 - comes with some additional
functions like set token URI. So
1276:52 - right after safe meant, we're
actually going to call set token
1276:56 - URI with this new item ID. And
then we're going to give it that
1277:03 - breeds token URI, we're gonna
give it a string here that
1277:08 - relates to whatever breed that
we just got based off the dog
1277:11 - breed here. Now, to do this,
what we could do is right at the
1277:15 - top and our NFT variables, we
could create a string array,
1277:20 - internal, Alt S dog token, your
eyes, we're gonna make this
1277:25 - constant where it would just be
this array of all these strings
1277:29 - that we created. But maybe in
our code, we want to make this a
1277:32 - little bit more variable. And we
want to parameterize this. And
1277:36 - that's exactly what we're going
to do. So we're going to create
1277:38 - this string array, internal s
underscore dog token, your eyes,
1277:42 - which is just going to be a list
of these URLs are these URLs
1277:47 - that point to stuff like this,
we're going to do that in our
1277:50 - code so that when we upload any
image that we want to IPFS we
1277:54 - can then upload this s dog token
you arise accordingly. In our
1277:58 - constructor, we're actually
going to take in another
1278:00 - parameter called a a string of
size three, memory dog token you
1278:08 - our eyes, we're going to pass as
a constructor parameter, these
1278:12 - different dog token you arise.
So we're going to pass it this
1278:17 - list of dog token arise. Of
course zero is going to be the
1278:21 - token URI of the pug. One is
going to be the Shiva in you and
1278:24 - two, of course is going to be
the St. Bernard. So we're going
1278:26 - to pass it this list of dog
token your eyes, and then down
1278:31 - in set token your eye from that,
that list that we created. We're
1278:37 - going to set the token URI of
this token based off of that
1278:40 - array of the UN 256 version of
that breed are casting this dog
1278:48 - breed back into you and 256 to
get its index. With that we now
1278:53 - have a way to actually,
programmatically get a provably
1278:57 - random NFT with different
randomness for different one of
1279:00 - these NF T's. Now, let's go back
up to our little, our little
1279:09 - comments we made here, limited
NFT, we trigger a chain link or
1279:13 - a VRF. To call random number, we
got the rarities down, we got
1279:16 - the minting down. Awesome. Okay,
we don't have this part, though.
1279:20 - Users have to pay to Minton NF T
and the owner of the contract
1279:24 - can withdraw the eath. Okay,
this is stuff we've already done
1279:26 - before, this should be pretty
familiar here. So back in our
1279:29 - request NF t function, we'll
make this a public payable. And
1279:32 - all we'll need to do is we'll
just say if message dot value is
1279:38 - less than some mint fee, and
actually let's go back to our
1279:41 - constructor, we'll create a mint
fee, you int 256 Mint fee.
1279:48 - And then we'll do you in 256
internal I underscore mint fee,
1279:53 - we'll make this immutable. And
then we'll just say I'm
1279:56 - intervene equals mint fee. If
message of value is less than
1280:01 - mint fee, you already know we're
going to do a revert, need more
1280:06 - eath sent, we'll create a new
air called need more eath sent
1280:12 - and actually we'll do air random
IPFS and ft underscore
1280:16 - underscore need more II sent
like that, copy this, paste it
1280:21 - here and boom. So now just by
adding this line, this is now a
1280:25 - payable function. And people
have to pay some mint fee to
1280:30 - mint their randomized NF t. Now
we're also going to want a way
1280:34 - for owner to withdraw. So we'll
scroll down a little bit. We'll
1280:38 - scroll down to here, CREATE
FUNCTION withdraw, this will be
1280:43 - public. And we only want the
owner to do this. So we could
1280:46 - create our modifier, you know, a
modifier again only owner, or
1280:51 - what we could do is use
openzeppelin. Again,
1280:53 - openzeppelin also comes with
some access code, or one of
1280:58 - them's this ownable code, and in
here, it already has the only
1281:03 - owner modifier for us, we're
just gonna go ahead and import
1281:06 - that as well. We'll do import at
openzeppelin slash contracts
1281:12 - slash access slash ownable dot
som, and we'll say contract
1281:17 - random IPFS. And if t is this,
this come ownable. And then
1281:23 - we'll make our withdrawal
function only owner. And so
1281:26 - whoever deployed this contract
is going to be set to being the
1281:29 - owner, which is what we want.
And when here, same as what
1281:32 - we've done, we'll do u and 256.
amount equals address this dot
1281:39 - balance. And then we'll do bull
success comma equals payable,
1281:47 - message dot sender, but call
value is going to be a mount and
1281:53 - then we're going to call
nothing. And then we're going to
1281:56 - say if not success. And we're
going to revert with transfer
1282:04 - failed, then on top, we're going
to do error transfer failed. I'm
1282:09 - just going to copy this a little
quicker, like so and then come
1282:14 - back down to transfer failed
paste it here. So we're gonna
1282:18 - revert random IPFS. And if T
transfer failed, perfect, so now
1282:22 - we have a withdrawal function
and a way for people to pay for
1282:25 - art here. Now we don't need this
token URI anymore, because when
1282:30 - we call set token URI, this is
going to set the token URI for
1282:35 - us because in the back ERC 721
Uri storage already has that
1282:39 - function laid out. So our
contract will already have the
1282:42 - token URI function and we don't
have to explicitly set it
1282:45 - ourselves. But we do have to
explicitly set some other ones.
1282:48 - We are going to need function
get meant fee will be a public
1282:52 - view turns you went to 36 turn I
meant fee will need function get
1283:01 - dog token your eyes, you went to
36 index, this will be a public
1283:06 - view which will returns the
string memory return s
1283:10 - underscore dog token your eyes
index will need function get
1283:17 - token counter. This will be a
public view turns you into 56
1283:24 - Return s underscore token
counter. Alright, so we just
1283:29 - wrote a ton of code here. And of
course as we taught you before,
1283:32 - we also are going to need some
events. So when we request an NF
1283:36 - T, we're going to emit an event.
So we'll omit NF T requested and
1283:43 - then we'll pass it the request.
ID in the message dot sender. So
1283:47 - up at the top will say event NF
T requested. So pet, take a un
1283:56 - 256 index Request ID, and then
an address requester. And then
1284:02 - we're also going to make an
event for NF T minted for when
1284:05 - it's finally minted. And it's
going to take a breed, dog
1284:09 - breed, and an address, mentor.
So write down when we fulfill,
1284:16 - we're going to emit NFT. minted.
1284:20 - And it's going to take that dog
breed and then the dog owner.
1284:29 - Okay, we've just written a lot
of code here. So let's go ahead
1284:34 - and see if we can compile this
with H H compile, or yarn
1284:37 - Hardhead, compile. And Wow,
looks like we went ahead and
1284:40 - compiled it. This is great. So
all of our code now looks good.
1284:44 - Now might be a good time to take
a quick breather, we've just
1284:46 - written a lot of code. And it
might be good to just go over
1284:49 - all the stuff that we just went
through. A lot of this is
1284:52 - familiar, but it's still really
good to redo some of this stuff
1284:55 - and really get that muscle
memory and for these credit, an
1284:58 - NFT contract that when you mint,
one of these NF T's, you're
1285:01 - gonna get a pug a Shiva in you
or St. Bernard, based off of
1285:06 - some rarity, where the pug is
really rare. Ship it in you is
1285:09 - sort of rare in the St. Bernard
is pretty common. The way we do
1285:13 - it is we have this request NF t
function, which people have to
1285:17 - pay to call and it makes a
request to a chain link node to
1285:21 - get a random number. Once our
contract gets that random number
1285:24 - uses a chance array to figure
out which one of the NF T's
1285:29 - we're going to actually use for
this for that minting. And we're
1285:32 - going to set the token URI
accordingly. And we're going to
1285:35 - store the image data for this on
IPFS, which we haven't done yet.
1285:40 - So our deploy function for this
is going to be really the
1285:43 - interesting part of this
contract. But because we just
1285:46 - went over so much, if you want
to take a quick break quick
1285:48 - breather, and then come back, I
encourage you to do so we just
1285:52 - learned a lot. And we wrote a
lot of solidity code. So go take
1285:55 - a quick breather, and I'll see
you in a
1285:57 - minute. So let's go ahead and
get on in here, create a new
1286:05 - deploy, go to ploy, random
ipfs.js. And now this is going
1286:15 - to look really similar once
again, to the lottery contract
1286:18 - that we've already done. And we
can copy some boilerplate from
1286:21 - our code over here, we're gonna
need all this, we'll just copy
1286:23 - that, close it off with a little
curly and boom, we've already
1286:27 - got a boilerplate. Now, since
we're working with chainlink,
1286:29 - here, we are going to be working
with mocks again. So we're gonna
1286:32 - come back new file 00, deploy
mocks dot j s. And if you want,
1286:39 - you can just copy paste from the
earlier section that we did with
1286:42 - the with the raffle slash
lottery. Since we're going to be
1286:44 - doing the exact same thing here,
I'm gonna go ahead and pause and
1286:48 - you can copy paste from your
previous projects. Or if you
1286:51 - want, once again, you can just
come to the GitHub repo
1286:54 - associated with this course,
come over to the deploy. And go
1286:57 - ahead and grab the deploy mocks
right from here. If you grab
1287:00 - from the GitHub repo, we also
are going to be working with a
1287:03 - mock v3 aggregator, but I'm not
going to add that part in quite
1287:06 - yet, because we don't need it
quite yet. So go ahead and pause
1287:09 - the video right now. Copy and
paste the VRF coordinator mock
1287:12 - or pause the video and try to
write the mock code yourself.
1287:16 - Okay, great. So once you've done
that, we're of course gonna need
1287:19 - to concentrate ID network dot
config dot chain ID, because
1287:23 - we're gonna need to decide if
we're actually on a development
1287:25 - chain. So same as what we did
before then we're gonna say if
1287:30 - development chains that includes
network dot name, then we're
1287:39 - gonna say const VRF coordinator,
B to mock goes await ethers dot
1287:46 - get contract VRF. Core. The name
for the to mock similar to the
1287:53 - raffle we're gonna say let VRF
coordinate Tor v two address,
1287:58 - same, the VRF coordinator v two
address equals VRF. coordinator
1288:04 - v two mach mock that address and
then we're going to want to
1288:08 - create a subscription exactly
the same as what we did with our
1288:11 - lottery. So we're gonna say
const, TX equals weight VRF
1288:17 - coordinate tore V to mock dot
create subscription. And then
1288:23 - we'll do const TX receipt equals
weight, TX dot weight one. And
1288:30 - we're gonna get the sub ID from
this exactly the same way we did
1288:33 - it in the lottery section. So
we'll say that we need that sub
1288:37 - ID by saying sub subscription ID
will say subscription ID equals
1288:45 - TX receipt, dot events, zero.
That args got somebody. So
1288:52 - that's what we do if we're on a
development chain, else said the
1288:57 - VRF coordinate tore V to address
equals network config of the
1289:06 - chain ID dot VRF coordinate or B
to that then the subscription ID
1289:13 - equals network config. Chain ID
dot subscription ID. Perfect.
1289:19 - And then we'll just double check
our helper hard hat config. So
1289:23 - that Rigby has both the VRF
coordinator v2. And we're also
1289:28 - going to need a subscription ID.
So right now, I have our
1289:31 - subscription ID from our past
project from our lottery
1289:34 - project. But we can go ahead to
V or F dot chain link, we can go
1289:38 - to V RF, that chain link can
make sure we're on rink B here.
1289:42 - Let's see our other
subscriptions. And it looks like
1289:44 - we have one here. So I'm going
to copy this and paste it in for
1289:49 - Rigby. Now again, we can go over
to DockStar, chain link EVM
1289:53 - chains, contract addresses for
using reminisce to see more
1289:57 - parameters in here, especially
for Rigby and make sure these
1290:00 - are all correct. We have our
subscription here, we'll add a
1290:04 - new consumer very soon once we
deploy this contract if we're
1290:07 - actually going to use RankBrain.
So we'll do a little log here
1290:11 - with a bunch of hyphens. We'll
now get args equals, we'll make
1290:19 - our arguments here. And what do
we need, we need the coordinator
1290:22 - subscription, gasoline callback,
address, dog, your dog token,
1290:27 - your eyes and admin fee. So
we're going to need VRF
1290:32 - coordinator for the to address
subscription ID. And we'll need
1290:39 - the network config. Chain ID dot
gas lane. We need the network
1290:46 - config chain ID dot meant fee,
then we'll leave that work
1290:53 - config chain ID dot callback gas
limit
1290:59 - the right order? Yes it is. And
then we need the dog token your
1291:03 - eyes and the mint fee with the
done here.
1291:12 - Now what do we not have, we
don't have this array of token
1291:16 - your eyes. Now we can do this
one of a couple of ways. If you
1291:19 - go to the GitHub repo associated
with this, go to deploy, we
1291:24 - actually did the randomness for
oh three in the get here,
1291:28 - there's one section where we
just automatically say, okay,
1291:30 - great token, you rise is just
going to be these three. And
1291:33 - then if we can actually even
copy paste these CDs on IPFS,
1291:37 - these are the better ones that
actually do have the IPFS as the
1291:41 - image. And we can see them like
that. So we could just use the
1291:44 - stuff that I've already
deployed. And if you want to do
1291:46 - that, you absolutely 100 percent Can,
or what we could do is we get to
1291:51 - actually learn to upload
programmatically our own images
1291:55 - to IPFS. That sounds a lot
cooler. So let's go ahead and do
1291:59 - that. Now what I want you to do,
if you want to use your own
1292:02 - images for this, feel free to do
so. But if you want to just
1292:04 - follow along with us, then we're
going to go to the Hardhead NFT
1292:08 - FCC repo. And we're going to
grab these random NF T's from
1292:14 - him. So all you can do is you
can come to here. And we can go
1292:17 - ahead, we can right click Save
Image, Jas, we'll save it to our
1292:20 - downloads, let's actually create
a new folder, we'll call it
1292:23 - images. And the images will
create a new folder called
1292:28 - random, then we can pull it just
right into here, make the name
1292:33 - random NFT. And this is just
going to be plugged up png. So
1292:38 - we can do that for all of our
images. Now in our images tag,
1292:42 - we have the pug ship in you and
St Bernard. So we have these
1292:46 - locally. But we want to upload
these to IPFS. We want to upload
1292:50 - them in a way that anybody can
actually pin them and work with
1292:52 - them. So before we do all this
stuff, where we get the
1292:56 - arguments to deploy this
contract, we're going to need to
1292:59 - get the IPFS hashes of our
images. And there's a couple of
1293:04 - ways we can do this. We do with
our own IPFS node, which I've
1293:09 - already shown you how to do that
manually, we can also do that
1293:13 - programmatically. Now, I'm not
going to show you how to do this
1293:15 - here. However, if you go through
the IPFS documentation, you
1293:19 - actually can learn how to do
through the command line and
1293:22 - even through some scripts.
However, if we're the only node
1293:25 - that's running this, again, it's
kind of centralized. So ideally,
1293:27 - we'd want these images and these
token your eyes and this and
1293:31 - this token metadata on our own
IPFS node and some other nodes.
1293:36 - So the second way that we can
look at this is using something
1293:39 - like Hinata Hinata is a service
that basically you just pay to
1293:43 - help pin NF T for you. And this
is going to be the one that
1293:46 - we're going to be looking at
here. Now the issue with binotto
1293:49 - of course, is that we're just
paying once single centralized
1293:52 - entity to go ahead and pin our
data, we're kind of trusting
1293:55 - that they're actually going to
pin it and that they're not
1293:57 - going to go down. The final way
that we could look into actually
1294:01 - getting our data is was this
thing called NF T dot storage.
1294:04 - And if T dot storage uses the
file coin network on the back
1294:07 - end to pin our data now filecoin
is a blockchain dedicated to
1294:11 - pinning IPFS data and storing
decentralized data. For us, the
1294:16 - process is a little bit more
complicated. But NFT dot storage
1294:19 - makes it really, really easy.
Now, we're not going to go over
1294:22 - using NFT dot storage in this
video. However, if you want to
1294:26 - look into NF T dot storage, for
putting your data in the GitHub
1294:29 - repo associated with this
course, we do have a script that
1294:32 - uploads your code to NFT to
storage called in the utils
1294:36 - folder, upload to NFT. Storage.
And if you want to go and try it
1294:39 - out, I recommend that you do so
working with NF T dot storage
1294:42 - will be one of the most
persistent ways to keep our data
1294:45 - up. But it's still good to
upload your own data to your own
1294:48 - IPFS node, which we've learned
how to do manually and at least
1294:52 - get one other person also
pinning your data. And then
1294:54 - ideally, an entire decentralized
network, pinning your data,
1294:58 - which is what NFS storage helps
you do. But for now, for us,
1295:02 - we're just going to work with
pinata to keep it nice and
1295:04 - simple for this video. And then
uploading uploading our metadata
1295:08 - and our token, your eyes up to
IPFS will give us this list of
1295:12 - token your eyes for our three
dogs. So up at the top here,
1295:15 - we're going to do a little if
we're gonna say if process dot e
1295:19 - NV dot upload to pinata equals
true, yes, we're going to use
1295:25 - the string true like that. Then
we're going to upload to pinata.
1295:29 - Above here we're going to say
let's token your eyes. And we're
1295:33 - gonna say token your eyes equals
await,
1295:36 - handle token your eyes. And
we're going to create a function
1295:40 - called handle token your eyes,
which is going to upload our
1295:43 - code to pinata down outside of
this, we're going to create a
1295:46 - new function called async.
function. And we'll token your
1295:52 - eyes. And this is going to
return an array of token your
1295:56 - eyes for us to upload to our
smart contract, we're gonna say
1295:59 - token, your eyes equals this and
then way at the bottom, we're
1296:03 - gonna say return token your
rise, right, so we're going to
1296:06 - be returning this array here.
Now we need to do two things, we
1296:10 - need to both store the image in
IPFS. And then we need to store
1296:16 - the metadata in IPFS. So first,
we're going to create a store
1296:21 - images function. And this is
where we're going to actually
1296:23 - get to go to our utils. And
we're going to create a new
1296:25 - folder in here, we're going to
create a file called New File,
1296:29 - Upload to pinata dot j s, we're
going to add all of our code for
1296:34 - actually uploading to pinata in
here. Because again, pinata is
1296:38 - this service that we're going to
be using to just pin data for us
1296:42 - and work with pinata, we can go
ahead, try for free. And we can
1296:46 - create our own application.
1296:56 - And we're good to go. See the
setup here looks really similar
1297:00 - to an IPFS node, because that's
essentially what pinata is. It's
1297:03 - just an IPFS node, run by
somebody else. And we can say,
1297:07 - Hey, can you please pin this
data for us. So a manual way we
1297:11 - could do this is we could just
hit Upload Cid just like an IPFS
1297:15 - node and put the hash of some
IPFS file, and pinata would pin
1297:19 - it for us, we could also upload
a file or a folder just like an
1297:23 - IPFS node. But for us, we're
just going to leave this blank
1297:26 - because we're going to want to
do this programmatically,
1297:29 - because we're engineers. So what
we can do is we come over to our
1297:32 - profile, we'll open up API keys
and documentation. And the
1297:36 - documentation pretty much has
everything that we need to get
1297:39 - started. If you scroll down to
the pinata Node js SDK, this is
1297:44 - basically what we're going to be
working with, they've already
1297:46 - created an SDK for us that we
can work with, we're gonna go
1297:49 - ahead and install this pinata
SDK. So they're using NPM,
1297:53 - install dash to save, we're just
gonna go ahead and use yarn, add
1297:57 - dash dash dev at pinata dash
SDK, and they have all these
1298:02 - different endpoints, we can call
to actually pin data, we're
1298:05 - going to be doing pin file to
IPFS, because we're going to
1298:08 - upload our files and also pin
JSON to IPFS. Since JSON is
1298:14 - going to be the metadata, and
file is going to be the actual
1298:17 - image. And if you click on it,
it'll even give you kind of the
1298:20 - output of the SDK here. So back
in our code, now that we've
1298:23 - downloaded this, we can go ahead
and start creating this. So
1298:26 - we'll say const pinata SDK
equals require at pinata slash
1298:31 - SDK, and then we'll create a
function async function called
1298:36 - store images, it'll take an
images file path. So we're going
1298:41 - to use this function will pass
it our images, random n of t
1298:45 - file paths, and we're going to
have it store everything in that
1298:48 - folder to help us work with
paths. We're also going to
1298:51 - Install this path package. So
we're gonna do yarn, add dash
1298:56 - dash dev path, like, so, we're
just going to work with Fs as
1298:59 - well not Fs extra. So now that
that's up, we're gonna say
1299:03 - const. Path equals require path.
And in here, we're gonna say
1299:08 - const, full images, path, equals
path dot resolve, images file
1299:16 - path. So if we give that like
dot slash images, slash random,
1299:21 - you know, NF T or whatever, this
will just give us give you the
1299:25 - full output of the path. So
we're getting the full images
1299:28 - path, and then we'll say, we'll
get those files by doing const
1299:32 - files equals Fs. So we'll do
we'll grab s will say const Fs
1299:37 - equals require Fs just to read
these files in here, that read
1299:43 - DirSync. We're just going to
read the entire directory and
1299:47 - get our files back to read
DirSync full images path. And to
1299:53 - actually test that this is
working, what we're going to do
1299:57 - is we're going to do module dot
exports, equals store images.
1300:03 - And then back in our deploy
script here, we can just go
1300:06 - ahead and
1300:08 - comment out args. And we can do
import const, store images
1300:16 - equals require dot dot slash
utils, slash upload to pinata.
1300:22 - And in this script, we could
just do a little, we just call
1300:25 - this we could say await, or
images, and then we'll pass pass
1300:31 - our images location, maybe way
at the top, even outside of the
1300:35 - function, we'll say const images
location equals dot slash images
1300:42 - slash random and ft. So we'll do
a weight store images like that.
1300:47 - And we should be able to run
Hardhead deploy. Then if we add
1300:51 - some tags to this deploy thing,
module, dot exports, dot tags
1300:57 - equals, we'll say all random
IPFS. And then main, we do
1301:03 - Hardhead deployed dash dash
tags, random IPFS will also do
1301:09 - mocks believe, and I need to
create a test folder in here New
1301:14 - Folder test. And we need to add
that VF coordinator v2 Mock in
1301:20 - here. So again, I'm just copy
pasting the VRF coordinator v2
1301:23 - Mock from our raffle project.
Feel free to pause, copy, paste
1301:28 - it over, or again, everything's
available on the GitHub. So
1301:31 - we'll try one more time. Tags,
random IPFS, and mocks and boom,
1301:35 - okay, mocks deployed and perfect
pug dot png ship any png St.
1301:40 - Bernard PNG. Great. So we're
getting the files correctly
1301:44 - here. Now let's create a little
array for responses from the
1301:49 - pinata server. So we'll say
responses equals this. And we'll
1301:52 - say for each file index in files
for each one of these files in
1301:58 - here, we're gonna say const
readable stream for file equals
1302:04 - Fs dot create read stream of the
full images path slash files of
1302:17 - file index. What does this line
doing? Well, we're creating a
1302:21 - read stream. Since this is an
image file, it doesn't work
1302:25 - exactly the same as just like
push this data, right? We have
1302:28 - to create a stream where we
stream all the data inside of
1302:31 - these images. Because these
images, even though they're just
1302:34 - like a cute little image here,
they're really this kind of this
1302:37 - big file with all this bytes and
all this data in here, and then
1302:40 - we're going to send it by doing
try, we'll say const response
1302:46 - equals await. And this is where
we're going to do pinata stuff.
1302:50 - If we go back to the pinata
docks, there's some stuff about
1302:54 - keys in here. What we can do, if
you go to your profile, go to
1302:57 - API keys, we can create a new
key, we'll say this is an admin
1303:02 - key, why not? We'll give it all
the pinning access here. Maybe
1303:06 - we'll give it this, maybe we'll
just give it everything,
1303:07 - whatever you want to do. And
then we'll call this hard hat,
1303:11 - Free Code Camp key, create key.
Now we're going to want to grab
1303:17 - these and drop these into a dot
env. So the API key, go ahead
1303:21 - and copy, come back over here.
Open up our dot env. And we're
1303:26 - gonna call it our pinata. And
data API key equals that key.
1303:33 - We're going to grab the API
secret and say pinata API secret
1303:39 - equals that key. We don't need
this massive token here for what
1303:42 - we're going to do. But if you
want it, you can absolutely have
1303:44 - it. And then outside of our
store images, we're going to say
1303:47 - const pinata API key equals
price says, do you need that
1303:54 - pinata API key? And then can't
pinata. API secret equals
1304:03 - process dot E and V dot pinata
API secret. And then we'll say
1304:09 - const. pinata equals pin auta s.
DK of pinata
1304:19 - API key comma, pinata API.
Secret in order to work with
1304:24 - pinata, we need to pass it an
API key and API secret so that
1304:29 - pinata knows it's us who's
working with them. So once we
1304:32 - initialize this pinata thing, we
can now run pinata dot and then
1304:38 - do some pinata stuff, right, we
want to work with this pin file
1304:42 - to IPFS, which takes this
readable stream, which is why we
1304:45 - created that readable string, so
pinata that pin file to IPFS. Of
1304:52 - readable stream or file. And
then we're going to push this
1304:58 - response on to our responses
array. So we'll say responses
1305:02 - dot push response. And then
we're going to catch error, just
1305:06 - in case there's some weird error
here. And we'll just say console
1305:09 - dot log error, and then we're
going to return responses and
1305:14 - files. So we're going to return
all the responses from pushing
1305:18 - all these files up, and then the
files as well. Now, at this
1305:22 - current point, we can go ahead
and actually test this out
1305:25 - ourselves. So we have this in
here. If we go back to our
1305:28 - deploy, at the top, we have this
if process dot E and V dot
1305:31 - upload to Niada equals true, do
this stuff here, uploading to
1305:37 - IPFS. And the final thing we
need to do in here, of course,
1305:40 - is going to be require dot env
dot config, so that we can pull
1305:48 - in our dot env file. Down here,
we're just doing a weight store
1305:52 - images. So if we run this as is,
it should go ahead and store
1305:57 - images. So let's run that same
command, or that deploy random
1306:02 - IPFS and the MOX to run this
store images command. And if we
1306:05 - come back to our pinata, after
we run it, we'll be able to see
1306:09 - the code uploaded here. If we
run now, the script loaded IPFS
1306:15 - it'll give us a little bit of a
delay, because it needs to
1306:17 - upload these big picture files
to IPFS. or more correctly.
1306:22 - pinata, I'm gonna say uploading
to nada. And we could even say,
1306:27 - console dot log, working on file
index, done Excel. And okay,
1306:35 - great. It looks like it finished
running. So if we come back to
1306:38 - our project here, and we do a
little refresh, we see our three
1306:43 - files have been uploaded, and we
see they each come with their
1306:46 - own CID. Now, if you want, you
can go ahead and copy the CID.
1306:51 - And if you have your IPFS node,
what you can do, what we can do
1306:55 - is actually we can hit import
from IPFS. Paste it in here. And
1307:00 - we can say exactly what this is,
which is IPFS dot dot slash last
1307:05 - as the St. Bernard called St.
Bernard. Important. And now
1307:10 - we'll have it pinned on our
IPFS. I've got mine saved in a
1307:14 - little puppies file. Now that
we've got them uploaded, and
1307:17 - pinata do actually recommend you
pin your own on your own node as
1307:20 - well. So cool. So we've got a
way to get those images up onto
1307:25 - IPFS. Awesome
1307:26 - onto. Now that we've done that,
we're also going to need to
1307:34 - store the token URI metadata. So
let's go ahead and we'll delete
1307:39 - that for now. What we can do
back in here, is back up at the
1307:43 - top again, we can say const meta
data, template equals and we'll
1307:49 - create a metadata template. This
is going to have all the basics
1307:53 - of what we need for our metadata
for our token URI. So in here,
1307:57 - we'll have a name, set, it's
blank, we'll have a description,
1308:02 - which will also set as blank
will have the image which this
1308:06 - is going to be replaced with the
image URI that IPFS URI we just
1308:10 - created. And if you want to give
your NFT like any types of
1308:14 - stats, you can do some you can
create this Attributes section
1308:20 - like so. And if you give it like
traits type, cuteness, comma,
1308:26 - value 100. And this is how if
you wanted to create like
1308:29 - different cards or have
different attack, defense, HP
1308:33 - speed in different different
stats for your NF T's, you would
1308:37 - add them in this Attributes
section. Typically, you'd want
1308:40 - these attributes also stored on
chain so your contracts can
1308:43 - obviously programmatically
interact with these attributes.
1308:46 - But so now we have this metadata
data template. This is what
1308:49 - we're going to fill out for each
one of our dogs. Yes, we're
1308:52 - going to create a new function
in here called async, store
1308:57 - token URI metadata. And we'll
pass in the meta data to the
1309:03 - async function. And we'll pass
in the metadata that we get from
1309:07 - our script over here. So we have
this little template here. And
1309:10 - we're going to populate this
template based off of what we
1309:14 - get from storing data in IPFS.
So now we're going to write the
1309:17 - rest of this handle token your
eyes bit. And so we're going to
1309:20 - want to do in our data and V,
we're going to say, upload to
1309:23 - pinata equals true, so that we
can do everything and handle
1309:28 - token your eyes. So upload to
pinata, it's true, we'll scroll
1309:31 - down, we'll start creating this.
So the first thing we got to do,
1309:34 - obviously, we're gonna want to
get those responses and those
1309:37 - files, right, because it's in
the responses, pin file to IPFS
1309:41 - is going to return the hash of
the file, right, and we need
1309:45 - that hash, to add to our
metadata. So we're going to do
1309:48 - is down here, we're gonna say
const, responses, which is going
1309:52 - to be image upload, responses,
comma files, equals await, store
1310:00 - images, and then images,
location. And so this response
1310:06 - is, is going to be a list of
these responses from pinata. And
1310:11 - these responses are going to
have the hash of each one of
1310:14 - these uploaded files. So now
we're going to loop through that
1310:17 - list and upload each of the
metadata does. So we're going to
1310:20 - say for each image upload
response index, in image upload
1310:29 - responses.
1310:31 - For each one of these, we're
going to create the metadata,
1310:34 - we're going to create metadata
and then upload the metadata. So
1310:38 - we're gonna say let token URI,
metadata equals dot dot, dot
1310:45 - meta data template. So this is
some fun JavaScript, syntactic
1310:50 - sugar, which kind of means like,
unpack. So basically, we're
1310:54 - saying token URI metadata is
going to be equal to this stuff.
1310:57 - We're sticking all this stuff
into this token, your metadata
1311:01 - variable, now we're gonna say
token, your metadata. dot name
1311:05 - is going to be equal to files
of, of the index, dot replace,
1311:13 - dot png, dot png with nothing.
So files is going to be each one
1311:17 - of those files, right? It's
going to be dot png can be St
1311:22 - Bernard dot PNG, and it's going
to be Shiva dot png. And
1311:26 - basically, all we're doing is
we're saying, okay, cool, the
1311:28 - name inside of our token,
metadata is just going to be
1311:31 - pug. So we're just going to drop
the extension, basically. So
1311:34 - that's how we're gonna get the
name token, your AI metadata dot
1311:39 - description, is going to be
equal to and adore a bowl. And
1311:46 - then we're just going to get the
name, token URI metadata dot
1311:50 - name. So it's going to be an
adorable pug pup and adorable
1311:53 - St. Bernard pop or an adorable
ship and you pup token URI
1311:57 - metadata dot image, which is
probably the most important one
1312:01 - here, this is going to be, it's
going to be that IPFS extension
1312:05 - with the IPFS hash that we get
from the response. So we can get
1312:10 - that by doing image, upload
responses of the image upload
1312:19 - response index dot i IPFS. Hash,
so we can go to the pinata docs.
1312:26 - And we can see pin file to IPFS
returns in IPFS hash, the pin
1312:31 - size and the timestamp, all we
care about is the IPFS hash. And
1312:36 - we're going to use that to give
the our metadata image here. And
1312:41 - then finally, I'll do a little
console dot log uploading. And
1312:45 - then we'll say, token, your eye
metadata dot name, dot dot dot.
1312:52 - And now we'll have to store the
file or store store the JSON to
1312:58 - pinata slash IPFS. And this is
where in our upload to pinata
1313:02 - bit here, we're going to add
this function here. So we have
1313:05 - store token URI metadata. And
all we're gonna do in here, so
1313:08 - we're gonna say try const
response equals await, and nada,
1313:13 - that pin JSON to IPFS of the
metadata, right. And again, we
1313:20 - have, we want pin JSON to IPFS,
which is going to be really
1313:25 - similar. So we need to pass the
body, which is going to be the
1313:29 - JSON. And we have some optional
stuff here, but it's gonna give
1313:31 - us the same return the IPFS hash
pin, size and timestamp. And
1313:36 - then if this works, well, we're
just going to do return
1313:39 - response. Otherwise, we'll do
catch error. And then we'll just
1313:43 - do console dot log error, and
then we'll just do return null
1313:50 - and then we'll exports or token
URI metadata. And then back in
1313:54 - our deploy, we'll go ahead and
import this store token URI
1313:58 - metadata. And we'll scroll down.
And they'll do const, metadata,
1314:04 - upload response equals await,
store token URI metadata where
1314:10 - we pass the token, Uri,
metadata. And now finally, and
1314:15 - now with all of these metadata
is being uploaded are finally
1314:19 - going to have the token you
arise that we need. So we'll
1314:22 - say, token, your eyes dot push,
IPFS, slash slash, and then the
1314:28 - metadata response here, metadata
upload response dot IPFS. Hash.
1314:33 - So we finally will have this
array of IPFS hashes that points
1314:37 - to the metadata, and each one of
these metadata are pointing to
1314:40 - the image. And then we'll do a
little console dot log token.
1314:44 - You arise, uploaded, they are
and then we'll do another little
1314:50 - console dot log token your eyes.
Oh, all right. So let's go ahead
1314:56 - and run this. And let's see if
it works. In our pinata, we
1315:00 - should see both the images and
then also the metadata. If
1315:04 - process dot E and V dot upload
to pinata equals true, looks
1315:08 - like it is true. And we should
run this and handle token, your
1315:12 - eyes will both upload our images
with store images here and then
1315:17 - upload our metadata. We'll only
see it in here once because
1315:21 - again, it's gonna have the exact
same Cid right, it's gonna have
1315:24 - the same hash, so we won't get
duplicates of the same file in
1315:28 - pinata, or in our IPFS. So let's
open this up. Let's run this one
1315:33 - more time, or had deployed dash
dash tags, random IPFS and
1315:37 - mocks. Okay, it looks like we
almost worked uploading to
1315:40 - banana working on zero working
on one working on two metadata
1315:44 - template is not defined. Ha,
because I spelt meta data
1315:50 - template, meta data template,
let's spell things correctly.
1315:55 - Now let's try this again, it
working on zero is it working on
1315:58 - two image upload response is not
defined. I should spell
1316:02 - correctly. There we go. Let's,
let's do our caps correctly.
1316:07 - Let's try this one more time.
Okay, 012, uploading pug
1316:11 - uploading Shiva in you uploading
St. Bernard token your eyes
1316:14 - upload it and they're here. Now
if we grab this, and stick it
1316:18 - into our browser, or your IPFS
node, boom, we have them in
1316:22 - here. And what we can do is we
can grab this hash, we can jump
1316:26 - into our IPFS desktop, go to
files, we import from IPFS paste
1316:32 - it in here. And you know give it
the name etc, that we have it on
1316:35 - our own IPFS node as well.
Awesome. Now if we go over to
1316:39 - pinata give this a little
refresh, we can see we have
1316:43 - everything in here. So if I copy
one of these, and I go to IPFS
1316:47 - dot dot slash paste that in, we
can see the metadata in here.
1316:51 - And everything looks good. So
this is absolutely massive that
1316:55 - we've just done this because now
we can store data both on our
1316:58 - own IPFS node and at least one
other nodes so that if our
1317:02 - computer goes down or our server
goes down, and there's at least
1317:04 - somebody else who's done it.
1317:11 - Now we finally have this list of
token your eyes, we can finally
1317:14 - go back to our arguments. And
now we can do like this. And we
1317:20 - can upload all of those token
your eyes to our smart contract.
1317:23 - And then we're going to need a
mint fee as well for this. So if
1317:26 - we go to our upper heart at
config will create like a little
1317:29 - mint fee in here, say mint fee
is going to be whatever we want
1317:33 - 12345678123456789 What we'll do
is 0.01 eath. So we'll even drop
1317:41 - this down one, we'll do it for
we'll do it for the Hard Hat
1317:44 - Network. And then we'll also do
it for Rinckey as well. We have
1317:47 - the arguments here. Now we can
finally deploy our contract. So
1317:51 - we'll do const random IPFS. And
if t equals await, deploy, if
1317:57 - the contract is random IPFS NF T
from Deployer. args is args. Log
1318:05 - is true. And then wait
confirmations is going to be
1318:11 - network dot config dot block for
confirm terminations, or one,
1318:21 - and great they might do another
little line here. We'll do the
1318:25 - verification bit. I'm actually
just going to copy that from our
1318:28 - deploy. Our basic I'm just going
to copy this it's going to be
1318:33 - code is going to be exactly the
same, except for we're going to
1318:36 - verify random IPFS instead of
and then actually we use args
1318:41 - instead of arguments, then that
is it. So we'll give this a
1318:44 - quick deploy test, HH deploy or
yarn Hardhead deploy. And it
1318:49 - looks like we almost worked we
almost got Everything's done.
1318:52 - Network config is not defined,
because we didn't import it. So
1318:56 - let's go ahead and import
network config from our helper
1318:59 - Hardhead. Config. So import
network config. We'll try this
1319:03 - one more time chain ID is not
defined, it's going to be chain
1319:07 - ID, that chain Id try one more
time. And awesome, it's at least
1319:13 - working for our heart Hat
Network. And then we can copy
1319:15 - this array, and just paste it in
here. Boom. And now we have this
1319:19 - token your eyes. And now back in
our dot env. Now we can set this
1319:23 - to false. Since we have all
those token neurons already, we
1319:27 - just run hard hit Deploy, we'll
just use the token heroes that
1319:30 - we already have uploaded. Yes,
we have done it. Now I know
1319:34 - you're excited to see this on
something like open See, you're
1319:38 - excited to see this right away.
But let's save deploying all
1319:41 - these to rink B for our last
thing, because again, deploying
1319:44 - to test nets is really slow. So
let's just wait until our last
1319:47 - bit and then we'll go ahead, and
we'll deploy this to rank B. But
1319:51 - before we write tests, something
that I noticed when I was
1319:53 - writing my test is that we
forgot to update the token
1319:56 - counter. So in here, before we
do, our safe, men will do s
1319:59 - token counter plus equals s
token counter, which is going to
1320:03 - be esto. Encounter equals es
token counter plus one. And
1320:07 - that's a perfect example of why
writing tests is so important.
1320:10 - Before you write any tests,
you're definitely going to need
1320:12 - to fund that subscription, which
we didn't do in here. So we need
1320:16 - to do a wait VRF coordinate Tor
V to mock dot fund, sub
1320:25 - scription. subscription ID,
comma will do fund amount, and
1320:32 - then just up at the top,
actually, we can even pull this
1320:35 - out too. Since that's not gonna
change at all. We can do let
1320:38 - token year I was like that looks
like const fund amount equals
1320:44 - cool. Or you could do you know,
you could also do ethers dot
1320:46 - parse. But as you know, before
we can even deploy to rink beam,
1321:00 - what should we do? Well, you got
it right, we should absolutely
1321:03 - 100 percent write some tests. So we're
create a new file called random
1321:08 - IPFS NF t dot test dot j s. And
we can write some tests here.
1321:14 - Now, once again, there isn't
anything new that you're going
1321:16 - to learn in this test here, it's
going to be very similar to the
1321:20 - lottery tests that we've written
before. So here's what I'm going
1321:23 - to say, I'm going to highly
recommend once again, that you
1321:27 - try to write at least two or
three of your own tests, but
1321:30 - definitely write a test fulfill
random words. But I'm going to
1321:33 - encourage you to pause the video
now, please pause the video and
1321:37 - try to write some tests yourself
struggling with some of these
1321:40 - tests. And writing some of these
tests is going to be what really
1321:42 - gives you those coding muscles,
if you will, that's going to
1321:45 - give you the skills to keep
writing these tests and be
1321:47 - really fast and really
efficient. When you're building
1321:50 - these smart contracts. These
tests are the tests that protect
1321:53 - you from writing bad immutable
code. So please pause the video,
1321:57 - I'm going to copy paste from the
GitHub repo. But please take
1321:59 - this time to write some of your
own tests here.
1322:08 - Alright, great. Did you write
some tests? Hope you did. If you
1322:12 - didn't write some tests, pause
this video and go write some
1322:14 - tests. I promise you doing these
tests, writing exercises on your
1322:17 - own will help you dramatically
at this point, what have we
1322:20 - done, we've done some some
amazing stuff, we've deployed a
1322:24 - basic NFT with pretty much
nothing to it, then we've
1322:27 - deployed a provably random NFT
with random stats with random
1322:31 - traits with different rarities,
for each NF T's depending on
1322:35 - when it was minted, or who
minted it. We've stored the data
1322:38 - for this on IPFS. And we've
learned how to programmatically
1322:42 - upload our files to pinata,
which is another pinning service
1322:46 - for us. We learned a little bit
about NFT debt storage, which is
1322:49 - another way to pin data to IPFS.
And then of course, we learned
1322:54 - that if we wanted to, we could
programmatically pin data to
1322:58 - IPFS on our own node. But since
a lot of us aren't gonna be
1323:01 - running our own computers 24/7.
We went ahead and said, Okay,
1323:04 - well, we'll stick with pinata
for our default here. Now that
1323:07 - we've done all that, boom, got
another little checkmark here.
1323:13 - Now I got something to say we
don't need to host our data on
1323:16 - IPFS can actually host our data,
our metadata directly on chain
1323:21 - if we want to. However, there
are some pros and cons to IT
1323:24 - pros of hosting on IPFS, or
that's going to be cheap. And
1323:27 - the cons are that someone needs
to pin our data, right? There's
1323:32 - at least one person always needs
to have her data pinned, right?
1323:36 - It's decentralized, but you at
least need somebody to pin your
1323:39 - data, right? And using something
like file coin is a way to
1323:42 - incentivize people to pin that
data. But if you're not using
1323:45 - File coin, it's not necessarily
guaranteed the pros of doing our
1323:48 - SVG on chain NFT the data A is
on chain. And you never have to
1323:53 - worry about somebody actually
pinning the data. The cons are
1323:56 - that this is much more
expensive. These little images,
1324:02 - right here are actually
surprisingly large and storing
1324:05 - them on chain can actually get
pretty expensive. So we're going
1324:07 - to use some different images, so
much smaller images, much
1324:10 - cheaper images to work with
here. And if you want to see
1324:13 - another version of this, I have
another video, how to make NFT
1324:17 - art with on chain metadata, it
goes through pretty much what
1324:20 - we're about to go through here
as well if you want a second
1324:23 - reference, and there's a link to
this in the GitHub repo
1324:25 - associated with this course. So
instead of these PNGs that we're
1324:29 - using, we're going to use
something called SVG s. Now, an
1324:38 - SVG stands for Scalable Vector
Graphics. And these are much
1324:42 - much more minimalistic files
that we can go ahead and upload
1324:46 - to to the blockchain. So that's
why we're going to use them
1324:49 - because since there's so much
more minimalistic, they're a lot
1324:51 - cheaper to upload. Because
remember, the more data that you
1324:53 - upload to the blockchain, the
more expensive it is. Now in
1324:56 - this video, I make randomize SVG
data on chain. And here's kind
1325:00 - of an example of what one looks
like. It's just a whole bunch of
1325:02 - random lines. Not super
thrilling, but random and kind
1325:06 - of cool. And it's 100 percent. On
chain, these SVG is actually
1325:09 - work right in HTML. So if you
want to use these for your
1325:12 - websites, you can as well now
there's a link to this tutorial
1325:16 - in the GitHub repo associated
with this course, where we can
1325:18 - go ahead and try it yourself.
And we can actually play with
1325:21 - making an SVG, right, so they
have all these different
1325:23 - commands in this web through
schools.com/graphics/svg intro
1325:29 - dot ASP, you can see some of the
different commands, right, you
1325:32 - can make a rectangle you can
make a circle path is a big one
1325:36 - where you can say exactly what
the path or the line you want to
1325:40 - draw is going to look like.
There's a whole bunch of stuff
1325:43 - you can make in this SVG. And
the cool thing is, no matter how
1325:46 - big you make an SVG, the quality
is always going to be exactly
1325:50 - the same, because SVG just
explains exactly how to draw it
1325:53 - no matter how big or how little,
the image is going to be. So if
1325:56 - you want to learn more about SVG
is you want to play with SVG is
1325:59 - you know, you can come in here
and try it yourself. So with
1326:02 - that being said, that's what
we're going to store on chain.
1326:04 - So that's how we're going to
store this SVG stuff on chain.
1326:07 - But we're gonna go one step
further, we're gonna make this
1326:09 - dynamic, we're gonna make this
actually change based off of
1326:13 - some data on chain. If you go to
the GitHub repo associated with
1326:17 - this lesson, and you go to the
images, and you go to dynamic
1326:20 - NFT, you'll see two images, see
happy dot SVG, which looks like
1326:24 - this. And you'll see frown dot
SVG, which looks like this. So
1326:29 - we're going to make this NFT
dynamic in the sense that we're
1326:32 - going to say, if the price of
eath is above some number, then
1326:37 - we're going to have it be a
happy face. And then if it's
1326:39 - below that, we're going to make
it a frowny face. So our NFT is
1326:44 - going to change based off of
some real world parameters. And
1326:47 - this is obviously really
powerful and really cool,
1326:49 - because we can have an NFT that
changes based off stats, we can
1326:53 - have an NF t that changes based
off of really whatever, and
1326:56 - we're going to store all the
data 100 percent on chain, it's going
1326:59 - to be a little bit more
expensive. So that's what we're
1327:02 - going to be building here.
1327:08 - Let's go ahead, let's jump into
it. And let's do the final
1327:11 - contract for our ultimate NFT
section. So we're going to
1327:14 - create a new contract in here,
new contract, and this is going
1327:17 - to be our dynamic, SVG and F T
dot soul. And it's going to look
1327:24 - real similar to what we've been
doing. slash slash dynamic. SVG
1327:28 - and ft dot saw, slash lat spdx,
license identifier, and my team
1327:37 - pragma. solidity, Eric zero,
point 8.7. Contract, dynamic
1327:46 - SVG, NF t. Now let's talk about
what the architecture of this is
1327:52 - going to look like. It's gonna
look like pretty normal NF T,
1327:55 - with a couple of caveats. We're
gonna give it a min function to
1327:58 - mint, these NF T's are also
going to store our SVG
1328:02 - information somewhere. And then
we're going to need to have some
1328:07 - logic to say show x image or
show y image, right. And as we
1328:14 - know, that's really just going
to be switching the token URI to
1328:17 - say show X or show y. So let's
go into how we'd actually do
1328:21 - this. So first, we know this is
going to be in ERC. 721. So we
1328:25 - can go ahead and import that
from open Zeppelin. So we're
1328:27 - going to say import at open
Zeppelin slash contracts, slash
1328:33 - token slash ERC. 721 slash ERC.
721 That's all. Now we're not
1328:40 - going to call that set token URI
function that we call before so
1328:43 - we can just use the raw ERC 721
instead of an extension. So
1328:47 - we'll say our contract is ERC
721 and Now that we're making it
1328:52 - an ERC 721. We can say construct
dorm like this, then we'll call
1328:57 - the constructor of the ERC. 721,
which we're going to call this
1329:01 - dynamic SVG, and f t DSN,
dynamic SVG and s, t and f t,
1329:10 - like so then we're also going to
need a mint function. So let's
1329:14 - just create that right now say
function, mint and f t or
1329:18 - request NFT. And we'll be a
little bit looser here, we'll
1329:21 - say the user doesn't need to pay
any money for this. So this will
1329:25 - just be a public function. And
we're just going to mint them
1329:27 - and NFT. Same thing, we're just
going to call Safe mint message
1329:31 - dot sender. And of course, we
need that token count term. So
1329:35 - let's go ahead and in our top
will do you in 256, private s
1329:40 - underscore token counter, we'll
do token counter here. And then
1329:45 - after we meant we'll do tag
counter plus, there's gonna be
1329:47 - equals token counter plus one.
And then that's pretty much it,
1329:52 - we have a way to meant we've
done some of the basics here.
1329:55 - We'll even we'll be explicit
will say s token counter equals
1329:58 - zero to initialize it. But now
what is this token going to look
1330:02 - like? We want these to look like
SVGs. And we want it to be based
1330:05 - off the price of some asset in
our constructor, all right,
1330:10 - create a string memory. We'll
call it low SVG and a string
1330:15 - memory, high SVG. And in our
code will save this low SVG in
1330:27 - this highest V G. So these will
be the images, these will be
1330:30 - like the frowny face and the
smiley face that will just
1330:32 - import as input parameters here.
So as we know, we can make these
1330:37 - immutable since these are
probably not going to change. We
1330:39 - can say String, private, I
underscore low image URI. And in
1330:47 - string private, I underscore
high image URI. But if we just
1330:52 - pass the SVG data, right, the
SVG data is going to look like
1330:55 - what in this GitHub, I can go to
display the source blob here and
1331:00 - I can see exactly what this code
looks like this code here is
1331:03 - definitely not an image URI.
What we need is the image URI to
1331:07 - look something like this, right?
Now, the way that we're going to
1331:09 - pass it in is like with this SVG
code, right? Because we want to
1331:12 - just pass it the SVG code, and
then have the contract handle
1331:15 - everything else.
1331:16 - So how do we actually do this?
Well, what we can do is we can
1331:21 - create a function called SVG to
image URI. And on chain, we can
1331:28 - convert these SVGs from SVGs. To
image arise. So instead of
1331:33 - having IPFS, as their start,
we're gonna use something called
1331:37 - base 64 encoding, you can
actually encode any SVG to a
1331:43 - base 64 image URL. That's right.
It'll look something like this
1331:48 - base. 64 is group a binary to
text encoding schemes that
1331:51 - represents binary data. Or in
our case, our SVG data. Base. 64
1331:56 - is particularly prevalent in the
world wide web, or one of its
1331:59 - uses is the ability to embed
image files or other binary
1332:03 - assets inside textual assets,
such as HTML, and CSS, what we
1332:07 - can do, can actually convert all
this SVG stuff to a URL or an
1332:12 - image URI would be great, right?
That's exactly what we want, we
1332:16 - want to be able to convert this
to a URL or an image URI. Now,
1332:20 - if you take one of these images,
or these SVG images, like the
1332:23 - happy to have SVG, what we can
actually do in this happy dot
1332:26 - SVG is we can actually copy the
image address, which is going to
1332:31 - be the URL of this address. And
if we paste it back in, we'll
1332:34 - see justice file here. And in
this site, we can actually do
1332:38 - data type, remote URL, paste it
in here. And we can say encode
1332:43 - SVG to base 64. And down here,
we'll get this weird job role of
1332:48 - numbers and letters and stuff.
This base 64 encoding represents
1332:53 - the SVG that we just got and
what we can do in our browser,
1332:56 - we can type data, colon, image,
slash SVG, plus XML, semicolon,
1333:06 - base, 64, comma, and then paste
that massive thing in here and
1333:11 - Enter. And wouldn't you know it,
we get exactly that image back
1333:16 - up. So that huge, massive thing
here is the base 64 encoding of
1333:21 - this image. So with this basic C
four encoded image, we can use
1333:24 - this on chain as the image you
arrive for our images. And then
1333:28 - for our metadata. We'll just
bake that directly into our
1333:31 - token URI. You'll see what I
mean in a second. So we have a
1333:34 - way where we can actually
directly put our SVG code right
1333:38 - into our smart contracts. Let's
figure out how to do that. So we
1333:40 - have function, SVG to image URI,
so we know we're going to want
1333:44 - to probably do that same base 64
encoding on chain. We're gonna
1333:47 - 100 percent do this off chain if you
want to save some gas but it's
1333:50 - kind of fun for To show how to
do this all on chain, so we'll
1333:53 - make this a public pure
function. And we'll have it
1333:56 - returns a string memory. So
we're going to give this
1334:02 - function an SVG, which we're
going to pass in from our
1334:05 - constructor. And we're going to
return a string, which is going
1334:08 - to be that base 64 encoded URL
that we just saw, while up at
1334:11 - our top will do string, private
constant, base S feed, base 64,
1334:21 - encoded SVG prefix equals that
right there. And we'll use this
1334:29 - to generate our SVG now, well,
we can do. And then we're going
1334:34 - to do string memory SVG, we're
going to encode this SVG in
1334:39 - basically for ourself by adding
the base 64 encoding on chain.
1334:43 - Now, we don't really want to
have to rewrite that ourselves.
1334:47 - So luckily for us, somebody has
already done this. And we can
1334:49 - see the GitHub repo associated
with this, this was created by
1334:52 - one of the LoopRing devs really
awesome project, if you want to
1334:55 - check that out as well. And
we're going to borrow this code
1334:58 - for our SVG on chain. So what we
can do is we can add this in
1335:02 - here, add their GitHub code,
where they have basically
1335:05 - everything that we need in here
to encode and decode basics
1335:09 - before, we can do yarn, add dash
dash Dev, base 64 Dash soul,
1335:16 - this is going to add their code
as a dependency. And once we've
1335:18 - added it, we can go ahead and
import it with import, base 64,
1335:24 - dash soul slash, base 64 dot
Sol. And this contract comes
1335:31 - with an encoder. So then we can
just do string memory, SVG base,
1335:37 - 64, encoded, equals base 64 dot
ENCODE. And here's where it gets
1335:44 - a little bit weird.
1335:45 - We'll do bytes string, abi dot
ENCODE, act, SVG, and then we'll
1335:56 - return string API dot encode
packed, base 64, encoded SVG
1336:04 - prefix, comma SVG base 64
encoded, and just this function,
1336:09 - this SVG to image URI will take
in any SVG and spit us back out
1336:15 - a URL or URI that looks exactly
like this. Now, I kind of sped
1336:20 - through some stuff in here.
There's a whole bunch of new
1336:22 - stuff like ABI dot encode packed
that we did twice, what is this
1336:26 - ABI dot encode packed doing?
1336:29 - Well, let's learn about that. So
from a really, really high
1336:37 - level, this is basically how you
concatenate strings. Right, this
1336:41 - is how you combine strings
together. And we're going to
1336:44 - jump over remix to actually
explore this ABI dot encode pact
1336:49 - and this ABI encoding stuff a
little bit more. Now the section
1336:52 - that we're about to go through
is definitely advanced. And
1336:56 - we're going to be going over
some really low level stuff, and
1336:59 - how solidity works behind the
scenes, how the binary works,
1337:03 - and this thing called opcodes.
And all this crazy, low level,
1337:06 - tricky, difficult things to
understand. If you want to move
1337:09 - past this section, there are
timestamps in the GitHub repo.
1337:13 - To help you move past this.
However, I do encourage you to
1337:16 - at least try to absorb most of
this material, if you don't
1337:20 - understand it the first time.
That's 100 percent. Okay, this is more
1337:24 - advanced. Anyways, for most of
your basic projects, you won't
1337:28 - really need this information.
It's only later on once you get
1337:32 - more advanced that knowing all
this is really going to make you
1337:35 - a phenomenal solidity developer.
And when you approach this
1337:38 - section, when you approach this
sub lesson on EVM, opcodes, and
1337:42 - coding and calling, just know
that if you don't 100 percent
1337:45 - understand it the first time
that is okay, if you want to
1337:48 - watch this section a couple of
times fantastic. So if you want
1337:52 - to jump over to remix and follow
along, let's do it. Now in our
1337:55 - contract section, let's go ahead
and create a new file, we're
1337:57 - going to call it encoding dot
soul. And remember, all the code
1338:01 - that we're going to be going
with in here is going to be in
1338:03 - this sub Lesson folder of the
Hardhead NFT. FCC. And all the
1338:07 - code we're going to be working
with is going to be in this
1338:10 - encoding dot soul. And then in a
little bit, we're going to work
1338:13 - on this call anything that soul
so we're in this encoding dot
1338:17 - soul. And let's just make our
basic code here. So we'll say
1338:20 - spdx, license identifier, MIT
pragma, solidity, carrot, zero,
1338:32 - point 8.7, like that, do
contract encoding, boom,
1338:36 - compile, or Command S or ctrl S
great things are looking good.
1338:40 - Now remember, the whole purpose
for this is to first understand
1338:44 - what's going on here, and more
about this API dot encode packed
1338:48 - stuff. So let's first just write
a function that should owes us
1338:52 - wrapping API dot encode packed
with some strings and wrapping
1338:55 - it around a string is going to
return a string. So we could do
1338:59 - function, bind strings, or
concatenate strings. This will
1339:04 - be a public pure since we're not
going to be reading any storage,
1339:08 - we'll say returns string memory.
And we'll say return string, API
1339:15 - dot encode packed. I'm I'm
comma, space in here, I miss
1339:21 - you, like so. We need another
parenthesis here. Okay, great.
1339:25 - Now let's go ahead and deploy
this, we'll start a JavaScript
1339:28 - VM will deploy encoding
coding.so. We'll come down here,
1339:34 - we'll click Combine strings, and
we get that whole string output.
1339:37 - Hi, Mom, miss you. So what we're
doing here is we're encoding hi
1339:41 - mom misuse together into its
bytes form, because API dot
1339:46 - encode packed returns a bytes
object, and we are typecasting
1339:50 - it by wrapping it in this string
thing to be a string. And
1339:53 - solidity says, okay, yeah, bytes
to string, that's fine, that
1339:56 - totally works. And this API dot
encode packed are these globally
1340:00 - available methods and units. And
actually, in solidity, there's a
1340:04 - whole bunch of these, there's
this solidity cheat sheet, and
1340:07 - there's gonna be a link to this
in the GitHub repo as well, that
1340:10 - has a whole bunch of operators
and it has a whole bunch of
1340:13 - these global variables and
methods. You can see if we look
1340:15 - in here, we look for ABI dot
encode pact, we see ABI dot
1340:19 - encode pact right here, we
scroll down, we'll see some more
1340:22 - that we're familiar with as
well. Like, for example, message
1340:25 - dot sender, sender of the
message, message dot value.
1340:29 - There's a whole bunch of other
globally available methods and
1340:33 - variables that we can use when
we're coding our stuff. Now, I
1340:36 - will say though, in 0.8, point,
well, plus, you can actually do
1340:41 - string dot concat, you know,
string a, comma string B, if you
1340:47 - want to, instead of doing this
API to encode packed, but I
1340:51 - still wanted to show you the API
dot encode pack, because it's a
1340:53 - great segue into all this ABI
stuff that we're about to go
1340:56 - over. But let's focus on this
encode packed thing. So what is
1341:00 - actually going on here? Well,
before we dive deeper into this
1341:05 - encode pact, let's understand a
little bit more about what
1341:09 - happens when we send a
transaction. So when we compile
1341:12 - our code, and again, all these
pictures are going to be in the
1341:15 - GitHub repo. Remember back to
ethers.js, we had those two
1341:18 - files, we got a dot ABI file,
and a dot bin or dot binary.
1341:23 - Back in our ether symbol
storage, when we ran yarn,
1341:26 - compile. The two main files that
we got, were this symbol storage
1341:30 - that abi, which was this, you
know, this ABI thing that we've
1341:34 - become familiar with. And then
the simple storage dot bin,
1341:38 - which is the binary, which has a
whole bunch of just numbers and
1341:40 - letters and stuff we didn't
understand. And you can see that
1341:43 - in remix to, like if we were to
compile this, you get a
1341:47 - compilation details, you get a
whole bunch of stuff in here,
1341:50 - right? You can see the ABI in
here, which this is kind of like
1341:53 - a different way of viewing that
API, we also get this bytecode
1341:56 - bit and it's this object that
has the same stuff that has like
1342:00 - those random numbers and
letters. But this is actually
1342:03 - the binary this is actually
what's getting put on the
1342:05 - blockchain. It's this binary,
it's this low level stuff. Now,
1342:09 - when we actually send these
contracts to the blockchain,
1342:12 - we're sending like I said, we're
sending this binary thing.
1342:15 - That's exactly what we're
sending to the blockchain. And
1342:17 - remember how, again, back in our
ethers project, we saw what is a
1342:22 - transaction, right, a
transaction has a nonce, it has
1342:25 - a gas price guess limit to value
data, we kind of skipped over
1342:29 - the VRS a little bit, because
that's kind of that mathy
1342:31 - component of the transaction
signature. But again, back in
1342:34 - our ethos project, we did this
as well, right in our deploy
1342:37 - script, ended up sending a
transaction ourselves, using
1342:41 - just ethers. We passed a nonce,
a gas price, gas limit to value
1342:46 - data was this massive thing to
declare a contract, and then
1342:50 - also the chain ID. We didn't
work with the VAR s, because
1342:53 - ethers does that for us. But
there's also this VAR s
1342:56 - component that we don't bother
to look at. When we send a
1342:59 - transaction that actually
creates a contract, the two is
1343:04 - going to be empty. We're not
going to send this contract
1343:06 - deployment to any address. But
the data of this is going to
1343:10 - have the contract initialization
code and contract bytecode.
1343:15 - Right. So when we compile it, we
get all this code, like how do
1343:18 - you initialize the contract, and
then what the contract actually
1343:21 - looks like. So if you look at
any of the contracts that you
1343:24 - deployed, for example, I'm going
to look at our raffle that we
1343:27 - deployed. If you go to the
transactions of your contract,
1343:30 - we can see create raffle, right,
let's go to that transaction. If
1343:35 - we go down and click to see more
in the ether scan, we can see
1343:39 - this input data thing. And once
again, it's got all this random
1343:42 - garbled numbers and letters.
This is that binary data of the
1343:47 - contract initialization code and
the contract byte code right
1343:50 - what we send in our trend In
this action is this data thing,
1343:53 - we send this this weird bunch of
garbled nonsense. Now we're
1343:58 - going to head back to remix. And
I'm just going to leave this as
1344:00 - comments in here in the encoding
dot soul and the GitHub repo.
1344:03 - There's a ton of comments in
here explaining exactly what I'm
1344:06 - explaining. So if you want to
follow along there, you can as
1344:09 - well. But now in order for the
blockchain to understand, okay,
1344:12 - what do these numbers and
letters even mean? You need a
1344:16 - special reader cerium or the
blockchain needs to be able to
1344:18 - read all this stuff, it needs to
be able to map all these random
1344:23 - numbers and letters to what they
actually do. How does Aetherium
1344:28 - or polygon or avalanche know
that all this nonsense is
1344:32 - basically telling it to make a
contract, you kind of think of
1344:34 - it as saying, like, take off
your coat. The only reason that
1344:37 - we as human beings understand
what take off your coat means is
1344:41 - that we understand English,
We're all reading English, for
1344:44 - solidity. And for blockchains.
Instead of English, I read these
1344:47 - numbers and letters kind of like
words, just instead of take off
1344:50 - your coat, it's like deploy
contract, and the contract does
1344:53 - next XYZ and all this random
stuff. So this bytecode
1344:55 - represents the low level
computer instructions to make
1344:58 - our contract happen. And all
these numbers and letters
1345:00 - represent kind of an alphabet,
just like how take off your coat
1345:04 - is an alphabet. And when you
combine them like this, it makes
1345:07 - something that to us makes
sense, you can kind of think of
1345:10 - the alphabet for these as what's
called opcodes. If you go to
1345:13 - create a new tab, if you go to
EVM dot codes, we'll get to this
1345:17 - place where it just has a list
of all these instructions. On
1345:21 - the left side, you can see this
thing called opcode. And then
1345:25 - you can see name, so this opcode
section is saying, Hey, if you
1345:29 - see a 00 in this bytecode, that
00 represents this opcode stop,
1345:36 - which does what which halts
execution, if you see a 01
1345:41 - you're gonna do some addition
stuff, a 02 is multiply, there
1345:44 - are all these op codes that are
kind of like the alphabet, or
1345:49 - the language of this binary
stuff, right, and they go all
1345:52 - the way down to f f self
destruct, these op codes also
1345:55 - have, and that's what this is
reading. Right? So if we look at
1345:59 - our transaction here, and your
yours might be a little bit
1346:01 - different. Oh six, one says,
Okay, the first thing we want
1346:04 - you to do is the O six, one
opcode. And if we go to EVM,
1346:07 - opcodes, we look for six one,
it's saying push to place to buy
1346:12 - item on the stack. That's
exactly how it's reading this
1346:15 - any language that can compile
down to this opcode stuff down
1346:19 - to this specific set of
Aetherium opcodes, or EVM.
1346:23 - opcodes, is what's known as the
EVM, the Etherium virtual
1346:27 - machine. So being able to read
these op codes is sometimes
1346:30 - abstractly called the EVM, the
Etherium virtual machine, the
1346:34 - EVM basically represents all the
instructions, a computer must be
1346:39 - able to read for it to interact
with Aetherium, or Aetherium,
1346:42 - like applications. And this is
why so many blockchains all work
1346:47 - with solidity because solidity
compiles down to this bytecode
1346:50 - here, and polygon, avalanche
arbitrage Aetherium, they all
1346:55 - compiled down to the exact same
type of binary, and they all
1347:00 - have the exact same readers. Now
why are we telling you all this
1347:03 - stuff, you might be saying, hey,
Patrick, this is cool and all
1347:05 - but it looks like ABI dot encode
packed, all that does is
1347:07 - concatenate strings, abi encode
pack can do actually way more.
1347:12 - And if we look at these global
variables, API dot encode packed
1347:16 - is like what the third one down
the list because it's a non
1347:19 - standard way to encode stuff to
this binary stuff that we just
1347:23 - talked about, we can actually
encode pretty much anything we
1347:27 - want to being in this binary
format, basically. And let's
1347:32 - take a look at at encoding
something. So let's create a
1347:34 - function called encode number.
And this will be a public pure
1347:38 - function, since we're not going
to read any state, and we'll say
1347:41 - returns a bytes memory. We're
going to have this function
1347:46 - return a bytes object, we're
going to have it returned the
1347:49 - what this number is going to
look like but in binary, so
1347:52 - we'll say bytes, memory number
equals ABI dot encode one, and
1347:59 - then return number. So we're
going to encode number down to
1348:04 - it's a bi or it's binary format.
So I know a lot of times when we
1348:08 - say oh, what's the ABI what's
the ABI right? Previously, we
1348:12 - say, Oh, the ABI is, is this
thing, right? It's, it's all
1348:15 - these inputs and outputs. This
is kind of the human readable
1348:18 - version of the ABI. But again,
the ABI is the application
1348:21 - binary interface we want to
encode or numbers down to it's
1348:26 - basically it's binary, this ABI
dot ENCODE is going to be a
1348:29 - little different than like the
ABI that you see when you're
1348:32 - looking at compilation details.
This is technically like the ABI
1348:35 - technically is how to interact
with this contract. However,
1348:39 - it's not the actual binary
version of it. So we're saying,
1348:42 - okay, encode this number one
down to its binary version, so
1348:46 - that our contracts can interact
with it in a way that they
1348:49 - understand. So we're just saying
okay, Watch that number one,
1348:52 - let's make you machine readable.
And if we go, we compile this
1348:56 - and we deploy this right, let's
delete that that old contract,
1348:59 - we deploy this, we now have
combined strings and encode
1349:02 - number, we click it, we get this
big hex thing. This is how the
1349:07 - computer is going to understand
the number one. Now we can
1349:11 - encode pretty much anything
actually, we could encode a
1349:14 - string. So we'll say,
1349:17 - function, encode string, we'll
make this a public key here as
1349:22 - well. It'll return a bytes
memory, because we want to give
1349:27 - it that binary stuff or that
bites stuff. And we'll say bytes
1349:30 - memory, some string equals ABI
dot encode some string, and then
1349:37 - return some string. Now let's
compile that delete our old
1349:41 - contract, deploy that code
string, we get this big, big,
1349:45 - big object here. And this is the
binary. Now you'll notice
1349:49 - something here, there's a ton of
zeros, and those zeros take up
1349:53 - space, right, that's a lot of
space for the computer to take
1349:56 - up, even though they're not
really doing anything. They're
1349:58 - just kind of taking up space. So
solidity also comes with this
1350:02 - ABI dot encode tact, which
performs packed encoding of the
1350:07 - given arguments. And you can
read more about it in the
1350:10 - solidity docs, if you want. And
this is called the non standard
1350:13 - packed mode. And it does the
same encoding with some
1350:16 - stipulations type shorter than
32 bytes are concatenated
1350:19 - directly without padding, or
sign extension, dynamic types
1350:23 - are encoded in place. And
without the length array
1350:25 - elements are padded, but still
encoded in place, you can kind
1350:28 - of think of ENCODE packed as
sort of like a compressor,
1350:31 - right? It's the ENCODE function.
But it compresses stuff, if we
1350:34 - wanted to encode some string but
want to save space. And we
1350:37 - didn't need the perfect low
level binary of it. We could do
1350:41 - function and code string packed,
make this a public pure, and
1350:46 - have it return a bytes memory.
We could say, bytes memory, some
1350:51 - string equals ABI dot encode
packed once again, some string.
1350:57 - So we're doing a code pack
instead of a code. And we'll
1351:00 - return some string here, we'll
compile this and we'll see the
1351:03 - difference, right compile, we'll
delete our old one, we'll deploy
1351:07 - this. Now we have ENCODE string,
which again, that's what encoded
1351:11 - string is gonna give us and we
have encoded string packed,
1351:14 - which returns us this much, much
smaller bytes object. So you see
1351:19 - the size difference, if we're
trying to save gas, in code,
1351:23 - string packed is going to be a
way for us to save a lot more
1351:26 - gas. Now, abi dot encode pact is
actually really similar to
1351:30 - something that we've done
before, which is typecasting, if
1351:33 - we didn't function and code
string, bytes, public pure
1351:39 - returns, bytes, memory, bytes,
memories, some string equals
1351:46 - bytes, some string, turn some
string, these two are going to
1351:51 - look nearly identical, right? So
if we compile, we'll delete our
1351:54 - old contract, deploy this code
string bytes, which gives us
1351:59 - this and encode string pack
using the ABI to encode pack,
1352:03 - they give us the exact same
output, whereas encode strings
1352:06 - to give us this big piece. So
the two of these get the same
1352:09 - result. But behind the scenes,
they're doing something a little
1352:11 - bit different. And I'm not going
to go over exactly what that is.
1352:14 - But I've left a link inside of
the code here, if you want to
1352:18 - learn more, which is exactly
what we're doing in our NFT.
1352:21 - Right, we're doing ABR dot
encode packed, we're combining
1352:24 - two strings. By putting them
together, we're encoding them to
1352:28 - their bytes implementation to
their packed bytes
1352:31 - implementation, and then we're
just typecasting them back from
1352:35 - bytes to string. And that's how
we concatenate them. Now, at
1352:39 - this point, you
1352:39 - might be thinking, okay, cool.
Great, Patrick. I'm all set. I
1352:42 - understand this. I'm happy to go
back to my project. And if you
1352:45 - want to do that, absolutely go
for it and skip over this
1352:48 - section, but some other viewers
might be going okay, Patrick,
1352:51 - this is seems pretty cool. But
I'm sure this encode pacts in
1352:55 - this encode function aren't just
here to concatenate strings,
1352:59 - they probably have some other
function, what do they actually
1353:01 - do? Well, if that's what you're
asking, I'm glad you asked. And
1353:04 - I'm glad you're curious, because
we're going to find out. Now not
1353:06 - only can you encode stuff, like
strings and numbers, and really
1353:11 - anything, but you can decode
stuff. So I can say, function,
1353:17 - decode string, public, your
returns string memory, string
1353:23 - memory, some string equals ABI
dot decode. This is going to
1353:28 - take a couple parameters. So if
you look in the docs here, abi
1353:32 - dot decode, it takes as a first
argument, the encoded data, and
1353:38 - then it takes a tuple. You can
kind of think of it as a list
1353:41 - but not quite a list, a set of
types to decode this into and it
1353:45 - returns the number of parameters
that you gave it. So we might
1353:48 - want to say this string memory
some string Adding, let's give
1353:52 - it as input this encode string
function, the result of this
1353:56 - encode string function, right,
which again, is going to be this
1353:58 - big thing. So this is kind of
equivalent to sticking this
1354:02 - massive thing in here, but we're
just not going to stick the
1354:04 - massive thing in there, because
it's really big. So we're gonna
1354:06 - say, Let's decode the result of
ENCODE string, and let's decode
1354:10 - it into a string. Because we
need to tell solidity, hey,
1354:16 - we're going to decode this, but
it doesn't know what to decode
1354:19 - it into. It's like, okay, cool.
I can decode this, but like,
1354:22 - what, what do you want me to do
with it, and we say, Oh, this is
1354:26 - a string, so decode it into a
string. And then we can do
1354:29 - return some string. Now, once
again, we deploy that old
1354:33 - Cotters, we delete the last
contract, we deploy this new
1354:36 - one. So in code string, and code
string, whereas in code, string,
1354:40 - and code string returns this
massive thing, as a human being,
1354:43 - we're like, God, I can't read
that computers can read that.
1354:47 - But we can't really read that.
So we say, okay, let's decode
1354:50 - that back into its string form,
we hit decode string, and we get
1354:54 - back some string. And now we can
actually multi encode and multi
1354:58 - and decode, right, we can encode
as much stuff as we want. So I
1355:02 - can say function, multi ENCODE,
public pure, returns bytes
1355:07 - memory, we're going to encode a
couple of things, we'll say
1355:10 - bytes, memory, some string
equals ABI dot encode some
1355:16 - string, comma, it's bigger. So
we're going to encode two
1355:21 - strings here, we're gonna encode
some string, and it's bigger. So
1355:25 - we have two strings, we're going
to encode and we'll return some
1355:29 - string, even though it's you
know, bytes. And then we can
1355:33 - actually multi decode. So we'll
say function, multi decode, this
1355:38 - will be a public pure returns,
we'll say it returns two
1355:42 - strings, string memory, and
string memory. And instead of
1355:46 - doing string memory, some string
equals API decode, we'll say,
1355:51 - string memory, some string,
comma string memory, some other
1355:57 - string. So we're gonna get to
returns equals Avi dot decode.
1356:03 - Let's decode this multi encode
result, which is the doubly
1356:07 - encoded strings into a string
and another string. And then
1356:12 - we'll return both of these are
some string, there we go. Now
1356:17 - we'll return some string, and
then some other string,
1356:20 - I need a semicolon here. So now
when we deploy this, let's close
1356:24 - this out, deploy this new one,
right, we now have this multi in
1356:28 - code, which gives us this even
bigger bites object, right?
1356:32 - Because this is two strings
encoded. And now if we hit multi
1356:36 - decode, take a second, what do
you think it's going to put out
1356:38 - output? Let's go ahead and hit
it. Now it's gonna give us two
1356:41 - strings, right, it's gonna give
you these two strings, some
1356:44 - string, it's bigger. So we can
tell solidity to encode a bunch
1356:49 - of stuff. And then we can even
decode it by telling it, okay,
1356:53 - this big object here, it's two
strings combined, and then we
1356:56 - decode it. Now you can even
multi encode with that encode
1357:00 - pack thing, right? We could do
function, multi encode packed,
1357:04 - public pure returns, bytes
memory, and then bytes memory,
1357:10 - some string equals ABI dot
encode packed some string,
1357:15 - comma, it's bigger than return
some string, we could do this,
1357:20 - right, but this is going to give
us the packed version of these
1357:24 - two strings. So the decoding
actually isn't going to work on
1357:29 - this because this is packed
encoding. So if we tried to do,
1357:33 - I'm gonna say this doesn't work.
Try to do function, multi
1357:38 - decode, packed, public pure
returns, string memory, string
1357:45 - memory, some string equals Avi
dot decode multi encode packed
1357:52 - in a string and have exactly
what we did above to, if we do
1357:56 - return some string, what do you
think's gonna happen? Let's,
1358:00 - let's try to delete the old
contract, deploy a new one.
1358:03 - We'll do multi decode, packed,
multi encode multi decode,
1358:07 - packed, and we actually just get
an error. solidity basically
1358:11 - goes, Yeah, this looks like it's
packed. I don't know how to
1358:15 - decode that. But instead, what
we can do is we can do function
1358:19 - more to string cast packed like
this a public pure returns
1358:26 - string memory, string, memory,
some string equals string, multi
1358:33 - and code packed, return some
string. This one will work right
1358:39 - because again, this pact
encoding is kind of similar to
1358:43 - just type casting. So we'll
compile will redeploy multi
1358:48 - string cast pact, we get some
Trying, it's bigger, right? And
1358:52 - we don't have a space here. But
we should have put a space in
1358:54 - there. Now that we've learned
more about this in ABI dot
1359:03 - encode and decoding, and we know
that okay, this is what the
1359:06 - computer, this is, what
Aetherium. This is what the EVM,
1359:09 - or any EVM compatible chain is
looking for. It's looking for
1359:12 - this bytecode. It's looking for
this, this binary stuff. And we
1359:16 - just learned a little bit more
about how to encode different
1359:19 - variables into the binary into
that data bit. Well,
1359:22 - what do we do now? Now since we
know that our transactions are
1359:26 - just going to be compiled down
to this binary stuff, what we
1359:30 - can do then is we can actually
populate this data value of our
1359:35 - transactions ourselves with the
binary that code is going to
1359:38 - use. So here's our transaction
for a contract deployment, the
1359:42 - data field of the contract
deployment is going to be all
1359:44 - that binary code of the contract
for a function call, the data
1359:49 - piece is going to be what to
send to the address what data
1359:53 - what function to call on the to
address. Let's look at another
1359:57 - one of our transactions on ether
scan right on one of our
1359:59 - contracts, you don't have to I'm
going to look at enter raffle
1360:02 - from a previous section. And if
we select down, we look at input
1360:06 - data. It says function enter
raffle method ID. But if we look
1360:09 - at the original, this is what's
getting sent in the data field.
1360:14 - It's this binary, it's this hex
it's this weird, low level bytes
1360:18 - thing. This is how the Ethereum
blockchain or the or whatever
1360:22 - EVM chain you're working with
knows which function to call, it
1360:25 - translates this into a function.
And we can do the exact same
1360:29 - thing and call these functions
ourselves. So what we can
1360:34 - actually do with this crazy
newfound data and coding stuff,
1360:38 - what we can actually do is send
the data field of a transaction
1360:43 - ourself, in a transaction call
back in this ether throwback
1360:48 - where this data thing was the
contract creation code. Well,
1360:52 - instead, we could populate this
data thing with our function
1360:56 - call code, the exact function
that we want to call in the
1361:00 - binary in hex addition. Now you
might be thinking, Oh, well, why
1361:04 - would I do that, I can always
just use the interface, the ABI,
1361:08 - all that stuff, well, maybe you
don't have that maybe all you
1361:10 - have is the function name, maybe
all you have is the parameters
1361:14 - you want to send. Or maybe you
want to make your code, be able
1361:17 - to send arbitrary functions, or
make arbitrary calls or do
1361:21 - random really advanced stuff,
right, that's where sending our
1361:25 - function calls directly by
populating this data field is
1361:27 - going to be incredibly
important. So remember, I said,
1361:30 - you're always going to need the
ABI, and the contract address,
1361:34 - send a function. Now, when I
said, you always need the API.
1361:37 - Originally, we were kind of
talking about this thing, this
1361:41 - big, this big thing, which is
cool, which is the API. But this
1361:45 - is like the human readable API,
you can also do it with the non
1361:48 - human readable API. And
additionally, you don't need all
1361:52 - this stuff, you can really use
just the name of a function, and
1361:56 - then the input types to send a
function call. So the question
1362:00 - is, then, okay, how do we send?
How do we send transactions that
1362:05 - call functions with just the
data field populated? And then
1362:10 - the next question is, how do we
populate the data field? What do
1362:14 - we populate the data field with
to make one of these function
1362:17 - calls? And then how do we send
these transactions slowly,
1362:20 - actually has some more low level
keywords, namely, static call
1362:25 - and call we actually we've used
call in the past before, does
1362:29 - this code look at all familiar
to you? Well, it should, because
1362:32 - this is, we use a similar setup
in our fulfill random words for
1362:36 - our lottery, right, we sent
money doing this recent winner
1362:40 - dot call, right? Recently, it
was the address of the recent
1362:42 - winner, and we did not call. And
then we have this weird stuff in
1362:46 - this brackets here, and then
nothing in the parentheses. So
1362:49 - we did actually, essentially, we
use this call keyword
1362:52 - previously, but we didn't really
tell you what it did. So call is
1362:56 - how we can call functions to
change the state of the
1362:58 - blockchain. Static call is
basically how at a low level, we
1363:02 - call our view, or pure
functions, write static calls
1363:05 - gonna be like, okay, don't
change the state of the
1363:07 - blockchain with this one, just
give us the return value. So
1363:10 - this is kind of similar to like
a view or a pure function at low
1363:13 - level, there's also a Send word
but like, basically forget about
1363:17 - it. We're just gonna be working
with call, instead of call. And,
1363:20 - you know, later on, we'll
1363:21 - learn about another one called
delegate call. But don't worry
1363:23 - about that for now. Recent
winter duck call like this, in
1363:27 - these little squiggly brackets,
we said, Okay, we updated the
1363:30 - value directly of our
transaction in solidity. So
1363:33 - which again, if we have these
transaction fields, and we just
1363:36 - directly updated value in these
little brackets, right, we can
1363:40 - also directly update gas limited
gas price in these little
1363:43 - brackets if we wanted to as
well. And in here, these
1363:46 - parentheses is where we're going
to stick our data. Since all we
1363:49 - wanted to do with our
withdrawal. function previously
1363:52 - was send money. We said, Okay,
send money change the value that
1363:57 - we're going to send. But don't
pass any data, keep that data
1364:00 - bit empty, which is why, again,
remember how we hit this button
1364:05 - before, right and we had called
data be empty, that's
1364:08 - essentially running this command
with called data be empty with
1364:12 - this section be empty, and then
just updating the value that we
1364:17 - set with the transaction. And so
it's this section that we can
1364:19 - use to populate data to actually
call specific functions. We're
1364:23 - going to put a whole bunch more
comments here. So when our
1364:25 - squiggly brackets, we're able to
pass specific fields of a
1364:27 - transaction like value. And in
our parentheses, we're able to
1364:31 - pass data in order to call a
specific function. But in here,
1364:34 - there's no function to call
since we were just sending them
1364:37 - if we want to call a function or
send any data, we can do this in
1364:40 - the parentheses. And I think I
spelt that wrong. Now, we've
1364:49 - learned a ton here. So let's do
a quick refresher of what we
1364:52 - just learned. And then we're
going to actually learn how we
1364:55 - can call any function just by
using this syntax here. Well, we
1364:59 - learned from really high level,
if we want to combine strings,
1365:02 - we can do ABI dot encode packed
and then typecast that to a
1365:05 - string. And in newer versions of
solidity you can do, you can do
1365:09 - string dot concat, you know, Hi,
Mom, come on, miss you. In newer
1365:16 - versions of solidity. This works
as well, but not in older
1365:18 - versions of solidity. Then we
learned a lot about some low
1365:22 - level stuff we learned, okay,
when we compile our contracts,
1365:25 - we get an ABI file, and this
weird binary thing that numbers
1365:29 - and letters stuff that gets when
we deploy a contract that gets
1365:33 - sent in the data field of our
contract creation transaction.
1365:37 - So for contract creations, the
data is populated with that
1365:40 - binary code for function calls
is going to define which
1365:43 - functions to call in with what
parameters and this is what
1365:46 - we're gonna go over next. Now,
we learned that we can actually
1365:49 - encode stuff into this binary
into this low level code. And
1365:54 - any program any process that can
read this low level stuff and
1365:58 - execute accordingly, read this
EVM stuff, read the specific
1366:02 - binary that Aetherium has
specified, or the EVM has
1366:05 - specified is considered EVM.
compatible. We can encode
1366:09 - numbers, we can encode strings,
we can encode pretty much
1366:12 - anything we want to encode. To
save space, we do encode packed,
1366:16 - we can decode stuff that we've
encoded, but we can't decode
1366:20 - stuff that we encode packed, we
can multi encode stuff, and then
1366:24 - multi decode stuff. And then
finally, we can use this call
1366:27 - function and add data in here to
make any call that we want to
1366:32 - any smart contract. And this is
what we're going to learn next.
1366:35 - Alright, so now's a great time
to take a break, because we just
1366:37 - learned some really difficult
concepts. And like I said, if
1366:40 - you don't get it the first
1366:41 - time, that is okay. Alright,
welcome back. Now that we've
1366:49 - learned about this encoding
stuff, let's learn how we can
1366:52 - populate this parenthesis this
data field, so we can call any
1366:56 - function and we can do
essentially, what the blockchain
1367:00 - is going to do at the low level,
we can work with just that
1367:03 - binary, we can work with just
that bytes, we can work with
1367:05 - that hex to interact with our
smart contracts. So let's create
1367:08 - a new file. And we're gonna call
it call anything, that's all
1367:12 - start off with spdx, license
identifier, MIT. And let's talk
1367:16 - about this. Now in order to call
now in order to call a function
1367:19 - using only the data field of the
call, we need to encode the
1367:23 - function name, and the
parameters that we want to add,
1367:26 - right, because when we call a
function, we call the function
1367:27 - name. And we call the
parameters. So we need to encode
1367:31 - these down to the binary level
so that the EVM, or these
1367:35 - Aetherium based smart contracts
and solidity stuff can
1367:38 - understand what's actually going
on. In order to do this, we're
1367:40 - going to need to work with two
concepts to encode the function
1367:44 - name so that the EVM or solidity
can understand it, we actually
1367:48 - have to grab something called
the function selector. Now the
1367:51 - function selector is going to be
the first four bytes of the
1367:54 - function signature. And the
function signature is just going
1367:58 - to be a string, which defines
the function name of parameter.
1368:00 - Now, what does this actually
mean? Well, if we have a
1368:03 - transfer function, this right
here is known as the function
1368:06 - signature. So the function name
is going to be transfer. And
1368:09 - it's going to take an address
and a un 256 as its inputs, if
1368:14 - we encode this transfer
function, and then we take the
1368:17 - first four bytes of it, we get
this, which refers to the
1368:21 - function selector. So that's how
solidity knows. So in the
1368:25 - bytecode, in the binary code,
this function selector is how
1368:29 - slitting knows Oh, they're
talking about the transfer
1368:32 - function they want me to call
the transfer function. And this
1368:35 - is one of the first things that
we need to use call to call any
1368:38 - function that we want, we need
to get the function selector and
1368:42 - we can get it a number of
different ways but one of the
1368:44 - ways is by encoding the function
signature and grabbing the first
1368:47 - four bytes. So we'll create this
contract we'll do pragma
1368:51 - solidity zero point 8.7 Say
contract, call anything. And
1368:57 - we'll give this to stored
variables, give the to stored
1369:00 - variables and address public s,
underscore some amount, or some
1369:04 - address, and then you in 256,
public s underscore mount. And
1369:10 - then we'll create a function
called transfer function
1369:12 - transfer. Now normally in here,
we would actually do like
1369:15 - transfer for like an ERC 20
transfer, but we're just going
1369:19 - to do address some address, and
then you add 256 amount, amount
1369:24 - here, we'll make this a public
function. And then all we'll do
1369:28 - is we'll set S, some address
equals some address, and then s
1369:32 - amount equals amount. So here's
gonna be the function that we're
1369:36 - going to work with. And the
function selector for that
1369:39 - function is this, the function
signature is this. So it takes
1369:43 - an address some address amount,
that gets boiled down to the
1369:46 - function selector, and the
function signature. And of
1369:49 - course, in our bytecode, there's
going to be some code saying,
1369:52 - Okay, here's what this function
does, blah, blah, blah. So we
1369:55 - can actually even write a
function to get that function
1369:57 - selector. So we can say,
function, get selector and I'm
1370:01 - gonna say get selector one,
because I'm gonna show you a few
1370:03 - ways to get the function
selector, we'll make this a
1370:05 - public pure. And we'll have this
return a bytes for selector, we
1370:11 - could say select or equals bytes
for, and then we hash with a
1370:17 - check to 56 of the bytes of that
signature, which is transfer.
1370:25 - And it takes an address and a
UNT 56. Right? If we compile
1370:31 - this, and then we run it, let's
get rid of our old contract,
1370:34 - deploy, make sure we're on call
anything, if you have the other
1370:37 - one up. In here, now we have a
couple of things, we hit Get
1370:41 - selector one, we get this Oh X,
a 905, blah, blah, blah, right.
1370:47 - And that's the same as the
example I just gave. So this
1370:49 - right here tells solidity tells
our smart contract, okay, when
1370:53 - we make a call to this contract,
if you see this in the function
1370:57 - data, this is referring to our
transfer function with an
1371:01 - address and a un 256 as input
parameter. So we see address you
1371:05 - into 56. Our function knows to
execute this data here. Great.
1371:09 - And then of course, sml, and S
address are zeros. Now, while
1371:12 - we're here, we can also see,
okay, what happens if we call
1371:15 - the transfer function, right? It
takes an address and an amount,
1371:18 - so let's just give it its own
address or an address. And we'll
1371:21 - do 777 for an amount. If we hit
transfer, we have the log up,
1371:25 - right, we'll get a little
checkmark here saying success.
1371:28 - Now, if we hit S amount, we'll
get 777. And then the address
1371:32 - will be the same, right? So
that's us directly calling
1371:34 - transfer. When we directly call
transfer, we're basically
1371:38 - saying, hey, grab this function
selector, and then do some other
1371:41 - stuff, which we'll we'll tell
you the other stuff in a minute.
1371:43 - Now we have the function
selector. Okay, great. What else
1371:46 - do we need, we also now need the
parameters we want to add. So
1371:49 - we're going to need to encode
those parameters with our
1371:54 - function selector. So what we're
gonna do is we're gonna say
1371:56 - function, get data to call
transfer. And in here, we're
1372:03 - just going to have this get data
to call transfer, we're going to
1372:05 - have it take these input
parameters, and we're going to
1372:07 - encode these to work with our
function selector, we're gonna
1372:11 - say address, some address. And
if it is x, amount, public pure
1372:18 - returns, bytes memory.
1372:22 - And then we can return and use
one of those ABI and codings
1372:26 - from the cheat sheet. Now, so
far, we've just been doing API
1372:29 - and code for a lot of our
encoding. So it since we have
1372:32 - the function selector, we can
actually do ABI dot encode with
1372:37 - selector. This ABI encodes the
given arguments starting from
1372:40 - the second and prepends, the
given four byte selector. When
1372:43 - we do in Cobra selector, we're
just sticking our selector onto
1372:47 - the data that we're going to
give it. So we're going to do
1372:49 - return API dot encode with
select door. And we're going to
1372:56 - pass it the result of get
selector one, and then we're
1373:00 - going to give it some address,
and amount. So what this is
1373:05 - going to do, it's gonna give us
all the data that we need to put
1373:08 - in that data field of our
transaction, to send to this
1373:11 - contract to let this contract
know, hey, go use the transfer
1373:15 - function, pass in some address,
and then an amount. And then if
1373:18 - we compile this, we run it,
let's delete our old contract,
1373:22 - we'll deploy up, we now got a
new function called Get Data to
1373:25 - call and transfer, we'll just
pass you know, we'll just pass
1373:29 - this contract address and then
we'll also do 777 again. And so
1373:34 - this thing right here is what
we're going to put into the data
1373:37 - field of our transaction in
order for us to call transfer
1373:41 - from anywhere. So this is the
bytes This is the binary encoded
1373:45 - data of Hey, call the transfer
function with this address that
1373:50 - we specified. with, you know,
777 Mt. So what we can do once
1373:54 - we have all this, we can
actually call our transfer
1373:57 - function without even having to
directly call it. So what we can
1374:01 - do is we can say function, call
transfer function directly, or I
1374:07 - guess with binary might be a
better title, but you get the
1374:11 - gist, we'll say address some
address, you in 256 amount,
1374:16 - we'll make this a public
function. And we'll have a
1374:18 - returns a bytes four and a bool.
You'll see why in a minute. And
1374:23 - we'll do that same call thing
that we did to send our raffle
1374:27 - money. So what we'll do is,
before we did recent winner dot
1374:31 - call, right, we're going to do
some address. And then for us,
1374:34 - we're going to address this dot
call. And then we're saying this
1374:38 - contracts address which we could
put any address here address dot
1374:41 - call, and we're going to call
the encoded data that points us
1374:46 - to the transfer function with
some parameters. So we're going
1374:50 - to do address this.com. And we
could just do get data to call
1374:54 - transfer
1374:56 - address amounts, right, we could
do it like this. Or we could do
1375:01 - it kind of the wrong way. We
could do ABI dot and code with
1375:04 - select dorm, get selector one,
comma, some address, comma
1375:10 - amount. And actually, there's no
semicolon there, sorry. So those
1375:14 - are going to be the same. And
this dot call thing, right, it's
1375:18 - going to return exactly what we
saw before, it's going to return
1375:21 - a bool success. So whether or
not the transaction was
1375:23 - successful, and then bytes,
memory, returned data, which is
1375:29 - going to be you know, whatever
the call returns. So right, and
1375:32 - this is where we put like
require success, right. But for
1375:35 - us, we're just going to return
bytes, four bytes for a return
1375:40 - datum, and then success. So
we're just going to return the
1375:43 - first four bytes of whatever
data we get returned. And then
1375:47 - we're going to return whether
this was successful or not. So
1375:49 - this function is going to have
us directly call the transfer
1375:54 - function by passing these
parameters without us having to
1375:57 - do like contract dot transfer,
or, or transfer whatever, right.
1376:01 - And you can do this across
multiple contracts across
1376:04 - different contracts, just by
changing the address that you
1376:07 - call on. So let's go ahead and
compile this. We'll run this now
1376:10 - we'll delete our old contract,
we'll deploy call anything. Now
1376:13 - if we if we were. So right now
sml, and estimators are both
1376:17 - zero. Now, if we do call
transfer function directly, and
1376:21 - we'll pass in this one's
address, and then we'll do 777.
1376:26 - Now, if we pull up the logs, we
hit this, we're gonna get this
1376:31 - transaction response here. But
if we scroll down, we'll ever
1376:35 - see the decoded output, which is
a bytes for of just a bunch of
1376:38 - zeros, right? Because our
transfer doesn't actually return
1376:41 - anything. So it's just gonna be
a whole bunch of zeros, and then
1376:44 - our Boolean true, which means it
was successful. So since it was
1376:47 - successful, these two should
have changed based off of that.
1376:51 - So let's go ahead and try them
out. And we do indeed see that
1376:54 - they're changed. So we have just
directly called this transfer
1376:58 - function without having to call
the transfer function itself, we
1377:01 - can also do encode with
signature instead of selector.
1377:05 - So if we go to our cheat sheet,
there's also this encode with
1377:08 - signature down here, which takes
the string memory signature, and
1377:12 - it's equivalent to doing ABI dot
encode with selector bytes for
1377:15 - CAC bytes, you know, signature,
it's, it's equivalent to doing
1377:18 - exactly what we did up here. But
it does this step for us. So we
1377:23 - could copy this whole thing,
paste it down here, right, and
1377:26 - we could do, instead of encoded
with selector, we can do encode
1377:30 - with SIG netshare, the function
signature, and then we'll copy
1377:35 - our function signature from up
here, paste that in here.
1377:39 - Compile, we ran into a
compilation error, up, these are
1377:43 - the same call transfer function
directly SIG, called that
1377:48 - compile, leader, old contract,
deploy. Now these two are both
1377:53 - zeros again. Now if we copy the
contract address, we do call
1377:56 - contract call transfer function
directly SIG. We paste that in
1377:59 - here, we do 777, we call it, let
me check these we can see that
1378:03 - that does the exact same thing.
So this is API dot encode with
1378:07 - signature. This is abi dot
encode selector. Encode with
1378:10 - signature just turns us into the
selector for us. That's all up
1378:14 - here, we just, we encoded this
selector ourselves. Now, there
1378:17 - are a whole bunch of different
ways to get the selectors. And
1378:20 - we're not going to code these
out ourselves. I'm just gonna
1378:22 - say a bunch of different ways to
get selector. And who knows why
1378:29 - why you might want to use one of
these other reasons, right?
1378:31 - There's there's a ton of reasons
why you might want to get the
1378:34 - selector a different way. And
here's some now in this video,
1378:36 - we're not going to explain or go
over all these different all
1378:40 - these different function
selector getting methods. But if
1378:43 - you go through them in the
GitHub repo associated with this
1378:45 - course, they all have a ton of
comments to explain what they're
1378:48 - doing. Well, we are going to
show you though, it's actually
1378:50 - how to contracts can interact
with each other without actually
1378:53 - having all the code for each
contract. So we're going to make
1378:56 - a second contract that has all
this binary this byte
1379:00 - information to call the transfer
function on a different
1379:03 - contract. And we're gonna show
you how that can work. This is
1379:06 - just another contract that I've
made called call function
1379:09 - without contract. Actually, down
here, we're going to call the
1379:11 - transfer function, just by using
the address and the function
1379:15 - selector signature and stuff,
we're going to update these
1379:18 - storage variables in our call
anything contract from another
1379:22 - contract just by doing this
binary calling, if you will,
1379:26 - right, so let's compile, it's
going to deploy, we can actually
1379:29 - leave this up right, we can
leave this up is let's deploy
1379:32 - our call function without
contract, we'll pass it as an
1379:36 - input parameter, the call
anything contract address, we'll
1379:40 - deploy it. Now in here, I can
call the transfer function
1379:45 - directly by you know, maybe I'll
switch it to this, this contract
1379:50 - address this new contract
address, and we'll give it a new
1379:53 - number of 123. Right, and we'll
click call transfer function.
1379:57 - And then when we go back up
here, we see that this has
1379:59 - indeed been updated. Now doing
this call stuff is considered
1380:03 - low level. And it's a best
practice to try to avoid it when
1380:06 - you can. So if you can import an
interface, it's much better to
1380:09 - do it like that. Because you're
going to have the compiler on
1380:11 - your side, you're going to be
able to check to see if your
1380:13 - types are matching and all this
other stuff. So usually doing
1380:17 - these low level calls some
security auditor checkers might
1380:21 - say, hey, like this books been
out a little bit, you doing this
1380:24 - low level stuff.
1380:24 - But with that being said, You
have just learned a ton about
1380:28 - lower level solidity. This is
some really advanced stuff. And
1380:31 - like I said, if this was hard,
if you're kind of confused here,
1380:34 - don't worry, you can always come
back to this section and try it
1380:37 - again, when you're a little bit
more advanced, if you want to
1380:39 - try to understand it all now.
Awesome. Absolutely, we've left
1380:43 - some links in the GitHub repo
associated with this lesson that
1380:45 - I definitely recommend you check
out one of the ones you should
1380:48 - definitely check out, it's going
to be this deconstructing
1380:51 - solidity by openzeppelin, it
really breaks down exactly
1380:55 - what's going on behind the
scenes of a contract. If you
1380:57 - want to learn more about
opcodes, about low level stuff,
1380:59 - definitely give this a read, it
is a phenomenal read,
1381:02 - essentially, it breaks down a
little bit more than what we
1381:04 - went over here. A couple other
videos as well. And I've left a
1381:08 - whole bunch of links in here
1381:09 - too. With that being said, here
we are back in our NFT. And now
1381:19 - we know all about this ABI dot
encoding stuff, right and what
1381:22 - it does, and we know that ABI
dot encode packed, the way we're
1381:25 - using here is just a way to
concatenate strings. And we're
1381:27 - not using ABI dot encode for
really any of its crazy
1381:30 - superpowers, but we might in the
later section of this course. In
1381:33 - other case, so we do use this
base 64 dot encode thing that
1381:37 - we've imported, right, we
imported this base 64 dot encode
1381:41 - so that we can encode our SVG
that we pass it in to its base
1381:46 - 64 encoding. I'm going to copy
paste an example here, you don't
1381:48 - have to do this. But like, for
example, we'll pass it in like
1381:51 - SVG width equals blah, blah,
blah, all this SVG stuff, kind
1381:55 - of similar to what I was showing
you before, we pass that in as
1381:59 - an input parameter here, and
output it, we're gonna get the
1382:02 - base 64 encoding of it, we're
gonna get this massive kind of
1382:05 - string here. We will test this
later to make sure that this
1382:08 - works. Normally, if I added a
function in like this right now,
1382:12 - I probably would test it right
away. For now we can just leave
1382:14 - it in here. That's going to be
great for getting this image
1382:17 - here. But we don't want just an
image, right? We were going to
1382:21 - need that metadata. We need this
to be a JSON object, not just an
1382:25 - image URL like this, we need
stick this image, this base 64
1382:30 - encoded image into this image
field of our JSON. So how do we
1382:35 - actually do this? Well, what we
can do is we know that our ERC
1382:39 - 721 code comes with a token URI,
and it's that token URI that
1382:44 - points to this, which tells us
what our code is going to look
1382:48 - like. So what we can do is we
can actually base 64 encode our
1382:52 - JSON as well, to turn into a
JSON token URI. So we basically
1382:58 - four encoded this image to get
this, we're going to stick this
1383:01 - URL into our JSON. And then
we're going to base 64 encode
1383:05 - our JSON, and that's going to be
the URI that our token uses. So
1383:09 - we have our function, token URI,
right. And this takes a un 256
1383:14 - token ID, we'll say it's going
to be a public view, public view
1383:20 - override, and it returns a
string memory. So we're going to
1383:24 - override the token URI function
of the ERC 721 to whatever we
1383:29 - want it to be. And here we're
going to encode some JSON text
1383:33 - that we give our contract into a
base 64 based JSON token URI
1383:39 - just to get started we'll do a
require underscore exists. Token
1383:45 - ID, and then I'm just gonna say
your I query for non existent
1383:51 - token. And yeah, this price
should be an if not exists,
1383:56 - Revert with an error. However,
we're just going to go like
1383:59 - this. And this exists function
comes in my ear C 721. So we're
1384:05 - going to do same thing here. So
we're gonna say require this
1384:07 - token, a D exists. And again, we
can 100 percent. And probably should
1384:10 - make this an IF EXISTS token,
ID, you know, now what we want
1384:14 - to do is we want to figure out
how to make this token URI
1384:17 - return a base 64 encoded version
of this JSON. So first, we know
1384:23 - how to how to concatenate a
string, right, so that's gonna
1384:26 - be the first thing that we're
going to do. So we'll do API dot
1384:28 - and code packed. And we're going
to encode ourselves the JSON on
1384:33 - chain, we're going to use single
quotes here, because inside of
1384:36 - this API and code packed, we're
going to use double quotes in
1384:39 - here is where we're going to add
our JSON. So we'll give a name,
1384:43 - right, so the first piece of
metadata needs to be a name. So
1384:47 - we'll give it a name. And we'll
put a comma here. And we'll say
1384:52 - the name of this NF T is going
to be the name we get from, we
1384:57 - have a name function, which
returns the name. So we're gonna
1385:00 - say the name is going to be the
name. And we're gonna just
1385:02 - concatenate all this stuff, name
right there. We're gonna
1385:05 - continue on with the JSON. So we
put a little quote here, and a
1385:09 - little quote here. So we
encapsulate this name in quotes,
1385:13 - right? Because remember, we're,
we're concatenating, this big
1385:16 - string that we're making here,
we'll do a comma, we'll say,
1385:19 - description, we'll do another
quote. And this time, we're just
1385:23 - going to put the description
ourselves, and we'll say, and
1385:26 - NFT, that changes, based on the
chain link feed, we'll put an
1385:32 - end quote here and a comma, and
we'll put a comma outside the
1385:35 - quote, down here, we'll say,
attributes.
1385:42 - We'll just say, trait type, it's
going to be coolness. Comma,
1385:53 - value, me 100. Boom, to a comma
to image. We'll put a comma out
1386:01 - here. And this is where we're
going to put our image URI,
1386:05 - image URI, which we're going to
have to get from somewhere. So
1386:08 - for now, I'm just gonna say,
string.
1386:12 - Memory image URI equals i,
right, which clearly isn't an
1386:16 - image arrived. But just to make
this format and stuff, we'll
1386:18 - we'll put this there. This is
where we're going to put that
1386:21 - image URI that we get from SVG
to image URI. And then that's
1386:26 - it. I mean, close off our JSON,
though. So doing ABI dot encode
1386:31 - pack is going to concatenate
this all together. So this is
1386:34 - basically going to be a string
that looks like this. Great. But
1386:37 - how do we turn this into a base
64 encoded token you arrive so
1386:43 - that other people can read it is
we're going to typecast this
1386:45 - whole thing to bytes. And then
now that this whole thing is in
1386:48 - bytes, we can do exactly what we
did with the SVG above is now we
1386:52 - can base 64 encoded. So we'll do
base 64, dot ENCODE. And then
1386:57 - we'll just put another pair of
parentheses around this save and
1387:00 - auto formatted. And this here is
going to give us this second
1387:04 - line, right, it's going to give
us all of this bit, but it's not
1387:08 - going to give us this first bit,
right. So we just need to append
1387:11 - to this first bit now. And we
should be good to go. For basics
1387:14 - before data image SVG plus XML
basics, the form, this is the
1387:19 - prefix for images for SVG
images, right? We use that above
1387:24 - because that's the prefix for
SVG images. The prefix for base
1387:27 - 64. Jason is going to be it's
going to be data application
1387:32 - JSON base 64. So we're going to
do it like this instead. Now the
1387:36 - ERC 721 has something called a
base URI that we're going to
1387:40 - override and that we're going to
use. So we're gonna say function
1387:43 - underscore base URI. This will
be internal pure. And we're
1387:48 - going to override the one that
ERC 721 has. And this is going
1387:51 - to returns a string memory. And
we're just going to return this
1387:57 - bit right here. And now we can
use this base URI. to append,
1388:02 - right, we're going to append
this first part to our base 64
1388:06 - encoded JSON. So in order to
append them, once again, we'll
1388:11 - do ABI dot ENCODE, packed. And
then we'll put this down here.
1388:19 - And we'll say, we're going to,
we're going to concatenate base
1388:22 - URI to this massive thing that
we just created. And then we
1388:25 - save and we ought to format the
now this is obviously a bytes
1388:28 - object, and we want it to be a
string. So then all we got to do
1388:32 - is typecast it as a string, but
another prints see down here,
1388:36 - and then we can actually just
return this, but basically what
1388:39 - we're doing is we're creating a
JSON string, we encode it in
1388:44 - bytes, that way we can encode it
in base 64. Once we have encoded
1388:49 - in base 64, which is going to
look like this second string,
1388:53 - it's gonna look like here out,
we then just append this initial
1388:57 - part. But for JSON objects, it's
data application JSON. We we
1389:03 - append that we do API dot encode
packed, and then cast it to
1389:06 - string and then boom, we now
have a token URI. That'll look
1389:10 - something like this. And then
all we have to do is update our
1389:12 - image URI with what we get from
our function appear, and then
1389:16 - we'll be good to go. So let's
finish this out. Let's do this.
1389:25 - So in our constructor, we're
passing a low SVG and a high
1389:29 - SVG. And what are these low SVG
is in these high SVG as well,
1389:32 - basically saying, when the price
of this asset is too low, show a
1389:38 - frown. And when the price of the
asset is high, show a smiley
1389:42 - face. So we're gonna give it
this frown, SVG, and this happy
1389:46 - SVG as input parameters, low CG
and high SVG, we probably want
1389:50 - to save those. But we don't
necessarily want to save them in
1389:53 - like their SVG format. So we
just want to store the image
1389:57 - URI, right, we will just want to
store this string up here
1390:00 - instead of the actual SVG. So
right in our constructor, we can
1390:04 - do I underscore low image URI
equals, and we have this SVG to
1390:12 - image your eye function, where
we can pass the low SVG. And
1390:17 - then we can do the same thing
for the high image URI. So now,
1390:22 - SVG image URI is going to return
something that looks like this.
1390:26 - And we're going to store just
this string this image URI on
1390:30 - chain. Now that we have the two
of those, we can use that down
1390:34 - below. In our token, Uri
function, when somebody calls
1390:37 - token, your I have token ID
zero, we're going to stick into
1390:41 - our JSON, either the low image
or I or the high image arrive.
1390:46 - And we're actually going to base
that off of the channeling price
1390:48 - feed. So how do we do that?
Well,
1390:51 - we've already worked with
channeling price feeds before so
1390:53 - let's go ahead and add it. So
yarn add dash dash dev at chain
1390:56 - link slash contracts. Once
that's done at the top, we can
1391:00 - do import at chain link slash
contracts, slash SRC slash V
1391:07 - 0.8, slash interfaces, slash ag
reg gate, Tor V three interface,
1391:14 - that soul like so. And then down
here, let's comment this out.
1391:20 - For now, we're going to want to
call a price feed to figure out
1391:23 - what the price is and then show
the high image or the low image
1391:26 - based off that. So in order to
get a price feed in our
1391:28 - constructor, let's just add
another price feed address,
1391:31 - street address. And then we'll
make another variable. We'll do
1391:36 - aggregate Tor v3 interface.
Internal, immutable, I
1391:44 - underscore price feed. And we'll
say in our constructor, I price
1391:48 - feed equals aggregate Tor v3
interface at price feed,
1391:56 - address. And then what we can do
down here, the old bunch of
1392:00 - commas in here into 256 Price
comma, comma comma equals i
1392:05 - price feed that latest round
data. And what we can do is we
1392:12 - can say if price is greater than
or equal to some value, then
1392:19 - show one image dry otherwise,
show another one. So we can say
1392:22 - String memory, image URI equals
s underscore low image URI. And
1392:30 - then if the price is higher than
some value, well greater than
1392:32 - the image URI we're going to use
is going to be there's gonna be
1392:35 - AI is going to equal the high
image URI. And then we have
1392:40 - image right down here. So all we
got to do is figure out the
1392:43 - price. So we can make, and in
our mind, we'll let the mentors
1392:47 - choose the value that they want
to use. So we can say, into 256,
1392:54 - I value and we'll assign each
NFT, their own high value. So
1392:58 - we'll need to create like a
little mapping up top, we'll
1393:02 - say, mapping, you went to 56.
Two, you went to 56. Let's just
1393:09 - make this public for the heck of
it public s underscore token ID
1393:15 - to high value. And we'll say
that when they meant an NF T
1393:22 - will do s token ID to high
value, s underscore token
1393:26 - counter. We'll set that equal to
high value. So when they meant
1393:31 - they choose the high value that
they want. And then down here
1393:34 - we'll say if the price is
greater than or equal to the
1393:38 - high value of the token ID, then
we'll use the high one.
1393:42 - Otherwise, we'll just use the
low one. Oops, and this needs to
1393:44 - be you into videos x two into
256. Excuse me, since we want to
1393:49 - be able to compare them pretty
equally. And boom, our contract
1393:53 - looks really good. Now the only
thing we'd want to add in here
1393:56 - is probably an event. So we
probably want to emit an event
1393:59 - in time we met to one of these
NF T's. So we might do event
1394:05 - created NF T, will say you went
to 56 indexed token ID comma int
1394:11 - 256. I value like so. And then
when we met this NFT, will do
1394:19 - emit create n t, s underscore
token counter, comma, I value.
1394:25 - And then it's best practice to
to have to update our token
1394:29 - counter before we actually do
the minting. So we'll do that as
1394:31 - well. Okay, there's a ton of
code here. And like I said, we
1394:35 - definitely would not have
written all that code without
1394:38 - having compiled to run some
tests first, but we decided we
1394:41 - want to just write it all right
off first. So and I did some
1394:45 - misspellings. Let's just make
sure everything compiles here.
1394:48 - Awesome. Everything's compiled
here. As you already know, a
1394:50 - couple things that we're going
to need to do to test this out.
1394:53 - First thing we're gonna need to
do is write our deploy function,
1394:56 - we've got our basic NFT, we've
got our random and f t, both of
1395:01 - these hosted on IPFS. Now we're
going to do a dynamic NFT that's
1395:06 - hosted 100 percent on chain, and it
changes based off the price of
1395:11 - an asset. So let's do this. Oh,
three, deploy dynamic, SVG
1395:25 - nft.js. We are no, we're gonna
need a little bit of
1395:28 - boilerplate. So let's go to our
basic NFT. And we'll just grab
1395:32 - all this the first seven lines
or so. And we'll just paste it
1395:36 - in here. What do we need for our
constructor? Well, we
1395:39 - need a price feed address, a low
SVG and a highest CG. Okay, so
1395:44 - let's get all of those. So price
feed address is something we've
1395:47 - already done before. And we can
add that into our helper
1395:50 - Hardhead config. And we'll do
one and a foreign local, we're
1395:54 - going to use what we're going to
use a mock. And if we're on
1395:57 - Rinkeby, or an actual network,
we're going to use an actual
1395:59 - address. So let's go ahead to
dark side chain that link will
1396:03 - grab a price feed address, the M
Aetherium. data feeds will go to
1396:08 - rank B, rank B and let's just
use eath USD copy that will make
1396:14 - a new entry eath USD price feed
like so. And for localhost,
1396:21 - we're good. So since we know for
localhost, we're going to need
1396:23 - to do a mock. Let's see if we
have a price feed mock. Okay,
1396:27 - now we don't, we're gonna need a
mock v3 aggregator dot soul. I
1396:31 - just copied pasted mine. If you
want, you can just go right to
1396:34 - the to a repo here. Or you can
copy from a previous section,
1396:38 - just a reminder heart at f and f
t FCC contracts asked moc v3
1396:43 - aggregator and this is using
point 06 of solidity. So we're
1396:48 - going to want to make sure that
in our hard hat dot config, we
1396:51 - have at least one 0.6 version,
which we do so we're good there.
1396:55 - That means in our deploy mocks,
we're going to want to add So
1397:18 - initial price will be 2000
decimals will be a team. So now
1397:21 - we've waited to deploy mocks for
that price feed. So we're gonna
1397:24 - say const chain ID equals
network dot config dot chain Id
1397:30 - do if development chains dot
includes network dot name, and
1397:36 - the more we need to import
development chains looks like
1397:38 - where did say const eth USD
akregator equals we'll get that
1397:45 - price feed equals awaits ethers
dot get contract Mark v3 Air
1397:52 - gate tour, and then we'll up
here we'll do let eath USD price
1397:57 - feed address eath USD price feed
address equals eath USD
1398:03 - aggregate tore that address else
will say the eath USD price feed
1398:08 - address is going to be equal to
what we find in the network
1398:11 - config. Network config. Chain ID
dot eth USD price. Okay, so we
1398:19 - have the eth USD price feed
rate. Now we need the lowest VG
1398:24 - and the high SVG. So we're going
to create a new folder in our
1398:28 - images folder. So we go CD
images, MK dir dynamic NF t. And
1398:35 - now we'll have two folders in
here dynamic which is empty and
1398:38 - random, which has all the random
stuff. If you want to use your
1398:41 - own SVGs for this, you
absolutely can. But if you want
1398:44 - to just come to my images file
and then save these images as so
1398:48 - just come right click Save image
as. Save them. and then drag and
1398:52 - drop them into your images files
here, you can absolutely do
1398:54 - that. So now that we have those,
we want to go ahead and read
1399:00 - those into our script here.
We'll say const, low SVG equals
1399:05 - a weight. And we're going to use
Fs again. So we're gonna do
1399:10 - const Fs equals require Fs, or
do await Fs dot read file sync,
1399:18 - we're going to read in this
file, which for me, it's at dot
1399:22 - slash images slash dynamic NF T
slash brown dot SVG. And we're
1399:29 - using encoding of UTF eight. And
then we'll say const. Hi, SVG
1399:35 - equals await Fs dot read file
sync. Copy this whole thing,
1399:41 - because we're using the same
stuff. This one's going to be
1399:44 - happy about SVG. And that's it.
So when price is good, we're
1399:49 - gonna do happiness, SVG, when
price is bad, we're gonna do
1399:52 - frown at SVG. Now, let's go
ahead and let's deploy this
1399:54 - contract. So we'll say arguments
or args equals, it's gonna be
1399:59 - the price feed address, low SVG,
and then high SVG. And we'll say
1400:05 - const, dynamic S, G and F T
equals await, deploy dynamic SVG
1400:14 - and f t, comma little bracket
here, from Deployer.
1400:21 - args, args log true. And the
weights confirmations, it's
1400:29 - going to be network dot config,
that block confirmations, or one
1400:38 - will do some logging, I will do
log to do that. But Larry, do
1400:45 - some verification, I'm actually
just going to copy paste that
1400:48 - from our last script, because
it's going to be exactly the
1400:50 - same copy paste. But instead of
random IPFS, it's going to be
1400:55 - dynamic SVG and f t. The rest of
this looks good. And that's just
1400:59 - about it. So we'll do module,
exports dot tags, equals and
1401:06 - we'll do all dynamic. SVG. And
we'll do main. Oh, okay. Let's
1401:14 - try to see if our deploy script
that we just created works. To
1401:19 - do h h, or yarn hardhat deployed
dash dash tags, die Namic SVG,
1401:26 - that makes sense, because we
didn't deploy the mocks. So
1401:28 - we'll do tags, dynamic SVGs. And
then also the mocks. Local
1401:33 - network detected play marks, we
deploy the marks, deploying
1401:36 - dynamic SVG, awesome. You know
what comes next? You Gosh, darn
1401:45 - right, it's time for some tests.
Now, once again, I'm going to
1401:50 - encourage you to pause the video
now and try to write your own
1401:53 - test for this test for this
section actually can be a little
1401:57 - bit tricky. Since we are going
to be manipulating the price of
1402:00 - our mock aggregator, we are
checking for these long strings,
1402:04 - and such. So be sure to use the
GitHub repository associated
1402:08 - with this lesson, in case you
get lost. Now, I want to show
1402:11 - you what this looks like on a
marketplace, like OpenCL. So we
1402:18 - are going to deploy this to rink
B. Now keep in mind test that
1402:22 - can be slow. So you might want
to be patient here. And you
1402:24 - don't even have to do it if you
don't want to. But it is kind of
1402:27 - nice to see. Okay, that's what
it really looks like. And you
1402:30 - can go to the contract on chain
once it's verified. And you can
1402:33 - read the token URI and
everything. And it's pretty fun.
1402:35 - So let's just add one more bit
to our deploy folder. Let's add
1402:40 - a mint script that just emits an
NF T for each one of these
1402:43 - contracts. So we're going to
create no for mint.js. And we're
1402:47 - just going to have each one of
these contracts mint NFT. Let's
1402:52 - go ahead and do this. So in
here, we'll do const ethers
1402:57 - network equals require arhat.
And then I'm going to do a
1403:03 - little copy paste in. I'm just
going to copy this part because
1403:06 - I know I'm going to need that.
We are going to need a deploy
1403:10 - but we're not going to need to
deploy. So I'll grab get named
1403:13 - accounts, get named accounts,
it's going to come right from
1403:16 - there. So we have a Deployer.
Our deployer is just gonna be
1403:19 - used to mint them. First we'll
mint the basic NF t. So we'll
1403:22 - say const basic NF t equals wait
ethers dot get contract, basic N
1403:29 - ft, and we'll connect the
deployer to it. And then we'll
1403:32 - say const basic mint and if T or
basic mint, TX equals await
1403:38 - basic NF T dot mint NF t. And
then we'll do a weight basic
1403:45 - mint, TX dot weight one and then
we'll do a little console dot
1403:50 - log base Again, T index zero has
token URI, we'll put in a little
1403:57 - await basic NF T dot token URI
of zero. That's it for the basic
1404:02 - entity. Now we'll do our random
IPFS and empty. So we'll say
1404:09 - const, random IPFS NF t equals
await ethers dot get contract,
1404:16 - random IPFS and f t, connected
to the Deployer. This one, we
1404:22 - need a mint fee. So we'll say
const, mint V equals await
1404:26 - random IPFS NF T dot get mint
fee. And then we'll do the mint.
1404:31 - So we'll say const, random IPFS
and ft mint, TX equals await,
1404:38 - random IPFS and F T dot request
and F team. And for this one, we
1404:44 - need to pass a value, which is
going to be the mint v.to
1404:47 - string. Now for this one, just
like what we saw in our tests,
1404:53 - we're going to have to do this
await new promise again, right,
1404:57 - because we need to wait for it
to return need to listen for
1405:01 - those events, we probably should
set up the listener first. So
1405:04 - let's actually set up the
listener first. So we're going
1405:06 - to do await new promise, and
we're gonna do async function.
1405:11 - And we're going to do resolve
reject. In here, we're gonna use
1405:16 - that, that fun little arrow
syntax in here.
1405:19 - And now since we're in this
function here, we actually set
1405:21 - the timeout resolve like this,
which means we have five minutes
1405:27 - to time this out, you might want
to bump this up even more five
1405:30 - minutes might not be enough,
this is gonna be 300
1405:33 - milliseconds here, we're gonna
do that once again. So we'll say
1405:36 - random IPFS and ft dot once.
Once we get that NFT minted
1405:41 - event, we're going to run an
async function, we're just gonna
1405:45 - do resolve. And inside here is
where we can actually put,
1405:50 - actually requesting the NFT. But
below our listener, right, so in
1405:56 - there, and then we can say if
developments chains, that
1406:02 - includes network dot name. So
let's just make sure we import
1406:07 - those development chains and
network or affect them and
1406:11 - chains that includes network dot
name. So we're on a test net,
1406:14 - this is where we go ahead and we
pretend to be those mocks. So
1406:17 - we'll say const Request ID
equals random IPFS. Oh,
1406:21 - actually, we're going to need to
do const random IPFS and ft min
1406:27 - TX receipt equals await on IPFS
and empty minted TX dot weight
1406:32 - one. So we're gonna need to get
the receipt. And from the
1406:36 - receipt, we can get the request
ID. That events one dot args dot
1406:41 - request id.to string. And then
we can do const VRF. coordinator
1406:49 - V to mock equals await ethers
dot get contract, the RF
1406:56 - coordinate for V to mock,
connect this to the Deployer.
1407:00 - And then we'll do a wait the RF
corded and a Tor V to mock that
1407:06 - fulfill random words with
Request ID, random IPFS. And if
1407:12 - T dot address, we can do console
dot log random IPFS and have T
1407:20 - index zero token URI to await
random IP. That's NF T dot token
1407:29 - URI of zero. Finally, we can do
our dynamic SVG, NF t. So we can
1407:37 - say const, high high value
equals ethers.utils.do parse
1407:43 - ether here. So we'll say
4000 $4,000 will be the high
1407:48 - value. We'll say const. Dynamic
SVG and f t equals await ethers
1407:55 - dot get contract, dynamic. SVG
and a T will connect it to the
1408:00 - deployer say const by Namic, s,
B, G, and f t mint, TX equals
1408:09 - await dynamic SVG and F T dot
mint and f t i value to string
1408:17 - then we'll just do wait. This
stat wait one. And finally
1408:24 - console dot log dynamic. SVG NFT
index zero token URI is going to
1408:33 - be a weight dynamic. SVG and ft
dot token URI of zero. Okay, I
1408:42 - think that looks good. Let's try
this on a local network. So
1408:44 - we'll do yarn hard hat deploy.
And we'll run all those scripts
1408:51 - It looks like everything worked.
So we have random, basic NFT
1408:55 - index zero has a token year, I
have this IPFS thing, random
1409:00 - IPFS NFT. index zero has this
thing. And then our SVG has this
1409:04 - giant monstrosity, okay,
perfect. And then we can even
1409:07 - check, right, we can even grab
this IPFS hash, we go to our
1409:12 - IPFS node, or if you installed
IPFS in your browser, or you're
1409:16 - working with Brave, we can just
pop it right into our browsers
1409:18 - and see what it looks like.
Right. And then if I zoom in,
1409:21 - and adorable St. Bernard, with
the image of the St. Bernard,
1409:25 - looking like that, this one's
also gonna be St. Bernard. And
1409:27 - then of course, are SVG, which
we can also copy, paste, and
1409:31 - boom, that looks great. And then
we can copy the image. And it's
1409:35 - a frowny face or shad. But
Awesome. Okay, so it's working
1409:39 - locally for us. Now, let's go
ahead and try to make this work
1409:43 - on an actual test net. So
hopefully, our helper hard hat
1409:47 - config is set up correctly. And
there's enough stuff in here
1409:50 - where we need to make sure that
we have a subscription ID,
1409:54 - right, we're going to need to
make sure we have a subscription
1409:56 - ID. And we shouldn't call the
mint function, right, because
1410:00 - we're going to need to add our
consumer to the VRF. Before we
1410:03 - can actually meant so let me
let's add some tags to our meant
1410:07 - here. So we'll do module dot
exports, dot tags equals, and
1410:11 - we'll say all comma meant a
while ago, I said okay, let's
1410:17 - add a main tag. Now we're coming
around to why we added this main
1410:22 - tag here. So what we want to do
is want to deploy all of these
1410:25 - contracts. But before we finally
meant for our IPFS one, we need
1410:31 - to add that contract to our
consumer, here's what we're
1410:34 - gonna do, we're gonna run yarn,
Hardhead, deploy dash dash
1410:38 - network Rinkeby dash dash tags
main. Now, this won't meant any
1410:45 - of our NF T's, okay, won't mean
to any of our NF T's, it'll just
1410:48 - deploy those contracts might
just sit around and wait a
1410:51 - little bit for these to actually
deploy. So this is a great time
1410:54 - to go take a break, maybe go
take a walk, get a sip of water,
1410:56 - get a cup of coffee, whatever
you want to do. Yeah, once
1410:59 - everything is deployed, then we
can go to V or F dot chain dot
1411:02 - link, we're already connected
here, we used our subscription.
1411:06 - And then we would just add our
IPFS consumer in here. And we'd
1411:11 - be good to go. And All right,
once everything goes through,
1411:13 - and we have all three of our
transactions on the blockchain,
1411:17 - we can go ahead, we can grab our
random IPFS NF T, we'll grab
1411:21 - that address, we'll come back
over to V or F dot chain dot
1411:24 - link slash rink D, we'll go to
our subscription ID, and we'll
1411:30 - add a new consumer will add that
contract address. So we'll go
1411:35 - ahead and approve and Metamask.
And once this goes through, we
1411:38 - can finish running the mint part
of our deploy folder. Once it's
1411:42 - confirmed, we can close maybe we
can do a little refresh, we
1411:46 - should see our new address added
as a subscription here. Now that
1411:49 - we've added that we can mint one
NF T from each one of these
1411:52 - contracts are in hard hats,
deploy dash dash tags meant dash
1411:58 - dash network Rinkeby. And we'll
have to wait a little bit for
1412:02 - this too. Okay, now that we have
them all minted, we should get a
1412:06 - little output like this. Right?
Basic NF t zero has token URI
1412:10 - here. Basic random IPFS NF T has
token your eye here. And then
1412:15 - our SVG has this as a token
year, right. So what can we do
1412:19 - now? Well, let me go grab, I'll
grab my wallet address and stick
1412:24 - it into Rinkeby ether scan. And
we can see we called mint
1412:28 - request and mint again. And we
created three contracts, right,
1412:33 - we created our basic NFT, our
random IPFS NFT and our dynamic
1412:37 - SVG NFT. What we can do now is
we can grab, we can copy the
1412:42 - address of our contract. And we
can go to test nets that open
1412:46 - see that i Oh,
1412:49 - and we can put that address in
the bar here in the search bar
1412:53 - here. Now this part is
incredibly, incredibly variable.
1412:57 - Okay, open C can be really slow.
And it can take open see up to a
1413:01 - couple of hours to register that
a contract has been deployed to
1413:05 - a test net. So if it doesn't
show up right away, don't be
1413:08 - discouraged. Don't let it drag
you down. But if it does, you
1413:11 - should be able to click on your
collection and see the NFT is
1413:15 - actually here. I'm going to grab
our random IPFS NFT. Let's grab
1413:19 - that contract address. I'm going
to grab that test net site open
1413:23 - c.io. Paste that address in
there. And what do you know we
1413:27 - do indeed see, random IPFS and f
t, right and I've deployed a
1413:32 - couple of them. So this one's v
two, and we have our adorable
1413:35 - Shiva in you right here. So this
is what it looks like an open C
1413:38 - now we can 100 percent verify that our
code is good even if it doesn't
1413:43 - show up on Open. See. If we go
to the contract we go to read
1413:46 - contract. And then we go to
token URI punch and zero here. A
1413:51 - query, grabbed this, stick it
into our browsers, the JSON
1413:56 - looks good. So let's grab the
image URI. Paste that in. And if
1414:00 - we can see this here, that means
that our code is good. And you
1414:04 - have successfully deployed a
number of FFTs to the
1414:08 - blockchain. We have learned a
massive amount in this course,
1414:15 - this is definitely one of the
most jam packed one. And it's
1414:17 - all about art. Right? Isn't that
crazy? Let's do a quick
1414:20 - refresher of this entire course
here. So first off, we learned
1414:25 - the basics of an NF T with our
basic NF T dot Sol, we learn
1414:29 - that these NF T's are based off
of the ERC 721 standard. And
1414:33 - that just means they have
functions like name, token, Uri,
1414:37 - etc. We learned that NF T's use
this token URI to tell us what
1414:43 - the token actually looks like a
token, your eye will look
1414:45 - something like this, it's going
to be a name a description, it's
1414:49 - going to have an image URL,
which points to a different
1414:52 - location for what the NFT
actually looks like. It'll have
1414:56 - stuff like attributes, it can
have stuff like attributes, and
1414:59 - a few other tags. This is known
as the metadata of the NFT. And
1415:03 - this tells us about the NFT. We
can also have all that metadata
1415:07 - on chain, of course, to
customize it on chain, and make
1415:10 - it look and grow and change and
be interactive on chain, we
1415:14 - learned more about IPFS, we
actually wrote a script called
1415:17 - upload to pinjarra.js, where we
can actually programmatically
1415:21 - upload images and files to
another IPFS pinning service for
1415:26 - us, we can of course, always use
our own IPFS nodes if we want.
1415:31 - Now this token URI can really be
anything. And we hosted it on
1415:35 - IPFS for our basic NFT and for
our random NFT. But for our
1415:40 - dynamic NFT, we actually hosted
the token, you're right 100 percent On
1415:45 - chain, so we didn't use IPFS.
And we made this dynamic where
1415:49 - the token URI actually changes
based off of the price of a
1415:54 - changeling price feed in our
random IPFS NFT, we gave our NFT
1415:59 - a chance we gave different
rarities to the different dogs
1416:03 - so that we could create
programmatically rare NF TS
1416:06 - where our pug is super rare. Our
Shiva is sort of rare, and our
1416:10 - St. Bernard is pretty common. So
the fact that we got to ship it
1416:13 - in you was awesome. We did some
amazing deployments, we wrote
1416:16 - some tests. Not only that, but
we learned a lot about
1416:19 - transactions, and how we can
actually add whatever data we
1416:23 - want to this data section. And a
little bit more about what our
1416:26 - transactions look like, and how
we can actually use functions,
1416:29 - selectors and function
signatures to be able to call
1416:33 - anything, right and we learn
more about ABI dot encoding, and
1416:37 - encoding packed and all this
binary stuff if you want it to
1416:39 - go deep into that. So this was
an absolutely JAM PACKED
1416:42 - session. And you should be
incredibly proud of yourself,
1416:45 - especially with your little
puppy that you can see on open
1416:48 - sea or you can see directly on
ether scan, or you can just look
1416:51 - at it and IPFS and be really
proud of what you've done. But
1416:55 - with that being said, huge
congratulations on making this
1416:58 - far. Definitely definitely
definitely take a break here,
1417:01 - and we'll see you in the next
one.
1417:12 - Okay, now we have less than
fifth team, which is going to be
1417:16 - our next JS NFT marketplace. And
if you finish this lesson, you
1417:21 - are a web three full stack
monster, this is going to be our
1417:25 - most complicated front end using
the web three stack and using a
1417:30 - lot of really advanced web
three, and blockchain tools. So
1417:33 - get really excited because we
are going to learn a ton in this
1417:37 - lesson. Now there are actually
three different repos associated
1417:40 - with this lesson. The first one
is going to be our typical hard
1417:43 - hat project. For the back end,
after the hard hat project, we
1417:46 - actually have two repos both are
going to be our front end repos,
1417:50 - and they're going to be slightly
different. In this project,
1417:53 - we're going to learn more about
how events are so important and
1417:56 - why events are so important,
especially for off chain
1417:59 - services. And so we're actually
going to look at two different
1418:01 - ways to work with them, one
using the mirallas, or a
1418:04 - centralized database, and then
one using the graph. And the
1418:07 - reason that I want to show both
of these is that oftentimes,
1418:10 - when people are looking to scale
the projects, when people are
1418:12 - looking to get things done
really quickly, taking a more
1418:16 - centralized approach can often
be a little quicker, and you can
1418:19 - sometimes add more functionality
to your website. And there's
1418:22 - still a lot of protocols that
have decentralized backends. And
1418:24 - centralized front ends. One such
example, is open sea, open sea,
1418:29 - for example, has the ability to
actually like different and fts.
1418:33 - Now, this isn't something that
we would actually want to spend
1418:36 - any gas on. But it is something
that we're gonna have to store
1418:38 - in some type of database
somewhere, so that people have
1418:41 - the ability to do that. So I
want to show you this optional
1418:44 - first way to build these front
ends, since all of our logic is
1418:47 - still going to be 100 percent. On
chain, the front end matters a
1418:50 - little bit less, because anybody
can still interact with the
1418:53 - contracts that we build on
chain. Now in web three, we
1418:56 - don't want to stay there.
However, getting an MVP done
1418:59 - getting a minimal viable project
done is really, really
1419:02 - important. So using a
centralized server, like
1419:04 - Morales, or centralized project
can make us much quicker. In
1419:07 - fact, we have been using
centralized services, like
1419:10 - alchemy, kind of throughout this
whole project. But of course, I
1419:13 - also want to show you the
decentralized way to make your
1419:16 - front end. So after we work with
Morales, we're also going to
1419:18 - show you how to use the graph
then for to do all this event
1419:21 - indexing. Now the graph is going
to be the decentralized way we
1419:25 - can make our front end and work
with these events. And the graph
1419:28 - also comes with its own graph
repo. So we'll learn all about
1419:31 - that once we get to the front
end section. But let me show you
1419:34 - what we're going to build
because it is really cool. Now
1419:37 - that we've learned a ton about
how to make NF T's what they
1419:39 - are, we're going to make our own
NFT marketplace. And like I
1419:42 - said, this is really going to be
our deep dive into all these
1419:45 - amazing front end tools. So
here's what our front end is
1419:48 - gonna look like. But what we can
do is we can connect with our
1419:51 - little connect button, we hit
Metamask Metamask pops up, we'll
1419:55 - go ahead and connect. And now
that we're connected, we can see
1419:58 - the different entities in here.
And if we're on an address
1420:01 - that's owned by us, it will say
owned by you. And if we switch
1420:05 - addresses, or UI will go ahead
and update, connect there. And
1420:10 - now we're owned by a different
address. Now, if it's owned by
1420:13 - us, we get this little hover
that says Update listing. And
1420:15 - right now it's worth 0.18.
That's what it's listed for on
1420:19 - our marketplace. If it's owned
by us, and we click it, we can
1420:22 - update it to a different price.
Let's update it to 50 eath, or
1420:26 - whatever your layer one currency
is, we'll just say new listing
1420:29 - price, we'll go ahead and
confirm. And I'll say listing
1420:33 - updated, please refresh, and
what we can do them. And we'll
1420:36 - mine some blocks on the back
end, and boom, now we see that
1420:40 - it's worth 50 here. Now if we
switch to a different account,
1420:44 - now we can see owned by blah,
blah, blah, and the hovered now
1420:46 - says by me, if his selected as a
different user, I'm gonna get
1420:51 - this transaction to actually buy
it. Now go ahead and confirm
1420:55 - that I'm gonna buy it, I get a
little pop up. This is item
1420:57 - bought successfully. Now if I do
a little refresh, we'll now see
1421:00 - that that NFT is gone from the
marketplace, since we bought it
1421:04 - right, it's no longer available
to be sold. Now what we can do
1421:07 - then is we can come over to sell
NF Ts and at the bottom, we'll
1421:12 - see a withdraw proceeds. So
whenever somebody buys an NF T,
1421:17 - the NFT marketplace actually
keeps the proceeds that actually
1421:20 - keeps the result of the sale. So
if we switch back to our address
1421:24 - that had the NF T listed, we can
now see Withdraw 50 proceeds
1421:28 - because we know that we have 50
eath, because we just bought
1421:30 - that for 50. So if we hit
withdraw, Metamask is gonna pop
1421:35 - up, we can go ahead and confirm,
wait a little bit as transaction
1421:39 - populates, and boom once it goes
through, we'll see now we have
1421:43 - zero proceeds. Right, we
withdrew everything from here.
1421:46 - So what we can do now, is we can
relist that NFT. So if we come
1421:50 - back, let's go back to the one
who just bought that NF t. If we
1421:55 - know the address and the token
ID of the NF t and we own it, we
1421:58 - can go ahead and relist it,
because we can place the address
1422:00 - in here with the token ID Give
us some sort of price, we'll
1422:05 - submit, we'll approve giving the
NFT marketplace access to our
1422:11 - NFT to our little doggie. And
then we'll go ahead and actually
1422:15 - send the transaction to actually
list the NFT on a marketplace
1422:20 - that we get NFT listed
successfully. After we remove
1422:24 - some blocks in the back end, we
can go back to the front end.
1422:27 - And we now see, it's owned by
us, instead of the original
1422:31 - owner, right and set for 10
ether. And then we can of
1422:35 - course, switch back to a
different user, and we can have
1422:38 - them actually buy. So this is
going to be a NFT marketplace
1422:42 - that's completely decentralized,
we are going to learn a ton
1422:45 - about front end a ton about
indexing a ton about events, and
1422:49 - why they are so powerful. And
I'm really excited for you for
1422:53 - this one. Because if you get
through this one, you will have
1422:55 - so many tools at your fingertips
for working with the blockchain.
1423:01 - Are you ready, let's jump in.
Let's build the contracts first,
1423:05 - and then we'll build the front
end. Let's do this. Now this
1423:07 - project is going to be based off
the Arteon project, which is a
1423:11 - completely open source
decentralized smart contract NFT
1423:15 - marketplace, I'll leave a link
to it in the GitHub repo
1423:18 - associated with this course,
ours of course, is going to be a
1423:21 - minimalistic version of this.
1423:28 - So we're in our VS code pre
normal. And we're going to
1423:30 - create a new folder here called
hard hat. And if T marketplace,
1423:37 - FCC, oops, MK dir, like them,
we're gonna cd into it. And then
1423:43 - open this up and its own VS
code. Once again, you can use
1423:47 - code period, or file open
folder, and open this folder.
1423:52 - Once we get in here, we're going
to do all of our normal stuff
1423:53 - that we've been doing throughout
the course. And once again, if
1423:56 - you want to copy paste over your
package, JSON, if you want to
1423:59 - copy paste in the modules,
whatever you want to do, feel
1424:02 - free to do so I'm gonna go ahead
actually, this repo here, we're
1424:06 - gonna scroll up and just grab
once again, this line from less
1424:09 - than nine. And just run that I
know I'm gonna be using prettier
1424:14 - so I'm just gonna go ahead and
copy paste those two prettier
1424:16 - files over prettier ignore and
prettier RC going to be using
1424:20 - them again, for linting. With
solidity we're going to use Sol
1424:23 - hint dot JSON. So we're going to
grab that dot soul hint dot
1424:25 - JSON. And the dots will hint dot
ignore. I'm also going to grab
1424:30 - the hard hat dot config dot j s
because we're going to be using
1424:33 - a really, really similar setup.
And this hard hat dot config dot
1424:36 - j s. It's got waffle in it,
ether scan, hard hat deploy
1424:40 - coverage gas reporter sizer and
Dottie and v dot config, we're
1424:44 - going to bring over our Dotty
and V. And we're also gonna
1424:47 - bring over our utils folder as
well. Right, so a lot of that
1424:50 - boilerplate we're gonna bring on
over. And now just like that,
1424:53 - since we have the hard hat dot
config dot j s in here, if we
1424:56 - run yarn, hard hat, right now,
yarn hard hat will actually see
1425:01 - we get the output like this. So
let's go ahead. And before we
1425:05 - actually write our contracts,
let's go ahead and write a
1425:08 - little doc saying what our
contract is even going to do,
1425:11 - what do we want this to do?
We're going to create a
1425:15 - decentralized NFT marketplace.
So what does that mean? What
1425:19 - will we probably need? Well,
we'll probably need some type of
1425:23 - list item function, because
we'll want to list NF T's and
1425:27 - this will be to list NF t's on
the marketplace, we'll need some
1425:31 - type of buy item to buy the NF
T's. And then we'll probably
1425:34 - need maybe like a cancel listing
or cancel item, if you no longer
1425:38 - want to sell it, maybe an update
listing, update price. And then
1425:44 - maybe a withdraw proceeds to
withdraw payment or my bot and
1425:50 - fts. So when somebody buys an
NFT, I'm gonna have to withdraw
1425:53 - it from the contract since the
contract is going to be the one
1425:56 - to actually hold those funds.
That looks pretty good to me.
1425:58 - Let's go ahead and start
building this. So let's create a
1426:01 - new folder, contracts. And let's
jump into this. So we'll create
1426:06 - a new file NFT marketplace.
1426:09 - That's all. So let's get our
boilerplate. spdx pragma,
1426:18 - solidity, carrot zero, point,
8.7, contract and ft.
1426:24 - Marketplace, boom. If we're
doing this, right, h h compile
1426:29 - or yarn Hardhead to compile or
MPX, art, hit, compile, boom,
1426:33 - things are looking good. So if
we go back to our readme, we can
1426:37 - grab these here, even stick them
in as like a little comment for
1426:42 - us to kind of reference later
on. Let's start with listing the
1426:45 - items. How are we going to keep
track of listing people's items.
1426:48 - And once again, remember, when
I'm usually coding this, I'm
1426:51 - going back and forth between
writing tests and writing the
1426:54 - actual code. We're just going to
write all the solidity in one
1426:57 - chunk, and then go write the
tests. So we're going to say,
1427:00 - these are going to be our main
functions. I'm going to start
1427:05 - with function list item. And we
are going to make this one look
1427:09 - really, really good. So we're
going to do natspec. And
1427:12 - everything, this is going to
need to be an external function,
1427:15 - right, we're probably not going
to want any of our internal
1427:18 - functions calling list item,
it's going to be called by
1427:20 - external projects or external
accounts are probably going to
1427:23 - need an address and ft address,
write the address of the NFT,
1427:26 - contract a un 256 token ID, the
ID of the token ID of the
1427:32 - contract that we're going to
use. And then we're going to
1427:34 - want to set a un 256 price. So
first off, we're probably going
1427:37 - to want the price to be greater
than zero. So maybe we'll put in
1427:41 - like a little if or require
statement here, we'll say if
1427:45 - price is less than or equal to
zero, then we'll go ahead and
1427:50 - revert with a price must be
above zero error. And then of
1427:57 - course, we'll prepend it with
the name of the contract into
1428:01 - underscores. And then at the
top, the error price must be
1428:06 - above zero. Now in order for us
to list it, we could actually do
1428:09 - this one of two ways we could
one, we could send the NFT to
1428:13 - the contract, this would require
us doing like a transfer, right,
1428:16 - we could have got the contract
hold the NFT. Now we could do
1428:21 - this, but this is going to be
kind of gas expensive for
1428:25 - someone to actually list on f t.
And we can have the owner of the
1428:29 - NFT be our NFT marketplace, we
could 100 percent do that. The issue
1428:32 - with this, though is that the
marketplace will then own the
1428:35 - NFT. And the user won't be able
to say like, Hey, I own this
1428:38 - NFT, it's in the marketplace,
they technically would be able
1428:40 - to but they would have to
withdraw it, we might do this a
1428:43 - slightly different way where we
can say owners can still hold
1428:47 - their NFT and give the
marketplace approval to sell the
1428:53 - NFT for them. Now, of course the
owners of the entity could
1428:57 - withdraw approval at any time
and the marketplace wouldn't be
1429:00 - able to sell it anymore.
However, this would be really
1429:03 - easy for people to actually
read, they would all they would
1429:05 - have to do is read like is
approved for marketplace. And
1429:09 - they can actually see if the
item was really listed or not.
1429:11 - So we're gonna go ahead and
write it this second way,
1429:14 - because that's what Ardian does.
And this is the least intrusive
1429:18 - way to have this marketplace,
right? People still will have
1429:21 - ownership of their NF Ts, and
the marketplace will just have
1429:24 - approval to actually swap and
sell their NF T once the prices
1429:29 - are met. So since we want to
make sure the marketplace has
1429:32 - approval, let's make sure the
marketplace has approval. So we
1429:36 - can call we can call this get
approved function on that token
1429:39 - ID to make sure that the
marketplace is approved to work
1429:44 - with the NFT. To do this, we're
going to need the AI ERC 720
1429:49 - interface and we can actually
grab that from open Zeppelin.
1429:53 - Right and this interface will
wrap around an address and then
1429:56 - we can call get approved on that
address. So we'll do import at
1430:01 - open Zeppelin slash contracts
slash token slash ERC 721 slash
1430:08 - I ERC 721 dot Sol. And since
we're doing an import from open
1430:13 - Zeppelin, we'll do yarn add dash
dash Dev, add open Zeppelin now
1430:19 - that we have this interface in
here, what we can do is we'll
1430:23 - say I ERC 721 NF t equals IRC
721 wrapped around this NF T
1430:33 - address that we're passing in.
And we'll say if NF T dot get
1430:37 - approved of the token ID that
we're trying to list does not
1430:43 - equal address this. So if we are
not approved, then we'll revert
1430:49 - not approved or market place.
And then we'll of course we'll
1430:56 - want to do prepend it with NFT
marketplace into underscores. So
1431:01 - error like this, Bada bing bada
boom, now that we've gotten a
1431:06 - little bit of that out of the
way, we're probably going to
1431:09 - want to have some type of data
structure to list all these NF
1431:12 - T's. And typically we get to
Okay, do we want to use an
1431:15 - array? Or do we want to use a
mapping? What do you think?
1431:17 - Before we continue? Let's pause
for a second, do you think it
1431:20 - makes more sense to put these NF
T's and an array or an A
1431:23 - mapping? And when you're
thinking about this, try to
1431:25 - think about, okay, well, people
are gonna have to buy these and
1431:28 - sell these, what makes more
sense, think about this for a
1431:30 - second, maybe pause it and write
in a comment here, what you
1431:34 - think an array or a mapping is
better. Now, if you said
1431:37 - mapping, I would agree with you.
You couldn't do an array and you
1431:40 - wouldn't necessarily be wrong,
but it's not the way that I
1431:43 - would go about that for an
array. Anytime someone wants to
1431:46 - buy an item, we're gonna have to
traverse through the array,
1431:49 - we're gonna have to make this
massive dynamic array. And that
1431:53 - might get a little bit dicey as
that array gets really, really
1431:56 - big. So we're gonna go ahead and
make this a mapping. And this is
1431:59 - probably going to be a global
variable or a state variable. So
1432:03 - up at the top, let's go ahead
and create this mapping, it's
1432:05 - going to be a mapping of
addresses of NFT addresses.
1432:09 - Right? So it's going to be the
NFT contract address mapped to
1432:13 - the NFT, token ID mapped to some
type of listing. So we'll say, a
1432:19 - mapping of address to a mapping
of UNT 256. to, well, what do we
1432:26 - want here? Well, we want we want
the price, right? So is that
1432:28 - another you went up to six. But
we also want, we also want to
1432:32 - keep track of the sellers, we
know who to send money to. So we
1432:36 - could make two mappings or we
just create a new type of type
1432:39 - listing, let's go ahead and do
that. We'll comment this out for
1432:42 - now. And so at the top, since
this is going to be a type
1432:46 - where, say, struct listing, and
in here, we're going to do a
1432:50 - utility six, the price of the NF
t, and then address the seller
1432:55 - of the NF team. And now that we
have that new typing, we can
1432:58 - uncomment this, we can say NFT,
contract address map to the NFT
1433:03 - token ID mapped to the listing,
and we'll make this a private
1433:08 - variable called S underscore
listings. Now back down in our
1433:12 - list item function, we're going
to update that s listing
1433:17 - mapping. So we're gonna say s
listing of NF T address, right,
1433:21 - the address of the NF T at the
token ID is going to equal we're
1433:25 - gonna create a listing of the
price. And then who, well the
1433:29 - seller is going to be message
that sender, right? So message
1433:32 - dot sender, they're the one
who's actually listing the item.
1433:36 - And since we're updating a
mapping here, what's the best
1433:38 - practice for update mappings,
you guessed it, we need to emit
1433:42 - an event and especially for this
project, you're gonna see why
1433:46 - emitting events, for at least
this project, this is so
1433:49 - helpful. So we're gonna go ahead
and emit an item listed event,
1433:53 - which we're going to create in
just a second. And we'll give
1433:56 - the message that sender, the NFT
address, the token ID, and the
1434:01 - price item listed. And then up
at the top, of course, but below
1434:06 - our structure, we're gonna say
event item listed will do an
1434:11 - address indexed seller
1434:15 - address indexed NFT, address,
address indexed token ID, and
1434:26 - then a un 256 price. Sorry, this
needs to be a un 256 token ID,
1434:31 - you int 56. This looks pretty
good to us. However, we probably
1434:37 - want to make sure we only list
and FTEs that haven't already
1434:40 - been listed. So we can add like
an if then in here. And this is
1434:45 - kind of where preference comes
in a little bit. But I'm
1434:47 - actually going to create a
modifier called not listed. So
1434:51 - we make sure we don't relist,
and if T's that are already
1434:54 - listed above our main functions,
or do like a little indicator
1435:00 - modifier not listed. This is
gonna take an an address NFT
1435:06 - address, a un 256 token ID and
an address owner. And what we're
1435:13 - going to say is we're going to
check, we're going to make a new
1435:16 - listing memory listing equals s
underscore listings of NFT
1435:22 - address token ID. Now we're
gonna say if listing dot price
1435:30 - is greater than zero, we're
gonna go ahead and revert with
1435:33 - already passing the NFT address
and a token ID. And of course,
1435:40 - we're going to prepend this with
NFT marketplace. And at the top,
1435:47 - we do error ft marketplace
already listed, like so. And
1435:52 - then we're going to put a little
underscore right underneath and
1435:56 - then up here, we'll do address
and if the address you went to
1436:01 - 56. Okay, ID. So this modifier
looks pretty good. Let's just
1436:06 - make sure it's actually going to
compile we'll do yarn Hardhead
1436:09 - compile or hh compile. Great.
That looks good. We'll add this
1436:13 - modifier to our list item
function will do NFT address,
1436:18 - token ID message dot sender.
Cool. What else should we check
1436:23 - for here? Well, we should also
check that the NF T that's being
1436:28 - listed is owned by message dot
sender. This way only the owners
1436:32 - of the NF T can actually listed
here so let's go ahead and we'll
1436:35 - add a is owner modifier modifier
is owner NFT address token ID
1436:45 - spender you into 256 here and an
address spender I ERC 721 NF t
1436:55 - equals IRC 721 And if the
address address owner equals NF
1437:01 - T dot owner a Have a token ID.
And then we'll say if spender
1437:08 - does not equal owner. And we'll
revert with a not owner error
1437:13 - that we're going to go ahead and
create up top. So we'll say
1437:16 - error, not owner. And we'll
prepend it with NFT marketplace
1437:22 - with two underscores revert
revert not owner, then will do
1437:27 - underscore for the rest of the
code, and boom, now underneath
1437:31 - are not listed will do is owner
NFT address, token ID message
1437:39 - dot center. So now our list item
checks to see if it's already
1437:42 - listed, make sure that only the
owner of the NFT of that token,
1437:48 - Id can list it. And then it goes
ahead and lists it looking
1437:51 - nicely. Okay, cool. So that is
our list item method here. Now
1437:55 - let's go ahead and do a little
bit of natspec on
1437:57 - this. And now we have a little
natspec here, which looks really
1438:05 - professional. Alright, great. So
we have a list item function.
1438:09 - All right, what's next? Well,
maybe let's make a buy item
1438:12 - function for people to buy their
NF T's after they've been
1438:15 - listed. So let's create them do
function by item. So we'll take
1438:21 - an address, and if the address
un 256 token ID, and this will
1438:28 - be an external function. And
that will also make this payable
1438:33 - an external function because we
know only people or contracts
1438:36 - outside of this contract are
going to call by item and
1438:40 - payable so that people can spend
eath to spend eath, or whatever
1438:44 - layer one currency to actually
buy these prices, we could want
1438:47 - 100 percent at channeling prices in now
for listing, we could of course,
1438:51 - add price and then do like, you
know address token price. And do
1438:57 - what we did before with chain
link price feeds to convert the
1439:00 - price of these tokens into how
much they actually cost. And we
1439:02 - could 100 percent do that with chaining
price feeds. But for simplicity,
1439:06 - we're gonna leave that off. But
I will put that as a challenge
1439:08 - to you through challenge is
going to be have this contract
1439:12 - accept payment in a subset of
tokens as well, of course, we
1439:17 - would need to give a little hint
here is channeling price feeds
1439:21 - to convert the price of the
tokens between each other, we're
1439:26 - gonna choose which NFT in which
token ID we want to buy. So
1439:30 - what's the first thing that we
probably want to do? Well, we
1439:33 - probably want to check that this
by item is actually listed. So
1439:36 - we're actually going to make a
new modifier instead of not
1439:38 - listed we'll make it is listed
up and modifiers modifier is
1439:43 - listed. And this is going to
take an address and up the
1439:47 - address un 256 token ID. And to
check to see if this is listed,
1439:54 - we'll say listing memory listing
equals s underscore listings of
1440:01 - the NFT address of the token, Id
sort of go into the mapping
1440:07 - here. And then we're just gonna
check the price. So we'll say if
1440:11 - the listing that price is less
than or equal to zero, so
1440:15 - basically, if there's no price,
if it's defaulted to zero, if
1440:19 - the price is zero, then we're
gonna say revert, not listed.
1440:26 - And after the address, token ID,
and of course, we're going to
1440:32 - prepend. And if the marketplace
and the marketplace underscore
1440:36 - underscore, not listed, and then
we're gonna copy this up here,
1440:40 - we're gonna say air listed, and
this is going to take address,
1440:45 - NFT address, and au int 256
token Id like so, the down in
1440:51 - our modifier, then we're going
to add the underscore and to add
1440:53 - the rest of our code here. So
now we have an is listed
1440:56 - modifier, we're going to check
to make sure that that NFT is
1441:00 - actually listed down here now
we're gonna say is listed
1441:03 - address and ft address or excuse
me, and if the address and token
1441:08 - ID. Now once again, we're gonna
say listing memory listed item
1441:16 - equals s underscore listings.
And if T address token ID, or
1441:24 - say if message dot value is less
than listed item dot price, then
1441:30 - we're going to revert with price
not met. Then we'll do NFT
1441:36 - address, Open ID listed item dot
price Excel so we're going to
1441:43 - create a new air price not met
error. Price not met of course
1441:47 - we're going to prepend this with
NFT marketplace to take an
1441:51 - address. And if the address you
went to 56 token ID and then a
1441:58 - UNT 256 price. So we can see exe
exactly how the price wasn't
1442:05 - met, and then back down here,
we'll get the full error. So we
1442:09 - want to make sure they're
sending us enough money. First
1442:12 - of all, when they send this
money, it needs to belong to
1442:16 - whomever listed the item. So we
actually need to keep track of
1442:20 - how much money these people
have. So let's create another
1442:24 - data structure called proceeds
where we keep track of how much
1442:28 - money people have earned selling
their NF T's. So we'll create a
1442:32 - mapping of address to you and
256. And this is going to be a
1442:40 - mapping of seller address to
amount earned. And we'll make
1442:46 - this private called S underscore
proceeds. And what we'll do is
1442:53 - when somebody buys an item, is
will update their proceeds.
1442:58 - So we'll say as proceeds of
listed item, that seller equals
1443:06 - s proceeds of illicit IO dot
seller plus MSG dot value. Now,
1443:13 - once we buy this item, we're
going to want to delete the
1443:17 - listing. So to delete a mapping
from a wreck, so to delete an
1443:21 - entry and a mapping, we just use
delete s underscore listings and
1443:26 - ft address of the token ID. So
we remove that mapping. And then
1443:32 - finally, we're going to go ahead
and transfer it. So we'll say I
1443:35 - ERC 721 and ft address, we're
going to call dot transfer from
1443:43 - the listed item dot seller to
the message dot sender with the
1443:49 - token ID. Now you'll notice
something here, we don't just
1443:54 - send the seller the money. Now
why is that? Well, solidity has
1443:58 - this concept called pull over
push. And it's considered a best
1444:02 - practice when working with
solidity, you want to shift the
1444:05 - risk associated with
transferring ether to the user.
1444:08 - So instead of sending the money
to the user, this is what we
1444:12 - don't want to do want to have
them withdraw the money, we
1444:16 - always want to shift the risk of
working with money and working
1444:19 - with eath or whatever layer one
you're working with, to the
1444:23 - actual user. So we don't want to
send them the money directly, we
1444:27 - want to create this s proceeds
data structure and we can have
1444:31 - them withdraw from it later on.
Now, we could probably do some
1444:34 - checking here. Or we could say
okay, check to make sure the NFT
1444:39 - was transferred. And if we look
at I ERC 721 though, and we're
1444:45 - looking at the transfer from
function, we don't see it
1444:49 - actually has a return. And if we
go to the IP 721 We can see that
1444:56 - none of these have a return type
though, transfer from doesn't
1444:59 - have a return type here.
However, we do see this safe
1445:02 - transfer from bit safe transfer
from it's going to be a little
1445:06 - bit better, right because if we
look at transfer from transfers
1445:09 - ownership of an entity, the
caller is responsible to confirm
1445:12 - that underscore two is capable
of receiving entities or else
1445:16 - they may be permanently lost. So
maybe instead we want to use
1445:19 - safe transfer from which throws
an error unless message sender
1445:23 - is the current owner and
authorize operator, or blah,
1445:26 - blah, blah. So instead of
transfer from we're going to
1445:29 - actually use safe transfer from
just to be a little bit safer.
1445:32 - So we'll do safe transfer from
instead of transfer from. And
1445:37 - then since we're updating a
mapping, we're going to do what,
1445:40 - you guessed it, let's omit an
event, we'll call item bot. Lab
1445:45 - will be a message that sender,
an empty address, token ID and
1445:50 - for listed item that price. So
off the top, let's create a new
1445:55 - event. To event item bought. And
this will be a an address
1446:05 - indexed fire an address indexed
NFT address an address indexed
1446:17 - token ID and then a un 236
price. Just kidding, that
1446:22 - doesn't look fantastic. This
should be intuitive six. Now it
1446:25 - looks fantastic. Now in this buy
item, we've set this up in a way
1446:32 - that is safe from something
called a reentrancy attack. And
1446:36 - we've been coding these
contracts in a way where we kind
1446:38 - of do all this state change
first. And then we transfer the
1446:42 - NFT that token or etc. But why
are we doing that? Cognitively
1446:47 - we think it might make sense.
Okay, first, maybe we should
1446:50 - actually send the NFT right,
we'd want to send the entity
1446:54 - first.
1446:57 - This is actually a huge security
vulnerability. And to understand
1447:01 - why let's learn about one The
most common hacks in blockchain,
1447:05 - the reentrant. See attack. Now
in this sub lesson, we're going
1447:08 - to talk about reentrant. C, and
in the GitHub repo associated
1447:11 - with this lesson, we're going to
have the code for everything
1447:14 - that we're going to go through
here. And the code that we're
1447:16 - looking at is based off of this
solidity by example. reentrant.
1447:21 - See example. And I have a link
to it in the GitHub repo
1447:24 - associated with this course.
Now, I have a sample contract
1447:26 - here, it's a place where you can
deposit and withdraw your eath.
1447:30 - So what it does is it has a
mapping called balances, where
1447:34 - you can call deposit, and it'll
update how much you've deposited
1447:39 - into the protocol. And then it
has a withdrawal function as
1447:42 - well. So what it does is it
first grabs your balance from
1447:47 - this balances mapping, make sure
that you have more than zero.
1447:50 - And then the way that we've been
sending eath, this whole time,
1447:53 - we do message that sender dot
call, we send the balance, and
1447:57 - then we update bounces of
message sender equals zero. Now
1448:01 - this is the line that actually
makes this contract incredibly
1448:04 - vulnerable. And if we run this
right now, though, we'll say
1448:07 - hey, no, it looks like it's
working as expected, we can go
1448:10 - to deploy a copy the accounts
that I'm working with, like that
1448:16 - in a bounce zero, we can
deposit, you know, it's going
1448:23 - away, let's go to ether, will
deposit to ether, come down,
1448:28 - what deposit now had to balance
bounces up, we'll hit withdraw,
1448:33 - now have bounces goes back to
zero. And it seems like it's
1448:36 - working as intended. Now,
there's actually a way we can
1448:39 - attack this function to drain
all the money in this contract.
1448:44 - And this is what's known as a
reentrancy attack. The two most
1448:48 - common kinds of attacks in this
space are going to be reentrancy
1448:52 - attacks, which is what we're
talking about here. And Oracle
1448:55 - attacks, which usually only
happen when a protocol doesn't
1448:58 - use the decentralized Oracle,
lucky for you, we're teaching
1449:01 - you right from the get go how to
use chain link so that you can
1449:04 - be protected. And it's these two
types of attacks that often
1449:07 - result in the most amount of
money last, there's a
1449:11 - leaderboard called rec dot news,
which keeps track of many of the
1449:14 - top attacks that have ever
happened in the defi space. With
1449:18 - many of them if you go into the
retrospectives are either an
1449:21 - Oracle attack or a reentrancy
attack. And you might be saying,
1449:25 - Hey, where are we just talking
about NF T's this, this doesn't
1449:28 - have anything to do with NF T's
we'll get there, don't worry. In
1449:31 - a new contract below, we're
going to create a new contract
1449:35 - called attack down here. And
what we'll do with this attack
1449:38 - contract is we'll grab this
reentrant vulnerable contract,
1449:42 - we'll say reentrant, vulnerable,
public reentrant vulnerable,
1449:47 - like so. And we'll save that
reentrant vulnerable contract as
1449:51 - a global variable. And we'll say
construct door address,
1449:56 - underscore ranch and vulnerable
address. And then we'll say
1450:02 - reentrant vulnerable equals
rancher and vulnerable at
1450:10 - reentrant vulnerable address.
Now what we're going to do is
1450:14 - we're going to create a function
called attack. And it's this
1450:18 - function that's going to call
withdraw in a malicious way. So
1450:24 - we're going to say attack, this
is going to be an external
1450:26 - payable contract. And we're
going to call the posit on this.
1450:30 - So we'll deposit some money
first. So we'll do reentrant
1450:33 - vulnerable dot the posit
1450:37 - will send a value of one ether.
And then immediately we will
1450:42 - call re N Trent vulnerable dot
withdraw. Now at first glance,
1450:49 - this seems pretty harmless.
1450:51 - But remember, when we call
message dot call like this to
1450:57 - send we're calling back to this
this attack contract. Now when
1451:01 - we call this attack contract, is
there a way to execute any other
1451:05 - code? Well, there is remember
how we learned about fallback
1451:10 - functions. If we put a fallback
function in here or a receive
1451:15 - function. When this code runs
call and seconds our contract
1451:20 - ether we can have it trigger our
fallback function to call
1451:25 - withdraw again. So that will
send our contract more ether
1451:30 - than it's do before we update
the balance. So let's see what
1451:34 - this looks like. So in our
fallback here, we'll say if the
1451:39 - address of reentrant vulnerable
balance is greater than or equal
1451:46 - to one ether aka we're saying if
there's money left in the
1451:50 - contract, then rancher
invulnerable dot withdraw. And
1451:57 - then we'll put to get balanced
function in our attacking
1452:02 - contract. We're going to attack
reentrant vulnerable by calling
1452:06 - withdraw. When we get to this
send section, what are we going
1452:10 - to do, we're going to have our
fallback function trigger
1452:13 - calling withdraw again. Now when
we call withdraw again, bounces
1452:18 - a message that sender hasn't
been zeroed out yet. So the
1452:22 - contract code will go, oh, you
still have some money here.
1452:26 - Let's go ahead and let's send
you that, which will then again,
1452:30 - trigger us to call withdraw. And
so we'll just keep calling
1452:32 - withdraw until we're done. So
let's see what this looks like.
1452:36 - So we compile this, and then
let's go to deploy, first, let's
1452:40 - deploy the reentrant vulnerable
contract. Alright, and we can
1452:45 - have any contract address, you
know, like the one that deployed
1452:48 - it, we can have a deposit, let's
do, we have a deposit one ether
1452:54 - deposit. Now we can check the
balances of it. Copy. Paste
1452:59 - great, is one. So now let's have
a do 10. Deposit, it took the
1453:07 - balance. And now we have this
much in here. So we have this
1453:10 - much in here. And if we
withdrew, we withdraw all of it.
1453:13 - And if we switched accounts, to
somebody else, we hit withdrew.
1453:19 - Nothing would happen because
that other account doesn't have
1453:21 - anything, which makes sense. So
there's a lot of money in here,
1453:25 - right. And if we do get balanced
with the contract, we can see
1453:29 - how much money it has, right? It
has this much money total. Now
1453:33 - what we can do on a different
account, let's choose this, this
1453:36 - brand new account, let's go
ahead and deploy the attack
1453:40 - contract. And we'll pass it the
reentrant value address as an
1453:44 - input parameter. So we'll deploy
that. And now what we'll do is
1453:50 - we'll call attack. And you'll
see even though this contract
1453:54 - doesn't have anything deposited
in the reentrant vulnerable
1453:58 - contract, we will still steal
all the funds in here or just
1454:02 - about all the funds. So right
now hit get balance, and a
1454:06 - reentrant vulnerable, here's
what it is, get balance a here
1454:09 - zero, you know, there's the
address, we had attack now, now
1454:13 - that get bounce, oh, excuse me
in public, and withdrawal should
1454:17 - be payable as well. Now we'll
pass one ether as an input
1454:22 - parameter to our attack
function, and we're going to
1454:24 - deposit just one ether. And then
we're going to withdraw. And
1454:27 - we're going to keep withdrawing,
because our fallback function is
1454:30 - going to keep calling withdraw.
And all we had to do was deposit
1454:34 - one ether, and we're gonna be
able to pull out all 11 that are
1454:38 - in here.
1454:39 - So we'll hit attack now.
Transaction went through, the
1454:44 - new balance of our contract is
12, because the one that we
1454:48 - deposited and then the 11 that
we stole, and the new balance of
1454:52 - our old contract is now zero. So
this is known as a reentrant.
1454:55 - See attack. Basically, since we
call a function in another
1454:59 - contract in the middle of our
withdraw, we allow code to run
1455:03 - on a different contract. And the
code that ran runs on this
1455:06 - contract, recalls withdraw
before balances is set to zero,
1455:11 - we get to here we call the
fallback function of our other
1455:14 - code, and it calls withdraw, and
we need to reread withdraw
1455:18 - before we get to setting
balances a message that sender
1455:21 - equals zero. So this is an
issue, obviously. And there are
1455:24 - two ways we can prevent it.
There's the easy way. And then
1455:27 - the mutex way, I don't wanna say
the hard way, it's just a
1455:30 - different way. So one of the
things you'll always see in
1455:33 - security tools is you always
want to call any external
1455:36 - contract as the last step in
your function, or the last step
1455:40 - in transaction. And we want to
update bounces to zero before we
1455:44 - call that external contract,
because of balances of message
1455:48 - sender is reset to zero before
we call external code, then if
1455:53 - it were to try to re enter this,
it would hit this require step
1455:56 - and just cancel out right here
and wouldn't be able to send any
1455:59 - ether again. So that's the first
step that we can do. The next
1456:03 - step that we can do is using
something called a mutex lock.
1456:06 - And this is what open Zeppelin
does with one of the modifiers
1456:09 - that they have, we can have some
type of a Boolean called locked
1456:16 - or something and just right at
the top, we can just say require
1456:21 - not locked. Otherwise, revert.
And then the first thing we do
1456:27 - in this contract is we can say
locked equals true. And then the
1456:31 - last thing we do in here is we
say locked equals false. And
1456:34 - using this lock in here, we only
allow one piece of code to ever
1456:40 - execute in here at a time and we
only unlock it once the code
1456:44 - finishes. Now open Zeplin comes
with a reentrancy guard which we
1456:48 - can use on our code. And it has
a modifier non reentrant which
1456:53 - does essentially what we were
talking about with our locks it
1456:56 - creates a variable called status
and changes it to enter whenever
1457:01 - a function has been entered. It
runs out code, and then changes
1457:05 - it back to not entered when it's
finishes. And whenever any code
1457:08 - runs, it just requires that it
is not entered. So if we wanted
1457:11 - to use this on our code, we can
import at open Zeppelin, slash,
1457:20 - contracts, slash security, slash
reentrancy. Guard about so we
1457:30 - can inherit the functions by
saying NFT marketplace is
1457:34 - reentrancy guard. And then any
function that we're nervous is
1457:38 - going to have this reentrant see
issue, like maybe by item, for
1457:43 - example, we would just add the
modifier non reentrant. Just
1457:48 - like that. And that'll add that
mutex, that locking mechanism
1457:51 - that we talked about. Now, the
mutex way is a little bit more
1457:54 - explicit with our security,
right? Because we're saying,
1457:56 - Hey, this is locked. This is a
non reentrant function. Still a
1458:00 - best practice, whenever you call
external code, like what we see
1458:04 - here is you do all of your state
changes before you call an
1458:08 - external contract. Now, you
might be saying, Oh, that's cool
1458:10 - at all. But what about how does
this relate to our NF Ts? Well,
1458:13 - imagine for a second, instead of
message that sender dot call,
1458:16 - this is, you know, all success
equals, you know, some NF T dot
1458:21 - transfer from, and then we do
some transfers from stuff in
1458:24 - here. And instead of doing some
fallback stuff, our NF T has our
1458:30 - NF T's function transfer from
the similis code to re enter
1458:35 - into our withdraw. If we have
our withdrawal set up like this,
1458:38 - since we're still calling an
external contract with NFT. To
1458:41 - transfer from that transfer from
in that external contract could
1458:45 - be malicious and try to re enter
our contract. As a best
1458:48 - practice, you always want to
change your state, before you
1458:52 - call any external contracts that
you might not have control of, I
1458:57 - highly recommend playing around
with this a little bit just
1458:59 - because seeing is believing. And
with that being said, again, all
1459:02 - the code for this is going to be
available in the GitHub sociated
1459:06 - with this lesson for this
reentrant vulnerable code. And
1459:09 - with that, let's go back to our
NFT project.
1459:15 - Okay, so now we know why we're
doing this safe transfer from at
1459:20 - the bottom of our function here
at the bottom of our bio,
1459:23 - because if our safe transfer
function from was a little bit
1459:27 - higher, maybe what ends up
happening is we send multiple NF
1459:31 - T's to the wrong address before
we update them. So that's why we
1459:35 - do that. And we favor push over
Paul. As we said, Here, there's
1459:38 - a whole lot of these security
tips that you'll learn going on
1459:41 - through this course and in
solidity. But this is still
1459:44 - fantastic, right, we have our by
item. And we have our list item
1459:48 - functions. Let's do a cancel
item now, or cancelled listing.
1459:53 - So we'll do a function.
1459:57 - Cancel listing we'll do the NFT
address. And the UN 256 token
1460:04 - ID. This will be an external
function. One will want to make
1460:11 - sure only the owner of this
entity can cancel it. So we'll
1460:14 - say is owner.
1460:17 - And if T address, token ID
message dot Sen. Want to make
1460:24 - sure that the NFT is actually
listed. So we'll do is listed
1460:29 - and ft address, token ID. And
great. Now to cancel this, all
1460:36 - we're going to do is we're going
to delete s listings NFT address
1460:43 - token ID, we're just going to
delete that mapping. And then
1460:46 - we'll emit an event item
cancelled message dot sender and
1460:53 - if T address and token ID. And
of course, we're going to create
1460:59 - a new event here. We'll say
event item canceled. And it will
1461:05 - be an address indexed seller
address. Index NFT address. You
1461:15 - want to 56 indexed token ID. All
right. Great. That was pretty
1461:19 - quick. Cancel listening. Boom.
Jack. Done. What's next? Okay,
1461:24 - let's update our listings. So
we'll do function update listing
1461:30 - address and if the address you
went to for the sixth token ID
1461:37 - you went to the six new price
will update the price of this of
1461:42 - this external we'll make sure
it's listed with is listed
1461:51 - say is owner do a token ID and
then we'll do message dot
1461:59 - sender. Now to update our
listing We'll just say s
1462:04 - underscore listings of NF T
address. At token ID dot price
1462:12 - equals the new price that we're
giving it. And then we'll admit,
1462:16 - we can omit like item updated.
But we can also just omit an
1462:20 - item listed with MSG dot sender
NFT address, token ID, new
1462:27 - price. Because essentially, by
updating it, we're essentially
1462:31 - just relisting it with a new
price. So we're just going to do
1462:34 - an item listed event, we only
have one more function to do, we
1462:38 - need to do a withdraw proceeds.
So we'll say function, withdraw
1462:43 - proceeds to get all the payments
for all of our entities. So
1462:49 - we'll get the the proceeds by
doing new activity six proceeds
1462:52 - equals s underscore proceeds of
MSG dot sender, right, we're
1462:57 - getting all the payments that
were collected in by item, and
1463:01 - we're saying if proceeds is less
than or equal to zero, then
1463:07 - we're going to revert with no
proceeds. And we're going to
1463:12 - make this a NFT. Marketplace
underscore underscore no
1463:16 - proceeds. Excel create at the
top error empty marketplace no
1463:23 - proceeds being otherwise, we'll
say s underscore proceeds of MSG
1463:30 - dot sender equals zero. So we're
going to reset the proceeds to
1463:35 - zero, right, we're going to do
this before we send any
1463:37 - proceeds. And then we're going
to do our traditional way we
1463:40 - send payments, so bool success
1463:43 - equals payable, message dot
sender call value is going to be
1463:54 - proceeds all blank here. And
then we could do require, you
1464:01 - know, we could do require
success, or we could say
1464:05 - if not success, reverts revert
with Aleksey marketplace,
1464:15 - transfer failed. And then we'll
make this a new air, air NFT
1464:19 - marketplace transfer failed. Put
a semicolon here. And we're
1464:24 - looking pretty good. Now we even
have a way to withdraw. So we
1464:29 - have our five functions here.
Awesome. Let's just create a
1464:33 - couple of getters. So maybe
we'll do we even copy this.
1464:38 - Paste it here we'll say getter
functions like so. And we'll do
1464:43 - function maybe we'll do get
listing. Take an address, NF T
1464:47 - address, the utilities X token
ID, external view, which returns
1464:56 - a listing in memory. And we'll
say return s underscore listings
1465:02 - of NF T address token Id like
so. And also function, get
1465:12 - proceeds of address seller,
external view returns, you went
1465:19 - to the desex return s underscore
proceeds of the seller. So we'll
1465:26 - get how much money somebody is
owed. And then any listings and
1465:30 - let's run a little compile here,
yarn, or hit Compile or hh
1465:34 - compile just to see where we
messed up. Oh, we did a mess up.
1465:37 - Wow, that's great. And now,
guess what? You have
1465:42 - successfully created a
minimalistic NFT marketplace
1465:47 - that's completely decentralized.
That is pretty wild. And that is
1465:52 - incredibly powerful. And you
should feel really excited for
1465:55 - yourself. Very cool, very good
job. But you know, we're not
1465:59 - done, we got to write some
deploys and some tests. So let's
1466:02 - jump into that. Now since we've
done this a couple of times, I
1466:05 - actually encourage you to pause
the video here and try writing
1466:08 - your own deploy scripts and your
own tests. And then go ahead and
1466:12 - come back and follow along with
us and see if you did it
1466:15 - correctly, we're going to create
a new folder called deploy. Of
1466:21 - course, we already have the hard
hat deploy in our hard hat
1466:26 - config. So we know we're good to
go here. So let's go ahead and
1466:29 - create a one. Deploy NFT
marketplace.js. Now once again,
1466:35 - you've seen a lot of this
before, so we're going to spare
1466:38 - the details do const network
equals require hard hat to
1466:49 - constant development chains,
equal equals require dot dot
1466:55 - slash help our hard hats config,
which we should have let's see.
1467:00 - Do we copy paste it over? No.
Okay, so we didn't copy paste
1467:02 - over Are helper Hardhead config
from the last project, let's go
1467:05 - ahead and grab it. Or we can
grab it from the smart contract
1467:08 - lottery and paste that in here.
And we really only need this
1467:12 - file for the development chains
here. Right for hard hat and
1467:16 - localhost, we're going to grab
the development chains from
1467:18 - that. And then we'll also grab
const. Verify, equals require,
1467:25 - get this from utils. Verify,
right? Do we have utils, we have
1467:29 - verify. Fantastic. Now we'll do
module that exports equals
1467:35 - async. an async function where
it's gonna take get named
1467:41 - accounts and deployments. From
the hard hat input parameter,
1467:49 - and then we're gonna do const.
Deploy comma log equals
1467:53 - deployments. And then const,
Deployer equals await, get named
1468:00 - accounts. Which, of course,
we're getting from our heart
1468:04 - head dot config. We have named
accounts, we have a Deployer.
1468:08 - And we have a player or whatever
you have in here from our last
1468:11 - project. And now does our entity
marketplace have a constructor?
1468:14 - Construct? Nope, no constructor.
So we know args is going to be
1468:18 - blank. And then we can say const
NFT. Marketplace equals await,
1468:25 - deploy. And if T marketplace,
say from Deployer, args is going
1468:34 - to be args. Log will be true.
And then wait confirmations will
1468:42 - be network dot config dot wait
confirmations or one, two, this
1468:50 - is going to be block on for
patients, we'll go to the
1468:53 - config, just make sure that
those are in here. I'm sorry, I
1468:57 - didn't add them in here. So
we'll do block confirmations is
1469:01 - going to be six
1469:03 - for all of our networks. So I
actually grabbed this not from
1469:10 - the last project, it looks like
I grabbed this from the hard hat
1469:13 - starter kit. So I'm just going
to add those block confirmations
1469:15 - in there. And now we're good to
go. Now we're gonna say if we're
1469:18 - not on a development chain, not
development chains that includes
1469:23 - network dot name, and process
study and be done ether scan API
1469:32 - key, then we're gonna go ahead,
we'll do log verifying. And then
1469:39 - we'll do a weight verify. And if
the markets place dot address
1469:45 - with arcs, and then we'll do
like log a whole bunch of
1469:50 - hyphens here. And then finally,
module that exports dot tags
1469:56 - equals all and then NFT Mar good
place. And we can test this
1470:04 - deploy function with yarn
Hardhead deploy. Tada, we did
1470:09 - it. Great. So now we have the
deploy function, we can verify
1470:12 - we have our contract, what else
are we probably gonna need to
1470:15 - do. Since this is an NFT
marketplace, we're probably
1470:18 - going to need some NF Ts. So
what we can do is in our
1470:22 - contracts, and we'll create a
new folder for tests got a new
1470:26 - file in here called Basic NF T
dot soul. And in here, we can
1470:32 - add that basic NF T from our
last project. Or you can just go
1470:36 - to my or you can just go to the
GitHub repo associated with this
1470:40 - course, go to contracts, test,
basic NF t, and then just copy
1470:44 - paste. That works too. So this
basic NF t that we're using is
1470:50 - just pointing to the pug as the
basic NF T for us to use just to
1470:55 - test this out. So now that we
have a basic NFT we're gonna
1470:59 - need to create new file, oh to
deploy basic NF T dot j s, and
1471:05 - we'll borrow a lot of the
boilerplate from over here. So
1471:08 - we'll copy all of this actually
paste it in. We'll say const
1471:14 - args equals blank, and we'll say
const basic NF t equals await
1471:20 - deploy basic NF T. From
Deployer. args is going to be
1471:30 - args. Log is going to be true
weight con confirmations is
1471:36 - going to be network dot config
dot block confirmations or one
1471:44 - and then we'll verify this with
if not develop meant chains dot
1471:50 - includes network dot name and
process dot EMV that ether scan
1471:59 - API key that will say log or To
find dot A dot await there if I
1472:07 - basic NFT dot address, and arcs,
module dot exports dot tags
1472:14 - equals all, and basic NFT. And
we can test both of these with
1472:19 - yarn, art had deploy. And
fantastic. Both of these have
1472:25 - been deployed. Again, you don't
have to pause. But it is a good
1472:28 - way to really hone in to really
sharpen those skills on doing
1472:32 - all this. And repetition is the
mother of all skill. So
1472:36 - repeating this stuff yourself
and thinking through these
1472:39 - problems yourself and trying to
code these things yourself, are
1472:42 - really what's going to make you
successful at this. All right,
1472:47 - awesome. Now that we have our
deploy Betson, it's time to
1472:51 - write some tests. Now, if you go
to the GitHub repo associated
1472:54 - with this course, and you go to
the test folder, the tests and
1472:57 - here are some of the robust,
we've actually written out of
1473:00 - all of our projects, there's a
lot of tests in here. Now,
1473:03 - pretty much everything in here,
we've already learned about and
1473:06 - you already know how to do you
have the ability to do it. So
1473:09 - I'm just going to go ahead and
get you started off, and we're
1473:11 - going to write one test
together. And then I highly
1473:14 - recommend you going back in, you
tried to write some tests
1473:17 - yourself, to get that code
coverage to get that test
1473:20 - coverage to be 100 percent. So let's go
ahead, we'll write one test
1473:24 - together, then you should pause
this video and try to write some
1473:27 - tests yourself. When you're done
writing tests and you think
1473:30 - you've hit 100 percent, feel free to
compare back to the test that we
1473:34 - wrote. So let's create a new
folder called tests. Test. And
1473:41 - in here, we'll do a new one
called unit. And if you want to
1473:44 - write staging tests later on,
you absolutely can we will not.
1473:48 - We'll create a new file in here
called NFT marketplace.test.js.
1473:55 - And we'll start some tests. So
we'll do const.
1474:00 - cert, expect equals require Chai
const. Network deployments,
1474:11 - ethers, equals require hard hat
const development chains equals
1474:21 - require dot dot slash dot dot
slash helper, hothead config.
1474:26 - And we're gonna do the same
setup we've been doing. We'll
1474:29 - say bang development chains dot
includes network dot name,
1474:38 - question mark, describe dot
skip. Else describe. And if NF T
1474:48 - marketplace tests, comma async
function, excuse me, this is
1474:55 - just gonna be a function.
Scrabble oval is just a
1474:59 - function, not an async function,
like so. Great. Now let's get
1475:03 - some variables and do a before
each. So we'll say NF T
1475:08 - marketplace, basic NF T, we'll
create a constant price. So
1475:14 - we're just always set the price
of all of our NF T's to the same
1475:17 - thing. This will be ethers dot
utils dot parse
1475:22 - ether 0.1. We'll say const token
ID for now will always be zero.
1475:31 - And then we'll do before each
will be an async function.
1475:38 - And we'll get out and we'll also
get Deployer. Say deployer
1475:45 - equals await, get named
accounts. We're gonna need to
1475:50 - grab getting into accounts from
hard hat as well wrap this all
1475:53 - up dot deployer Excel and then
we'll also in our heart
1475:58 - hat.config.js. Under get named
accounts, we also have something
1476:02 - called player. Now I didn't talk
about this too much. But we're
1476:05 - going to have a second account
which is defaulted to the first
1476:09 - index, right? So we can do at
the top to come up player. And
1476:15 - we can say player equals await
get named accounts dot player.
1476:23 - Now we have a player and a
deployer account will do await
1476:26 - deployments, that fixture. All
will just deploy all of those
1476:32 - contracts will run through
everything in our deploy folder.
1476:37 - We'll get our NFT marketplace.
We'll say NFT marketplace equals
1476:41 - await ethers dot get contract
and ft. marketplace. And then
1476:49 - we'll do basic NF t equals await
ethers dot get contract. Basic
1476:57 - NF T. The way ethers dot get
contract works is it defaults to
1477:02 - grab thing, whatever account is
that account zero, which right
1477:06 - now is our Deployer. If we want
to call a function on NFT
1477:09 - marketplace, with the player
being the one calling the
1477:12 - function, we would have to say,
entity marketplace equals await
1477:18 - and empty marketplace dot
connect player like this. And
1477:25 - now whenever we call a function,
we would use the player instead
1477:30 - of the Deployer. Sometimes what
I like to do and you'll see this
1477:33 - in my code, is I'll do let NFT
marketplace contract. And then
1477:39 - let NFT marketplace, and then
I'll do NFT marketplace contract
1477:45 - equals await ethers dot
contract. And then I'll connect
1477:49 - and set that to the NF T
marketplace. Yes, we can do, we
1477:53 - can automatically choose who to
connect by placing whoever want
1477:57 - to connect to write and get
contract. But sometimes it's
1478:00 - really nice to be kind of
explicit. So it's really up to
1478:02 - you. I'm going to undo all that,
I just want to re show you that
1478:06 - to make sure that you knew
that's how you kind of switch
1478:08 - around with the different
accounts and the different
1478:10 - users. Now that we have an NF T,
we're probably going to need to
1478:13 - mint the NFT so that we can
actually place it on the market.
1478:16 - So we'll do await basic NF T dot
meant NF t, and then we'll
1478:20 - approve to send it on to the
marketplace. So we'll do a wait.
1478:24 - Basic NF T dot approve and T
market place dot address token
1478:33 - ID, which is going to be zero.
And just like that, the NOC
1478:38 - marketplace remember, it can't
call approve, because it doesn't
1478:41 - own that NF t. So we need to
have the Deployer. Call
1478:45 - approved, right. And remember,
since we're not we need to put
1478:49 - basic NF T in here. Since we
didn't tell ethers who to
1478:53 - connect this to it just
automatically connected it to
1478:56 - our Deployer because that's
what's at account zero. So it's
1478:58 - the deployer calling minting it
and then the deployer approving
1479:03 - to send it to the marketplace.
Only after this approved
1479:06 - function has been called canned
the NFT marketplace called
1479:10 - transfer from all those NF T's.
Now we're just going to do one
1479:14 - test here. We're gonna say it
lists and can be bought. That's
1479:20 - it, and this will be an async
function. And we're just gonna
1479:24 - list the NFT and buy a weight
entity marketplace.if We go to
1479:31 - our energy marketplace, what are
we doing, we're listing it
1479:33 - right, we want to list the item
or with the address token ID and
1479:36 - the price. So we'll do dot list
item. Basic NF T dot address,
1479:44 - token ID is zero, which we've
defined right here. And then
1479:47 - price we've hard coded up here
as well. So we're listing it. So
1479:51 - the deployer owns the NF T, the
player is now listing it, now we
1479:55 - want to buy it, let's have the
player be the one to buy it. So
1479:59 - what we're going to do is we're
going to have to connect the
1480:02 - player to the NFT marketplace.
So we can say const player
1480:07 - connected NF T, marketplace
equals and ft marketplace dot
1480:13 - Connect. Player. And then we can
buy the item by saying a weight
1480:19 - player connected and ft
marketplace.by item. It'll be
1480:24 - the basic and if we look back at
the end of the marketplace, what
1480:27 - does buy item need, needs the
NFT address and the token ID. So
1480:31 - basic NF t that address
1480:35 - and then the token ID and after
this bot, we should check to see
1480:39 - that the player actually does
indeed own that NF team. So we
1480:43 - can say const new owner and we
check to see if that owner is
1480:47 - indeed updated. We can say basic
NFT dot owner of because NF T's
1480:52 - have an owner of function, token
ID and then we also want to see
1481:01 - that the deployer actually is
going to get paid. So we can say
1481:04 - await and if T marketplace dot
get
1481:08 - proceeds of Deployer. So now we
can do assert new owner dot two
1481:17 - string equals player and we can
assert deployer proceeds.to
1481:29 - string equals price.to string
because they should have been
1481:35 - paid that price. And that's
right, it's actually a little
1481:38 - bit easier. instead of grabbing
players from getting named
1481:41 - accounts. It's a little bit
easier just to grab it right
1481:43 - from ethers. So we'll do const
accounts equals await
1481:49 - get signers. And then we'll save
player equals accounts of one
1481:56 - just because when we connect
it's expecting it type of
1481:59 - account and then the the get
named account is a different
1482:02 - type. So Oh, it's just a little
bit easier to actually connect
1482:04 - like this. So now we'll connect
to the player like so just know
1482:07 - that player and deployer are now
different types. So you'll see a
1482:11 - little bit differences there. To
me, this is ethers that gets
1482:15 - signers. And then when we buy
the item, we're of course gonna
1482:18 - have to pass a value, it's gonna
be price, of course, we're going
1482:23 - to need to pay the price of the
NFT. And then of course, this
1482:26 - needs to be player dot address.
And that's the difference right
1482:29 - now we got to do player that
address whenever we want the
1482:31 - address of one of the ethers
accounts. And then this new
1482:34 - owner, of course, should be in a
wait. And now we can run this
1482:37 - all. In Tada, we see things
pass. So our NFT marketplace is
1482:47 - able to facilitate the buying
and selling of an NF T with
1482:52 - arbitrary humans. This is
fantastic. So we just ran the
1482:56 - single test to show a little bit
of the oddities when working
1482:58 - with NF T's and some different
accounts. But 100 percent If you feel
1483:03 - up for the challenge, take this
time, pause this video and try
1483:08 - to write some tests. Remember,
the goal here is for us to do
1483:11 - yarn hardhat coverage, and see
what our coverage is and try to
1483:16 - get it to be 100 percent coverage. If
we run it right now, we'll see
1483:22 - Oh, my goodness, we are missing
a lot of coverage. Here, we have
1483:26 - a ton of uncovered lines, on top
of uncovered functions,
1483:29 - branches, statements, etc. Try
to write some tests to get this
1483:32 - to 100 percent and then come back.
Okay, welcome back. Hopefully
1483:41 - now you've written some tests.
And when you run your tests, you
1483:44 - can get some of them, I look
like this, right. And these are
1483:47 - my tests, these are the tests
that I wrote, you could do more
1483:49 - you could do last. And let's
see, when I run yarn Hardhead
1483:51 - coverage, I even missed some
lines. And I could I could test
1483:55 - a little bit more. So make your
tests even better than the ones
1483:58 - that I made. So these are the
tests from the GitHub repo
1484:00 - associated with this. Now that
we've written some tests here,
1484:03 - let's just write a couple of
scripts. And the reason we're
1484:06 - gonna write a couple of scripts
is we're gonna need these a
1484:08 - little bit later. So we'll write
some scripts to mint, some
1484:12 - amount of teased by some NF T's
etc. And we'll need this to
1484:15 - fiddle around and play on the
front end a little bit later. So
1484:19 - to create a script, again, we've
done this perform, let's do a
1484:23 - script called mint, and list dot
j s. And this will be to mint at
1484:29 - NFT. And then immediately listed
on the marketplace. So let's
1484:34 - create an async function called
mint, and list. And down below,
1484:40 - we're going to call mint and
list I'm going to copy paste
1484:42 - with that same script thing that
we've been doing. Obviously,
1484:45 - instead of Maine, though, we're
calling this mountain list. Now
1484:48 - in this mountain list, where
it's a constant, NFT mark, and
1484:52 - of tea market, place equals
await ethers dot get contract.
1485:01 - And ft marketplace. And right
we're going to import ethers
1485:06 - from hard hat. And then we'll do
we'll grab basic NF t. So we'll
1485:09 - say const. Basic kind of T
equals await ethers dot get
1485:15 - contract. Basic NF t. And then
first we'll mint a basic NF t.
1485:22 - So we'll do console dot log,
maintained at the top. And we'll
1485:27 - do a weight or actual we'll say
const. Mint, TX equals await
1485:32 - basic NF T dot mint NF t. And
then we'll do await min TX dot
1485:39 - Wait, wait one block. And
actually we'll say const. Mint
1485:44 - TX receipt. So that equals that.
And in this receipt, here's
1485:50 - another reason why events are so
good. When we met this NFT.
1485:53 - We're omitting the token ID in
an event in this document ID
1485:58 - event. So we could say const
token ID equals mint TX receipt
1486:08 - dot events of zero. That args
dot token Id like that. And now
1486:14 - we have the token ID. And now
that we have the token ID and
1486:17 - the basic NFT. minted we can now
call on our NFT marketplace list
1486:21 - item. So now we'll say console
dot log. Approving NFT right,
1486:27 - it's gonna be real similar to
our tests here. I'm gonna say
1486:29 - const approval TX equals await
basic NFT data prove
1486:36 - NFT marketplace dot address
token ID and then we'll do a
1486:42 - weight approved TX dot wait one
and we'll do console dot log
1486:49 - listing NF t.at that and then
we'll do const TX equals await
1486:54 - and if T market market place
that list item and we'll do NFT
1487:00 - marketplace that address So can
Id do await TX dot wait one,
1487:07 - console dot log listed and cool.
And we can try this out by
1487:14 - running yarn hardhat node, which
is going to run through our
1487:17 - deploy scripts, right, it's
going to run to these deployed
1487:19 - scripts here. And then in a new
terminal, we'll run our script,
1487:23 - yarn hard hat, run scripts meant
and list dash dash network
1487:30 - localhost. And we missed an
argument, oh, we need a price as
1487:34 - well to list our entity. So
we'll create a constant price
1487:39 - equals and we'll say ethers dot
utils dot parse, ether 0.1. And
1487:49 - we'll pass the price and to the
list item. So oops, and sorry,
1487:54 - it's not the marketplace that
we're listing, the basic NF t
1487:58 - that we're listing, of course,
so run that again. And Bada
1488:02 - bing, bada boom, got some listed
events. And we can see here,
1488:06 - we're doing some listing and
awesome. So now we have a
1488:09 - script. Alright, so now that we
have a script, and we're going
1488:12 - to be writing a couple other
scripts a little bit later, we
1488:14 - essentially have a really solid
repo here are our totally
1488:19 - decentralized, NFT marketplace,
this is absolutely massive, and
1488:23 - you should be incredibly,
incredibly proud of yourself.
1488:31 - Now, of course, this is all
code. And people can interact
1488:34 - with this, if they're software
developers, which is great. But
1488:38 - we're going to want to allow
anybody to be able to interact
1488:42 - and list their own NF t's on our
marketplace. So what are we
1488:46 - going to do? Well, we're going
to want to build a front end for
1488:50 - this. And now we're gonna get
into the second part of this
1488:53 - lesson. So on lesson 15, we just
finished the backend. Now we're
1488:58 - gonna move on to the front end,
we're gonna start with this
1489:00 - morass code. The code for both
of these is pretty much nearly
1489:05 - identical. But we're going to
start with Morales, and we're
1489:07 - going to teach you how to do
both of these. And we're going
1489:09 - to teach you the difference
between the Morales and the
1489:11 - MoGraph. And kind of why we're
even using them in the first
1489:14 - place, we're going to start with
Morales. So if you want to
1489:17 - follow along with this next
section, all the code we're
1489:20 - going to be working with, is
going to be in here. So you
1489:23 - excited, I hope you are because
this is going to be a phenomenal
1489:27 - session, we are about to build
one of the most sophisticated
1489:30 - front ends that we can using the
tools that we have. And like I
1489:34 - said, we showed you a little bit
earlier what this is going to
1489:36 - look like. So let's do a quick
refresher here. So here's what
1489:39 - our front end is going to look
like. But what we can do is we
1489:42 - can connect with our little
connect button, we hit Metamask
1489:45 - Metamask pops up, we'll go ahead
and connect. And now that we're
1489:48 - connected, we can see the
different NF T's in here. And if
1489:53 - we're on an address that's owned
by us, it will say owned by you.
1489:57 - And if we switch addresses, are
you I will go ahead and update,
1490:01 - connect there. And now we're
owned by a different address.
1490:04 - Now if it's owned by us, we get
this little hover that says
1490:06 - Update listing. And right now
it's worth 0.18. That's what
1490:10 - it's listed for on our
marketplace. If it's owned by
1490:13 - us, and we click it, we can
update it to a different price.
1490:16 - Let's update it to 50 eath, or
whatever your layer one currency
1490:20 - is, we'll just save new listing
price. We'll go ahead and
1490:23 - confirm. And I'll say the
listing updated, please refresh,
1490:27 - what we can do them. And we'll
mine some blocks on the back
1490:30 - end, and boom, now we see that
it's worth 50 here. Now if we
1490:33 - switch to a different account,
now we can see owned by Baba
1490:37 - blah, and the hovered now says
by me enough is selected as a
1490:41 - different user, I'm going to get
this transaction to actually buy
1490:45 - it. Now go ahead and confirm
that I'm going to buy it, I get
1490:48 - a little pop up. This is item
bought successfully. Now if I do
1490:51 - a little refresh, we'll now see
that that NFT is gone from the
1490:55 - marketplace since we bought it
right and it's no longer
1490:57 - available to be sold. Now what
we can do then is we can come
1491:00 - over to sell NF tees. And at the
bottom, we'll see a withdraw
1491:05 - proceeds. So whenever somebody
buys an NF T, the NFT
1491:09 - marketplace actually keeps the
proceeds that actually keeps the
1491:13 - result of the sale. So if we
switch back to our address that
1491:16 - had the NFT listed, we can now
see Withdraw 50 proceeds because
1491:20 - we know that we have 50 eath,
because we just bought that for
1491:23 - 50. So if we hit withdraw,
Metamask is going to pop up, we
1491:27 - can go ahead and confirm, wait a
little bit as transaction
1491:31 - populates, and boom once it goes
through, and we'll see now we
1491:35 - have zero proceeds. Right? We
withdrew everything from here.
1491:39 - So what we can do now is we can
relist that NFT. So if we come
1491:42 - back, go back to the one who
just bought that at a T if we
1491:47 - know the address and the token
ID of the NF t and we own it, we
1491:50 - can go ahead and relisted you're
gonna place the address in here
1491:54 - with the token Id give it some
sort of price. We'll submit
1491:59 - we'll approve giving the NFT
marketplace access to our or
1492:03 - NFT, to our little doggie. And
then we'll go ahead and actually
1492:07 - send the transaction to actually
list the NFT on a marketplace
1492:12 - that we get NF T listed
successfully. After we move some
1492:16 - blocks in the backend, we can go
back to the front end. And we
1492:19 - now see, it's owned by us,
instead of the original owner,
1492:23 - right and set for 10 ether. And
then we can of course, switch
1492:27 - back to a different user, and we
can have
1492:30 - them actually buy. Alright, so
now that we have the contracts,
1492:36 - we know what this looks like on
the contract side. So now let's
1492:39 - figure out how to do this on the
front end side. So let's jump
1492:42 - into our code editor. And begin
if we're on our hard hat and my
1492:46 - NFT marketplace Free Code Camp
folder. That's great. But we're
1492:50 - going to create another folder,
we're going to CD down and
1492:52 - directory. And we're going to
make a new directory. I'm going
1492:55 - to call it next Jas and if T
marketplace dash FCC. Now you
1493:01 - can do next Jas marketplace dash
mirallas FCC if you want. Again,
1493:05 - we're starting with mirallas CD
next Jas NFT marketplace FCC. So
1493:10 - now that we have this folder,
will do code dot will open up a
1493:14 - new VS code, or you can do File
Open folder and open this new
1493:18 - folder. And we can begin working
in this new folder in here. Now
1493:22 - that we're in our new project,
we're in our new folder, we're
1493:25 - gonna do exactly what we've done
before. Yarn create next app,
1493:30 - period. Okay, we've done our
setup here. Now, I don't like es
1493:36 - lint. So once again, I'm just
going to go ahead and delete
1493:37 - that. And what we're going to
add in instead is our prettier
1493:42 - stuff. So prettier, ignore
prettier RC. Again, some people
1493:45 - may strongly disagree with me on
that, but to each their own
1493:48 - right, this is what I like to
do. So this is what I'm going to
1493:50 - do. Now we have a minimalistic
react project, right? If we run
1493:54 - yarn Dev, we open up our UI on
that site, copy this, or
1494:00 - Command, click it. Tada. Welcome
to next. Jas Yeah, we've got an
1494:04 - x js application. As we know, we
go to pages, we go to index.js.
1494:09 - Let's delete everything in here.
Bom will leave the stuff and
1494:16 - head if it comes with stuff and
head will write Hi, exclamation
1494:19 - mark. We'll save we'll come
back. And now we see Hi. And
1494:22 - I'll zoom in a whole bunch.
Boom. So now we have some
1494:25 - minimalistic reacts minimalistic
next, Jas. Now, I know we
1494:29 - already started the project
here. But let's jump to the
1494:32 - readme that's given to us. And
let's talk about how we want to
1494:35 - do this what we want this to
actually look like. Well, we're
1494:39 - going to want to make a
homepage. And in this homepage,
1494:42 - we'll say we'll have it show
recently listed, NF T's homepage
1494:46 - will show recently listed
entities that will say if you
1494:50 - own the NFT, you can update the
listing. If not, you can buy the
1494:55 - listing. So we'll have that. And
then we'll have a sell page. And
1494:58 - in this page, you can list your
NFT on the marketplace. So these
1495:03 - are going to be our two main
pages, we're gonna have a
1495:05 - homepage and a sell page. Now
we're going to have a ton of
1495:08 - components, but we're really
only going to have two main
1495:10 - pages. So if we go back over to
Pages, right, right now we have
1495:15 - our apps dot j s, which serves
our app, which is cool, which
1495:19 - everything runs through. And
then we have our homepage. Let's
1495:21 - also create right now, our sell
page or selling of T dot j s.
1495:27 - And then in here, we'll just
make this really minimal, that
1495:30 - we can copy most of what's in
here, we can actually just copy
1495:33 - paste this whole thing, paste it
in here. And instead of high,
1495:36 - we'll say sell page. We'll save
that. Now if we go to our
1495:42 - localhost do debt slash sell.
And if T oops, we gotta run. Run
1495:48 - the front end again. With yarn
Dev. Sorry, we'll run yarn dev
1495:51 - again. Now we refresh. And now
we can see sell page. So sell
1495:55 - pages that slash sell page, and
then home is just going to be
1495:58 - high. Okay, cool. So we have our
two pages. Which one should we
1496:02 - work on first? Well, let's work
on our homepage. So we're going
1496:07 - to be in our index.js. I'm going
to keep this front end bit
1496:10 - running, we're going to hide it
oops, that's the opposite of
1496:13 - hiding it, push it down, we're
going to hide it like that. And
1496:16 - let's go ahead and let's start
building this. So we see in our
1496:19 - index js, we have some head
stuff here, I'm going to change
1496:22 - this to NFT. Marketplace.
Description is going to be just
1496:28 - an empty marketplace.
1496:32 - Like so Fabcon looks great. Now
if we do a little refresh, now
1496:36 - it says NFT marketplace up at
the top here, which is good.
1496:40 - That's what we want. Well in our
index page, what's one of the
1496:42 - first things that we're always
going to need to do? You guessed
1496:45 - it, we're going to need a little
connect button right? We're
1496:47 - going to need our users to be
able to connect to to web three
1496:51 - to connect to a blockchain. So
same as we've done before. Let's
1496:55 - go ahead let's create a
components folder. And we'll
1496:57 - create a header component
component Nance folder and we'll
1497:01 - create a new file The header
digests. Now remember, since
1497:06 - we've done this before, with our
front end lottery code, we can
1497:09 - always refer back to the lottery
code as well when we're building
1497:12 - this, okay. And of course, we
have all of the code for this on
1497:16 - the GitHub repo. So you can use
that to what I'm not going to
1497:19 - have you all do is last time, we
did that manual header thing,
1497:22 - right, where we had to do all
the local storage and do all
1497:24 - that crazy stuff, we're not
going to do that. This time,
1497:28 - we're going to just do it the
easy way, we're going to just
1497:30 - use the web three UI kit. So to
use this connect button, we're
1497:34 - going to do yarn, add. And we're
not going to do dash dash Dev,
1497:38 - because this connect button is a
necessary component for the
1497:42 - front end, yarn add web through
UI Kit. This also means we're
1497:46 - going to do Morales and react
mirallas. I said, and this is
1497:51 - where it might be a little
confusing. I know I said in here
1497:54 - that we have both a Morales and
other graph edition. So we're
1497:59 - still going to use the Morales
package in both of them. The
1498:02 - only difference is we're going
to use a Morales server as well
1498:05 - in our Morales edition. And
we're not going to use a morale
1498:08 - server on our the graph edition,
they're both can use the Morales
1498:11 - package because all the open
source hooks and tools are still
1498:14 - incredibly powerful, even if we
don't use the Morales server. So
1498:18 - we're still going to use the
Morales package even when we're
1498:20 - going to be using the graph.
Great. So now that we've added
1498:23 - those all, we're going to do
exactly what we did before on
1498:26 - our last next Jas process. So in
order to use our web through UI
1498:30 - component in our app, dot j, s,
and do import mirallas provider
1498:40 - quotes and without sorry, and
curly brace, it's from react
1498:45 - mirallas like that. And then
we're going to wrap our whole
1498:49 - component thing in a morass
provider. So we're gonna do
1498:53 - return, little open parentheses,
close parentheses here. We're
1499:00 - gonna do rounds provider. And
then we're gonna do in if she
1499:06 - allies on Mount is going to
equal false, because we're not
1499:12 - going to use the server yet, or
else provider. Okay, cool. Now
1499:15 - that we've wrapped our app in a
Morales provider, and go back to
1499:19 - our header, we're gonna say
Export default function header,
1499:26 - we're going to grab our Connect
button from what through your
1499:29 - eye kit. So we'll do import
connect button from web three UI
1499:35 - kits. And then in here, we're
just gonna say return. The next
1499:42 - button. Now what we can do back
in our app, J. S, is we can do
1499:46 - import, import, do header from
dot dot slash components header,
1499:54 - and we have our header, we'll
just put our header right above
1499:57 - the component. And we're going
to add some stuff to the header
1500:01 - in a bit. Let's just make sure
that we're importing the header
1500:03 - correctly. Let's go back to our
UI here. And okay, boom, we have
1500:06 - our connects button. If we click
it, you know, we'll get this
1500:09 - little pop up. And I'm way
zoomed in. So I'm going to anway
1500:12 - zoom in.
1500:14 - Now, what else do we want to put
in our header? Well, we're
1500:16 - probably going to want to like
give this like a name and make
1500:19 - this look a little bit nicer,
probably going to want to a link
1500:22 - as well to our cell NF T page.
So let's create a navbar. So
1500:27 - instead of just returning the
connect button, put this in
1500:29 - parenthesis and we'll have a
return some other stuff too. So
1500:33 - we can use this nav tag, which
usually defines like a nav bar.
1500:37 - So it's really similar to a div,
it's just another tag. Right, so
1500:41 - now we'll put everything into
this nav tag. And in next Jas,
1500:44 - we can actually make links using
the next Jas link tag. So what
1500:51 - we can do in this is link allows
us to basically connect to
1500:55 - different links or URLs in our
application, like so. So we can
1501:00 - do import link from next slash
link. And in here, let's say if
1501:07 - we want it to go to the
homepage, we can make a link.
1501:11 - And we'll say h ref equals slash
equals slash. And inside of
1501:18 - this, we would wrap this in an a
tag to make it clickable. And
1501:23 - then we could just say something
like NFT marketplace. Now if we
1501:28 - save that, we go to our front
end, we now we see have a NFT
1501:32 - marketplace button that we can
click and since we're already at
1501:35 - home, we're not going to go
anywhere. But if we copy this
1501:38 - link section, paste it below,
and we make another one for cell
1501:42 - and f t. And we title this cell
NF t. Now we save we go back to
1501:48 - our front end, we now have NFT
marketplace and sell NFT if I
1501:52 - click sell NF t we now get to
the sell page right we'll go
1501:55 - back to the homepage sell page
flip back and forth. Awesome,
1502:01 - very exciting. So now we have
have an incredibly minimalistic
1502:05 - header obviously looks terrible.
So let's do just a little bit of
1502:09 - formatting. And oftentimes
you'll do the formatting last.
1502:12 - But while we're here, we might
as well do our formatting we're
1502:16 - going to use what if you guessed
tailwind? You guessed correctly.
1502:20 - So remember, tailwind with.
Next. Jas, you can always just
1502:25 - follow along here. And we'll
grab, we'll do the exact same
1502:28 - thing we did before we'll do
yarn, add dash dash Dev, that
1502:32 - stuff right there. And then
we'll run a knit after these
1502:36 - finished
1502:36 - installing. So we'll do yarn,
and then paste that in. And
1502:42 - there we go. So now we've got
our post CSS config, we've got
1502:46 - our tailwind config. We're going
to grab tailwind.config.js.
1502:50 - Paste it in here. And then we're
going to grab Global's dot css
1502:54 - and open up Global's dot css,
paste that in there, and cool.
1502:58 - Now we have tailwind in here.
Now that we have tailwind, we
1503:01 - can do some tailwind stuff to
our header here. Let's let's
1503:05 - create a div for all of these
for everything here, we'll
1503:09 - create a little div for all the
stuff here, we'll make like a
1503:12 - big section for almost like a
big sign saying, Hey, you're at
1503:15 - the NFC marketplace, h1, which
stands for header one, and we'll
1503:20 - give it a class name of padding
y of form. Padding x of four,
1503:26 - we'll do font bold text will be
three XL, and then it'll just
1503:33 - say NFT marketplace. Now we have
this NFT marketplace, which is
1503:36 - nice bolt. Awesome. If you're on
your server you're going to kill
1503:40 - it's going to kill it with Ctrl
C, and then we're going to
1503:43 - restart it. And that's going to
pull in all the tailwind stuff.
1503:46 - And now if we refresh our local
main, we should now see okay,
1503:51 - and if T and F c, r gets place,
right, we now see this and big
1503:56 - and bold, which looks a lot
better. So let's keep going.
1503:59 - Let's give our whole nav a class
name. Equals we'll give it
1504:03 - padding of five, border bottom
to flex flex row justify just if
1504:13 - between n items center. We'll
see how that looks. Haha, looks
1504:19 - a lot better. We're now kind of
like setting this up with a
1504:22 - bottom border kind of stick and
some stuff like this, that looks
1504:25 - much much nicer already. Let's
go down here. Let's make our
1504:29 - buttons have a class name equals
lax lax row items center. And
1504:36 - like I said, this is not a
styling class. So we're not
1504:40 - really going to go over exactly
how we're styling this. And that
1504:43 - is okay. But that's going to
move that over make that look a
1504:46 - little nicer. We'll give our
link here, a class name equals
1504:51 - Mr. For P six. And we'll give
both of these the same class
1504:56 - name both these links, give them
some padding, so they moved away
1505:00 - from each other some margin to
the right, so they're away from
1505:02 - each other. And oh, I forgot to
do this Morales off equals
1505:07 - false. We need Morales auth
equals false so that we don't
1505:11 - automatically connect to a
Morales database or try to
1505:13 - connect to Morales database,
when we connect, we want to just
1505:15 - connect with our Metamask. And
we'll change this to home
1505:19 - instead of the marketplace. But
otherwise, that looks pretty
1505:21 - good home selling of T Connect
button. And we can adjust the
1505:25 - formatting of this to make it
look a little different. But I
1505:28 - think for the most part, this
looks much better,
1505:29 - right? Alright, cool, much, much
better looking header. Here, we
1505:35 - have our app.js setup with the
mouse provider headers
1505:38 - components. Let's now move on to
our index. Let's now move on to
1505:43 - showing these NF T's showing all
the NF T's in our marketplace.
1505:47 - And here's where it's going to
already start to heat up and get
1505:51 - really interesting. And actually
one more thing, we're going to
1505:53 - grab this headpiece in the index
if you haven't. And we're just
1505:57 - going to have it be in the app
JSX. So yeah, and our app.js
1506:02 - we're going to put that header
up at the top, and just put a
1506:05 - little, little div, Div. div,
like so wrapping around this
1506:11 - whole thing. This goes here. And
this way, no matter what page
1506:16 - we're on, we're always going to
have this as our header. And we
1506:19 - don't have to define it each one
of our little our things here.
1506:21 - So we'll do a refresh. And it
says head is not defined. Sorry,
1506:25 - that's because we're going to
need to copy import head from
1506:28 - next slash head. Paste it into
our app that Jas import head
1506:32 - from next head. And now we can
see we're going to empty
1506:35 - marketplace no matter what page
we're on, because we're defining
1506:37 - it at our app level. We have the
header in here, we have this
1506:40 - stuff in here, index almost has
nothing in it now. Let's do
1506:44 - this. So what do we want to do?
We want the homepage aka our
1506:48 - index to show recently listed
NFT. So the question is, how do
1506:52 - we show the recently listed NF
Ts. How do we do that? Well,
1506:58 - let's go back to our contract.
We go back to our hard hat NFT
1507:02 - marketplace So we're looking at
at the marketplace, what do we
1507:05 - have in here? How do we actually
see where NFT is stored? Well,
1507:08 - they're stored in this listings
mapping. However, how do we see
1507:12 - all of the listings that are in
here? Well, this is a mapping,
1507:15 - which means we have every single
address on the planet in here,
1507:18 - we can't loop through the
mapping, we'd have to loop
1507:21 - through every single address on
the planet, which is some
1507:25 - insanely large number that you
and I could never fathom how
1507:28 - many addresses there are. So
what are some solutions that we
1507:31 - can take to this problem, right?
Because we're obviously not
1507:34 - going to loop through
everything. So what do we do?
1507:37 - What's what's kind of the first
approach, one of the first
1507:40 - approaches would be like,
alright, Patrick, well, why
1507:42 - don't we just create an array,
an array of listings instead,
1507:46 - and this might be a good
approach. But what if then later
1507:49 - on, we also want to get some
other weird data, maybe we want
1507:52 - to get all the NF t's a user
owns NF t's a user owns, there's
1507:57 - no array of NF T's that a user
owns. Again, that's just a
1508:01 - mapping. But what if we want to
query some other weird data, or
1508:04 - query some other weird data, or
what if an array will be very
1508:10 - gas expensive, which it is, if
we make this an array to loop
1508:13 - through, it'll be incredibly gas
expensive. So we don't want to
1508:16 - have to go back and change. So
I'm going to I'm going to type
1508:19 - this out. Because this is
important. We don't want to
1508:22 - change our protocol for just the
website, we don't want to change
1508:28 - our protocol for just the
website, or we don't want to
1508:31 - much change our protocol for the
website. Because if we were to
1508:34 - make this an array, it would
become incredibly gas
1508:37 - inefficient. And it would become
much harder to use this NFT
1508:40 - marketplace because it would be
so much more expensive. And as
1508:43 - you build more and more complex
protocols, you're going to
1508:46 - realize that having an array for
every single mapping you have
1508:50 - isn't feasible. This is one of
the reasons where these events
1508:54 - come into play. So every single
time we list an NF t, we call
1509:00 - this list item function. And we
omit item listed, this item
1509:04 - listed event is stored in a data
structure that's still on chain,
1509:09 - but just smart contracts can
access it. However, guess what
1509:12 - can't access it off chain
services can access these
1509:16 - events. So what we do in this
case, is what we're going to do
1509:21 - is we will index the events off
chain and then read from our
1509:27 - database. So what we're
literally going to do is we're
1509:30 - going to set up a server to
listen for those events to be
1509:34 - fired, fired. And we will add
them to a database to query. So
1509:39 - yes, we're literally going to
take every single time an item
1509:43 - is listed, we're going to index
it in a database for ourself.
1509:47 - And then we're going to call our
centralized database to start
1509:51 - and we're going to call that
database to do that. Now the
1509:53 - question then becomes Whoa,
isn't that centralized? Hey,
1509:58 - Patrick, we're talking isn't
that centralized? What the
1510:00 - Hickety heck, and the answer to
that is, it's not necessarily.
1510:04 - So the graph is a protocol that
does exactly this. It's a
1510:08 - protocol that indexes events off
chain, and sticks them into this
1510:13 - the Graph Protocol. And it does
it in a decentralized way,
1510:17 - Morales, the way we're going to
show you first does it in a
1510:20 - centralized way, Morales is
going to do it in a centralized
1510:23 - way, which might be the route
that you want to go for speed
1510:27 - for extra bells and whistles, so
that you can do local
1510:30 - development, which is what we're
going to be focusing on here, or
1510:32 - any of the other functionality
that Morales comes with. Because
1510:35 - Morales does a lot more than
just that. That's something to
1510:38 - keep in mind too, is even though
we are adding a centralized
1510:41 - component, or logic, our smart
contracts, the real bulk of this
1510:45 - application is decentralized.
And you can verify all your
1510:49 - interactions are working with
this decentralized smart
1510:51 - contract, we've actually been
using a lot of protocols that
1510:54 - are centralized, like ether
scan, like open see, and some of
1510:58 - these centralized protocols are
really important to this space.
1511:01 - So we're showing you Morales to
get you familiar with working
1511:04 - with one of these centralized
servers, in case you optionally
1511:06 - want to make an application that
provides a centralized service.
1511:10 - And there's a ton of tools in
the space like opens up and
1511:12 - defender tenderly and more, that
are centralized, but give us
1511:17 - massive, massive benefits. We as
a community are bringing more
1511:20 - and more things to being
decentralized. And sometimes we
1511:22 - need some training wheels to get
there. And then the graph is
1511:25 - going to be the decentralized
way, which is a bit of a longer
1511:27 - process to go main net, but
we'll explain all that when we
1511:30 - get there. Let's learn how we
can list the most recently
1511:33 - listed NF T's and Morales in the
graph. Both have some really
1511:37 - solid videos, I'm going to leave
some links in the GitHub repo
1511:40 - associated with this. So if you
want to learn more, you should
1511:42 - definitely watch both of those
because they are absolutely
1511:44 - fantastic and will help you
understand this event stuff
1511:48 - better. So normally, when we
read from the blockchain, we do
1511:51 - something like contract dot get,
get listing, you know, and then
1511:55 - we put it whatever our input
parameters are. Contract double
1511:59 - blah, so instead, so we're going
to read from a database that
1512:02 - houses All the mappings and an
easier to read data structure.
1512:05 - Both Morales and the graph do
this.
1512:11 - We've been using the morass,
open source packages and tools.
1512:13 - However, Morales also comes
optionally with a server back
1512:17 - end to give your web three
applications more functionality.
1512:20 - However, there's a ton of stuff
that we're not going to cover
1512:23 - that Morales can do to help
build your web three
1512:25 - applications. So instead of me
continuing to talk about
1512:28 - Morales, and what it can do, we
have Ivan here to give a brief
1512:31 - overview of some of the other
things that Morales can do take
1512:34 - it away, and
1512:34 - my name is Ivan, I'm from
rallis. And I'm here to tell you
1512:38 - how you can speed up your
development by 10 times and I'm
1512:41 - not over exaggerating, when
you're building something, you
1512:43 - want to ensure that is scalable,
because your DAP may go global,
1512:47 - it may get viral, it may go
mainstream, it can happen. And
1512:51 - if it happens, you don't want to
start from scratch, you want to
1512:55 - use tools and services that
allow you to go fast, and also
1512:59 - to go big. And that's exactly
what mirallas provides. At
1513:02 - mirallas. We create tools, we
create infrastructure for
1513:06 - developers in a way that you
have a single workflow, and they
1513:11 - will soon explain what it means
because this is what saves you
1513:13 - time. If you have a single
workflow for doing things. And
1513:16 - workflow in web three really
means that you have to have a
1513:20 - smart contract, whether it's a
token, the game, some kind of
1513:23 - staking some kind of
marketplace, some kind of defy,
1513:26 - it will be on chain, but at the
same time, you have to connect
1513:29 - it to your back end. Because
when something happens on chain,
1513:32 - you need to monitor that. So you
can create web hooks, you can
1513:35 - create email, you can create a
push notification, you can run
1513:39 - some custom code, you can run
some calculation, you can save
1513:43 - something to the database,
everything on chain at the end
1513:45 - of the day needs to go into our
back end. And when something is
1513:49 - in your back end, it needs to go
to the front end. So for
1513:51 - example, you change the UI when
something happens on chain or
1513:55 - you change the UI. If your user
receives a transfer there is
1513:58 - above a specific threshold. Or
if your user has this NFC, you
1514:02 - can allow them access into some
kind of chat or some kind of
1514:06 - exclusive piece of content. So
at Morales, we provide you with
1514:09 - a full stack suite of tools that
is used by over 100,000
1514:13 - developers, it's really becoming
one of the most adopted tech
1514:17 - stacks in web three. And it all
starts with Morales identity,
1514:21 - which ensures that you get one
piece of code, you write one
1514:24 - piece of code and you can log in
your users across different
1514:26 - blockchains across different
wallets. And in your morale is
1514:30 - dashboard, you will get the user
profile, and you will get a web
1514:33 - session. So mirallas allows you
to manage identities because a
1514:36 - user profile can have many
different wallets from many
1514:39 - different chains connected to
it. And all of the transactions
1514:42 - will be synced from that user,
all the real time transactions
1514:45 - will be synced about that user.
And also, you have established
1514:50 - web session between your front
end whether it is a game,
1514:53 - whether it is a web website, we
ensure that you have secure
1514:58 - authenticated web sessions, and
we provide you with session
1515:01 - management. So in case you have
your own bike, and then you have
1515:04 - mirallas session identity
management, you can invalidate
1515:07 - sessions, you can log in users
and do all of that great, all of
1515:10 - these great things with one line
of code. That's very important.
1515:13 - Number two is Morales real time
I already mentioned a bit of it.
1515:17 - But basically when you have a
user, you know exactly what's
1515:19 - going on in real time. You can
run custom code, whenever a user
1515:22 - does a transaction, you can run
custom code or do a web hook or
1515:26 - email or push notification
whenever a user interacts with a
1515:29 - smart contracts or when a smart
contract simply emits an event.
1515:33 - This can be an trade in an NFC
marketplace, this can be ERC 20
1515:38 - transfer, you can be very
flexible by setting filters. So
1515:42 - you can say only give me alerts
only give me web hooks when the
1515:46 - user transfers more than 10
NFCs. Or when this token
1515:50 - transfer is above $1,000, and so
on so forth. This is morale is
1515:54 - real time very, very powerful
things. Next are mirallas SDKs.
1515:59 - So whether you're building a
website, whether you're building
1516:02 - a game where full integration
with game engines, whether
1516:05 - you're building for some other
platform, we have extensive SDKs
1516:09 - that are easy to use that allow
you to do all of this that allow
1516:13 - you to connect to Morales and do
this very, very easily. And if
1516:16 - you go to our documentation,
which I highly recommend you to
1516:19 - do, you go to Morales, Doc's dot
morales.io, if you go to Doc's
1516:23 - dot, Marisa Yo, you will first
and foremost understand what
1516:26 - mirallas is in depth. So you can
think of it kind of like
1516:28 - Firebase, but for crypto,
basically, it's a managed
1516:31 - backend, that you can connect
your front end. Also, you can
1516:35 - connect it to your own back end
using no GS SDK, it's very, very
1516:38 - easy. But what I wanted to show
you here is cross platform. So
1516:41 - for each thing we have, let's
say you want to get nfts for
1516:44 - your user, we'll show you how to
do it in simple JavaScript,
1516:47 - vanilla JavaScript, how to do it
and react, how to do it using a
1516:51 - web request. Let's say that you
just want to use a raw web
1516:54 - request. Let's say you're using
some kind of language that we
1516:57 - don't have SDK for you still can
use Morales just that you have
1517:00 - to call the raw HTTP request.
And we'll also show you how to
1517:04 - do it in Unity using C sharp in
Unity game engine. So we're
1517:07 - very, very clear cross platform.
And we are cross chain. So this
1517:12 - means for example, when you log
in the user, you can create the
1517:15 - user profile where you have the
lambda address, let's say your
1517:19 - user uses Solana then they can
easily connect Aetherium, they
1517:22 - can easily connect Binus chain,
the end, we're gonna add more
1517:25 - chain soon, they can easily
connect L Ron, to one user
1517:28 - profile. And then you have all
kinds of different wallets,
1517:31 - different chains, and you have
one single user profile one
1517:34 - single user ID. This is, by the
way, how it will look like in
1517:37 - your database. As you can see,
you're going to have a user user
1517:42 - table right here, you're going
to have all of their accounts.
1517:45 - So in this case, I only have
eath. But if I have Solana, if I
1517:48 - have other types of blockchains,
it will all be right here. And
1517:52 - this is a database that also has
all my transactions. This is a
1517:56 - database where I can set up
different listen events or smart
1518:00 - contracts. So for example, open
see I can watch open see smart
1518:04 - contracts or something else. And
it's very, very variable,
1518:06 - because this is MongoDB. This is
MongoDB, you can run MongoDB
1518:10 - queries, it's very, very
variable. So in that sense,
1518:13 - mirallas gives gives you a nice,
nice dashboard with everything
1518:16 - you need to know about your
users, their sessions, their
1518:18 - permissions, and so on, so
forth. And of course, you can
1518:21 - connect to your own back end
using the Node js SDK. So this
1518:25 - is Morales SDKs. And finally,
when we're speaking about the
1518:29 - workflow, the final thing is the
API's, which I also already
1518:32 - showed you, but the API is that
you can do RAW requests from any
1518:36 - programming language from any
kind of architecture. So using
1518:39 - this workflow, you can easily
achieve anything you want very,
1518:42 - very quickly. You really have to
try Morales it is it will change
1518:46 - your life. I can explain here
all I want, I have limited time.
1518:49 - But as you can already see, by
this presentation, you're very
1518:53 - curious, as you already can see,
by this presentation, you want
1518:56 - to try this as you already feel
by watching me here, you are
1518:59 - very, very excited. We have to
get your hands dirty. So go,
1519:04 - number one, two dogs, authorize
the sale, and go here getting
1519:07 - started connector SDK in vanilla
or react and go through all of
1519:12 - this. See the magic for
yourself. And if you want
1519:14 - practicalities, go to youtube
channel and go to morality Oh,
1519:17 - slash projects, guys, you all in
the community. Using Morales,
1519:21 - you will succeed using rallies,
you will achieve your goal. And
1519:25 - you're going to do sooner than
you expect yourself. You're
1519:28 - gonna surprise yourself. But
don't let yourself down. Go to
1519:32 - morales.io sign up, get started,
1519:34 - you guys. Now that I've
explained all of that, what does
1519:41 - this look like? Well, this is
where we're actually going to
1519:42 - start using mirallas with its
server capabilities. And we're
1519:46 - going to sign up for a server
here. And we're going to use
1519:48 - Morales as our back end for our
application. So to get set up
1519:52 - with Morales, we go to
morales.io. We can go ahead and
1519:55 - sign up for free. We'll put our
email in, we'll create some
1519:59 - password. Why are you here?
Other please specify Patrick's
1520:03 - amazing hardhat video, you don't
have to write that. But if you
1520:06 - want to write that you can. What
did you hear about Morales for
1520:09 - the first time? Well, you all
heard about it on YouTube,
1520:12 - because you heard it from me,
and then pick your roll, I'm
1520:14 - going to be a developer, we'll
hit next, I don't want to
1520:16 - subscribe. But I'm going to not
be a robot and create your
1520:19 - account. And it even gives us a
little property or create your
1520:22 - first server. So our back end is
going to use a server to do any
1520:26 - stuff on the back. So we'll
create a server. And if we were
1520:30 - going to do a main net or a
testament, we choose one of
1520:32 - those. But for now we're going
to do a local dev chain server.
1520:35 - And again, this is one of the
advantages of Morales is it
1520:38 - allows us to work with our local
dev chain. For indexing events,
1520:42 - we can actually index our events
from our local hard hat node,
1520:46 - which is incredibly, incredibly
powerful here, so check your
1520:48 - email, and we'll have an
activate my account thing,
1520:51 - email, we'll hit activate your
account. And it'll bring us back
1520:54 - here and we'll recreate and
we'll do local dev chain.
1520:56 - Alright, so now we're going to
create a new local dev chain
1520:59 - server. So we're going to call
this NFT marketplace, we're
1521:04 - going to select the region,
whatever region you want, I'm in
1521:06 - the eastern United States. So
I'm going to choose New York.
1521:08 - But whatever location works for
you, we're gonna do local dev
1521:11 - chain, and we're going to do
eath, local dev chain. And
1521:13 - again, if you're building for
polygon, if you're building for
1521:15 - avalanche, if you're building
for Phantom, if you're building
1521:17 - for any of these EVM compatible
chains, again, your eath local
1521:21 - dev chain, it's going to work
exactly the same. So we're going
1521:23 - to add instance now. And we're
going to create a new
1521:26 - application here. So we're going
to close now we have the server
1521:30 - here, and it says ganache, but
it's really hard hat. Don't
1521:32 - worry about that. Now that we
have our server up, we can go to
1521:34 - the Morales documentation, what
we're looking for is events,
1521:38 - we're looking to sync with
events. So we can even do a
1521:41 - little search in here for
events. And we see smart
1521:45 - contract events platform
Automatic Sync, and even tells
1521:48 - us a little bit more about why
do we need to sync and watch
1521:50 - smart contract events. So
basically, this server our
1521:53 - database is going to be looking
for these events to be emitted.
1521:56 - But before we can do that, we
need to hook up our application
1521:59 - to our server and if you go to
the React Morales GitHub right
1522:02 - at the top And you'll probably
see saw this before, when you
1522:05 - have this Morales provider in
their docks, they actually pass
1522:08 - an app ID and a server URL. And
this is how we can actually
1522:11 - connect directly to our servers
on mirallas. So what we're gonna
1522:16 - do is right, now we're gonna go
back to our app that Jas and
1522:19 - originally we've been saying
initialize on Mount equals
1522:22 - false. When we say this, we're
saying, Hey, we're not going to
1522:25 - use a morale server, we're just
going to use the open source
1522:28 - morass tools that y'all provide.
Now, we actually do want to use
1522:31 - their server, right, we do want
to use all these bells and
1522:33 - whistles that Morales comes with
out of the box. So we're going
1522:35 - to change that. So instead of
saying initialize on Mount
1522:38 - equals false, we're just getting
ready with the app ID and the
1522:40 - server URL. So we're going to
delete this. And just like it
1522:43 - says, in the documentation,
we're gonna give it an app ID
1522:46 - and a server URL. So we're gonna
say app ID equals, and this is
1522:49 - where as a string, we'll put our
app ID. So if we go back to our
1522:52 - Morales database, we can go to
view details. And we see all
1522:56 - this information in here. And we
can grab our application ID, we
1523:00 - can copy it, paste it in here.
And then we'll want to grab our
1523:04 - server URL, which is at the top.
So this is the URL of our unique
1523:09 - custom morale server. So we'll
say server, URL equals and then
1523:14 - paste that in there like that.
Now, if you've been following
1523:16 - along with these tutorials, you
might be thinking oh, we're
1523:18 - we're kind of just hard coding
that stuff right in there like
1523:20 - that, how that seems kind of
that seems kind of bad. Well, if
1523:24 - that's your intuition, that is
fantastic. So instead, we're
1523:27 - actually going to put these into
environment variables. So we're
1523:29 - going to create a new file, a
dot env file. And this is where
1523:34 - we're going to put all of our
environment variables. Now next,
1523:36 - Jas comes with built in support
for environment variables, which
1523:39 - allow you to do the following
use dot env, dot local to load
1523:43 - environment variables or those
environment variables to the
1523:45 - browser by prefixing. It with
next underscore public. So
1523:48 - there's a couple of different
environment variable paths we
1523:50 - can use. We can do dot env, dot
local, we can do dot env, dot
1523:53 - this dot that that the other
thing, we're just going to do
1523:55 - dot env, to keep it simple here.
But in order for our front ends,
1523:58 - to read environment variables
from our dot env file, we have
1524:01 - to do next underscore public
underscore, and next Jas will
1524:06 - look into our dot env file for
variables that start with this
1524:09 - and only stick these environment
variables into our application.
1524:13 - If we were to just do like
Morales server equals blah,
1524:16 - blah, blah, it has no idea what
this is because we need to do
1524:20 - next underscore public
underscore. And if we do that,
1524:24 - and we'll do a console dot log,
look here, process dot env. Next
1524:28 - public morale server and we
actually need to kill it and
1524:31 - restart it. And then we go back,
we do a little refresh here,
1524:34 - it'll say Look here as a do bla
bla bla, because that's what is
1524:37 - in the dot env file with that
next public. So we'll grab our
1524:41 - app ID, we'll copy it. And then
our dot env will do next public
1524:48 - app ID equals and we'll paste
that in there. We'll grab our
1524:52 - server URL, we'll go back to
here. We'll do next public
1524:57 - server URL equals, we'll paste
that like that. And now at the
1525:02 - top, we'll say const. App ID
equals process dot E and V dot
1525:10 - next, public app ID. And then
we'll say const. Server URL
1525:16 - equals process dot E and V dot
next public server URL. Now that
1525:23 - we've had these variables, we'll
stick them in like this.
1525:28 - So this is how we can connect
our application to our morale
1525:32 - server. Now, of course, we
haven't done anything yet. But
1525:35 - we're getting started, right?
This is how we're going to
1525:37 - connect to it. Now that we've
signed in, well, I told you that
1525:40 - our morale server was going to
be indexing our events. And if
1525:43 - you go to this Dashboard button,
this is our entire database.
1525:46 - Everything in this browser tab
is what's in our database right
1525:49 - now. And as you can see, right
now, there's not a whole lot of
1525:51 - anything, if we had any events
data in here, it would be in
1525:55 - here. So we need to tell our
server, hey, you need to start
1525:58 - listening for events. So we can
show the most recently listed
1526:01 - entities. So morale server, you
need to start listening, you
1526:04 - need to create a database entry
for every single one of these
1526:07 - item listed events. And whenever
somebody buys an item, right,
1526:11 - whenever somebody buys that
item, or cancels an item, you
1526:14 - need to remove that from your
database. How do we start
1526:17 - telling Morales to start
listening to our events? Well,
1526:20 - first off, well, first off,
we're gonna need to connect it
1526:22 - back to to our blockchain. And
then we're going to say, which
1526:26 - contract which events and what
to do when it hears those
1526:30 - events. So we need to connect it
and then we need to tell it what
1526:32 - to do when it hears those
events. So how do we connect our
1526:35 - mirallas server to our hard hat
blockchain? And right now, we're
1526:38 - not running one. But let's go
ahead and we'll start up our
1526:41 - hard hat, our local host
blockchain. So in one terminal,
1526:45 - we're running the front end and
another terminal will see the
1526:48 - download directory. We'll cd
into our hard hat NFT
1526:52 - marketplace dot Free Code Camp
or Free Code Camp, and we'll do
1526:56 - yarn hard hat node. And if we've
done everything correctly, it'll
1527:00 - deploy our NFT marketplace.
It'll deploy our Basic NFT and
1527:03 - then it'll start local HTTP web
socket at blah, blah, blah. So
1527:07 - that's good. So now that we have
that Node running, what we can
1527:09 - do is we can go to view details,
and go to dev chain proxy
1527:14 - server. So this dev chain proxy
server is going to be how we
1527:18 - actually tell Morales to listen
to our locally running hard hat
1527:22 - node. Now, to do this, what
you're going to need to do is
1527:25 - we're going to need to download
this what's called a reverse
1527:28 - proxy. And I have a link to this
in the GitHub as well, depending
1527:32 - on what computer you're running
on will tell you which one of
1527:35 - these we actually need to
download. And then there's some
1527:37 - troubleshooting tips down here
if you ever get lost, and if
1527:40 - you're really, really confused,
what we can do what Morales FRP
1527:46 - to download, do a quick search
on this. We even come right to
1527:50 - the documentation, connecting
ganache to Morales note for Mac
1527:54 - users download FRP dot Darwin
dot bla bla bla for the nosh
1527:58 - proxy server. So I'm on a Mac.
So I'm going to download this
1528:01 - Darwin AMD 64. And for look at
the releases, that's the first
1528:05 - one at the top, Darwin AMD 64.
So this is the one that I'm
1528:08 - going to go ahead and download.
1528:10 - I'm gonna click it, I'm going to
download it. Once I have it
1528:13 - downloaded, we're going to open
it up, and we're gonna get a
1528:16 - folder and we're gonna get a
folder that looks like this. The
1528:18 - main things that we need are
going to be f RP and FRP C dot
1528:23 - ini. F RPC is going to be the
executable it's going to be what
1528:27 - we're going to run to connect
our blockchain node to Morales,
1528:31 - and F RPC dot ini is going to be
basically the config file to do
1528:34 - this. Now, again, this is one of
the sections where downloading
1528:38 - this is going to be one of the
hardest steps here. So if you
1528:40 - get lost, please ask questions
in the GitHub, please ask
1528:43 - questions in the Morales forum,
there is a Morales forum as
1528:46 - well, where you can ask a ton of
different questions. And please
1528:48 - check out the troubleshooting as
well. But what I'm going to do
1528:51 - is I'm going to create a new
folder in here new folder called
1528:55 - F R P. And I'm doing it in here
just to make it a little easier.
1528:58 - But you could really put this
wherever you want, and then
1529:01 - always refer back to it. And
what I'm going to do is I'm
1529:03 - going to take I'm going to copy
these two files, and place it
1529:07 - into this FRP folder. So now I
have FRP C, and F RPC that ini
1529:12 - if you click on the F RPC, it's
going to be like, hey, it's
1529:15 - binary, you can't really look at
this, don't click that, it'll
1529:18 - just be a whole bunch of
nonsense, but the F RPC dot ini
1529:21 - looks like a pretty typical
config file. And this is what
1529:24 - we're going to adjust. If we
even go back to our morale
1529:28 - server, it'll give you what you
need down here. And we're using
1529:32 - hard hat. So we're going to copy
everything here. We're gonna go
1529:36 - back to our F RPC dot ini, and
then just paste whatever is in
1529:40 - there in here. And that's how
we're going to tell this F RPC
1529:43 - thing that we need to connect. I
haven't tried this out for users
1529:46 - using WsL. So if you're using
WsL, let us know in the full
1529:50 - blockchain solidity course, Jas,
make a new discussion, if you
1529:53 - haven't seen it already, saying,
Hey, I'm using WsL for the F
1529:56 - RPC. And here's what you need to
use. And then at the bottom, it
1529:59 - says, run and enjoy. I'm running
on a Mac OS, which runs Linux
1530:03 - commands, so I can just copy
this, I'll create a new
1530:06 - terminal. And what I'm going to
do is I'm going to cd into that
1530:09 - FRP folder. And I'm going to
paste that thing that I just
1530:14 - that I just copied from Ross. So
we're running that F RPC
1530:17 - executable dash c, which is dash
config, F RPC dot ini. If I hit
1530:22 - Enter, it's gonna say log into
server success, get run ID,
1530:27 - blah, blah, server, UDP port,
and then a whole bunch of other
1530:30 - stuff. If you're seeing success
stuff here, that means you did
1530:33 - it right. And you can hit CTRL C
to cancel because we're not
1530:37 - going to keep running it. Now,
if you want to just run this,
1530:40 - you absolutely can. But I'm
going to show you another way to
1530:43 - do this. And this is using the
Morales admin CLI. So everything
1530:48 - that we're doing here, all these
buttons that we're pressing,
1530:50 - Morales actually comes with this
thing called the Morales admin
1530:53 - CLI or the command line
interface. So this is a way for
1530:57 - us to connect and run all these
buttons and stuff that we're
1530:59 - pressing right from our terminal
and right from our shell. So I'm
1531:02 - going to show you a couple of
commands on how to work with the
1531:05 - admin CLI. And we're going to be
working with a lot of admin CLI
1531:08 - commands. But all we're going to
do is npm install dash g
1531:11 - Morales, admin CLI or for us
yarn Global Add. So we're going
1531:15 - to grab that will do yarn,
Global Add routes, admin CLI
1531:20 - like that. And now we should be
able to run Morales admin CLI
1531:26 - and see a whole bunch of stuff
like that. And if you ran
1531:28 - routes, admin CLI, we have all
this stuff. And one of the big
1531:32 - ones, one of the important ones
that we're going to be working
1531:34 - with is this connect local dev
chain. So running this F RPC
1531:39 - dash c dash f RPC ini. That's
going to be the same as running
1531:43 - this connect local dev chain.
Now what I like to do is jump
1531:47 - into our package dot JSON. And
we'll create an additional
1531:51 - script in here for us to just
run yarn, whatever the name is
1531:55 - that we want, and just to do
that, and just to make it a lot
1531:57 - easier for us to connect our
local dev chain so underneath
1532:01 - lint, I'm going to do a calm
Ma'am, I'm going to create a new
1532:04 - command. I'm gonna say Morales
sync. And we're going to run the
1532:09 - Morales admin CLI version of
this f RPC dash c thing. So what
1532:14 - we're going to do in here is
we're going to say mirallas
1532:17 - admin CLI, connect local dev
chain, dash dash chain, hard
1532:27 - hat, dash dash mirallas. Capital
sub domain.
1532:33 - This is where we're going to put
the subdomain of a morale
1532:36 - server, which if we go to, we go
back to our routes, admin data
1532:40 - servers, we can go back to
server details. So it's going to
1532:44 - be not the HTTPS, it's just
going to be from here all the
1532:47 - way to the.com. So not even the
port, we're going to grab that
1532:51 - we're going to paste that there.
And then we're going to do space
1532:54 - dash dash f RPC path is going to
be dot slash F RPC, slash FRP
1533:04 - slash F RPC. Now if we save
this, and we run it, it's not
1533:07 - going to work though. So if I
run yarn with our new script,
1533:11 - Morales sync, it's gonna say
specify Morales API key, it's
1533:14 - going to give us this prompt.
And in our dashboard, we have
1533:18 - our API key, which we can copy,
we can paste it, and then API
1533:21 - secret, we can copy and then
paste it. And then we'll say
1533:24 - starting connection to hard hat,
which is great. But that's
1533:27 - really annoying. And I don't
want to have to do that. So
1533:29 - we're going to Ctrl C, we're
going to kill that. And what we
1533:31 - can do is we can go into our dot
env. And we can actually add
1533:36 - those as environment variables
that Morales is expecting. So
1533:40 - when we run this Morales admin
CLI, it'll check our dot env
1533:44 - file for Morales API key, which
we can copy right here. And then
1533:50 - Morales API secret, which we can
copy, and paste right here. Now,
1533:57 - the reason that these aren't
capital and doing next public,
1533:59 - these are not going to be part
of our front end piece. These
1534:03 - are keys that we're using on the
back end to test and for our
1534:06 - local dev chain connection. So
we don't need to do next public,
1534:10 - we're just going to leave it
like this. But now if I hit up
1534:12 - and run yarn Morales sync,
again, it's not going to prompt
1534:15 - me this time, it's just gonna
say starting connection to hard
1534:18 - hat. And if you see this, this
starting connection to hard hat
1534:21 - bit, we can come back to our
servers, we'll go to dev chain
1534:24 - proxy servers, we'll hit this
disconnected button and refresh.
1534:29 - And if you see connected, you've
successfully connected our heart
1534:32 - add node, which is running here
to our Morales server, which is
1534:37 - awesome. And in fact, if you sit
on your heart had no terminal,
1534:40 - you'll see the actual RPC calls
to our blockchain here. And
1534:45 - you'll see Morales is
consistently calling f block
1534:49 - number to make sure it's up to
date with what it has. So how do
1534:55 - we tell a morale server to start
listening for events? Well,
1534:59 - there are two ways we can do
this. The first way is with the
1535:02 - user interface. So we can go to
view details, we'll go to sync.
1535:06 - And right now it says no sync
services installed. So we'll hit
1535:09 - Add a new sync. And we can see
sync and watch address and sync
1535:14 - and watch contract events, we
can watch the address for
1535:16 - transactions or we can watch
some address for any events. And
1535:20 - we can manually add all our
information here, you can select
1535:23 - the chain description, decide if
we want to optionally sync
1535:26 - historical, we could put the
topic of the event, the ABI of
1535:29 - the event, the address of the
event filter, and then a table
1535:32 - name. Or we could do all this
programmatically, which is what
1535:34 - we're going to do, we'll create
a little script that we can run,
1535:37 - tell our morale server to watch
for those scripts. And we'll see
1535:40 - our database get upgraded to
listen for those events. So back
1535:44 - in our code, we're going to
create a new file called add
1535:48 - events that Jas now we have one
terminal that's running our
1535:52 - front end one terminal that's
running our blockchain one
1535:55 - terminal that syncing our
blockchain with morass. And now
1535:58 - we're going to do another
terminal. For anything else we
1536:00 - want to do like run little
scripts become the Morales
1536:02 - docks, and you click connect
with SDK, there's a ton of
1536:05 - different ways we can actually
connect with the SDK, we've
1536:08 - already learned how to connect
with react by using React
1536:10 - Morales. Now we're going to
connect with no JS since we're
1536:14 - going to run a little Morales
script. And here's like a little
1536:17 - example of what it looks like in
the documentation. But I'm gonna
1536:20 - go ahead, so I'm gonna say const
Morales, equals require oralis
1536:25 - slash node. And we're going to
import the node extension of the
1536:29 - Morales package into our script
here, we're going to require dot
1536:33 - env
1536:34 - dot config, which means we're
going to need to install dot env
1536:39 - yarn add dash dash dev dot env.
And now we have to tell our
1536:44 - morale server all the same
information that we would need
1536:47 - to tell it on the user
interface. So one of the first
1536:49 - things that we're going to need
is the address of our contract.
1536:51 - We're gonna need to say const
contract address equals and this
1536:55 - is where we go oh, well, how do
we how do we get that contract
1536:58 - address? The easy way to do this
is we just go back where we're
1537:01 - running the blockchain And we'd
grab where that NFC marketplace
1537:05 - is deployed. And similar to our
smart contract lottery where we
1537:09 - created an update front end
script, we're gonna do the exact
1537:11 - same thing here. So back in our
heart hat, NFT marketplace, and
1537:15 - if T code, we go to our deploy
script or deploy folder, we're
1537:18 - gonna create a new file called
99 Dash update, front end dot j
1537:25 - s, and we're gonna create a
little bit of our deploy process
1537:27 - that will automatically update
our front end. So we can just
1537:31 - grab the network address from a
file that is programmatically
1537:34 - created. So we're gonna do
module dot exports equals async
1537:38 - function. And now we'll say if
process dot EMV that update
1537:44 - front end, then console dot log,
updating front end so that in
1537:53 - our dot EMV, we have update
front end equals true. And that
1537:57 - will be how we decide whether or
not we actually want to update
1538:00 - the front end. And then we'll
create a function called up date
1538:03 - contract addresses, which we
will await. And this will update
1538:07 - the contract addresses of our
front end. So let's make that
1538:10 - function. Do async function
update contract addresses, make
1538:16 - sure those are spelled the same.
So we'll say const NFT, market
1538:21 - place equals await ethers dot
get contract. And then yes, we
1538:27 - need to import const ethers
equals require hardhat, we'll
1538:30 - grab the NFT market place. And
then we're going to want to
1538:34 - write our files in here to
someplace in our front end code
1538:39 - for us, we're going to do in a
new folder constants. And we're
1538:43 - going to create a new file in
here called network mapping dot
1538:48 - JSON. And we'll have this just
be a JSON object which keeps
1538:52 - track of all of our deployments.
So if we deploy something to
1538:56 - rink V chain will keep a list
will keep a list of it will say
1538:59 - NFT marketplace will keep a list
of all the addresses of the IoT
1539:03 - marketplace, comma basic NF T,
right, and then I list of all
1539:08 - those right now we don't have
anything deployed. So we'll just
1539:11 - have it be an empty JSON object.
Now back in our deploy script in
1539:15 - the hard hat NFT marketplace
project, we're going to keep
1539:19 - track of that location. So right
at the top, we're gonna say
1539:22 - const. Front, and contracts file
equals, and we'll place where it
1539:29 - is according to your file setup.
So if I do cd dot dot slash,
1539:35 - next JS NFT, marketplace, free
code, Camp constants, network
1539:39 - mapping dot JSON, this is where
mine is. So you're going to want
1539:42 - to put it wherever your location
is in relation to your heart at
1539:46 - Mt marketplace Free Code Camp,
it's my front end contract file,
1539:49 - it's going to be right here. Now
that we have all that we're
1539:51 - going to get the chain ID. So
we're gonna say const, chain ID
1539:55 - equals network dot config dot
chain, id.to string. And we're
1540:01 - going to need to import network
from hard hat as well. And then
1540:05 - we're going to want to read from
this network mapping file to see
1540:08 - what's currently in there. So
we'll say const. Contract
1540:13 - addresses equals and we're gonna
do a JSON dot parse Fs dot read
1540:19 - file sync, front, and front and
contracts. File comma UTF,
1540:28 - eight. Now here's what we're
gonna say, if chain ID is in
1540:33 - contract. addresses, let's say
if this list of contract
1540:38 - addresses doesn't include the
marketplace, then added on,
1540:42 - we're gonna say if contract
addresses of chain ID of the
1540:46 - NFT. Marketplace will say dot
includes NF T, market, Mar get
1540:56 - place dot address, then so we'll
say contract address says chain
1541:02 - ID NFT marketplace, dot push NFT
marketplace dot address else
1541:12 - we're gonna say contract
1541:14 - address says of chain ID of NFT
marketplace, which is going to
1541:20 - be a new entry now equals NFT.
Market market place dot address.
1541:28 - So now we've updated our
contract addresses object and we
1541:31 - just need to write it back to
the network mapping. So now
1541:34 - we're gonna say Fs dot right
file sync front and contracts
1541:39 - file comma JSON dot string five
contract addresses and then at
1541:47 - the bottom we'll do module dot
exports dot tags equals and
1541:51 - we'll say all or front end. Now
what we can do is we can run
1541:56 - just this update front end
script with yarn hardhat deploy
1542:02 - dashed dash, network localhost.
And we only want to do this
1542:07 - update front end script. So we
say dash dash tags front end,
1542:11 - and we run this, and I ran into
an error FS is not defined, oh,
1542:15 - I forgot to do const Fs equals
require Fs stride again, cannot
1542:22 - set properties of undefined NFT
marketplace. Oops. And that's
1542:26 - because this line is off instead
of this line, sorry. Basically,
1542:30 - right now, what it's saying is,
it's saying, hey, this NFT
1542:32 - marketplace thing doesn't exist.
So we need to make it exists. So
1542:36 - now we'll say contract addresses
of chain ID equals a new entry
1542:41 - of NFT marketplace and adds its
first parameter, it's going to
1542:45 - be NF T, Mark gets placed dot
address, like that. Now we can
1542:52 - run it, and updating front end
looks like it's done. So if we
1542:56 - go back to our front end, we now
see we have an entry for
1542:59 - localhost with NFC marketplace
with the address in our network
1543:03 - mapping dot JSON. So if you did
that correctly, you should get
1543:05 - this. If not, if you're having a
hard time with that you can, of
1543:08 - course, just go ahead and hard
coded in but I do highly
1543:10 - recommend you do it
programmatically, because your
1543:12 - life is going to be a lot
better. So cool. We have this
1543:14 - update front end script that
works now, so we can put this
1543:17 - back off to the side. And let's
keep going. So we now have this
1543:21 - network mapping file with
contract addresses based off of
1543:24 - the chain ID. So what we can do
is we can pull that in as well,
1543:28 - we'll say const contract,
address says equals require dot
1543:35 - slash constants, slash network
mapping dot JSON. And now we can
1543:41 - get the contract address based
off the chain ID. So we'll say
1543:44 - chain ID equals process dot E
and V dot chain ID, or 31337. So
1543:54 - in our data and V, we'll make a
new entry called Chain ID. And
1543:59 - for now, we'll do 31337. And now
we can get the contract address
1544:03 - by saying contract address
equals contract addresses at the
1544:07 - chain ID of n, f t, Mark get
place of zero. So we're going to
1544:15 - go into that network mapping, go
to the chain, Id go to the NFT
1544:18 - marketplace and get the most
recently deployed NFT
1544:21 - marketplace boom. So now we have
the contract address contract
1544:24 - address says Excuse me. Now in
our add events, we'll create a
1544:28 - new function kind of similar to
what we're doing, we'll do async
1544:31 - function main. And this will be
our main function. And then of
1544:35 - course, we're going to copy
paste that main script thing
1544:38 - we've been doing this whole time
domain dot then catch blah,
1544:42 - blah, blah, we go back to the
morass documentation, though, we
1544:45 - can see we're going to need to
grab our server URL, app ID
1544:49 - master key, and then start it
up. So we're gonna do the exact
1544:52 - same thing. So once again,
sorry, before we even get into
1544:55 - our main, you can do it in your
main function, if you want.
1544:57 - We'll say const server URL
equals, and we can just grab
1545:02 - this once again, from our web.
So we'll say process web dot
1545:07 - next public Morales server URL,
we'll get the app ID equals
1545:14 - process Studien v dot next
public Morales app ID, and then
1545:21 - we'll say const, master key
equals process study v dot
1545:26 - master key. So we don't have a
master key in here yet. So we'll
1545:30 - create a new one called master
key. We'll go back to our
1545:34 - Morales front end, we'll close
out of this, we'll hit View
1545:38 - Details. And we'll grab that
master key. So we'll copy that,
1545:42 - go back to our code editor and
paste it in. And now we have a
1545:45 - master key in our web as well.
We don't want our master key on
1545:49 - our front end. So we're not
going to put next public like
1545:52 - that. Now, the first thing we're
going to do in our main function
1545:55 - is we're going to do await
Morales dot start server URL,
1546:00 - app ID and master key as the
input parameters for this will
1546:05 - do a little console dot log,
working with contract address,
1546:11 - contract address. Now we're
gonna go ahead and add all those
1546:15 - same pieces that we see on the
UI. So what are the events we
1546:18 - want to listen for? Well, if we
go back to our code here, so we
1546:23 - have our NFT marketplace, where
just type in event we have item
1546:27 - listed item bought an item
cancelled. So we have three
1546:30 - events we want to listen and a
Morales, they have this add new
1546:33 - events synced from code, which
we're basically going to be
1546:35 - following. To do this, we need
to obviously start and then
1546:38 - create our options for the
event. We have the chain address
1546:43 - topic, abi elimite, table name
and sync historical and then we
1546:47 - just do Morales dot Cloud dot
run, watch cloud event options
1546:51 - use master key. And that's
pretty much it. So we're going
1546:54 - to follow these documents here
to do our code. So let's start
1546:57 - with item listed. Let's create
some options for our IDed listed
1547:00 - event. So we'll say let item
listed options, or we could do
1547:05 - const if we want to, but I'm
just gonna do let item listed
1547:08 - options equals. And first we're
gonna need the chain ID, which
1547:12 - we have, because we're getting
it from Morales. Now the first
1547:16 - thing to point out about chain
ID is that ralis understands a
1547:20 - local chain is 1337. So even if
you're on 31337, if you're doing
1547:25 - a local development, you got to
switch it to 1337. So we're
1547:29 - going to make another variable
called Morales chain ID. And
1547:33 - we're just going to say, let
Morales chain ID equals chain ID
1547:41 - equals 31337. Question mark
311337. Otherwise, chain ID but
1547:52 - we're saying since Morales
understands that any local Dev
1547:55 - is going to be 1337, we're going
to say if chain ID equals 31337.
1548:01 - Then have Morales chain ID equal
1337. Otherwise have an equal
1548:06 - whatever whatever our chain
ideas and in our dot env we can
1548:10 - decide okay, if we want to do
rink B, localhost main net, etc.
1548:14 - We're gonna say Okay, chain ID
morass will do your Morales
1548:17 - chain ID, comma, we'll say what
else do we need? We did the
1548:20 - chain ID, we're gonna skip
description, a sync historical.
1548:24 - So hit sync historical allows
the node to go back throughout
1548:27 - the blockchain, grab all the
events ever emitted by that
1548:30 - contract. Since this is a very
small local blockchain will just
1548:34 - say sync historical is true.
Like that. Okay, what else do we
1548:40 - need? Okay, we need the topic,
the topic is going to be your
1548:43 - event information. So to get the
topic, go back to our event
1548:47 - code, and the topic is just
gonna be the name of the event,
1548:49 - plus the type of the parameters.
So we're gonna go back to our
1548:52 - code, we're gonna go back to
here, we're gonna say, topic is
1548:56 - going to be item listed, and it
takes an address, an address, an
1549:00 - address, you went to 56, and a
UNT 256, address address, you
1549:06 - interviewed six, YouTube and
six. Those problems seem like
1549:10 - that, we also need the API of
just the event, which again, we
1549:13 - can find we go back to our hard
hat project, we go to artifacts,
1549:18 - we go to contracts. And if the
marketplace dot soul NFT
1549:22 - marketplace dot JSON, our ABI
starting from here is going to
1549:26 - be the ABI of the whole
contract. And we just want that
1549:29 - item listed event. So we did
Ctrl F, and we found it here.
1549:33 - And we're going to grab from
right after it says type event,
1549:36 - we're going to copy we're going
to scroll up to write up to
1549:39 - anonymous false, right, so this
bit describes the ABI of the
1549:43 - event. So we have internal type,
address, name, seller type,
1549:47 - address, and if T address token
ID price item listed, right, so
1549:50 - this is going to be the ABI of
our just our item listed event,
1549:54 - we can take that and we just
stick it in here, hit save, and
1549:57 - mine auto format it to get rid
of the parentheses. Okay, what
1549:59 - else do we need, we have the
topic, we have the ABI, we
1550:03 - already have the address, we're
not going to do a filter. And
1550:05 - then we need a table name. So
we're going to do a new line,
1550:08 - we'll say table name, it's going
to be item listed. And this is
1550:12 - going to be the name of the
table that we update in our
1550:15 - database. So we're gonna get a
new table in here called item
1550:18 - listed, and it's just gonna be
filled with information about
1550:21 - the item listed event. And
that's it right and we would hit
1550:23 - confirm if we were doing this on
the UI. And since we're doing
1550:26 - here, we'll just hit save, this
is one of our events, we want to
1550:29 - do this for all of our events.
Let's do it now for item bought.
1550:32 - So we'll say let's, item bought
options, equals and we'll repeat
1550:37 - the process, some of the stuff
at the top is gonna be the same,
1550:39 - the chain it is gonna be the
same sync historical is gonna be
1550:41 - the same. So we can just grab
those two, paste them down here
1550:44 - for item, but the topic is going
to be different. The topic is
1550:48 - going to be item bot is the name
of the event, it's going to take
1550:51 - an address, an address, a un 256
and a un 256. The ABI is going
1550:59 - to be different. Once again,
we're gonna go to our Hardhead
1551:02 - NFT marketplace, we'll look for
a bot, you'd find this event
1551:06 - here. We'll copy this, go back,
we'll paste it in here, we now
1551:10 - have item bot, we'll give it a
table name of item bot. And then
1551:16 - one more then we have let item
cancelled options equals and
1551:24 - we'll do chain ID that's going
to be rouse chain ID gonna be
1551:29 - the same boilerplate from the
top address. Contract address
1551:34 - topic is going to be different.
The topic for this it's called
1551:37 - item cancelled, and it takes an
address, an address and a UNT
1551:42 - 256 will say sync. Historical
will be true, historical is
1551:48 - true. And then we need the ABI.
Once again we can go back to our
1551:52 - hard hat, compile information we
can look for item cancelled,
1551:57 - grab that ABI of that event.
Copy that. Come back to our
1552:03 - running code pasted in. Oops and
I didn't give item canceled.
1552:06 - Let's give item canceled the
1552:08 - table name, which will be item
canceled. So now if I zoom out
1552:14 - just a hair, I now have item
cancelled options, item bought
1552:17 - options. And item listed options
are telling Ross Hey, listen for
1552:21 - these events, whenever you hear
an item canceled event, stick
1552:25 - all this stuff into a database.
Whenever you hear an item bought
1552:28 - event, stick all this in a
database, whenever it emits an
1552:31 - item listed, stick all this in
in a database so that we can
1552:34 - read from it. So we're indexing
these events so that we can
1552:36 - query them much easier. Now to
send them up to our our server
1552:40 - will say const listed response
equals await or Alice or Alice
1552:48 - dot Cloud dot run, watch
contract event will pass the
1552:55 - item listed options. And then
one more comma, and then we pass
1553:01 - an object in here where we're
just gonna say use master key is
1553:05 - going to be true. And we'll do
the same thing we'll say const
1553:08 - bot response or passing the bot
item options. So we'll say bot
1553:13 - response equals await or else
dot Cloud dot run, watch
1553:19 - contract, event, comma, item
bought options. Comma, use
1553:28 - master key that's going to be
true. And then finally Kant's
1553:34 - canceled response equals await
oralis dot Cloud dot run, watch
1553:42 - contract event, comma, item
canceled options, comma use
1553:50 - master key is going to be true.
Now this Morales dot Cloud dot
1553:54 - run API call to our server that
we're making is going to return
1553:58 - a response. And let's look at
the docs to actually see what
1554:00 - that response looks like if it
worked out. Well. In the
1554:03 - terminal, you'll see success
true. So this is the return
1554:08 - we're getting from the API. So
just to make sure everything
1554:11 - goes well, I'll do an if listed.
response dot success, we're
1554:17 - getting that success object from
the rails server, we'll just do
1554:20 - a console dot log success
database updated with watching
1554:29 - events. And then else we'll say
console dot log, something went
1554:35 - wrong with a duck. And of
course, we're not just looking
1554:39 - for let's say response dot
success to be true. We also want
1554:44 - canceled response that success
and bots response
1554:50 - is successful. Then say hey, you
did it. Otherwise say hey,
1554:55 - something went wrong. So this is
how we're going to
1554:57 - programmatically tell our server
our database to listen for
1555:01 - events. So we just do await
Murata Clodagh, run, watch
1555:04 - contract events, we pass it this
object with all these parameters
1555:07 - and flags in there. And then
that's it. And then we can send
1555:10 - them is because I put next
public Morales server URL. And
1555:14 - in my DMV, I just have next
public server URL. So let's
1555:17 - change the name here. Looks like
our server URL was wrong. And
1555:20 - our app ID name is also wrong.
So let's fix that next public
1555:24 - app ID master key looks correct.
Okay, cool. So let's know things
1555:28 - right? More Alice, like cada
run, Rasta cloud run, when we
1555:32 - run this in our database, if we
hit refresh, right now, we don't
1555:36 - see those tables in here. But
once we run this, add events.js,
1555:41 - we should call our server and we
should tell it hey, you need to
1555:44 - add these tables. And you need
to start listening for those
1555:46 - events. So in a new terminal,
we're going to run this add
1555:49 - events such as, so I'm going to
make the terminal nice big. And
1555:53 - this is where if something goes
wrong, it can be a little
1555:55 - frustrating to figure it out how
to fix this. So if you run into
1555:58 - an issue here, if something's
not working as expected, please
1556:01 - use the GitHub repo associated
with this course. And also the
1556:04 - Morales forum is here for you,
and Stack Exchange Etherium. So
1556:08 - we're going to run Node, add
events, dot j s, and we'll hit
1556:13 - enter. Okay, boom, now we see
success database updated with
1556:17 - watching events. Now, if you ran
into an issue, and you rerun it,
1556:20 - and it gets something went
wrong, there's a chance that it
1556:24 - could still be correct, right,
because it returns false. It
1556:27 - returns that there's an issue if
any of these already have the
1556:30 - table in there. So if we go back
to our database here, and we hit
1556:34 - refresh, I can now see item
bought, item canceled and item
1556:38 - listed in my database. And
again, you can see them by
1556:40 - hitting the drop down on your
server and hitting dashboard. We
1556:44 - also see event Sync Status. And
this is how our database knows
1556:48 - that it needs to be listening
for some events, and it's got
1556:51 - all the information about how to
listen for our events in here.
1556:55 - So cool. So now we are listening
for events. This is fantastic.
1556:58 - So now what this means is our
database is now listening To our
1557:03 - blockchain node, and it's
listening for events in here
1557:06 - it's listening for these item
listed item bought item,
1557:09 - cancelled events. So let's go
ahead and test this back in our
1557:12 - hardhat NFT marketplace Free
Code Camp window. We have some
1557:16 - scripts in here. One of them is
mint and list. So we went to New
1557:20 - NFT. And we listed on the
marketplace when we list an NF
1557:24 - T, well, our mirallas database
should hear that item listed
1557:28 - event and go ahead and stick it
into this item listed table that
1557:32 - it made. So for us to test this
out, let's open up our terminal
1557:35 - in our Hardhead NFT marketplace
repo. And we'll run Minton list
1557:39 - for our localhost before we
actually run it, just be sure
1557:44 - that our hard hat node is synced
up with our Morales server in
1557:48 - order for your database to
actually grab that event. Your
1557:51 - local hard hat node needs to be
connected. So we'll do yarn,
1557:55 - hard hat run scripts, mint and
list.js dash dash, network
1558:01 - localhost. Let's enter. Okay,
minting, approving listing
1558:05 - listed now if we flip back to
our database, after a quick
1558:11 - refresh, what do you know, we
see that there's an indeed an
1558:15 - item listed events in our
database, we can see information
1558:18 - about a tool we can see there's
a block hash, a timestamp, we
1558:21 - see the token ID that was
listed, we see the price of the
1558:24 - listing the transaction hash, we
see all this information about
1558:29 - our event. And now it's in this
database for us to query. So if
1558:32 - you have reached this point, you
have successfully set up an
1558:35 - indexer with the Morales
database. And you should be
1558:38 - super pumped because this is
really powerful. And now we're
1558:40 - getting advanced, we're starting
to do some advanced stuff. So if
1558:43 - you've made it this far, huge
congrats. This is already really
1558:46 - cool. Now, some other
troubleshooting help here that
1558:51 - I've run into many times myself,
let's say I've left this
1558:54 - project, and I've killed my
heart hit note, I'm going to
1558:57 - kill it right now. If I stopped,
my heart had node and I come
1559:00 - back to my Morales admin, I'm
going to view details dev chain
1559:04 - proxy server, I'm now
disconnected. And if I hit this
1559:06 - little refresh, I'm disconnected
of course, because I'm not
1559:09 - running my heart headnote
anymore. If I restart my node,
1559:13 - my note is now restarted. My
connects local dev chain command
1559:16 - is still running. If I re fresh
it, it'll now say connected,
1559:20 - which is great. However, if I go
back to my blockchain, or if I
1559:24 - go back to my hard hat, NFC
marketplace script, I run yarn,
1559:28 - hard hat script, mint and list
again, network localhost, I go
1559:31 - back to my database now, and I
do a refresh, we don't see that
1559:35 - item listed in here. So our
mirallas server is looking to
1559:39 - make sure that that the
blockchain we're working with is
1559:42 - the same one. So if we reset our
blockchain, like we did, right,
1559:46 - we canceled it and we reset it,
our database is gonna get really
1559:50 - confused. So what we have to do
is we have to hit reset local
1559:53 - chain, reset local chain, we
want to make sure that our new
1559:58 - local chain is running, and that
we're connected here. So we'll
1560:01 - hit reset local chain, and this
will tell them Ross, hey, we
1560:04 - reset the chain, it's okay,
please continue doing so. And
1560:07 - once we hit reset local chain,
we're not going to see that item
1560:10 - listed in here. However, if we
go back, and we rerun mint and
1560:16 - list network, local host with
this reset local chain. Now, if
1560:21 - we go back to our Morales
database, we hit refresh, we now
1560:24 - see that new one has gotten in
anytime you stopped your hard
1560:27 - hat note, anytime you reset your
hard hat node, the takeaway is
1560:31 - you're going to need to go to
View Details dev chain proxy
1560:33 - server and reset local chain.
Now you can do that
1560:36 - programmatically as well, we're
not going to go over how to
1560:38 - programmatically do that. But
that might be something you want
1560:40 - to add to your hard hat deploy.
The other thing to note is that
1560:44 - it didn't clear out our last
event, right, the last event.
1560:47 - And if I go one minute and list
again, after completes, we'll
1560:52 - have another event in here.
1560:56 - Okay, this is great. So all of
this is being said, the reason
1561:00 - we're doing all this in the
first place is so that in our
1561:03 - index.js we can start listening
for events. How do we show the
1561:06 - recent listen entity. So now we
have a database of listed
1561:10 - entities. So what we could do,
we could just query this item
1561:13 - listed table right and grab
everything in here. However, we
1561:16 - have an issue here, what happens
if someone buys an NFT, if
1561:19 - someone buys an NF T, the item
listed event will still be in
1561:22 - our database. But technically it
won't be on the marketplace
1561:25 - anymore. It'll be gone, it won't
be listed. So what can we do,
1561:29 - there's a number of
architectural choices we can
1561:30 - make to get around this problem
to solve this problem. But one
1561:33 - of the things we can do is
actually we can use mirallas
1561:36 - Cloud Functions. So Morales
cloud functions allow us to just
1561:40 - really add anything we want our
front end to do from the morale
1561:44 - server. And these are functions.
These are scripts that are going
1561:46 - to run on a morale server
whenever we want them to. So we
1561:49 - go to our server hit the little
drop down and we hit Cloud
1561:52 - Functions. Now this is where we
can write somewhere else stuff
1561:56 - to run on our server whenever we
want. And we are going to set up
1562:00 - our Cloud Functions in our IDE
by hitting this little drop done
1562:03 - to actually sync up our Visual
Studio code with our Cloud
1562:07 - Functions, we can just run this
command here, and it will add
1562:10 - whatever cloud functions we have
in some cloud folder to here. So
1562:14 - what we can do back in our VS
code, let's make a new folder,
1562:18 - new folder called Cloud
Functions. And in here, we'll
1562:22 - create a new file called Update,
active items.js. So in here, if
1562:29 - we were to write something like
console dot log, hi, we can
1562:32 - actually have this automatically
saved on a morale server. And
1562:36 - the way that we do this is by
running this command. Now, we
1562:39 - want to make it so that it's a
lot easier for us to run this
1562:42 - command than just always having
to run this massive thing. So
1562:45 - what we're going to do is we're
going to open up our package
1562:47 - json, and we're going to make
another Morales script here,
1562:50 - right below here, we're going to
make another Morales script,
1562:53 - we're gonna say Morales Morales
cloud, and we're going to have
1562:57 - it, run this command. So we're
going to copy this command here,
1563:03 - paste it into our package json.
So it's going to be Morales
1563:06 - admin CLI, watch cloud folder,
we don't need the Morales API
1563:11 - key, because it'll grab that
from our environment variables.
1563:13 - We don't need them rouse secret,
because it'll grab that from our
1563:16 - environment variables, we do
need the morale subdomain
1563:20 - autosave one. And then the
Morales cloud folder is going to
1563:24 - be that new Cloud Functions bid
that we made that slash cloud
1563:30 - functions, functions. Now, in a
new terminal, if I run yarn,
1563:36 - more Alice cloud, which is going
to be same as running this huge
1563:40 - function here, I hit enter,
it'll say compile, you know,
1563:44 - version, blah, blah, compiling,
blah, blah, changes uploaded
1563:47 - correctly. And if we go back to
our front end, we can see this
1563:51 - console dot log ky and our front
end being updated. And if we
1563:54 - continue to run this in our
update active items at Jas, we
1563:57 - could also write console dot
log, you'll save it. And if this
1564:02 - is still running, it'll
automatically upload it. And now
1564:05 - we can see if we do a little
refresh on our front end Cloud
1564:08 - Functions, we can see it's been
uploaded here. Now at this
1564:11 - point, if you have a ton of this
stuff running, you might see CPU
1564:14 - 100 percent, you might see this little
thing pop up and the server
1564:18 - might start going a little bit
slower, we're starting to use a
1564:20 - lot of network activity here. So
I'm going to close my yarn
1564:26 - Morales cloud for now. And I'm
just going to upload it once
1564:29 - when I need to. Because we're
connected, we have it listening
1564:32 - to events, we're having it doing
more and more stuff here. And it
1564:35 - can start to put a lot of load
onto the server. So we're just
1564:38 - gonna go ahead and we're going
to cancel that out. And now the
1564:41 - CPU is a lot lower. But if we go
back to Cloud Functions, we can
1564:44 - see it's still in here. And
anytime we update our Cloud
1564:48 - Functions, it'll update our
server with those cloud
1564:50 - functions. And we'll just run
that darn morass cloud once
1564:53 - we're all done here. Anyways, so
right now we're trying to figure
1564:56 - out, Okay, we have item listed,
but if someone buys an item,
1564:59 - technically, it won't be listed
anymore. But our item listed
1565:04 - table will still have it listed.
So what we can do is we can
1565:06 - create a Cloud Function that
runs whenever we want. And like
1565:09 - I said, we can have these run
whenever we want. We can call
1565:12 - these whenever we want. But
we're going to create a Cloud
1565:14 - Function that only runs.
Whenever one of these events are
1565:17 - synced item listed item
cancelled or item bought, we're
1565:20 - going to create a new table
called active item, an active
1565:24 - item is going to say, okay,
anytime it's listed, it will be
1565:27 - active, but when it's bought or
cancelled will remove it from
1565:30 - the active item list. So we're
going to create a new table. So
1565:33 - let's go ahead and do that. We
started off with more Alice
1565:36 - thought. And then if you're IT
auditors that you don't need
1565:40 - this, we don't need to import
Morales here, because we're
1565:43 - going to upload it as a Cloud
Function. And our server already
1565:46 - just automatically injects
mirallas into our scripts. So
1565:49 - we're gonna say Morales dot
cloud, that after save, and
1565:53 - there's a whole bunch of stuff
you can do with your Morales
1565:57 - cloud. And again, you can find
these all in the documentation.
1566:00 - The after save keyword means
that anytime something gets
1566:03 - saved on a table that we
specify, we'll do something. And
1566:06 - it takes two parameters. So it
takes what table that we want to
1566:10 - do something after it's saved.
And we're gonna say item listed.
1566:13 - So we're saying anytime
something is saved to the item
1566:15 - listed table, we'll run some
async function.
1566:20 - And we'll put request in here.
Because anytime something gets
1566:23 - saved, it comes with a request.
So anytime an item listed
1566:27 - happens, we want to add it to
our active items list. And our
1566:31 - requests come with this is
flagged called confirmed. So
1566:35 - we'll say const confirmed
because every request, every
1566:38 - event actually gets triggered
twice. So once a transaction
1566:41 - goes through, it triggers a save
and then once again, once that
1566:45 - transaction is actually
confirmed, we actually only want
1566:48 - to update our active item when
the transaction is actually
1566:51 - confirmed. So we'll say const
confirmed equals request dot
1566:54 - object dot get confirmed.
Screening, get the confirmed
1567:00 - attribute from that request. And
then we're also going to make A
1567:03 - logger will say const logger
equals oralis dot Cloud dot get
1567:09 - logger. And you'll see why in a
second, we can actually write
1567:12 - logs to our Morales database
with this logs thing. So any
1567:17 - logs we can add into here, and
I'll show you that in a minute.
1567:20 - So console logger Morales dot
cloud, get logger. And then
1567:23 - we'll just do logger dot info.
1567:26 - Looking for confirmed x, and we
can actually test this right
1567:31 - now. Right, we can actually test
this right now. In our logs. We
1567:35 - should see looking for confirmed
TX Once an item listed and saved
1567:40 - now to test this out just to
test that our logger is actually
1567:42 - working. Let's run yarn, yarn
Ross cloud just update active
1567:47 - items to our to our morale
server changes uploaded
1567:50 - correctly. Okay, we'll kill it
now. And now in our where we
1567:54 - have our Minton, lists script.
Let's run Minton list. And we
1567:59 - should see on our server we
should get those logs. Now if we
1568:02 - go to our server, we do a little
refresh here. And if we look at
1568:05 - our logs now we can now see
looking for confirmed TX in our
1568:10 - server logs. Now in our logs.
Here we see we only see that
1568:13 - looking for confirmed TX once
and I just told you, it actually
1568:18 - triggers twice once when the
transaction is first sent. And
1568:21 - then once when the transaction
is confirmed, aka has block
1568:25 - confirmations. And additionally,
if we look in our database at
1568:28 - the item listed, and we scroll
all the way to the right, we can
1568:32 - see confirmed equals false. So
we only want to count this item
1568:36 - listed event interactive items
when confirmed is true. So what
1568:41 - we want to do actually is we
want to update our scripts to
1568:44 - add one block confirmation on
top of our local Hardhead
1568:47 - blockchain so that these can be
changed to confirmed now to get
1568:51 - around this. What I usually will
do in my mentalist script is
1568:55 - I'll add a new utility. So I'll
go to my utils, I'll do new
1568:58 - file, and I'll create a move
blocks.js. And this will be a
1569:04 - utility that I use to actually
move the blocks. So when we run
1569:09 - our own heart hat node, we
actually have complete control
1569:11 - over what we want our heart hat
node to do. So what we can do is
1569:14 - we can actually manually mine
nodes and actually move blocks
1569:17 - ahead so that Morales knows Oh,
okay, this transaction is
1569:21 - confirmed, right, because we're
mining the block with the
1569:22 - transaction. And that's it, and
Ross is just going to forever be
1569:26 - waiting for the next block. So
we want to add some
1569:29 - functionality to our scripts,
where we just mine a block after
1569:32 - it's done. Now, keep in mind
that if we mined like 1000
1569:35 - blocks or a ton of blocks really
quickly, Moorehouse might have a
1569:38 - hard time indexing that. So we
really want to just mined one at
1569:41 - a time and give me enough time
to index each block that we
1569:44 - mined. So we're actually going
to build a little script, we're
1569:47 - going to manually mine using
this EVM mine RPC method that
1569:52 - comes with our heart hat
blockchain. So we have this new
1569:54 - move blocks script. And let's go
ahead and make this. So instead
1569:57 - of this being our script, we're
going to have like a main
1570:00 - function at the bottom, we're
just gonna have this be a
1570:02 - utility that we're going to
import into other scripts. So
1570:05 - we're not going to need a main
function here, we're just going
1570:07 - to need to make this an async
function. And we'll call it move
1570:11 - blocks. And then we'll say
amount, which is going to be the
1570:14 - number of blocks, we want to
move, we'll also put a sleep
1570:18 - amount and default it to zero,
this sleep amount is going to be
1570:22 - an optional parameter. If we
want to move blocks and sleep
1570:26 - maybe a second between blocks to
resemble a real blockchain, we
1570:30 - can have that in here too. So we
can have it resemble a real
1570:34 - blockchain by sleeping every
time a block is moved or just
1570:37 - kind of waiting every time a
block has moved. So in our move
1570:40 - block scripts, we'll do console
dot log, moving blocks, dot that
1570:44 - dot, and we'll say for let index
equals zero, and we'll do a for
1570:49 - loop around the amount and call
that EVM. Mine in this for loop
1570:54 - index is less than amount index
plus plus a weight network. And
1570:59 - then we got to import network
oops, we got to import network
1571:02 - from hard hat here, await
network dot provider dot
1571:06 - request. And then we're going to
request the method e v, mime,
1571:13 - comma params are going to be
empty. And this is actually the
1571:17 - same way we can make raw calls
to our blockchain nodes. We
1571:20 - don't do a lot of this because
ethers abstract this under the
1571:23 - hood, but we're making a raw
call to EVM mine. Obviously, you
1571:27 - can't call EVM mine on a real
blockchain because you can't
1571:30 - just tell a blockchain node to
mine the next block. Since this
1571:34 - is our local hard hat node, we
can call the VM now we're gonna
1571:37 - say if sleep amount is greater
than zero, or just if sleep
1571:42 - mount, then we're also going to
have this script sleep or wait a
1571:47 - short duration. So up at the
top, we're actually going to
1571:49 - create a new function called
sleep, which is going to input a
1571:53 - time in milliseconds. And this
is going to return a new
1571:58 - promise, right? Because
remember, in order for us to
1572:01 - wait for some time we got to use
promises, which we've learned
1572:04 - before. And this promise is
going to take a function with
1572:07 - resolve as an input parameter.
And we're just going to say, set
1572:12 - timeout is going to be resolve,
comma, time in Ms. So the way we
1572:18 - can sleep in JavaScript is we
return a new promise. And we
1572:21 - just call this set timeout
function, which basically just
1572:24 - weights the time in
milliseconds. Now to actually
1572:25 - sleep. We'll say console dot
log, sleeping for sleep amount.
1572:32 - And then we'll do await, sleep,
sleep amount, and this is going
1572:37 - to be in milliseconds. So since
sleep returns a promise, we can
1572:41 - call it with await to say, okay,
wait for this sleep function to
1572:44 - finish. And the sleep function
is only going to finish when the
1572:48 - time in MS in time in
milliseconds finishes. So now we
1572:52 - have a function called move
blocks, which will actually
1572:55 - mined blocks on our local
blockchain, so that Morales can
1572:58 - get that block confirmation that
it's looking for now at the
1573:00 - bottom, we'll just do module dot
exports, move blocks, move
1573:05 - blocks, and then we'll also
export sleep as well, because
1573:08 - why not? Equals like that. Now,
what we can do back in our
1573:12 - Minton list, up at the top,
we'll say const, move blocks
1573:17 - equals require dot dot slash
utils slash move blocks. And
1573:24 - then we'll also import network
from ethers network. And the
1573:28 - down in our script. Just right
at the bottom, we'll just say if
1573:32 - network dot config, that chain
ID equals equals 31337 await,
1573:39 - move blocks, we'll say we'll
move to blocks and then we'll
1573:43 - also do sleep amount equals
1000. We'll wait one millisecond
1573:47 - between each block that we
mined. So sleep mount equals
1573:50 - 1000, which is going to be one
millisecond. Now let's even just
1573:53 - comment all this out for a
second. We'll just run this
1573:57 - script with only this live.
Right we'll pull this up the
1574:01 - yarn hard hat, run scripts,
mentalist dash dash network,
1574:07 - local host, we'll just move the
blocks move back to our front
1574:12 - end, we'll refresh, we'll go
look at item listed. We'll
1574:15 - scroll all the way to the right,
and now we see confirmed is
1574:18 - true. And now if we were to look
in our logs, we would see that
1574:21 - logging item happened twice.
Alright, so Let's uncomment this
1574:25 - and continue. Now that we have
this now that we're learning
1574:29 - about logging, now that we're
doing all this stuff, we can say
1574:32 - If confirmed, we're going to do
some stuff. If confirmed, we're
1574:35 - going to create a table called
active item and add this to the
1574:37 - active item table. So we're
going to do a little logger dot
1574:40 - info bound item. And we'll
create a new table and a new
1574:45 - entry in this table. So we'll
say const active item equals
1574:50 - more Alice dot object dot extend
ACC active item. This we're
1574:58 - saying if active item exists,
great grab it if not create it.
1575:02 - So we're going to create this
active item table if it doesn't
1575:05 - exist, if it does exist, great,
grab it. And we're going to say
1575:08 - const active item equals new,
active item. So we're going to
1575:13 - create a new entry in this
active item table that we're
1575:16 - creating. And we'll say active
item dot set. And we can set any
1575:22 - of the columns we want for this
new table that we're creating.
1575:25 - So let's give it a marketplace
address column. So we'll say
1575:28 - market place address. And this
will come from the request dot
1575:35 - object dot get address all of
these requests from events come
1575:41 - with the address that they're
coming from, which for us is
1575:43 - going to be the marketplace
address, we'll do active item
1575:46 - that set and if T address which
these events saved come with all
1575:52 - the parameters of our event. So
we'll say request that object
1575:57 - dot get NFT address will get the
price will say active item dot
1576:02 - set price is going to be request
dot object dot get price will
1576:09 - get the token IDs will say
active item dot set token ID
1576:15 - request dot object dot get token
ID and then we'll get the seller
1576:22 - will say active item dot set
seller is going to be request
1576:27 - that object dot get seller. So
we're getting all of this
1576:34 - information from our event. And
this event update from Ross
1576:39 - automatically always comes with
the address that the event was
1576:41 - omitted from. So we're gonna
grab all that we're going to
1576:43 - create this active item table.
We're going to add all these
1576:46 - rows. We're going to add this
one row with all these columns
1576:49 - in it. Awesome. Now we'll just
do logger dot info just to do a
1576:53 - little print out. We'll say
adding address. We'll do a
1576:56 - little string interpolation
we'll say request dot object dot
1577:01 - get address period token ID with
1577:07 - request dot object dot get token
ID. And I need to close this off
1577:14 - here, better. And then outside
of the logger dot info, we'll
1577:18 - just say logger dot info,
saving. And then we just run
1577:24 - await active item dot save. And
now we have cloud function
1577:30 - that's going to create a new
entry in a new table called
1577:34 - active item anytime item listed
happens. So after item is called
1577:39 - the trigger for our cloud
function, and there are a whole
1577:41 - bunch of different triggers for
different Ross Cloud Functions.
1577:44 - If you go to the Morales docs,
we look for trigger, we can find
1577:48 - a list of all these different
triggers in here, like after
1577:51 - save for Save. After save,
before delete, after delete,
1577:58 - before save file, there's all
these different triggers to
1578:01 - trigger this cloud code. Now, if
we upload this new script to our
1578:04 - morale server with yarn morass,
cloud changes uploaded
1578:07 - correctly, okay, great, we'll
kill it. Let's go to our cloud
1578:09 - server, do a little refresh just
to make sure that it's not still
1578:13 - processing that update. Okay,
CPUs low enough. Okay, great.
1578:16 - Now in our database, we don't
see an active item table in
1578:19 - here. But if we go back to our
Hardhead script, and we call
1578:24 - mint and list, since now we have
a Cloud Function that says okay,
1578:29 - anytime an item listed event
happens, update that active item
1578:33 - table, we should see active item
update. So let's run this. And
1578:37 - remember for all of this, we
need to have our heart head node
1578:40 - running connected to Hardhat.
And if we reset our local chain,
1578:43 - we need to click that reset
local chain button. So we went
1578:46 - ahead, we ran this. Now if we go
back to our database, we give it
1578:50 - a little refresh. And right now
I actually don't see anything.
1578:53 - So if I go to my logs go to
info, I can see any errors or
1578:58 - issues in here. So it looks like
after save failed for item
1579:01 - listed for user bla bla bla,
looks like there is an issue
1579:04 - cannot read properties of
undefined reading extend. And
1579:07 - that's also in the info, I made
an issue. I didn't quite write
1579:11 - all my code, right. And if we go
back to our update active item,
1579:15 - I can see where I messed up. It
should be Morales dot object
1579:19 - with a capital O dot extent. So
what I'm going to do, then run
1579:22 - yarn morass cloud again, now
that I have this correct, we're
1579:26 - going to cancel that, we're
gonna run our mminton list
1579:28 - again, now that we've fixed our
script. And now that we've fixed
1579:33 - our script, go back to our
database, we'll give it a little
1579:36 - refresh, I can now see we have
an active item entry in
1579:40 - here. Now at this point, there
are going to be times when you
1579:44 - don't want to leave and go get a
coffee, right, or go to the
1579:46 - bathroom or go get some food.
And you're going to want to stop
1579:49 - your terminals from running. So
let's actually practice
1579:52 - restarting everything and re
getting into this local
1579:55 - development environment. Because
it can be a little weird and a
1579:57 - little tricky. So let's practice
this. So once again, let's come
1580:01 - over here. And what do we need
to do? Well, we're going to Ctrl
1580:04 - C, we're going to kill our
blockchain Ctrl C, we're going
1580:08 - to kill our connection to our
Morales server. And if we're
1580:11 - running a front end Ctrl C, that
too, now if we go to our server,
1580:14 - we go to view details. Dev chain
proxy server, if we hit status,
1580:19 - this reset button here will
still we will be disconnected
1580:22 - now. And now everything has been
disconnected. Now if we want to
1580:25 - restart everything, if we're on
our heart hat NFT marketplace
1580:28 - will run yarn Hardhead node, and
that will spin everything up
1580:31 - again, we'll run yarn Morales
sync to sync back with our
1580:37 - routes connection, we can go
back to our server will do view
1580:40 - details and we should be
connected now. Connected. Since
1580:43 - we restarted our local
blockchain, we now need to
1580:46 - remember to do reset local
chain, we'll go ahead and run
1580:49 - that. Great. If we want to
restart our front end, we can
1580:53 - restart our front end like so
now the thing is, our database
1580:57 - will still have even when we
refresh it even though we reset
1581:00 - the local blockchain, it'll
still have all this stuff in it.
1581:02 - Now these entries in here are
entries from a blockchain that
1581:06 - no longer exists. So what I
often will do is I'll click this
1581:10 - button up here, and we'll just
delete all rows in this class.
1581:14 - To confirm we do active item,
read the name of the table. And
1581:18 - let's do it for item listed too.
We'll select that edit, delete
1581:21 - all rows, item listed. Yes,
delete. We'll do a little
1581:26 - refresh. Now everything is
zeroed out here. Now we have an
1581:29 - empty database for these events
in our after save here. And now
1581:32 - that we've added that little
weight in our script, let's go
1581:35 - back to our hard hat NFT
marketplace, we'll run yarn, RT
1581:40 - hat, run scripts, mint and list
dot j s dash dash network, local
1581:48 - host. This will mint it approve
it listed and then we mined two
1581:54 - blocks to give Morales time to
index our event and then on a
1581:57 - morale server. We go ahead and
refresh we now see item listed
1582:01 - as one and active item is One
all at the same time. So that is
1582:05 - how we're going to make sure
that Morales always indexes
1582:09 - whenever we call a function,
we're just going to mind one
1582:11 - additional block to tell Morales
Hey, that transaction has indeed
1582:15 - been confirmed. So really
exciting. And we got to practice
1582:18 - closing and restarting and doing
all that good stuff, too. So now
1582:21 - this is fantastic. Now that we
have this additional
1582:26 - functionality to make it a lot
easier for someone else over
1582:29 - okay, awesome, we can check
active item. Well, we're not
1582:31 - quite done yet, right? Because
what if somebody buys an NFT, or
1582:35 - sells an entity we should have
active item be removed? Right,
1582:38 - right now there's one item
listed in one active item. But
1582:41 - if we buy an item, active item
will still show that that item
1582:45 - is active. So let's go ahead and
let's update our cloud function
1582:49 - to also say, okay, anytime an
item is bought, we remove that
1582:53 - item from being active. So let's
create another after save. Let's
1582:57 - first built this for canceling
the item. And then we'll build
1582:59 - one for buying the item. So to
make another after save to make
1583:03 - another trigger, we'll say
mirallas dot Cloud dot after
1583:07 - save, we'll say item cancelled.
And this will be an async
1583:11 - function that takes the request
as an input parameter again, and
1583:15 - we're going to do the same
thing. We're gonna say const
1583:16 - confirmed equals request that
object dot get confirmed, we'll
1583:24 - say const. Logger equals routes
dot Cloud dot get logger, like
1583:29 - so. And then we'll do logger.
Oops, lowercase L. And then
1583:34 - we'll do logger dot info,
marketplace, the little pipe
1583:40 - object and then just request dot
object. And then we'll do the
1583:46 - same thing. If confirmed. If
this transaction is confirmed
1583:49 - after one block, we're going to
remove it from active item. And
1583:53 - we're going to be using a query
to first find that active item
1583:56 - that's getting cancelled. And
you can learn more about basic
1583:58 - queries in the Morales
documentation here. So we're
1584:00 - going to get that table by
saying const active item equals
1584:05 - more outlets that object for the
capital O object dot extend
1584:10 - active item. And we're going to
create a new query. So we're
1584:13 - going to query our table before
we actually set or save
1584:16 - anything. So we're gonna say
const, query, query equals new
1584:21 - Morales dot query of active
item. So we're going to query
1584:26 - our Morales database to find an
active item that's in there,
1584:30 - that's going to match the
request here, so we can cancel
1584:33 - it. So we'll say query dot equal
to
1584:37 - marketplace address, comma
request that object dot get
1584:44 - address, we're looking for an
active item where the
1584:47 - marketplace address is going to
be the same as the address of
1584:50 - the item cancelled. We'll say
query dot equal to NF T address,
1584:57 - comma request dot object dot get
an F T address will say query
1585:05 - dot equal to token ID, comma
request dot object dot get token
1585:14 - ID. And that should be it right?
So let's look again at our
1585:18 - contract here. And what is the
item canceled give us it gives
1585:22 - us a seller NFC address and a
token ID seller and ft address
1585:25 - and a token ID. And we're
looking for NFT address and the
1585:28 - token ID, we don't need to look
for the seller, we just need to
1585:31 - look for these two. And then of
course, the marketplace address.
1585:33 - So great. So now that we have
those two, we can say logger dot
1585:36 - info, and then we'll just print
out marketplace type query. And
1585:42 - then we'll just print out this
query that we're running. And
1585:45 - then we can say const, cancelled
item equals await query dot
1585:51 - first, we're going to find the
first active item in the
1585:54 - database that has the same
marketplace address and a T
1585:57 - address and token ID that just
got cancelled. So we're going to
1586:00 - find that first cancelled item.
We'll do a little bit more
1586:02 - logger information, we'll say
logger dot info, marketplace,
1586:08 - pipe, cancelled item. And then
we'll just do some string
1586:11 - interpolation. And we'll print
out that canceled item.
1586:14 - Cancelled item and we'll say if
cancelled item. So if the query
1586:20 - doesn't find anything, it'll
return undefined. So we're
1586:23 - saying if cancelled item which
will return true if it found
1586:26 - something. So if cancelled item,
then we're gonna say logger dot
1586:31 - info. Deleting and then we'll do
request dot object dot get token
1586:38 - ID at address, request dot
object dot get address address
1586:47 - space since it was canceled, so
we're going to do a little print
1586:51 - little logging here. Take the
leading that thing since it was
1586:55 - canceled and then we're going to
run a wait canceled item dot
1587:00 - destroy and that's when we
remove it from the active item.
1587:03 - And then we'll just say else.
Logger dot info, no item found
1587:09 - with address, request dot object
dot get address, and token, Id
1587:19 - request dot object, dot get
token ID. So cool. So now we
1587:24 - have this after save here, it
looks like my terminal
1587:27 - automatically added this require
in here, which we don't want. So
1587:31 - I'm just gonna go ahead delete
that. We can upload this to our
1587:34 - Morales server by running yarn,
Morales cloud and great changes
1587:38 - uploaded correctly. And now to
test this test that this is
1587:41 - working, let's create a new
script in our hard hat NFT
1587:45 - marketplace called cancel item.
So we'll go to scripts right now
1587:49 - we have mentioned list, we'll do
new file, we'll call it cancel
1587:53 - dot Jas. We'll do cancel item,
Jas. And this will be a script.
1587:59 - So we're going to use that that
main thing here, but we're going
1588:02 - to call our function cancel. So
we'll do async function cancel,
1588:08 - and then at the top, we'll say
const token ID equals Now let's
1588:12 - go to our active item list. And
let's find a token ID that's in
1588:17 - here. Okay, token ID zero. And
so we'll use this as the token
1588:21 - ID that we want to delete. So
we'll use token ID zero. So in
1588:26 - our cancel item.js script, we'll
say const token ID equals zero
1588:30 - and let's cancel it. So we'll
say const NFT. Marketplace
1588:34 - equals await ethers dot get
contract. And yes, const ethers
1588:39 - equals require hardhat. And ft
marketplace will say const basic
1588:45 - NF t equals await ethers dot get
gets contract. Basic NF team do
1588:54 - const TX equals await NF T
marketplace dot cancel listing
1589:02 - basic NF T dot address token ID.
And we're going to call cancel
1589:10 - item should be cancelled listing
we call the cancel listing. So
1589:14 - cancelled listing Yep, like
that. And it takes the address
1589:19 - of the NFT and the token ID. So
the basic NF T dot address and
1589:23 - the token D Okay, great. And
then we'll do a weight TX dot
1589:26 - weight one. And then we'll do
console dot log NFT cancelled.
1589:32 - And then we'll say if network
dot config dot chain ID equals
1589:39 - equals 31337. We'll go ahead and
we'll do a wait move blocks to
1589:47 - two and then we'll say sleep.
Mount equals 1000. And then
1589:52 - we'll just say const. Move
blocks equals require dot dot
1589:57 - slash utils slash move blocks.
Okay, cool. That looks really
1590:00 - good. So let's go ahead and run
this yarn hardhat run scripts
1590:04 - cancel item.js dash dash
network, local host and ft
1590:10 - cancelled moving blocks
sleeping. Okay, great. Our node
1590:14 - is running. Awesome. We're
connected to our mirallas we've
1590:17 - uploaded our cloud function with
yarn Morales cloud. Now if we go
1590:21 - back to our database, do a
little refresh. Looks like I
1590:27 - have an issue here. I go to my
info it says after save failed
1590:31 - for item Cancel for user blah
blah, blah. Here's the login
1590:34 - information. Morales dot cloud
apt get latar is not a function.
1590:38 - Uh huh. Well, that makes a lot
of sense. Get water. Let's do
1590:44 - let's make this get logger.
Shall we get logger to let's re
1590:48 - upload them. Changes uploaded
correctly. And now I'm going to
1590:52 - have to manually go to active
item I'm gonna have to manually
1590:55 - delete this one will have a
delete this row. Yes, delete, do
1590:58 - a refresh. And the reason I have
to do that is because it's
1591:01 - already been saved. And we're
doing an after save. So because
1591:05 - I messed up. If you spelt that
right, you probably did, right.
1591:08 - But because I messed up, we're
gonna have to rebuild a new one.
1591:10 - And then delete that new one.
I'm going to run yarn, hard hat
1591:14 - run scripts, mint and list
network localhost. And we just
1591:17 - meant to add a new one. Let me
check the Morales database,
1591:20 - we'll do a refresh. I can see it
in here, I can see it an item
1591:24 - listed. It has a token ID of
one. So let's go ahead and
1591:26 - cancel that now. So I'm going to
change my token ID and cancel
1591:30 - item to one. And now we'll run
that script Barnhardt at run
1591:34 - scripts cancel item, network,
local host run this NFT
1591:38 - cancelled moving blocks. Now
we'll go to the front end, we'll
1591:41 - do a refresh. And we can see
it's been removed from active
1591:44 - item programmatically, which is
great. So this is where these
1591:47 - logs can be really helpful. Now
it can be a little scary to do
1591:50 - things wrong on purpose, but
learning how to use information
1591:54 - like the logging and learning
how to debug effectively is
1591:56 - going to make you a lot faster
of a coder because guess what,
1591:59 - you're not going to be perfect.
You're going to run into issues
1592:01 - understanding how to use The Log
Understanding how to read the
1592:04 - errors is going to make you much
faster developer. So now we have
1592:07 - something for cancelled item,
we're also going to need
1592:09 - something for what? Well, you
guessed it for buying the item.
1592:12 - So let's make another one of
these murales to cloud that
1592:15 - after save. And we're going to
be using most of this same exact
1592:19 - code for item bought that we use
for item cancelled, we probably
1592:23 - should turn it all into a
function. But for practice,
1592:25 - we're just going to go ahead and
do it one more time, we'll do
1592:28 - Morales dot cloud. And then my
VS code keeps sticking this in
1592:32 - for some reason. I'm going to
undo that Morales dot Cloud dot
1592:37 - after save. Item bot is the
event. There'll be an async
1592:42 - request little arrow function
here, say const confirmed equals
1592:50 - request that object dot get
confirmed will get whether this
1592:55 - transaction is confirmed. We'll
get the logger I'm just going to
1592:58 - copy paste so I get it right
this time. So I'm going to copy
1593:01 - and paste those two lines const
logger equals Morales dot Cloud
1593:05 - dot get logger logger dot info.
And we'll say If confirmed const
1593:12 - active item equals Morales dot
object dot extend active item
1593:20 - const query and for this query,
I'm actually just going to copy
1593:24 - these lines because this is
going to be exactly the same.
1593:26 - We're going to look for the NFT
address and the token ID and the
1593:29 - marketplace address. And if we
look in our NFT dot soul and up
1593:33 - to marketplace dot som alright
and bot event as the NFT
1593:36 - address. And the token ID which
is what we want to find are
1593:40 - listed and of team. So we'll run
that query. We'll do const bots
1593:44 - item equals await query dot
first, and we'll do exactly what
1593:50 - we did before. If bots item then
logger dot info, deleting
1593:57 - request dot object dot get
object ID await bought item dot
1594:06 - destroy logger dot info deleted
item with Open ID request dot
1594:16 - object dot get open ID at
address request dot object dot
1594:24 - get
1594:26 - address. And then if we don't
find it will say else. Logger
1594:30 - dot info, no item found with
address request that object dot
1594:38 - get address and token, Id
request that object dot get
1594:46 - token ID. Cool. So that looks
good. Let's go ahead and upload
1594:50 - this to the cloud. So do yarn
oralis Cloud changes uploaded
1594:56 - correctly. Let's go make sure it
looks good on our server. So
1594:59 - we'll give a morale server a
little refresh. Go to Cloud
1595:03 - Functions here. I can see the
item cancelled in here still.
1595:07 - And now I can see the item
bought after save perfect. Looks
1595:11 - like I'm at 100 percent capacity. So
we're gonna give it a second
1595:14 - just to cool down thinking give
it a little refresh and looks
1595:17 - like we're back down after our
cloud function has been
1595:19 - uploaded. Okay, cool. To test
out that this part is working.
1595:23 - Let's go ahead we'll write
another script here. Do new file
1595:26 - by item dot j s. And we'll do
the same thing right now. On our
1595:31 - database. We don't have any
active items. So we'll just run
1595:35 - real quick. We're on mint and
list. Mint a new one. We'll go
1595:40 - check our database we'll do a
little refresh. Looks like
1595:43 - active vitamins in here with a
token ID of two now. So we'll do
1595:47 - is we'll buy that token ID so
we'll say const ethers network
1595:53 - equals require arhats const move
blocks equals require dot slash
1596:01 - utils slash move blocks const
token ID equals to async
1596:09 - function by item const NFT
marketplace equals await ethers
1596:19 - dot get contract NF T
marketplace const basic NF t
1596:26 - equals await ethers dot get
contract basic NFT coms listing
1596:36 - equals await and ft market place
dot get listing basic NF T dot
1596:43 - address and the token ID will
say const price equals listing
1596:51 - that price that to string and
we'll say const Tx and this is
1596:56 - us going to actually buy it
equals await and ft marketplace
1597:00 - dot buy item basic n f t dot
address, token ID, comma. And
1597:10 - then the value of course is
going to be the price. Do await
1597:13 - TX dot wait one, console dot log
bots NF t. And then if network
1597:21 - dot config dot chain ID equals
31337, then await move blocks to
1597:31 - comma, sleep amount equals 1000.
And then this is a script of
1597:37 - course, so we're going to use
the same stuff we're using for
1597:39 - cancel. But instead of
cancelled, it's going to be
1597:42 - called by item. So we have the
item inactive item here, we run
1597:47 - yarn, art hat run scripts by
item.js Dash network, localhost.
1597:55 - Now we can test buying this
item. Okay, Bob, the NFT looping
1597:59 - blocks, we'll do a little
refresh on our database, and
1598:02 - boom, we can see the active item
is gone. And we can see, the
1598:06 - item has now been bought.
Awesome. We're almost done
1598:10 - keeping our active item, just a
table of active items. But
1598:14 - there's one more thing we should
do. We're not going to test this
1598:16 - here. But if you want to test
it, we can we actually in our
1598:19 - NFT marketplace, go to
marketplace dot Sol, we actually
1598:23 - have an update listing function
as well, that also admits an
1598:27 - item listed. So we also want to
check to see if item listed is
1598:32 - coming from update listening. So
back in our item listed Cloud
1598:37 - Function, before we actually
start saving stuff, we want to
1598:41 - check to see if it already
exists. So we're gonna say so
1598:45 - we'll say const query equals new
mirallas dot query. And sorry, I
1598:52 - keep sticking the sin of active
item. And we're going to do
1598:56 - exactly what we've been doing.
We're gonna say query dot equal
1598:59 - to NFT. Address, we're gonna
look for the NFT address request
1599:04 - dot object dot get and ft
address, query dot equal to
1599:11 - token ID, request that object
dot get token ID, query dot
1599:18 - equal to marketplace, address,
comma request dot object dot get
1599:26 - address query dot equal to
seller requests dot object dot
1599:35 - get seller will say const
already listed item equals await
1599:42 - query dot first. And then we'll
say if this item has already
1599:47 - been listed. Then we'll go ahead
and say logger dot info.
1599:52 - Deleting already listed request
dot object dot get object ID.
1600:00 - And we'll do a weight already
listed item dot destroy. And
1600:06 - then do logger dot info, deleted
item with token ID request dot
1600:16 - object dot get token ID at
address request dot object dot
1600:24 - get address since it's already
been listed, if the object has
1600:31 - already been listed, we know
that it's coming from this
1600:33 - update listing function. So
we're going to delete it first,
1600:37 - and then we'll resave it with
its new price. So and let's just
1600:40 - go ahead, and let's upload this
to the cloud yarn Morales cloud.
1600:46 - upload this to our server
changes uploaded correctly.
1600:50 - Let's go check our server, give
it a little refresh. We'll go
1600:54 - check Cloud Functions. And it
looks like our item listed query
1601:00 - for deleting is now in here. But
with all that, we now have a way
1601:04 - to constantly have this active
item table only be the items
1601:09 - that are actively on our
marketplace without having to
1601:12 - spend any additional gas in our
application. And this is going
1601:15 - to be way better for user
experience because they're not
1601:18 - going to have to pay extra gas
to keep all these entities and
1601:21 - maybe an array or some more data
structures. If you've made it
1601:24 - this far. This is easily one of
the hardest parts of this
1601:28 - course, because we're working
with a ton of technologies.
1601:31 - We're working with a smart
contract, we're working with
1601:33 - Cloud Functions, we're working
with a back end database. Now if
1601:37 - you've made it this far, you
should be incredibly incredibly
1601:40 - proud. So now let's just go
ahead, let's mint and list one
1601:45 - more NFT. So we'll do we'll run
yarn heart at run scripts, mint
1601:50 - and list network local hosts
will meant it will list it or
1601:53 - sleeping. Let's go check our
database. We'll do a refresh. We
1601:56 - see the active item in here. And
now let's learn how to call all
1602:01 - of the objects in In our active
item database here, let's do it.
1602:06 - And remember, if you ever reset
your local blockchain, you're
1602:09 - gonna have to come in here and
delete all the rows in the
1602:12 - support tables.
1602:16 - With all that being said, it's
time to finally come back to our
1602:20 - front end, and come back to our
index dot J. S and answer this
1602:25 - question. How do we show the
recently listed NF Ts, we only
1602:30 - want to show the active NF t's
on the marketplace. And now we
1602:33 - have a system for getting only
the active ones, only the ones
1602:38 - that are currently on the
market, because we're indexing
1602:41 - these events. Now, I'm going to
delete all these comments here.
1602:44 - And let's do this. So what we're
going to do is we're going to do
1602:47 - this thing called use Morales
query. So if we go to the React
1602:50 - Morales docks, there is a hook
called use Morales query. And
1602:55 - this allows us to fetch and make
queries to our database in a
1602:59 - React context. Back in here,
we're going to say, import, use
1603:03 - Morales query from react
mirallas. Now, if you look in
1603:09 - the docs here, use mouse query
returns data error is loading.
1603:14 - And this will automatically run
this query the instant our index
1603:18 - pops up. So to get the data from
the query to get all of our
1603:22 - active items from our database,
we'll say const data, and we'll
1603:26 - rename data to listed and fts.
And then we'll also check to see
1603:31 - if this query is still fetching.
So we'll say is fetching and
1603:35 - then we'll rename that to
fetching listed NF t is equals
1603:42 - use Morales query. And inside
here, this takes two input
1603:46 - parameters, it takes the table
name to do the search on and
1603:49 - then it also takes a function or
the query. So the table name
1603:54 - that we're going to be looking
for is going to be active item.
1603:57 - And then the function for the
query is going to be we're going
1604:01 - to say query dot, we'll limit it
just to 10. So we'll say only
1604:06 - the first 10, we'll do it in dot
descending order, based off the
1604:12 - token ID. And then if we wanted
to do different pages, we could
1604:16 - do this thing called dot skip
with page numbers, we're not
1604:20 - going to do page numbers here.
So we're just going to leave it
1604:22 - like this for now. And that's
it. So we're saying, okay,
1604:25 - great, grab from our database on
the active item table, grab just
1604:29 - the first 10 in descending order
of the token ID. Now it's going
1604:33 - to save the result of this to
this listed NF TS section. Now
1604:38 - to see if this is working. Let's
just do a little console dot log
1604:43 - listed NF t's just to see what
this using Ross query actually
1604:47 - returns for us. And now we have
our local blockchain Node
1604:50 - running, we have our connection
to our Morales server, and we
1604:54 - have our front end running. So
let's go to our front end, we'll
1604:57 - do a little refresh here, we'll
right click and hit Inspect,
1605:00 - we'll go to the console. And we
see we have this array being
1605:04 - spit out here. Now the first
time it console dot logs, it's
1605:08 - empty. This is because when it
initially loads listed out of
1605:13 - T's hasn't returned yet. And
it's so it's actually just going
1605:15 - to be an empty array. But when
it finishes loading, we're going
1605:18 - to get an array of size one, we
get an array of size one,
1605:21 - because active item only has one
enter right now. So we get this
1605:24 - array of size one, and we can
see it index zero, we have class
1605:28 - name active item, we have the
item ID, we have all these
1605:32 - attributes, which are going to
be created at the marketplace
1605:35 - address. And if the address the
price, the seller and the token
1605:38 - ID this is exactly what we see
in our database here. So
1605:43 - Perfect. That's exactly what we
want to be able to show these NF
1605:46 - t's on the front end. So how do
we actually show this NFT and
1605:50 - list this NF T. For people who
aren't developers and aren't
1605:53 - going to go into the console dot
log? Well, what we're going to
1605:55 - be doing is in this return here,
we'll put some parentheses
1606:00 - around this. First, we should
check to see if we are fetching
1606:03 - those listed NF T's. So we'll do
some JavaScript stuff. And we'll
1606:07 - say fetching listed NF T's and
we'll do a ternary operator. So
1606:11 - we're gonna say if we are
fetching those NF T's, let's add
1606:15 - like a little div div that just
says loading that that done,
1606:19 - we'll put a little colon here.
And if we're not fetching, we'll
1606:22 - do we'll say listed NF TS dot
map. So dot map basically loops
1606:29 - through and does some function
on all of the listed entities in
1606:35 - the function we're going to want
ours to do. And it's going to
1606:37 - take each NF t as input
parameters. So we say we're
1606:41 - going to basically loop through
each NF T. And we're going to
1606:44 - say, console dot log and F T dot
attribute attributes with an S.
1606:50 - And then inside of these inside
of this attributes are the
1606:54 - different pieces that we want.
So we're going to get those
1606:56 - pieces we'll say const we want
to show the price. The NFT
1607:01 - address, the token ID in the
marketplace address, which of
1607:05 - course is just gonna be this
one, and then the seller, that's
1607:08 - all this information that we're
going to want to show on the
1607:10 - front end will say that equals
NF T dot attributes. So we're
1607:15 - going to pull these out, and we
can see price seller token ID,
1607:19 - etc. We're going to pull those
out of NF T dot attributes. And
1607:22 - we can show those by in this
function here, we'll say return.
1607:26 - And then we'll return some HTML,
we'll do like div div. And then
1607:30 - we can say like price, price,
price,
1607:34 - period, and f t address and ft
address, token ID, token ID
1607:44 - seller, then added this for some
reason. So I'm going to delete
1607:48 - that add $1 signs before all
these for some reason, delete
1607:52 - those, save. Now if I go to the
front end, I can now see
1607:56 - information about our NFT from
our database is listed here.
1608:01 - That's fantastic. We see the
price we see the address, we see
1608:04 - the token ID we see the seller.
Now if we go back to our NFT
1608:08 - marketplace, our little our
little hard hat MC marketplace,
1608:11 - let's mint another one. Yarn
hard hat run scripts mentalist
1608:15 - Dash network localhost, we're
going to run that it's going to
1608:19 - mint one more. If we go back to
our Morales database, we do a
1608:23 - little refresh on that active
item table, we now have a new
1608:27 - item in here. So if we go back
to our front end, we give this a
1608:31 - little refresh. And boom, now we
have two items in here. So this
1608:35 - is awesome, we now have a way to
actually show the most recently
1608:38 - listed NF t's on our
marketplace, plus ah.
1608:44 - Now, of course, you might be
saying to yourself, hey,
1608:46 - Patrick, that's cool and all.
But that looks really ugly. And
1608:51 - I would agree with you. But 100 percent
agree with you. So we should
1608:55 - come up with a component to show
our listed entities that looks a
1608:59 - lot nicer. So when instead of
returning and just printing out
1609:02 - the raw information, we probably
want to show the image, right,
1609:05 - we want to show the image, we
want to make everything look a
1609:08 - lot nicer. So we're going to
create a new component that
1609:10 - we're going to return in here to
format all of our NF T's
1609:13 - appropriately. So we're gonna go
to components, we'll do new
1609:17 - file, and we're going to call NF
T box dot j s. And this is where
1609:21 - we're going to grab all the
information on how to show what
1609:24 - our NFT actually looks like. So
let's get started working on our
1609:27 - entity box, we're gonna set this
up, the way we've been setting
1609:30 - all these up would do export
default function, and ft box.
1609:35 - Now something that's a little
bit different for this one,
1609:38 - though, is that in our index, we
have all this information. So
1609:42 - we're gonna need to pass all
these variables to our NFT Box
1609:47 - component. So to do that, we'll
add them as input parameters for
1609:50 - our component here. So we'll say
price, and if the address, token
1609:54 - ID, marketplace, address, and
seller. So right now on our
1610:00 - front end, we just have a whole
bunch of text, and we even have
1610:02 - this gross warning, we're gonna
get rid of that tip. And as we
1610:04 - know, tokens have their token
URI, which points to an image
1610:08 - URI or an image URL of what the
actual token looks like. So what
1610:13 - we're going to want to do is
we're going to want to call that
1610:16 - token URI, and then call the
image URI to show the image. So
1610:20 - we're going to actually have to
wait those two API requests to
1610:24 - get the actual image. And we're
going to save that image as a
1610:28 - state variable on this component
here. So as you already know,
1610:32 - we're going to work with use
state to keep track of that
1610:34 - image URI. So we'll do import,
use state from react like this.
1610:41 - And in here, we'll say const,
image, Uri, comma set image, URI
1610:48 - equals use state. And we'll
start it off as a blank string.
1610:53 - Now let's create a function,
we're going to call it update UI
1610:57 - to update our UI and grab this
token URI and the image URI. So
1611:01 - we'll create an async function
called Update UI. And in order
1611:06 - to get the image first, we're
gonna need to get the token URI,
1611:10 - and then using the image ag from
the token URI gets the image. So
1611:17 - first thing we're gonna have to
do is get the token URI. So we
1611:20 - know how to do this with use web
three contract. So we'll do
1611:24 - import, use web three contract
from react Morales. And as we
1611:29 - know, use web through contracts
is going to need some
1611:31 - parameters. So we'll say const
run contract function, get token
1611:38 - URI, equals, use web through
contract. First, we need the ABI
1611:44 - of the NFT because we're gonna
need to call token URI. So to
1611:48 - get the ABI we're gonna need to
once again update our front end.
1611:51 - So let's comment this part out.
We'll go back to our hard hat
1611:54 - piece. And let's look in our
deploy scripts. We have this
1611:58 - update front end right now. All
this is doing is updating calm
1612:03 - object addresses. Well, that's
good. We're also going to want
1612:05 - to add API's to our front end as
well. So let's create another
1612:09 - function in here called Update
API. And we'll pass the API's as
1612:12 - well. So we'll do async function
update API. And we'll give it
1612:17 - both the basic NFT API and the
NFT marketplace API, because
1612:22 - we're going to need both of
them. So we'll say const NF T,
1612:25 - marketplace equals await ethers
dot get contract. And f t
1612:32 - marketplace, we're going to
write the ABI to the front end
1612:35 - API location, we have the front
end contracts file. So let's
1612:39 - also do a const. Front and ABI
location equals, and we'll do
1612:46 - dot dot slash next, Jas, and if
T marketplace dash FCC slash
1612:54 - constants, and instead of
actually just giving the file
1612:56 - name, we can just give it the
front end API location. And then
1613:00 - we'll actually have it generate
that file for us because we're
1613:03 - just going to overwrite the ABI
file anytime we work with it. So
1613:06 - now that we have the
marketplace, we'll just do Fs
1613:09 - dot right file sync, and we'll
do front and ABI location, and
1613:16 - ft marketplace, dot JSON. And ft
marketplace, dot interface that
1613:26 - format ethers dot utils dot
format types dot JSON. So we're
1613:33 - also going to want to do that
for the basic NF t. So we'll say
1613:35 - const basic NF t equals await
ethers dot get contract basic NF
1613:41 - T Fs dot right? file sync, it's
going to be that exact same
1613:47 - place right here. Except for
it's going to be a different
1613:50 - location, it's going to be basic
NFT dot JSON. And of course,
1613:55 - we're gonna do a comma basic NF
T, that interface dot format
1614:00 - ethers dot utils, dot format,
types dot JSON, you can find
1614:05 - this NFT marketplace that
interface in the Hardhead
1614:08 - documentation. And you can find
this in the ethers
1614:11 - documentation. So now we have
this update ABI function. Let's
1614:15 - also add this to our module that
exports so we'll do a weight up
1614:19 - the ABI like that.
1614:23 - There's a hyphen here that
shouldn't be here. And we'll run
1614:25 - just this part of our hardhat
front end, run yarn, hard hat,
1614:31 - deploy dash, dash dash tags, the
tag here is front end, front
1614:36 - end. And now it's had nothing to
compile updating front end, it's
1614:39 - done. So if we go back to our
front end, now, we go to our
1614:42 - constants, we now see two
objects in here, which are going
1614:46 - to be API's, the basic NFT, and
the NFT. Marketplace. Awesome.
1614:50 - So now that we have that, we can
import those into our front end.
1614:54 - So we can say import, and if T
marketplace, abi from dot dot
1615:00 - slash constants slash NF T,
marketplace dot JSON. And we can
1615:07 - also get the NF T API. So we'll
do import NF T, abi from that
1615:12 - the slash constants slash basic
NF T dot JSON. Now in our run
1615:18 - contract function, our token URI
function is part of the NFT API.
1615:23 - So the API will be the NFT, abi,
the contract address
1615:29 - is going to be the address of
the NFT, which we're passing in
1615:32 - as a parameter. So we'll pass an
NF T address, the function name
1615:36 - is going to be token URI, and
the params are going to be the
1615:41 - token ID, which is getting
passed as an input parameter to
1615:45 - this function to this component.
Right. And we can double check.
1615:49 - We're good to our basic NF T dot
soul, right? We scroll down, we
1615:53 - have this token URI that we're
overriding. And this is the
1615:55 - function we want to call takes
the token ID. So this the
1615:59 - function we want to call takes
the token ID. Okay, great. So in
1616:02 - our update UI, first, we'll say
const, token URI equals await
1616:08 - token URI. Now let's do a little
console dot log token your eye,
1616:13 - just to see what this returns to
make sure that update UI is
1616:16 - called, we'll add it to a use
effect, we'll say use effect.
1616:20 - And this takes an input
parameter of a function to do,
1616:23 - we'll just say Update UI. And
then we'll only have this run
1616:28 - anytime is web three enabled
changes. So we want to run
1616:33 - update UI, but we want it to be
dependent on is web three
1616:36 - enabled. And then we'll say if
it's web three enabled, then
1616:41 - update UI. So we need to add use
effect as well. So we're using
1616:44 - use state, we'll do comma, use
effect. And now we should at
1616:49 - least be reading our token URI
off the blockchain. We're not
1616:52 - going to set the image yet,
right, because we're going to
1616:54 - get the image URI from the token
neuron. Let's add this NFT box
1616:58 - to our index to see if it's
working well so far back in our
1617:02 - index Next, up at the top, we
will import NF T box from dot
1617:09 - dot slash components slash NF T
box. And down here, while we're
1617:14 - returning this will add our NF T
box component will make sure to
1617:18 - pass in all the parameters it
takes. So the price is going to
1617:21 - equal that JavaScript price. And
ft address is going to equal the
1617:27 - JavaScript entity address. The
token ID is going to equal the
1617:31 - token ID, marketplace address is
going to be marketplace address
1617:39 - seller is going to be the
seller. And you saw that warning
1617:43 - where it's saying, hey, all the
components need to all the
1617:45 - things in the mapping need to
have their unique key. So we'll
1617:49 - say key, we'll give these all a
key as well. We'll say key
1617:52 - equals this, we'll do some
string interpolation, we'll just
1617:55 - say the NFT address, combined
with the token ID can be the
1617:59 - key. So if we save that, go back
to our front end here, do a
1618:03 - little refresh marketplace
address is not defined market
1618:08 - place address. So let's make
sure we spell things right,
1618:11 - let's go back to the front end,
we'll give it a refresh is what
1618:14 - three enabled is not defined.
Oops, excuse me in the NFT box,
1618:17 - we need to grab that from us
Morales, so we'll import use
1618:20 - Morales. And in our ponents here
we'll say const is web three
1618:27 - enabled equals use Morales.
We'll save that. And one thing I
1618:33 - noticed actually is this needs
to be wrapped in squigglies.
1618:36 - Sorry, I forgot to do that. Our
component actually just takes a
1618:39 - props, props input parameter.
And we would need to do like
1618:42 - props that token ID to get token
ID. But instead, we just extract
1618:46 - it out by doing putting the
little squiggly brackets here.
1618:50 - So put the squiggly brackets
there. Great, we'll do a little
1618:52 - console dot log token, your eye,
or index.js has everything
1618:56 - updated. Here. Let's do a little
save. And we can even say if is
1619:00 - web three enabled up the UI.
Like that we'll save we'll go to
1619:05 - the front end, we'll do a little
refresh. We'll see if
1619:07 - everything's working as
expected. And as long as we're
1619:10 - on that hard had localhost and
our meta mask. And again, you
1619:13 - can ignore this error, this
warning that's up here for now.
1619:16 - And if you click this, and you
have your IPFS and brave or your
1619:20 - IPFS companion, we can now see
we're getting our token URI,
1619:24 - which is perfect. The piece that
we want now is this image bid.
1619:27 - And for this one that I'm using
it is an HTTPS, which
1619:30 - technically isn't decentralized,
right, we would need it to come
1619:33 - from instead of HTTPS, we would
need to come from IPFS colon
1619:37 - slash slash but but actually
having it as HTTPS ipfs.io. For
1619:42 - now was good, we'll explain why
in just a second. Now that we
1619:45 - are getting the token URI, we
can call this URL, and we can
1619:50 - get back the image that we want
to actually show on the front
1619:54 - end. So in here, we'll do a
little console dot log, the
1619:58 - token, URI is string
interpolation, like this, and
1620:04 - then we'll say if token URI,
we're going to need to now grab
1620:08 - this token URI, and get the
image from it. And this is where
1620:12 - we're going to get a little bit
funky. And we're going to cheat
1620:14 - a little bit. Now for our
application, not everybody is
1620:17 - going to have IPFS companion,
not every browser is IPFS
1620:22 - compatible. So we're gonna have
to actually cheat a little bit
1620:26 - here, we're actually going to
change the token Uriah from its
1620:29 - IPFS edition to an H HTTPS
edition. And this is known as
1620:34 - using an IPFS gateway, which is
a server that will return IPFS
1620:42 - files from a normal URL. So
we're going to use an IPFS
1620:47 - gateway, which we can just make
regular HTTPS calls to, and it
1620:52 - will return those IPFS files. So
technically, are we making the
1620:55 - centralized doing this? Yes. And
is that ideal? No. However,
1620:59 - until the world adopt IPFS, and
until the world adopts the
1621:02 - standards, it's kind of what we
have to do right now. Because
1621:05 - otherwise, the front end will
just show up as blank to them.
1621:07 - And we can't have that we don't
want that. So we're gonna say
1621:10 - const request URL equals token
URI dot replace IPFS, slash
1621:18 - slash with HTTP s, HTTPS.
1621:25 - slash slash ipfs.io/ipfs/so.
We're saying, if you have a
1621:28 - token URI that starts with IPFS,
that's great. But we're going to
1621:32 - switch it to using an IPFS
gateway. It's really use the
1621:35 - IPFS gateway provided by the
team that builds IPFS. So pretty
1621:41 - reliable gateway is is kind of a
cop out. Yes. Are our files
1621:44 - still on? IPFS? Yes. So it's not
the end of the world. But this
1621:48 - is just going to make calling
these API's a lot easier for us.
1621:52 - And we're going to say const
token URI. Response equals
1621:59 - await. And this is going to be a
little weird. We're going to do
1622:02 - two awaits. await a weight fetch
request, URL dot JSON. So fetch
1622:10 - is a keyword you can use in
JavaScript to fetch or get a URL
1622:15 - fetch keyword is essentially
doing the same thing as pasting
1622:18 - this into the browser, like so.
And getting this JSON response.
1622:22 - So we await to get the response.
And then we await to convert the
1622:25 - response to JSON. And that's how
we get the toggle response. So
1622:29 - we now have this object in our
JavaScript, which is perfect
1622:33 - because this object has this
image attribute that we want. So
1622:37 - we're gonna do the same thing we
did here, we're gonna use the
1622:39 - IPFS gateway, this one's already
using HTTPS that ipfs.io. But if
1622:44 - it wasn't, we would still want
to convert it. So now we're
1622:46 - gonna say const. Image URI
equals token you are i response
1622:53 - dot image. So we're gonna get
the image tag of this response
1622:58 - here. And then we're going to
say const. Image URI URL, is
1623:04 - going to equal to, and we're
gonna do the exact same thing
1623:06 - that we did up here, we're going
to use the gateway image URI dot
1623:10 - replace IPFS, colon slash slash
with HTTPS ipfs.io/ipfs. And
1623:19 - now, and that's how we get this
URL right here. And so we can
1623:24 - finally do set image URI, to
that image URL. And now we have
1623:32 - our image URI is going to be
that image right here. Now, is
1623:35 - this a little bit wonky? Yes.
Are there better ways that we
1623:38 - can do this? Yes, there's
actually a number of better ways
1623:40 - that we could do some of this,
we could actually, since we're
1623:43 - using Morales, we could render
image on our server and just
1623:47 - call our server, what else could
we do well, or test nets and
1623:51 - maintenance routes actually
comes with a bunch of hooks like
1623:53 - us NFT balance that will show us
an F TS show us how many NF T's
1623:58 - shows all this information about
NF T's but it only works on test
1624:02 - nets and main net, we'd have the
world adopt IPFS. So we don't
1624:05 - have to do this wrapping.
Unfortunately, it doesn't yet so
1624:08 - such as life. But now that we're
setting the image, alright, we
1624:11 - have this image URI, we have
what this actually looks like,
1624:14 - we're going to have this and if
we click on this, we use this in
1624:17 - our browser, it returns this
dog. So now we have the image
1624:21 - URI in our website, we can
finally use it to show what this
1624:25 - is going to look like. So
finally, we can create a return
1624:29 - in here. So down below, we'll do
return to a little div. And then
1624:33 - we'll do another div just
because I want to. And we can do
1624:36 - some JavaScript, we can say if
if that image array exists,
1624:39 - we'll do some stuff. Otherwise,
we'll do some other stuff. So if
1624:43 - it doesn't exist, maybe we'll do
a div for now. div that just
1624:47 - says loading dot the dot. And if
it does exist, for now, we'll
1624:52 - just say, just do a little div,
close the div. And we'll just
1624:57 - say found it. Now if we go back
to our front end, let's see if
1625:01 - we're good here.
1625:03 - Uh huh. If I do a refresh, we
see found it for both of these
1625:07 - NF T's. Okay, cool. So how do we
actually show these NF T's, we
1625:12 - finally have the URL that we can
use to show the NF T's. But we
1625:15 - want to actually use them next.
Jas actually comes with a
1625:18 - component called the image
component that we can use to
1625:21 - render images really easily just
by using a URI. Now, because
1625:26 - we're going to use this image
tag, and because it does some
1625:28 - optimizations on the back end,
that means that this website
1625:31 - won't be able to be deployed to
a static to a static site, like
1625:36 - IPFS. Because now our website
requires a server technically,
1625:40 - requires a server just because
we have Morales. So that might
1625:43 - be another reason, we might not
want to, since we're using this
1625:46 - image tag, we can't deploy this
statically to something like
1625:49 - IPFS is we're going to up at the
top, we're going to import image
1625:54 - from next slash image. And we're
gonna down here we're going to
1625:59 - say, instead of founded, we're
gonna go Image, we're gonna
1626:04 - close it off here, too, we're
gonna give a loader of just a
1626:08 - blank function that just gives
us the image URI. Don't worry
1626:12 - too much about loader. For now,
we're gonna say the source of
1626:15 - the image is going to be the
image URI. And then we'll give
1626:18 - it a height of maybe 200. And
then we'll give it a width of
1626:23 - also maybe 200. And if we did
this right, after we save, we
1626:27 - should see the image on our UI.
So we'll go back to our website,
1626:30 - and oh, my goodness, we can see
the dogs holy cow. This is
1626:35 - getting really exciting. We can
see the puppies, we can see the
1626:37 - images, we're definitely doing
something right here, which is
1626:40 - really exciting. Now I know I
said this before that this isn't
1626:43 - a CSS. This isn't a formatting
tutorial, because that's
1626:47 - definitely not my expertise.
However, let's make this look a
1626:50 - little bit nicer. And we're
going to use once again, the web
1626:53 - three UI kit, because the web
three UI kit has a whole bunch
1626:56 - of tools that are really, really
helpful for us to use. So if we
1626:59 - go to the web three UI kit, we
can go to that live storybook
1627:03 - Another interactive bit, and we
can scroll down to the section
1627:07 - that has called card. Or we can
make these little clickable
1627:10 - cards and we can display some
information about our nfts. So
1627:14 - let's go ahead and at the top,
we'll do import import card from
1627:20 - web three UI kit. And now
instead of just showing the
1627:24 - image, we'll wrap the image in a
card like this. We'll save that.
1627:29 - Now back on our front end, give
it a little refresh. Now we've
1627:34 - got this kind of clickable
section that looks a little bit
1627:37 - nicer. We'll even label it. And
we can even label it with a
1627:40 - title and description. Now we
can grab the title and the
1627:43 - description from the token URI
response. So up at the top,
1627:48 - let's go ahead, let's grab the
title and the description of the
1627:51 - token UI as a state variable. So
we'll say const, token name, set
1627:56 - token name, equals use state,
start off as blank, the const
1628:02 - token description, that token
description, equals use state.
1628:10 - Start off as blank to download,
we do this update UI bit, we'll
1628:14 - call set token name. So we'll
say name is token, your response
1628:21 - dot name, we'll say set token
description, which will be
1628:26 - token, your response dot
description. And then we'll use
1628:30 - those descriptions and title in
the cart. So we'll say title
1628:34 - equals token name, description
equals token description. Save
1628:43 - that. We'll look at our front
end here. Give it a little
1628:46 - refresh. Oh, and now we have the
name of the NFT. And its
1628:50 - description on our front end.
Okay, cool. Let's keep going.
1628:52 - What else do we want on this?
Well, we probably want who it's
1628:55 - owned by. So we'll put a little
div inside the card, say div,
1628:59 - maybe we'll even put the token
ID we'll do a little number.
1629:02 - With the token ID.
1629:05 - We'll do another little div, and
then we'll make this italic.
1629:08 - We'll say class name equals
italic. And then text is going
1629:13 - to be small. And we'll say owned
by, and this is where we can get
1629:17 - the seller that we're passing in
as an input parameter. And then
1629:20 - maybe underneath the image, we
want to put the price. We'll do
1629:23 - a little div here. And then
we'll say price like this.
1629:27 - However, we're probably don't
want it in way we want it in
1629:30 - human readable units. So we'll
import ethers, we'll say import
1629:35 - ethers from ethers. And then
instead of just showing the
1629:40 - price, we'll do a little, little
JavaScript and here we'll do
1629:44 - ethers dot utils dot format,
units, price, price and ether.
1629:50 - And then we'll do space eath.
And then we'll make this be
1629:53 - class name equals font bold, so
we can read how much it's listed
1629:59 - for on our marketplace. Let's go
back a high we can now see, this
1630:03 - is token ID number four. We can
see who it's owned by we'd see
1630:07 - the price of it and then more
information about the dog. Yay.
1630:10 - Now let's format all this stuff
in here a little bit nicer. So
1630:13 - let's wrap everything in a div
in one more div. And that will
1630:17 - say class name is going to be
flex. And this is going to help
1630:20 - format everything, we'll put
everything in a column items and
1630:25 - get to. And now if we look back
there, kind of like in a column
1630:28 - now, wrapping one more div, give
them some padding, last name
1630:33 - equals P to say a little bit
padding has been added. Okay,
1630:36 - nice. And then we'll go back to
our index, and we'll add some
1630:40 - formatting to our index here. So
our main one, we're going to
1630:44 - remove styles dot container,
we're just gonna say container.
1630:48 - MX auto, we're going to make an
h1 in here, class name, equals,
1630:55 - I form E X for font bold text to
XML. This is we're just gonna
1631:07 - say recently listed, then we're
going to do another div. Class,
1631:13 - name equals flex, flex wrap.
We're going to end this div
1631:20 - around our JavaScript here. And
let's look at our UI. And let's
1631:23 - see what that does. Okay, cool.
Let's go back to our index.
1631:26 - Let's remove all this stuff.
Since now we're adding that to
1631:28 - the card. Let's save. Now it's
looking a lot better, we finally
1631:34 - able to start listening our NF
Ts and then have them show up on
1631:37 - our marketplace like we see
here. Fantastic. Okay, if we go
1631:41 - to the readme homepage show
recently listen to empties. Oh,
1631:44 - my goodness, this is a check
we're done here. Now, and I know
1631:48 - what seemed like a lot of work,
but a lot of it was setting up
1631:50 - that morale server correctly.
And because we have our own back
1631:53 - end, now, we have some back end
services that we needed to
1631:56 - configure. But now that
everything's set up, the rest of
1631:58 - this is going to be easy St. Now
we are only going to want this
1632:02 - to show if we're connected to
web three. Right? Now, if we
1632:05 - click this, this still shows up.
So we're going to have to update
1632:09 - this a little bit. And in our
index.js, we're now we're
1632:14 - checking to see fetching.
Listen, NF T's right before
1632:18 - that, right? Before we do that
we actually want to see is web
1632:22 - three enabled. And this is going
to be a little bit of nested
1632:25 - tertiary operations. If web
three is enabled, then we're
1632:28 - going to do all this fetching,
listed NF T's stuff here. We're
1632:31 - gonna do everything in here. So
if it's not enabled, let's do
1632:35 - like a little div that says web
three, currently not enabled.
1632:42 - And of course, we're going to
need to grab is web three
1632:45 - enabled. So we're going to say,
for the top we'll do const is
1632:49 - what three enabled equals use
oralis as we've been doing, and
1632:53 - we're going to grab use Morales
from react Morales, we'll save
1632:56 - that go back to our front end,
give it a little refresh. If
1632:59 - we're connected, we'll see the
marketplace. If we disconnect,
1633:02 - we see web three currently not
enabled, which is what we want.
1633:06 - Perfect. So what is next in our
readme. If you only NFT, you can
1633:10 - update the listing. Let's first
let's figure out if somebody
1633:13 - actually is the owner of these
entities. Let's make it really
1633:16 - easy for the people on this
website. Well, first we can get
1633:19 - the person's Metamask by
grabbing the account from us
1633:23 - mouse, so we'll do a comma
account. So then we can easily
1633:27 - just do const is owned by user
equals seller equals equals
1633:34 - equals account. So the seller
we're getting from the contract,
1633:38 - the account we're getting from
whoever's connected here, if the
1633:41 - seller equals the account, there
is no seller equals equals
1633:45 - equals undefined. We'll just say
they're owned by you. And now
1633:50 - instead of saying owned by
seller, we can say const,
1633:54 - formatted seller address equals,
and we'll do the ternary
1633:59 - operator will say if it's on by
you, then we'll just say you
1634:04 - instead of seller. Otherwise,
we'll say seller. Now we'll say
1634:08 - owned by formatted seller
address like this. So if we go
1634:11 - back to our front end, we do a
little refresh. depending on
1634:16 - who's connected, you might see
owned by blah, blah, blah. Now
1634:19 - if I go to my Metamask, let me
go ahead and switch account to
1634:22 - account three, let's go ahead
and connect our account three,
1634:27 - we now see owned by you instead.
Right, and we can even switch
1634:31 - again, we'll switch accounts
again, we'll switch to account
1634:35 - one, we now see owned by blah,
blah, blah, like so since when
1634:38 - we switch back and forth, the
diameters of this actually
1634:41 - change which is really annoying.
So maybe we want to go one step
1634:44 - further. And we want to truncate
this seller address make it a
1634:47 - little bit smaller. So we want
to make a seller a little bit
1634:51 - smaller. So let's create a new
function. And we can create this
1634:54 - outside of the export default
function because this is going
1634:57 - to be a function that doesn't
depend on anything inside our
1635:02 - app. It's just going to be kind
of a raw function. So we're
1635:04 - going to create we'll call it
const truncate string, and this
1635:08 - is going to be a function that
takes a full string, and a
1635:13 - string length as parameters. And
we're just going to pass the
1635:17 - seller address and how long we
want to make this string. So
1635:20 - this is going to be an arrow
function we're going to do here,
1635:22 - and we're gonna say, if all
string dot length is less than
1635:27 - or equal to str Lang, return
full str. Otherwise, we'll say
1635:32 - concept ra torx equals three
little dots. And we'll say,
1635:38 - Let's separate Tor length equals
Sep. Ra Tor dot length. To make
1635:46 - con separator length, we'll say
const chars to show is going to
1635:52 - be the the string length minus
the separator length, we'll say
1635:58 - const. Front chars or front
characters is going to equal
1636:03 - math dot ceiling chars to show
divided by two const back chars
1636:10 - is going to equal math dot
floor, chars to show divided by
1636:15 - two. And if you don't understand
this math here, don't worry
1636:18 - about it. And then we're gonna
say return full string
1636:22 - substring of zero to front chars
plus the SEP IRA tour plus full
1636:31 - STR dot substring. of full STR
dot length, minus back chars.
1636:38 - And now what we can do is we can
grab this truncate STR this
1636:41 - truncate string and for is
formatted seller will say if
1636:45 - it's you will still do you but
otherwise we'll do truncate
1636:49 - string of seller or blank if
there's no seller, and we'll
1636:54 - have it be size 15. And now if
we save that, go back to our
1636:57 - front end, if it's owned by you,
it's still gonna say on by you.
1637:01 - But if we switch accounts, and
now says owned by, you know,
1637:05 - blah, blah, blah, dot the dot
blah, blah, blah with a
1637:07 - truncated address. And then
these sizes don't actually
1637:10 - change, which is a lot nicer
than them getting bigger and
1637:13 - smaller. So awesome. So now we
have this formatted even better.
1637:17 - Okay, now what do we want to do?
Well, now that we know who owns
1637:23 - the NFT, NF T, and it's
formatted pretty nicely, we need
1637:27 - to figure out a way to update
the listing. So what we want to
1637:30 - do is, once again, if it's owned
by us, and we can switch back to
1637:34 - the account, it's owned by if
it's owned by us, when we click
1637:37 - on it, we want to be able to
update the listing on the
1637:40 - marketplace. So to do this,
we're going to create a new
1637:43 - component called Update listing
ngModel. So we're gonna create a
1637:48 - new component, new file, update,
listing ngmodel.js. A ngModel is
1637:56 - something that like pops up. So
for example,
1638:00 - this little pop up here is known
as a modal. And this is what we
1638:03 - want to build. If it's owned by
us, when we click this, we want
1638:06 - it to pop up this modal thing.
So to get started, we'll do the
1638:09 - same thing we've been doing for
all of our components here,
1638:12 - we'll do export default,
function, update, listing
1638:18 - ngModel, like so. And we're
probably going to want to pass
1638:22 - it these parameters from the
entity box, probably gonna want
1638:25 - to pass these parameters. So the
ngModel knows what function it
1638:29 - needs to call in our NFT
marketplace. The way we're going
1638:32 - to update listing is we're going
to call this update listing
1638:35 - function where we need the
address token ID and then some
1638:38 - new price. So we're going to at
least need those. So we're going
1638:41 - to need the NFT address, and at
least the token ID to make this
1638:46 - little pop up, we're not going
to code it ourselves, we're
1638:48 - going to once again, use the web
three UI kit, web three UI Kit
1638:51 - has this nice pop up section,
where it has some code to work
1638:55 - with a modal. So we're going to
import that will do import
1638:59 - ngModel from web three UI kit,
like so here's what it looks
1639:04 - like we have modal and then we
have all this stuff on working
1639:08 - with the modal. So we'll do our
return, do a little modal, like
1639:12 - this. One of the key things in a
ngModel is whether or not it
1639:15 - should be visible. So it has an
is visible tag, which we're
1639:19 - actually gonna have to grab,
we're actually gonna have to
1639:22 - grab from the empty box. So
we're going to pass a little is
1639:25 - visible here as well, in our NFT
box, we need to tell our ngModel
1639:30 - when it's visible. So we'll
we'll make that code in a little
1639:33 - bit. Right now, it'll just be
blank. And inside of our
1639:35 - ngModel, we're going to want to
give an input field for how to
1639:38 - update it. So I know we've done
some regular inputs before,
1639:41 - since we've been working with
web through UI kit, let's just
1639:44 - use the input that it has as
well. So we'll do a little comma
1639:47 - input here. And inside of the
ngModel we'll create a new
1639:51 - input. So on our input field,
we'll give this a label which is
1639:55 - going to be update listing price
in L one currency. And we'll
1639:59 - just do eath. For now we'll just
hard coded as eath name will be
1640:03 - new listing price, and type is
going to equal a number we'll do
1640:10 - Little backslash here, oops,
we'll do a little backslash
1640:13 - instead of like that. So cool.
So when this modal pops up, it's
1640:16 - gonna have this input in here.
And we can actually test to see
1640:19 - if this is working. We can
import this into our NFT box,
1640:24 - we'll do import, update, listing
ngModel. From that slash,
1640:30 - update, listing ngModel oops,
and sorry, this doesn't need
1640:32 - parentheses, and at the top of
our return here, right before
1640:36 - our card will add it in. So
we'll just add another div
1640:39 - though. So that these two can be
in the same react. But we'll add
1640:43 - another div, we'll say Update
listing ngModel, like so with a
1640:47 - little backslash here. And right
now we just have to pass is
1640:51 - visible. And then for now, we're
just going to say true. So now
1640:55 - with this listing ngModel on our
front end, we do a little
1640:58 - refresh. And we get this little
box like this update listing
1641:01 - price and one currency. And we
have to close two of them.
1641:04 - Because technically we right now
both modalities are true, right.
1641:08 - So if we do a refresh, we get
this little input pop up this
1641:11 - little modal and we close it
twice, because we have two NF
1641:14 - T's if you have a ton of NF T's
here, you will have to close a
1641:17 - ton of those. So we change it to
false, we go back to the front
1641:20 - end, we do a little refresh, and
boom, now it's false. So true,
1641:25 - save, run, and it's there.
Gross, delete, delete, false,
1641:31 - save front end, it's not there
anymore. Okay, cool. So we're
1641:34 - gonna have to tell this ngModel
only to pop up when somebody
1641:38 - clicks this and have tea that
they own. So to actually toggle
1641:41 - this and actually make this
work, we're going to update our
1641:44 - card. So whenever we click our
card, we're going to create a
1641:48 - function called handle card
click that handle card click is
1641:51 - going to update a variable for
whether or not we should show
1641:54 - this ngModel. So we're going to
do is we're gonna say on click
1641:59 - of the card, aka, once we click
our dog, we're going to call
1642:03 - some function. So we're gonna
say on click, equals handle
1642:07 - card, click, animal card, click,
and we're going to make this a
1642:11 - function, we're gonna say const,
handle card click equals a
1642:15 - function, we'll use some Arrow
stuff here. And then we'll just
1642:19 - say, if it's is owned by user,
if it's on by user, we'll show
1642:25 - the ngModel. Else, we will call
the by item function, since we
1642:30 - want our whole UI to rerender.
Once we change, once we change
1642:35 - the variable to show the
ngModel, we're going to do this
1642:37 - as a US state. So we'll say
const, show ngModel. Come a set,
1642:43 - show ngModel equals use state.
And then we're going to start it
1642:47 - off being defaulted to false. So
by default, we are not going to
1642:51 - show them on down which is what
we want. But if it's owned by
1642:53 - the user, we're gonna say Set
Show ngModel to be true. And
1642:59 - then else right now we'll just
put console dot log, let's buy
1643:04 - will actually update this to
bind the item a little bit
1643:06 - later. So now instead of having
is visible be false, we'll have
1643:10 - is visible equal to show
ngModel. Or show ngModel.
1643:13 - Variable. Okay, great. So now if
we save that, we go back to our
1643:16 - UI, we right click, we hit
Inspect, if we own it, and we
1643:21 - click it, the ngModel will pop
up, and we can click it out,
1643:24 - click another one, but that will
pop up if we don't own it. So if
1643:28 - we switch accounts, Connect will
switch. We click it, nothing
1643:32 - happens. And if we go to
inspect, we go to the console,
1643:36 - we click it, we should see let's
buy pop up, which is what we do
1643:40 - see, we'll do a little refresh
here. Click we see let's buy pop
1643:44 - up, click again, let's buy click
let's pilots pilots, why? Great,
1643:48 - cool. So now we have a word for
that ngModel. To actually show
1643:51 - up correctly, let's switch back
to the person who actually owns
1643:54 - this NFT we click it, we want to
be able to when we hit OK, or
1643:58 - submit, we want to send a
transaction to update the price
1644:02 - of our NFT here, so what we can
do is in our input will have a
1644:05 - label called on change equals
and this is the function that
1644:09 - will call whenever this updates.
So we're gonna say on change
1644:12 - event is going to be a function.
And we're going to create a
1644:17 - function called set price to
update listing listing with
1644:22 - event dot target dot value. So
we want to keep track of
1644:27 - whatever we've put in here. So
when we call the function to
1644:30 - update the price, it'll just
already automatically have it.
1644:32 - So we'll create this function
and event dot target dot value
1644:36 - is going to be whatever's in
this input box here. So we'll
1644:39 - create this set price to update
listing with will have this be a
1644:43 - use date because we are going to
want to change the UI based off
1644:46 - this so we'll say const price to
up date listing with comma set
1644:52 - price to update listing with
equals use state and then we'll
1644:58 - have this be zero to start or
blank. And so now, whatever is
1645:03 - in here is going to get updated
with this. So now I can do like
1645:06 - our console dot log price update
listing with Get back to the
1645:11 - front end, oops, we need to
import use state import, use
1645:16 - state from react. Go back to the
front end, we click this, we
1645:21 - right click Inspect.
1645:23 - By type one, we can see 114, we
see 14. So let's remove the
1645:27 - console dot log now. Now what we
can do in here is we can create
1645:31 - field called on okay, this is
going to be the function that we
1645:34 - call when we hit this, okay
here, so on. Okay, it's going to
1645:37 - be equal to a function, we're
going to use a little arrow
1645:40 - notation, and we're going to
call that update listing
1645:44 - function on the blockchain,
we're going to need to grab that
1645:47 - function so we can use it. So
once again, to use that
1645:50 - function, we're going to import
use web three contract from
1645:55 - react mirallas. And as a new
hook, we'll say const run
1646:00 - contract function called Update
listing, equals use web three
1646:06 - contract. And this is going to
be a function that we're going
1646:09 - to call on our NFT marketplace.
So ABI is going to be the NFT
1646:15 - marketplace API, which we can
get by doing an import, similar
1646:20 - to what we did over here. And we
actually just copy paste from
1646:24 - our NFT box. So we'll do import
NFT marketplace API from dot dot
1646:30 - constant send it to marketplace
that JSON, we're gonna need the
1646:33 - contract address, which is going
to be an input parameter to our
1646:38 - update listing ngModel. So we
can even do a comma market place
1646:43 - address, copy this place that
here, that means in our NFT box,
1646:48 - pretty soon, we're going to have
to pass all these variables to
1646:51 - it, but we'll save that in just
a second. So NFT marketplace
1646:54 - address marketplace address
function name, is going to be
1646:57 - what it's called Update, listing
in our smart contract, and then
1647:02 - the params. So if we go to this,
we have update listing takes the
1647:06 - NFT address token ID and new
price do NFT address, which will
1647:11 - be NFT address, we'll say token
ID is going to be token ID and
1647:16 - the new price your price will
get from price to update listing
1647:20 - with but will convert it from
human readable to ethers. So
1647:25 - we'll import ethers from ethers.
And the new price will be ethers
1647:33 - dot utils dot parse ethers or
ether price to update listing
1647:39 - with or just in case it's blank,
we'll just say or zero. So we
1647:44 - have the NFT address the token
ID marketplace address in our
1647:48 - NFT box, we're gonna have to
pass those parameters in here.
1647:51 - So we have is visible, we're
also going to have token ID,
1647:54 - which is going to equal token
ID, marketplace address is going
1647:59 - to equal the marketplace
address. And the NFT address is
1648:05 - going to equal the NFT address.
And as we code and test this
1648:10 - something that's going to be
really annoying, because it's
1648:12 - really annoying for me right now
let's refresh our website. And
1648:15 - if we click it, this thing pops
up. But when I hit X, and I
1648:18 - click this, again, nothing shows
up. That's because technically
1648:22 - show ngModel is still true right
now, even though we've exited
1648:25 - out. So what we want to do in
the NFT box is in our update
1648:30 - listing ngModel we're also going
to pass it in on close, and
1648:33 - we're going to pass it a hide
ngModel variable that we're
1648:37 - going to create, and right under
Show ngModel Set Show ngModel
1648:41 - we're going to create const Eid
ngModel. And this is just going
1648:46 - to be a function, that's just
going to say set, show modal. to
1648:51 - false, we're going to pass this
function to our update modal
1648:56 - listing. So we're going to do
comma on Close. And in our modal
1649:01 - here, we're going to say, on
Close. On, cancel, we're going
1649:07 - to do, we're going to call that
on close function, or on Close
1649:13 - button pressed, we're also going
to call that on close function.
1649:17 - Now if we refresh our website,
click this modal pops up, we
1649:22 - click X, click it again, it'll
pop back up, because now we're
1649:25 - properly setting it to false and
then resetting it to true. Now
1649:29 - to actually send this update
listing function, we're going to
1649:32 - pass this another thing, another
variable, we're going to pass it
1649:37 - on Okay, which is going to be a
function as well. It's just
1649:40 - going to call update listing
that we just created. Now, it's
1649:44 - always a good idea to add an On
error. We'd say on error, take
1649:48 - that error as a function and
console dot log.
1649:54 - The error and this needs to be
in squiggly brackets like that,
1649:58 - but contract address is wrong.
So we'll make this contract, con
1650:04 - tract address and spell that
correctly. Spelled correctly.
1650:11 - Now let's go back to the UI,
we'll give it a little refresh.
1650:14 - Click, this will add one. And we
see Metamask pop up. So this is
1650:19 - working out perfectly. Now I'm
going to cancel it, and our apps
1650:22 - gonna freak out and stuff. But
that's okay, we are doing
1650:24 - fantastically okay app popped up
like that, which is good. We
1650:28 - have this little error handling,
which I like to add for all of
1650:30 - these run contract functions.
Let's also do an on success. So
1650:35 - let's say when this does go
through successfully, we'll call
1650:37 - a function called handle update,
listing success. And this will
1650:43 - be a function that we'd call
when this goes through
1650:45 - correctly. So at the top, let's
make this new function, we'll
1650:47 - say const. Handle update,
listening success is going to be
1650:51 - a new function using the arrow
syntax here. And we'll have this
1650:55 - setup a new notification for a
web application. So for us to do
1651:00 - notifications, we're going to
use web three UI Kits use
1651:03 - notification, this is going to
be that same notification
1651:06 - service that we used in our last
one. So up at the top here,
1651:10 - we'll import it, use
notification. And then we'll
1651:14 - say, right in our component,
we'll say const, dispatch equals
1651:18 - use notification. And since
we're using notifications back
1651:23 - on our app.js, we have to import
it in here. So we'll do import
1651:27 - notification provider from web
three UI kit. And inside of our
1651:33 - Morales provider, we'll add the
notification provider around our
1651:37 - header and our component, so
that we have context for this.
1651:44 - Now in our handle update listing
success, inside this function
1651:49 - will say dispatch, say type is
going to be success. message
1651:54 - will be listing updated, title
will be listing updated, please
1652:01 - refresh, please refresh and move
blocks. And then position. Top
1652:10 - right. And then we'll do on
clothes, and on clothes. And
1652:17 - we'll say set price to update
listing with back to zero. I
1652:23 - also I'm editing this a little
bit in the future. And I
1652:25 - realized that I actually forgot
to add the TX to a lot of these
1652:29 - handle functions. So on these,
whenever we call one of these
1652:33 - run contract functions, like
we've been saying they have this
1652:36 - on error in this onsuccess. Now
this onsuccess automatically
1652:40 - passes the result of the call to
whatever callback function is
1652:45 - there. So for example, up the
listing returns a transaction,
1652:50 - and we'll pass that transaction
to whatever you add to the
1652:54 - onsuccess. So now in here, you
can actually have it have a
1652:58 - transaction as an input
parameter. And this would be the
1653:00 - transaction that's going to go
on the blockchain to you know,
1653:03 - update the price. So we actually
want to change it from a regular
1653:07 - function to an async function.
So we can actually do await TX
1653:11 - dot Wait, one, because we don't
want to say, hey, success, you
1653:14 - know, listing has been updated
before the transaction actually
1653:17 - goes through. So we want the
transaction to go through first.
1653:20 - And then we want to pop the
dispatch up saying, hey, it's
1653:23 - gone through so and then
additionally, when we actually
1653:26 - call these modells on the on,
okay, on the onsuccess, we pass
1653:31 - them in just by referencing the
name of the function. So we
1653:34 - don't do this arrow syntax,
anymore like this, we just say,
1653:40 - hey, the onsuccess is going to
be this, go ahead and pass your
1653:44 - results to it. So that's how we
actually call it down here. If
1653:48 - you look at the GitHub repo
associated with this, you go to
1653:50 - components, and we go into
these. So in this video, I
1653:54 - forgot to add the await TX dot
wait one. But in the GitHub
1653:58 - repo, we have these. And when
I'm demoing things in the video
1654:01 - here, the dispatch, it's gonna
pop up before the transaction
1654:05 - actually finishes going through.
So just want to let you know,
1654:07 - and back to the video. So now we
have a little success thing
1654:11 - that'll pop up when we're
successful. And the other thing
1654:14 - is, when we call this, we are
going to omit an item listed
1654:18 - inside of our Morales dashboard,
the price should actually update
1654:23 - in our active item because of
our Cloud Functions. So we're
1654:27 - going to put this all together
now. So we're on the front end.
1654:31 - And if the marketplace owned by
you will click it. Update
1654:35 - listing to 25. We're gonna hit
OK, meta masks is gonna pop up.
1654:41 - We're gonna go ahead and confirm
and ran through an error because
1654:46 - we need to click Metamask I need
to reset my account. So I'm
1654:49 - going to do settings, advanced
reset account.
1654:54 - Okay, now let's go ahead
Metamask has popped up again,
1654:58 - we're gonna go ahead and confirm
it closed, the pop up modal, and
1655:03 - we got our little notification
there. And we can see an
1655:06 - activity we have that
transaction has indeed completed
1655:11 - So now if we go to active item,
we give it a little refresh.
1655:14 - Right now we see our item listed
event. But the issue is that
1655:19 - it's not confirmed yet. So what
we're going to need to do is
1655:23 - we're going to need to move our
blocks by one. So in our NFT
1655:26 - marketplace, we're just going to
create a new script, a new file
1655:31 - called Mind dot Jas, just to
move our blocks once, and we're
1655:34 - going to say const, move blocks,
equals require dot slash utils,
1655:42 - slash move blocks, we'll say
const blocks equals to const
1655:49 - sleep amount equals 1000 async
function mine, do await move
1655:58 - blocks will do blocks as the
parameter and then sleep sleep
1656:06 - amount will equal sleep amount.
And this will be a script. So
1656:12 - we'll add our copy paste our
that same syntax we're doing
1656:16 - here just with mine. And now we
want to just mine these two
1656:20 - blocks. So we'll run yarn, art
hat run scripts. Mind that Jas
1656:27 - dash dash network, local host.
So we're going to mine those two
1656:33 - blocks. Now if we go back to our
database, we go back to active
1656:38 - items, we can see it's been
updated because now in our item
1656:43 - listed, that 2500 event is now a
confirmed transaction, and we
1656:50 - get to confirm their excellent.
So that means since it's
1656:54 - confirmed back in our front end,
we'll give this a little
1656:57 - refresh. We can see the pup is
now worth 25 eath. Awesome. So
1657:04 - we're updating ngModel is
working perfectly. Excellent
1657:07 - job. So now let's go to the
readme. If you own the NFT, you
1657:10 - can update the listing. That's a
checkmark. Excellent. Next, what
1657:17 - do we want it to do? If you
don't own it, you can buy the
1657:20 - listing. Okay, so let's go back
to our website, let's switch
1657:24 - users to a different account,
we're probably going to want an
1657:28 - account that own some money. So
let's go ahead and send this
1657:31 - other account some money
transfer between my accounts,
1657:33 - we'll send 100 eath to account
one, confirm on our hard hat
1657:38 - chain here. Alright, great. Now
we can go ahead and switch to
1657:41 - account one, and we have 100
eath. Okay, great. As these
1657:44 - pops, each cost less than 100
eath. So that's gonna be more
1657:47 - than plenty for us to test this
out. Let's go back to this box.
1657:50 - Because I think somewhere we
said, we did a little handle
1657:53 - card click, if it's owned by the
user, have the modal pop up. If
1657:58 - not, let's do the by
functionality. So to do the by
1658:02 - functionality, we're gonna go
ahead and do another run
1658:04 - contract function. So we'll do
const run contract function,
1658:11 - we'll call this one by item. And
this will equal use web three
1658:17 - contract. And this is going to
be the ABI for the NFT
1658:21 - marketplace. API, the contract
address is going to be the
1658:27 - market place address. The
function name is going to be by
1658:34 - item, the message value is going
to be the price of the NFT.
1658:41 - Because we need to send that
amount to buy the item. And then
1658:44 - params are going to be NFT
address, which is going to be
1658:49 - the NFT address. And the token
ID, which is going to be the
1658:54 - token ID now that we have this
by item on handle card click, we
1658:58 - can say okay, said show ngModel
is true. Otherwise, we're gonna
1659:03 - call by item. And we're going to
do on air. Air is going to be a
1659:09 - function where we're just going
to console dot log the air and
1659:12 - onsuccess. It'll be a function
where we call handle by item
1659:19 - success. So we'll create a new
handler for this right
1659:23 - underneath handled cart click
the const handled by item
1659:27 - success equals a function. And
for this, we'll also have this
1659:31 - do a little notification. So
once again, we're going to
1659:35 - import we're going to import use
notification from web through UI
1659:40 - kit. We're going to say const.
Dispatch equals use
1659:46 - notification. And then in
handled by item success. We're
1659:50 - gonna say dispatch
1659:53 - type, success. Message. Item
bought. Title will also be item
1660:04 - bought. Then pole position will
be top right That's it. So
1660:12 - handle card click, if they own
it, we're going to show that
1660:16 - update listing ngModel. If they
don't already own it, someone's
1660:19 - gonna buy it. So let's go back
here. And I'm currently on an
1660:22 - account that does not own these
NF T's. Let's go ahead and click
1660:25 - it. Our Metamask does indeed
show up for 25 eath. That's
1660:30 - crazy expensive. Let's go ahead
and confirm item has been
1660:34 - bought, we'll go ahead and click
that little x, we go to our meta
1660:37 - mask, the transaction is
pending. And it's gone through.
1660:41 - This is fantastic. Okay, our
homepage is done, we can show
1660:45 - recently listed NF T's if not,
you can update the listing. If
1660:49 - not, you can buy the listing.
And now it's time for our cell
1660:52 - page. So the last thing that we
need to do is our cell page,
1660:59 - let's get this cell page, let's
get this done pages, we have our
1661:03 - cell NFT page, which right now
does a whole lot of nothing. And
1661:07 - on our front end, we go here,
there's not a whole lot here.
1661:11 - And actually, you can list your
NFT in the marketplace, we also
1661:14 - needed to add withdraw proceeds.
So I didn't add that. But that's
1661:18 - probably going to be something
we're going to want to allow
1661:20 - people to do as well. So let's
get started here. So we can
1661:23 - remove this head stuff now that
we're adding that in our main
1661:26 - page. And for us to submit a new
NFT, we're probably gonna need a
1661:31 - space to add the address of the
entity that token ID of the NFT
1661:35 - and all this other stuff. So
we're gonna need a form to do
1661:37 - this, which guess what, we can
also grab a form from the web
1661:41 - through UI kit as well. So we're
gonna go ahead in our cell NMC
1661:45 - page, we're going to import form
from web three UI kit. And we're
1661:53 - going to create a new form in
our cell page. Now, the
1661:57 - parameters we can add to our
form, again, you can find them
1662:00 - in documentation here, or we're
going to add with one of the
1662:03 - main pieces is going to be this
data piece, which is going to be
1662:06 - an object that has a list in it,
of all the different fields, we
1662:11 - can put in our form. So maybe
we'll do our first one have a
1662:14 - name of NFT address. That's
gonna be of type text, excuse
1662:21 - me, and these are all going to
be this is a list of list of
1662:26 - objects like that. Now, if we
save that, we go back to our
1662:30 - cell page, we can now see an
empty address and a little
1662:34 - Submit button. That right now
does a whole lot of nothing. So
1662:37 - we have an NFT address, it'll
take a text, maybe we'll also do
1662:41 - in foot width of 50 percent will have
the starting value be blank. And
1662:48 - the key of this will be NFT
address, what else do we need,
1662:52 - we're going to need to give it
the token ID so we'll say name,
1662:58 - token ID, type is going to be a
number value, we'll start off
1663:04 - it's blank. And then the key for
this will be token ID. Next,
1663:12 - we're going to need the price.
So we'll say name will be price.
1663:18 - In eath. type will be a number
value will be blank. And the key
1663:25 - will be price. And we don't need
to have to form tags, we'll just
1663:29 - delete that second one and have
it auto close with one tag. And
1663:33 - then in here, we'll do title
equals sell your NF T ID equals
1663:40 - main form. So cool. So now we
can take an empty address, a
1663:44 - token ID and a new price with
the title of cellular NFT.
1663:48 - Great, that looks really nice.
Right now our form doesn't do
1663:51 - anything, we probably want to
give it the functionality to
1663:54 - actually do stuff. So we'll say
on Submit, and we'll have to
1663:58 - create a new function to
actually list our NF T's. So
1664:01 - we're going to create a function
called approve and list we have
1664:05 - to approve our marketplace to
pull the NFT from our wallets.
1664:10 - So we're going to create a new
function, a sync function
1664:14 - approven list, which is going to
take a data input parameter on
1664:19 - our form, when we hit on submit,
it's automatically going to pass
1664:22 - this data object to our approved
list function. So that's how
1664:26 - we're going to get the value of
the address the value of the
1664:29 - token ID and the value of the
price. So in our async function
1664:33 - approven list, do console dot
log, approving the contract, the
1664:39 - NFT address is going to come
from this data object. So it's
1664:44 - going to be data dot data at
index zero, or zero with object
1664:50 - here is going to be our address
that input result.
1664:56 - Our token ID is going to equal
data dot data. One because
1665:01 - again, this one is going to be
our token ID that input result.
1665:07 - And then the price is going to
equal that ethers dot utils dot
1665:12 - parse units of data dot data
have to the input result, comma
1665:22 - ether.to string. So we're going
to get the price in eath. In
1665:28 - human readable form, we're going
to convert it to Aetherium
1665:32 - readable form. And then we're
going to pass it as a string
1665:35 - because this returns a big
number, which we don't want. So
1665:39 - we have the NFT address, the
token ID and the price of the
1665:42 - new listing, what we can do now
is we can say const approve
1665:46 - options equals a little function
here, the ABI which is going to
1665:51 - be our NFT abi, which we need to
import, we need to import both
1665:55 - ethers from ethers. And we also
need to import the NFT abi, for
1666:03 - its NFT ABI from dot dot
constants slash basic at A T dot
1666:07 - JSON, I just copied and pasted
from the NFT box, the contract
1666:12 - address is going to be the NFT
address, the function name is
1666:19 - going to be approve params are
going to be two, the marketplace
1666:27 - address, which we're going to
define in just a second, and
1666:29 - then the token ID will be token
ID. Now the marketplace address
1666:34 - in our NFT box, we're getting
this directly from index, an
1666:38 - index is getting it from our
database. Now we want our app to
1666:42 - be smart enough to be able to
grab the NFT marketplace itself,
1666:46 - the marketplace address. And if
we go to our constants, right
1666:50 - now, we actually have it in this
network mapping. So we're going
1666:53 - to want to grab it right up at
the top by saying const
1666:56 - marketplace address equals
network mapping, network mapping
1667:02 - of what of the chain ID of the
entity marketplace address at
1667:07 - the zero with index. So network
mapping of the chain ID, which
1667:11 - we're going to get honest chain
ID equals us Morales. Now chain
1667:17 - Id actually comes like we said
it's a wax hex form for Morales.
1667:22 - So we're gonna have to convert
the chain ID to its string
1667:25 - readable version. So we'll say
const, chain string equals chain
1667:31 - ID. And we'll do a tertiary
operator, if the chain ID
1667:35 - exists, will parse int of the
chain id.to string. So we'll
1667:42 - parse it from its hex to a more
readable version, and then do.to
1667:46 - string. And then otherwise,
we'll just say we're on 31337.
1667:51 - So chain ID string. So in the
network mapping at the chain ID
1667:55 - string, dot NFT marketplace at
index zero, that's going to be
1668:02 - our marketplace address. So we
got the marketplace address,
1668:06 - this is all we need to call the
approved function on our NFT we
1668:10 - can now call running contract
function for a proof. So we're
1668:13 - actually going to do this a
little bit differently. We're
1668:15 - just going to say const. Run
contract function equals use web
1668:23 - three contract, you could import
just run contract function, and
1668:27 - then pass all those options to
it like what we're gonna do
1668:30 - here. Now we're just gonna say
await on contract function.
1668:34 - Because this is an async
function await run contract
1668:37 - function, we're gonna say params
are going to be approve options.
1668:43 - And we're gonna say onsuccess,
we're going to do something, I'm
1668:47 - going to say on error, we're
also going to just do error,
1668:52 - little arrow function, console
dot log error. Now on success,
1668:59 - once we send this transaction,
after the Approve goes through,
1669:03 - we're going to want to call the
list function right underneath
1669:06 - this will call async async.
Function, handle approve
1669:13 - success. And this is going to
take the NFT address, the token
1669:18 - ID, and the price is it put in
parameters. So once this run
1669:22 - contract function goes through,
we're going to call
1669:26 - of handle proof success. And
we'll pass it the end of the
1669:29 - address, token ID and the price,
which will say console dot log.
1669:36 - Okay, now time to list and we'll
do the same thing. We'll do
1669:40 - const list options, equals and
this is going to be all the
1669:45 - options for calling the list
function API is going to be on
1669:48 - the marketplace this time. So
NFT market place abi, which
1669:54 - again, we're going to have to
import so I'm going to go back
1669:56 - to NFT box. We're gonna copy
that line here, paste it in the
1670:00 - top. That's going to be the API
for that contract address. It's
1670:04 - going to be the marketplace
address, which we already have.
1670:09 - function name is going to be
list item. And the params are
1670:14 - going to be NF T address of the
NFT address, token ID of token
1670:22 - ID, price of price. And now we
have those options, we can do
1670:28 - await, run contract function
with params. Of list options,
1670:35 - will say onsuccess arrow
function, handle list success,
1670:42 - which is a function we haven't
made yet. It will say on air
1670:47 - error. And we'll just say
console dot log error. Okay, so
1670:54 - let's make this handle list
success handle one spell handle
1670:58 - correctly handle the success,
this will be an async function.
1671:03 - And this is also going to call
dispatch and make a little
1671:05 - notification. So we're going to
grab that from web three UI kit,
1671:10 - use notification. We'll say
const dispatch equals use
1671:16 - notification. And now down in
handle the success say dispatch,
1671:22 - type success. Message NFT
listing, title NFT listed
1671:33 - position. top bar, and cool. And
we're also gonna have to grab us
1671:39 - Morales from react Morales. So
do import us Morales from react
1671:46 - or else. So let's import this
network mapping. Import network
1671:51 - mapping from dot dot slash
constants slash network mapping
1671:57 - dot JSON. Because I spelled
contract address wrong again,
1672:00 - good our front end we'll give it
a refresh us web three contract
1672:03 - isn't defined. Let's get that
from react moralss. Well save
1672:07 - that refresh our front end. And
tada, we're good to go here.
1672:11 - Alright, now to test this out,
we're going to want to do is
1672:14 - we're going to want to create
another script here. So we're
1672:16 - back in our heart at NFT
marketplace, we're looking at
1672:19 - our scripts. And we're going to
create a new file just called
1672:22 - mint.js. So we're not going to
list this time, we're just going
1672:27 - to mint it just going to mint an
NF t so we can list it ourselves
1672:31 - on the UI. And actually, we can
just copy our mminton list code,
1672:34 - paste it into here, and just
remove the approval and the
1672:39 - listing code. Boom, remove that,
remove this, remove this. And
1672:44 - that's all we need. And now
we'll just change the name to
1672:47 - mint. Well, we can remove price
as well. And we'll change this
1672:50 - to mint. And that's it. Now we
have a script that we can call,
1672:55 - well, we'll just mint an NFT, we
can also get rid of the NFT
1672:58 - marketplace. Actually, we will
probably want the token ID so we
1673:01 - can know what it is. So let's do
const token ID equals. So let's
1673:07 - actually get the receipt we'll
do const mint TX receipt, but
1673:11 - the receipt, I can there equals
that. And then I'm just going to
1673:15 - copy this from the mminton
receipt. Cons token ID equals
1673:19 - this, paste it into our mint.js
and then a console dot log. Got
1673:26 - token ID, string interpolates
token ID, hard hat, run scripts,
1673:33 - mins dot j s dash dash network,
local host. And we're going to
1673:38 - mint an NF T. Got token ID six
means we know m token ID six, we
1673:46 - can list this entity. Let's also
add the address. Let's do
1673:49 - console dot log NFTL. And if the
address is going to be we'll do
1673:56 - string interpolation.
1673:59 - And you know what? Let's make
this again. Mint dot j s okay
1674:03 - cool. Got token ID seven and if
the address this so what we can
1674:07 - do now we'll grab this NFT
address. So from account one,
1674:11 - let's go to Account three
because that's the account that
1674:13 - I've done my imports on now when
you switch accounts, we're going
1674:16 - to want to refresh the page as
the address seven 0.6. Submit
1674:22 - Metamask pops up. Give
permission Yes. Okay, now it's
1674:26 - time to list you now have one
pen, okay. Local host list item.
1674:31 - We can see all the data and
everything. Okay, let's go ahead
1674:33 - and confirm NFT listed Okay,
okay. Okay. Okay. So this is
1674:38 - good. Now to get Morales to
catch up to speed back in our
1674:41 - node. Let's just go ahead and
run yarn, RT hat run scripts,
1674:46 - mine dot j s dash dash network,
local host. We're going to mine
1674:51 - those two blocks. And now if we
go to our item listed, we'll
1674:55 - give this a little refresh. Go
to active item. We can see
1675:01 - there's a new item listed for
0.6 eath. In our database. This
1675:05 - is fantastic. Now that we've
listed this, if we go back to
1675:09 - now let's make And let's move on
to one more. Let's list the
1675:13 - second one, just to see that
it's actually working. Okay,
1675:15 - token ID eight. Let's grab this
address. Let's give this a
1675:20 - refresh. paste this in token ID
eight. We'll do 0.999. Let's
1675:26 - submit. we'll approve this. Yes.
Then we'll send it. Yes. Okay,
1675:34 - now let's go ahead and mine two
blocks. So I'm just going to hit
1675:36 - up and go back to mine will run
the mining, moving blocks. Okay,
1675:41 - great. Now, if we go back home,
we'll see there are three NF T's
1675:47 - now listed, we have the original
one, that we have those two that
1675:51 - we just listed eight, and seven
for 0.6 and 0.999. Listed on our
1675:56 - NFT marketplace. This is so
exciting. Our listing is working
1676:00 - correctly, okay. Now, due to the
fact that this lesson is already
1676:03 - incredibly long, actually
decided to cut the part of that
1676:07 - and then withdraw a bit, because
we don't really learn anything
1676:09 - new there. However, feel free to
jump back in to get every bit
1676:13 - associated with scores, where we
will have that withdrawal
1676:16 - functionality for you if you
want to implement it. Otherwise,
1676:20 - feel free to skip and move on
ahead. This is incredibly
1676:22 - powerful. And you should be
incredibly excited about
1676:25 - yourself. If you've made it this
far. This is awesome. You just
1676:30 - made a decentralized marketplace
and then built a front end on
1676:33 - top of it to allow anybody to
interact with your marketplace.
1676:37 - Easily. Huge, huge.
Congratulations here. Oh, this
1676:42 - is a perfect time to go take a
break and celebrate. And this is
1676:45 - a great time to ping me on
Twitter to ping me on Twitter
1676:48 - saying hey, Patrick, I just
completed the NFT marketplace.
1676:51 - Full Stack front end part of
your Free Code Camp course, I
1676:55 - now know how to build full stack
front end on top of my smart
1676:59 - contract applications. And be so
so pumped with yourself because
1677:02 - this is so awesome. I can't
understate how excited I am that
1677:06 - you've made it this far, you are
learning and working with a ton
1677:09 - of technologies, solidity smart
contracts, and front end you are
1677:12 - doing full stack you were doing
a lot of stuff here. So you
1677:15 - should be really proud of
yourself. huge congratulations,
1677:18 - be sure to absolutely give
yourself a pat on the back. And
1677:22 - then get ready to continue to
our next section.
1677:27 - Now that we've done all of this
using our Morales back end, I'm
1677:31 - about to switch it up on you,
instead of indexing all of our
1677:34 - events with a centralized
server. Now we're going to learn
1677:37 - how to build this using the
graph, which is a decentralized
1677:42 - event indexer that we can use, a
lot of the code is going to be
1677:46 - exactly the same. So instead of
us starting from a new, what
1677:52 - we're going to do, first of all
we can we can close all our
1677:55 - local stuff, we can close all of
these things, we can close all
1677:59 - of our terminals finally, which
is really exciting. And in this
1678:03 - folder, what we're going to do
is we're actually just going to
1678:06 - copy everything into a new
folder. So I'm going to CD down
1678:11 - a directory, we're going to make
a new one called next Jas. And
1678:15 - if T marketplace, the graph,
dash FCC, and all the code for
1678:23 - this section is going to be here
for front end the graph indexer
1678:28 - we're gonna have to make another
repo and we'll get to that in a
1678:30 - little bit. For all the changes,
it's going to be in this section
1678:33 - here. So what we're going to do
is we're going to make this new
1678:36 - folder, and we're going to do
copy dash R. Next, Jas and ft
1678:42 - marketplace FCC into next Jas
NFT. Marketplace, the graph FCC.
1678:51 - So we're going to copy
recursively, everything that's
1678:54 - inside that folder we just
created into this new one that
1678:57 - we're going to make a lot of
adjustments to. And this might
1679:00 - take a little bit of time to run
because we've got a lot of stuff
1679:04 - in this folder. And Alright,
once we've done that, we can cd
1679:07 - into this next Jas and ft
marketplace, the graph FCC and
1679:13 - do code period and open this up
in a new code editor. Or as
1679:17 - always, you can do File Open
folder to open it like that. Now
1679:21 - that we're in here, we're going
to learn how to do this exact
1679:24 - same project, instead of using
mirallas. But using the graph,
1679:28 - one of the things that we're
first going to do is we're
1679:29 - actually going to deploy our
contracts to rink B. So we're
1679:33 - going to grab our marketplace,
that soul, pull this over, we're
1679:37 - going to grab our hard hat
marketplace dot soul project,
1679:40 - pull it over. And first, we're
going to run our deploy script
1679:43 - on rink v. So hopefully, you've
got all your deploy stuff set up
1679:46 - correctly, so that all the
arguments can go through
1679:49 - correctly for rink v as well. So
we're gonna go ahead and run
1679:52 - this yarn, hard hat deploy dash
dash network Rinkeby. And to
1679:58 - make sure that it's going to
work for Rinkeby. Let's check
1680:01 - our hard hat config. Okay for
networks, looks like I have my
1680:05 - Rigby stuff in here for
networks. Okay, I've got my RPC
1680:08 - URL, which I'm getting from my
environment variables. If I have
1680:11 - a private key, I have a private
key, which I'm also getting from
1680:13 - environment variables, I have a
chain ID block confirmations and
1680:17 - save deployments. So let's go
ahead and run this. Now we're
1680:20 - going to go ahead and be
deploying the NFT marketplace to
1680:23 - the Rigby network. And our
deploy script also has an ID
1680:27 - some verification. So we can
verify this as well, you can't
1680:30 - really follow along with this
section without deploying a
1680:33 - marketplace to rink be here. So
deploy to rank B, or whatever
1680:36 - test net is recommended in this
lesson 15 section, and go from
1680:40 - there. Alright, great, we've
deployed our NFC marketplace.
1680:43 - Now we're gonna go ahead and
deploy our basic NFT. And once
1680:46 - these are done deploying, we can
start updating our front end
1680:48 - code to work with the graph
instead of mirallas. Okay, we've
1680:51 - verified everything to which
looks great. Now we're going to
1680:54 - verify our basic NFT. And we've
have it verified. Awesome. So
1680:58 - now we have an NFT marketplace
deployed to ring P, and a basic
1681:02 - NFT deployed to rink B. And both
of them are verified. So be sure
1681:06 - to take note of those, because
we're going to need them when
1681:09 - we're moving over to our the
graph section. So now let's grab
1681:13 - our code editor titled next Jas
and ft marketplace, the graph.
1681:17 - And let's get going. Now, we
just deployed that to rink B.
1681:21 - But we forgot to add some code
in here to update our network
1681:24 - mapping. However, if we go back
and we open back up code dot
1681:29 - dot, next Jas NFT marketplace,
FCC, in the network mapping in
1681:36 - here will now have a new entry
for rink B, if we did it
1681:39 - correctly, let's copy this
network mapping and paste it
1681:43 - over in our network, our next GS
and ft marketplace, the graph
1681:47 - section, or you can just
manually add your new entry.
1681:50 - Right. So you want to add
network ID for network
1681:53 - marketplace. And the address of
that network marketplace that
1681:56 - you just deployed, is we're
going to delete this Cloud
1681:59 - Functions bit. Goodbye, because
since we're not working with the
1682:02 - server anymore, there's not
gonna be any cloud functions or
1682:05 - any back end to run. So we're
gonna move that to trash
1682:08 - goodbye. Next, we don't need FRP
anymore, because we're not going
1682:11 - to be connecting our local
blockchain to the graph, we're
1682:14 - only going to be working with
the test net here. So let's go
1682:16 - ahead and delete that. Goodbye,
what's next in our pages, and
1682:21 - our app dot j s. Right now we're
connecting to a Morales provider
1682:26 - like this, we're going to switch
this back to initiate allies on
1682:31 - Mount, this is going to go back
to being false, we're no longer
1682:35 - going to connect to our Morales
database like this, we're just
1682:38 - going to use the hooks again.
Now with that the only thing
1682:41 - that's going to change is our
index.js. Right now, in our
1682:44 - index.js, we're getting our list
of NF TS from our Morales query.
1682:51 - So we're going to change this,
let's update our readme. So
1682:54 - we're gonna say instead of
reading the events from ralis,
1682:58 - we will first off we're going to
index them with the graph. And
1683:02 - then we're going to read from
the graph. So the question is,
1683:05 - what is the graph.
1683:09 - So the graph is going to be a
decentralized layer for storing
1683:13 - event data. So there are all
these blockchains and all these
1683:16 - different storage networks. And
the graph is and the graph is a
1683:19 - network of different nodes that
read from blockchains and index
1683:23 - this data, and it exposes an API
for us to call we can read that
1683:27 - data. Rather than just myself.
We actually have nattered
1683:29 - Abbott, who can explain it a lot
better than I can take it away.
1683:32 - And at.
1683:33 - First, I'd like to thank Patrick
for creating such a wonderful
1683:36 - educational resource and
inviting me to be a part of it.
1683:39 - My name is Nadia dabit. I'm a
developer relations engineer
1683:42 - working with the graph. The
graph is an indexing and
1683:44 - querying protocol for
decentralized networks like
1683:46 - Aetherium IPFS, dozens of other
EVM compatible networks, as well
1683:50 - as near and then the future
cosmos and Solana. Using the
1683:53 - graph developers can build and
publish open API's called
1683:56 - subgraphs that they can then use
in their applications to enable
1683:59 - better querying capabilities of
data stored on these networks,
1684:02 - including features like
filtering, sorting, relational
1684:05 - data, and full stack search.
subgraphs live in between the
1684:09 - blockchain and the UI providing
an important piece of software
1684:12 - infrastructure, a flexible
performant and decentralized API
1684:15 - layer, and the traditional tech
stack databases, servers and
1684:19 - API's query filter, sort
paginate group and join data
1684:24 - before it's returned to an
application, usually via some
1684:27 - type of HTTP request. These
types of data transformations
1684:31 - are not possible when reading
data directly from Aetherium or
1684:34 - other blockchains. Before the
graph teams had to develop and
1684:37 - operate proprietary indexing
servers. This required
1684:40 - significant engineering and
hardware resources and broke the
1684:43 - important security principles
required for decentralization,
1684:46 - how we interact with and build
on top of blockchains it's much
1684:49 - different than what we are used
to in the traditional tech
1684:51 - stack. In a blockchain data
isn't stored in a format that
1684:54 - can be easily or efficiently
consumed, or retrieved directly
1684:58 - from other applications or front
ends. The problem is that you
1685:01 - need to have the data indexed
and organized for efficient
1685:03 - retrieval. Traditionally, that's
the work that databases and web
1685:07 - servers do in this centralized
tech stack. But that in indexing
1685:10 - layer was missing in the web
three stack. Let's take a look
1685:13 - at a couple of other examples of
indexing in the real world.
1685:16 - Search engines like Google crawl
the internet indexing relevant
1685:19 - data making it available for
users to search via their web
1685:22 - interface and other API's.
Without this indexing layer,
1685:25 - it'd be hard for us to know
where and how to find relevant
1685:28 - information across the web.
Another similar analogy is a
1685:31 - library. Using an indexing
system like the Dewey Decimal
1685:35 - System, we know where to find
the book that we're looking for
1685:38 - without having to go through
book by book looking throughout
1685:41 - the entire library. The graph
serves over 2 billion queries
1685:44 - per day to many different types
of web three applications,
1685:47 - including apps in the defy
gaming and FC space. Before we
1685:50 - dig into any code, let's take a
look at how to build a sub
1685:53 - graph. To get started, you would
go to the graph.com and create a
1685:56 - new sub graph and the graph user
interface. You would then use
1686:00 - the graph CLI to scaffold out an
empty sub graph boilerplate that
1686:03 - you can then update with your
own contract information. In
1686:07 - your subgraph configuration, you
would define things like your
1686:09 - data model, the network, the
contract addresses and other
1686:12 - configurations that are specific
to the data that you would like
1686:15 - to index. For our data model, we
use Graph QL, schema definition
1686:20 - language defining top level
types as well as fields within
1686:23 - those types. When we're ready to
deploy our subgraph, so we can
1686:26 - begin testing it out and using
it in our application, we can
1686:29 - use the graph CLI running the
deploy command. Once the
1686:33 - subgraph is deployed and the
data begins to be indexed, we
1686:36 - can start testing it out using
the graphical interface directly
1686:39 - in the graph dashboard. When
we're ready to start queering,
1686:43 - our sub graph from our
application, we can use the API
1686:45 - URL that's been given to us by
the graph along with any Graph
1686:48 - QL query. If you'd like to learn
more about the graph, check out
1686:53 - the graph.com as well as Graph
Protocol, Twitter, the docs at
1686:57 - the graph.com/docs, or our
Discord at the graph.com/discord
1687:02 - Thanks matter. And now that we
have a better idea of what the
1687:04 - graph is, we can actually start
building with it. Now if we were
1687:09 - to try to run this app as it is,
it obviously would fail, right,
1687:13 - because index.js, right now is
reading from mirallas instead of
1687:18 - from the graph. So like it says
in our readme, first thing we're
1687:21 - going to need to do is we're
gonna need to index from the
1687:24 - graph, and then we can just this
project to read from the graph.
1687:28 - So let's go ahead and learn how
to build our sub graph. In order
1687:31 - for us to tell the graph network
to start indexing the events
1687:35 - from our contract, we're gonna
go to graph.com, we're gonna go
1687:39 - to products. And we're going to
go to sub graph studio, if you
1687:43 - go to products, the first thing
you see is the Graph Explorer,
1687:46 - these are already existing sub
graphs. And if you go through
1687:49 - here, you'll see a lot of
incredibly popular decentralized
1687:52 - protocols all have different sub
graphs, hosted service is going
1687:55 - to get discontinued at some
point. So we're going to skip
1687:57 - there. So let's go to sub graph
studio, this is going to help
1688:00 - enable us to create a sub graph
for other nodes to start
1688:03 - indexing our events. So we're
gonna go ahead and connect our
1688:06 - wallet with meta mask. And I'm
going to choose account one
1688:10 - here, next connect, and we're
going to want to switch off of
1688:15 - Hardhead. Local, over to the
Rinkeby test network. And I'll
1688:21 - go to Account one here. And
we're going to get a signature
1688:23 - request from the graph summary
to the website that we just
1688:27 - built. The subgraph website has
some signings functionality with
1688:31 - a database on the back end. So
we're seeing in real life,
1688:34 - exactly the methods that we just
used. So instead of signing with
1688:38 - Morales, they're just have their
own custom sign in here. So
1688:41 - we're gonna go ahead and sign in
so that the graph website knows
1688:44 - that it can interact with us.
And we can go ahead and enter
1688:46 - our email if we want. I'm gonna
go ahead and skip. And you'll
1688:50 - even get a little notification
here saying only subgraphs
1688:53 - indexing Aetherium or main net
or Rigby can be created in
1688:56 - subgraph studio. So let's go
ahead and create a subgraph. So
1689:00 - we're going to pick a cerium
Rigby and the subgraph name is
1689:04 - going to be NFT marketplace.
We'll go ahead and hit Continue.
1689:08 - Now, this is going to be our
dashboard for creating our sub
1689:11 - graph. And there's a ton of
instructions over here and
1689:14 - documentation that we can view
to get started, I'm going to add
1689:17 - this documentation to the GitHub
repo associated with this
1689:20 - course. So this NFT marketplace
sub graph is going to need its
1689:24 - own git repository itself. So
what we're going to do back in
1689:27 - here is we're going to CD down,
we're going to make a new
1689:30 - directory, and we're going to
call it graph. And if T
1689:35 - marketplace, FCC, we're going to
open that up as well. So code
1689:40 - graph NFT, marketplace, FCC, or
file open graft code marketplace
1689:46 - FCC, and in this window, we're
going to build our subgraph.
1689:50 - Locally, we're going to build
our subgraph and push it up to
1689:53 - the subgraph studio. And in
here, there's a whole bunch of
1689:56 - instructions that we can follow
along with to go ahead and
1689:59 - install. The first thing that we
need to do is install the graph
1690:02 - command line interface. And we
want to install this globally.
1690:06 - So I'm going to copy this part
here. Come back to my terminal
1690:10 - Oh, yarn, global ad and paste
that in. It's this command line
1690:15 - that's going to help us build a
graph and build instructions for
1690:19 - the graph to actually start
indexing our events. Now that
1690:22 - we've installed the globally, we
can initialize our graph code.
1690:26 - So we can copy this line. And
we'll run graph a knit dash dash
1690:31 - studio NFT marketplace and hit
enter. The protocol is going to
1690:35 - be Aetherium, or subgraph. Slug
will be NFT. marketplace. We
1690:40 - want the directory to be here,
but it's saying directory
1690:43 - already exists. So we'll just
give it NFT marketplace. And
1690:46 - then we'll move it after this.
And this is on the Rinkeby. Test
1690:49 - net. And now we want to give it
the contract address. So we want
1690:53 - to grab that address that we
just deployed. And it should be
1690:56 - now in our network mapping. So
we're going to grab that
1690:59 - contract address that we just
deployed, and paste it in here.
1691:04 - Like so. And since we've already
verified on ether scan, it
1691:09 - automatically grabs the ABI for
us from ether scan, we'll give
1691:12 - it the contract name, which is
the NFT marketplace. And it's
1691:16 - going to give us a whole bunch
of boilerplate code in this NFT
1691:20 - marketplace directory. And this
might take a couple of minutes.
1691:23 - Alright, awesome. So now that
it's done, we see subgraph NFT
1691:26 - marketplace created in NFT
marketplace. Now, I don't want
1691:30 - it to be in the seller folder.
So what I'm going to do is I'm
1691:32 - going to move it down a
directory, but you can leave it
1691:34 - where it is, if you want, I'm
going to say move, I'm going to
1691:38 - say move NFT marketplace, star
to dot slash. Now everything
1691:44 - inside of NFT marketplace will
be in this current directory.
1691:47 - And then if the marketplace will
be empty. So with that, I'm
1691:50 - gonna go ahead and delete. And
if the marketplace. Alright,
1691:53 - great. Now let me walk you
through exactly what's going on
1691:57 - here and what these files are
that we just created. So our
1692:00 - first folder is going to be
API's. In order for the graph to
1692:03 - index and read our contract
index our events, it's going to
1692:06 - need the ABI of our events. So
we've got the ABI of our entire
1692:11 - marketplace, from ether scan, if
we didn't verify an ether scan,
1692:15 - we can just create this API
folder ourself and add the NFT
1692:18 - marketplace JSON in here. Now we
have this generated folder. This
1692:22 - is an auto generated file. He
even says at the top, do not
1692:25 - edit this file directly. You can
kind of think of this as the
1692:29 - build folder, or where we
compile graph code. Node
1692:33 - modules, of course, is going to
be node modules and
1692:35 - dependencies. SRC is going to be
where we define and we tell the
1692:40 - graph, how to actually map and
how to actually work with our
1692:43 - contract. And it is a TypeScript
file. So for all of you who have
1692:47 - been just doing this in
JavaScript, I will have to teach
1692:50 - you a little bit of TypeScript
just to get through this part.
1692:53 - Then we have networks dot JSON,
which gives us all of our
1692:56 - network information about which
networks, what are the
1692:59 - addresses, and what are the
different contracts that we're
1693:01 - going to be indexing, package
dot JSON, which of course is
1693:04 - just a normal package dot JSON.
And it's got some graph scripts
1693:08 - already built in schema dot
graph. QL is going to be our
1693:12 - Graph QL schema. So this is also
going to be how we tell the
1693:16 - graph how to actually work with
our events and index our events.
1693:19 - And if you're familiar, the
schema follows the Graph QL
1693:22 - syntax. So if you've ever worked
with Graph QL, before, it's
1693:26 - going to be the exact same way,
graph. QL is a query language
1693:30 - for your API. And instead of
being kind of a relational
1693:33 - database, it can query in a more
graph type way, I'm not going to
1693:37 - go too deep into how it actually
works behind the scenes. But if
1693:40 - you want to learn more, I'm
going to leave some docs in the
1693:42 - GitHub repository associated
with this course, the sub graph
1693:45 - dot Yamo tells our subgraph how
to combine all the files
1693:48 - together. So we have data
sources, data sources, where
1693:51 - they're coming from different
addresses, different entities or
1693:54 - events, the API's where to grab
our files from different event
1693:58 - handlers, which we'll talk about
in a minute. And then the main
1694:01 - file, which is going to be our
mapping.ts, we have a TS config,
1694:04 - which is a configuration file
specific to TypeScript. And then
1694:08 - of course, we have our yarn dot
lock. With all this information
1694:11 - with all this code, we are now
going to update all this code to
1694:15 - tell the graph to start indexing
our events. So we can read our
1694:20 - events from the graph in a
decentralized context, as
1694:22 - opposed to from a centralized
database. And after we build
1694:26 - everything, we're going to run
through this off and deploy
1694:29 - code, which is to authenticate
ourselves, and then deploy our
1694:32 - code to the graph to start
indexing. So without further
1694:36 - ado, let's jump in. And let's do
this. So one of the first things
1694:40 - I'm going to do, I'm going to
add a highlighter for these dot
1694:43 - Graph QL files. So in our
extensions, we're gonna look at
1694:46 - Graph QL. And we're gonna stall
this Graph QL extension. Now
1694:51 - that we've installed it, if we
go back to schema dot graph, QL,
1694:54 - we've got it with some colors
now, which is exciting. So this
1694:57 - schema dot Graph QL is going to
define what entities we have in
1695:02 - our contract if we were to be
analogous to mirallas. These are
1695:06 - going to be how we're going to
define what our tables are going
1695:08 - to look like. And these are
going to be our events. plus
1695:10 - that active item table that we
created. So we're not going to
1695:14 - have an example entity though,
we're going to have a type
1695:18 - active item. And this is going
to be an add entity. So these
1695:22 - are the different types we have
in our graph that we can
1695:25 - actually query on, our main
thing that we're going to want
1695:27 - to query on is same as before,
it's going to be our active
1695:31 - items. And then inside of our
active items, we're going to
1695:33 - tell the graph, what parameters
each one of these active item
1695:37 - types has, well, it's going to
have an ID of type ID. So the
1695:42 - variable is ID of type ID. And
you can read more about the
1695:45 - different types in the graph
documentation. And this
1695:48 - exclamation mark means it must
have an ID. So every active item
1695:53 - needs to have and will have an
ID, we'll say there's going to
1695:56 - be a buyer, which is going to be
an address, so that's going to
1695:59 - be a byte and the buyer could be
blank, right? It could be the
1696:03 - 0x 000, we're going to have all
of our active items have a
1696:08 - 0000 dot.if. If no one has
bought yet, we're going to have
1696:13 - a seller, which of course is
also going to be a bytes because
1696:16 - it's going to be an address,
we're going to have an NFT
1696:19 - address. So the address of the
NFT, which will also be bytes,
1696:22 - we're going to have a token ID
which isn't going to be bytes,
1696:25 - this is going to be of type big
int, and then we're going to
1696:28 - have a price, which is also
going to be a big int. Now price
1696:32 - we're going to leave as not
required for price, we're just
1696:35 - going to have price be nullable.
So price can be null. So we have
1696:39 - an active item. Awesome. What
else are we going to need? What
1696:42 - what other tables do we have in
Morales? Well, we're going to
1696:44 - need type item listed. And this
is going to be at entity is
1696:50 - going to need an ID, it'll have
a seller. Whenever an item gets
1696:54 - listed, it's going to have a
seller right, which is going to
1696:57 - be a bytes again. And if the
address the address of the NFT,
1697:00 - which will also be bytes, the
token ID, which is going to be a
1697:05 - big int, and then the price,
which will also be a big end,
1697:09 - we're gonna need a type item
cancelled at entity
1697:15 - which will have an ID seller an
NFT address. And a token ID will
1697:28 - be a big end. And then last type
item bought will be in that
1697:34 - entity is going to have an ID
ID. It's going to be a buyer
1697:41 - bytes.
1697:43 - And then of T address a bytes
and a token ID again, and then a
1697:53 - price of beginnt. And with
Justice Information, we've
1697:56 - defined what we want our
subgraph to keep track of wants
1698:00 - to keep track of item bought
events, item, cancelled events,
1698:03 - item listed events. And then
we're going to make this new
1698:07 - active item table similar to
what we did with mirallas. And
1698:10 - it's going to be some function
of these these other three
1698:13 - events. And now we're done with
our schema dot graph. QL.
1698:17 - Awesome. So what do we do now
we're going to need to tell our
1698:20 - sub graph to actually listen for
these events. So what we can do.
1698:24 - So what we want to do to tell it
how to listen for these events,
1698:27 - is we're going to go to src
mapping.ts. It's this mapping.ts
1698:33 - file that's going to tell our
subgraph how to actually map and
1698:37 - how to actually store all the
event information that we have.
1698:40 - If you look in it right now, it
might even give you kind of a
1698:43 - sample event. So it says Export
function, handle item event.
1698:47 - This is what Maya says right
now, it takes as an input
1698:49 - parameter event item bot. So
this is saying whenever an item
1698:54 - bot event occurs, do this handle
item bot function. So anytime
1698:59 - item bot happens do this handle
item bot. And we're actually
1699:02 - getting this item bot from our
generated NFT marketplace from
1699:07 - some generated code. In the
graph. If we run graph code Gen.
1699:12 - This graph code Gen command
grabs all the stuff we have in
1699:16 - the schema dot Graph QL and puts
it in this generated file. Now
1699:20 - that I've run graph code Gen,
you'll see in here there's an
1699:23 - item bot class, you see there's
a schema, that type script. And
1699:27 - actually we can even find that
new active item class that we
1699:31 - created in our schema. So
anytime you update schema dot
1699:35 - Graph QL, you're always going to
want to run graph code Gen, so
1699:39 - you can update those types. And
if this failed, it means that
1699:42 - you messed up something in your
schema dot Graph QL. Now in our
1699:45 - mapping.ts, we're actually
importing item bought item
1699:48 - cancelled item listed from
generated and if the marketplace
1699:53 - and if the marketplace from our
generated code. These are going
1699:56 - to be our events. And we're not
going to need to do anything
1699:59 - with the NFT marketplace. We're
just going to need our event
1700:01 - information. For now. Let's go
ahead and just delete everything
1700:04 - inside our handle item bot or
whatever sample is given to you.
1700:09 - So we're importing a or events
from our generated code. And
1700:13 - then we have this line here,
which we're going to change in a
1700:16 - second. So again, we have these
three functions handle item
1700:19 - bought, handle item canceled and
handle item listed. Whenever we
1700:22 - get an item bought event, we're
going to do this function.
1700:25 - Whenever we get an item canceled
event, we're going to do this
1700:27 - function. And all this code is
defined in our sub graph dot
1700:32 - Yamo. You can see the different
entities here in a bot item
1700:35 - cancelled item listed, and the
event handlers. So it says,
1700:39 - okay, anytime this specific
event gets fired with an index
1700:45 - address, an index address index,
YouTube 36 in YouTube had six
1700:49 - call handle item bought, which
again, we're getting in here
1700:52 - handle item. But so that's
exactly how this works. So let's
1700:56 - figure out what to do when an
item bought event triggers. And
1701:00 - I think that item bought item
cancelled item lists it is a
1701:03 - little confusing. So I like to
change this to item bought as
1701:08 - item bought event item cancelled
as item cancelled event item
1701:16 - listed as item listed event. So
I'm just changing the names of
1701:22 - these three that are imported
from NFT marketplace. And now
1701:26 - I'm going to change event item
bot to item bought event. Event
1701:30 - item cancelled to item cancelled
event and event item listed to
1701:33 - item listed event. Okay, great.
And we're just going to remove
1701:37 - this line for now. And we also
don't need this line at the top
1701:39 - at the beginning, we will in a
minute, but we'll delete it for
1701:42 - now. So here's our minimalistic
code here. So whenever we list
1701:46 - an item, what do we need to do?
Well, we need to save that event
1701:50 - in our in our graph. And then we
also need to update our active
1701:54 - item, exactly as we did with
Morales. So first thing that
1701:58 - we're going to need to do is
either get or create an item
1702:01 - listed object. And something
that we need to know is that
1702:04 - each item needs a unique ID. And
we actually need to create that
1702:09 - ID. So one of the first things
I'm going to do is going to
1702:12 - create a function called Get ID
from event params. And it's
1702:18 - going to take a token ID and
here's where TypeScript comes
1702:20 - into play a little bit. In
TypeScript, we actually need to
1702:23 - define the types of our
different parameters. So token
1702:26 - ID is going to be a big int. And
we'll also take an NFT address,
1702:31 - which will take in a type of
address. And we also need to say
1702:35 - what return type or function is
going to give, which we're going
1702:38 - to return a string, we're going
to create an ID from event
1702:42 - params. And it's just going to
be a combination of the token ID
1702:45 - and the NFT address. The
combination of these two will
1702:48 - give a unique ID for each one of
these types of event. So we're
1702:52 - just gonna say return token ID,
and token ID has a function
1702:56 - called to x string, I'm gonna
say plus, and if T address.to X
1703:03 - string, like so. And big int an
address, we need to import from
1703:08 - at Graph Protocol slash graph
TX. It already imported big
1703:11 - enough for me. So I'm just going
to add address in here is the
1703:15 - two special types that come from
the graph. And then string is
1703:17 - built into TypeScript. Now that
we have a way to get a special
1703:20 - ID for each item in our function
here, we have to now either get
1703:25 - or create a new item listed. Now
right now we have an item. But
1703:30 - event we don't have an item
bought object. So the item
1703:34 - bought object is going to be
what we save, the item bought
1703:38 - event is just the raw event. So
we have to create an item bought
1703:42 - object from our item bought
event. And in TypeScript, these
1703:46 - are going to be two different
types. So we have to import
1703:49 - these item by objects. So those
actually get auto created from
1703:53 - generated schema. In here we
have active item, we have item,
1703:57 - we have an item bought class, we
have an item cancelled, etc. So
1704:02 - we're gonna have to import those
types from there. So we can say,
1704:05 - import, item listed, comma,
active item, item bought an item
1704:12 - cancelled from dot slash,
generated slash schema. Let's go
1704:18 - ahead and get or create an item
bot object. So we'll say let
1704:23 - item bot equals item bot dot
load. And this is how we load an
1704:30 - item we load its unique ID by
calling this get ID from event
1704:34 - params dot load, get ID from
event params. And we can pass
1704:42 - event dot params. That token ID
1704:46 - because an item bot event is
going to have a token ID and
1704:50 - event that params.nf T address.
Now I know we probably should
1704:55 - have done handle item listed
first but we're doing item bot
1704:58 - first. Since we're buying an
item, we probably will also have
1705:02 - an active item as well, right?
We haven't made yet an item
1705:05 - listed. But this is going to be
similar to what we did with
1705:07 - Morales. So we know that every
time we live Certain items will
1705:11 - also list an active item. So
we'll say let active item equals
1705:17 - active item that load. And we're
going to do this exact same
1705:21 - thing. So I'm just going to copy
paste it into here. And even
1705:25 - though these are going to have
the exact same ID, it doesn't
1705:28 - matter because they're the same
ID across different types. Now
1705:33 - we're gonna say, if there is no
item bot, we'll say item bot
1705:38 - equals a new item bot object.
And we'll give it an ID, which
1705:45 - is going to be exactly our ID
giving parameter here, get ID
1705:49 - from events, and pass that
there. So we're going to create
1705:52 - a new item bought here. And now
we're going to update all its
1705:55 - parameters. So back in our
schema dot graph, QL. An item
1705:59 - bought has an ID, buyer address,
token ID and price. So we're
1706:03 - gonna say, item bought, that
buyer equals event dot params
1706:10 - dot buyer, item bought.nf T
address equals event.params.nf T
1706:18 - address, item bot, dot token ID
equals event dot params dot
1706:25 - token ID. And that looks good.
And our active item will be from
1706:28 - item listed, and item listed
should give it all these
1706:32 - parameters, except for it won't
have a buyer. So we just need to
1706:35 - update the buyer on our active
item. So we'll say active item,
1706:40 - dot buyer, we'll do a little
exclamation mark. This is some
1706:43 - TypeScript stuff, saying we will
have an active item. Don't worry
1706:46 - too much about it if you're
unfamiliar with TypeScript. And
1706:48 - we'll say that equals event dot
params dot buyer. And now
1706:53 - similar to Morales, we're gonna
do item bot dot save and active
1706:58 - item with an exclamation mark
again, that save and this is how
1707:02 - we're going to save this item
bought event as an object in our
1707:06 - the Graph Protocol. And also,
we're going to update our active
1707:09 - item. So this is our full
function of handle item bought.
1707:13 - Whenever somebody buys an item,
we update a new item bought
1707:16 - object, and we update our active
item to be a new buyer, we're
1707:21 - not going to delete it from our
active items list, we're just
1707:24 - going to update it with a new
buyer. And we'll just say if it
1707:27 - has a buyer, that means it's
been bought. If it doesn't have
1707:30 - a buyer, that means it's still
on the market. Awesome. So now
1707:34 - that we've done our handle item
bot, let's now do our handle
1707:37 - item listed, which will
hopefully make our handle item
1707:39 - bot a little bit easier to
understand. So for handle item
1707:42 - listed, we're going to do the
same piece here. So we're going
1707:45 - to say let item listed equals
item listed dot load. And we're
1707:51 - gonna do the exact same thing as
what we did for all these will
1707:55 - do get ID from event params.
Like so, get a different event
1707:59 - params. And we're gonna say let
active item. And this line is
1708:03 - going to be exactly the same as
up here. So I'm just going to
1708:07 - copy paste. So we're saying,
okay, great, grab our item
1708:11 - listed, and grab our active
item, see if those objects
1708:14 - already exist. I will say if
there is no item listed, which
1708:18 - there shouldn't be, we'll go
ahead and create a new one,
1708:20 - we'll say item listed
1708:23 - equals new item listed. And its
ID is going to be from this
1708:28 - function that we created are
unique IDs. Now, unlike what we
1708:32 - did above, we're also going to
say, if there is no active item,
1708:37 - then we're going to create a new
active item, right? Because
1708:39 - we're listing an item, it
shouldn't be an active item. Now
1708:42 - this functionality is going to
make a lot more sense here,
1708:44 - right? Because if we're updating
the price of an item, active
1708:47 - item will already exist. If it's
a brand new listing, though,
1708:51 - active item will not exist. So
we'll say okay, if it doesn't
1708:55 - exist, okay, that means it's a
brand new listing, we'll say
1708:58 - item listed equals new item
listed, and then we'll give it
1709:03 - an ID. That's the same ID
methodology, paste that in. So
1709:08 - now all we got to do is update
these new objects. So I will say
1709:13 - item listed that seller equals
event dot params dot seller. And
1709:19 - I'm just going to copy paste
this line. Because this is just
1709:22 - gonna be active item dot seller
now. Oops, see me and then it'll
1709:27 - make this active item. active
item instead of item listed. And
1709:31 - what else comes with item
listed? Well, let's go to the
1709:33 - schema item listed has an NFT
address, token ID and a price.
1709:38 - So okay, so let's add those.
item listed dot NFT address
1709:45 - equals event.params.nf T
address. Copy paste this line
1709:50 - because it's gonna be the be the
exact same for active item. Now
1709:55 - item listed that token ID equals
event dot params dot token ID.
1710:02 - Copy paste this line. Same thing
for active item. Item listed dot
1710:07 - price equals event dot params
dot At price, copy, paste this
1710:12 - line for active item. And then
we just say those two. So item
1710:17 - listed that save active item.
Save. So in our protocol here,
1710:25 - if it's already been, if there
already is an active item, then
1710:28 - we just go ahead and we get that
active item. This would be for a
1710:31 - listing that we're updating. If
not, we make a new one. We
1710:35 - update it with whatever came in
through the event. And then we
1710:38 - save it to our graph protocol.
Okay, perfect. Now we only have
1710:42 - one left, item cancelled. So
let's figure out how to do item
1710:45 - cancelled, it's going to look
really similar to item bought.
1710:48 - So we'll say let item cancelled
equals item cancelled that load.
1710:55 - Again, we're going to do this
exact same Id get our that we're
1710:58 - doing for everything, we'll say
let active item equals, and I'm
1711:03 - going to zoom out a little bit
less active item equals active
1711:08 - item dot load. Or do this exact
same thing here. Boom. And then
1711:14 - we're gonna say, if not item
cancelled, which there shouldn't
1711:20 - be because this should be the
only item canceled event here.
1711:23 - We'll say item cancelled, equals
new item cancelled. And we're
1711:30 - gonna give it an ID using the
same ID methodology we've been
1711:33 - using. Now this is going to look
a little bit different. We're
1711:36 - gonna say item canceled, that
seller equals event dot params
1711:41 - dot seller. So far, so good.
Item canceled dot NFT address
1711:47 - equals event dot params dot NFT
Address item canceled dot token
1711:52 - ID equals event dot params dot
token ID. And then finally, we
1711:58 - are going to change the active
item a little bit different than
1712:00 - what we've seen. active item
exclamation mark again, ignore
1712:04 - if you're confused by that dot
buyer. And we're going to update
1712:08 - the buyer to equal address dot
from string.
1712:13 - We're going to give it what's
called the Dead address. And
1712:16 - that's this right here.
0x 1-234-567-8910 1112 1314
1712:22 - producing 718 1920 21 to two to
three to 45 to 67 to
1712:25 - 8930 3130 230-334-3536 zeros
lowercase d, uppercase E,
1712:34 - lowercase A uppercase D, this is
known as the dead address. And
1712:38 - this is how we're going to
decide if an item is still on
1712:41 - the marketplace or not. Or if an
item has been bought or not. If
1712:45 - we have the dead address as its
buyer, that's going to mean that
1712:49 - the item has been cancelled. And
that's how we are going to be
1712:51 - able to tell that an item is on
the marketplace or not dead
1712:54 - address means it's been
cancelled. An empty address,
1712:58 - which is what will happen for
handle item listed means it's on
1713:01 - the market. And an actual real
address means that it's actually
1713:05 - been bought by somebody. So the
way we can tell if it's on the
1713:07 - market is it's 0x 0000000.
Because the data address is
1713:12 - obviously going to be different
than than all zeros. The data
1713:15 - address is a commonly used
address kind of as a burner
1713:18 - address that nobody owns, then
we can just say, item cancelled
1713:22 - that save an active item that
say active item, exclamation
1713:28 - mark dot save and perfect. Our
mapping file is now completed.
1713:33 - We now have three different
functions to define how to
1713:36 - handle when items are bought
events, how to handle when items
1713:39 - are cancelled event and item
listed events. And if you're
1713:43 - confused, remember all the code
for this is available on this
1713:46 - the graph section of my GitHub.
So you can just follow along
1713:49 - with the code here, if you ever
get lost or need help. And with
1713:52 - that, we're almost ready to tell
our subgraph to start listening
1713:55 - to our contracts, there's just
at least one more thing that we
1713:58 - want to do. So in our sub graph
dot Yamo, we'll see source
1714:03 - address blah, blah, blah, this
is telling us to start indexing
1714:06 - events since the beginning of
Aetherium. Now we don't really
1714:10 - want it to do that, because it
will take a really long time, we
1714:13 - want to tell our subgraph Hey,
you don't just start from
1714:15 - beginning of time, you just need
to start from right before our
1714:19 - contract was deployed. So we can
add what's called our start
1714:22 - block to tell it what block
number to start deploying. Now
1714:26 - if we have our address, which we
do right here, we can copy it,
1714:30 - we can paste it on to the rink
fee, ether scan, paste it in
1714:35 - here, or really any block
Explorer, and we'll see what
1714:38 - block number our contract was
deployed. And it looks like it
1714:42 - was this block. So I'm going to
copy that address, go back to my
1714:46 - code and say starting block,
it's going to be right here.
1714:50 - Starting block is going to be
when it was deployed, minus one.
1714:55 - So we're gonna go right before
we deployed our contract, we're
1714:58 - going to start reading any event
that is indexed from it. Now if
1715:02 - you just deployed this, it might
not have any events in it at
1715:05 - all, which we're going to fix in
just a minute so don't worry,
1715:08 - but with that all the
instructions for how to build
1715:10 - Our sub graphs are ready to be
deployed to the graph, start our
1715:14 - indexing and start working with
our instructions in a
1715:16 - decentralized context. So what
we can do now is back in the
1715:22 - graph, we actually have the auth
and deploy code right here, we
1715:27 - can copy this, this graph auth
dash dash studio, which is our
1715:32 - deploy key on how to deploy. And
we can run this in our code
1715:35 - editor. So we're going to paste
that in here, graph off dash
1715:39 - studio, hit enter. And we're
gonna say deploy key set for the
1715:43 - graph. So this is just setting
us up so that whenever we push
1715:46 - our code, it's going to push it
to this sub graph configuration
1715:49 - that we've made on their site to
help us deploy automatically.
1715:52 - Now we can do, we don't need to
enter the subgraph, because
1715:55 - we've already moved stuff down,
is we'll build the sub graph,
1715:59 - we'll run graph code Gen, we can
just run graph kojem,
1716:04 - which again, is just going to
make sure our schema dot Graph
1716:07 - QL looks good. And then we're
going to run our graph build.
1716:11 - And this graph build command is
going to compile and run all of
1716:15 - our sub graph stuff, everything
in mapping that JSON all our
1716:18 - generated code. And it's going
to put this into a real build
1716:21 - folder, the generated folder has
kind of like a pseudo build
1716:24 - folder. And then we have a real
build folder. So the generated
1716:27 - is just to build some typings
for our TypeScript. And it's
1716:30 - this build folder, this real
build folder, is what we're
1716:33 - going to actually be deploying
and sending to the graph. And we
1716:36 - can actually deploy our
subgraph. Now, with graph deploy
1716:40 - dash s studio. And if the
marketplace, which we're going
1716:43 - to run right now, now is going
to give us a version label
1716:46 - option, which we're going to
give it the 0.0 point one, since
1716:51 - this is our first version, and
it goes ahead and starts
1716:54 - deploying it to the graph, we
also get to upload our sub graph
1716:58 - to IPFS. And we have a little
hash right here for IPFS for a
1717:02 - subgraph that we could look at.
But now if you're successful, we
1717:05 - now have this build completed
thing. And we have these sub
1717:09 - graph endpoints for queries and
subscriptions. So we can
1717:12 - actually start querying and
subscribing to our sub graph.
1717:16 - But if we go back to our site
here now and we hit refresh, we
1717:20 - can now see status deployed, we
can see that we're sinking. And
1717:24 - now we have some nodes that are
listening for our events to be
1717:28 - emitted here, which is
incredibly exciting. We can go
1717:31 - to logs to see if anything went
wrong. And right now it's just
1717:34 - indexing, it's listening. It's
going through all the different
1717:37 - blocks in the blockchain,
listening for our events. And
1717:40 - then we have a playground here
where we can run some queries to
1717:43 - see different events and the
different responses from our
1717:46 - Graph QL, which right now, it's
totally blank, because we
1717:50 - haven't done anything yet. So
once again, let's pull up our
1717:53 - hard hat and ft marketplace
code, or open it up in a new
1717:57 - terminal, whatever you want to
do. And let's go ahead, and
1718:00 - let's run our mminton list
script. But for rink B, so we'll
1718:05 - do yarn, hard hat, run scripts,
mint, and list item dash dash
1718:11 - network Rinkeby. So we're going
to mint an NF T, right, this is
1718:16 - going to be to transaction, so
we're gonna have to wait a
1718:17 - little bit, and then we're going
to approve the NFT. And then
1718:20 - we're going to list it on our
marketplace. And once it's
1718:22 - listed, it's going to emit an
item listed event. And we should
1718:26 - see now we have an active item
and an item listed data in our
1718:30 - Graph QL. Now you can learn more
about now what you see here on
1718:34 - the left hand side is what's
known as a Graph QL query. Now,
1718:37 - we're not going to go over how
to do these, but I'm going to
1718:39 - leave some links in the GitHub
repository. If you want to learn
1718:42 - how to do more of these queries,
these are going to be similar to
1718:44 - what we saw with Morales. But
instead of them being kind of
1718:47 - regular table lookups. They're
in Graph QL syntax, and the
1718:50 - results of our query, end up
being over here, we can see more
1718:53 - information about our schema all
the way to the right over here.
1718:56 - But if we look at our code, now,
we've made the NFT approved it
1719:00 - we've listed it on our
marketplace. So now if we go
1719:04 - back to the graph, and we run
this query, and we do a little
1719:09 - refresh on our NFT marketplace,
we might have to wait a few
1719:12 - minutes for the graph to index
these new blocks. But in our
1719:15 - playground, we should see the
show up as a query. If you don't
1719:19 - automatically get these you can
pause the video to write these
1719:22 - into your Graph QL playground,
right? So after a few minutes,
1719:27 - refresh on ether scan, I can see
that list item transaction has
1719:30 - gone through. This means we've
emitted a new event. So if I
1719:34 - come back to my playground, and
I hit play here, oh my goodness,
1719:38 - we can see we have active items.
And we see we have item listed.
1719:42 - This is fantastic. That means in
a decentralized context, we have
1719:46 - a off chain service that is
indexing our events for our
1719:49 - contract so that we can update
our front end and we can update
1719:52 - people in a decentralized way.
This is so exciting.
1719:59 - Awesome, so now that we have
this all set up, we can finally
1720:01 - go back to our next JS project
or next Jas NFT marketplace the
1720:07 - graph FCC. The reason we did all
this is because right Now in our
1720:11 - code base for our next Jas NFT
Marketplace application, we're
1720:15 - reading from a Morales database,
which we're not going to do
1720:18 - anymore. Instead of reading from
a Morales database, we're going
1720:21 - to read from the graph, let's go
ahead and learn how to update
1720:24 - our code our index dot j, s to
read from the graph instead. So
1720:29 - to highlight this, to show this,
we're actually going to create a
1720:31 - new page, a new file, and we're
just going to call it graph,
1720:35 - example, dot j, s. And we're
just gonna make this a really
1720:39 - minimalistic page to show you
how to do a graph query. So
1720:43 - similar to index dot j, s, we're
gonna do export default graph
1720:49 - example. It's going to be a
function, or default function,
1720:54 - graph example. And we're gonna
use this tool called Apollo
1720:57 - client, copy, paste it over. And
we're going to add it with yarn,
1721:00 - add dash dash dev at a P O ll O,
slash, client, or excuse me, not
1721:07 - Dev, because we do need this on
the front end. So yarn add at
1721:11 - Apollo slash client. Oh, sorry,
we also need to do yarn, add
1721:16 - Graph QL, we need to add both of
those. And it's this Apollo
1721:20 - slash client, which is how we're
going to make queries to our
1721:23 - newly created graph. QL. So
we're gonna say import the use
1721:28 - query hook, from this package we
just installed from at a P, O,
1721:34 - ll o slash client. And we'll
also import G QL. So to create a
1721:39 - new query, we'll say const, get
active item equals g QL. And
1721:47 - we'll add this backtick here.
And we'll add all of our Graph
1721:51 - QL stuff in here, this is gonna
be equivalent to this, this is
1721:54 - Graph QL. Syntax. And we're
gonna be putting this Graph QL
1721:57 - syntax into our code base here.
But we only want to get the
1722:01 - active items. So how are we
going to get the active items?
1722:04 - Well, we can actually build it
over here on our playground
1722:08 - first, and then add it to our
code base. So we'll say we want
1722:12 - to grab the active items, we'll
grab the first five, and then
1722:19 - we'll say where the buyer is
going to be 0x 12345678. We're
1722:28 - saying where the buyer is empty.
So we're grabbing the active
1722:31 - items where there is no buyer,
and then we're going to do and
1722:35 - then we're going to get the ID,
the buyer, the seller, the NFT
1722:42 - address, token, ID and the price
from that. And if we hit run, we
1722:51 - get our active item here. So we
see here, the buyer is this
1722:55 - exact 0x 12345678 Because it
gets defaulted to zero when
1723:02 - there is no buyer. And this is
why for item cancelled, we
1723:05 - updated the buyer to be that
dead address. So if it's bought,
1723:08 - it won't be active anymore. And
if it's cancelled, it also won't
1723:11 - be active anymore. Now we can
copy this query and paste it
1723:16 - into our code. And now we have a
Graph QL query that we can use
1723:21 - for our graph example. Now in
our graph example, we'll use
1723:24 - this query with this use query
hook. So in export default
1723:27 - function, graph example, we can
say const. And it comes with a
1723:31 - whole bunch of stuff like
loading error, and then the data
1723:35 - returned equals, use query. And
then we'll just pass it this Get
1723:41 - active item, or get active
items, let's put an S on it, get
1723:45 - active items. And then we can
just return return a little div.
1723:51 - And we'll say hi in the div, and
then we'll just do console dot
1723:54 - log data. And then now we'll go
back to our app.js, where we're
1723:59 - wrapping everything in a Morales
provider, we also need to wrap
1724:02 - everything in an Apollo
provider. And we need to
1724:05 - initialize it kind of similar to
how we initialize connecting to
1724:08 - our morale server, but we're
going to initialize connecting
1724:11 - to our Graph QL. So we're gonna
say import a P O ll o provider,
1724:18 - a P O ll o client, and in mem
ory, cache from at a P O ll o
1724:29 - slash client, like that, and
then we'll have to initialize
1724:33 - this so we can delete the morale
stuff. We'll initialize this
1724:36 - client by saying const client
equals new a P O LL. O client,
1724:43 - and we'll give it the parameters
here. And you can find this all
1724:46 - in the Apollo client
documentation will say there's
1724:49 - going to be a cache to help when
we do refreshes and stuff we'll
1724:52 - say new in
1724:55 - memory cache, and we'll say
comma URI, a que where we're
1725:01 - going to be connecting. And this
is where we're going to add the
1725:03 - API for our sub graph. So if we
go back to details, we can see
1725:08 - temporary query URL and this is
a rate limited temporary query,
1725:12 - because this is just a test net,
and we're going to copy this, go
1725:15 - back to our code. And we're just
going to paste it in here. So
1725:17 - whatever you have for temporary
query URL, and your sub graph
1725:21 - studio, that's where you're
gonna paste in here. Now, this
1725:24 - client tells our Graph QL, where
it should be making those
1725:28 - queries. And we're gonna make it
to here. Now, this starts with
1725:31 - HTTPS. So is this centralized?
Yes, because we are directly
1725:35 - calling the graph website.
However, all the data is still
1725:40 - gonna be stored in this
decentralized graph indexer. And
1725:43 - kind of similar to what we did
with IPFS, we're doing this kind
1725:46 - of as a gateway to make it a lot
easier for us to connect and
1725:49 - read the data from the graph
studio. However, in the future,
1725:53 - as more protocols and more
browsers adopt the graph, and
1725:55 - IPFS, this will become a lot
easier inside of our Morales
1725:59 - provider, but outside of our
notifications provider, we're
1726:03 - gonna say a P O ll o provider,
and then client equals client.
1726:11 - And then we're going to copy the
closing tag, and put it around
1726:15 - the notification provider and
press Save. Now I'm gonna save
1726:18 - our front end, now we're going
to try to run our front end. And
1726:20 - we're gonna have to change some
stuff in here because it's going
1726:22 - to freak out. So we're gonna run
yarn Dev, for new front end. So
1726:27 - we're gonna go to our localhost
3000. And it's going to totally
1726:30 - freak out, because we still have
some morale stuff in here. And
1726:33 - that's totally okay. We, of
course, we don't need a hard hat
1726:36 - Node running. Because we're on a
test net, we don't need to be
1726:38 - synched with Morales, we don't
need to be doing any of that
1726:41 - stuff. Because we're working
with a test net, right now, it's
1726:44 - actually not freaking out, which
is great. But it shows obviously
1726:47 - nothing for recently listed. So
what we're going to do now is
1726:50 - we're gonna do slash, graph
example, and hit enter. And we
1726:56 - can see Hi, show up. But if we
go to inspect, and we go to
1727:01 - console, a console here, we can
see an object here of active
1727:07 - items, which is returned from
the graph with buyer ID, NFT,
1727:12 - address price and all this stuff
in the air. This is fantastic.
1727:15 - So okay, okay. Okay. So all we
have to do now is we just have
1727:19 - to update. So let's go ahead,
we'll kill our server. For now,
1727:22 - all we have to do is update,
instead of use mirallas query,
1727:27 - we're going to delete this. And
we're just going to query from
1727:29 - Apollo query from our Graph QL.
And everything else stays the
1727:33 - same, right? Because our NFT
box, and all the rest of the
1727:37 - code that we worked with, will
still work exactly the same. So
1727:40 - first, we just got to get our
address. So we're gonna say
1727:42 - import, same as Sell, sell NFT,
import the network mapping, so
1727:46 - I'm actually just going to copy
it. So we're going to import
1727:49 - network mapping from constants,
network mapping dot JSON. And
1727:52 - now we can say const.
Marketplace, address equals, and
1727:59 - we're going to get the exact
same way we did this and sell
1728:01 - NFT to, so we're going to grab
this line getting the chain
1728:05 - string, we'll paste that in
here, which means we're going to
1728:08 - need to get chain ID from user
Morales. And then we're gonna
1728:12 - get the marketplace address like
this. So we're going to copy
1728:15 - that line, paste it in here.
Okay, great. Now we have the
1728:18 - marketplace address. So now
we're just going to do const.
1728:23 - Loading error data, which we can
do listed. And if T is again,
1728:29 - equals, use query, and we can do
that get active items. So what
1728:35 - I'm going to do is I'm going to
create a new file and constants,
1728:39 - we're going to pass that get
active items thing in their new
1728:42 - file, we're just going to call
it sub graph queries, dot j, s.
1728:47 - And then here, we're gonna say
import G QL. From at a Apollo
1728:53 - slash client. And we'll say
const, get active items, equals
1729:00 - g QL backtick. And exactly what
we did in that great, let's go
1729:05 - back to the graph example, we'll
just copy that whole line
1729:07 - actually pasted in here. And now
we'll just do export default,
1729:14 - get active items. And we'll
import this query from sub graph
1729:20 - queries into our index dot j s.
So we'll say import, get active
1729:26 - queries are skimming apt get
active items from dot dot slash
1729:31 - constants slash sub graph
queries. And now in our use
1729:37 - query will pass Get active
items, which should return are
1729:41 - listed NF Ts. So now, we'll
change this from fetching listed
1729:46 - NF Ts to loading, loading, or we
don't have listed NF Ts. So if
1729:54 - it's loading or we don't have
listen if TS then do loading,
1729:58 - otherwise, we're going to do
another mapping, but the return
1730:02 - of the Graph QL is going to be a
little bit different. So instead
1730:06 - of listing MTS dot map, it's
going to be listed NF T's dot AQ
1730:10 - two have items, dot map and f t,
and then we're going to get
1730:15 - price. And if the address token
ID, we're not going to get
1730:19 - marketplace address, but we'll
get seller from NFT. And it's
1730:22 - not going to be returned with
attributes. So we can just do
1730:25 - console dot log NFT instead. And
then we just pass all that stuff
1730:29 - normally to, to that NFT box
exactly the way that we did
1730:32 - before. So really, we're all
we're doing is we're swapping
1730:35 - out the query methodology here,
price is going to be from price
1730:38 - price is going to be from the
query, and ft address is going
1730:41 - to be from the query token ID
from the query marketplace
1730:44 - address, that's also gonna be
slightly different, we're going
1730:46 - to get that from our own config
seller is going to be from the
1730:49 - query, and then the key is going
to be from the query as well. So
1730:52 - now if we save that, if we
restart our website, with yarn
1730:57 - Dev, and we go back to our
homepage, we should see
1731:00 - everything exactly the same,
except for the images being
1731:04 - pulled from the graph, instead
of being pulled from her Alice.
1731:08 - Let's go back to our front end,
we'll give it a nice refresh,
1731:11 - close out the console. And we'll
go to our homepage. And I forgot
1731:15 - to do use query. So let's import
use query, import, use query
1731:22 - from at a Paulo slash client.
Let's save and let's go back and
1731:27 - give that a refresh. And oh, my
goodness, we now have updated to
1731:33 - get our events from a
decentralized data structure.
1731:38 - That's freaking awesome. Now
let's talk about hosting this
1731:43 - real quickly, we are using the
image tag in here in our NFT
1731:47 - box, we are using the image tag
in here from next Jas, which
1731:51 - comes with some pre processing.
So it's a little hard to use on
1731:54 - IPFS. So we would need to update
the way we do images in order to
1731:57 - host this on IPFS. But we still
can do that. Some other options
1732:01 - we have actually are Morales, we
can actually even host our apps
1732:04 - on Morales, if we want. We can
also use things like for cell or
1732:08 - Netlify, or etc, or really any
other traditional centralized
1732:11 - hosting service. Now, if you
want to, I challenge you to
1732:14 - update this code to make it be
able to be hosted on IPFS. So
1732:18 - that you'll have an end to end
decentralized. And if the
1732:21 - marketplace first wanted to make
a PR to this code, so that it
1732:24 - can be successfully hosted
completely end to end on IPFS
1732:28 - wins and empty for me. But wow.
And with that we are done with
1732:31 - less than 15. This is an
absolutely monstrous
1732:35 - accomplishment. And if you
finish this, if you've
1732:38 - understood everything, if you've
gotten through everything so
1732:40 - far, you should feel incredibly
proud of yourself. Because this
1732:43 - is our last full stack section,
our front end section and you're
1732:46 - a full stack monster at this
point. huge congratulations, you
1732:50 - should be super, super, super
proud. And definitely take a
1732:54 - break, go get a coffee, and get
ready for the final stretch of
1732:58 - lessons 1617 and 18. Those are
gonna go by a little bit
1733:01 - quicker. I'm very excited for
you take a break, and I'll see
1733:04 - you there.
1733:13 - Right, welcome to Lesson Six
tene, where we're going to be
1733:18 - going into even more low level
code here. The hard hat upgrades
1733:23 - of course, per usual, our entire
GitHub repository is located
1733:27 - here. And additionally, we have
an optional video that you can
1733:30 - watch. If you want to learn
more, we're actually going to
1733:33 - watch a slice of that video that
explains upgradable smart
1733:36 - contracts. So let's jump in. Now
I'm editing this video much
1733:39 - later after I filmed that, hence
why I have a beard so I'll be
1733:42 - jumping in from time to time
updating some of the sections.
1733:45 - When deploying your smart
contracts on chain. We all know
1733:48 - that those smart contracts are
immutable or unchangeable. But
1733:51 - what if I told you that they
were immutable?
1733:55 - Well, technically, that wouldn't
be correct. However, smart
1733:58 - contracts actually can change
all the time. When people
1734:01 - transfer tokens when people
stake in a contract or really do
1734:04 - any type of functionality. Those
smart contracts have to update
1734:07 - their balances and update their
mappings and update their
1734:09 - variables to reflect this. The
reason that they're immutable is
1734:12 - that the logic itself never
changes and will be on chain
1734:15 - like that forever. So
technically, yes, once they are
1734:18 - deployed, they are immutable.
And this is actually one of the
1734:20 - major benefits of smart
contracts in the first place
1734:22 - that nobody can tamper with or
screw with our smart contracts
1734:25 - once we deploy them. However,
this can be an issue if, for
1734:27 - example, we want to upgrade our
smart contract or protocol to do
1734:30 - more things, or want to fix some
glaring bug or issue that we
1734:34 - have. Now even though we can't
change the specific code that's
1734:37 - been deployed to an address, we
can actually do a lot more than
1734:39 - you think. And in this video,
we're going to explain the
1734:41 - different methodologies behind
upgrading your smart contracts.
1734:44 - And then we're going to show you
how to do it with hard hat and
1734:47 - open Zeppelin huge shout out to
a lot of open Zeppelin and
1734:49 - trilobites articles that helped
me put this video together and a
1734:52 - number of other sources as well
links in the description. So
1734:55 - let's get to it. Now at first
glance, you might be thinking,
1734:59 - if you can upgrade your smart
contracts, then they're not
1735:01 - really immutable that in a way
you'd be right. So when
1735:07 - explaining kind of the different
philosophies and patterns that
1735:09 - we can use here, we do need to
keep Behind the philosophies and
1735:12 - decentralization implications
that each one of these patterns
1735:15 - have, as they do all have
different advantages and
1735:17 - disadvantages. And yes, some of
the disadvantages here are going
1735:21 - to affect the centrality. So we
need to keep that in mind. And
1735:23 - this is why it's so important
that before you go ahead and
1735:26 - jump in and start deploying
upgradable smart contracts, you
1735:29 - understand the trade offs. So
we're going to talk about three
1735:31 - different ways to upgrade your
smart contracts. The first one
1735:34 - being the not really slash
Paramor ties way to upgrade your
1735:38 - smart contracts, the social
migration method, and then the
1735:41 - method that you probably have
heard about, which is proxies,
1735:44 - which have a ton of
subcategories, like metamorphic
1735:47 - contracts, transparent
upgradable, proxies, and
1735:50 - universal upgradable proxies. So
let's talk about the not really
1735:53 - upgrading method, or the
parameterization method, or
1735:55 - whatever you want to call it.
This is the simplest way to
1735:58 - think about upgrading your smart
contracts. And it really isn't
1736:01 - upgrading our smart contracts.
Because we can't really change
1736:04 - the logic of the smart contract,
whatever logic that we've
1736:06 - written, is there, we also can
add new storage or state
1736:09 - variables. So this is really not
really upgrading. But it is
1736:12 - something to think about
upgrades is just parameterizing,
1736:16 - everything, whatever logic that
we've deployed is there, and
1736:18 - that's what we're interacting
with this function means we just
1736:21 - have a whole bunch of setter
functions. And we can update
1736:23 - certain parameters. Like maybe
we have a reward parameter that
1736:26 - gives out a token at 1 percent, every
year or something like that.
1736:30 - Maybe we have a setter function
that says, hey, update that to
1736:33 - 2 percent, or update that to 4 percent. It's
just a setter function that
1736:36 - changes some variable. Now, the
advantages here, obviously, this
1736:40 - is really simple to implement.
The disadvantage is that if you
1736:43 - didn't think of some logic or
some functionality, the first
1736:46 - time you deployed their smart
contract, that's too bad, you're
1736:49 - stuck with it, you can't update
the logic or really update
1736:52 - anything with the
parameterization, aka, not
1736:55 - really method. And the other
thing you have to think about is
1736:57 - who the admins are, who has
access to these setter functions
1737:01 - to these updating functions. If
it's a single person, guess
1737:04 - what, you have a centralized
smart contract. Now of course,
1737:07 - you can add a governance
contract to be the admin
1737:09 - contract of your protocol. And
that would be a decentralized
1737:12 - way of doing this. So just keep
that in mind, you can do this
1737:14 - method just need a governance
protocol to do so another
1737:17 - example of this might be a
contract registry. And this is
1737:20 - something actually that early
versions of ABA used before you
1737:23 - call a function, you actually
check some contract registry
1737:25 - that is updated as a parameter
by somebody and you get routed
1737:28 - to the contract, and you do your
call there. Again, this really
1737:31 - doesn't allow us to have the
full functionality of upgrades
1737:33 - here, you can argue that this
registry is a mix of one of the
1737:36 - later versions. But for all
intents and purposes, this
1737:39 - doesn't really give us that
flexibility that we want for
1737:41 - upgrades. But some people might
even think that upgrading your
1737:44 - smart contract is ruining the
decent reality. And one of the
1737:47 - things that makes smart
contracts so potent is that they
1737:49 - are immutable, and that this is
one of the benefits that they
1737:51 - have. So there are some people
who think that you shouldn't add
1737:54 - any customization or any
upgradability, you should deploy
1737:57 - your contract. And then that's
it. trilobites has actually
1738:00 - argued that if you deploy your
contract, knowing that it can't
1738:04 - be changed later, you take a
little bit extra time, making
1738:07 - sure you get everything right.
And there are often less
1738:09 - security vulnerabilities because
you're just setting it
1738:12 - forgetting it and not looking at
it again. Now, if I wanted to
1738:15 - upgrade a smart contract with
this philosophy in mind, the
1738:18 - philosophy that I do want to
keep my smart contracts
1738:20 - immutable, we can instead use
the social migration method,
1738:24 - which I previously called the
Eat method. And now I think it's
1738:27 - less funny. So we're just gonna
stick with social migration, the
1738:30 - social eating method, or the
migration method is just when
1738:33 - you deploy your new contract,
not connected to the old
1738:36 - contract in any way. And by
social convention, you tell
1738:39 - everybody, hey, hey, this new
contract, this new one that we
1738:42 - just deployed? Yeah, this is the
real one now. And it's just by
1738:45 - convention of people migrating
over into using this new one,
1738:49 - that the upgrade is done, hence
my slang name of social yeet.
1738:51 - Because you use the first one
out of the way and move to the
1738:55 - second one.
1738:58 - I think I'm funny. Yeah, this
has the advantage of truly
1739:01 - always saying, Hey, this is our
immutable smart contract. And
1739:04 - this is our new one. This is
really the truest definition of
1739:07 - immutable, because since you
give it no way of being upgraded
1739:11 - in place, than if somebody calls
that contract in 50,000 years in
1739:15 - the future, it will respond
exactly the same. Another huge
1739:18 - disadvantage here is that you
have to have a totally new
1739:21 - contract address. So if you're
an ERC 20 token, for example,
1739:25 - you have to go convince all the
exchanges to list your new
1739:28 - contract address as the actual
address. Keep in mind that when
1739:31 - we do this, we do have to move
the state of the first one over
1739:34 - to the second one. So for
example, if you're an ERC token
1739:37 - moving to a new version of that
ERC token, you do, you have to
1739:41 - have a way to take all those
mappings from the first contract
1739:44 - and move it to the second one.
Obviously, there are ways to do
1739:46 - this, since everything is on
chain. But if you have a million
1739:49 - transfer calls, I don't want to
have to write the script that
1739:51 - updates everyone's balance and
figures out what everyone's
1739:53 - balance is just so I can migrate
to my new version of the
1739:56 - contract. So there's a ton of
social convention work here to
1739:59 - do. trilobites has actually
written a fantastic blog on
1740:02 - upgrading from a v1 to v2 or
etc. With this eat methodology
1740:07 - and they give a lot of steps for
moving your storage and your
1740:09 - state variables over To the new
contract. So link in the
1740:12 - description if you want to read
that. Now let's get to our big
1740:14 - ticket item. So in order to have
a really robust upgrading
1740:16 - mentality or philosophy, we need
to have some type of methodology
1740:20 - or framework that can update our
state, keep our contract address
1740:23 - and allow us to update any type
of logic in our smart contracts
1740:27 - in a easy way, which leads us to
our big ticket item is the
1740:30 - proxies. What's our big ticket
item?
1740:36 - proxies, proxies. Proxies are
the truest form of upgrades,
1740:41 - since a user can keep
interacting with the protocols
1740:43 - through these proxies, and not
even notice that anything
1740:46 - changed or even got updated.
Now, these are also the places
1740:49 - where you can screw up the
easiest. Proxies use a lot of
1740:52 - low level functionality. And the
main one being the delegate call
1740:56 - functionality. Delegate call is
a low level function where the
1740:59 - code in the target contract is
executed in the context of the
1741:04 - calling contract. And message
dot sender and message dot value
1741:07 - also don't change. So you
understand what delegate call
1741:09 - means. Now, right? Great. And in
English, this means if I
1741:12 - delegate call a function in
contract B from contract a, I
1741:17 - will do contracts B's logic in
contract a. So if contract B has
1741:22 - a function that says hey, store
this value in a variable up top,
1741:26 - I'm going to store that variable
in contract a, this is the
1741:30 - powerhouse. And this combined
with the fallback function
1741:33 - allows us to delegate all calls
through a proxy contract address
1741:38 - to some other contract, this
means that I can have one proxy
1741:41 - contract that will have the same
address forever. And I can just
1741:45 - point and route people to the
correct implementation contract
1741:49 - that has the logic, whenever I
want to upgrade, I just deploy a
1741:53 - new implementation contract and
point my proxy to that new
1741:57 - implementation. Now, whenever a
user calls a function on the
1742:00 - proxy contract, I'm going to
delegate call it to the new
1742:03 - contract, I can just call an
admin only function on my proxy
1742:07 - contract, let's call it upgrade
or something and I make all the
1742:09 - contract calls go to this new
contract. When we're talking
1742:12 - about proxies, there are four
pieces of terminology that we
1742:14 - want to keep in mind. First is
the implementation contract. The
1742:17 - implementation contract has all
of our logic and all the pieces
1742:20 - of our protocol. Whenever we
upgrade, we actually launch a
1742:23 - brand new implementation
contract, the proxy contract
1742:26 - proxy points to which
implementation is the correct
1742:29 - one. And routes everyone's calls
to the correct implementation
1742:33 - contract, you can think the
proxy contracts sits on top of
1742:36 - the implementations the user,
the user is going to be making
1742:39 - contract and function calls
through the proxy contract. And
1742:43 - then some type of admin, the
admin is the one who's going to
1742:46 - decide when to upgrade and which
contract to point to. In this
1742:50 - scenario, the other cool thing
about the proxy and delegate
1742:53 - call is that all my storage
variables are going to be stored
1742:56 - in the proxy contract and not in
the implementation contract.
1743:00 - This way, when I upgrade to a
new logic contract, all of my
1743:04 - data will stay on the proxy
contract. So whenever I want to
1743:07 - update my logic, just point to a
new implementation contract, if
1743:10 - I want to add a new storage
variable or a new type of
1743:12 - storage, I just add it in my
logic contract and the proxy
1743:16 - contract will pick it up. Now,
using proxies has a couple of
1743:19 - gotchas. And we're gonna talk
about the gotchas. And then
1743:21 - we're going to talk about the
different proxy contract
1743:23 - methodologies, because yes,
there are many proxy contract
1743:26 - methodologies as well. And this
is why trilobites doesn't really
1743:29 - recommend using upgradable
proxies for your smart
1743:31 - contracts. Because they're
fraught with a lot of these
1743:34 - potential issues. Not to
mention, again, you do still
1743:37 - have some type of admin who's
going to be upgrading your smart
1743:40 - contracts. Now, if this is a
governance protocol, then great,
1743:43 - you're decentralized. But if
this is a single group or
1743:45 - entity, then we have a problem.
The two biggest gotchas are
1743:50 - storage, clashes, and function
selector clashes. Now, what does
1743:55 - this mean? When we use delegate
call, remember, we do the logic
1743:58 - of contract B inside contract a.
So if contract B says we need to
1744:03 - set value to two, we go ahead
and set value to what these
1744:07 - smart contracts are actually
kind of dumb, we actually set
1744:11 - the value of whatever is in the
same storage location on
1744:14 - contract as contract B. So if
our contract looks like this,
1744:17 - and we have two variables and
contract a, we're still going to
1744:20 - set the first storage spot on a
contract a to the new value.
1744:24 - This is really important to know
because this means we can only
1744:26 - append new storage variables and
new implementation contracts.
1744:30 - And we can't reorder or change
old ones. This is called storage
1744:33 - clashing. And in the
implementations we're going to
1744:36 - talk about, they all address
this issue. The next one is
1744:39 - called function select or
clashes. When we tell our
1744:42 - proxies to delegate call to one
of these implementations, it
1744:45 - uses what's called a function
selector to find a function. A
1744:48 - function selector is a four byte
hash of the function name and
1744:52 - the function signature. Don't
worry about the function
1744:54 - signature for now. Now, it's
possible that a function in the
1744:58 - implementation contract has the
same function selector as an
1745:02 - admin function in the proxy
contract, which may cause you to
1745:05 - do accidentally a whole bunch of
weird stuff. For example, in
1745:08 - this sample code in front of you
even though All these functions
1745:11 - are totally different, they
actually have the same function
1745:13 - selector. So yes, we can run
into an issue where some
1745:17 - harmless function like get price
has the same function selector
1745:21 - as upgrade proxy or destroy
proxy or something like that.
1745:25 - This leads to our first of the
three implementations of the
1745:28 - proxy contracts. This is called
the transparent proxy pattern.
1745:32 - And it's actually going to be
the pattern that we're gonna be
1745:34 - demoing to you today. In this
methodology, admins are only
1745:37 - allowed to call admin functions.
And they can't call any
1745:40 - functions in the implementation
contract. And users can only
1745:44 - call functions in the
implementation contract and not
1745:46 - any admin contracts. This way,
you can't ever accidentally have
1745:50 - one of the two swapping, and
having a function selector clash
1745:53 - and you running into a big issue
where you call a function, you
1745:55 - probably shouldn't have, if
you're an admin, you're calling
1745:57 - admin functions. If your user
you're calling implementation
1746:00 - functions. So if you're an
admin, and you build some crazy,
1746:02 - awesome defi protocol, you
better come up with a new wallet
1746:05 - address because you can't
participate. The second type of
1746:07 - proxy we're going to talk about
is the universal upgradeable
1746:10 - proxy, or the
1746:11 - op amps. This version of
upgradable contracts actually
1746:18 - puts all the logic of upgrading
in the implementation itself
1746:22 - this way, the solidity compiler
will actually kick out and say,
1746:26 - Hey, we got two functions in
here that have the same function
1746:29 - selector. This is also
advantageous because we have one
1746:31 - less read that we have to do, we
no longer have to check in the
1746:35 - proxy contract if someone is an
admin or not. This saves on gas,
1746:39 - of course, and the proxy is also
a little bit smaller. Because of
1746:41 - this, the issue is that if you
deploy an implementation
1746:44 - contract, without any
upgradeable functionality,
1746:47 - you're stuck. And it's back to
the Eat method with you. And the
1746:51 - last pattern or methodology that
we're going to talk about is the
1746:53 - diamond pattern, which does a
number of things. But one of the
1746:56 - biggest things that it does, it
actually allows for multiple
1746:59 - implementation contracts. This
addresses a couple of different
1747:02 - issues. For example, if your
contract is so big, and it
1747:05 - doesn't fit into the one
contract maximum size, you can
1747:08 - just have multiple contracts
through this multi
1747:11 - implementation method. It also
allows you to make more granular
1747:14 - upgrades, like you don't have to
always deploy and upgrade your
1747:17 - entire smart contract, you can
just upgrade little pieces of
1747:20 - it. If you've chunked them out.
All the proxies mentioned here
1747:22 - have some type of Aetherium
improvement proposal, and most
1747:25 - of them are in the draft phase.
And at the end of this
1747:27 - explainer, we will do a demo of
showing you how the delegate
1747:30 - call function works. And the end
of the demo is right now. So
1747:35 - let's look at delegate call.
1747:39 - Now, we're going to learn about
how to actually build these
1747:42 - proxies how to build these
upgradable smart contracts. And
1747:45 - to do this, we first need to
learn about this delegate call
1747:48 - function. And it's going to be
really similar to the call
1747:51 - function, which we learned much
earlier. If you haven't seen
1747:53 - that, be sure to go back to our
Harnett. And if T's we have a
1747:56 - sub lesson in there, about EVM,
opcodes, and coding and calling
1748:00 - and we'll give you all the
context for delegate call. Like
1748:03 - I said, in the explainer, it's
very similar to call however,
1748:06 - the way that I think about it is
one contract says Oh, I really
1748:10 - like your function, I'm going to
borrow it myself. And we're
1748:13 - going to be looking at solidity
by example. I'll leave a
1748:15 - description in the GitHub. And
all the code for this will be in
1748:19 - the GitHub associated with this
lesson as well. Now we have two
1748:22 - contracts, we have this contract
B that we're going to be
1748:25 - deploying on remix and it looks
like a real minimalistic real
1748:28 - simple contract. We have a
couple of storage variables
1748:30 - here. And then we have a
function that updates our
1748:33 - values, we have a function
called Set VARs and updates are
1748:36 - you into public num? Now as we
learned before, whenever we have
1748:40 - some type of contract with
storage variables they get
1748:43 - stored in, in this storage data
structure that's index starting
1748:47 - from zero, right now are you
into public num is that index
1748:51 - zero, or sender's at index one,
our values and index two etc.
1748:55 - Now we're going to deploy a
contract a and now this contract
1749:00 - is actually going to use the
delegates call function. Now a
1749:03 - contract a this is going to look
a little bit different, but it's
1749:05 - still going to have this set
bars functions, except it's
1749:08 - going to make a delegate call
function call to our contract B.
1749:12 - Now in our lesson 14 with NF TS
we learned about call API dot
1749:16 - encode with signature API dot
encode etc. So if you're
1749:19 - unfamiliar with function
selectors, if you're unfamiliar
1749:21 - with if you're unfamiliar with
this syntax, be sure to go back
1749:24 - to lesson 14 To understand ABI
dot encode with signature and
1749:28 - contract dot call. The
difference here is we're doing
1749:32 - contract dot delegate call. What
this call does is something very
1749:36 - similar to call. Normally, if we
did contract dot call on this
1749:40 - contract, we would just call
this, we would just be calling
1749:43 - this function set VARs, which
would update contracts B's
1749:47 - storage, but instead we're
saying Hey, call that set VARs
1749:50 - function, and then pass this as
an input parameter, but call it
1749:54 - in our contract, call it on
contract a, we're kind of
1749:58 - borrowing a function for our
contract. And so instead, what
1750:02 - we're going to do, is we're
going to borrow this set bars
1750:05 - and run the set bars function
over here. Now the difference is
1750:08 - instead of num equals num The
variables could be named
1750:11 - different than the variables on
contract a. So instead of num
1750:15 - equals num, our contract is
going to say, hey, whatever that
1750:19 - storage of zero have that equal
to whatever we pass as an input
1750:23 - parameter. And if that's a
little bit confusing, just stay
1750:25 - with me. Let's go ahead and
let's see this in remix. So I'm
1750:28 - going to copy paste this code
into remix here. So we can kind
1750:31 - of test and see what this looks
like. Again, there's a link to
1750:34 - this in the GitHub repo
associated with this course,
1750:37 - feel free to pause the video to
grab this link. It's solidity,
1750:40 - hyphen, by hyphen,
example.org/delegate call, or
1750:44 - you can just grab the code
directly from lesson 16 Hardhead
1750:47 - upgrades. So let's compile this
code. And let me show you what I
1750:49 - mean. So I'm going to compile
it, and we'll go to the Run tab.
1750:53 - And first let's deploy this
contract beam, we'll hit Deploy,
1750:56 - we now have a contract, num,
center and value are all blank,
1751:00 - we'll update the number to
something like 777, we'll hit
1751:03 - Set VARS. Set VARs will change
the storage variable num to 777.
1751:09 - And then we're changing the
sender and the value, sender,
1751:12 - and value is zero. Now let's
deploy contract a. So we'll
1751:16 - scroll back up contract a
deploy, of course, we're on the
1751:19 - JavaScript VM. Now we have this
contract a with num value in
1751:23 - Cinder are also all blank. But
when we call set VARs, it's
1751:27 - going to borrow this set VARs
function from contract B and run
1751:32 - it in contract a, you can almost
think of it as if we're copying,
1751:37 - set VARs and pasting it into our
contract a just for one run, and
1751:42 - then immediately deleting ADM,
that's what this delegate call
1751:45 - function does. So when I call
set VARs, we're going to pass it
1751:48 - this contract address as an
input parameter. So it knows to
1751:51 - call this contract said virus
function. When I pass it the
1751:55 - address, and I pass 987. Since
we're borrowing the function,
1752:00 - we're not going to update this
num. On contract B, we're going
1752:03 - to update the num on contract a.
So when I hit Set VARs, we see
1752:08 - num now has 19. Seven, we see
Senator and we see value still
1752:12 - being zero here, because again,
we're borrowing this function
1752:14 - and running it here. Now the way
that this works, is it actually
1752:18 - doesn't look at the names of our
stored variables, it looks at
1752:22 - the storage slots. So when we
borrow this function using
1752:26 - delegate call, so we could have
this these variables we named
1752:29 - anything instead of num, we
could call this first value.
1752:34 - Senator, we could call something
else. And then value we could
1752:38 - call foo, or whatever you want
here. And when we borrow this
1752:43 - function using delegate call,
instead of grabbing the actual
1752:47 - names of the variables, our
contract will swap out these
1752:49 - variable names with the storage
slot. So it says oh, okay, well,
1752:53 - in contract B, you're accessing
the num variable, which is,
1752:57 - which is at storage slot zero.
So when we borrow set bars and
1753:01 - contract a with Delegate call,
we'll say storage slot
1753:08 - zero is going to equal that
underscore num. Which are this
1753:14 - contract storage slot zero is
first value. So we'll say first
1753:18 - value equals underscore Now,
something else is going to be
1753:23 - stored slot two, so it's gonna
say okay, storage slot two,
1753:27 - we're gonna update storage slot
two to message that sender.
1753:30 - Okay? value here is storage slot
three. So whatever's in storage,
1753:35 - slot three, will update with
message dot value like this. So
1753:39 - that's essentially what's going
on behind the scenes. So let's
1753:42 - go ahead and let's delete those
and redeploy. redeploy them. So
1753:46 - we'll deploy contract be
deployed contract a, right now
1753:50 - in B, once again, if we do 1234,
set VARs, we have 123. And then
1753:55 - contract a. Now even though
these variables have different
1753:59 - names, we could grab contract
B's address, paste it in, do
1754:04 - 654, hit Set VARS. And first
value is now six by four. So
1754:10 - delegate call allows us to
borrow functions, and then just
1754:13 - transposes whatever is in here
to the storage location
1754:17 - equivalents. And the other thing
that's interesting is even if
1754:20 - you don't have variables, it'll
still save to storage slots. So
1754:24 - in contract a, if we didn't have
any of those variable names,
1754:27 - storage slot, 01, and two would
still get updated. Now here's
1754:30 - where things can get really
interesting. Let's delete our
1754:33 - contract again. And let's change
the type of our contract A's
1754:38 - first value to from a UNT to a
Boolean. Let's save that. And
1754:43 - now let's deploy contract a. Now
when we call set VARs, on our
1754:48 - contract a, it's still going to
use the Set VARs function of
1754:53 - contract B, which takes a
Yewande and assigns the first
1754:57 - storage slot that number we pass
it, but our first storage slot
1755:01 - is now a Boolean was so what do
you think's going to happen now?
1755:04 - Well, let's try it out. Let's
copy contract B's address, paste
1755:08 - it in here. We'll pass we'll do
tu tu, tu as our input
1755:12 - parameter, we'll hit Set VARS.
Our transaction actually does go
1755:17 - through. And now when we look at
first value, it says true. Hmm,
1755:22 - that's really weird. What if we
change set VARs to zero, and hit
1755:26 - Set VARS. And now, first value
is false. In storage here, when
1755:31 - we add a number with set VARs,
it's going through because it's
1755:34 - just setting the storage slot of
the boolean to a number. And
1755:39 - when solidity reads it, it goes,
Oh, well, first value is a
1755:43 - Boolean. So if it's anything
other than zero, it's going to
1755:46 - be true. So this is how you can
actually get some really weird
1755:49 - results. If your typings are
different, or if your stored
1755:52 - variants are different. What if
we made this an address. So this
1755:55 - is where working with Delegate
call can get really weird and
1755:58 - really tricky, really fast.
1756:05 - All right. Now, with all this
being said, let's turn up the
1756:09 - heat. And let me show you a
small proxy, a minimal proxy
1756:12 - example, that shows how a
contract can be used as a
1756:16 - singular address, but the
underlying code can actually
1756:20 - change. And all the code we're
gonna be working with, once
1756:23 - again, in the hardhat upgrades,
FCC sub lesson, small proxy dot
1756:28 - Sol, and you can go ahead and
copy paste this code if you want
1756:31 - to follow along. So you don't
have to code along with me here.
1756:34 - But you absolutely can if we
want. Now, I will say this is
1756:37 - going to be one of the most, if
not the most advanced section of
1756:41 - the entire course. So feel free
to go ahead and skip over this
1756:44 - sub lesson. If you want to just
move on to learning how to
1756:47 - actually build these proxies,
without really understanding
1756:50 - what's going on behind the
scenes. However, it is still
1756:52 - really powerful if you do
understand what's going on
1756:54 - behind the scenes. So I have
this minimalistic starting
1756:57 - position right here. I have
small proxy is proxy. And I'm
1757:01 - importing this proxy dot sole
thing from up in Zeplin.
1757:05 - openzeppelin has this
minimalistic proxy contract that
1757:08 - we can use to actually start
working with this delegate call.
1757:11 - Now this contract uses a lot of
assembly or what's something
1757:14 - called you'll. And it's an
intermediate language that can
1757:17 - be compiled to bytecode for
different backends. It's a sort
1757:20 - of inline assembly inside
solidity and allows you to write
1757:24 - really, really low level code
close to the opcodes. Now we're
1757:28 - not going to go over you'll but
I'll leave some links to the
1757:30 - you'll documentation if you want
to learn more. Even if you're a
1757:33 - really advanced user, you really
want to try to use as little
1757:37 - EULA as possible. Because since
it is so much lower level, it is
1757:42 - much easier to screw things up.
However, like I said, for this
1757:45 - example, we are going to be
using a little bit of you'll now
1757:48 - in this proxy that we're going
to be doing, we have this
1757:51 - delegate function, which inside
this inline assembly, which is
1757:55 - you'll, it does a whole lot of
really low level stuff. But the
1757:59 - main thing that it does is it
goes ahead and it does this
1758:01 - delegate call functionality. If
we look here, we can see it's
1758:05 - using a fallback function and a
receive function. So whenever it
1758:09 - receives a function that doesn't
recognize it'll call fallback,
1758:14 - and fallback calls our delegate
function. So anytime a proxy
1758:19 - contract receives data for a
function it doesn't recognize it
1758:23 - sends it over to some
implementation to some
1758:26 - implementation contract where it
will call it with Delegate call.
1758:30 - In our minimalistic example
here, we have a function called
1758:34 - Set implementation, which will
change where those delegate
1758:37 - calls are going to be sending.
This can be equivalent to like
1758:40 - upgrading your smart contract.
And then we have implementation
1758:44 - here to read where that
implementation contract is. Now
1758:48 - to work with proxies, we really
don't want to have anything in
1758:51 - storage, because if we do
delegate call, and that delegate
1758:54 - call changes, some storage,
we're going to screw up our
1758:56 - contract storage. The one caveat
though to this, we do still need
1759:00 - to store that implementations
address somewhere, so we can
1759:03 - call it so ERP 1976. It's called
the standard proxy storage slot,
1759:08 - which is an Aetherium
improvement proposal for having
1759:11 - certain storage slots
specifically used for proxies.
1759:15 - And in our minimalistic example
here, we set bytes 32, private
1759:19 - constant implementation slot to
that location in storage. And
1759:24 - we'll say, okay, whatever is
that this storage slot is going
1759:28 - to be the location of the
implementation address. So the
1759:32 - way our proxy is going to work
is any contract that calls this
1759:36 - proxy contract. If it's not this
set implementation function,
1759:39 - it's going to pass it over to
whatever is inside the
1759:42 - implementation slot address.
That's what we're going to build
1759:44 - here. So we have the small proxy
is proxy. And we'll create a
1759:49 - real minimalistic contract. So
we'll say contract employee,
1759:54 - mentation A, and we'll just give
it a U and 256. public value and
1760:00 - then function set value, you add
256 new value, public will say
1760:07 - value equals new value So this
is going to be our
1760:12 - implementation. So now anytime
somebody calls small proxy, or
1760:16 - small proxy contract, it's going
to delegate, call it over to our
1760:21 - implementation, a, and then save
the storage in our small proxy
1760:26 - address. So we're going to call
our small proxy with the data to
1760:30 - use this set value function
selector. So let's make it a
1760:34 - little easier just to figure out
how to get that data by creating
1760:37 - a new helper function, do
function, get data to transact.
1760:45 - And we can get the data using
the API dot encode with
1760:48 - signature that we learned in an
earlier lesson. So function get
1760:52 - data to transact, we'll pass it
a un 256 number to update. So
1760:58 - we'll give this the number we
want to call a new value. We'll
1761:02 - have this be public pure, that's
going to return a bytes.
1761:08 - Memory. And we'll just say
return ABI dot ENCODE. With
1761:14 - signature set value, you went to
56, comma, number to update.
1761:24 - So you'll remember this from our
call anything section. And if
1761:28 - you don't remember how to do
that, remember to refer back to
1761:30 - our NFT section to learn how to
call anything and use ABI dot
1761:34 - encode ABI dot encode with a
signature and call anything with
1761:38 - its raw bytes bring and get the
data to transact. And we know
1761:42 - that when we call implementation
a, from our small proxy, we're
1761:46 - going to update our small
proxies storage. So we'll create
1761:49 - a little function in solidity
just to read our storage in
1761:52 - small proxy. We're gonna say
function, read storage. And this
1761:57 - will just be a public view, will
do returns, returns you into
1762:04 - 256, value at storage slot,
zero. And we are going to use a
1762:11 - little bit of assembly here
since we are doing all this low
1762:13 - level stuff. And we're going to
call the s load up code to read
1762:18 - the value at storage slot zero,
we'll say value at storage slot
1762:21 - zero, and we're going to set it
and then in assembly, this is
1762:25 - how we set things, we're going
to set it equal to s load of
1762:29 - storage slot zero, and then it
will return this value here. So
1762:33 - we're reading directly from
storage. Oops, and then we need
1762:36 - a little parenthese here. Sorry.
So now, let's go ahead and
1762:40 - deploy our small proxy. And
let's deploy our implementation
1762:43 - A. Now our small proxy has a
function called Set
1762:47 - implementation. So we're saying,
okay, anytime we call this proxy
1762:51 - contract, we're going to
delegate call the functions over
1762:55 - to here. So we're going to grab
current implementations A's
1762:58 - address, paste it into set
implementation 77. So this is
1763:04 - the data of set value you in
256, with that number to update
1763:08 - encoded in it. So if we call our
small proxy, with this data, our
1763:13 - proxy contract is gonna go, oh,
okay, this is a function. I
1763:18 - don't I don't see that function
here. We're going to call our
1763:21 - fallback, right, which again, is
coming from open Zeplin. And our
1763:25 - Fallback is going to do this
delegate, which is this low
1763:28 - level stuff, but it's basically
just doing a delegate call,
1763:30 - we're gonna call our fallback
function, and then we're gonna
1763:33 - get the function in the
implementation A, we're gonna
1763:36 - borrow this function, and we're
gonna use it on our on
1763:40 - ourselves. So if I copy this,
the implementation has been set
1763:44 - to being this address down here.
So all the logic is going to be
1763:47 - done here. So when I go ahead,
and I grabbed this, and paste it
1763:50 - into call data, and I hit
transact looks like it went
1763:53 - successfully went through. If I
read storage, now, we see that
1763:57 - it is indeed 777, which is
incredibly exciting. Now, this
1764:01 - is incredibly beneficial,
because now let's say we want to
1764:04 - go and update our code, right?
We don't like contract
1764:07 - implementation anymore. So let's
go ahead copy contract
1764:10 - implementation A. And we'll make
a new one called implementation
1764:14 - B. Now, let's say whenever
somebody calls set value, we do
1764:19 - value equals new value, plus
one, or plus two. Let's go
1764:24 - ahead, let's save this. Let's
compile this. And let's deploy
1764:29 - implementation B, we'll grab
implementation B's contract
1764:33 - address, we'll call it onset
implementation in our proxy. And
1764:37 - essentially, we have now
upgraded from implementation a
1764:41 - to implementation B. Now, if we
use this same data here, we're
1764:46 - still going to call set value
was 777. But instead, we're now
1764:51 - delegate calling to
implementation B, instead of
1764:54 - implementation A. So if I call
if I put this data into the low
1764:59 - level call data, and I hit
transact, it looks like it went
1765:02 - through. Now I read storage and
now is 779 since doing value
1765:07 - equals new value plus two so
this is a minimalistic example
1765:12 - of how upgrading actually works.
Now, this is incredibly
1765:15 - beneficial, because we can
always just tell people, Hey,
1765:18 - make all your function calls to
small proxy, and you'll be good
1765:22 - to go. But like I said before,
this also means that the
1765:25 - developers of this protocol can
essentially change the
1765:29 - underlying logic at any time.
This is why it is so important
1765:32 - to be sure to read contracts and
check to see who has the
1765:36 - developer keys. And if a
contract can be updated, if a
1765:39 - contract can be updated, and a
single person can update it,
1765:41 - well guess what, you have a
single centralized point of
1765:44 - failure. And technically the
contract isn't even
1765:46 - decentralized. Now, something
else I was talking about in the
1765:49 - video is function clashes
function selector clashes. Right
1765:54 - now, whenever we call set
implementation, the proxy
1765:57 - function sedimentation gets
called because we don't trigger
1766:00 - the fallback because we can see
the function is here. However,
1766:02 - if I have a function called Set
implementation, in our
1766:05 - implementation, this one can
never be called, whenever we
1766:08 - send a function signature of set
implementation, it's always
1766:12 - going to call the one on the
proxy. This is where the
1766:15 - transparent proxy that we're
going to be working with can
1766:17 - help us out here and the
universal upgradable proxy can
1766:20 - help us to, and I'm not going to
go too much deeper into these
1766:22 - now. But we've left some links
in the GitHub repository to
1766:26 - teach you more about these
selector clashes. And how those
1766:29 - two proxy patterns that I just
mentioned, the transparent and
1766:32 - universal upgradable can get
around these, if you're confused
1766:35 - by anything in here, go into
this discussion thread and make
1766:37 - a new discussion about proxies
make a new discussion about the
1766:41 - Assembly about the you'll set
implementation, this is a great
1766:44 - time to connect with other
people taking the course and ask
1766:47 - questions here, because I know
that this is a really advanced
1766:49 - section, and requires you
haven't gone through a lot of
1766:53 - those sub lessons that we've
gone before. And if it takes you
1766:55 - a couple times of playing around
with solidity and playing around
1766:58 - with remix, I definitely
recommend you do so this is the
1767:02 - section we're seeing really is
believing. And I want you to
1767:04 - jump into remix. And I want you
to test this. And I want you to
1767:07 - play around with this and see
what you can break and fiddle
1767:10 - with. But with all that being
said, we finally have all the
1767:13 - knowledge that we need to build
our hardhat project that deals
1767:16 - with upgrades. So let's go ahead
and jump into it.
1767:22 - Your new terminal, we're going
to do MK dir, hard hat,
1767:26 - upgrades, FCC, CD, hard hat,
upgrades, FCC, and then code
1767:32 - period, or file, open folder,
this folder here, now I'm going
1767:37 - to grab that same yarn add we've
been grabbing from less than
1767:40 - nine, we're gonna paste it in,
we're going to add all of these
1767:43 - different parameters. And once
again, we're going to copy over
1767:46 - our hard hat config from
previous sections, we're going
1767:48 - to copy over prettier. And we're
just going to get our basic
1767:51 - default setup. At this point,
you might have a setup that
1767:54 - works best for you and that you
like better. And feel free to
1767:57 - grab that as well. So I'm going
to paste the prettier is in
1768:00 - here. And I'm going to paste the
hard hat.config.js that we've
1768:03 - been using, instead of running
yarn hard hat. And now we should
1768:06 - be good to go. So let's create a
new folder called contracts. And
1768:11 - in here, we're going to create a
new file called Box dot soul.
1768:15 - And then it's this contract,
that's going to be our
1768:17 - implementation or our logic
contract. So it will say pragma,
1768:21 - solidity carrot zero point 8.7
contract box will say you into
1768:28 - 256 internal value will do event
value changed you into 256 new
1768:36 - value, do function store, you
went to 36 value, this will be a
1768:43 - public function will say value
equals new value. So this store
1768:48 - function is going to update our
variable at storage slot zero,
1768:52 - internal, and then we'll just
omit value changed that new
1769:00 - value. And then we'll just
create function retrieve, which
1769:06 - will be a public view returns a
UNT 256 We'll just do return
1769:11 - value. And then we're going to
create a new function called
1769:16 - version. And this will be a
public door. And that returns a
1769:21 - un 256. And we're just going to
have this return one. So our box
1769:26 - contract here is going to be
version one. Now we're going to
1769:29 - copy all this code, paste it
into a box v two dot soul and
1769:34 - rename it to contract box v two,
we're going to update the
1769:37 - version to version two here. And
we're going to create a new
1769:40 - function called increment. And
this will be a public function.
1769:46 - And we'll say value equals value
plus one. And then we will emit
1769:52 - a value changed event with
value. We're going to have one
1769:57 - contract address originally use
the logic in box and then we're
1770:01 - going to upgrade it to the logic
in box V two. And we're going to
1770:05 - learn how to use all the tools
that we've been working with
1770:07 - here to add this logic and
create this logic And let's just
1770:11 - make sure this works, we'll do
yarn, or that compile.
1770:17 - So let's make a readme.md, we'll
say, one, we're going to upgrade
1770:22 - box to box V two. So we're going
to make a proxy contract, that's
1770:28 - gonna point to box. And then
later on, we're going to update
1770:32 - it to point to box V two. Right,
so we're going to start it up
1770:37 - pointing to box, then we're
going to have it point to box V
1770:40 - two. And that's how we're going
to upgrade it, one of the first
1770:42 - things we're going to need to do
is deploy a proxy, we can deploy
1770:46 - a proxy manually ourselves, and
we can build the proxy contracts
1770:49 - and do all that stuff. That's
our first option. Hardhead
1770:52 - deploy also comes built in with
deploying and upgrading proxies
1770:57 - itself, where we can just
specify that we want to use a
1771:00 - proxy. And we could specify the
type of proxy that we want to
1771:03 - use. So number two is just
saying using hard hat deploys,
1771:07 - built in proxies. And then
number three is open Zeppelin
1771:11 - actually has an upgrades plugin,
which allows you to write some
1771:14 - really simple scripts that
allows you to have a really
1771:16 - simple API like upgrades dot
deploy proxy, and then upgrades
1771:20 - that upgrade proxy. Now for this
section, we're going to be doing
1771:24 - the hard hat deploys built in
proxies. However, in the GitHub
1771:28 - repo associated with this, if
you go to scripts, there's other
1771:31 - upgrade examples that will show
you how to use the opens up and
1771:34 - upgrades plugin. And we're not
going to do deploy a proxy
1771:37 - manually manually, because we
essentially just showed you how
1771:40 - to do that in our sub lesson. So
we're going to show you this,
1771:44 - we're going to show you the
Hardhead deploys built in
1771:46 - proxies, and if you want to use
the openzeppelin upgrades
1771:48 - plugin, that is available in the
GitHub repo as well. So let's go
1771:52 - ahead and do this. So we're
going to go ahead and we're
1771:55 - going to make a new folder, or
deploy folder. And first, we're
1771:58 - going to make a new file called
a one, deploy box dot j s. And
1772:03 - this is going to look really
similar to everything we've been
1772:05 - doing so far. So module dot
exports, equals async function,
1772:11 - we're going to get named
accounts and deployments. The
1772:15 - arrow function will say const
deploy COMM A log equals
1772:20 - deployments const deployer
equals await, get named.
1772:29 - Accounts, do a little logging,
like this, and then we'll say
1772:34 - const, box equals await, loi,
box, comma, we'll say from
1772:42 - Deployer, comma, args like this,
we'll say weight con formations
1772:49 - is going to be network dot
config dot block confirmations
1772:56 - for Masons. And yep, we got to
grab const from hard hat. And
1773:02 - then we can add the parameter in
here for proxies. And this is
1773:06 - where we can add a ton of
information. So like I said,
1773:10 - we're going to use the
transparent upgradable proxy
1773:12 - from open Zeppelin, which if we
want to use it, we're going to
1773:15 - have to add open Zeppelin. So
we'll do yarn, add dash dash dev
1773:21 - at open Zeppelin slash
contracts. And we can tell our
1773:26 - hard hat to deploy this box
contract behind a proxy will say
1773:31 - the proxy contract is going to
be the open Zeppelin transparent
1773:39 - proxy. And we're also going to
do a via admin contract. So
1773:45 - instead of having an admin
address, for the proxy contract,
1773:49 - we're going to have the proxy
contract owned by an admin
1773:52 - contract. And doing it this way
is considered a best practice
1773:55 - for a number of reasons. But
we'll name this admin contract,
1773:59 - box proxy admin and the artifact
for this box proxy admin. So
1774:08 - we'll need to create a box proxy
admin contract to be the admin
1774:12 - of our box. So in our contracts
folder, create a new folder
1774:17 - called proxy. And in here, a new
file called Box proxy admin that
1774:23 - saw and this is going to be the
admin contract we're going to
1774:26 - have for controlling the proxy
of our box so inbox proxy admin
1774:30 - dot Saul will do SP DX license.
I then to fire MIT pragma
1774:41 - solidity, carrot zero, point
8.7,
1774:45 - say contract, box proxy admin,
like this, right? And once
1774:51 - again, we're going to use one of
the open Zetland tools in the
1774:55 - transparent folder. They have a
proxy admin dot Saul, which is
1774:59 - going to be essentially what our
box proxy admin is going to be.
1775:02 - It has some functionality, it
has some functions in here like
1775:05 - change, proxy admin, upgrade,
upgrade and call for dealing
1775:09 - with upgrades. All contracts. So
we're going to import it will do
1775:12 - import at open Zeppelin slash
contracts slash proxy slash
1775:18 - transparent, slash proxy admin,
dot soul. And we'll say our
1775:24 - Brock's box proxy admin is proxy
admin, like this. And to have
1775:30 - this box proxy admin work with
the heart at deploy plugin, our
1775:34 - constructor needs to take an
address owner as an input
1775:37 - parameter, but we're just going
to leave that blank. And then,
1775:40 - and then we need to do the proxy
admin, which is just going to be
1775:42 - blank as well. And that's it.
That's all we're going to do box
1775:45 - proxy admin contract, which just
has all of the functionalities
1775:49 - to do upgrades and change proxy
admin and all this stuff. We're
1775:52 - going to deploy our box contract
behind a proxy and opens up and
1775:56 - transparent proxy that is owned
by our Brock's proxy admin
1776:00 - contract in the template
Aetherium contracts. GitHub repo
1776:04 - is actually an examples slash
opens up on proxies branch that
1776:08 - will show you how to work with
different types of proxies. And
1776:12 - there will be a link to this in
the GitHub repo associated with
1776:14 - this course. And then we'll do
our verification, say, chains
1776:20 - dot includes. And we'll go
ahead, I'm going to copy paste
1776:24 - our hard hat helper config from
our last project, which has
1776:27 - development chains, hard hat and
local host that we export, will
1776:31 - import this as well. const
development chains equals
1776:36 - require dot slash helper hard
hat config. If development
1776:42 - chains dot includes network dot
name, and process dot env dot
1776:48 - ether scan API key log,
verifying that the same as we've
1776:54 - done a way to verify last, we're
going to copy over our utils
1776:59 - folder. So just copy, paste, we
now have verify, which will
1777:03 - import it in here. So we'll do
const verify equals require dot
1777:11 - dot slash utils, slash verify,
await verify box dot address.
1777:17 - And then args is going to be
blank. So we'll just do blank
1777:20 - here, and boom. And that's going
to be it for our box deployment.
1777:25 - So we can test this out by
running yarn Hardhead deploy,
1777:29 - see if everything works here.
And that's it done. And then we
1777:33 - should do actually, we should
add log beach true as well.
1777:38 - Let's run this again, much
better. So you can see we
1777:41 - actually deploy a couple of
contracts. So we deploy our box
1777:44 - proxy admin, which is going to
be our admin contract, then we
1777:48 - deploy box implementation. So
hard hat deploy, went ahead and
1777:53 - took our box contract and
renamed it to box implementation
1777:57 - and then deployed it, then it
deployed our box proxy here. So
1778:02 - anytime we call this address, it
actually will point to the logic
1778:05 - of our box. Now what we can do
is we can write a deploy script
1778:10 - to deploy box, the box v2
implementation, and then upgrade
1778:14 - our box to box V to create a new
deploy script called Zero to
1778:19 - deploy box v2 dot j s or deploy
box two dot j s. And we'll do
1778:25 - something really similar here.
Right, so I'm just going to copy
1778:28 - pretty much of this, paste it in
here. Now we're going to do
1778:34 - const box v two equals await,
deploy. Box v two, comma, from
1778:44 - Deployer. Log True RMS blank,
weights confirmations, it's
1778:53 - going to be network dot config
dot lock.
1778:59 - Or masons, then I'm going to
copy the verification code, copy
1779:04 - this, paste it here, server,
this is going to be box v2 dot
1779:08 - address. Okay, great. So we now
have some code where we can
1779:13 - deploy box and box v2. Now let's
go ahead and write a script to
1779:17 - actually upgrade these. So we'll
do a new folder, scripts. New
1779:23 - File, and we'll call it upgrade
box dot j s. Now we're going to
1779:28 - do it the manual way here. And
the reason we're going to do it
1779:30 - the manual way is because I want
to show you exactly the
1779:33 - functions that we're calling to
do this upgrade process.
1779:36 - However, hard hat deploy also
comes with an API to make it
1779:40 - really easy to actually just
upgrade your box contracts. This
1779:43 - is gonna be script. So we'll
start off with async function
1779:47 - main. And then we'll copy paste
our traditional script, main dot
1779:52 - then process exit blah, blah,
blah, that whole thing. We're
1779:54 - first gonna get the box proxy
admin contract. We'll say box
1779:59 - const. Box, proxy admin equals
await ethers dot get contract,
1780:07 - box proxy admin and we got to
import you Here's from Hardhead,
1780:11 - then we're going to get the
actual proxy, which is our
1780:14 - transparent proxy. So we'll say
const transparent proxy equals
1780:20 - await ethers dot get contract,
box underscore proxy. Since hard
1780:26 - hat deploy, we'll just name the
proxy the name of the
1780:28 - implementation underscore proxy.
And then of course, we're going
1780:32 - to need our box V to contract.
So say const. Box v two equals
1780:37 - await ethers dot get contract,
box V two. Now we can say const,
1780:44 - upgrade TX equals a weight box
proxy admin, that upgrade. And
1780:50 - we're going to call the upgrade
function on our box proxy admin,
1780:54 - which calls it on our
transparent proxy, which will
1780:56 - change the implementation from
box one to box two. So box proxy
1781:01 - admin, that upgrade, we're going
to upgrade the transparent proxy
1781:05 - dot address to our box B to that
address, it will look in our box
1781:14 - proxy, a box proxy has an
upgrade function which calls
1781:18 - upgrade to on our transparent
upgradeable proxy will do a
1781:21 - weight upgrade TX dot wait one.
And now to work with the
1781:26 - functions on our box v two,
we're gonna say const proxy box
1781:31 - equals await ethers dot get
contract. At box v two, we're
1781:38 - going to get the box v two ABI
however, we're going to load it
1781:42 - at the transparent proxy
address. This way ethers knows
1781:48 - okay, we're going to call all of
our functions on the transparent
1781:51 - proxy address. But this proxy
box is going to have the ABI of
1781:55 - box v2, which is what we want.
Now we can say const version
1782:00 - equals await proxy box dot
version. And we'll say console
1782:05 - dot log version. And if we want
to compare this to its original
1782:10 - implementation, before we
upgrade, we can do the same
1782:14 - thing. We can say const proxy
box v1, let's actually call this
1782:18 - proxy box V to say cost proxy
box v one is going to be this
1782:23 - exact same thing
1782:26 - equals this call box here. And
we'll do const version equals
1782:34 - weight, right proxy box v1 dot
version, console dot log
1782:41 - version, or version v1, version
v1. We'll call this version v
1782:47 - two, version v two, and proxy
box V two. So we'll get our
1782:53 - version v one will upgrade. And
then we'll see at that same
1782:57 - address what the version
function now returns. So let's
1783:01 - open our terminal. If I run
yarn, our head node will spin up
1783:07 - a node will have deployed our
admin our implementation, our
1783:12 - proxy, and then our box V to
implementation. I'll make a new
1783:17 - terminal. And I'll run yarn,
hard hat run scripts upgrade box
1783:23 - that J S dash dash network,
local host. And we should see
1783:28 - that box actually update. And
that's exactly what we see. And
1783:31 - then let's do well, it's I
forgot to do.to string in here.
1783:34 - But it goes from version one to
version two on that exact same
1783:38 - address. And with that little
code, we have successfully
1783:42 - learned how to upgrade our smart
contracts programmatically. Now,
1783:45 - like I said, in the GitHub repo
associated with this lesson, you
1783:49 - can also check out the upgrades
plugin from open Zeppelin. So to
1783:53 - work with that, you would just
do upgrades dot deploy proxy
1783:56 - proxy to call the Prepare
upgrade function, and then
1784:01 - upgrade upgrade proxy just like
that. They also have an upgrade
1784:05 - tutorial, step by step for
hardhat that you can follow
1784:07 - along with as well. Now I know
this was an advanced section.
1784:10 - And I know we went a little bit
quick here. But honestly, if you
1784:14 - just finish this section, not
only have you completed all
1784:16 - these other sections that make
you a really powerful smart
1784:19 - contract developer. But you've
learned some really advanced
1784:22 - stuff here. We've gone into low
level code like delegate call,
1784:26 - we've gotten to assembly we've
gotten to you'll we've gotten to
1784:29 - these proxy patterns, which can
really make you a an incredible
1784:33 - stand out developer in the smart
contract space. So if you just
1784:37 - finished this section, you
should be so so proud of
1784:40 - yourself because we went really
fast and because there's a lot
1784:42 - of advanced information here.
Now, like I said, 100 percent, be sure
1784:46 - to go into the discussions tab
and ask questions and connect
1784:50 - and talk to other people in the
area. Maybe look at the already
1784:53 - running discussions and jump in
and start asking other students
1784:57 - and start asking other people
about what they've learned and
1785:00 - how their proxies are going. And
if they made anything really
1785:02 - cool. If you're just excited and
you want to go to the show and
1785:05 - tell section, make a show and
tell me like hey, here's my
1785:07 - GitHub repo for doing this
upgrade section. going here and
1785:11 - be excited with that being said
go and take that coffee break go
1785:14 - take that walk go to the gym go
get excited Go tell your friends
1785:18 - we are almost done we have two
lessons left and then you're
1785:22 - home free
1785:26 - All right, welcome back to
lesson 17 For hardhat. Douse,
1785:30 - you're almost done. Now for this
section, I've actually already
1785:34 - made a video on how to code a
dowel with TypeScript and
1785:37 - solidity in JavaScript. So we're
actually just going to play this
1785:41 - video for this section. The
reason we're going to display
1785:43 - this one is because I did a lot
of work to make this one look
1785:45 - really good. And it's still
incredibly up to date. So this
1785:49 - is going to be in TypeScript and
solidity. However, we're going
1785:52 - to have the JavaScript edition
of the code base in this code
1785:56 - from the video section. If you
want the most up to date version
1785:58 - of this delta template code, you
can use, you can select this up
1786:02 - to date code, which goes to this
doubt template repo. I'll be
1786:05 - updating this repo periodically
with new Dao examples and new
1786:09 - ways to create doubts or
decentralized autonomous
1786:11 - organizations. Now, before we
learn how to code a doubt, we
1786:14 - should learn what the DAO is.
And again, I've already made a
1786:17 - video that I've put a lot of
work into. So we're going to
1786:19 - watch what a Dow is from a high
level first, then we're going to
1786:22 - learn how to code a Dow. And
then our last section is going
1786:25 - to be security and auditing. And
we're going to finish this out.
1786:27 - So Bucklin, let's learn what a
Dow is. And then let's go ahead
1786:32 - and build a Dow, let's do it.
Now, daos for decentralized
1786:39 - autonomous organizations is a
bit of an overloaded term. But
1786:43 - it typically describes any group
that is governed by a
1786:46 - transparent set of rules found
on a blockchain or smart
1786:49 - contract. And I say overloaded
because some people say bitcoin
1786:53 - is down because the miners can
choose whether or not to upgrade
1786:55 - their software. Other people
think that Dows must use
1786:58 - transparent smart contracts,
which have the rules ingrained
1787:01 - right into them. And then other
people think Tao is just a
1787:03 - buzzword, so they just slap the
name relay on to any
1787:06 - organization so that they can
get some clout. And this makes
1787:08 - for sad, Patrick. And it's not
to be confused with the Dow,
1787:14 - which was an implementation of a
Dow back in 2016, which set the
1787:17 - record for the largest hack at
that time. So there's a lot of
1787:20 - different ways to think about
and the Dow term is used in a
1787:23 - lot of different ways. But in
essence, imagine if all of the
1787:25 - users of Google were given
voting power into what Google
1787:29 - should do next. And the rules of
the voting was immutable,
1787:32 - transparent, and decentralized.
This solves an age old problem
1787:37 - of trust, centrality and
transparency, and giving the
1787:40 - power to the users of different
protocols and applications
1787:43 - instead of everything happening
behind closed doors. And this
1787:46 - voting piece is a cornerstone of
how these operate this
1787:49 - Decentralized Governance, if you
will, and it can be summarized
1787:52 - by company or organization
operated exclusively through
1787:56 - code. And to really understand
all this, we're going to look
1787:58 - under the hood of the protocol
that's setting the precedent for
1788:02 - all other doubts and compound,
then once we look at compound,
1788:05 - we'll understand what goes into
building one of these and all
1788:08 - the trade offs, all the
different architectural choices
1788:10 - mean for your group. And then in
my next video, I'm gonna have a
1788:14 - full coat along tutorial for
developers looking to build one
1788:17 - of these themselves. But be
absolutely sure to watch the
1788:19 - rest of this video because it's
going to give you all the
1788:21 - architectural fundamentals. So
you can make intelligent
1788:24 - decisions when you get to that
section. And be sure that you
1788:27 - and your Dow friends smash the
like and subscribe button. So we
1788:29 - can keep giving you the best
engineer first content on the
1788:33 - planet when
1788:34 - it comes to smart contracts.
Let's get into it. So here we
1788:37 - have the compound protocol. It's
a borrowing and lending
1788:40 - application that allows users to
borrow and lend their assets.
1788:44 - And everything about this
application is built in smart
1788:46 - contracts. Now, oftentimes,
they're gonna want to do a lot
1788:49 - of new things, maybe they want
to add a new token to allow
1788:52 - borrowing and lending, maybe
they're gonna want to change
1788:55 - some of the API parameters,
maybe they're gonna want to
1788:57 - block certain coins, there's a
lot of different things that
1788:59 - they might want to do. So that's
where we're gonna go ahead to
1789:02 - governance, this is where you
can find a user interface for
1789:07 - list of all the proposals and
all the different ballots that
1789:10 - came to be. So here's a list of
some of the governance proposals
1789:13 - that this protocol has actually
been making to improve. And
1789:16 - let's look at one of these
proposals that's currently
1789:18 - actually in process. So if we
click on the proposal, we
1789:21 - actually see everything about
this proposal, who voted for who
1789:25 - voted against and the proposal
history here. Now, the first
1789:28 - thing to one of these proposals
is somebody has to actually
1789:30 - create the proposal in a
proposed transaction. And we
1789:33 - actually see that proposed
transaction right here. If we
1789:37 - click on this, and we scroll
down, we can actually see the
1789:40 - exact parameters they used to
make this proposal. Let's go
1789:44 - ahead and decode the input data.
And we can see this is exactly
1789:47 - what this proposal looks like.
The way that they're typically
1789:49 - divided is they have a list of
addresses and the list of
1789:53 - functions to call on those
addresses. And then obviously,
1789:55 - the parameters to pass those
addresses. So this proposal is
1789:59 - saying, Hey, I would like to
call Support Market on this
1790:03 - address, set reserve factor on
this address. Here are the
1790:07 - parameters we're going to pass.
They're obviously encoded with
1790:10 - bytes. And then here's the
description string of what this
1790:13 - is doing and why we're actually
doing this. The reason we have
1790:16 - to do this proposal governance
process is that these contracts
1790:19 - likely have access controls
where only the owner of these
1790:22 - contracts can actually call
these Do functions, and the
1790:25 - owner of these two contracts is
likely going to be this
1790:28 - governance style. And values.
Zero just means that we're not
1790:31 - going to send any eath along
with these transactions, once a
1790:34 - proposal has been created, after
a short delay to becomes active,
1790:38 - and this is when people can
actually start voting on them,
1790:41 - this delay between a proposal
and an act of vote can be
1790:44 - changed or modified, depending
on your doubt, then people have
1790:47 - some time to start voting on
them. And if it passes, which
1790:50 - this one overwhelmingly did, it
reaches succeeded, we click on
1790:54 - this transaction again, and we
go to the compound governance
1790:57 - contract. And we scroll down to
contract, right as proxy, we can
1791:02 - actually see the exact function
that the people call to vote,
1791:08 - namely cast by vote, cast, vote
by signature and cast vote with
1791:12 - reason. We'll talk a little bit
about the exact differences
1791:15 - between these in our next video.
But these are the functions that
1791:18 - they're actually calling. And if
you go to the compound app, and
1791:22 - we go over to vote, this is a
user interface you can actually
1791:25 - vote through to make it easier
if you're not as tech savvy. So
1791:29 - you can vote right through this
app dot compound at finance. Or
1791:32 - you can just send the
transaction yourself. Once all
1791:35 - those votes happen. It reaches
this queued stage. Now what is
1791:39 - queued mean? Well, before a
proposal actually becomes
1791:43 - active, there's a minimum delay
between a proposal passing and a
1791:47 - proposal being executed. So
somebody has to call this cute
1791:51 - function. And it only can be
called if a vote passes. And it
1791:55 - says, OK, that postal ID has
been cued, and we're going to
1791:58 - execute it soon. Now, if we go
to a different proposal, like
1792:03 - this one, for example, we can
see it has been executed, we can
1792:05 - see somebody called this
executed function. And they
1792:10 - executed Proposal A detail. So
this is going to be a full
1792:13 - example of the lifecycle of a
proposal going through this
1792:17 - process. Now there are a couple
that even failed, a whole bunch
1792:21 - of people voted against this.
And if you scroll down, you can
1792:23 - see it was created, it was
active, and the majority of
1792:26 - people voted against. So that's
where it stops. Now oftentimes,
1792:30 - just putting one of these
proposals through isn't enough
1792:32 - to really garner some votes for
it, you generally want a forum
1792:36 - or some type of discussion place
to talk about these proposals
1792:40 - and why you liked them or don't
like them. Oftentimes, a
1792:42 - discourse is one of the main
places that people are going to
1792:45 - argue for why something is good,
or why something is bad. So
1792:48 - people can vote on these
changes. And again, snapshot
1792:52 - might be one of these tools that
you use to figure out if your
1792:54 - community even wants something
before it even goes to vote, you
1792:57 - can join one of these, and with
your tokens actually vote on
1793:01 - things without them being
executed just to get the
1793:03 - sentiment or like I said before,
you could build your protocol in
1793:06 - a way that snapshot actually
helps you with the voting
1793:08 - process. All right, now you've
seen the protocol that has been
1793:11 - influencing all the other
details on how to vote. Now, you
1793:14 - know, now that we know what a
doubt looks like,
1793:17 - let's talk about the
architecture and tools that go
1793:19 - into building one of these and
additionally the trade offs that
1793:21 - they have. And the first thing
to talk about here is going to
1793:24 - be the voting mechanism. Now
voting in Decentralized
1793:27 - Governance is critical to these
days, because sometimes they do
1793:31 - need to update and change to
keep up with the times. Not all
1793:34 - protocols need to have a Dow,
but those that do need to have a
1793:37 - doubt need a way for the
participants to engage. This is
1793:40 - one of the most important
questions to ask him to tell
1793:43 - your communities. How do I
participate? How do I engage in
1793:47 - this doubt? How do I help make
decisions and you'll find this
1793:51 - is a bit of a tricky problem to
solve. Now, an easy approach to
1793:55 - this problem is going to be
using an ERC 20 or an NFT token
1793:59 - as voting power. Similar to what
we saw with compound use the
1794:02 - comp token to vote for different
proposals seems simple enough,
1794:06 - right? Boom, problem solved
gray. Now, this actually might
1794:09 - be the right approach for
certain doubts. But it also runs
1794:12 - the risk of actually being less
fair. Because when you tokenize
1794:15 - the voting power, you're
essentially auctioning off this
1794:18 - voting power to whoever's got
the deepest pockets, whoever has
1794:21 - the most money gets to pick the
changes. So if it's only the
1794:25 - rich people who get to vote,
then it's highly likely that all
1794:28 - the changes in the protocol are
going to benefit the rich, which
1794:31 - doesn't really seem like that
great of an improvement over our
1794:34 - current world. And if T's are
interesting, because they have
1794:37 - this non fungible component, but
yet, even they still run into
1794:41 - this issue. Additionally, if you
buy a whole bunch of votes, you
1794:43 - make a bad decision and then
sell all your votes. You as an
1794:47 - individual don't really get
punished, you just punish the
1794:49 - group as a whole. But you being
malicious, you can get away with
1794:52 - pretty scot free now again, this
voting mechanism is going to be
1794:55 - correct for some groups, but for
other groups, maybe not. It
1795:00 - really just depends on what your
down community setup is going to
1795:02 - look like. Now the next one
we're going to talk about is
1795:04 - skin in the game. Now metallic
has actually written a lot about
1795:07 - this and I highly recommend you
read his article, link in the
1795:10 - description to see that the skin
in the game method means that
1795:13 - whenever you make a decision,
your vote is recorded. And if
1795:16 - that decision leads to a bad
outcome, your tokens are axed.
1795:21 - You get punished for making evil
or bad decisions for your Dao
1795:25 - and your protocol. I like this
mentality because even if you
1795:27 - buy a ton of tokens and decide
to be ill with it, you can be
1795:30 - held accountable for your bad
decisions. Now, the hardest part
1795:33 - about this, though, is gonna be
how do we decide as a community?
1795:37 - What is bad outcome? How do we
actually punish these people?
1795:40 - And that's easy, because the
answer is, I'm not sure. Now,
1795:45 - the third method of this voting
mechanism is probably one of the
1795:48 - most interesting ones, but also
the hardest ones to implement.
1795:51 - And this is proof of personhood,
or participation. Imagine that
1795:55 - all users of the compound
protocol were given a single
1795:58 - vote simply because they use the
protocol. And even if they had
1796:02 - 1000 wallets, they use the
protocol. One human being means
1796:06 - one vote, this would be amazing,
and a far more fair
1796:09 - implementation where votes
couldn't actually just be
1796:11 - bought. The issue, however,
comes in something known as
1796:14 - civil resistance, how can we be
sure that it's one vote equals
1796:19 - one participant and not one
participant pretending to be
1796:22 - 1000s of different people, so
they get more votes. This method
1796:25 - hasn't really been solved yet.
But I'm willing to bet some very
1796:27 - clever engineer will do some
amazing chainlink integration,
1796:30 - because proof of personhood is
basically just off chain data
1796:33 - that can be delivered on chain.
And that's exactly where
1796:36 - channeling shines. Now, as you
can see all of these methods and
1796:39 - even more that you probably
think of aren't that far
1796:42 - fetched. And we actually see
these exact same methods
1796:45 - happening in the real world.
Proof of personhood or proof of
1796:48 - participation might just be the
exact same as kind of the
1796:51 - regular government voting that
we see every day. In the United
1796:54 - States, at least one person gets
to vote for one president, you
1796:57 - can't go around making a whole
bunch of fake people and voting
1797:00 - for president. But in companies
the ERC 20 voting standard kind
1797:03 - of applies, the more shares of a
company you have maybe the more
1797:07 - voting power you have in that
company. So we can draw
1797:09 - parallels between the real world
and how voting and governance is
1797:11 - going to work in our smart
contracts. And in fact, you
1797:14 - should draw parallels and look
for inspiration from the web to
1797:17 - space. Now when it comes to
implementation of the voting, I
1797:19 - put them into two categories on
chain voting and off chain
1797:22 - voting on chain voting is
exactly what we saw with
1797:25 - compound, the smart contract on
chain, your voter, you call some
1797:29 - function called vote with your
meta mask your ledger or
1797:32 - whatever, send a transaction and
vote, you voted Congrats, you
1797:36 - can wear your little sticker now
call that function and you send
1797:38 - a transaction, you send a
transaction, what are the
1797:43 - transactions use that are kind
of annoying and kind of costly?
1797:47 - Oh, that's right gas, I imagine
you have 10,000 people in your
1797:49 - community and it costs $100 To
vote per person, you're now
1797:53 - costing your community $1
million. Anytime you want to
1797:57 - change anything. This is
obviously insane, and not very
1797:59 - sustainable for your community
pro here is that the
1798:02 - architecture is really easy.
Everything's going to be
1798:04 - transparent, everything's going
to be on chain. And that's
1798:06 - really good. But yes, the con is
that you're going to break the
1798:09 - bank account for a lot of people
potentially. Now there are a lot
1798:11 - of variations of this to help
solve some of these problems,
1798:14 - especially the gas problem. One
of the ones that I'm incredibly
1798:17 - excited for is this one called
governor's seat, where they use
1798:20 - some random sampling to do some
quadratic voting to help reduce
1798:23 - costs while increasing civil
resistance. You want to learn
1798:26 - more about that one to be sure
to read about it in the
1798:28 - description. So on chain voting
is the simplest one here. But
1798:31 - let's talk about off chain
voting. To cast the vote off to
1798:36 - decentralized context, relax,
relax, you can vote off chain
1798:39 - and still have the 100%
decentralized, you can actually
1798:42 - sign a transaction and sign a
vote without actually sending to
1798:46 - a blockchain and therefore
without actually spending any
1798:49 - gas. Instead, what you can do is
send that signed transaction to
1798:53 - a decentralized database like
IPFS, count up all the votes in
1798:57 - IPFS. And then when time comes,
deliver the result of that data
1799:01 - through something like an Oracle
like chain link to the
1799:03 - blockchain all in a single
transaction. Alternatively, what
1799:06 - you could do is you could replay
all the same transactions in a
1799:10 - single transaction to save gas,
this can reduce the voting cost
1799:13 - by up to 99%. Right now, this is
an implementation and one of the
1799:16 - most popular ways to do this is
through snapshot. And I'm just
1799:20 - dying for someone to make a
chain link integration because
1799:23 - it's going to be so much safer,
more secure and better and blah,
1799:26 - blah, blah, die for it. This is
your call to action go build
1799:28 - this thing. This option. voting
mechanism obviously saves a ton
1799:31 - of gas to the community and can
be a more efficient way to store
1799:35 - these transactions anyways,
however, it needs to be
1799:37 - implemented very carefully. If
you run your entire Dow through
1799:40 - a centralized Oracle, you are
essentially reintroducing a
1799:43 - centralized intermediary and
ruining the decent quality of
1799:45 - your application. So don't do
that. And if you made it to this
1799:48 - point of the video, give
yourself a little pat on the
1799:50 - back. You're doing fantastic.
Fantastic. Like I said, I have a
1799:53 - video coming out after this one
it's going to show you end to
1799:56 - end how to build one of these
from scratch let's learn about
1799:59 - some of the tools that you can
use to help get you up to speed
1800:02 - quicker. Now there are a number
of no code solutions that can go
1800:04 - into building one of these
dowels Tao stack Aragon. Just
1800:10 - kidding, this is Aragon, colony
and Tao house are all
1800:13 - alternatives that can actually
help you with the upside of
1800:16 - running a Dao and building a
doubt. However, if you want more
1800:19 - granular control and you don't
want to have to pay any the fees
1800:21 - associated with these protocols,
you might want to Do it from
1800:24 - scratch. Now let's talk about
some of the more Cody solutions
1800:26 - that you can use snapshot is one
of the most popular tools out
1800:29 - there for both getting the
sentiment of a Dao. And actually
1800:32 - performing that execution, users
can vote through this protocol
1800:35 - with their actual tokens, those
transaction gets stored in IPFS.
1800:39 - But none of it actually gets
executed. Unless the doubt
1800:42 - chooses to, this can be a great
way to get a feel for what your
1800:46 - Dow wants to do. And Optionally,
you can send the transactions
1800:50 - and execute the votes as well
highly recommend checking out
1800:53 - Zodiac which is a suite of
database tools for you to
1800:56 - implement into your Dallas as
well tally is another one of
1800:59 - these UIs that allows people to
see and actually vote and
1801:02 - interact with these smart
contracts through user
1801:04 - interface. So those of you who
don't know about Gnosis safe,
1801:06 - you absolutely should know Safe
is a multi SIG wallet. And the
1801:10 - reason I put this on the list,
even though it's adds kind of
1801:12 - this centrality component is
that most dowels in the
1801:15 - beginning, are probably going to
start with some type of
1801:18 - centrality, it's much easier to
be fast when you don't have
1801:20 - 1000s of people to wait for a
vote. And in the beginning, any
1801:23 - protocol is going to be
centralized to some degree
1801:26 - anyways, using a multisig, we're
voting happens through only a
1801:29 - few key members can be good in
the beginning for your dials,
1801:32 - and often emergencies as well.
But just keep in mind, when you
1801:36 - add one of these, you are adding
this level of centrality, and
1801:39 - then of course opens up and
contracts we love opens up and
1801:41 - contracts. These are the
contracts that we're going to be
1801:43 - basing our Dao code along.
Alright, so that's all the
1801:46 - tools. That's the architecture.
One more thing before I let you
1801:49 - go legality, the future of Dows
is interesting for all these
1801:53 - reasons we just talked about,
but especially on a legal front,
1801:55 - does it make sense for a doubt
to live by the same regulation
1801:58 - as another company? Why would
you even force it down to do
1802:01 - something, you'd have to enforce
them to all vote a certain way
1802:03 - if the government tells you to,
it's a little gray, it's hard to
1802:07 - nail down who to even keep
accountable for these days and
1802:09 - the United States at least you
can actually form your own Dow
1802:12 - and have it legally recognized
in the state of Wyoming. This is
1802:15 - something I want to do. So we'll
just have to see what happens
1802:18 - there. Oh, at this point, you
have been injected with all the
1802:22 - Dow knowledge you need to
succeed and thrive with this new
1802:26 - amazing technology and these new
amazing concepts. And I found
1802:29 - them kill baby. All right, well,
you heard him it's time to
1802:32 - build. Like we said, All the
code is going to be located in
1802:36 - less than 17 Here, let's jump
in.
1802:44 - In this video, we're going to
show you how to build your own
1802:46 - doubt inspired by compound now
this is going to be 100% on
1802:51 - chain voting and on chain
governance. We're going to show
1802:53 - you the easiest way to spin up
an NFT or ERC 20 voting type
1802:57 - down all using solidity and
hardhat. Now if you haven't
1803:00 - watched my last video going over
the architecture of Dows, what
1803:03 - goes into one of these be
absolutely sure to watch that
1803:05 - video first and then come to
this video. Because that video
1803:08 - explains all the philosophy
behind what we're doing here
1803:10 - we're going to be using opens up
and contracts and a hard hat
1803:13 - framework to build this all in
solidity. If you want to see a
1803:16 - brand new or Pythonic version of
doing this, check the link in
1803:18 - the description because we did a
video over at the chainlink
1803:20 - hackathon recently. And
additionally, additionally, we
1803:23 - know that because we're doing
this 100% on chain gas fees are
1803:27 - going to be expensive. So I'm
really looking forward to
1803:30 - somebody doing a chain link plus
IPFS plus snapshot integration
1803:33 - so that we can do all this off
chain. And once that exists, you
1803:36 - already know I'm gonna make a
tutorial on that. And if you
1803:38 - like this style of content, be
sure to smash that like button,
1803:41 - subscribe and leave a comment in
the comment section to let me
1803:43 - know what you want to see. Next,
let me know how you want to
1803:45 - supercharge your smart contract
developer experience. So let's
1803:48 - jump in. Right, so here's what
we're going to be building,
1803:52 - we're gonna have a very basic
smart contract here, right, it's
1803:55 - called box and all it can do is
store a value and then retrieve
1804:00 - a value. But the thing is, its
ownable. And only the owner of
1804:04 - this contract can call the store
function and guess who the owner
1804:07 - is going to be the owner is
going to be the doubt. So only
1804:10 - through a process of governance,
can anyone store a different
1804:14 - function here. And once we're
done, we're going to go through
1804:16 - the entire process of proposing
voting queueing and then
1804:20 - executing a transaction in a Dao
to update our Bach contract. And
1804:25 - that's one of the beautiful
things about these these Dao
1804:27 - setups is that they're
completely modular, right. And
1804:30 - so when I go through the whole
process, I'll do Hardhead tests
1804:33 - here, which my tests right now
are set up to just do
1804:36 - everything, we're going to see
every single step that this Dow
1804:40 - is going to take. So we see box
starting value is going to be
1804:44 - zero. And then all of this stuff
is going to the governance
1804:47 - process. These are just some
some notes. Basically people are
1804:49 - voting, queueing and executing.
And then at the end, we chained
1804:53 - the value of the box contract
through a voting process. And
1804:58 - that's exactly what we're gonna
show you how to do today. Now
1805:00 - remember all the code for what
we're going to be doing here is
1805:03 - in my doubt template GitHub repo
so if you ever get lost, feel
1805:06 - free to refer back to this to
get started. And additionally,
1805:10 - if you want to see the Pythonic
version of this, feel free to go
1805:13 - back to the downmix The main
thing is though that all the
1805:16 - contracts are going to be the
same no matter what brownie hard
1805:19 - hat, dab tools, foundry, it
doesn't matter. So the first
1805:22 - part of this section is gonna be
exactly the same. And here's our
1805:26 - agenda here. First, we're gonna
write the smart contract. So if
1805:29 - you're not familiar with
Hardhead, who cares, we're gonna
1805:31 - be doing the smart contracts
first, then we are going to
1805:33 - write deployment scripts. And
this is where your hard hat
1805:35 - knowledge is going to come into
play. We're going to be writing
1805:38 - our deployment scripts in
TypeScript here, because
1805:40 - TypeScript is phenomenal. If
you're unfamiliar with
1805:42 - TypeScript, I challenge you to
rewrite this in JavaScript and
1805:45 - make a JavaScript version. And
then finally, we're going to
1805:47 - write some scripts to interact
with our governance with our
1805:51 - deployed contracts. Now, a quick
note, this isn't how I
1805:54 - originally built this, I didn't
just read smart contracts, write
1805:57 - deployment scripts, write the
scripts, and then the tests and
1805:59 - boom, I was done, I had a back
and forth between tests, smart
1806:02 - contracts, deploy scripts, etc.
If you're thinking, Oh, my
1806:05 - goodness, that's so easy for him
to go through this. So
1806:07 - seamlessly. When I originally
wrote this code, it was a lot of
1806:10 - back and forth. And that's how
you should be developing, you're
1806:12 - going to be moving between tests
and smart contracts and stuff.
1806:14 - Additionally, in this tutorial,
we are going to show you some
1806:17 - sick Hardhead skills. So you are
not only gonna learn how to
1806:20 - build a Dow, but you're gonna
learn some really advanced
1806:23 - Hardhead skills. So let's jump
in. Let's do this. So the code
1806:28 - editor I'm using is Visual
Studio code. So make sure you
1806:30 - have a code editor up and ready
to go. And you'll need a couple
1806:34 - of prerequisites here. Again,
the prerequisites are in the
1806:38 - GitHub repository, we're going
to need Git, no J, s. And yarn,
1806:41 - if you want to just clone this
repo and follow the instructions
1806:44 - here to get started, you
absolutely 100% can and then you
1806:47 - don't even need to build this
from scratch. But we're going to
1806:49 - want to learn to build this from
scratch. So let's just start git
1806:51 - dash dash version. Great, we
have Git no dash dash version.
1806:56 - Great, we have node, and then
yarn dash dash version. Great,
1806:59 - we have yarn, we can get
started. So everything that
1807:01 - we're going to be installing
here for packages is going to be
1807:04 - a dev dependency. So the first
thing we need to do is do yarn,
1807:07 - add dash dash Dev, hard hat,
1807:10 - if you'd haven't already. And
now in our folder, we're gonna
1807:13 - have node modules package dot
JSON readme and a lock. Of
1807:17 - course, now that we have that we
can run yarn RDAP, we're gonna
1807:20 - get the hard hat CLI up. And
we're going to have all this
1807:23 - stuff in here, we're just going
to create an empty hardhat dot
1807:25 - config dot j s, and we're going
to turn it to TypeScript. The
1807:28 - advanced sample TypeScript
project has a bunch of stuff
1807:30 - that I don't like. So we're just
going to create an empty
1807:32 - hardhead.config.js. And perfect,
we've got a little hard
1807:35 - hat.config.js. Now let's go
ahead and create a folder, or
1807:39 - contracts folder. And this is
where we're going to add all of
1807:42 - our contracts. So the first
thing contract that we're going
1807:44 - to need is the contracts we want
to have govern, which in our
1807:48 - case is going to be box dot
soul. Now, I am actually just
1807:52 - going to copy paste my box, that
soul here, because it's not
1807:55 - particularly interesting. But
you could really code whatever
1807:58 - you want here. So feel free to
pause the video, copy paste from
1808:01 - my GitHub repo, create your own
governance contract that you
1808:04 - want to play with, or do
whatever you want here. But for
1808:06 - us, we just have a store
function, and retrieve function,
1808:09 - and an event, and then a private
value that we're going to be
1808:12 - storing and retrieving. And
that's it. So of course, we want
1808:16 - to fix this. We're importing
from openzeppelin contracts
1808:19 - opens up is amazing. We're gonna
want to add this we'll do yarn,
1808:23 - add dash dash Dev, at opens up
on contracts. And that should
1808:27 - get rid of the box. That's all.
let's reopen box. And boom,
1808:32 - looks like we did a detour to
that perfect. And for
1808:34 - extensions, I'm using the
solidity, the one Blonko, slit
1808:38 - extension. And that's what we
get this wonderful linting
1808:40 - things here. Great. So now we
want to check to see if this
1808:43 - compiles if using remix, you can
compile with remix hard hat,
1808:46 - you're gonna see how we compile
here. Or if you're using you
1808:49 - know, Browning, we just want to
see if this compiles correctly.
1808:52 - So run yarn had a hard hit
Compile. Looks like we ran into
1808:56 - some compilation errors, because
we need to update this, let's
1808:59 - use these 8.8 of solidity we'll
try to compile again. And
1809:02 - perfect looks like we're
compiling successfully. Look
1809:05 - here, we do indeed have our
contract in here. Okay, perfect,
1809:09 - easy part out of the way.
Already. That was so quick. Now
1809:12 - let's start creating the next
part. Let's create the
1809:14 - governance part. So what we're
going to be working with to
1809:17 - build this governance platform
is we're gonna be building it
1809:21 - off of the ERC. 20 standard, so
you're gonna get an ERC 20
1809:24 - token. And that's going to be
the token that you get to vote.
1809:27 - So let's create a new file
called governance token. That's
1809:32 - all governance token dot Sol.
And this is gonna be the code
1809:36 - for the token that we use to
actually vote. Now we're going
1809:38 - to create a normal ERC 20 token.
And then we're going to extend
1809:42 - it to make it governance a bowl
and you'll understand what I
1809:44 - mean in a second. So let's go
ahead and make this spdx license
1809:49 - identifier. It's going to be MIT
pragma solidity we'll do zero
1809:56 - point 8.8. And then we'll do
contract governance token, and
1810:01 - then we'll say is ERC 20 I'm
just gonna go ahead and import
1810:04 - openzeppelin Because open
Zeppelin has a package where
1810:07 - basically has everything we need
for an ERC 20 token. So we're
1810:10 - gonna say import at open
Zeppelin slash contracts slash
1810:13 - token slash ERC 20x We can go to
their github openzeppelin
1810:20 - contracts token, your C 20 And
we'll do ERC 20 Dotto, we'll do
1810:25 - this for now.
1810:27 - token, use your C 20 ditzel.
We're gonna change this, but
1810:31 - don't worry about that yet. Now
we're going to do a un 256
1810:35 - Public Storage Max supply, it's
the best practice, but it's
1810:39 - fine, we'll give this a max
supply this much was going to be
1810:42 - 1-234-567-8910 12345678. So it's
gonna be 1 million, we're gonna
1810:48 - do 1 million of these tokens.
And then we're gonna create the
1810:50 - constructor construct or your C
20. Give it governance token as
1810:57 - a name, and then our symbol is
going to be GT. And for those
1811:00 - who who don't know, when you
inherit another contract in your
1811:04 - constructor, you can use that
inherited contracts constructor
1811:07 - as well. In fact, I think you
have to So governance token G
1811:10 - team, and then we'll even call
one of these ERC 20 functions
1811:14 - called mint. And we'll mint to
message dot sender, so whoever
1811:18 - deploys this ERC 20 contract
will just meant them everything,
1811:21 - the whole Max supply. Now
normally, if this was a normal
1811:24 - ERC 20 token, you'd be all done.
But this isn't a normal ERC 20
1811:28 - token. See, when we do votes, we
need to make sure that it's
1811:31 - fair, imagine this for a second,
someone knows a hot proposal is
1811:36 - coming up, they want to vote on.
So they just buy a ton of
1811:42 - tokens. And then they dump it
after the votes over. We want to
1811:47 - avoid this. We want to avoid
people just buying and selling
1811:50 - tokens to get in on governance.
So what we do is we actually
1811:53 - create a snapshot of how many
tokens people have at a certain
1811:57 - block snapshot of tokens people
have at a certain block. And we
1812:04 - want to make sure once a
proposal goes through, we
1812:06 - actually pick a snapshot from
the past that we want to use
1812:09 - this kind of incentivizes people
to not just jump in when it's a
1812:12 - proposal and jump out because
once a proposal hits, it uses a
1812:16 - block snapshot from the past. So
we're actually going to need to
1812:19 - change this a little bit. We're
gonna change this from ERC 20 to
1812:23 - an ERC 20 votes, and we can
actually see this in open
1812:27 - Zeppelin and the extensions
slash ERC 20 votes that soul
1812:32 - contract. If we go back to IRS
to their GitHub, we can see ERC
1812:37 - 20 votes, they also have a
snapshot, which is pretty
1812:39 - similar. And some of the main
functions are it has these
1812:42 - checkpoints. So these
checkpoints are basically Hey,
1812:46 - what is the snapshot? There's a
number of checkpoints, you can
1812:49 - also delegate your tokens to
different people. So maybe
1812:52 - you're not going to be available
to actually vote. So you say,
1812:54 - Hey, I'm gonna give my tokens to
somebody else. You can get how
1812:57 - many votes somebody has passed,
votes get passed, or was apply
1813:02 - it has all these functions that
make this token, much better as
1813:06 - a voting tool. Right makes it
much much better. So we're gonna
1813:09 - say our contracts governance
token is ERC 20 votes and we
1813:12 - just have to add additional
constructor, this ERC 20 permit,
1813:17 - I'm sorry, I kind of copied
pasted that. So ERC 20 permit
1813:20 - governance token. And right now
we have a governance token that
1813:24 - is a little bit more capable of
doing actual voting, right,
1813:27 - because as the snapshot has this
delegating functionality, it has
1813:31 - these checkpoints, it's going to
be much better for doing votes
1813:34 - in a fair way. The only thing
that we need to do though, is we
1813:37 - need to add some overrides,
right. And we're just gonna say
1813:40 - the functions below our
overrides required by solidity.
1813:47 - And this part is a little bit
boring. So I'm just going to
1813:50 - copy paste it, feel free to copy
paste it from my GitHub. But
1813:54 - what we're doing is anytime we
do this after token transfer,
1813:58 - and the time we transfer a
token, we want to make sure that
1814:02 - we call the after token transfer
of the ERC 20 votes. And the
1814:05 - reason that we do this is
because we want to make sure
1814:08 - that the snapshots are updated,
right, we want to make sure that
1814:11 - we know how many people have how
many tokens at each block. Same
1814:15 - thing with the mint. Same thing
with burning, we want to make
1814:18 - sure we always know how many
tokens people have at different
1814:21 - blocks or can be at different
checkpoints I should say. And
1814:24 - that's the most important bit at
which checkpoint Are you going
1814:26 - to use for your token voting. So
cool. Feel free to copy that,
1814:29 - again, from a GitHub or if you
want you can even just try the
1814:32 - rest of the tutorial without
this and see how you fare. But
1814:35 - cool. So now we have a
governance token and ERC 20
1814:38 - token that we can use for
governance. So let's try to
1814:41 - compile it. Yarn Hardhead
compile. Great, looks like
1814:45 - things are compiling
successfully. Perfect. So our
1814:48 - governance token looks good. Our
box looks good. Let's actually
1814:52 - now start creating our
governance contracts. Now we're
1814:56 - actually going to make a folder
called governance standard
1815:00 - because this is going to be the
standard governance model. This
1815:03 - is going to be this on chain ERC
20 and I plan on updating this
1815:06 - in the future with no a
governance off chain or
1815:09 - something right. So for now,
we're calling a governance
1815:11 - standard because this is the
quote unquote standard way to do
1815:13 - governance, but in the air,
we're going to need two
1815:16 - contracts actually, we're gonna
need a government work, contract
1815:19 - that soul and then we're also
going to need a time lock that
1815:23 - soul and this will make sense in
a second. So our gov contract
1815:28 - dot soul, this is going to be
the contract that has all the
1815:30 - voting code, all the voting
logic that our governance token
1815:34 - is going to use, the Time Lock
is actually going to be an
1815:37 - additional contract that is
actually the owner. So the Time
1815:41 - Lock and the governor contract
are sort of one in the same, but
1815:44 - the difference is the Time Lock
is actually going to be the
1815:47 - owner of the box contract. And
this is important because
1815:50 - whenever we propose or cue
something to a proposal to go
1815:54 - through, we want to wait, right?
We want to wait for a new vote
1816:00 - to be executed. Now, why do we
want to do that, let's say some
1816:05 - proposal goes through, that's
bad. So like, let's say we have
1816:08 - a box contract. And then a
proposal goes through that says,
1816:10 - Everyone who holds the
governance token has to pay five
1816:16 - tokens, or something like that,
right, or whatever, or who
1816:19 - knows, right? Maybe that's
something that you don't really
1816:21 - want to be a part of. So all of
these governance contracts give
1816:25 - time to give time to users to
get out, if they don't like a
1816:32 - governance update. So we always
want to have some type of
1816:36 - timeline. So once a proposal
passes, it won't go in effect
1816:40 - right away, it'll have to wait
some duration, and then go in
1816:43 - effect. So that's what the
timeline is gonna be for.
1816:45 - Governor contract is going to
have all of our actual code. Now
1816:48 - we can cheat a little bit.
1816:50 - Actually, we can cheat a lot of
a little bit. So opens up one
1816:53 - has a thing called the contracts
wizard, and there'll be a link
1816:56 - to this in the description as
well. And this opens up when
1816:59 - wizard is a way for us to write
really basic boilerplate code
1817:04 - right in there wizard. So right,
so if we go to the wizard
1817:06 - contract here, we can see we can
make an ERC 20 and NFT 1155. And
1817:12 - then finally, this gov thing
here. So we can call it give it
1817:16 - a name, we're going to call Rs.
Gov contract, during explain
1817:20 - what all this means, and give it
a voting delay, which is the
1817:24 - delay since a proposal is
created until voting starts. So
1817:26 - once you create a proposal, you
gotta wait a little bit, the
1817:28 - voting period, how long votes
should go for. And the reason
1817:32 - that this audio is important is
because they actually do votes,
1817:36 - voting period in terms of
blocks. So it's an anti pattern
1817:39 - to actually do timed based
things in smart contracts, it's
1817:42 - much better to do block based
things. So we're saying one
1817:45 - week, but it's that's going to
be you know, if if the average
1817:48 - block time is 13.2 seconds,
we're gonna figure out the weak
1817:51 - proposal threshold is going to
be the minimum number of votes
1817:53 - and account must have to create
a proposal. So maybe you only
1817:57 - want people who have a lot of
your governance token to make
1818:01 - votes quorum percentage, it's
what percentage of people need
1818:04 - to vote it all. So we're saying
4% of all token holders need to
1818:08 - vote or we could say you know,
exactly 100 tokens need to vote
1818:11 - whatever we want to do here. We
also have some updatable
1818:13 - settings we have Bravo
compatible Bravo is the compound
1818:17 - type contract. So if you want to
make it integratable, with
1818:20 - compound you can do that. Votes
comp like or ERC 20 votes, we're
1818:23 - working with this ERC 20 votes,
we always want to do a time
1818:26 - lock, we're gonna do the open
Zeplin implementation of a time
1818:29 - lock, you could also do a
compound implementation, we
1818:31 - aren't going to do upgradability
here, however, I have a number
1818:35 - of fantastic resources on how to
actually do upgradability. And
1818:37 - if we did want to do
upgradability, it adds all this
1818:40 - other stuff. We're not going to
do that for now because it makes
1818:43 - it so much longer video, and
then you can add some stuff like
1818:45 - this, but Oh, so that's pretty
much it. And I know this feels
1818:49 - like you're cheating, or we're
just going to copy this whole
1818:51 - thing, right? Copy all that
stuff that we put in copy to
1818:54 - clipboard, and we're going to
paste it in. Don't worry, I'm
1818:57 - gonna explain what's going on
now. So we have our government
1819:00 - contract. And this is governor
Governor setting Governor
1819:03 - counting simple Governor votes,
Governor votes, quorum Franco,
1819:06 - all this stuff. All these are
just implementations to make it
1819:09 - easier to be governor, Governor
counting simple is a way of
1819:12 - counting votes, Governor votes
is a way of integrating with
1819:14 - that year's 20 contract. Quorum
fraction is is a way to
1819:18 - understand quorum time lock.
Obviously, it's time lock. This
1819:21 - is going to be the base
contract. That's gonna be some
1819:22 - settings. And we're gonna talk
about this in a minute. But
1819:25 - let's go over what are the
functions here so we have voting
1819:27 - delay. This is exactly the
voting delay, which we're gonna
1819:30 - do superdad voting gelei, we're
gonna get from this governor
1819:33 - settings contract that we're
going to set in a minute your
1819:35 - voting period that we're going
to set in our gov settings,
1819:38 - which is this one right here.
And again, if you want to like
1819:40 - look at all these contracts, you
absolutely can, right, if we go
1819:42 - to contracts, governance,
extensions, we have all these in
1819:47 - here, right? So if we look at
governance settings, we can see
1819:50 - it has voting delay voting
period, proposal threshold, and
1819:53 - those are right in its
constructor. And that's exactly
1819:56 - what we're setting, right. We're
setting voting delay voting
1819:59 - period, and then the proposal
threshold, and then we're also
1820:01 - going to make this customizable
as well. And the rest of these
1820:04 - that's exactly what doing
calling the quorum from the
1820:06 - super get votes. And then again,
the super is those inherited
1820:10 - contracts, get the state and
then we have some interesting
1820:13 - functions we have proposed. This
is what we're actually going to
1820:16 - do to propose new governance we
have proposal threshold, and
1820:20 - then we have execute which
executes a cued proposal. To
1820:24 - cancel, we have executor which
we're is going to be who can
1820:27 - actually execute stuff, we're
actually going to make it
1820:30 - anybody and then supports
interface, you can basically
1820:33 - ignore. But let's make this a
little bit more customizable. So
1820:36 - we have Iboats token, this is
going to be our governance
1820:39 - token, the timeline controller
timeline, this is going to be
1820:41 - the timeline controller that we
make an amended. And again, we
1820:44 - need this because we don't want
to let any proposal just go
1820:47 - through once it passes, we want
to give people time to get out.
1820:50 - But let's add the UN 256 voting
delay as a parameter here. And
1820:57 - for voting delay, we're going to
do this, we're going to set it
1821:00 - as our governor settings, we're
going to do a UNT 256 voting
1821:05 - period. And we're going to add
that right here. And this means
1821:09 - 45,000 blocks is approximately
one week. And that's what that
1821:14 - means we're going to leave
proposal threshold to zero
1821:17 - because we don't really want to
change that we want to let
1821:18 - anyone make a proposal. And then
we're just going to add you in
1821:22 - 256 underscore core
1821:26 - percentage to this. So Governor
votes quorum percentage
1821:30 - corporate senators. So now this
is completely customizable, for
1821:33 - voting, delay voting period,
core percentage for whatever you
1821:36 - want it to be. And believe it or
not, that's it. Now you have a
1821:39 - simple governance contract.
Thank you, openzeppelin, for
1821:42 - doing 99% of the work for us. So
that's it. So this contract,
1821:46 - it's going to have all these
functions that we're going to go
1821:48 - over for proposing for executing
and for queuing, different
1821:52 - proposals. Right. Now we got to
make a time lock contract here.
1821:57 - And this contract is actually
going to be a lot easier. So
1822:00 - we're just going to do it from
scratch. So we're going to spdx
1822:02 - license I then to fire, my team,
do pragma solidity and let's
1822:09 - just do this your point a point
zero, and then we're going to
1822:12 - import from open Zeppelin, a
contract called the Time Lock
1822:15 - controller. So if we look at the
governance here, if this time
1822:18 - lock controller dot soul
contract, and this has all this
1822:21 - functionality in here for
creating roles, who can actually
1822:24 - propose who can execute, who's
the Time Lock admin, but it also
1822:28 - has these execute stuff in here
as well. It's gonna work in
1822:31 - tandem with our governance
contract, right? This is the
1822:34 - contract that says that makes
sure our governance contract
1822:38 - doesn't just push stuff through
willy nilly. So we're gonna say
1822:41 - we're gonna first import that
import at open Zeppelin slash
1822:45 - contracts slash governance slash
Time Lock controller. That's all
1822:52 - and then we're gonna say
contract, I'm lock is Time Lock
1822:57 - controller like that. And we'll
create our little constructor
1823:00 - here, and truck door. And this
because this takes a couple
1823:05 - different parameters, we're
gonna take a un 256 Min delay,
1823:09 - which are min delay, Min delay
is going to be along you have to
1823:14 - wait before executing. So this
is Hey, once proposal passes,
1823:19 - great, we gotta wait this
minimum delay, then we're going
1823:21 - to do a list of proposers, an
address array memory of
1823:27 - proposers. And then the
proposers is the list of
1823:31 - addresses that can propose for
us, we're just gonna say
1823:34 - everyone's gonna be able to
propose. And then last, an
1823:38 - address array, memory of
executors who can execute
1823:42 - everything, and we're just gonna
say executors who can execute
1823:47 - when a probe posle passes. And
again, we're just gonna say
1823:51 - everybody, and the reason we
need these is because we need to
1823:53 - pass these to our time lock
controller, this constructor is
1823:56 - expecting three parameters. So
we'll just do Tama controller,
1824:01 - delay, pro posers, X EQ, tours.
And that's it. So this is going
1824:09 - to be what owns everything, it's
the timelog, that's going to be
1824:13 - owning our box. It's not the
government contract, the
1824:15 - government contracts is where
we're going to send our votes
1824:18 - and stuff. But at the time lock
that actually everything needs
1824:20 - to flow through in order for
governance to actually happen,
1824:23 - because we want to make sure we
have this min delay, we go
1824:26 - through the right process and
everything. And believe it or
1824:28 - not, that's everything. That is
all the code you're going to
1824:31 - need as far as the solidity
goes, to create a governance to
1824:35 - create a Dao. So even do your
own hard hat compile, make sure
1824:39 - everything's compiled. And tada,
we've done it, you've done most
1824:43 - of the hard work. Now we're
going to flip over to actually
1824:45 - writing the scripts to deploy
and to interact with everything
1824:48 - using TypeScript here. At this
point, if you're like, Oh, I
1824:51 - already learned everything that
I wanted, I don't use hard hat,
1824:54 - I use some other tools. This is
where I challenge you to go out
1824:57 - and I challenge you to try
something else. Now if you've
1824:59 - reached this point, I just want
to give you a huge congrats,
1825:01 - because you have taken the steps
to build your own doubt build
1825:05 - your own governance model.
That's all the solidity that you
1825:07 - really need. You can take that
deploy that and you're good to
1825:10 - go. But of course, we know that
there's more to being a smart
1825:13 - contract developer than just the
solidity you got to do the
1825:16 - tooling right to let's go ahead
and we'll jump into writing
1825:19 - those TypeScript scripts to
actually do this. And again, if
1825:21 - you want to see a Python version
of this, go check out a link up
1825:24 - description to see the Pythonic
version of this. And of course,
1825:26 - don't forget to smash that like
button, subscribe, leave a
1825:29 - comment on how you're doing so
far. And, of course, give
1825:32 - yourself a pat in the back.
Great job. You're doing amazing
1825:34 - getting this far. Congrats,
let's jump in.
1825:38 - Alright, so we're back here,
we've written our smart
1825:41 - contracts already, check wasn't
that easy, right, this was way
1825:44 - easier than I thought it would
be. Now we're just gonna write
1825:46 - our deployment scripts, and then
we're gonna write our scripts to
1825:48 - interact with them. Again, my
full repo also has tests, but
1825:52 - we're just gonna write some
scripts. And then feel free to
1825:54 - check out the tests yourself. So
let's write those deployment
1825:57 - scripts to we're actually going
to be using a package for
1826:00 - deployment called Hard Hat
deploy. It is absolutely
1826:03 - phenomenal for hard hat for
making your deployments much,
1826:06 - much easier. We're gonna scroll
down to installation, and we're
1826:08 - actually gonna go ahead and
install this. So typically, you
1826:11 - could install it like this.
Well, we're gonna use yarn, but
1826:13 - we're gonna do kind of the more
safe way which looks a little
1826:16 - wonky, but I'm explaining it
right. So instead of NPM
1826:19 - install, we're gonna do yarn,
add dash dash Dev, and then this
1826:22 - whole thing right here. So we're
gonna do yarn, add dash dash
1826:26 - Dev, and then just paste that in
here. So this is gonna be at
1826:28 - nomic, labs slash hard hat,
hyphen ethers at NPM, colon,
1826:33 - hard hat, deploy ethers. And
what this is doing is we're
1826:35 - basically saying hard hat deploy
ethers is going to be overriding
1826:40 - this hardened ether thing. And
we're also going to add ethers
1826:42 - as well. And then once we add
this in, check our package json,
1826:46 - we can see we have hard hats. We
have hard hat ethers, which is
1826:50 - being overwritten by this hard
hat, deploy ethers. And then
1826:53 - additionally, we're going to
want to add on a deploy. So do
1826:58 - yarn, add dash dash Dev, hard
hat hyphen, deploy. And what
1827:03 - this is going to allow us to do
is instead of having to write
1827:05 - scripts, and do all this stuff,
that kind of makes it hard to
1827:08 - save your deployments and
everything, we're going to just
1827:11 - create a deploy folder, where
we're going to add all of our
1827:14 - deploy scripts in here. So I
absolutely love this package.
1827:17 - It's makes deployment really,
really easy. So in here, we're
1827:20 - gonna create new file, it's
going to do oh one, we're gonna
1827:22 - go step by step deploying
everything, we're gonna call
1827:24 - this deploy, govern or token dot
TypeScript, that's gonna be the
1827:29 - first thing we're going to do.
Also, we're gonna change this to
1827:33 - TypeScript. Tada, we now have
TypeScript. Yay. Now the one
1827:37 - thing that is kind of nice about
doing kind of that advanced
1827:40 - TypeScript thing at the heart
had kind of gives it the
1827:42 - beginning, is you don't have to
install all the TypeScript stuff
1827:45 - yourself. But we do. So we're
going to do yarn, add TypeScript
1827:49 - type chain, vs node at type
chain slash ethers, V five, this
1827:57 - is a lot of stuff, don't worry
type chain slash hard hat, at
1828:00 - type slash Chai, at type slash
node. And then we'll make sure
1828:05 - this is all Dev, dash dash Dev,
I know there's a lot of stuff.
1828:10 - There's all this stuff to make
it TypeScript D.
1828:12 - You can absolutely do this in
JavaScript if you want. You just
1828:15 - have to do JS files and ignore
the typing. So But feel free to
1828:18 - do whatever you want to do.
Alright, cool. And we should be
1828:20 - okay here. Let's go into our
governor token here. And we'll
1828:24 - create a deploy script. So the
Hardhead deploy GitHub repo has
1828:28 - a little demo boilerplate code
for you actually do your deploy
1828:31 - script. So feel free to
reference here if you lost or
1828:34 - confused. So what we're going to
do is we're going to import the
1828:37 - hard hat runtime environments,
from our enhanced slash types.
1828:44 - And you'll see why we need this
in just a second. And then we're
1828:46 - also going to import deploy
function from Hardhead. Deploy
1828:50 - slash types. And these are the
two main things you need to
1828:53 - create a deploy function with
pothead deploy, we're going to
1828:56 - create our function, we're going
to call it const ploy governance
1829:00 - token, it's going to be of type
deploy function. So in order for
1829:04 - these to actually work, we just
create a whole bunch of deploy
1829:06 - functions that we run with heart
hub. And this is going to be an
1829:08 - async function. That's going to
take the hard hat runtime
1829:12 - environment as an input
parameter that we're going to
1829:15 - call HRV. So when we run hard
hat deploy, which you'll see in
1829:19 - a second, we're actually passing
our fake hard hat chain that
1829:22 - gets spun up in the background
for us, right, we can even do
1829:25 - like console dot log Hello. And
if we do yarn, hard hat deploy.
1829:30 - Actually, before we even do
that, if we do yarn, hard hat
1829:32 - dash dash help, you'll see,
since we imported hard hat
1829:35 - deploy up excuse me, we need to
add this to our config. First in
1829:39 - our config, we're gonna need to
do top imports, hard hat deploy
1829:45 - top Roscoe need to import at
nomic labs slash hard hat
1829:49 - ethers, we're also going to need
to import at type chain slash
1829:53 - hard hat. And then we'll leave
it there for now. We'll have to
1829:56 - import more stuff in a second
but literally like that. Now, if
1829:59 - we do yarn hard hat that should
help we should see a new task in
1830:03 - here. And we do we actually see
a ton of new tasks right? Filled
1830:06 - with tasks, check clean compile,
console deployed. And this is
1830:10 - the new task that we have that
actually deploys all of our
1830:13 - contracts, anything that's in
this deploy folder, our head
1830:16 - will go ahead and run right now
in our deploy folder. All we
1830:19 - have is this console dot log
Hello. So if we run yarn, or hit
1830:23 - Deploy, we should See, it just
prints out hello. It'll spin up
1830:26 - a new blockchain background,
while all of our projects and
1830:29 - everything, do some type type
chain stuff, and it says you'll
1830:33 - see this a lot deploy script dot
func is not a function. And
1830:36 - that's because we actually need
to export this now. So we'll do
1830:38 - export default, deploy
governance token. That's why
1830:44 - it's getting mad at us. Now
we'll run yarn had her hard hat
1830:46 - deploy. And boom, we say hello.
So this is how we can actually
1830:50 - deploy all of our scripts. And
we can run everything that's in
1830:53 - this deploy folder in one go,
which is really helpful. So
1830:57 - let's go ahead and deploy our
governance token first. And this
1831:00 - will get a lot faster as we go
along. Don't worry, so delete
1831:02 - this. And first we're gonna do
it, we're gonna say const. We
1831:05 - need an account to deploy this
first. So we'll say const, get
1831:08 - named accounts, deployments, and
network equals HRA. And this is
1831:13 - going to be a little bit more
advanced. This is hard stuff.
1831:15 - This is this is the slick stuff
we're doing here, we're getting
1831:18 - these from our hard hat runtime
environment, which is being
1831:21 - updated from hard hat deploy. So
get named accounts is way for us
1831:25 - to actually import accounts from
our hard hat config, right into
1831:29 - our deploy script. So we're
gonna go to our hard hat config.
1831:31 - And we're gonna create a new
config that's a little bit nicer
1831:34 - than this. So first, we need to
import the hard hat config type.
1831:37 - Since we're using type scripts,
we're going to import hard hat
1831:39 - user config from hard hat slash
config. And we're going to
1831:43 - create a config. So I'm just
gonna comment this out. For now
1831:47 - we're gonna say const. Config,
it's gonna be type hard hat user
1831:50 - config. Equals, and this is
where we can add a whole bunch
1831:53 - of stuff. So let's say our
default network is going to be
1831:56 - hard hat, which is kind of our
local fake blockchain. And then
1832:00 - we're gonna say solidity is
zero, point 8.8, then we're
1832:05 - going to do this thing called
named accounts, which is what we
1832:08 - came here in the first place
for. So this is just a list of
1832:11 - accounts that we can use. So for
accounts, we'll say Deployer,
1832:14 - this will be the name of our
account that does all the
1832:17 - deploying, and we'll just say,
default, is going to be zero. So
1832:21 - whenever we run an any chain,
our zero with account is going
1832:26 - to be named Deployer. What other
thing that we need to do is we
1832:29 - need to add our networks here.
And there's actually two
1832:32 - networks that we're going to
have, we're gonna have a hard
1832:33 - hat with a chain ID of 313337.
And we're also going to have
1832:39 - local hosts of chain ID 31337.
Now, these look like they're
1832:44 - pretty much the same. And I
understand that, but they're
1832:48 - not. And you'll understand why
in a second, but we need them
1832:51 - for now. Just to tell Hardhead
hey, here are the development
1832:55 - fake blockchains that we're
working with? Okay. So this is
1832:59 - kind of our basic setup here.
Okay. I know that was kind of a
1833:02 - lot. But now that we have get
named accounts, we have network,
1833:04 - right? Because anytime you
deploy something, it's going to
1833:06 - be on a network. And when we
deploy something, if you run
1833:11 - yarn, hard hat node, what hard
hat is going to do, it's going
1833:14 - to spin up a fake blockchain in
the background. Oh, it's gonna
1833:17 - be mad at me for a second. Oh,
1833:18 - I forgot to add export, default
config, right, we need to export
1833:22 - the config. Hell hard hat that
we're using this version of
1833:26 - sling. Now if you're on a hard
hat node, you'll see why we
1833:29 - added these two networks up here
hard hat on localhost, we
1833:31 - actually get spun up our own
fake blockchain, we get
1833:34 - accounts, we get private keys,
we get everything right. This is
1833:37 - a hard hat Node running in this
terminal, right? When you run
1833:41 - hard hat node, oddly enough,
it's actually the local host
1833:44 - network. It's not the Hard Hat
Network. When using hard hat
1833:47 - deploy, it's gonna be the local
host network. Or excuse me, when
1833:50 - you use hard hat node, it's
actually going to be the local
1833:52 - host network, not the Hard Hat
Network. The Hard Hat Network is
1833:55 - what it uses when it runs tests.
localhost is when you run this
1833:58 - hard hat node and have this kind
of fake blockchain running in
1834:02 - your terminal. So that's what
the localhost is. Cool. Well,
1834:05 - Ctrl C will kill that. Alright,
great. So now stuff is actually
1834:08 - working. So get them to count
deployments is going to be a
1834:11 - whole bunch of stuff from
deployments, you'll see in a
1834:12 - second and network is the
network that we're on. Okay,
1834:14 - great. So now we're gonna grab
const deploy log equals
1834:19 - deployments, this deployments
object comes with this deploy
1834:22 - function. And this log function,
this log function is kind of
1834:25 - nice for doing logging. And then
we're gonna grab const, employer
1834:30 - equals await, get named
accounts. So we're grabbing from
1834:35 - our config, this deployer
account, right? And it's always
1834:40 - going to be the zero with index.
So it's defaulted to the zero
1834:44 - index for whatever accounts that
were with. Great. So we now have
1834:47 - an account to deploy stuff from
we have a deploy function, we
1834:49 - have all this stuff, we're
looking pretty good. Cool. So
1834:52 - sometimes they'll do like a log,
flying governance token, dot,
1834:58 - and we'll say const governance
token equals await, deploy, and
1835:03 - then the name of the contract
which is governance token,
1835:06 - comma, and these are all the
parameters that we're going to
1835:08 - pass to it. So we're gonna say
from deployer doesn't take any
1835:13 - arguments. So args is just going
to be blank. We're going to do
1835:17 - log to be true so we'll get some
logs printed out for us. And
1835:20 - then I have this wait
confirmations attribute set in
1835:24 - GitHub repo. For now we're going
to ignore this. But if you
1835:27 - follow along with my repo and
you want to auto verify stuff,
1835:29 - this is something that you're
going to want to use. So you
1835:31 - need to wait some amount of
blocks for this contract to be
1835:35 - deployed before you can actually
go ahead and verify it, right.
1835:38 - Because if you're using ether
scan or something, you're gonna
1835:40 - need to wait like, yeah, you're
gonna need to wait a few
1835:43 - minutes. So check out my GitHub
repo for this wait confirmation
1835:45 - stuff, I'm just going to ignore
it for now. Additionally, in my
1835:48 - GitHub repo, I have this verify
function, where we check to see
1835:51 - if it's on a development chain.
And if it is, we don't verify
1835:54 - it. But if it's on like ether
scan or something, we go ahead
1835:56 - and verify it. So be sure to
check the GitHub repo to learn
1835:59 - how to just auto verify without
having to do anything. Now if we
1836:02 - just do this part. And then we
can even do Floyd, governance
1836:07 - token to address governance
token dot address. And we'll do
1836:16 - yarn hardhat. Deploy. Boom. So
we spin up on a fake Hard Hat
1836:24 - Network, we do deploy governance
token to address boom. And this
1836:27 - is how we deploy a fake has
deployed this to our own little
1836:30 - network here. Great. So this
tokens been deployed, we have
1836:34 - our deploy script. Yeah, zoom
out a little bit. Let's zoom out
1836:37 - a little bit. Great. That's the
whole thing. Now we're going to
1836:39 - add one more thing here, we're
going to add something called
1836:41 - delegate function. Now, when you
actually deploy this contract,
1836:44 - nobody has voting power yet. The
reason is, because nobody has
1836:47 - the token delegated to them, we
want to delegate this token to
1836:51 - our Deployer. Right, so we're
going to call this delegate
1836:53 - function. So we're going to
create a new function called
1836:56 - const. delegate. And it's going
to be an async function. It's
1837:01 - going to take a governance token
address as a string, it's going
1837:05 - to take a delegated account,
also as a string, so we're
1837:08 - racing and say, who do we want?
Delegate? Who do we want to be
1837:14 - able to vote with our token?
Okay, so we have created this
1837:17 - async function called delegate.
And how do we do this? Well, we
1837:20 - say Kant's over its token equals
token equals await ethers dot
1837:29 - get contract at.
1837:33 - And probably for two ethers for
us from hardheaded Otto did
1837:36 - that, which is great. That's
what we want. Once it's like
1837:38 - ethers. Thank you vs. Code away.
Ether is like a contract at. And
1837:43 - we're going to say we want our
governance token, which is at
1837:47 - contract, governance token
address. And I have auto format
1837:53 - unsaved, which is why it keeps
formatting like that. This
1837:55 - should be delegated account.
Okay, cool. We have our
1837:58 - governance token contract. Now
we can do const TX or
1838:02 - transaction equals await,
governance token dot delegate
1838:07 - delegate this delegated account
here. And then we can do a wait,
1838:11 - we'll wait for this transaction
to be confirmed by one block.
1838:16 - And then we'll just do console
dot log checkpoints, wait,
1838:21 - governance token dot num
checkpoints delegated account?
1838:28 - So what is this doing? So we
have this num checkpoints
1838:31 - function which we can go check
to see on that ERC 20 token what
1838:35 - this is actually doing. But
basically what this whole thing
1838:37 - is doing, we have this delegate
function that we haven't used
1838:40 - it. But when somebody calls us,
we're saying, Hey, you can use
1838:43 - my vote, take my votes and vote
however you want. And that's
1838:45 - what these this delegate does.
Now, if we look at this token,
1838:48 - here, see 20 extensions, your
see 20 votes, we look at number
1838:53 - checkpoints, we can see how many
checkpoints that account
1838:57 - actually has reason this is so
important is because once again,
1839:00 - like I was saying when people do
a vote, they do it based off
1839:03 - some checkpoints. And anytime
you transfer a token, or
1839:06 - delegate a token, basically call
this function move voting power,
1839:09 - which happens with the back end,
which writes the checkpoint and
1839:12 - says, Hey, at checkpoint x,
here's what everybody has for
1839:16 - voting powers. And that's what
these are so important. And I
1839:19 - know I said before, it's every
block, but it's actually just
1839:21 - every checkpoint, whenever these
checkpoints are updated, that's
1839:24 - gonna be a lot cheaper on gas
than if we just did every single
1839:26 - block, right? That'd be kind of
insane. So the checkpoint for
1839:30 - this governance checkpoint, and
we'll see what that actually is
1839:33 - in just a second. So we'll even
do a wait, delegate, governance
1839:37 - token dot address, and Deployer.
And we'll say log delegated.
1839:44 - Now, when we're on this
function, John Howard hit
1839:47 - Deploy. We have one checkpoint,
which makes sense, right?
1839:51 - Because this was just deployed,
it was just delegated. This
1839:55 - address has one checkpoint.
That's it. And the reason I
1839:58 - checked for this is because if
you see zero checkpoints here,
1840:00 - it means you haven't delegated
correctly. So be sure to check
1840:03 - for checkpoints. But that's it.
We have our deployed governance
1840:06 - token contract done. Bravo.
Let's move on to the next one.
1840:10 - So what do we want to do after
we deploy our governance token?
1840:13 - Well, let's deploy that timelock
or timelock.ts. And we're going
1840:17 - to copy a lot of this stuff over
from here, so I'm actually going
1840:20 - to Oh, and then sometimes you'll
get some weird linting errors
1840:23 - here. I just do det TS ignore
there. And sometimes you'll get
1840:26 - it here too. Oh, actually, we
don't even need network. Okay,
1840:29 - cool. Yeah, you don't even need
network loops. Sometimes we get
1840:32 - some weird linting errors.
Sometimes Vyas code has a hard
1840:35 - time telling understanding like
this, this overwrite thing that
1840:38 - we did. So just run that TS
ignore if if it gives you some,
1840:42 - some engineers, anyways, yes, we
have this Oh, to deploy time
1840:45 - lock here, we're going to deploy
our time lock contract. And
1840:47 - we're going to borrow a lot of
the things that we did from
1840:49 - here, so I'm just going to come
back here are actually going to
1840:52 - copy paste these two top bits.
Again, we're gonna do const
1840:56 - deploy timelock is going to be a
deploy function, it's going to
1840:59 - be an async function that takes
the heart at runtime environment
1841:04 - as a parameter, and cool, nearly
exactly the same sorry. And then
1841:08 - we're going to grab these first
three lines, or first four
1841:10 - lines, I guess, pesos, then
we're going to be getting those
1841:14 - exact same things here. And
we're going to be doing nearly
1841:16 - the exact same thing. So we'll
do log deploying. Time Lock,
1841:21 - point time lock, will do const.
Mark equals await, deploy,
1841:28 - unlock. We'll add some
parameters in here, we'll say
1841:31 - from Deployer. Now does this
take some arguments? It
1841:36 - absolutely does. Right, we can
take a look at the Time Lock,
1841:39 - Min delay proposers and
executors. So what do we want
1841:43 - our min delay to be? Well, this
is a value that we're actually
1841:46 - going to use a lot. So what I
usually like to do is I create a
1841:49 - new file called helper. hardhats
config.ts. And right at the top,
1841:56 - I'll say Export const min.
Delay, and I'll have this delay
1842:01 - be whatever I want it to be. So
let's just go ahead and do 3600,
1842:04 - which is going to be
approximately an hour, right,
1842:06 - you gotta wait this many
seconds, I think that's an hour.
1842:09 - Without the old calculator.
There's 60 seconds, in 60
1842:12 - minutes. Great. That's gonna be
one hour. So wait 30 minutes.
1842:16 - And we're gonna go ahead and
import that here. We'll say
1842:18 - import, Min delay. Wow,
autocomplete for being great.
1842:23 - From helper from, you know, it's
down directory, helper Hardhead
1842:27 - config. And that's gonna be our
first argument here. Our second
1842:30 - argument is going to be a list
of proposals. Now we're going to
1842:32 - leave it blank for now. And also
the list of executors we're also
1842:35 - going to leave it blank for now,
we're going to update this in a
1842:38 - minute. And you'll see why once
we get there, we'll do log true.
1842:42 - This also has a wait
confirmations thing in my
1842:44 - GitHub, but we're going to skip
that for now. It also has an
1842:47 - auto verify, we're also gonna
skip that for now. Then we just
1842:50 - need to export default, deploy
timelock. And boom, we should be
1842:55 - good. So let's try to run this
on hard hat deploying. So now
1842:59 - this should run both of these
great deployed governance token
1843:03 - deployed timelock.
1843:04 - Perfect, we are cruising now
what we want to deploy that
1843:08 - governance contract now. So
let's go ahead and do that.
1843:10 - We're gonna do Oh, three LOI.
Gov, nor contract.ts. And you
1843:18 - guessed it, this is going to
look pretty similar to what we
1843:21 - just did. Right. So in our
deployed time lock, let's go
1843:24 - ahead and just grab those top
two things. We'll paste it in
1843:27 - here. We'll do const deploy,
govern or contract, there's
1843:33 - going to be an apply function,
it's going to be an async
1843:35 - function, taking a part at
runtime environment, save and
1843:40 - close this for now. And we can
even go back and grab these
1843:43 - three lines from our Oh, to
deploy time lock, paste that
1843:46 - right in here, because we're
going to need to get the exact
1843:48 - same things. And additionally,
for this, we're going to need to
1843:51 - get the governance token and the
Time Lock contract. So we'll do
1843:55 - const governance, token equals
await. Get which actually, we
1844:01 - have this, this get function
that comes from these
1844:03 - deployments, which literally
just goes out and gets these
1844:06 - deployments. So we'll say get
Gover Nance token. And then we
1844:10 - also need to get the Time Lock.
So await, get m lock. And we
1844:17 - need these to pass as parameters
for our governor contract.
1844:22 - Right? Because if we open up the
governor contract that soul, we
1844:27 - look at the constructor, it
takes the token, the Time Lock
1844:29 - voting, delay voting period and
quorum percentage as input
1844:33 - parameters. So we'll do a quick
log deploying go burn nor ello.
1844:39 - And they will do const govern
nor contract equals await,
1844:44 - deploy, and will deploy the
govern nor contract I'm not sure
1844:48 - if I'm spelling this right
always, but that's fine. And
1844:51 - we'll do the parameters once
again. So it's gonna be from
1844:54 - Deployer. args are going to be
this list of args. What's the
1844:58 - first thing that it needs? It
needs the token first and the
1845:02 - Time Lock. So we'll do
governance token dot address,
1845:06 - then it's going to need the Time
Lock that address. And it's
1845:09 - going to need a vote on voting
delay voting period and quorum
1845:13 - percentage. So these are also
values that we're going to make
1845:17 - a lot. So let's open back up
that helper Hardhead config, and
1845:20 - let's create those as well. So
we'll say Export const just
1845:24 - voting period. And we'll say
this is going to be five blocks,
1845:28 - we'll do export const voting
delay, this is going to be just
1845:32 - one block, which I know is
really quick. And then we're
1845:36 - gonna need export const Orem
percentage, which we're gonna
1845:42 - say is four 4% of voters always
need to be voting. Excuse me, 4%
1845:47 - of voters need to have voted for
a vote to pass. Great. So we're
1845:51 - going to do voting delay voting
percentage quorum percentage. So
1845:55 - we'll import those so to import
voting delay voting period, or
1846:05 - quorum percentage from helper
Hardhead config. And now that we
1846:08 - have those delay period
percentage, we can just do kind
1846:12 - of a voting delay, voting
period, farm percentage, and
1846:16 - then we'll say log is true.
Again, this one as well. It has
1846:20 - a wait confirmations and auto
verification that we're going to
1846:23 - totally ignore. And then we'll
export default, blood Governor
1846:27 - contract. Oh, Carrie, we're
getting spicy. Let's just make
1846:30 - sure this works. Yarn hardhat
deploy. We should see three
1846:33 - contracts deployed here. I think
to compile governance, token
1846:37 - deployed timelock deployed
governance contract deployed.
1846:40 - Let's go. Alright. Now, we're
not done yet. We have two more
1846:45 - deploy scripts to do. The first
one, we're going to call setup
1846:47 - governance contracts. Okay. And
this one's really important. The
1846:51 - right now our time lock contract
has no proposers and no
1846:55 - executors. Right. So we want to
change that we want to only
1846:59 - allow for the proposer to be the
governor, the governor contract
1847:02 - should be the only one that
proposes things the Time Lock,
1847:05 - and then anybody should be able
to execute the way that this
1847:07 - works. We say the governance
contract proposes something to
1847:10 - the Time Lock once it's in the
Time Lock, and it waits that
1847:13 - period. Anybody can go ahead and
execute it. So Governor contract
1847:17 - everybody votes and everything.
Once a vote passes, Governor
1847:20 - says hey, Time Lock, can you
please propose this? Tom like
1847:23 - goes yeah, sure. But we got to
wait, this minimum delay, once
1847:26 - it's been in delay happens,
anybody can execute it. Now this
1847:29 - would be really cool to do an
integration with chain link
1847:30 - keepers, by the way, for the
chain link keepers to
1847:33 - automatically execute. And I
should build the next anyways.
1847:36 - So we have to set this up so
that these work as such, so
1847:39 - we're gonna create a new deploy
thing called Oh, four, setup,
1847:42 - governance contracts dot
TypeScript. And this is going to
1847:46 - be the code that does all the
setting up. And this is gonna
1847:49 - look really similar once again,
to all of our other deploy
1847:51 - functions. So we'll go head back
from oh three, we'll paste these
1847:55 - two top ones in here, of course,
we're gonna do const setup
1847:59 - contracts, is it going to be a
deploy function, going to be an
1848:03 - async function, it's going to
take HRV art at runtime
1848:08 - environment as parameters, and
then that's the winner right
1848:11 - there. Cool. And we're gonna be
grabbing those same three from
1848:15 - the top, as you can see, that
gets a little bit easier,
1848:17 - because it's kind of repetitive,
right, we're gonna grab that bit
1848:20 - right here. And now we're gonna
get those contracts so that we
1848:22 - can interact with them. And this
is another reason why a hard hat
1848:25 - deploy is so nice, because we
can just do const timelock
1848:29 - equals await ethers that get in
the next let's go ahead and
1848:33 - import ethers from hard hat
imports. Ethers
1848:38 - from Red Hat will even drop a
little TS ignore here. Ethers
1848:44 - dot get contract, we want that
time lock contract. And we say
1848:47 - we want to attach it to the
Deployer. So whenever we call a
1848:50 - function on it, it'll be the
deployer calling that function
1848:52 - and we want to do const Governor
equals await ethers dot get
1848:57 - contract, Governor contract,
this is all going to be attached
1849:01 - to the Deployer. Right. Now,
we're gonna do log setting up
1849:05 - roles. And we're going to set up
the roles right, again, we're
1849:09 - setting it up so that only the
governor can send things to this
1849:12 - time lock, because the Time Lock
is going to be you can almost
1849:15 - think of the Time Lock as like
the president. Right. So
1849:17 - everything goes to the Senate,
the House representative, which
1849:20 - is the governor and then the
President just says yeah, sure.
1849:23 - We just got to wait this minimum
delay, but the President will be
1849:26 - the one to actually execute
everything which I'm not
1849:27 - actually sure that's how it
really works in in politics, but
1849:30 - for for now, that's that's where
we're protecting the president
1849:33 - or the time like is the only one
that can actually do anything
1849:36 - here. So the way that this works
is we're actually going to get
1849:40 - the byte codes of different
roles, right? So if you look at
1849:43 - these time locks here, so we'll
do ones up on contracts. And we
1849:49 - go to the governance here. We go
to Tama controller has these
1849:53 - things called proposal roll,
executor roll time, like admin,
1849:57 - etc. And these are just hashes
of these strings here. But these
1850:01 - are these are bytes 32 saying,
Hey, anybody who has this this
1850:05 - byte 32 is a proposer, anybody
who has this byte 32 is an
1850:08 - executor. Anybody has this byte
there and soon as time like
1850:10 - admin, etc. Right now, our
Deployer account is the time
1850:14 - like admin, and that's bad. We
don't want that we don't want
1850:17 - anyone to be a time like admin,
right? We don't want anyone to
1850:20 - have power over this time lock.
We don't want any centralized
1850:24 - force here. So what we're going
to do is we're going to const
1850:26 - we're going to get those roles.
proposer, proposer role, it's
1850:30 - going to be a weight, unlock
that row pole sir role. And if
1850:35 - you're familiar with multi call,
this would be a great time to do
1850:38 - multi call and copy paste that
whole line x EQ tour role at x
1850:44 - EQ tour roll, we're gonna copy
this whole line admin role. And
1850:50 - this is going to be on lock
admin role. So these are these
1850:54 - three roles that we need to fix,
right, and let's go ahead and
1850:58 - fix them. So the first thing
we're gonna need to do is we're
1851:00 - gonna need to do const row poser
dx equals await Time Lock dot
1851:06 - grant roll, propose a roll to
our governor dot address. So
1851:10 - saying, okay, Governor, you're
the only one who can actually do
1851:14 - anything once you tell the Time
Lock to do something. We'll wait
1851:17 - for the Time Lock period to be
over. And then we'll be done.
1851:20 - And then we'll just do an await
posit TX dot wait one block just
1851:24 - to make sure. Now we're gonna do
the const executor, TX equals
1851:29 - await Time Lock dot grant roll
executor role to nobody, we're
1851:36 - going to execute this we're
gonna give this to nobody, we're
1851:39 - going to say address zero which
is going to be something that
1851:41 - we're going to want to add if we
go to our helper or head config
1851:45 - will say Export const address
zero equals zero by you can just
1851:51 - copy paste this if you want.
There's a couple other ways you
1851:53 - can do this with ethers as well.
We're just gonna do like this. I
1851:56 - like having my conflict this and
then we just import it say
1852:00 - import at zero from dot dot
slash helper Harnett config. So
1852:05 - we're giving the executor role
to nobody, which means
1852:08 - everybody. So once a proposers
thing has gone through, anybody
1852:12 - can execute it. So we'll say
executor, TX That wait one wait
1852:16 - a block. And then got one more
to do here, we need to revoke
1852:21 - role right now our Deployer
count owns that time lock
1852:25 - controller, right. And that's
how we can actually do these
1852:28 - transactions, we can actually
grant role because our Deployer
1852:31 - account owns it now that we've
given everybody access. And
1852:34 - given all the decentralized
access we need, we want to
1852:37 - revoke that role. So const
revoke TX equals await. I'm
1852:41 - locked up revoke role, admin
role from Deployer will do Rotex
1852:48 - that wait, now guess what
anything that's um, like, wants
1852:51 - to do has to go through
governance, and nobody owns the
1852:54 - time I controller, it's
currently after this runs, it's
1852:57 - impossible for anyone to do
anything with the Time Lock
1853:00 - without governance happening.
And then of course, when the
1853:03 - export default set of contracts,
great. And then the last step
1853:07 - that we need to do here is we
need to deploy the contract that
1853:11 - we actually want to govern over
write that box contract, that
1853:14 - real basic contract. So we're
gonna create a new 105, deploy
1853:17 - box.ts. And we're gonna do some
of the same exact stuff we've
1853:21 - done right, so we're gonna grab
these two, these two here, paste
1853:24 - it in, os deploy box is going to
be a deploy function equals
1853:29 - async function, Ah, sorry, hard
hat runtime environment,
1853:34 - we're gonna grab those first
three lines, the TS ignore, just
1853:38 - like that. And now we're going
to deploy this box. So log,
1853:42 - deploying bucks, and we're going
to do const box equals await,
1853:47 - deploy box, give us some values
from our Deployer. args does
1853:53 - this have any args so open a box
dot soul, I don't see a
1853:56 - constructor. And while this is
the easiest contract out of all
1853:59 - these though, no constructor,
and then we'll just say log,
1854:03 - it's going to be true. And
again, if you want to check out
1854:06 - my GitHub repo for that
confirmations, but feel free to
1854:09 - do so it's coming here. And
right now, our deployer has
1854:13 - actually deployed this right,
not our time lock. So we want to
1854:16 - give the boxes ownership over to
our governance process. So now
1854:21 - we're going to do say const
timelock, is going to be a
1854:24 - weight ethers dot get contract.
The same thing as before.
1854:28 - timelock. We're going to grab
ethers from hardhat import
1854:33 - ethers from hard hat. And we're
gonna do a little TLS ignore,
1854:38 - it's being finicky. And then
we're going to transfer the
1854:42 - ownership of our box to this
time lock, okay, and now so this
1854:46 - is actually what's known as a
box deployment. So before we do
1854:49 - that, we have to get the box
contract. So this is a box
1854:51 - deployment object, which doesn't
have contract functions we want
1854:54 - to get the box contract object
so we to box or const box
1854:58 - contract equals await ethers dot
get contract at box and then
1855:06 - we'll just do you know box that
address. You could also do get
1855:09 - contract. Actually both of these
pretty much if you have the
1855:12 - address, you can just do box
that address. You could also do
1855:15 - get contract here. Either one
works now that we have the box
1855:17 - contract, we do const transfer
owner, dx equals await by
1855:24 - contract dot transfer TX or
schema dot transfer ownership to
1855:30 - our timelock dot address, time
walk dot address, then we just
1855:36 - do a weight transfer ownership
TX dot weight one, do a log, you
1855:43 - done it. Those are export
default. Deploy box. Oh, let's
1855:51 - see if this works. So we just
did everything. We're deploying
1855:56 - the GOV token, deploying the
timelock, which owns the
1855:59 - governance process, we're
deployed the governance process,
1856:02 - we're setting up the governance
process so that it's totally
1856:05 - decentralized. And then we
deployed and set up our box so
1856:08 - that it only can be updated
through a governance process.
1856:13 - Let's see if it works. Yarn,
hard hat deploy. Let's see if it
1856:18 - works. Bada boom, you've done
it. So you've just set up a
1856:23 - script to set this entire
governance process up so you can
1856:27 - build your own doubt. Are you
still here? Well, hell yeah, you
1856:31 - are, congratulations on getting
this far, we have one more piece
1856:35 - to go, we just got to write
those scripts. So we can
1856:37 - actually interact with this, we
can actually do a governance, we
1856:40 - can actually see exactly what
the governance process looks
1856:42 - like. Now again, if you didn't
watch my last video on Dows, be
1856:45 - sure to watch that, because
that's going to give you all the
1856:47 - context for this part here. And
if you're still watching 100%,
1856:51 - smash the like button, hit the
subscribe, leave a comment in
1856:54 - the comment section below, it
really helps the channel out. So
1856:57 - proud of you for getting this
far. We're almost there, you're
1856:59 - getting now one more to go. And
then you are home free on
1857:02 - building your doubt. Let's get
back into it.
1857:06 - Alright, so now we're going to
make some scripts to actually
1857:08 - interact with propose Q and vote
on anything that happens in our
1857:13 - Dao. And these are the scripts,
these are kind of the things
1857:16 - that you would do on your front
end when you build this when you
1857:18 - build your doubt on the front
end. Or you could do an
1857:20 - integration with snapshot or
tally or something like that.
1857:23 - And again, if you want to see
come to full functionality on
1857:26 - the GitHub, I have this test
flow.ts It's not the greatest
1857:29 - test here. But you can also
check this out, because it also
1857:31 - does a soup to nuts
demonstration of going through
1857:35 - this exact process. So let's go
ahead and start making some
1857:37 - scripts. So we're gonna create a
new folder called scripts. And
1857:40 - this is where we're going to put
all of our scripts. Now the
1857:43 - process for this is going to be
we're first going to propose
1857:47 - something right? You know, maybe
we're going to propose that our
1857:50 - box contract stores the value
77, right? Because when it first
1857:55 - gets initialized, it's going to
start with zero. So maybe we'll
1857:57 - we'll propose it could start at
77. Once proposing is done, we
1858:02 - are voting on it. Right once
proposals it and we're going to
1858:04 - vote on whether or not we want
the proposal to go through right
1858:07 - yes or no. And then if it
passes, we go to queue and
1858:12 - execute, we queue first. And
then we execute, I'm just
1858:15 - putting them both in the same
script to make it easier. So
1858:18 - let's start with propose here,
because it's going to be the
1858:21 - first thing that we're going to
do. So let's create a new
1858:23 - function. We'll call it async
function, and then we'll
1858:27 - actually export it to export
async function propose. And
1858:30 - we're going to be in here for a
little bit. So let's clear
1858:32 - everything out. And okay, cool.
So this is where we're actually
1858:35 - going to propose on our governor
contract, right? So we're going
1858:38 - to propose a new governor
contract. So the first thing
1858:40 - we're gonna need, of course, is
gonna be the governor. So you
1858:42 - can't govern nor equals await
ethers dot get contract, govern
1858:49 - or contract, right? Since we're
doing ethers, we're gonna have
1858:52 - to do import ethers from heart
app. And then we're still
1858:57 - getting that fundamental thing.
We'll do a little AT Ts ignore
1859:01 - here. Cool. So we have the
governor contract here, we're
1859:03 - going to need the box contract,
we're gonna say hey, we want to
1859:06 - propose the box contract changes
the store value. So we'll do
1859:10 - const box equals await ethers
dot get this is a gift contract,
1859:16 - we want get contract, get
contracts at box. And those are
1859:19 - the two main ones that we're
going to need just to start.
1859:22 - Now, if we look at the proposed
function, right, if we go to
1859:26 - governance, we go to Governor,
and we look at that proposed.
1859:29 - This is what it looks like. Now,
I explained this proposed
1859:31 - function in my last video. So if
you haven't seen it, be sure to
1859:34 - go back and watch it right
because it'll give you
1859:37 - everything that you need to know
here are basically we pick a
1859:39 - list of targets, which our list
is just going to be just our box
1859:42 - contract. These are the targets
that we want to call functions
1859:45 - on, we do values like how much
needed ether we want to send,
1859:48 - which we're not going to send
anything, we have bytes, a array
1859:51 - called data. So this is going to
be our encoded parameters for
1859:55 - the function that we want to
call and then a description. So
1859:58 - that's exactly what we're going
to do here. So first, we need to
1860:01 - figure out what we're going to
do. So look at Box, we're going
1860:03 - to call this store function with
this new value here. So we need
1860:06 - to encode we need to encode this
socks here. And we also need to
1860:10 - encode what we want to upgrade
it to right so we have to code
1860:13 - all the function parameters. So
we'll do const encoded function
1860:17 - call equals box and the way we
can get this box that interface
1860:21 - that encode function data and
This is what actually turns it
1860:25 - to being this bytes call data,
right? So we're encoding
1860:29 - everything and this encoded
function, you can find this in
1860:32 - the ethers documentation, we
have to pass it the function to
1860:36 - call, and then the arguments we
want to pass, right, and this is
1860:38 - how we actually get that. So
let's get these arguments here.
1860:42 - So we're gonna say args, we're
going to make our proposed
1860:44 - function a little bit modular.
So we're gonna say args is going
1860:47 - to be an array of anything, and
then we're gonna say function to
1860:50 - call is just going to be a
string, right, and then right at
1860:53 - the bottom, we're actually gonna
call this, this proposed
1860:56 - function. So we're gonna say
propose, and let's say we want
1861:00 - to give it 77, the function is
going to be what it's going to
1861:02 - be store, store. And that's a
string. And this needs to be a
1861:06 - list. So we're going to do like
this. Now, we're actually going
1861:09 - to use this all over the place.
So since we're gonna be using
1861:12 - this all over the place, we want
to stick them in this part head
1861:16 - helper config. So what we're
going to do is we're gonna say,
1861:18 - export const, new store value
equals 77. And we're gonna do
1861:23 - export const funk equals store.
And I propose, we're just going
1861:29 - to import those. So we'll do
import, new store value, and
1861:33 - also funk from helper Hardhead
dot config, and it added it in
1861:38 - for us, which is great. So we'll
just put new store value in
1861:41 - here. And then we'll put funk in
here. And I know this might look
1861:44 - a little confusing, but
basically, the first thing we're
1861:46 - gonna do is we're gonna call
this proposed function which
1861:48 - calls you know, post function up
here. Now we're going to do some
1861:51 - fun little then process that
exit zero. And then we're going
1861:56 - to do a dot catch error, which
if there's an error, basically,
1862:00 - we'll just do console dot log
error, then process that makes
1862:05 - it. And this is pretty typical
setup for a really any script
1862:10 - you work with, and hardhat. So
great. So we have constant coded
1862:13 - function call, which has this
function to call an arc. So
1862:16 - we're basically combining these
into this bytes thing. And we
1862:19 - can even print this out, you can
see what this looks like. So you
1862:21 - do console dot log, you see that
this is like this, this crazy
1862:24 - bytes thing here. And the way we
can kind of test this, we'll do
1862:28 - yarn hardhat node, which will
spin up again, our fake
1862:33 - blockchain. But additionally,
with Hardhead deploy, it will
1862:35 - deploy all of our contracts
here, right, we can see timelog
1862:39 - governance, you know, everything
that we need for testing locally
1862:43 - has already been done. So once
we have that up, we can then do
1862:46 - yarn hardhat, run scripts,
propose that TS dash dash
1862:52 - network, local host, this is
important to do, again, because
1862:55 - when you're working with a node
that's running locally, you're
1862:57 - going to be working with local
host, we'll see what it prints
1862:59 - out here.
1863:01 - Contract named Governor
contracts, Governor contract.
1863:05 - Let's try that again. And cool,
you can see this is what that
1863:09 - encoded function call and
arguments looks like is this
1863:13 - really long byte string. But if
you were to decode this, using
1863:16 - the box interface, you would get
the function call and the
1863:19 - arguments, which is really
exciting. So cool, we've encoded
1863:22 - it to bytes. And now what we
want to do, we encourage the
1863:25 - bytes, and now we're going to
create that proposal
1863:27 - transaction. So we'll do console
dot log will say pro posing, and
1863:32 - say, function to call on box
that address with args. And then
1863:37 - we also need to pass a proposal
description. So we're gonna say
1863:41 - pro pose, all description, we
would do it on new line, why
1863:46 - not? Pro pulls all this option,
which we don't have yet.
1863:50 - Alright, we're gonna get it. So
we also need to pass a proposal
1863:52 - description, right, because we
have down here, description. So
1863:56 - let's add another parameter to
our propose here. So we'll say
1863:59 - proposal description, and this
will be also a string. Down at
1864:04 - the bottom, we're going to need
a proposal description as well.
1864:07 - So we'll create a proposal or
export const proposal
1864:11 - description, there's just going
to be some string. So we'll say
1864:13 - proposal number one, door 77 In
the box, that's the description
1864:19 - here, comma proposal
description. And then we import
1864:22 - this or a helper config. Okay,
perfect. So now we have the new
1864:25 - store value, the function the
proposal description, and we can
1864:29 - now call that propose that we
were just looking at so here's
1864:32 - what we're going to do const
propose TX equals await. gov dot
1864:38 - propose. And we need to pass
those lists. So first is going
1864:42 - to be a list of targets, which
for us is just a box that
1864:44 - address right only one target.
And again, these these little
1864:47 - brackets, make it a list of
values, which is just going to
1864:49 - be zero, a list of encoded
function calls or our bytes
1864:54 - data, basically, and then the
proposal description, and then
1864:58 - we're going to do propose, TX
dot wait one. Now, if you
1865:02 - remember, from compound, this is
going to be the exact same if we
1865:06 - go back to compound back to
governance, this transaction is
1865:10 - literally going to be the same
as this created thing here.
1865:14 - Right? And if we scroll down,
like more, we can see the code
1865:17 - input data, those exact same
things on a compound proposal,
1865:20 - right? We have targets values
signatures, well okay, this CES
1865:24 - is a little bit more, this a
little bit more advanced here,
1865:27 - using signatures, but it's got
the same thing called data and
1865:29 - then a description here, okay.
Now since we have a voting
1865:33 - delay, people actually can't
vote until the voting delay
1865:36 - passes. Now, with a local
blockchain, nobody's actually
1865:39 - processing blocks and time
doesn't really pass as quick as
1865:43 - we want. And so we're just going
to speed things up for our own
1865:46 - testing purposes. So the way I
normally do this is I create
1865:49 - this this variable, all
development, exports, on
1865:53 - development chains, and I'll add
hard hat and local host. Because
1865:59 - we can actually do things with
our own local blockchain, we can
1866:01 - actually speed up time, we can
speed up blocks, we can do all
1866:04 - this crazy stuff. So usually,
I'll actually import this in
1866:07 - here. And then we'll do a quick
F. And I'll say, if we're on a
1866:10 - development chain, let's just go
ahead and speed things up for
1866:12 - us. Right. So I'll say if
development chains that includes
1866:18 - network dot name, and then we
can import network from from
1866:22 - ethers, as well. And this is
what I was talking about those
1866:24 - super six skills that you're
gonna learn. If it includes
1866:26 - network dot name, then we're
gonna go ahead and move the
1866:29 - blocks forward, right, because
if we're not on development
1866:31 - chain, we can't actually move
blocks. So what we'll do here is
1866:34 - actually I'll create a new
folder called utilities, you
1866:37 - folder, you are utils. And in
here, I'll create a script
1866:41 - called Move blocks.ts. And we're
just going to create this little
1866:46 - function called move blocks,
which moves blocks for us. And
1866:49 - you'll see how we do this. So
we're going to import network
1866:51 - from heart app, because we want
to speed up that voting delay,
1866:54 - we'll do export async function,
we'll call it move blocks. And
1866:58 - it'll take an amount, which will
be a number, so how many blocks
1867:01 - that we actually want to move.
And then we'll just do console
1867:04 - dot log moving blocks. And we'll
say for let index equals zero,
1867:10 - index is less than amount. index
plus plus, or we're going to do
1867:15 - is we're going to do a weight
network DAP provider dot request
1867:19 - request. And we're going to
request method EVM. Mine. So
1867:25 - basically, we're mining for our
local blockchain, right, so you
1867:30 - can find these docks in the hard
hat docks in the ethers docks,
1867:34 - there's a couple different
places you can find these. But
1867:36 - this is kind of this really cool
hack that we can use to actually
1867:40 - move blocks forward on our local
chain. Now, obviously, this
1867:42 - won't work on an actual chain,
because you'd actually have to
1867:45 - do the mining but on our local
chains, we can absolutely do
1867:47 - this. So we've exported this
move blocks function, and we're
1867:51 - actually gonna grab that Mark
propose, we're going to import
1867:55 - move box from utils blocks. And
we're going to say down here, if
1868:01 - we're on this development chain,
and do a weight move blocks, and
1868:04 - then we'll move blocks by that
voting delay that we were
1868:07 - talking about, right? Because we
need to wait that voting delay
1868:09 - in order to move and it looks
like an auto import it for us
1868:12 - from our helper hardware config.
I told you, we were gonna use
1868:14 - that a couple of times, but
we're gonna move blocks by that
1868:16 - voting delay. Now, this proposed
transaction does some stuff that
1868:19 - we actually want, right? So one
of the big things that it wants
1868:22 - is, is it has this proposal ID.
And if we scroll down to the
1868:25 - event that it emits, it ends up
emitting this proposal ID, we
1868:29 - actually need the proposal ID
for later on when we actually go
1868:33 - to vote. So what we're going to
do is we're actually going to do
1868:35 - const propose receipt equals
proposed text dot weight. And
1868:41 - we're going to get those events
from this proposed receipt. So
1868:44 - we're gonna say const. Proposal,
id equals proposed receipt, that
1868:49 - events, the zero with event
because that first event is the
1868:52 - only one we care about that are
your stop proposal ID. This is
1868:56 - how we get this proposal ID from
this omit also created event. A
1869:00 - couple other ways to get
proposals to get events in
1869:03 - hardhat. And I got a video on it
on my YouTube, if you want to go
1869:05 - check that out. Something else
that we want to do is maybe we
1869:08 - want to see what the deadline is
with a snapshot, you can go
1869:11 - ahead and check my GitHub to
kind of see what the snapshot
1869:13 - looks like or the deadline,
basically, how long we have to
1869:16 - vote, you know what snapshot
you're working with, and all
1869:18 - these different things. But for
now, we're just gonna stick with
1869:20 - the proposal Id be sure to check
out the GitHub for more stuff.
1869:22 - Now we want to save this
proposal ID, we want to save it
1869:25 - somewhere so that our other
scripts so that our vote and our
1869:27 - queue and execute know what this
proposal ID is going to be when
1869:31 - we run those. So what we're
going to do is we're going to
1869:33 - create this file called
proposals dot JSON. And it's
1869:36 - going to store all of our
proposals. So we're gonna say
1869:38 - pro poll, souls dot JSON, it's
going to have all of our
1869:42 - proposals in here. So what we're
going to do and we're going to
1869:45 - add this to our helper Hardhead
config, and do export const,
1869:48 - proposals, file equals proposals
dot JSON. And we're going to
1869:52 - import this at the top as well
as proposals file. And then once
1869:56 - we get this proposal ID, we're
going to do is we're going to
1869:59 - read all the current proposals.
So we're gonna say let proposals
1870:02 - equals JSON dot parse, and we're
gonna do Fs dot read file sync
1870:08 - from this probe proposals file,
and we're going to pass it to
1870:13 - UTF eight. Now, this Fs we don't
have yet, so we're going to need
1870:18 - to import Fs. So we're going to
do yarn add Fs like that. If
1870:23 - we're looking at package dot
JSON. Oops, I should have saved
1870:26 - that as Dev, but I didn't Oh,
well, doesn't really matter. Now
1870:31 - that we have that we can
actually import this into our
1870:33 - TypeScript. So we're just going
to say, import star as Fs from
1870:38 - Fs. And now we can actually use
Fs F as a way to kind of read
1870:42 - from files. Now we can get this
list of proposals. So we got two
1870:45 - proposals that JSON right now
we're just making a blank JSON.
1870:48 - So the first time we run it,
it'll just be blank. But later
1870:51 - on, it'll have stuff in it. And
the way that we're going to save
1870:54 - these proposals is we're going
to say pro proposals of network
1870:58 - dot config dot chain ID, and
this little bank to say, yes,
1871:02 - there will be a chain id.to
string, we're going to store
1871:06 - them by their chain IDs, right.
So for each network that we have
1871:09 - a proposal to we'll we'll start
like that. And then we'll do dot
1871:12 - push proposal, id.to string, and
then we'll write it back. We'll
1871:17 - do Fs dot right, file sync,
proposals file. JSON does string
1871:23 - phi, proposals, and awesome. And
that's all we need to do. So
1871:28 - let's go ahead and actually run
this. And then I have some
1871:30 - console dot logs in here saying,
Hey, here's what the proposal
1871:32 - state is, is it open? Is it
voting is it canceled, you know,
1871:35 - etc. What the proposal snapshot
is, you know, again, check my
1871:38 - GitHub for that. But what we can
do, now this is done, we can do
1871:42 - yarn, Hardhead node, spin up our
little note here. And all the
1871:46 - contracts are deployed. And then
we'll do yarn, run scripts,
1871:50 - proposed that TS dash dash
network, local host scripts
1871:54 - proposed that TS is not found.
Pro pose, yarn, hard hat, run
1872:01 - scripts, pose IDs, oops, dash
dash network, local hosts. Try
1872:06 - this again. Now you found it.
Yay. Oh, I ran into an issue.
1872:10 - Although description Moviebox
Cannot read property zero of
1872:12 - undefined. Let's see where it
got mad at me. Poser sheet dot
1872:16 - event. It is events, not event
shots again, on the localhost.
1872:20 - There we go running ran into
another issue. Posle already
1872:23 - exists. Okay, so great. So the
proposal already exists, let's
1872:27 - go ahead and just like kill the
node, restart the node, so you
1872:30 - can't have two proposals that
are exactly the same, basically,
1872:33 - right. So we can't do that, we
would need to change the
1872:35 - description or something. So
we're just going to kill the
1872:37 - node and restart. Now we're
going to run this proposal
1872:39 - again. And hopefully this one
should work this time. Community
1872:44 - Property zero of undefined owes
receipt. This needs to be await
1872:49 - because it is a promise, kill
this one more time we run it
1872:53 - once all these get deployed. And
we're gonna go ahead and run
1872:56 - this. Now you can see how much
quicker this is than if you were
1872:58 - to actually send this to a test
net right to an event a lot of
1873:00 - waiting, which is no bueno. And
we run into one more Cannot read
1873:06 - property, push them undefined.
That makes a lot of sense, too.
1873:09 - Because proposals dot JSON as
nothing for chain IDs. So
1873:13 - 231337. And we'll put a little
list in here. Right now it's an
1873:18 - empty list. Now we're going to
kill this one more time, kill
1873:21 - it.
1873:23 - And then once this goes, then
we're gonna go ahead and do
1873:25 - this. Perfect. Now we're going
to run this and now it should
1873:29 - save and everything should be
peachy hunky dory. Awesome.
1873:34 - proposal number one store in the
box, we move the blocks. And if
1873:38 - we look at proposal dot JSON, we
now see there's a list of
1873:41 - proposals. And this is the
proposal ID of that one we just
1873:44 - created. Oh, okay, we made a
proposal. Awesome. Nice work,
1873:47 - we'll leave that Node running.
And hopefully we'll just do
1873:50 - things right for the voting. So
let's create this vote script
1873:54 - now. Okay, so now we proposed
it's time to vote, let's do a
1873:58 - little voting. So this is going
to look pretty similar to that
1874:00 - script, we just we just created
right. So we're in New async
1874:03 - function, we'll call this main
proposal index number, and we're
1874:08 - calling this main because we're
going to have the vote function
1874:11 - be a little bit different.
You'll see why. And at the
1874:13 - bottom, of course, we're going
to do main index dot then
1874:17 - process dot exit zero, catch
error arrow function, console
1874:24 - dot error, error, and then
process that exit. One main
1874:30 - index, we're gonna say our index
zero cost index zero. We'll do
1874:34 - like this cost index is your
postal index. So we're gonna get
1874:36 - we're gonna get that bit zero
with index, right, the first
1874:39 - index in our proposals dot JSON.
So whatever is the first one in
1874:42 - this list is what we're gonna
use, right? And that's what we
1874:44 - want right now. There's only one
so it's easy. So we're gonna get
1874:46 - that first one in here. So first
thing we're gonna need to do is
1874:49 - we're gonna need to grab the
list of proposals. So we're
1874:52 - gonna do const proposals equals
JSON dot parse, FS dot read,
1874:57 - file sync proposals file, UTF,
eight. So of course, we're going
1875:02 - to need to import a bunch of
stuff. We're going to import
1875:05 - proposals file from that a slash
a Bernhard config. And then
1875:10 - we're going to do import star as
Fs from us. Great. We have Fs,
1875:16 - we can read stuff, and we can
get those boats. Okay, cool. So
1875:19 - we have a list of proposal IDs.
Now let's get our proposal idea
1875:22 - we'll do const probo. also ID
equals proposals of network dot
1875:28 - config. And then that's not what
we want. We want to actually
1875:32 - import network, import network
from hard hat, network dot
1875:37 - config, that chain ID,
exclamation mark of proposal
1875:43 - index, which for us is going to
be zero, right? We're getting
1875:45 - that first proposal in the list
of proposals. Now we're gonna
1875:48 - choose how we want to vote. So
zero equals against one equals
1875:52 - four, and then two is abstain. I
don't know why you'd ever
1875:55 - abstain abstaining costs gas,
you could just not vote, but
1875:58 - we're gonna say const vote way
and the way we're gonna vote
1876:01 - equals one. And we can also do a
reason. So if we go back to our
1876:05 - governor, there's a couple
different functions we get to do
1876:07 - to vote, there's cast vote,
where we just cast a vote, cast,
1876:10 - vote with reason, and cast vote
with signature where we actually
1876:14 - do a signature. And I asked this
question, Hey, what is cast vote
1876:17 - by sick do on the opens up on
forum, I was like, hey, what's
1876:19 - the what is the purpose of this?
My hunch was that anyone could
1876:22 - then execute this vote on behalf
of me if I didn't send the
1876:25 - transaction. And that's exactly
what it is. This method
1876:27 - implements a meta transaction
and allows a project to
1876:30 - subsidize voting fees, the
voters can generate a signature
1876:32 - for free, and the project can
submit those and pay for the
1876:35 - gas. So this is incredibly
powerful. And this is the
1876:38 - function that allows this, this,
this cast vote by signature is
1876:43 - what allows that snapshot chain
link integration that you know,
1876:46 - hopefully one of you build, but
for us for this, since we're not
1876:49 - implementing these meta
transactions, these off chain
1876:52 - stuff, we're just going to do
cast a vote with reason why
1876:54 - because we want to give it a
reason. That's really it. So
1876:57 - we're gonna say const boat TX
response equals await. Gov nor
1877:03 - dot cast, excuse me, we need to
get the government contract. So
1877:06 - we'll do const. Gov nor equals
await ethers dot get contract.
1877:11 - Gov contract. And then if we
don't have ethers, we should get
1877:14 - ethers. Great. Let's get ethers.
And we'll ignore that. But now
1877:18 - we have the contract. So we'll
do a weight gov dot cast vote
1877:21 - with reason spell this right?
With reason. And we'll say
1877:25 - proposal ID that way. And then
the reason which we don't have a
1877:29 - reason here, so let's make a
reason. Let's say the reason is
1877:33 - reason, equals I like do cha
cha, if you know that film, you
1877:39 - should definitely comment it in
the description. We have a
1877:41 - reason so we're voting for we're
saying yes, we want we do indeed
1877:45 - want you to change the box to
77. And the reason is because I
1877:49 - like a do the Cha Cha makes
perfect sense if you don't think
1877:52 - about and then we'll do a wait,
Kotex response that wait. So I
1877:56 - do some stuff, again, checking
the state of the proposal where
1877:59 - different numbers mean, hey,
it's in process, it's voting,
1878:02 - etc, we could check on that. But
we're gonna skip that for now.
1878:04 - All we're going to do now, now
that we voted, we're going to be
1878:07 - the ones to vote. So we're just
going to once again move the
1878:09 - blocks along. Why because we
want to just get to the end of
1878:13 - that voting period. So we're
gonna do again, if velopment
1878:16 - chains, that includes network
dot name, then we're gonna do a
1878:20 - weight move blocks, voting
period, plus one. So we need to
1878:25 - import a whole bunch of stuff in
here. poses file development,
1878:28 - looks like those got auto
imported, we need to import this
1878:31 - move blocks. So import move
blocks from utils blocks, and
1878:37 - that network is in here. And
then we need voting period from
1878:40 - our helper config. voting
period. Okay, cool. And then
1878:43 - we'll do console dot log, voted,
ready to go. Now the reason that
1878:49 - I checked the proposal state is
because there's this state
1878:52 - function in the governor
contract. So if we look up
1878:55 - state, what this does is it
tells us what the state of the
1878:59 - proposals in right if it's been
executed, return that's been
1879:02 - executed, if it's been canceled,
return has been canceled. You
1879:05 - have the deadline, check to see
if it's active, check to see if
1879:08 - quorum reached all this stuff,
right? And what you're usually
1879:10 - looking for is worm reached and
vote succeeded, right? If both
1879:14 - of these happen, the proposal
state DOT succeeded, right?
1879:17 - Otherwise, it's defeated or it's
not there yet. I believe this is
1879:20 - a one and this is a zero. So if
you were to call that function
1879:23 - and get the state right, now we
should get a zero. Or excuse me,
1879:27 - we should get a one for this
having passed. If you want to do
1879:29 - that as a little extra credit,
feel free to do so. So let's see
1879:32 - if we did this right. Well,
actually, I guess we got to
1879:34 - change this just to vote. But I
just wrapped everything up into
1879:37 - main. So let's see if this
works. Yarn, hard hat run
1879:40 - scripts vote network, local
host. So we should get a little
1879:44 - console dot log at the bottom
that says voted ready to go. So
1879:48 - now we're voting. We didn't just
go to the Arctic Council, we
1879:51 - could do yarn, hard hat console,
dash dash network, local host.
1879:56 - And in here, you can actually
just check the state right in
1879:58 - here. Why not? We'll copy this
line as governor because we
1880:02 - either get contract Governor
contract. Now we can do a wait,
1880:06 - Governor, that's state of go to
the proposals dot JSON, grab
1880:12 - this, paste it in here. And we
get a for the state of this
1880:16 - right now is for I forget what
four means. It's like a proposal
1880:19 - state. The proposal state is
actually in the eye governor so
1880:22 - the interface of the governor We
can see, zero is pending, one is
1880:27 - active, two cancelled, three
defeated, and four have
1880:30 - succeeded. So we are in a
succeeded state, which is really
1880:34 - good. That's exactly what we
want. So let's go ahead and quit
1880:36 - now. Excuse me Ctrl. C, our
proposal is now in a succeeded
1880:41 - state. And we've actually moved
the blocks along the voting
1880:44 - period. So voting is now over
because we cheated. So now let's
1880:47 - go ahead and queue and execute
this to the last bit here. So
1880:52 - this is gonna look real similar
to what we've done already.
1880:53 - Right? Let's minimize this,
export async, function, Q, and
1880:59 - execute. And then at the bottom,
we'll just call queue, and
1881:04 - execute. And I'm just going to
copy paste, but it's that same
1881:07 - syntax here, then process exec
catch, blah, blah, blah, you get
1881:10 - the drill. So in order to queue
and execute, go back to the
1881:14 - governor contract, not the
governor, let's go to the
1881:16 - governor. First thing we're
going to do is call this queue.
1881:19 - Now this Q function is actually
in the governor time lock, which
1881:24 - is in this extensions here. So
we can find the governor Time
1881:27 - Lock controller here, and it
does exactly the same as propose
1881:31 - we take everything that we did
in the proposal, and then we
1881:34 - just queue it like so. So we
pass the exact same values here.
1881:37 - And that's so cute. So what
we're going to do is we're gonna
1881:40 - need to first get those exact
same values, which I told you
1881:42 - we're going to use a few times.
So we're going to import bunk,
1881:45 - new store value, proposal
description of our article
1881:51 - thing, right now that we have
all that stuff, we'll say const
1881:53 - args equals a new store value,
1881:56 - we'll do const box equals await
ethers dot get contract, let's
1882:03 - get that box contract again,
we're gonna have to import
1882:06 - ethers from our hat. And this is
going to be from we're gonna do
1882:11 - TS ignore, then we're once again
code this function call to const
1882:16 - encoded function call equals
Boxtop interface, encode
1882:21 - function data. Once again, we're
gonna do funk is the function we
1882:25 - want to call and args this is
like real similar to the our
1882:28 - proposed bit that we did. And
then we're gonna do content
1882:31 - description hash equals ethers
dot utils that get GAC 256
1882:38 - ethers dot utils, that to you,
TF eight bytes, this will make
1882:43 - sense in a second. We're also
description. So what's our
1882:47 - propose, all we did was pass our
proposal description, however,
1882:51 - it actually gets hashed on
chain, and that's what our view
1882:54 - and execute is gonna be looking
for, it's gonna be looking for
1882:56 - the description hash, instead of
just the pure description,
1882:59 - right, and it's gonna be a
little bit cheaper gas wise,
1883:01 - which is good. So now that we
have the description hash, now
1883:04 - that we have all the same
functions that we did for the
1883:06 - suppose it's time to queue them.
So do cost gov equals await
1883:11 - ethers dot get contract. Gov
contract, console dot log will
1883:16 - say we're queuing and then we'll
do cos Q, dx equals gov dot q.
1883:23 - And we're going to pass the
exact same parameters we did
1883:26 - with the pose except for what
the hash instead of the actual
1883:28 - proposal, so box that address
zero for eath, and pass that
1883:33 - code at function call. And then
the description hash rate. And
1883:38 - then we're going to do oops, is
going to be a weight here. And
1883:42 - then we're gonna do a wait. You
text Oh, wait, one, wait a block
1883:46 - there. And great, then we're all
queued up. Now we still have to
1883:50 - wait that minimum delay, right?
Remember, on our timeline, it's
1883:53 - got this min delay thing. It
says, Hey, once something gets
1883:56 - queued up, you can't just
execute it right away. You gotta
1883:59 - give people time to get out. So
we're going to speed up time
1884:02 - again, we're going to say if
development chains develop l
1884:06 - meant chains that includes and
then it looks like it auto
1884:09 - imported for me development
chains. Yes, it did. Amazing.
1884:13 - That includes network dot name.
Let's just make sure we import
1884:16 - network from Hardhead. That
includes our name, then, of
1884:20 - course, we're going to move
blocks. But we also actually
1884:23 - have to move time here as the
minimum delay is looking for
1884:26 - some time. So let's create a new
util called Move time. Okay,
1884:31 - move time that Yes. And this
util is going to allow us to
1884:36 - move time so you're learning all
the cool stuff. So we'll quickly
1884:38 - write a script to do this
important network from hard hat
1884:41 - export async function move time,
how much time will be a number
1884:47 - of Mount console dot log, moving
time, and let's say await
1884:52 - network dot provider dot send
EVM increase time and then just
1884:59 - by the amount, then we'll just
say console dot log, move
1885:03 - forward, amount seconds, it goes
forward and seconds. Cool. So
1885:07 - now we have this move time
function. That was pretty quick,
1885:10 - right? So first, we're going to
move time and we're gonna move
1885:12 - time by that min delay first,
plus one just to be safe. And
1885:16 - then we're also going to move
blocks. We're gonna do a weight
1885:18 - move time, and then a weight
move blocks. And we'll just move
1885:22 - on block. So got it Import move
blocks from utils. It imports
1885:27 - move time from those utils as
well, time. And then we also
1885:32 - have to import this min delay,
which we get from our helper.
1885:35 - Hardhead config. Great. So we
moved all that stuff. Again, if
1885:38 - this were a real chain, you just
have to wait. But since we're
1885:41 - not a real chain, we can do
whatever we want. Yes, love
1885:43 - doing whatever I want. Now that
it's all cued up, the voters
1885:46 - passed, we're looking spicy.
Let's drive this home. Xe cuting
1885:52 - do a little console dot log
executing the const execute TX
1885:57 - equals await. gov dot execute.
We're going to pass this the
1886:01 - exact same set of things we did
for the Q TX so I'm literally
1886:05 - gonna copy this. paste it down
here. And then we're just going
1886:08 - to do a weight SQ TX dot weight.
We're going to wait one block.
1886:13 - And then the final hour we'll
see if the governance updated
1886:18 - our box contract const box new
value equals await box dot
1886:23 - retrieve. And that will do
console dot log. New box value.
1886:30 - Box new value.to string Oh, so
if we did this right, it's new
1886:35 - box value to be updated. Let's
see if we did it right yarn hard
1886:39 - hat run grips Q and execute now
work localhost. Did we do it
1886:45 - right? Are we successfully done
governance? We did. That's okay.
1886:50 - We're gonna figure out what we
did wrong. Did you mean could
1886:52 - check 256 I spelt some stuff
wrong. It needs to be spelt like
1886:57 - no CK. Just just k. Okay, let's
try again. It failed before it
1887:01 - actually did. I think that's
good. Queuing moving time
1887:04 - provider EVM and crit cuz I
spelt increased time wrong. Oh,
1887:08 - no EVM increase time to just
double check. Make sure I'm
1887:15 - spelling this right T is
actually capital. So I totally
1887:18 - messed up. So it's actually
already been queued. It's been
1887:21 - queued right now on our little
node EVM increased team. So we
1887:25 - can either delete and kind of
restart, or I can just go ahead
1887:28 - and I'm just going to comment
out a bunch of stuff, we're just
1887:31 - going to skip the cueing here.
We're gonna run this one more
1887:34 - time, because it's already been
queued. And now should just
1887:37 - execute, we're gonna move time
again. But that's fine. Oh, my
1887:40 - goodness, we did it. Right. And
then normally, you would just do
1887:43 - it in one script. But this queue
would fail because it was
1887:46 - already queued. Right, you can't
queue twice, move forward. In
1887:49 - time, we move blocks we executed
and we got a new box value
1887:54 - completely using our Dow
completely decentralized voting
1887:58 - completely on chain, no third
party trust going in on here.
1888:03 - There's no voting booth, there's
no you know, spending 1000s of
1888:06 - dollars on staff, everything we
just voted on happened right in
1888:10 - front of our faces. Now, again,
I highly recommend go to my
1888:13 - GitHub repo, you take a look and
you see what's going on here.
1888:16 - Again, if you want to see
JavaScript stuff, feel free to
1888:18 - do some JavaScript stuff. But
this goes over how to just get
1888:21 - clone and get started if you
want to do that as well. But if
1888:24 - you walked with me here, if you
walked through this with me, you
1888:28 - have learned in the absolute
Khan, thank you so much for
1888:31 - being here. And I'll see you
next time.
1888:35 - All right. Now, welcome to the
final section of our course, the
1888:40 - security and auditing section,
this one is going to be a little
1888:44 - bit less coding and a little bit
more explaining. And most of
1888:47 - what we're going to be learning
about here is in this Hardhead
1888:49 - security FCC section. Throughout
this course, we've given you a
1888:53 - couple of tips about different
security features. One, we
1888:57 - talked about reentrancy, we
talked a little bit about Oracle
1889:00 - Tax, and we're going to talk
about those more. And some of
1889:03 - the tools we can use to make our
code more efficient, to look out
1889:07 - for bugs, and to make our code
more secure. So we're gonna go
1889:11 - ahead, we're gonna go over this
hard hat security FCC code base,
1889:15 - and we're going to walk through
it a little bit. So one of the
1889:18 - first things that we're going to
talk about is, what is an audit?
1889:22 - Well, an audit is going to be a
security focused code review,
1889:25 - looking for issues with your
code. So for example, let's say
1889:29 - we have some code that looks
like this, this should be a
1889:31 - little bit familiar, because we
talked about this in one of our
1889:34 - earlier sections with
reentrancy, our code, withdraw,
1889:38 - goes and sends ether and then
updates the balances, this code
1889:42 - is clearly vulnerable to a
reentrancy attack here. And this
1889:45 - is something that an auditor
would catch. Since when we
1889:48 - deploy our code, that code is
immutable. And that code will
1889:50 - always be there, it's really
important to have these security
1889:54 - reviews done before we deploy
our code to a main net, and
1889:57 - before we go live, so if you're
going to deploy some crazy,
1890:00 - massive defy protocol, and
you're gonna have billions of
1890:02 - dollars of people's money locked
into your protocol, you probably
1890:05 - want to make sure that the money
is going to go to the correct
1890:07 - places. So audits are incredibly
important for the lifecycle of
1890:12 - our projects. And we want people
to peer review, we want people
1890:15 - to review our code to make sure
that everything looks good. Now,
1890:19 - when we send our code to audit,
though, we shouldn't just say
1890:22 - hey, here's our code. Can you
check them Make sure it's good.
1890:25 - That's not going to give an
auditor enough information, they
1890:27 - need to be able to very easily
know what your code does, how to
1890:30 - work with it, and what you're
looking for. Because auditors
1890:34 - aren't going to be kind of this,
this failsafe, where if your
1890:36 - code is terrible, they're going
to catch everything. Auditors
1890:39 - are human beings too. They can
miss things as well, auditors.
1890:42 - Also, don't make sure that your
code is bug free. Like I said,
1890:45 - audits are security focused peer
reviews for your codebase. And
1890:49 - when you do send your code to
audit, you want to make sure you
1890:52 - help out your auditors as much
as possible. There's an amazing
1890:56 - tweet thread from Tinto and
previously was an open Zeplin
1890:59 - auditor with a ton of tips and
tricks for working with
1891:02 - auditors, I highly recommend you
pause the video, you click this
1891:06 - link and you read through his
tweets because they are
1891:08 - fantastic. openzeppelin has a
readiness guide to try to help
1891:12 - you make sure that you're even
ready for an audit in the first
1891:16 - place. And we've got a link to
this readiness guide in the
1891:18 - GitHub repository. The summary
of them are to add comments to
1891:22 - your code, use natspec, which we
learned about to document your
1891:26 - functions, document your
functions, document your
1891:29 - functions, test, be ready to
talk to your auditors, and be
1891:33 - prepared to give them plenty of
time. They are literally pouring
1891:36 - themselves over your code for
weeks on end to make sure
1891:39 - there's nothing wrong. If you
rush your auditors, you're gonna
1891:42 - get a rushed audit, and they're
going to miss things. So let's
1891:45 - talk about the auditing process.
In auditing process is going to
1891:48 - look like this. First, they're
going to run your tests. That's
1891:51 - the first step in order is
always going to take and right
1891:54 - there, they're gonna find okay,
do they have enough code
1891:56 - coverage? Is everything passing?
What do the tests do? What is
1892:00 - the optimal functionality, after
an auditor runs tests, they're
1892:04 - going to read specs or run your
docs. And then they're going to
1892:07 - run some fast tools like
Slither, linters and static
1892:11 - analysis. And that's going to be
one of the first things we're
1892:13 - going to talk about slither and
static analysis. So static
1892:17 - analysis is the process of just
running some program to read
1892:22 - over all your code and look for
commonly known bugs. One of the
1892:25 - most popular static analysis
tools is going to be this tool
1892:28 - called Slither. And that's going
to be one of the first things
1892:31 - we're going to do here. So let's
go ahead and open up our VS code
1892:34 - now. And we'll make a new
directory called hardhats
1892:37 - security, FCC. We'll cd into it.
We'll do code period. And we'll
1892:45 - open this up. Now what I want
you to do, instead of starting a
1892:49 - new folder, and everything is
we're going to get clone, my
1892:51 - heart had security FCC. So we'll
do git clone, our net security
1892:56 - FCC space, and then put a period
to clone it into this directory.
1893:00 - And we'll get everything like
this. Now in here, this comes
1893:04 - with a couple of different
contracts for us already, that
1893:07 - each have a different
vulnerability, one of them is
1893:10 - going to be bad RNG. This is a
contract that picks a random
1893:14 - winner of a raffle using block
difficulty and message dot
1893:18 - sender. This isn't truly random,
as the miners can influence the
1893:22 - block dot difficulty, and people
can cancel transactions. And
1893:25 - there's a ton of ton of
different vulnerabilities with
1893:28 - creating randomness in this way.
We also have this liquid pool as
1893:32 - an Oracle, the two most common
types of attacks are reentrancy,
1893:35 - which we've learned about an
Oracle manipulation attacks,
1893:39 - which luckily for you, we've
taught you about decentralized
1893:42 - Oracle's and working with chain
link, which should make you a
1893:44 - lot safer. And especially for
this section, I'm going to harp
1893:48 - on these, please, please,
please, if you taking this
1893:51 - course, please do not make a
protocol that falls victim to
1893:55 - one of these, I will feel like I
have failed you. If you build a
1893:57 - protocol where you use some
centralized oracle that gets
1894:00 - manipulated, or you build a
protocol that has a reentrancy
1894:03 - attack. The tools that I'm going
to show you right here are going
1894:06 - to help you with reentrancy. And
everything I've taught you about
1894:09 - chain link should hopefully
teach you how to not get Oracle
1894:12 - manipulated. So in this contract
here, we're using a liquidity
1894:16 - pool as an Oracle and this is
kind of some advanced defy stuff
1894:19 - here. This is a minimalistic
decentralized exchange example
1894:23 - where people can buy and sell
and swap different assets. Now
1894:27 - using this singular exchange, to
get the swap price is a terrible
1894:32 - idea. Because this is a single
protocol for a single price. The
1894:36 - price from this protocol is a
single centralized location, and
1894:39 - we don't want to get our price
from a single centralized
1894:42 - exchange. We want to get it from
many exchanges. Getting the
1894:45 - price of any asset from a single
decentralized exchange is not
1894:50 - decentralized, is somebody
manipulates the market doing
1894:53 - some crazy advanced defy things
that will ruin the price of your
1894:57 - assets. So getting the price of
your assets from a centralized
1895:01 - location is a terrible idea. We
have a metamorphic proxy here.
1895:05 - The issue here is that it's
initialized double, and we don't
1895:08 - guarantee that the contract has
been initialized. We have a
1895:11 - classic reentrancy issue here.
And then we have and then we
1895:15 - have a vault here where some
password is stored on chain and
1895:19 - we're crossing our fingers that
nobody reads this password to
1895:22 - unlock it. So we're going to run
some static analysis on these
1895:25 - contracts, see if that static
analysis can spot some of the
1895:29 - bad things in here.
1895:32 - To get started, we're going to
use a tool like I said called
1895:35 - slither slither tool was created
by this Crytek team, aka the
1895:40 - trilobites team. Now, trilobites
is one of my absolute favorite
1895:44 - auditors in the space. And I
absolutely love all the tools
1895:47 - that this team puts out, they
put up open source security
1895:49 - tools for any of us to use such
as slitter. Now to get started
1895:53 - with Slither, we actually need
to install Python first. So you
1895:57 - can also run it with Docker. But
I'm going to show you how to how
1896:01 - to work with Python first. So if
you haven't worked with Python,
1896:04 - before, you can come to
python.org/downloads and
1896:07 - download Python right from the
website, you'll know you've done
1896:09 - it right. And you can run python
three dash dash version, like
1896:13 - this. Or if you have an older
version of Python, you can run
1896:16 - Python dash dash version. Once
you install Python, you should
1896:19 - also have this tool called PIP
three installed and you can
1896:22 - check by running PIP three dash
dash version, or PIP dash dash
1896:27 - version. And we also want to
install this sock select package
1896:32 - just in case we're using weird
versions of solidity to install.
1896:35 - So select, we run PIP three,
install sock select, like that.
1896:40 - And then we can do sock, select,
use. And then we can choose the
1896:45 - version of solidity or slither
to work with. Once you have
1896:49 - those tools, you can just run
PIP three install slither
1896:52 - analyzer like so. And you can
install slither into your Python
1896:56 - environment. I'm not going to
run it because already have. You
1896:59 - can also learn how to do this
all with Docker and we'll learn
1897:01 - how to do this with Docker in a
little bit. Now in our package
1897:04 - json, we actually have command
script in our package. JSON for
1897:08 - running Slither, you'll know
you've installed slither
1897:11 - correctly. If you can run
Slither, dash dash help you get
1897:18 - an output like this. Now we can
use slither to run it on our
1897:21 - contracts folder by running this
big command here. So we'll say
1897:25 - Slither. And we want to run it
on dot slash contracts, we need
1897:29 - to tell it that it has some
psaltery mappings, and every
1897:32 - time it sees open Zeppelin, it
should use Node module slash
1897:36 - open Zeppelin and every time it
sees chain link introduced node
1897:39 - modules slash chain link. And
I'm just going to read from our
1897:42 - package json. And we're
excluding a couple of functions
1897:46 - that it runs and excluding
builder ignore, but don't worry
1897:49 - too much about that. We've
actually just run that by first
1897:51 - running yarn to install all of
our packages.
1898:03 - And after we've installed all of
our packages, we can run yarn
1898:06 - Slither. Or you can copy paste
that slither command and run it
1898:09 - directly. Now we'll get this
massive output that looks like
1898:14 - this with some red and some
green. Let's go through what's
1898:17 - actually happening here, the way
that we can read Slither, it'll
1898:20 - list out a number of lines that
have an issue and then a
1898:23 - reference to that issue. And
each one of these is separated
1898:26 - by a new line. So that's a
section that's exception, etc.
1898:31 - So if we get a red here, that
means that there is a high
1898:34 - impact issue that we definitely
should address. And it even
1898:38 - comes with a reference link that
we can copy paste and put into
1898:42 - our browser and see what the
issue is and more information
1898:45 - from the slither tool about what
that issue is and how to correct
1898:49 - it. We can see it catches our
metamorphic contract issue. It
1898:54 - says metamorphic contract is
never initialized. It is used
1898:57 - here in metamorphic dot kill.
The reason that this is a
1899:01 - massive issue, if we go to our
metamorphic contract outsole is
1899:05 - that if we deploy this contract,
somebody else could initialize
1899:09 - this code, become the owner, and
then automatically kill it
1899:12 - before we even have a chance.
This is actually something that
1899:15 - has happened in the past and has
caused a ton of issues. So if we
1899:19 - see red in the terminal, this
means Hey, massive issue, we
1899:22 - should absolutely check it out.
Now there's gonna be a ton of
1899:25 - green in here. These are
detectors that are probably low
1899:28 - impact, and they're probably
okay. And in fact, we can see,
1899:32 - it's even just calling out some
opens up on stuff here, saying,
1899:35 - Hey, we see some inline
assembly. Inline assembly is
1899:38 - kind of scary, maybe don't use
that. So you can think of green
1899:41 - as kind of a warning that
there's a low likelihood that
1899:44 - this will impact anything, but
you might want to check it out,
1899:47 - we get this different versions
of solidity used, which is just
1899:50 - saying, hey, there's a couple
different versions of solidity
1899:52 - that might be something you want
to keep in mind, maybe you
1899:54 - should use the same versions of
solidity. We have this allow old
1899:58 - versions. And this is actually
why throughout this whole
1900:00 - course, we've been using zero
point 8.7 Because zero point 8.4
1900:05 - and zero point 8.7 are
considered more stable versions
1900:08 - of solidity. So if you're using
versions outside of there, so
1900:12 - there will say hey, maybe you
want to work with a different
1900:14 - version. We have some flags in
here about maybe Hey, you should
1900:18 - make a variable constant because
it never changes which is great.
1900:21 - Uses literal with too many
digits saying hey, this Just
1900:24 - kind of hard to read, maybe you
screwed up some of the zeros,
1900:27 - loud old versions. And what's
this reentrancy in ether store
1900:31 - dot withdraw. So just by running
this slither tool, we can catch
1900:36 - a reentrancy vulnerability in
one of our contracts, which is
1900:39 - fantastic. So running the static
analysis caught at least two
1900:43 - huge vulnerabilities in our
metamorphic contract. And in our
1900:47 - reentrancy contract, it didn't
catch the issues involved at
1900:50 - sole liquidity pool, or bad RNG,
though, which is why we don't
1900:55 - only want to rely on slither
because it's not going to catch
1900:57 - everything, but it will catch a
lot of major vulnerabilities. So
1901:02 - that's how we can use Slither,
at least from a middle middle
1901:05 - stack point to get started. So
great, we just learned how to
1901:08 - work with Slither. That's one of
the first tools that are really
1901:11 - fantastic in our audit process.
And that's going to be
1901:14 - considered a fast tool for
static analysis, running tests,
1901:18 - linters, etc, are also types of
static analysis.
1901:24 - After we run a tool like that,
we enter some manual analysis
1901:28 - where we walk through the code
ourselves manually, and maybe we
1901:31 - do it in tangent with running
some slower tools, like a kitna
1901:35 - Manta Corp, and other symbolic
execution tools. Symbolic
1901:39 - Execution is where we simulate
executing transactions on the
1901:43 - blockchain. And one of these
symbolic execution tools that
1901:46 - we're going to work with is this
a kidmin tool. Again, this is a
1901:49 - trail of bits tool for doing
something called fuzz testing.
1901:52 - Now in programming, fuzzing or
fuzz testing is an automated
1901:55 - software testing technique that
involves providing invalid
1901:59 - unexpected or random data as
inputs to a computer program. In
1902:03 - a lot of our code, oftentimes,
we're going to get people
1902:06 - interacting with them in ways
that we will never think about.
1902:10 - So we want to be able to provide
random data and random
1902:13 - information to our test to see
if something weird happens that
1902:16 - we weren't expecting. So we can
actually build our own fuzz
1902:20 - tests in our hard hat projects
and run these fuzz tests, I've
1902:24 - actually created a sample of
fuzz tests, we write our fuzz
1902:27 - tests in solidity, actually, as
opposed to writing our tests in
1902:31 - JavaScript. So let's say for
example, we've built this vault
1902:34 - contract. And we think that at
first glance, hey, nobody should
1902:38 - ever be able to know the
password, and no one should ever
1902:41 - be able to unlock this contract.
Which obviously, we know is
1902:45 - ridiculous, because we know that
anybody can read anything in a
1902:48 - storage variable. So we know
that this should fail, but it
1902:51 - might be hard to write a test.
To catch that this actually
1902:54 - would fail. A good approach to
testing this would be to just
1902:58 - send a ton of random bytes 32
objects to this unlock function
1903:02 - to see if we can unlock it. We
can write a fuzz test to do
1903:05 - exactly that. So in my vault,
fuzz test dot Sol, we're
1903:09 - importing vault outsole. And so
we're saying vault fuzz test is
1903:13 - vault and we have a password of
123, ASD 123. And now we have a
1903:19 - function called a kid and a test
find password, where it's going
1903:24 - to send a ton of random data
into vault to try to make s
1903:28 - locked equal false. So we just
say s locked equals true here,
1903:32 - and our first test will try to
make s locked equals false. Now
1903:35 - we could install just the kitna,
but at this point, it's a good
1903:38 - idea to bring up our the
security toolbox from trail of
1903:43 - bits. So trail of bits has a
package called the eath security
1903:46 - toolbox, which has all their
security tools in one single
1903:50 - container kitna, Ethan o Manta
core, slither, rattle, and not
1903:54 - so smart contracts, it has all
these in the same exact package.
1903:58 - Now to work with this toolbox.
We're gonna need Docker
1904:01 - installed. So we're gonna do a
little bit of installation here.
1904:03 - And again, sometimes this can be
the hardest part of the course
1904:06 - is just installing these
packages. So we've left a link
1904:09 - to Doc's dot docker.com, get
Docker to install Docker, to
1904:13 - actually work with these tools,
you're just going to come you're
1904:15 - going to click whichever one of
these is appropriate for you to
1904:18 - install Docker, once we have
Docker installed, we can run the
1904:21 - E security toolbox by pulling it
down from the Docker equivalent
1904:25 - of GitHub. And we're going to
use a whole bunch of Docker
1904:27 - commands that I'm not going to
explain here because this isn't
1904:29 - a Docker course, if you're
looking to get into the security
1904:32 - stuff, I would definitely
recommend reading up on all
1904:34 - these commands afterwards. And
we're going to leave a ton of
1904:37 - links for you to learn more. And
in the package that JSON
1904:40 - associated with this lesson. We
even have the command to get set
1904:44 - up right in here. So we can just
run yarn toolbox, which will run
1904:47 - our Docker command like this. So
I'm just going to run yarn
1904:51 - toolbox. And if you get
something like this saying
1904:54 - cannot connect to the Docker
daemon is the Docker daemon
1904:57 - running, because I need to have
my Docker daemon running. Since
1905:00 - I installed Docker desktop. I
need to have my Docker engine
1905:04 - started and running for it to
actually be working. Again to
1905:07 - work with this. There's a lot of
Docker setup and configuration
1905:10 - that needs to happen, which I'm
going to leave a ton of
1905:13 - instructions on how to get
started with Docker. Once we
1905:15 - have Docker setup. Now we can
run yarn toolbox, which will
1905:19 - stick us into a new shell to
work with any of these tools
1905:22 - that trilobites has Out of the
box. Now our vault fuzz test
1905:26 - comes with a config as well.
This is in a Yamo file with all
1905:30 - our arguments for running a
kidnap. So it has a test limit,
1905:34 - which is how many different
runs, we should do a time delay,
1905:37 - block delay. And then of course,
some re mappings in here. This
1905:40 - darker shell will already have
the security tools already
1905:43 - installed like the Kidner test.
So we'll run a kinah test on SRC
1905:50 - slash contracts slash test slash
fuzzing slash fault fuzz test
1905:58 - dot Sol dash dash contract will
be vault fuzz test, dash dash
1906:05 - config will be SRC slash
contracts slash test slash
1906:10 - buzzing slash config dot Yamo.
And we'll go ahead and we'll hit
1906:15 - enter here, and it'll say
analyzing contract, it'll give
1906:18 - us an output like this, it will
give us an output that looks
1906:20 - like this. What it's saying is
it found a use case where it
1906:24 - could make s locked equals
false. And the use case was 123,
1906:29 - ASD 123. So when what seemed
like almost seconds, it found
1906:34 - the password to unlock our
contract. And this is why
1906:37 - running a fuzz tester can be so
powerful, we thought our
1906:41 - contract was secure, but it
immediately found the password,
1906:44 - which means anybody else could
immediately find the password.
1906:47 - And this would be an indicator
that what we're doing there is
1906:49 - not a good setup. So we'll hit
CTRL C to escape. And to leave
1906:53 - our Docker setup here,
1906:54 - we'll just write exit. Now
again, I'm going to leave a ton
1906:58 - of links to work with a
kidnapper and work with this
1907:00 - fuzz tester in the GitHub repo
associated with this lesson, so
1907:03 - that you can go ahead and learn
more. Now, if you take anything
1907:09 - away from this whole section, it
should be this right here. The
1907:13 - two most common tasks are
reentrant. See, and Oracle
1907:16 - manipulation. So if you're not
going to be an auditor, and you
1907:19 - just want to deploy things to
main net, always, always before
1907:22 - you deploy anything, the
absolute minimum that you should
1907:26 - be doing is always running
Slither. And then looking
1907:29 - manually for Oracle manipulation
and reentrancy attacks. If you
1907:33 - see in your code that you're
getting pricing information.
1907:37 - Price is a piece of data that we
as humans have assigned to
1907:40 - something if you're getting
pricing information from a
1907:42 - centralized location, rethink
that scenario, rethink what
1907:46 - you're doing there. If you're
getting a random number, if
1907:49 - you're doing any type of
automation from a centralized
1907:51 - location, rethink it and change
your strategy. The chain link
1907:54 - Oracle network has been created
for a reason to prevent getting
1907:58 - hacked like this. So please keep
these in mind before you deploy
1908:02 - anything to main that with any
type of security guarantees.
1908:05 - Okay, great. So we've learned
about the fast tools, we've
1908:08 - learned about some of the slow
tools. We didn't look into Manta
1908:11 - Corp or Mythix. But these are
also tools that you can use
1908:14 - Manta Corp is going to be
another tool from the trilobites
1908:17 - team. And Mythix is actually a
smart contract security service
1908:21 - from the consensus team, you
basically send a bot that they
1908:24 - have running in the cloud your
contracts and will do some
1908:27 - automated process to check for
security vulnerabilities. This
1908:30 - is a paid service. But if you're
going to be deploying a protocol
1908:33 - that's worth millions of
dollars, spending a few $1,000.
1908:36 - Spending a few $1,000 to make
sure it actually does. What it
1908:39 - says is going to do correctly is
definitely something that you
1908:41 - want to invest in. After you run
through this whole process. You
1908:46 - the smart contract developers
and the auditors should discuss
1908:49 - their findings. And if there's
any issues, repeat the steps,
1908:52 - repeat all the steps again after
changes are made. So this audit
1908:56 - process and making sure your
contracts are secure is a long
1908:59 - process. And then afterwards, an
auditor will finally write your
1909:02 - report with all security
vulnerabilities and everything
1909:05 - that they found in your
contracts. Typically, you'll
1909:08 - organize reports in a chart
that'll look something like
1909:11 - this, you'll label issues that
have a high chance of happening
1909:14 - and have a high impact as
critical things that have a high
1909:17 - impact, but a low likelihood as
medium, and etc. I'm also going
1909:22 - to leave some examples two
audits that have been done in
1909:25 - the past so that you can take a
look at them. And you can see
1909:28 - what a full audit looks like on
certain code. We'll be looking
1909:31 - at openzeppelin sigma prime, and
trilobites, because these are
1909:34 - three of what I think are some
of the best auditors in the
1909:37 - space. Now in the GitHub repo.
We also have a ton of other
1909:40 - tools that you can use Mythix,
mithril ethers play and
1909:44 - consensus security tools. If you
want to learn more about
1909:47 - security and auditing, I highly
recommend that after this course
1909:51 - you play the Ethernet game and
damn vulnerable Defy. These are
1909:54 - two games that will teach you a
ton about security. And we'll
1909:57 - test the chops and we'll test
everything that you've learned
1910:00 - in this course. There's also a
couple of security focused blogs
1910:03 - that I really like. One of them
in particular is wrecked dot
1910:06 - news. They keep a running list
of some of the largest hacks
1910:10 - that have ever happened in the
space and then retrospectives on
1910:14 - why those actually happened. And
they usually make it very
1910:16 - entertaining as well. We have
some articles in here as well.
1910:20 - One of the best places to look
at is this known attacks section
1910:23 - where they talk Talk about
reentrancy, Oracle manipulation,
1910:26 - front running and a ton of other
attacks that you should
1910:30 - absolutely be aware of when
writing your smart contracts,
1910:32 - we're not going to go over them
here because they do a great job
1910:35 - in these resources explaining
them, you should also check out
1910:38 - this article because I helped
write it. So definitely check
1910:41 - that out. And then we've got a
list to even more sections. So
1910:44 - this is going to be a living
section here. So please feel
1910:48 - free. If you find more things in
the future, please feel free to
1910:50 - make pull requests and update
this repository so that other
1910:54 - people can learn and know more
about security and auditing and
1910:57 - have contract examples on what
bad code looks like and how to
1911:01 - actually catch them. Even though
this was one of our quickest
1911:03 - sections. From a video
standpoint, this actually is
1911:06 - going to be one of the longest
sections of your career.
1911:10 - Security is something that is
always going to be on your mind.
1911:13 - And there's always going to be
new tools to help with security.
1911:16 - And there's always going to be
new things to think about. So
1911:18 - even though we went through this
very quickly, I would 100% want
1911:22 - you to pause this video, and
work with and try out some of
1911:25 - the tools we tried here. And
then maybe even try coming up
1911:28 - with your own vulnerabilities as
well. And with that being said,
1911:33 - you have just finished the last
section of this massive master
1911:38 - course on learning smart
contracts, solidity, web three
1911:42 - and blockchain development,
1911:44 - you should be incredibly proud
of yourself. Congratulations, I
1912:07 - and the web three community as a
whole want to congratulate you
1912:11 - for completing this absolutely
monstrosity of a tutorial, you
1912:16 - have done an amazing job to get
this far. And to watch me
1912:21 - talking to you right now. And if
you haven't finished the course,
1912:24 - go back and finish it before
coming here. We have learned so
1912:28 - much on this journey. And I can
say from the bottom of my soul
1912:33 - that I am so glad to have you in
the web three space, smart
1912:36 - contract space, the blockchain
space, the cryptocurrency space,
1912:40 - we are so excited that you're
here. I'm really looking forward
1912:44 - to seeing you in the web three
in the blockchain community. Now
1912:48 - a lot of people ask, Well, where
do I go? Now, I didn't have all
1912:52 - this newfound knowledge. I'm
armed with the intelligence of
1912:55 - the web three developer space.
Well, I've left some links in
1912:59 - the GitHub repository to lead
you to those next steps. But the
1913:03 - biggest thing that you can do
for yourself right now is go
1913:06 - take what you've learned, and
apply it somewhere. This is
1913:10 - going to be probably the most
thorough course you will ever go
1913:14 - through in this space. And you
can go tutorial to tutorial and
1913:17 - boot camp to bootcamp all you
want. But at some point, you
1913:21 - have to make that leap, and you
have to dive in. And that's
1913:25 - where the majority of the growth
is going to be anyways. So if
1913:28 - you're here, wondering where to
go next, go join a hackathon. Go
1913:32 - start jumping into issues on
GitHub repos, go start applying
1913:36 - for grants, go start applying
for jobs and say, I took
1913:40 - Patrick's massive course. Here's
my GitHub repo, work on a
1913:43 - personal project, work on
somebody else's project. Take
1913:47 - this knowledge and apply it, the
challenges that you'll run into
1913:50 - and the challenges that you'll
face. Really trying to do
1913:53 - something without me hand
holding you is where you're
1913:56 - going to learn 10 times as much
as what you've learned here.
1914:00 - I've walked through as deep down
this rabbit hole as I can take
1914:03 - you. Now it's up to you to go
out and do something with it. So
1914:08 - thank you, everybody who helped
me create this course. Thank you
1914:11 - for taking this course. And I'm
so excited to see you in the
1914:15 - community and see what you build
and see what we can create with
1914:20 - this technology.