00:00 - Learn all the basics of structured query language in this comprehensive SQL course.
00:06 - You will build out real database tables and practice querying them in flexible ways as
00:11 - a back-end web developer would in the production setting.
00:15 - Lane Wagner created this course.
00:17 - Lane is an experienced software engineer and creator of Boot.dev.
00:21 - So let's get started.
00:23 - As a web developer, you might think that you need to know JavaScript and Python and Go
00:27 - and TypeScript, but I'm actually here to tell you that what you really need to know is SQL
00:33 - or SQL.
00:34 - See, no matter what programming language you end up using day-to-day as a developer, it's
00:38 - very likely that you'll actually be using SQL alongside that programming language in
00:45 - your web projects.
00:46 - Stick around and in just a few more minutes I'll explain why SQL can actually be a game
00:50 - changer for your career.
00:51 - I'm Lane, the founder of Boot.dev and the host of the back-end banter podcast.
00:56 - I've been writing SQL for about 10 years now.
00:58 - I've spent over a year designing this course and updating the material, and I've actually
01:04 - already taught thousands of students with this stuff.
01:07 - And all of their feedback has actually gone back into the course improving it over time.
01:12 - So what you're about to watch is actually some really battle-tested material.
01:16 - During this course, we'll be learning all the foundational SQL skills that you need,
01:21 - but we'll be focused on the stuff that's most important for web development.
01:25 - The best part is that we'll be hands-on keyboard, filling out a real-world database layer for
01:31 - an actual web application.
01:33 - It's actually a PayPal clone that I'm calling Cashpal.
01:36 - This next part is very important.
01:38 - Do not, please do not binge watch this video.
01:43 - Look, tutorial hell is a real place.
01:45 - It's a place you're going to find yourself if you don't write your own code.
01:48 - So please, code with me.
01:50 - So, head over to boot.dev right now, grab a free account, and that's where you can actually
01:55 - follow along with every exercise right in your browser.
02:00 - Alternatively, if you don't want to create a boot.dev account, I've also linked all of
02:04 - the raw text files down in the description below.
02:07 - There's a GitHub link.
02:08 - Now, be aware, this SQL course is actually just one part of a full backend developer
02:14 - career path over on boot.dev.
02:16 - If you're interested in going from zero to hireable as a backend developer, definitely
02:21 - go check that out as well.
02:23 - If you get stuck during this course, don't worry about it.
02:26 - We've got three resources that you can check out.
02:28 - The first is the boot.dev discord, the second is the free code camp discord, and the third
02:33 - is the free code camp forum.
02:35 - All of those places are great resources for getting help.
02:38 - They'll be linked down in the description below.
02:40 - Lastly, if you want to connect with me personally, there's three places.
02:43 - You can find me on Twitter or X at wagslane.
02:47 - You can go sign up on boot.dev and I'll be in your email.
02:51 - Or I'm also the host of the backend banter podcast, which you can find in any major podcast
02:56 - player or just here on YouTube.
02:58 - With that out of the way, let's talk about SQL.
03:04 - As a backend engineer, one day I'm sitting in my office at work and my boss is staring
03:08 - kind of longingly out the window and I walk over and he says, look at that guy.
03:13 - Look at that guy shoveling manure.
03:18 - That's what I do.
03:19 - That's what I do day to day as a developer.
03:22 - And I mean, he was right.
03:24 - As developers, we just kind of take data from one place and shovel it into another place.
03:29 - We're just kind of moving crap around.
03:31 - And the best tool that we have for moving crap around is SQL or SQL.
03:38 - Say you're a developer working at YouTube.
03:40 - Your job is to shovel data from creator's devices, right?
03:44 - So a video, a title, a description, a thumbnail, shovel that up into the cloud and store it
03:49 - in some database.
03:51 - And then your job is to shovel that data back down to user's devices where they can watch
03:56 - the videos and see the thumbnails, SQL or structured query language, often also called
04:01 - SQL.
04:02 - I like to call it SQL.
04:03 - It's a little easier to say a few syllables.
04:06 - This is the language that we use to communicate with most databases.
04:10 - The vast majority of databases use SQL as a query language, a protocol that we use to
04:17 - communicate and get data in and out of database servers, things like MySQL, PostgreSQL or SQL
04:26 - Lite.
04:27 - A database is just a piece of software that makes it easy to store large amounts of data
04:32 - in your computer's file system.
04:34 - You could kind of think about it as just a really advanced Microsoft Excel or an advanced
04:38 - Google sheets.
04:40 - When you work with Google sheets or Excel, you're probably moving data around fairly
04:44 - manually, right?
04:45 - You're pointing and clicking, dragging and dropping.
04:47 - When you work with SQL and with a database, you automate all of that, right?
04:52 - So you write code that automates the creates, the reads, the updates and the deletes within
04:58 - the database.
04:59 - That's why SQL is so cool.
05:00 - And that's why as backend developers, SQL is critically important.
05:04 - Let's hop right into the first lesson and we'll start writing some SQL.
05:07 - So here on the right, I have my kind of starter SQL code for the lesson.
05:11 - On the left, I've got my instructions.
05:13 - And then down here at the bottom, I have the ability to run and submit the code.
05:17 - Now it's important to note that all throughout this course, we're going to be writing SQL
05:22 - that's executed against the cash pal database.
05:26 - And cash pal is really just a toy web application.
05:29 - That's sort of a clone of PayPal.
05:31 - PayPal is an application for sending money online and cash pal is basically the same
05:36 - thing in toy form, right?
05:37 - So you can imagine that the data that's stored in cash pal's database is things like users,
05:42 - right?
05:43 - Who are the people that use cash pal and then transactions, right?
05:46 - Every time one user sends money to another user, we need to store that information in
05:51 - our database.
05:52 - So let's jump right into the assignment.
05:54 - It says, I have provided a simple SQL statement for you that retrieves some records from a
05:58 - table.
05:59 - However, there isn't a people table.
06:01 - The table in our database is called users fix the bug by changing people to users within
06:07 - the select statement.
06:08 - So here we've got select star from people.
06:10 - Um, and it looks like there was just, you know, a mistake made.
06:12 - So we're going to swap that out for select star from users.
06:15 - In fact, let me really quickly run it in its old state and just see what happens.
06:20 - SQL logic error, no such table people.
06:23 - Okay, cool.
06:24 - And then let's change it to users.
06:26 - Run that code perfect.
06:30 - And I just want to call attention to the fact that the output of our little SQL statement
06:34 - here isn't console output, like you might get in a programming language like Python
06:39 - or go.
06:40 - Instead, we actually get a result set that's kind of formulated as a table of rows and
06:46 - columns.
06:47 - So now let's kind of break down the anatomy of the select statement that we modified in
06:51 - the first exercise.
06:53 - It's important to note that select statements are probably the most common type of statement
06:57 - that you'll write in SQL because select statements are the equivalent of a read operation, right?
07:03 - It's how we get data out of the database.
07:05 - Let's take a look at this first example, right?
07:07 - Select ID from users.
07:10 - In this case, we're selecting the ID column from the users table and all SQL statements
07:19 - and in a semi-colon.
07:20 - So we're saying, give me all of the IDs from the users table.
07:27 - It's also worth pointing out that keywords in SQL are case insensitive.
07:32 - Generally speaking, SQL is case insensitive.
07:34 - So this select statement is all caps, which is typically the convention.
07:39 - The convention would normally also be for this from keyword to be all caps.
07:43 - But I just wanted to demonstrate that it doesn't actually matter.
07:45 - It will work either way.
07:47 - So we've talked about how to select a single field or a single column, right?
07:51 - Select ID from users.
07:53 - Selecting multiple fields is also pretty easy.
07:55 - You just separate field names with a comma, right?
07:57 - So if we want all of the IDs and the names from the users table, then we would select
08:02 - ID, comma, name from users.
08:05 - Now in the last assignment, we actually just selected all fields.
08:08 - We didn't name explicitly which fields from the table we wanted to get back.
08:12 - We said, just give me all of the columns that exist on the table, right?
08:16 - And when you want to do that, you just use the star operator or the wildcard operator
08:20 - instead of explicitly naming every single field and separating with commas.
08:25 - So moving on to the assignment, it says the state of our cache pal users table is as follows,
08:30 - gives us this nice little table.
08:31 - So keep in mind, this is the data that's actually in the database, right?
08:35 - And when we write a select statement, we're generally trying to select some subset of
08:41 - that data.
08:42 - We generally don't want all of the data in the database to come back from our query.
08:45 - We're just trying to get at something specific, right?
08:48 - So the assignment goes on, it says, it's very common to write queries that only return specific
08:52 - portions of data from a table.
08:53 - Our HR team has requested a report asking for all of the names and balances of all of
08:58 - our users.
08:59 - Write a query that retrieves all of the names and balances from the users table.
09:03 - So let's go ahead and do that.
09:05 - Start with a select keyword.
09:08 - And we're not going to do star because we just want name and balance.
09:13 - We just want the name and the balance columns, right?
09:16 - And I will capitalize to kind of adhere to conventions from the users table.
09:24 - Go ahead and run that.
09:26 - So you can see all we got back was names and balances.
09:29 - If we wanted, for example, the age as well, then we could add age here, right?
09:34 - We'd get an additional column back in our result set, but we don't need age, right?
09:38 - The assignment didn't ask for that.
09:40 - So we'll go ahead and submit that.
09:42 - So many databases use SQL.
09:45 - SQL is just a query language, right?
09:48 - And lots of different database technologies out there use SQL or allow us to write SQL
09:53 - in order to interface with the database, right?
09:55 - So Postgres is a really popular one.
09:57 - It's one that I use in production all the time.
09:59 - SQLite is really popular.
10:01 - It's the one that we are using in this course, actually.
10:03 - SQLite is what boot dev is running on the back end to power this whole interactive experience.
10:10 - But really, that's all you need to know is that SQL is a common language.
10:13 - So when you learn SQL, you'll be able to use basically any database that supports SQL.
10:20 - Though it is worth mentioning that while SQL is a common language, sometimes databases
10:26 - support different dialects of SQL.
10:29 - So you will see minor differences, right?
10:31 - Maybe SQLite only supports certain data types, whereas Postgres supports other data types.
10:37 - So there are little nuances, but generally speaking, when you pick up SQL as a skill,
10:42 - it will make it so that you're able to use all of these databases, even if you do have
10:45 - to look up little things that are different from time to time.
10:48 - So let's jump into this assignment.
10:49 - It says one way in which SQLite is a bit different is that it stores Boolean values as integers,
10:55 - right?
10:56 - The integers zero and one.
10:57 - So it's very kind of raw binary in that way.
11:00 - Select all the IDs, names, and is admin flags from the users table.
11:05 - Okay.
11:06 - Pretty straightforward.
11:07 - So select ID, name, is admin from users, go ahead and run that.
11:19 - Looks good to me.
11:21 - You may have heard that SQL isn't web scale.
11:24 - Why didn't you use MongoDB?
11:27 - MongoDB is a web scale database.
11:30 - Just by not using structured query language, you can make your database scale to billions
11:35 - and billions of users, anyways, that's not how it works.
11:39 - Let's talk about the real differences between SQL and no SQL.
11:42 - Let's look at a few of the more popular examples in both categories.
11:46 - So on the SQL side, we've got Postgres, QL, one of my personal favorites, for sure.
11:52 - You've probably heard of MySQL, SQLite.
11:57 - We've got SQL Server, SQL Server, that's Microsoft's.
12:03 - You've probably heard of Oracle, and also thrown a mention of Cockroach, CockroachDB.
12:09 - Okay.
12:11 - So these are just a few examples.
12:13 - There's literally hundreds of SQL databases out there, but these are ones that you may
12:17 - have heard of.
12:19 - No SQL databases, got Mongo, MongoDB.
12:24 - You probably heard of Redis.
12:27 - You may have heard of Elastic, Elasticsearch.
12:32 - Firebase, Firebase is pretty popular.
12:36 - And we'll also mention Dynamo, DynamoDB, that's Amazons.
12:41 - So these are just some examples of databases that fall into the SQL and the NoSQL categories.
12:46 - Now the first thing you need to understand about the difference between SQL and NoSQL
12:50 - databases is that the SQL databases tends to be much more similar.
12:56 - I mean, they're in a group because they're all SQL databases.
12:59 - So right out of the gate, they have something in common.
13:02 - Whereas the NoSQL databases, all they have in common is the fact that they don't use
13:07 - SQL, right?
13:09 - They don't all use the same query language, right?
13:13 - All SQL databases use structured query language.
13:15 - They have a common language that we use to interface with the databases.
13:18 - No SQL databases do not all use the same query language.
13:21 - They just don't use SQL.
13:24 - Now SQL databases also tend to be, they tend to be kind of general, general purpose.
13:34 - Now that's not always true, right?
13:36 - At the end of the day, a SQL database is just any database that supports SQL, right?
13:41 - So you could have a specialized database, but it just so happens that the most popular
13:46 - SQL databases tend to sort of be general purpose, which means they're often a great starting
13:51 - point for most web applications or websites.
13:54 - And right out of the gate, I'm going to go ahead and call out an exception here in that
13:57 - Cockroach DB is kind of an outlier among these databases in that it's a very distributed
14:03 - database kind of built for scale, right?
14:05 - So you add some complexity to the database, you get some scaling benefits.
14:09 - Same with SQLite.
14:10 - SQLite is kind of purpose built for very small applications where you embed your database
14:15 - like directly within your application.
14:18 - So those two, I'm going to kind of just flag as a little different, not quite as general
14:24 - purpose.
14:25 - Now, no SQL databases on the other hand, tend to be specialized, specialized, right?
14:34 - So usually no SQL databases are built for a very specific purpose, right?
14:40 - And again, I'd flag an exception MongoDB tends to be a little bit more of a general purpose
14:44 - database.
14:45 - For example, Redis is often just used for caching or kind of in memory, key value stores,
14:53 - right?
14:54 - So it's very specifically built for one use case.
14:56 - A lot of times, web apps will use Redis and a SQL database.
15:00 - Elasticsearch, as you could probably tell, is very often used for search and used for
15:07 - aggregations.
15:08 - So if you have, for example, a giant search component on your site, right, like the eBay
15:14 - search bar, for example, you might use Elasticsearch to make those searches efficient.
15:20 - Firebase is Google's product.
15:22 - It's kind of specifically good at real time, real time, and mobile, like mobile apps, right?
15:31 - And then DynamoDB is probably actually similar to Mongo.
15:35 - It's a little bit more general purpose, but it's AWS's kind of specific product for data
15:40 - at scale.
15:41 - Now I've done a lot of hand waving here, but the thing that I really want you to take away
15:45 - from this is that at the end of the day, an SQL database is just any database that can
15:50 - be interacted with using the programming language, structured query language, SQL, right?
15:56 - And any no SQL database is a database that just doesn't have that, right?
16:00 - It probably has its own kind of proprietary or specific query language that you'll use
16:04 - to interact with it.
16:06 - Just like any technology decision, when you're deciding which database to use for your project,
16:10 - you really need to kind of weigh the pros and cons of the database against your specific
16:15 - use case.
16:16 - That said, for most simple web applications or websites, something like Postgres is going
16:21 - to do really well, right?
16:22 - It's a general purpose database that can handle scale at a decent level as your application
16:28 - scales up and you understand more your specific needs, right?
16:31 - Maybe you need caching, maybe you need search.
16:34 - You can look at introducing other database technologies to your stack.
16:37 - So as we spoke about earlier, the big difference between SQL and no SQL databases is just whether
16:42 - or not the databases support the use of SQL, right?
16:47 - And that's what this assignment is talking about.
16:49 - And it really, I want to reiterate the fact that no SQL databases don't have all that
16:57 - much in common, right?
16:59 - For example, there's a bunch of no SQL document databases and those tends to have more in
17:04 - common with each other, right?
17:05 - MongoDB and DynamoDB, for example, are both kind of document stores and they're more similar
17:12 - than just like the whole group of all no SQL databases, right?
17:16 - Key value stores like Redis and Memcached are quite similar, but they're not similar
17:21 - to again, other no SQL databases like Mongo.
17:26 - They're kind of in a class of their own, if that makes sense.
17:29 - So the question for this assignment is each no SQL database tends to use blank query languages.
17:36 - And the answers are the same or different.
17:38 - And I'm going to say different because they're kind of all over the place.
17:42 - The next question on SQL versus no SQL is blank compatible databases tends to be more
17:48 - similar in their functionality than blank databases.
17:51 - So no SQL and SQL or SQL no skill.
17:55 - Well, let's see what makes sense here.
17:58 - SQL compatible databases tend to be more similar in their functionality than no SQL databases.
18:02 - So it's going to be that second one.
18:05 - Next question is which type of database always uses table structures, right?
18:10 - So SQL organizes data into tables, right?
18:13 - When we were writing our SQL queries earlier, we were doing select star from users, right?
18:17 - The user's table stores data, SQL assumes the existence of tables that we can select
18:24 - data from, right?
18:25 - No SQL databases don't always use that terminology.
18:29 - Don't even always use that way of grouping data, right?
18:32 - So it's just SQL that always uses table structures.
18:37 - I really quickly want to just compare a few of the popular SQL databases that are out
18:43 - there.
18:44 - You may have heard of Postgres, MySQL, Microsoft SQL Server, SQLite, and there are a ton of
18:48 - others.
18:49 - In fact, if you want to follow this link here, you can go look at really all of the, at least
18:54 - relatively well-known SQL databases that exist, and there's more than a hundred.
18:59 - So let's quickly just compare SQLite and Postgres.
19:03 - So we're using SQLite in this course, but I do use Postgres in later web development
19:09 - courses on boot dev.
19:10 - I think they're both great databases.
19:12 - SQLite is sort of built for the embedded use case.
19:16 - So it's really great when like resources are constrained, maybe you need a database on
19:20 - like a mobile device, or if you're deploying say to the edge, right?
19:24 - Maybe if you're running a database, um, say hundreds of copies of your database on different
19:29 - edge servers distributed geographically around the world, SQL, SQLite can be really good
19:34 - for that.
19:35 - It's really good at being embedded within your application.
19:37 - So there are great use cases in production, even for SQLite, Postgres on the other hand
19:42 - is more of a monolith, uh, Postgres acts as a server itself and will typically be used
19:50 - for more traditional web applications that need to serve more users or at least operate
19:56 - at a larger scale.
19:57 - Right?
19:58 - So if you're storing massive amounts of data in your database, Postgres will be a better
20:03 - option most likely than SQLite.
20:06 - Postgres also just has many more features than SQLite, right?
20:10 - So if you're storing lots of data in a database and you need to do lots of complex things,
20:14 - Postgres is going to serve your needs a little bit better.
20:16 - And one of those features is kind of exhaustive type checking.
20:20 - So SQLite is pretty loosey goosey with types, right?
20:24 - You can specify types on your columns, but at the end of the day, SQLite will kind of
20:29 - just let you put whatever you want anywhere, whereas Postgres will enforce kind of more
20:34 - strict static type checking.
20:36 - To show you what I mean, let's jump down into the assignment.
20:39 - So it says, let's look at how SQLite does not enforce type checking.
20:44 - This within the create table statement, name is defined as a text field, right?
20:46 - Okay.
20:47 - So we've got this first statement, create table users.
20:49 - It's got an ID field that's an integer, a name field that is text, and an age field
20:55 - that is an integer.
20:57 - Next it's inserting two records into that table.
21:02 - ID name age values one John Doe and 21, right?
21:06 - So ID one name John Doe age 21.
21:10 - And then also inserting a second record into the table where ID is two, name is Montgomery
21:15 - Burns and age is 33.
21:18 - And then finally there is a select star from users table that runs.
21:22 - So let's go ahead and just run that code so you can see, see the output, right?
21:26 - Got this users table, got some data in there.
21:29 - So it says run the code and take a look at the results.
21:31 - We did that on line three, change the text string Montgomery Burns to the integer one
21:39 - and run the code.
21:41 - So this is what's kind of interesting, right?
21:43 - We're no longer putting text in the name field.
21:48 - We're putting an integer there, but it still works, right?
21:52 - SQLite just like doesn't care.
21:54 - Whereas Postgres would have actually thrown an error at us in this instance.
22:00 - This is notice how even though we define name as text, SQLite allowed us to use an integer
22:04 - like Python and JavaScript, SQLite has a loose type system.
22:08 - You can store anything anywhere.
22:09 - So to pass the assignment, submit the code in the altered state where the record with
22:12 - ID two has a name of one.
22:16 - Okay, cool.
22:17 - We'll just submit like this.
22:22 - So by now we're familiar with the idea of a table in a database, right?
22:26 - The table has columns and every new entry in the table is a row in the table, right?
22:31 - Each row, of course, having multiple cells, each with a value for the associated column,
22:36 - right?
22:37 - A table, a user's table might have ID, name, date of birth as columns, and then every new
22:43 - user would get their own row in the table.
22:45 - Well, now let's look at the SQL statement that we can use to create new tables.
22:49 - Okay, so we've got the create table statement.
22:53 - So create table and then the name of the table.
22:55 - So in this example, we're creating an employees table, and then we're specifying a few different
23:00 - columns that we want to create, right?
23:02 - An ID column that's of type integer, a name column of type text, an age column of type
23:08 - integer, and finally is manager, which is a Boolean and salary, which is an integer.
23:13 - This is kind of annoying to specify the create table statement horizontally like this.
23:19 - So there's a little more well organized syntax that we can use like this, where we kind of
23:25 - split it up onto new lines with some nice indentation to make it a little bit easier
23:30 - to read, right?
23:31 - But the takeaway here is that name of the table comes right after the create table statement.
23:35 - Then we've got an open and a closed parentheses, and inside we specify all the fields and their
23:41 - types.
23:42 - So let's jump down into the assignment and write some SQL.
23:44 - So the assignment says, let's begin building a table for the cache pal database, create
23:48 - the people table with the following fields.
23:50 - All right, so create table, going to be called people, open parentheses, the names of all
23:57 - the fields, we've got ID, which is an integer, then a comma to separate between the columns.
24:03 - You'll notice that I'm using the term column and field kind of interchangeably.
24:07 - In SQL world, column is definitely the more correct term.
24:11 - The reason you'll hear developers kind of, I don't know, slip up or use the terms field
24:15 - and column interchangeably is because once you convert a row in a database into a struct
24:20 - or an object, then within the programming language, you'd call that a field on an object.
24:25 - So for example, a person object might have an ID field.
24:28 - All right, moving on, we've got handle, which is text, name, which is text, age, which is
24:38 - an integer, balance, also an integer, integer, and finally is admin, is a Boolean.
24:51 - Then we end all of our SQL statements with a semicolon.
24:53 - Great.
24:54 - I'm going to go ahead and run that.
24:58 - And just so you're aware, this next SQL statement that's running after the create table statement
25:02 - just kind of dumps the information about the people table.
25:05 - So that's why we were able to get kind of this nice little description of the table
25:09 - that we just created, all the different columns we created and their types.
25:13 - That looks correct to me.
25:14 - I'm going to go ahead and submit it.
25:16 - Now it's extremely rare to work on a web application that only has one table.
25:21 - Most web applications are going to have many tables.
25:23 - They certainly have a table per entity.
25:26 - So for example, in a social media application, you might have a table for your users, a table
25:30 - for their posts, maybe a separate table for all of the comments on those posts, and then
25:35 - maybe even a separate table keeping track of all the likes on the posts, right?
25:40 - Well in our case, we're building a cash pal, which is a PayPal like clone.
25:44 - So we'll probably need another table called transactions.
25:47 - This is where we'll keep track of all of the payments between users.
25:51 - So create the transactions table with the following fields.
25:54 - So create table transactions, fields ID, integer, recipient ID, integer, sender ID, integer,
26:14 - note, text, and finally amount, integer, perfect, right?
26:24 - This makes sense.
26:25 - Every transaction is going to get a unique ID to identify that transaction.
26:29 - We'll also need to keep track of the recipient and the sender in every transaction, an optional
26:35 - note and how much money is being sent.
26:38 - Cool.
26:39 - Let's go ahead and run that.
26:40 - And that's looking correct to me.
26:44 - Now rather than creating a new table, let's talk about changing an existing tables.
26:48 - This would typically be kind of dangerous, right?
26:51 - If you have code that depends on a specific name of a database table, then it can be tricky
26:56 - to kind of swap the name out live.
26:59 - But if you're working with a toy database or maybe you haven't pushed to production
27:04 - yet, this is usually a pretty simple thing to get done.
27:07 - We have an alter table statement that allows us to do it.
27:10 - So for example, if we would just want to rename a table, then we can alter table employees,
27:16 - rename it to the contractors table, right?
27:19 - We can also rename columns by doing alter table name of the table and then rename column
27:25 - salary to invoice, for example, right?
27:28 - So the same alter table keywords are used for both altering the name of the table and
27:34 - the name of individual columns.
27:36 - And then if we're not actually renaming, but instead we're adding or deleting columns,
27:41 - we actually still use that same alter table keyword at the start of the SQL query.
27:46 - So alter table contractors, in this case, add column, and then the name of the column
27:51 - and its type, or just alter table contractors drop column and then the name of the column.
27:57 - So this alter table statement really gets a lot done for us.
28:00 - It's the latter half of the statement that really kind of describes what's going on.
28:05 - So dropping down into the assignment here, it says, we need to make some changes to the
28:08 - people table.
28:09 - At the moment, we have these five columns shown as rows so we can display data types.
28:14 - Okay, so these are our columns, ID, handle, name, age, balance, is admin.
28:19 - Rename the table to users, rename the handle column to username and add the password, text
28:26 - column.
28:27 - Okay, so we're actually gonna be writing a few different SQL commands here.
28:29 - And just to start, I'm gonna go ahead and run the code in its current state and it looks
28:37 - like the users table doesn't exist, which if we take a look at the setup code, we can
28:42 - see that this is kind of what's being run before our code runs.
28:45 - So this makes sense, right?
28:46 - The people table is being created and when we kind of dump the information on the users
28:51 - table, it's not there.
28:53 - Okay, so first thing we need to do is rename the table to users.
28:56 - So we'll do alter, able people and then I'm gonna double check our syntax up here.
29:07 - Rename to, rename to users and just so that you're aware, users is a very conventional
29:16 - name for the users of an application.
29:19 - You typically would not name all of the people that are using your tool in your database.
29:25 - You typically would not name that table people.
29:29 - In fact, I explicitly named the table people so that we could in this exercise change it
29:33 - to users because that's the much more kind of standard thing to do.
29:37 - So alter table people, rename to users, I'm gonna go ahead and run that.
29:41 - Cool, now we're getting closer to the right answer, right?
29:45 - We're at least getting this output that describes the users table.
29:50 - But there's a couple more instructions.
29:52 - Rename the handle column to username.
29:54 - Okay, so after this, we'll do alter table, now called users, right?
30:00 - Alter table users, rename handle to usernames.
30:04 - It's going to be rename column handle to username, okay?
30:16 - This one I've seen both ways.
30:17 - I wouldn't say there's necessarily a right or a wrong answer around handle or username,
30:21 - right?
30:22 - Twitter calls them handles.
30:23 - Most applications probably call them usernames, but it's not too important.
30:27 - And I would argue the more social your app is, the more likely you're probably going
30:31 - to call them handles.
30:32 - Okay, cool, let's run that.
30:35 - Now we can see that we've swapped that handle out for the username fields.
30:40 - That's looking good.
30:41 - And then add the password column and it should be of type text.
30:46 - So again, alter table users, add column, password type text.
30:58 - And let's run that.
30:59 - Cool, this is looking good to me.
31:01 - I'm going to go ahead and submit it.
31:04 - Good database migrations are kind of like unit tests in the sense that a lot of people
31:08 - don't actually do them very well, but like to walk around talking about how great they
31:12 - are.
31:13 - I am an aggressive unit tester.
31:14 - So if you're wondering what the hell I'm talking about, this video is for you.
31:17 - Let's talk about database migrations.
31:20 - Let's jump right into an example.
31:21 - Let's say that we have a users table in our database and you, the users table has a few
31:30 - fields might have an ID.
31:34 - Say users have a username, maybe a password anyways, let's say that we've deployed this
31:43 - application to production.
31:45 - So we actually have users, this table is being used in production by our web application.
31:50 - But what happens is now we want to add a new feature and the new feature requires a new
31:55 - field in the database.
31:56 - Turns out now we need to add a new field, call it birthday.
32:03 - The act of adding that field of adding a new column to the table.
32:09 - That is a database migration.
32:11 - Now this type of migration where we've added, add a new column or add a new table, it tends
32:18 - to be fairly safe, tends to be fairly safe.
32:22 - And the reason for that is the application that's been connected to this database and
32:27 - running queries, it didn't care about this birthday field before.
32:31 - It was never say, you know, querying, give me all of the users whose birthdays are before
32:36 - the state.
32:37 - It wasn't making those queries by adding a new field.
32:39 - It's very unlikely that we'll break anything by adding a new table to a database that's
32:45 - being used.
32:46 - Very unlikely you'll break anything because the current code simply doesn't care about
32:51 - that database table because it just didn't exist in the last version.
32:54 - On the other hand, let's say we do a migration where we remove passwords from the users table.
33:02 - Maybe we're no longer storing user passwords because we only support signed one with Google,
33:06 - something like that.
33:07 - These types of migrations, right, removals of data, remove, I'll just do RM, they're
33:14 - very dangerous.
33:15 - They tend to be very dangerous.
33:17 - So let's talk through some rules of thumb about how you'd approach migrations depending
33:22 - on if your migration is adding a resource like a column or a table, deleting a column
33:28 - or a table, or updating because this is going to change a lot, right?
33:32 - So let's assume that we're adding, we're adding a new column or a new table.
33:36 - This tends to be safe and so what you can do first to keep things simple is first you
33:41 - run the migration on the database.
33:43 - So you update the database, step number one, right?
33:47 - And by updating the database, you haven't broken what's currently running because you're
33:52 - just adding new stuff, right, again, generally speaking.
33:55 - Okay, number two, you'll update your code, right?
33:59 - Now you can deploy the new version of the application that actually uses those new fields
34:04 - or tables.
34:05 - Now let's assume that you're deleting a column or a table.
34:09 - The first thing you're actually going to do in this case is update the code, right?
34:14 - So presumably you're deleting a column or a table from a database because you no longer
34:18 - need it in your application logic, right?
34:21 - For whatever reason, you don't care about users' birthdays anymore so we're just going
34:24 - to go ahead and delete it.
34:25 - Well, first you need to update the code.
34:28 - Stop querying that resource, right?
34:31 - Stop querying that column or that table.
34:34 - Once the code has been updated, now you can safely update the database without breaking
34:40 - anything.
34:41 - Now let's talk about the thing that is by far the hardest.
34:44 - This is updating.
34:46 - Now generally speaking, you should try just to not update.
34:50 - And what I mean is changing the name of a table is generally speaking just a really
34:55 - bad idea, changing the name of a column really bad.
34:59 - Try to get those things right the first time.
35:01 - But if you do have to change it, just know that it's going to be more work and you need
35:06 - to be extra careful.
35:07 - Because keep in mind, when we're adding stuff, we can safely update the database beforehand.
35:14 - When we're deleting stuff, we can safely update the database after the fact.
35:19 - When we're updating stuff, there's really no safe way.
35:24 - I mean, think about it for just a second.
35:25 - You've got an old version of code that expects an old database name and a new version of
35:30 - code that expects a new database name.
35:33 - Really your only option is to make sure that you update both the database table name and
35:40 - the code at exactly the same moment in time.
35:44 - And it's really hard to make sure that happens.
35:46 - You're going to have probably milliseconds or seconds of downtime.
35:49 - So because this is a harder problem, there's not just a simple one to solution.
35:54 - I'm going to just give a few ideas of how you can approach updating the database.
36:01 - Approach number one is scheduled downtime.
36:04 - Downtime.
36:05 - This means you literally just turn off your application.
36:08 - You're like, look, customers, I'm sorry, you cannot access the application for the next
36:11 - 30 minutes.
36:12 - We're doing a big update to our database.
36:14 - I don't recommend that that kind of sucks, right?
36:16 - People want access to your web application.
36:19 - So this is like what you would do if you really feel like you don't have any other options.
36:24 - It's simple, but it does affect your customers.
36:26 - Number two is kind of what I described at the start, which is just a same, same time
36:33 - deploy, right?
36:37 - So we're just going to deploy the update and we're going to deploy the code at the same
36:40 - time.
36:41 - We understand that there will be kind of a bug there for a few seconds.
36:46 - But if you've determined that say you don't have any active users at the moment or a few
36:52 - seconds of issues, aren't really a problem and it's not worth doing anything more complex.
36:57 - I mean, I've seen companies do this.
36:59 - I wouldn't say it's a good idea, but it does get the job done.
37:03 - The best approach or the most robust approach is probably to copy, to copy the database
37:11 - or the database table, right?
37:13 - So we create a new copy of the table with all the exact same data.
37:18 - We can update the new copy's name to be the new table, right?
37:23 - And now we can safely deploy the new code that references the new table.
37:28 - There is a possibility of, you know, in the interim of you've done the copy and now you've
37:34 - deployed the new code that new records will be added to the old table that you would also
37:38 - need to copy, but that can also be handled, right?
37:41 - You can write a fairly robust migration script that copies data to the new table, deploys
37:46 - the code, makes sure it moves over any records that were added in the interim, that sort
37:51 - of thing.
37:52 - So copying tends to be very robust.
37:54 - It takes a little more work, right?
37:56 - You're writing a more, a more complex migration scripts to make sure that everything goes
38:01 - off without a hitch.
38:02 - Now, I know I just said that copying was the best approach and I may have misspoke there.
38:07 - There actually is a better approach that I'm aware of.
38:10 - I'm going to call it aliasing.
38:15 - The thing is sometimes aliasing is not possible.
38:18 - So there are certain databases that support an aliasing feature and some that don't.
38:23 - So it kind of just depends if this is available to you.
38:25 - But the whole idea behind aliasing is that you can give the table a second name.
38:29 - So your database table effectively has two names it can be referenced by.
38:34 - So what that means is your old code references the old name.
38:37 - You alias the table with a second name, so that can be referenced by two different names.
38:42 - The new code uses the new name, right, and then once you've safely deployed the new code,
38:47 - you can drop the old name from the table.
38:50 - That would actually be the best, the safest and the simplest approach, but it kind of
38:54 - depends on your database technology and what's available to you.
38:56 - These are just four options.
38:57 - These are the four that I've tended to use the most.
39:00 - Hopefully they help.
39:01 - And then I just want to reiterate that you shouldn't be updating names very often, right?
39:06 - Pick good table names, pick good column names, try to do ads and deletes and avoid a bug.
39:12 - Now, the last thing we need to talk about with database migrations are up, up and down
39:19 - migrations.
39:20 - Right?
39:21 - So we talked about the different types of migrations in the sense that you can add something,
39:25 - delete it, or update it.
39:27 - But realistically, any migration that brings us forward in time, we call an up migration,
39:34 - right?
39:35 - Our first up migration might create a table, right?
39:44 - And then our second migration might delete, I should say our second up migration might
39:51 - delete a column from that table, right?
39:55 - Our third up migration might create a new table, create another table.
40:01 - Now let's say our fourth up migration renames a column.
40:10 - And then maybe our last migration deletes, deletes a table.
40:16 - Okay, those are all up migrations.
40:20 - And in theory, the latest running or the current running version of our application, we'll
40:27 - just use the latest version of the up migrations.
40:31 - In other words, it will have run every single up migration in order to arrive at kind of
40:37 - the final state of the database, the one that's running in production.
40:41 - Now a down migration, a down migration is really just used to roll back changes in the
40:48 - case of emergency or in the case that something goes wrong.
40:52 - So you don't plan to use your down migrations.
40:55 - You just kind of have them as a backup.
40:58 - And frankly, this is why at the very beginning of the video, I talked about how people talk
41:01 - about great migrations, but oftentimes they don't employ them.
41:05 - Not every company has great plans for down migrations, just to speak frankly, it's more
41:12 - robust to have a great down migration so that you can roll up your database and roll down
41:16 - your database, bring it forward and backward in time.
41:19 - But it's a lot of work, right?
41:20 - So you won't necessarily always see teams that have fantastic down migrations, but let's
41:26 - just talk about what they'd look like.
41:27 - So a down migration is very simply just the opposite of its kind of related up migration.
41:33 - So when you add a new table, you might also log a down migration that deletes that same
41:38 - table.
41:40 - So delete table, here we'd have add column, right?
41:45 - We're just doing the inverse of the equivalent up migration.
41:49 - The third down migration would delete a table again, delete table.
41:56 - The fourth would rename the column back to whatever it was, right?
42:01 - It would invert this up migration.
42:04 - And then finally here, we would have an add table command.
42:10 - And that's a five.
42:11 - Why did I write six?
42:12 - There we go.
42:15 - Okay.
42:16 - So the theory is I can go all the way up to the latest version by running these up migrations
42:20 - in order.
42:21 - And if I need to go back a version, I can just run the equivalent down migration, right?
42:26 - So I get up to the latest and then I say, oh crap, I need to roll back to the last version
42:31 - of my database.
42:32 - I can just run this down migration number five to re-add that table that I just deleted.
42:39 - So as we just talked about, database migrations can be pretty dangerous.
42:43 - They tend to be some of the more dangerous things that you do when working with databases.
42:48 - Like with all web development, the closer you get to the data, the more careful you
42:53 - have to be, right?
42:54 - Bugs that you push to production are generally pretty easy to revert and get the right code
43:00 - pushed out to users and get the bug fixed.
43:02 - When you mess up data, sometimes it can be harder to revert those changes.
43:06 - So you always have to be more careful when you're working with kind of the persisted
43:10 - data that sticks around in your database because sometimes just changing the code back to what
43:15 - it was won't necessarily revert the state of the file system in the database.
43:21 - This is a pretty solid meme regarding production databases.
43:25 - I've definitely been the dog in this situation.
43:27 - You don't want to be the dev that alters the production database and brings the site down.
43:31 - It's actually, it's not fine.
43:34 - Moving on.
43:35 - The question associated with this first lesson about database migration says, which of the
43:40 - following statements about migrations is false?
43:44 - So first one is you can be fast and loose when writing migrations.
43:47 - A bad migration is easy to fix.
43:50 - That is false.
43:51 - I'm going to read the rest of them just to make sure nothing else is even worse.
43:56 - Well written migrations are reversible.
43:58 - That's generally true, right?
43:59 - You can go up and you can go down.
44:03 - That doesn't necessarily mean you always want to be doing that, but they are reversible.
44:09 - A good migration takes into account any systems that rely on the existing schema.
44:14 - That is true.
44:15 - You need to make sure you don't have any active code that's relying on an old version of the
44:19 - database.
44:20 - Migrations are incremental changes made to a database.
44:22 - That is true.
44:23 - Okay, cool.
44:24 - So it is this one.
44:25 - You should not be fast and loose with migrations.
44:26 - They are not easy to fix if you get them wrong.
44:30 - The next question is will database migrations often be coupled with application code updates?
44:35 - And that is generally speaking true, right?
44:39 - You want to roll the database forward to a new version along with the new code that uses
44:44 - that new schema.
44:47 - The next question says why are good migrations written in a reversible manner?
44:51 - And the answers are they are not so that if something goes wrong, the changes can be rolled
44:55 - back or because you should always roll back changes before applying new ones.
45:01 - Well they are.
45:03 - Good migrations are written in a reversible manner, so it's not the first one.
45:07 - You don't always need to roll back changes before applying new ones.
45:10 - That's not how migrations work.
45:11 - Usually you'll add one new incremental migration and just roll that one forward.
45:16 - The middle one, so that if something goes wrong, the changes can be rolled back, that
45:20 - is the real reason.
45:22 - It's important to understand though that just by rolling back the schema changes doesn't
45:27 - necessarily mean you've fixed the data.
45:31 - So it just kind of depends on what quote unquote went wrong, but at least when you have good
45:37 - down migrations, you can bring the schema back to where it's supposed to be.
45:41 - So it's going to be that middle one.
45:42 - So we've talked about this a little bit before, but when you're writing reversible migrations,
45:46 - the term up and down migrations really are used to refer to kind of the chronology.
45:51 - So you'll put every new change to the database schema in subsequent up migrations, right?
45:57 - So your first up migration might create a new table, the next one might add a column,
46:01 - et cetera, et cetera.
46:02 - And every down migration has one associated up migration.
46:07 - Okay.
46:08 - Our assignment here where we'll be practicing with some migrations is to add additional
46:12 - columns to the transactions table.
46:13 - We want to know whether or not the transaction was successfully completed between two users.
46:17 - We also want to know, or we also want our database to track the type of transactions.
46:23 - So our transactions table looks like this at the moment, okay?
46:28 - Complete the up migration, complete the following up migration.
46:32 - Add the Boolean was successful column to the transactions table, and then add the text
46:39 - transaction type column to the transactions table.
46:41 - Okay, cool.
46:42 - So we'll be adding two columns, alter table transactions.
46:51 - Add column was successful Boolean, and alter table transactions.
47:06 - Add column transaction type, cool.
47:15 - Let's go ahead and take a look at that was successful Boolean transaction type text looks
47:21 - good to me.
47:23 - Let's talk about some data types.
47:25 - So as I've mentioned before, we're actually using SQL lite in this course.
47:29 - And the data types that are available to you kind of do depend on the specific database
47:34 - engine that you use it, right?
47:35 - So we're using SQL lite.
47:37 - And so you'll see types like null, which means nothing's there.
47:41 - And actually that is pretty ubiquitous.
47:43 - Basically every SQL database I've ever worked with supports null values.
47:49 - You've got integer types, which are, you know, all numbers that can also be negative, right?
47:56 - So negative one, negative two, zero, one, two, three, four, etc, signed integers, reels,
48:02 - this is your equivalent of like a floating point value or a double, depending on what
48:07 - programming language you're coming from, but basically numbers with a fractional part.
48:12 - You've got text fields, and then blobs, which are basically just like big blobs of binary
48:17 - data.
48:20 - And then the other thing to keep in mind when working with SQL lite is just that Boolean
48:24 - values false and true.
48:26 - You can use the kind of keywords false and true in your SQL, but when you get the data
48:32 - back, it will be represented as ones and zeros.
48:36 - I think the only other thing really worth pointing out at this point is that the text
48:42 - field is supported by most other large databases, think, you know, Postgres, MySQL, but they
48:48 - also have an additional type of text field called a varchar.
48:52 - And you would typically use a varchar if you know exactly how long your text field is going
48:57 - to be.
48:58 - Like say, you know, it's going to be 36 characters long.
49:01 - Like maybe you're storing, I don't know, password hashes or emails, and you know that there's
49:05 - a maximum length of emails.
49:07 - And the reason you would do that usually is for performance reasons.
49:09 - If you can tell the database, hey, this field is never going to store data larger than 36
49:14 - characters, then the database can make certain optimizations to keep the database kind of
49:19 - fast in the file system, right?
49:21 - Keep your queries a little more performant.
49:23 - But SQL lite just doesn't deal with that, right?
49:25 - It's a little more loosey goosey with how it deals with data.
49:28 - And in case you're wondering why it's called a varchar, that's kind of shorthand for character
49:32 - varying, right?
49:34 - So varying amount of characters.
49:36 - But again, you would actually specify exactly how many characters when you use that type
49:40 - of column.
49:41 - So again, in this course, we'll just keep it simple, use the text type.
49:45 - So the question is, how is a true Boolean value stored and presented in SQL lite?
49:52 - And we've got the string true, the string false, one or zero.
49:56 - True is the Boolean value one.
49:59 - Next question presented as a statement says all SQL databases support the same data types
50:05 - that is false.
50:08 - Next question, what type would you use to store a user's email?
50:12 - Well, of these types, we've got integers, reels, texts, blobs, I guess technically you
50:17 - could like convert the email address to a binary number stored as a blob, or frankly
50:22 - even maybe an integer real if there's enough, if there's enough data there.
50:28 - But realistically, come on, you should be storing it as a text field if you're using
50:33 - SQL lite.
50:34 - Again, if you're using MySQL or Postgres, you might use like a varchar 36 or something
50:40 - like that.
50:46 - It's really important to understand null values in SQL because it's not necessarily the most
50:51 - intuitive thing you've probably ever encountered.
50:55 - So a null value indicates the absence of a value.
51:01 - So for example, if you have a column called username, and a row in that table has a cell
51:12 - that is the empty string, then technically that is a username of string length zero.
51:22 - And that's different than if you actually explicitly set the value of that cell to null,
51:28 - which is used to indicate that there's nothing there.
51:32 - So generally speaking, you want to prefer to use nulls rather than like empty strings
51:37 - or zeros or false in the case of a boolean value when you're trying to represent the
51:44 - fact that there's nothing here.
51:46 - It's probably worth mentioning that the idea of null in SQL is very similar to the idea
51:50 - of none if you're coming from the Python world or null if you're coming from the JavaScript
51:55 - world or mill if you're coming from the Go programming language.
52:00 - And one of the neat things we can do in SQL is actually set constraints on our database
52:05 - schema and say, we never want a specific column to be allowed to house nulls, right?
52:12 - So that protects us and says we'll never accidentally insert, for example, a user into a database
52:19 - without making sure that they have an email.
52:21 - Okay, enough about nulls and constraints, let's jump into the assignment.
52:25 - Because we didn't force any constraints on our tables when we created them earlier and
52:29 - it has allowed for null entries to make their way into our table.
52:32 - Let's take a look at our transactions table and see what those null values look like.
52:36 - Write a query to select all of the fields on all of the records of the transactions
52:40 - table.
52:41 - So select star, that's all of the columns or all of the fields, right?
52:47 - From transactions, let's go ahead and run that.
52:54 - And we can see, notice that there's a bunch of data just seemingly missing, right?
53:01 - That's because those cells have the null value in them and it looks like that's all we have
53:08 - to do for this assignment.
53:09 - So I'm going to go ahead and submit it.
53:10 - So we talked a little bit about constraints in the last lesson, but now we're going to
53:14 - actually use them and essentially a constraint is just a rule that enforces something about
53:20 - our schema, right?
53:21 - So again, for example, if we have a user's table and we want to make sure that we never
53:25 - accidentally insert a user into that table without ensuring that they have a valid email
53:30 - address, we could add a not null constraint on the email column.
53:35 - Now how do we actually define a constraint?
53:38 - So the constraint just comes after the type in, for example, a create table statement.
53:43 - So ID is the name of the column and then we have integer, the type, and then the constraint,
53:48 - right?
53:49 - So for the ID, there's a primary key constraint, which we'll talk more about later.
53:53 - We've got a unique constraint on the name.
53:55 - Again, we'll talk about that one later.
53:57 - And then here you'll see the not null constraint that we're putting on the title.
54:01 - Okay, let's jump into the assignment.
54:03 - It says, thankfully all of the tables we've created for cache palette to this point have
54:06 - been for testing purposes.
54:07 - Now that we have a better understanding of constraints, let's rebuild our database with
54:10 - the proper constraints and tables, create the user's table with the following fields
54:14 - and constraints.
54:16 - So we're going to need a create table statement table is going to be called users first field
54:22 - is ID.
54:23 - It's an integer type and the constraint is going to be primary key really quickly.
54:30 - Let's just talk about what the primary key constraint means.
54:33 - So a the primary key constraint means that ID is going to need to be unique for every
54:39 - new row.
54:40 - So if I add a user with ID one, and then I try to add another user with ID one, then
54:47 - the database should error and get mad at me, right, because they're not unique.
54:51 - So that's the first thing.
54:52 - The second thing that the primary key constraint does is that you can only use the primary
54:57 - key once on any given table, right?
55:00 - That's why we're calling it a primary key.
55:03 - So you'll most often see primary keys on some sort of ID column.
55:09 - One last thing worth mentioning that the primary key constraint does is that it is also it
55:14 - doubles as a not null constraint.
55:16 - So you can almost kind of think of a primary key constraint as both a unique constraint
55:21 - and a not null constraint.
55:24 - So we want to make sure that an ID is present on every single user record in this case.
55:29 - Moving on, we've got a name field, it's going to be text and it's just going to have a not
55:34 - null constraint.
55:35 - Right?
55:36 - So keep in mind, that means the name field can be the same on different rows, right?
55:41 - We can have two users with the same name, not a problem.
55:45 - We just can't have it missing, right?
55:47 - In this case.
55:48 - Okay.
55:49 - Next we've got age.
55:50 - It's an integer, integer, see if I can spell.
55:53 - It's also going to be not null.
55:54 - We want to make sure we've logged an age for everyone.
55:57 - Next we've got a country code.
55:58 - We want to know what country our users are living in.
56:02 - That'll be an integer.
56:03 - Oh, no.
56:04 - Excuse me.
56:05 - It's an age and it will be not null.
56:08 - Next we've got a username, also text.
56:12 - In this case it's going to be unique.
56:14 - Now the primary difference between unique and primary key is that A, you can use unique,
56:21 - you can use a unique constraint on multiple columns, so you won't just have one unique
56:25 - column.
56:27 - And also unique columns can typically be nulled.
56:30 - So that's not necessarily a problem.
56:33 - All right, I should capitalize this.
56:36 - Use proper conventions, so unique.
56:40 - Next we'll need a password, text, not null, and is admin going to be a boolean with no
56:50 - constraints on that one.
56:54 - Finished up with a semicolon.
56:55 - Let's go ahead and run that, see what we get.
56:59 - Sequelogic error near closing parenthesis.
57:01 - Ah, I have a trailing comma here that I do not need, run it again.
57:06 - Cool.
57:07 - So we can see the names of all the columns, we can see the types, and we've got, you can
57:12 - see the constraint here of whether it's not null, you can see the primary key there.
57:17 - This is looking good to me, I'm going to go ahead and submit it.
57:21 - So I already kind of did a spoiler of this exercise, but I'll go ahead and just kind
57:25 - of give you the rigmarole again.
57:27 - A primary key is a constraint that is effectively adds a not null, right, so you can't have
57:33 - null primary keys, you can't have duplicates, so they're effectively unique, and you can
57:37 - only have one primary key on a table.
57:40 - And most of the time, you'll see this a lot, especially in backend web development, most
57:44 - of the time you'll have an ID column on a database, and that column will be the primary
57:50 - key.
57:51 - Sometimes you might be tempted as a web developer to make a column like email the primary key,
57:56 - right, thinking to yourself, well, we don't allow any two users in our database to use
58:01 - the same email, so we might as well just make it the primary key and kind of use it as an
58:05 - ID.
58:06 - I would definitely recommend against this.
58:09 - It's definitely best practice to have a specific column called ID that is used as the identifier
58:16 - for that row in the database.
58:19 - And the main reason for this is sometimes business logic changes, right, maybe in the
58:25 - future you will allow users to have the same email address, and if you've been using that
58:31 - email address as a unique identifier all over the place in your code base or in your systems,
58:35 - it's really hard to undo that change.
58:38 - So just coming right out of the gate with, you know, we're going to put a unique identifier
58:42 - on every single row, and that's never going to change, that can save you a lot of hassle
58:47 - in the future.
58:48 - So let's hop down into the assignment.
58:49 - It says run the code and notice there's a bug, okay, let's run it.
58:54 - Constraint failed.
58:55 - Unique constraint failed.
58:56 - Users dot ID.
58:57 - All right, there's a violation of a primary key constraint on the ID column.
59:01 - Fix the data that's being inserted.
59:03 - When working with integers IDs, it's best practice to increment the ID by one for each
59:07 - successive insert.
59:09 - Follow this convention when fixing the bug.
59:10 - Okay, so if I look at this code, I can see there's two inserts happening, and it looks
59:16 - like the first insert is inserting a value of zero for the ID, and the next one is also
59:23 - using a value of zero.
59:25 - So to fix this bug, I should be able to just change this to a one.
59:29 - Cool.
59:31 - Now we've got two rows in our database.
59:32 - First one with ID zero, second with ID one, going to submit that.
59:37 - Next we've got foreign keys, right?
59:39 - So we just talked about primary keys, which are an ID on an individual table that kind
59:43 - of identifies every row in that table.
59:47 - A foreign key is just a key in a table that references the ID of another table.
59:55 - So it's really what makes databases relational, right?
59:58 - This is how we relate data in one table to data in another table.
60:03 - Now you don't technically need to add a foreign key constraint on a field in a table to make
60:10 - it a foreign key, right?
60:12 - Remember a foreign key kind of just references an ID in another table, right?
60:15 - So if I have a user's table and there's a user in there with ID four, and then I have
60:20 - my transactions table and it has a column called, you know, user underscore ID with
60:27 - an ID four, then it's, you could argue it's, it's referencing that other table, right?
60:31 - Just kind of inherently, however, there is an explicit foreign key constraint that we
60:37 - can add to fields.
60:38 - You can see that syntax right here.
60:40 - And the reason you would use that constraint is to ensure that when you're referencing
60:47 - a specific foreign key or I guess in your table, it's a foreign key in the table that
60:53 - you're referencing, it's, it's that primary key.
60:56 - But what it does is it ensures that that key actually exists in the other table, right?
61:01 - So when I create a transaction, say with user ID four, right?
61:07 - So my foreign key is a primary key of my user.
61:12 - So this transaction is for user number four, that foreign key constraint will make sure
61:18 - that in the user's table, there actually is a user with ID four.
61:22 - And if there isn't, then it will throw an error, right?
61:25 - So it's a way to make sure that my relationships actually exist in my database.
61:29 - This is one of those things that's kind of hard to understand in the abstract.
61:32 - So let's take a look at this example.
61:34 - So let's say we have a department's table.
61:37 - And each department has an ID, which is its primary key, right?
61:41 - So something identifying each individual department, and then it's got a name for the department.
61:46 - Great.
61:47 - And then let's say we have another table employees.
61:50 - Each employee also has its own ID, right?
61:53 - So keep in mind, we've got a primary key for both tables.
61:57 - Now employees, of course, can belong to departments.
62:01 - So we're going to store a department ID on the employee's table, right?
62:07 - This will tell us which department the employee is in.
62:11 - This is referencing the other table.
62:13 - Now, this is a foreign key, right?
62:15 - Because it's referencing the primary key of another table, but we're also going to add
62:19 - a constraint called foreign key departments in this case, right?
62:24 - We just name our constraint, technically, whatever we want, but it's nice to be descriptive.
62:28 - So foreign key departments.
62:30 - It's going to be a foreign key on our department ID field, referencing the department's table
62:39 - and the ID column from that table, right?
62:43 - So by adding this constraint, if we try to create a new employee in a department that
62:49 - doesn't exist, the constraint will come into effect and give us an error.
62:53 - Let's hop down into the assignment.
62:54 - It says our users table stores the country our users are from in a country code field.
62:59 - So we've got country code on the users table.
63:02 - We need some additional data about countries, like their name, but we don't want to bloat
63:06 - our users table with all of that country data.
63:09 - That makes sense, right?
63:10 - We want to keep country data kind of in its own table.
63:12 - The locations team at Cashpal has created a countries table, and we can link a user
63:17 - to their country by setting a foreign key in the users table.
63:20 - Take a look at the code.
63:22 - There's an issue with the insert statements again.
63:24 - Fix up the data so no foreign key constraints are violated.
63:28 - You'll need to reference the setup code below.
63:29 - Okay, so I'm going to take a look at this setup code.
63:33 - Looks like we're creating a users table with that country code, and then it looks like
63:38 - some data is being inserted into the countries table.
63:43 - Oh, and here's the create table statement for the countries table.
63:47 - So it's just got a code and a name.
63:50 - Okay, and then we'll have United States that's in the countries table, and we also have India
63:55 - codes US and IN.
63:57 - So let's go ahead and run the code in its current state to see what happens.
64:00 - Constraint failed.
64:01 - Foreign key constraint failed.
64:02 - Okay, so this first user is going to reference US.
64:07 - That should work, right?
64:08 - We have an ID of US here.
64:13 - That's fine, but here, ah, so we're inserting again into the users table, but here it looks
64:20 - like this was mistyped, right?
64:21 - It's supposed to reference IN as the country code for India, but it's got IND.
64:27 - So just removing that D should fix this up.
64:31 - There we go.
64:33 - So I've used this word schema a few times so far in this course, and I really just want
64:37 - to talk about what it means.
64:39 - Basically a database schema is just the shape that you're using to define your data, right?
64:47 - So for example, the number of tables in your database is part of your schema.
64:52 - The names of those tables is part of the schema.
64:54 - The names and data types of all of the columns in your tables, that's all part of your schema.
65:00 - So really a schema just tells you how is data organized within this database.
65:05 - Now it's important to point out there is no perfect database schema for your app.
65:10 - There's lots of different ways that you could model the data that makes your application
65:15 - run.
65:16 - You could pick one and there are a few rules of thumb for picking a good one, which of
65:21 - course we'll talk about in just a second.
65:23 - So get your database schema as best you can to model what's going on in your application.
65:31 - And honestly, my rule of thumb is try to keep it as simple as you possibly can while accurately
65:39 - modeling relationships.
65:41 - If you keep it simple, it's always easy to add complexity that adds functionality later.
65:47 - Whereas if you add a bunch of complexity up front, oftentimes it can be harder to strip
65:52 - back that complexity into simplicity down the road.
65:56 - So to start getting specific, we can use cash pal as an example.
66:00 - It says one very important decision that needs to be made is to decide which table will store
66:04 - a user's balance.
66:06 - As you can imagine, ensuring our data is accurate when dealing with money is super important.
66:11 - We want to be able to keep track of a user's balance, see the historic balance at any point
66:17 - in the past, and see a log of which transactions changed the balance over time, right?
66:24 - So to be able to essentially audit the balance as it changes, right?
66:28 - People are curious as to all of the transactions they've had in the past.
66:32 - So we need to make sure that we don't like overwrite that data or lose that data.
66:36 - There are many ways to approach this problem.
66:37 - For our first attempt, let's try the simplest schema that fulfills our project's needs.
66:41 - Again, we're always going to try to opt for simplicity first.
66:45 - So jumping into the assignment, it says the architecture team at cash palace decided on
66:48 - a single transactions table.
66:50 - The transactions table stores individual transactions, and we can keep track of the current balance
66:54 - on each transaction record.
66:55 - If we want the current balance, we just look at the most recent transaction.
66:58 - So create the transactions table with the following fields and constraints.
67:02 - All right, create, table, transactions, going to be an ID, integer, primary key, sender
67:17 - ID, integer, recipient ID, integer, memo, text, not null, mount, integer, not null.
67:37 - And finally, the balance, integer, not null.
67:43 - Now you might be wondering, I don't think I've addressed this yet, why we're using
67:47 - integers here for amount and balance instead of reals, which are like floating point numbers.
67:53 - And the reason is in financial applications, it's actually very common to store money as
67:59 - an integer and just store it in the units of like the smaller units.
68:05 - So for example, rather than storing our money in dollars and storing like $5.67, we store
68:13 - it as pennies.
68:15 - So when you have $5, we just store 500, right?
68:18 - You have 500 pennies.
68:20 - And the reason for that is floating point arithmetic has like rounding issues in computation,
68:28 - whereas integers don't have those issues.
68:30 - So if we just use integers, keep it simple, then we don't have any of those potential
68:36 - data integrity issues that you get with floating point numbers.
68:38 - I'm not going to go super into detail on all the issues you can get with floating point
68:41 - numbers.
68:42 - You can definitely go look that up.
68:44 - Let's know that that's why you'll see integers very often used in financial applications.
68:50 - Okay, now that we've written our create table statement, let me go ahead and run that.
68:56 - See if we get what we expect.
68:59 - This looks good to me, I'm going to go ahead and submit.
69:01 - So we've been using the term relational quite a bit throughout this course, but we haven't
69:05 - really talked about what it means.
69:07 - A relational database is just a type of database that stores data that can be related to other
69:12 - pieces of data, right?
69:14 - So in the case of Twitter, a user is related to their tweets, right?
69:18 - And relational databases are just databases that keep that in mind, right?
69:23 - They make it really easy to relate different entities between tables.
69:27 - So some properties of relational databases are data is typically represented in tables,
69:32 - right?
69:33 - That's how we've been doing it throughout this course so far.
69:35 - Each table has columns or fields that hold attributes related to that record, right?
69:40 - So in this image, for example, we've got a students table, and then there's two columns,
69:44 - the ID column and the name column or the ID field and the name field.
69:49 - Column is the more accurate database term, but you'll hear field used just because fields
69:54 - are often used in kind of more traditional programming, which is like Python or Go or
69:58 - JavaScript.
70:00 - Each row or entry in the table is called a record, right?
70:02 - So this first record in the student courses table, for example, has student ID one and
70:07 - course ID one, and then typically each record has a unique ID called the primary key.
70:12 - Now that's not always the case.
70:15 - That's why I say typically, so maybe nine times out of 10, you'll have an ID column
70:21 - on a table so that it's really easy to identify each unique record in the table.
70:28 - So let's answer this question.
70:30 - It says, how many courses is Sam enrolled in?
70:33 - So we've got our relational database here, and we can see that Sam is ID number one in
70:40 - the students table, right?
70:41 - So we're trying to figure out how many courses he's enrolled in.
70:42 - Well, let's look up the student courses table.
70:45 - We can see that student ID one, which is Sam, right?
70:48 - Because we have that relationship over here.
70:51 - We can see he's enrolled in three different courses, right?
70:55 - We have three rows in the student courses table.
71:00 - He's enrolled in course one, two, and three.
71:03 - So the answer is going to be three there.
71:06 - The next question is, how many students are in the MongoDB course?
71:09 - Okay, so this time I'm going to start at the courses table, look up the MongoDB course.
71:14 - I can see it here.
71:15 - It's got an ID of three.
71:17 - So looking at the student courses table, I can see there's three rows that reference
71:23 - the MongoDB course, right, with ID three.
71:27 - And I see students one, two, and three.
71:32 - So all three students are in the MongoDB course.
71:34 - So going to be three again.
71:37 - So we know what a relational database looks like, right?
71:40 - With tables and keys that kind of point to each other and reference each other to build
71:44 - relationships.
71:45 - The question is, what's a non-relational database?
71:48 - And I mean, most simply put, a non-relational database is just a database that doesn't support
71:53 - those kinds of complex relationships between data.
71:56 - And typically, when we're talking about like no SQL non-relational databases, we're talking
72:02 - about databases that nest data.
72:05 - So rather than using keys to reference other data and keeping everything kind of nice and
72:11 - tight and normalized, which is a concept that we'll talk about more later, they just kind
72:16 - of lazily nest the data within itself, which does have benefits.
72:23 - So I'm not trying to say that non-relational databases are always a bad thing, but it's
72:27 - important to understand some of the trade-offs.
72:29 - So to oversimplify it, you can kind of think of a non-relational database or most non-relational
72:33 - databases as just giant blobs of JSON data, right?
72:38 - JavaScript's object notation.
72:40 - For example, if a user can have multiple courses, you might just add all of the courses to the
72:44 - user record.
72:45 - So for example, in this database, we've got one kind of top level JSON object, and then
72:51 - we have this key users, which holds an array or a list, a list of things, right?
72:58 - And in this case, we've got one user with ID zero, the name is Elon, and then we've
73:04 - got a nested list or nested array of courses.
73:09 - So we're actually storing each course on top of each user record, which means if we were
73:15 - to add another user to this array, right, like we add Bob, for example, and we want
73:22 - to put Bob in the biology class, we would actually need to store a copy of the biology
73:29 - class's information under the Bob record, right?
73:33 - So now instead of having one course and one user and having them reference each other,
73:39 - we have to have a user and their copy of the course, right?
73:45 - So it kind of, in some instances, creates data redundancy in the system.
73:50 - So here's a visual example, right?
73:52 - We've got in the relational database, we have a posts table and a comments table.
73:57 - And the posts will reference the comments or actually the comments will reference the
74:02 - original post.
74:03 - So every time you have a new comment added to the system, it will just reference the
74:07 - original post.
74:09 - Whereas in a non relational database, what you'd actually do is just have one posts table
74:14 - or whatever the database happens to call the kind of equivalent idea of a table and you
74:20 - just nest all of the individual comments within each post.
74:26 - So in this case, it probably is fine, right?
74:30 - Because a comment can't really be a comment on two posts, most likely.
74:34 - But it does get to be more of a problem when you do have those many to many relationships
74:39 - that relational databases make really easy.
74:41 - So the question says, relational databases typically blank duplicate data, while non
74:47 - relational databases often blank duplicate data.
74:50 - So do duplicate data or do not duplicate data.
74:54 - And typically relational databases are very good about not duplicating data.
74:59 - So they do not duplicate data.
75:00 - Whereas non relational databases or no SQL databases kind of are okay with duplicating
75:07 - some data, again, usually with some sort of trade off and we'll talk about some of those
75:11 - trade offs later.
75:12 - The next question is non relational databases connect similar entities by using blank got
75:18 - nested data, keys, lover and concurrency.
75:21 - And the answer is nested data.
75:25 - And I will point out that this question should probably be a little more loose and say typically
75:32 - connect similar entities by using nested data because there are no SQL databases that do
75:36 - allow for more complex.
75:41 - Well I should say there there are other alternatives aside from just nesting data.
75:45 - In fact, some non relational databases are so simple that you couldn't even nest data
75:52 - in them if you wanted to write maybe they're just very simple key value stores.
75:56 - So just kind of keep that in mind.
76:02 - Let's talk about CRUD or C R U D which stands for create, read, update and delete.
76:08 - These four operations really are the bread and butter of all things data, all things
76:13 - databases, right?
76:15 - And HTTP and CRUD map very well to one another.
76:21 - So your typical backend web server in like a very standard web application will often
76:27 - be referred to as a CRUD server because it very simply maps HTTP requests to database
76:35 - operations.
76:36 - So for example, an HTTP POST request will very often create a new record in a database.
76:43 - Whereas an HTTP GET request will perform a database read, an HTTP PUT will update something
76:49 - and an HTTP delete will delete something.
76:52 - So in the simplest web applications, again, your server is really just reading an HTTP
76:58 - request and kind of deciding what it needs to do to the database.
77:03 - Just need to create, read, update or delete.
77:06 - So moving on to the assignment, it says we've created a table for you called CRUD.
77:10 - It's a toy table that we're using for interview practice at cashpal.
77:14 - Determine which SQL command can be used for a read operation and use it to read all of
77:18 - the fields in all of the records in the CRUD table.
77:21 - Cool.
77:22 - So this is just going to be a select star from CRUD.
77:27 - Let's run that.
77:29 - Cool.
77:30 - And you can see here, it looks like the table is filled with those mappings of HTTP methods
77:37 - to in this case, actually database keywords.
77:41 - So read, select.
77:42 - Yeah, makes sense.
77:43 - I'm going to go ahead and submit that.
77:46 - We've done a lot of selecting so far and we've done a lot with schemas, but now it's time
77:51 - to look at how we can insert data into a database.
77:54 - So there is in fact an insert statement and it looks like this.
78:00 - So insert into table name followed by a list of fields and then the values that we want
78:10 - to insert into those fields or insert into those columns.
78:13 - The assignment says, let's start manually adding some of the records to our users table.
78:17 - Take a look at the create table statement in the setup code below for the users table
78:20 - structure and use that information to insert the following records into the table.
78:23 - Okay.
78:24 - So we're going to be inserting record one and record two.
78:26 - Let's take a look at that schema here.
78:29 - So we've got this create table users.
78:31 - Okay.
78:32 - We can see what columns are available to us.
78:34 - It looks like we need to write our insert statements here.
78:36 - So insert into users.
78:44 - Then we need to do the names of the columns we want to insert into, I'll actually put
78:51 - this on a new line.
78:53 - So it's going to be ID, name, age, country, code, username, password, and is admin.
79:07 - And it's going to be values and then all the actual values we want to add, so values.
79:21 - And one, David 34, us, David dev, the username, insert practice is the password and is admin
79:41 - is false.
79:43 - And we ended up all with a semi-colon.
79:45 - Oh, okay.
79:48 - So just to be clear, order matters here, right?
79:53 - So the first key I'm passing into this insert statement is the ID column, which means the
79:59 - first value needs to be the ID value.
80:03 - Make sense?
80:05 - Cool.
80:06 - And we have one more record to insert.
80:11 - The good news is all of column names are the same.
80:16 - Now we just need to change them with values.
80:18 - So it's going to be ID two, name, Samantha, age 29.
80:25 - Looks like she's in Brazil, username, Sammy 93, password, adding records, and is admin
80:34 - is still false.
80:35 - Cool.
80:36 - Go ahead and run that.
80:38 - Seems to have worked.
80:39 - I'm going to go ahead and submit.
80:42 - Let's talk about how data flows through your typical web application.
80:47 - So take a look at this diagram here.
80:51 - We've got the front end of our web application.
80:54 - In this case, looks like it's a mobile device or a mobile app.
80:58 - We have the backend web server, which is what we as backend developers are primarily responsible
81:04 - for coding up.
81:06 - And then we've got the database, right?
81:09 - Maybe SQL light postgres, my SQL, whatever.
81:13 - And the way that these three things typically communicate with each other is that the front
81:17 - end communicates with the backend over HTTP.
81:20 - So HTTP get requests, post requests, but delete, whatever, right?
81:26 - And the backend server commit communicates with the database itself using SQL.
81:31 - By the way, I want to point out if you've gotten this far in the course and you're hearing
81:35 - me say HTTP post, get, put, whatever, and you're not understanding what I'm talking
81:40 - about, I do have an HTTP course that I'd recommend you take before this course.
81:45 - So you might want to pause your progress on this course, go look up my HTTP course, check
81:50 - that out, and then come back.
81:51 - So just so you're aware, I'm kind of assuming that you understand at least the basics of
81:56 - HTTP requests as they relate to web development.
82:00 - Cool.
82:01 - So the front end processes some data from user input, maybe a form is submitted, right?
82:05 - Maybe a button is clicked, whatever.
82:07 - Front end sends that data to the backend via an HTTP request.
82:11 - And then the HTTP request is kind of converted into a SQL statement and the backend server
82:16 - sends that to the database, right?
82:18 - So let's take the example of a new user is registering.
82:22 - So the new user enters an email, a password, clicks a button.
82:25 - The front end sends a post request to the database with the new username and password.
82:31 - The excuse me, let me, let me rewind that just a second.
82:34 - The front end sends a post request to the web server, an HTTP post request to the web
82:40 - server with a username and password.
82:42 - The server takes that username and password from the post request, converts it into an
82:47 - SQL statement and executes the SQL statement against the database, right?
82:51 - Probably inserting a user record.
82:54 - If that operation succeeds, then the HTTP post request will be responded to by the web
82:59 - server and the front end will get a happy 200 okay response code.
83:04 - So the question here is a front end typically communicates with the database directly to
83:09 - add new records.
83:10 - And then the answers are false and true.
83:12 - No, it is unusual for a front end to interact directly with a backend database.
83:18 - There are exceptions here.
83:21 - It can be the case that the front end application is actually running a database locally, right?
83:26 - For example, SQL light is very often used as kind of an embedded database.
83:32 - But that doesn't work if your application wants to store data on the cloud, for example,
83:38 - right?
83:39 - That would be like a local only application that would do something like that.
83:41 - So in your typical kind of web application architecture where data is stored on the cloud
83:48 - and kind of travels across devices, the front end won't often, will not often communicate
83:55 - directly to a database.
83:58 - So this is false.
84:02 - The next question is the create in CRUD maps to which SQL statement and HTTP method.
84:08 - And it's going to be, well, in SQL, it's an insert, right?
84:11 - That will create a record.
84:13 - And in HTTP, that would typically be a post.
84:17 - Let's talk about the auto increment keyword.
84:18 - So the auto increment keyword in SQL is a feature supported by most SQL databases that
84:24 - effectively allows you to automatically increment the values in a given column.
84:31 - So for example, this is most common with an ID column.
84:34 - So you have an ID column that is integer primary keys, right?
84:39 - So every new, say user in your database, you want them to have a new ID and you want to
84:46 - increment by one every time.
84:47 - So let's just say that you've got this user's table, it's got its ID column, and you've
84:51 - got four records in the database and they have IDs one, two, three, and four.
84:57 - What the auto increment keyword allows you to do is when you insert that fifth record,
85:01 - you actually don't have to specify in your SQL statement that its ID is going to be five.
85:07 - You can just say, hey, please auto increment this column, and the database will automatically
85:12 - check and say, oh, I'm already using IDs, you know, one through four.
85:17 - So this new record is going to have ID five.
85:21 - That's useful because it means when you insert a new record, you don't first have to do a
85:25 - database read to check which IDs are available or which ID you should use next.
85:31 - Now quickly, before we jump into the assignment, I do want to call out that while this paradigm
85:36 - of using an integer ID that auto increments is fairly common, you'll also see a lot of
85:43 - UUIDs out there in the world.
85:46 - And to summarize, a UUID is basically a randomly generated ID, right?
85:50 - So instead of every record having an ID that just increments by one number, you'll be generating
85:55 - a very large random number as your ID for every record.
85:59 - And again, the nice thing about that is you don't have to do a read before you do an insert
86:04 - because you can just kind of generate a huge number randomly and be fairly confident that
86:10 - and when I say fairly, I mean extremely, like it's essentially mathematically, it's nearly
86:15 - impossible to have duplicate UUIDs because there's just so many possible combinations.
86:20 - But that is something you'll see out in the wild.
86:23 - We won't be doing them here.
86:25 - If you want to go Google UUIDs, please do so.
86:28 - They're very interesting.
86:30 - Those are kind of the two main ways that I've seen primary key IDs handled in production
86:37 - databases.
86:38 - So jumping into the assignment, it says, let's add some more records, but allow the database
86:41 - to automatically increment the ID field, add the following records to the database.
86:44 - Okay.
86:45 - Straightforward.
86:46 - And the interesting thing to note here is that it says SQL lite or in SQL lite, an integer
86:53 - ID field.
86:54 - So if its name is ID and it has a primary key constraint, it will automatically auto
87:00 - increment by default.
87:02 - So in some databases, you actually do need to like specify auto increment in the table
87:07 - creation, but you can see down here in the setup code, there's actually no auto increment
87:14 - keyword added to the ID column.
87:16 - SQL lite is just doing it by default.
87:19 - So go ahead and get these records inserted.
87:24 - This is the state of the database at the moment.
87:27 - Right?
87:28 - You can see in the setup code, it's inserting a bunch of users ahead of time.
87:35 - We need to write our own insert statement.
87:37 - So insert into users and we've got name, age, country code, username, password is admin.
87:53 - Again, we don't need to use the ID column because it will be done automatically for
87:58 - us.
87:59 - So let's use lance 20 us, there's a username, there's a password and then is admin is false.
88:22 - Need another one of these.
88:26 - This time we've got Tiffany 28, she's in the US username, auto increments, keeping, keep
88:39 - in mind auto increment is just, just happens to be Tiffany's password.
88:43 - And she is an admin and go ahead and run that well, and you can see that it automatically
88:50 - used ID seven and eight.
88:52 - This looks good to me.
88:54 - Now at this point in the course, you might be wondering, gee, this seems really inconvenient.
89:00 - Every time I need to insert something into my web applications database, I have to go
89:04 - manually write some SQL to do it.
89:06 - Uh, no, that's, that's not how it works at all.
89:09 - When you're sort of just poking around through your applications database, maybe trying to
89:13 - figure out what the schema looks like, maybe just doing some research, trying to figure
89:17 - out, you know, how many users your applications has at that point, you will just kind of be
89:22 - manually doing SQL queries, right?
89:25 - You might have some SQL client like PG admin.
89:28 - If you're using Postgres or SQL workbench, you'll probably just be writing manual SQL
89:33 - queries connected to your database.
89:35 - When you're actually writing backend servers, you probably will not be writing one off SQL
89:41 - statements.
89:42 - Instead, what you'll be doing is writing SQL, but using kind of dynamic interpolation to
89:49 - inject values into the SQL.
89:51 - Let me, let me show you what I mean.
89:53 - So here's some go code, for example, that you, I don't want to say that you'd see this
89:59 - in production because there's actually safer ways to do this, but I think it gets the idea
90:05 - across.
90:07 - Here we've got an SQL statement, right?
90:09 - Insert into users, name, age, country code, values, and then you'll see we've got these
90:14 - dynamic placeholders percent S, percent B, percent S.
90:20 - In go, these placeholders will get replaced by whatever these values are that come afterwards.
90:29 - So the user's name, the user's age, and the user's country code.
90:34 - So this is more like what you would see in a production application, right?
90:39 - You've got some SQL, but it's being dynamically generated either by your programming language
90:46 - or by your programming framework.
90:48 - And I also just want to overstate that you probably won't see something quite this simple,
90:53 - right?
90:54 - In go, you probably won't just see fmt.sprintf.
90:57 - If you're coming from the JavaScript world, you probably won't just see a template literal
91:02 - with values injected.
91:04 - And the primary reason for that is because there's this whole area of security concerns
91:09 - called SQL injection, where basically, depending on what those dynamic values are, people can
91:15 - actually kind of hack your query and cause your query to do things that you didn't intend.
91:20 - The good news is that basically every library, any good library that allows you to connect
91:27 - to a production database should handle SQL injection for you.
91:32 - For example, in go, the standard library's database SQL package handles this for you.
91:38 - So you will see something that looks like this, but there's probably a specific method
91:45 - or function that you'll be calling that handles potential SQL injection for you.
91:50 - So the important thing to take away from all of this is just that your SQL statements will
91:57 - likely be generated dynamically in your programming language.
92:02 - So question here.
92:04 - Every time someone creates an account on boot.dev, Alan or Lane has to manually add them to the
92:09 - database by hand by writing a SQL query.
92:11 - That is false, right?
92:13 - We've automated this whole process in our backend server.
92:17 - Next question is within backend systems, SQL queries are typically blank, generated by
92:22 - code or written by hand.
92:25 - So I mean, to be fair, like this template is typically written by hand, but then the
92:30 - kind of end query that's running against the database is generated by code.
92:34 - So I'm going to go with generated by code on this one.
92:36 - It's often useful to get the count of the records in a table rather than just getting
92:41 - all of the records in a table.
92:42 - So we can use a select statement to get a count of the records.
92:46 - This can be useful when we want to know how many there are, right?
92:49 - So here's an example is SQL light, select count, which is actually a function of star
92:56 - from employees.
92:57 - This can actually be kind of weird the first time you read it, right?
93:02 - Why am I selecting a count of star or a count of wildcard?
93:07 - Well, in reality, the count function takes field names, right?
93:13 - So you can count on individual fields or individual columns, but if you just want to know the
93:19 - total number of rows, then you can just use a wildcard to say, I don't really care about
93:25 - which column I'm counting.
93:28 - So the assignment says, here's the current state of our users table.
93:32 - Cool.
93:33 - So we've got eight different users, a bunch of fields, whatever.
93:38 - It says our base, our business strategy team at cashpal wants to know how many users of
93:42 - the app we have.
93:44 - We can't use the ID number to calculate the count because user accounts can be deleted,
93:48 - right?
93:49 - So maybe one day John is deleted.
93:53 - We can't just look at the current ID because Tiffany would still have ID 8, even if we
93:59 - deleted John, right?
94:00 - We'd just be missing kind of a record for ID 3.
94:05 - So we need to use account statement to retrieve the number of records in the users table.
94:10 - Let's go ahead and write that.
94:11 - So select out star.
94:17 - And again, star is referring to column names, but I don't care.
94:21 - I'm just trying to get the total number of rows.
94:23 - I don't care, you know, whether a name is present or a name is not present, I just want
94:28 - total number of rows.
94:29 - So we'll use the wildcard.
94:30 - Let's let count star from users.
94:35 - From that, count star 8.
94:42 - So earlier we talked about how a create operation flows through the architecture of a web application.
94:47 - But now let's talk about a read.
94:50 - So again, we've got our front end, our backend server, and our database here in the diagram.
94:54 - In fact, let me grow this just a little bit.
94:58 - The first thing that happens when we want to do a read is that the mobile application
95:02 - will send probably an HTTP GET request to the server, right?
95:07 - By convention, that's a pretty common way to do it.
95:10 - At that point, the backend server will fire off a select statement to the database, right?
95:15 - What it gets back from the database are a essentially a table of rows, right?
95:20 - And it will parse that table of rows and do some sort of conversion into something that
95:26 - it can send back in the HTTP response.
95:29 - Very often it will be a JSON object.
95:33 - So that's that's pretty standard operating procedure.
95:36 - This is not how it has to work.
95:38 - This is not the only way web applications are built.
95:41 - But it is a very common convention, especially for restful APIs.
95:47 - So the question here is the HTTP method that generally corresponds with a SQL select statement
95:52 - is an HTTP blank.
95:54 - We've got patch, update, get input, and it's going to be a GET.
95:59 - Next question is which happens first, a select statement is executed, a GET request is made,
96:04 - or a JSON response is sent.
96:07 - And in this case, it's going to be a GET request is made.
96:10 - That's the very first thing that happens, right?
96:12 - We can't execute a select statement until the front end makes a GET request can't send
96:16 - a response till we get the request in the first place.
96:19 - Let's talk about the where clause.
96:21 - So you'll see the where clause all the time.
96:25 - In fact, it's actually pretty unusual to make a select statements in SQL without using a
96:31 - where clause because the where clause allows us to filter down the data.
96:35 - And unless your database only has like eight rows in it, which would be pretty crazy for
96:39 - a production database, you'll probably want to filter down your result set.
96:43 - So what does that actually look like in syntax?
96:46 - Well, here's an example.
96:48 - Select name from users where power level is over 9000, or I should say, greater than or
96:55 - equal to 9000.
96:56 - So this will return all of the rows from the users table, sorry, it will return the
97:04 - name column or the values in the name column from the users table, where the power level,
97:14 - which is a different column, right, not the name column, but the power level column is
97:18 - greater than or equal to 9000.
97:21 - So the assignment says we need to know the username of all of the users in our users
97:28 - table that have admin privileges, retrieve them.
97:33 - Let's start with something simple.
97:35 - Let's do select star from users.
97:40 - I'm going to go ahead and run this.
97:41 - And this will just allow us to see our full, our full data set, right?
97:49 - So this is just everything in the users table.
97:52 - Now, we want to filter down to just the rows, just the rows where the user has admin privileges
98:00 - or there is admin flag assets too.
98:02 - So I'm going to go ahead and say select star from users, where is admin is true.
98:09 - Go ahead and run that.
98:13 - It looks like we've properly filtered down the result set.
98:17 - The last thing is it says we just want the username.
98:20 - So I'm going to change this star username, I would expect just to get Alias and Tifaroon.
98:28 - Cool, let's submit it.
98:31 - We already know what a null value is, but now let's talk about how we can filter down
98:35 - to either just the null values or maybe ignore the null values, right?
98:41 - So there's actually two special ways to deal with null values in SQL.
98:45 - You've got the is null syntax and the is not null syntax.
98:49 - So for example, select name from users where first name is null, right?
98:53 - Or is not null in the other example.
98:57 - The assignment says the way we store transactions at cache pal is interesting.
99:01 - We store a user ID field on the transactions table.
99:05 - That user is the owner of the transaction and a user ID is never null.
99:12 - Whenever the owner of the transaction receives money, the sender ID will not be null.
99:18 - So let's think about that for a second.
99:20 - So you've got a transaction with a user ID.
99:23 - So that user owns this transaction.
99:27 - If they are the receiver of money, the sender ID will not be null because it will include
99:33 - the ID of the sender, right?
99:34 - So when the sender ID is not null, we can see who sent the kind of owner of the transaction
99:41 - the money.
99:42 - And then the opposite of that was also true.
99:44 - If the owner of the transaction is the sender, then the recipient ID will not be null because
99:50 - that ID will point to the receiver of the money.
99:53 - Start to make sense?
99:54 - All right.
99:55 - So select all of the rows from the transactions table where the owner of the transactions
100:00 - is receiving money.
100:02 - Okay.
100:03 - And I'm just going to look at the setup code.
100:06 - So transactions, we've got an ID for the transaction, user ID, recipient ID, sender ID, and amount.
100:12 - Okay.
100:13 - So select star, right?
100:15 - So select all of the rows from the transactions table where the owner of the transaction is
100:22 - receiving money.
100:24 - So select star from transactions where if they're receiving money, there needs to be
100:33 - a sender, right?
100:34 - So where sender ID is not null.
100:41 - Run that.
100:43 - Cool.
100:44 - And as we'd expect, the recipient ID on these is null because the user is the recipient.
100:51 - So let's go ahead and submit that.
100:53 - Let's talk about deleting now.
100:55 - So when a user deletes their account on Twitter or deletes a comment on a YouTube video, that
100:59 - data actually needs to be removed from those respective databases, right?
101:04 - So when you delete your tweet, we need to actually go purge it from the database, right?
101:09 - The Twitter database.
101:11 - In SQL, there is a delete statement.
101:13 - Looks like this.
101:14 - So delete from table name, and then optionally, you can say where something equals something
101:21 - or you know, where something is greater than or less than or whatever, right?
101:25 - But the point is delete from table name is kind of the different thing.
101:31 - A couple of things I want to point out here, if you just do delete from employees, that
101:38 - will delete everything in the employees database, right?
101:42 - So for example, if I just do delete from users here, everything's gone, right?
101:52 - That's like super dangerous.
101:54 - So when you're working with a production database, be very, very careful with your delete statements.
101:59 - You do not want to delete the data when you're not intentionally trying to delete the data.
102:06 - The difference between delete from users and delete from users where ID equals three is
102:15 - a huge difference.
102:16 - This will delete one user, whereas if I remove that where clause, that just says delete all
102:23 - users.
102:24 - In fact, a rule of thumb that I just personally have is anytime I'm going to run a delete
102:29 - statement against a production database, I always run it as a select statement first,
102:36 - just to make sure that I got my where clause right, right?
102:39 - Just to make sure, and I can kind of see everything that's going to be deleted by running a select
102:44 - first.
102:45 - So again, when you're working with production data, run a select, see all of the stuff that
102:50 - you're going to delete, and then just change it into a delete statement and run that.
102:55 - Okay, the assignment says, Samantha, one of our cache pal users has opted to delete her
103:00 - account and stop using our app, which of course makes us sad.
103:03 - Anyways, we need to remove her record from the database.
103:06 - So delete Samantha's record from the user table.
103:09 - This is what our users table looks like at the moment.
103:11 - So it looks like Samantha has ID two.
103:16 - Now something to point out here.
103:18 - It just so happens that we could write, we could write this SQL query, delete from users
103:29 - where name equals some man thought, okay, we could run this.
103:36 - In fact, let me run it and it works, right?
103:41 - Samantha's gone.
103:43 - There's a devious little problem with this, right?
103:47 - It's very likely that if our app is popular, that there's many Samantha's in the database.
103:54 - So this is actually a really bad query to run.
103:57 - You could potentially delete 20 different user records, all of whom are named Samantha.
104:04 - So generally speaking, if you know you just want to delete one record, use the primary
104:09 - key.
104:10 - So we're going to do where ID equals two.
104:14 - This is much, much safer.
104:17 - We're guaranteed to only delete the row we care about.
104:20 - So I'm going to go ahead and submit it in this form.
104:23 - The wisest senior developers are the first to admit that their code base is a flaming
104:29 - pile of bug ridden garbage that has somehow survived in production as long as it has.
104:36 - So because you and your team are always just one bad commit away from wiping out all of
104:41 - your customer's data, don't you think it would be smart to back up your production databases?
104:45 - So let's talk about how you would actually set up database backups or how they work is
104:50 - probably a more accurate way to put it.
104:52 - So here we've got our production database, right?
104:57 - And every day new data is being added to the production database.
105:01 - And so naturally we're concerned, right?
105:03 - We want to make sure that even if something catastrophic happens, if this database gets
105:08 - deleted, if some bad code gets pushed that wipes out all of the rows in the database,
105:11 - right, that we have a way to restore the database.
105:14 - So one very common strategy is just kind of snapshot the database, let's say daily.
105:22 - A lot of companies I've worked at kind of just do daily snapshots.
105:26 - So for example, every day at midnight, an automated task runs, right, there's some code
105:32 - running on the server that copies all of the data out of the production database and into
105:40 - a snapshot for the day.
105:42 - So we'd say prod database copy, you know, May 1st, 2023, something like that.
105:52 - And that data is going to live in cold storage somewhere.
105:58 - It's going to be very cheap.
106:00 - We're going to shove it into a flat file system.
106:02 - We don't need to be able to access this data kind of live from our application, right?
106:07 - So kind of technically speaking, this might live in something like an Amazon S3 bucket
106:12 - or a Google cloud storage, cloud storage bucket, right, so very cheap storage, the idea being
106:20 - if something goes wrong, we can always kind of restore from this backup back into our
106:27 - prod database, right?
106:29 - It's not being used live, it's just it's just a backup.
106:32 - And then of course, the next day we would take, let me change colors back.
106:38 - The next day we would take a new snapshot and name it prod database copy, May 2nd, 2023,
106:52 - right?
106:53 - You get the idea.
106:54 - We're taking snapshots daily.
106:56 - And then usually what would happen is we'd only keep the snapshots for a certain amount
107:01 - of time, right?
107:02 - We might take a snapshot every day, but only keep them around for a month.
107:06 - So once we have a month's worth of snapshots, we start deleting the old snapshots, just
107:10 - so we don't need to store all of that data forever, because that could start to get expensive.
107:15 - Now you may have already noticed there's a problem here, right?
107:17 - If we're just taking a snapshot every day, that means that we take our snapshot, more
107:23 - data is added to the database, and then something bad happens.
107:26 - If we restore from that last snapshot, we're actually going to lose whatever happened in
107:31 - the last, you know, five or six hours since that snapshot was taken.
107:35 - So like the simple way to solve this or to mitigate this would be to, instead of doing
107:41 - daily snapshots, you could do hourly snapshots, right?
107:44 - You still have the same problem, but now you have it at a smaller scale.
107:47 - You'll never lose more than say 59 minutes worth of data.
107:51 - Now it's worth pointing out that for most small companies, this snapshot at a, you know,
107:56 - hourly or kind of daily rate, um, is fine, right?
108:01 - You hopefully don't lose your production database anyways, but if you do, you're only going
108:05 - to lose a couple hours of data.
108:07 - It's probably not mission critical.
108:08 - Your business probably won't go out of business, right?
108:12 - And this is a very simple thing to set up, right?
108:15 - Most cloud providers of databases, things like Amazon RDS or Google Cloud SQL have literally
108:21 - just a button you can click to set up automated snapshots.
108:24 - So if you're working at a small company or on a small project, snapshots are probably
108:28 - the way to go.
108:29 - Let's talk about kind of a more robust option.
108:31 - Say you can't afford to lose any data.
108:34 - What you might do in that case is, I mean, you'd still have your, your prod.
108:39 - Let me, let me make this a little bit bigger.
108:42 - You'd still have your prod database, but now instead of taking hourly or daily snapshots,
108:48 - what you might do is anytime a change is enacted on the prod database, you might set up a system
108:55 - where that change is copied to some, to some append only log, append only log, right?
109:07 - So for example, if you create a record here, you would also in the append only log, log
109:17 - the fact that you created the record.
109:20 - Similarly, if you then delete a record, keep in mind, when you delete a record in the prod
109:28 - database, it's just gone, poof, right?
109:30 - But in the append only log, you would just log that you deleted a record.
109:35 - So log that record was deleted.
109:40 - The difference is in the append only log, right, we still have, we still have the log
109:49 - of the record being created.
109:50 - So we could kind of go back and replay that record creation event if we need to.
109:56 - So this kind of a system is frankly a bit more complex to set up, a bit more expensive
110:01 - to set up, but can give us a little more granularity and robustness in the sense that we won't
110:07 - ever lose any real time data.
110:10 - And I quickly just want to reiterate the fact that for most companies, especially smaller
110:15 - companies, the snapshot update works just fine, and you only kind of venture into this
110:20 - more complex set up if you really needed to.
110:22 - So we already touched on this briefly, but deleting data can be really, really dangerous,
110:27 - right?
110:28 - If you delete stuff that you didn't want to delete, you'll be sad, right?
110:31 - Especially you don't have any sort of backup strategy, you know, set up.
110:37 - So we've already talked a little bit about some of the different backup strategies.
110:42 - Just know that there's really two high level things that you want to think about.
110:47 - The first is, one, make sure that you have a backup strategy for any production database,
110:52 - right?
110:53 - Make sure that you're at least taking snapshots at regular intervals, right?
110:56 - So that, you know, if something goes catastrophically wrong today, you can at least restore the
111:02 - database to what it was yesterday.
111:04 - Yes, some people will lose their data, and that really sucks, but it's not as bad as
111:08 - losing all of the data in the application for all time.
111:12 - So definitely have some sort of backup strategy.
111:15 - Number two is sometimes you will want to do soft deletes.
111:21 - And a soft delete is just where instead of taking a snapshot of the entire database,
111:29 - you just never delete stuff from the database.
111:32 - You never run a SQL delete statement, and instead you just mark records as deleted,
111:38 - right?
111:39 - You have like a deleted at column on your database table, right?
111:45 - And when something is deleted, you'd like set that timestamp to the time that it was
111:49 - deleted at.
111:50 - And then later when you select data out in your application logic, you just like ignore
111:55 - stuff that's been marked as deleted.
111:57 - So this makes it so you never actually delete anything.
112:01 - Applications do this.
112:02 - The only time you really need to be wary of doing this, I mean, there's actually two things.
112:05 - The first is it adds a lot of complexity to your application, because now you have to
112:11 - actually like be filtering based on this deleted at flag.
112:15 - So it actually is more work to do it this way.
112:18 - The other problem is you potentially have like GDPR or privacy concerns, right?
112:23 - Because now when your users delete their accounts, their data is not actually being deleted from
112:28 - your database, which again, like from kind of an ethical privacy standpoint might not
112:32 - be what you want.
112:33 - So just some things to keep in mind.
112:34 - Okay, the question says, you should have or you should blank have automated backups being
112:41 - taken of a production database, answers are sometimes never almost never or almost always,
112:45 - it's going to be almost always like please, please have backups.
112:49 - Next question says, a soft delete is where you blank, delete some data, but it's not
112:54 - actually removed from the database for 30 days, delete data from a snapshot, mark a
112:59 - row as deleted instead of actually removing the data, or delete some data by asking your
113:04 - database in a very nice soothing voice, usually with a please.
113:09 - It's going to be marking a row as deleted.
113:14 - Soft delete, mark it as deleted, don't actually remove the data.
113:18 - One last thing I forgot to say about soft deletes is just like it can potentially be
113:23 - expensive in the sense that like, if you have a very large database table and say like 90%
113:29 - of the data is deleted, if you're keeping it around and just having it marked as deleted,
113:33 - your queries might start to get slow, even though you've deleted a lot of data.
113:36 - So you know, soft deleting will never like make your database faster due to like decreasing
113:42 - the amount of data in it.
113:43 - So just of course, just another thing to keep in mind.
113:47 - Let's talk about updating data.
113:49 - So we've talked about creating new rows in a database, talk about reading them, we've
113:54 - talked about deleting them.
113:55 - Now we're going to talk about updating existing rows, right?
113:58 - So maybe we just want to swap out one specific field or one specific column on an existing
114:03 - database row.
114:04 - In SQL, we do this with the update statement.
114:06 - So the update statement looks like this, update employees.
114:09 - So literally just update and then the name of the table, set, and then a comma separated
114:15 - list of column names and their new values, and then an optional where clause, right?
114:22 - So in this case, update employees, set job title to backend engineer, salary to 150,000,
114:28 - where ID equals 251, right?
114:31 - So we're updating one employee.
114:32 - We're giving them a new title, a new salary.
114:34 - Great.
114:35 - Okay.
114:36 - Let's jump into it with the assignment says we need to update Lane's record in our user
114:40 - table.
114:41 - He founded cache pal, but he's not even recognized as an admin update Lane's record within the
114:45 - users table so that the is admin field is set to true.
114:49 - Here's the current state of the users table.
114:51 - Okay.
114:52 - So it looks like Lane has ID nine.
114:56 - And currently he is not an admin.
114:59 - So update users set what's called is admin true where ID equals nine.
115:20 - Now again, important to point out here, I could say where name equals Lane, but if we
115:29 - have other lanes in the database that we don't want to be admins, then that's going to capture
115:36 - them as well.
115:37 - Right?
115:38 - So, you know, be as specific as you can be with your where clauses so that you don't run
115:43 - into any of those sorts of issues.
115:44 - Let's go ahead and run that.
115:47 - And you can see that the record is updated.
115:49 - So I'll go ahead and submit it.
115:51 - I want to briefly touch on the idea of an ORM object relational mapping.
115:56 - If you're not new to web development, you'll almost certainly have heard of ORMs or maybe
116:00 - even used one before, basically the, an ORM is just a library that makes it much easier
116:06 - to interact with a database.
116:09 - And even more specifically, the whole idea of object relational mapping is to map kind
116:15 - of our in-memory representation of some object or some struct or some record, map it to the
116:23 - database schema that we're using, typically the table, right?
116:28 - So for example, we might have in Golang a struct called user, and a user has an ID,
116:36 - which is an integer, a name, which is a string, and is admin, which is a Boolean, right?
116:40 - And this is Golang code, right?
116:44 - If we're using an ORM, then what we might be able to do is just create an instance of
116:49 - a user, right?
116:50 - ID 10, name, lane, is admin false, and use some sort of method or function like database.create,
116:58 - give it the user, and it will just kind of automatically generate the SQL that will run
117:05 - that insert statement, right?
117:06 - So generate an insert statement and execute it against the database.
117:10 - This is really convenient, right, because it means we don't have to worry about writing
117:15 - all of the raw SQL, we can kind of automatically map objects in our programming language to
117:21 - rows in our databases.
117:24 - There are good and bad things about ORMs.
117:26 - I would argue that generally speaking, you'll want to use an ORM, as long as the ORM makes
117:33 - it easy to also write straight SQL, right?
117:38 - So you still get this escape hatch where you can do very specific and very, I don't want
117:44 - to say complex, but more advanced things with your SQL, right?
117:48 - Sometimes very simple functions like create, update, delete, will get you really far, but
117:54 - later you'll need to write more complex queries, right?
117:57 - Things that we'll cover later in this course.
117:59 - And if your ORM is limiting you from using the full flexibility or the full power of
118:04 - SQL as a language, then that can be a disadvantage.
118:08 - So to like sum up and give you a rule of thumb, an ORM typically trades simplicity for control.
118:18 - And again, in production, what that often means is you will use an ORM for most stuff,
118:22 - and then occasionally you'll need to write some raw SQL when you're trying to do something
118:27 - very, very specific.
118:28 - Cool.
118:29 - The question here is, when using an ORM, you blank, call methods and functions made available
118:35 - via the ORMs API, or you write a lot of raw SQL.
118:41 - And the answer is you call methods and functions made available from the ORMs API.
118:46 - Next question says, one advantage of an ORM is that it blank, gives you more control over
118:51 - your database, is easier to debug at a low level, makes your code less verbose, or ensures
118:56 - faster queries.
118:58 - This isn't actually, this is actually interesting.
119:00 - The answer is that it makes your code less verbose, right?
119:03 - You don't have to write nearly as much code when you're using an ORM, you just call some
119:08 - function or some method that's been rebuilt for you by the library.
119:14 - So it does make your code less verbose.
119:15 - However, I do want to point out that it does not give you more control over your database.
119:20 - In some cases, it actually takes control away.
119:22 - It's also not easier to debug at a low level, because if you want to figure out what SQL
119:27 - is being run against your database from this method, you're going to have to do some digging,
119:31 - right?
119:32 - So you're just looking at your code and, you know, fixing your SQL.
119:37 - Also ensures faster queries, again, not necessarily the case, sometimes, especially when your
119:42 - ORM code starts to get a little hairy, it can really generate inefficient SQL, which
119:48 - again can be hard to debug.
119:50 - So there's trade offs with ORMs, I'm definitely not going to say they're bad or they're good,
119:55 - use as intended.
119:56 - So should you use an ORM?
119:58 - Almost always, it depends on the project slash team, almost never, always.
120:03 - I'm going to go with it depends on the project slash team.
120:08 - There are instances where an ORM makes a ton of sense and there are instances where it
120:12 - doesn't.
120:13 - Moving on, let's talk about aliases.
120:18 - So there is an AS keyword, AS AS, in SQL that allows us to essentially rename different
120:26 - words in our SQL queries, and we would typically do this to make the query a little bit more
120:31 - concise, easier to type, less verbose.
120:35 - And it's important to understand that these aliases, they only last for the duration
120:40 - of the query.
120:41 - So really the convenience they provide is just for kind of within the SQL itself.
120:46 - It doesn't persist, it doesn't get saved to the database or anything like that.
120:50 - It's really just to make writing the query itself a little simpler.
120:53 - Let me show you an example.
120:54 - So let's pretend that we have two columns, employee ID and employee name on an employee's
121:01 - table.
121:02 - Now, first of all, I would argue that this naming scheme isn't very good.
121:06 - I would have preferred to just see an ID column and a name column, because remember these
121:11 - columns are on the ID's table, so it's pretty obvious that it's an employee ID and an employee
121:17 - name.
121:18 - So you kind of have some redundancy here in the column names.
121:22 - But either way, let's just assume that this is the schema we're working with.
121:25 - What we can do is alias the employee ID column as just ID and the employee name column as
121:34 - just name.
121:36 - That does two things.
121:37 - It means that later in the query, we can refer to those columns as just ID and name, right?
121:42 - So it makes writing the SQL a little simpler.
121:44 - It also means that when the data comes back from the database, like the literal rows that
121:49 - we get back from the database, the keys for those columns will now be ID and name instead
121:56 - of employee ID and employee name.
121:58 - So kind of useful from a structuring the return data standpoint as well.
122:03 - So let's see what this looks like in an actual assignment.
122:06 - Let's write some code.
122:08 - It says, a user has asked us to find all the transactions on their account from their grandma.
122:12 - We thought it would be fun to rename the note field to birthday message because we noticed
122:16 - all the transactions from grandma just happened to be birthday messages.
122:21 - Return the amount and the note field, renamed to birthday message from the transactions
122:25 - table where the sender ID is 10, which is grandma.
122:28 - Okay, I'm going to show the database setup codes so we can see what we're working with
122:32 - here.
122:33 - All right, so return the amount and the note field.
122:36 - So select amount note from transactions where sender ID equals 10.
122:50 - Now if I just run this as is, this is what I get, right?
122:55 - The key for this column is amount.
122:57 - The key for this column is note, and then we've got the amounts and we've got the notes.
123:01 - But we've been asked to rename the note field to birthday message.
123:05 - So we'll do note as birthday message.
123:11 - Now the only difference here, again, well, I should say there's two differences.
123:15 - This now means that later in the query, we can refer to the note column as birthday message,
123:20 - but we're not going to do that because we don't care in this query, right?
123:23 - We don't need to use, we don't need to like write a where clause using the note column.
123:28 - So we don't have to worry about that.
123:29 - But what it should do is also change that key in the return data, right?
123:35 - So now when we parse these SQL rows in our application, we'll parse this column as birthday
123:41 - message.
123:42 - Cool.
123:43 - I'm going to go ahead and submit that.
123:44 - Let's talk about functions in SQL.
123:47 - So remember that SQL is a language and like most programming language, it supports functions.
123:53 - So in SQL, functions look very similar to functions that you've used in other programming
123:59 - languages.
124:00 - And when you call them, you use parentheses and you pass in some number of arguments,
124:05 - right?
124:06 - So in this case, we've got the IIF function, open parentheses to start passing in parameters,
124:12 - and then we're passing in 123 parameters.
124:17 - And then we're closing the function call.
124:19 - Now you might be wondering what the IIF function does.
124:22 - Well, the IIF function is essentially a ternary, if you're familiar with ternaries from JavaScript.
124:29 - And basically what it says is, first, give me a condition.
124:34 - If the condition is true, I will return the first value you give me.
124:40 - But if the if the condition is false, I'll return the second value, right?
124:47 - And actually, if you look closely, there's actually a slight bug here, because if these
124:51 - two values are the same, then it will return the string car B is bigger.
124:55 - So this would probably say car B is greater than or equal to something like that.
125:02 - Anyways, irrelevance.
125:04 - The point is, you get how this works, right?
125:06 - Conditions true, we return the first thing conditions false, we return the second thing.
125:09 - So IIF can be really useful if we're trying to like compute something based on some conditional.
125:16 - So when would I use this kind of a function?
125:18 - Well, let's take a look at the example.
125:21 - Let's say we have a product table, and we want to return kind of how many we have of
125:29 - each product, right?
125:30 - So say we've got, I don't know, 10 apples and 30 bananas in stock, right?
125:33 - We want to return the the sheer amount that we have.
125:37 - But we also want to return a little text string that that's a little more descriptive, right,
125:44 - that can be computed from the quantity itself.
125:47 - So in this case, we're saying if the quantity is less than 10, we're also going to return
125:52 - the string or we're also going to put in the return row, the string order more.
125:59 - Otherwise, if we have at least 10, we're going to put the string in stock in the row.
126:05 - And you can see why this would be really useful, right?
126:08 - Now you can give your employee this report, and it will just clearly state on every row,
126:13 - right?
126:14 - 9, order more, right, bananas, 11, in stock.
126:19 - Now they can just take a look at the order more or the in stock column to see whether
126:23 - or not they should order more of whatever it is, right?
126:26 - We can do interesting kind of computed columns in our return data by using a function like
126:33 - this.
126:34 - And you can see we're actually coupling this with an as clause so that when the data comes
126:40 - back, it has a nice kind of column name to it.
126:44 - So the assignment for this lesson says we need to look through cachepals transaction
126:49 - data and determine whether or not any of the transactions need to be audited.
126:54 - Return all the data from the transactions table and add an extra column at the end called
126:57 - audit.
126:58 - Okay.
126:59 - So let's just start with that.
127:00 - So select star from, do that right, from transactions and add an extra column name at the end called
127:11 - audit.
127:12 - I'm going to run this query, I'll just get the whole transaction stable.
127:16 - Okay.
127:18 - Now this audit column, it says if a rows was successful field is true, the audit field
127:25 - should say no transaction, no action required.
127:27 - However, if was successful is false, the audit field should say perform an audit.
127:33 - Okay.
127:34 - So in addition to the wildcard, in addition to everything else, we're also going to return
127:42 - a new column.
127:43 - We're calling it audit.
127:44 - And in order to calculate the audit field, we're going to use this IIF, it's IIF, not
127:49 - IFF, right?
127:50 - Okay.
127:51 - IIF.
127:52 - And the condition is going to be if was successful equals true, right?
128:02 - Or actually, I think because this evaluates to a Boolean, we can just say if was successful.
128:08 - So if was successful is true, then the first thing we pass in as a parameter, technically
128:14 - the second parameter, right?
128:15 - The first thing after the condition will be what's returned.
128:18 - So we'll do no action required.
128:23 - Otherwise, we'll say perform an audit.
128:31 - And then we want this new column to be called audit.
128:36 - So select star and audit, and the way we'll calculate audit is using this function.
128:44 - So in theory, we should have one row down here at the bottom, right?
128:51 - This magic the gathering draft row, it should be the only one where an audit needs to be
128:56 - performed.
128:57 - So let's run that again.
128:59 - Take a look at our results set.
129:01 - Yep.
129:02 - No action required on all of those performing audit on the last one.
129:06 - This looks good to me.
129:07 - Another useful clause is the between clause, right?
129:11 - So this essentially lets us to check whether a value is between two other values, right?
129:16 - So in this example, select employee name and salary from the employees table, where the
129:22 - salary is between 30,000 and 60,000, right?
129:26 - So we'll go get all the rows from the database, where the salary field has a value between
129:30 - 30 and 60,000.
129:32 - It's also worth pointing out that we can just throw a not before the between, and that will
129:37 - give us everything that's not between the two numbers, right?
129:40 - So if we don't want everything between 20 and 100, then we can do a not between.
129:45 - Oh, the assignment says we need to figure out or we need to see how many young adults
129:49 - are using cashpal.
129:51 - Query our users table to find all the name and age fields of users between the ages of
129:55 - 13 and 18.
129:57 - Seems straightforward enough.
129:58 - So select.
130:01 - One page from capitalized from users where age between age between 18 and 30.
130:22 - Cool.
130:23 - Let's run that.
130:28 - This is looking good.
130:30 - Let me see what the full, I'm actually curious now, what does the full table look like?
130:36 - Run without between.
130:37 - Yeah.
130:38 - Okay.
130:39 - So we're like excluding Ram here, excluding David.
130:44 - Cool.
130:46 - Okay.
130:48 - That looks right to me.
130:49 - Let's submit it.
130:51 - Distinct is another super useful keyword that does kind of what you'd expect.
130:55 - It allows us to select rows where a distinct value is present.
131:00 - So for example, select distinct previous company from employees.
131:06 - This will only return one row per unique value, right?
131:11 - So let's say that I have 10 employees and between the 10 employees, maybe there's three
131:16 - that worked at Google for that worked at Microsoft and another three that worked at Apple.
131:21 - When I run this query, I only expect to get three values back, Apple, Google, Microsoft.
131:28 - So jumping into the assignment, it says cash bill executives want to know how many countries
131:32 - we have customers in.
131:33 - We store country code data as a column on the users table, run a distinct query to get
131:37 - all the unique country codes from the user's table.
131:40 - So simple enough, select country, I'm going to run it kind of the normal way first so
131:48 - we can see the difference from, let me capitalize that, from users.
131:55 - Select country code from users.
131:56 - If I just run this, I'll get one country code per row in the database.
132:02 - You can see tons of stuff here, but this isn't what the executive is asking for, right?
132:06 - They don't want a single row for every user in the database.
132:11 - Maybe we have 100,000 users, right?
132:13 - They just want to know how many countries total, right, exist across all of our users.
132:20 - So we can use distinct, distinct.
132:27 - Run that again.
132:28 - Oh, had to refresh my page, had a network issue.
132:35 - Okay, so it's like this to cover code now, yeah, now we get it kind of whittled down
132:40 - to each unique country code.
132:41 - I'm going to go ahead and submit that.
132:43 - Well, let's talk about logical operators.
132:46 - You're probably already familiar with logical operators if you've done any sort of programming
132:50 - in like Python or JavaScript or whatever.
132:53 - It's really simple in SQL.
132:56 - The logical operators are just the key words and and or, spoiler alert, we'll talk about
133:01 - or in just a second.
133:02 - Cool, so when we're writing, for example, a where clause, we can add more than one condition
133:09 - by anding that condition with another condition.
133:11 - So for example, here we're selecting product name, quantity, shipment status, right, those
133:16 - three columns from the products table where both of these things are true.
133:22 - The shipment status is pending and the quantity is between zero and ten, right?
133:28 - This again should be a pretty familiar concept if you've done any sort of programming before.
133:37 - And then the only thing I really want to call attention to in SQL is that when you're doing
133:44 - a quality in SQL, all these inequality operators are what you'd expect, right?
133:49 - Less than, greater than, less than or equal to, greater than or equal to.
133:53 - But the equal operator, when you're checking for equality, is just a single equals.
133:59 - It's not double equals or triple equals like it is in some other languages.
134:04 - And that's just because it's not taken up for assignment.
134:07 - So like it's not taken up as the assignment operator.
134:10 - So it's just the equal sign.
134:12 - Cool.
134:13 - Like you could see here, right?
134:15 - Shipment status equals pending, not equals, equals pending.
134:18 - Okay, with all that preamble, let's get to the assignment.
134:22 - It says the legal restrictions in Canada have changed the way that we handle Canadian minors.
134:29 - So minors are people under the age of 18, right, essentially kids.
134:34 - The way that we handle their transactions has to be more strict, right, for legal reasons.
134:37 - We need to find all those users so that we can find how many of our users are going to
134:41 - be affected by these changes.
134:43 - So write a query that retrieves all of the fields from the users table, where the users
134:49 - are from Canada and are under the age of 18.
134:53 - We can take a look at the table here.
134:55 - Okay, select star from users, where country code equals Canada, and age says under the
135:14 - age of 18, so less than 18.
135:18 - This looks good to me.
135:25 - Now we're going to work with the or operator.
135:28 - So it works very similarly to the and operator, but instead of both conditions on either side
135:34 - of the or keyword needing to evaluate to true, only one does, right?
135:42 - And to be clear, it's okay if both do.
135:44 - So at least one side needs to evaluate to true.
135:46 - At least one condition needs to evaluate to true.
135:49 - And it's also worth pointing out that the order of operations can be manipulated with
135:55 - parentheses.
135:56 - So in this case, we're saying we're going to evaluate this and that first.
136:01 - And then the result of that is going to be ordered with the other, right?
136:06 - So we can use parentheses, just like in math, to adjust the order of operations.
136:12 - Okay, assignment says the laws have changed again.
136:14 - Now we need to see how many affected users meet this criteria.
136:17 - Users who are from the United States or Canada and are under 18.
136:19 - Write a query that retrieves the count of every user that matches the conditions.
136:23 - Okay, so select count star from users.
136:30 - Let's just run that.
136:32 - So in total, there's 11 users in our table.
136:37 - Next we need to filter this down and say where country code equals US or country code equals
136:54 - Canada.
136:55 - Okay, with that filtering, we're down to eight.
136:59 - Now I'm going to pop this in parentheses and say and because we're requiring that all the
137:06 - users must be under 18 and age is less than 18.
137:12 - Let's run that perfect.
137:18 - Next we've got the in clause.
137:21 - This one's pretty cool.
137:22 - And it's not always, in my opinion, super intuitive how it works.
137:26 - So we'll definitely go over it.
137:28 - But basically, the in operator returns true or false.
137:33 - If the first operand matches any of the values in the second operand.
137:38 - So it's kind of a shorthand for like multiple or conditions.
137:42 - So take a look at this, we've got this first query, select product name and shipment status
137:46 - from the products table, where shipment status is in this kind of list of options.
137:53 - So as long as shipment status is one of these shipping, preparing or out of stock, it will
137:59 - return true, which means we'll return the row, right?
138:03 - Whereas here, we've got select product name, shipment status from products, where shipment
138:07 - status is shipped or shipment status is preparing or shipment status is out of stock.
138:12 - These are identical queries, they do the exact same thing.
138:15 - This is just kind of a more convenient way to write it.
138:18 - And later, we'll see how this allows us to kind of use the in operator with dynamic data.
138:26 - So we don't have to like explicitly spell out all of the different options, right?
138:31 - Maybe we're comparing against other data that's somewhere else in the database, cool.
138:37 - So let's jump into the assignment.
138:39 - It says, we want to know which of our users are from North America, right?
138:43 - A select statement that returns the name, age and country code fields for every user
138:46 - within US, Canada or Mexico.
138:49 - So select, and this isn't a count, right?
138:53 - We want to know which of our users, let's see, okay.
138:56 - So select name, age, country, code, from users, where, let's see, age, not age, where country
139:16 - code in US, Canada, Mexico.
139:29 - Looks good to me.
139:30 - I'm just gonna send it on this one.
139:33 - Next we've got the like operator.
139:35 - I love the like operator.
139:37 - It's kind of the first operator that we've used that allows for like fuzzy matching,
139:41 - right?
139:42 - Or kind of wild card matching.
139:45 - So the first thing to understand is that the like keyword is going to allow us to look
139:50 - stuff up in the database by like partial matches, right?
139:55 - So we'll get to that.
139:58 - It'll make more sense with an example.
140:00 - First let me explain this kind of percent operator.
140:03 - So this percent sign operator will match to zero or more characters, and we can use this
140:09 - operator within the query string that's supplied to the like clause to find more than just
140:17 - exact matches depending on where we place it.
140:19 - So for example, select star from products where product name is like this string, banana
140:27 - percent.
140:28 - And what we're saying is any product names that just start with the string banana, we
140:37 - want to match, right?
140:38 - Because this this percent sign effectively says anything else can be here, right?
140:44 - Zero or more characters can be in this spot in the string.
140:50 - So similarly, if we want every product name that ends in banana, we just put the percent
140:56 - at the beginning, right?
140:58 - And then if we just want to do a contains, right, does the string banana show up anywhere
141:04 - in the product name, then we can just slap a percent sign on both sides of the string.
141:09 - So the assignment says our HR team is dealing with a ticket from one of our users, but they're
141:12 - having a trouble pulling up their record in the database.
141:15 - They're pretty sure the user's name starts with a L write a query that returns all the
141:20 - fields for records where the user's name starts with a L. Okay.
141:26 - So select star from users where the name is like they starts.
141:43 - So starts with a L. So it needs to be a L and then percent cool.
141:50 - Going to just send it, right, we got Alan, Albert, Alvin, Alphonse.
141:59 - Looks good to me.
142:00 - So still working with the like clause, we're going, we're going to take a look at another
142:04 - operator basically.
142:05 - So the, the percent operator or the percent sign, like I said, matches zero or more characters.
142:13 - Whereas the underscore operator matches exactly one character, right?
142:19 - So for example, here we're saying, uh, you know, give me all products where the product
142:26 - name is a four letter word that ends in oot, right?
142:31 - So it'll match boot, root foot here.
142:34 - I don't know if you can tell, but there's actually two underscores, but now this is
142:41 - going to match things like shoot and group, but importantly, it will not match things
142:45 - like boot, root foot, right, explicitly going to have five characters.
142:51 - Okay.
142:52 - HR has been able to narrow down their query even further.
142:54 - They want a report of all users whose names start with a L and are exactly five characters
142:59 - long.
143:00 - Okay.
143:01 - So let's do select star from users where name, like underscore, underscore, underscore,
143:14 - but an Al at the beginning.
143:17 - So it starts with Al one, two, three underscores run that Alan and Alvin perfect.
143:26 - And just to show you what would have happened if we did this, we would match some more stuff.
143:31 - We'd get Alfonso and Albert.
143:35 - So that's looking right to me.
143:37 - First quiz question dealing with wildcards and the like, the like clause says, which
143:42 - describes the values that match example one?
143:45 - Okay.
143:46 - So this is example one or underscore wildcard.
143:54 - Let's see values that start with or yup and have three characters exactly.
144:00 - No, because we've got this wildcard here that could be zero or more characters values that
144:06 - end in or no, that's not it.
144:08 - Values that end in or no, that's not it.
144:10 - Values that start with or and are at least three characters in length.
144:13 - Yeah, that's accurate, right?
144:14 - We need three characters.
144:16 - We could have some more.
144:19 - Next question, which would not match example two?
144:24 - So we've got two underscores here, bling that matches sling that matches thing that
144:32 - matches singing does not match too many characters, right?
144:36 - This, this only has room for five characters.
144:41 - New keyword, we've got the limit keyword.
144:45 - Now this one, this might be one of the keywords that I use the absolute most in SQL apart
144:52 - from like the obvious things like select and where limit is super, super common, both when
144:57 - you're writing application code, as well as when you're just kind of making one off queries
145:01 - to a database, because it's very often the case that when you're working on a production
145:06 - scale database, a table doesn't just have six or seven or 10 rows like what we've been
145:11 - dealing with in our little sandbox environment, right?
145:14 - We could have a thousand rows, we could have a million rows, we could have 100 million
145:20 - rows in the database.
145:21 - And if you try to just select all of those rows, something's going to crash, right?
145:27 - That's a lot of data to pull out of a database all at once.
145:31 - So that's where the limit keyword becomes really, really useful.
145:35 - Here's what it looks like.
145:36 - So after any select statement, we can end it with this limit, this limit section here
145:44 - we're saying, just give me 50, do not give me more than 50 rows, right?
145:49 - Give me up to 50.
145:52 - So if my query was only going to return three rows anyways, the limit keyword effectively
145:57 - would do nothing here.
146:00 - But if like, you know, 7000 products match this query, we're going to stop the database
146:08 - and say, just give me the first 50, give me the first 50.
146:11 - Okay.
146:12 - Moving on to the assignment says a lot of our users have been using catch pal to pay
146:16 - other users for lunch.
146:17 - Let's take a look at a sample of that data.
146:20 - Write a query that returns all rows and fields from the transactions table.
146:25 - Any record where the note field has the word lunch in it, okay.
146:29 - And the query should return at most five records.
146:32 - So select, it says all rows and fields, yeah, select star from transactions, where note
146:47 - like just has the word lunch.
146:50 - So we'll do wildcards on other sides of lunch.
146:54 - Okay.
146:57 - And let's just go ahead and run that really quick to see how many there are.
147:01 - Looks like we've got a lot, 14.
147:05 - And now we'll limit it down to just the first five.
147:09 - Again, cool.
147:12 - Just five, just five results now.
147:16 - I want to just point out, you'll probably do this a lot when you're like manually working
147:21 - with a database and just trying to like figure out what the data sort of looks like.
147:24 - Right?
147:25 - So you've got a database, we got a table in it.
147:27 - It has a hundred thousand records.
147:28 - You don't need to see every single record to get a feel for like what all the columns
147:34 - are and what kind of data is actually in those columns.
147:37 - You'd typically just kind of like connect to the database, run a simple query like this,
147:40 - maybe limit it to 10 or 20 or 30 rows that you can fairly easily scan through.
147:45 - That's something I find myself doing a lot as a backend developer.
147:48 - Cool.
147:49 - I'm going to go ahead and submit that.
147:51 - So this question here says, limit five will always return five records and the answers
147:58 - are true and false.
147:59 - And the reason this is false, I'll just go ahead and click that now.
148:03 - The reason this is false is because if the query were only going to return zero or one
148:09 - or two records anyways, then limit five isn't going to add records, right?
148:16 - It's just saying, don't give me more than five.
148:18 - So it's actually possible for a query with limit five on the end to return fewer than
148:25 - five records.
148:27 - Next question says, why might you use a limit clause?
148:31 - First answer, I wouldn't.
148:33 - System performance is an ops person's problem.
148:37 - I like that answer, but it's wrong.
148:39 - Next one is to get as much data as possible.
148:42 - Nope, that can't be it, right?
148:43 - We're trying to limit the data, the amount of data because I'm a machine learning engineer
148:48 - and don't care about efficiency.
148:50 - Again, kind of funny, not accurate.
148:54 - Last one to avoid selecting a huge amount of data and causing strain on the system.
148:58 - It's going to be that last one.
149:01 - Next is the order by clause.
149:03 - And this one usually goes hand in hand with the limit clause.
149:07 - It's very often that you'll use both of these in a query and it's because the order by clause
149:13 - allows us to sort the data, right?
149:16 - And then the limit clause caps the amount of data, right?
149:21 - So if we order it the way we want it and then we just get like the first five, that's potentially
149:27 - pretty useful, right?
149:28 - Like give me, for example, like maybe you're building a leaderboard, a leaderboard, right?
149:33 - Like the one we have on boot dev.
149:35 - And I want to like get all of the users, but first I want to sort them by like how many
149:42 - exercises they've completed, right?
149:44 - And then just give me the top 10.
149:45 - Like that's a very common type of query that you're going to make in a database.
149:49 - So let's take a look at an example.
149:51 - So here we've got, you know, select name, price, quantity from products, order by price.
149:56 - Okay.
149:57 - So this is going to sort by the price field.
150:00 - Now by default, it's going to sort in ascending order, right?
150:06 - In other words, it's going to put the lowest values at the top and go down from there,
150:13 - right?
150:14 - Whereas, or sorry, it's going to put the lowest values at the top and then increase in value
150:20 - as you go down row by row, that's ascending order, right?
150:25 - If you want descending order, you have to explicitly specify it, right?
150:29 - So order by quantity descending, right?
150:34 - And that would, again, that would give us the highest values at the top.
150:38 - And then the values would drop as we go down.
150:41 - Okay.
150:42 - So the assignment says, write a query that lists all of the records in the transactions
150:45 - table where amount is between 10 to $80 and the results are sorted by amount in descending
150:51 - order.
150:52 - Okay.
150:53 - So first let's just write the select statement.
150:54 - So select star from transactions where amount between 10 and 80.
151:06 - Okay.
151:07 - Let's just run that.
151:10 - Take a look.
151:12 - So we've got our data correct, but it's not ordered the way we want, right?
151:19 - The amounts are kind of all, all out of order.
151:22 - So we'll add order by, what was it amount, order by amount, if I run this.
151:32 - So now we've got the smallest amount at the top and it's ascending as we go down, but
151:38 - it says we want it in descending order, so we want the biggest amount at the top.
151:41 - So we'll just add a descending keyword there.
151:45 - Run that.
151:46 - Cool.
151:47 - Now we've got the biggest amounts at the top and we go down from there.
151:51 - All right.
151:52 - We've got a quiz, got a little database table here and says example one is sorted in blank
151:58 - order.
151:59 - And I'm going to go ahead and assume it's talking about the age column, much more obvious
152:04 - how to sort by age than sort by name.
152:09 - It's sorted in descending order, right?
152:12 - We start with the biggest number, we go down from there.
152:14 - Next quiz question says, which query would potentially return the data in example one?
152:20 - Okay.
152:21 - Same table.
152:22 - The select star from people order by age.
152:26 - That would not give us this data because it doesn't specify an order, so it would do ascending.
152:33 - That wouldn't do it.
152:34 - Select star from people order by age descending.
152:37 - That could definitely be it.
152:38 - Select star from people order by age ascending, again, no, and select star from people order
152:45 - by descending age.
152:46 - That one's just incorrect.
152:47 - So it's going to be order by age descending.
152:49 - All right.
152:50 - Now we're going to use both of these keywords kind of in tandem.
152:55 - Like I said earlier, this is pretty common.
152:58 - Assignment says, an HR employee got into the Git repository where we store all of the queries
153:02 - that we run and tried to update one himself.
153:06 - Fix the bug in the SQL query.
153:08 - Okay.
153:09 - So select star from transactions where amount between 10 and 80 limit for order by amount
153:14 - descending.
153:15 - Let's try to run that SQL logic error, right?
153:22 - The problem here, so this wasn't actually a problem.
153:25 - It just bothered me.
153:26 - The descending is in lowercase and I like my conventional SQL where everything's capitalized.
153:36 - The problem here is that these are out of order.
153:38 - You need to order by first.
153:41 - First we sort, then we truncate is like the way I like to think about it.
153:46 - First you sort the data set and then you limit it down to just the bit that you want.
153:50 - Let's run that.
153:56 - Aggregations are one of my favorite parts about working with databases.
154:00 - Now aggregation sounds like a big, scary word, but it's actually a pretty simple concept.
154:05 - An aggregation is just when we take a large amount of raw data and aggregate it down into
154:11 - a single value.
154:12 - Now there's something interesting that I want to point out when it comes to architecting
154:16 - your database.
154:17 - Generally speaking, I think it's a really good idea to store database or store data
154:23 - in your database in sort of a raw format.
154:26 - And the reason for that is if you pre-aggregate your data, right?
154:30 - If you pre-compute a result and then store it in your database and say kind of discard
154:35 - the original raw data, you can never get back at that original kind of raw form of the data.
154:41 - So generally speaking, it's a good idea to store data in your database in sort of a raw
154:45 - format, and then you can just run aggregation queries on the fly when you need the calculated
154:51 - data.
154:52 - And I know I'm talking in vagaries, but we're going to hop into it in just a second so you
154:56 - can really see what I mean.
154:57 - So without realizing it, you've probably, well, you actually have already written an
155:03 - aggregation in SQL.
155:05 - The count function is a very simple aggregation, right?
155:08 - It takes as input many rows from the database and returns a single value, right?
155:14 - The count of how many rows there are.
155:16 - So to sort of reiterate why this matters, right?
155:18 - Why we would store data in a raw format and just run, for example, a count query when
155:24 - we want to know the count of rows is if we just store the count of rows, thinking, well,
155:31 - maybe I don't actually need all these transactions, I can just store the count of transactions
155:34 - because at the moment, all I'm doing is showing on the page how many transactions they are.
155:39 - The problem is if later down the line, we need to show something like when the transactions
155:44 - happened, right?
155:45 - So we need all the dates on every individual transaction.
155:48 - If all we were doing was storing the results of the aggregation, the count itself, we wouldn't
155:53 - be able to go backwards.
155:54 - So again, I just want to reiterate, store data in a raw format, right?
155:59 - As raw as you can, as raw as makes sense.
156:02 - And run aggregations like count queries when you need that data.
156:08 - So let's hop into the assignment.
156:09 - It says the front end team is building a dashboard page in cache pal.
156:12 - We need to be able to provide them the number of successful transactions for a given user,
156:16 - return the number of transactions where the user ID is six and was successful is true.
156:21 - Okay, so select, count, star.
156:28 - Now remember, when we're using the count function, this wildcard refers to the fields, right?
156:38 - So we're just saying we don't care which field we count, we just care about the number of
156:42 - total rows.
156:43 - So just keep that in mind.
156:44 - All right, select the count of star, ROM, transaction, transactions, where, let's see,
156:56 - user ID equals six and was successful is true.
157:09 - Cool.
157:10 - Let's try running that.
157:13 - We got three, let's take a look at the setup code just so we can see.
157:18 - Okay, yeah, it looks like a lot of stuff was inserted into the database.
157:22 - So we, we, it looks like we're filtering it down to an appropriate amount.
157:26 - I'm going to go ahead and just submit that.
157:30 - Moving on, we've got another aggregation.
157:32 - This is one that we have not used yet.
157:34 - So the sum function or the sum aggregation does what you'd expect.
157:38 - It sums a group of values.
157:40 - Now with the sum aggregation, it wouldn't make sense to use all of the fields in a database,
157:46 - right?
157:47 - We're not counting rows.
157:48 - Now, what we're trying to do is sum all of the values in an individual column.
157:54 - So here, we're going to pass in the salary field as the parameter to the sum aggregation
157:59 - in order to get a total.
158:00 - So let's jump into the assignment says we need to be able to calculate the current balance
158:04 - for a given user, because we don't yet store the running balance on each individual transaction
158:10 - record.
158:11 - Write a query that returns the sum aggregation of the amounts for all of Bob's transactions.
158:17 - So first, let's just go ahead and do select star from transactions, transactions, where
158:27 - user ID equals nine, right for Bob.
158:33 - Let's just take a look at this data.
158:36 - Okay, so it looks like there's three transactions, and we've got three amounts, 1050, 50, and
158:45 - negative 2489.
158:47 - Now to get his balance, all we have to do is sum the amount field for the amount column,
158:56 - right?
158:57 - Go ahead and run that.
158:59 - Cool.
159:01 - That looks about right based on what I remember from Bob's transactions.
159:05 - We've got another aggregation to practice with.
159:08 - This is the max aggregation, again, pretty obvious what it does, it just returns the
159:12 - largest value from a set of values.
159:15 - So for example, select max price from products should return the product the max price or
159:21 - specifically the value of the max price.
159:25 - So let's jump in to the assignment again, pretty straightforward, how's this work.
159:32 - So I want to just get right to an example.
159:34 - It says use a max aggregation to find the largest amount of money received by Jill,
159:39 - user ID four, return her user ID and that amount.
159:44 - Okay, so first I want to just find the transactions from Jill, so select star from transactions,
159:56 - where user D equals four.
160:01 - Okay, run that, get a feel for what Jill's transactions look like.
160:10 - Okay, and we're looking for the max and the largest amount of money, return her user ID
160:18 - and that amount.
160:19 - Okay, so it looks like the max is 50, so we're going to expect that.
160:23 - So I want to do select max amount and I can just comma separate, right, because I want
160:32 - to select multiple things, select max amount and user ID from transactions.
160:39 - Run that, yep, 50, there it is, perfect.
160:45 - We did max time to do min, min function works the exact same way except it returns the lowest
160:51 - value, smallest value, okay, assignment says use a min aggregation to find the age of our
160:56 - youngest cache pal user in the United States in the users table, okay, the users table
161:03 - has these fields available to it, ID, name, age, country code, user name, okay, and we
161:10 - want just the age, okay.
161:14 - So select min age from, oh, this is from the users table, from users, where country code
161:30 - equals US, run that, that looks right to me.
161:38 - Now let's talk about the group by clause.
161:41 - So the group by clause is not an aggregation function like min or max, but instead it gives
161:47 - us a more powerful way to interact with aggregation functions, let me show you what I mean.
161:53 - So the group by clause essentially allows us to create multiple summary rows, in other
161:59 - words to kind of run the aggregation multiple times resulting in multiple results.
162:05 - So for example, look at this query, we've got select album ID and the count of song
162:11 - IDs, so give me the album and the number of songs in the songs table grouped by the album
162:19 - ID, right, this is a really useful query, we've got a huge list of songs, they all have album
162:25 - IDs on those records, we can group all the rows for each album ID together and count
162:32 - the number of songs, right, super useful query, a way to see how many songs are in each album.
162:38 - Let's use it in the assignment, says let's get the balance of every user now, all in
162:42 - a single query.
162:43 - Use a combination of the sum aggregation and the group by clause to return a single row
162:47 - for each user.
162:48 - The row for each user should contain the user ID and their balance, which is a sum of their
162:54 - amounts called balance, so we want to make sure we alias that column so that it's called
162:59 - balance, okay, so select user ID, sum amount, from, this is transactions, where, wait, is
163:21 - there a where here, no, group by, user ID, use a combination of the sum, single row for
163:36 - each user, okay, that looks right, the row should contain the user ID and their balance,
163:41 - okay, cool, oh, we just need to alias it, so let me run it like this, and you can see
163:46 - by default, SQL just kind of gives us some amount as the name of this column, which is
163:54 - kind of nasty, we're gonna do instead as a balance, like that, cool, and submit that.
164:05 - Next we've got the average aggregation, again, it does exactly what you'd imagine, these
164:10 - are kind of very common statistics ideas, right, we're gonna find the average of a bunch
164:16 - of values, it is important to note that it does ignore null values, so it's only going
164:22 - to average kind of the values that exist, cool, let's use it in the assignment, it says
164:28 - our marketing team is trying to determine the best marketing channels to advertise through,
164:31 - but they need more information about our current users, they wish to know the average age of
164:35 - users in the United States, return a single value representing the average age of all
164:38 - users where the country code is US, so, select average age from users where country code
164:50 - equals US, let's just send it, we got it, let's talk about the having clause, and I
164:59 - actually want you to almost pause the video, well, not pause the, well, okay, pause the
165:05 - video after I explain this concept, because it's one of those concepts that when I first
165:11 - learned about databases really eluded me, I had a really hard time understanding the
165:16 - difference between the having clause and the where clause, so let me try to break it down
165:21 - for you.
165:22 - The having clause is just like the where clause, it works the same way, it's used to filter
165:30 - rows down, the difference is that having operates on rows after an aggregation has taken place
165:41 - due to the group by clause, whereas the where clause operates on the rows before the aggregation
165:49 - happens.
165:50 - Does that make sense?
165:51 - So if you think about the order in which the query is executed, first the where clause
165:57 - is going to filter the total result set down to some smaller set.
166:01 - Then the group by clause is going to kind of break that smaller set into individual
166:06 - groups that you can then aggregate, right, like maybe you can get the count of all songs
166:10 - in the album, right, you've got five albums, you've got five subgroups.
166:14 - The having clause allows you to filter again after that group by using the results of the
166:24 - group by in the having clause.
166:26 - So to be clear, the having clause is definitely not as commonly used as the where clause,
166:32 - right, because it's only really going to be used in tandem with an aggregation.
166:37 - Let's take a look at this example.
166:39 - So here we have select album ID, count of ID as count from songs, group by album ID.
166:45 - So we've seen this before, right, this should return the album ID and the number of songs
166:50 - in the album.
166:51 - The difference now is that we've added a having count is greater than five clause.
166:58 - So what this will do is it will take that end result, right, of album ID and count,
167:06 - let's say that there were 10 albums, each with their own kind of song count associated
167:11 - with them.
167:13 - On that small resulting set of the 10 albums with their counts, we're going to filter one
167:19 - last time where we remove all of the rows or all of the albums, essentially, that don't
167:25 - have at least five songs in them.
167:28 - As usual, hopefully, this makes more sense after the assignment.
167:31 - Let's jump right into it says a new page in the cashpal app allows users to see how much
167:36 - money they've spent on a specific kind of transaction and alerts them if that amount
167:40 - is fairly large.
167:41 - Let's write a query that returns the total amount spent by each user on lunch when that
167:47 - balance is greater than 20.
167:48 - Okay, so this is actually gonna be a pretty complex query, which is which is great, good
167:53 - for practice, right?
167:54 - Again, if you're following along on boot dev, I highly recommend you pause the video and
167:58 - try to solve this on your own.
168:01 - So it says your query should return a sender ID, the person spending the money and a balance.
168:06 - The balance is the sum of all amounts spent.
168:08 - So first, let's just let's just start by getting a look into this table.
168:13 - We're working with the transactions table, I believe, let me in fact, let me go ahead
168:18 - and take a look at the setup code.
168:19 - Yeah, it's just a bunch of transactions.
168:22 - So to start, let's just select star from transactions.
168:29 - Take a look at some of this data.
168:32 - Okay, now we can kind of start to understand what we're working with.
168:39 - So we want a query that returns the total amount spent by each user.
168:43 - So it's gonna look something like this, let's select some amount from transactions.
168:57 - Group by user ID.
169:03 - And I should probably include the user ID there.
169:06 - Is that something we want?
169:10 - Return a sender ID, the person spending the money and a balance, the balance is the sum
169:13 - of all the amounts spent.
169:14 - It's gonna be some amount as balance than that.
169:17 - So now we can see the user IDs and their balances.
169:24 - Total amount spent by each user on lunch when that balance is greater than 20.
169:29 - Okay, so we also need a having balance greater than 20.
169:35 - So we'll filter out any rows that don't have that.
169:37 - It's now really starting to get down into the weeds here.
169:40 - It says the query should return a sender ID, the person spending the money.
169:45 - Okay, so we don't actually want the user ID, we want the sender ID.
169:55 - Which means I think we should be grouping by the sender ID as well.
169:58 - Don't return any rows that have a null sender ID.
170:00 - Yeah, so we want to group by the sender ID.
170:04 - The note must contain the word lunch to be part of the aggregation.
170:07 - So that's actually a where clause, right?
170:09 - So where note like, we know how to do this, right, like percent lunch percent, right?
170:22 - That'll match a zero or more characters to run that.
170:27 - Okay, now we're really getting somewhere, got three sender IDs, we got some balances.
170:33 - Order the results by the balance in ascending order.
170:37 - Order by balance, ascending.
170:42 - Okay, we did we check all these boxes, returning the sender ID and a balance, good.
170:50 - The balance is the sum of the amounts, good.
170:52 - Don't return any rows that have a null sender ID, there's no nulls there.
170:56 - Group by sender ID, yep, the note must contain lunch, we got that.
171:01 - The aggregated get balance must be greater than 20, we got that.
171:05 - Order the results by balance and ascending order.
171:07 - We should be good to go.
171:08 - I know I already went over this, but I really just want to reiterate it again because this
171:12 - can be really confusing.
171:15 - The difference between the having and where clauses, because they are very similar, they're
171:20 - both used to filter down results set, is that the where condition is applied to all the
171:24 - rows before the rows are grouped into aggregate rows, right?
171:30 - Whereas the having condition is applied to the grouped rows, right?
171:34 - The results of the aggregations.
171:37 - So with that in mind, let's look at the question.
171:38 - It says, in the example, should you use a where clause or a having clause to filter
171:42 - down to a specific class ID?
171:44 - So here's the example.
171:47 - Select class ID, count ID as count from students, where blank, group by class ID, having blank.
171:55 - So if we want to filter down to a specific class ID, we should actually do that in the
172:00 - where clause because we have access to that information before doing the group by, right?
172:07 - Having is typically used to filter based on the result sets, so we would do that after
172:13 - the aggregation.
172:15 - So in this case, we'll use the where.
172:18 - Next question says, in the example, should you use a where or a having clause to filter
172:21 - down classes of a particular size?
172:24 - Okay, interesting.
172:25 - So this is the count, right, the size is the count of students in a class.
172:32 - We can't do that before the group by clause because we haven't yet figured out the count
172:38 - inside each class, right?
172:40 - We have to do the aggregation on each class ID to figure out how many rows, right?
172:45 - How many student rows there are for each individual class.
172:48 - So it has to actually be the having clause in this case.
172:53 - Let's talk about rounding numbers.
172:55 - Not every function that's built into SQL is an aggregation, right?
172:59 - The round function is not an aggregation.
173:02 - It takes just a single value as input.
173:04 - Well, technically it takes two values, right?
173:05 - It takes the value to be rounded and the precision that we want to round the value to, but it
173:11 - is really common to use the round function when you're dealing with the results of an
173:17 - aggregation.
173:18 - By default, if we do not pass in a value for the precision parameter, by default, SQL will
173:25 - just round it to the nearest whole number, at least SQL lite will.
173:29 - Okay, so the assignment says fix the query so that it returns a whole number.
173:33 - That just means a number without a fractional part, right?
173:36 - And rename the result column to round age.
173:40 - Okay, so first, let's just run this as is.
173:43 - We get this really nasty decimal point here.
173:47 - We're going to change this to round to a whole number.
173:53 - I would expect this to round up to 28, right?
173:56 - Yep, 28, that looks good.
173:59 - And then it says to rename this field.
174:01 - This is a nasty, nasty column name, right?
174:04 - Round average age.
174:05 - Disgusting.
174:06 - Let's alias it as round age.
174:12 - Perfect.
174:14 - Fair warning, the queries we write in this chapter will start to get a little bit harder.
174:22 - We're moving into sub queries.
174:25 - So make sure that you understand regular queries, at least all the concepts we've covered so
174:29 - far fairly well before moving on to this chapter.
174:32 - Let's take a look at an example.
174:34 - So in this query, we've got select ID, song name, artist ID from the songs table, where
174:41 - the artist ID is in.
174:44 - Now remember, we've seen the in keyword before, we kind of used it to select, or to query
174:52 - for when a value is in a list or a set of values.
174:58 - But now, instead of saying, for example, artist ID in, you know, one, two or three, right,
175:05 - a list of explicit IDs, we're going to perform a sub query inside of these parentheses.
175:11 - And we're saying we want the artist ID to be in the result set of this sub query, right?
175:21 - So this query will run first, and the results will be used here in the in clause.
175:29 - Hopefully that makes sense.
175:30 - It should make some more sense when we get to writing some code here in a second.
175:34 - And I do want to point out that actually the only syntax specific to sub queries are these
175:41 - parentheses that surround the sub query itself, right, we're, we're quite literally just writing
175:46 - a normal query, and using the result set here in this in statement.
175:53 - So jumping down into the assignment, it says one of cash bow's customer service representatives
175:57 - needs us to pull all the transactions for a specific user.
176:00 - The trouble is, they only know the user's name, not the user's ID.
176:06 - So keep in mind, we could solve this problem by like running a query to get the user by
176:12 - their name, copying the ID, and then manually running a second query, what using a sub query
176:19 - is going to allow us to do is do it all at once all in one SQL query.
176:25 - So we've been tasked with using a sub query to get all of David's transactions.
176:30 - Okay, so we want to select star from transactions, where user ID equals now remember we weren't
176:49 - provided with a user ID, so we actually can't explicitly set it here.
176:55 - So we need to use sub query where user ID equals select ID from users, where they go
177:10 - to another line, where name equals David.
177:17 - Okay, we can just double check does this match our syntax from before?
177:25 - Looks good.
177:26 - Okay, so to be clear, we've got two different tables we're interacting with a transactions
177:31 - table and a user's table.
177:34 - And we are saying we want to get all the transactions or the user whose ID is whatever the results
177:42 - of this query is, which is select ID from users where David equals where name equals
177:47 - David.
177:48 - Okay, let's go ahead and run that.
177:55 - That looks good to me.
177:56 - It looks like it's grabbing all the records for user ID one, let's just check the setup
178:00 - code really quick and make sure that David is number one, it looks like he is because
178:05 - we're using an auto increments, primary key ID, so David should be ID number one.
178:13 - Cool, I'm going to submit.
178:15 - Now I just want to point out the difference between the query we wrote in the example
178:19 - here.
178:20 - Like I said before, the in syntax is not required for sub queries.
178:26 - The difference is that in this query, we expect multiple rows or multiple values to be returned.
178:32 - So we need to do an in clause, whereas here, we expected just a single user to be returned.
178:40 - And in fact, if we wanted to ensure that we could add a limit one, right, just in case
178:46 - there are multiple David's.
178:48 - Next we've got a little quiz.
178:51 - So it says a sub query, a creates a temporary table, B allows you to query the result set
178:58 - of a nested query, or C is a technique for speeding up your database.
179:02 - Now it doesn't create a temporary table, a sub query only exists at execution time.
179:08 - So no data is actually stored in the database, like the result set of your sub query is not
179:13 - stored in a new table in the database or a temporary table in the database.
179:17 - That's not what's happening.
179:19 - It's just a way to express a subset or a result set within your query.
179:24 - It only exists at execution time.
179:27 - And it's not a technique for speeding up your database.
179:30 - It's not any sort of like performance optimization, at least not inherently.
179:35 - So the answer is it allows you to query the result set of a nested query.
179:39 - Now this quiz question says the example will return blank rows.
179:43 - Okay, let's take a look at this.
179:46 - We've got select ID, song name, artist ID from songs, where artist ID in this.
179:52 - Hmm.
179:54 - Okay, this is actually the same example from the previous lesson.
180:00 - How many rows will this return?
180:04 - Well, we can expect that this sub query will return multiple rows because it's just querying
180:13 - for names like Rick.
180:15 - So anyone with a first name, last name, combo that starts with Rick is going to be returned
180:21 - here, right?
180:23 - And then the outer query is selecting ID, song name, artist ID from the songs table.
180:31 - So it's potentially selecting many songs where the artist is in this smaller list of artists.
180:39 - So I mean, we're already working with multiple artists.
180:42 - So it stands to reason that we have to be working with multiple songs.
180:46 - So potentially many is what I'm going to go with here.
180:49 - It's important to remember that SQL is technically a full programming language.
180:55 - Now, like I said, at the beginning of the course, we don't typically use SQL to build
181:00 - out full applications from scratch, right?
181:02 - It is a domain specific language in the sense that it's intended to be a query language,
181:07 - a language used to interact with databases, but it is a programming language, right?
181:12 - It has functions.
181:13 - It has ways to do these sorts of things.
181:15 - One example of this is that you can actually select information using SQL without having
181:22 - any backing database or table.
181:25 - So for example, this query select five plus 10 as sum.
181:30 - I mean, all that does, in fact, I'll just run it here.
181:33 - All that does is return a sum column with the result 15, right?
181:38 - But you'll notice I didn't even reference any tables in order to do that.
181:42 - Let's jump into the assignment that kind of demonstrates this.
181:44 - So the finance department has found that people who have lived longer than 40 years need to
181:48 - start thinking about retirement, write a query that returns all of the users who are more
181:53 - than 40 years old.
181:55 - Unfortunately, this tapered awkwardly stores age in days in the age in days field, use
182:00 - a sub query to convert years to days and filter on that.
182:05 - Assume every year has 365 days.
182:08 - Okay, so write a query that returns all the users who are more than 40 years old, select
182:12 - star from users, where, let's say age, this age is greater than something like this.
182:29 - And then we'll do a sub query there.
182:32 - Now we have an age in days field, where age is greater than, we can do age in days, sorry,
182:49 - we want to reference age in days, because that's, that's the actual column that's on
182:53 - the database.
182:54 - Right?
182:55 - Yeah, okay.
182:56 - Oops.
182:57 - So age in days is greater than.
183:01 - Now remember, we can't just do 40 here, we can't just do that, because that's years.
183:07 - So we need to convert to days.
183:09 - So we can do 40 times 365, right?
183:17 - We'll convert our years into days.
183:20 - Cool.
183:21 - Let's run that and see what we get.
183:25 - See these age in days, values are actually quite large.
183:29 - That looks good to me.
183:33 - Another quiz, SQL can only operate on data stored in tables.
183:38 - That is false, as we just saw.
183:43 - Architecting a database can be really tricky.
183:46 - But the most important thing to get right is that you've modeled your one to one relationships,
183:50 - your one to many and your many to many relationships accurately.
183:54 - If you do that, everything else will start to fall into place.
183:57 - Let's talk about.
183:58 - There are really three different types of relationships that we can have between entities
184:02 - in our database, right?
184:04 - We've got one to one, one to many, and many to many.
184:12 - And to draw that out, look something like this.
184:17 - If I have one of entity number one, it relates to one thing of entity number two.
184:23 - Another thing of entity number one, it relates to exactly one other thing of entity number
184:28 - two, you get the idea.
184:31 - One to many would look more like this.
184:33 - We have some things of type number one or of entity number one, and they might relate
184:39 - to three different types of entity number two.
184:47 - The second one might relate to two.
184:50 - This third one might just relate to one.
184:54 - It's really one to zero to many.
184:57 - You might even have one that doesn't relate to anything there.
185:00 - Okay, cool.
185:01 - And then a many to many relationship is exactly what it sounds like.
185:04 - We'll have all these different instances of thing number one, some instances of thing
185:10 - number two, and we can have kind of multiple relationships going on at the same time.
185:21 - Now let's start simple.
185:23 - Let's say we have in our database, a users table.
185:29 - Actually let's go with students, a students table, be a little bit more specific.
185:34 - And in the students table, we have two fields.
185:36 - A student has an ID, and a student has a name.
185:41 - Let's say we are thinking about adding a new entity to our database, and this entity is
185:46 - a GPA, right, a grade point average, and we're trying to decide how we're going to relate
185:53 - a GPA to a student.
185:55 - Well, once we decide that it's a one to one relationship, meaning a GPA and a student
186:01 - are tightly coupled to one another, right, a student has one and only one GPA, and that
186:08 - GPA is related to one and only one student, right.
186:12 - If that's the case, then it's pretty simple.
186:16 - We just add a new field, right, we just add a new field called GPA.
186:22 - Generally speaking, with a one to one relationship, it's easiest to model that as just another
186:27 - field on a database table.
186:30 - There is one other option though.
186:31 - What we could do, and I would argue this is typically a little less common because it's
186:36 - a little more complex, but I've seen it around, is that we'd create a new table, and we might
186:40 - call it something like, I don't know, student credentials, or maybe student scores.
186:51 - In this second table, we would have essentially the same ID, and the reason we'd have the
186:57 - same ID is to make sure that this relationship remains one to one.
187:05 - At the end of the day, we want to make sure that both of these tables have the exact same
187:09 - number of records, so that one record in one table will relate to exactly one record in
187:15 - the other table.
187:16 - We would typically do this for organizational or performance reasons, right.
187:20 - It's that we want to take this field here, the GPA field, and move it into a new table
187:28 - and kind of keep it separated physically and logically from the students table, right.
187:34 - It would give us some flexibility.
187:35 - Maybe we have some other data in here, like a test score that we'd want to add as another
187:43 - field on this table.
187:44 - So one to one relationships, generally speaking, it's just a field on the same database table,
187:49 - but it might be a kind of one to one mapping of primary keys between two tables.
187:56 - Now let's talk about one to many.
187:58 - Now one to many tends to be the most common type of relationship that you'll see in web
188:03 - development, right.
188:05 - Imagine a user and their tweets, right.
188:07 - You have one user and that one user can have zero to many different tweets that they've
188:13 - authored.
188:14 - Let's go ahead and model this out.
188:15 - So let's say that users have an ID and a name, seems pretty straight forward, and then tweets
188:25 - will need an ID, some text, and now is the tricky part.
188:31 - We actually need to model the relationship between tweets and users.
188:35 - So keep in mind, a user can have zero or many tweets.
188:39 - And this is the case, the easiest thing to do is to put a foreign key ID on the entity
188:48 - that is the many.
188:49 - So in this case, the tweets should reference the users.
188:52 - So tweets need a user ID.
188:57 - If you think about it, it starts to make sense, right?
189:00 - In fact, let's just jump right into some examples.
189:02 - Let's say that we have a user number one, name Lane, and user number two, ID two, name
189:10 - Alan.
189:13 - And then a new tweet is created ID one says hello.
189:18 - And let's say Lane tweeted it.
189:19 - So it will be user ID one, right, it references Lane over here in the users table.
189:27 - The next tweet will of course be ID two, because we need all of the IDs in the tweets table
189:34 - to be unique, right?
189:35 - They're the primary key.
189:36 - But the user ID on this one, it's hey, might be user ID two, right?
189:42 - So Alan tweeted this tweet.
189:44 - Now when we add a third tweet, yo, let's say Lane tweeted this one again, we could just
189:52 - reference Lane again, right?
189:54 - So we can have many tweets, right, in this case, tweet number one and tweet number three
189:59 - that are related to one user, right?
190:03 - User number one, which is Lane in this case.
190:05 - So one to many relationships, foreign key on the table of the many.
190:10 - Now let's talk about many to many.
190:13 - This is the arguably the most, the most complex relationship type, many to many users and
190:21 - tweets don't really make sense.
190:22 - So let's call, let's change out the tweets table for something else.
190:27 - Let's do groups.
190:28 - So let's say that users can organize themselves within groups.
190:34 - And if you think about it, this starts to make sense, right?
190:36 - A user should probably be able to be a part of many different groups, but a group naturally
190:42 - can have many different users in it.
190:44 - So we've got a many to many relationship.
190:46 - Okay, let me move these apart just a little bit.
190:51 - Now, a group, a group is going to have slightly different data.
191:04 - A group should probably have a name, I guess that makes sense.
191:09 - But just to keep it a little unique, let's say that a group also has a size, like a max,
191:14 - a max size, okay.
191:21 - And let's add a couple of groups.
191:22 - So we can still use Lane and Allen, but we'll create a new group, all the Gophers, and it
191:29 - has a max size of 20.
191:31 - Then we'll create another group.
191:34 - Pythonistas, max size of 30.
191:40 - Okay, got a couple groups.
191:43 - And actually, just so that they're different.
191:45 - Let's add a third group.
191:46 - Now let's add a third user, that'll be good.
191:50 - So this will be user number three, name of John.
191:57 - Okay, now, how do we model a many to many relationship?
192:01 - The problem is we can't use a foreign key.
192:04 - Because if we just add a foreign key to the group, we'd be stuck with a one to many relationship,
192:10 - we'd have no way to relate multiple users to multiple groups, we'd only be doing multiple
192:16 - groups to one user.
192:18 - So the approach, typically here, is to create a new table.
192:24 - So we actually have to add a third table here in the middle.
192:29 - And this is typically called a joining table.
192:32 - And really, its only purpose is to model the relationship between users and groups.
192:38 - And oftentimes, you'll see the table just called, for example, user groups, right.
192:48 - Very obviously, just kind of mapping the difference or mapping the relationship between users,
192:53 - users groups, right, users and groups.
192:55 - Okay, what would what would actually be in this table?
192:58 - Well, typically, there's just two things in this table.
193:03 - There is a user ID.
193:08 - And there is a group ID.
193:09 - All right, so just two foreign keys, make up this table.
193:15 - And typically, you'd put a constraint on this table, and say, we're not going to allow two
193:22 - rows in this table to be identical, let me show you what I mean.
193:25 - So let's say that Lane joins the Gophers group.
193:30 - When he does that, the way we're going to indicate that he's joined is by adding a new
193:34 - row to the joining table that says user ID one group ID one, let me add some some spacing
193:45 - there.
193:46 - So user ID one group ID one.
193:49 - Now let's say that Lane also joins the Pythonistas group.
193:53 - So we do user ID one group ID two.
193:56 - Now what I was talking about constraints earlier, what I mean is we wouldn't have a we wouldn't
194:01 - allow a second row to be added here that's identical to this other row, because it's
194:05 - fully redundant.
194:06 - It's telling us the exact same thing, right, that Lane has already joined the Pythonistas
194:10 - group.
194:11 - So we wouldn't do that.
194:12 - So Alan, Alan joins Pythonistas as well.
194:17 - So Alan's in the Pythonistas group, right?
194:20 - And maybe John, maybe John joins the Gophers group.
194:30 - Okay, so notice the many to many relationship here, right?
194:35 - Lane has now joined both groups, Gophers and Pythonistas.
194:42 - But the Gophers group also has two different users, right?
194:46 - It has Lane and it has John.
194:49 - So by using a joining table, we're able to accurately model a many to many relationship.
194:54 - So like we just talked about, there's essentially three different relationship types we need
194:59 - to concern ourselves with one to many one to one and many to many.
195:04 - The question here is, which is an example of a one to one relationship?
195:09 - A university's professors, so the relationship of university to professors, that's not one
195:16 - to one, there's one university has many professors potentially.
195:21 - And I mean, I guess you could even have like, you know, professors that work at multiple
195:26 - schools at the same time, maybe they're part time, right, so you get a little complicated.
195:31 - A father's children, again, not one to one can have multiple children.
195:35 - A transactions note, that's potentially one to one, right?
195:40 - I mean, it doesn't necessarily have to be but it could be you could definitely constrain
195:44 - your app and say every transaction can have just one note on it.
195:49 - Or a user's transactions.
195:52 - That doesn't make any sense.
195:53 - A user should be able to have many transactions.
195:55 - So I think the most correct thing here by far is a transactions note.
196:01 - Next question is, how would you model the relationship between a class and its name?
196:06 - Okay, so let's take a class like CS50, right, Harvard's famous CS50 class.
196:16 - It can only have one name.
196:18 - I don't see a world in which you would want multiple names for an individual class.
196:25 - This seems like a field on a row sort of situation, so I'm going to say one to one.
196:30 - Let's take a look at this example of a one to many relationship, or a couple examples
196:36 - here.
196:37 - A customer's table and an order's table, right?
196:40 - Each customer should have zero, one, or many orders.
196:43 - And this is important to understand.
196:44 - When we say one to many, what we really mean is one to potentially many, right?
196:51 - Zero to many.
196:53 - It's okay to have a customer and they haven't placed any orders yet.
196:57 - That should be a valid state of the database.
197:00 - A user's table and a transactions table, right?
197:02 - Again, a user should be able to have multiple transactions.
197:05 - Let's jump down to the assignment.
197:06 - It says, it turns out that when we originally designed the cache pal database schema, we
197:10 - assumed that users would only have a single country that they lived in.
197:14 - With digital nomads becoming a thing, it turns out many users actually have dual citizenship.
197:19 - So instead of a single user's table, where each user has a single country code, do the
197:24 - following.
197:26 - Remove the country code field from the user's table and create a new table called countries
197:30 - with four fields, ID, country code name, user ID, foreign key to the user's table.
197:36 - Okay.
197:37 - That makes sense, right?
197:39 - So with our current database schema, all we can do is give each individual user, right?
197:45 - Each individual user row can only have one country code because it's just a field on
197:50 - the row or a column on the row.
197:53 - That's a problem.
197:54 - So we're going to remove the country code from the user's table and create a new table.
197:58 - So create table, and we're going to call it countries.
198:05 - And it should have four fields or four columns, ID, integer, primary key, I'm going to guess,
198:19 - country code, text, name, text, user ID, integer, but it's not enough just to add the column
198:37 - user ID, we're going to actually constrain it with a foreign key.
198:40 - So foreign, foreign's always hard for me to spell foreign key on the user ID column, references,
198:53 - user's table, ID column, okay?
199:01 - This looks better to me.
199:03 - And I hope as you're looking at this query, it's making sense why this works, right?
199:08 - We can now add multiple rows to the country's table that reference the same user, right?
199:17 - So say you have your user record lane, right with ID one, I can now go into the country's
199:23 - table and add two records, I can add maybe United States and Canada, and have them both
199:30 - reference lane.
199:31 - So this is a way for us to model the relationship between one user and their multiple dual citizenship.
199:38 - Next, we've got many-to-many relationships, and frankly, these ones are kind of the biggest
199:42 - pain in the butt because it just takes a little bit more work to model this in your database.
199:47 - I mean, to be fair, one-to-one is the easiest, one-to-many is kind of middle of the road,
199:51 - and many-to-many is hardest.
199:53 - And when I say hard, I don't mean it's like super complex and hard to learn, I just mean
199:58 - there's just a little bit more legwork to do.
200:01 - So typically the way that we model a many-to-many relationship in an SQL database is by using
200:06 - a joining table, right?
200:08 - So a joining table is a special table that doesn't really have any metadata on it, right?
200:15 - So when I say metadata, I mean like all this extra crap, right?
200:19 - So you've got the user's ID, and that's its primary key, but all this other crap, we can
200:25 - just kind of call that metadata.
200:27 - It's data about the user, right?
200:30 - But it's not the identifier of the user.
200:33 - So essentially you could break almost every database schema up into the primary key and
200:41 - then the metadata.
200:42 - So what I'm saying is a joining table is really just a table with only identifiers and no
200:49 - extra metadata.
200:50 - And that's because its only job is to model relationships, which is what IDs do a great
200:55 - job of.
200:56 - Now, I'll show you an example of a many-to-many table in just a minute when we get into this
201:01 - exercise, but I also just want to point out that one thing that makes our joining tables
201:07 - better is when we use a unique constraint across two fields.
201:11 - So for example, here in this example, we have a product suppliers table, and all it has
201:23 - on the whole table is two IDs, product ID and supplier ID, right?
201:29 - So imagine a products table and a suppliers table, and we're trying to model a many-to-many
201:33 - relationship between the products and the suppliers.
201:37 - This joining table has rows in the table with just two values, the product ID and the supplier
201:43 - ID, and all this does is say I have a relationship between product one and supplier three, or
201:51 - product one and supplier one, or supplier one and product four, right?
201:56 - I can now model this many-to-many relationship because I have a joining table, and this unique
202:02 - constraint just makes sure that I never try to model the exact same relationship twice,
202:08 - right?
202:09 - When I'm doing a many-to-many relationship and drawing lines between the two different
202:13 - types of entities, I don't need the exact same line drawn twice, right?
202:18 - So you may have already guessed it, but what a row in this database means is that I've
202:24 - drawn a line between a product and a supplier.
202:28 - So say we have our product table and our suppliers table, and at present, no products are associated
202:35 - with suppliers.
202:36 - In other words, we're essentially saying that the suppliers don't carry any of the products
202:41 - yet, but the minute a supplier decides to carry a product, right, and supply that product,
202:48 - we would add a row in the database with that product ID and that supplier ID, right?
202:53 - And so if we need to check, hey, does this supplier offer this product, then we can just
202:58 - go into our joining table and look up, you know, all the products, where the supplier
203:03 - ID equals X, right?
203:05 - And we could do it the other way around.
203:08 - That's the interesting thing about a joining table, it allows you to do it both ways.
203:13 - So jumping into the assignment, it says we have another issue with our current user-to-country
203:18 - relationship.
203:19 - In the current schema, a user can have many countries associated with it, but there are
203:23 - duplicate records.
203:25 - If two users are associated with the United States, we are creating two countries' records.
203:30 - It would be better if each country only had a single record.
203:34 - That way, when a country changes its metadata, for example, maybe it renames itself, right,
203:38 - instead of United States of America, maybe we wanted it to be the United States of America,
203:44 - we only have to update one record, right?
203:46 - In the old schema, we were storing one country per user.
203:50 - So if we change the name of a country, we'd have to update every country record for every
203:54 - user.
203:55 - We don't want to do that.
203:56 - We don't want to duplicate data, right?
203:58 - So the assignment says, use a joining table to deduplicate country data.
204:02 - Remove the user ID field from the countries table, okay?
204:06 - So we will no longer have this foreign key here.
204:09 - Now the countries table is simply countries, right?
204:14 - Create a new table called users countries, all right?
204:19 - Create table, users countries.
204:22 - It should have two fields, country ID and user ID.
204:30 - Country ID, integer, user ID, integer.
204:38 - And we want to add this unique on both columns constraint.
204:46 - Country ID and user ID.
204:50 - Perfect.
204:51 - Let's run that.
204:52 - Uh-oh.
204:53 - What did I mess up?
204:57 - What did I mess up here?
205:05 - There's an extra comma there on that.
205:11 - There we go.
205:12 - I was required to take a database normalization class during my CS degree and frankly it was
205:18 - boring.
205:23 - Look here's the deal.
205:24 - There's basically the academic definition of database normalization and there's how database
205:30 - normalization actually impacts the apps you write.
205:33 - Now in this video, I will give you kind of a high level overview of the academic definitions
205:38 - of first, second, third normal form.
205:40 - But really what I want you to take away from this video is how database normalization and
205:46 - how certain strategies can help you reduce data duplication in your databases and improve
205:51 - data integrity.
205:53 - Basically just making your web apps easier to work within and more maintainable.
205:57 - So we are talking about database normalization and basically what that means is you can have
206:02 - a database that's architected in a less or a more normalized way.
206:07 - And the more normalized the database is, the less data redundancy you'll have.
206:13 - So the less data duplication and the more data integrity you'll have.
206:19 - So the more correct the data will be.
206:21 - So generally speaking, normalization good and the reason for that is you're much less
206:27 - likely to introduce data related bugs into your application.
206:30 - So there are four tiers of database normalization.
206:34 - There's first, first normal form, second normal form, third normal form, and voice cod normal
206:44 - form.
206:45 - And after the guys who kind of came up with this system.
206:48 - Okay.
206:49 - So what does that mean?
206:50 - Well, basically the most important thing to understand is that as the levels go down,
206:56 - your database becomes more normalized and these names for second, third normal form
207:02 - and voice cod normal form, just map to some rules, right?
207:06 - So for example, first normal form might have one, two, three rules associated with it.
207:18 - That's not actually how it works.
207:19 - I'm trying to, trying to give an example.
207:21 - Second normal form adheres to, let's say two additional rules and, and all of the rules
207:31 - from first normal form.
207:33 - So five total rules for second normal form, right?
207:37 - Third normal form, let's say tax on one additional rule and it adheres to all of the rules from
207:44 - second and first normal form.
207:46 - Hopefully you get where I'm going with here.
207:48 - So third normal form has six total rules and let's say voice cod normal form tax on one
207:53 - additional rule, right?
207:55 - And then adheres to all of the previous rule sets.
208:01 - So as you normalize your database more and more, you'll be kind of moving down this kind
208:07 - of tier list of normalization.
208:10 - So we talked abstractly about the idea that all of these normal forms have rules.
208:14 - Now let's talk about the actual rules themselves.
208:16 - So first normal form has two rules.
208:19 - The first rule is every row must have a unique primary key and rule number two is that there
208:33 - can be no nested tables, okay?
208:37 - Two very simple rules.
208:39 - Let me show you what I mean.
208:42 - Here is, well, let's, let's draw out a little database for ourselves.
208:46 - Let's say that we have a table in the database and the first row, let's say this is a user's
208:52 - table.
208:53 - We've got first name, lane, last name, Wagner, and then age 17.
209:01 - If in the same table, I have the exact same row, Lane Wagner 17, then this table does
209:10 - not adhere to first normal form.
209:14 - First normal form requires that every row must have a unique primary key, which translated
209:20 - out of kind of academic database speak literally just means that you cannot have completely
209:25 - duplicate rows, right?
209:27 - So the simplest way to escape, to escape, you know, this, like being outside of any
209:36 - normal form at all would be to just add an ID column.
209:39 - Like if we just add IDs here and we give row number one ID one and row number two ID two,
209:46 - then tada, we're in first normal form.
209:50 - Now there is this second rule, right?
209:51 - There can be no nested tables.
209:53 - I've never actually ran into that in production.
209:56 - Most production databases don't even allow you to nest tables in the first place, so
209:59 - you don't have to worry about it too much.
210:01 - But it really just means you can't, you know, take an entire table and shove it into the
210:05 - cell of another table, um, which again, hopefully it just makes sense why you wouldn't want
210:10 - to do that.
210:11 - Um, but again, most databases don't let you do that anyways, moving on to second normal
210:15 - form.
210:16 - Second normal form actually just has one additional rule.
210:18 - So to be in second normal form, your database must adhere to first normal form and what
210:24 - additional rule?
210:25 - The additional rule is that all columns that are not part of the primary E must only be
210:41 - dependent on the entire primary E, not just a part of the primary key.
210:50 - That's kind of word soup.
210:52 - So let's look at an example.
210:54 - We've got our database, say we have three columns, we've got first name, and do last
211:02 - name and first initial.
211:04 - So first name, last name, and first initial.
211:11 - And then let's populate the database with some names.
211:15 - So we've got, say we've got two lanes, we've got a lane small, we've got a lane Brewer.
211:29 - And then let's say that we've got an Allen small, and then the first initial for all
211:37 - of these would be L, L, and A. Now this table adheres to first normal form because there's
211:51 - no duplicate rows and no nested tables.
211:55 - It does not, however, adhere to second normal form.
211:58 - And in order to understand why, we have to understand what we mean by primary key.
212:02 - So typically when you're working in a production database, the primary key in a practical
212:07 - sense will just be an ID column, and that ID column will always have a unique ID for
212:11 - every row in the table.
212:13 - That makes database normalization fairly easy, right?
212:16 - But when we're trying to understand database normalization in more of an academic sense,
212:20 - when we say primary key, what we mean is just kind of the smallest number of columns that
212:26 - we can use to uniquely identify a row.
212:29 - So in this case, first name can't be a primary key on its own because there's two lanes.
212:34 - First name can't be a primary key on its own because there's two smalls.
212:38 - And first initial can't be a primary key because there's two Ls.
212:41 - But if we say combine first and last name columns together, they are unique together,
212:47 - right?
212:48 - There's only one lane small combination.
212:51 - There's only one lane brewer combination, and there's only one Allen small.
212:55 - So our primary key is going to be the combination of first and last name columns.
212:59 - So with that definition in mind, let's read the rule again.
213:02 - All columns that are not part of the primary key, so in this case, first initial, must
213:07 - only be dependent on the entire primary key, not just a part of it, right?
213:12 - Here's the problem.
213:14 - First initial is entirely dependent on just the first name column.
213:19 - In other words, it's dependent on part of the primary key, not the entire primary key.
213:25 - One way to solve this problem would be to create a new table and to move, to move first
213:33 - initial, the first initial column down here into that second table.
213:42 - And then we would map first name to first initial.
213:48 - And now you'll see we actually have some redundancy down here.
213:51 - Notice that lane being mapped to L only needs to happen once, right?
213:56 - So we could actually remove a row.
214:00 - Cool.
214:02 - Now we have one table with unique data, and anytime we need a first initial, we can look
214:07 - up the first initial for a given name in a separate table.
214:11 - This reduces redundancy, right?
214:13 - We talked about how normalization reduces data duplication and data redundancy.
214:18 - We now have less data duplication.
214:20 - Moving on, we've got third normal form.
214:22 - So remember, the database in third normal form follows all the rules of first and second
214:27 - normal form, but also one additional rule.
214:29 - And that is that all the columns not in the primary key are dependent only on the primary
214:39 - key.
214:41 - Pendant.
214:42 - Let's bust out an example.
214:44 - I'll use the same examples last time.
214:46 - Let's say that we've got lane small, actually, let's do this.
214:52 - Let's do first name, do last name, we'll do first initial.
215:07 - The key difference is that this time we'll add at the start an ID column.
215:16 - And we'll even be good database citizens and give some unique IDs.
215:22 - So in this example, the primary key is literally just the ID column.
215:31 - And then let's add some data.
215:32 - So we've got, we need two lanes, lane, lane, do Allen again.
215:41 - And we'll do small, small, and we'll do Brewer in the middle.
215:52 - And then here, we've got L, L, and a, whoo, okay, now notice this table actually does
216:07 - adhere to second normal form technically, right?
216:12 - Because yes, first initial is completely dependent on first name, but first name is now not part
216:19 - of the primary key.
216:21 - So it does adhere to second normal form.
216:24 - I'd argue that it's a pretty stupid academic distinction.
216:29 - Really we have the same problem, we're duplicating data.
216:32 - So anyways, the way we fix it is essentially identical.
216:36 - We can take this table, create a new one, and strip it down to just the parts we care
216:44 - about.
216:45 - In this case, we don't need last name or ID, we would just map first names to first initials.
216:56 - And the way we're going to do that is by shrinking it down here.
217:01 - We don't need two lanes.
217:02 - We just need a lane and an Allen, and move this column as well, again, remove the redundancy.
217:10 - Cool.
217:11 - Now we have all the same data being represented.
217:14 - Why can't I move that?
217:16 - There we go.
217:18 - Anytime we need the first initial for a first name, we can look it up in this secondary
217:21 - table, right?
217:23 - We've reduced some redundancy, and we have a primary ID column.
217:28 - Again, the distinction between second and third normal forms in practice as a backend
217:34 - developer working on databases is fairly meaningless.
217:39 - The idea is basically the same.
217:41 - So voice cod normal form adds one additional rule, and that rule is that a column that
217:49 - is part of primary key may not be dependent on a column that is not part of the primary
218:05 - key.
218:06 - A fun historical fact is that voice cod normal form was actually created later, after the
218:12 - first second and third normal forms, only after realizing that there is a way for duplicate
218:17 - data to slip into tables, even when a table adheres to all the rules of third normal form,
218:24 - so this additional rule was added.
218:26 - Now in order for voice cod normal form to actually matter, the database actually has
218:30 - to be in kind of a weird and specific state.
218:33 - That's why it wasn't really added until later, when people actually found out that this is
218:37 - potentially a problem.
218:39 - Okay, so what do I mean?
218:40 - Let's take a look at this database we have here, with the four columns, release year,
218:46 - release date, sales, and name.
218:49 - The problem here is that we have multiple possible primary keys, or candidate primary
218:56 - keys.
218:57 - For example, we could just have the primary key be the name column, because all of these
219:01 - names are unique.
219:02 - Kiss me tender, bloody mary, I want to be them, he got me.
219:06 - They're all unique.
219:07 - Additionally, a possible primary key could actually be the combination of the release
219:13 - year column and the sales column.
219:17 - If you take a look, 2001, 100, 2001, 200, 2002, 100, 2002, 200, those are all actually
219:24 - unique combinations, so that could be a possible candidate key.
219:30 - Additionally, just the release date column could be its own possible candidate key.
219:36 - Again, the thing that sets up this problem for voice cod normal form is we have multiple
219:43 - possible primary keys.
219:45 - Now, let's say for the sake of example that we've chosen the combination of release year
219:51 - and sales, these two columns, release year and sales, as our primary key.
219:57 - Now, the problem is that release year, this column, is fully dependent on the release
220:05 - date column.
220:07 - We have a column in the primary key that is dependent on release date, which is a column
220:15 - that is not part of the primary key.
220:18 - We're breaking voice cod normal form.
220:21 - If you go back and read the text from second and third normal forms, you'll actually realize
220:25 - that this isn't strictly forbidden in those definitions of normal forms.
220:32 - We can fix this.
220:33 - The way we fix this is just by making release date not dependent on release year.
220:43 - We'll just do release date and we'll just store the month and the day in that column.
220:50 - If we were saying we might change this to say release month day or something like that,
221:01 - you get the idea.
221:02 - It's worth pointing out that the distinction between second, third, and voice cod normal
221:08 - forms is mostly an academic exercise.
221:11 - In your day to day job as a developer, you shouldn't be worried too much about the differences
221:16 - between all of the different normal forms.
221:18 - What you should be worried about is are you duplicating data?
221:23 - Is there a way I can restructure my tables so that when I update something in one place,
221:28 - I don't also need to update it in another.
221:31 - That will keep your database less duplicated and it will also keep it more correct because
221:37 - there's less of a chance of you forgetting to update multiple copies of the same data.
221:42 - To recap, really the whole purpose of database normalization is to get data integrity and
221:49 - to reduce data redundancy.
221:52 - One great example of data integrity is I like to think of a user's age and their birthday.
221:59 - If we store their age in a database, like age equals six, that data becomes incorrect
222:07 - with the passage of time.
222:08 - If we don't touch that data next year, it will just be wrong.
222:12 - It will just be out of date.
222:16 - That data does not have integrity.
222:18 - It becomes incorrect.
222:19 - That's a problem.
222:20 - Anytime it's easy for your data to become incorrect or it becomes incorrect with time,
222:26 - you don't have good data integrity.
222:28 - If instead you store the birthday, now that never gets old.
222:34 - We can always calculate an age from a birthday when we need it.
222:38 - Similarly, data redundancy, obviously we've talked about this, but we don't want multiple
222:42 - copies of the same data in a database.
222:45 - That can actually lead to data integrity problems because maybe we update it in one spot but
222:50 - forget to update it in another.
222:52 - Now we have incorrect, mismatching data.
222:54 - The question is, to improve data integrity, data should generally be stored in a blank
222:59 - form, precalculated or raw.
223:04 - Now if we precalculate the data, the problem is again, it can become out of date if the
223:11 - underlying raw data changes.
223:13 - So I would argue store the raw data makes it easier to update.
223:18 - You can always calculate the result later.
223:21 - The only time you ever really want to store precalculated data is for very specific performance
223:27 - reasons, right?
223:28 - And like all things with performance, it's not the first thing you should optimize.
223:32 - You really would only start to look into that if your queries were getting really slow and
223:35 - becoming a problem.
223:39 - Pick the best example of data redundancy.
223:42 - Each table has an ID field as its primary key.
223:46 - It's not redundant.
223:47 - A user's address is stored in two different tables.
223:51 - Yeah, that seems like a problem, right?
223:53 - Now when they update their address, we're going to have to update it in multiple places.
223:56 - By the way, this is like what governments do.
223:58 - I don't know if you've ever been through this where like you update your address with the
224:01 - DMV and like they update it, but then like it's not updated on your taxes.
224:06 - It's because like every government agency has their own database and so it's not all
224:10 - synced up.
224:11 - It's not all in sync.
224:12 - This is the whole problem of data redundancy, right?
224:16 - So you don't want that within your own system.
224:18 - I'm just going to read these other ones just in case.
224:21 - Two tables can both contain fields that store Booleans.
224:25 - Not a problem because as long as they're different columns that mean different things, that's
224:30 - not necessarily a problem.
224:31 - A country table and a user's table each contain a field called name.
224:35 - Again, not really a problem.
224:37 - And frankly, the more you work with production databases, the more you'll kind of find very
224:41 - common patterns amongst the names of columns.
224:44 - Almost every table will have an ID.
224:46 - Most tables will have a name column.
224:49 - Many tables will have a created at column, right, so that you can see when each individual
224:53 - row is created.
224:54 - There's some common patterns you'll see and that's definitely not a problem.
224:59 - So a user address stored in two different tables is the answer.
225:02 - The next question deals with the normal forms specifically.
225:05 - We can take a look at this diagram.
225:07 - I think it does a good job demonstrating, you know, if you're in a voice cod normal
225:13 - form, then you must also be in third normal form, second normal form, first normal form,
225:19 - right?
225:20 - Voice cod normal form is the most normalized database.
225:24 - First normal form is kind of the minimally normalized database, right?
225:29 - Okay.
225:30 - Which form has the most duplicate data?
225:33 - It's going to be first normal form.
225:36 - Least normalized.
225:38 - Next is which form encourages the most accurate and up to date information?
225:42 - It's going to be voice cod normal form, right?
225:45 - The most normalized.
225:46 - In the context of normalization, a primary key is made up of blank table columns.
225:53 - Now I want to reiterate this because it's really important to understand.
225:57 - In the context of normalization, a primary key is made up of one to many columns, okay?
226:04 - In the context of SQL databases, that's not always the case.
226:09 - It just depends on the database technology you're using, right?
226:12 - Some databases might only allow you to use one column for a primary key.
226:16 - Some might allow you to do unique on two columns and call that a primary key.
226:20 - So like the different technologies matter here.
226:24 - Just understand that when we're talking about database theory, yes, a primary key can be
226:28 - made up of, you know, combinations of multiple, multiple table columns.
226:32 - All right.
226:33 - We've got an assignment to go along with first normal form.
226:37 - It says, we hired an intern at Cashpal and her first task was to design a new company's
226:42 - table.
226:43 - This table will store our business client's data.
226:46 - Unfortunately she has committed the unforgivable sin.
226:48 - There's no primary key on this table.
226:51 - We could have entire duplicate rows, right?
226:53 - So this table does not even adhere to first normal form because we can just have completely
226:59 - duplicate rows.
227:00 - Big problem.
227:01 - Add an ID field.
227:02 - It should be an integer and have a primary key constraint on it.
227:05 - When you're done, the company's table will be in first normal form.
227:08 - Cool.
227:09 - This is easy.
227:10 - This is straightforward.
227:12 - ID, integer, primary key.
227:17 - Boom.
227:19 - Very rare that you won't see ID fields on tables in production.
227:26 - Now we've got an assignment for second normal form.
227:28 - It says, another developer on our team has created a joining table for the companies
227:32 - to use as many to many relationship.
227:34 - Unfortunately they did it a bit weird.
227:36 - They included meta information about companies on the joining table.
227:41 - A good joining table simply has the IDs of the entities in the relationship, right?
227:45 - We already talked about this.
227:46 - Metadata doesn't really belong in joining tables most of the time.
227:50 - It manages the relationship and nothing else.
227:52 - Any information about the entities themselves belong in their respective tables.
227:55 - Move the column that's out of place to its proper table.
227:58 - Be sure to add it as the last column to the table you add it to.
228:02 - Okay.
228:03 - So, it looks like our joining table is here.
228:07 - Users, companies.
228:08 - I would expect it to have, yeah, a user ID and a company ID.
228:11 - Yeah, revenue.
228:12 - This is a problem, right?
228:14 - This is a huge problem for several reasons, but just, I mean, just think about it for
228:18 - a second.
228:19 - Imagine that you have multiple records in this table for a single company, which you
228:27 - obviously will, right?
228:28 - Because one company can have many users associated with it.
228:32 - So, you'll have like seven different records.
228:34 - They could each potentially have their own revenue.
228:37 - That doesn't make sense, right?
228:38 - A company can just have one revenue number, not different revenue.
228:43 - It's all the same company, right?
228:45 - So, this needs to belong on that individual company's record.
228:50 - Next, we've got an assignment for third normal form.
228:54 - So, this rollout of business accounts is really causing some headaches for our development
228:58 - team.
228:59 - The company's table has been a disaster.
229:01 - Our database architect pointed out that the idea behind the size field is redundant.
229:06 - If a company has more than 100 employees, we consider it large.
229:11 - Otherwise, we consider it small.
229:14 - Remove the size column from the company's table and alter the select statement to calculate
229:19 - a size field in the result set that works the same way.
229:22 - Okay, so, let's see if this is making sense.
229:25 - So, we've got a company's table, a company has an ID, a company has a name, it has a
229:28 - number of employees, and it has a size.
229:31 - So, the problem here is that these two columns are essentially the same because we can always
229:39 - calculate a size, as we've defined size, right, small or large, from the number of employees.
229:46 - It's fully dependent, is what we would say in kind of a normalization theory.
229:50 - It is fully dependent on the number, the num employees column.
229:54 - So, let's get rid of that field.
229:56 - It's a dumb field.
229:57 - It's a stupid field.
229:58 - It's gone.
229:59 - Now, we need to alter the select statement because if I run it in its current form, there
230:04 - is no size column, but we still want the size column in the result set, right?
230:09 - Theoretically, we have someone looking at this report.
230:12 - We want them to be able to at a glance see if it's a small or a large company.
230:16 - So, we'll just add a little calculation here.
230:19 - We'll say select star and we'll also select IFF.
230:26 - Remember, we learned this, we learned this function a few chapters back.
230:34 - We're going to do a comparison on if num employees is greater than, what, 100, and is more than
230:43 - 100, then we'll consider it large.
230:47 - Otherwise, we'll consider it small.
230:51 - And we want this to be named size.
230:53 - We want the column in the result set to be named size.
230:56 - Let's run that.
230:58 - Oh, what did I screw up?
231:04 - IIF, not IFF.
231:11 - I was reading it and I was like, IFF, IIF, that is honestly really terrible name for
231:17 - a function.
231:18 - Very confusing.
231:19 - All right.
231:20 - IIF, we got it.
231:21 - Does this look correct?
231:22 - It's 10,000 large, 1,000 large, 4 small, 12 small.
231:26 - This looks good to me, right?
231:27 - We cleaned up our table definition, but we're still getting a good report for our stakeholders.
231:33 - All right, we've got a quiz about voice cod normal form.
231:38 - So cast your mind back to the explanation of voice cod normal form.
231:43 - Remember that it's kind of weird and doesn't frankly come up very often, at least in the
231:47 - sense that the distinction between third normal form and voice cod normal form.
231:52 - Okay.
231:53 - The question is, when can a table be in third normal form but not voice cod normal form?
231:59 - It has multiple possible primary key combinations and one of the columns in a possible primary
232:04 - key is dependent on a column outside of that primary key.
232:09 - That's sounding right.
232:11 - That's sounding right.
232:12 - Can Raymond F. Boyce and Edgar F. Cod decree it so from on high?
232:18 - Eh, close.
232:19 - Not quite.
232:20 - It has a primary key that depends on another column that's not a primary key.
232:22 - No, that's not BCNF.
232:25 - It has multiple possible primary keys.
232:27 - Yep, not that one.
232:28 - It's going to be this top one.
232:29 - This next question is just, which should you optimize for first, generally speaking, reducing
232:36 - duplicate data or speed?
232:38 - Now this is really just kind of a rule of thumb in software engineering.
232:43 - This isn't like a hard and fast fact.
232:46 - But in my opinion, and I hold this opinion fairly strongly, generally speaking, you should
232:53 - start with just reducing duplicate data because you're going to have fewer bugs in your application
232:58 - that way.
232:59 - You'll be able to move faster as a team.
233:01 - You'll be able to fix bugs, ship features, refactor code, right?
233:05 - Do all of the things that you normally have to do as a developer.
233:07 - You'll be able to do them better if you don't have to deal with duplicate data, right?
233:13 - If you have speed problems that can easily be solved or are best solved by introducing
233:21 - some duplicate data, that's okay.
233:24 - It's not like you can never, ever, ever have duplicate data, right?
233:28 - I mean, at the end of the day, caching just is duplicate data, right?
233:33 - It's not necessarily a problem, but cache invalidation is hard, right?
233:37 - So we kind of stay away from it as long as we can.
233:44 - This next question is when you don't need a composite key, and remember a composite
233:47 - key is just when you have like two unique columns together, right?
233:52 - So in the example of a joining table, we don't have an ID primary key column necessarily,
233:58 - right?
233:59 - We can just do a composite key on two different columns, right?
234:02 - So when you do not need a composite key, what should the name of your primary key's column
234:07 - be?
234:08 - I may have just given away ID is a very conventional name.
234:12 - This isn't, again, this isn't a hard and fast rule.
234:14 - It's not like your application is going to break if you name the column key or identifier
234:18 - or skeleton key, but like everyone uses ID, just freaking use it.
234:25 - Like, why don't be confusing, right?
234:28 - It's kind of like how everyone uses I in loops, right?
234:32 - Or I less than zero, like there's just a convention around some things in programming.
234:40 - And if you stick to them, it'll make your life a little bit easier.
234:43 - This question is which is more important for your career in backend development, memorizing
234:47 - the exact definitions of first, second, third, and Boyce Cod normal form, or internalizing
234:53 - simple rules of thumb regarding database normalization?
234:58 - The answer is internalizing the simple rules of thumb.
235:02 - That's going to make you a much better backend engineer, in my opinion, right?
235:06 - You do not need to know the exact definitions of these, of these normal forms.
235:10 - They are useful theoretical exercises for us to think about normalization, right?
235:15 - But these rules of thumb, right?
235:18 - Things like adding primary keys to all of our rows, avoiding duplicate data, not storing
235:25 - data that's completely dependent on other data, right?
235:28 - Having our schema simple, those things are what you're going to really use day to day
235:33 - and what you need to keep top of mind.
235:36 - Trying to hold the full academic definitions in your head is just going to be confusing.
235:44 - Finally, we've gotten to joins.
235:49 - Now joins are actually one of the most powerful features of relational databases.
235:53 - In fact, without joins, it almost wouldn't even make sense to worry about all these different
235:58 - complex relationships between tables.
236:01 - To put it as simply as I can, a join is just a way to query multiple tables in an SQL database
236:07 - at the same time.
236:08 - Now the first type of join that we're going to talk about is called an inner join.
236:12 - It's also kind of the simplest and the most common type of join.
236:16 - So by default, a join command is an inner join.
236:19 - So if you just use the join keyword in an SQL statement, you'll be doing an inner join.
236:25 - And an inner join returns all of the records in table A that have a matching record in
236:31 - table B.
236:33 - So we have two tables, right?
236:35 - And we'll get to the syntax of a join here in just a second, but understand that what
236:40 - we're talking about is we've got some number of rows in table A and we've got some number
236:45 - of rows in table B. Let's say we have 100 rows in each.
236:49 - When we write our join query, we're trying to get a single result set back, right?
236:55 - So if we got all of those rows back, we'd get 200 rows, right?
237:01 - Well an inner join is just saying, I don't want necessarily all of the rows.
237:08 - I want all of the rows that exist in both tables, right?
237:12 - And we typically link on some sort of ID.
237:15 - So you can see by this diagram, essentially what we're saying with an inner join is I
237:20 - just want the set of rows from both tables that exist in both tables, right?
237:26 - So let's say that in table A we have 100 records and 25 of them share some ID, some linking
237:34 - key with table B. It's only those rows that we're going to return in the result set.
237:41 - Let's take a look at an actual example.
237:44 - So here we've got some SQL, says select star from employees, right?
237:49 - So employees is in this case table A. Inner join departments, in this case departments
237:56 - is table B. And now we have this new keyword, the on keyword,
238:02 - which is used in tandem with a join.
238:05 - So this describes how we're going to join.
238:09 - It describes that key relationship.
238:11 - So inner join departments on employees dot department ID equals departments dot ID.
238:20 - So in this case, we're saying we want all of the rows where on the employees table,
238:28 - the department ID matches a row in the departments table with that same ID.
238:34 - Does that make sense?
238:36 - Think about it for just a second.
238:37 - Let's jump into the assignment and hopefully it will start to make sense as we go through
238:41 - some examples.
238:42 - So the assignment says our front end team is working on a profile page and would like
238:45 - to display a user's country name instead of just the country's two letter code.
238:50 - Let's start by writing a simple join between the user's table and country's table.
238:54 - We will expand on this query more in the next exercise.
238:57 - Okay, so write an inner join between users and countries.
239:00 - So it's going to, and then the next bullet point says return all fields from both tables.
239:04 - Okay, so select star from start with the user's table is table a so select star from users
239:16 - inner join between users and countries join on the country code field.
239:23 - So inner join the name of table B countries on running at my spacing, right?
239:34 - This is embarrassing.
239:35 - There we go on users dot country ID node be users dot country code.
239:44 - Let's take a look at the setup code so we know what we're working with.
239:47 - Okay, yes, the user's table has a country code.
239:50 - Users dot country code equals take a look at the country's table.
239:58 - Country's table dot also country code, okay, so we're saying give me all the rows from
240:06 - sorry all the fields from the user's table, inner join all of the fields and rows from
240:14 - the country's table where the country codes match on both tables.
240:19 - Okay, let's go ahead and run that.
240:24 - And I want to point out something that's interesting here.
240:27 - We'll see we have some duplicate column names.
240:31 - That's because when we do select star from users inner join countries, we're going to
240:35 - get every field from both tables.
240:39 - So first we're getting all of the fields from table a right ID name age country code username
240:43 - password is admin, and then all of the fields from table B, right kind of mashed together
240:50 - in the result set.
240:51 - So this feels right to me, I'm going to go ahead and submit that.
240:55 - Moving on, talk about name spacing on tables.
240:58 - So when we're working with multiple tables, we can specify which table a field exists
241:02 - on by using the dot, right, we use this in the last in the last example.
241:06 - So this kind of follows a similar pattern to different programming languages where you'll
241:10 - use this for like objects, right, like you might have a student object and if you want
241:14 - the field, you would do dot name.
241:16 - So SQL luckily uses a very similar syntax, right, we can do table name dot column name
241:22 - in order to access a column on a specific table.
241:25 - In fact, you'll get yelled at if you're trying to work with two different tables and you
241:30 - use the name of a column that's ambiguous.
241:33 - In other words, it exists on both tables, you kind of have to tell SQL like, you know,
241:38 - I'm using the name field on the students table, not the name field on the classes table.
241:42 - This will come up a lot when you're using common class names like ID, sorry, not common
241:47 - class names, common field names or common column names like ID or name.
241:53 - So this query returns the name field from the students table and the name field from
241:56 - the classes table.
241:57 - Yep.
241:58 - Makes sense.
241:59 - Moving on to the assignment, it says adjust the query to return the name and age fields
242:05 - from the users table, return the name field from the countries table and rename it to
242:11 - country name, sort by the country name as any order.
242:14 - All right, so let's fix the fix the select first.
242:16 - In fact, I'm going to run this so we can see the data that we're working with.
242:21 - Okay, we got we got a bunch of stuff there.
242:26 - So we're going to change this star, which is just all fields to be a little more explicit.
242:32 - So users dot name, users dot age.
242:37 - At this point, it's probably good for me to point out a convention here, you'll notice
242:43 - that it's kind of considered best practice to name tables in the plural sense.
242:49 - So we wouldn't have a user table, we should have a users table.
242:55 - That's just, it's just good convention, it kind of makes sense when you think about it,
242:59 - right?
243:00 - The users table holds many users.
243:02 - So you'll see that come up a lot.
243:04 - All right, users dot name, users dot age, return the name field from the countries table.
243:08 - So countries dot name as country name, and then sort by the country name in ascending
243:21 - order.
243:22 - So order by country name, sending.
243:30 - And remember, we can use this column name because we defined it up here.
243:37 - And that's who we get.
243:41 - Name age country name.
243:42 - This looks good to me.
243:44 - All right, so we talked about how the inner join is kind of the default join.
243:48 - In fact, you don't even have to write inner join in your SQL queries, you can just write
243:52 - join and it will perform an inner join.
243:54 - Left join, however, is a little bit different.
243:57 - Essentially, what left join says is it will return every record from table A, regardless
244:04 - of whether or not that record has a match in table B, right?
244:09 - So like, we're always getting every record from table A, regardless of the on clause
244:14 - in the join query.
244:16 - Right?
244:17 - However, table B, we'll still only get rows that do have a match in table A. Okay?
244:24 - All right.
244:27 - A small trick you can do to make writing the SQL query easier is to define an alias for
244:31 - each table.
244:32 - This is also just an important thing to understand.
244:34 - When you start working with a lot of SQL queries that start to get really long and really verbose,
244:40 - you'll see people alias table names, typically to make it shorter.
244:45 - So like aliasing the employees table as E, right?
244:52 - I don't think that's necessarily a good idea all of the time.
244:57 - The only time I recommend using an alias in order to shorten a name is if you're doing
245:03 - like a lot of manual queries and you're just trying to type faster, right?
245:07 - Like your bottleneck is your typing speed.
245:10 - When you're writing queries that are going to be used for a long time, like you're not
245:13 - just kind of running them one off against a database, like say you're saving them in
245:17 - your code base for your back end system to run, you probably don't want to alias your
245:22 - employees table to just be E. That only serves to make your code harder to read.
245:27 - Okay.
245:28 - Let's hop into the assignment.
245:29 - Hopefully this will help us understand left joins a little bit better.
245:32 - It says the cashpal team needs to report on all the transactions each user has made.
245:37 - Join the users and transactions table.
245:38 - Okay.
245:39 - So it looks like what we're going to want here is a result set that includes a row for
245:44 - every single user in cashpal, regardless of whether or not they have a transaction, right?
245:50 - Be sure to still return user records of users who have no transactions, right?
245:52 - So we want every single user record, right?
245:56 - And then we only care about the transactions that actually are associated with a user.
246:03 - If there's like orphan to transaction records, which means like they, they are not attached
246:07 - to a user in the users table.
246:09 - Like we can just discard them.
246:10 - We don't care about them.
246:12 - Okay.
246:13 - So let's jump right into it.
246:15 - Select says three fields, uh, users.name, name, uh, the user.
246:25 - Uh, the sum of transactions, dot amount, grab my comma as some count of transactions, dot
246:41 - ID as count.
246:44 - Now the reason I'm doing transactions, dot ID here and not just star is because I only
246:48 - want to count the transactions records, not all the user records, right?
246:54 - Okay.
246:55 - Uh, from users, left, join transactions.
247:01 - Now why am I doing it this way?
247:02 - Right?
247:03 - Why am I doing users, left, join transactions instead of transactions, left, join users?
247:07 - Well, the reason is because I want everything from the users table.
247:10 - So users needs to be table a, right?
247:13 - I want every user.
247:14 - I don't necessarily need all the transactions.
247:16 - I only need the transactions that are related to users on right users where we do our linking
247:23 - key.
247:25 - So users, dot ID equals transactions, transactions, dot user ID.
247:33 - Now we're using some aggregations here, right?
247:36 - Count and sum.
247:37 - So we need to tell SQL how we want to group our rows group by, um, users, dot ID.
247:48 - Let's run that really quickly and see what we get.
247:53 - Okay.
247:54 - First of all, does that look like the right amount of users?
247:56 - Let's take a look at our input data.
247:59 - Al, Alvin, Albert, yeah, this looks like, looks like we got all the users successfully.
248:09 - And you'll notice we have some missing data, right?
248:12 - We have, uh, null sums and zero counts.
248:18 - And that's good because that means everything's working, right?
248:23 - We have some users that don't have any transactions yet.
248:26 - So this is what we'd expect to see.
248:28 - Now there was one last constraint that we forgot to add up front, so let's go ahead
248:33 - and add that now.
248:34 - It says, be sure to order the data by the sum field and descending order.
248:38 - So order by some descending, run that cool, that looks a little more digestible, right?
248:47 - Bring everything sorted nicely and submit it.
248:50 - Now it makes sense that if we have a left join, there would also be a right join, but
248:55 - to be honest, right join is pretty dumb.
248:59 - Like there's really, there's really not a reason to use it.
249:03 - Um, in fact, SQL light doesn't even allow right joins, although some other s dialects
249:10 - of SQL or database technologies do allow you to use a right join.
249:14 - If you think about it, the whole idea behind a right join is kind of redundant.
249:19 - Instead of using a right join and ordering tables, A and B, where B is the table you
249:25 - want all the records from, you can just swap the order of the table names, right?
249:30 - And use a left join.
249:31 - So that's why I think left SQL light actually took kind of a good stance on this and said,
249:36 - look, we don't need right joins because just change the ordering of your tables and we'll
249:41 - just kind of force you to always make the first table, the one you get all of the rows
249:45 - from.
249:46 - I think it makes it easier to think about that way.
249:48 - So the question says we can retrieve the same records with a right join and a left join
249:53 - by grouping the table by a different field, giving up and drawing Venn diagrams, changing
249:59 - the field on the table, changing the field that the tables are joined on or flipping
250:03 - the position of the tables in the joint statement.
250:05 - It's going to be flipping the position of the tables.
250:07 - Now next we've got a full join and full join actually is different, but it kind of does
250:13 - what you expect.
250:14 - It just returns all the rows from both tables.
250:18 - Now something I want to point out that I don't think I've necessarily given enough attention
250:22 - to is that joins don't really operate on columns, right?
250:28 - They operate on rows.
250:30 - So when I was first learning SQL, I kind of got hung up on joins and I was a little confused
250:37 - thinking that like this Venn diagram represented all the fields in table A and all the fields
250:42 - in table B or all of the columns in table A and the columns of table B.
250:46 - That's not what's happening here.
250:47 - We're talking about the rows, right?
250:51 - So a full join will just return all of the rows from both tables.
250:58 - And like we've seen before, what it does when there's, uh, you know, what it does in relationship
251:03 - to the columns is just that it matches them all together, right?
251:07 - You'll get all of the columns from table A and then all of the columns from table B.
251:10 - Um, but you can control which columns you get back just like you normally would in the
251:15 - select statement.
251:16 - Right?
251:17 - It doesn't really have anything to do with the joins.
251:19 - So the question here is select the best scenario to use a full join when you need the matching
251:25 - results from two tables, when you need every single row from two tables, whether or not
251:30 - they're related.
251:31 - When you need all results from one table and matching results for another, or when you
251:34 - need all the results from a single table, um, it's going to be this one when you need
251:37 - every single row from two tables, whether or not they're related, uh, next we've got
251:42 - this little quiz.
251:43 - It says given the tables and the query, which join type produces the result.
251:48 - Okay.
251:49 - So we've got this users table here and a transactions table here and a result below.
251:59 - Okay.
252:02 - So which joint type produces the result?
252:05 - Well, the result does not have the same number of rows as either table, which means it has
252:12 - to be a subset, right?
252:15 - Can't be a left join can't be a full join because it only has three rows and the transactions
252:20 - table is the smaller table with four rows.
252:22 - So we're getting a subset, which means this has to be an inner join.
252:25 - All right, we got some different data now.
252:28 - And we're being asked the same question.
252:30 - So now let's see, we've got one, two, seven users and four transactions.
252:40 - And in the result set, it looks like we've just duplicated the user row once, which makes
252:49 - me think, let's see, makes me think that we've got, we could potentially have a left join
253:04 - going on here.
253:05 - And actually I should point this out because when we did our left join exercise, we did
253:10 - a group by, which means, uh, we kind of, you know, we got the exact same number of rows
253:16 - in our result set as table A.
253:19 - But if you don't do a group by and aggregate your table B rows, you can from a left join
253:27 - actually get more rows in your result set.
253:31 - Then we're on your left side, you're like your left hand table.
253:36 - That makes sense.
253:39 - Because you'll get one row per like related, uh, per relationship.
253:46 - So, um, select star from users, left join transactions on user ID equals transactions.userID.
253:57 - This is a left join.
254:00 - This is a left join because we don't have every transaction, right?
254:04 - If I check the transactions, we've got one, two, three transactions, transaction IDs,
254:10 - we're missing transaction ID four.
254:12 - So this is a left join.
254:14 - Now again, I just want to point this out really quickly.
254:18 - Here in the result set, we have two records for David and you might be wondering why.
254:26 - Because when we did our left join exercise earlier, this wasn't the case.
254:30 - The reason for that is because David is the only user here that has two transactions,
254:36 - right?
254:37 - So we get one row back for David and we get all that data and we get his, essentially
254:44 - his first transaction.
254:45 - In this case, the transaction with ID three, and then we get another row for David with
254:50 - his data for transaction one.
254:52 - And this is the default behavior when you run a join, right?
254:57 - You get all of the combinations of the relationships between the rows and the tables.
255:03 - The reason that we did not get multiple records for our users earlier was because we did a
255:10 - group by aggregation on our table B, which we could do here in order to smash those rows.
255:19 - So just be aware that's what's going on.
255:21 - All right, we got another quiz, new result set.
255:26 - Okay, this one's looking like it's actually based on the transactions table.
255:30 - And if we look at the query, we've got select star from users, blank transactions.
255:35 - So in this case, could be an inner join, but let's see, could it be an inner join?
255:47 - No, it's not an inner join because the last row in the result set does not have a user
255:54 - associated with it.
255:55 - It's not an inner join.
255:57 - It's definitely not a full join.
255:58 - This is a right join because transactions is table B down here in the query, right?
256:05 - So we get all the rows from table B and only the associated rows from table A.
256:11 - All right, time for some joining practice.
256:14 - Joins take some time to get used to, but the key to understand and using them effective
256:18 - is practice.
256:19 - That couldn't be more the truth.
256:22 - You just got to write a lot of SQL sometimes.
256:24 - Okay, multiple joins.
256:26 - To incorporate data from more than two tables, you can multiply multiple joins.
256:30 - Okay, so select star from employees, left join departments on employees.departmentid
256:35 - equals departments.id, inner join regions on departments.region.id equals regions.id.
256:40 - Cool, right?
256:41 - So we can potentially join lots of tables together.
256:45 - One thing I will point out, and I think we'll talk about this more in the next chapter,
256:48 - is that depending on how much data you're joining together, this can be a reason that
256:53 - queries get slow.
256:54 - So you know, just keep that in mind as you're architecting backend systems, if you're planning
257:00 - on using a lot of joins for queries that have to happen, say, maybe many times per second,
257:05 - you might start to get some slowness in your app.
257:09 - Okay, assignment says our front end team is finalizing the profile page for cashpal.
257:14 - We need to write a query that returns all the user data they need for an individual
257:17 - user's profile.
257:19 - The query needs the following fields.
257:21 - Okay, return only a single user record, specifically the one with ID equals six.
257:29 - Okay, how many tables are we working with here?
257:32 - We are working with looks like a user's table, a country's table, and a transactions table.
257:41 - Okay, so select, return only a single user record.
257:45 - So users.star, sounds like single user records, specifically the one with ID equals six, users.star
257:55 - from users.
257:58 - Now we don't want to do some joining.
258:01 - Now how do we want to do this joining?
258:04 - Oh, the query needs to return the following fields.
258:06 - Okay, sorry, I missed that.
258:08 - So we need to do users.id, we need to do users.name, users.age, users.username, user's country
258:25 - name or name to country names, it's actually going to be, that's going to be on the countries
258:29 - table.
258:30 - So countries.name is my guess as to how that's named, we could probably look here.
258:37 - Yeah, countries.name, okay.
258:44 - And then we also need the sum of the user's transaction amounts.
258:49 - So I misspelled users.
258:54 - So sum of transactions.amount as balance.
259:01 - Okay, so that's the data we're selecting.
259:05 - Now let's think about our joins.
259:08 - So we know we're going to be filtering this down just to a single user row.
259:17 - So we just want to make sure that we don't have any duplicate rows, right?
259:21 - We want just one row for the user.
259:26 - So thinking, when we join the countries table, I think we can just do a regular old join,
259:39 - which is, I mean, it's the same thing as an inner join, right?
259:42 - Inner join countries.
259:47 - What this means is if the user doesn't have a country, we won't return a row for them.
259:54 - So actually, I don't like that.
259:56 - We should probably do a left join here, because we want that user record either way.
260:01 - And if they don't have a country associated with them, we should probably just leave,
260:05 - like we should just be okay with this column being blank.
260:07 - So let's left join that.
260:09 - Left join countries on users.country code equals countries.country code.
260:21 - Okay, now transactions, we definitely want to left join on.
260:26 - Again, just in case, you know, there are no transactions.
260:30 - We want like a balance of zero, for example.
260:32 - So left join transactions on transactions.userid equals users.id.
260:45 - And because we're aggregating the transactions, we'll need to do a group by.
260:48 - So group by users.id.
260:56 - And that should get us pretty close.
261:00 - Let's run that.
261:01 - No such column users.identity.
261:02 - Oh, my autocomplete is killing me.
261:06 - There we go.
261:08 - Okay, so this is looking correct.
261:11 - We've got one row per user.
261:13 - I think the only thing we need to do now is filter down to a specific user.
261:17 - So we can just end this whole thing.
261:20 - Actually, we don't end because where goes before the group by.
261:24 - We just say where users.id equals six, six, right?
261:37 - Run that.
261:40 - Cool.
261:41 - Alan, Alias, we've got the country name.
261:45 - Ooh, do we need to rename country name?
261:47 - Yeah, that was close.
261:48 - I almost missed that.
261:49 - Countries.name as as country name.
261:54 - This is really common, right?
261:55 - Where you have two names, two column names that are identical, name and name.
262:02 - And so you want to change the name of one of them in your result set so that you get
262:05 - something that makes a little more sense.
262:08 - Cool.
262:09 - Submit it.
262:10 - We're on the home stretch now.
262:13 - We're in the last chapter where we're going to talk about performance.
262:16 - Now I've mentioned this before, but really performance with your database is actually
262:21 - one of the last things that you need to think about when you're designing how you're going
262:25 - to set up your database, right?
262:27 - Which database technology you use and how you're going to architect your schema performance
262:32 - is important.
262:33 - Don't get me wrong, but getting the data, right?
262:36 - Having the data, you know, reducing data duplication, increasing data integrity.
262:42 - Those things are generally speaking more important because it'll stop you from shooting yourself
262:48 - in the foot with bugs.
262:50 - Performance is something that you typically want to optimize for once you start having
262:55 - performance problems or once you know that performance problems are going to start happening
263:00 - in the near future, right?
263:02 - Maybe you're onboarding tons of new users every week.
263:05 - That's when you really should start be thinking, you should start thinking about performance
263:08 - for the first time.
263:09 - So at the heart of performance in SQL databases is the index, the index, SQL indexes.
263:17 - And an index is really just an in-memory structure held onto by the database that ensures that
263:23 - queries we run on our database are performant, which just means that they run quickly.
263:29 - If you have taken a data structures and algorithms course, and if you haven't, that's fine, actually
263:35 - have a data structures and algorithms course on boot dev that you can go check out.
263:39 - If you are not familiar with DSA, but if you are, a binary tree is one of the most popular
263:47 - data structures.
263:48 - And in fact, binary trees are what are typically used by SQL databases under the hood in order
263:54 - to create indexes.
263:56 - And without going too far into the weeds, a binary tree is really just a tool that we
264:04 - can use to efficiently find a value in a sorted list of values.
264:11 - So when you think about an ID column on a database, IDs are sortable, right?
264:18 - We can sort them into a list.
264:20 - And then by using a binary tree, we can perform a, essentially a binary search on that list
264:25 - and very efficiently find the value we're looking for, right?
264:31 - In other words, if we have a million rows in our database, and we do a lookup by ID
264:37 - on that database table, our database, if it's using an index, will not have to scan every
264:45 - row in the database to find the row we're looking for.
264:49 - Instead, it can use the index to very quickly use that binary tree that binary sort to find
264:56 - the key it's looking for, and then go directly to that row.
265:01 - So in big O notation, looking up using an index is a log N lookup, rather than an N
265:09 - time lookup.
265:11 - If that just went way over your head, go check out my data structures and algorithms course.
265:17 - But really, the only thing you need to know is that the index makes the lookup a lot faster.
265:23 - So let's check out the create index syntax.
265:28 - So in order to create an index on our database table, we just use the create index query,
265:35 - we create an index name, technically, we could call it anything, but probably a good idea
265:39 - to make it descriptive on a table and on a specific column in that table.
265:46 - It's fairly common to name an index after the column it's created on with a suffix of
265:49 - IDX.
265:50 - So for example, email IDX, if you want to index the email column.
265:55 - So I just want to point out like, why and when would you do this, right?
266:00 - Well, let's take the users table, for example.
266:04 - Right now, we have an index on the ID column, because by default, if you specify a primary
266:12 - key on a column, that column will be indexed automatically.
266:17 - But what if we are constantly looking up users in this database by their email and not by
266:24 - their ID, right, the ID is the primary key, but maybe like on the login page, for example,
266:31 - the users aren't supplying their IDs, they're just supplying their emails.
266:34 - So we need to do a query and look up the users by emails.
266:36 - Well, that query is going to be slow if we don't have an index on that column, right?
266:45 - It's not going to be slow if we only have like 1000 records or 10,000 records, but it's
266:49 - going to get very slow once we have 1 million records or 10 million records.
266:54 - So at that point, it gets really important, we need to think about how we index our columns.
266:59 - So the assignment says here, as it turns out, the front end frequently finds itself in a
267:02 - state where it knows a user's email, but not their ID, right?
267:05 - This actually is very common.
267:07 - Let's add an index to the email field called email IDX.
267:10 - Okay.
267:12 - So here, we're going to create an index.
267:15 - We're going to call it email IDX on the user's table, column name, email.
267:30 - Cool, let's run that.
267:36 - And you can see down here, I'm just doing, we're just doing a little select on the SQL
267:40 - light master to get to make sure that the index was created properly.
267:46 - All right, now it's important to talk about when we should index things because you may
267:52 - be thinking to yourself, well, if indexes just make everything fast, then let's just
267:57 - add indexes on every column in the database, right?
268:01 - That's actually not a good idea for several reasons.
268:04 - But really, one of the best reasons is that actually creating the index does have some
268:11 - overhead to it.
268:13 - So when you create an index on a column, what you're telling the database to do is to now
268:19 - keep an in-memory store of the data in that column, right?
268:25 - So rather than just storing it on disk, it's now going to bring it into memory.
268:29 - So indexes have a non-zero memory cost to create them, right?
268:35 - Even though they make queries faster when you run the queries, they can actually bloat
268:39 - like memory usage of the database as an example.
268:42 - There's other things too.
268:44 - For example, now when you insert a row into that table, the binary tree actually has to
268:52 - do an insert operation, which is a little slower than if it didn't have to do that.
268:58 - So if you've got hundreds or thousands of indexes on a very large database, you might
269:03 - start to see other kinds of performance problems.
269:07 - So as a general rule, I would argue it's best practice to not create indexes until you have
269:15 - a good use case for them, right?
269:17 - Until you need them to speed up an individual query.
269:21 - So the question here is, a binary tree index makes lookups, and this is in big O notation,
269:28 - order log n, order n log n, order n squared, or order n.
269:34 - And the answer is that it makes the lookups order log n, which is extremely fast.
269:39 - And again, I don't want to do like a crash course on data structures and algorithms in
269:45 - the middle of this SQL course, but if this is going over your head, please feel free
269:49 - to go check out my algorithms and data structures courses on boot.dev.
269:55 - Last question says, add indexes to blank, all columns, only foreign keys, columns that
270:01 - you frequently perform lookups on or only primary keys.
270:06 - And the answer is columns that you frequently perform lookups on, right?
270:10 - Once you understand that you're doing a lot of lookups on a column, and that those queries
270:15 - are starting to get slow, that's a good time to go add an index to that column.
270:22 - It's also worth pointing out, by the way, that when I say doing a lookup on a column,
270:29 - I'm talking about the where clause, I just want to be specific about that, right?
270:33 - Like in the example of the users table, it'd be like, select star from users where email
270:39 - equals X, that's a lookup on the email column.
270:44 - So the email column would need an index, right?
270:46 - An index on the ID column, in that case, does you no good.
270:50 - Last question says, indexes slow down blank, write speed or read speed.
270:55 - Now my assumption here is that when we say read speed, we mean lookup speed, right?
270:59 - And they definitely don't slow down lookups, they speed up lookups, but they can slow down
271:03 - writes, right?
271:05 - Now every time that you insert a row into a database, you need to update all of your
271:11 - in memory binary trees in order to keep them up to date, which again, makes sense if you
271:16 - understand how binary trees work.
271:19 - Because essentially you do some upfront work to make the lookups much faster down the line.
271:26 - Now we've talked about single column indexes, which are fairly straightforward.
271:31 - But there's also multi column indexes.
271:34 - And they're useful for exactly why you might think, right?
271:38 - It's when you need to do a lookup based on more than one column.
271:42 - Okay, so let's look at the syntax.
271:45 - We've got create index on blank, sorry, create user or create index, index name on users,
271:53 - and then all the columns in the index, right?
271:56 - So in this case, the first name column, the last name column and the age column.
272:01 - Okay, it's important to understand that a multi column index is sorted by the first
272:05 - column first, right?
272:08 - So the order of these columns or the order of these fields do matter for performance
272:13 - reasons.
272:14 - A lookup on only the first column in a multi column index gets almost all the performance
272:19 - improvements that it would get from its own single column index.
272:22 - Okay, so what do I mean by that, right?
272:25 - In the case of this index here, if I just did select star from users, where first name
272:31 - equals lane, that would be very fast, right?
272:36 - It would get basically all of the performance benefits from from this multi column index
272:43 - because I was just using the first name field.
272:47 - However, if I did a lookup based on just the last name or just the age, so for example,
272:52 - select star from users where last name equals Wagner, I would not get all that big a bump
272:59 - in performance improvements.
273:02 - Because first, the database needs to essentially guess at the first name, or do like a full
273:07 - table scan, right?
273:10 - So the order matters here, like first we care about the first name, then the last name,
273:14 - then the age.
273:15 - So the reason you would do this is if the query that you're running, your hot query
273:21 - that started to get slow, is a where on like all three of these things, right?
273:27 - So like select star from users where first name equals blank and last name equals blank
273:32 - and age equals blank, or whatever, right?
273:35 - So that's the reason behind why you would use a multi column index and just understand
273:41 - that you can essentially repurpose it as an index for the first column.
273:46 - So like you wouldn't need to go add a second index for just the first name, probably.
273:52 - And I just say I add that probably at the end, because technically SQL is just a query
273:58 - language and under the hood, every database acts a little bit differently.
274:01 - So it's always just something to keep in mind.
274:03 - Okay, so rule of thumb, unless you have specific reasons to do something special, only add
274:08 - multi column indexes if you're doing frequent lookups on a specific combination of columns.
274:13 - All right, let's jump into the assignment says we frequently need to look up all of
274:17 - the transactions between two specific users.
274:20 - There's a page on the website that allows a user to look up all the payments they've
274:22 - made to a friend by the friend's name, add an index on the user ID and recipient ID columns
274:28 - called user ID recipient ID IDX to speed up our app.
274:32 - Make sure the user ID is the first column in the index so that we can also use this
274:36 - index to speed up our queries that only care about the user ID.
274:40 - Okay, so create index, we wanted to name it user ID recipient ID IDX.
274:52 - And we're using that on keyword again, right, you'll you'll recognize the on keyword from
274:56 - joins, right, on which table the user's table, no, transactions tip, it's gonna be the transactions
275:07 - table.
275:08 - Yeah, transactions table right there on transactions.
275:14 - And then the field names, it says we want to make sure to use the user ID on first so
275:19 - that when we just query based on user ID, it's still fast, then the recipient ID.
275:26 - Perfect, let's run that.
275:30 - Looks good to me.
275:31 - All right, we had a whole chapter on normalization.
275:34 - Now let's talk about D normalization, right?
275:38 - So you'll remember that I mentioned during the normalization chapter, the generally speaking
275:43 - normalization is a good thing.
275:45 - And you want to normalize your databases, right?
275:47 - You want to reduce data duplication, improve data integrity, all those good things.
275:52 - Well, it turns out that sometimes all that normalization does come at a cost, right?
275:59 - When you get to certain levels of scale, all that normalization, all of those foreign keys,
276:05 - the linking relationships, the join queries, the sub queries, they can start to get slow,
276:11 - because your database technology is trying to do all of that heavy lifting for you all
276:16 - of the time, right?
276:18 - So sometimes, again, I really want to say sometimes you'll run into issues that really
276:24 - can only be solved well by actually denormalizing your database.
276:28 - And what that usually means is introducing duplicate data so that you can speed something
276:34 - up, right?
276:36 - So the question here is denormalizing a database can be used to slow down queries or speed
276:42 - up queries, and really, the answer is to speed up like that's the only reason you would ever
276:49 - like denormalize a database like I don't know why you do it to slow down the queries.
276:54 - The next question is, it's smart to start with a blank database and blanket as needed
276:58 - for speed.
276:59 - So I would argue it's smart to start with a normalized database and only denormalize
277:04 - it as needed for speed.
277:05 - We haven't really talked about this yet, but why does adding duplicate data speed up the
277:14 - database?
277:15 - Or why can it speed up the database?
277:18 - Well, the answer is that when you copy data, you frequently are putting it in a different
277:25 - format that makes it easier to get at makes it easier to access, right?
277:31 - So let's take the example of like an aggregation.
277:33 - Let's say we want to know how many transactions a user has, right?
277:38 - We can write a join query on the users and the transactions table and do a count on all
277:43 - the transactions and return the count of the transactions and voila, right?
277:47 - We have a count.
277:49 - That was a lot of steps just to get the count of transactions, right?
277:52 - If we just store the current number of transactions separately in, say, like a table called transactions
278:00 - count, now our query to get that transactions is like just one, a very simple query that
278:07 - can be performed very quickly as like a primary key lookup, right?
278:12 - Like select star from transactions count where user ID equals blank, right?
278:17 - That's a very fast query.
278:18 - There's no aggregation involved.
278:20 - We like essentially pre-aggregated by keeping that field up to date.
278:25 - Now again, you have a problem when you do this because it means now like what happens
278:32 - when you have 10 transactions in the transactions table, but your count says 11, right?
278:39 - You've introduced a potential problem or data integrity in your database.
278:44 - So this isn't something you initially want to do.
278:47 - However, when your app gets unbearably slow, because every time a user loads a specific
278:53 - page, you're doing some huge aggregation.
278:56 - It can make sense to de-normalize, to pre-calculate, right?
279:02 - Just for the sake of speed.
279:04 - So start with normalize, de-normalize as needed.
279:07 - A blank database is easier to keep bug free, de-normalized, it's the same or normalized.
279:12 - I would argue a normalized database is much easier to keep bug free because it ensures
279:17 - that your data is more accurate.
279:19 - You couldn't have a SQL course without talking about SQL injection or SQL injection.
279:25 - This is like the most famous kind of security vulnerability that you can build into your
279:30 - apps if you're not careful.
279:34 - This is a fantastic comic by XKCD.
279:37 - Feel free to pause it and read it.
279:38 - It's hilarious.
279:39 - Go look it up online.
279:40 - Whatever.
279:41 - I love it.
279:42 - Okay.
279:43 - But let's talk about why the joke in this comic works.
279:47 - So let's pretend that we have this query.
279:53 - Insert into students name.
279:57 - So we're inserting into the students table the name column, values, and then a question
280:02 - mark.
280:03 - So we're going to insert some dynamic value into this table, right?
280:07 - So imagine we've got some backend server that has this query programmed into it, and it's
280:11 - going to insert a student's name maybe based on the form input on the website, right?
280:17 - So you can type in your name, click enter, and save a new student in the database.
280:24 - If we're allowing our users to inject any old string into our SQL query, then we can
280:32 - open ourselves up to some vulnerabilities.
280:35 - So in this example, if the user is effectively allowed to put whatever they want in this
280:39 - question mark here, under normal circumstances, we would expect them to just put their name,
280:45 - right?
280:46 - Lane, Allen, whatever.
280:48 - But if instead they put this disgusting little snippet of text, they can actually, you know,
280:59 - rewrite the query a little bit.
281:00 - So instead of this, now we have this filled out version with insert into students name,
281:07 - issues, Robert, semicolon.
281:11 - Now remember a semicolon in SQL terminates the statement.
281:16 - So whatever comes after it is now a new statement, right?
281:20 - So in this case, what this person did was they altered the SQL to now be two statements,
281:26 - the first one inserting a student named Robert, but the second, but the second statement just
281:32 - says drop table students, which means delete the table, right?
281:37 - So by allowing our users to put anything into our SQL queries, we can open ourselves up
281:43 - to this kind of an attack or someone just, someone just destroys your whole database
281:47 - table.
281:48 - So the answer to this, like the way you stop people from doing this is by sanitizing your
281:53 - inputs, which means you're basically detecting this kind of crap and not allowing it to happen.
281:59 - And you might be wondering, Oh no, that sounds like a big pain in the butt.
282:02 - I'm going to have to write some really sophisticated algorithms to stop SQL injection.
282:07 - No, in practice, you, you will not have to do that because those libraries exist, right?
282:14 - So for example, if you're writing go, the go standard library has a SQL package that
282:23 - allows you to like do variable interpolation, right, putting dynamic values into your SQL
282:29 - in a safe way that protects against SQL injection.
282:32 - And basically any database library worth its salt in any programming language is going
282:39 - to take care of that for you.
282:40 - Sure.
282:41 - It's worth looking up and making sure that your database technology does that for you,
282:46 - but you need to, your database library, your data's client does that for you.
282:51 - But just, just, just know that you don't need to be writing it from scratch.
282:54 - You should be finding a tool that does this for you.
282:57 - There's plenty of open source tools that do that.
283:01 - The most common mistakes that the developers make surrounding SQL injection, or I should
283:06 - say the most common mistake that developers make is rather than using a library's ability
283:12 - to do safe interpolation, developers will just use like normal string concatenation
283:20 - in whatever programming language they're using.
283:23 - So, so don't do that.
283:25 - Don't do like normal string concatenation where you have like your SQL and just like
283:29 - a raw string and you're just injecting values into it manually using whatever like the default
283:35 - language features are, right?
283:36 - In JavaScript, it would be template liberals in go, it would be like fmt.edsprintf.
283:42 - In Python, it would be fstrings.
283:44 - Like don't use those to put dynamic values into your database, right?
283:51 - Your database client should have a built-in way to do it that's SQL specific.
283:55 - So the question here says, SQL injection is best avoided by using a modern SQL package
283:59 - that handles the sanitization of user provided values.
284:04 - That is true.
284:07 - Next question says, what happened in the comic?
284:09 - All right, pause the video, read the comic.
284:14 - So, the answers are Robert's grades were all changed to A's, every student's database or
284:21 - every student's data in the school's database was deleted, Robert's data was deleted, or
284:26 - every teacher's data in the school database was deleted.
284:29 - Well, if we look at what actually got injected here, right, Robert drop table students, it's
284:35 - just dropping the students table.
284:37 - So all the students' data in that school's database was deleted.