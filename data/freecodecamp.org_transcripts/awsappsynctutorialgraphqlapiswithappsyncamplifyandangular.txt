00:00 - hey guys welcome
00:02 - this video is about aws appsync which is
00:04 - a managed graphql offering from aws
00:07 - and today we are going to create a
00:09 - simple angular application that talks to
00:11 - a graphql server which is built on aws
00:14 - appsync and we are going to use amplify
00:16 - library to send request and receive
00:18 - response from the graphql endpoint as
00:21 - you guys may know amplify is a front-end
00:23 - library that makes our life easy to talk
00:25 - to aws back-end resources so let's get
00:28 - started now before i move on i want to
00:30 - give a quick introduction to graphql api
00:33 - now graphql api is
00:35 - quite fast and flexible comparing to
00:37 - rest api because unlike crest
00:40 - in graphql it's the client who decides
00:43 - you know what data it needs from the
00:45 - server for example let's say there's a
00:47 - web page that needs to populate with
00:49 - some data so the client or the browser
00:52 - decides okay these are the data that i
00:54 - have to populate in this page so server
00:56 - please give this data to me so it
00:58 - request the data in terms of a query
01:01 - from the server and server will fetch
01:03 - the corresponding data and send it back
01:05 - to the client so it can easily populate
01:08 - the page
01:09 - and graphql of course it operates over
01:12 - http and unlike rest guys we can use
01:15 - fewer http request to get our job done
01:18 - because the client has the handle know
01:20 - what data it needs
01:22 - and what query it creates to get the
01:24 - data so the client doesn't need to send
01:27 - bunch of http requests to get whatever
01:30 - the data it needs for the most part it
01:32 - will get it in one go with a one request
01:34 - and in graphql the queries are quite
01:36 - flexible so it's less code to maintain
01:39 - as well so let's take example
01:41 - now this is a graphql query so in this
01:43 - query we are basically asking from the
01:45 - graphql server a graphql server give me
01:48 - this particular user's name and the
01:50 - email address
01:52 - and also
01:53 - all the blog posts that he has created
01:55 - so when you send this query to a graphql
01:58 - server you will get a response like this
02:00 - one so this is json response can you see
02:03 - the return data is exactly smashing the
02:06 - attributes that the client has requested
02:08 - for example is the user
02:10 - and is the user object and here's the
02:12 - name
02:13 - and the email
02:14 - and the posts
02:16 - since the user has multiple posts so it
02:19 - is written as an array so inside this
02:22 - array you have objects so each objects
02:25 - contain title and with the body
02:27 - so how come graphql is faster than rest
02:29 - for example if it is rest we may have to
02:32 - get the user's name and the email and
02:35 - the id first
02:37 - using a one http call to the server
02:40 - and then we may have to send the user's
02:43 - id to a different api endpoint to fetch
02:46 - all the post of that user so it could be
02:50 - like couple of requests in order to like
02:53 - formulate this type of a data object but
02:56 - in graphql for the most part we have
02:59 - only one api endpoint for that api
03:02 - endpoint we send the query that we need
03:05 - so the browser or the client makes this
03:07 - query and the server will make sure get
03:10 - whatever the corresponding data from
03:12 - different data sources different tables
03:14 - for in this case uh it might have you
03:16 - know queries these two fields from the
03:19 - user table and these post from the post
03:22 - table and aggregate it and send the
03:24 - response back to the user in terms of a
03:27 - json object which can be easily
03:29 - populated on the client so that's the
03:31 - power of graphql and it is quite fast
03:34 - and there are three main operations we
03:36 - already talked about query so that is
03:37 - basically fetching the data from the
03:39 - graphql api which corresponds to a get
03:41 - request in
03:43 - rest and then we have mutation mutation
03:46 - is nothing but changing the data
03:48 - like creating updating deleting a record
03:52 - in the database
03:54 - in rest we use post put delete requests
03:58 - but in graphql we send a mutation and
04:00 - then we have a subscription
04:02 - so which is basically you know watching
04:05 - over the changes of particular data
04:07 - for example let's say you do a mutation
04:10 - let's say you create a new post in the
04:13 - post table and the clients can always
04:16 - listen onto the post creation mutation
04:19 - so whenever a new post is added the
04:22 - changes will pass on to the client in
04:24 - real time so this is happening through
04:26 - websocket in graphql so basically client
04:30 - is opening up a websocket connection to
04:32 - the server and whenever mutation is
04:35 - happening and if the client has a
04:37 - subscription on to that mutation then it
04:39 - will receive the real-time data okay so
04:42 - that's a quick introduction to graphql
04:44 - so let's go to our demo i'm opening up a
04:46 - terminal and navigate to desktop and
04:49 - create a new directory called appsync
04:51 - and i will go into appsync directory and
04:54 - i will open it in visual studio code by
04:57 - typing code space period so let's create
04:59 - a angular application first
05:01 - so i'm going to use angular cli so i
05:04 - open up an integrated terminal here and
05:07 - i have installed angular cli so i can
05:09 - type ng new my app and i'm going to
05:12 - enable routing as well so i have the
05:15 - latest angular cli and i will choose the
05:18 - styles as a css then start creating my
05:20 - application okay we are going to create
05:22 - a very simple to-do application so that
05:25 - a user can log into the application and
05:27 - then create his or her to-do's so in our
05:30 - application i need two components
05:33 - let's cd into my app folder the first
05:35 - component is auth so i will use ng
05:38 - gc or the cli generator to generate the
05:42 - component and its name is auth so this
05:44 - oauth component it will comprised of my
05:46 - login screen and i am going to use
05:48 - amplify auth ui component to integrate
05:51 - login signup and all those screens very
05:53 - simply so the next component is to do so
05:57 - this is the component which contains my
05:59 - to-do's okay both the components are
06:01 - created and if i
06:03 - open my my app folder and into the
06:05 - source folder into the app folder you
06:07 - should see those two components so i'm
06:09 - going to set the routing as well so i
06:11 - will go to app routing module and let's
06:14 - set two parts
06:15 - part to do that will render the to-do
06:18 - component and another default path that
06:21 - render the oauth component
06:23 - so let's see if everything is working i
06:25 - will type ng-serve so when i open the
06:27 - application it should render the default
06:29 - route and you can see the oauth works
06:31 - here and these are the default content
06:34 - which we are going to delete it right
06:36 - now so here's the default content and i
06:39 - will delete it so i will have only the
06:41 - router component and save it and here
06:44 - you go so our default is oauth route and
06:47 - it works and if i go to to-do the to-do
06:49 - works as well so now we are going to add
06:51 - amplified cli and the amplify library so
06:55 - we can add a logging screen instead of
06:57 - this auth works okay so let's stop the
07:00 - server and type npm install
07:03 - dash d at aws amplify
07:07 - dash cli and hit enter so this will
07:10 - install the amplify cli globally cli is
07:13 - installed so now we can create resources
07:15 - in aws like appsync service now let's
07:18 - install aws amplifier and aws amplify
07:22 - angular so these two libraries will
07:24 - allow us to talk to backend resources
07:26 - via the api so in order to get these two
07:28 - libraries working we have to do a small
07:30 - changes in our angular application the
07:32 - first one is adding a polyfill so go to
07:35 - polyfill.ts
07:37 - and on top add this line of script
07:39 - windows as any global window so this
07:42 - will provide a stream for the global
07:43 - object and in index.html inside the
07:47 - header tag you need to add a script tag
07:49 - and inside the script tag at this line
07:52 - of code
07:53 - if global is undefined set the global to
07:56 - window and now go to
07:58 - tsconfig.app.json file
08:00 - here's this file and under types array
08:03 - add node because amplify will use node
08:06 - behind the same so we have to add the
08:08 - node type here
08:09 - okay now let's use amplifyca cli to spin
08:12 - up resources so let me clear the screen
08:15 - so first we need to create a logging
08:17 - screen we are going to create a cognito
08:19 - user pool to hold our users and then
08:22 - allow them to access upon successful
08:24 - authentication so let's enable
08:26 - authentication with amplify by typing
08:29 - amplify and first type help so you will
08:33 - see all the commands now first of all
08:35 - let's initialize the project even before
08:37 - adding the functionality so i will type
08:40 - amplify hope you guys can see it if not
08:43 - amplify init hit enter so this will
08:46 - initialize the amplify project in aws so
08:48 - choose the default editor in my case
08:50 - visual studio code and i'm going to
08:53 - build a javascript application which is
08:57 - an angular and our source directory is
08:59 - src because our directory
09:03 - name is src hit enter and distribution
09:06 - directory is dist slash my app which is
09:09 - the name of my app and build command hit
09:12 - enter and accept the default start
09:14 - command ng server so now it asks whether
09:16 - or not i want to use an aws profile
09:19 - now here i
09:21 - say yes
09:22 - and i'm going to pick my youtube profile
09:25 - so if you guys have not configured an
09:28 - iem profile in your machine use amplify
09:30 - configure and add your access key and
09:32 - secret access key with the name of a
09:34 - profile okay now the project is
09:36 - initialized so let's add all so here's
09:38 - the category oath so in order to add
09:40 - that let's type amplify at oauth select
09:44 - the default configuration now this is
09:45 - the default configuration of the user
09:47 - pool okay it is added now before you
09:49 - pushing those changes to aws i'm going
09:52 - to add api as well so i will type
09:55 - amplify add api and hit enter so this
09:58 - time we are going to choose graphql api
10:01 - so select graphql not fresh and provide
10:04 - the api name i will say my app and the
10:07 - authorization type choose amazon cognito
10:10 - user pool since we have already created
10:12 - a user pool we can use authorization
10:14 - from that user pool
10:16 - so amazon cognito usable
10:19 - and then it will ask do you have an
10:21 - annotated graphql schema in my case i do
10:24 - not have anything so i will say no and
10:26 - hit enter
10:28 - do you want a guided schema creation
10:30 - hit yes and then it will ask some
10:33 - information about your project so is it
10:35 - a one-to-many relationship like blocks
10:38 - and post or single object with fields
10:41 - like a to-do application which exactly
10:44 - what we are building so let's select
10:45 - single object with fields and now it
10:48 - will ask do i need to edit my schema
10:49 - right now i will say yes and hit enter
10:52 - it's going to open my schema.graphql
10:54 - this is my
10:56 - graphql schema so i'm going to change
10:58 - this attributes a little bit for my
11:00 - to-do so id is fine for to do name is
11:04 - fine and instead of description i will
11:06 - type body
11:07 - and also i will have another attribute
11:10 - called completed and that's the type of
11:13 - boolean i will save it and come back to
11:16 - my editor and hit enter okay it is
11:18 - created locally
11:20 - now when i type amplify publish or push
11:22 - so what happens is amplify will create
11:25 - my graphql api so it will look at my
11:27 - schema definition so this one graphql
11:30 - schema and it will create an appsync
11:32 - service and it will create a dynamodb
11:35 - table with these fields and also it will
11:38 - link that dynamodb table with the
11:39 - appsync service and also at the
11:41 - necessary configuration to create read
11:44 - delete update records in that table as
11:47 - well so that's very convenient for us as
11:49 - a developer so let's type amplify push
11:51 - and it'll ask these other things or the
11:53 - resources that it's going to configure
11:55 - in cloud the oauth the cognito user pool
11:58 - and for the api
12:00 - my ap my app appsync api so i will agree
12:04 - by typing yes
12:05 - and hit enter so then it's going to ask
12:07 - me do you want to generate code for the
12:09 - newly created graphql api i will say yes
12:12 - because i need the code for my angular
12:15 - application and then it will ask me okay
12:18 - your path pattern to store all the
12:19 - queries mutation and subscription i will
12:21 - accept the default because it's going to
12:23 - create this graphql folder inside my
12:26 - source directory and then add all those
12:28 - graphql files so then it further
12:30 - suggests me okay
12:31 - now do you want to
12:33 - like create all those example operations
12:36 - like queries mutations and subscriptions
12:38 - as well of course i want i need that and
12:41 - now it's going to ask for a file to
12:42 - generate that code i will accept the
12:44 - default so that will create
12:46 - api.service.ts file and now it's
12:48 - updating the resource now while it is
12:50 - updating i want to do attention on this
12:52 - particular directive so this is the
12:54 - graphql schema and it has this
12:56 - particular directive called at model so
12:59 - there are multiple directives in amplify
13:01 - so at model is one of them so in this
13:03 - directive what it does is as soon as it
13:05 - shows okay this type with this directive
13:08 - it's going to create a dynamodb table
13:10 - with these attributes and as i
13:12 - previously mentioned it will do all this
13:14 - linking part with the appsync service
13:17 - together with all the operations so
13:19 - that's very cool
13:20 - all right it's created
13:22 - you can see it has given me the graphql
13:24 - endpoint as well so as you can see it
13:26 - has created a lot of files here here the
13:29 - log says generated graphql operation
13:31 - successfully saved that source graphql
13:33 - folder so let's see this is our source
13:35 - folder and this is the graphql folder
13:38 - and inside the graphql you should see
13:40 - all the queries and
13:43 - see we have a get to do query get all
13:46 - the to do's like list2do's query
13:49 - and then we have mutations like creating
13:51 - a to-do update and delete to do mutation
13:54 - and also subscriptions as well so
13:58 - we can subscribe to like one create to
14:00 - do as soon as a to-do is created we can
14:03 - just listen for that and get the content
14:05 - so
14:06 - apart from that you should see there's
14:08 - this aws export.js file and it has all
14:11 - the configuration that amplify has
14:14 - provision in my aws account so it has
14:16 - cognito
14:18 - user pool information and also the
14:20 - graphql information etc now we need to
14:22 - do one thing so let's just take a copy
14:26 - of this file
14:27 - and
14:28 - paste it in the source directory again
14:30 - and instead of
14:32 - js file i'm going to rename it as aws
14:35 - export.ts file now we can import this
14:37 - file into our angular components now let
14:39 - me show you one other thing if you go to
14:41 - amplify folder here and into the back
14:44 - end into this api folder and inside app
14:46 - folder you should see the build folder
14:48 - go inside that then you should see this
14:51 - folder called resolvers now open it up
14:53 - when you open it up you should see there
14:55 - are multiple resolvers for creating
14:58 - to-do's
15:00 - and deleting to-do's
15:01 - updating getting and listing to those
15:04 - for each resolver there's a request
15:07 - template this is the request template
15:09 - for create to do and this is the
15:10 - response template for creating to-do's
15:12 - and here's the same and here's the
15:14 - request and response template for get to
15:16 - do now what is this guys in graphql when
15:19 - the browser sends a query to the api
15:21 - let's say uh it's asking to you know get
15:24 - a particular to do right then we have to
15:26 - write a resolver in order to
15:28 - do that operation so if we want to get
15:31 - the to-do's we have to query the
15:32 - dynamodb table and get that
15:35 - corresponding to do matching with the
15:37 - to-do id right so we can do that in
15:39 - different ways in graphql we can have
15:41 - resolvers either by using the data
15:44 - source for example in this case it is
15:46 - the dynamodb so we can use the dynamodb
15:50 - gate item operation so you can see the
15:52 - operation is get item and the key this
15:55 - is the hash key or the primary key so
15:57 - that is corresponding to the id of the
15:59 - to do
16:00 - so this is the one of the options that
16:02 - you can write the resolvers or else you
16:04 - can write a lambda function and hook
16:07 - that as a resolver and inside that
16:09 - lambda function you can talk to the
16:10 - dynamodb and get the result and send it
16:14 - back to the client so there are multiple
16:16 - ways that you can attach resolvers so
16:18 - the request template is basically you
16:20 - are requesting the data from the data
16:22 - source in this case dynamodb and the
16:24 - return data you can like modify that
16:27 - return data back into a graphql response
16:30 - so yeah you can like restructure it as a
16:32 - graphql response but if you want to do
16:35 - like further filtering before sending
16:37 - the response you can add this here so
16:38 - that's about getting to do so how about
16:40 - creating to do so that's a mutation so
16:43 - when you send that mutation you can
16:45 - again use dynamodb operation put item
16:47 - operation and then for this new key
16:51 - and
16:52 - you know add those
16:53 - attributes that is coming along through
16:55 - the mutation and create a new to do item
16:58 - and here also instead of using this
16:59 - velocity template and using the dynamodb
17:02 - put item operation you can use a lambda
17:04 - function to talk to dynamodb using
17:07 - dynamodbsd case and do that operation as
17:10 - well okay so now let's set the amplifier
17:12 - logging to our application so in order
17:14 - to use amplify we have to do a little
17:16 - bit of configuration so let's go to
17:18 - source folder and into our app and into
17:21 - app.module.ts and we have to import some
17:24 - libraries so what library do i have to
17:26 - import i'm going to import
17:27 - amplifyservice and amplify angular
17:29 - module from aws amplify angular library
17:32 - and i will add the module inside the
17:35 - imports
17:36 - here and the amplify service as the
17:39 - provider so now that we have the amplify
17:41 - angular module imported we can use the
17:44 - ui component provided from the aws
17:46 - amplifier angular for authentication so
17:48 - let's go to our auth component and go to
17:51 - and go to a component.html file and here
17:54 - instead of hot works let me delete it
17:56 - and i will paste in the amplify
17:59 - authenticator directive this will add
18:00 - all the ui components for login logout
18:03 - forget password sign up etc but in order
18:05 - to do some styling let's import amplify
18:09 - styles into our
18:10 - styles.scss file so i will go to
18:13 - styles.css file and here i'm going to
18:16 - import aws amplify angular slash
18:20 - theme.css now let's see our application
18:22 - looks by typing ng serve and when we go
18:24 - to localhost 4200 yes i should see this
18:27 - nice ui so now let's add some code to
18:30 - our to-do component as well i will
18:32 - remove this to do works template and i
18:34 - will paste in this code so
18:36 - press this do the wrapper due around so
18:39 - inside that i have two buttons first one
18:42 - is to create a to do and the other one
18:43 - is to get all the to do so create to do
18:45 - is linked with the create to do function
18:47 - get to do is link with get to those
18:49 - function and then we have another view
18:51 - this view will iterate over all the
18:53 - to-do's and print out the to-do name and
18:56 - the body and whether or not it is
18:58 - completed i will upload this code into
19:00 - github and link it so you guys can see
19:02 - it as well
19:04 - okay guys let me change this get to do
19:06 - to uh list to-do's because you are
19:08 - listing all the to-do's here and now
19:10 - let's create those function go to our ts
19:13 - file and first one is create to-do
19:16 - and
19:17 - list to-do's
19:18 - now in order to create to-do uh i'm not
19:21 - going to use any like input boxes and
19:23 - get the actual to-do content from the
19:26 - user but instead i'm going to
19:28 - like generate a couple of to-do's when
19:31 - someone hit this button so let me paste
19:33 - in this code so const new to do and i
19:36 - have given the to-do name as to do and
19:38 - then a random value between 1 200
19:42 - and sample description and this is the
19:44 - completed status which is false and now
19:46 - we have to use create to do mutation so
19:48 - for that let's use amplify api now
19:51 - before actually use amplify we haven't
19:53 - uh configured it properly we got to do a
19:55 - small thing so let's go to a main.ts
19:57 - file which is our main angular file that
20:00 - get bootstrapped
20:01 - and there we need to import amplify from
20:04 - aws amplify library
20:06 - like this import amplify from aws dash
20:09 - amplify and then we have to import that
20:12 - aws export file if you can remember guys
20:14 - the amplify generated this aws export.js
20:16 - file and we created this ts file of
20:18 - course we can like use a
20:20 - script to do this conversion but we'll
20:23 - like copy paste for now so we are
20:25 - importing that particular export file as
20:27 - well then we are using
20:29 - amplify.configure and passing that
20:30 - particular export file so that's it so
20:33 - once you do this amplify configure
20:35 - amplify know okay these are the
20:37 - resources that it can talks to and these
20:39 - are the metadata that it can use for
20:41 - example appsync url let's do another
20:44 - thing
20:45 - if you can remember amplify has created
20:47 - this api dot service file so this has
20:50 - all the mutations queries and
20:52 - subscription of web sync so we need to
20:54 - import this api service if you want you
20:57 - can put it to the app module as a
20:59 - provider so you can use it throughout
21:01 - your components but in my case i will
21:03 - only use in the to do component so how
21:05 - can we use it let me go to to do
21:07 - component and on top let me import that
21:10 - one directory up and api service and i
21:14 - think that is called api service yeah so
21:17 - let's import our service as well and
21:19 - here in the constructor let's create a
21:21 - private variable call it api of api
21:24 - service so now we can use this
21:27 - api private variable in order to talk to
21:29 - a web sync endpoint so let's go into our
21:32 - method which is create to do so we have
21:34 - this new to do and in order to call this
21:37 - mutation we have to use our api this dot
21:40 - api dot
21:42 - and it is create to do and it will take
21:46 - the input test that you do input which
21:48 - is nothing but our new to-do let me just
21:50 - copy it and paste it in
21:53 - okay
21:54 - now this function is asynchronous
21:55 - function guys so we need to wait for
21:57 - that and let's take the result into a
22:00 - variable called result why not and since
22:02 - we are using a weight we have to like
22:04 - create this function as a async function
22:07 - all right and let me just put a debug
22:09 - point here just to stop it at this point
22:11 - and inspect the result and for list to
22:13 - do's what do we need let's create
22:15 - another variable called all to do's and
22:18 - that is what we have referenced in our
22:20 - loop yes it is all to do and let's call
22:23 - our
22:24 - api again api dot
22:28 - list to do's i don't have to pass any
22:30 - parameters here again we have to make
22:32 - this function
22:34 - async and rather we'll define this old
22:36 - to-do's on top and here let's call it
22:40 - this dot all to do and on ng on init so
22:43 - this is the function that called when
22:45 - this component is initialized so let's
22:48 - call the same thing here so when we
22:50 - refresh the page it will always like
22:53 - call this function and here also let's
22:56 - do another change so once you have
22:58 - successfully created it
23:00 - let's push that to do into our all to-do
23:03 - list this dot or to-do's dot push the
23:07 - result okay
23:09 - let's see if it is compiling it all
23:10 - right yes i think so and i will go to uh
23:14 - localhost
23:16 - 4200 nothing
23:18 - let's inspect it process is not defined
23:21 - i think that's another problem in
23:23 - angular 6
23:24 - where we need to use another
23:26 - shim for that so
23:29 - let's go to a polyfill.js
23:32 - so in the polyfill.js if you can
23:34 - remember we had a polyfill for the
23:36 - global object and also we need to have a
23:39 - polyfill for the process object this is
23:41 - a workaround that i found on internet so
23:43 - let's set this one window as any process
23:46 - the script and save it and now
23:49 - let's do a refresh
23:51 - there you go now it works now we are at
23:54 - localhost 4200 and now this is our login
23:56 - page since
23:58 - you guys don't have any account created
24:00 - you click create account and sign up for
24:02 - a new account with the username password
24:04 - an email and those stuff and afterwards
24:07 - you will receive an email to your email
24:09 - address with the confirmation code
24:12 - add that in and then you are good to
24:14 - sign in i have already created a user so
24:16 - let me login with him mjson and click
24:19 - sign in here you should
24:21 - see the inspect element the network tab
24:24 - all the calls that it does
24:26 - for the backend so it's calling the
24:28 - cognito api and once you are
24:30 - successfully signed in cognito will send
24:32 - you all the tokens id token access token
24:34 - and refresh token and they will be
24:35 - stored in the local storage
24:37 - so you can see it has grabbed my name
24:39 - hello mjson and
24:41 - let's go to uh to do endpoint
24:44 - now that we are signed in you can see uh
24:47 - our two uh buttons okay we got an error
24:50 - so let's see yeah uh we need to define
24:53 - this as an array all to do and then
24:56 - here let's take this into a variable
25:00 - let result and assign
25:04 - this dot all to do's as
25:07 - results good items because there's this
25:10 - items
25:12 - attribute that these to-do's will be
25:14 - populated okay and here also the same
25:16 - thing let me just copy these two lines
25:19 - and when you click list
25:21 - to do's it will show that as well okay i
25:24 - think now it looks good let's see there
25:26 - you go
25:27 - now i have all these to do so i created
25:31 - so i got 9 68 18 and 78 let's create
25:34 - another one
25:35 - 88 and if i refresh it
25:39 - i should get all those things right and
25:40 - if you go to inspect element 10 into the
25:42 - network tab let's inspect what happens
25:44 - when you click create to do's it's
25:47 - calling the graphql api and it's calling
25:50 - the create to do mutation so it is
25:52 - passing the body completed or not all
25:54 - that right okay so this is one of the
25:56 - ways that we can work with appsync
25:59 - endpoint with amplify graphql client but
26:01 - this amplify graphql client does not
26:04 - support offline functionality so if you
26:06 - want offline functionalities and those
26:08 - complex features you have to use appsync
26:11 - sdk but this graphqlapsync client is
26:14 - really great for you know handling
26:16 - mutations queries and subscription quite
26:18 - easily
26:19 - all right guys so this video is about
26:21 - modeling relationship in graphql when
26:23 - you are using appsync and amplify
26:25 - library i will give you an example on
26:27 - how do you model one-to-one relationship
26:30 - one-to-many relationship and
26:31 - many-to-many relationship in your
26:33 - applications so throughout this video i
26:35 - am going to use one of this example to
26:37 - demonstrate this relationship so this is
26:39 - one of the very common example so let's
26:41 - say you have these three entities you
26:43 - have departments
26:45 - and you have employees and also you have
26:48 - projects so let's see what are the
26:50 - relationship between departments
26:52 - employees and projects so one of the
26:54 - relationship that we are going to map is
26:55 - a department has a manager let's see
26:58 - this one so department has a manager so
27:02 - that manager is also included in the
27:05 - employees right
27:06 - so of course a manager is also an
27:08 - employee so a department has a manager
27:12 - so what type of relationship is that
27:14 - it's a one-to-one mapping because one
27:16 - department has only a one manager right
27:19 - and also
27:20 - the second relationship we are going to
27:22 - do is a department has many employees of
27:24 - course a department has many employees
27:27 - so one department
27:29 - has many employees so what type of
27:32 - relationship is that it's a one-to-many
27:34 - relationship or we denote it as one
27:36 - colon m or one colon n right
27:38 - and finally we are going to look at one
27:41 - uh many too many relationship as well so
27:43 - that is nothing but a project has many
27:45 - employees let's say
27:47 - a project so we have a project entity a
27:50 - project has many employees let's say
27:53 - many employees are assigned to one
27:54 - particular project and on the other hand
27:56 - a single employee can be in multiple
27:59 - projects as well so one project has many
28:02 - employees
28:03 - and one employee can be assigned to many
28:05 - projects so what type of relationship is
28:07 - that that's a many-to-many relationship
28:10 - all right guys so let's see how do we
28:12 - map this relationship quite easily with
28:14 - amplify library all right so head over
28:16 - to amplify library website so at this
28:18 - particular link
28:20 - now guys in the previous video we talked
28:22 - about amplify library and graphql
28:24 - introduction so if you guys want to
28:25 - watch it i will put a link up here and
28:28 - once you are in the documentation you
28:29 - should see how to install the amplify
28:31 - library
28:32 - so it's basically a simple npm install
28:35 - and then you can use amplify init to
28:37 - initialize a project in aws cloud
28:40 - so let's take a terminal and create a
28:42 - new directory called relationships
28:45 - cd into relationships and inside this
28:48 - folder let's create an angular
28:49 - application
28:50 - ng new my app well you can use angular
28:54 - react view or any other front-end
28:56 - framework but in my case i use angular
28:58 - yes i want to add routing and i'm going
29:00 - to use scss
29:02 - so once you have this created go into
29:04 - the folder and
29:06 - open it in your
29:08 - code editor i'm using visual studio code
29:10 - here all right now i open up the
29:12 - integrated terminal and let's initialize
29:14 - a new amplifier project by typing
29:15 - amplify in it okay the edit i'm using is
29:18 - visual studio code and it's a javascript
29:21 - application it's angular application so
29:24 - if you guys like spin up react
29:26 - application use react or view
29:29 - in my case angular and the source
29:31 - directory
29:32 - it's src folder and
29:35 - my build file resides in
29:37 - dist slash my app my app is the name of
29:40 - my app
29:41 - and hit enter build command is this one
29:43 - ng serve
29:45 - all right and now it's using
29:46 - cloudformation to initialize the project
29:48 - so do i want to use aws profile yes
29:50 - because i have this particular profile
29:53 - for my youtube
29:55 - alright so now project is now
29:56 - successfully initiated in the cloud so
29:58 - now i can add api so let's add our
30:01 - graphql api by typing amplify add api
30:06 - and hit enter choose graphql and hit
30:08 - enter again
30:09 - an api name i will just choose the
30:12 - default name my app and the
30:14 - authorization type well i'm going to
30:16 - choose cognito user pool and then it
30:17 - asks me okay do i need to add the
30:20 - default configuration to the cognitive
30:21 - user pool i will just select default
30:23 - configuration if you want like you can
30:25 - go through the setup and customize the
30:27 - configuration now it asks do i have a
30:29 - graphql schema in my case i do not so i
30:32 - will type in and hit enter do you want a
30:34 - guided schema creation yes then it will
30:37 - suggest me like
30:39 - three types of schemas no single object
30:42 - with fails one to many relationship
30:44 - and fine grain access so in this case i
30:46 - will choose one to many relationship
30:48 - that will give me a blog post schema
30:51 - and do you want to edit the schema now i
30:53 - will hit yes and now it's going to open
30:56 - up the schema file so minimize the
30:59 - integrated terminal and so this is the
31:01 - created blog post schema so in our case
31:04 - we don't need this one
31:06 - because we have department employees and
31:08 - projects so i will delete it so let's
31:10 - start building our schema so first type
31:13 - is department
31:15 - so what field does the department has it
31:17 - has an id of id
31:19 - so capital id is a common type that we
31:22 - denote id in graphql and department has
31:25 - a name of string
31:27 - yeah that should be it so our department
31:29 - has an id and its name and now i am
31:32 - going to use a directive from amplify
31:33 - library called at model so this at model
31:36 - directive will create a
31:39 - dynamodb table for department and also
31:41 - it is going to create all the graphql
31:43 - mutation queries and subscription for
31:45 - department model
31:47 - or department type so what is the next
31:49 - entity so let's create our employee
31:53 - and let's use the same directive here
31:55 - because we want to create a table for
31:57 - employees as well so our employees also
31:59 - has an id and a name and
32:03 - let's add h as well so now let's set the
32:06 - first relationship so what is our first
32:08 - relationship a department has a manager
32:11 - so in the departments let's add another
32:14 - field called manager
32:16 - and that manager is again a employee
32:19 - right now before that let me just uh
32:21 - take out this s and keep it single sorry
32:24 - about that
32:25 - so this manager is again an employee so
32:28 - manager is type of employee okay so we
32:31 - are referencing this type
32:33 - when it comes to manager so this is id
32:36 - and string a scalar type in graphql but
32:39 - when you are referencing another type
32:41 - these are called non-scholar type so in
32:43 - order to make this a one two one
32:45 - relationship let's add another directive
32:47 - called connection
32:49 - so we are making a connection
32:51 - on manager
32:53 - to this particular employee type now
32:55 - here's what happens when amplify
32:57 - compiles this schema with these
32:59 - directives it's going to create this
33:01 - department table in the dynamodb and
33:03 - it's going to create id attribute name
33:06 - attribute and it's going to create
33:08 - another reference for the manager by
33:10 - adding attribute called manager id so
33:13 - department table then has a reference to
33:15 - the manager's id so let's see this in
33:17 - action so i'm going to open up the
33:19 - integrated terminal again
33:21 - and hit enter and then i will type
33:23 - amplify push so now amplify is going to
33:26 - compile the code and create a cloud
33:28 - formation template and then it create
33:30 - all the resources so answer yes to all
33:32 - these questions all right so it has
33:34 - given me the graphql endpoint and let me
33:37 - go to aws console and see the resources
33:39 - that it created and if i go to appsync i
33:42 - should see my new api my app and go into
33:44 - that if you go to the schema you should
33:47 - see the full schema that it has created
33:49 - you see it has added all these input
33:52 - types and mutations subscriptions etc so
33:55 - let's go to dynamodb as well
33:58 - because it should create a table for
34:00 - department and employees so these are my
34:02 - two tables and also let me go to aws
34:05 - cognito
34:06 - because we are using cognito
34:08 - authorization so if i open it in a new
34:10 - tab i should see my new cognito user
34:13 - pool so here's my user pool so in the
34:15 - appsync console let's try to create a
34:17 - query let's try to create a department
34:21 - now
34:21 - i first have to login with the user pool
34:23 - because that's how the authorization
34:25 - happen so in order to do that
34:27 - i need to provide the client id and
34:29 - username and password of a particular
34:31 - user so let's create a user here in the
34:33 - user pool i will click create user
34:36 - and
34:37 - okay manoj is fine and i don't need to
34:40 - send any mutation add a temporary
34:42 - password guys and just untick this one
34:45 - manoj test.com and create the user okay
34:48 - user is created and now go to app
34:50 - clients because we need to just copy the
34:52 - client id and make sure you're not using
34:55 - the one with the secret key but
34:58 - without the one this one so just copy in
35:01 - the client id in the app sync console
35:04 - client id paste that in and your
35:06 - password
35:07 - and the username and now i'm logged in
35:09 - as manoj okay now if you click docs here
35:12 - you should see your schema
35:14 - and let's see what are the mutation that
35:16 - i have if i click mutation link here i
35:19 - have this create department mutation
35:20 - right so let's try to create that one
35:23 - we'll type mutation create department
35:26 - and the field name is
35:29 - create department
35:30 - input so what are the input types so if
35:32 - you go to create department you should
35:34 - see the input type is of this particular
35:37 - create department input type just click
35:39 - that should see what are the required
35:41 - field
35:42 - and i should give the name
35:44 - and then let's call it engineering
35:47 - department and department manager id
35:49 - since i don't have a user created or the
35:52 - employee created i can't give it yet so
35:54 - let's leave it blank and later on we'll
35:57 - update the department and the create
35:58 - department's outputs are departments so
36:01 - in the department i can just print out
36:03 - the id and the name right so now let's
36:07 - run this mutation click this button
36:10 - there you go it's created
36:12 - so let's make a note of the department
36:14 - id and i will just copy this and i will
36:17 - put it in a notepad okay so this is the
36:20 - department id and guys let's create a
36:22 - employee as well let's create employee
36:25 - you can just name this one any name but
36:29 - when you're choosing the field type make
36:31 - sure to pick the right one okay
36:33 - an input type colon and
36:36 - open braces if i go to mutation always
36:39 - use the documentation it's quite easy
36:41 - and create employee you should see the
36:43 - input type is create employee input and
36:45 - it accepts name and edge right so name
36:48 - let's say
36:50 - john doe and h t1 and the mutation
36:54 - returns
36:56 - an employee see so employee has
36:59 - a
37:00 - name and id i will just print out the
37:02 - name and the id okay let's close this
37:04 - out
37:05 - and
37:06 - click this one and select create
37:09 - employee okay john doe is created let me
37:11 - just note down
37:13 - these two as well john doe
37:15 - id is this one let's create two more
37:18 - employees jando of age 28 and create the
37:22 - employee and just note the id as well
37:25 - here and also another employee manoj
37:28 - fernando create employee make a note
37:33 - so now that is created so let's see if
37:35 - it is like
37:36 - updated in our database right so if i go
37:38 - to dynamodb and if i go to department
37:41 - table and into the items i should see my
37:45 - first department is created see
37:47 - department engineering department can
37:49 - you see i still don't have that manager
37:52 - id
37:53 - so
37:54 - let's add a manager to our department so
37:56 - i will go to appsync and this time i'm
37:58 - going to use the update mutation
38:01 - mutation let's call update manager so
38:04 - the mutation name let's see what is that
38:07 - name
38:08 - update department okay update department
38:11 - and as for the input type
38:14 - okay
38:16 - update department input if i go into
38:18 - that i i can individually update these
38:20 - attributes so in this case i need
38:23 - department manager id
38:26 - so let's set john doe as our engineering
38:28 - department manager department manager's
38:31 - id so let me quickly copy john doe's id
38:35 - here paste it in here department id that
38:38 - will return me uh the name okay
38:41 - i can just return whatever the values
38:43 - here and let me just run the update
38:45 - manager mutation oh we got an error
38:48 - because we have to like give the id of
38:50 - the department as well
38:52 - so department id that we are going to
38:54 - change is this one
38:56 - so this is the engineering department
38:58 - sorry about that so of course you have
39:00 - to add the department id that we are
39:02 - going to update
39:04 - so make sure to add the department id
39:06 - here and the department manager id which
39:09 - is our john dose id right and then run
39:12 - again all right so it is updated so
39:14 - let's see if it is updated i will click
39:17 - refresh and open this up you see the
39:19 - department manager id so this is how we
39:21 - create one to one relationship now let's
39:24 - add the other relationships as well
39:26 - so let's add this one a department has
39:29 - many employees i will go to my schema
39:33 - now department has a manager one to one
39:35 - relationship and department has many
39:37 - employees so let's add another attribute
39:40 - here it's called it employees
39:44 - and that is an array of employee type
39:47 - so its employees are array of employees
39:50 - so arrays is denoted with brackets so we
39:53 - are referencing the employee type in an
39:55 - array because it's a list of employees
39:57 - right
39:58 - and let's
39:59 - add another connection here
40:02 - now guys when you add this connection it
40:04 - works so when you create one too many
40:07 - relationship so in this case department
40:10 - has many employees when you're creating
40:12 - an employee in the employee table it
40:14 - should have an attribute called
40:16 - department id say department id yeah
40:19 - something like that
40:21 - so this will reference the department so
40:23 - every time you create an employee we
40:25 - should have that particular id
40:27 - now there's a small issue when you just
40:29 - add employees it just works but this
40:32 - particular attribute name we get it as
40:35 - department employees id so it's
40:38 - basically get the
40:40 - type names
40:42 - department and the employee
40:44 - and the id right because if you can
40:46 - remember
40:48 - our manager it was called department
40:51 - manager id similarly it will infer a
40:54 - attribute name called department
40:56 - employees id right this doesn't make any
40:59 - sense so in order to have an attribute
41:01 - that makes sense let's create a named
41:03 - connection now these are named
41:05 - connections so name connection is quite
41:07 - easy just add a brackets and type name
41:11 - and then you can just add any name here
41:14 - this is basically a label guys some
41:15 - reference
41:17 - so it can be anything so let me here
41:20 - just call it department employees
41:24 - and once you are adding a named
41:26 - connection you have to have another
41:27 - field in the corresponding table so
41:31 - this is referencing the type employee so
41:33 - in our employee type
41:35 - let's add another reference to the
41:37 - department as well so let's call it
41:39 - department department and it's the type
41:41 - of department and let's add the same
41:44 - name connection here as well
41:47 - so we have to do this by directional
41:48 - mapping on in order to get this thing
41:50 - working right so when you add that guys
41:53 - this name could be anything what changes
41:55 - is the attribute name so earlier
41:58 - if we weren't using named connection the
42:00 - attribute name could be department
42:02 - employees id now it will take the name
42:05 - as employee department id so that makes
42:08 - sense right because employee belongs to
42:10 - department so employee department id
42:12 - makes sense all right so now let's
42:14 - compile our schema again so how can we
42:16 - compile it take your integrated terminal
42:19 - and type this command amplify
42:21 - api gql dash compile so this will
42:26 - recompile our schema and update our
42:28 - cloudformation stack now let me
42:30 - reiterate again of course you can like
42:32 - take this out and only keep the unnamed
42:35 - connection right because department has
42:38 - many employees this just works without
42:39 - any doubt right
42:41 - but the attribute name is a weird
42:43 - attribute name so in order to have a
42:45 - meaningful name something like employee
42:47 - department id we need to have a named
42:50 - connection okay it's successfully
42:52 - compiled now let's push our changes
42:54 - amplify push
42:56 - so once it is completed let's go back to
42:58 - our aws console to appsync console maybe
43:01 - you have to just log out
43:02 - and log in back now if you take the docs
43:06 - and go to the mutations let's see when
43:08 - you create an employee what are the
43:09 - input types
43:11 - you see there's the new input type
43:13 - called employee department id
43:16 - you see now the name matches quite fine
43:18 - because employees has a department id so
43:21 - let's update our three employees with
43:23 - their corresponding department shall we
43:25 - so i will go back to the scheme and
43:27 - let's use this update employee mutation
43:30 - update employee and the input type is
43:33 - off
43:34 - let's see always use the reference the
43:37 - id of the employee is let's start with
43:39 - john doe id and
43:43 - employee department id so let's add
43:47 - the department engineering department id
43:49 - this is this one and
43:52 - you can just get the name if you want
43:55 - and then i will update the employee all
43:57 - right it's successfully updated
43:59 - similarly let's update the other two
44:01 - employees as well
44:02 - jando just change the employee id here
44:05 - don't change this one because you are
44:07 - adding to the same engineering
44:08 - department so that is the department id
44:10 - and run the update employee again okay
44:12 - jendo is updated and finally manoj
44:16 - employee id change it and run the
44:18 - mutation update employee okay now it is
44:21 - updated now let's try to query a
44:23 - department and see
44:25 - so if the department has these employees
44:28 - get department
44:30 - what is the query so this time it's not
44:32 - a mutation it's a query click query and
44:35 - get department query get department and
44:38 - id so we have to provide the idea for
44:41 - department and that gives me a
44:43 - department click on the return type here
44:46 - department and you get all these
44:48 - information right so let's print out the
44:50 - department name
44:52 - and the manager so manager again system
44:55 - type of employee you see manages another
44:57 - type of employee if you go into that you
44:59 - can just print out the manager's name
45:01 - and go back here so what else do we have
45:04 - we have employees as well so employees
45:07 - and
45:09 - employees are a type of employee
45:11 - connection it's a type of connection and
45:13 - it has these items array because
45:16 - employees are a list of employees and
45:18 - items are list of employees click into
45:21 - the employee and everyone has a name and
45:25 - let's print out the age as well why not
45:27 - so now let's execute this query
45:30 - i will hit play button and click get
45:32 - department there you go
45:34 - so we got the data back so our
45:36 - department name is engineering
45:38 - department our manager is john doe
45:41 - and these are the employees employees
45:43 - employee one two three manoj jando and
45:46 - john doe nice
45:48 - now i want to show you one other thing
45:49 - if we go to dynamodb table and do a
45:51 - refresh on this and if you go to
45:53 - employees table first note that you have
45:56 - the employee department id attribute and
45:58 - secondly if you go to indexes
46:01 - you should see it has created a global
46:03 - secondary index on
46:06 - employee department id key so dynamodb
46:08 - has internally created this index on the
46:11 - employee department id so that it can
46:14 - query using the employee department id
46:16 - efficiently awesome
46:18 - so now let's add the many-to-many
46:19 - relationship so what is our maintenance
46:21 - relationship it's basically a project
46:24 - has many employees an employee can be
46:26 - assigned to many projects so let's go to
46:29 - our
46:30 - schema now we need to have another type
46:33 - called
46:34 - project
46:35 - and it's also a model we need to have a
46:37 - dynamodb table and all the mutations and
46:40 - queries
46:41 - and it has a id
46:43 - project id and let's say there's a
46:45 - project name as well
46:47 - that should be enough so what should be
46:48 - the relationship
46:49 - the project has many employees yeah so
46:53 - we can simply add employees of type
46:56 - employee array
46:59 - make sense
47:00 - so employees it's an array of employee
47:03 - right and we can just make this as a
47:05 - connection
47:06 - right if you want like we can create
47:09 - this uh named connection as well and how
47:11 - about the other side employee can be
47:13 - assigned to many projects so employees
47:15 - also can have multiple projects right so
47:18 - if you just type projects
47:21 - and
47:21 - it's a list of project we can just make
47:24 - this as a connection as well right so we
47:28 - have both the relationship employee has
47:29 - multiple projects and project has
47:32 - multiple employees
47:34 - but guys when you are mapping main to
47:35 - many relationships and if you are only
47:37 - using two tables when there are a lot of
47:40 - data the relationships get quite messy
47:42 - because you see the employee table has
47:44 - the relationship to the projects and the
47:46 - project has relationship to the
47:47 - employees and one employee could be in
47:49 - multiple projects and one project has
47:52 - multiple employees so you have to like
47:54 - have so many number of records in these
47:57 - two tables it get quite messy quite fast
48:00 - so one of the ways that we can like
48:02 - model it in a different manner is using
48:05 - a third table we can create a third
48:07 - table and create two one-to-many
48:10 - relationships and then achieve this
48:12 - many-to-many relationship
48:13 - confusing let me just show you so let's
48:15 - create another table called or type
48:18 - called let's say
48:19 - employee
48:21 - projects
48:22 - right
48:23 - so when we are naming this table it
48:26 - could be like employee projects or
48:27 - project employees whichever makes more
48:29 - sense right so in this case
48:31 - both seems fine employee projects or
48:34 - project employees
48:35 - so let's create a model here and this
48:37 - particular table also has an id
48:39 - attribute and i'm going to take out
48:41 - these two early records
48:44 - this one and this one okay so we can
48:47 - start with a clean slate so what are we
48:48 - going to do
48:49 - we are going to create this particular
48:51 - table employees projects table and
48:53 - create two one-to-many relationship
48:56 - employee table to employee projects
48:58 - table and another one-to-many
48:59 - relationship from project table to
49:01 - employee projects table so let's create
49:04 - that shall we so employee has multiple
49:07 - projects and that is the type of
49:10 - employee project
49:12 - not employee type but employee project
49:15 - and it has a connection and we'll call
49:17 - that connection uh employee projects
49:20 - remember you can name this anything
49:22 - and once you create one record here you
49:24 - have to have a reference record here as
49:27 - well so let's call it employee
49:31 - because this is the type of employee
49:34 - and
49:35 - the employee type and let's have the
49:37 - same connection name here so we created
49:39 - one of the one-to-many relationships as
49:42 - we have created one-to-many relationship
49:43 - in department and employees you see this
49:45 - one
49:46 - similarly we created another one-to-many
49:48 - relationship between employee table and
49:50 - employee projects table right so we'll
49:53 - do the second one-to-many relationship
49:55 - from projects to employee projects so
49:58 - project has many employees and that is
50:02 - an array of employee project let's add a
50:04 - connection with the name
50:06 - project
50:08 - employees so let's create the reference
50:10 - attribute here
50:11 - that is project because we are
50:14 - referencing the project type
50:16 - and
50:17 - that is of project type and have the
50:20 - same named connection here
50:24 - also
50:25 - so now let's recompile this amplify api
50:28 - gql dash compile
50:31 - okay we got no errors
50:32 - and one other thing guys uh this
50:35 - particular employee projects model and
50:37 - when we add this particular at model
50:39 - directive it's going to create all the
50:41 - queries mutation subscription and
50:43 - everything right but we are only like
50:46 - adding the records or creating this
50:48 - employee and
50:50 - project reference in this table we are
50:52 - not going to query anything from this
50:54 - one so in order to tell amplify don't
50:56 - create query types we can pass
50:59 - additional information with parentheses
51:01 - let's say
51:02 - queries
51:04 - null
51:05 - so it's not going to create any queries
51:06 - but only the mutations all right and
51:09 - let's do another compilation okay it's
51:11 - compiled successfully let's do amplify
51:15 - push
51:15 - to push all the changes and like update
51:18 - our resources in aws okay guys it's
51:21 - updated so let's go to our aws appsync
51:24 - console
51:25 - and let me log out again and log in and
51:28 - now if you look at the schema and if you
51:29 - go to mutation you should see create
51:31 - project and update project that means it
51:34 - has created project type as well
51:36 - so let's create a project guys so i will
51:39 - type mutation create project and let's
51:42 - use
51:43 - create project field and input so what
51:46 - is the input click here so basically ids
51:50 - auto generator you just have to give it
51:51 - a name let's call it uh
51:53 - project x
51:55 - and then
51:56 - let's get the id
51:58 - and the name okay execute it create
52:01 - project
52:02 - there you go it's created
52:04 - and let me take a reference on the
52:06 - project id project x id is this one and
52:10 - now let's add manoj and jane to this
52:13 - particular project x so those are the
52:15 - two employees assigned to project x
52:17 - right and how do we do that we are going
52:19 - to create an entry in our employee
52:21 - projects third table so let's use create
52:24 - employee projects mutation so i'm going
52:27 - to use
52:28 - mutation add
52:30 - employee to project
52:33 - and we are going to use create
52:36 - employee projects
52:38 - and as for the inputs
52:40 - we have to provide let's see what are
52:42 - the inputs here employee id and the
52:45 - project id so employee projects project
52:48 - id so what's the project id so we are
52:51 - going to associate him uh with our
52:53 - project x so let's get this project id
52:57 - and who are we going to associate the
53:00 - employee id of
53:02 - chain
53:04 - all right so let's get the id out so
53:07 - this will assign jane to our project
53:10 - text so let's add the employee to that
53:13 - project okay so it's added and let's add
53:16 - manoj also
53:18 - so let's get the manoj id and i'm going
53:21 - to add manage to the same project and
53:24 - let's add the employee to that project
53:27 - okay great
53:28 - so let's now query that project and see
53:31 - if these two employees are actually
53:33 - added right so let's go to docs again
53:36 - query get project by id get project
53:40 - get project
53:42 - and id so what is the id
53:45 - project text id here okay and the get
53:48 - project returns a project so inside the
53:50 - project what do you have you have name
53:53 - and employees you see one-to-many
53:55 - relationship there name
53:58 - and
53:59 - employees now take a look at the type
54:02 - guys this employees are type of employee
54:04 - project connection yeah
54:06 - so uh if you go into this
54:08 - should see i will get a list of
54:10 - employees
54:11 - so i can just query that items
54:15 - and these items of type employee
54:17 - projects so employee project we have
54:20 - employee and the project so let's get
54:23 - the employee again
54:25 - and i will take the name employee so it
54:28 - will give me the name of this employee
54:30 - hope it's clear so
54:32 - let me just query the project
54:36 - get project here we have it so
54:40 - our project project x
54:42 - it has these two employees so one
54:44 - project can have many employees so let's
54:47 - see the other side that means one
54:49 - employee can have multiple projects
54:51 - so let's set manoj to another project
54:54 - shall we so first let me just create a
54:57 - new project i will use the previous
54:59 - mutation i will call this as project y
55:02 - and let's run this one create project so
55:05 - it's the one so i created it so this is
55:08 - my project y copy the id here project y
55:14 - now let's associate
55:17 - manoj to that project y so project y id
55:21 - i already copied it so let me just
55:24 - quickly paste it here so this is the
55:27 - id of project y and the employee id of
55:30 - manage so that is this one
55:34 - all right and i'm going to execute add
55:36 - the employees to the project great now
55:38 - if we query manoj then we should see all
55:41 - the associated projects let's query that
55:44 - get employee
55:45 - query
55:46 - name let's get employee okay get
55:50 - employee and basically you need to give
55:52 - the id of the employee which is
55:56 - manoj id
55:57 - and now
55:58 - look at the return type so this is the
56:00 - get employee
56:02 - and you will get an employee
56:05 - type out
56:06 - so in this employee type
56:08 - there are a bunch of things right first
56:09 - we can get the name and we can get the
56:12 - edge
56:13 - and the department i will just omit
56:16 - department for now because you are
56:18 - concerned about the projects so i will
56:21 - type projects
56:23 - and the project is type of project
56:26 - connection
56:27 - and go into that you get items that
56:30 - means list of projects
56:33 - and each of these of our third table
56:35 - type which is employee projects and
56:37 - inside it we can simply get the project
56:41 - and project age type of again project
56:44 - and just get the name nice so let's run
56:47 - this query and it should return both
56:50 - project x and y ideally let's see get
56:53 - employee
56:54 - there you go
56:55 - so manoj
56:57 - is part of project x and project y great
57:00 - so now we have completed all these
57:02 - relationships
57:03 - this video is about real time updates
57:05 - with graphql subscriptions with aws
57:08 - appsync so we have been building upon
57:10 - this particular to-do application or
57:12 - other automated to do application where
57:14 - we can like click create to do button
57:16 - and generate list of to-do's into this
57:19 - particular list so currently we have to
57:21 - do 50-33 and if i click create to do
57:24 - again i should see to do 36 all right so
57:27 - when you click create to do button it
57:29 - will call upon a graphql mutation and
57:32 - create that particular to do in a
57:34 - dynamodb table
57:36 - see if i refresh it
57:38 - i should see three item now let's delete
57:41 - like two of these and now if i click get
57:43 - to do's button here this will call upon
57:46 - a graphql query so in that last video we
57:49 - looked at how to implement both
57:51 - mutations and queries
57:53 - so as our server we used aws appsync so
57:57 - appsync is our graphql server which is a
57:59 - managed graphql server
58:01 - and in order to like work with this
58:03 - particular server we used amplify
58:05 - library now here's our app sync server
58:08 - so this is the schema now in order to
58:10 - work with this server we use javascript
58:13 - amplify library the amplifier provides
58:15 - two ways to communicate with graphql
58:17 - first by using uh amplify graphql client
58:21 - can you see this one and also using aws
58:24 - appsync sdk
58:25 - this one
58:26 - we used amplify graphql client to simply
58:29 - create queries and mutations
58:31 - and now today we are going to use that
58:33 - to create subscriptions as well so what
58:36 - really is a subscription guys
58:38 - subscriptions are basically watching
58:40 - over changes
58:42 - in graphql for example you can watch
58:45 - over particular mutation
58:47 - let's say a create to do so when one of
58:49 - the client creates a to-do so that
58:52 - change or that new to-do will be
58:55 - distributed to all other connected
58:57 - clients now let me show you this one now
58:59 - if i take a new
59:00 - browser window and go to localhost 4200
59:04 - to do same angle application we can
59:07 - simulate another client okay
59:09 - so in the first client or the first
59:12 - browser window if i click create to do
59:15 - i will get the to do 41
59:17 - but my other client will not see that
59:20 - change right in order to see that change
59:22 - yes like
59:23 - refresh it or like click our get to do's
59:25 - query there you go but with subscription
59:28 - we can transmit all these changes in
59:30 - real time to all those connected clients
59:33 - so let's see how to do that
59:35 - so i'm going into my code so this is how
59:38 - to do component html that creates this
59:41 - particular page i'm going to do a one
59:43 - particular change instead of clicking
59:45 - this button and generate this automatic
59:47 - to do
59:48 - let's actually allow the user to type
59:50 - something and then click the to do and
59:53 - then add that custom name as the title
59:55 - of our tutorial shall we so this is the
59:57 - html so i'm going to take out this list
60:01 - to do buttons and add the input box here
60:04 - of type text so this will be the place
60:07 - that clients are typing the to-do name
60:10 - and let's add a label to do name so we
60:13 - can pass the to-do name to our create to
60:15 - do function so let's do that
60:17 - to do name
60:19 - and let's change the to-do function as
60:20 - well i will go to to do component.ts
60:24 - and this is our create to-do function
60:25 - now you will receive the to-do name as
60:28 - well here
60:29 - so instead of this random to-do name let
60:32 - me just add the actual to-do name that
60:34 - is passing from the client so these two
60:37 - attributes let's keep it as it is now
60:39 - before i pass that name let's check
60:41 - whether it's not empty
60:43 - if you have
60:45 - a particular length on the to-do so that
60:48 - means there's something in the to-do and
60:50 - i will put that in the if block so now
60:53 - what happens is we will formulate the to
60:55 - do
60:56 - and then we are going to call upon this
60:58 - create to do mutation right since this
61:01 - is a synchronous function we are waiting
61:02 - for that and once the result is received
61:05 - we are pushing that to do into our old
61:07 - to-do array then in the template we are
61:10 - looping over that all to do address and
61:13 - printing out this to do name body and to
61:15 - do completed right now let me change
61:17 - these two as well i will take it out
61:19 - body and completed because these are
61:21 - hard coded values i will just keep the
61:24 - video name
61:26 - let's see if that looks nice on the
61:27 - browser nice
61:29 - now we can like type something back up
61:31 - at
61:32 - 5 a.m and click create to do yeah
61:35 - there's a small error instead of just to
61:38 - do name you have to reference the value
61:41 - here as well right
61:42 - so to do name dot value will give the
61:45 - name of the to-do
61:48 - so now let's try that
61:50 - there you go now it works let's clear
61:52 - this input box as well to do name dot
61:55 - value
61:57 - equal null
61:59 - wake up at 5am click the to do now it's
62:02 - getting cleared okay so how do you
62:04 - attach subscription here or how do we
62:06 - push these changes to all the connected
62:08 - clients now guys when you create our
62:09 - schema amplify has already created all
62:12 - these mutations queries and including
62:15 - subscriptions as well so if you can
62:17 - remember in the last time we have been
62:19 - referencing our service
62:21 - api service which is generated
62:23 - automatically by amplify so this api
62:26 - service
62:27 - also has our subscription code as well
62:30 - now this is our api service.ts can you
62:32 - see there's this subscriptions called on
62:35 - create subscription
62:36 - and we have on update subscription on
62:39 - delete subscriptions so from our client
62:41 - we can like subscribe to this
62:44 - subscription for example let's say
62:46 - oncreatesubscription and once we do that
62:48 - we will receive any newly created
62:51 - to-do's from other clients in real time
62:54 - so let's try that
62:55 - so i'm going to reference this
62:58 - oncreate subscription so this is
63:00 - actually the type and if i just search
63:03 - again you can see on create to do
63:05 - listener returns an observable where we
63:08 - can subscribe to right so let's use that
63:10 - i go to my to do component and here in
63:12 - my create to do method instead of
63:15 - pushing this new to-do into our old
63:17 - to-do's
63:18 - so i will let the subscription to add
63:20 - that particular new to-do into our old
63:22 - to-dos array so let's comment this one
63:24 - out i will just remove it
63:27 - i will take this variable out as well so
63:30 - we are now just waiting for create to do
63:32 - to happen and i will take out this
63:34 - debugger point as well now in our ngo
63:37 - ninit lifecycle method let's subscribe
63:40 - for that particular subscription so how
63:42 - can we do that this dot api so we are
63:45 - referring our api and here oncreate to
63:48 - do listener we are going to subscribe to
63:50 - this particular listener and there it
63:52 - will send me the new to do as the
63:55 - function parameter to our next method so
63:59 - we are subscribing to this oncreate to
64:01 - do listener and in the next function it
64:04 - will send me the new to do that is being
64:07 - created by another client so this happen
64:09 - in real time guys well a graphql
64:11 - subscription creates a website
64:13 - connection with all the connected
64:15 - clients and send this information right
64:17 - so the server sends this in real time so
64:19 - now let's add this to do to our to-do
64:21 - array let's get this new to do into a
64:24 - variable so that is inside to do dot
64:26 - value dot data dot create to do
64:29 - so you have to like go into this
64:31 - particular object we are going to push
64:33 - this to do
64:34 - into our old to-do's array new to do
64:37 - so let's see if this works now again we
64:39 - are subscribing to this oncreate to do
64:41 - listener at the ngoninit method so
64:44 - whenever the component is loaded it will
64:46 - subscribe to this event
64:47 - and once it is subscribed it will
64:49 - receive all the new to-dos that is
64:51 - created by other clients in real time so
64:54 - once a new to-do is received we are like
64:56 - adding it to our old to do survey let me
64:59 - test to do test
65:01 - create to do
65:03 - well i get an error it says cannot read
65:05 - the property of push of undefined that
65:07 - means this. is undefined so let's see
65:11 - yeah here guys let's use the arrow
65:14 - function instead of
65:16 - the normal
65:17 - function so it will correctly reference
65:20 - this with the arrow function okay so
65:22 - let's try now hello
65:24 - create to do now let's get added okay
65:27 - let me just clear out all these items in
65:30 - the dynamodb table
65:36 - and let's test this in different clients
65:39 - so i will take two clients here so this
65:42 - is my first client and this the other
65:44 - client so let's test this out i will
65:46 - type what to do wake up at uh 5 a.m and
65:51 - create to do
65:53 - there you go
65:54 - it get added here and in the other
65:56 - client also it was visible
65:58 - now let's take another client i will
66:00 - take a safari go to the same local host
66:03 - 4200 to do so this is safari and this is
66:07 - chrome this is also chrome let me add
66:09 - another one eat breakfast there you go
66:13 - so can you see now all these connected
66:15 - clients they will receive this newly
66:17 - added to-do through that subscription in
66:20 - real time and they will render their
66:22 - template today we are going to
66:24 - demonstrate the offline capabilities of
66:26 - appsync there are two ways of working
66:29 - with appsync
66:30 - basically you can use the amplify
66:32 - graphql client which is a very
66:34 - lightweight client where you can easily
66:37 - interact with your appsync backend but
66:39 - it does not support advanced features
66:42 - like offline etc so if you need advanced
66:45 - features we have another way that is
66:48 - using aws appsync sdk
66:51 - so today our main focus is using aws
66:53 - appsync sdk and build a small offline
66:57 - application and i'm going to use angular
66:59 - framework today because there are a lot
67:01 - of resources for react but very few
67:04 - resources for angular
67:06 - and there are some gotchas we have to be
67:08 - aware of so let's get started so i will
67:11 - take a terminal
67:13 - and i am in my desktop and let's create
67:16 - a directory
67:18 - offline
67:20 - cd into offline and i will
67:23 - create new angular application ng new my
67:26 - app
67:27 - now add routing guys
67:29 - use a ccs and let it create okay cd into
67:33 - my app
67:34 - and
67:35 - open it in visual studio code or any
67:37 - editor you use i will take integrated
67:39 - terminal here and now we have to install
67:41 - couple of libraries there are four
67:43 - libraries that you have installed
67:45 - first one is the amplify cli you have to
67:47 - install it globally so write npm
67:50 - installed hd at aws amplify cli
67:54 - and then you have to install aws
67:56 - amplifier locally and amplify angular
68:00 - and also
68:01 - aws appsync this is our websync sdk
68:04 - and graphql tag library so let me just
68:07 - copy the first one install that i've
68:09 - already done that let me show the
68:11 - version that i have so i have
68:14 - 0.1.45 and let's install the other
68:16 - libraries
68:18 - npm install
68:20 - aws amplifier locally
68:24 - amplify angular
68:29 - map sync sdk and graphql tag
68:32 - all right it's done now if i go to the
68:34 - package.json
68:36 - have a look at the versions that i have
68:37 - installed
68:39 - now before building our application we
68:40 - have to do a bit of initial
68:42 - configuration to avoid some compile time
68:44 - errors when compiling angular with
68:46 - amplify and appsync
68:48 - so first thing is you need to go to src
68:52 - and find your index.html
68:56 - at this script tag
68:58 - so basically it's a reference to the
69:00 - window object which is referred as
69:02 - global so we need this one okay
69:05 - and don't worry guys i will add a link
69:07 - to the github repository so you guys can
69:09 - easily copy paste the code
69:11 - okay first thing is done and secondly
69:14 - you need to go to
69:16 - tsconfig.app.json file
69:18 - and under the compile options under
69:21 - types add node so this is required when
69:24 - compiling application with amplify and
69:27 - now you need to go to
69:30 - polyfill.ts
69:31 - sort of this file on top of the file we
69:34 - have to add two things
69:36 - first one is a reference to the global
69:38 - object there is referencing window
69:40 - and another reference for the process so
69:42 - these two are required all right and
69:45 - also we have to do another configuration
69:47 - in tsconfig.json
69:51 - this particular file
69:52 - here you need to set the attribute
69:55 - called skip leap check to true otherwise
69:58 - you will get some errors when you add
70:01 - the
70:02 - appsync sdk so make sure to add these
70:05 - two i think these are the main
70:06 - configuration we need
70:08 - so now let's initialize an amplify
70:09 - project so i will take the
70:12 - integrated terminal and clear the
70:14 - console i will type
70:16 - amplify init
70:18 - hit enter editor vs code javascript
70:22 - angular src is our source directory and
70:27 - build file will be in dash my app which
70:31 - is the name of our folder
70:33 - and build command accept the default hit
70:35 - enter start ng server right now it's
70:38 - asking whether we want to use the aws
70:41 - profile in my case i will had yes i have
70:44 - multiple profiles i will choose youtube
70:47 - you guys can choose default or
70:49 - if you have a profile configured for aws
70:52 - use that one so it's creating this stack
70:54 - i will fast forward okay done now we
70:57 - need to add some appsync features so uh
71:00 - let's clear this out
71:03 - and i will add
71:05 - the auth first
71:06 - because we need a login
71:08 - and let's use cognito user pool
71:10 - authentication for our small to-do
71:13 - application and i will use the default
71:15 - configurations
71:17 - let's add api as well
71:20 - amplify add api
71:22 - choose graphql provider api name my app
71:26 - is fine and here use amazon cognito user
71:29 - pool do you have an updated graphql
71:32 - schema no yes i need a guided creation
71:36 - single object with fields to do
71:39 - do you want to edit yes
71:42 - and she'll open it up and here guys i
71:44 - will just take out the description as
71:46 - well just want the name of the to-do
71:48 - that's it so i will save it
71:51 - and hit enter
71:53 - okay now we need to do amplify push
71:56 - to update the resources in the aws
72:00 - select yes
72:01 - so it will update both author api and
72:04 - now
72:05 - take this up a little bit so you guys
72:07 - can see do you want to generate code for
72:09 - your newly created graphql api say yes
72:13 - then choose the code generation language
72:16 - now here guys you can use typescript
72:18 - because
72:19 - here it will create those
72:22 - mutations and subscription separately
72:24 - where you can easily import it so use
72:27 - typescript accept the defaults
72:30 - say yes i want to generate all
72:33 - okay
72:34 - there should be
72:35 - the file it should be in source api dot
72:38 - ts
72:39 - hit enter now it's creating the
72:40 - resources let's give it few minutes
72:43 - okay it's created now if you go to
72:45 - amplify folder and into the backend api
72:48 - my app and into the build folder
72:51 - you can see the graphql schema that it's
72:54 - generated
72:55 - so you have all the queries and
72:58 - mutations and subscriptions all that
73:00 - right and also if you go to your source
73:03 - folder you should see a new folder
73:05 - created graphql inside that you should
73:07 - see the mutations queries
73:11 - and subscriptions as well right now we
73:13 - can easily import them into our
73:15 - components
73:17 - so let's create our components
73:19 - so how many components do i need i need
73:21 - let's say two components
73:24 - ng
73:25 - gc first one let's say auth
73:28 - that will include our login screen
73:31 - and i will create another one in ggc
73:34 - to do
73:36 - that will include our to-do application
73:38 - and also i will create a service file in
73:41 - ggs appsync
73:44 - so let's create a service uh called
73:46 - appsync as well
73:48 - so that is created so let's see the
73:50 - generated files
73:52 - both
73:53 - component to do component and here our
73:56 - appsync service okay first and foremost
73:58 - guys we need to register amplify angular
74:01 - module and also our service app sync
74:04 - service so let's import it in the
74:08 - app.module.ts file so this is our main
74:10 - module file here let's import
74:13 - amplify angular module and amplify
74:15 - service from aws amplify angular library
74:20 - so the module put it inside the
74:23 - imports
74:24 - and amplify service put it inside
74:27 - the provider now we need to import the
74:29 - appsync service as well so this
74:33 - new service that we just created so
74:35 - let's import that
74:36 - app sync service from app sync service
74:40 - should be simple as here and add this to
74:42 - our providers list as well
74:45 - now when we push our websync services it
74:47 - has created this uh aws export.ts file
74:51 - rather js file you can find it in your
74:53 - source folder here aws export.js
74:57 - so it has all the reference to your
74:58 - backend resources like where you use a
75:00 - pool use a pool id and absyncroftql
75:04 - endpoint etc
75:06 - so we need to reference this in our
75:08 - application and initialize at start so
75:11 - go to main.ts file here
75:14 - and let's import this
75:16 - aws export file
75:18 - i import it as amplify import amplify
75:21 - from dot slash aws export
75:24 - and also import the amplify library
75:26 - itself
75:27 - import amplify from aws amplifier now
75:30 - let's configure amplify amplify dot
75:33 - configure oops configure
75:36 - with our exported configuration okay now
75:41 - it will initialize successfully but we
75:43 - have to do one other thing as you can
75:45 - see uh our aws export is a.js file you
75:48 - have to convert it to ts
75:50 - we can do it using a script provided in
75:53 - the documentation of amplify
75:56 - for that you go to
75:58 - package.json and you have to replace the
76:01 - start and build command with a script
76:04 - so if you go to amplify
76:07 - documentation at this link and you go to
76:11 - angular and ionic
76:14 - menu and if you scroll down a little bit
76:16 - you should see the script here just copy
76:18 - these two lines so that is basically
76:20 - converting your js file to ts on the fly
76:24 - just replace start and build nice
76:27 - okay now let's add our login screen let
76:30 - me go to auth component.html
76:33 - so this will have our login screen
76:35 - clear out the content let's use the
76:38 - built-in directive for amplify
76:40 - authenticator
76:42 - so this will easily render our login
76:45 - screen so import this directive amplify
76:47 - dash authenticator into your
76:50 - alt.component.html now for styling this
76:52 - component you should add the styles as
76:54 - well just
76:57 - search your styles.css file which is
76:59 - here inside the source directory here
77:02 - and import
77:03 - amplify angular theme
77:05 - you can find this also in the
77:07 - documentation so let's see if the
77:10 - things are working fine
77:12 - so i will type ng serve so that will
77:15 - start the application locally let's see
77:17 - if there are any compilation errors it
77:19 - seems to be working fine
77:21 - we forgot to add one thing that is our
77:23 - routes
77:24 - so
77:25 - go to your app folder
77:27 - and in there app dash routing.module.ts
77:32 - so currently we don't have any routes so
77:34 - let's add some route i'm going to add
77:36 - two routes here first one is
77:38 - to do
77:39 - so if if someone navigate to slash to do
77:42 - it should load up the to-do component so
77:44 - let's import the to-do component up here
77:46 - to component
77:48 - from to do to do component
77:51 - and also
77:53 - the default route is our component
77:55 - that will render our login screen so i'm
77:58 - not going to add any
78:00 - route cards or anything as such right
78:02 - you guys can use it if you want what
78:04 - component from out slash what component
78:09 - okay and let's navigate to http
78:12 - localhost 4200 and i should see my login
78:15 - screen and see
78:17 - let's remove this uh default content
78:19 - i'll go to
78:21 - component.html and let's remove all this
78:23 - default content save that come back here
78:27 - it will reload the page and here's our
78:29 - login screen so make sure you don't have
78:31 - any errors in the network tab in the
78:33 - inspect element now let's add a very
78:35 - basic ui to our to-do component as well
78:38 - so inside our to-do component to do html
78:41 - i'm going to replace it with this bit of
78:43 - html so this is basically a rendering an
78:46 - input type or an input box
78:48 - and then a button to click
78:51 - so in the input box you will type the
78:52 - to-do name and when you click the button
78:54 - it will
78:55 - fire this create to do event and it will
78:58 - pass the to-do name along with that and
79:00 - under it you are going to render all the
79:02 - to-do's in an array called all to-do's
79:05 - so basically when you click the create
79:07 - to do we will add that to do into this
79:09 - all to lose array and that will show it
79:12 - in the screen so in the javascript side
79:14 - guys let's import our service first so
79:16 - i'm importing appsync service from our
79:18 - appsync service file
79:20 - and let's inject this into our
79:22 - constructor let's create a private
79:24 - variable called
79:26 - appsync of type
79:29 - appsync
79:30 - service so now we can use the sap sync
79:33 - service which
79:34 - itself is single returned throughout our
79:36 - components to talk with our backend
79:38 - services through the appsync sdk right
79:41 - but before that let's uh add some
79:43 - configuration or the code to our websync
79:45 - service so i will go to
79:47 - source app and
79:49 - appsync service here
79:51 - currently we don't have anything first
79:53 - i'm going to import appsync sdk from aws
79:55 - fsync and then we need aws export file
79:59 - as well because we are going to use the
80:01 - graphql endpoints from this file when
80:03 - configuring a web sync sdk finally we
80:06 - have to import auth and or type from
80:10 - aws amplify and appsync
80:12 - oauth link
80:14 - because these are necessary for sending
80:16 - out the credentials of the user when
80:18 - requesting the information so let's see
80:20 - how to use this i'm going to paste some
80:22 - code into the constructor okay let's go
80:24 - through that first i create a variable
80:26 - called client so this is basically aws
80:29 - fsync client that we have exported up
80:32 - here so as for the configuration we have
80:34 - to pass few attributes first one is the
80:37 - abstinence graphql endpoint url that we
80:40 - get from aws export file because inside
80:43 - aws export file we have this particular
80:46 - endpoint let me quickly show you here
80:48 - so that's the url and the region so
80:51 - again in the same export file you can
80:53 - get the region as well now we have the
80:56 - auth attributes so out type is basically
81:00 - it's a type of amazon cognito user pool
81:02 - because we have initializer user pool
81:05 - you can here use the api key if you want
81:08 - but
81:09 - use cognito user pool because that is
81:11 - the standard when it comes to enterprise
81:13 - applications so you go to pass the id
81:16 - token along with your request so that's
81:18 - where we are extracting the id token
81:21 - from current user session so we are
81:23 - getting the id token and
81:25 - send it in attribute called aw d token
81:29 - so that's our client basically and we
81:31 - need to export this client we'll have a
81:33 - variable up here
81:34 - let's say let's see and at the bottom of
81:37 - constructor let's assign underscore hc
81:40 - variable to our client and let's have
81:43 - another function called let's see
81:45 - so what does this sc mean anyways guys
81:47 - so uh
81:48 - let's see is basically hydrated client
81:51 - don't need the arrow function here so
81:54 - here we are returning this dot
81:56 - underscore hc hydrated okay a quick word
81:59 - about aws sync client so this is
82:02 - basically using apollo client so apple
82:04 - client is a graph giveaway
82:06 - implementation that has offline features
82:08 - as well so aws appsync has created a
82:10 - wrapper or another implementation from
82:13 - apollo client and that's what we are
82:14 - using today so in apple client we can
82:17 - cache all the queries in the local
82:19 - storage or any other storage medium and
82:21 - here it will wait until the cache is
82:23 - populated
82:24 - so then only it will return the client
82:26 - or the app sync client so let's see how
82:28 - to use this map sync service i will go
82:30 - to to do component we already imported
82:33 - the appsync service here and in our html
82:35 - we have a create to do function that
82:38 - will fire when the button is clicked so
82:42 - let's have that function implemented so
82:44 - i will create async function for that so
82:47 - it will pass the to-do name here
82:50 - as the parameter and let's check if
82:53 - to-do name has some value and if so
82:56 - let's create appsync client so i created
82:59 - a constraint called client and i'm
83:01 - awaiting this dot appsync dot hc so this
83:05 - two type sync is our service here and it
83:08 - sees the function that returns the
83:10 - hydrated trend right so we are waiting
83:12 - for the client and afterwards we have to
83:14 - create our mutation so what is the
83:16 - mutation is basically creating this to
83:18 - do
83:19 - in the database right so let's look at
83:21 - our mutations
83:23 - so if you can remember inside our
83:25 - graphql folder we have mutations
83:27 - so here's our create to do mutation so
83:30 - we need to export or rather import this
83:33 - mutation into our to do component so
83:35 - let's do that i will import create to do
83:38 - mutation from graphql mutations and also
83:41 - i'm going to import graphql tag library
83:43 - as well import gql from graphql tag and
83:47 - let's import other tools as well like
83:49 - the queries and the subscription because
83:51 - we have mutations
83:53 - so we may need the queries and
83:55 - subscriptions or at least queries so i'm
83:57 - importing the list to do queries from
84:00 - this queries dot ts file here
84:03 - inside the graph keyword and i have
84:05 - create to do mutation as well so how do
84:08 - we make this mutation guys so basically
84:10 - now that we have the appsync client we
84:13 - can simply use a
84:15 - mutate right and add the mutation
84:17 - together with the passing uh to-do value
84:20 - so that is fine
84:21 - but are we using the offline features
84:24 - yet
84:25 - no right so in order to use offline
84:27 - functionality we have to make sure that
84:30 - if there's no network
84:32 - cache whatever the mutation in the local
84:34 - storage or whatever the storage medium
84:36 - that we are using for front-end
84:37 - application and
84:39 - thanks to apollo client it will maintain
84:42 - a map
84:43 - or a queue of all the mutation that is
84:47 - being added during the offline so it
84:49 - will maintain this queue
84:51 - so this q will have all the mutations
84:54 - let's say
84:56 - you added three to do's so it will first
84:59 - add the to do one into this queue
85:01 - offline queue and when you add the
85:03 - second to do it will push this to the
85:04 - queue that one as well
85:06 - so similarly it will like populate this
85:09 - queue in your local storage at the front
85:12 - end right so whenever the network is
85:15 - back so when you're online so it will
85:18 - start executing this queue item from the
85:21 - order that they were received
85:23 - so it will start from the first element
85:26 - of the first item and it will go to the
85:28 - last element that was added so now to
85:31 - call this functionality there are two
85:32 - ways
85:33 - first one is either you can use
85:35 - an update function that will be called
85:38 - when offline as well as when it is back
85:42 - online or you can use the build mutation
85:45 - helper
85:46 - from appsync sdk which is the
85:48 - recommended method
85:50 - so let's use build mutation for that i
85:52 - need to
85:53 - import build mutation up here first
85:56 - import build mutation from aws fsync and
86:00 - here
86:01 - let's get the result of the mutation
86:03 - into a variable called result s-u-l-t
86:07 - okay and i'm going to copy paste some
86:09 - code here okay now let's go through this
86:11 - code so i created this constraint called
86:14 - result and i am awaiting the client
86:18 - again on a method called mutate so this
86:21 - is basically the function that called
86:22 - the mutation from the absync sdk so
86:26 - client.muted and so inside the
86:28 - parentheses we have to pass the
86:30 - build mutation function so the build
86:32 - mutation function so as we have imported
86:36 - up here
86:36 - so we say it's built mutation and inside
86:40 - that build mutation it accepts several
86:42 - parameters here's the first parameter so
86:45 - it is the first parameter is the client
86:47 - available client right web sync client
86:49 - rather and then
86:51 - we have to pass
86:52 - the mutation so which mutation are we
86:55 - going to call it's the create to do
86:57 - mutation right so create to do mutation
86:59 - we have imported up here
87:02 - and i'm going to grab that mutation
87:05 - using graphql tag library so gql so this
87:09 - will add proper graphql tags
87:11 - to our create to do a mutation and then
87:14 - the third one we have to pass the input
87:16 - type so we have not yet imported our
87:19 - create to do input so let's do that at
87:21 - once so we need to import the inputs as
87:25 - well so currently we don't have any
87:27 - inputs
87:28 - associated here so
87:31 - i will create a new file called inputs
87:35 - dot ts and here i'm exporting the create
87:38 - to do inputs let me paste that
87:41 - so from where did i get this so i'll
87:43 - show you uh so it's basically
87:46 - this text
87:47 - that i copied from our graphql schema so
87:52 - if you can remember our graphql schema
87:54 - is available inside of amplify folder in
87:57 - the current backlog api in the build
88:01 - graphql and here you have
88:04 - create to do input
88:06 - just copy this
88:08 - and come back here
88:09 - and paste it in here so simply add to
88:13 - backticks
88:14 - and export it now we can import it from
88:17 - here so in our to-do component.ts file
88:21 - so i'm going to import that create to do
88:23 - imports from graphql inputs
88:27 - nice so now our error is gone so we are
88:30 - decorating that again with graphql tags
88:33 - and variables so variables is basically
88:36 - the inputs that we are providing it
88:38 - right so as we have already seen
88:41 - it is expecting and name the to-do name
88:45 - and that is a mandatory field right
88:47 - so in our app sync back-end we are
88:49 - generating this id automatically so we
88:51 - just have to pass the name here
88:54 - so i saw variable we are passing to do
88:56 - name dot value now we have to pass this
88:59 - as an object so let me just take it out
89:03 - i will add object literals here
89:05 - name has to be to do name dot value
89:08 - nice so then we are passing another
89:12 - query list to do squarey as we have
89:15 - imported it up here so we have imported
89:17 - list to use queries as well so why do we
89:20 - actually need these guys so in build
89:23 - mutation so what basically happens is if
89:26 - it is offline if there's no network
89:29 - what apple client does is it will use
89:32 - one of the queries that has cached
89:35 - earlier in the local storage so here it
89:38 - used the list to do query so it will
89:41 - read all the to-do's or the list of
89:44 - to-do's that it has cached earlier so it
89:47 - read it from the cache
89:49 - and at this newly created value into the
89:52 - cache
89:53 - or the list to do's array so it will
89:55 - read the cache and write the new item
89:58 - into the cache as well so finally we
90:00 - have to pass the to-do type so that is
90:02 - also required so when the network is
90:04 - back it will play all the mutation that
90:07 - is recorded inside the cache and there's
90:09 - another concept called optimistic ui
90:12 - update so that is basically when there's
90:14 - no network obviously result is not going
90:17 - into the database right and it is stayed
90:19 - in the cache but we will update the ui
90:23 - even though it is not persistent in the
90:24 - database so that it will give a better
90:27 - use experience for whoever the user
90:29 - using the application
90:31 - so how to do that optimistic ui update
90:34 - so once we have built the mutation and
90:36 - it returns the results here let's push
90:39 - into the array
90:41 - that we are referencing in the ui so
90:43 - that is all to do
90:44 - and i'm going to push
90:46 - the result that is returned here so that
90:51 - is all to do and i think we have not
90:54 - references up here as well so let's add
90:58 - that variable up here all to do so of
91:00 - any type and
91:02 - down here let's push that item in the
91:05 - cache into this this dot altodos.push
91:09 - and it is inside the result variable
91:14 - dot result.data.create to do and let's
91:17 - empty our
91:19 - to-do name value as well so it will look
91:22 - nice on the ui all right
91:25 - now uh when loading up this component i
91:28 - need to like show all the to-do's that
91:32 - has been earlier added right so let's
91:34 - populate these all to do's
91:36 - with a query by calling the list2do's
91:39 - query
91:40 - using our appsync client so in ngon it
91:43 - i'm going to paste this code so i pasted
91:46 - this code
91:47 - so it's basically the
91:49 - stotapsync.hydradarclan so we are
91:51 - calling our service and then you get a
91:52 - client
91:54 - and inside that client we are calling
91:56 - the watch query so that will basically
91:59 - do a query on list to do's which we have
92:02 - imported up here and the fetch policy is
92:05 - cache and network it's basically check
92:07 - the check cache and then go into the
92:09 - network and we are subscribing to the
92:11 - data that is returned from the query
92:14 - and we are setting this total to do's
92:16 - to the data that is returned from here
92:19 - it is data dot
92:21 - list to do start items right now as i
92:23 - previously mentioned this code will be
92:25 - available in the github link below okay
92:27 - now it all looks good so let's see if it
92:30 - is actually working so i will go to my
92:33 - ui and do a refresh and make sure you
92:35 - don't get any errors and now let's
92:37 - create account click create account your
92:40 - username password you have to add
92:43 - capital and numbers there sign up
92:46 - okay you should receive an email to your
92:48 - email address get that code and paste it
92:51 - here and confirm it so then you'll
92:54 - redirect the login page again so type
92:56 - your password sign in okay now you're
92:58 - signed in so now let's navigate to to do
93:03 - okay i don't see any errors that looks
93:05 - good and
93:07 - let's try to edit to do shall we
93:12 - go to gym
93:16 - yes it does
93:17 - beautiful
93:18 - let's verify that i will go to
93:20 - aws.amazon.com
93:23 - and into my dynamodb log into your
93:26 - console guys okay and this is my table
93:28 - here
93:29 - click on that
93:30 - and in the items there you have it
93:33 - so it persisted beautiful so let's add
93:36 - another one eat
93:38 - healthy
93:41 - yep that is also added
93:43 - let's check that
93:44 - there you go
93:46 - now let's try offline so i'm going to
93:49 - click here
93:50 - and turn off my wi-fi
93:52 - so it's turned off
93:54 - and i will add
93:57 - offline to do
93:59 - let's see if i see a network request
94:04 - it is directly added thanks to our
94:06 - optimistic ui response but as you have
94:08 - seen there is no any network call so
94:12 - let's reconnect our wi-fi and and have a
94:15 - look at here
94:18 - you should see
94:19 - the request will automatically be made
94:22 - there you go
94:23 - this is the request that got
94:25 - automatically made
94:27 - and now if you go to dynamodb and
94:29 - refresh it
94:31 - there i have the offline to do
94:34 - beautiful
94:35 - if i refresh it again
94:37 - you see those are indeed persistent
94:40 - so this is what i want to show you guys
94:42 - i hope you guys enjoyed this
94:44 - and if you guys like my videos
94:46 - so if you want to see this nature of
94:48 - content please like and subscribe to my
94:50 - channel guys
94:52 - thank you very much