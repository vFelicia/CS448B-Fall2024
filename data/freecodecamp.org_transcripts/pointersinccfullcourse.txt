00:00 - The course you're about to watch is about pointers 
in C. The course was developed by the excellent  
00:05 - instructors from my code school. My Code School is 
one of the earliest software channels on YouTube,  
00:11 - and has inspired many developers and creators. 
In the description. I've included a link to an  
00:17 - article about the channels amazing story. 
Now let's get to the course. pointer  
00:23 - is a very fundamental and important concept in 
programming. But a lot of beginner programmers  
00:30 - find it difficult to understand pointers. So in 
this lesson, we will try to demystify pointers.  
00:36 - And all you need to know to understand this 
lesson is how to write a basic C program,  
00:42 - how to declare a variable and how to do 
simple arithmetic upon those variables.  
00:47 - Okay, so let's get started. To understand 
pointers, we first should understand how  
00:54 - various data types or various variables are stored 
in computer's memory. Okay, so let us say, this  
01:01 - figure in the right here is computer's memory. And 
when we talk about computer's memory in context of  
01:08 - program execution, we mostly talk about 
the random access memory or the RAM,  
01:13 - we often say that my machine has got two GB of 
two gigabytes of RAM, or four gigabyte of RAM.  
01:19 - Now let's say these segments, or partitions that 
we are showing here in the memory is each one byte  
01:25 - of memory. Now in a typical memory architecture 
in a typical computer architecture of the memory,  
01:33 - each byte of the memory has an address. So let's 
say the first byte in this memory, which we can  
01:42 - assume to be the lowest by deep down here has an 
address zero and the address keeps on increasing  
01:49 - as we go towards the top. So we go on like 012. 
And let's assume this particular address is  
01:58 - 201. So the next byte will have an address of 202. 
And we will go on like 203204, and so on. Now,  
02:08 - when we declare a variable in our program, let's 
say for example, if we declare a variable a of  
02:14 - type integer, then when this program executes, 
the computer allocates some amount of memory  
02:20 - corresponding to this particular variable. 
How much memory it allocates, depends upon  
02:26 - the data type, and also upon the compiler. So 
in a typical modern day compiler and integer  
02:33 - is allocated four bytes of memory. Character 
variable is allocated one byte of memory,  
02:40 - float is allocated four bytes of memory and 
we can have other variables as well. Okay,  
02:46 - so as soon as the computer sees a declaration, 
like this, during the program's execution,  
02:52 - it knows that this is an integer variable, so 
we need to allocate four bytes of memory. Let's  
02:57 - say in our example, it allocates memory starting 
address 2042 address 2074 a. And the computer has  
03:07 - an internal structure, a lookup table, where it 
stores this information that there is a variable  
03:12 - a, it is of type integer, and it is located at 
address 204, which is the starting address of  
03:19 - the variable. Now, if we declare another variable, 
so for example, if we declare a variable named C,  
03:26 - which is of type character, now once again, 
when the machine sees this declaration,  
03:31 - it knows that it is a character variable, so it 
needs one byte of memory. So it looks for some  
03:36 - free space, let's say in this case, it allocates 
the address to 09 the byte 2094 C, and once again,  
03:46 - it keeps an entry for it in an internal structure 
called lookup table, that a sees a character  
03:53 - and its addresses 209. Now when we perform some 
operation with these variables, like let's say  
03:59 - if we initialize a to five, when our machine or 
computer sees such a statement, it looks into  
04:05 - the lookup table for this variable A. So it finds 
this variable a that it is an integer and it is  
04:11 - at address 204. So, it goes at address 204 and in 
these four bytes starting 204 it writes this value  
04:21 - five now in reality, the value is written in 
binary but for the sake of understanding we  
04:27 - are writing here in decimal form. Now once again, 
let's say we have some statements and then again  
04:33 - after these statements, we have another statement 
which increments a Now again, when computer sees  
04:39 - that, he has to be incremented, it again looks 
for this address for a goes to the address and  
04:46 - modifies this value at this particular address. 
So this block of memory allocated for a stores  
04:52 - the value six now. Now, all of this is really 
cool, but can we know the address of a variable  
05:00 - In our program, or can we operate upon 
these memory addresses in our program?  
05:04 - Well, yes, you can do so in a C or c++ program 
using the concept of pointers. pointers are  
05:12 - variables that store the address of another 
variable. And to make you understand about this  
05:17 - a little better, I'll redraw a couple of these 
things. Let us say we have a block of four bytes  
05:23 - at address two sort of food that stores an integer 
variable a. Now we can have another variable,  
05:31 - the type of which is pointer to integer. And 
let us say the name of this variable is P.  
05:38 - Now this variable p can store the address of 
A. And using the properties of P, or using some  
05:46 - operators upon p, we can reach a. Now p also 
takes some memory. So let's say it is stored  
05:54 - at location address 64. And it also takes four 
bytes of memory, we can also modify p to point to  
06:03 - another integer. So let's say if we 
have another integer at address 208,  
06:09 - named B and having value 10. And if we change the 
address in p from 2042208, then P now points to  
06:18 - me. Let us now see the syntax of pointer variables 
and see a normal variable is declared by writing  
06:26 - the data type and a variable name. So int a means 
that we have a variable a of type int. If we want  
06:33 - to write a pointer variable that should point to 
another variable, all we do is we put an Asterix  
06:40 - sign before the variable. So P is now a pointer 
variable that points to an integer. So P is a  
06:51 - variable that can store the address of an integer. 
Now, to store the address of A in p, we need to  
06:59 - use a statement like p is equal to ampersand a. 
Now if we put ampersand in front of a variable,  
07:06 - it gives us the address of that particular 
variable. In fact, it returns a pointer  
07:12 - to that particular variable. Okay, so let's try 
to see a simulation of this. Let's say when we  
07:16 - declared the variable A, then it was allocated an 
address to zero for now we declare an a pointer to  
07:25 - integer p, let's say it was allocated 
at a 64. Now when we write a statement,  
07:29 - like p is equal to ampersand A, then P now has 
the address of A and it kind of points to a.  
07:40 - Let's initialize a to some value let's say is 
equal to five, so we fill value five into a now.  
07:48 - Now, what will happen if I print p, what will 
be the output? Any guesses? Think about it.  
07:57 - Okay, so if we try to print p, then the output 
will be 204 because P has a value to 04. What if  
08:06 - we simply try to print ampersand of a ampersand 
of a also gives us the address of a so this will  
08:12 - also be 204. What if we want to print ampersand 
of P. Now P is also a variable and it is also  
08:21 - stored in the memory. So ampersand since it prints 
the it gives you the address of that variable.  
08:27 - So, printing ampersand of P should give us 
64 which is the address of P. Now, there is  
08:34 - one more important property of pointer, if we 
put an asterisk sign in front of the pointer,  
08:40 - then it gives us the value at 
the location that it points to.  
08:44 - So, what will happen if we try to print star 
of P asterik of p? Well, it will give us  
08:51 - five This concept is called as D referencing 
because we have a reference or we have stored  
08:59 - an address in P and we kind of get the value 
at this particular address using this operator.  
09:06 - In fact, we can modify the value at this 
particular location by saying something  
09:12 - like Star P is now eight star p means value at p 
and so, the value at p is now modified to eight.  
09:21 - So, what will happen if you print star p 
or print a now the output will be eight  
09:30 - by value of p i mean value at address P. 
So P is the address and star P is the value  
09:38 - at address that is stored in P. Okay, so just 
to reiterate, we define a pointer variable  
09:45 - using by putting an asterisk sign 
in front of the variable name.  
09:49 - And if we put an ampersand sign in front of 
a variable name, we get the address of it.  
09:54 - So if we try to print a pointer variable without a 
strict sign or operate upon it without astrix I We  
10:00 - are operating with the address, while if we put 
an Asterix and in front of the pointer variable  
10:05 - and operate upon it, then we are 
operating the value at that address.  
10:10 - So this was some of the basics of pointers. In the 
coming lessons, we will see some code snippets,  
10:16 - where we will see some of the common errors that 
we make while using pointers. And we will also  
10:22 - learn pointer arithmetic and pointers in the 
context of arrays. So, thanks for watching.  
10:30 - So, in our previous lesson, Introduction to 
pointers, we learned the basics of pointers. In  
10:36 - this lesson, we will see how to work with pointers 
in some real code examples. But before that  
10:42 - a quick recap, pointers are variables that store 
address of other variables. We declare a normal  
10:50 - normal variable with a syntax like 
the data type or the variable type,  
10:56 - followed by the variable name, but we declare 
a pointer variable with a syntax data type and  
11:05 - an Asterix sign followed by the variable 
name, we need an integer pointer variable  
11:11 - to store the address have an integer to store the 
address of say, a character variable we will need  
11:18 - a character pointer so the same syntax 
will be used we put an asterisk sign  
11:23 - and let's say the name of the variable is P zero. 
So C is a character variable and P naught is a  
11:30 - pointer to character. And similarly, we can have 
a pointer to double. And we can also have pointers  
11:38 - to a user defined structure or a user defined 
class also. And to get the address of a variable  
11:46 - we write a statement like p is equal to ampersand 
a now this ampersand works as an operator, that  
11:54 - gives us the address of A. And what happens in the 
memory is something like this. Variable p stores  
12:01 - the address of variable A. So in this figure 
here, PS value is 204, which is the address of a  
12:08 - so P points to a and using p we can also get the 
value of A. So let's say if A is eight, and we  
12:19 - use a star operator in front of p, then the star 
p gives us eight which is value of A. If we try  
12:27 - to print stoppie it gives us eight. Let us now 
try to see some of these in real code. Okay,  
12:34 - so time to see things moving in a real C program. 
Now, what I'll do is I'll play a game with you, I  
12:41 - will write some print statements, and you need to 
guess what will be the output. So what I'll first  
12:47 - do is I'll declare an integer variable a, and 
then I'll declare another variable which will be  
12:53 - pointed to integer. And now I'll write a 
print statement where I'll be printing P. Now,  
13:01 - what will be the output of this program? Okay, 
so let's run this program. Oops, this gives us  
13:07 - an error. And if it is too small for you to read, 
then this is giving an error that the variable P  
13:15 - is not initialized. And we are using it without 
initializing. So that's why the program is  
13:22 - crashing. So now I will write a statement p 
is equal to ampersand a now ampersand of A is  
13:30 - nothing but address of A. Now let's run this 
again. Okay, so this springs and address  
13:40 - and how do we know that this is the address or 
this is the right address that is stored in P.  
13:45 - So I'll write another print statement. And now I 
am printing star p now star operator when it is  
13:52 - put in front of that dress then it gives 
us the value at that particular address.  
13:57 - Okay, so what will be the output of the second 
print statement? So when we done this, the the  
14:04 - first line gives us the address that points to 
and this address is different than the previous  
14:09 - address because every time the program runs afresh 
new addresses are located. But the value at B  
14:17 - is some garbage value is some 
integer that I'm not sure what it is.  
14:22 - This is happening because I have not initialized 
a and all the memories are located for a there is  
14:30 - some garbage value there that I do not know 
about. Okay, so let's initialize a let's say  
14:34 - a is equal to 10. And now the 
second line prints the value of a  
14:43 - and now I will write another print statement. And 
this time I'll print ampersand a. Now what should  
14:51 - be the output of this third print statement? 
And this should be pretty easy to guess.  
14:57 - ampersand operator gives us the address And that's 
why the third line is also the address of A.  
15:05 - In fact, that's what we have done 
here, when we have assigned p,  
15:09 - the address of A, we have 
used operator and percent.  
15:13 - Now what I will do is, I will modify the value in 
a using the pointer P. And to do so I will write a  
15:20 - statement like Star p is equal to 12. And this is 
read as value at address p value at address being  
15:27 - pointed by B is now 12. This concept is called 
dereferencing. So, now, if I try to print a,  
15:36 - and let's also put one print statement for 
a before we modify the value, and let's  
15:42 - run this. So the first print gives me 10, which 
is the value that we had initialized a with  
15:49 - and the second print gives us a is equal 
to 12. Because we modified the value  
15:55 - using the pointer. Okay, so one more thing that 
I'll do here, now, I'll have another variable b,  
16:01 - that will have value 20. And now what I'll say 
is start p or value at address p is equal to b.  
16:09 - And the question now is that will the 
address and P change now 2.2 b? Well,  
16:16 - no, unless you explicitly write a 
statement like b is equal to ampersand b,  
16:22 - this reverse operation will not happen, 
what we are doing here is actually only  
16:26 - putting in the address of a the value that B 
has, but we are not pointing to B. And this  
16:32 - will get clear only if we write some more printf 
statements. So before writing the statement,  
16:38 - I'm writing two print statements, one to 
print the address and one to print the value.  
16:43 - And after we write the statement, I'll write two 
more print statements trying to print the address  
16:48 - and value again. So, let us see what output is 
now okay. So, address of P initially is t 144576  
16:57 - and value is 10. And after the statement star p 
is equal to b only the value is modified and the  
17:03 - pointer still points to a. So a kind of now 
becomes 20, but the address does not change.  
17:08 - Now, one more thing, sometimes we declare and 
initialize a variable in the same statement.  
17:14 - So instead of writing this A equal 10, here, 
we could simply say that int a is equal to 10.  
17:21 - So we can do so for the pointer 
variable as well, we could simply say  
17:25 - for these two statements, one simple statement 
like n star p is equal to m percent a and we  
17:33 - will not need the statement. This one statement 
is same as saying the earlier two statements,  
17:38 - the syntax of declaring pointers some people write 
this asterisk sign after end and do not write it  
17:46 - in front of the variable name. This also works 
and this is also fine. So you can write int  
17:51 - star which which means pointer to integer 
and then you can write the variable name  
17:55 - and this will also work. Okay, so now we 
will point we will talk about a concept.  
18:03 - We will talk about the 
concept of pointer arithmetic.  
18:09 - But before that I'll write this rewrite this 
declaration and initialization like before  
18:15 - in two statements. I like it better this way, 
it's less confusing. Now I will write two print  
18:21 - statements here. In the first statement, 
I'll print P and in another statement,  
18:27 - I will print p plus one. Now is it really possible 
to do so? Can we really increment and decrement  
18:35 - a pointer variable? Well, yes, we can do so. So 
now let's assume that the address stored in P is  
18:43 - something like 2002. So any guesses what 
p plus one will be? Will it be 2003?  
18:52 - Well, no p plus one will be 2006. This is because 
if p is an integer pointer incrementing it by one  
19:01 - unit takes us to the address of the next integer. 
And because the size of an integer is four bytes.  
19:08 - So to go to the next integer address, we need to 
skip four bytes. So P plus one increments p by  
19:16 - four bytes, I'll write another print statement in 
which I'll print the size of an integer variable.  
19:22 - And I'll write something like size of integer is 
and we have a function and see size of that gives  
19:30 - us the size of a data type. So this statement this 
print statement will give us the size of integer  
19:36 - and let's write in the first and 
third print statement something like  
19:42 - address P is blah and address p plus one is a 
block. So let's now run this and see what happens  
19:50 - okay. So the output is address P is 4586052 which 
is some address. And then we print size of integer  
19:58 - is four bytes. So for this Particular compiler, 
the size of an integer is four bytes and address  
20:04 - p plus one is four bytes more than address p, you 
can try this thing out for a character pointer or  
20:10 - a double pointer or a pointer of some other data 
type. Okay, so we could also increment this by  
20:16 - two. And what happens if we increment this by two? 
Well, it will increment the address by eight. So  
20:24 - this will be like 2010 plus two will be 2010. 
And this 2002 and 2010 is something that I've  
20:33 - picked up randomly, just for the sake of example. 
Okay, so now once again, what if I want to print  
20:39 - the value at this particular address, so I'm 
printing two more lines here now I'm printing  
20:43 - that value at address P is and I'll print star 
p, which gives us the value at that address.  
20:49 - And we will print another line that will say that 
value at address p plus one is and there should  
20:55 - be star p plus one, we put the star operator in 
front of the address Okay. So now what will be the  
21:02 - output, okay, so, the output is that address P is 
some address and value at address P is 10, which  
21:07 - is alright, because we had stored the address 
of variable a in P. Now, next time the size  
21:13 - of integer is four bytes, and p plus one is four 
more than that recipe. and the value at address p  
21:19 - plus one is some integer value that I do not 
know about. In fact, this has some garbage value,  
21:24 - because because we do not really have an integer 
allocated to this particular memory address.  
21:30 - And this is one dangerous thing about C using 
pointer arithmetic using pointer manipulation,  
21:35 - you can reach to any address. And sometimes 
these kinds of operations can bring some unwanted  
21:41 - behavior to your program. I recommend trying 
these things out these snippet of code with  
21:46 - other data types like character or float, and the 
result the results will be similar. So this was  
21:53 - some playing around with pointers. And in 
the coming lessons, we will talk more about  
21:58 - pointers. And we will talk about pointers in 
the context of arrays. So thanks for watching.  
22:06 - So far, in our previous lessons, we have 
seen how to work with pointer variables.  
22:12 - So we pretty much understand the basics. In 
this lesson, we will write some more code  
22:17 - using pointers. And we will look through some 
of these concepts. in more detail using some  
22:23 - examples. The first thing that I want to point 
out is that pointer variables are strongly typed.  
22:29 - What it means is that you need a pointer variable 
of a particular type to store the address of a  
22:35 - particular type of variable. So int star or a 
pointer to integer will be needed to store the  
22:40 - address of an integer character pointer will 
be needed to store that does have a character.  
22:45 - And similarly, if we have a user defined 
structure or class, then we need a pointer  
22:51 - of that particular type only. But why do we 
need these strong types? Isn't it that the  
22:56 - pointer variables just store the address of the 
variable? So why couldn't we have just one type?  
23:02 - That will be some generic type to store the 
address of all kinds of variables? And the answer  
23:08 - is that we do not use the pointer variables only 
to store memory addresses. But we also use them  
23:14 - to dereference these addresses so that we can 
access and modify the values in these addresses.  
23:22 - Now, as we know, data types have different sizes, 
like in a typical modern day compiler and integer,  
23:29 - it's stored in four bytes. A character 
variable is stored in one bite of float  
23:37 - is again stored in four bytes. And these variables 
differ not only in their sizes, they also differ  
23:43 - in how we store information in whatever bytes are 
available for these variables or data types. Let's  
23:51 - say we have an integer a and its value is 1025. 
And this is how it is laid out in the memory each  
23:59 - each bracket here is one byte. So let's say this 
particular byte which is the least significant  
24:04 - byte is byte zero, and then we go on like bite 
one, bite two and by three. Now we also know that  
24:13 - each byte in the memory is addressable. Let's say 
the address of bytes zero is 200. Now these four  
24:21 - bytes need to be contiguous let's say the address 
of byte to byte one is 201. And then we go on like  
24:27 - 202 and 203. When an integer is represented in the 
memory is stored in the memory the leftmost bit  
24:36 - stores the information that whether this integer 
is positive or negative, so this is also called  
24:42 - signed bit, signed bit and rest 31 
bits are used to store the value.  
24:49 - So if you see we have a one at right most 
bet with place value two to the power zero  
24:56 - and at this particular bit with place value to to 
the About 10. So the overall value that we have in  
25:03 - binary here is one zero to five in decimal. 
Now, what if I declare a pointer to integer  
25:11 - P and store the address of A in p 
by using the ampersand operator,  
25:17 - what will happen if I print the value of p, the 
value of p or the address stored in p will be 200,  
25:23 - the address of bytes zero. So we're kind of saying 
that we have the address of an integer variable  
25:30 - starting at address 200. If we dereference 
this address and try to print asterik P,  
25:36 - we want to know the value at this particular 
address, then the machine sees that okay,  
25:40 - P is a pointer to integer, so we need to 
look at four bytes starting address 200.  
25:48 - And then the machine knows that how to extract 
extract the value of an integer data type.  
25:54 - So it really it retrieves the value one 
zero to five out of this four bytes. Now,  
26:01 - if p was a character pointer, then while 
dereferencing, the machine would have looked  
26:05 - at only one byte because a character variable 
is only one byte. If P was appointed to float,  
26:13 - then although float is also stored in four bytes, 
but the way information is written for float  
26:19 - in these four bytes is different from the way 
information is returned for an integer datatype.  
26:24 - So the value printed would have been 
something else. Let's go write some of  
26:28 - this in a real program and see what happens. In 
my C program, I will first declare an integer A  
26:36 - equal to 1025. And now I'll declare a pointer 
to integer P. And then I'll store the address of  
26:44 - A in p by using the ampersand operator. Now I'll 
write a print statement like this size of integer  
26:52 - is, and we have a function size of NC, which gives 
us the size of a particular datatype in bytes.  
26:59 - And now I'll write a print statement like this 
address is equal to P and value is equal to  
27:07 - asterik p with dereference p to bring the value. 
Now let us see what is the output of this program.  
27:14 - No points for guessing this is pretty 
straightforward. The size of integer  
27:18 - is four bytes, the address that we are showing 
here is some address and the value is 1025.  
27:25 - Okay, now I'll do some trick here, I'll declare 
a character pointer let's say the name of the  
27:30 - variable is P zero. Now I'll try to put the same 
address as we have in P into P zero by writing  
27:39 - a statement like this. But this will give us a 
compilation error because p zero is a pointer to  
27:44 - character and p is a pointer to integer. So what 
we will do here is we'll typecast p to character  
27:52 - pointer and then assign the value. And now I'll 
write two more print statements. First is size of  
27:59 - character is these many bytes and use the method 
size of again and the second is the address is  
28:06 - P zero and the value at addresses asterik p zero. 
So we dereference we try to dereference p zero now  
28:13 - and let us see what's the output now, the first 
line of output a size of integer is four bytes  
28:19 - address because we are running the program fresh 
this address will not be the previous address that  
28:24 - was from the previous run this will be a different 
address by dereferencing the integer pointer we  
28:30 - are getting the value 1025. Now the next line 
of output a size of character is one byte  
28:35 - addresses 5373032 which is the same address as 
we have in the second line, but the value of this  
28:42 - time is one. Now why is this value one once 
again if we write 1025 in binary using 32 bits,  
28:51 - then this will be the representation. When 
we do this typecasting here trying to store  
28:57 - the address of P in p zero, then the address 
of this particular byte the rightmost byte  
29:02 - is stored in p zero. But when we dereference p 
zero because p zero is a pointer to character  
29:08 - the machine says that hey, this is a pointer to 
a character and the character is only one byte.  
29:13 - So I look at only one byte to see the value. 
And if you see this particular byte in binary  
29:20 - is one and that's why this output here is one. 
Okay, I'll write two more print statements now.  
29:28 - One to print the address p plus one and the 
value at address p plus one. Now as we know  
29:34 - we can add or subtract in an integer constant 
from a pointer variable. This is allowed in fact  
29:42 - the only pointer arithmetic that is allowed is 
adding or subtracting some constant integer value  
29:47 - to the pointer. p plus one will take 
us to the address of the next integer.  
29:52 - So it will skip four bytes and take us four bytes 
ahead. Let's say we also want to print p zero plus  
29:58 - one and the value at V zero plus one. Okay now 
let's see the output of this particular program,  
30:04 - the address of a this time is 4456036 that's 
what is allocated for a in this particular run  
30:12 - the value is 1025 p plus one is 4456040 if you 
see this is four bytes more than the address of A,  
30:21 - because size of integer is four bytes and 
p is a pointer to integer So, incrementing  
30:27 - p takes us four bytes forward and this value is 
some garbage value because we have not filled  
30:32 - anything in this particular address. So, there is 
some garbage in the memory which we are picking up  
30:38 - now, the address in PS row is also 4456036 
which is the address of the first byte the least  
30:45 - significant byte of a the value is one now, P zero 
plus one is 4456037 here we have a value which is  
30:54 - one byte more and this is because character is 
stored in one bytes. Now, the value here is four  
31:00 - if you see p zero plus one will take us to this 
particular byte the address of this particular  
31:05 - byte and this particular byte in binary is four 
this was to show you how things happen in memory  
31:13 - when we dereference a pointer variable by using 
the Asterix operator and also what happens when  
31:19 - we perform pointer arithmetic with a particular 
pointer type. This typecasting of pointer variable  
31:26 - from one to another also has some use cases we 
will discuss them later. Now, we will discuss  
31:32 - one pointer type which is generic pointer type 
it does not correspond to a particular data type  
31:38 - and this pointer type is called void pointer 
and we declared this particular pointer type  
31:44 - by using the keyword void and using an Asterix 
sign in front of the variable name okay now,  
31:51 - we can write something like p zero is equal to p 
we do not need an explicit typecasting here like  
31:59 - this, the statement p zero is equal to P is valid 
and this will not give you a compilation error  
32:05 - and because this particular pointer type 
is not mapped to a particular data type,  
32:10 - we cannot dereference this particular pointer 
variable. So, if you try to print star  
32:15 - P naught or astrix p not this will give you 
an error we are getting a compilation error,  
32:23 - we can only print the address. And as we can 
see here the address is same as the address of  
32:28 - A and if we perform arithmetic, if we try to do 
something like p zero plus one access something  
32:35 - like p zero plus one, this is also not possible 
this will also give you a compilation error,  
32:41 - we will come back to the 
use cases of wide pointers  
32:44 - in forthcoming lessons. Let's for now know 
that there is something called void pointers.  
32:51 - So this was diving deep into pointer types, 
typecasting and pointer arithmetic, we will have  
32:58 - a lot of fun with pointers in the coming lessons. 
So thanks for watching. In our lessons so far, we  
33:05 - have seen how we can work with pointers in some of 
the basic scenarios. But there are some scenarios  
33:12 - where pointers can be really puzzling. And once 
that scenario is when we want to use pointers to  
33:19 - pointers. So in this lesson, we are going to see 
how we can use a pointer to pointer let us assume  
33:27 - that this is a logical view of computer's memory 
and each partition here is one byte of memory Now,  
33:34 - we know that each byte of memory has an address, 
we have drawn the memory horizontally here,  
33:39 - let us assume that the address increases as we go 
from left to right. So if this byte is at address  
33:45 - 200 the next byte would be at address 201 and 
the next byte would be at address 202 and so on.  
33:53 - Now let's say in my program, I have 
declared an integer variable named x  
34:00 - and maybe I have initialized it as five and now 
when the program will run some amount of memory  
34:08 - will be allocated for this variable x. In a 
typical architecture in a typical compiler  
34:14 - integer is stored in four bytes, so four byte 
will be allocated for x. So let's say these  
34:21 - four bytes at address 225. This block of four 
bytes starting address 225 is allocated for x.  
34:29 - And the values stored in this block of four bytes 
for x is five. Now the next thing that I want to  
34:37 - do is I want to declare a pointer variable that 
will store the address of x. Now to store the  
34:44 - address of an integer we will have to declare a 
pointer to integer something like this, we need  
34:50 - to put an asterisk sign in front of the variable 
name. Now, what will happen is that some amount  
34:55 - of memory will be reserved for this variable p in 
a typical All architecture pointer is also stored  
35:02 - in four bytes. So let's say we get this block of 
four bytes at address 215 for P. And now, I want  
35:10 - to write a statement like this. So I want to fill 
in the address of x in P. And that's how p points  
35:17 - to x ampersand operator gives us the address 
of a variable. Now one important thing here,  
35:24 - we are able to store the address of x in p because 
P is of type pointer to integer, if p was of type  
35:33 - pointer to character, or pointer to some other 
variable. And this statement, p equal ampersand  
35:39 - X would not have been valid. So if I have to write 
down the types of these two variables, then x is  
35:45 - an integer, and p is a pointer to integer. Or I 
can also say that that P is int star, int asterik.  
35:54 - And y pointer variables are strongly typed. Why 
do we need a pointer to integer to reference  
36:00 - or store the address of an integer? It is because 
we don't just store the address of a variable in a  
36:06 - pointer variable. We also use the pointer variable 
to dereference that address dress and write some  
36:14 - value there. So if I write a statement like this, 
this value here at address 225. And this x is  
36:21 - now modified. Now can I create a pointer to this 
variable p, which itself is a pointer to integer?  
36:29 - Well, yes, we actually we can do so. So let's 
say we want to create a variable named queue,  
36:35 - that will store the address of P. Now what 
will be the type of this variable, we need  
36:40 - a pointer of a particular type to store the 
address of a particular type of variable.  
36:45 - So to store a pointer to integer, we will 
have to say that, that we want a pointer  
36:52 - to pointers, so we will put two Asterix sign 
in front of the variable name. And now this  
36:58 - variable q can store the address of P. So with 
this first line with this end asterik asterik q,  
37:08 - we created q let's say we created q at 205. And 
now we are seeing that q will store the address of  
37:16 - P. So q points to P and the type of Q is int 
asterik asterik with to be put to Asterix.  
37:27 - simple way to read this is that the type 
of variable x is an integer. So to store  
37:32 - the address of x we will need a pointer of type 
int star. So we will put one star to say that  
37:40 - this is a pointer to that particular type. 
And to store the address of p we will need  
37:45 - a pointer to int star so we will put one extra 
star to say that this is a pointer to int star.  
37:52 - And we can go on like this. Let's say we want 
to declare a pointer to pointer to pointer so  
37:58 - int asterik asticus pointer to pointer and 
we will put one more asterik or we can put  
38:03 - these three asterik immediately after this 
keyword end. Or we can put it immediately  
38:08 - before the variable name like we have done in 
the case of Q here. Let's say we define r as int  
38:14 - star star star. So let's say R gets this address 
to 13 the memory now are is of type int asterik  
38:24 - astrick Asterix so it can store the address of 
int asterik asterik. So, it cannot store the  
38:30 - address of X or P all the statements something 
like r is equal to ampersand Q will be valid.  
38:38 - Now, I have translated my previous rough code 
into a working C program. Now let us assume that  
38:45 - this program is working as per this memory 
sketch that we are showing in the right  
38:51 - now I will write some print statements and you 
need to get the output. So basically you have  
38:57 - to assume that these variables x p, q and r are 
allocated these addresses what we are showing here  
39:05 - in the right. So the first print statement that 
I'm going to write is I want to print as strict p  
39:12 - and this one should be simple for you asterik 
p would be value stored at address in p so this  
39:18 - will be six. Now the next statement 
that I want to print is asterik q.  
39:24 - So astrick q will be a value at address stored 
in Q address stored in variable Q is 215. So  
39:32 - this is nothing but the value of p so this will be 
25. And now I want to print asterik astrick q so I  
39:41 - want to do dereferencing twice. First I want to go 
to Astra q Astra Q is this address 225 and now I  
39:50 - want to look at the value at address 225. So this 
one will be six we could have avoided writing this  
39:58 - paranthesis here We could have said Astrid, 
gastric que only and that would have also,  
40:05 - that would have meant the same. But it's a good 
practice if we are using this asterik operator  
40:10 - to use paranthesis wherever we can do it because 
sometimes, when we are also using other operators,  
40:18 - we are not sure about the proceedings, 
and we want to avoid unwanted behaviors.  
40:25 - Now, what about these two print statements asterik 
asterik R and Astra gastric asterik r asterik  
40:32 - r means value in Q which will be 215. And then 
further, one more dereferencing will take us to  
40:39 - value in p which is 225. And one more 
dereferencing will take us to value in  
40:45 - x which will be six. If you see this is really 
interesting. From our we are using one asterik  
40:52 - operator and we are able to go to Q then we are 
using das trick operator twice and we reach P  
40:58 - and then we are using the astrick operator thrice 
and we reach x, let's make some more changes in  
41:04 - this code and run this in a real compiler. So what 
I'll do here is I'll write a statement like this.  
41:13 - And then after this statement, I'll print the 
value in x. If you run this now, as you can see,  
41:21 - asterik p astrochemistry q and astrochemistry 
gastric are all these three values are six,  
41:27 - the address will not be same as we had shown in 
the example for obvious reasons. And as you can  
41:34 - see, we are able to modify x by doing this 
chain of dereferencing using this variable  
41:41 - r if we would write something like astrochemistry 
Q is equal to let's say something like this.  
41:52 - Now asterik P is also referencing x and 
astrochemistry Q is also dereferencing x sorry,  
41:59 - we are dereferencing here. So any guesses what 
will be the output of this last print statement?  
42:05 - Well, if you see x is incremented by two 
here. So this was pointed to pointer,  
42:10 - I recommend that you write some of this code 
yourself and play a little bit in the coming  
42:16 - lessons we will use pointer to pointer in some 
real problems scenarios. So thanks for watching.  
42:24 - In our previous lessons, we define pointer 
variables. And we also saw how to operate  
42:30 - upon pointer variables how to work with pointer 
variables in C or c++ program. But we did not  
42:37 - really talk about the real use cases of pointer 
variables in watch scenarios we may want to  
42:43 - use pointer variables. So, in this lesson, we 
will talk about one of the use cases of pointer  
42:48 - variables and the use cases using them using 
pointers as function arguments. And we also termed  
42:56 - this as call by reference. So, let's discuss 
a scenario all Bert is a beginner programmer,  
43:04 - and he has recently learned about the concept 
user defined functions. Now he tries to apply  
43:11 - this concept and he writes a simple C 
program like this, what he is trying to  
43:17 - achieve here is that he has an integer variable 
declared and initialized in the main method  
43:25 - and he wants to increment the value in this 
variable by one. So, instead of writing  
43:29 - something like a plus plus or a equal to a plus 
one, instead of writing a statement like this,  
43:36 - he writes a function increment that will take an 
integer a as argument and inside this function, he  
43:43 - is writing a statement like a is equal to a plus 
one he calls this function increment from the main  
43:49 - method passing a as argument and then he prints 
the value of a now what he is expecting here  
43:57 - is that the value of a will be incremented to 
11 and hence the print statement will print a  
44:04 - equal leaven, but when he runs the program, the 
output of the print statement is a equal 10. Now,  
44:11 - Albert does not understand why this is happening, 
he has declared a variable a and then he has  
44:17 - initialized this variable to 10 and then he is 
passing the same A to the function increment  
44:23 - and the same a is being being incremented by one 
in this function. So why the value of a being  
44:30 - printed is not leaven. Why is it 10 now, 
what Albert does not understand well,  
44:37 - or what he probably forgot, is that whenever 
we declare a variable inside a function,  
44:44 - then we call that variable a local variable, 
because as such, just using the variable name,  
44:50 - we can access that variable only inside the same 
function in which we have declared the variable.  
44:56 - So these two a this a in the function 
increment and this a In the function main,  
45:01 - are actually not the same a, the A in 
the function increment is another a,  
45:06 - when main calls the method increment and passes 
this a as argument to the function, then only the  
45:15 - value of a is copied to this another A, which is 
another variable local to the increment function.  
45:22 - So what I'll do is I'll do couple of modifications 
in this code to show you a better picture.  
45:28 - I will write two print statements in 
this code. First print statement in the  
45:32 - increment method something like this address 
of variable a in increment is and as we know,  
45:41 - if we put ampersand operator in front of the 
variable name, then we get the address of that  
45:46 - variable. And I'll comment out this print and I'll 
write one more print in the main method like this.  
45:55 - And here I print that address of variable a in 
Maine is ampersand a. Let us now run this and see  
46:01 - what happens. Let me also put an end of line after 
we print the statement. And the output is address  
46:10 - of variable a in increment method is printed as 
4454460. And in Maine, it is equal to 4454660.  
46:22 - This two looks similar, but they're not the same. 
One is having 4460 and then and another time 4660.  
46:29 - What the values are is not important, what 
the addresses are is not important. What's  
46:34 - important is that these addresses are different. 
If the A in main method and the A increment method  
46:41 - was same, these two addresses would have 
been same. To understand this even better,  
46:47 - we will try to understand how things happen in 
computer's memory when a program executes when  
46:54 - a program or an application is started, then the 
computer sets aside the machine sets aside or  
47:00 - reserves some amount of memory for the execution 
of this program. The memory that is set aside  
47:07 - for the application is divided into is typically 
divided into these four parts that we are showing  
47:14 - here one part of memory is allocated to store 
the various instructions in the program, the  
47:21 - computer needs to keep all these instructions in 
the memory these instructions that we have in the  
47:25 - program like increment or declare these variables 
all these sequential instructions, one part of the  
47:31 - memory is one part of the allocated memory is for 
static or global variables. If we do not declare  
47:38 - a variable inside a function in c++ or C then 
it is a global variable. Now global variables  
47:46 - can be accessed and modified anywhere in the 
program unlike local variables, which can be  
47:53 - accessed and modified within a particular 
function or within a particular code block.  
47:58 - Now, the third part of the applications memory 
is called as stack and this is really important,  
48:06 - this is where all the local variables go and we 
will mostly be talking about stack in this lesson.  
48:13 - And the fourth part the fourth part is heap. And 
we will come to this later in in our forthcoming  
48:20 - lessons have these four segments of the allocated 
memory the text segment, the global variable  
48:28 - segment and the stack segment, these three are 
fixed and they are decided when the program  
48:34 - starts executing the application however, can keep 
asking for more memory for hits its heap segment  
48:41 - during its execution only. We will cover all of 
these things in detail in our forthcoming lessons  
48:48 - please do not get scared by these terms. 
Let us now see what happens when a program  
48:54 - executes. Let us say this is our computer's 
overall memory, the RAM and as we know each byte  
49:01 - in the memory is addressable. So, let's say the 
memory allocated for our program is from address  
49:08 - 200 to 800. And these are the various segments of 
our applications memory and have this let's say  
49:16 - address 300 to 600 is allocated for stack. 
Now there is more memory of course in the ram  
49:23 - after address 800 and before address 200 
Okay. So from 200 to 800. This part of  
49:29 - the memory is assigned for our program, let's 
say this C program that we have in the left.  
49:35 - Now, when a function is invoked, like when the 
program starts the main method is initially  
49:41 - invoked, all the information about the method 
all the information about the method call  
49:47 - like its parameters, all the local variables, 
the calling function to which it should return.  
49:54 - The current instruction at which it is executing. 
All this information is stored in the stack. So,  
50:00 - we will take out from the stack some part for the 
main method and create a unit which we call stack  
50:08 - frame, each function will have a stack frame. Now 
we have a variable a now memory is allocated for a  
50:16 - from this stack frame and the value of a is 10. 
Now, the main method calls increment function,  
50:23 - what happens when main method calls increment 
is that the machine says that hey, I will stop  
50:28 - your execution for some time, I will stop at this 
particular instruction let me go ahead and finish  
50:34 - this method increment. And then I'll come back 
to the main method once I'm done with increment,  
50:40 - now another stack frame is allocated for the 
increment method and the parameters in increment  
50:45 - method like we have a parameter a So, fresh local 
variables are created corresponding to these  
50:51 - parameters and whatever values have been passed 
are copied to these variables these parameters  
50:57 - Now, when we say a is equal to a plus one 
here in this statement, then what happens that  
51:03 - this a which is local to the increment 
function in this particular stack frame,  
51:07 - this is incremented we cannot access a variable it 
outside it stack frame and now increment finishes  
51:16 - when increment finishes the control returns to 
the main method and what the machine does is  
51:21 - it clears the stack frame that was located for 
increment and main method resumes again So, main  
51:27 - method was paused at this particular instruction 
increment. So, lifetime of a local variable is  
51:33 - till the time the function is executing. Now, 
the next statement in main method is a call to  
51:39 - the function print f print F is not a user 
defined function it is a library function  
51:44 - the state of execution of main method is 
kind of paused and printf is executing now,  
51:49 - we often call this particular structure call stack 
or function call stack whatever function is at  
51:56 - the top of the stack is executing and remember 
this stack is fixed in size. So, if you have a  
52:02 - scenario where one function keeps calling another 
function in dead definitly like in the case of  
52:08 - an infinite recursion, then the memory of this 
stack will overflow and our program will crash  
52:14 - okay but that is not relevant for this scenario. 
So, now, you must be getting a picture of what  
52:19 - happens when one function calls another function. 
This a is in the stack frame of the main method.  
52:25 - Main is our calling function and increment is 
our call function. When we call a function in  
52:32 - the calling function, the argument is also known 
as actual argument and in the call function,  
52:38 - the argument is known as formal argument. All 
that happens is the actual argument is actually  
52:44 - mapped to a formal argument. So, when this 
function called happens a is mapped to a as an  
52:51 - actual argument is mapped to another A, which is a 
formal argument instead of a if we were having an  
52:57 - x here, so, we would have written something like 
in x as is the argument and x is x plus one then  
53:04 - a would have been mapped to x. So, the value of 
a will be copied to the variable x. Now, when we  
53:10 - make such a function call, where we basically have 
one variable being mapped to another variable that  
53:17 - value in one variable copied to another variable 
then such a function call is also called as  
53:23 - call by value. So, this is what Albert was doing, 
making a call by value. And that's why he was not  
53:31 - able to get the desired result. But can we get 
the result that Albert wanted to have all but  
53:37 - wanted to use this variable A, which is local to 
the main method inside the increment function?  
53:44 - Can we really do so? Well yes, we can do so, 
if we use pointers as function arguments. Let  
53:51 - us now look at this code. And I'm drawing only the 
stack here so that I'm able to show the simulation  
53:57 - of program execution neatly. Now, what we are 
doing here is that we do not have an argument  
54:03 - which is integer in this function increment we 
have an argument which is pointed to integer  
54:09 - and pointer to integer as we know we will it will 
store the address of an integer. So now what we  
54:14 - are doing is that in the increment function, we 
are passing the address of a so when the program  
54:20 - will start executing the main method will be 
invoked First, let's say this is the stack frame  
54:25 - of the main method. Let's say 300 to 350. This 
addresses the stack frame of main method and there  
54:33 - would be a local variable a. In this main method, 
let's say the address at which a is stored is 308.  
54:42 - This may not be in proportion, but still 
let's say this is how it is stored.  
54:46 - Now when main method calls increment, then a 
local variable corresponding to the parameter P is  
54:52 - created. And this is a pointer to integer and the 
value that is passed to this particular function.  
54:58 - The value that gets stored In this particular 
Sorry, it's not a function, it's a variable  
55:03 - the value that gets copied or stored in this 
particular variable would be 308 the address of A.  
55:11 - So P is pointing to a. Now in this statement 
here when we say asterik P, we dereference  
55:17 - this address, so we are seeing here that asterik 
P is value at address stored in p. So, we say that  
55:25 - increment the value stored at address p by one, 
the value stored at address 308 gets incremented  
55:30 - by one, so, a is now 11. So, now when increment 
finishes, and we come back to the main method,  
55:39 - and the next line gets executed, 
which is the print statement,  
55:43 - then A is now 11. If you run this program, 
then what gets printed is a equal lemon,  
55:50 - such a function call in which instead of passing 
the value of a variable, we passed the address of  
55:55 - the variables so that we have a reference to the 
variable and we can dereference it and perform  
56:01 - some operations is called call by reference. 
So, if we use pointers as functions arguments,  
56:08 - then we are using call by reference call by 
reference can save us a lot of memory because  
56:13 - instead of creating a copy of a large and complex 
data type, if we just use a reference to it,  
56:20 - and using a reference will also cost us 
some memory but very small amount of memory,  
56:24 - then, we are saved from creating a new copy of a 
complex data type. In the coming lessons, we will  
56:30 - see more of the layout of applications memory, 
and what are things we can do using pointers. So,  
56:37 - thanks for watching the concept of pointers and 
arrays in C or c++ go together, there is a very  
56:46 - strong relationship between these two concepts. 
And in this lesson, we will be discussing this  
56:51 - relationship. When we declare an array, let's 
say we declare an integer array A of size five,  
57:00 - then we create five integer variables named is 
zero, a one a two, a three and a four. Now these  
57:09 - five integers will be stored in the memory as a 
block of five consecutive integers something like  
57:15 - this, what we are showing here in the right, 
if a zero or the first element in the array  
57:20 - is stored at address, let's say address 200. And 
in a typical compiler, modern day compiler integer  
57:27 - is stored in four bytes. So a one will be four 
bytes ahead of a zero at 204. And a two will be  
57:34 - at 208, a three will be at 212. A four will be 
at 216, the overall size of the array would be  
57:42 - 20 bytes, and these 20 bytes will be one 
consecutive block, we are only showing  
57:49 - the section of the memory in which a is stored. 
Sometimes we also show the memory horizontally,  
57:55 - something like this, from left to right, we 
increase the address but these two representations  
58:01 - are just for the sake of understanding, 
let's use the horizontal representation of  
58:05 - the memory. And this time, I'll show this memory 
a little more extending towards the right so that  
58:11 - I can accommodate a couple of more variables. 
Let's say apart from this integer array, I have  
58:18 - an integer variable x and its value is five. And 
let's say x is located at address 300. Now, let's  
58:28 - say I have a pointer to integer P and P, I store 
the address of x if we print p then the value  
58:39 - in p would be 300. So, this statement will print 
300 and if we dereference P and try to print the  
58:48 - address stored in Try to print the values stored 
in this location p then the value would be five  
58:58 - this is fine. But we also know that 
we can do an operation something like  
59:02 - increment or decrement a pointer variable 
by a constant. So we can do something like  
59:07 - p equal p plus one and this will take 
us to the address of the next integer  
59:12 - and because integer is four bytes, so now p would 
be 304. So if I want to print p now, then the  
59:20 - output should be 304. But if we try to dereference 
p now and try to print Asterix p then we do not  
59:28 - know the value at this address. So we cannot say 
what will be printed. It's like we know that Mr.  
59:34 - X lives at address 300 but we do not know who is 
his neighbor who lives at address through 304.  
59:42 - But for this integer array A, let us say I'm 
writing the same integer array in right here,  
59:48 - which is located at address 200. If I declare a 
pointer to integer P and store the address of the  
59:57 - first element by putting an ampersand operator 
In front of a zero, then printing p would give  
60:04 - us in this scenario, the output 200 and printing 
astrak p would give us. But before that, let's  
60:13 - say we have these values in the array, 
let's fill up some values in the array.  
60:19 - So Asterix p would be two. Now if I want to 
print p plus one, then the address would be  
60:30 - 204. And if I dereference p plus one, and try 
to print this value, then it will be four.  
60:37 - And similarly if we wanted the third element 
in the array, we could do a p plus two here.  
60:44 - So using pointer arithmetic makes sense in the 
case of pointers, because in the case of arrays,  
60:50 - because we know what is in the adjacent location, 
there is one more property of the array,  
60:56 - if we just use the name of the array A, then a 
gives us the pointer to the first element in the  
61:02 - array. So we can write a statement like p is equal 
to a, in fact, we do not even need to take this  
61:08 - address in another pointer variable. If we simply 
print a then this gives us nothing but the address  
61:16 - of the first element in the array. And if we want 
to dereference this and try to print asterik A,  
61:24 - then this will give us the value. So if we want 
to perform something like we want to print a plus  
61:31 - one, then this will give us the address to 04 and 
asterik, a plus one will give us the address of  
61:38 - the second element in the array value of the 
second element in the array. For an element  
61:44 - in the array. at index i we can retrieve the 
address of this particular element in the memory  
61:52 - using either ampersand AI, or simply a plus i 
and these two will give us the address of AI and  
62:04 - the value of AI can be retrieved using either we 
simply use AI, or we can also use Asterix a plus i  
62:14 - an Asterix a plus I will also give us the value. 
Now this is an important concept, we can write  
62:20 - ampersand AI or a plus i for each other and they 
mean the same. And we can write a AI or Asterix a  
62:28 - plus AI for each other and they mean the same. The 
address of the first element in the array can also  
62:35 - be called the base address. And a simply using 
the variable name a gives us the base address  
62:43 - of the array. Let us now see some code examples 
and try to solidify our concepts further.  
62:51 - In my program, let's say we have an integer 
array A. Now as I said, if we simply print  
62:59 - a then this should give us the address 
of the first element in the array.  
63:04 - And we can also get the address of the first 
element in the array by using ampersand operator  
63:08 - in front of a zero. If I simply print a zero 
it will print the first element in the array  
63:15 - and we can also print the first element in the 
array by using Asterix operator in front of  
63:23 - the variable name a. Let us now run this and see 
what happens. And I also need to put an end line  
63:30 - after each of these print statements. Okay, so the 
output is that the first two lines are the same,  
63:37 - they are giving us the address of the first 
element in the array and the second two lines  
63:42 - are giving us the value. In fact, if we run 
a loop like this from zero to index four,  
63:48 - then we can print address of the element 
at index i as ampersand AI or a plus i  
63:55 - and we can print the value of if element as a AI 
and Asterix a plus AI. Now, if we see the output  
64:03 - here, this is a fresh run a new run so the address 
or locations will change. But if we see the  
64:10 - address printed in two lines for a zero is same 
the value is same again for a one addresses same  
64:17 - four bytes I had off the previous address and the 
value is as expected and we can go on like this.  
64:25 - Now one more thing even though just using 
the variable name a returns us pointer to the  
64:32 - base address or the address of the first 
element and we can equate the variable name  
64:38 - a against some pointer variable like this. We 
cannot do something like a plus plus increment the  
64:44 - value of a this will give us compilation error. We 
can do something like p plus plus once we assign  
64:50 - a to some pointer variable other pointer variable 
but incrementing a itself would be invalid.  
64:59 - So this As far as how arrays are stored in memory 
and how the addresses can be manipulated, and how  
65:06 - we can access the values using pointers, in the 
next lessons in the coming lessons, we will talk  
65:13 - about character arrays. And we will talk about 
passing arrays as function arguments. So thanks  
65:20 - for watching. In this lesson, we will be talking 
about one more scenario in which the concept of  
65:26 - arrays and pointers go together. And this scenario 
is when you pass an array as function argument,  
65:35 - let us see a code example where we pass array 
as function argument and try to analyze it,  
65:42 - I will write a simple C program in which I will 
write a function that will give me the sum of  
65:49 - all the elements in an integer array, this 
function will take an integer array as argument,  
65:56 - this is one of the ways to pass an integer array, 
an array in general as argument, this would be  
66:01 - the data type and this would be the name of the 
array. And in the main method, we have declared  
66:08 - and initialized an array named a. Now, in the main 
method, we will call this function sum of elements  
66:14 - and pass it the array as argument. And of course, 
we need to write the body of this function, sum  
66:21 - of elements, I will declare two variables I and 
another variable sum and initialize it to zero,  
66:28 - I will be used to run a loop. So, we will 
iterate through all the elements in the  
66:33 - array that is passed as argument. But wait a 
minute, we do not know the size of this array,  
66:40 - is there some way to know the size of the 
array. One of the ways to find out the size  
66:46 - of the array and by the size of the array, we 
mean the number of elements in the array here  
66:50 - is to use the function size off. So if we write 
something like size of a here in the main method,  
66:58 - then this will give us the size of the array 
in bytes. array has five integers and in a  
67:04 - typical compiler, and I know for sure that in this 
compiler and integer is stored in four bytes, so  
67:09 - size of a will return 20. If we want to know the 
number of elements in the array, then we can do  
67:17 - something like divide the size of the size and 
bytes of the whole array by size of one integer.  
67:24 - So we will say size of a upon size of each integer 
and by the size of a zero would give us the  
67:31 - number of elements in the array. 
And I'll write this particular line  
67:36 - below this line the line where we are 
calling the function sum of elements.  
67:41 - Now, what we can do is we could either pass 
the size of the array as another argument.  
67:48 - So that would be cool. And then we can 
run the loop starting zero till index size  
67:55 - minus one and we keep on adding each 
element to this variable sum. And finally,  
68:03 - we return sum. And finally, we will write 
a print statement something like this,  
68:12 - to print the sum of all the elements in the array, 
let us now run this program and see what happens  
68:18 - the output on console is that the sum of elements 
is equal to 15 five plus four plus three plus two  
68:25 - plus one is 15. So, this is all right. Now, what I 
want to do is I want to modify this code a little  
68:32 - I do not want to pass the size as argument here, 
I want to calculate the size of the array inside  
68:38 - this function. So, we will not be passing 
this sizes argument here. So there will be  
68:44 - there will be just one argument the array. So 
we have this array as argument the array and we  
68:51 - calculate the size here as total size of the array 
in bytes upon the size of one integer in bytes.  
68:58 - Let us now run this program and see what 
happens. Oops, this seems to be some problem,  
69:04 - because the sum of elements that we have as output 
on console here is equal to one it should be 15.  
69:11 - And why is it so, explain this behavior, 
I will write two more print statements,  
69:17 - what is the function sum of elements where I will 
print the size of a and the size of a zero I will  
69:25 - be calling these two functions size off upon a and 
upon a zero respectively. And we will write one  
69:32 - more print statements in the main method. It will 
again be the same thing printing the size of a in  
69:36 - bytes and the size of a zero in bytes. Let us now 
see the output in the method sum of elements size  
69:43 - of A is equal to four bytes. size of a zero is 
equal to four bytes in the method main size of  
69:49 - phase equal to 20 bytes and the size of a zero 
again is four bytes. To understand this concept,  
69:56 - why the size of a is four by In the method sum of 
elements and it is equal to 20 bytes in the main  
70:04 - method, we need to dive deep into how compiler 
interprets an array as function argument. Once  
70:12 - again I will draw this familiar memory diagram, 
the memory assigned to an application or a program  
70:19 - is typically divided into these four parts, we 
have talked about this in our previous lessons  
70:24 - for the execution of function calls, we use 
stack section of the memory, this green rectangle  
70:31 - here is our stack. Now, when the program starts 
executing, first the main method is invoked. So  
70:38 - some amount of memory from the stack is allocated 
corresponding to the call of the main method  
70:45 - and this particular section or this particular 
part is also called the stack frame of a method  
70:52 - all the local variables reside within this 
stack frame. Now, here in main method, we have  
70:58 - two local variables one is the array and 
another local variable is integer total.  
71:05 - So, around 20 bytes if integer is four bytes, 
exactly 20 bytes, in fact, would be allocated  
71:13 - from this stack frame for the local variable a the 
array and four bytes for total the variable total  
71:22 - and there would be some more information 
in the stack frame. Now, when the program  
71:25 - execution reaches this particular line, 
where we make a call to sum of elements,  
71:30 - then the execution of main is paused and another 
stack frame is allocated to execute the function  
71:39 - sum of elements. We have talked about this 
call stack growth and function execution  
71:45 - a number of times in our previous lessons, okay, 
now, this is a local variable, this parameter is  
71:50 - a local variable to the function sum of elements 
it is not this a in the main method, what happens  
71:57 - when we make a function call is that the value of 
this particular local variable in the main method,  
72:03 - or we should rather say the value from 
the variable in the calling function is  
72:07 - copied to the variable in the call function. So 
ideally, we should have one more a local to the  
72:16 - function called sum of elements. and the value 
of a should be copied into this parameter A.  
72:25 - So we would have another array named a, taking 
20 bytes in the stack frame of some of elements,  
72:31 - and it would have the same value same 
elements as the array in the calling function  
72:38 - main. But actually, this doesn't happen, when 
compilers sees an array as function argument,  
72:47 - it does not copy the whole array, what it actually 
does it, it just creates a pointer variable by the  
72:56 - same name, instead of creating the whole array, 
it just creates a pointer to the data type of  
73:02 - the array. So in this case, it will be pointed to 
integer and the compiler just copies the address  
73:09 - of the first element in the array of the calling 
function. So, let's say the starting address  
73:16 - the address of the first element in this array, 
that belongs to the main method is 200. So,  
73:22 - in sum of elements, all that happens is a pointer 
to integer is created and the value in this  
73:28 - pointer to integer is 200. The compiler implicitly 
converts this int a to something like in Star a,  
73:39 - that is this a here in this particular format is 
not interpreted as an array, but it is interpreted  
73:45 - as pointer to integer. So whether you write int 
space variable name following these brackets, or  
73:53 - you write something like in Star space a, they're 
both the same. We have a term for this, instead  
74:01 - of copying the value of the variable, we are just 
copying and storing the address of the variable.  
74:07 - So, we make a call by reference here, arrays 
always are passed as a reference parameters.  
74:14 - And this makes a lot of sense, because arrays 
can be really large inside so it does not make  
74:20 - much sense to create a new copy of the array each 
time it is unnecessarily using a lot of memory.  
74:27 - So for arrays, there is no call by value 
there is always a call by reference. And  
74:32 - that's why this size of a here would give us four 
as output, because A is a pointer to integer here,  
74:40 - while here in the main method is an array. So this 
format of passing array as function argument where  
74:47 - we put these braces to tell that this is an array 
is actually interpreted something like this by the  
74:55 - compiler. You can put an asterisk sign here or you 
can put an Asterix sign here. It's the same thing.  
75:00 - It makes more sense to write it like this. 
So A is actually interpreted as a pointer to  
75:06 - integer. That's why when we pass array as function 
argument, there is no way to know the number of  
75:12 - elements in the array. By using a trick like this, 
we actually need to pass the size of the array.  
75:19 - So I'd rather move this size calculation 
in the main method and pass the size.  
75:26 - And when we run this program, now, we get 
the output as expected sum of elements is  
75:33 - 15. We should always keep in mind that a 
variable name which is used as an array  
75:40 - is different from a variable which is pointed 
to integer. Even though the compiler gives us  
75:45 - some privileges, like we can use the name of the 
array to get the pointer to the first element,  
75:52 - like in this function sum of elements, we could 
say something like to pass the first element,  
75:57 - we should, we could have said ampersand 
is zero, the address of the first element.  
76:02 - But if we just use a instead of using ampersand a 
zero, then that is allowed if A is an array. But  
76:10 - if a is an array, we cannot do something like 
incrementing or decrementing. It like pointer  
76:16 - variables. With pointer variables, 
we can do couple of other stuffs.  
76:21 - And if we have a pointer to the starting 
address of the array, we can pretty much use  
76:25 - it like a variable name for array because II II 
is interpreted as value at address a plus i. So  
76:34 - we need to keep these differences and similarities 
in mind, it's a little tricky. There is one more  
76:39 - thing because the array is passed by reference, 
we can modify the elements of the array in the  
76:47 - call function, and it would refer reflect in 
the calling function. So let's say instead of  
76:55 - calculating the sum total, we want to double 
all the elements, each individual element in the  
77:00 - array. So our code will go something like this, I 
want to say that AI is now twice API. And we will  
77:08 - not return an integer let's say the return type 
is void. And in the main method, I'll clear all  
77:14 - this stuff. And what I'll do is I'll simply run 
a loop to print all the elements in the array  
77:21 - Okay, let us now run this and see what happens. 
Oops, I forgot to call the function double  
77:27 - I must make a call before I print the 
elements Okay. Let us now run this.  
77:32 - If you see the elements in the array are modified 
each element is twice its previous value,  
77:40 - because this is called by reference the same copy 
of the array is modified using dereferencing.  
77:50 - So this was array as function arguments. An 
important use case of array as function argument  
77:58 - is when we work with strings in C strings 
in C are nothing but character arrays.  
78:06 - This concept really becomes important in the 
context of character arrays, we will be talking  
78:11 - about it in the coming lessons. So thanks for 
watching. In our lesson, so far, we have seen  
78:18 - how the concepts of arrays and pointers go 
together. Now in this lesson, we are going  
78:23 - to talk about character arrays, how we can 
work with character arrays using pointers.  
78:29 - When we talk about character arrays in C, 
we basically want to talk about strings.  
78:35 - Strings are group or set of characters, 
and real world data like names, phrases,  
78:42 - and sentences. All of these are strings to us. 
So these are some of the examples of strings.  
78:49 - Character arrays become all the more important 
because we use them to store strings, and then  
78:55 - perform a lot of operations on strings, like 
modifying a string, copying a string concatenating  
79:02 - two strings or finding out properties of strings 
like finding out the length of a string. To be  
79:08 - able to work with strings efficiently in C, there 
are a couple of things that we need to understand.  
79:14 - The first thing that we need to understand 
is how we store strings in character arrays.  
79:19 - To be able to store a string in a character 
array. The first requirement is that  
79:25 - the character array should be large enough to 
accommodate the string. And what is a large enough  
79:31 - character array. A large enough character array is 
a character array of size greater than or equal to  
79:38 - number of characters in the string 
plus one. So let's say if our string is  
79:45 - a name of four characters, like john, then 
the size of the array should be greater than  
79:51 - or equal to five. Now the obvious question would 
be why do we need space for one extra character?  
79:58 - Isn't it that if we layer, character array of size 
four, we can store all the characters in john j  
80:05 - will go at the zero at index, four will go at the 
one at index, H and n will go at second and third  
80:12 - index respectively. So I'm storing all the data, 
isn't it? Let's try to understand it this way.  
80:18 - Let's say we have a character array of size eight. 
Let's say this is a logical view of our array C,  
80:25 - and we want to store the string john, in this 
particular array, we have indices from zero to  
80:30 - seven, and this is an array of size eight. 
So we can store j at the zero at index o at  
80:35 - the one at index H, add to it index and n add 
the three utter index. So we have stored all  
80:41 - the characters of the string john in this array. 
But if you see we have not stored one information,  
80:48 - or we have not stored the information that this 
particular character, n is the last character in  
80:52 - the string, so the string ends at index three. So 
let's say if we pass this string to a function,  
80:59 - and that has to print the string john, or find out 
the length of the string that we have stored in  
81:04 - this array, then how would the function know that 
the string is only till index three, even though  
81:09 - we have not filled anything in these indices at 
four or five, six and seven, there would be some  
81:16 - garbage value there. So either we pass this 
extra information, or we do something else,  
81:21 - to store this information that this is the 
end of the string in the character array.  
81:26 - This is the used part of the string. And this is 
the unused part, we use a simple design at the end  
81:33 - of the string in the next position, we put a null 
character, and null character has asked by value  
81:39 - zero. And we can put a null character at position 
four in this example, something like this,  
81:46 - within single quotes, we put a forward slash 
and number zero, this is null character. All  
81:52 - the functions for string manipulation in C, expect 
that strings will be null terminated. So this is  
81:59 - a rule string in C has to be terminated by a null 
character. And that's why we need one extra space  
82:07 - to store this null character. Let us try to see 
some running code that will help us understand  
82:12 - this concept better. What I have done here is I 
have taken a character array of size four, and  
82:18 - I have filled in the characters, but I have not 
used any space to null terminated. And then I'm  
82:25 - using the printf function, this percentile, so it 
tells that I want to print a string and then I'm  
82:31 - passing this array C. Let us run this program and 
see what happens. As we can see, there are these  
82:38 - bunch of characters that are getting printed after 
john, this is happening because we have broken  
82:45 - the assumption for the printf function that my 
string that are a string will be null terminated.  
82:52 - So that's why this undefined behavior is coming. 
If we change the size of the character array to  
82:57 - five and put a null termination, something like 
this at fourth index, and then things will be  
83:04 - fine. Now even if we change the size of the array 
to 20 printf function will print till it finds  
83:11 - a null character. So it only prints on the 
first four characters in the array. And it's  
83:16 - not just the print function, there are a bunch 
of functions, we have this library string dot h,  
83:22 - that gives us a bunch of function for string 
manipulation. So all these functions assume  
83:27 - that the string will be null terminated. So this 
is one contract that we have to follow. Let's  
83:34 - say we want to use one function str le n string 
length. To find out this length of the string,  
83:41 - I'll print something like this, let's run this and 
see as you can see, the output is length is equal  
83:47 - to four even though the array is of size 20. So 
string length function also counts still it sees a  
83:54 - null character. In our program, instead of writing 
these characters individually at this positions,  
84:02 - we could have used string literals string literals 
are group of characters within double quotation  
84:10 - marks. So we could have written something like 
this. And this would have initialized C as  
84:16 - the string and the null termination for a string 
literal is implicit, it is always stored with a  
84:24 - null termination and memory. Remember, when we 
declare and initialize a character array like  
84:30 - this, this has to happen in one line, we cannot 
do something like we declare in one line and then  
84:35 - we go on and modify this in the next line this 
will be invalid. We could also avoid writing  
84:41 - this size here, and this would have been fine. 
In this case, the size of C will be five units,  
84:48 - five bytes where one byte stores one character. 
So it would be just enough to store the string  
84:55 - john. So if we try to print the size in bytes of 
C, using The size of function, then size in bytes  
85:03 - is five one character stored in one byte. So space 
has been allocated for five characters, but the  
85:08 - length is four, because the null character does 
not count in the length, if we write something  
85:14 - like c four is equal to this particular string 
literal with four characters, this will give us  
85:20 - compilation error, because the compiler will force 
this particular array to be of minimum size five,  
85:28 - there is one more syntax of initialization we can 
put all these characters as a comma separated list  
85:36 - within these braces, but in this case, 
the null termination will not be implicit,  
85:42 - we will have to do it explicitly. And the size 
of the array has to be greater than or equal  
85:47 - to the number of characters here, so it should be 
greater than or equal to five. Okay, so these are  
85:51 - some of the ways to initialize a character array. 
The next thing that we need to understand is,  
85:57 - arrays and pointers are different types that are 
used in similar manner. Now, what does it really  
86:03 - mean? Well, let's say we declare a character 
array, see one of size six, and initialize it  
86:08 - with this string literal. And let's say this is 
how it gets stored in the memory, or is stored  
86:14 - in one contiguous block of memory. So let's say 
the first character is at address 201 character  
86:19 - is of size one bytes, so the next character will 
be at address 201. And the next will be at 202,  
86:25 - and so on. Now c one is the variable name for this 
whole array. Now what I'll do is, I'll declare a  
86:32 - variable, which is a pointer to character, let's 
name this C two. So let's say we get this variable  
86:38 - c two somewhere in the memory, a pointer variable 
in a typical architecture is stored in four bytes.  
86:44 - So this variable will also have some address, 
let's say this variable is at address 400.  
86:48 - I'm just picking up these numbers for example 
sake, now, what we can do is we can write a  
86:53 - statement like this C two is equal to c one. 
Now even though c one is a character array is  
86:59 - a variable name for character array. And c two 
is a variable which is pointed to character,  
87:03 - this particular expression is valid, just using 
the name of the array actually returns the address  
87:10 - of the first element in the array. So what this 
expression, what this statement will do is,  
87:16 - it will fill in the address 200 and C two. So C 
two now points to the first element in the array.  
87:23 - Now, we can use this variable c two, which is a 
character pointer, or just like C one to read and  
87:30 - write into the array. So if I write something like 
print c two, I, let's say we want to print c Two,  
87:38 - one, then the output will be L. and we can even 
modify the array. Let's say we want to modify  
87:45 - the character at zero at index two A. So the 
string will be modified and will become this,  
87:53 - when we write C two I for any position I it is 
nothing but as strict c two plus i. So C two is  
88:00 - the base address, C two plus, I will take you 
to the address of the eighth element. So in this  
88:06 - case, let's say C two plus two will be 202. And 
if we put this asterik operator, we are basically  
88:12 - dereferencing and finding out the value, so these 
two syntaxes are alternate syntaxes. And even if  
88:18 - it is an array name, we can write on these two as 
substitutes for each other. So this was all the  
88:25 - similarity in how we actually use them use arrays 
and pointers to read and write. Let us now look at  
88:34 - the differences. We cannot modify an array with a 
statement like this, C two equals c one is valid,  
88:42 - but c one equals c two is not valid, it does 
not make sense, this will give you a compilation  
88:48 - error, we cannot even say C one is equal to c 
one plus one, we cannot increment or decrement.  
88:54 - This video we'll see what we can do it for C two, 
which is a pointer variable, we can say C two plus  
88:59 - plus so C two now points to the next element. 
With this statement here, all that will happen  
89:05 - is C two will become 201. So instead of pointing 
here, it's now pointing to this particular element  
89:12 - e to traverse an array, we run a loop and we 
use a local variable let's say I and increment  
89:18 - it in the loop if we have a pointer variable, 
we can just keep on incrementing the pointer  
89:22 - and we can traverse the list we can traverse the 
array, we will keep doing this C two plus plus.  
89:28 - So we must understand where we have an array and 
where we have a pointer and what we can do with  
89:32 - which one. Now, the next thing that we need to 
understand is that arrays are always passed to  
89:41 - functions by reference or when we pass arrays 
to functions, we only pass the base address  
89:47 - of the array in a pointer variable and we do not 
pass a whole copy of the array. The compiler does  
89:53 - not let you do do that. And we have talked 
about this in detail in our previous lesson.  
89:58 - Arrays as function arguments. Let us look through 
some code and try to understand this better.  
90:04 - In my code, I have declared a character array of 
size 20. And I have stored a string of length five  
90:11 - in this character array. The null termination 
is implicit if we are using string literal.  
90:17 - Now I want to print this string, but I do 
not want to use the library function print F,  
90:22 - I want to write my own function print, I want to 
pass this array to the function. And this function  
90:29 - should print the string part in a character 
array. The argument to the function we have  
90:35 - talked about this earlier can be something like 
this to say that we are receiving an array here,  
90:40 - but the compiler actually interprets this as 
this. So the compiler forces that only the address  
90:48 - of the character array or the address of any array 
be received as argument to the function, because  
90:55 - arrays are large in size, so it is inefficient to 
create a copy of the same array for each function.  
91:02 - Okay, so let's write the logic now. Now, this 
print function does not have any idea that this  
91:07 - particular array is of size 20, it only knows 
the base address. So what we can do is we can  
91:13 - have a variable I initialize it to zero and we can 
say something like this, while ci is not equal to  
91:22 - null character, we can print the character ci,  
91:27 - and then we will increment i. And when we find 
a null character, we can come out of this loop  
91:33 - and print an end of line. Once again, this print 
function does not know that this character arrays  
91:39 - of size 20, it only knows the base address. 
And that's why in the printf function,  
91:45 - when we were not null terminating an array, we 
were printing all the garbage value even after the  
91:50 - array was finished. Because until we get a null 
character, we do not know where to stop, and we  
91:56 - keep on going into unwanted memory locations. 
Now this code should work. Yes, this is fine.  
92:04 - In my code, here, I'm using percent and see 
here to say that we want to print character,  
92:09 - and see if we can also write as strict c plus II 
as substitute for ci. And that will also mean the  
92:16 - same. Sometimes you'll see this kind of syntax. As 
we talked earlier, both of these syntax as trixi  
92:23 - plus imci are valid, they are the same, there is 
one more thing in our code that we may do, we will  
92:29 - not choose to have this particular variable i, 
we could simply say that while Asterix c is not  
92:37 - equal to null, print, Asterix C and then increment 
c itself. And this code will also work on why this  
92:45 - code will work. I leave it as an exercise for you 
to think in the coming lessons, we will implement  
92:50 - more functions for string manipulation. This is it 
for now. Thanks for watching. In part one of our  
92:56 - lesson on character arrays and pointers, we saw 
how we can store strings in character arrays. And  
93:03 - we also saw how we can work with character arrays 
using pointers in some of the basic scenarios.  
93:09 - Whenever we are working with pointers, it's 
really important that we visualize how things are  
93:14 - happening in the memory. So, the first thing that 
we will do in this lesson is we will simulate the  
93:19 - program that we had written in the previous 
lesson to print the characters of a string  
93:25 - and see what goes where in the memory. And we will 
also look into the concept of string constants  
93:32 - and constant pointers. So, this is where 
we had left in our previous lesson,  
93:37 - we have written a function Print to print the 
characters in a string in the main method,  
93:43 - we have a character array of size 20, but we 
have stored a string of length five in it,  
93:49 - we have used a string literal, so null termination 
is implicit, we have talked about this earlier.  
93:56 - So, let us step through this code and see how it 
is working. Once again I have drawn this familiar  
94:02 - diagram the memory that is allocated for execution 
of a program is typically divided into these  
94:08 - four parts these four sections on one part of the 
memory stores the instructions in the program,  
94:14 - we call that the code segment or the text 
segment, one part one section stores the  
94:20 - global variables and stack is where all the 
information regarding function call execution and  
94:26 - all the local variables go whenever we are writing 
a program whenever we are executing a program we  
94:32 - should always visualize what variable goes where 
or what data goes where and what is the scope of  
94:39 - that variable or data okay. So, let us run through 
this code and see what is happening in the memory.  
94:46 - When this program will start executing first 
the main method, main function will be invoked  
94:53 - whenever a function is called some amount 
of memory from the stack is allocated for  
94:59 - the execution. Attack function, it's called the 
stack frame of that function. So, let us say,  
95:06 - this stack frame from address 100 250 is 
allocated for the main function stack is  
95:12 - one contiguous block of memory. So let us say in 
the stack the memory increases from bottom to top,  
95:19 - all the local variables of function go into the 
stack frame of the function. So, when we declare a  
95:26 - character array, or 20 bytes from the stack frame 
will be allocated for this particular character  
95:31 - array. Let's say they're allocated from address 
100 220. Each character is stored in one byte,  
95:38 - so we need 20 bytes for character array of size 
20. Apart from local variables, there may be  
95:44 - some more information and stack frame. So that's 
why we have some more space. And now the control  
95:50 - of the program goes to the statement print 
see, as soon as we make a call to another  
95:55 - function from a function, the execution of that 
particular function is paused at that particular  
96:00 - line and the machine goes on to execute the 
called function, the call function is allocated  
96:06 - stack frame on top of the calling function. So 
print will be allocated a stack frame on top of  
96:12 - main function, whatever function is at the top 
of the stack and at any point is executing main  
96:18 - will wait for this function to finish let's say 
this particular stack frame is from 150 to 170.  
96:26 - Main is paused and print is executing right now. 
Now print will also have a local variable C,  
96:32 - but this will be a pointer variable. 
A pointer variable takes four bytes of  
96:37 - memory in a typical architecture. So this will be 
taking four bytes. So let's say starting address  
96:44 - a 154. In this stack frame, we have four bytes 
for this particular character pointer. So this C  
96:50 - in main is actually not the same C in print, 
the C in main and the C in print are different.  
96:57 - They have different scopes, or we could have 
named this particular variable a or PTR or  
97:03 - whatever. But all that happens when we make this 
particular called to print and pass this see here  
97:10 - is that the address 100 which is the base address 
of the array is passed to the print function and  
97:16 - the print function keeps it stores it in a 
pointer variable. Sometimes it may confuse  
97:22 - us when we are using the same local variable 
name in the calling function and the same  
97:28 - argument name in the called function. But we 
must always understand that they are different.  
97:32 - Okay to run through this code further. I'll clear 
some space here. Now. I'll draw this array c  
97:40 - outside the stack here we have an array of 
size 20. But we are only showing the first  
97:47 - six positions in the array from address 100 205. 
And that's why it is extending towards the right.  
97:54 - The sixth character is a null character and the 
first five characters are the characters of word  
98:00 - hello. Now we have this another guy which is 
C of print, which is a character pointer at  
98:06 - address 154 that stores address 100 so it points 
to the first element of the array. Now let's  
98:14 - come back to our program execution. Let's say we 
are here initially, I'll mark the statement that  
98:20 - is executing by this green arrow or Let's 
name these two guys this guy see but this guy  
98:26 - is an array, local domain and this is also c 
but it is a character pointer local to print.  
98:32 - Okay, so now here what we're saying is, while 
Asterix c is not equal to the null character,  
98:38 - when we put this asterik operator in front of a 
pointer variable, we are looking at the value at  
98:44 - that particular address. So at this stage, when 
C is pointing to the base address as Trixie is H,  
98:52 - so this condition is not true, we will go to 
this line printf that will simply print Asterix C  
98:59 - which is h let's write down the output here. So we 
have printed h so far, and then we say c++. If we  
99:08 - understand pointer arithmetic from our previous 
lessons incrementing a pointer by one unit  
99:14 - increments the address by size of the data 
type that the pointer points to see here is a  
99:20 - pointer to character data type and character data 
type is one byte. So C plus one, c++ is saying  
99:27 - C is equal to C plus one. So C now becomes 101. So 
now c points to the second character in the array.  
99:36 - And once again we come to verifying this condition 
in the while loop as Trixie Is he here it's not  
99:42 - null. Now once again we will go inside the loop 
and print E and we will keep on going like this  
99:50 - builder address in this pointer variable 
reaches 105. Now here, the value at this  
99:56 - particular addresses null character so the 
loop Will not execute, or we will come to  
100:02 - this statement to print and end offline and 
the execution of print function will finish.  
100:09 - So this particular stack frame for print will 
be cleared from the stack will be de allocated.  
100:16 - And now main will resume and finished. So with 
pointers, we should always know what's going where  
100:22 - in the memory. Okay, so let us now modify this 
particular code to learn some more concepts.  
100:29 - Or what I'm going to do in my code is, instead 
of creating a character array of size 20,  
100:36 - I'll create a character pointer named C and 
equated against a string literal in a statement  
100:45 - like this. And if you run this program on the 
output will be the same, what really happens is  
100:51 - if you use the string literal initializations 
to statement of an array something like this,  
100:57 - and then the string get stored in the space 
that is allocated to the array. So in this case,  
101:02 - it will go into the stack in this character array 
of size 20. But if you use the string literal  
101:08 - elsewhere in a statement like this, or maybe when 
we do something like passing a string literal  
101:16 - to a function, then in these cases, the string 
gets stored as a constant during the compile time,  
101:25 - most probably it will be stored in the 
text segment of the application memory, and  
101:30 - it cannot be modified. So if you write a 
statement like this, let's say you want to  
101:34 - change the first character of this constant 
string to a or running this program will  
101:40 - give you an error will cause a crash. Okay, 
coming back to having a character array. Now,  
101:48 - if we have a character array, and we are passing 
on the address of the array to a function,  
101:54 - that function receives it in a character 
pointer. Now, using this pointer, we can modify  
102:01 - the data in this particular array. So if I say 
something like this, we first change the first  
102:06 - character to a and then we are printing 
the characters. And then as you can see,  
102:11 - it is possible to do so. Now sometimes we may want 
a function and just to read a string and not write  
102:17 - anything. to force this kind of behavior, we can 
change our argument to const character pointer.  
102:25 - Now if we run this code, this code will give us 
compilation error, or we can read whatever is  
102:30 - there in the array that is passed. But we cannot 
write to any of the positions, and this code  
102:36 - will work fine. pointers are really tricky, 
and even the most experienced programmers  
102:43 - write buggy code when they're using pointers, 
I recommend that you get your hands dirty by  
102:48 - writing some code yourself. That's the best way to 
learn. So this is it for this lesson. Thanks for  
102:54 - watching. In this lesson, we are going to talk 
about pointers and multi dimensional arrays.  
103:01 - As we have seen in our previous lessons, the 
concepts of pointers and arrays go together. We  
103:07 - have already talked about pointers in context of 
one dimensional arrays, how we can work with one  
103:12 - dimensional arrays using pointers. Now let's 
see how we can work with a two dimensional  
103:17 - array or a three dimensional array, or a multi 
dimensional array in general, using pointers.  
103:23 - To understand this concept, once again, we first 
need to understand how multi dimensional arrays  
103:28 - are organized in computer's memory. Let's first go 
back to the organization of one dimensional arrays  
103:34 - in memory. When we declare a one dimensional array 
something like this, let's say we are declaring  
103:40 - an integer array A of five elements, then 
basically what we are doing is we are creating  
103:47 - five different integer variables that we can name 
a zero, a one, a two, a three and a four as one  
103:55 - contiguous block of memory. What I'm showing here 
is a section of computer's memory, or a let's say  
104:02 - is stored in this section of memory, and the 
starting address of A is 200. As we know each  
104:09 - byte in a computer's memory has an address. And if 
we assume that an integer is stored in four bytes,  
104:16 - which is what it takes, in a typical compiler, 
then the block of four bytes starting address 200  
104:23 - will be a zero, as I'm showing here, block of four 
bytes starting address 204 will be a one. Next  
104:30 - block of code byte starting address 208 will be 
a two and so on. I'll fill in some values here.  
104:38 - We had seen this earlier also in our previous 
lessons. If we write a statement like this,  
104:43 - then this is all right. If I just use the variable 
name a then name of the array in an expression  
104:51 - basically returns a pointer to the first 
element of the array, because this is an  
104:57 - array of integers. So each element will be an 
integer Hence a returns a pointer to integer.  
105:03 - Once I have written a statement like int Asterix 
p equal a, I can use pointer arithmetic and  
105:09 - dereferencing to access all the elements in 
the array, if I would just try to print the  
105:15 - address stored in P and I'm not using full 
printf statement here, my output will be 200  
105:21 - if I would simply try to dereference 
p, then output will be two if I would  
105:27 - try to print something like Asterix 
p plus two, then output will be six  
105:33 - because we have an integer pointer adding one 
will take us to the address of the next integer  
105:39 - which will be four bytes ahead adding to will take 
us to the address of next to next which will be  
105:45 - eight bytes ahead if we would be printing p plus 
two it will be 208. And if we would dereference  
105:53 - and we would print Asterix p plus two then it 
will be value six, we have already discussed  
105:58 - pointer arithmetic in our previous lessons. Now 
language gives us this flexibility that we can use  
106:05 - the name of the array just like a pointer 
for all the dereferencing. So instead of  
106:11 - doing all of this printing with P if we will do 
all of this with a it will still be the same.  
106:18 - In fact Asterix a plus i is same as AI these are 
alternate syntax and a plus i is same as ampersand  
106:28 - AI both will give us the address of the ayat 
element in the array. Please remember that even  
106:33 - though we can use the name of the array just like 
pointer for all this dereferencing and arithmetic,  
106:40 - it's not seen as a pointer variable. So 
we can do something like p equal a like  
106:46 - what we have done here. So this is all right. 
But we cannot do the other way we cannot say  
106:51 - equal p this will give you a compilation error. 
So this is pretty much how we would use pointers  
106:59 - with one dimensional arrays. Let's now say 
we want to create a two dimensional array,  
107:04 - I will declare a two dimensional array 
of integers named t something like this.  
107:11 - Now, what we are doing here is we are creating 
array of array, we are creating two one  
107:17 - dimensional arrays of three elements each this 
time be zero and B one are both one dimensional  
107:25 - arrays of three integers each. a one dimensional 
array of three integers would be 12 bytes, if each  
107:33 - integer is four bytes in size. So if I have to 
show this in memory, the first block of 12 bytes  
107:40 - starting address 400 will be B zero. And the next 
block of 12 bytes starting address 412 will be b1.  
107:53 - As we had said name of the array returns a pointer 
to the first element in the array. This time each  
108:00 - element is not an integer, each element is a one 
dimensional array of three integers. So if I would  
108:08 - write a statement like this int Asterix p equals 
p, then this will give me a compilation error,  
108:14 - because b will return a pointer to a 1d array of 
three integers and not just a pointer to integer,  
108:21 - the type of a pointer matters not when you have to 
read the address. It matters when you dereference  
108:28 - or when you perform pointer arithmetic. It's 
really important that we understand this we can  
108:33 - define a pointer to a 1d array of three integers 
like this. And now if I equate this with B,  
108:42 - this is all right. equate B with B this time if 
I would print just p which is same as printing  
108:51 - address of B zero, this will be 400 if I 
will print Asterix P which will be same as  
109:00 - B zero, then B zero this time is variable name 
for a one dimensional array of three integers.  
109:07 - So just using the name B zero will return us a 
pointer to the first in teaser in B zero which  
109:14 - will be accessed as p 00. So I'm putting 
this ampersand sign here in front of P 00.  
109:21 - First integer in B zero will be this block 
of four bytes. Its address once again is 400.  
109:29 - Okay, now I have also created three blocks of 
four bytes each in both v zero and v one and  
109:36 - also filled in some values. Now I'm going to 
write some print statements and I want you  
109:42 - to guess the output. What will be the output 
if I'll try to print B plus one I will write  
109:49 - the address of each block of four bytes 
in the 2d array the address of a block  
109:55 - is the address of the first byte in the block. 
Okay, so what will be the value of B plus one  
110:01 - B this time is returning us a pointer to 
one dimensional array of three integers.  
110:07 - So, if I would do a pointer arithmetic like adding 
plus one, we are moving to the next one the array  
110:13 - of three integers. So, we will be moving to 
address 400 plus size of one dimensional array  
110:18 - of three integers in bytes. So, output will be 412 
which makes sense because p plus one is same as  
110:27 - ampersand B one or address of B one and address 
of B one is 412 okay now, what if I print Asterix  
110:37 - B plus one when we are putting an Asterix signs 
when we are trying to dereference This is when the  
110:43 - type of pointer becomes important B is a pointer 
to one dimensional array of three integers. So,  
110:48 - B plus one is also a pointer to one dimensional 
array of three integers and when we will  
110:53 - dereference we will get this whole one dimensional 
array of three integers starting address 412  
110:59 - Asterix B plus one is same as B one. So, we will 
get b one now printing B one means using the  
111:06 - name of this one dimensional array B one which 
should return us the pointer to the first  
111:13 - integer in B one. So, astrick b plus one is 
basically pointer to this integer at address 412.  
111:21 - Once again this output will be 412 all these 
expressions Asterix p plus one or B one or  
111:28 - ampersand v one, zero are returning us pointer 
to integer okay now you need to get up because  
111:36 - I'm going to give you some tough ones to decode 
what will be the output if I will print Asterix  
111:42 - B plus one plus two, take some time and think 
about it. Asterix B plus one as we saw above,  
111:50 - will return an integer pointer to first integer 
and B one to the integer at address 412. Adding  
111:58 - to here is performing pointer arithmetic because 
Asterix p plus one is a pointer to integer  
112:04 - storing this address 412 adding to is basically 
going to the address of next to next integer,  
112:13 - which will mean skipping eight bytes and and going 
to reference in teacher at address 420 as strict B  
112:21 - plus one in this expression can be written as b 
one simply be one because they are substitutes  
112:26 - for each other their alternate syntax. So this 
is same as B one plus two. And once again,  
112:33 - these expressions are returning pointer to 
integer they are returning pointer to this element  
112:38 - B one two. That's why we can also say ampersand 
B one two, all these three once again are seen.  
112:45 - Let's do one more print. If you can get this one 
right, I can say that you're good working with two  
112:51 - dimensional arrays using pointers what will be the 
output for this expression as trick of Asterix,  
112:59 - Asterix of Asterix B plus one what will be the 
output for this expression? Think about it,  
113:07 - whenever you encounter an expression with pointer 
arithmetic and dereferencing then you must go step  
113:13 - by step here B is returning us a pointer to one 
dimensional array of size three one dimensional  
113:21 - array of three integers and dereferencing it will 
give us the one dimensional array. So asterik B  
113:29 - as we know will give us B zero asteroid B is 
same as B zero. Now B zero in my expression,  
113:36 - because B's row is named for a one dimensional 
array returns me a pointer to the first integer  
113:43 - in the one dimensional array. So b zero returns a 
pointer to integer we will get appointed to this  
113:49 - integer at address 400. Now, what will happen if 
you will add one to an integer pointer, it will  
113:56 - take you four bytes ahead to the next integer it 
will return you a pointer to the next integer. So  
114:02 - we will get a pointer to this integer at address 
404 astrick b plus one is basically ampersand b  
114:10 - 01. And with this final dereferencing we can get 
rid of this ampersand. So the overall expression  
114:19 - will be p 01 which is three for a two 
dimensional array b i j where b is named  
114:28 - for my two dimensional array and i and j are 
some indices can be written as Asterix of B i  
114:36 - plus j and once again p AI can be 
written as as strict SOF B plus i.  
114:44 - So these three expressions are same. I would 
recommend trying all of this in real code.  
114:50 - So far this discussion has been about working 
with two dimensional arrays using pointers. We  
114:54 - will stop here for this lesson. In another lesson 
we will play with some real code And we will also  
115:00 - discuss how we can work with an array of further 
higher dimension like a three dimensional array.  
115:06 - We will also discuss passing of arrays 
to functions through pointers. This is  
115:11 - it for this lesson. Thanks for watching. In 
our previous lesson, we saw how we can work  
115:17 - with two dimensional arrays using pointers. 
Now in this lesson, we will see how we can  
115:22 - work with arrays of further higher dimensions 
like three dimensional arrays using pointers.  
115:28 - We will also see how we can pass multi dimensional 
arrays as arguments to functions because that's  
115:35 - one scenario where pointers once again will come 
into picture. I will start with a quick recap of  
115:40 - what we have discussed in our previous lesson. 
Whenever we create a multi dimensional array,  
115:45 - and let's pick up the example of two dimensional 
array that we had created in our previous lesson,  
115:50 - we must think of the multi dimensional array as an 
array of arrays. Array basically, is a collection  
115:57 - of similar things of similar objects. So a multi 
dimensional array is basically a collection of  
116:04 - arrays. This array B here is a collection of one 
dimensional arrays of three elements each, we have  
116:12 - to one dimensional arrays of three elements each, 
what I have tried to show in this figure is how  
116:18 - array B will be organized in memory, I have 
assumed that the starting address of the array is  
116:24 - 400. Each cell storing and teacher here is a block 
of four bytes. As we know each byte in computer's  
116:31 - memory has an address, I'm not drawing all the 
bytes partition for all the bytes, I'm trying  
116:37 - blocks of four bytes each. And that's why I'm 
writing only the starting address of each block,  
116:42 - you can imagine a block of four bytes something 
like this, the starting address is 400. Let's say  
116:48 - each partition here is one byte. So the next byte 
has address 401 and the next one has address 402.  
116:57 - And the next one has address 403. Overall, this 
first block of 12 bytes, that will that contains  
117:05 - these three integers two, three, and six that I'm 
showing in yellow here is my first one dimensional  
117:11 - array that I can call B zero. And this next block 
of 12 bytes is my second one dimensional array of  
117:18 - three integers that I can call B one. So we have 
two one dimensional arrays in our collection,  
117:25 - we have two collections of three integers each 
in our collection, and everything is organized  
117:30 - in one contiguous block of memory. Now let's look 
at this B zero is from byte address 400 till 411  
117:40 - we have three integers and we have four bytes 
for each integer. The first integer that we can  
117:45 - access as element at zero at index of B zero is 
taking four bytes starting address 400 the next  
117:54 - integer that can be accessed as p 011 element 
of B zero will take next four bytes starting 404  
118:04 - and the next one will be v 02 element at index 
two of P zero. And similarly we will have four  
118:12 - bytes for zeroeth element of v one four bytes for 
one element and four bytes four element at index  
118:20 - two of B one as we had seen in our previous 
lesson when we just use the array name,  
118:26 - then it returns us a pointer to the first element 
of the array. Here B is a two dimensional array  
118:33 - it is an array of one dimensional arrays of size 
three. So b will basically return us a pointer to  
118:41 - one dimensional array of three elements pointer 
to one dimensional array of three integers. In  
118:48 - this statement, I have declared a variable which 
is pointer to one dimensional array of three  
118:53 - integers and the name of the variable is be a 
statement like this is all right, a statement like  
118:59 - this will not be alright because b will not return 
a pointer to integer B will return a pointer to  
119:05 - one dimensional array of three integers. Now 
I will write three print statements that I had  
119:10 - also written in our previous lesson. I'm not 
writing the complete syntax for printf. Okay,  
119:15 - so once again you need to tell me what will be the 
output if we would print these three expressions  
119:21 - we have p Asterix B and B zero. Well for all 
these three, output will be 400. here when we  
119:30 - say B just using the array name B will return us 
a pointer to the first one dimensional array in B  
119:38 - the type of a pointer variable is relevant 
only when we are trying to dereference or  
119:43 - perform pointer arithmetic. But if we will 
just try to print the address stored in the  
119:49 - pointer variable it will be the starting address 
address of the first byte of a block of memory.  
119:56 - So if we have a pointer to this one dimensional 
array that is storing two, three Six,  
120:00 - then it's addresses 400. Now when we did an 
Asterix B, which is same as B zero, we data  
120:08 - friends and now we have got the complete 
one dimensional array B zero. Now if I use  
120:14 - B zero because b zero is a one dimensional array, 
we will get a pointer to the first integer in  
120:20 - B zero, so we will get a pointer to bs 00 in 
this block of four bytes starting address 400.  
120:28 - Once again if we would just print the address, 
then the starting address of this block is 400.  
120:35 - That's why the output here is 400. Even if I would 
print ampersand bs 00, the output will be 400 B  
120:43 - and Asterix B are both returning us pointers, the 
difference is that B is returning a pointer to a  
120:49 - one dimensional array of three integers while 
Asterix B is returning a pointer to an integer,  
120:56 - when we are just printing the address both 
these objects the complete one dimensional  
121:01 - array B zero and the first element in B zero have 
the same starting address. So the same starting  
121:06 - address will be printed the type of pointer 
plays a role when you try to dereference or  
121:11 - when you try to perform pointer arithmetic. 
We had also seen in our previous lesson that  
121:17 - B IJ can be written as Asterix of B i plus j if b 
II for some value of i is a one dimensional array,  
121:27 - then b i will give us an integer pointer will 
return us an integer pointer to the first integer  
121:33 - in bi then adding j is basically performing 
pointer arithmetic and getting a pointer to  
121:39 - integer at index j in one dimensional array bi 
and then finally this dereferencing is getting  
121:47 - the value of that integer. Once again be 
I can be written as Asterix B plus i B  
121:56 - is a pointer to one dimensional array of three 
integers. So b plus I will also return a pointer  
122:01 - to one dimensional array of three integers and 
T referencing this particular dereferencing will  
122:06 - give us the one dimensional array and the name 
of one dimensional array returns us a pointer to  
122:12 - the first element in the array. So this once again 
will be pointer to integer. By now if you clearly  
122:18 - understand how all the pointer arithmetic and 
dereferencing is happening in these expressions,  
122:25 - then it's not very difficult to understand how 
things will be for say a three dimensional array.  
122:32 - Now let's say we have created a three dimensional 
array named C we have an array of three cross two  
122:39 - cross two or three dimensional array is basically 
an array or collection of two dimensional arrays.  
122:46 - So if I have to show C in memory, 
I will show it something like this,  
122:51 - I have assumed that the starting address of C is 
byte addressed 800 the first 16 bytes starting  
122:58 - address 800 is my first two dimensional array, 
I am assuming that each integer will take four  
123:05 - bytes. So all these cells in yellow are 
part of the first two dimensional array.  
123:11 - The next block of 16 bytes starting address 
816 is C one and the next block of 16 bytes  
123:19 - starting a 32 is C two, we can further break down 
the two dimensional arrays into one dimensional  
123:26 - arrays. The first two integers in c zero are 
part of the first one dimensional array c 00.  
123:34 - And seven and nine are part of C 01. The first 
integer in C 00 can be accessed as C 000. And we  
123:45 - can go on like this. Okay, once again, we'll play 
the same game, I will write some print statements  
123:52 - and you need to guess the output. This time just 
using the array name C will give us a pointer to  
124:01 - a two dimensional array of integers of size two 
cross two. So we can write a statement like this  
124:08 - I have declared a pointer to a two dimensional 
array of integers of size to cross to hear the  
124:14 - name of the point that is B if I would just print 
p or C here and I'm not writing the complete  
124:21 - printf statement once again my output will be 800. 
Now if I will perform a dereferencing and try to  
124:29 - print Asterix C then this will be seen as c 
zero and c zero is a two dimensional array.  
124:37 - So we will get a pointer to the first element 
in c zero. All these expressions are returning  
124:43 - us a pointer to one dimensional array of integers 
of size two and the address printed will be  
124:52 - 800. Remember C is of type pointer to 2d array 
of two cross two and Dear friends in ones is  
125:02 - giving us point at a one dimensional array 
of two integers, C is returning us pointer to  
125:08 - two dimensional array of integers c itself is an 
array, there is difference between the two types  
125:15 - okay for c c ij k where i j and k are some 
indices can be written as Asterix off c ij plus  
125:26 - K and now once again we can write C ij 
as Asterix of C i plus j and the overall  
125:35 - expression will look something like this and we 
can go ahead and write C i as Asterix of C plus i  
125:44 - if you are able to understand how 
I have derived these expressions,  
125:48 - if you are able to understand all the pointer 
arithmetic and dereferencing in these expressions,  
125:54 - then you are good working with multi 
dimensional arrays using pointers.  
125:58 - I want a quick answer for this one what 
will be the output for this print statement?  
126:05 - Well c 01 means we are going to this one 
dimensional array that has these two elements  
126:11 - seven and nine. And when we are using the our 
namc Is it a one we are getting a pointer to first  
126:18 - integer in this one dimensional array pointer 
to this integer seven, adding one we are doing  
126:26 - pointer arithmetic to an integer pointer So, we 
will go to nine and data referencing will give us  
126:33 - integer nine. In fact, this expression is same as 
C of 011. Now, what will be the output for this  
126:41 - print statement aspects of C one plus one c one 
will return us a pointer to one dimensional array,  
126:49 - the first one dimensional array in C one, 
this block containing integers three and four,  
126:55 - adding one is performing pointer arithmetic 
and going to the next one dimensional array,  
127:01 - it's going to this one dimensional array 
containing six and one. And now dereferencing  
127:07 - is basically getting the one dimensional array 
from the pointer. And if you just use the name  
127:14 - of the one dimensional array, you get a pointer 
to the first element in one dimensional array.  
127:20 - So we will get a pointer to this 
integer six, output will be 824.  
127:27 - This block of four bytes storing address 
storing integer three is 816. Next would be  
127:33 - next will be a 20 and next will be a 24 we can 
try out these expressions in a real program.  
127:40 - I'm writing this simple C program I have 
created this three dimensional array see  
127:46 - the data filled in is same as we were showing 
in the example. In the first printf statement  
127:52 - I'm writing I'm trying to print c astrak, c c zero 
and ampersand c 00. All of these are pointers. And  
128:01 - if I will just use person D address would be 
printed. When I'm running this code as you can see  
128:08 - the output for all these four expressions is same. 
Any guesses for what will be the output for this  
128:15 - printf statement, this expression is nothing but 
c 001. The output for first printf is different  
128:23 - because this is a different run of the program and 
in each run, the assigned address will change. But  
128:30 - whatever the address is, it will be seen for these 
four expressions, I would recommend trying out all  
128:36 - the different expressions that we were decoding 
earlier in a real program like this. Okay, the  
128:43 - next thing that I want to talk about is passing 
multi dimensional arrays has function arguments.  
128:50 - I'm going to declare a function and 
let's name this function f u n c. And  
128:58 - I want this function to accept a three dimensional 
array as argument. So what do I do? If I wanted  
129:06 - a one dimensional array as argument I could have 
given something like this. But as we had discussed  
129:12 - in one of our previous lessons, this syntax is 
only a syntactical sugar it is interpreted like  
129:19 - this by the compiler. A fresh copy of array is 
not created for a function call, only a reference  
129:26 - to it in the form of a pointer is created. So 
now if in the main function, I have an array  
129:33 - of one dimensional array like this, and let's 
say the return type of this function is void,  
129:40 - I can make a function called passing a like 
this and this will be fine. Now let's say  
129:46 - we declare a two dimensional array of two cross 
three. And now we want this function to receive  
129:52 - to take a two dimensional array as argument. Now 
as we discussed, he will Her return has pointed  
130:01 - to in teacher but B will return us a pointer to 
array of three integers one dimensional array of  
130:09 - three integers for this particular definition 
of p. So, for the function to take this array  
130:16 - p as argument definition should be something 
like this argument should be something like this,  
130:22 - either we can write this or we can write 
something like this, only the first dimension  
130:28 - can be left empty the other dimension has to 
be specified. And now I can pass B, there is  
130:35 - something interesting here, if I would declare 
a two dimensional array something like this,  
130:39 - let's declare a two dimensional array x have to 
cross for now, I cannot pass x to the function,  
130:48 - because x will return pointer to one 
dimensional array of foreign teachers,  
130:53 - while this function is supposed to receive 
one dimensional array of three integers,  
130:58 - if x is defined something like this of dimension 
five cross three, then passing x is fine.  
131:05 - Now, if we want to pass this three dimensional 
array, then once again we need to see what pointer  
131:11 - types he will return. So, C will basically return 
a pointer to two dimensional array of two cross  
131:19 - two. So, we can either use a syntax like this 
or something like this and then we can pass c.  
131:28 - So, this is how things will be for any multi 
dimensional array, except the first dimension  
131:34 - all other dimensions will be enforced. One 
common mistake that people do is for a two  
131:40 - dimensional array, they try to use pointer to 
pointer something like this. And for a three  
131:45 - dimensional array, they try to use something like 
this, which just won't work. So, this is pretty  
131:51 - much what we wanted to talk about pointers and 
multi dimensional arrays. Thanks for watching.  
131:59 - Memory is one important and crucial resource 
on our machine. And it is always good to know  
132:08 - the architecture of memory, the way operating 
system manages memory and the way a memory is  
132:14 - accessible to us as programmers. In this lesson, 
we will discuss the concept of dynamic memory  
132:20 - and we will see how to work with dynamic memory 
using C or c++ the memory that is assigned  
132:28 - to a program or application in a typical 
architecture can be divided into four segments,  
132:36 - one segment of the memory is assigned to store 
the instructions that needs to be executed.  
132:44 - Another section stores all the static or global 
variables the variables that are not declared  
132:51 - inside a function and that have the whole lifetime 
of an application they are accessible anywhere  
132:56 - during the whole lifecycle of the application as 
long as the application is running, one section of  
133:02 - the memory is used to store all the information 
of function calls and all the local variables  
133:09 - and we have also talked about stack in our lesson 
on call by reference local variables are declared  
133:17 - inside a function and the live only 
till the time the function is executing  
133:22 - the amount of memory set aside for these 
three segments the text segment the global  
133:27 - variable segment and the stack does not grow 
while the application is running. We will  
133:32 - come back to why we use this fourth segment 
heap in a while, let us first understand how  
133:38 - these three segments of the memory are used. When 
a program executes, I have a simple C program here  
133:45 - we have a function square that gives me the 
square of a number we have another function  
133:51 - square of sum that is given two arguments x and 
why and it returns us the square of x plus y and  
133:59 - in the main method, I'm just calling this function 
square of some passing it two arguments A and B.  
134:06 - Let us now see what happens in the memory when 
this program executes. Let us say this rectangle  
134:13 - in green here is memory reserved as stack and 
this rectangle in Orange is the memory reserved as  
134:20 - statical global variables section when the program 
starts executing first the main method is invoked  
134:26 - when the main method is invoked some amount of 
memory from the stack is allocated for execution  
134:32 - of main and this total is a global variable. So it 
should sit in this section. The amount of memory  
134:40 - allocated on stack for execution of main can also 
be called the stack frame for the method main all  
134:47 - the local variables arguments and the information 
where this function should should return back to  
134:54 - all this information is stored within this stack 
frame. The size of the stack frame for a method  
135:00 - is calculated when the program is compiling. 
Now, when main calls square of some method,  
135:06 - that's right shortcut s four s four squared off 
some, then a stack frame is allocated for the  
135:14 - call to square of some all these local variables 
x y Zed will set in this particular stack frame.  
135:21 - Now, sum of square calls square, let's 
again put a shortcut here for square.  
135:26 - So, another stack frame for Squire and 
it will have its own local variables  
135:31 - at any time during the execution of the program, 
the function at the top of the stack is executing  
135:38 - and rest are kind of paused waiting for the 
function above to return something and then it  
135:44 - will resume execution I have drawn this play and 
pause button here in case you do not understand  
135:52 - Okay, so, this total is a global variable 
it sits here in this section global variable  
135:57 - because it is not declared and declared inside 
a function, we can access it anywhere. And then  
136:02 - we go to this particular statement where we call 
square of sum and square of some calling square.  
136:07 - So right now, this is our call stack. This program 
may not be the best way to implement this logic,  
136:13 - I have written this program this way 
so that I can have some nested methods  
136:18 - calling each other let's say right now, we are 
at this particular statement we are executing  
136:23 - executing this statement. So, at this stage 
calls a call stack will have these three methods.  
136:29 - Now, when this method finishes, we will 
return back to this particular statement.  
136:34 - As soon as Squire function will return, it will 
be cleared from the stack memory and now some  
136:40 - square of some function will resume. Once again 
when square of some finishes, the control will  
136:46 - come back to this particular line to line total is 
equal to square of sum and main will resume again.  
136:54 - Now main we'll call printf. So once again 
printf will go to the top of the stack  
137:01 - printf will finish and the control will come 
back again to main and now main will finish  
137:06 - and when main finishes program will also finish. 
So in the end, our global variables will also get  
137:12 - cleared, there was no need in this program. To 
keep this variable total as global, we should  
137:18 - assign a variable as global only if it is needed 
at multiple places in multiple functions, and it  
137:25 - is needed for the whole lifetime of the program. 
Otherwise, it's a waste of memory to keep it  
137:31 - keep a variable for the whole lifetime of program 
execution. We had kept one global variable in this  
137:38 - program just to understand the cost concepts. 
Here, I must point out one more thing,  
137:44 - when our program starts our operating system 
allocates some amount of reserved space, let's say  
137:51 - always allocates one MB of space as stack, 
but the actual allocation of the stack frame  
137:59 - and the actual allocation of the local variables 
happens from this stack during runtime. And if  
138:05 - our call stack grows beyond the reserved memory 
for the stack, like for example, if a method  
138:11 - a calls b b call C and we go on calling and we 
exhaust the whole space reserved for the stack,  
138:18 - then this is called Stack Overflow and 
in this case, our program will crash.  
138:26 - One common case of Stack Overflow is when 
you write a bad recursion and your program  
138:31 - goes infinitely into recursion. So, as we can see, 
there are some limitations of stack the memory  
138:38 - set aside for stack does not grow during runtime 
application cannot request more memory for stack.  
138:45 - So if it is one MB then if the allocation of 
variables and functions in stack exceeds one MB  
138:52 - our program will crash for the allocation and de 
allocation of memory onto the stack happens by a  
138:59 - set rule when a function is called it is pushed 
onto the stack on top of the stack, when it  
139:05 - finishes it is popped or removed from the stack 
it is not possible to manipulate the scope of a  
139:10 - variable if it is on the stack. Another limitation 
is that if we need to declare a large data type  
139:18 - like an array as local variable then we need to 
know the size of the array at compile time only.  
139:25 - If we have a scenario like we want to decide how 
large the array will be based on some parameter  
139:30 - during runtime, then it is a problem that stack 
for all these requirements like allocating large  
139:38 - chunks of memory or keeping variable in the 
memory till the time we want. We have heap  
139:46 - like stack applications he is not fixed. Its size 
can vary during the lifetime of the application.  
139:54 - And there is no set rule for allocation and 
de allocation of memory. A program can totally  
140:00 - control how much memory to use from the heap 
till what time to keep the data in the memory  
140:07 - during the applications lifetime and he can 
grow as long as you do not run out of memory  
140:14 - on the system itself. That is a dangerous 
thing also and we need to be really careful  
140:19 - about using heap For this reason, we also 
sometimes call heap, free pool of memory or free  
140:26 - store of memory, we can get as much as we want 
from the heap. How heap is implemented by the  
140:34 - operating system Language Runtime or the compiler 
is something which can vary which is a thing of  
140:40 - computer architecture. But an abstracted way 
of looking at the heap as a programmer is that  
140:46 - this is one large free pool of memory available 
to us that we can use flexibly as per our need.  
140:56 - heap is also called dynamic memory and using the 
heap is referred to as dynamic memory allocation.  
141:03 - And let us now see how to use the heap in our C 
or c++ program. I will clear this code in the left  
141:12 - and I will draw one more rectangular block 
here for our heap. There is one more thing  
141:18 - that I must point out before moving forward. He 
is also one data structure. And if you do not  
141:24 - know about this data structure heap yet, you will 
learn about it in your data structure course. But  
141:30 - this nomenclature here has nothing to do with 
the heap data structure. The term heap here is  
141:36 - being used only for the large free pool of memory. 
heap data structure does not come anywhere in this  
141:43 - context. This term often confuses a lot 
of people when they know about heap data  
141:48 - structure. Stack is also one data structure but 
the stack segment of the memory is actually an  
141:54 - implementation of stack data structure. But heap 
is not an implementation of heap data structure.  
141:59 - To use dynamic memory in C, we need to know about 
four functions malloc calloc, realloc and free to  
142:11 - use dynamic memory in c++ we need to know about 
two operators new and delete. These four functions  
142:20 - can also be used in c++ because c++ has backward 
compatibility, it is only a superset of C, but  
142:29 - c++ programmers mostly use these two operators, 
new and delete, we will see some code examples  
142:37 - and try to understand how things happen. When 
dynamic memory is used, let us first pick up  
142:43 - some code example in C, let us write a C program. 
I'll clean up some of this stuff in the right  
142:50 - one MB first tag this was just an assumption. In 
reality the size of the stack will be decided by  
142:55 - the operating system and the compiler, it is a 
thing of architecture. Coming back to the code.  
143:00 - If we declare a variable like this, then this 
variable is a local variable it goes on the stack  
143:06 - memory for this particular variable a will 
be allocated from the stack frame of the main  
143:12 - method. Let us say we want to store an integer on 
the heap to reserve or get some space allocated  
143:20 - on the heap, we need to call the malloc function 
something like this, the malloc function asks for  
143:26 - how much memory to allocate on the heap in bytes, 
when we say malloc and passes pass as argument  
143:33 - size of integer then we are saying that hey give 
me a block of memory which is four bytes four  
143:39 - bytes is the typical size of an integer. So one 
block of four bytes will be reserved or allocated  
143:45 - on the heap and malloc will return a pointer to 
the starting address of this block and malloc  
143:51 - returns a void pointer. Let us say the starting 
address of this block of four bytes is 200.  
143:58 - So malloc will return us the address 200. Now 
we have a pointer to integer p, which is a local  
144:03 - variable to main. So this will be this will be 
allocated in the stack frame of the main method.  
144:09 - We have done a typecasting here because malloc 
returns pointer to wide, sorry, void pointer, and  
144:15 - p is an integer pointer. Now p stores the address 
of this block of memory which is 200. So we have  
144:23 - got some block of memory on the heap, which we 
want to use to store an integer. Right now we  
144:29 - do not know what's there in this particular block 
of memory. If we want to fill in something here,  
144:36 - we need to dereference this location using the 
pointer P and then put in some value. In fact,  
144:41 - the only way to use memory on heap is through 
reference. All the malloc function does is  
144:48 - look for some free space in the heap book set or 
reserved set for you and give back the pointer and  
144:54 - the only way you can access this particular block 
by keeping a pointer variable which will be local  
144:59 - to function. Now, let us write something like 
this, after writing 10 in this particular block,  
145:07 - I will go ahead and make one more call to malloc. 
When I make one more call to malloc, one more  
145:14 - block of four bytes is allocated on the heap. And 
let us say the addresses 400 for this block. Now,  
145:20 - the address that is returned by the second call to 
malloc and restore this address in the variable p.  
145:26 - So, what happens is that P is now pointing to 
the address 400. The next line writes 20. at  
145:33 - this address, we allocated one more block and 
we modified that recipe to point to this block,  
145:40 - the previous block will still set in the heap. 
This memory we're still consuming, it will not  
145:46 - be cleared off automatically. At any point in 
our program, if we are done using some particular  
145:51 - block of memory which is dynamically allocated 
unique using malloc. We also need to clear it  
145:57 - because it is unnecessary consumption of memory 
which is an important resource. So, what we should  
146:02 - have done here is that once we were done using 
this particular block of memory at 200, we should  
146:08 - have made a call to the function free any memory 
which is allocated using malloc is cleared off  
146:15 - by calling free and to free we pass the pointer 
to the starting address of the memory block.  
146:20 - So, now with this code, this first block of 
memory will first be cleared and then we will  
146:26 - be pointing to another memory address. It is the 
responsibility of the programmer to clear anything  
146:32 - on the heap if he has allocated it 
and does not need it any further.  
146:37 - So if you see in terms of the scope of the 
variable, anything allocated on the heap  
146:41 - is not automatically D allocated when the function 
completes like on the stack, and it does not live,  
146:47 - it does not need to live for the whole lifetime 
of the application like a global variable,  
146:52 - we can control when to free anything on the 
heap when to deallocate anything on the heap.  
146:58 - If we wanted to store an array on the heap, like 
let's say we wanted to store an integer array,  
147:03 - then all we do is make a call to the malloc asking 
for one block of memory equal to the total size of  
147:09 - the array in bytes. So, if we want an integer 
array of 20 elements, then we will make a call  
147:17 - to malloc asking 20 into size of int which will 
be for number of bytes. So what will happen now  
147:24 - is that one big contiguous block of memory for 
20 integers will be allocated on the heap and  
147:31 - we will get the starting address of this block. 
So we kind of get the base address of the array,  
147:37 - the speed will point here to the base address of 
this block. And then in our code we can use this  
147:44 - 20 integers as P zero p one, p two and so on. 
As we know, P zero is same as saying value at  
147:53 - address P and P one is same as saying value 
at address p plus one, this is what it means.  
148:01 - One more thing, if malloc is not able to find any 
free block of memory is not able to allocate some  
148:06 - memory on the heap, it returns null. So for 
error handling, we need to know this. And we  
148:12 - need to write our code appropriately malloc and 
free the use of malloc and free a C style code.  
148:19 - If we want to write the same code, same logic 
in c++, then there is not much difference.  
148:25 - Instead of using these two functions malloc and 
free, we will use two operators new and delete  
148:32 - and write our code something like this. So instead 
of using malloc, they are using the new operator  
148:37 - here. And instead of using free we are using 
delete here. If we want to allocate an array, we  
148:45 - use something like this where we put the size in 
brackets here. And if we want to free an array,  
148:50 - we use this particular operator delete 
and two brackets, sorry, one bracket.  
148:55 - With c++ we do not have to do all these typecast 
things like malloc returns void and we need to  
149:01 - typecast it back to integer pointer, new undelete 
operators are type safe. What it means is that  
149:07 - they're used with a type and return pointers 
to a particular type only. So here we will  
149:12 - get a pointer to integer only, we will be talking 
about dynamic memory allocation and other library  
149:18 - functions in more detail in the coming lessons. 
So thanks for watching. In our previous lesson, we  
149:25 - learned the concept of dynamic memory allocation, 
we learnt about stack and heap in the context of  
149:32 - applications memory. In this lesson, we will be 
looking at various library functions available  
149:38 - in C for dynamic memory allocation. We will look 
through these functions. In some code examples.  
149:46 - We will be talking about three functions that 
allocate block of memory on the heap. And these  
149:52 - functions are malloc, calloc and realloc. And 
we will also be talking about one function that  
150:00 - D allocates a block of memory on the heap and this 
function is three. Let us first talk about malloc.  
150:09 - This is the most frequently used library function 
for dynamic memory allocation. And the signature  
150:16 - or the definition of this function is 
something like this. This function as  
150:21 - argument asks you for the size of the memory block 
in bytes. This data type size underscore t if you  
150:29 - are not aware of it is a data type that stores 
all the positive integer values. So, you can  
150:36 - think of this particular data type as unsigned 
integer data type, the size cannot be a negative  
150:43 - value it cannot either be zero or a positive 
value. And to force this kind of behavior,  
150:48 - we use this particular type. And this 
function malloc returns a void pointer,  
150:54 - we have talked about word pointer in our previous 
lessons malloc returns a void pointer that gives  
151:00 - us the address of the first byte in this 
block the block of memory that it allocates.  
151:07 - So using malloc, you kind of say that, hey, 
give me a block of memory with these many  
151:12 - bytes. Let us say what we have here in the right 
is the heap section of memory available to us.  
151:18 - Each of these partitions are one byte. As we 
know each byte in the memory has an address,  
151:23 - let us say this bottommost byte has the address 
to 00. And the next byte is 201. And we go on  
151:31 - increasing towards the top, I'll mark these 
among the address of some of these bytes.  
151:36 - Let's say in our code, we make a 
call to malloc something like this,  
151:40 - that, hey, give me a block of memory. 
That is four bytes. Let's say we store  
151:46 - the address returned by malloc in a void pointer 
variable. Now let's assume that this particular  
151:53 - rectangular block that we're showing here in the 
read is what gets allocated against this call to  
151:58 - malloc These are four bytes the starting address 
is 208. So what will be the address and P if we  
152:05 - want to print the address and p, then what 
will be the output, the output will be 208.  
152:12 - This is cool. Using malloc, we are able to 
allocate some amount of memory deserves some  
152:16 - amount of memory. But why do we resolve memory, 
we reserve or allocate memory because we want  
152:21 - to store some data there. So we do not want to 
just randomly allocate some number of bytes. So  
152:27 - although it is correct to write a statement like 
this, in practice, we would not do so in practice,  
152:32 - we would first calculate how much amount of memory 
we need to store our data. So let's say we want to  
152:38 - store an integer, just one in teacher. So I need 
memory blog equal to the size of one integer.  
152:47 - So we typically use the function size off, which 
returns us the size of a variable and bytes  
152:53 - to figure out the size of the data type. And 
then we typically multiply this particular value  
153:00 - returned by size of by the number of units 
that we need. So if we need just one integer,  
153:07 - if we need memory for just one integer, and 
this is good, if we need memory for 10 integers,  
153:12 - we would write something like this, give me 10 
into size of integer. integer is a primitive data  
153:18 - type. Sometimes you may know that I know that size 
of integer is four bytes. So I can write something  
153:23 - like 10 into four here, but it's not a good 
practice to do. So, size of a variable depends  
153:28 - upon the compiler. And we will also be using 
malloc to allocate memory for complex data types.  
153:34 - So we must use malloc. Like this. Total number of 
bytes should be written as number of elements into  
153:41 - size of one unit, one unit of the data. Let's 
say if you want to have space for three integers,  
153:50 - I have picked up three so that I have enough 
enough space to allocate memory in the figure that  
153:55 - I'm showing here. Let's say this block of 12 bytes 
is allocated because size of integer is four bytes  
154:01 - typically, so the starting address would 
be 201. Now, how do we fill in data here,  
154:08 - if you see malloc returns a void pointer and 
void pointer as such cannot be dereferenced  
154:14 - you cannot write a statement something 
like asterik p is equal to two.  
154:19 - This is incorrect, you cannot dereference 
a void pointer wide pointer in fact is only  
154:24 - used as a generic pointer type which is normally 
typecasted into a pointer type of a particular  
154:30 - data type. And then it is used because malloc 
itself is a generic function to allocate  
154:36 - some number of bytes in memory in heap. It does 
not care where whether you are allocating this  
154:41 - memory to store character or to store integer or 
to store any other data type. It simply returns  
154:47 - a void pointer to the starting address. To be 
able to use this block of memory we first need to  
154:52 - typecast this void pointer into a pointer of some 
data type. So here we will write something like  
154:59 - Hanes Star p, instead of picking up a void 
pointer, we pick up a pointer to integer  
155:05 - because we want to operate with integers, so to 
dereference, we need an integer pointer type. So  
155:12 - we do the typecasting here of the void pointer 
pointer. And now this statement is valid.  
155:18 - If we want to assign some value to the second 
element, second integer in this list, then we  
155:24 - will do something like we will dereference the 
address p plus one, let's say we write the value  
155:29 - four here. And if we want to access the third 
integer, then we will write something like this.  
155:36 - Let's set the value of sex here. By asking for a 
memory block. For three integers, we are basically  
155:42 - creating an array of integers with three elements, 
we could also write this as strict p as P zero.  
155:50 - And we could also write as strict p plus one as 
p one. And similarly as strict p plus two SP to  
155:56 - the mean the same. All the manipulation on 
dynamically allocated memory happens through  
156:03 - pointers, you have a pointer to the starting 
address. And then if you want to go to the next  
156:09 - element in the array, you increment the pointer. 
And this is how things happen. We have two more  
156:15 - functions that allocate block of memory. 
Let us now talk about calloc. The signature  
156:20 - or definition of calloc is something like this 
calloc also does the same stuff as malloc, it is  
156:28 - only a slightly different calloc also returns 
void pointer. But calloc takes two arguments,  
156:34 - instead of one argument, it takes two arguments. 
The first argument is the number of elements  
156:40 - of a particular data type. And the second 
argument is the size of the data type.  
156:45 - So with malloc, if we have to declare an array 
of size three, an integer array of size three,  
156:50 - we would say three into size of int. With 
callot, we would say something like this,  
156:55 - the first argument is how many units of the data 
type you want, or the number of elements. And  
157:01 - the second argument is the size of data type in 
bytes. There is one more difference between malloc  
157:07 - and calloc. When malloc allocate some amount of 
memory, it does not initialize the bytes with  
157:13 - any value. So if you do not fill in any value into 
these addresses allocated by malloc, you will have  
157:19 - some garbage there. But if you allocate memory 
through calloc calloc sets all byte positions with  
157:27 - value zero, so it also initializes the memory that 
it allocates to zero. The third function that we  
157:36 - want to talk about is realloc. If you have a block 
of memory, dynamically allocated block of memory,  
157:43 - and if you want to change the size of this 
block of memory, then you can use realloc.  
157:49 - The definition or the signature of this particular 
function is this function takes two arguments. The  
157:54 - first argument is pointed to the starting address 
of the existing block. And the second argument is  
158:03 - the size of the new block, there can be a couple 
of cases in relock, the size of the new block  
158:09 - that we want may be larger than than the size 
of the previous block. In that case, machine  
158:16 - may create an entirely new block and copy the 
previous data, whatever bytes was written in the  
158:21 - previous block into the new block, if contiguous 
or consecutive memory is already available  
158:27 - with the existing block and the existing 
block may also be extended. Let us now look at  
158:32 - some code examples and see what we can do with 
these three functions. And we will discuss the  
158:38 - function three in our code itself. I'll write some 
C code and look at some of the use cases in which  
158:45 - we can use dynamic memory allocation. The first 
use cases let us say we want to declare an array.  
158:52 - And we want to first asks the user the size of 
the array and then we want to declare an array  
158:58 - exactly of this particular size entered by 
the user. So let's say I have a variable  
159:02 - n and I write a print statement like enter size 
of array and then I input this number n from the  
159:10 - console. Now I want to declare an array of size n 
only. So can I do something like this? Well, no,  
159:19 - this particular value in the braces cannot be a 
variable this will give you a compilation error,  
159:24 - we need to know the size of the array we cannot 
know the size of the array during runtime.  
159:29 - In such a scenario, we can allocate the memory 
dynamically. So we will write something like  
159:35 - in Star A is equal to and we will make a 
call to malloc to allocate a memory block  
159:42 - equal to the size of an integers. And this will 
again give a compilation error unless we typecast  
159:50 - this particular the return of malloc to integer 
pointer and now we have an array of size n and  
159:58 - we can fill in some data into the dynamically into 
the elements of this dynamically allocated array.  
160:03 - Let's say we want to put data something like first 
element is one, and the second element is two,  
160:08 - and so on. So we will write something like a i is 
equal to i plus one, we can print the elements in  
160:15 - the array. Let's say we want to pick up size of 
array as then. Okay, so the output is as expected,  
160:23 - we have 10 elements from one to 10. If 
I give size of array as let's say 25,  
160:31 - then this is what we get, we 
get all the elements till 25.  
160:36 - If we wanted to use calloc, instead of 
malloc. Here, the only change in this  
160:40 - code would be that we would use calloc 
here, and we would have two arguments,  
160:45 - and would separate out as first argument and 
the second argument would be size of int.  
160:50 - And this program will run around seamlessly. There 
is one more difference between malloc and calloc.  
160:56 - If we do not use this initialization, then with 
calloc, as you can see, all the elements are  
161:03 - being printed as zero, they're all initialized 
to zero. But if we were using malloc here,  
161:11 - then these elements are not initialized, there is 
some garbage value at each of these indices in the  
161:16 - array. So this is one difference between malloc 
and calloc calloc initializes fills the value  
161:21 - zero into each byte while malloc doesn't do this 
initialization. I'll rewrite this initialization  
161:29 - loop again. And now we will talk about free any 
memory that is dynamically allocated remains  
161:35 - allocated till the lifetime of the program till 
the time the program is executing, unless you  
161:41 - explicitly D allocated and to deallocate memory 
allocated using malloc and calloc or relock,  
161:49 - we have the function three and to the function 
free, you just pass the starting address of the  
161:53 - memory block as argument. Now what will happen 
if I free a, if we free a then the data from that  
162:00 - memory is erased, it may or may not be erased, it 
actually depends upon your compiler or machine.  
162:07 - But that memory will be available for a location 
against another call to malloc. Let's say let's  
162:12 - see what happens in this case when we are printing 
after freeing that particular memory block, I give  
162:17 - array sizes five and as you can see the elements 
being printed here, there is some garbage value  
162:22 - being printed. If this tree was not there, we 
would have printed elements 12345 as initialized.  
162:29 - Now the obvious question would be even though 
we are freeing the memory here, we are able to  
162:35 - access that the value at that particular memory 
location using the statement when we are using AI  
162:40 - the element at index i Well, that is one dangerous 
thing about pointers. If you know the address,  
162:45 - you can look at the value at that address. But 
you should read and write to that address only  
162:50 - if that address is allocated to you. What if that 
address is not allocated to you like in this case?  
162:56 - Well, you do not know what you are reading 
or what you're writing. And what we have  
163:00 - here it will have, it actually depends upon 
the compiler and the machine. In my case,  
163:05 - let's say after freeing we try to access the third 
element a two and try to push some value there.  
163:11 - Let's see what happens if we run this program. 
Let's give size of arrays five again, if you see  
163:16 - even after free, we are able to modify the value 
at this particular address a two part on some  
163:22 - machine such a program may cause our program to 
crash, we should always be sure to use the memory  
163:28 - that is allocated. Otherwise, it's like shooting 
in the dark. We do not know what will happen.  
163:35 - We will not talk about Maria Alok. If we want 
to modify the size of a memory block. Let's say  
163:41 - we have a memory block to store n elements in an 
array. And we want to extend it to maybe we want  
163:47 - to double the size of the array. Or maybe we 
want to reduce the size of the array to half.  
163:53 - For such scenario we use real lock and call 
to Ria lock will be something like this.  
163:58 - Let's say we take another pointer variable b 
then to relock we pass the previous pointer a  
164:04 - and size of the new block. So the new block is 
two into n into size of int and we'll have calls  
164:10 - to of course do the typecasting here okay now 
what this call will do is it will create a new  
164:16 - memory block of size to n and copy the values in 
the previous block in the previous memory block a  
164:24 - into this new memory block. how realloc works is 
that if the size of the new block is greater than  
164:30 - the size of the previous block, then if it is 
possible to extend the previous block find some  
164:36 - constitutive memory with the same block. Then 
the previous block itself is extended. Else.  
164:42 - A new block is allocated and the previous block 
the content from the previous block is copied  
164:47 - and the previous block is d allocated this 
will become further clear if I write this  
164:52 - print statement. I'll print the previous block 
address stored in a and the new address stored  
164:57 - in B and I'll also print all the two elements in 
B now, and I'll print each element in the array  
165:05 - B in one single line. Let's say size of there is 
five again. Okay, so the previous block address is  
165:12 - 9920128. And if you see the new address is also 
same. So it was possible to extend the previous  
165:18 - block only. And in B, the first five elements are 
from a and rest five elements are garbage value.  
165:24 - If we wanted to reduce the array size to let's 
say, half the same block, the previous block  
165:30 - itself will be reduced. So let's say I want to 
print the previous block now, the n elements.  
165:36 - Now as you can see, the first two elements 
are copied one and two, they're not copied,  
165:40 - in fact, they are there already, the rest three 
are de allocated. When we divide five by two,  
165:44 - we take only the integral part. So we kind of 
deallocate the space for three elements here.  
165:50 - In fact, if we give the size to be zero, here, all 
that will happen is that the complete block four  
165:56 - a will be de allocated. So this statement 
will be equivalent to using free upon a.  
166:03 - In most cases, we will put the return address 
by realloc into the same integer pointer.  
166:08 - so we can write instead of writing B here we can 
write a also, we can also pass the first argument  
166:15 - to realloc as null if the first argument 
is null, and the second argument is size.  
166:22 - And let's say we want to create something like a 
new block, with address starting at a stored in B,  
166:29 - that is the first argument is null, then 
this is equivalent to calling a malloc.  
166:36 - This only creates a new block does not 
copy anything from the previous block.  
166:41 - So realloc can be used with the right arguments 
as substitute for free as well as as substitute  
166:47 - for malloc. This was all about malloc, 
calloc, realloc. And free, we will see more  
166:53 - code on dynamic memory allocation in the coming 
lessons. So thanks for watching. In this lesson,  
166:59 - we will talk about pointers as return types. For 
functions. A pointer is just another data type.  
167:07 - It's just that a pointer stores the address 
of another data type. So it is quite possible  
167:13 - for a function to return pointer. But we must 
understand the use cases in which we may want to  
167:19 - return a pointer from a function. So let us try 
to understand this. I'll get started by writing  
167:25 - some code. Now I want to write a very simple C 
program. Initially, I want to write a function  
167:32 - ad that will take two integers as argument 
and sum these two numbers and return the sum.  
167:38 - So let's say we declare another variable c and c 
is equal to a plus b and the function returns C.  
167:46 - Now in the main method, I'll initialize two 
variables. Let's name these variables x and y,  
167:52 - let's say x is equal to two and y is equal to 
four. And we will have another variable said,  
167:58 - which will be the return of this function 
ad. And we will pass x and y as arguments to  
168:04 - this function. And finally, I'll print something 
like sum is equal to Zed. No prizes for guessing  
168:13 - the output here. I'll modify this code slightly. 
But before that, I want to talk about this concept  
168:20 - once again, that x, y and Zed are local variables 
to main function, and a, b and c are local to add  
168:30 - function. And what really happens when we call 
the add function is that value in this variable  
168:36 - x of Maine is copied to variable a of add, 
and value in y of Maine is copied to b of ad.  
168:45 - And what if we named these variables in 
Maine, A, B, and C instead of x, y and Zed  
168:53 - if we run this code output will be the same. This 
time, what we will say is that the value in a of  
168:59 - Maine is copied to a of ad and the value in B of 
Maine is copied to b of ad, this a in Maine and  
169:06 - this a in AD, they are not the same. You can 
verify this by printing something like this.  
169:13 - I'm printing the addresses of these two A's in 
my code. And as you can see, our address of A  
169:20 - in Maine is something like 2883032 and in 
AD it is 2882792 so they're not the same.  
169:28 - That means these variables are not the same they 
are at different memory addresses and the names of  
169:34 - variables are local or specific to a particular 
function. In our example, here, the method the  
169:40 - function mean can be called calling function and 
the function ad can be called called function.  
169:48 - In this particular call, when we are saying that c 
is equal to AD and passing a and b, and this call  
169:54 - where a and b in Maine are getting copied to 
a and b in AD. This is called Called by value,  
170:02 - this can be called a call by value. Now, what 
I want to do is instead of passing by value,  
170:08 - I want to pass the addresses of these two 
variables. So, I want to say that I want  
170:13 - to pass address of A and address of b to 
the add function. So, the signature of add  
170:20 - function should be such that it should receive 
the addresses. So, I will say that, okay,  
170:25 - it takes two pointer to integers A and B. And 
now, we can access the values at these addresses  
170:35 - by using this Asterix operator which is used to 
date reference and address. Now such a call is  
170:42 - called call by reference, a and b are integers 
local to main function and in the function  
170:48 - ad, A and B are not integer variables, A and 
B are pointer variables pointer to integers.  
170:56 - So the type is different. They're not in 
their int star. But at the end of the day,  
171:02 - they are also variables which are local to the 
function add. It's just that they're not integers.  
171:09 - And now I'm using these two variables which are 
pointer to integers to access these two variables  
171:16 - a and b in the main method, and to do so we use 
the asterik operator and now this code should  
171:21 - also work. I'll write a few more print statements 
inside this function add. I have tried to print  
171:29 - a and I have tried to print Astra K. And 
initially I was printing ampersand A.  
171:34 - So now ampersand a should give us the address of 
the pointer variable a should give us the address  
171:40 - of A in Maine because that is what this variable 
stores and asterik A should give us the value of  
171:47 - A in Maine let us see. And the output. As you can 
see here, the address of A in Maine is 3537612.  
171:57 - And address of A in AD is something else, but 
the value in a of ad, which is the address of  
172:02 - a of Maine is equal to 353762. So the first 
and the third line are same. And using the  
172:09 - address we are printing the value, which is 
equal to two I had a spelling mistake here.  
172:16 - Now I'll clean up some of these print statements 
coming back to our function ad we are returning  
172:21 - this value C and once again in the main method we 
are collecting this value seen another variable  
172:28 - which is C of main why not do something like pass 
the address of this C in add function. So what  
172:36 - we will do now is we will say that we want to 
return a pointer to integer from this function.  
172:40 - And here we will return ampersand see now 
ampersand operator when it is put in front of  
172:45 - a variable it gives us the address. Now of course 
here we will have to collect this particular  
172:51 - address. So we will have to define a pointer 
variable. Now this would be okay. And when we  
172:56 - are printing, we will have to print the value at 
address being pointed to by this pointer variable.  
173:03 - So what we just did was, what we just did is we 
modified this add function to return a pointer  
173:10 - to integer there are two syntax, we can say int 
and then put this Asterix sign or we can say int  
173:18 - and then put this Asterix and in front of the 
function name, ad and what the syntax are valid.  
173:26 - Now this function is returning pointer to integer. 
Let us run this program and see what happens.  
173:33 - Well, let me also strike off this print statement 
here. Okay, so the output seems to be all right.  
173:41 - Now have you got some logical error with this 
code already? If you haven't, stay with me for  
173:48 - some time. Now what I want to do is I want 
to write another function, a simple function  
173:53 - that will print hello world. So I'll name this 
function print hello world. And in this function,  
173:58 - I'll write a simple print statement. And now 
before I print the sum, what I'll do is I'll  
174:05 - call this function print hello world. And let's 
see what happens now. Oops, this looks weird.  
174:12 - Some is not correct. Now, I just saw that it 
was coming fine in my last run when I did not  
174:18 - call this print hello world. What happened? So 
let's try to understand what really happened here.  
174:24 - I'll come back to this family a diagram of various 
sections of applications memory, and the memory  
174:30 - that is allocated to a program is typically 
divided into these sections, all the local  
174:36 - variables, and the information about function 
call executions goes into the stack. So let us  
174:43 - run through this code. Let us simulate this code 
and see what's really happening in the memory.  
174:48 - For each function calls some part of the memory 
from the stack is allocated for its execution. We  
174:54 - call this the stack frame of that method or that 
function when the program starts executing for  
175:00 - The main method is invoked. So in the stack frame, 
some memory will be allocated for main function,  
175:06 - and all the local variables of main function 
will live inside this stack frame. Let's say  
175:12 - the starting address of this stack frame is 100. 
And the end address of the stack frame is 130. And  
175:19 - we will have three local variables created here, 
A, B and PTR. a and b are integers and PTR is an  
175:26 - integer pointer, let's say is at address 100, b 
is at address 112. And PTR is at address 120. I'm  
175:37 - just making these assumptions. Now when the main 
method will come at this line will where it is  
175:42 - calling ad function, its execution will pause and 
now memory will be allocated for the execution of  
175:49 - ad at any time whatever function is at the top 
of stack is executing main method will wait for  
175:57 - add function to complete and return. So here I 
should say a is equal to two b is equal to four.  
176:04 - And now add comes here in the stack, let's say 
add gets memory from 130 to 160. And add also  
176:11 - has three local variables a B and C A and B are 
pointers to integers, the value of a will be 100  
176:18 - and the value of B will be 112. Let's say their 
addresses his addresses are 130 140 and 144.  
176:31 - Once again these are just random assumptions. Now 
see is calculated as asterik A plus asterik b A  
176:38 - is pointing to this location and B is pointing to 
this location asterik is value at address stored  
176:45 - in a and astrick B's value at address stored in B 
so this C will be six here these two values will  
176:52 - be added. Now this add function will return the 
address of its local variable C which is 144 and  
177:00 - finish its execution. So this PTR will be 144 and 
now the memory that is allocated to add function  
177:08 - will be de allocated. Now this memory above 
address 130 can be used for other function calls.  
177:16 - And even though this variable pointer PTR 
stores the address 144 stores the address  
177:23 - of this particular block it kind of points to this 
particular block. The data here is not guaranteed  
177:29 - because this memory has been de allocated. Now 
we come here to this print hello world. And now  
177:34 - a memory from stack will be allocated for 
print hello world. Above this stack frame  
177:39 - of main method. This is main. So let's say 
that print HelloWorld gets this memory block  
177:45 - from address 132 address 150. But there is no 
local variable in this print hello world function.  
177:52 - But still function call execution involves storage 
of some information. So now this section from 130  
177:58 - to 150 is for print hello world, I'll write 
pH Ws shortcut for print HelloWorld. And it  
178:04 - has been overwritten. So this block at 144 no 
more stores a value of six. So when we come here  
178:11 - at this print statement to print the value at this 
particular address, we get some garbage value. Now  
178:18 - the obvious question would be why did the diode 
Why did we get the right value, when we were not  
178:23 - making a call to print hello world, I would say 
that I just got lucky maybe because I did not  
178:28 - call any other function after making a call to add 
my machine did not overwrite or erase the data at  
178:35 - that particular memory location. But when I made 
a call to print HelloWorld that memory got used.  
178:42 - If you see we have passed the addresses of these 
two variables a and b of Maine to add function,  
178:49 - but that is all right because called function 
always comes above the calling function in  
178:54 - the stack. So anytime this called function is 
executing calling function will be in the memory.  
178:59 - So if ad is executing main is guaranteed to be 
in the memory. So addresses of variables in Maine  
179:05 - will be accessible to add. But if we try to return 
a local variable from the call function back to  
179:11 - the calling function, like if we want to return 
a local variable from add to main, then when that  
179:17 - function finishes and the control returns back 
to the calling function, that memory has already  
179:22 - been de allocated. So it is okay to pass something 
from bottom to top in this call stack. Or I should  
179:28 - rather say that it's okay to pass a local variable 
the address of a local variable from bottom to top  
179:34 - in this stack but it is not okay to return the 
address of a local variable from top to bottom  
179:40 - in the stack in the call stack. I hope this 
makes sense. So now the obvious question would  
179:46 - be what are the use cases in which we may want to 
return pointers from functions and well if we have  
179:52 - address of some memory block in the heap section 
or some memory block in the global section,  
179:58 - then we can safely return that address Have 
these blocks because anything in the heap has  
180:03 - to be explicitly de allocated we control it's 
D allocation unlike stack. And anything which  
180:09 - is in the global section, a global variable 
lives, for the entire lifetime of the program,  
180:15 - I can use malloc or new operator in c++ to get 
some memory on heap. So, if I modify my code  
180:22 - something like this, I will declare this C as a 
pointer to integer and get some space allocated  
180:30 - on the heap using a call to malloc. Now malloc 
is a library function that returns a pointer,  
180:38 - but it returns a pointer to an address which 
is on the heap. So, we get a memory block and  
180:45 - using this pointer variable now, we can write this 
value asterik A plus astrick b at that particular  
180:52 - memory block and then we can return this address C 
which is the same address that malloc returned us,  
180:59 - but we are safe now because we are returning 
address of a block which is on the heap and and  
181:05 - not on the stack and this will work now. Now in 
this code, let's say this call to malloc gives us  
181:12 - this block at address 500 in the heap see now 
is only pointing to this block and using C we  
181:18 - have written this data here this value six and 
now when add finishes, the address returned by  
181:24 - the add function which is address 500 is still 
valid and we still have the data there and it  
181:31 - will not be de allocated anything on the heap 
is explicitly has to be explicitly de allocated.  
181:37 - So while returning pointers from functions, we 
need to be careful about the scope, we must be  
181:42 - sure that the address is not reused to store 
something else or the data is not cleared from  
181:48 - that address. In most cases we will be returning 
pointers to memory that is allocated on the heap,  
181:55 - or memory that is in the global section the global 
variables section. In our coming lessons one place  
182:00 - where we will be using pointers as function 
returns in our code is implementation of  
182:06 - linked list data structure. So this was pointers 
as function returns. Thanks for watching.  
182:13 - In this lesson, we are going to talk about 
function pointers. function pointers,  
182:17 - as the name suggests, are used to store address 
of functions. So far, we have used pointers mostly  
182:25 - as variables that would store address of other 
variables. Basically, pointers are data types  
182:31 - that can be used to store the address of some data 
stored in computer's memory, or in other words  
182:37 - to point to or refer to some data. And it doesn't 
always have to be a variable data could be stored  
182:43 - as constant also. And we use pointers not just to 
store the address, we can dereference and get the  
182:50 - value at whatever address the pointer is pointing 
to. Now we are saying that we can have pointers  
182:56 - that can store address or functions or in other 
words can point to functions. And we can use a  
183:02 - pointer to function to dereference and execute 
the function. And this is really interesting.  
183:09 - Some basic questions would pop up what really 
would be the address of a function. And even  
183:15 - if we can have pointers to functions, what are 
the use cases in which we may want to have them?  
183:21 - There are really interesting use cases of function 
pointers, but we will talk about them later.  
183:26 - Let's first try to understand the core logic here. 
Once again, I have drawn this familiar diagram,  
183:32 - the memory that is allocated to an application 
or a program can typically be divided into  
183:38 - these four segments. We have talked about 
this quite a bit in our previous lessons.  
183:43 - Okay, now a program is basically a set or 
sequence of instructions that you would give  
183:49 - to the computer to perform a task, we can write 
our program in a high level language like C  
183:56 - or c++, but at lowest level in its architecture, 
computer understands and executes only binary,  
184:04 - any instruction that has to be executed by the 
computer has to be encoded in binary. Of course,  
184:10 - there will be some rules for encoding. So what we 
do is we write our program or set of instructions  
184:18 - in a high level language like C or c++, and we 
pass it to a program called compilers as input  
184:26 - and corresponding to the source code compiler 
generates what we call machine code, or executable  
184:33 - code, which is instructions encoded in binary. 
Something like what I'm trying to show here.  
184:40 - compiler basically takes one or more source files. 
Let's say the program that I have written here is  
184:46 - in a file named program dot c. Now a compiler for 
C language will take this file as input and create  
184:54 - an executable file that will have the machine code 
on a Windows machine executable file has extension  
185:01 - e x e, an executable file will be stored in 
disk drive or some secondary storage device.  
185:09 - Whenever we say memory, just memory in context 
of programming, we mean the random access memory  
185:15 - or RAM that we also call the main memory or 
primary storage. So whatever applications memory  
185:22 - we're talking about here will be a chunk of main 
memory. A program or application gets a chunk of  
185:28 - memory only when it starts execution. When the 
application finishes execution, this memory is  
185:34 - claimed back. What really happens is that when we 
run a program, when a program starts execution,  
185:42 - some amount of memory is allocated to it. And that 
is what we are calling applications memory. Here.  
185:47 - The cold or text segment of applications memory 
is basically the machine code or instructions  
185:54 - copied from the executable file. Instructions 
are not executed directly from secondary storage.  
186:00 - Therefore, they are first copied to main memory, 
and then only they can be executed. During program  
186:07 - execution, we need memory not just to store 
instructions to be executed, but also to store  
186:13 - a lot of data that we would work upon in a 
program. These other segments are mostly about  
186:20 - storing and managing data. What I'm going to 
do now is I'm going to zoom into the code or  
186:25 - text segment, let's assume that each 
instruction in machine language takes  
186:30 - four bytes. I'm trying to show the section 
of memory storing the instructions here,  
186:35 - each partition here is a block of four bytes 
and addresses increasing from top to bottom.  
186:40 - So, we have instruction zero at address 200. 
And the next instruction is at address 204.  
186:46 - And the next is at 208. And so on, instructions 
in a program are executed sequentially.  
186:53 - Only Exception will be when instruction itself 
will say that hey go to or jump to this other  
187:00 - instruction at this particular address, which will 
happen in case of function calls. For example,  
187:07 - if instructions 01 Nat address 200 is currently 
executing By default, the next instruction to  
187:13 - be executed is instruction 02 at address 204 
unless instructions 01 itself is something like  
187:21 - go to instruction 05 at address 216 which will 
happen in case of function calls. A function  
187:28 - is nothing but a set of instructions 
stored in one contiguous block of memory.  
187:34 - Let's say this block containing instructions five 
till eight is a function. I'll name this function  
187:41 - if you and see one. Basically, a function is 
a set of instructions to perform a sub task  
187:47 - in memory a function will be one contiguous 
block with some instructions, the address of  
187:53 - a function what we also call entry point of 
a function will be the address of the first  
188:00 - instruction in the function. In this example here, 
address of function one is 216. a function call in  
188:09 - machine language will basically be an instruction 
to jump to entry point of some function to jump to  
188:16 - first instruction in a function. Now we will not 
go any deeper into architecture now this is good  
188:21 - enough to understand function pointers. When we 
say function pointers store address of functions,  
188:27 - we basically mean that function pointers store 
the starting address or entry point of the block  
188:35 - of memory containing all the instructions in a 
function. Let's now see how we can create and  
188:40 - use function pointers in a C or c++ program. I am 
going to write a simple C program here. The first  
188:47 - thing that I'm going to do is I'm going to write 
a function named ad. That will take two integers  
188:53 - as argument and return the sum of these two 
integers. And now I'm going to create a function  
188:59 - pointer that should point to this function 
add. The syntax to create function pointer is,  
189:06 - first type in the return type of the 
function to which this pointer will point  
189:11 - at will return int so I typed in int, then 
after space within paranthesis, type in  
189:19 - Asterix, and then name of the variable so I'm 
creating a pointer named P. And now once again  
189:26 - within paranthesis. Type in all the argument types 
of the function to which this pointer will point.  
189:33 - argument types in function declaration should be 
exactly the same as in the function to which this  
189:39 - pointer will point. Because both arguments 
in add function are int, we have two ends  
189:45 - in the declaration of function pointer also, 
to initialize function pointer and fill in  
189:50 - the address of a function we can use a statement 
like this. As we know ampersand operator gives us  
189:57 - the address of something. This statement p equal 
ampersand ad will fill in the address of ad in P.  
190:05 - So P now points to AD. And using p, we can execute 
this function ad. What I'm going to do here is I'm  
190:13 - going to declare an integer variable named C. And 
now I'm going to write a statement like this. What  
190:20 - I've done here is first I have used the Asterix 
operator to dereference and get the function.  
190:26 - And then I have passed arguments just like I 
would do with a function name. So I've passed  
190:33 - two integers two and three. And if everything is 
alright, the output of this printf statement here  
190:39 - should be integer value five, when I 
run the program, this is what I get.  
190:44 - So, this is really cool, we just used a 
function pointer to refer to a function  
190:50 - and then execute the function. One thing about 
the syntax of function pointer declaration,  
190:55 - we are putting the identifier or name of the 
pointer within this paranthesis if we would not  
191:01 - use the paranthesis then it will mean that we are 
declaring a function that will return a pointer  
191:09 - to integer in this case, if I would write 
something like this, I would write a declaration  
191:15 - something like this, then this is declaring a 
function that would return a pointer to integer  
191:21 - we can have an Asterix just before the function 
name or we can have an Asterix just after int  
191:28 - these two syntax are same, but if I would put 
this within paranthesis then this is declaring a  
191:36 - function pointer. Okay, a few more things. In this 
initialization Here we are using this ampersand  
191:43 - operator. Even if we do not use this ampersand 
operator, it will mean the same just using the  
191:50 - function name will also return us address of the 
function or in other words and appropriate pointer  
191:57 - to data friends, instead of using this paranthesis 
and Asterix operator with function pointer name,  
192:03 - we can simply use the function pointer name 
and this is good enough. So we can use function  
192:09 - pointer name or identifier just like function 
name, as you can see the output here is as  
192:15 - expected. So, we have two possible syntax for 
both referencing and dereferencing you can use  
192:21 - whichever you like the second one is more famous, 
one final thing to be able to point to a function  
192:28 - type of the function pointer must be appropriate. 
So in this declaration of P here if I would change  
192:34 - it something like this, then this function pointer 
is meant to point to a function that should take  
192:40 - two integers as argument and should return void 
add function is returning int, so P cannot point  
192:48 - to add this will give me compile ation error. 
Once again, if I will change the declaration  
192:53 - something like this, if I will have only one 
argument in the declaration of function pointer,  
192:58 - then P cannot point to add. Okay, now let's use 
some more functions with different signatures  
193:05 - and try to execute them through function 
pointers. I'm writing this function print hello,  
193:10 - it will simply print hello on screen. And we will 
have to declare a function pointer like this.  
193:18 - And then we can initialize the pointer and fill 
in the address of this function. And now we can  
193:24 - execute the function through the pointer. Let's 
see what the output is. This looks alright.  
193:31 - Now let's say we want to say hello to someone 
and I'll change the signature of print hello,  
193:37 - to take a string as argument the declaration 
of a function pointer will also change  
193:44 - and while calling we will have to pass a 
string upon running this program, this is  
193:49 - what I get. And this is also looking fine. So this 
is pretty much how we can create and use function  
193:56 - pointers in C or c++ function pointers are used 
in a program in interesting scenarios. They have  
194:01 - interesting use cases. We will talk about the use 
cases in next lesson. This is it for this lesson.  
194:08 - Thanks for watching. In our previous lesson, 
we saw what function pointers are. And then we  
194:14 - wrote a simple program to understand how we can 
create function pointers in C or c++ program. But  
194:22 - we did not discuss the real use cases of function 
pointers, real scenarios where function pointers  
194:27 - can be useful. So in this lesson, we are going 
to talk about the use cases of function pointers.  
194:33 - All the use cases of function pointers are 
around this concept that function pointers can  
194:38 - be passed as arguments to functions. And then a 
function that would receive a function pointer as  
194:45 - argument can call back the function that this 
pointer will point to. To explain this better,  
194:52 - I will have to write some code. First of all, 
I'm going to write a simple function named  
194:58 - a dysfunction. No argument returns void and 
simply prints Hello on screen. Now I will write  
195:06 - another function named p, this function takes 
a function pointer as argument PTR should point  
195:14 - to a function that should take no argument and 
should return void of function like a. Now in B,  
195:22 - I will simply use this function pointer PTR to 
call whatever function it's pointing to. Or in  
195:29 - other words, I can say that I will call back the 
function passed to me or given to me through PTR.  
195:36 - In the main function, I will declare a function 
pointer. And this function pointer should also  
195:42 - point to a function that should take no argument 
and should return void. I will initialize this  
195:48 - function pointer p with address of A. And now 
I will call this function be passing it this  
195:56 - function pointer P. Let's run this program and see 
what happens. Hello is getting printed on screen.  
196:02 - So, basically function a is getting executed, 
a is getting executed through this callback.  
196:09 - In the main function instead of writing 
these two statements, I can simply write  
196:14 - a statement like this and this should be good 
enough, because name of a function we had  
196:19 - discussed this earlier also returns a pointer. 
So, this one statement is same as previous two  
196:25 - statements, when reference to a function is passed 
to another function, then that particular function  
196:31 - is called a callback function. So, a is a callback 
function here, it can be called back by B through  
196:39 - the reference through the function pointer. 
This statement where we are calling the function  
196:44 - through function pointer is a callback, we are 
still not doing something very meaningful here.  
196:50 - What's the point in calling a indirectly through 
B in this code, this is not making much sense.  
196:57 - So let's now look at a scenario where using a 
function pointer and callback can make our life  
197:03 - easier. I have a simple scenario, I have a list of 
integers in an array, and I want to sort this list  
197:11 - in increasing order of the value of integers. 
To do so I will write my own sort function,  
197:18 - I'm writing a function named sort that will take 
an array and number of elements in the array,  
197:25 - the function will take an integer array, 
here I can write a and then brackets or  
197:31 - I can write Asterix a these two are alternate 
syntax, I will use simple bubble sort algorithm,  
197:38 - I have renamed this function as bubble sort. In 
bubble sort, we make multiple passes on an array.  
197:45 - And in each pass as we go from left to right, 
as we go from lower indices to higher indices,  
197:52 - we compare adjacent elements. And if the element 
at lower index is greater than the element at  
197:58 - higher index, while comparing adjacent elements, 
then we swap the elements, this inner loop  
198:05 - is a pass on array. And this outer loop is 
basically saying that we will make n passes  
198:12 - after first pass the largest element in the 
list will bubble up to the highest index,  
198:19 - and in the next pass, the second largest 
will bubble up to its appropriate position,  
198:23 - this will go on and it finally in n passes, the 
complete list will be sorted. If you want to  
198:29 - refresh bubblesort. There is a link to my 
code schools lesson on bubble sort in the  
198:34 - description of this video. In the main function 
I have called bubblesort function passing it  
198:39 - array A, and then I'm printing all the elements 
in a and hopefully elements should be printed in  
198:46 - increasing order. The output is as expected, we 
have a sorted list here. Okay, now let's say I  
198:52 - want to sort my list in decreasing order of the 
value of integers. So what change should go in  
198:57 - my code here? Think about it. The only change will 
be in this comparison logic in this if statement,  
199:05 - while comparing the adjacent elements. Now, I will 
say that if the element in left is smaller, if the  
199:11 - element at lower index is smaller than swap, or 
basically, in 10, push it towards higher index,  
199:18 - comparing adjacent elements and swapping is 
basically pushing smallest or largest element  
199:24 - towards higher indices. With this condition. 
With this comparison, we are pushing the smaller  
199:30 - number towards higher index. Let's see the output 
now. As you can see, I'm getting the numbers in  
199:35 - decreasing order. Now my list is sorted in 
decreasing order of the value of integers.  
199:41 - Now let's say I have a requirement like this. 
Sometimes in my program, I want to sort a list  
199:47 - of integers in increasing order. And sometimes 
I want to sort a list in decreasing order of the  
199:53 - value of integers. So what all can I do? Think 
about it. One thing that I can do is I can write  
200:00 - To start functions, the first sort function 
to sort in increasing order and another sort  
200:06 - function to sort in decreasing order. But if we 
will do so there will be a lot of duplicate code,  
200:12 - the two functions will be same, except 
just one character this less than sign,  
200:18 - or greater than sign. Writing duplicate code has 
a lot of disadvantages. So can we do something  
200:24 - better. Another thing that we can do is we can 
pass one more parameter to the sort function to  
200:30 - say whether we want the list sorted in increasing 
order or decreasing order, we can have a flag,  
200:36 - let's say when flag is one, we will start in 
increasing order and when flag is zero, we will  
200:41 - start in decreasing order. Using this approach, 
we can avoid writing a lot of duplicate code.  
200:48 - What I'm going to do is I'm going to use 
a function pointer. Sorting off a list is  
200:52 - always done on basis of some ranking mechanism. 
So based on some property, we should be able to  
200:58 - compare elements and say that they should come 
first and they should come later, the core  
201:03 - logic in sorting will always be the same. Only the 
ranking mechanism or comparison logic will change.  
201:10 - What I'm going to do is I'm going to decide which 
element is greater in rank and which element is  
201:16 - lesser through a function, basically, I will 
perform this comparison through a function,  
201:21 - my function will take a function pointer as 
argument, my sort function will take function  
201:27 - pointer as argument, the callback function, or 
the function that this pointer should point to,  
201:33 - must take two integers as argument, it should 
compare the two integers, and then it should  
201:39 - return back an integer. It should return 
one if first element has higher rank  
201:46 - zero if the elements are equal, and minus 
one if second element or second argument  
201:52 - has higher rank. And let's say the element 
that has higher rank will go towards the end  
201:58 - in sorted array towards higher indices. These are 
my assumptions while designing this sort function.  
202:06 - Now I'm going to use my callback function for 
comparison, if AJ and AJ plus one are now passed  
202:13 - as arguments to this callback function, and 
we get one, so this condition will be true,  
202:20 - we will swap in this condition because AJ will 
have to be higher in rank for this comparison  
202:27 - function to return one. So we will try to push 
a j towards higher indices. Let's now try to use  
202:35 - this particular implementation of bubblesort, 
I will have to write a callback function first,  
202:40 - I have written a function like this. Now in main, 
I can just use the name of this function that will  
202:46 - return me a function pointer and pass it in this 
call to bubblesort. In this comparison function,  
202:54 - I have not written a statement to return zero if 
elements are equal. Equality doesn't matter in the  
203:00 - logic, so far equality also I will return minus 
one. Let's first run this program and see the  
203:06 - output. This is what I'm getting the numbers 
are sorted in increasing order. Now I will  
203:12 - change the comparison logic a bit, I will return 
minus one if a is greater than b. So basically,  
203:20 - I have changed the ranking mechanism, the 
element with lower value is now ranked higher,  
203:25 - and will go towards the end of the array. This 
is what I'm getting upon running the program.  
203:30 - The array is now sorted in decreasing order of 
the value of integers. This is a really good  
203:36 - design because now our sort function can sort a 
list of integers based on any ranking mechanism,  
203:44 - we can have one callback function for each 
ranking mechanism. I will take one more  
203:49 - example. Let's say we have a list of integers 
with both positive and negative values in it,  
203:55 - I have modified a here a now has both positive 
and negative values, this time I want to sort this  
204:02 - array in increasing order of the absolute value 
of integers. So the negative sign will not matter,  
204:10 - we will just take a mod and then compare 
this array upon sorting should rearrange like  
204:18 - this. To be able to sort I will have to write a 
comparison function. Last time, we had modified  
204:23 - the same compare function, but actually we 
should be writing one comparison function  
204:28 - for each sorting scenario. So I will write a new 
function this time, I will write a function named  
204:35 - named absolute compare. I have included a 
reference to math dot h library and I will use  
204:42 - a BS function from this library that will give me 
absolute value of an integer. If absolute value of  
204:48 - a is greater than absolute value of b, then it's 
ranked higher, I should return one else I should  
204:56 - return minus one. Let's now use this function to 
solve This array, I have a minus spell error here.  
205:04 - Okay, instead of passing this compare function, 
I will now pass absolute compare in this call  
205:09 - to bubblesort. This basically is passing 
a pointer to absolute compare function.  
205:15 - Let's now run this program and see what happens. 
This is what I'm getting the elements are sorted  
205:20 - in increasing order of their absolute values. 
The bubble sort function here can take only an  
205:26 - array of integers, but we have a library function 
that can take any array. So it's further generic.  
205:34 - This library function is in STD 
lib dot h library. And it's named  
205:41 - q SOT q SOT for quicksort and to this function 
you should pass an array and it can be any array  
205:48 - it can be an array of integers or it can be an 
array of characters or even a complex data type or  
205:56 - structured first argument will be the array second 
argument will be number of elements in array,  
206:01 - third argument will be the size of the data type. 
So if this is an array of integers, I need to pass  
206:08 - size of int, size of data type in bytes size 
of function gifts, size of any data type in  
206:14 - bytes. last argument should be a function pointer 
a pointer to compare comparison function signature  
206:22 - of the comparison function should be like this, it 
should take two constant void pointers as argument  
206:29 - and return an integer. Why word pointers? What 
pointers are generic pointers, we can typecast  
206:36 - them to a pointer of any data type. And this 
is the specification of Q sort function,  
206:42 - it should be passed a pointer to such a 
function, so it will be able to call it  
206:46 - back. Let's write the comparison function. You 
can think of this as a reference of first element  
206:54 - passed as a void pointer to get the element. 
If it's a list of integers, I'll first have to  
207:02 - typecast the void pointer to int pointer. And 
then I'll have to use the Asterix operator to  
207:10 - dereference and get the value, we will do the same 
to get the value of second element, this function  
207:15 - must return any positive integer, if A is ranked 
higher, a negative integer if A is ranked lower,  
207:24 - and zero if both are ranked same, we can simply 
return A minus B and it will mean the same. If  
207:31 - A is higher in value, A minus B will be positive. 
And I'm trying to create a simple comparison  
207:37 - function here that would rank and integer with 
higher value as high. So basically this comparison  
207:42 - function can be used to sort the array in 
increasing order of value of integers. So,  
207:48 - like I said, returning positive value means a 
is ranked higher returning negative value means  
207:53 - B is ranked higher with this comparison 
function, if I would simply pass this to  
207:58 - Q sort and after the call to cusat print the 
value in this array, this is what I will get  
208:05 - as you can see the list is sorted in 
increasing order of the value of integers.  
208:10 - If I will change this comparison function to 
return b minus a. So element with lesser value  
208:16 - integer with lesser value will be ranked higher, 
the list will be sorted in decreasing order of the  
208:22 - value of integers. And if I will use abstract 
absolute value of A minus absolute value of b,  
208:29 - this is what I will get. Remember, in this 
comparison function, the two elements to be  
208:35 - compared are being passed through reference, their 
addresses are being passed through a pointer. The  
208:43 - const keyword here means you cannot modify the 
address in this pointer variable. We are having  
208:49 - to use void pointer because of generic design of Q 
sort function. Remember q SOT can sort any array,  
208:56 - not just an integer array, it's just that you 
will have to give the comparison logic. Okay, so  
209:03 - we just discussed one of the use cases of function 
pointers. This whole idea of callback is used in  
209:10 - a lot of interesting design scenarios. One more 
thing where this concept of callback makes our  
209:15 - life easier is something called event handling. If 
you are curious, you can check the description of  
209:21 - this video for some resources on event handling. 
This is it for this lesson. Thanks for watching.  
209:28 - In our previous lessons, we have learned 
the concept of dynamic memory allocation  
209:33 - we have understood what is stack and what is 
heap in applications memory. Now in this lesson  
209:39 - we are going to talk about one situation which is 
caused by improper use of dynamic memory or the  
209:45 - memory on the heap and this situation is memory 
leak. A quick recap of some of the concepts that  
209:51 - we have discussed in our previous lessons. The 
memory that is allocated for the execution of an  
209:57 - of a program or what we can also Call 
applications memory is typically divided  
210:03 - into these four segments or these four sections. 
One section stores the instructions in the program  
210:10 - that need to be executed. This section is 
called the code segment or the text segment.  
210:15 - Another section is used to store the global 
variables the variables that are not declared  
210:21 - inside functions and have lifetime of the whole 
application. Another section of the memory is  
210:27 - used to execute the function calls and store all 
the local variables this section is called stack.  
210:34 - The size of these three segments that code segment 
the global variable segment and the stack segment  
210:40 - are fixed and decided when the program is 
compiling. That is at the compile time. And the  
210:46 - fourth section, which is called heap, or dynamic 
memory does not have a fixed size, heap can grow  
210:55 - as per need. As we know, we get memory from the 
heap by making a call to malloc function in C.  
211:03 - And when we are done using that memory on the 
heap, we make a call to the free function to  
211:08 - deallocate or free that particular memory. In 
c++ apart from malloc. And free, we can also use  
211:15 - the operator new to get some memory and the 
operator Delete to free that memory. memory  
211:20 - leak is a situation when we get some memory 
on the heap, and do not free it when we are  
211:27 - done using it. So our application is actually 
holding on to some unused memory on the heap.  
211:34 - But why do we call this situation memory leak? And 
why does it happen due to improper use of dynamic  
211:40 - memory only due to improper use of heap only and 
not some other sections of applications memory,  
211:46 - we will try to understand this through 
one simple program. So what I'll do is,  
211:51 - I'll write one simple program and show the 
simulation of its execution in the memory.  
211:57 - To explain these concepts. In my C program here 
I'm going to write a very simple betting game.  
212:03 - And the game is that we have three positions 
and three cards, jack, queen and king. Initially  
212:10 - jack is at the first position key queen is at 
the second position, and King is at the third  
212:15 - position. And then computer shuffles these cards 
so that the positions of these cards is changed  
212:24 - is randomized. And now the player has to guess the 
position of the queen, he has to bet some amount  
212:32 - of money. Let's say it's virtual cash. And if he 
wins if he predicts the position, if he guesses  
212:39 - the position of Queen correctly, he takes away 
three times the amount that he had back. And  
212:44 - if he loses, he simply loses the bet amount. Let's 
say the player initially has $100 of virtual cash,  
212:52 - and he can play as many times as he wants until 
he runs out of cash. So let us now implement  
212:59 - this game. The first thing that I want to do 
is I want to declare a global variable named  
213:04 - cash that at any point will store the virtual cash 
available with the player initially he has $100 of  
213:11 - virtual cash. And then in the main method, I will 
declare a variable named bet. And I will write  
213:17 - code something like this. While cash is greater 
than zero, while player still has some cash,  
213:25 - we will ask him to bet something and we will take 
this input in this variable bet using scanf. For  
213:33 - negative scenarios like bet equals zero or bad 
being greater than the cash available, let's say  
213:39 - we will break out of this loop we will end our 
game for all of the conditions let's say we will  
213:43 - make a call to play function. And of course, 
now we will have to write the play function  
213:49 - we will be passing bet to the play function. So 
that will be an argument. And now in the play  
213:56 - function I will declare a character 
array of size three. And initially,  
214:02 - we will have the character j at the first position 
to say that there is a jack at the first position  
214:08 - J is for jack and similarly Q is for Queen 
and k is working. And now the computer must  
214:14 - perform a randomized shuffling. So we will write 
a print statement like this. Now we need to find  
214:19 - a logic to make a random shuffle of cards. One 
such logic is that we can make a call to random  
214:25 - number generator function in C to use the random 
number generator. First, we will make a call to s  
214:31 - RAND function and pass it an argument something 
like this. I'll come back to what I'm doing here  
214:38 - in a strand by making a call to a strand. Now 
let's say we run a loop five times and we will  
214:44 - choose any two random positions among 01 and two 
and swap the letter said these positions in the  
214:51 - array. Let's say these positions are x and y. Now 
when we make a call to RAND function, we will get  
214:56 - a random number but we want a number between Zero 
and two, zero and two included. So we will take a  
215:02 - modulo by three so that we either get zero or one 
or two. So we will take two such random positions  
215:10 - with statements like this. And now, what we can do 
is we can swap the characters at these positions.  
215:17 - So we will use a temporary variable First, we 
will store the character at position x in temp,  
215:24 - and then we will do something like this. I'm 
short of space here. So I'm writing three  
215:30 - statements in the same line. 
Okay, so now the swapping is done.  
215:37 - So we are swapping or shuffling characters or two 
positions, five times each time, we are picking up  
215:44 - two positions x and y are randomly by making call 
to RAND function and taking a module by three.  
215:51 - So this will guarantee us that x and y is between 
zero and two. That will be valid positions  
215:58 - by making a call to RAND function, we will 
get the random numbers but we also use this s  
216:05 - Rand once and pass this time null, the return 
of time function in random number generation,  
216:14 - there is something there is one concept of seeding 
the random number generators, so we are passing  
216:20 - seed to random number generator, we will not go 
into the details of random number generation now.  
216:25 - Now what I'll do in the proof play function is 
I'll have a variable named players guess. And  
216:32 - I'll ask the player to guess the position of Queen 
and then I will use scanf to take the input. Now  
216:41 - if the player is correct, then the character at 
that particular position in the character or a C,  
216:48 - and the position will be one minus what the player 
inputs, because the player is inputting one,  
216:54 - two or three that will map to 01 and two in the 
array. So if the character is Queen, he has one.  
217:01 - So his overall cash will be incremented by three 
times the amount else he has lost, lost, and his  
217:09 - cache will be decremented by the bet amount. So in 
the case of when we will write a print statement  
217:14 - like this, we will say that you have one and the 
result is this and your total cash, right now is  
217:20 - this. Remember, cash is a global variable. And we 
will print something similar if the player loses.  
217:27 - Finally, our play function is looking something 
like this. And we have also moved this variable  
217:33 - cash at the top. In the main method, I've 
added two more print statements initially.  
217:39 - Let's now play this game and see what happens. 
What I have done is I have compiled this code  
217:45 - and created an executable named game dot txt. And 
now I'm going to run that executable. So this is  
217:52 - asking, what's your bet. Let's say we want to bet 
$5 on position one, and I lose my balance now is  
218:01 - $95. Let's bet again, this time again, I lose. And 
I can go on playing some losing again and again.  
218:11 - Finally, a win after long time, I can go 
on playing this game, but I want to show  
218:15 - you something else, I have opened the task 
manager of Windows. And here. As you can see,  
218:22 - this highlighted row is for game dot e xe. The 
third column here is the memory consumed by this  
218:28 - executable game dot e xe you will have to see 
this in full screen. Now as I go on playing  
218:36 - the memory consumption here, the memory that 
showing you is not increasing, it's always 340 8k.  
218:44 - Now I'll go ahead and make some changes 
in my code. What I'll do here is  
218:48 - this particular character array that I'm creating 
as a local variable in the play function. Right  
218:54 - now it's created as a local variable, so it will 
go on the stack. Now I want to create a character  
219:00 - array on the heap. So what I'll do is, I'll write 
a statement like this, I'll declare a character  
219:06 - pointer named C and then I'll use malloc. To 
fetch memory to store three character variables.  
219:15 - In c++, we could have said something like this, 
we could have used the new operator. And now I'll  
219:21 - set a value at z zero at index as j, one at index 
Sq and two at index as K. So we have created an  
219:30 - array on the heap and c is a pointer to the base 
address of that array C is still a local variable,  
219:38 - but now it is a pointer to character and we can 
still use it like array. The rest of the code  
219:45 - will just work fine. Let us run this code and see 
what happens. I have opened the task manager and  
219:50 - I'm running the executable. Watch for the memory 
consumption of game dot txt. I will make some bets  
219:59 - as you You can see right now the memory 
consumption is 340 8k. I just kept on playing and  
220:05 - after some time the memory consumption is 480 8k, 
it has shot up. And if you will keep playing this  
220:12 - game further, after some time it will shoot up 
again, or maybe after some time, but it will shoot  
220:17 - up for sure. So why is it happening, or why was it 
not shooting up when See, the character array was  
220:23 - not on the stack, not on the heap and it was on 
the stack. Let's try to understand, I have drawn  
220:28 - sections of applications memory here. And let us 
now see what really happens in the memory when we  
220:34 - are playing our game. As we know from our previous 
lessons, all the information about function call  
220:39 - execution goes into the stack section of 
the memory. Anytime a function is called  
220:44 - some amount of memory from the stack is allocated 
for its execution when the program starts  
220:50 - executing. First, the main method is invoked or 
called. So let's say some amount of memory is  
220:54 - allocated for the execution of Maine. This is what 
we call the stack frame of a function. So this is  
221:01 - stack frame of Maine and all the local variables 
of Maine will sit inside this stack frame in our  
221:06 - code we had a local variable named bet, so it will 
go here and we had a global variable named cache.  
221:13 - So initially, let's say main function is executing 
when we play our game main function makes multiple  
221:19 - calls to play function. And what really happens 
when a function makes call to another function  
221:24 - is that that particular function is paused 
and memory is allocated for the execution of  
221:29 - the called function. So main will pause and play 
will start executing and play will go on top of  
221:35 - main in the stack. Now, we had a couple of local 
variables in play all will go in this stack frame  
221:40 - i x y players guess and for the case 
one when we had the character array C  
221:47 - on the stack itself, so it was not created using 
a call to malloc the character array C will also  
221:54 - sit in this stack frame. Now when the execution 
of play function will finish control will return  
221:59 - back to main and the memory that was allocated for 
the execution of play function will be reclaimed.  
222:05 - Anytime a function call finishes, the memory 
that it is allocated on the stack is reclaimed.  
222:10 - So there is one stack frame corresponding to 
each call. And as soon as that call finishes,  
222:16 - that memory is claimed back. Now main will make 
another call to play because we will play multiple  
222:21 - rounds. So play will again come into the stack 
and it will be cleared again when play finishes.  
222:26 - As you can see, all the local variables get 
cleared each time the function call finishes.  
222:31 - For anything on the stack, we do not have to worry 
about its deallocation it happens automatically  
222:36 - when the function call finishes. Now let's talk 
about the second case when character array is  
222:41 - created on the heap using a call to malloc 
function. Once again we will make multiple calls  
222:46 - to play function. Now, what will happen this time 
is that we will not create the array on the stack,  
222:54 - we will still have a variable named c a local 
variable named c but this variable will not  
223:00 - be of type character array of size three, this 
variable will be of type pointer to character and  
223:06 - we will make a call to malloc function to create 
the array on the heap and this local variable  
223:11 - which is a pointer to character will only point 
to this particular memory block anything that is  
223:16 - on the heap has to be accessed through a pointer 
variable. So here we have created the array on  
223:22 - the heap and we have kept only a pointer variable 
on the stack. Now when the call to play function  
223:27 - will finish the memory allocated for the execution 
of call to play function will be reclaimed. So all  
223:34 - the local variables will go away. But this memory 
on the heap will lie unused and unreferenced and  
223:41 - it will not get d allocated anything on the heap 
has to be explicitly D allocated by making a call  
223:46 - to free function or by using delete operator and 
think about it we will make multiple calls to play  
223:52 - function as we play multiple rounds of our game. 
And each time in each call to play we will create  
223:59 - one such memory block on the heap that will lie 
unreferenced and unused when call to play function  
224:06 - will finish. If we will play our game 100 rounds 
then we will have hundreds such unreferenced and  
224:13 - unused memory blocks of three characters and 
the heap. heap is not fixed in size. And our  
224:19 - application can claim can get more memory in 
the heap section as long as our system itself  
224:25 - is not running out of memory. And if we are not 
D allocating this unused memory on the heap via  
224:31 - depleting and wasting memory which is an important 
resource. Our applications memory consumption will  
224:37 - only keep on growing with time. memory leaks 
are really nasty bugs to have in your program.  
224:43 - Anything unused and unreferenced on the heap 
is garbage. In C or c++ we have to make sure  
224:49 - as programmers that garbage is not created on the 
heap memory leak is nothing but growth of garbage  
224:55 - in the heap. in languages like Java and C sharp 
garbage is automatically cleared From the heap,  
225:00 - so a programmer does not have to worry about 
freeing or D allocating the memory on heap,  
225:05 - which is a cool feature to have. It avoids memory 
leak. In this example, we were creating an array  
225:10 - of three characters on the heap. What if we were 
creating an array of 10,000 characters and not  
225:15 - freeing freeing the memory after we were done 
using it, at the end of the function, the memory  
225:19 - consumption would have shot up like anything. 
Coming back to my code here, what I have done is,  
225:25 - I have created a character array of size 10,000 of 
10,000 characters here, my logic would not change,  
225:32 - I'll just use first three positions in the array. 
I'm just trying to show you something. And at the  
225:38 - end of this particular function, when we are done 
using this array on the heap, we are making a call  
225:46 - to the free function, passing it the address of 
this memory block this array see, our program  
225:52 - will just work like before. But let's run this 
and monitor the memory consumption once again.  
225:57 - Once again, I'm showing you the task manager 
and I'm playing the game. Let's make some bets.  
226:03 - Now watch out the memory consumption of game dot 
txt. For howsoever Long You will play the game,  
226:11 - the memory consumption will shoot up. As you can 
see, it's 350 6k. And it's not shooting up for me  
226:18 - even after playing for a long time. And 
it is not shooting up because we had used  
226:25 - free to D allocate the memory when we were done 
using it at the end of the function. Remember,  
226:32 - we had created an array of size 10,000. And if 
we were not using free then the memory would have  
226:39 - shot up like anything the memory consumption 
would have shot up like anything. But because  
226:44 - we are freeing at the end of the function, it's 
not going up there is no memory leak. So finally,  
226:50 - to summarize it, memory leak is improper use 
of dynamic memory or the heap section of memory  
226:57 - that causes the memory consumption of our program 
to increase over a period of time. Remember,  
227:02 - memory leak always happens because of unused and 
unreferenced memory blocks in the heap. Anything  
227:08 - on the stack is de allocated automatically 
and stack is always fixed in size. At the  
227:14 - most we can have an overflow in stack. So this 
was memory leak in C c++. Thanks for watching.