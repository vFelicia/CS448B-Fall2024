00:00 - Swift is a popular programming language
00:02 - often used for creating iOS apps this is
00:05 - the perfect course for learning Swift
00:07 - vandad teaches this course he currently
00:10 - works as a lead iOS Developer and he's
00:13 - created many popular courses
00:15 - hi everyone and welcome to this course
00:17 - my name is vandon and I'm a senior full
00:19 - stack developer from Sweden
00:22 - in this course we're going to talk about
00:23 - Swift as a programming language without
00:25 - blending in Mac OS or iOS or back-end
00:28 - development we're going to talk about
00:29 - variables constants structures enums
00:33 - classes you name it even modern futures
00:36 - of Swift as a program language such as
00:37 - async and await I've been doing iOS
00:40 - development myself since late 2007 and
00:43 - I've been using Swift since 2014 when it
00:46 - came out first publicly
00:48 - this course is built for people who are
00:50 - already familiar with another program
00:51 - language from before you don't have to
00:53 - be very proficient in that language that
00:55 - you're using but as long as you know the
00:57 - basics it could be python typescript
00:59 - JavaScript rust whatever it is but as
01:02 - long as you're familiar with the basics
01:03 - then you should be good to go
01:05 - this video itself is part of a bigger
01:07 - playlist which is available on my
01:09 - YouTube channel and which you can find
01:11 - just by searching for my name and this
01:14 - playlist which I'm referring to is
01:15 - called Full stack with Swift and the
01:17 - goal of the playlist is just to get us
01:19 - familiar with doing Swift development
01:21 - for both front and and back end so if
01:24 - throughout this course I sometimes make
01:26 - references to this playlist then at
01:27 - least you know what that is for
01:30 - before we get started I'd really also
01:32 - appreciate it if you could give me a
01:33 - follow on YouTube just by searching for
01:35 - my name the link to which you can find
01:37 - in the description at the bottom of this
01:39 - video and I'm also very active on
01:41 - Twitter and Linkedin daily by publishing
01:44 - tips and tricks about programming
01:45 - languages and just generally informing
01:48 - the public about languages such as
01:50 - python typescript JavaScript rust Swift
01:53 - you name it so without further Ado let's
01:56 - just get started with the course
01:59 - hi everyone and welcome to this chapter
02:01 - of full stack with Swift in this chapter
02:04 - we're going to look at all the modern
02:06 - Concepts that are available in Swift as
02:10 - a programming language if you've already
02:12 - watched an introduction you probably
02:13 - know that and that this course generally
02:17 - not just this chapter but this course
02:19 - generally is not for absolute beginners
02:21 - so I expect you to already know another
02:24 - programming language it doesn't it
02:26 - doesn't really matter what it is it can
02:27 - be python rust it can be typescript
02:29 - JavaScript whatever as long as you know
02:32 - the basics of programming languages such
02:34 - as what functions and variables are then
02:36 - you're good to go if you don't have that
02:38 - experience from before this course
02:41 - generally might be a little bit
02:42 - difficult for you to follow through with
02:44 - and I will do my best to explain
02:46 - everything but since I I don't really
02:48 - want to explain all the basics
02:52 - um I think it is best that you perhaps
02:54 - have a look at some guides on getting
02:56 - started with another broken language
02:57 - such as Python and then get started with
03:00 - this course however if you haven't
03:02 - worked with any other program language
03:03 - from before and you're also very
03:05 - talented as well and which I assume
03:08 - every everybody is you might be able to
03:10 - follow along with this course without
03:12 - problem
03:13 - so what we're gonna do now is to go
03:16 - ahead and set up a playground basically
03:19 - a workspace with many playgrounds in it
03:22 - and playgrounds are Swift's concept of
03:25 - being immediate being able to
03:28 - immediately see what your changes are
03:30 - doing and it will allow you to basically
03:32 - run your code automatically as soon as
03:34 - you make any changes to your code so
03:37 - it is a very powerful way of testing
03:40 - code or even creating some projects in
03:43 - it you can you can create a whole
03:45 - project with a playground and see the
03:47 - results graphically even on the screen
03:49 - so it's very very
03:51 - um powerful for those of you who are
03:53 - familiar for instance with flutter and
03:55 - dart you already know that you can see
03:57 - your changes and display it on the
04:00 - screen immediately and playgrounds are
04:02 - no different they're very similar
04:03 - actually to how Dart and flutter work
04:05 - but a little bit actually simpler I
04:08 - would say because we're writing pure
04:10 - code and just seeing pure text displayed
04:13 - on the screen as a result of for
04:14 - instance calling a function
04:16 - so in order to continue with this
04:19 - chapter you probably need a a Macintosh
04:24 - um however what we're going to do we're
04:26 - just going to use Swift foundation and
04:28 - SDK in here or a library so you can
04:32 - actually follow through as well on Linux
04:35 - such as if you have for instance Visual
04:37 - Studio code re setup and if in and
04:40 - you've installed Swift you should be
04:43 - able to follow through the only
04:45 - difference will be that those of you who
04:46 - have a Macintosh and xcode installed you
04:49 - will be able to create a simple
04:51 - playground and see your changes
04:53 - immediately for those of you who are
04:54 - following this on Linux and visual
04:57 - studio code for instance you need to run
04:59 - the code manually so you will need to
05:01 - just type your code and then call Swift
05:05 - compiler from from your terminal and
05:09 - we're a console in order to run those
05:10 - codes so it shouldn't be that different
05:12 - so you should be able to follow along
05:14 - even on a Linux machine so without
05:17 - further Ado let's just go ahead and
05:19 - create our workspace now I'll explain
05:22 - what a workspace really is a workspace
05:24 - is a collection of pro projects you
05:27 - could say a collection of files and
05:29 - projects it's it's really just one file
05:32 - that explains the structure of a project
05:34 - to xcode if you're if you're running
05:38 - things on Linux so you don't have to
05:40 - create a workspace you probably can't
05:42 - because xcode does that and
05:45 - unfortunately this xcode
05:46 - um obviously xcode application creates
05:48 - like a proprietary format for all of its
05:52 - files kind of so not the text files but
05:54 - like the workspace and project files
05:56 - they are proprietary XML format which is
06:01 - puzzling Y in this day and age it has to
06:04 - use XML really but um
06:07 - that's a different subject so if you're
06:09 - following through and with the course at
06:11 - home with Linux then you don't have to
06:14 - create this workspace but if you're at
06:17 - home with a Macintosh you need to go
06:19 - ahead and create this workspace together
06:21 - with me
06:22 - so I'm going to bring up my extra just
06:24 - enough in here so that we can see what
06:26 - we're doing I'm going to go to new and
06:28 - let's just say workspace
06:30 - then in here let's just say Swift and
06:33 - crash course YouTube okay in here and
06:37 - let's just say save this workspace as
06:39 - you can see it's just an empty workspace
06:41 - at the moment so it doesn't have any
06:42 - contents
06:44 - what we're going to do then let's just
06:45 - increase the size of this so it takes
06:47 - the entire screen
06:49 - and then we're going to go ahead in file
06:51 - new and then we're going to go into a
06:55 - file
06:56 - and in here type playground in the
06:59 - search field and add a new blank
07:02 - playground okay
07:04 - so the first concept that we're going to
07:06 - talk about in here is going to be called
07:09 - variables so let's just say variables
07:12 - and I can see that our workspace was
07:13 - actually just creating here without any
07:15 - folder so we might be able to remedy
07:18 - that before we click create our
07:20 - playground let me just go ahead and open
07:23 - a finder window in here so let's just go
07:26 - ahead in here
07:28 - you don't see actually what I'm doing
07:30 - but right here is the folder then I'm
07:33 - going to take a I'm going to create a
07:35 - folder in here let's let's say Swift
07:37 - crash course YouTube
07:40 - and place this and and then we can close
07:42 - our xcode place the workspace in there
07:45 - and let's just double click on the
07:47 - workspace to open our xcode so now all
07:50 - the playgrounds that we're going to
07:51 - create are going to be creating inside
07:52 - that folder okay so let's go ahead and
07:55 - create our variables for a playground
07:58 - from scratch so file new file okay and
08:02 - then in here we're going to say
08:04 - playground and you can actually find
08:05 - playground a little bit lower in here I
08:07 - think as somewhere in here you can see
08:09 - in the playground section so let's say
08:12 - blank playground and let's call the
08:14 - variables okay because we're going to
08:16 - talk about variables now
08:18 - so this is the default thing that you
08:20 - can see in here and basically this is
08:22 - your view you might see A Whiter screen
08:25 - in here simply because well maybe you
08:27 - haven't changed your themes in xcode and
08:29 - that's something that you can figure out
08:30 - on your own how to change themes and
08:32 - exit we're not going to talk about that
08:33 - okay let's clear this and instead of
08:36 - importing UI kit we're going to just
08:37 - import foundation and if you're watching
08:39 - this course at home or wherever you're
08:41 - watching this on Linux for instance then
08:44 - and if you don't have a Mac OS you need
08:46 - to also do the same thing just import
08:48 - Foundation just create a simple Swift
08:50 - file you don't have to create a
08:51 - playground just click create a plain
08:54 - text Dot Swift file and then import
08:56 - Foundation library in here okay
08:59 - foreign
09:02 - foundation and Foundation includes all
09:05 - the basic as its name indicates it
09:07 - includes all the basics of what Swift
09:10 - contains really like how strings work
09:12 - how integers work all the default
09:15 - operations between these different
09:17 - variables and even optionals Etc so
09:21 - importing foundations is one of the most
09:22 - important uh things you can do basically
09:25 - in your Swift file as you're as you're
09:28 - getting to learn Swift
09:30 - okay so let's go ahead and talk about
09:34 - variables in Swift There are two
09:36 - different syntaxes or keywords for
09:38 - creating variables One is using a let
09:41 - and the other is creating a variable
09:44 - using VAR so let and VAR the difference
09:48 - between these is very confusing for some
09:51 - people and that they think that let
09:53 - creates immutability and VAR creates a
09:56 - mutability
09:57 - however the only thing different between
09:59 - these two is that a let variable cannot
10:03 - be assigned to again whereas a VAR can
10:06 - be assigned to again
10:08 - and there are some other small
10:11 - differences between them such I mean we
10:13 - will actually look at those things and
10:15 - when we're working with classes for
10:17 - instance or structures how they differ
10:19 - from each other and but for now just
10:22 - know that let's cannot be assigned to
10:24 - again and far can be assigned to a game
10:26 - but also keep in mind that there are
10:28 - some other small differences between
10:30 - them which we'll explain okay so let's
10:33 - go ahead in here and say let's my name
10:36 - and then we say equal to Lambda for
10:39 - instance and then we say let your name
10:41 - is Foo okay after you've done these and
10:44 - created these two variables you cannot
10:47 - assign to them again simply because
10:49 - there are less variables so let's say my
10:51 - name is your name and if we go down here
10:55 - at the bottom of the screen you can see
10:56 - my mouse and I'm going to hold on this
10:59 - button so I'm just going to press my
11:00 - track path and then say automatically
11:03 - run and this will just ensure that this
11:05 - playground will be automatically
11:07 - executed anytime we change anything in
11:09 - it okay you can see the error it says
11:12 - that cannot assign the value my name is
11:15 - a let constant so that's how you know
11:18 - that you cannot assign to it again after
11:20 - creating a let constant you just need to
11:23 - leave it you don't have to you you can't
11:25 - basically assign a new value to it okay
11:28 - so that's how let's works now let's go
11:32 - ahead and create a variable so for now
11:35 - we're just going to create a simple
11:36 - array and already assume that you know
11:39 - what arrays are but we're going to talk
11:41 - about collections a little bit later
11:43 - just know that in Swift you create an
11:45 - array with this syntax with square
11:47 - brackets okay so let's say VAR names is
11:51 - we're going to say Mining and your name
11:54 - okay so we just created an array in here
11:57 - and you can then see the results to the
11:59 - right hand side you can see this array
12:01 - contains van Dot and a foo okay
12:03 - now you can go ahead then and say since
12:06 - this is a variable then it can be
12:08 - mutated even internally if it contains
12:10 - for instance a structure so we say names
12:13 - and then we can call an append function
12:16 - on it and we say bar and then we can
12:18 - also add baths to it as you can see in
12:20 - here so by the end of this then our
12:23 - array called names contains found.foobar
12:26 - and bass however if you change this to a
12:29 - let you will see that we'll get some
12:31 - errors in here saying that this is a let
12:34 - constant cannot use mutating member on
12:37 - immutable value names now this goes to
12:41 - this goes a little bit deeper in how
12:44 - let's mvar are different from each other
12:46 - but in order to understand that we need
12:48 - to understand what structures are
12:51 - because arrays in Swift by default are
12:53 - structures if you're not using old
12:56 - Objective C arrays for instance so just
12:59 - know that by creating a variable array
13:02 - you can append to it and you can remove
13:04 - stuff from it for instance as we'll see
13:06 - later however if this is let you cannot
13:09 - mutate even the internal values inside
13:11 - it so you can see there are two
13:14 - mutability concepts in in Swift one is
13:17 - that you can actually mutate this array
13:19 - for instance you can say names is
13:21 - completely equal to another variable
13:23 - like the law okay
13:25 - so you can see all of a sudden it became
13:27 - blah blah bar bass you see so this is
13:30 - mutating the variable itself it is
13:33 - actually assigned a complete new array
13:36 - to names as a variable and these two
13:39 - statements are mutating what is inside
13:42 - this variable so doing a let in here
13:45 - prevents both assigning a new value to
13:48 - names and also mutating names
13:52 - however having a VAR you can assign a
13:54 - new variable two names and you can also
13:57 - mutate names internally okay so this is
14:00 - another difference between let and VAR
14:03 - so it is also very very important to
14:07 - understand these two differences
14:10 - mutation of the variable internally and
14:13 - assigning a new value to the variable to
14:16 - mutate it so a lot of developers
14:18 - struggle with that especially in the
14:20 - beginning so I completely understand if
14:22 - it is a little bit difficult to start
14:24 - with but the earlier you learn this
14:27 - concept the better because otherwise I
14:30 - think a swift can become quite difficult
14:32 - for for you to understand going forward
14:35 - so spend some time and experiment with a
14:39 - let's and VAR but we will have quite a
14:42 - lot of examples in this chapter so you
14:44 - don't have to do it on your own okay
14:47 - so
14:48 - now if you change a variable like if
14:51 - you've created a variable and you assign
14:55 - a new value to it and it won't it won't
14:58 - change the object that it originally was
15:01 - assigned to now I will explain what that
15:03 - actually means so let's say let's Foo
15:05 - let's create another space in here let's
15:07 - say Foo is foop and then we say VAR Foo
15:11 - 2 is equal to foop like this okay you
15:15 - can see now this variable of food 2
15:17 - contains the value inside Foo all right
15:20 - and you can see both of them contain the
15:22 - string Foo now if you go ahead and set
15:24 - the value of Foo 2 to for instance Foo 2
15:27 - like this you can see that Foo and futu
15:30 - still contain the values that you'd
15:33 - expect Foo contains food and food 2
15:36 - contains the new value so by assigning a
15:39 - new value to Food 2 which was previously
15:42 - equal to Foo you're not overwriting the
15:45 - value that was inside Foo simply because
15:47 - this is referring to this
15:49 - and the reasoning behind this is that
15:52 - we're working with something called
15:53 - value types now I will explain more
15:56 - value types later but all you need to
15:59 - know for now is that by assigning the
16:01 - value of Foo to Foo to we're simply
16:06 - copying this value over to futu
16:09 - so this value is being completely copied
16:12 - and you're creating a new instance of it
16:14 - inside food too so now we have two Foos
16:17 - inside memory by this point
16:20 - so we're not getting a reference so it's
16:23 - not a reference type that we're talking
16:25 - about
16:26 - Swift has value types and reference
16:28 - reference types for those of you who are
16:30 - not familiar with this concept from
16:32 - before don't worry about it I'll explain
16:33 - it more in details but for those of you
16:35 - who are familiar with this concept just
16:37 - know that
16:38 - structures which are basic basically as
16:41 - Swift string is a type of structure
16:45 - it in structures are basically value
16:47 - types and then we also have classes and
16:49 - which are reference types and we'll
16:51 - explain all of these later in the future
16:53 - but just know that by assigning a value
16:56 - that was assigned to a variable would
16:59 - let assigning it to a variable like this
17:02 - with VAR and then changing the value of
17:06 - that variable and assigning a new value
17:08 - to that variable you're not changing the
17:11 - value that was assigned to that variable
17:13 - initially I know that I mean this the
17:15 - sentence is a little bit complicated but
17:17 - I think I think you get my points in
17:19 - here what I'm trying to say okay
17:22 - now we can have a look at another
17:24 - example of this and how that looks so
17:27 - let's go ahead and say let's more names
17:29 - and let's create an array in here and
17:32 - then we say Foo and then a bar okay
17:36 - then let's let's say we create a copy of
17:38 - it we say a copy is more names and
17:41 - simply because this is a let's variable
17:44 - and also that we're working with a swift
17:47 - array which is a structure then we
17:51 - should know that structures are value
17:53 - types and assigning the value of a
17:56 - structure to another let's variable in
17:59 - here creates a copy of this entire array
18:02 - for us okay so now that we have sorry
18:05 - let's make this a copy variable
18:07 - basically let's now go and add some
18:10 - value to this cop a copied variable and
18:13 - say append and we say Bas all right and
18:16 - then we say let's get the value of more
18:18 - names and then the copy you can see more
18:21 - names in here still contains Foo and bar
18:23 - which were the original values however
18:26 - they copied the variable now contains
18:29 - bass as you can see in here so adding
18:31 - Beth to this copy did not change the
18:34 - values that were inside more names and
18:37 - this again goes back to how swift is
18:40 - working with value types in here it is
18:42 - copying over the contents of more names
18:45 - into this copy variable and changing
18:48 - this variable's internal data does not
18:51 - affect the original data which it was
18:53 - assigned to in the beginning okay so
18:56 - hopefully that makes sense by now
18:59 - now one thing that can be a little bit
19:01 - confusing for developers is when when
19:05 - they're working with let M VAR but with
19:09 - old Objective C classes all right and
19:13 - this this can be a little bit strange to
19:15 - start with like a lot of developers who
19:17 - are not so familiar with swift would say
19:19 - that let creates immutable variables so
19:22 - you cannot change them internally
19:24 - however if you're working with a let's
19:27 - variable with a let constant for
19:30 - instance in Swift however that that its
19:34 - internal value is an instance of a class
19:37 - that class can mutate internally without
19:40 - this letter variable getting in the way
19:42 - let's have a look at an example
19:45 - for those of you who are familiar with
19:47 - Objective C you know that there is a
19:50 - class inside Swift
19:52 - which is called NS mutable array now if
19:56 - you just want to learn Swift you don't
19:58 - at all need to know about this it is
20:00 - simply for those of you who are a little
20:02 - bit curious about let's and VAR okay I'm
20:05 - just going to demonstrate this to you
20:07 - but please if you're not completely
20:08 - understanding this example it is
20:10 - completely fine chances are if you're
20:12 - working with Swift and you're learning
20:14 - Swift swift UI and even if you're
20:16 - working with UI kit for instance you
20:18 - create your UI applications for iOS Mac
20:20 - OS whatever
20:21 - chances are you may not really be using
20:24 - the this uh thing that I'm gonna show
20:27 - you at all or maybe you'll use it once
20:30 - or twice in your entire career and more
20:33 - and more Swift gets modern less and less
20:34 - we're going to use these classes so but
20:37 - for those of you who are Mac Developers
20:39 - for instance you probably actually work
20:40 - with NS Mutual array perhaps often okay
20:43 - if you especially if you have an old
20:45 - code base
20:46 - so let's create a constant in here where
20:49 - we say let's old array and we create an
20:52 - NS mutable array in here okay
20:55 - and then in here we say that the value
20:58 - is an array okay and then we say the
21:01 - array contains the values of Foo and bar
21:04 - like this okay then you can see in here
21:07 - that Swift playground says old array as
21:09 - Foo and bar right and you see oh this is
21:13 - let so we cannot change its internal
21:15 - values because if you for instance have
21:18 - a look at this one an array again okay
21:21 - which is created with let if you say
21:23 - more names and you say append and you
21:26 - say hello you will see that you will get
21:28 - an error in here it will tell you that
21:30 - you cannot append to this variable
21:32 - because it's created with a let
21:34 - statement or a let's syntax okay over in
21:37 - here since we're creating a let's old
21:39 - array that is equal to a class instance
21:42 - which is not a structure and again I
21:44 - completely understand that we haven't
21:45 - talked about classes and structures yet
21:47 - but just know that this is not and this
21:50 - is basic as its name indicates it is
21:52 - mutable internally it can be changed
21:54 - whether it is assigned to a let or a VAR
21:57 - it doesn't make any difference it is a
21:59 - class whereas this is a structure okay
22:02 - and structures are value types and
22:04 - classes are reference types okay so just
22:07 - know that for now that this is indeed
22:09 - mutable even if it is assigned to LED
22:12 - variable okay so now all of a sudden you
22:14 - can say old array and then you can say
22:16 - add and let's say baz
22:19 - all right and now you can see Swift
22:20 - playgrounds runs this code and tells you
22:22 - that indeed your let's constant what you
22:25 - thought was constant has changed
22:26 - internally all right now you can go
22:29 - ahead and create a new verbal and we say
22:30 - new array is old array
22:33 - and if you say new array
22:35 - add
22:37 - q u x in here Cox okay and then we say
22:40 - old array and we say new array
22:43 - now you can see the results in here
22:45 - since new array got the value of old
22:48 - array
22:49 - you add a new value to this new array
22:51 - and you'd expect probably for new array
22:54 - only to change not for old array to be
22:57 - affected however you can see the result
22:58 - that both old array and new array are
23:01 - actually referring to the exact same
23:03 - array so this can cause a lot of
23:05 - confusion for developers who are for
23:07 - instance new to Swift thinking that oh I
23:09 - just created a let immutable variable no
23:12 - one can change this however you can see
23:14 - that it got changed and even worse you
23:17 - can as if if you pass this value for
23:19 - instance to a function
23:21 - and that function itself can also change
23:23 - this variable so it is quite dangerous
23:25 - just by using let it's not that we're
23:28 - completely getting rid of mutability in
23:31 - Swift so a lot of things can go wrong
23:34 - especially if you're using reference
23:36 - reference types such as nsmutable array
23:39 - but don't worry about it I mean if if
23:40 - this is a little bit alien at the moment
23:42 - I will explain this a lot more in
23:44 - details later okay
23:46 - as I mentioned be very careful when
23:48 - you're working with mutable types in
23:50 - Swift and when you're passing them for
23:53 - instance to functions because those
23:56 - functions can actually change your
23:59 - mutable types even if they say they
24:01 - don't okay so let's have a look at this
24:03 - let's say we create another array in
24:06 - here let's let's copy this and I'm going
24:09 - to say let's some names and then we say
24:12 - Foo and bar okay so that's fine let's
24:16 - create a function and I completely
24:17 - understand we haven't talked about
24:18 - functions yet but this is this syntax of
24:21 - what functions look like in Swift so we
24:23 - say funk change the array and then we
24:26 - have an argument call array and in here
24:28 - we say NS array okay now I'll explain to
24:31 - you what nsra is nsra is the um and it's
24:35 - mutable array is the mutable
24:37 - variant of nsra and if you actually go
24:41 - to the source code for NS mutable array
24:43 - let's say in its Mutual array
24:45 - you can see that it's subclasses nsra so
24:48 - anywhere you have an NS Mutual array and
24:51 - sorry anywhere your function or call
24:54 - expect and NS array you can actually
24:56 - pass an instance of NS Mutual array to
24:58 - its because it will just work it will be
25:00 - downgraded to ns3 okay
25:02 - so let's say that we look at this
25:04 - function and this function just looks
25:05 - like it is working with an immutable
25:08 - array in here however internally it can
25:11 - say let's let's just say copy as array
25:14 - as in its mutable array so this is a
25:18 - syntax in Swift that you shouldn't
25:19 - really use that often but code can
25:22 - actually do that without without getting
25:24 - bugged by Swift really okay so you can
25:27 - see in here we're saying we're creating
25:29 - a copy
25:31 - uh oh a rage array like this where we're
25:36 - basically creating a variable that is
25:38 - called copy however it's not really
25:39 - copying the instance it's just named
25:41 - copy so maybe we could just call it
25:44 - array2 or something or just copy but uh
25:47 - just know that it is really not copying
25:49 - the value inside this or it is just
25:52 - assigning it to this variable and but it
25:55 - is setting its data type it's promoting
25:57 - its data type to immutable data type
26:00 - it's assuming that it is mutable okay
26:02 - it's this is really bad code you should
26:04 - never write stuff like this okay but I'm
26:07 - just demonstrating that it is possible
26:09 - to write code like this and you should
26:10 - kind of guard yourself against code like
26:12 - this and then in here we say copy dot
26:15 - add Mass okay now if you pass if you
26:19 - call this function change the array with
26:22 - your Mutual array everything will just
26:23 - work as expected some names
26:26 - and then you can say some names and have
26:28 - a look at the data
26:30 - now when this code is run you can see in
26:33 - this scope some names after being passed
26:36 - to change the array has actually been
26:38 - internally mutated you can see Foo bar
26:41 - and pass so this pass that this function
26:43 - added to this array is actually present
26:46 - outside that function as well simply
26:48 - because we're working again with
26:49 - reference types meaning that there's one
26:51 - copy of this in the memory and this
26:53 - function is actually changing the
26:54 - original copy okay
26:56 - so that was really uh it that's what I
27:00 - wanted to explain in this particular
27:01 - section of the video with variables and
27:05 - uh constants so just know that you have
27:07 - let and you have VAR and let it if
27:12 - working with value types such as
27:14 - structures of Swift arrays or strings or
27:17 - integers it prevents immutability of
27:21 - that value internally meaning that you
27:24 - can't change this van dot to for
27:25 - instance say and my name my name
27:29 - uh and then you can say
27:33 - is equal to actually my name make
27:36 - uppercase you can't do stuff like this
27:38 - so you cannot and like change the value
27:40 - that is assigned to this and you can't
27:43 - reassign a value to my name after it has
27:47 - been created okay so the reassigning
27:50 - that you cannot reassign a value to a
27:52 - let constant applies to both reference
27:55 - types and and value type so it doesn't
27:58 - matter if if the value inside this let
28:01 - constant is a string or it's an instance
28:04 - of a class as long as it's let you can't
28:07 - assign a new value to it for instance
28:09 - let's say here is you can see it is a
28:12 - sum names it is an instance of a class
28:14 - which is a reference type However the
28:17 - fact that you cannot reassign a value to
28:20 - this still holds true whether it is
28:22 - holding an instance of a class or an
28:25 - instance of a structure so let's say
28:27 - some names is blah in here now we should
28:31 - get an error in here saying that you
28:33 - cannot reassign another value to this
28:36 - after you have created it so this
28:39 - reassigning to a let constant applies
28:42 - both to reference types and value types
28:44 - however the internal mutability of a
28:49 - let's constant only applies the
28:52 - prevention of internal mutability of a
28:56 - let constant only applies to Value types
28:58 - such as structures if you've assigned a
29:01 - class to a let constant the class might
29:04 - internally change without Swift actually
29:06 - complaining at all okay so I completely
29:09 - understand is a little bit complicated
29:11 - and I personally believe that some other
29:13 - personal languages have implemented this
29:15 - a little bit more beautifully and a
29:16 - little more like fluid such as rust
29:20 - can I have some courses actually about
29:22 - rust as well so you can watch my Ross
29:24 - crash course for instance on YouTube and
29:26 - learn about mutability and rust as well
29:28 - but I I believe that Russ has
29:30 - implemented mutably a bit nicer than
29:33 - Swift and because Swift can cause some
29:35 - confusion in how it handles and mutable
29:38 - values but for now just know these
29:40 - simple rules and then we can move on to
29:43 - the next section of this video
29:46 - all right now that we've talked enough
29:48 - about variables let's move on to another
29:50 - concept which is very very important to
29:53 - learn in any programming language that
29:54 - you're learning at the moment and those
29:56 - are or that is operators so operators
29:59 - are small functions that are a little
30:02 - bit special in how they're declared and
30:05 - Swift treats them as such it treats them
30:08 - a little bit more special than other
30:10 - functions so and let's have a look at
30:12 - what operators are but before doing that
30:14 - let's create a simple playground for
30:16 - operators so let's say go let's say file
30:18 - new and we say file if we can find it oh
30:21 - we can't because we can't create a file
30:23 - inside this so let's be in here inside
30:26 - our editor and I'm going to say command
30:28 - n and then I'm going to go ahead and
30:30 - create a playground in here let's say
30:32 - blank playground and then we're going to
30:35 - say operators but be very careful
30:37 - because by default so if playgrounds or
30:40 - xcode actually tries to create this
30:42 - playground inside another playground and
30:44 - that is horrible it is really off full
30:46 - and just please just use the main folder
30:50 - to create your playground and also add
30:52 - it to the main
30:54 - xcode workspace structure as well in
30:57 - here so let's say create
30:59 - now we have operators and let's do the
31:01 - same thing in here I want to say import
31:03 - Foundation okay
31:05 - after doing this let's start talking
31:07 - about
31:08 - operators so let's create two constants
31:11 - in here let's say my age and we say 22
31:14 - and we say let your age is 20 okay
31:17 - now let's work with our first two
31:20 - operators and those are the greater than
31:22 - and less than operators if you have two
31:24 - integers like this and I kind of expect
31:26 - you to already know what an integer is
31:28 - from other program language perhaps that
31:30 - you already know then we say if my age
31:33 - then once you have two integers you can
31:35 - use this particular operator that you
31:38 - can see it says greater than so the left
31:40 - side should be greater than the right
31:42 - side your age and your age and this is
31:46 - an if statement okay which I kind of
31:49 - already actually I kind of expect you to
31:51 - already know what if statements are so
31:54 - you can see now we're using an if
31:56 - statement and then and putting our left
31:59 - hand side and right hand side variables
32:01 - in here and using operator which is
32:03 - having this kind of a syntax so what
32:06 - this operator is doing is comparing the
32:09 - value to the left with the value to the
32:10 - right and it Returns the value of true
32:12 - if the value to the left is indeed
32:15 - greater than the value to the right okay
32:17 - and here then we can say I'm older than
32:20 - you okay and then we say else if my H is
32:25 - less than your H so this is another
32:27 - operator that works between integers for
32:30 - instance that says it will I will return
32:32 - true if the value to the left is less
32:34 - than the value to the right then in here
32:37 - we say I'm younger than you and else oh
32:42 - hey we are the same age okay so if I'm
32:45 - not older than you and I'm not younger
32:47 - than you then we should be the same age
32:49 - logically all right you can see nothing
32:51 - is happening in this playground because
32:53 - we don't have automatic running so I'm
32:55 - just gonna hold my trackpad on this
32:56 - button and then I'm gonna say
32:57 - automatically run and then you can see
33:00 - that our code is going to run in here
33:02 - and the value basically we got into this
33:05 - branch of our if statement I'm older
33:07 - than you simply because this operator
33:08 - indicated to Swift that the value to the
33:11 - left is indeed uh larger than the value
33:14 - to the right return the value of true
33:16 - and then Swift fell into this if
33:19 - statement so that's these two are the
33:22 - first operators that we're seeing in
33:24 - Swift basically however I mean there are
33:26 - some other very special operators such
33:28 - as the equal operator that we're seeing
33:30 - in here but we shouldn't really go ahead
33:32 - and explaining that we're simply
33:34 - assigning a value to a variable in here
33:36 - with that operator okay
33:38 - now there are other operators such as
33:40 - Plus for instance let's say let my
33:43 - mother's age is my age plus 30. so this
33:46 - is a an operator that is operating
33:49 - between two integers I can from the left
33:51 - hand side and a right hand side so it
33:53 - simply takes
33:54 - the value to the left and adds the value
33:56 - to the right to it and then returns that
33:59 - result to us okay
34:01 - so that's another operator that we're
34:04 - seeing in here the plus operator you can
34:06 - also of course use for instance the
34:09 - multiplication operator and we can say
34:11 - let's double
34:12 - and double my age is my H and you say
34:16 - times two and as you can see this is an
34:19 - operator that is sitting between two
34:21 - integers again it takes the integer to
34:22 - the left and and multiplies it by the
34:25 - integer to the right and Returns the
34:27 - value and which then gets assigned to
34:30 - this variable you can see it's 44. if
34:32 - you remember the age was set to 22 times
34:35 - 2 is 44.
34:37 - so you've probably now seen a few
34:40 - operators in here and you're wondering
34:42 - okay how many different types of
34:44 - operators are there and there are three
34:46 - different types of operators in Swift
34:48 - and I mean not I'm not counting these
34:53 - operators I'm just talking about three
34:55 - different types of operators okay
34:58 - the first one is called a unary prefix
35:01 - the second one is called a unary postfix
35:05 - and the third one is called a binary
35:08 - infix okay so when we're talking about
35:11 - unary as you remember let's actually
35:13 - write them down let's just say uh one is
35:16 - unary urinary prefix the second one is
35:21 - urinary postfix and then the third one
35:24 - is binary infix okay
35:27 - wherever you're seeing unary just know
35:29 - that this thing is working with only one
35:31 - value again working with one value and
35:34 - binary is working with two values okay
35:36 - so you can now imagine that this
35:38 - operator the multiplication operator
35:40 - that is working with two values is
35:42 - indeed a binary in fix it is binary
35:45 - because it's working with two values the
35:47 - left and the right hand side and it is
35:49 - an infix operator because it's sitting
35:51 - in between so infix in between okay it's
35:55 - sitting in between two other values so
35:58 - all the operators that we've seen so far
36:00 - the greater than or less than
36:03 - basically addition and multiple
36:05 - multiplication are binary infix
36:08 - operators we haven't seen a unary and Sr
36:12 - unary prefix and unitary postfix so
36:14 - let's have a look at unary prefix as
36:17 - you'd expect unary Works only with one
36:20 - value so let's say let's Foo is true so
36:24 - this is just assigning the value of true
36:25 - to Foo however if you want to change the
36:28 - value of this true to false and you want
36:30 - to flip it basically you use this
36:33 - operator in here which is the apostrophe
36:35 - operator which is a unary prefix
36:38 - operator that takes the value to its
36:41 - right hand side and basically
36:43 - um negates it okay so you can see in
36:46 - here true became false simply like that
36:48 - so this is a unary prefix it's prefix
36:51 - because it's before the value that comes
36:54 - right after it okay
36:56 - then we have a urinary post fix so a
37:00 - unary postfix offer is a little bit
37:02 - special I mean in all my years of
37:04 - working with swift I've been working
37:05 - with swift since summer of 2014. it is
37:09 - very very seldom that you create your
37:12 - own post-fix operator and you want to
37:14 - read postfix There are some unitary
37:16 - postfix operators already it's built
37:18 - into Swift but and you use them perhaps
37:21 - quite a lot however creating your own
37:23 - postfix uh unary postsex operator is
37:26 - something that you do very very seldom
37:29 - okay
37:30 - let's have a look at a unary postfix
37:32 - operator let's say name
37:34 - and I'm just going to create an optional
37:36 - value now I know we haven't talked about
37:38 - optionals but just for the purpose of
37:41 - demonstrating what a unary postfix
37:43 - operator is let's go ahead and write
37:45 - this syntax let's say optional and then
37:47 - we say rendered okay
37:49 - now if you want to grab the value that
37:51 - is inside this variable and unwrap it we
37:55 - say let unary
37:57 - postfix is equal to name and then we put
38:00 - this apostrophe after this name now just
38:04 - know for now that what the what we did
38:06 - in here is that we put an optional value
38:09 - into a variable call name an optional
38:11 - simply means that this name can either
38:13 - contain null values or it can contain a
38:16 - value that's what optionality in Swift
38:17 - means but I've prepared a completely
38:20 - separate playground for optionals which
38:22 - we're going to talk about a little bit
38:23 - later however this you can see now it
38:26 - goes ahead into this optional value and
38:29 - grabs the internal value and assigns it
38:31 - to this okay so let's say if we inherit
38:35 - say type of name and then we can type of
38:38 - unary postfix now they have two
38:41 - different types you can see the type of
38:43 - this variable is an optional string and
38:46 - the type of this variable is indeed a
38:48 - string so this unary postfix operator
38:52 - went inside this optional and grabbed
38:55 - its value out and forced it out and
38:58 - assign it to the variable to the left
39:00 - hand side basically using the assign
39:01 - assignments operator
39:03 - so this is a unary postfix operator it
39:07 - comes after a variable and it works only
39:09 - with one variable so it doesn't have a
39:12 - variable here and a variable there it is
39:15 - only working with the Val and the
39:16 - variable to its left hand side okay
39:18 - prefix unary prefix works with the value
39:21 - after it post or postfix works with the
39:25 - value before it okay so that's the
39:28 - second example basically for unary
39:30 - postfix
39:32 - now for the last type of operator which
39:36 - is the most common type and we call them
39:37 - binary infix simply because they work
39:40 - with two values hence the name binary
39:43 - and also infix simply because they sit
39:45 - in between the values that they work on
39:48 - okay so let's say a result is one plus
39:52 - two and this is a simple example of a
39:55 - binary infix operator you can see it's
39:57 - working with two values and sits in
39:59 - between them okay
40:01 - and other another example is let's say
40:03 - let names is equal to Foo
40:06 - and then we say plus empty space plus
40:08 - bar and this is another
40:11 - um
40:12 - infix binary
40:14 - operator that is sitting between two
40:16 - strings you can see you may be a little
40:18 - bit confusing you can say oh but if this
40:20 - is sitting between these two strings
40:23 - what is this sitting in between is it a
40:25 - prefix operator well it is not what is
40:28 - happening here is that Swift is
40:30 - executing this code from the left hand
40:32 - side because there is no parenthesis
40:33 - then it says okay Foo plus empty space
40:37 - becomes Foo plus like empty space like
40:40 - this and then takes this plus and uses
40:43 - it in between the result of the previous
40:45 - statement and Bar
40:47 - okay so that's what is happening inside
40:50 - this code basically
40:52 - okay so that was an example of a binary
40:54 - infix operator and as I mentioned most
40:56 - operators that you use in Swift are
40:58 - going to be binary and fix there are
41:00 - quite a lot of actually other operators
41:02 - as well but we don't use them so often
41:04 - okay depends again also on your code
41:07 - base
41:08 - now there is another category of
41:11 - operators and which is called a ternary
41:14 - operator okay and ternary is something
41:16 - that is a kind of a Hot Topic in any
41:19 - programming language that supports
41:20 - ternary simply because it can be misused
41:23 - and it can cause your code to look very
41:26 - very difficult to read actually so
41:29 - um what I suggest oops what I think is a
41:33 - good idea is always a check with your uh
41:36 - with your teammates who are working with
41:39 - your colleagues basically in your team
41:41 - and ask them if if they're comfortable
41:43 - with ternary and if they're if there are
41:46 - what are the
41:48 - um what are the boundaries that they
41:49 - that they feel comfortable using ternary
41:52 - operators within ternary can become very
41:55 - complicated especially if you're nesting
41:57 - them if you're using a ternary inside
41:58 - iternary and it's just good to check
42:02 - with people what they're comfortable
42:03 - with okay but let's just have a look at
42:05 - a ternary operator let's say let's a H
42:09 - is 30. now let's say that you want to
42:12 - display a message to the user saying
42:15 - that let's message and then you want to
42:18 - say if the age is over or equal to 18
42:22 - then this message should say you are an
42:26 - adult however if the age is less than 18
42:30 - then you should say you are not yet an
42:33 - adult
42:34 - how do you do this well what you could
42:36 - do is to say let's message is a string
42:39 - okay
42:40 - uh and then you could say if
42:45 - H is more than or equal to 18 then
42:49 - message is you are an adult
42:52 - otherwise message as you are not yet an
42:57 - adult so this works actually very well
42:59 - and you can type the message out you can
43:01 - see now it says you are not all simply
43:03 - because the H is 30 or if you were 16 it
43:06 - would say you are not an adult yet or
43:09 - you're not yet an adult
43:11 - however there's another way of writing
43:13 - the same exact code so let's just
43:15 - comment this out okay and that is using
43:18 - the ternary operator so in here you can
43:20 - see we've defined our variable first and
43:22 - then we're going using an if statement
43:24 - and an else statement and then assigning
43:25 - values to that variable okay however you
43:28 - can also say let's message is then you
43:31 - would put your condition in here you say
43:35 - condition
43:36 - okay
43:37 - and then the format is then you put a
43:40 - question mark then you say value if
43:43 - condition
43:44 - is met
43:46 - and then so let's put this to the next
43:48 - line and then a colon in here and value
43:53 - if the condition is not met
43:57 - so this is the format of a ternary
43:59 - operator first you put your condition in
44:01 - here so what is the condition so if the
44:04 - age is more than or equal to 18 so just
44:07 - let's just write it age should be more
44:09 - than or equal to 18. then we say that
44:12 - the value should be you are an adult
44:15 - then the value if the condition is not
44:17 - bad is you are not yet an adult and that
44:21 - is exactly how you write a ternary
44:24 - operator so you say you take your
44:27 - variable that you want to actually
44:28 - calculate the value of then you say it's
44:30 - equal to then you put the condition of
44:33 - your ternary operator and then a
44:35 - question mark after a question mark
44:36 - follows the value that you want to
44:38 - assign to your variable
44:39 - should the condition be met and then a
44:43 - colon and the value that you want to
44:45 - assign to the variable should the
44:46 - condition not have been met okay and you
44:48 - can see now the messages you are an
44:50 - adult and if you change this value again
44:52 - to 17 you can see the value will be
44:54 - changed to you're not yet an adult okay
44:58 - so
44:59 - I hope that you've now got an idea of
45:02 - some operators in Swift you've we've had
45:05 - a look at different types of operators
45:07 - in unary prefix unary postfix we have
45:11 - binary infix and we've also looked at a
45:14 - fourth category of operators which are
45:17 - ternary operators and again just be a
45:20 - little bit careful with ternary
45:21 - operators because not a lot of
45:22 - developers are actually very comfortable
45:24 - using these I met I personally like
45:28 - ternary especially like in these cases
45:30 - where is less code is understandable
45:33 - it's compact is not so much logic
45:36 - however some developers just write them
45:38 - all in one line like this and that can
45:41 - be a little bit difficult to read I I
45:43 - actually agree my uh habits in Swift is
45:48 - to manually
45:49 - break my code down into smaller bits and
45:52 - pieces like this into different lines as
45:54 - well
45:55 - unfortunately unlike some other
45:57 - programming languages like rust and dart
45:59 - and there is no internal analyzer as
46:02 - such sorry there are no formatter so
46:05 - Swift Code you need to format it by hand
46:08 - unfortunately and it has been
46:10 - eight years since Swift's come out and
46:13 - there is still no internal formatter for
46:15 - Swift of course you can select your code
46:18 - and then indent your code with Ctrl I in
46:22 - xcode
46:23 - but you cannot have xcode format of your
46:26 - code for you as you type so that is a
46:29 - little bit of an unfortunate problem
46:32 - that we have to deal with but it is what
46:35 - it is and we can just get used to it so
46:37 - if you want to make your code a little
46:38 - bit more readable I suggest that you
46:40 - format it a little bit by hand so kind
46:42 - of handcrafted as well okay
46:45 - that was really it for the operators so
46:48 - in the next section we're gonna look at
46:51 - if an else statement so see you there
46:54 - now that we're done with operators let's
46:57 - go ahead and create a new playground or
46:59 - if and else so right here I'm going to
47:02 - press command n
47:04 - on MacIntosh and let's say playground in
47:06 - here oops if I can spell it and a blank
47:09 - playground
47:11 - and let's just call it if
47:13 - else
47:14 - and please just ensure that you're not
47:16 - creating it
47:17 - inside an existing playground you can
47:19 - see in here it's called operators and we
47:21 - should change that to be inside our main
47:24 - folder basically okay and then we say it
47:27 - shouldn't be inside the operators group
47:29 - either it should be inside the group op
47:31 - ARP workspace so create now we can
47:35 - collapse the other ones and in here just
47:37 - like normal we say foundation not like
47:39 - normal actually like usual I meant to
47:42 - say
47:43 - so let's talk about if and else
47:45 - statements we've already seen a few
47:46 - examples of if and else and if you've
47:48 - already done programming in another
47:51 - programming language you should already
47:52 - be familiar with what if and else
47:55 - statements are so it's just a
47:56 - conditional basically okay let's add a
47:59 - few values in here so I'm just going to
48:01 - copy and paste some values and place
48:03 - them in here so some seed values that we
48:05 - can work with Okay let's create a simple
48:08 - if statement and then if sorry an if an
48:11 - else statement so we say if my name is
48:14 - equal equal valid so in here
48:17 - so like this and so this is using a
48:21 - lowercase v as you can see in here okay
48:23 - then we say your name is and then we're
48:26 - going to add our variable within a
48:29 - string and this is how you do it in so
48:30 - if you say back backslash and then
48:33 - parenthesis and then you say my name in
48:35 - here okay
48:37 - then in here we can say else and with no
48:40 - conditions in front of it and then we
48:41 - say oops
48:43 - I guessed I guessed it wrong like this
48:47 - and then let's do an automatic run for
48:50 - our playground and we should now come to
48:52 - the oops part because we guessed the
48:54 - name incorrectly with a lowercase v as
48:57 - you can see in here so this is a simple
48:58 - if statement so you compare something
49:00 - with uh with something else and then you
49:03 - can have an else block or not you can
49:05 - actually just have an if statement as
49:07 - well so you don't have to have an else
49:09 - Block in Swift okay
49:11 - now you're not limited in you're not
49:14 - limited only to one else statement you
49:16 - can't have else if as well okay so let's
49:20 - just say if
49:22 - my name my name is equal equal land up
49:25 - with the proper spelling as well with a
49:28 - capital V then we say now I guessed it
49:31 - correctly okay
49:33 - and then we say else if
49:36 - my name
49:37 - is Foo now you can see that we have
49:40 - another Branch so we have an if and then
49:42 - if that case is not met then the program
49:46 - will fall into this statement so it's
49:48 - very important to understand that it's
49:49 - not that Swift is executing both of
49:51 - these concurrently it's executing the
49:54 - first one first if that condition is met
49:56 - then Swift goes in here and ignores
49:58 - everything all the other statements
50:00 - inside the if statements so all the
50:02 - other else ifs and the last L statement
50:05 - if it is available so it's just
50:08 - branching basically okay
50:10 - so if my name is Foo as we say are you
50:13 - Foo and this doesn't really matter what
50:15 - you type in here I'm just trying to
50:17 - demonstrate how if and else if basically
50:19 - statements work in Swift and then we can
50:21 - have a final else statement in here and
50:23 - says okay I give up okay
50:26 - and you can see that Swift has gone into
50:29 - this Branch because name was correctly
50:32 - set to Van Dot and we're comparing it
50:34 - with vandan sorry it wasn't set to Vanda
50:37 - I mean it was set in here but we're
50:38 - actually comparing it correctly with the
50:40 - correct value in here okay and some
50:43 - people write their if statements a
50:45 - little bit more in like what I call a
50:47 - flipped way and here you can see we're
50:49 - saying if my name is equal to Vandal and
50:52 - so if you're reading it like you would
50:53 - read an English sentence I would say if
50:55 - my name is equal to valid however some
50:58 - people actually do it in the opposite
51:00 - way like this they would say if van dot
51:03 - is equal to mining so this is another
51:07 - way of writing it an uncommon way of
51:10 - doing this and a lot of old and like a
51:13 - little bit old school developers would
51:14 - do stuff like this it is not so common
51:17 - in all my years of working as a software
51:20 - engineer I've seen one or two people
51:22 - preferring this however
51:24 - me and my colleagues have been able to
51:26 - convince them otherwise that this is
51:29 - this we shouldn't do this in most modern
51:31 - Source codes don't do this however you
51:34 - may be an exception in so maybe you're
51:36 - working at a company where this is the
51:38 - prevalent way of doing if statements in
51:41 - that you actually put the value and that
51:43 - you and are testing
51:46 - um last and then you compare with the
51:49 - value and that you're expecting first as
51:52 - I said this is a little bit uncommon in
51:54 - my experience but maybe at the company
51:56 - that you are you and your teammates have
51:58 - decided that this is the way to do it it
52:00 - is completely equal to this it is the
52:04 - same thing as this code and I mean what
52:07 - it achieves is the same however the
52:09 - syntax is a little bit different okay so
52:11 - it is up to you and your teammates to
52:13 - decide what which way to do however
52:17 - if you're new to Swift I beg you to
52:20 - please don't do this and it is this way
52:24 - that you should learn how to write your
52:26 - if statements so please don't flip these
52:29 - values however if you're a seasoned
52:31 - developer and you know exactly what
52:33 - you're doing and you and your teammates
52:35 - have decided that in your code base all
52:38 - your if statements should be written
52:39 - like this or in just a few exception
52:42 - cases you write your code like this as
52:44 - long as you've checked with your team is
52:46 - and everything is fine then you go ahead
52:47 - and do it but if you're learning Swift
52:49 - just now this is the way to write an if
52:52 - statement okay and this is the way that
52:54 - almost everyone writes their if
52:56 - statements seasoned or not seasoned
52:59 - good so that was simple these are some
53:03 - simple if statements basically comparing
53:05 - a value with another value but what if
53:07 - you are having a little bit more
53:09 - complicated logic in here
53:11 - so let's say that you want to make sure
53:13 - that your name is found out and that
53:15 - your age is also 30. so you can see the
53:18 - age is defined in here as 20. let's just
53:20 - go ahead and compare it with 30 instead
53:22 - let's say if my name
53:24 - and in here if you want to compare also
53:27 - the age you can say and
53:30 - my age is 30 for instance okay then we
53:33 - say name is landlord and age is 30. then
53:36 - we say else if a my age is 20 then we
53:40 - say I only guess the age right and then
53:44 - an else statement in here we can say I
53:47 - don't
53:48 - know what I'm doing okay so as you'd
53:51 - expect now we're going to go into this
53:53 - line of code so what's happening here is
53:55 - that Swift started executing this code
53:57 - from left to right and I said okay from
53:59 - left the name is truly vandot and it
54:03 - started comparing the age and that says
54:05 - age is indeed 20 is not 30 so I'm not
54:09 - going to go into this if statement so it
54:11 - ignores this if then it looks at the
54:13 - code that follows this if statement and
54:15 - says oh it's an else otherwise if the
54:18 - age is 20 is the age 20 yes it is then
54:21 - it falls into this statement and then
54:23 - ignores the rest of the else
54:26 - so you need to think of if statements as
54:28 - in branches and they get executed
54:31 - separately not concurrently and they're
54:34 - basically in a Serial order from the
54:37 - first statement if it fails goes to the
54:40 - next statement then goes to the next
54:41 - statement if any of these statements
54:44 - succeed in trapping the logic so this
54:47 - one trapped and said okay if the age is
54:49 - 20 and in it is indeed then the code
54:53 - goes in here if any of these else
54:55 - statements or if statements do that the
54:58 - entire rest of this code is then ignored
55:01 - so this didn't fall into so this we
55:04 - didn't fall into this we did fall into
55:06 - this and then the rest is completely
55:08 - ignored regardless of how many else's
55:11 - you have in here you can say else if
55:13 - blah blah and then another else after
55:15 - that but all of those will be ignored
55:17 - okay
55:19 - now just like we have the an operator in
55:21 - here the logical and operator we also
55:23 - have the or operator okay but you need
55:27 - to be careful with it because you can
55:29 - actually make the code and do things
55:32 - that you didn't want it to do so let me
55:34 - just explain something in here
55:36 - so let's write an example let's say if
55:40 - my H is 20 not 200 or my name is Foo
55:47 - then we say either age is 20 name is Foo
55:52 - or both
55:54 - so what happening here is that you can
55:57 - see we say you may be reading this
55:59 - saying either the age is 20 or the name
56:01 - is Foo but what Swift does reading here
56:04 - says either the name at the age is 20 or
56:07 - the name is who or both of these so even
56:10 - if both of these are true then this code
56:13 - is executed and the reason behind that
56:15 - is that if your age is 20 then the code
56:19 - actually comes here just by default it
56:22 - doesn't even execute the rest
56:24 - okay so that is the reason that if age
56:27 - is 20 your name might indeed be Foo and
56:31 - that is what you've written in here but
56:32 - the code has already fallen into this
56:34 - simply because the first part of the
56:36 - condition was met so Swift doesn't even
56:39 - execute this part it says oh ages 20 of
56:41 - course let's go in here okay simply
56:44 - because Swift looks at the statement app
56:45 - versus oh said or so I don't have to
56:48 - execute it simply because I already know
56:50 - that my age is 20 so it falls here okay
56:53 - so it can be either this part this one
56:57 - or both
56:59 - animistics and developers make is they
57:01 - think that they can add another else
57:03 - Block in here and that else block will
57:06 - be executed as well and that is not the
57:10 - case because as I've explained it before
57:11 - if statements are zero and they get
57:14 - executed one at a time if any of them
57:17 - traps the
57:19 - um the execution of the program meaning
57:22 - that it actually results to the compiler
57:25 - understanding that oh this branch of
57:27 - code should be executed then the rest
57:28 - will be ignored so if in here you type
57:31 - else if my name is Van dot even if your
57:34 - condition is met which in this case is
57:36 - because my name is truly vandad or my
57:40 - age is 30 I started 20 which it was set
57:43 - up here if you remember
57:45 - my name and my age were van dot and20
57:48 - respectively this code will not be
57:51 - executed so let's say it's too late to
57:54 - get in this class you can see that it
57:56 - won't be executed it won't be displayed
57:58 - in here only this branch is executed
57:59 - simply because my age was 20. okay and I
58:02 - can change it actually to Foo and you
58:04 - can see it still gets here first because
58:07 - my age is 20 and the operator after that
58:10 - is a logical or meaning that oh if this
58:13 - or this or both and it's since this one
58:16 - is true it doesn't even have to execute
58:18 - this okay
58:20 - so
58:21 - as I mentioned yeah or can actually or
58:25 - an and logical operators they can get
58:28 - quite complicated in that if you're if
58:30 - you're working with these operators and
58:33 - also parenthesis then you could create
58:36 - kind of confusing code as well and if
58:40 - you actually don't use parenthesis
58:42 - sometimes your logic could be completely
58:44 - incorrect let me just show you an
58:46 - example
58:47 - let's write a coding here and we say if
58:49 - my name is landlord
58:52 - and then we go to the next line and we
58:54 - say and my age is 22.
58:59 - okay
59:00 - then we go to the next line and your
59:03 - name is Foo and remember
59:06 - my name is my age is 20. your name is
59:10 - Foo at your age is 19. okay then here
59:13 - we're saying your name is who and we
59:15 - know that that is true in fact
59:18 - or your age
59:21 - is 19. okay so we say and what is this
59:25 - code actually doing so we say my name is
59:27 - Found Love
59:29 - and I'm 22 and your name is Foo
59:33 - Foo
59:35 - or
59:37 - you are 19. do you see what happening
59:40 - here so what happened was that and you
59:42 - can see that this message actually is
59:44 - printed here in our playground meaning
59:46 - that the code did fall into this as into
59:49 - this execution Branch so what happened
59:51 - you can say that my name is Vanda and my
59:54 - age is 22 but you can say well your age
59:57 - is not 22. how did this code come here
60:00 - and the reason is because we're mixing
60:02 - ands and ores and you can see what what
60:05 - Swift reads in here says okay if your
60:08 - name is Van Dot
60:10 - and your age is 22.
60:13 - and your name is Foo is this true then
60:17 - looks at all these ants this is yeah
60:19 - your name is but your age is not 22.
60:22 - then it looks at the rest that it could
60:24 - and says do I have any other logic to
60:26 - follow and it says yes actually you've
60:28 - written it here either these
60:31 - or that your age should be 19 and it
60:34 - looks at your age so uh Yes actually
60:36 - your age is 19. so you can see how this
60:39 - could be confusing for you reading this
60:41 - you may think oh your name should be
60:43 - vandot and your age should be 22 and
60:46 - your name should be Foo or your age
60:48 - should be 90 so you may think that this
60:50 - part is executed separately and this
60:52 - part is separate but since there's no
60:54 - parenthesis between these Swift reads it
60:56 - from left to right and then there's no
60:59 - uh precedence between the ands and ores
61:03 - so they have the same precedence so it
61:05 - says okay this entire thing is the same
61:07 - precedence and I just execute it from
61:09 - left to right
61:10 - and this or at the end basically traps
61:13 - the execution branch and ensures that
61:16 - the code falls into the if statement
61:17 - okay so writing code like this could be
61:20 - a little bit confusing what you might
61:23 - have wanted to write is this instead
61:26 - you probably wanted to say if and then
61:29 - parenthesis okay
61:31 - and then this is your own logic so you
61:34 - want to basically check your name and
61:35 - age so let's put it inside parenthesis
61:37 - so we say my name is founded
61:40 - and let's go to the next slide and
61:45 - my age should be 22 so you're basically
61:48 - saying and so you say my name is Vandal
61:52 - and my http 22. then you go to the next
61:55 - line and you say and and another
61:58 - parenthesis your name
62:00 - is Foo
62:02 - or your age is 19. like this okay so
62:08 - what is happening in here is uh and I
62:12 - can see our playground has some problem
62:14 - so what this really equates to I mean if
62:17 - you want to read it in English you could
62:19 - say my name is founded and I'm 22.
62:23 - and
62:25 - your name is Foo
62:28 - or you are 19. so do you see how this is
62:32 - differences your name and my name is Van
62:34 - Dot and I am 22 so this condition should
62:37 - be met and so should this because we are
62:40 - using an and meaning that not only this
62:42 - condition should be met but also this
62:44 - condition then it says okay well this
62:46 - condition is met because your name is
62:49 - Vandal and your age is 20 actually
62:51 - oops we have 20 here so that's that's
62:55 - interesting so so we wrote 22 that's
62:59 - fine I mean let's let it actually be
63:00 - like this so it says my name is Vandal
63:03 - and my age is 22 so it says oh this is
63:05 - not met okay so as soon as this is not
63:08 - met and this is an and statement it says
63:10 - oh I don't have to execute any of this
63:12 - now because I know that the left hand
63:14 - side of the and operator and The Logical
63:16 - operator is not exec is not true so I'm
63:19 - not even going to execute this okay then
63:22 - if we put an else Block in here
63:24 - then we can say hmm and let's say hmm
63:28 - that didn't work so well okay so if you
63:33 - put parenthesis between these and you
63:35 - can see that the logic becomes a little
63:37 - bit clean clear so and we can change
63:40 - this actually and we say let's say or
63:44 - okay and now all of a sudden you can see
63:47 - that this block of code is executed
63:49 - simply because either this should be
63:52 - true or this or both of them and since
63:55 - this part is not true it comes here it
63:58 - says your name is for indeed and your
64:00 - age is 19. do you remember H was 19 and
64:03 - name was Foo then it executes this code
64:06 - simply because one of these branches is
64:09 - true either this or this or both and we
64:12 - know that that this is true so it
64:14 - executes this code so
64:16 - usually you don't write code actually
64:19 - like this thankfully in Swift usually
64:22 - your code should make more sense inside
64:25 - your if statements and you shouldn't
64:26 - have too many branches like this with
64:28 - ands and ORS and parentheses but
64:30 - sometimes if you have very complicated
64:32 - code if you're working with low-level
64:34 - Logic for instance At Your Service layer
64:36 - you might write code like this so you
64:38 - should be ready to kind of be able to
64:41 - handle and read this type type of code
64:44 - but I completely understand it it is a
64:46 - little bit complicated to look at it if
64:47 - you're just looking at it like this and
64:50 - usually code like this is prefix with
64:52 - some common explaining why we're doing
64:54 - things the way we're doing them okay
64:57 - so that was it for our if and else
65:01 - playground in the next section we're
65:03 - gonna talk about functions so we can
65:05 - create a separate playground basically
65:07 - for functions after working with if and
65:10 - else statements we can go ahead now and
65:13 - work with functions we've seen a few
65:15 - examples of functions in Swift before
65:17 - and hopefully you already know what
65:19 - functions are so we don't have to go too
65:21 - much into details with functions but
65:23 - let's go ahead and explore some
65:25 - possibilities that we have with
65:27 - functions in Swift so command n in xcode
65:30 - or if you're in Visual Studio code I
65:31 - think also command n and or control n on
65:34 - Linux and we are going to just search
65:37 - for playground in here playground and
65:39 - let's say blank playground in here and
65:42 - let's call it functions and then let's
65:45 - create it inside the main group and
65:47 - inside the main folder okay and I think
65:49 - would be perhaps a little bit better if
65:52 - we change the size in here so I'm going
65:53 - to go to themes in Midnight which I'm
65:56 - using I'm going to select all of these
65:58 - and then let's just change the font size
66:00 - perhaps to let's just say 36 perhaps or
66:04 - even yeah 30 36 I think is good enough
66:07 - so we see the code a little bit better
66:08 - okay
66:09 - so with functions in Swift you have the
66:13 - same possibilities as you have in many
66:15 - other programming languages such as
66:16 - Python and dart and typescript
66:19 - JavaScript pretty much all the modern
66:21 - programming languages have some kind of
66:23 - same syntax and functionality for
66:25 - functions so let's have a look at a few
66:28 - examples so let's say we import
66:30 - Foundation
66:31 - I'm gonna get rid of that part to the
66:34 - left or Explorer so we can create
66:37 - functions in Swift with the func syntax
66:41 - or a keyword and then the name of the
66:43 - function and it should be camel case
66:45 - meaning that the first word of the
66:47 - function name should all be lowercase on
66:49 - all the subsequent words inside the
66:51 - function name should have or their first
66:54 - letter as uppercase and all the other
66:55 - letters as lowercase so here is an
66:58 - example of a function that takes no
67:00 - arguments and it has no return value so
67:02 - let's say no arguments and no return
67:06 - value you can see all the if the first
67:08 - word has all its letters as lowercase
67:11 - and all the other words have their first
67:13 - letters as uppercase that follow the
67:16 - first word okay
67:18 - then we put uh parenthesis in here and
67:21 - we can put our arguments in between the
67:23 - parenthesis but this function doesn't
67:24 - have any arguments then we do curly
67:26 - brackets and then inside the curly
67:29 - brackets is the body of your function
67:31 - and here we're just going to say I don't
67:33 - have I don't know what I'm doing okay
67:38 - and the way that we write these things
67:40 - in playground is a little bit special
67:41 - because in Swift playgrounds whatever
67:43 - you type as the string will actually be
67:45 - printed inside the playground's preview
67:48 - however this is not how you would
67:50 - actually write Swift Code so you would
67:52 - probably just issue a print statement
67:54 - okay but in playgrounds this does make
67:57 - sense so let's just do automatically run
67:59 - in here so our code gets executed
68:01 - automatically without us having to do
68:03 - anything and you can see nothing is
68:04 - being printed here simply because we're
68:06 - not calling or invoking our function now
68:09 - the process of invoking a function is
68:11 - just to tell to tell Swift that you want
68:14 - the code inside this function to be
68:16 - executed and the way to do that is just
68:18 - you use the function name no arguments
68:21 - and then with the parenthesis and any
68:24 - arguments that the function expects
68:26 - within the parenthesis now thankfully
68:28 - this function doesn't have any arguments
68:29 - so we don't have to pass any arguments
68:31 - within the parenthesis either and you
68:33 - can see the value is then printed to our
68:36 - playground console in here okay now we
68:40 - can also have functions that have
68:43 - arguments so let's create a function
68:45 - that takes any integer value and adds
68:47 - the value of 2 to it but this particular
68:50 - function is not going to have any return
68:51 - value again so we're just going to have
68:53 - a look at how to pass arguments to a
68:56 - function so let's say func plus two so
68:59 - like this and then we take a value and
69:02 - you can see this is how you specify an
69:04 - argument to a function in Swift you just
69:05 - type name of the argument and then you
69:08 - type the data type and also there's
69:10 - another way of doing this and I'll
69:12 - explain it later and you can have two
69:15 - labels for a variable one an external
69:17 - label and an internal label which is
69:19 - something
69:20 - quite unique to Swift you can have it in
69:22 - some other languages but not in all so
69:25 - here's an example of a function that
69:26 - internally creates a new variable let's
69:28 - call it new value and then takes that
69:31 - value and adds a 2 to it with a unary
69:34 - with a binary infix operator as we've
69:36 - seen before
69:38 - but you can see that it doesn't return
69:39 - anything okay and we can say plus two
69:42 - and then we can pass the value of 30 in
69:43 - here and you can see new value will be
69:46 - equal to 32 within this function all
69:49 - right so that's how you can basically
69:52 - pass a variable to a function using an
69:55 - argument
69:56 - you can have functions that return
69:58 - values as well so they do some
70:01 - calculation and then they return a value
70:03 - and the way to do that is to use this
70:05 - particular syntax as I'll show you now
70:08 - let's say new plus 2 and then we take a
70:10 - value of type integer and we return a
70:12 - value in here and then we can just say
70:14 - we return the value of
70:17 - value basically plus two and the return
70:20 - statements in these simple functions
70:22 - that just have one line of code is
70:25 - optional this is something that Swift
70:27 - has taken from rust however rust takes
70:30 - it to an entirely new level in that rust
70:32 - allows even for you to type some more
70:34 - code in here and then the last statement
70:36 - inside the function that doesn't have a
70:39 - semicolon will be returned however Swift
70:42 - doesn't have that ability so because
70:44 - semicolons are optional in Swift so if
70:49 - you don't want to have a return value in
70:50 - here if you don't want to type the
70:52 - return syntax in here or keyword you're
70:54 - more than welcome to do that the most
70:56 - modern code actually emits return so if
70:59 - you see a statement like this this
71:00 - function is set to return this statement
71:04 - implicitly all right and the way to call
71:07 - it is that you can say new plus two and
71:09 - then you pass the value of 30 and you
71:11 - can see the value of 32 will be returned
71:13 - from this function okay
71:16 - now you can also have functions with
71:19 - multiple arguments so let's say func
71:22 - custom ADD so we have a new add function
71:25 - in here okay and we take two variables
71:27 - so let's say value one int and value two
71:30 - int all right and then we return also an
71:34 - INT so what we return is value One Plus
71:37 - value two all right so we take two
71:39 - arguments value one namely and value two
71:41 - we add them and we just return them as
71:44 - part of our function declaration all
71:46 - right
71:47 - then we can assign the return value of
71:50 - this custom ad to a variable so let's
71:52 - say let custom ADD it
71:55 - is equal to execute the function of
71:57 - custom ad and for Value 1 we pass the
72:00 - value of 210 and for the second value we
72:03 - pass the value of 20 and you can see the
72:05 - result is value of 30. so this function
72:08 - is being executed and it's returned
72:10 - value is being assigned to this variable
72:12 - to the left hand side of the assignment
72:13 - operator okay now you can also have
72:16 - functions that do not have this outside
72:19 - label as as it is called so at the
72:23 - moment this function has two arguments
72:24 - and they only have one label this label
72:27 - is used externally as you can see at the
72:29 - call site and also internally inside the
72:32 - function however functions can also
72:35 - determine how these labels are created
72:37 - every argument can have two label sorry
72:40 - two labels external and internal okay so
72:45 - you can see that then internally inside
72:48 - this function this label is not
72:50 - available so if you type external there
72:52 - is nothing available but if you type
72:53 - internal then it is available to you
72:55 - okay so and let's go back in here and
72:59 - have a look at an example of a function
73:01 - that doesn't have any external labels
73:03 - all right so for its arguments so let's
73:06 - say func custom minus all right and it
73:09 - has two arguments and let's just call
73:11 - them left hand side and then right hand
73:13 - side and we return an integer as well
73:16 - okay
73:17 - oops and then we say left hand side
73:20 - minus right hand side now if you call
73:22 - this function just the way it is then
73:25 - you can you can write like this custom
73:28 - subtract it
73:30 - and then we say is equal to custom minus
73:33 - and then let's let's say let's say the
73:36 - value of 20 and the value of 10 in here
73:39 - okay and you can see then easily that at
73:42 - the call site we have to pass these
73:44 - argument names LHS and rhs however if
73:48 - you don't want to do that if you don't
73:49 - want to pass a an argument name you can
73:52 - just say custom minus and then you want
73:53 - to say 20 and 10 like that then you have
73:56 - to make sure that Swift gets the
73:58 - external name as underscore like this so
74:01 - underscore simply means that the a call
74:03 - site where you're calling this function
74:05 - from shouldn't have argument names so
74:07 - you can see now you have to remove LHS
74:09 - and rhs and then your code will work as
74:12 - expected
74:13 - okay so that's how you can basically
74:16 - ignore external argument names and just
74:19 - keep in mind that the first uh the first
74:22 - part of the argument's name can be its
74:25 - external name and then if you put a
74:27 - space and then another
74:28 - basically word or sentence hopefully not
74:32 - a sentence but a few words it will be
74:34 - the internal name of that argument okay
74:37 - and if you don't have that the only name
74:39 - you have in here will be available
74:40 - externally and internally all right
74:44 - good so
74:46 - um if you are now if you're in pure
74:48 - Swift you can see in here we're at the
74:50 - moment calling this a function like
74:52 - custom minus but if you're in pure Swift
74:55 - meaning that you're not inside a
74:57 - playground if you call a function that
75:00 - has a return value so let's say cost
75:02 - them add
75:04 - and then you say value one is 20 value 2
75:07 - is 30. in a playground you just get the
75:09 - return value and the return value of
75:12 - this function will be displayed here
75:13 - however if you're in peer Swift meaning
75:16 - that you're not inside a playground then
75:19 - doing this will actually give you a
75:21 - warning telling you that you're calling
75:23 - a function without consuming its result
75:25 - the reason we're not seeing that morning
75:27 - in a playground is that playgrounds
75:29 - consume the result of all functions
75:31 - implicitly and and type them out here in
75:34 - the preview but inside pure Swift Code
75:37 - when you're writing like iOS code or Mac
75:39 - OS code or watch OS whatever and you're
75:42 - basically you don't have a playground in
75:44 - those codes it's pure Swift Code so you
75:46 - need to consume these values meaning
75:47 - that you have to assign them to
75:49 - something okay like that and then you
75:51 - need to also consume this somehow so
75:53 - even if you type code like this so it
75:55 - will complain saying that hey you're
75:57 - assigning this to add it but you're not
76:00 - using added anywhere so what's the point
76:02 - of doing this function call all right so
76:05 - if you want to write a function in Swift
76:07 - that does produce a value however the
76:10 - person or the call site where you're
76:12 - calling that function doesn't
76:14 - necessarily have to consume that value
76:17 - you can mark that function as
76:19 - discardable result and I'll show you how
76:22 - to do that so let's go ahead and create
76:24 - a my custom ADD function in here so we
76:26 - say my custom at okay and then we have
76:29 - two arguments in here that are
76:31 - externally not named but internally
76:33 - they're called LHS as in left hand side
76:36 - and then we have rhs in here okay and we
76:40 - return integer as well and we say LHS
76:42 - plus rhs so if you want this function to
76:45 - be able to produce integer but the call
76:47 - side the color of this function doesn't
76:49 - have to consume that integer you need to
76:51 - mark this function as discardable result
76:53 - doing this in a playground doesn't make
76:56 - any difference at all because as I
76:58 - mentioned playgrounds consume the result
77:00 - of all functions implicitly however if
77:03 - you're in pure Swift this will make a
77:05 - lot of sense and to be honest with you
77:07 - we can actually have a look at this I
77:09 - mean now I'm improvising a little bit
77:11 - I'm just going off the script but let me
77:13 - just create a simple iOS project in here
77:15 - and let's say my app
77:17 - and then we're just gonna save it on
77:19 - desktop it's fine I don't really care
77:21 - where it is saved at the moment so let's
77:23 - just save it
77:24 - and let me just show you how this looks
77:27 - inside a for instance Swift UI
77:29 - application so if you go into our app in
77:31 - here and say
77:34 - um what should we do in here let's say
77:36 - perhaps we have a window group in here
77:38 - let's go to content View
77:41 - and now we have a swift UI application
77:43 - though so it would have been better if
77:45 - we actually created a
77:47 - um let's just create a filing here Swift
77:49 - file let's say my service okay
77:53 - and in here let's just say that we have
77:56 - a
77:57 - what should we do let's say uh struct
78:01 - person okay
78:03 - and then we create a function in here
78:05 - just like we're learning now we say get
78:07 - H and this is not really how we write
78:10 - normal code anyways but this is for the
78:12 - purpose of demonstration and then we
78:14 - have another function that's called do
78:16 - something and then we say length age is
78:18 - get H so we call that function now if we
78:21 - leave this code like this let me just
78:23 - actually change this to yeah that's fine
78:25 - if you try to compile this code you can
78:27 - see that now we're getting
78:28 - initialization of immutable value age
78:30 - was not used or something was never used
78:32 - okay and you even if you write your code
78:35 - like this you will get a warning same
78:37 - result of call to get ages on you so
78:40 - this is the warning that I was just
78:41 - talking about inside a playground you
78:42 - don't get These Warnings but inside a
78:44 - pure Swift Code you get These Warnings
78:46 - so the way to fix that is to prefix this
78:48 - with discardable result and then compile
78:50 - your code you can see then it's working
78:52 - as expected however if you assign this
78:55 - to a variable you will get the warning
78:58 - anyways because you're assigning it to a
79:00 - variable that you're not using later so
79:02 - this discardable result doesn't fix this
79:03 - this issue however it fixes the issue of
79:05 - you calling this function without
79:07 - assigning its variable to any values
79:10 - sorry without assigning its value to any
79:12 - variables okay
79:14 - good you didn't have to create this
79:15 - project I mean this was just a test okay
79:17 - so that I can demonstrate what I meant
79:19 - in this case now that we have that we
79:22 - can just type my custom ad and then we
79:25 - can just say say the value of 20 and 30
79:27 - in here without having to worry about
79:30 - consuming the result of this function
79:32 - now you you may be thinking but why
79:34 - would you write a function like that
79:35 - well some functions for instance in
79:38 - service layers inside an application may
79:40 - do some complicated work and they may
79:42 - produce a Boolean value indicating
79:44 - whether it was successful or not however
79:46 - it's not always that you actually care
79:48 - about that Boolean value and you can
79:50 - call that function without caring about
79:51 - its result in that case you can prefix
79:54 - the function declaration with a
79:55 - discardable result as I showed you right
79:58 - here okay now functions can also contain
80:01 - their own functions so this is something
80:04 - that not many program languages support
80:06 - darts for instance support so then you
80:08 - can also have something like that in
80:09 - Rust as well
80:10 - so let's have a look at that so we say
80:12 - funk do something complicated with a
80:16 - value and you can see width is the
80:19 - external argument label and value is the
80:21 - internal argument label in here okay and
80:23 - this function we can see returns an
80:25 - integer let's break this parameter down
80:27 - like this and then in here we say we
80:31 - have another function inside this that
80:32 - actually does the logic okay so we say
80:35 - main logic
80:36 - with a value and returns an INT and in
80:39 - here we just say Value Plus 2 okay so
80:42 - we're not really doing anything
80:43 - complicated we're just plusing the value
80:45 - with 2. however this function do
80:48 - something complicated contains another
80:49 - function that does the actual logic and
80:52 - this function then can call this
80:53 - function internally but no one else in
80:55 - the entire application can call this
80:57 - function this function is only available
81:00 - to this function because it is written
81:02 - inside it okay then what we can do is
81:05 - say return the main logic we call that
81:08 - function we say Value Plus three then in
81:11 - here we can go ahead and say do
81:12 - something complicated with the value of
81:14 - 30. so what happens is that the value of
81:17 - 30 goes in here
81:18 - then 30 will be plus 3 33 and then we'll
81:23 - go into main logic so 33 plus 2 will be
81:26 - 35 as you can see printed out here okay
81:30 - now arguments in Swift for functions can
81:33 - also have default values so you can have
81:36 - for instance a function that says Funk
81:38 - gets full name as you can see in here
81:40 - okay we say first name is the name of
81:42 - the argument internally and externally
81:44 - it has the default value of Foo and then
81:46 - we can say last name is a string and it
81:49 - has the oops the default value of bar
81:51 - okay and this function returns a string
81:54 - which is like this we put the first name
81:57 - in here and a space and last name all
82:00 - right so we're basically calculating a
82:02 - full name using this syntax now you can
82:05 - call this function now in so many
82:07 - different ways actually you can call in
82:08 - three different ways I would say one is
82:10 - without arguments so because both the
82:13 - arguments that are available that are
82:16 - required for this function have default
82:18 - values so you don't have to pass any
82:20 - arguments to it and you can also mix and
82:22 - match you can for instance pass actually
82:25 - I think you can call it in four
82:26 - different ways yes so you can also call
82:28 - it only with a first name if you want to
82:30 - so you can say bass you can say you can
82:32 - see now the result will be bazbar so the
82:35 - last name is picked from the default
82:37 - value and the first name is overwritten
82:39 - by the value at call site
82:41 - and you can also say get full name and
82:44 - then we say only pass the last name
82:45 - let's say Foo so now the value will be
82:47 - Fufu right
82:50 - and then you can also call it with both
82:52 - parameters so you can say first name and
82:54 - we say Babs and last name we can say
82:58 -  like this all right so you can see
83:01 - now the result will be baz and Cox in
83:04 - here all right so these were just some
83:06 - examples of how you can create functions
83:09 - in Swift now we will actually look more
83:13 - at functions on how to create more
83:15 - complex functions perhaps but this is
83:17 - like the basic structure of how to
83:19 - create functions in Swift and there are
83:22 - some functions of course that are a lot
83:24 - more complicated than what we have in
83:26 - here but the complication is usually
83:27 - inside the function itself the function
83:31 - um header or the function signature is
83:33 - usually one form of these things that
83:35 - we've written in here with some param
83:37 - with some arguments that perhaps have
83:39 - internal or external names or some
83:41 - arguments that have no external names
83:43 - but internal names discardable result
83:45 - and pretty much pretty much that's it
83:48 - really so that's about functions for now
83:50 - in the next section of uh this video
83:53 - we're going to have a look at closures
83:55 - which are kind of special functions so
83:57 - see you there now that we've finished
83:59 - talking about functions let's go ahead
84:01 - and talk about a special kind of
84:03 - function which is with local variables
84:05 - and it is called closure so before we do
84:08 - that let's create
84:10 - its own playground so I'm going to go
84:12 - here and say command n and type
84:15 - playground in here if I can spell it
84:18 - and in blank playground I'm going to
84:20 - create closures in here and Ensure again
84:23 - that it is created in your workspace and
84:26 - not inside another playground
84:29 - I'm going to press the create button and
84:31 - let's say in here that import Foundation
84:33 - okay now
84:36 - closures are available in many other
84:38 - programming languages such as python
84:40 - there are also available available in
84:43 - Dart for instance and in I would say
84:46 - rust as well and of course JavaScript
84:49 - and typescript
84:50 - so most modern programming languages
84:52 - have closures and what closures really
84:55 - are there are special types of functions
84:58 - that are created in line so that you can
85:01 - actually pass them to another function
85:04 - for instance and they can hold a
85:06 - function so you could you could pretty
85:07 - much say that there are function
85:09 - references kind of but not really uh but
85:13 - I think the easiest way to explain
85:14 - closures is to demonstrate how they look
85:17 - like how to how the syntax looks like
85:19 - and I think after that it will be a lot
85:22 - more uh it it will be a lot easier to
85:25 - understand what basically they do so
85:28 - let's go ahead and create a closure in
85:30 - here which is supposed to add two
85:32 - integers together and return a result so
85:34 - if you were to do that using a function
85:36 - you would probably do add and then you
85:39 - would say like left hand side into your
85:41 - right hand side integer uh and you could
85:44 - perhaps also remove the external label
85:47 - of these arguments so that you don't
85:49 - have to actually write LHS rhs when
85:51 - you're calling this function then you
85:53 - would say that this function returns an
85:55 - integer then you could say left hand
85:56 - side plus right hand side is that
85:58 - function
85:59 - however if you want to assign this to a
86:01 - variable for instance call at then you
86:05 - could say let's actually comment this
86:07 - out then you could say let's add then as
86:10 - you would do with any other variable you
86:12 - as you could do actually with any other
86:14 - variable you don't have to do that but
86:16 - you need to tell Swift what type of data
86:19 - type this function is accepting so you
86:22 - could say let's add and then you would
86:24 - say column and instead of for instance
86:26 - saying this is an integer equal to one
86:29 - or this is a string equal to Foo you
86:31 - could say in here that this is actually
86:33 - a function
86:34 - right and then you say okay it accepts
86:37 - an integer and it actually accepts two
86:40 - integers and it returns an integer okay
86:42 - so this is you defining the data type of
86:45 - this variable or a closure okay and then
86:49 - you could say it's equal to so now
86:51 - you've defined a data type now you
86:53 - actually create the function then inside
86:55 - the creation of the function you just
86:57 - create curly brackets as you would do
86:58 - any other function and in here then you
87:01 - get your data you say left hand side is
87:03 - an integer right hand side is an integer
87:05 - okay
87:06 - and you return an integer
87:08 - and then you say in like this so let's
87:11 - actually break this down bring it to the
87:13 - next line
87:14 - like this okay so this is where you're
87:17 - defining the data type for ADD and this
87:19 - is where you're actually assigning it to
87:21 - a valid function all right and let's
87:23 - change our playground to automatically
87:26 - run in here and then you can see Swift
87:28 - is telling you that you're not returning
87:30 - anything in here so let's just say LHS
87:31 - plus rhs okay and these values that we
87:35 - have in here they're just internal uh
87:38 - argument names so they're not actually
87:40 - being used externally okay now that we
87:43 - have ADD you can see it tells you that
87:45 - add is actually invariable that points
87:47 - to F function which requires two
87:49 - arguments and returns also an integer
87:53 - so you could call at just like you would
87:55 - call the add function so if you say add
87:58 - 20 and 30 you can see that you're pretty
88:01 - much just calling that function that is
88:04 - beneath this add variable you could say
88:07 - okay so you get the result of 30.
88:10 - so now that you know how to create one
88:13 - of these functions closures you can see
88:15 - you can create it in line like that you
88:18 - can actually pass any one of these
88:21 - functions like these and which you
88:24 - create inline to another function and
88:26 - that's where the power of closures
88:28 - really come to play so let's create a
88:30 - quite a useless function and that we
88:33 - call custom ADD but it's just there for
88:35 - for the purpose of demonstration of
88:37 - closures
88:39 - so this custom function what it does it
88:42 - it takes two integer variables and then
88:45 - it uses another function that you give
88:48 - it so you pass a function to this
88:50 - function and that function is passed to
88:53 - this function will do the actual
88:54 - addition and R function that we will
88:58 - create now will just call that function
89:01 - all right so it will just demonstrate
89:03 - how you can pass a function to another
89:04 - function and how you can create a
89:06 - function on the go or on the fly so
89:09 - let's create this custom ADD function in
89:11 - here we call it custom ad like this okay
89:15 - and this custom ads it takes two uh two
89:18 - values we call them LHS left hand side
89:21 - all right and then we say rhs another
89:24 - integer and as the second parameter we
89:27 - want actually a function that does the
89:29 - addition for us so this custom ad itself
89:32 - doesn't really do the addition it will
89:33 - delegate the addition task to the given
89:36 - function so just like you would Define
89:39 - any other variable like here you
89:41 - basically type the external argument
89:43 - name internal argument name
89:45 - or just one argument name that is used
89:48 - externally and internally and then you
89:50 - would Define its data type this is very
89:52 - similar you see defining a data type
89:54 - with a column we did the same thing in
89:56 - here so we want basically a function
89:59 - that takes an integer or two integers
90:01 - and returns an integer so let's go ahead
90:03 - and Define it here we say the external
90:06 - label for this argument is using so we
90:10 - can say custom ad kind of like this
90:11 - custom at 10 20 using like this okay
90:16 - so the external name of this argument is
90:18 - using and internally is called function
90:20 - all right and then we say this function
90:23 - requires two integers and it returns an
90:26 - integer all right so this is just like
90:28 - defining any other variable inside or
90:30 - argument inside your function signature
90:32 - you just say external data sorry
90:36 - external argument name internal argument
90:37 - name it's data type and its data type is
90:40 - pretty much just a function with two
90:41 - integers as arguments and returns an
90:44 - integer okay after doing that we close
90:46 - the arguments list with the closing
90:49 - parenthesis and now we have to define
90:50 - the return value of R function so this
90:53 - custom ADD function at the moment you
90:55 - can see it's not returning anything
90:56 - because the parenthesis ends here but we
90:59 - don't have any of these pointers in here
91:00 - so let's say that our function also
91:02 - returns an integer okay then inside the
91:05 - function itself inside this custom math
91:08 - function we need to return an integer
91:09 - but it is this function that does the
91:12 - calculation so let's just call it just
91:14 - like you would call any other function
91:15 - so we just say function LHS and rhs and
91:18 - again this is just a label it doesn't
91:21 - have to be called function you can just
91:23 - call it f if you want to or you can just
91:25 - call it l h whatever you want to but I
91:28 - really really suggest that you don't
91:30 - name your variables with f or H or L
91:33 - it's just better just to call them
91:34 - something and that means something as
91:37 - well okay and in this case function I
91:38 - think is a quite a good name for it but
91:42 - you might disagree
91:44 - so we have function now and you can see
91:46 - it is being called by custom add-ins and
91:49 - this result is being returned from
91:50 - Custom app and you can call the custom
91:52 - ad function as I'll show you now so
91:55 - let's say custom ad you can see we have
91:57 - three parameters okay I'll break them
91:59 - down here now the left hand side you can
92:02 - see it doesn't have any external labels
92:03 - so let's just say 20. and then we say
92:06 - 30. now this using is going to be very
92:09 - interesting because usually when you
92:10 - come here Swift is going to be able to
92:12 - substitute this for you using an a
92:15 - trailing closure syntax okay so if I go
92:19 - here and press enter you can see all of
92:21 - a sudden the using label was just
92:23 - completely removed now if if you go
92:26 - ahead in here and you just want to see
92:28 - okay but what is happening in here what
92:31 - you could do is instead go ahead and
92:33 - create a function in here because this
92:34 - should be a function you see it's
92:35 - telling you it needs to have two
92:36 - arguments and a return value of integer
92:38 - you could create a function yourself and
92:41 - then say left hand side and right hand
92:44 - side ends and it should return an INT
92:47 - and then in here you and also please
92:49 - don't forget the in syntax because it
92:51 - needs to know Swift needs to know where
92:54 - this function actually starts its body
92:56 - okay then in here you say left hand side
92:59 - plus right hand side so after doing this
93:01 - you can see now the value of 50 being
93:03 - printed to the playground console all
93:06 - right so that's what you could do
93:09 - manually however what syntax what Swift
93:12 - does is that if it sees an argument at
93:15 - the end of a function you can see sorry
93:18 - an argument at the end of the list of
93:20 - arguments of a function so here we have
93:22 - a left hand side and right hand side and
93:23 - then we have a closure
93:26 - that has to be passed to this function
93:28 - but disclosure is not like the first
93:31 - argument it is the last argument and
93:34 - Swift does something called a trailing
93:36 - closure syntax what it does is that and
93:39 - we can actually do it by hand we can go
93:42 - in here you can see it removes this
93:43 - argument name first of all
93:46 - then it puts an ending parenthesis here
93:49 - and then removes this column
93:52 - then you can see this should pretty much
93:55 - do the same thing in here so and then it
93:57 - of course removes this parenthesis in
93:59 - here as well
94:01 - so now you can see the parenthesis ends
94:03 - here and then there's no using since
94:06 - using argument name and then there is a
94:08 - trailing closure right after the
94:10 - function is finished so we can actually
94:12 - put this maybe here actually it's good
94:14 - yeah and we can clean this up as well a
94:17 - little bit like this so this is the
94:20 - trailing closure syntax in Swift meaning
94:22 - that if there is a closure at the end of
94:24 - a function and then it shouldn't it
94:27 - doesn't necessarily have to have all the
94:29 - bells and whistles around uh argument
94:32 - names and Etc okay it can just emit
94:35 - writing the argument name close the
94:37 - parenthesis right after the argument
94:40 - before it and then creates the closure
94:43 - right after this function call and it
94:45 - will be passed into this argument okay
94:48 - so now you saw that we created a closure
94:51 - which is this one and we passed it to
94:53 - another function which is then being
94:55 - used to calculate the value of 20 plus
94:58 - 30 okay
95:01 - now Swift also has a very handy
95:04 - functionality where it can infer data
95:09 - types based on the function signature
95:12 - now I'll explain this a little bit now
95:13 - and you can see in here this function
95:16 - custom ad already has defined that the
95:18 - closure being passed to the function
95:21 - argument has to have the data type of
95:23 - integer integer and it sorry it has to
95:26 - have the data type of integer for both
95:28 - of its arguments and also integer first
95:31 - return value
95:32 - now in here then you could say okay but
95:35 - if this function already knows that it
95:37 - should be integer and integer maybe I
95:39 - could just remove these well it kind of
95:41 - would be right you can just go in here
95:42 - and say left hand side right hand side
95:44 - and then in
95:46 - and if it runs your code again you
95:49 - should basically see 50 again you can
95:51 - see in here so we could maybe change
95:52 - this to 30 just to see that everything's
95:55 - working as expected
95:58 - uh there we go we got the value of 60.
96:00 - so you can remove these data types
96:03 - right so if let's actually copy this
96:06 - code and bring it a little bit down here
96:08 - and remove the data types like this and
96:12 - we can remove the return value as well
96:14 - so that's the first step of cleaning up
96:16 - the code that you can do all right now a
96:18 - lot of developers would call this
96:20 - actually clean up they would say oh yeah
96:22 - you should remove these data types
96:24 - they're not so good Etc however I've
96:26 - worked on a lot of big projects that
96:29 - have been written in purely in Swift
96:32 - and once your code base gets very very
96:35 - large that you have maybe thousands of
96:39 - source files and then every of those
96:41 - source files has hundreds of lines of
96:43 - code
96:44 - on average perhaps written in them I've
96:47 - noticed that I mean after doing a lot of
96:49 - uh
96:50 - benchmarking on the compilation and
96:53 - asking xcode to tell me exactly where
96:57 - things are taking a time or the most
97:00 - time during the compilation it's been
97:02 - where it has where the compiler has been
97:05 - trying to figure out data types so
97:07 - there's a little less information you
97:09 - give to the compiler the more time it
97:12 - takes for the compiler to compile your
97:13 - code so here you can see we have a lot
97:16 - of information for the compiler we're
97:18 - telling it that this closure has two
97:19 - arguments integers and it's returning an
97:22 - integer so the compiler doesn't have to
97:24 - figure it out on its own so it says okay
97:26 - then I just calculate this and return
97:29 - the data however here the compiler has
97:31 - to ensure that yeah okay so the function
97:36 - it has to go back to the custom ad
97:37 - function and say okay this shouldn't
97:38 - have two integer arguments and it should
97:40 - return an ins then it comes here and
97:42 - checks that because we haven't even told
97:45 - it what return value we have then it
97:47 - says okay there's some data here some
97:49 - data in here and they have to be plus
97:51 - together can two integers be plus
97:53 - together okay so it's it has to figure
97:56 - figure out all of this on its own so it
97:58 - has to basically look up the plus
98:00 - function or in fixed binary operator to
98:04 - ensure that that actually exists between
98:06 - two integers so you can imagine all of
98:09 - this basically puts strain on the
98:11 - compiler and of course if you have
98:13 - thousands and thousands of these
98:14 - functions that where the compiler has to
98:16 - figure out things on its own then of
98:18 - course your compilation is going to be
98:20 - drastically slower
98:21 - now now that we're talking about
98:23 - stripping information from the compiler
98:25 - there's also one more step that you can
98:27 - take in order to make your code more
98:28 - Compact and more difficult for the
98:30 - compiler to guess but on small smaller
98:33 - code basis this is this doesn't really
98:35 - make any difference to be honest so
98:37 - let's actually copy and paste this code
98:38 - right here what you can do in this case
98:40 - is that you can completely remove these
98:43 - this information from here and in Swift
98:46 - you can tell it that you have two
98:49 - arguments in here by specifying by
98:51 - prefixing every argument with its index
98:54 - and dollar so you can say dollar zero
98:56 - plus dollar one so Dollar in here will
98:58 - mean basically an argument at an index
99:02 - of zero which is this guy and an
99:04 - argument at the index of one which is
99:06 - this guy and then you're just plusing
99:08 - them together and returning the value so
99:10 - some developers will then be like custom
99:13 - at 20 30 and then we'll do like this
99:17 - so it is completely up to you and your
99:20 - teammates how you like to format your
99:22 - Swift Code because unfortunately there's
99:24 - no real official linter and official
99:29 - code formatter for Swift as I mentioned
99:31 - before so there are some Community
99:35 - guidelines how to format code but you
99:37 - can't actually see code written like
99:39 - this sometimes and to be honest with you
99:41 - for me at least this is readable I have
99:42 - nothing against it but if it was me
99:44 - writing this code I would probably write
99:47 - it a lot more like this
99:50 - just because of the experience I've had
99:53 - with ensuring that the compiler can
99:55 - compile my code faster on larger code
99:58 - basis but writing code like this is also
100:01 - completely fine dependent on the context
100:05 - all right
100:06 - good now now that we've done that let's
100:09 - have a look at passing
100:11 - um some sort of special closures to
100:14 - functions and before I before we do that
100:17 - let me just write some coding here as uh
100:20 - like a preparations let's just Define an
100:23 - array in here and say and I'm also aware
100:26 - that we haven't worked with arrays yet
100:28 - but if you've worked with another
100:30 - programming language you already
100:31 - probably know what arrays are so it's
100:33 - just like a homogeneous uh actually they
100:36 - can be heterogeneous as well but it's
100:39 - just like a series of data okay let's
100:41 - just leave it at that let's just say
100:42 - ages are 30 20 19 and 40. so now we have
100:46 - four integers placed inside this array
100:49 - okay now you can see in here we can
100:52 - start sorting this array let's say that
100:55 - we want to sort things ascending and
100:56 - descending so we say sorted okay and you
100:59 - can see it has an argument in here and
101:02 - there's a function called sorted using
101:04 - actually let's just say sorted by let's
101:06 - say sorted by this a little bit better
101:08 - and you can see it expects a function so
101:11 - it says give me a function that takes
101:13 - two integers and then it can throw and
101:16 - we haven't talked about throws it and it
101:18 - should return a Boolean okay so let's go
101:21 - ahead and see how we can implement this
101:23 - function so we say LHS integer rhs
101:27 - integer and it should return a Boolean
101:29 - okay and then actually it throws as well
101:32 - but we don't have to write that and then
101:34 - we say in all right so in here let's
101:38 - just return true for now and let's see
101:40 - what happens okay so if you return true
101:42 - in here let's see the data that is being
101:45 - returning here
101:47 - uh ss14 19 20 30. so it really didn't do
101:51 - anything so but if we say in here uh LHS
101:54 - should be more than rhs okay and this is
101:59 - of course it's going to return a Boolean
102:00 - value all right now you can see what
102:03 - happened is that the result is that the
102:06 - return from age is that sorted is an
102:09 - array that is sorted descending so as
102:12 - long as left hand side is more on right
102:14 - hand side if you're basically doing this
102:16 - comparison with greater than then you're
102:19 - sorting the array descending and you can
102:21 - read the documentation if we're sorted
102:22 - by as well to understand how it actually
102:25 - works okay so it's when you want to sort
102:27 - a sequence of elements that don't
102:28 - conform to the blah blah let's see and
102:31 - that returns true when the first element
102:32 - should be ordered before the second so
102:34 - it says return true when the first
102:36 - element should be ordered before the
102:38 - second and and what we're saying is that
102:40 - if left hand side is more than the right
102:42 - hand side then it should be sorted
102:44 - before and that's why we're getting
102:46 - descending and if you change this to
102:48 - less than
102:49 - you should expect your rate to be sorted
102:52 - ascending okay
102:55 - so what what I'm trying to doing here is
102:58 - that we have a lot of code in here you
103:00 - can see that takes left hand side and
103:02 - right hand side returns a Boolean
103:03 - however there as you may guess this
103:07 - particular
103:09 - um
103:09 - operator which is a binary infix
103:12 - operator already takes a left hand side
103:14 - and a right hand side and returns a
103:16 - Boolean so if we were to Def to
103:18 - implement this uh operator ourselves we
103:22 - would probably write it like this right
103:24 - function less than and we say left hand
103:27 - side integer right hand side integer and
103:30 - it returns a Boolean and we say left
103:33 - hand side less than right hand side
103:35 - however please don't do this because
103:36 - this actually goes into a something
103:39 - called an infinite Loop
103:41 - it will go into an infinite recursion of
103:44 - itself because this function will just
103:45 - call itself all right so what I'm trying
103:49 - to say in here is that if you look at
103:51 - this function signature you can see it
103:53 - is exactly the same as this function
103:55 - signature so and since this is a
103:58 - function name in itself why don't we
104:01 - just pass it to this so instead of
104:04 - writing all of this why don't we just do
104:06 - this
104:08 - right because it is the same thing it is
104:10 - the exact substitute of this so let's
104:12 - remove that
104:13 - and remove this code as well and you can
104:16 - see actually you can do that so by
104:18 - passing a function or an operator a
104:21 - binary in fix operator to this to this
104:24 - argument you're substituting pretty much
104:27 - all this code that we wrote in here so a
104:30 - lot of newcomers to Swift will write
104:32 - code like this but a lot of seasoned
104:33 - developers know that that and this
104:36 - binary and fix operator already is a
104:38 - substitute for that closure so you can
104:40 - do the same thing for more than so this
104:43 - is going to sort descending and this is
104:45 - going to sort ascending so you can see
104:47 - here descending sort and ascending sword
104:50 - okay
104:52 - so
104:53 - that was uh one one example or rather
104:58 - two examples of passing operators to
105:01 - closures okay
105:04 - now let's move on to the next example
105:06 - and for that I'm gonna go here to our
105:08 - custom ad function and I'm gonna copy it
105:10 - right right here and let's paste it down
105:14 - here and let's call it custom ad2 and if
105:17 - you remember I mentioned that we have
105:18 - this syntax called basically trailing
105:22 - closures in Swift meaning that if there
105:24 - is a closure at the end of the function
105:27 - signature as its list of arguments then
105:29 - Swift helps you out by removing by
105:32 - allowing you to remove the and the
105:35 - argument label and allowing it to Trail
105:38 - basically the closure at the end of the
105:40 - function call as we saw in here so you
105:43 - don't have to type and using in here
105:46 - okay which is something that we
105:48 - otherwise would have to do all right
105:50 - like this using this and then
105:52 - parenthesis so since that function as
105:56 - since this argument is at the end then
105:58 - we don't have to do all of that work
105:59 - however if you make a mistake of putting
106:02 - this argument for instance at the first
106:03 - place where are in the middle not at the
106:06 - end then let's see actually what
106:08 - happened in here with a comma
106:10 - then calling this function you will have
106:12 - to do something like you have to do
106:14 - mental gymnastics like this custom uh
106:16 - two and now you have to pass your
106:19 - closure like this all right and then you
106:22 - say LHS
106:24 - and rhs
106:26 - and then you say LHS plus rhs and then
106:30 - you have to go in here and say 20 and 30
106:32 - for instance okay so I don't know about
106:36 - you but this code looks a lot dirtier to
106:39 - me than it should be because it has a
106:41 - lot of labels and it is like it is a
106:44 - function or a closure before these
106:47 - values being sent here and so to me this
106:51 - doesn't look very clean to be honest
106:52 - with you and you can of course make this
106:54 - a little bit shorter as well you can
106:56 - remove that code that you've written in
106:58 - here and you can say dollar zero dollar
107:00 - zero plus dollar one and then do it like
107:03 - this and then go 20 30. so it becomes a
107:06 - little bit more readable if you do this
107:08 - however it's still not as clean as it
107:11 - can be so you can also put perhaps the
107:15 - value of 10 in here just to demonstrate
107:16 - that this is actually working as
107:18 - expected so now this should be 60 okay
107:21 - so
107:22 - um that's why I really suggest that you
107:25 - take advantage of trailing closure
107:27 - syntax in Swift and add your closures if
107:30 - you have a closure argument at the
107:32 - absolute end of your argument list okay
107:35 - now we've seen how we can pass uh
107:38 - operators like this to a closure
107:41 - parameter of a function and but as you
107:44 - as you'd expect since arguments sorry
107:47 - since operators are normal functions and
107:50 - you can also pass normal functions to
107:53 - closures so let's have a look at an
107:55 - example let's create a function in here
107:57 - it's called add 10 2 and then we get a
108:00 - value of integer and we return an
108:01 - integer and we just add 10 to this value
108:04 - all right and then we can have another
108:06 - function in here called at 22 and then
108:10 - we just add 20 to whatever integer
108:12 - parameter that is passed to our function
108:15 - now we can then have an a function in
108:18 - here called do addition all right and
108:21 - then it takes a value and we externally
108:24 - call it on and we say do addition on
108:27 - value all right int
108:30 - and then we want to have a function that
108:33 - basically takes this value and does some
108:35 - addition with it and returns an integer
108:37 - okay so we say using a function using
108:39 - function and this function should take
108:42 - an integer as its only argument and it
108:44 - should return an integer okay so that's
108:46 - so it shouldn't take two integers
108:48 - basically simply because we want to pass
108:50 - one of these functions which has only
108:52 - one integer as its input to this closure
108:55 - in here okay and our function should
108:58 - return an integer than what it's going
109:00 - to internally do is going to invoke that
109:02 - function with this value and return its
109:05 - result as the result of our function we
109:08 - could have written return in here but it
109:10 - is not necessary in modern Swift okay
109:13 - now let's go ahead and invoke this let's
109:15 - say do addition and then we say on the
109:18 - value of 20 and in here using you could
109:21 - you could imagine that well you could
109:23 - create a trail enclosure in here you can
109:25 - see and we say value and we could say
109:28 - value
109:30 - plus 30 okay so what is going to happen
109:33 - in here is this value of 20 is going to
109:34 - be passed here to this closure and it's
109:36 - going to be 20 plus 30. so let's see if
109:40 - Swift playground is going to be able to
109:41 - recover and you can see 20 plus 30 is
109:43 - 50. now instead of doing this instead of
109:46 - passing this uh into basically an inline
109:51 - closure to this using argument you can
109:53 - as you'd guess pass a reference to any
109:56 - of these functions that has the same and
109:59 - they both these functions have the same
110:01 - um header or definition as this closure
110:05 - they take an integer as their argument
110:07 - and they return an integer so let's say
110:10 - that we say add 10 to
110:12 - like this and you can see now it's this
110:16 - function internally going to be passed
110:17 - through this so this function is going
110:19 - to be at 10 2 and it's going to be
110:21 - invoked with the value of 20. 20 plus 10
110:23 - is going to be 30 which is which is then
110:26 - printed right to our playground console
110:29 - then let's copy this and go here and
110:31 - then we say add do addition again on 20
110:34 - but add 22 which is our other function
110:37 - up here okay and then we have the value
110:41 - of 40 printed to the screen now and this
110:44 - function is a little bit strange as you
110:46 - can see I mean not strange actually they
110:48 - don't have external
110:51 - argument names so if you change that and
110:54 - so that the value is actually the
110:56 - external argument name then you have to
110:57 - change the signature past here as well
110:59 - so then we should say add 10 to with
111:02 - value and add 22 with value so just make
111:06 - sure that your function signatures are
111:08 - basically the right signature according
111:12 - to how you've defined those functions in
111:15 - here okay
111:17 - very good I think this suffices for uh
111:21 - closures really closures are as I've
111:24 - mentioned uh kind of inline arguments
111:27 - and usually that you pass to another
111:29 - function
111:30 - and you can Define closures and by
111:33 - assigning a function to a variable and
111:35 - then you can pass that variable around
111:37 - to other functions as well so
111:39 - really when as Swift developers talking
111:42 - about closures they're just talking
111:43 - about functions that are in line so they
111:46 - don't have the funk keyword before them
111:50 - so any function that doesn't have the
111:52 - fun keyword behind it is in fact a
111:54 - closure instead you could pretty much
111:56 - just say that okay
111:58 - good we're done now with closures and we
112:01 - can now move on to talking about a
112:03 - little bit more fun stuff in Swift
112:06 - um namely structures see you there
112:09 - so we're now done with closures or at
112:12 - least for now let's go ahead and start
112:14 - talking about structures I think from
112:16 - this point on in the course we're gonna
112:19 - actually have a little bit more fun
112:20 - since we've talked about the absolute
112:22 - basics of Swift up to this point and you
112:25 - can imagine that the basics are not so
112:28 - fun and I think for me at least
112:31 - personally personally the fun part comes
112:33 - in when we have enumeration structures
112:36 - uh classes protocols extensions generics
112:39 - all that so let's get started with that
112:42 - I'm going to go in here and let's do
112:43 - command n and xcode and let's create a
112:47 - blank playground and we're going to call
112:50 - it structures okay
112:52 - structures again a warning please click
112:55 - create this not inside another
112:57 - playground just change both the group
112:59 - and the folder to the root of your or to
113:03 - your workspace basically okay and then
113:06 - we say create
113:07 - so we have structures and let's import
113:09 - Foundation as usual I'm going to get rid
113:11 - of the Explorer to the left hand side
113:15 - so structures in Swift are a way of
113:20 - grouping data together and giving some
113:22 - sort of a name structures in Swift are
113:25 - value types and meaning that when you
113:28 - assign an instance of a structure to
113:30 - another variable then the data inside
113:33 - that structure gets copied over so you
113:36 - don't actually get
113:38 - um it get you don't get the same
113:40 - reference using two variables I know it
113:43 - I mean this could be a little bit
113:44 - difficult to understand for especially
113:46 - those who are not familiar with value
113:47 - types from another programming language
113:49 - but don't worry about it I'll explain it
113:51 - all soon so let's just first of all go
113:53 - ahead and create our first structure
113:55 - which we're going to call person okay
113:57 - struct person
113:59 - and in here when you create a structure
114:01 - you can then go and instantiate it so
114:04 - you can create an instance of this
114:06 - person such as let Foo is person okay
114:08 - and you can see then you do this syntax
114:11 - in here with parenthesis
114:13 - and inside this parenthesis you would
114:15 - eventually pass any arguments that the
114:18 - Constructor of this structure requires
114:20 - at the moment the structure doesn't have
114:22 - any values inside it so it doesn't
114:25 - contain any properties so that's
114:28 - important to understand the term
114:29 - property it doesn't have any property
114:31 - and we could go ahead and create
114:33 - properties and the way to do that is
114:35 - using the let's or VAR RM scene keywords
114:39 - in here so you could say we have a
114:42 - constant in here called nape and its
114:44 - data type should be string and all of a
114:46 - sudden you see your playground is going
114:47 - to give you an error in here if you have
114:49 - automatic running as well especially it
114:51 - tells you that you are missing an
114:52 - argument called name let's just ask it
114:54 - to fix it for us and we say name okay
114:56 - it's a string and we say Foo in here
114:58 - okay just like having the name property
115:02 - in here you can create another property
115:04 - for instance called H and we could say
115:05 - it is an integer now you see playground
115:07 - will give you another area in here
115:09 - saying that you're missing the age
115:11 - argument and we can ask it to fix it and
115:13 - says H okay then we say 20 in here okay
115:16 - now you can see we've created an
115:18 - instance of person with two properties
115:21 - name and H all right now you can access
115:26 - these properties using something called
115:28 - a DOT notation so if you go in here and
115:31 - say Foo dot name and food.h just like
115:35 - that and Swift playground is going to be
115:37 - able to print and consume the results of
115:39 - these and print them to the console as
115:41 - you can see in here however if you're
115:43 - writing pure Swift Code this will make
115:45 - no sense you're basically saying food's
115:46 - name but you're not doing anything with
115:48 - it but since Swift playground implicitly
115:52 - consumes the result of all variables and
115:54 - all return data it is being printed in
115:56 - here but in Swift it is more likely that
115:59 - you would say let's name and and age is
116:03 - foo's name and then plus food that's age
116:06 - inside like a string or something okay
116:09 - so I'm not going to write all of that
116:10 - but you you get my point so you have to
116:12 - consume it in another way if you're not
116:15 - using Swift playgrounds but just know
116:16 - that you can drill down inside a
116:19 - structure using this notation which is
116:21 - called a dots notation you just put the
116:23 - name of the variable that points to
116:24 - structure and you say dot and then you
116:26 - get the properties out okay
116:29 - now you can also have custom
116:32 - Constructors for your structures as you
116:36 - can see in here we didn't actually have
116:37 - a Constructor and the Constructor for
116:40 - structures is always created by the
116:42 - compiler itself and this is one of the
116:43 - reasons a lot of people prefer to use
116:45 - structure as a swift rather than classes
116:47 - simply because you don't have to create
116:50 - Constructors for them Constructors are
116:52 - implicitly created by the compiler so if
116:56 - you add another property in here there
116:58 - will be a new Constructor so which will
117:00 - replace the old one that had only name
117:02 - and age with the new arguments in it as
117:04 - well or the new property in it as well
117:06 - okay so that's one of the properties of
117:08 - Swift structures that they have implicit
117:10 - Constructors you don't have to create
117:12 - yourself
117:13 - now if you do want to create a custom
117:15 - initializer or Constructor for your
117:18 - structures you can also do that I'm
117:19 - going to show you how so let's create a
117:21 - structure in here and we say Commodore
117:22 - computer okay
117:24 - for those of you who are old schoolers
117:26 - and have worked with comforters one of
117:28 - my favorite computers it was actually my
117:30 - first personal personal computer at
117:31 - Commodore 64. okay
117:33 - and so we create a common computer and
117:36 - we say let's name okay and your name is
117:40 - the name is supposed to be something
117:42 - that you designate it could be like my
117:44 - lovely Commodore or whatever and then we
117:46 - have another property in here called
117:47 - menu Factory I always have difficulty
117:51 - writing and spelling it and we say it's
117:53 - the string now in this case if someone
117:56 - wanted to go ahead and create an
117:58 - instance of commodore computer it would
117:59 - probably go let's say Commodore 64 is
118:02 - equal to color computer and they would
118:04 - say name and then they would say my
118:08 - commodore
118:10 - and the manufacturer is always always
118:13 - going to be a Commodore okay so in
118:16 - Commodore 64 has the manufacturer of
118:18 - cover and also Commodore 128 is going to
118:21 - have a my color 128 okay so both of
118:26 - these instances have the manufacturer as
118:28 - Commodore then you can ask yourself okay
118:30 - if you have a Commodore computer who
118:33 - always has its manufacturer equal to
118:35 - Commodore why should the call site
118:37 - meaning this part pass this value over
118:40 - and over again so you could create a
118:43 - Constructor that always sets this value
118:45 - for you to Commodore let's go ahead and
118:48 - have a look at how you could do that
118:50 - so let's go ahead and say we have an
118:53 - initializer you can see in here okay so
118:55 - you just type in it not funk in it
118:58 - except you just type in it and it
119:00 - implicitly becomes a function then since
119:03 - it is a function then you have your
119:04 - argument list and then your function
119:06 - body then as you as you can expect in
119:09 - here you just want the call side to pass
119:11 - the name to you so you're just say name
119:13 - String but you emits the manufacturer
119:15 - from the initialization so you say self
119:18 - name is name all right and you need to
119:21 - prefix this name which itself simply
119:23 - because if you say name is equal to name
119:25 - it just thinks you see it highlights the
119:27 - name it says name is name it's the same
119:29 - thing you're not actually referring to
119:32 - the name inside the structure so you
119:34 - have to say self that name so Swift
119:35 - understands you're referring to this
119:37 - name being assigned the value of this
119:40 - argument okay and then you say self dot
119:43 - manufacturer is Commodore so you
119:46 - yourself take it upon yourself to assign
119:49 - a value to this property okay then you
119:52 - can go ahead and say let's 6 c64 is
119:55 - Commodore computer and you can see the
119:58 - only argument that the call site has to
119:59 - pass to you is the name so you say c64
120:03 - then you can say c64 name and c64 at dot
120:08 - manufacturer and the values will be
120:10 - exactly as you'd expect them so it'll be
120:12 - c64 and the manufacturer will be
120:14 - Commodore as you've set it inside the
120:16 - initializer or the Constructor of this
120:18 - structure okay
120:19 - now there are other ways of actually
120:22 - doing that so what you could have done
120:24 - in here instead of having a custom
120:26 - initializer in here or a Constructor you
120:28 - could have commented this out and he
120:29 - said in manufacturer equal to Commodore
120:32 - like this
120:34 - okay so this would have achieved the
120:37 - exact same result so you don't you don't
120:39 - have to have a custom initializer if you
120:42 - want to assign values to your properties
120:44 - that don't change pretty much okay so
120:47 - just keep that in mind please so there's
120:48 - another way of doing that
120:51 - okay
120:52 - now we've looked at that let's have a
120:54 - look at another type of properties that
120:56 - you can create inside your structure and
120:58 - those are called computed properties and
121:00 - I'm going to show you the Syntax for
121:02 - them now for that let's go ahead and
121:04 - create a new structure so we say struct
121:07 - and we call it person two unfortunately
121:09 - we've already consumed person in here so
121:11 - we can't have another structure called
121:13 - person unless we go ahead and comment
121:16 - this out but we're not going to do that
121:17 - let's just create a person too but
121:18 - please if you're working with production
121:20 - level applications please don't do this
121:22 - please don't call your structures or
121:25 - classes two or three or four unless your
121:28 - business logic requires you to do that
121:30 - okay
121:31 - which in all my years of software
121:33 - development I've never had the
121:34 - requirement of calling something two or
121:36 - three so
121:38 - um just keep that in mind please this is
121:39 - just for the purpose of demonstration in
121:41 - this playground okay so let's go ahead
121:44 - and create a person person structure in
121:48 - here with a first name and last name so
121:49 - I'm just going to say first name
121:51 - is a straight and then I'm going to copy
121:53 - this and go ahead and change at first to
121:56 - last so we have first name and last name
121:58 - now let's say that your requirement in
122:01 - here to create a property for your
122:03 - person 2 structure called full name so
122:06 - this full name should always be equal to
122:08 - the first name and the last name with a
122:10 - space in between it so what you could do
122:13 - is to go ahead and create an initializer
122:16 - for your person too and you could say
122:18 - full name and you can see in here you
122:20 - can't just say full name is equal to
122:22 - first name and last name because you
122:26 - will get actually an error in here and
122:28 - you this this syntax is invalid so let's
122:32 - actually have a look at here cannot use
122:33 - instance member last name within
122:35 - property initializer because at the
122:37 - point of you assigning this value to
122:39 - full name first name and last name are
122:42 - not known so even though this might make
122:44 - sense just looking at it but Swift
122:46 - compiler doesn't work that way so you
122:49 - could be tempted to go ahead and say
122:50 - okay I will create an inch socializer in
122:52 - here
122:53 - and I say first name is a string last
122:56 - name is a string but I don't want you to
122:59 - pass me to full name I can't figure it
123:01 - out on my own so you say cell first name
123:02 - is first name self last name is last
123:05 - name and cell full name is a string
123:08 - consisting of Ace another string which
123:12 - is the first name which is passed in
123:13 - here as a parameter and then we will
123:15 - have a space and then last name so this
123:19 - actually is completely valid Swift Code
123:21 - there's nothing wrong with it I would
123:23 - say however there is a better way of
123:26 - doing that and that is used and that is
123:28 - called computer properties so what you
123:31 - could do is to completely remove this
123:33 - initializer in here
123:34 - and then change this let's to a VAR and
123:37 - then make it a function
123:39 - so this is a computer property when you
123:42 - have a variable and inside and then for
123:46 - the variable value you actually have a
123:48 - function in here okay and in here you
123:51 - could just say first name
123:53 - and space last name so now you actually
123:56 - did what we wanted to do from the
123:59 - beginning when we said equal to you see
124:02 - we try to do this but that didn't work
124:04 - all you have to do really all you have
124:06 - to so this is what we try to do at first
124:07 - but in order to get this to work you
124:10 - have to say first VAR Define the data
124:13 - type
124:13 - to remove the equal sign make it a
124:15 - function and then put the logic in here
124:18 - and that will be valid Swift Code okay
124:20 - so you can now go ahead and create an
124:22 - instance of this structure let's say a
124:25 - let Foo bar is person two
124:28 - we say pers first name is Foo and last
124:31 - name is bar like that then we say Foo
124:35 - bar first name and foodbar last name and
124:38 - then we can have access to a property
124:40 - called full name just like you have
124:41 - access to first name and last name you
124:44 - can see first name is Foo last names bar
124:45 - add full name property or computer
124:48 - property is set to food space bar okay
124:51 - and this is how computer properties work
124:54 - all right
124:56 - now
124:57 - structures the way they're created is
125:00 - that they don't inherently allow
125:03 - mutation right so let's let's have a
125:06 - look at an example every I mean
125:08 - everything we've created so far has been
125:10 - immutable meaning that we haven't been
125:11 - able to change the structure internally
125:13 - we've just instantiated those structures
125:16 - and assigned some values to them and
125:18 - after assigning value to them we
125:20 - couldn't actually change those values so
125:22 - we can't go in here and say c64 name as
125:25 - well so this is going to give you an
125:27 - error because this is not assign it all
125:30 - right you can see we got an error in
125:31 - here okay so how do we make sure that we
125:35 - can create structures that are mutable
125:37 - so you can actually change them after
125:40 - you create an instance of them so let me
125:43 - show you an example of creating a
125:45 - function that can mutate a structure
125:47 - okay so let's create a car in here car
125:50 - structure and then we say current speed
125:53 - is in an integer let's just say current
125:56 - speed then we can pass 10 or 20 meaning
125:58 - 10 kilometers an hour for instance
126:01 - now what if you want to have a function
126:03 - in here a funk drive with a specific
126:06 - speed okay and then in here we could say
126:09 - driving
126:11 - but what we want to do is to change the
126:13 - current speed of this car with the speed
126:16 - that is given inside the drive function
126:18 - so if you say current speed current
126:20 - speed is speed you can see now you
126:23 - immediately get an error in here saying
126:25 - that you cannot do that so it says
126:27 - cannot assign to property current speed
126:29 - and because it is a let constant
126:33 - so you might say okay let's fix that
126:35 - let's change it to VAR then this will
126:38 - not work either because you can see now
126:40 - you get another error saying cannot
126:42 - assign to property self is immutable so
126:45 - the suggestion that and that's uh xcode
126:49 - playgrounds is giving you it says Mark
126:50 - the method as mutating so let's fix that
126:54 - and you can see the suggestion actually
126:56 - works so this function is prefix with
126:59 - the keyword of mutating allowing the car
127:02 - instance to be changed and the reason
127:05 - behind all of this mental gymnastics is
127:08 - that structures inherently are immutable
127:11 - meaning and and they're also date and
127:13 - there are also value types meaning that
127:17 - once you've created an instance of it
127:18 - it's sitting in the stack and it
127:19 - shouldn't be changed but if you create a
127:21 - mutating instance then then a mutating
127:23 - function you're basically bending the
127:26 - rules of how structures are actually
127:27 - working and it's completely valid Swift
127:29 - syntax as well so it's nothing illegal
127:32 - but
127:33 - I think actually in I mean all my years
127:36 - of working with swift it is not so often
127:39 - you want to do something like this and
127:42 - but there are a lot of classes inside
127:44 - Swift itself that have mutating
127:47 - functions but usually when it comes to
127:49 - structures you don't want to mutate them
127:51 - but sometimes you have valid reason to
127:53 - do that okay
127:55 - so let's go ahead and create an
127:58 - immutable car you may be thinking okay
128:00 - but what does that mean but this is a
128:03 - mutating function I'm going to show you
128:05 - what I mean let's create an instance or
128:08 - a variable car called immutable car and
128:10 - we're going to say it's an instance of
128:12 - car and this current speed is 10. then
128:14 - you can go ahead and say immutable car
128:16 - and then you could say drive and with
128:20 - the speed of 20. all right you can see
128:22 - now you're going to get an errand here
128:24 - saying that oops you're calling a
128:26 - mutating member on an immutable value or
128:30 - variable and it says immutable car is a
128:33 - lead constant so what happened here is
128:35 - that since immutable car is let
128:38 - you can't you can't actually call a
128:40 - function that changes the internal value
128:43 - of that let constant and this is one of
128:46 - the very subtle differences between
128:48 - let's and VAR in Swift if you remember
128:51 - when we talked about variables at the
128:53 - absolute beginning of this course I
128:54 - mentioned that there are some small
128:55 - differences between let's and bar which
128:57 - we can't explain right now and this is
128:59 - one of those differences what Swift is
129:01 - doing in here saying that okay you
129:02 - create a let constant in here
129:05 - and you're saying that it is equal to an
129:07 - instance of a structure but then you're
129:09 - going ahead and trying to change it by
129:11 - calling a mutating function on it if
129:14 - this function wasn't mutating and we
129:16 - didn't have this code in here you would
129:18 - be able to easily call it you can see no
129:20 - problem but if this function is marked
129:23 - as mutating you're telling Swift that
129:24 - this function is internally going to
129:26 - change the data inside the structure and
129:29 - since this is a let constant it is not
129:31 - allowed to change either so by changing
129:34 - I mean you're not either allowed to do
129:36 - this so you can't do this and you can't
129:40 - change it internally either so both of
129:43 - these are invalid okay so that's what
129:44 - let's stands for in this case
129:47 - so how do we do that let's just comment
129:49 - this out and go ahead and create now a
129:52 - mutable instance of car how do we do
129:54 - that well of course there's a syntax
129:56 - word and the svar it's a variable it can
129:59 - change so we say mutable car is a car
130:02 - with a current speed of 10.
130:05 - then you can go ahead and say that car
130:09 - Mutual car
130:11 - like this and drive with the speed of
130:13 - 30.
130:14 - and then you see mutable car current
130:16 - speed then you can see the current speed
130:19 - is Gonna Change to 30 in here okay
130:23 - so
130:24 - um what we're going to do then is to
130:26 - have a look at a little bit of copying
130:28 - values and seeing how that also affects
130:31 - our mutual mutability so let's just
130:33 - remove this code for now
130:35 - and if we go ahead and create a let copy
130:38 - of this so we say let's just say copy is
130:40 - immutable car so what what we're doing
130:42 - in here is we're taking the value inside
130:45 - mutable car which is an instance of car
130:48 - and we're assigning it to a new let
130:51 - constant called copy since structures
130:54 - just remember that structures in Swift
130:56 - are value types meaning that if you
130:59 - assign an instance of any structure to
131:02 - another
131:02 - variable the internal data of that
131:06 - structure will be copied over to this
131:08 - variable meaning that now you have
131:10 - duplicate cars one is in the mutable car
131:13 - and another one is in copy and they have
131:16 - absolutely no connection to each other
131:18 - let's demonstrate that and we say
131:20 - mutable car in here and we say drive it
131:22 - at the speed of 30. and then we say
131:25 - Mutual car and current speed and then we
131:28 - say copy current speed now you probably
131:30 - think oh they should both be 30 but you
131:33 - can see that the mutable car which was
131:35 - actually mutated using the drive
131:37 - function
131:38 - it has the current speed of 30 however
131:40 - the copy has the current speed of 10 at
131:43 - the point it was it was taken or
131:46 - basically it took over a copy of mutable
131:48 - car at this point mutable car had the
131:51 - current speed of 10 as you can expect
131:54 - from The Constructor or initializer okay
131:56 - so remember structures are value types
132:00 - when you assign a value of a a let
132:04 - constant for instance or a variable and
132:06 - where it is equal to an instance of
132:08 - instruction to another variable then
132:10 - you're basically getting a copy of that
132:13 - structure and you might be thinking okay
132:15 - is that is that because of let okay
132:17 - let's test that let's change this to VAR
132:19 - and see what happens in here you can see
132:22 - it didn't really change anything by
132:24 - assigning simply assigning an instance
132:27 - of a structure to another variable
132:28 - whether it's VAR or let you're making a
132:31 - copy of this and placing it in here okay
132:34 - so that's a very very important thing to
132:37 - understand about structures
132:39 - so
132:41 - structures in Swift cannot subclass
132:45 - other structures okay and subclassing is
132:49 - something that comes into play when we
132:51 - talk about classes but I'm naming it in
132:53 - here we haven't talked about it yet but
132:54 - I'm naming it here because as I
132:56 - mentioned at the introduction to this
132:57 - course I expect you to already know
132:59 - another program language and chances are
133:01 - you probably know JavaScript or python
133:03 - or Dart for instance or rust and you are
133:06 - probably comfortable with subclassing
133:07 - though rust doesn't really have
133:09 - subclasses it it has the concept kind of
133:12 - like protocols okay but
133:15 - I just want to mention that Swift
133:18 - structures cannot have the functionality
133:21 - of subclassing and I'm gonna I'm gonna
133:23 - explain that how subclassing pretty much
133:25 - works but we're going to go more into
133:27 - details about subclassing when we get to
133:29 - the definition of classes in Swift and
133:32 - that is going to come up soon okay for
133:34 - now let's create a oops a struct and
133:37 - we're going to call it living think and
133:39 - in the init function we're just going to
133:41 - say I'm a living thing all right now you
133:45 - may be thinking okay a living thing
133:47 - could be an animal for instance so we
133:49 - create a structure and we say animal and
133:51 - you would expect it to be able to
133:53 - subclass living thing like this you
133:55 - would say an animal is indeed a living
133:57 - thing but you can't do this this is not
134:00 - a valid uh Swift syntax you can see this
134:03 - is inheritance from non-protocol type
134:06 - living thing so just keep in mind
134:08 - structures cannot inherit from each
134:10 - other in Swift okay
134:13 - so let's comment this code out and we
134:16 - just leave it there leaving thing is
134:18 - still evaluative syntax so we could just
134:19 - leave it there okay
134:22 - now in Swift you can also have custom
134:25 - copying of structures and as we saw when
134:29 - you assign a value inside a variable to
134:32 - like here we had mutable car and you
134:34 - sign it to a copy let constant the
134:38 - entire contents of this mutable car was
134:40 - copied over to this variable but what if
134:43 - you want to have some sort of a custom
134:44 - logic while copying over something to a
134:47 - variable well you have to create that
134:50 - logic yourself let me show you how let's
134:52 - say struct bike
134:54 - we say manufacturer okay and we say
134:57 - string and we say let current speed is
135:00 - integer all right now if you say in here
135:04 - let's bike one is a bike
135:07 - and we have a manufacturer of Harley
135:10 - Davidson in here and we say let's say
135:12 - the current speed is 20. so not nothing
135:14 - illegal and then we're going to create a
135:17 - bike two in here so we say let's bike
135:20 - two and then you say uh bike one now
135:25 - what you want to do in here you say well
135:27 - I want to get bike one but I want to
135:29 - change its as sorry but I want to change
135:32 - its speed when it is being assigned to
135:35 - this variable you can't do that at the
135:37 - moment right because even if you change
135:39 - this to VAR and if you say Bike 2
135:41 - current speed is 30 you can't do that
135:44 - simply because current speed inside the
135:46 - bike is specified as let you can't
135:49 - change it you then go say okay I have to
135:51 - change it to VAR then well you'd be
135:54 - right you can't change it to VAR and
135:55 - everything will just work fine but
135:57 - remember you have to do all of this work
135:59 - simply because you had this requirement
136:01 - in here to assign a bike to another bike
136:04 - and change its current speed there is
136:06 - another way of doing this and it's
136:08 - actually more preferred I would say to
136:11 - do it this way that I'm going to show
136:12 - you is to create a function that allows
136:14 - you to do that so you could go ahead in
136:16 - here and and say well I have a function
136:18 - and I'm just going to call it copy it
136:20 - doesn't have to be called copied you can
136:22 - say copied with or whatever you want
136:24 - okay then you can say copy and then you
136:27 - say current speed so you want to change
136:30 - the current speed so take it in as an
136:31 - argument and then your function could
136:34 - actually return an instance of bike
136:35 - itself then you say okay I create a bike
136:38 - its manufacturer is the sales
136:40 - manufacturer because remember this is an
136:42 - instance method meaning that it is
136:44 - actually operating on an instance of
136:46 - bike itself so it has access to self and
136:48 - the manufacturer and its current speed
136:50 - is going to be the current speed that is
136:51 - coming from the argument itself in here
136:54 - okay
136:55 - so now that you have that you can go
136:57 - ahead at call site in here and say bike
136:59 - one copy with the current speed of let's
137:01 - say 30. and then if you change this back
137:04 - to lats you can see it works as well and
137:06 - by two current speed is now
137:09 - uh 30 and we could also say bike one
137:12 - current speed and you can see that
137:14 - should be 20. so this is one way of
137:17 - creating copies or custom copies of your
137:20 - structures and to be honest with you
137:22 - there's not much more to structures I
137:24 - mean it you have to just get the concept
137:25 - of mutability and structures and also
137:27 - having the ability to have arguments and
137:30 - sorry having the ability to have
137:32 - properties in here we talked about VAR
137:34 - properties as well that can mutate and
137:37 - we also talked about computed properties
137:40 - which can return a value by assigning a
137:44 - function pretty much to and that's
137:46 - argument sorry to that property of the
137:49 - structure so there's not so much more
137:51 - into structures and I think we've talked
137:53 - enough about them in the next section
137:55 - we're going to go ahead and talk about
137:57 - enumerations so let's create the
137:59 - enumerations at Playground now so
138:01 - command n playground
138:03 - and blank playground and let's call it
138:06 - enumerations
138:08 - and in here I'm going to say it is
138:09 - created inside the main workspace let's
138:13 - change the group as well to the main
138:15 - workspace in here and press the create
138:17 - button okay gonna get rid of the
138:19 - Explorer and let's say import Foundation
138:22 - all right now let's talk then about
138:25 - enumerations and immersions are one of
138:29 - my favorite features of Swift and any
138:30 - other program language that supports it
138:32 - and I think actually almost all
138:35 - languages that I've worked with except
138:37 - for assembly of course support
138:39 - enumerations or a form of enumerations I
138:42 - mean Objective C does it C does it have
138:44 - C plus plus does it typescript does it
138:46 - JavaScript is it python does it Dart
138:48 - rust all these languages I've worked
138:51 - with have the concept of enumerations
138:52 - and that's that's very good I mean and
138:55 - they do have enumeration spot to a
138:57 - certain degree they differ from each
138:59 - other so some have more advanced
139:01 - enumerations such as Swift I would say
139:03 - Swift enumerations are the most advanced
139:05 - I've seen and after that rust
139:07 - enumerations are number Advanced and
139:09 - then we have also JavaScript and
139:11 - typescript which are at the same level
139:13 - kind of like Dart animations but also
139:16 - Dart is less advanced in supporting
139:18 - different features of enumerations
139:21 - what are animations I mean I've talked
139:23 - quite a bit now about enumerations but
139:25 - what are they
139:26 - well enumerations are categorization of
139:30 - similar values that are named
139:33 - such as animals cats dogs and rabbits
139:36 - you could put them inside an enumeration
139:39 - now if I for instance ask you and I said
139:41 - let's create a structure in here struct
139:43 - animal and I said define the type of
139:46 - animal in here you would probably say
139:47 - Okay type is a string
139:49 - and I would say okay so can I create an
139:51 - animal and its type is a bike then you
139:54 - say okay so what should we do should we
139:57 - go ahead and create an initializer in
139:58 - here that takes the type and it says if
140:01 - type is a rabbit
140:04 - or type is Doc
140:07 - or type
140:09 - is cat then self-type is type
140:15 - otherwise you create a preconditioned
140:18 - failure
140:19 - of oops it didn't work something like
140:21 - that so this is valence syntax and uh it
140:25 - is going to work but it is not so
140:27 - obvious I mean a lot of cases it
140:30 - probably people don't even see your
140:31 - source code so they have to kind of
140:33 - guess what type they have to pass in
140:35 - here
140:35 - and that is the reason we have
140:37 - enumerations Innovations is the
140:39 - categorization of similar data together
140:41 - by a name
140:43 - so let's have a look at how that
140:45 - actually works let's say an enum animals
140:49 - okay and we can remove the structure
140:51 - from here and this enumeration let's
140:53 - also have our playground as
140:55 - automatically running and it's animals
140:57 - in here then you can Define your
140:59 - different types of animals giving them
141:01 - names and the way to do that is by using
141:04 - a case syntax in here or a case keyword
141:07 - then you say you can't I have a cat I
141:10 - have a dog and I have a rabbit now when
141:14 - I say I have I don't actually mean that
141:16 - these are properties I mean these are
141:18 - cases this animal's enumeration has
141:21 - these various cases and you can also
141:24 - omit case for every one of these cases
141:27 - and remove it and just do it like this
141:28 - as well this is also completely valid
141:31 - Swift syntax so you don't have to prefix
141:33 - every case with the case keyword but a
141:37 - lot of people do that and it allows you
141:39 - to also go to the next line I mean you
141:40 - can also do this but it looks a little
141:42 - bit strange to be honest with you if you
141:43 - do something like this I haven't seen
141:45 - animations in Swift in all my years like
141:48 - I've written like this it's either
141:50 - written like this or it is written like
141:53 - this usually okay but it kind of depends
141:57 - on you and your team how you want to
141:59 - Define your animations I think what
142:01 - would be really good if you and your
142:02 - team decided on a convention
142:05 - of how you want your animations to be
142:07 - created either all of them have case
142:09 - before them or you just have one case
142:11 - for all the cases basically okay
142:14 - so you may be thinking then okay now
142:17 - that we have this how do we create an
142:19 - instance of these animals so we could
142:21 - say let cat is animals dot cat as you
142:23 - can see in here you have all these
142:24 - properties in here cat dog rabbit Etc
142:27 - let's say cat and then we can print it
142:30 - out here to the playground console and
142:33 - you can see it just says cat you can
142:34 - change this to dark and you can see it
142:36 - says dog in here though we have to
142:40 - change the variable name probably as
142:41 - well okay so that's the simplest way of
142:44 - creating an instance of enumeration now
142:48 - you can compare enumerations with if
142:50 - statements so if we go in here and we
142:52 - say if cat is equal to animals cat then
142:57 - this is a cat
143:01 - and we can say else if cat is animals
143:04 - animals dot dog
143:07 - this is a dog otherwise this is
143:11 - something else okay and of course you
143:14 - can continue here you can say else if
143:16 - cat is animals dot uh rabbits however in
143:20 - here you can't say else if cat is equal
143:22 - to three and this just won't work
143:24 - because 3 is an integer and cat is an
143:26 - instance of animals so you cannot
143:28 - compare you can see it says there's no
143:31 - comparison operator between animals and
143:34 - integer and you would be thinking then
143:37 - oh maybe I should go and create one and
143:39 - you could do that you could say funk
143:41 - equality and so this is an in binary
143:45 - infix operator on the left hand side you
143:47 - have an animal animals and on the right
143:50 - hand side you have an integer and you
143:53 - return a Boolean and you could say if
143:55 - you could say you return left hand side
143:58 - left hand side is equal to cat and right
144:02 - hand side equal to three okay so then
144:04 - this returns a Boolean and now you can
144:06 - see your error will go away so you could
144:09 - do something crazy like that in Swift
144:11 - but please don't do it I mean I'm just
144:13 - showing you different ways of doing
144:14 - things but this I just want to tell you
144:18 - that this is not okay to compare an
144:20 - instance of a an enum with an integer
144:24 - for instance okay
144:26 - however there's another way of doing
144:28 - this using its raw value but we haven't
144:30 - talked about that yet so let's just
144:31 - remove this and remove this entire if
144:34 - statement from here like that okay so we
144:37 - just have an else and you can see as you
144:39 - expect this statement is being executed
144:41 - simply because cat is in fact an
144:43 - instance of animals dot cat all right or
144:46 - an instance of animals rather equal to
144:48 - cat okay
144:50 - now if statements are a little bit
144:53 - strange in that you would have to write
144:55 - quite a lot of code if and then else if
144:57 - and then you have to compare them with
144:58 - animals etc etc there's another way of
145:01 - doing this and that is using a switch
145:03 - statement I'm going to show you how to
145:05 - do that if you say switch on an instance
145:07 - of an enumeration then in here you can
145:10 - get help actually from xcode to complete
145:13 - it for you you can see and you just
145:15 - press the fix button and it will tell
145:16 - you that okay I know that cat is an
145:19 - instance of animals and I know animals
145:21 - has cat and dog and rabbit I will type
145:24 - it out all for you so you can see that
145:26 - syntax is case and then the enum value
145:29 - and then you can type some code in here
145:31 - and you can say break meaning that as
145:34 - soon as it hits that point you just
145:35 - break out of this switch statement like
145:37 - this okay so let's go ahead in here and
145:39 - say this is a cat
145:41 - and this is a dog and this is a rabbit
145:45 - all right so we've written our code and
145:48 - we expect this line to be executed and
145:50 - if you go ahead in here and change the
145:52 - value of cat to a dog then this case is
145:55 - going to be executed you'll see soon
145:56 - this is a DOT right
145:59 - so let's change it back to cat again so
146:01 - this is how you would do a switch
146:03 - statement and then there's a Syntax for
146:06 - switch statements where you don't have
146:09 - to specify all the cases so if you don't
146:11 - want to specify the case of rabbit you
146:13 - can also do that just remove it but
146:14 - you're going to get an error now as
146:16 - you'll see soon it'll say that you
146:18 - haven't covered all the valid cases it
146:21 - says it must be exhaustive meaning that
146:23 - you have to cover all the cases but if
146:25 - you don't want to cover all the cases
146:27 - there is a special syntax called default
146:29 - in here and say this is something else
146:31 - which is similar to our else statement
146:34 - right so these two are pretty much the
146:37 - same our One is using a switch the other
146:39 - one is using a um an if and else
146:43 - statement now
146:45 - oh I probably I should tell you that
146:48 - this is usually not a good idea
146:51 - specifying a default clause simply
146:53 - because in the future I mean uh let's
146:56 - let me actually demonstrate to you let's
146:58 - go ahead and in here say that you have a
147:01 - funk and you want to say describe animal
147:04 - and then you say animal
147:07 - is of type animals okay then you go in
147:09 - here and you say describe animal
147:13 - and let's change the switch to uh from a
147:16 - cat to an animal in here which is passed
147:18 - to us then we say describe animal and we
147:22 - pass our cats to it okay
147:25 - um in the case of cat we're saying this
147:27 - is a cat in the case of dog we're saying
147:29 - that this is a dog and in here actually
147:31 - we don't have to pass Cat to it we can
147:33 - say animals dot rabbits
147:35 - okay if we do that you can see it says
147:38 - this is something else now what if we go
147:41 - ahead and add another case in here and
147:43 - we say case Hedgehog I think it's
147:46 - spelled like this now you can see our
147:49 - function is still saying this is
147:50 - something else so for every case of our
147:54 - um animals where it is not handled it's
147:58 - neither cat or a dog it's saying this is
148:00 - something else well this might work in
148:02 - this example but usually in larger
148:04 - applications when you add a an enum case
148:07 - to your animations you want everywhere
148:10 - where you have a switch statement to
148:12 - actually take care of that case okay so
148:15 - let me show you how if we remove this
148:17 - case from here so we have cat dog and
148:19 - rabbit again we go in here and we bring
148:21 - the case of
148:23 - at rabbit okay and we say this uh this
148:27 - is a rabbit and we break okay and we can
148:30 - actually take this out we don't have to
148:32 - have it inside a function anymore we
148:34 - take it out all right and then say in
148:36 - here we say switch cats so we have all
148:39 - the cases covered now cat dog and rabbit
148:41 - now if another programmer inside our
148:43 - team goes ahead and adds a case of
148:45 - Hedgehog you can see our if statement
148:47 - still works and you might be thinking
148:49 - well the if statement still works it
148:51 - must be good but the switch doesn't work
148:53 - so it's not good however in my opinion
148:57 - where you go ahead and add a new case on
148:59 - enumeration you need to also always
149:02 - ensure that everywhere you're handling
149:05 - an instance of that enumeration you're
149:08 - taking care of the new case as well the
149:10 - if statement doesn't do that it doesn't
149:12 - fail because it's simply doing
149:14 - comparison however switch is doing more
149:17 - than that it's ensuring that if you're
149:18 - switching on an enumeration that the
149:21 - enumeration cases must be exhaustive
149:22 - meaning that you have to cover all the
149:24 - cases so in in my opinion with my
149:28 - experience it is always almost always
149:31 - best to compare enumerations using
149:34 - switch okay because it will tell you
149:36 - that oh you can't upon your code now
149:38 - because someone has gone and added a new
149:40 - case through the switch you have to
149:42 - handle that so let's handle Hedgehog in
149:44 - here and we say this is a hedgehog
149:48 - okay and we break
149:50 - so now you can see it is handled and
149:53 - though this is still a cat so this
149:55 - statement is being called but at least
149:57 - we've handled the case of adding a
149:58 - hedgehog in here okay
150:01 - now now that we've taken care of that
150:03 - let's talk about enumerations a little
150:06 - bit more advanced enumeration Concepts
150:07 - and that is enumerations with Associated
150:09 - values okay animations in Swift have the
150:13 - ability to have Associated values a dart
150:15 - for instance for those of you who are
150:16 - flutter developers you probably think
150:17 - that Dart also has that but
150:19 - unfortunately it doesn't and in Dart
150:22 - enumerations you create an enum and you
150:25 - can't make it a class almost by adding
150:27 - properties to it and then you create
150:28 - enum cases that hard code the values of
150:31 - those properties and that's not really
150:32 - the same thing as having enumerations
150:35 - with Associated values like Swift and
150:37 - rust half because as you'll see soon
150:40 - enumerations in Swift can have
150:42 - Associated values that are dynamically
150:43 - added at the time of creating the an
150:46 - instance of that narration okay let's
150:48 - for instance have a look at an
150:50 - integration called shortcuts or
150:52 - shortcuts
150:53 - let's say in here you want to create
150:55 - three shortcuts and one is called for
150:58 - instance a case File or folder okay
151:01 - another one is a www URL and then a
151:05 - shortcut to a song so let's say that
151:07 - you're creating an enumeration that can
151:08 - allow the user to do a shortcut to any
151:11 - one of these cases either a song for
151:13 - instance on Spotify or a website address
151:16 - or a file or folder
151:18 - now how do you go ahead and do that how
151:21 - do you then say okay this let's say let
151:23 - www.apple
151:25 - is shortcut
151:27 - to www URL but how do we specify that
151:31 - this is actually going to go to Apple
151:33 - all right then you you would probably
151:34 - think that okay I want to add case
151:38 - www.apple.com or something like that
151:41 - well if you had to do that then you
151:43 - would have to create a case for every
151:45 - website in the world and that won't work
151:48 - and that is the reason we have
151:49 - Associated values for enumerations is
151:52 - Swift and rust
151:53 - so let's go ahead in here and you say I
151:56 - want to add some values to these guys
151:57 - whoever is creating an instance of any
152:00 - of these cases has to pass some values
152:01 - to them then we say for instance here
152:03 - the path is a URL you see in here okay
152:06 - so then at the call side we're creating
152:09 - an instance of this WWE URL you have to
152:11 - pass it a URL okay so we say let's go to
152:14 - the path and we create a URL and in here
152:17 - we say it's a string of https and
152:19 - apple.com and we force on rapid we
152:22 - haven't talked about this operator yet
152:24 - actually I think we talked about it once
152:27 - is um this is a unary suffix
152:31 - operator which we've actually seen an
152:34 - example of before
152:35 - okay when we're talking about optionals
152:38 - but you see we haven't gone into depth
152:40 - and with options yet so just accept that
152:43 - this is a URL for now okay but we don't
152:46 - have to know exactly what this one does
152:48 - I'm going to explain it soon when we go
152:50 - and talk about options
152:51 - all right so you can see now we actually
152:53 - passed a value to an instance of this uh
152:57 - enum case and you can do the same thing
152:59 - for others like file or folder we could
153:02 - say it has a path to a URL and it has a
153:05 - name of string okay and we could say a
153:07 - song has an artist a of type string and
153:11 - a song name of type string all right so
153:14 - this is up to you I mean it's really up
153:16 - to your imagination What values you want
153:18 - to have associated with your enum cases
153:20 - okay
153:22 - now you would be thinking okay now that
153:25 - we have this guy how do we compare it
153:27 - with like if if there is a case in your
153:30 - application where you get a copy of an
153:33 - enumeration or an instance of this
153:34 - enumeration if you want to see whether
153:36 - this is a song or a URL or a file or
153:39 - folder how do you do it so you would
153:41 - probably say of if ww apple is equal to
153:44 - shortcut dot dot URL and then let's say
153:48 - you pass this URL to it
153:50 - boom then do this okay so you may be
153:54 - thinking okay I could do that but no you
153:56 - can't really do that you can't do
153:57 - comparison between an enum instance with
154:01 - associative value and another in
154:03 - immenses with the same associative value
154:04 - because as soon as you add Associated
154:07 - values to enumerations in Swift you
154:09 - basically you need to Define equality
154:12 - for this enumeration yourself there is
154:14 - no equality by default anymore in this
154:17 - case when we had animals and there was
154:19 - no associative values we could do this
154:20 - because Swift adds implicit equality
154:24 - operator which is a binary infix
154:26 - operator to enumerations with no
154:28 - Associated values by default but as soon
154:30 - as your animations have Associated value
154:32 - Swift doesn't know how to compare them
154:33 - anymore because it's not the comparison
154:35 - of their cases anymore but you actually
154:38 - have to define a comparison yourself
154:39 - maybe you want to only compare the names
154:42 - in the case of file or folder maybe you
154:44 - don't care about the path maybe in the
154:46 - case of a song you don't care about the
154:48 - artist you just want to basically
154:50 - compare the song names so Swift can't
154:52 - deduce that equality operator for you
154:56 - so you can't do that unless you go ahead
154:58 - and you go ahead and and basically
155:00 - Define equality operator which is a
155:02 - little bit more advanced than what we're
155:04 - going to go into right now so as you'd
155:06 - guess you can rely on your friend switch
155:09 - statement so we say switch dot Apple in
155:12 - here and we can actually ask Swift to
155:14 - complete this for us you'll see now
155:16 - it'll be a little hint in here it says
155:18 - fix and you can see it will come up with
155:21 - all the cases for us okay now I usually
155:24 - don't like the default format that is
155:27 - created in here but we can use it for
155:30 - now I'm just going to break them down
155:32 - into smaller parts in here into smaller
155:34 - bits of pieces of code now in here we
155:37 - could say print the path print the name
155:39 - and then break okay in here as well
155:42 - we're going to say print the path and
155:43 - then break and then here we're going to
155:45 - say take the artist to its own line sign
155:48 - name to its own line and then print the
155:51 - artist
155:52 - and then print the song name and then
155:55 - break
155:56 - like that all right so now we can see
156:00 - that we're going to hit this point
156:03 - and it says that you are the path of
156:05 - this URL is actually apple.com all right
156:08 - and actually I think in here yeah it was
156:10 - called path as well but here it doesn't
156:12 - have to be called the same just so you
156:14 - know this path it doesn't have to be so
156:16 - you could say let P okay the important
156:19 - part is this one
156:21 - now there is another way uh you can also
156:25 - remove the argument names so you can see
156:28 - in here it says there's an argument name
156:29 - path and then it's a let path let's copy
156:33 - this and make it cleaner let's copy this
156:34 - entire thing so this is what Swift
156:36 - suggests that you do but usually in
156:39 - codes in code bases or at least the ones
156:41 - I've worked with no one does this okay
156:43 - no one says here's the artist and then
156:46 - let's artist no one does that what
156:49 - usually people do is go ahead and chain
156:51 - and remove this external argument naming
156:53 - here and just leave the let's in here
156:55 - okay so remove the path and remove the
156:59 - previous thing in here as well and this
157:01 - and you will see that this works exactly
157:03 - the same as the other one all right so
157:07 - uh that's another way of writing it and
157:10 - what is also very very common in Swift
157:13 - uh code bases is that people don't like
157:16 - the syntax of writing let's before every
157:18 - argument name either so you could copy
157:20 - this code now let's clean it up even
157:23 - more gonna paste it here and remove all
157:26 - these let's
157:27 - okay so that let
157:31 - this let as well and also these lengths
157:34 - from here and what we're going to do is
157:36 - to go ahead right after the case type
157:39 - let
157:40 - right after the case type let right
157:42 - after the case type lets so this let is
157:45 - going to be applied to all of these
157:47 - arguments in here and you can see it
157:49 - works exactly the same way as it did in
157:52 - the other two examples every example is
157:54 - going to become shorter and more compact
157:56 - than the one before it basically okay
158:00 - really good now there's another very
158:03 - compact way of unpacking values inside
158:07 - in iterations that have Associated
158:10 - values
158:12 - now there was two values in my sentence
158:14 - but I think you get the point and that
158:15 - is using an if statement in very rare
158:19 - cases if you want to only handle a
158:21 - specific enum case uh for instance in
158:24 - this case you want to see if this dot
158:26 - dot apple is an actual URL you could use
158:30 - a if Case let statement you could say if
158:33 - Case let
158:35 - and to be honest with you in all my
158:37 - years of doing Swift I still get this
158:39 - wrong almost every time I sometimes type
158:41 - if let case and sometimes if case
158:44 - something something and then let but the
158:46 - actual syntax is if Case let all right
158:49 - and then you say the case is dot dot URL
158:53 - which is your actual enum case and then
158:55 - you say pass is equal to your variable
158:59 - then you can print out the past so you
159:02 - can see it's printed in here so you can
159:04 - in here then say it could be anything
159:06 - else it could be file or folder and then
159:08 - you could say path and then name
159:11 - all right equal to
159:14 - your enum case like this
159:16 - and you can see it is not executed
159:18 - simply because.apple is not an instance
159:20 - of file or folder enum case in here
159:23 - let's change it back then to drop.url
159:26 - and then we can grab the path out of
159:29 - this variable instance or
159:32 - a shortcut instance in here okay
159:35 - now while you're working with enums you
159:39 - can also ignore values inside the enum
159:42 - cases let me show you how let's say we
159:44 - create a an instance of shortcut we say
159:47 - without you is an instance of shortcut
159:49 - to a song by one of my favorite artists
159:52 - Symphony X and the song name is called
159:55 - without you so one of the really good
159:57 - songs of Symphony X I highly recommend
159:59 - that you watch it and sorry and listen
160:01 - to it if you want to I don't actually
160:04 - think there is a music video to it
160:06 - unfortunately uh but there may be one of
160:09 - these lyrics uh music videos to it on
160:11 - YouTube
160:12 - so now we have without you and we want
160:14 - to compare it if it's a song by
160:17 - um for instance only looking at its song
160:20 - name so we say if uh case let
160:24 - and it is it a song and we don't want
160:27 - actually we don't care about its artists
160:29 - so we can ignore the artist using an
160:31 - underscore in here but we only care
160:33 - about the song name and we say if that
160:35 - is equal to without you
160:37 - in here then we can grab the song name
160:40 - okay so you can see it's it says without
160:43 - you without actually using the artist in
160:46 - here you could also say artist and then
160:47 - type the artist in here as well and grab
160:49 - that artist you can say it's a Symphony
160:51 - X but if you want to ignore the artist
160:53 - you can just pass underscore in here
160:56 - okay
160:57 - really good now you can also have a
161:02 - case statements and switching case for
161:06 - enums with Associated values that have
161:08 - similar data types okay let me let me
161:11 - actually show you an example of it let's
161:13 - go ahead and create an enum of a vehicle
161:15 - all right and we say one is a car and
161:18 - every car has a manufacturer of type
161:21 - string and a model of type string and
161:25 - then we have bikes as well and with
161:27 - manufacturer as well
161:29 - and like this but for bikes we don't
161:32 - want a model we want a year made integer
161:34 - okay so this is an enumeration now you
161:36 - may be thinking okay let's say that you
161:39 - have this business case of uh every time
161:42 - you access an instance of vehicle you
161:45 - may want to grab its manufacturer so how
161:48 - do you do that let's let's go ahead and
161:49 - say let car is vehicle
161:53 - and how do we do that let's say
161:54 - vehicle.car
161:56 - for its manufacturer we say it's a Tesla
161:59 - and for model we say it's model X then
162:01 - we say let's bike is a vehicle bike okay
162:05 - and its manufacturers Harley Davidson
162:08 - and it's your mate let's say 1987 or
162:11 - something like that okay just making
162:13 - things up in here okay now how do you
162:16 - grab the manufacturer out of these two
162:18 - like you have a car and you have a bike
162:20 - and you want to grab their manufacturers
162:22 - you know both of them have a
162:23 - manufacturer but how do you grab that
162:26 - well you could go ahead and say okay I
162:29 - switched the car I'll let Swift extract
162:32 - this information for me for all the
162:35 - cases then add this in here then you say
162:39 - okay I have the manufacturer I will
162:42 - learn that we can have a let statement
162:43 - in here and remove all of this in here
162:45 - so we have the manufacturer we don't
162:47 - care about the model so underscoring
162:48 - here then you say manufacturer
162:50 - manufacturer and then you break and you
162:53 - do the same thing for bike okay you say
162:55 - case let manufacturer is right there and
162:58 - the year made we ignore and then in here
163:01 - you say manufacturer and break okay so
163:04 - this is a switch on the car all right
163:06 - and you can see we grabbed the Tesla
163:08 - manufacturer out of that car but what do
163:10 - we do with the bike oh yeah we have to
163:12 - go ahead and do the same thing for bike
163:14 - we go ahead in here and we say switch on
163:17 - the bike and we say in this case since
163:20 - it's a bike you see Harley Davidson is
163:22 - extracted then you may be smart and say
163:24 - okay
163:25 - I'm sorry and not you may be smart you
163:28 - are smart but you might try to be smart
163:30 - to say okay then I can create a function
163:32 - out of this then I will say funk
163:35 - um
163:36 - get manufacturer
163:39 - from vehicle
163:41 - okay and vehicle of type vehicle and it
163:46 - returns a string and in here you could
163:49 - just say return
163:50 - manufacturer and return manufacturer you
163:54 - could do that as well okay so this is
163:56 - actually one step closer to making this
163:58 - a little bit more usable and then you
164:00 - could call gets manufacturer
164:03 - uh from car and then gets manufacturer
164:07 - from bike as well okay so you could do
164:10 - that as well so you get Tesla and then
164:12 - oops
164:14 - what happened to our bike the
164:17 - manufacturer should be Harley Davidson
164:19 - so car manufacturer bike manufacturer oh
164:22 - because we're switching on car this is
164:24 - very very bad we should switch on the
164:26 - vehicle in here okay which is a local
164:28 - variable to the function then we get our
164:30 - Tesla and we should now soon get Harley
164:32 - Davidson so this is this is another step
164:34 - towards having a more reusable
164:37 - extraction of manufacturer from our
164:39 - vehicles what you could do is to move
164:42 - this actually out and place it inside
164:45 - the enum itself and instead of switching
164:48 - on a vehicle that is passed as a
164:50 - function we can remove this and say we
164:53 - switch ourself all right and then we go
164:55 - in here and then we can say car gets
164:58 - manufacturer okay and then we could say
165:00 - bike gets manufacturer right
165:04 - so that's one one more step actually
165:06 - towards having it a little bit more
165:08 - Compact and having it make more sense so
165:10 - it's a car get manufacture and buy get
165:12 - manufacturing now both of them have the
165:14 - same function however what you could do
165:16 - is to have this as a computed property
165:19 - enums just like structures can have
165:21 - computed properties so let's say VAR
165:24 - and we change it to manufacturer and we
165:28 - say it returns a string
165:30 - and now all of a sudden you don't have
165:31 - to call this as a function you can
165:33 - actually say manufacture just like a
165:36 - property right like this
165:39 - good now it's one step closer to having
165:41 - it very clean there's one more thing
165:43 - that we can do to have it even better
165:45 - and that you can see that these both
165:47 - cases case let car case like bike
165:50 - they're pretty much doing the same
165:51 - comparison they're extracting a
165:53 - manufacturer and ignoring the second
165:55 - value well what if we could just remove
165:57 - this
165:58 - and remove this case
166:01 - and have a comma here instead so we say
166:03 - in both cases the case of car and byte
166:06 - we're returning the manufacturer and you
166:08 - can see that this is valid Swift code
166:10 - and it is doing the exact same thing
166:13 - right so if you have pattern matching in
166:16 - your enumerations like this where two
166:18 - enum cases or more are having the same
166:20 - pattern matching by grabbing one value
166:23 - and it doesn't necessarily have to be
166:25 - this to be honest with you it could it
166:27 - could for instance be in the case of
166:28 - bike and sorry in here model and you can
166:32 - ignore this one and instead use the
166:34 - model in here so actually you then have
166:36 - to call them the same thing let's say
166:38 - Foo Foo and then you return Foo okay so
166:43 - pattern matching Works basically just by
166:45 - matching the value types since both of
166:47 - these are strings and the other stuff is
166:50 - being ignored then you can use this food
166:52 - but we actually broke the code because
166:54 - instead of the car manufacturer we're
166:56 - returning the car model in here but I
166:58 - just wanted to demonstrate to it doesn't
166:59 - necessarily have to be at the same place
167:01 - so it doesn't necessarily have to be
167:02 - like the same at first value of both
167:05 - cases okay so this is a computer
167:07 - property on an enumeration
167:10 - and it is returning and it's doing a
167:13 - pattern matching on the both cases and
167:16 - it doesn't have separate case statements
167:18 - in here okay
167:20 - really good that part's also done now
167:23 - apart from enumerations with Associated
167:26 - values you can also have enumeration
167:28 - with raw values and here's an example of
167:31 - that so let's go ahead and say enum
167:33 - family
167:34 - member and then in here you can actually
167:36 - say that we have a case of Father case
167:40 - mother case brother and we have a case
167:43 - sister but what if you want these cases
167:46 - to for father for instance to be called
167:49 - Dad so to have that value of that so you
167:52 - want to for instance have a mother be
167:54 - equal to Mom then you can say Okay
167:56 - father is that
167:58 - mother is Mom
168:00 - brother is bro and sister is sis okay
168:03 - but we're gonna get an error now simply
168:05 - because it says that this integration
168:07 - can't have values like raw values like
168:10 - this what you need to do is to tell so
168:12 - if that this enumeration has raw values
168:14 - of a specific data type like this so you
168:16 - could say it is a string basically all
168:19 - right and now Swift is very happy so
168:21 - what you could do then is to say family
168:23 - member dot father and then you have a
168:26 - new property in here called raw value
168:27 - then you can grab that Dad value out of
168:30 - Father case and it is a string you could
168:34 - do the same thing with brother or mother
168:36 - and sister as well okay so brother is
168:38 - going to say bro in here
168:40 - okay
168:42 - um now you can also have a enumerations
168:45 - in Swift that have that you can extract
168:50 - other cases because if you go into
168:52 - family member at the moment
168:54 - you can see that you have brother blah
168:56 - blah in it raw value but you don't have
168:59 - you you don't have the possibility
169:01 - of extracting all the cases inside this
169:04 - iteration but you can do that in Swift
169:06 - by conforming to a protocol called case
169:09 - I turbo we haven't talked about
169:11 - protocols yet we're going to do that
169:13 - soon but for now just it's enough if you
169:16 - understand the syntax so let's say
169:18 - enough favorite emoji
169:20 - and we say it is a string and also we're
169:23 - conforming to a protocol called case I
169:25 - trouble okay just learn it for now that
169:27 - if you do this Swift allows you to go
169:29 - through all the enum cases using a
169:31 - property as you'll soon see so let's say
169:33 - case blush is equal to blush in here
169:36 - okay
169:38 - and we say case rocket is rockets in
169:42 - here
169:43 - we then say case fire is
169:46 - fire like this all right then you can go
169:50 - ahead and say favorites emoji
169:53 - and like that and we say we have a new
169:55 - property here all of a sudden call all
169:57 - cases all right you can see it says
169:59 - blush rocket and fire so it gives you
170:01 - all those cases okay and also you can
170:04 - grab their values you can say favorite
170:05 - emoji not all cases now we're going to
170:08 - use a function called map and we're
170:10 - going to get their raw value and please
170:11 - don't worry if this doesn't make sense
170:13 - I'm just demonstrating what you can do
170:15 - but we're gonna talk about these things
170:17 - when we talk about collections later all
170:20 - cases is now an array of your favorite
170:23 - emojis okay so if you make an
170:25 - enumeration conform to this case I
170:27 - triple protocol I think it is actually a
170:30 - protocol yes then you can you can grab
170:33 - all the cases out of your uh out of your
170:36 - enumeration using all cases property
170:38 - okay
170:41 - now now you have enumerations you can
170:44 - also I mean you can create instances of
170:46 - them using like uh favorite emoji.blosh
170:49 - favorite emoji.rocket but if you have an
170:53 - if you have the value of an enumeration
170:55 - how can you create an instance of it so
170:58 - using so right now we have been able to
171:00 - say favorite emoji.blosh dot raw value
171:03 - so we get the value but if you have the
171:05 - value can you reverse it into blush so
171:09 - if you have an emoji like this
171:12 - can you actually grab an instance a
171:14 - favorite emoji using the Emoji itself
171:16 - and yes of course you can do that and
171:19 - the Syntax for it is if let blush is
171:22 - favorite emoji and you can say using a
171:25 - raw value of your emoji in here then you
171:28 - say found the blush emoji and then you
171:31 - can print it out to the console
171:32 - otherwise this Emoji doesn't exist like
171:37 - this else if I can spell it right now
171:40 - you can see it says found the blush
171:43 - emoji and then it actually prints it out
171:45 - which is blush it's not the Emoji itself
171:47 - you see it is actually the blush case of
171:50 - the Emoji
171:51 - the favorite emojis enumeration favorite
171:53 - emoji you can see in here okay
171:55 - but don't worry too much about this
171:57 - because we're going to talk more about
171:59 - these in later chapters when we talk
172:01 - about optionals at the moment we haven't
172:04 - talked about optionals so this might
172:06 - look a little bit strange to be thinking
172:07 - what is a flat well it is strange
172:10 - because we haven't talked about them yet
172:11 - but this is just an example all right
172:14 - let's copy this as well and do another
172:16 - example then we say let's see and create
172:19 - instead of blush in here we're going to
172:21 - say snow and we say
172:23 - snow exists really so let's Pass snow in
172:28 - here and see what happens because we
172:29 - haven't defined snow as one of the cases
172:31 - in here you see we don't have a snow
172:33 - Emoji so and then we say
172:36 - try to create an instance a favorite
172:39 - emoji with this note and if it is
172:41 - created then type this snow exists
172:44 - really okay and then we can in here say
172:47 - as expected snow doesn't exist in our em
172:52 - so we expect actually to get in here
172:54 - because snow doesn't exist as one of the
172:56 - cases of our enumeration okay
173:00 - now we've looked at these and don't
173:02 - worry about these two particular
173:03 - examples because they're using optionals
173:05 - and we'll talk about options more in the
173:08 - future okay now let's talk about
173:11 - mutating members of enumerations now
173:14 - just like in structures you can have
173:17 - mutating functions inside enumerations
173:19 - and the way to do that is by prefixing
173:22 - the function with mutating as you did
173:25 - with structures so let's say enum height
173:28 - and then we say we have cases of short
173:30 - medium and long and then we have a
173:33 - mutating funk in here
173:35 - Funk make long all right and by mutating
173:40 - an enumeration you're pretty much just
173:41 - assigning a new value to self because
173:44 - there's not much more you can mute it
173:45 - with an enumeration than actually
173:46 - mutating it itself so in here then you
173:50 - can say self is equal to height dot long
173:53 - all right so you can basically assign it
173:57 - back to your own self and change
173:59 - yourself instance using a mutating
174:02 - function on an enumeration okay so let's
174:05 - go ahead and say we have a variable my
174:07 - height is equal to height medium and
174:10 - then we say my height make long and then
174:13 - we say my height let's see what it is
174:15 - so once it is executed first is medium
174:18 - and then we made the heights equal to
174:20 - long in here as you can see okay
174:23 - and if this was a let constant then you
174:27 - wouldn't be able to do this you will see
174:29 - now that make long can't be executed
174:32 - simply because it is trying to mutate
174:34 - self all right
174:37 - good now we're done with that now and
174:40 - there is another Concept in Swift
174:42 - iterations which is a little bit more
174:44 - advanced but I wanted to just name it
174:46 - and they're called recursive
174:48 - enumerations or indirect iterations and
174:50 - in all my years of working in Swift I
174:53 - think I've used them once once or twice
174:56 - it is very uncommon that you see
174:58 - indirect enumerations and that's why
175:00 - I've left them as the last concept to
175:02 - explain it here but I think it's still a
175:04 - good idea uh to explain them so let me
175:06 - show you what indirect or recursive
175:09 - enumerations are in short a recursive
175:12 - Innovation as its name indicates is an
175:14 - enumeration that refers to itself so in
175:17 - here you can see we had Integrations
175:18 - that just have short medium long and
175:20 - even have we had iterations in here with
175:22 - Associated values that we're not
175:24 - referring to themselves you can see in
175:26 - here they just had associate values of
175:28 - URL but no Associated values of touch
175:30 - shortcut again okay but let's go ahead
175:33 - and create a new enumeration in here
175:34 - which has reference to itself we say
175:36 - enum int operation
175:39 - and then we say we have a an addition
175:42 - let's say so we're ex we're basically
175:45 - defining an addition between two
175:47 - integers okay so it's just a case it's
175:50 - not a function we say k subtract and
175:53 - then we subtraction subtractions between
175:55 - two integers as well and then we can
175:58 - have a free hand this is a special uh
176:00 - case that we're creating which refers to
176:02 - ins operation itself all right so what's
176:05 - happening in here now you see we'll
176:07 - again an error saying that you cannot
176:09 - have error you cannot refer to yourself
176:12 - unless you mark this enumeration as an
176:15 - indirect enum as you can see in here
176:18 - okay so you can now see that issue has
176:21 - disappeared but what does this actually
176:23 - really mean and what it means is that
176:26 - now you can have a free hand operation
176:29 - on this ins operation and I I completely
176:32 - understand this is a little bit
176:32 - complicated and we don't have to learn
176:35 - this but let's just let's just see how
176:37 - we can create a function now on this
176:39 - enumeration that calculates the results
176:41 - based on the cases let's say we have
176:44 - funk
176:45 - calculates results and we say that the
176:50 - parameter is off operation
176:54 - and we say ins operation in here okay as
176:57 - optional
176:58 - and we say that's equal to nil
177:00 - and again I completely understand we
177:02 - haven't talked about these yet either
177:04 - and in here we could then basically
177:06 - calculate the operations and by doing a
177:09 - switch statement I'm just I'm just going
177:11 - to paste that in here so we don't have
177:12 - to type all of this to be honest with
177:14 - you okay
177:15 - so let's see what happening here we have
177:17 - the operation or self
177:20 - an unexpected non-void return value and
177:22 - in here we should return an integer as
177:24 - well okay so what's happening is that
177:26 - we're we're basically switching on this
177:28 - operation since it's optional we're
177:30 - saying either the operation or self
177:31 - itself and we're saying if it's an
177:34 - addition then do addition if it's a
177:36 - subtraction do subtraction if it's free
177:38 - hand let's actually change this to
177:40 - freehand with a capital H if I can spell
177:42 - if it's freehand then call this function
177:45 - recursively with that operation
177:48 - and the result to this really is that
177:51 - you can go ahead now and say let
177:53 - freehand
177:54 - is into operation dot freehand okay and
178:00 - in here then you can say do an addition
178:02 - of two and four
178:04 - and then you can say freehand uh and you
178:07 - can say freehand dot calculate results
178:11 - and then you can see the result being
178:13 - printed in here of six
178:15 - again please don't worry this is very
178:17 - complicated this is almost going to like
178:19 - Advanced Swift and as I said in all my
178:22 - years of working with
178:24 - um Swift I've had to use I think once or
178:26 - twice uh indirect iterations and if you
178:29 - didn't learn this it's completely fine
178:31 - it was kind of expected to answer it and
178:34 - that's one of the reasons I'm kind of
178:35 - jumping over it and pasting code because
178:37 - I don't think there's so much value in
178:39 - spending time learning about indirect or
178:42 - recursive enumerations so just know that
178:45 - they exist but you don't have to learn
178:48 - it okay so let's close off the
178:51 - iterations chapter with this indirect
178:54 - iteration and that is probably a better
178:56 - idea actually if you just remove this
178:58 - whole thing from here so you don't have
178:59 - to be taunted by the thought of having
179:01 - indirect iterations
179:04 - so uh at least for me it doesn't feel so
179:06 - good to end the chapter with something
179:08 - that we just jumped over but I just want
179:11 - to explain that this exists so you know
179:13 - about it okay
179:15 - good now we're done with enumerations in
179:18 - the next section of this video we're
179:20 - gonna talk about classes now that we've
179:22 - talked enough about enumerations let's
179:24 - go ahead and talk about the next concept
179:27 - which we've actually named before and
179:29 - you probably know them from other
179:31 - programming languages that you're
179:32 - already familiar with and that concept
179:35 - is classes so let's create a separate
179:39 - um
179:40 - blank playground for this so let's say
179:43 - playground in here and we say blank
179:45 - playground and let's call it classes and
179:48 - just again ensure that you're creating
179:50 - it inside your main folder or workspace
179:54 - and then we say in here create
179:57 - and like we usually do we just say we
179:59 - need to import foundation in this
180:02 - playground and again hold and the
180:05 - trackpad in here and say automatically
180:07 - run okay
180:08 - so we have structures in Swift and we
180:12 - also have enumerations but there's a
180:14 - third category of storage space you
180:18 - could say in memory and that is called a
180:21 - class and and classes are like
180:24 - structures but they're not value types
180:27 - they're reference types and also they
180:30 - allow for mutability without having to
180:32 - prefix things for instance with mutating
180:34 - a syntax or keyword so let's have a look
180:38 - at a simple class in here so I'm just
180:40 - going to say class person and let's say
180:42 - VAR name String and then bar age ends
180:46 - okay
180:47 - and so this is a simple class now it has
180:49 - two variables and let's see oh we're
180:52 - getting an error in here and simply
180:53 - because we have no initializers and this
180:55 - is actually really good we're getting
180:56 - this error
180:58 - um because
180:59 - um I actually didn't think of explaining
181:00 - this first but now that it has appeared
181:03 - let's talk about it as you saw before if
181:06 - you have a structure like let's say in
181:08 - here we say class person sorry struct
181:10 - person
181:11 - and let's actually put exactly the same
181:13 - code inside the structure and comment
181:15 - the class out and you can see everything
181:17 - will just go fine with the structure you
181:20 - don't need an initializer or a
181:22 - Constructor for a structure by default
181:24 - an implicit one will be created for you
181:27 - with all the member variables added to
181:30 - the argument list of the Constructor so
181:33 - if you say person you can see name and
181:35 - age are already there
181:37 - however when it comes to classes you
181:39 - always have to create Constructors
181:41 - yourself there is a refactoring feature
181:43 - in xcode where you can ask xcode to
181:46 - create the Constructor for you I'm not
181:48 - sure if it is available inside
181:50 - um playgrounds and we can see that it
181:52 - isn't maybe there is a menu somewhere
181:55 - let's let's say Constructor or
181:58 - initializer generate member-wise
182:00 - initializer and that's the one but it
182:02 - doesn't seem to really work in
182:04 - playgrounds so we need to just use this
182:06 - little hint in here and ask it to
182:08 - perhaps
182:09 - oops yes it is not really allowing us to
182:13 - actually add an initializer it's trying
182:15 - to add a default value to these
182:16 - properties and that's not what we want
182:18 - to do so a class's first difference to a
182:21 - structure is that it needs to have a
182:24 - Constructor or an initializer and we
182:26 - already know the Syntax for it and that
182:29 - is within it and then in in the
182:31 - parenthesis you would add your arguments
182:33 - in here okay so let's say we have a name
182:35 - which is a string and then H which is an
182:37 - INT and again the um not again actually
182:41 - we haven't talked about this before but
182:42 - the ordering of these arguments it
182:45 - doesn't necessarily have to be the
182:46 - ordering of your properties so it can be
182:48 - anything in here and you can actually
182:49 - ask for more stuff let's just say height
182:52 - and I don't know what you want to do
182:54 - with that because you're we don't have a
182:56 - place at the moment to store it but you
182:58 - can ask for more things than your class
183:00 - actually has as properties because maybe
183:03 - some of those values are going to be
183:05 - using other ways inside the Constructor
183:07 - of your class okay so let's take this
183:10 - back to having name and agent here all
183:12 - right and then inside a Constructor your
183:15 - job is to first and foremost ensure that
183:17 - your class as properties are all set
183:20 - before the Constructor is finished so
183:22 - you cannot return from a Constructor or
183:24 - an initializer as Swift calls it and
183:27 - without having initialized or all your
183:29 - stored properties okay so it says name
183:33 - needs to be stored I need name needs to
183:35 - basically have a value and then we're
183:37 - going to go ahead and say self that's
183:39 - name
183:40 - self that name is equal to name right
183:44 - and then we also have to say self-h is
183:46 - equal to H
183:48 - alright so that's that's the simple
183:51 - initializer but we haven't really looked
183:53 - at mutability let's have a function in
183:55 - here and say increase H all right and
183:57 - then in here we say self age is and
184:00 - we're using this operator in here which
184:02 - basically takes the left hand side and
184:04 - adds the right hand side to it all right
184:07 - so now we have a function in here you
184:11 - can see it's increasing the age property
184:13 - by one and it doesn't have to be prefix
184:16 - with mutating actually I think if you
184:18 - type mutating in here it will give you a
184:20 - syntax error is not valid on instance
184:23 - methods and classes so you shouldn't
184:25 - actually prefix anything in your in your
184:27 - classes with mutating all right then you
184:30 - can go ahead and create an instance of
184:32 - this class let's say let's Foo is a
184:35 - person with the name of Foo and the age
184:38 - of 20. all right then I'm going to break
184:40 - these into their own lines
184:43 - then we're going to say Foo H have a
184:45 - look at the age and then we say Foo
184:47 - increase age and then full H all right
184:49 - so let's have a look at these values
184:51 - then you can see first the age of Foo is
184:54 - 20 and then after
184:57 - think after incrementing it using the
184:59 - increase age then we get the H equal to
185:02 - 20. so nowhere in here did you actually
185:04 - have to create anything mutating and you
185:06 - can see that the variable itself is
185:09 - actually created with a let so that's
185:11 - the second difference when you create a
185:14 - let constant equal to an instance of a
185:16 - class you cannot assign a new value to
185:20 - the select constants constant because
185:22 - there is one of the natures of a left
185:23 - constant after creation it cannot be
185:25 - assigned a new value so you cannot go
185:27 - ahead and say Foo is equal to some other
185:29 - person in here
185:30 - so that rule stays the same when it
185:33 - comes to let constants and classes
185:36 - however since now you're working with
185:39 - the let constant equal to an instance of
185:41 - a class this class internally can change
185:44 - as you can see the age has changed
185:46 - without you having to change this to
185:49 - afar so that's the second difference
185:51 - between classes and structures in that
185:55 - classes allow for internal mutability
185:57 - without you having to create an actual
186:00 - VAR out of them all right and also their
186:03 - reference types and we'll talk about
186:05 - that soon actually okay
186:07 - so let's and let's have a look at what
186:09 - reference types actually mean so in here
186:12 - we say Foo age let's bring this down Foo
186:15 - H maybe just type it again in here and
186:18 - then we say bar is equal to food all
186:20 - right and then we say bar increase H now
186:23 - you'd probably expect bar to be copied
186:25 - and have actually a new copy of Foo
186:28 - however since classes are reference
186:30 - types the reference of this Foo is
186:32 - placed inside this bar so pretty much
186:34 - after line 30. bar and food point to the
186:38 - same
186:39 - instance of person in memory so bar gets
186:43 - a reference to this Foo and then by
186:45 - increasing the age of bar then Foos age
186:48 - is also increased and bars H is exactly
186:52 - the same so they're basically pointing
186:55 - to the same memory and memory space or
186:58 - memory allocated memory for this
187:01 - person's person instance okay so keep
187:04 - that in mind it's very very important
187:05 - now you can also compare instances of
187:09 - classes by using the equal equal so the
187:13 - triple equal syntax which in all my
187:15 - years are working with so if I've never
187:17 - had to use so it is very unlikely that
187:20 - you'll have to use it however if you
187:23 - want to see if two instances of a
187:25 - variable pointing to a class are pointed
187:28 - at the at the exact same memory space
187:31 - then you would use this syntax you would
187:33 - say if
187:35 - Foo oops if I can spell is equal equal
187:38 - bar
187:39 - okay and I think I've placed actually my
187:41 - fingers on the right on the wrong place
187:43 - on the keyboard so that's why I'm typing
187:45 - everything incorrectly so let's say Foo
187:47 - and Bar
187:48 - point to the same memory
187:51 - otherwise we say Foo they don't point to
187:55 - the same memory and then you can expect
187:58 - that you get this printed to the console
188:01 - simply because yes the r actually
188:03 - pointing to the same memory space and if
188:05 - any if for for those of you who are
188:07 - curious you'd be probably thinking okay
188:09 - what happens if I just change it to this
188:11 - and we should ideally get an error as
188:13 - you can see in here and that is simply
188:15 - because we haven't implemented equality
188:18 - on this class so person doesn't conform
188:20 - to equality in here and we'll talk more
188:23 - about equality perhaps a little bit
188:24 - later but if you wanna basically ensure
188:27 - your class instances are Equitable then
188:30 - you have to say Equitable in here and
188:32 - then you go ahead and Define a static
188:35 - Funk equal like this but we will
188:38 - probably talk about this a little bit
188:39 - later just know that this equal equal is
188:42 - not the same as equal equal this
188:44 - basically tests if two variables hold
188:48 - values that internally are equal to each
188:51 - other base based on some logic however
188:53 - this is some logic that Swift has
188:56 - implemented and you don't implement this
188:57 - in this logic at all what this one does
189:00 - is just make sure two variables are
189:02 - pointing to the same memory allocation
189:04 - all right and as I as I mentioned before
189:07 - you probably don't use this so often
189:10 - now classes unlike structures can also
189:13 - have inheritance meaning that you can
189:16 - create a super class with some logic and
189:18 - then you can have some other subclasses
189:20 - that conform to that actually not
189:21 - confirmed but they subclass that's super
189:24 - class all right let's have an exam have
189:26 - a look at an example in here so we say
189:28 - class vehicle alright so we have a
189:30 - simple class and we say go vroom
189:33 - like this and in here we save room vroom
189:35 - like this alright doesn't necessarily
189:37 - have to be anything scientific then we
189:40 - create a car class which should subclass
189:42 - vehicle okay so we say it's subclasses
189:45 - that vehicle in here and the car doesn't
189:47 - have any implementation of its own then
189:49 - you can create an instance of car like
189:52 - this
189:53 - and then you can say cargo vroom so you
189:55 - can see car though it doesn't have an
189:58 - internal implementation of Gover it it
190:01 - has inherited that function from its
190:04 - superclass namely vehicle in this case
190:06 - so keep that in mind you can have
190:08 - inheritance using classes which is
190:11 - something that you cannot do in
190:13 - structures okay now classes can also
190:17 - have private Setters so you can actually
190:20 - have a variable and that is marked as
190:23 - VAR but can only be set privately so you
190:26 - can see in here these variables are just
190:28 - simple vars meaning that they can be
190:30 - both internally changed and also
190:33 - externally changed you can see in here
190:35 - let's say Foo has the age of 20. I can
190:38 - go in here and say food at age plus
190:40 - equal to 10. and with this syntax I'm
190:44 - pretty much changing the age of Foo so
190:46 - if I then go to full age it should be 31
190:49 - in here so you can see it's a variable
190:51 - that can both be externally Lee and
190:54 - internally changed all right so if you
190:57 - mark some a property as VAR inside a
191:00 - class however you can also Mark a
191:02 - property as VAR however allow that to be
191:06 - only internally within the class changed
191:09 - okay so let's say class person two
191:12 - so then we say private set VAR H ins so
191:17 - by by using private sets we're saying
191:20 - that only can be set internally inside
191:23 - this class implementation and can be
191:25 - read from the outside all right and then
191:27 - we say we initialize it with an H of int
191:31 - then we say self H is H all right and
191:34 - then we have a function in here we say
191:35 - increase
191:37 - increase age and we say self-age is
191:39 - equal plus equal one so we're basically
191:43 - saying pretty much the same logic as we
191:45 - had before but you'll now see that you
191:47 - cannot change this age from outside this
191:49 - class implementation so let's say Bas is
191:52 - equal to person two
191:54 - and then we say 20 here then we say bad
191:56 - H Bas dot h if you then try to change
192:01 - this externally you will gain an error
192:03 - simply because this property is not
192:05 - settable from outside you can see it
192:07 - can't be mutated all right now if you
192:10 - remove this private set from here you
192:12 - can mutate that age from the outside as
192:15 - well all right you can see it's working
192:17 - as expected but if you have the syntax
192:20 - private set then it can't be modified
192:22 - from outside the class implementation
192:24 - itself however you can use still this
192:27 - function which then modifies that
192:29 - variable internally so you can say bads
192:32 - increase age and then passage you can
192:33 - see now H should have been changed to 21
192:36 - at this
192:37 - all right so that's the Syntax for
192:39 - private set in classes in Swift
192:42 - now you can also I mean now that we're
192:45 - talking about about classes very
192:47 - important that we talked about
192:47 - initializers as well because
192:49 - initializers are very very special I
192:51 - would say in Swift in that you can have
192:52 - convenience initializers and you can
192:54 - also have designated initializers now
192:57 - designated initializers their goal
193:00 - really is to is to ensure that they
193:05 - construct an instance of the Class by
193:08 - first of all ensuring that all property
193:10 - values are set and also that the
193:13 - internal structure or the internal
193:15 - validity of that class holds up
193:18 - however you can also have convenience
193:20 - initializers meaning that the only thing
193:22 - they do is that they probably add some
193:25 - logic to the Constructor or the
193:27 - initializer of that class but they
193:30 - essentially at the end of the day
193:31 - delegate the initialization to a
193:35 - designated initializer so it's as if you
193:38 - have for instance a you have for
193:41 - instance your mother in the kitchen or
193:44 - your father in the kitchen there is a
193:45 - party and they're making food and then
193:49 - you stand at the door of the kitchen as
193:51 - kind of like a delegate and people come
193:53 - and make their uh make like
193:57 - they basically make their order they say
193:59 - could I please have this then you can
194:01 - talk to them you'd be like let's say
194:03 - someone comes to the door the kitchen
194:04 - says could I please get a cup of tea and
194:06 - then you can say oh dude does it have to
194:08 - be red tea or does it have to be a black
194:10 - tea then they say oh red tea then you go
194:13 - to your father and say could you please
194:14 - make a air blah blah so I actually
194:17 - forgot whether it was black or red that
194:19 - that person decided But whichever they
194:23 - say then you go to your father and ask
194:25 - or your mother and ask them to make it
194:27 - so you're kind of like a delegate you're
194:28 - making the job of your father or mother
194:30 - a little bit easier and that's exactly
194:32 - what a convenience initializer does it
194:36 - gets rid of some Hassle and then at the
194:38 - end of the day it delegates the work to
194:40 - a designated initializer so just the
194:42 - designated initializer is the person in
194:44 - the kitchen and the convenience
194:45 - initializer is you at the door okay but
194:47 - let's have a look at some examples of
194:49 - how this actually works in real life so
194:51 - let's say class Tesla all right then we
194:53 - say let's manufacture my manufacturer
194:56 - server is Tesla then we say let's model
195:00 - is a string and let's year is in so the
195:03 - year production all right then
195:05 - um we will initialize our test line here
195:08 - we we create a designated initializer
195:11 - you can see in here is designated it
195:13 - doesn't have convenience written before
195:15 - it and we'll talk about convenience soon
195:17 - but any initializer that doesn't have
195:19 - the word convenience before it is a
195:21 - designated initializer and classes can
195:23 - have multiple designated and multiple
195:26 - um convenience initializers all right so
195:29 - here's a designated initializer and we
195:31 - say here model is X so let's say by
195:34 - default anyone initializing Tesla
195:36 - without passing any values to us they
195:39 - get a Model X Tesla and then we say year
195:41 - is 2023.
195:44 - so that's one designated and designated
195:47 - initializer the next one we will say
195:49 - init and in this designated initializer
195:52 - we actually take the model as a string
195:55 - and the year as an integer all right so
195:57 - we say self model is a model and
196:00 - self.year is a year
196:02 - all right
196:03 - like that now another property of
196:06 - designated initializers is that they
196:08 - cannot
196:09 - delegate their work to another
196:11 - designated initializer so in here you
196:14 - can say self in it model X and year is
196:19 - 2023 so we should get an error in here
196:21 - saying that a designated initializer
196:23 - cannot delegate its work to another one
196:26 - okay you can see it cannot delegate so
196:29 - designated initializers should do all
196:31 - their work themselves they cannot rely
196:34 - on another designated initializer okay
196:37 - so that's for designated initializers
196:40 - now let's have a look at a convenience
196:41 - initializer now let's say that you want
196:44 - to create a convenience initializer that
196:46 - by default assumes that the year is
196:49 - 2023. so the caller to that initializer
196:52 - doesn't have to pass the year all right
196:54 - so then you say convenience
196:57 - initializer or sorry init and then the
197:01 - only property we want in here is the
197:02 - model all right and in here then you can
197:05 - say this function calls the self in it
197:08 - with the model
197:09 - that is given in here but the year is
197:12 - 2023 by default so you can see a
197:14 - convenience initializer is delegating
197:16 - its work to a designated initializer in
197:19 - here okay now you can go ahead then and
197:22 - create a subclass you can say class a
197:25 - Tesla
197:26 - model y all right and it is subclassing
197:30 - Tesla and in its in it then what you
197:33 - want to do you want to create an
197:35 - initializer for model y that by default
197:38 - calls the super initializer and sets the
197:41 - model to Y and sets the year to 2023 all
197:45 - right or perhaps it could just call this
197:48 - convenience in it in here as well let's
197:50 - have a look so you create an initializer
197:52 - and here you say Okay I want an init all
197:54 - right however you need to be careful
197:55 - because init is already implemented on
197:57 - the superclass right here so if you're
198:00 - also creating an in and in your subclass
198:03 - you have to pre prefix it with override
198:05 - so you're saying I'm creating also
198:07 - another version of this okay and you can
198:10 - see it it says you need to at the end of
198:12 - this initializer somehow call Super in
198:15 - it so then we say okay then we call
198:16 - Super init and for model we say model Y
198:20 - and year is 2023. all right let's see
198:23 - what happens in here
198:25 - okay so now this should actually work as
198:27 - expected this shouldn't give you any
198:29 - errors all right let's see what happens
198:31 - if you comment this out and just instead
198:33 - call one of our designated initializers
198:36 - so sorry our convenience initializer
198:38 - which is this guy right here we just
198:41 - passed the model since the Year is
198:43 - already set to 2023 in this convenience
198:45 - initializer we could just try to call it
198:48 - and see what happens so I'm just going
198:49 - to say model is y all right and right
198:53 - here since this is a designated
198:55 - initializer inside a designated
198:57 - initializer you cannot call a
198:59 - convenience initializer from your super
199:01 - super class so this is another rule that
199:03 - you have to remember so I think a good
199:06 - rule to remember is that designated
199:08 - initializers in subclasses they can only
199:13 - call to designated initializers in their
199:15 - superclass
199:17 - inside any class a designated
199:19 - initializer cannot delegate to any other
199:22 - initializer okay convenience
199:25 - initializers can inside subclasses and
199:29 - inside their own classes
199:32 - call either and no basically not either
199:35 - but they can call a designated
199:37 - initializer okay it is a little bit
199:39 - special I'm completely aware of that but
199:42 - it's just some rules that Swift has set
199:44 - and I think logically they make sense
199:46 - but kind of they can make programming a
199:48 - little bit difficult sometimes when
199:50 - you're working with classes so let's
199:52 - let's create an instance of this model y
199:53 - so we say Tesla Model Y and in here you
199:57 - can see we don't have to pass any values
199:59 - to the initializer simply because we
200:02 - already have an init with no input
200:06 - values basically no arguments okay then
200:08 - we say model y oops model y dot model
200:11 - and model y that year and then model y
200:16 - dots manufacturer which comes from the
200:18 - superclass which is always set to Tesla
200:21 - all right
200:22 - now one thing that I mentioned at the
200:25 - beginning of the section was that
200:26 - classes are reference types they're not
200:29 - value types unlike structures
200:32 - and that should really make you aware of
200:35 - passing instances of your classes to
200:38 - functions so let's have a look in here
200:40 - let's create a foo bar and we say it's
200:42 - an instance of person two all right with
200:44 - the age of 20 in here and then we say
200:47 - Fubar dot h and then let's say that
200:50 - there is a function that is looking
200:53 - harmless it's called do something all
200:55 - right and with person and we just pass
200:58 - person two instance to it what this guy
201:01 - does internally is that person dot
201:03 - increase age it calls increase age
201:05 - function on that person all right Fubar
201:08 - is at the moment having the age of 20
201:10 - and then if you say do something with
201:12 - fubar and then say fubard.h you can see
201:16 - the age will have been increased to 21.
201:19 - and simply is because the reason behind
201:22 - it behind this is that classes are
201:25 - reference types meaning that by calling
201:27 - this function and passing an instance of
201:29 - your variable to this function you're
201:33 - not copying the values of food bar over
201:35 - as new instances except you're actually
201:38 - passing your entire memory space Sorry
201:41 - the memory and allocated for your person
201:44 - 2 instance into this function so this
201:46 - function is completely free to do
201:49 - anything it wants with this person
201:50 - instance so just be a little bit careful
201:53 - with that just know that classes are a
201:55 - little bit more special than structures
201:57 - with structures you get a little more
201:58 - safety so to say
202:00 - now another concept and that we're going
202:03 - to talk about before we close off this
202:04 - section of the video is de-initializers
202:06 - they're quite useful in some special
202:09 - cases but some other cases you probably
202:12 - don't need them so I would say probably
202:13 - 90 percent of ties are working with
202:15 - classes you don't need the initializers
202:16 - unless you're working with some sort of
202:18 - notifications or RX for instance and
202:21 - yeah if you're working with reactive
202:23 - programming
202:24 - so let's have a look at the initializers
202:27 - as their name indicates they're kind of
202:29 - similar to initializers but they do the
202:31 - opposite the initializers are invoked
202:34 - automatically by Swift whenever your
202:37 - class instance is going out of memory so
202:40 - it's kind of getting cleaned from the
202:41 - memory so no one else is holding on to
202:44 - it and it has to be removed from memory
202:46 - so let's create a my class in here okay
202:48 - then in the init and we will just say
202:52 - initialized and then we'll have a
202:54 - function here called do something which
202:56 - which is empty at the moment all right
202:58 - then we create a new function in here
203:01 - called D in it and you can see that it
203:03 - is purple in here but it doesn't matter
203:05 - I mean the color doesn't really matter
203:06 - it just matters that this is a reserved
203:09 - word it's a keyword in Swift meaning
203:11 - that you can't really use it anywhere
203:12 - else except if you do something like
203:14 - funky like that but just know that
203:15 - there's a reserved word it's it's
203:17 - similar to in it but it's just called
203:19 - when your class is going out of scope
203:21 - and in here we can say d initialized all
203:24 - right now to test this we should
203:26 - actually create a function in which we
203:28 - create an instance of this because if
203:30 - you create an instance of your class in
203:32 - here let's just say let's my class is an
203:35 - instance of my class and then my class
203:38 - do something where the initializer won't
203:41 - probably be invoked you can see your
203:43 - initializer is invoked uh do something I
203:46 - mean in here we could actually say do
203:47 - something just so that we see that that
203:49 - function is also invoked however Danish
203:52 - Lancer isn't embodian that's just the
203:54 - nature of uh of playgrounds so what you
203:58 - could do is to create a closure my
204:00 - closure and we say it is
204:03 - this it is basically carrying out this
204:05 - logic inside the closure and then we can
204:08 - call our closure so at the end of this
204:11 - closure this variable should go out of
204:13 - scope meaning that it's the initializer
204:15 - should be called so let's say my closure
204:17 - in here all right and then you can see
204:19 - your D initializer oopsie Daisy what
204:22 - happened my closure
204:24 - uh all right cannot find my did I spell
204:27 - it incorrectly like this
204:29 - and now you can see that the initializer
204:31 - is in fact called and invoked simply
204:34 - because after my closure is called this
204:36 - scope completely finishes meaning that
204:38 - all variables inside this scope should
204:40 - also go out of scope so dnits will be
204:43 - called on all class instances all right
204:47 - really good we seem to now be done
204:49 - actually with classes so
204:53 - um let's just jump right ahead into the
204:55 - next concept and that is protocols so
204:57 - I'm going to go in here and actually not
205:00 - there we don't have to go there I'm just
205:01 - going to press command n in here create
205:03 - a new playground and we're going to say
205:05 - protocols again ensure that it is inside
205:08 - your workspace and in not inside another
205:10 - playground
205:12 - create all right and we get rid of this
205:15 - Explorer in here and we say Foundation
205:16 - like this Foundation all right now
205:21 - protocols for those of you who are rust
205:23 - developers you probably already know
205:24 - what protocols are and Protocols are
205:27 - special kind of objects kind of like
205:29 - interfaces you could say in Java for
205:31 - instance I'm not sure the term in kotlin
205:35 - what that is but you also have protocols
205:37 - as mixings in Dart for instance
205:41 - so what protocols are is that you create
205:45 - an interface you create a set of rules
205:48 - that objects which conform to a protocol
205:51 - have to follow
205:52 - so it is not a class and because if you
205:56 - have a class for instance if you have a
205:57 - super class that has some functions all
205:59 - subclasses do not have to re-implement
206:02 - that function however if you have a
206:04 - protocol that only creates some
206:06 - functions with no body so the functions
206:09 - don't have logic in them any object that
206:12 - conforms to those protocols have to
206:14 - implement those functions by themselves
206:17 - all right so it is actually a little bit
206:20 - difficult to explain what protocols are
206:22 - without having a look at how they work
206:25 - so let's go in here and say that this is
206:27 - automatically running and create our
206:30 - first protocol so we create a protocol
206:32 - called can breathe okay
206:35 - and in here we say any object that can
206:37 - breathe should have a function called
206:39 - breathe so you can see this function is
206:41 - special functioning it has no body you
206:44 - cannot create for instance a class
206:46 - person and just have this in it this
206:49 - just won't work you have to have a
206:51 - function body and you can't do that
206:54 - either in structures your function has
206:56 - to have a body so you can see that won't
206:59 - work in structures either that's why
207:01 - Protocols are a little bit special in
207:03 - that they can have just function
207:04 - declarations without any implementation
207:06 - all right and that's what is called
207:08 - interface insomni in so many other
207:10 - languages all right
207:12 - so we have a protocol now can breathe
207:15 - let's go ahead and create a structure
207:17 - called animal and we saw when we when we
207:21 - were talking about structures that
207:21 - structures cannot have super classes so
207:23 - they cannot actually inherit from each
207:25 - other okay so if you create for instance
207:27 - a structure of animal and then you say
207:30 - struct cat you cannot say that cat is an
207:33 - animal it just won't work structures
207:36 - don't allow inheritance however they do
207:39 - allow inheritance from protocols so you
207:42 - can say a structure of animal that
207:44 - inherits from can breathe and this is
207:46 - completely fine Swift syntax however
207:49 - we're getting an error because now you
207:51 - can see it says the animal a type
207:53 - doesn't conform to protocol can't
207:54 - breathe and the reason behind that is
207:56 - that a protocol here called can't
207:58 - breathe specifies that anyone conforming
208:00 - to this protocol has to implement this
208:03 - particular function and we haven't done
208:04 - that so as soon as we go and type
208:06 - breathing here you can see then this
208:09 - error will go away because now animal uh
208:12 - character conforms to Cambridge protocol
208:16 - okay and in here we can just say animal
208:18 - breathing like this okay
208:22 - and also then you can create another
208:23 - structure struct person can breathe like
208:26 - this and in here we say breathe as well
208:29 - and then we say person breathing like
208:33 - that all right so then you can go ahead
208:35 - and create instances of these two
208:37 - structures we say dog is an animal and
208:39 - we say dog breathe and then we create a
208:42 - person called Foo an instance of person
208:45 - we say the food breathe all right now
208:48 - you can see both of these lines will
208:49 - then be invoked uh simply because we
208:52 - call them from here so that's basically
208:55 - the essence of how protocols work I mean
208:58 - protocols can be a lot more complicated
209:00 - than that actually uh in that I mean we
209:03 - talked right now about having protocols
209:05 - that only have function declarations but
209:07 - not implementations but protocols and
209:10 - Swift are kind of like mix-ins and dart
209:12 - in that they can't actually have their
209:15 - own implementations so they're not just
209:17 - like objects that have dummy function
209:20 - headers but they can indeed have
209:22 - function implementations so let's have a
209:24 - look at that let's create a protocol
209:26 - called protocol can jump and then we say
209:29 - a jump function all right then in order
209:32 - to create implementation for this
209:35 - function I mean you may be thinking okay
209:36 - maybe I should do this jumping and this
209:40 - will just give you an error because you
209:41 - cannot create your function body inside
209:43 - the Proto call itself the trick to do
209:46 - that is to go ahead and create an
209:47 - extension on can jump okay and we
209:50 - haven't talked about extensions yet but
209:52 - it is necessary that we just name it in
209:54 - here simply because that's the way to
209:56 - actually add implementation to this
209:58 - function all right then we go and say
210:00 - okay it's the same function and then we
210:02 - just say jumping
210:04 - so by this trick you I mean it's not
210:07 - really a trick this is the way to do it
210:09 - by using this uh technique I'm trying to
210:14 - avoid saying trick by using this
210:16 - technique you're adding a default
210:18 - implementation to this otherwise very
210:20 - dumb function
210:22 - so you may be asking okay but what
210:24 - happened here can I just call this
210:26 - function now so can I just say can jump
210:28 - is an instance of can jump can I do that
210:32 - well you can't because you cannot
210:34 - instantiate a protocol you need to
210:37 - instantiate an object that conforms the
210:39 - protocol
210:40 - okay such as a cat that can jump so
210:42 - let's say struct cat and jump and now
210:45 - since this jump function already has an
210:48 - implementation you can see that we're
210:49 - not getting an error from Swift saying
210:51 - cats should implement this function if
210:54 - you remove this implementation from here
210:56 - all of a sudden all objects that conform
210:58 - to can jump need to implement this jump
211:00 - function themselves but if you bring it
211:02 - back into can jump then all objects that
211:04 - conform to that protocol will get this
211:06 - implementation by default but they can
211:08 - go ahead and change it if they want to
211:10 - like this okay
211:13 - so that's also valid however if you
211:15 - leave it it also works with that problem
211:17 - so let's create an instance of this cat
211:19 - we say Whiskers Whiskers it's an
211:23 - instance of cat and we can just say
211:24 - whiskers.jump all right this is how we
211:27 - can invoke that function that is
211:29 - implemented on can jump right
211:33 - now protocols apart from defining
211:36 - function headers that they're conforming
211:39 - objects have to implement they can also
211:42 - Define variables let's let's go ahead in
211:45 - here and say we have a protocol in here
211:48 - we say protocol has name protocol
211:52 - has a name and then in here we say VAR
211:55 - name a string and then we have to say
211:58 - gets in here or set or both like this
212:01 - now what this really means is that this
212:03 - protocol is asking Swift saying any
212:06 - object that com conforms to me has to
212:09 - have a variable called name that has to
212:12 - at least have a getter what does this
212:15 - mean well this is really just a dumb way
212:17 - of saying this
212:19 - so it it basically says a variable that
212:22 - at least I can read from but this syntax
212:25 - isn't valid and protocols I wish it was
212:27 - but you have to implement them like this
212:29 - so you're basically saying a some sort
212:31 - of a variable that I can read from which
212:33 - is called name all right and then you
212:35 - can also have H all right and let's just
212:38 - say h should be getter and Setter
212:40 - meaning that it should actually be a
212:42 - variable that can be set all right now
212:44 - we can go ahead in here and say we have
212:46 - a struct of dog and it has a name you
212:49 - can now see that we'll get an error now
212:52 - from Swift saying that this doesn't
212:53 - conform to has name and we can ask it to
212:56 - fix it for us and you can see by default
212:57 - it creates these variables for us
212:59 - however what I really don't like about
213:01 - this is that what it did is that it
213:03 - created a variable for name so it could
213:07 - actually be a let since the protocol has
213:10 - name asks for this variable to be at
213:13 - least and at most actually in read-only
213:16 - so we can just demote this to a let's
213:19 - variable and you'll see that everything
213:21 - will work as expected okay so let's go
213:24 - ahead in here and then create an
213:25 - instance of this dog
213:27 - and we can call this instance woof let's
213:29 - say woof is an instance of dark and we
213:32 - say name is with
213:34 - an H is a very graceful ten then we say
213:38 - with that name all right and with that H
213:40 - wolf dot h plus equal one so we just
213:45 - increase the age but we cannot change
213:48 - the name all right so let's just woof
213:50 - agent here as well so let's see what
213:53 - happens okay and this I mean we're
213:54 - getting these errors right here because
213:55 - we can't modify woof because it's an
213:58 - instance of a structure which by default
214:00 - becomes a left constant that cannot even
214:02 - have a mutation internally so we have to
214:04 - change this to A4 so remember structures
214:06 - are different from classes all right
214:08 - so this is basically a protocol that
214:12 - required all its uh classes or
214:15 - structures that conform to it to have a
214:17 - variable call name that can at least and
214:20 - at most be read from so it can be a let
214:22 - and it can also be a VAR but why does it
214:24 - have to be a VAR a promotion of let if
214:27 - we don't have to have it as a bar
214:29 - because the protocol says I should just
214:31 - be able to get from it now you may be
214:33 - thinking okay but why do we do these
214:35 - things well the reason is if you want to
214:37 - go ahead and add functionality to this
214:39 - protocol then this protocol internally
214:41 - has access to name and age let's say
214:44 - extension has name and then we can then
214:47 - create a function that says describe me
214:50 - then we can see we can say you your name
214:53 - is name and you are
214:57 - age years old
215:00 - okay so since this protocol expects a
215:04 - name variable and an age variable and it
215:07 - can then go ahead and read them so it
215:10 - can access them and it should also be
215:12 - able to set them okay and then you can
215:14 - say func increase age and in here then
215:17 - you can say self h plus equal one and we
215:20 - can fix this actually now
215:21 - so you can basically go ahead and add
215:24 - functionality to your protocols let's
215:28 - say fix it and we add a mutating
215:30 - function in here so you can see this
215:32 - protocol since it knows what it requires
215:35 - all its uh classes and structures that
215:38 - conform to it have to have these values
215:40 - then it can go ahead and take advantage
215:42 - of those variables or functions or
215:45 - whatever it has okay so now all of a
215:47 - sudden all objects are conformed to have
215:49 - has the name protocol will get a
215:51 - describe me function let's go ahead in
215:53 - here and say woof you can see it has a
215:56 - describe me function all of a sudden and
215:58 - it will say oops okay here
216:02 - your name is woof and you are 11 years
216:04 - old okay and maybe this should actually
216:06 - return a string
216:08 - and it could just return that string
216:10 - instead of printing it here and in here
216:12 - then we get the result you can see it
216:14 - says your name is Wolf and you're 11
216:15 - years old and then since we have a VAR
216:18 - with uh pointing to a structure we can
216:22 - go ahead and say woof dot increase age
216:24 - and then we say wolf h all right so the
216:27 - H by this point is 11 and then we in we
216:31 - invoke this increased age function which
216:32 - is mutating function and then we get the
216:35 - age of 12 all right so protocols can
216:38 - Define kind of um constraints or kind of
216:42 - like an interface on objects that
216:44 - conform to them and therefore can using
216:47 - extensions on those protocols can access
216:49 - those variables and functions which are
216:52 - placed in here so it's kind of like
216:53 - giving a blueprint so it's kind of like
216:55 - any object that conforms to me has has
216:57 - to have this blueprint and then I can
216:59 - internally use that blueprint to my
217:01 - advantage okay
217:04 - now just we've just like we've seen this
217:06 - in here protocols can have mutating
217:09 - functions something that I want to
217:10 - mention next but I think I just
217:12 - mentioned a little bit too early perhaps
217:14 - but at least you get the point let's now
217:16 - focus on that mutating function so if
217:18 - you say protocol vehicle I just want to
217:21 - show you another example
217:22 - and let's say we have a variable speed
217:25 - and we say it should be an integer which
217:27 - is getter and Setter so we should be
217:29 - able to set it and read from it okay
217:31 - then we create a mutating function here
217:34 - increase speed and we say buy which
217:38 - value like this okay so we Define this
217:42 - mutating function here and then we go
217:44 - ahead and extend this vehicle
217:46 - like this and we implement this mutating
217:49 - function all right so what we did here
217:51 - was a little bit um is not optimal
217:53 - because we implemented a mutating func
217:55 - increased age inside the extension so
217:58 - whoever looks at our protocol won't
218:00 - immediately understand that there is a
218:02 - mutating funk available on it so if you
218:04 - wanted to make this code a little bit
218:05 - more readable we would place this
218:07 - function a declaration here as well okay
218:09 - so let's go in our code again and we say
218:13 - in the implementation of our protocol
218:15 - increase speed by value will actually
218:17 - have an implementation that's a
218:19 - self.speed is plus equal to Value like
218:24 - that and we can bring this value down
218:26 - here to make the code a little bit more
218:27 - readable as well
218:29 - and perhaps decrease the size of the
218:31 - preview as well
218:33 - so let's then go ahead and create for
218:35 - instance a a concrete implementation of
218:38 - this vehicle protocol so we say struct
218:40 - bike and then bike it will have a speed
218:44 - oh let's actually move this and say it
218:47 - is a vehicle all right then we get an
218:49 - error from uh Swift saying that it
218:52 - doesn't conform to Vehicles simply
218:53 - because it didn't have the speed
218:55 - variable then inside this bike we create
219:00 - an init and we say self dot speed is
219:03 - zero you could have also done it like
219:06 - this
219:07 - that also works it kind of depends on
219:09 - how you like to implement and do your
219:12 - implementations I've seen both and for
219:14 - me both are fine it's up to you and your
219:17 - team to actually make a decision on what
219:19 - uh can what convention you want to use
219:22 - for initializing your variables and
219:24 - structures okay but this is completely
219:26 - valid syntax as well
219:28 - after doing that let's create an
219:29 - instance of this byte let's say bike is
219:31 - an instance of bike like this then we
219:34 - get the current speed it should be zero
219:36 - because that's what the initializer did
219:38 - then we say bike increase speed by 10
219:41 - and then we say bike speed all right so
219:44 - because we are conforming to the vehicle
219:46 - protocol we can have access to this
219:50 - increased speed function in here now I
219:53 - can see we're getting an error simply
219:54 - because a bike cannot be mutated you can
219:57 - see we're actually invoking a mutating
219:58 - function on an immutable let constant
220:01 - and the solution to that is to change
220:03 - this to VAR all right now you can see
220:06 - our speed was zero and then it was
220:08 - increased to 10 simply because we
220:10 - increased it using this mutating
220:12 - function defined and implemented on the
220:16 - vehicle protocol all right
220:18 - so that's one thing I mean that's not
220:21 - one thing that's quite a lot of things
220:22 - about protocols but at least you get the
220:23 - idea of protocols now protocols can also
220:26 - be used as a conformance uh how do you
220:30 - say it blueprints kind of so
220:33 - let me just explain how this would work
220:35 - you can at any point in Swift use the is
220:38 - syntax or a keyword in order to check
220:41 - whether an object conforms to a protocol
220:43 - or not because any class or any
220:46 - structure can conform to at least one
220:50 - and actually not at least at least zero
220:53 - and at most unlimited number of
220:56 - protocols so a structural class doesn't
220:59 - have to conform to any protocol or it
221:01 - can conform to one or more protocols
221:03 - that's what I'm trying to say and if you
221:05 - want to at any point check whether an
221:07 - object conforms to a protocol you can
221:09 - use the is syntax let's have a look at
221:11 - that let's say we create a function
221:13 - called describe and it takes an object
221:16 - of type any and we haven't talked about
221:18 - this before but any is pretty much as
221:20 - its name indicates any object okay then
221:22 - we say if object is a vehicle then we
221:26 - say uh object conforms to
221:30 - their vehicle protocol
221:33 - else object does not conform to the to
221:39 - the vehicle protocol all right then we
221:42 - can go ahead and call this describe
221:44 - function and describe our object of bike
221:47 - and then you can see since by conforms
221:50 - to the vehicle protocol then we get this
221:52 - printed to the screen however if we had
221:55 - a structure of warm or at work warm and
221:59 - it didn't conform to the vehicle
222:03 - protocol and we sit warm as an instance
222:07 - of warm and then we just say describe
222:10 - more then you can see that we will get
222:13 - this message printed to the screen
222:16 - object does not conform all right so now
222:19 - that we've done that let's just remove
222:21 - this warm I don't like to have worms in
222:22 - my coat
222:24 - so at least you get the point now with
222:27 - with that as well
222:28 - now there's one more uh one more thing
222:33 - that we have to talk about when it comes
222:34 - to protocols and that is I mean we've
222:38 - talked about is but we haven't talked
222:41 - about as and as with a question mark and
222:45 - they make more sense when we when we've
222:47 - already talked about optionals and we
222:48 - haven't talked about optionals yet we'll
222:50 - talk about optionalism in like the next
222:52 - three sections of this video but I just
222:54 - want to name it as well so you know that
222:56 - it exists in Swift so
222:59 - using this as syntax you can
223:01 - conditionally promote an object to a
223:05 - specific type so in here you can see
223:09 - object is vehicle and if you say object
223:11 - dot you don't have any anything to do
223:15 - now with this I mean you cannot do
223:16 - anything with this object even though
223:18 - you actually said if object is a vehicle
223:20 - then I kind of would expect us to be
223:23 - able to invoke these functions on that
223:25 - vehicle because we actually asked Swift
223:27 - is it a vehicle then we come here but
223:30 - Swift doesn't understand the syntax as
223:33 - good as it understands as like this and
223:37 - the reason behind that is You're simply
223:38 - just doing an if statement in here
223:40 - saying is it that then do something but
223:44 - you didn't actually promote this object
223:46 - to that type all right so any is like a
223:50 - very low object type however this is
223:52 - sitting a lot higher in the hierarchy
223:54 - and that's the reason we say promote
223:57 - so let me actually show you an example
223:59 - let's say that we have
224:01 - uh that we have let's say a bike in here
224:05 - and bike is a vehicle which has
224:07 - increased speed all right but we want to
224:09 - create a function that that can allow
224:11 - any object to come in and if that object
224:14 - is a vehicle kind of like this then it
224:17 - will increase its speed by 20. all right
224:20 - so let's say funk
224:22 - increase speed if vehicle
224:26 - and then the parameter to this is an
224:29 - object of type any all right then in
224:31 - here we say if then we create a VAR and
224:35 - the vehicle is equal to this object and
224:38 - then we say is it
224:40 - a vehicle like this with an as syntax if
224:43 - it is then we say vehicle speed you see
224:46 - now we get access to all properties of
224:48 - that vehicle because we promoted this
224:50 - object to a vehicle so it's not similar
224:53 - to is
224:55 - because this won't allow us to access
224:57 - the vehicle objects and hear our
224:59 - Properties or functions then we say get
225:01 - the current speed vehicle increase the
225:04 - speed by 10 and then get the speed again
225:06 - in here okay otherwise we say this was
225:10 - not a vehicle so let's then go ahead in
225:14 - here and see what happens so let's say
225:18 - increase speed
225:19 - if vehicle and then we pass our bike in
225:22 - here all right let's see what happens
225:25 - are we getting a lot of Errors perhaps
225:26 - from Swift it crashed no okay so you can
225:30 - see we got the value of 10 in here okay
225:32 - and then we get the value of 20. right
225:36 - here okay
225:38 - now you may be thinking about what
225:41 - happened in here bike let's have a look
225:42 - at bike you can see its speed it was
225:46 - zero in here and then 10. and then we
225:49 - call this function which should have
225:51 - increased the speed to 20. but if in
225:53 - here we say bike speed what happens do
225:56 - you think it's 20 well no it is 10
225:59 - actually and the reason behind that is
226:01 - that bike is an instance if you go back
226:03 - to it is an instance of a structure
226:05 - called bike so it's a structure
226:08 - structures are value types meaning that
226:11 - when you call this function with an
226:13 - instance of your bike you're not
226:15 - actually passing the memory consumed by
226:17 - this bike as a reference to this
226:18 - function what are your what are your in
226:20 - fact doing is that you're making a copy
226:22 - actually not you directly but Swift is
226:24 - doing it doing that Swift is making an
226:26 - entire copy of this is making a copy of
226:29 - this entire object and passing it in
226:31 - here so in here this VAR actually is
226:35 - pointing to not the same memory address
226:38 - that bike is consuming but it's pointing
226:40 - to a completely new variable in the
226:41 - memory and is allowing it to basically
226:44 - be increased by a certain speed which is
226:46 - not affecting the spike however if this
226:49 - bike was an instance of a class so if we
226:52 - went in here and said bike is actually a
226:54 - class let's say class now you can see
226:57 - calling this function it will actually
227:00 - change the speed for you to 20. so
227:02 - calling this function it affects the
227:05 - actual instance of bike itself see the
227:07 - speed is exactly the same but if you go
227:09 - back to a struct you can see the speed
227:10 - of your bike will be 10. all right so
227:13 - keep that in mind when you're working
227:15 - with protocols protocols and classes and
227:17 - structures together go really hand in
227:19 - hand to create amazing object oriented
227:22 - applications in Swift but they can make
227:25 - things also a little bit complicated so
227:27 - keep that in mind when you're working
227:29 - with these um
227:31 - with these Concepts
227:33 - good that's quite enough about protocols
227:36 - now that we've talked enough about
227:38 - protocols let's go ahead and talk about
227:40 - extensions you've already seen examples
227:43 - of extensions and how they work in Swift
227:45 - but we haven't really focused on them so
227:48 - let's do that now let's go oh I don't
227:50 - have to do that let's create a new
227:52 - playground playground and in here we say
227:56 - blank playground and we say extensions
227:58 - all right like that
228:00 - and here as well then we say create
228:04 - and just like usual we say we just need
228:07 - foundation for now all right
228:10 - so extensions as their name indicates
228:13 - they can add functionality to existing
228:16 - types they can extend existing types so
228:20 - let's have a look at an example let's
228:22 - say that we have an extension on data
228:25 - type of integer and then we say we have
228:27 - a function called plus two which returns
228:30 - an integer and since this function is an
228:34 - extension of int self in here refers to
228:37 - the current integer instance okay then
228:41 - we say we return self plus two all right
228:44 - then we can go ahead and say 2 is equal
228:46 - to value of 2 and then we say 2 plus 2
228:49 - and then you can see then we get the
228:51 - value of 4 here in our playground okay
228:54 - so self inside extensions refers to the
228:58 - current instance meaning that this two
229:00 - in this case all right so self in here
229:02 - is actually two so if you just print
229:04 - self and then you say return self
229:08 - self plus two you can see self is indeed
229:11 - the value of 2 in here which is what
229:13 - you've specified here so if you change
229:15 - that self will change to that as well
229:17 - all right so keep that in mind that's
229:20 - one example of an extension
229:23 - Now using extensions you can also add
229:26 - initializers to existing types which is
229:29 - one of the most powerful features of
229:31 - extensions in Swift let's have a look at
229:33 - an example let's say that you create a
229:34 - structure called person in here and you
229:37 - have a first name
229:38 - string and then let's last name last
229:42 - name as a string okay now what you want
229:45 - to do is to create a I mean you want to
229:47 - behold and sorry you want to hold on to
229:49 - this person's Constructor or initializer
229:52 - that Swift already creates for you with
229:54 - the first name and last name so you
229:56 - don't want to change that but you also
229:59 - want a Constructor that takes in a full
230:01 - name however if you go in here and say
230:03 - init full name screen
230:06 - then you can see all of a sudden your
230:08 - person doesn't have any other
230:10 - Constructor with a first name and last
230:12 - name anymore your only Constructor
230:14 - inside the structure itself will replace
230:17 - the existing Constructor okay and that's
230:19 - not good so what you want if you want to
230:22 - for instance have a Constructor
230:23 - initializer on this person that doesn't
230:25 - replace the existing in initializer that
230:28 - Swift creates for you then you need to
230:30 - create an extension on person
230:32 - and then you go ahead and add your
230:34 - initializer in here okay now you can see
230:37 - if you try to initialize an instance of
230:39 - person you have both of these
230:40 - Constructors the default one that Swift
230:42 - created for you and also your own
230:44 - Constructor which is inside the
230:46 - extension all right so let's inside this
230:49 - Constructor go ahead and grab the
230:51 - components out of this full name so we
230:53 - say full name
230:55 - components is a function and we separate
230:57 - the components by space all right and so
231:01 - we say let components and then we want
231:04 - to pass these values that we extract
231:06 - from components so we say self in it
231:08 - into our Constructor then we say the
231:11 - first name is actually components first
231:15 - otherwise fully and we say in here as
231:18 - last name is components last otherwise
231:21 - fully just like that all right so this
231:25 - is very dumb implementation to be honest
231:26 - with you but I mean it's not too dumb
231:29 - either it is literally taking the first
231:30 - part of a name and the last part of a
231:32 - name assuming that this is the first
231:34 - name and this is the last name and
231:35 - anything that is between them separated
231:37 - by space is the middle name which we
231:39 - don't care about in this instance okay
231:41 - then we can go and create an instance of
231:44 - person so left person is a person then
231:47 - you can see we have both Constructors or
231:50 - initializers and we're going to use full
231:51 - name in here we say Foo and bar you can
231:54 - see they're separated by space and the
231:55 - first component is Foo and last name and
231:57 - last components bar then we say person
232:00 - first name and person dot last name all
232:02 - right so that's another powerful future
232:05 - of extensions in Swift in that you can
232:08 - extend an existing structure for
232:11 - instance and add a new Constructor or
232:13 - initializer to it okay
232:16 - now apart from that you can also extend
232:20 - existing types and add conformance to a
232:23 - protocol to an existing type so that's
232:25 - also really cool so let's create a
232:27 - protocol in here we call it Goes Vroom
232:29 - okay so that's our protocol name
232:32 - and this protocol what it does is that
232:34 - it has a VAR room value and it's a
232:37 - string and it should we should be able
232:38 - to read from it okay and then we create
232:41 - a function we say go vroom and then this
232:44 - function returns a string now we go
232:46 - ahead and extend our goes room and then
232:50 - we add the default implementation for
232:52 - this go vroom function and then we say
232:55 - self Dot vroomvalue
232:58 - goes room
232:59 - so remember this is just a variable that
233:02 - we know any instance conforming to our
233:04 - protocol should have access to and then
233:05 - here we're just adding the default
233:07 - implementation for this code firm
233:08 - function and returning this string as
233:10 - its return value all right then we go
233:13 - and create a car instance we say struct
233:15 - car and this car conforms actually we
233:18 - don't want to conform yet and in here we
233:20 - say let's manufacture is a string and we
233:23 - say let's model is a string as well I
233:27 - guess this is just a simple car
233:29 - structure
233:30 - then we can say let model X is an
233:34 - instance of car with the manufacture of
233:36 - Tesla and its model is going to be X
233:41 - and after creating this instance we can
233:43 - go ahead and actually extend this model
233:45 - X so we can say model X extension sorry
233:48 - extension of car then we say car now all
233:51 - of a sudden conforms to the Goes Vroom
233:54 - protocol you will get an errand here
233:57 - telling you that you're not actually
233:58 - conforming to go Gold's room and the
234:00 - reason behind it is that if you go to
234:02 - ghost room you can see that we have two
234:03 - requirements one is that we have any
234:05 - type conforming to goes from protocol
234:08 - has to have a variable called room value
234:12 - that's at at most and at least readable
234:15 - uh however Carr doesn't have that and
234:18 - that's the error that we're getting in
234:19 - here so let's just get Swift to fix it
234:21 - and you can see it creates a computer
234:22 - property in here called vroom value
234:24 - which should return a string okay and
234:27 - for our vroom value we're going to say
234:29 - it is self manufacturer model
234:33 - and self.model all right and then all of
234:37 - a sudden this car instance conforms to
234:39 - That Goes Vroom protocol meaning that
234:42 - this model X all of a sudden gets a
234:44 - function called go vroom and if you do
234:46 - that you can see it says Tesla Model X
234:48 - goes room and that's because vroom value
234:51 - is a variable that is implemented on all
234:54 - types that conform to God's room but
234:57 - ghost room doesn't really know what this
234:58 - value actually is it just extracts that
235:01 - value and adds it here and then says
235:03 - goods room however it is the conforming
235:05 - types responsibility to return this
235:08 - value and in this case the case of car
235:10 - structure we're just saying manufacture
235:13 - and then model X so it says Tesla Model
235:16 - X goes through this part is provided by
235:19 - conforming types such as car and this
235:21 - part is provided by the ghost room
235:23 - protocol itself okay
235:25 - so you can also have I mean now now that
235:29 - we've talked about that let's go to the
235:30 - next concept and that is having
235:32 - extensions on classes and with
235:35 - convenience initializers so you can
235:37 - actually extend existing data types and
235:40 - add convenience initializers to classes
235:42 - and not structures because structures
235:44 - don't have convenience initializers but
235:46 - classes can
235:47 - so let's go ahead in here and create a
235:49 - class and we call it my double so like a
235:52 - class that holds on to a double variable
235:54 - and we say VAR value double
235:58 - and then we can say an initializer that
236:00 - takes a value of double and we say self
236:03 - value is value in here okay
236:05 - now you can go ahead then is actually
236:07 - this I don't think this needs to be a
236:09 - VAR it can just be a let perhaps okay
236:13 - and in here then we're going to go ahead
236:14 - and create a convenience initializer and
236:17 - which always sets this value to zero if
236:20 - anyone initializes the instance of My
236:22 - Double because at the moment if we say
236:23 - let
236:25 - let's go ahead Foo is my double you can
236:29 - see that you always have to have a value
236:31 - available and pass to my double
236:33 - initializer but if you don't want to
236:36 - have that you can extend your my double
236:38 - class in here and say you have a
236:40 - convenience in it in here that takes no
236:43 - parameters and calls self in it with a
236:46 - value of zero so this is literally
236:49 - delegating its task to a designated
236:51 - initializer in the my double class but
236:53 - it is a convenience initializer that is
236:54 - created inside an extension so you
236:56 - that's one of the powers of extensions
236:58 - you can extend an existing class and add
237:01 - a new convenience initializer okay
237:04 - so then you can go ahead and say my
237:06 - double to create an instance of it and
237:08 - then you can just say value all right
237:10 - you can see now the value is zero this
237:12 - is another fancy way I'm of basically
237:14 - accessing the value you could have said
237:16 - let my double is an instance
237:18 - of My Double and then you could have
237:20 - said my double dot value so that those
237:22 - two lines of code work pretty much I
237:24 - mean achieving the same thing okay
237:28 - now apart from extending I mean not
237:31 - apart from but I mentioned that
237:33 - extensions can extend structures and
237:36 - classes but guess what they can also
237:39 - extend existing protocols so so you can
237:44 - see in here we have a protocol called
237:46 - ghost room and it has this go room
237:48 - function you can go ahead and extend it
237:50 - you can say extension goes room
237:53 - and then in here you can add a new
237:55 - function say go of room room even more
237:58 - okay so this is just a ridiculous name
238:01 - I'm completely aware of it but you can
238:04 - um what I'm trying to say is that you
238:05 - can extend an existing protocol as well
238:08 - and add new functionality to it and by
238:10 - doing this every data type that conforms
238:13 - to that protocol would get your new
238:14 - function by default so you don't have to
238:16 - do anything okay then in here we just
238:18 - say self room value
238:21 - is vrooming even more like that okay
238:25 - then all of a sudden model X that we
238:28 - created in here which conforms to which
238:30 - is an instance of car which conforms To
238:32 - Go's room gets this new functionality by
238:34 - default so then we can say Model X
238:38 - go vroom vroom even more and then you
238:41 - can see that value being printed to the
238:43 - screen as well is rooming even more okay
238:46 - so extensions are I would say one of the
238:49 - most fun aspects of any programming
238:52 - language and in Dart for instance
238:54 - they're called mixins as well and
238:56 - they're available in some other
238:57 - languages such as rust as well so
238:59 - they're really fun because they allow
239:02 - you to make existing things and types
239:05 - better they can kind of get out of hand
239:07 - sometimes if you're like misusing them
239:10 - in that when you're extending generics
239:12 - types for instance you can just go crazy
239:13 - with generics but as long as you're
239:16 - comfortable and you and your teammates
239:18 - are comfortable with those extensions I
239:19 - would say go for it now we've talked
239:22 - enough about extensions for now at least
239:25 - let's go ahead and start talking about
239:27 - generics which is a topic a lot of
239:29 - developers try to avoid but I think you
239:32 - need to embrace it because if you look
239:33 - at most modern toolkits and Frameworks
239:36 - such as Swift UI
239:38 - they could have not been made possible
239:40 - without generics Swift UI is pretty much
239:43 - based entirely on generic types so I'd
239:46 - say one of the best practices of
239:48 - becoming a better developer is to
239:50 - embrace generics learn how to use them
239:52 - learn how not to use them and truly
239:55 - don't be scared of them so practice
239:57 - practice until you get the concepts and
240:00 - then use them wherever you think and
240:03 - your teammates think makes sense
240:05 - so without further Ado let's start
240:07 - talking about generic so I'm just going
240:09 - to press command in here and say a
240:11 - playground and we say generics
240:15 - like this and ensure you're creating it
240:17 - inside your workspace so Swift crash
240:19 - course
240:20 - and we create this generics uh
240:23 - playground import foundation and we say
240:25 - automatically run this all right I'm
240:28 - going to get rid of the export to the
240:30 - left hand side now generix is for me at
240:34 - least it's used to avoid writing the
240:38 - same function multiple times or writing
240:41 - the same code multiple times all right
240:43 - now
240:45 - generics they kind of look a little bit
240:47 - strange
240:48 - but
240:50 - they really at the end of the day once
240:52 - you've written the code for generics you
240:55 - can use them in so many different ways
240:57 - and you will be amazed by how powerful
241:00 - they are okay so what we're going to do
241:03 - as the first example of generics I'm
241:05 - actually gonna jump right in and write
241:07 - kind of like a scary looking function
241:09 - all right but what this function is
241:11 - trying to achieve is that I mean its
241:14 - mission statement is kind of like this
241:16 - it wants to expect any numer any
241:20 - numerical data such as a floating value
241:23 - or double value or an integer two of
241:25 - those values so it takes a left hand
241:27 - side and a right hand side and it
241:29 - expects us to pass it a function that
241:32 - can perform an operation on those two
241:35 - values and return a new value in
241:37 - response such as let's say x x is 10 and
241:42 - let's Y is 20 and then we say let's C is
241:46 - equal to X Plus y so this plus function
241:49 - takes a left hand side and a right hand
241:51 - side and returns a result which is the
241:54 - equivalent of adding those two values
241:57 - right
241:58 - now you can have minus in here you can
242:01 - have division in here it can have
242:02 - multiplication oops if I can write it so
242:06 - all these functions take a left hand
242:08 - side and a right hand side so they do
242:09 - some operations and they're actually
242:11 - operators we've talked about operators
242:13 - before okay so let's say then we create
242:17 - a function we say a function that
242:20 - performs
242:21 - a task and we say
242:24 - it's an operator that takes an integer
242:28 - and an integer and returns an integer
242:30 - kind of like this okay
242:33 - and then oops and then we say it
242:36 - performs this operation on a value
242:40 - on left hand side of type int and
242:43 - and right hand side of type int and then
242:46 - in itself returns int okay so you can
242:50 - see it's performing an operation that
242:51 - actually does the job I think they
242:53 - actually did something like this when we
242:54 - were talking about operators and we
242:56 - actually put this as a trailing closure
242:58 - I remember but it's similar to that at
243:01 - least and internally what it does is
243:03 - calls that op function and passes the
243:05 - left hand side and right hand side to it
243:07 - and returns this value in return
243:09 - then you can go ahead and say perform
243:12 - Plus on 10
243:15 - and 20. and then you can see it will
243:18 - just say 30 as a result because this is
243:21 - actually a function all right and you
243:23 - can say plus and then you can say minus
243:25 - of course you can say multiplication in
243:28 - here
243:29 - and you could also say division in here
243:31 - okay
243:32 - so maybe we could say 20.
243:35 - and 10 in here for the division so that
243:37 - we get proper values printed to the
243:39 - console
243:40 - so this is an example of this function
243:42 - now your teammate comes to you and says
243:44 - could you make this function work with
243:46 - doubles as well then be like um okay
243:49 - then I'm gonna change this to double
243:52 - and this two double
243:54 - and then this to double and then you
243:56 - have to go and change this to double and
243:58 - this to double and this to double
244:00 - then your code kind of works all right
244:04 - but the result of these is actually now
244:07 - a double so if you look at Foods data
244:09 - type is a double what happened to your
244:11 - integers well you change the function
244:13 - signature from int to double and you
244:16 - lost the ability to work with integers
244:18 - then you'd be like okay then I need two
244:21 - functions one for integer m one for
244:24 - double then you call this perform int so
244:27 - we say let's see if I can change this
244:30 - name perform int and then you say okay
244:32 - I'm smart enough I go ahead and create a
244:34 - perform double and I make sure that this
244:37 - double works with doubles okay so
244:40 - whoever wants to work with doubles calls
244:42 - perform double and whoever wants to work
244:45 - with integers works with uh perform int
244:49 - then your third colleague comes and says
244:51 - okay but I want to work with CG float
244:55 - and which is another data type which is
244:57 - inside the core Graphics framework which
244:59 - we haven't worked with right now but you
245:01 - can say core graphics and then you can
245:03 - say let X is CG
245:05 - CG float is equal to one it's kind of
245:08 - like a double actually
245:10 - and then you say oh a CG float then I
245:12 - have to create another perform function
245:15 - which is called perform CG flow
245:17 - however as you can see this is not a
245:20 - very maintainable way of working so this
245:23 - will just increase the size of your code
245:25 - base and you have to constantly go ahead
245:27 - and add new functions to your
245:28 - application
245:30 - wouldn't it be really good if we could
245:32 - create a function that works with any
245:33 - numerical type
245:35 - and if you look at integer let's go to
245:38 - anything here and then we see signed
245:41 - integer and then side numeric you can
245:43 - see that this sine numeric protocol
245:45 - conforms to another protocol which is
245:47 - called numeric okay and if you have a
245:50 - double value let's say let's X is a
245:53 - double 1.1 if you go to double and let's
245:58 - say numeric
246:00 - there should be an extension on double
246:03 - extension double which makes it conform
246:06 - to a
246:08 - that's numerical type as well so let's
246:10 - say binary floating point I think and
246:13 - then expressible by Flo oops not that
246:15 - long perhaps
246:16 - by integer literal hashable so stridable
246:21 - it is one of these implementations
246:24 - which conforms double
246:27 - to add that numerical type that we were
246:30 - just talking about I'm not sure which
246:31 - one it is we have to dig deep inside
246:33 - Swift source code basically
246:35 - but what I'm trying to say is that both
246:37 - double uh and int conform to a protocol
246:41 - called a numeric numeric
246:45 - now if we could somehow in here say that
246:48 - this function works with any numerical
246:50 - data type that would be really good so
246:52 - let's change this to numeric
246:55 - and then we say numeric numeric and here
246:58 - here and here okay
247:01 - now you'll see what happens inside your
247:03 - sift code and Swift tells you okay I
247:05 - understand you want to work with the
247:07 - numerics but you can't just add them
247:10 - like that you can't just say that this
247:12 - function expects numerics numeric is a
247:15 - protocol and if you want to use it here
247:17 - you have to use generics so the way to
247:20 - use generics is that you go right after
247:22 - your function name and you just open
247:25 - these less than an equal signs kind of
247:27 - like in here then you designate a letter
247:30 - usually a letter but sometimes people
247:33 - use words as well but it is very very
247:35 - common to use a letter so you say Okay I
247:38 - want to represent numeric with a letter
247:41 - okay I can't just say new American here
247:43 - because that is an existing data type
247:45 - let's just say n okay as a numeric then
247:48 - you say n should conform to numeric data
247:51 - type or protocol then anywhere inside
247:54 - your function signature where you're
247:55 - using numeric just type n okay so in
247:58 - here in here right there
248:02 - there and also here and also for the
248:05 - return value of your function
248:07 - all right so now you see all of these
248:09 - errors are going to go away so you can
248:11 - see all of them went away and your
248:13 - function still works and if I say let X
248:17 - and then I look at the data type for X
248:20 - you can see X it is understood to be an
248:22 - integer but how you didn't say anywhere
248:25 - that you're working with integers
248:27 - and that's the power of generics the
248:29 - compiler is uh is basically inferring
248:32 - the data type based on the values you
248:34 - pass here so if you say 10 and 20 then
248:37 - it knows that they both are integers and
248:39 - the result should be an integer and
248:41 - let's change this actually it's not
248:42 - perform int anymore it is perform okay
248:46 - now if you go and do and let's say let's
248:48 - X is perform on 10.1 and 20.2 all of a
248:54 - sudden X is a double because compiler
248:57 - understood that oh these both values are
248:59 - actually double they're not integers
249:01 - anymore so it substitutes the return
249:04 - value which is indicated by this n
249:06 - generic value to the actual values you
249:09 - pass through this function in here okay
249:11 - and you can also go ahead in here and
249:13 - say 10.1 and 20 what do you think X is
249:16 - going to be now
249:17 - well the compiler is also intelligent
249:19 - enough to promote the value the return
249:21 - value to the more complex or more
249:26 - complete data type the more complete and
249:28 - precise data type in this case is not
249:30 - integer but it is actually double so if
249:33 - you look at the data type for X is
249:35 - indeed double all right so that was the
249:39 - first example of using generics in Swift
249:43 - and I know it could look a little bit
249:45 - complicated but the more you work with
249:48 - generics you the more you will actually
249:50 - appreciate them
249:51 - we've now seen this example I would say
249:55 - actually a quite a simple example of
249:57 - generics in Swift now when you have
250:01 - functions that have multiple generic
250:03 - parameters in this case we have just one
250:05 - generic parameter that we've called n of
250:07 - type numeric
250:09 - but in other functions you might have
250:12 - generic parameters maybe two two or
250:14 - three of them or even more in that case
250:16 - the function signature might be getting
250:19 - quite long you would say R is something
250:22 - and D is something else so looking at
250:25 - this function you you would probably
250:27 - just get a panic attack just looking at
250:29 - the function signature and that is why
250:31 - Swift allows you to create function
250:34 - signatures for or generic function
250:35 - signatures where the direct generic
250:37 - parameters are stated at the end of the
250:40 - function declaration itself and right
250:44 - after actually the return type so to
250:47 - demonstrate how that works as well let's
250:49 - just take this that we have in here the
250:51 - code that we have in here and let's go
250:53 - and paste it right there okay and we
250:56 - will just name this function and perform
250:58 - two and change all these instances to
251:00 - perform two just to ensure that
251:01 - everything is working as expected so in
251:04 - order to create a function or generic
251:07 - function where the generic parameters
251:08 - are defined at the anode function
251:10 - signature you have to remove this
251:12 - generate type right here or as many as
251:14 - generic types as you have you remove
251:17 - them from the beginning or attached to a
251:19 - function name and you go right after the
251:23 - return value and then Define them right
251:25 - there using a word clause so in here we
251:28 - then say where for instance n is numeric
251:32 - so this is an alternative way of
251:34 - creating a generic signatures for your
251:38 - um or for your functions and in here you
251:41 - would of course you would still have n
251:43 - in there but you don't actually tag and
251:46 - as a meaning of type numeric so this is
251:48 - just a an alternative way of doing it
251:50 - and some developers prefer this way
251:53 - simply because in here you could just
251:55 - say A B C D or your generic types and at
251:58 - the end you could actually say what
252:00 - those a b and c and d are in fact of
252:04 - type of all right so just keep it in
252:06 - mind it's it's a it's an alternative way
252:09 - of defining your generic functions and
252:11 - it will just perform exactly the same
252:13 - way it did in the previous example okay
252:17 - now any data types such as a class and
252:21 - actually I can't say any data but
252:22 - classes and structures in Swift can
252:25 - conform to multiple protocols they don't
252:27 - necessarily have to conform only to one
252:29 - protocol okay and using this you can
252:32 - basically create generics that are
252:35 - um that are conformant to multiple
252:37 - multiple types so let's have a look at
252:39 - that right now and let's create
252:43 - and let's create let's say that we
252:45 - create two protocols in here we say
252:46 - protocol can jump okay and then in here
252:49 - we have a function that says jump so any
252:52 - type that conforms to can jump should
252:54 - have a jump function and then we create
252:55 - another another protocol in here that we
252:57 - say can run okay and can run has to have
253:01 - a run function then we go ahead and
253:04 - create a structure in here we call
253:06 - person and we say it can jump and it can
253:09 - run like that all right so this is
253:11 - conform conforming a new structure to
253:15 - two different protocols we can get a
253:18 - swift to fix these functions up for us
253:21 - in here you can see in run we say
253:23 - running
253:24 - and in Jump we say jumping jumping okay
253:29 - I think the indentation was a little bit
253:30 - wrong all right now we have that
253:33 - now let's say that you want to create a
253:36 - function called jump and run okay so
253:39 - let's say flunk jump
253:42 - and run and you want to take in a value
253:45 - in here of some type you you want to say
253:47 - Okay I want some value to be of any type
253:50 - and in here I want to say value jump and
253:53 - value the run but since this value at
253:56 - the moment is of type any it cannot have
253:58 - the ability to invoke that function jump
254:01 - or the Run function so you could say
254:04 - Okay I want value to be of type can jump
254:08 - if you do this then you can do the jump
254:10 - function but you can't do the run
254:12 - function all right so in here what you
254:14 - need to do is to go ahead and Define a
254:16 - generic data type in here let's say t
254:18 - and we say this data type can run can
254:22 - jump and can run like this and then
254:26 - inside the function signature itself you
254:28 - say the value is of type T now you can
254:30 - see if you type value you have access to
254:32 - jump and run functions so this is a way
254:35 - of combining multiple protocols in order
254:37 - to create a generic function signature
254:39 - where you have access to not only one
254:42 - protocol data but also multiple as long
254:45 - as basically you can make this as long
254:47 - as you want to all right
254:49 - so then we can go ahead in here and
254:51 - create an instance of person we say
254:53 - person is an instance of person and then
254:55 - we can say jump
254:57 - and run with the value of person and we
255:01 - can actually change this values internal
255:03 - sorry external parameter type to nothing
255:05 - so we can just say jump and run person
255:08 - in here okay
255:10 - now you can also have extensions on
255:13 - generic types and one generic type that
255:16 - is very useful is actually we haven't
255:18 - talked about them so much about their
255:20 - arrays and I raise you to find them like
255:22 - this you could say let names for
255:24 - instance is Foo and bar now if you look
255:27 - at the data type for names you can see
255:29 - it is an array of string so it is
255:32 - denoted by these square brackets now you
255:35 - can actually look at if you just type
255:38 - this is a string in here and let's see
255:41 - if you can find the data type for array
255:43 - so if you say array of strings so this
255:45 - is this is a an alternative way of
255:47 - writing the same same text instead of
255:49 - this you can just do syntactic sugar
255:51 - here and say array of string now if you
255:53 - go to array you can see it is a
255:55 - structure and it is a generic structure
255:57 - basically it's working with a generic
255:58 - argument called element
256:00 - now you can also create extensions on
256:03 - generic types so by simply saying
256:05 - extension Offspring You're basically
256:07 - extending an array of string and this is
256:11 - new format actually there's a new syntax
256:13 - in the latest Swift versions previously
256:15 - you have to say extension array where
256:18 - element
256:20 - was equal to string so this is the old
256:23 - syntax but the new syntax you can just
256:24 - simply extend an array of string which
256:26 - is a lot more readable okay then what
256:29 - you can do in here since you already
256:30 - have you've told the Swift compiler that
256:33 - you're extending an array of string if
256:36 - you create a function let's say we want
256:37 - to create a function on our on any array
256:39 - of string that finds the longest string
256:41 - okay so we say longest string and we
256:44 - return an optional string we haven't
256:46 - talked about optionals yet so just for
256:48 - now know that this means that we can
256:50 - either return actually have we talked
256:52 - about options structures enumerations
256:54 - protocols extensions closures no we
256:57 - haven't yet we will talk about optional
256:59 - soon okay but just know that this means
257:00 - it can either be a value or it can be
257:03 - the lack of a value equal to nil all
257:06 - right so and the reason behind is that
257:08 - you can always have and the reason I
257:10 - mean this is an optional string is that
257:12 - any array like final names is an array
257:16 - of string in here it can actually be
257:18 - empty okay so if this array is empty how
257:21 - can you find the late at the longest
257:23 - string in this array well you can't
257:25 - there are no strings in here okay
257:27 - finally it should be let right so the
257:30 - reason this is optional is because of
257:32 - that
257:33 - and then what you can do in here is to
257:34 - say let dot
257:37 - um so you sorry you say self-sorted and
257:39 - this is I mean to be honest you don't
257:40 - have to know exactly how this is working
257:42 - and this is just an example okay so we
257:45 - say sorted and then we say left hand
257:47 - side string
257:49 - and then we say right hand side string
257:50 - and we want to say left hand sides count
257:54 - the number of characters in the left
257:56 - hand side should be more than the right
257:58 - hand size characters and then we say
258:00 - take the first argument you can see the
258:02 - first argument is then deduced to be of
258:04 - type string as simply because we are
258:07 - extending a generic type whose elements
258:10 - are of type string and if you look at
258:12 - this property you can see it is using
258:15 - the same generic type call Elements all
258:17 - right so that's also extending generate
258:20 - types and then you can go ahead in here
258:22 - and say let's say
258:24 - we create an array of strings we say Foo
258:27 - bar and bads in here has one string and
258:31 - then Cox in here then we say longest
258:33 - string all right then we can get the
258:35 - value of bar and pass it to the console
258:39 - or the playground console whatever you
258:42 - want to call it okay
258:44 - then we have another topic to actually
258:46 - discuss and this is this goes to a
258:49 - little bit more
258:50 - um I would say Advanced but I think
258:52 - generics are Advanced topics to start
258:55 - with so we shouldn't be scared of having
258:58 - a look at some Advanced topics in here
259:00 - so let's go ahead and talk a little bit
259:04 - about Associated types in protocols okay
259:07 - so and this is this makes generic
259:10 - protocols we've already talked about
259:11 - protocols before but we haven't talked
259:13 - about generic protocols so let me just
259:15 - show you an example and demonstrate how
259:17 - generic protocols work in the beginning
259:19 - it might not make so so much sense but
259:21 - as we go on and complete this example it
259:24 - will make hopefully more and more sense
259:25 - to you okay let's create a protocol in
259:27 - here we call it view all right so
259:29 - anything that can that can be displayed
259:31 - to the user and we call it just view all
259:33 - right we say any view should have a
259:36 - function on it that is called add sub
259:38 - View and it is basically using the same
259:41 - view so it says anything that's a view
259:43 - should be able to add on another view to
259:45 - itself alright then we go ahead and
259:47 - extend this view we say it we had the
259:50 - add sub view as a default implementation
259:52 - in here and we say by default it is
259:54 - empty all right so the end the default
259:57 - implementation of add sub U doesn't do
259:59 - anything then we go ahead and create a
260:02 - structure in here we call a button and
260:03 - we say it conforms to the view protocol
260:06 - and at the at the moment we say it its
260:08 - implementation is currently empty okay
260:11 - if we didn't have this default
260:13 - implementation of the add sub view
260:15 - function then button structure would
260:16 - have had to implement the add sub view
260:20 - functioning here as you can see
260:21 - suggested by the playground all right
260:25 - so let's remove these comments from here
260:27 - we go back to how we had it before
260:29 - then what we're going to do in here is
260:31 - to create a protocol and we say and we
260:34 - want to basically represent every object
260:36 - in our system that can be turned into a
260:40 - view let's say you have a struct person
260:42 - okay and then you say it has a name and
260:46 - then you want to say I want to somehow
260:48 - present this person on my user interface
260:51 - and then you say okay I want to make it
260:53 - presentable all right so you could
260:55 - Define anything in your system that is
260:57 - presentable as a View using a protocol
260:59 - let's say protocol presentable as view
261:02 - all right and this is kind of like
261:04 - hypothetical at the moment but later in
261:07 - this course we will actually talk about
261:09 - mvvm in iOS or Macos and watch us using
261:13 - for instance combine and Swift UI plus
261:16 - RX Swift on RX Coco but for now just
261:18 - this is a hypothetical protocol but it
261:20 - is very real actually I use this in
261:22 - production today so
261:24 - and I just want to give you an example
261:26 - of how this could look like all right
261:28 - now if you want to turn a protocol to a
261:31 - generic protocol you use a syntax or a
261:33 - keyword called Associated type and using
261:36 - Associated type is almost as if you say
261:38 - presentable ads view has some sort of a
261:40 - generic parameter but this syntax isn't
261:42 - accepted and so if you get an error okay
261:44 - you can actually see it says an
261:45 - Associated type name V must be declared
261:47 - so let's go ahead and Define this we say
261:50 - Associated type and we say view type
261:52 - should be any data type that conforms to
261:55 - the view protocol you see what we did in
261:57 - here we didn't just leave it empty we
262:00 - said if something is presentable as view
262:02 - its view should actually be be of type
262:05 - view all right so it can either be a
262:07 - button or it can perhaps be struct table
262:11 - here's a view all right and maybe this
262:14 - struck the person will conform to
262:16 - presentable as view and say that my you
262:18 - type is actually a table all right again
262:20 - this is hypothetical at the moment at
262:22 - least
262:23 - then we say any object that is
262:25 - presentable as view should be able to
262:27 - produce a view for us to display the
262:28 - user so we say produce view is a
262:30 - function okay and this guy should
262:33 - actually produce a view of type not view
262:35 - but view type all right so if your view
262:38 - type is for instance button then this
262:40 - function should produce a button if your
262:43 - view type is table then this function
262:45 - should produce a table
262:47 - then we can't go ahead and create the
262:49 - next function in this protocol let's
262:51 - let's just call it configure so we say
262:53 - anytime we want to present a an object
262:56 - as a view we can allow it to configure
262:58 - itself using a super view as its
263:01 - reference so super View and we say this
263:04 - is a view as well and we save this view
263:07 - is view type so we say the super view
263:10 - could be any view but this view oops
263:13 - type but this view should be is of type
263:16 - view type which is a generic parameter
263:18 - to this vertical okay and last but not
263:20 - least then every object that is
263:22 - presentable as view should have a
263:24 - function on it that is called present
263:25 - all right and in here we say view is
263:28 - view type and then we say on super view
263:30 - view all right so this view we're
263:33 - already sure it is of type view type
263:35 - because this configure function sorry
263:37 - this produced view function actually
263:39 - produces a view type and that same view
263:41 - will be passed to this percent function
263:42 - okay and a superview should be anything
263:45 - that is a few okay so that that was the
263:48 - X their protocol definition itself all
263:51 - right let's go ahead and Define
263:52 - implement it and basically do some
263:54 - default implementation for some of these
263:56 - functions inside this protocol so we say
263:57 - extension presentable as View and now
264:01 - this is a generic protocol simply
264:03 - because it has an Associated type all
264:05 - right then we go ahead and configure our
264:08 - we write our configure function in here
264:10 - so like that
264:12 - let's just paste it in here and we say
264:14 - it's default implementation is empty by
264:16 - default all right then we will have a we
264:20 - will implement the present function all
264:22 - right like this and upon presenting a
264:26 - view on a super view we just go to super
264:28 - View and we say add sub view view all
264:31 - right because we already know anything
264:32 - that is a view has this add sub view
264:35 - function on it so we just call it all
264:37 - right then what we can do to make this
264:40 - all very exciting we say we create a
264:42 - button called my button which is
264:44 - presentable as a view all right then we
264:47 - know that this function and this button
264:50 - has to have two function implementations
264:52 - and they're the remaining two functions
264:55 - actually we don't want to do that so you
264:57 - can see presentable as view requires
264:59 - four actually three functions it has a
265:03 - produced View and it has a configure
265:05 - Ampersand and these two functions at the
265:08 - moment have default implementations
265:09 - right here but the Purdue view function
265:13 - doesn't have a default implementation so
265:15 - you can go ahead in here and say that
265:18 - you want to Define produce View
265:20 - produce view okay and then we change
265:23 - this and we say this actually returns a
265:25 - button as we've defined it in here
265:27 - button is a view all right and according
265:29 - to our protocol implementation the
265:31 - producer has to produce a view type that
265:33 - conforms to the view protocol and button
265:35 - does that it conforms to the view
265:37 - protocol in here okay so inside produce
265:40 - view we just say we return an instance
265:42 - up button just like that all right now
265:45 - what's going to happen is that you don't
265:46 - have to implement anything else except
265:48 - for this but if you want to go ahead and
265:50 - for instance do it as configure function
265:52 - in here so as soon as you start typing
265:54 - it let's say configure you can see then
265:57 - a swift understood that super view is a
265:59 - view however this view is a button but
266:03 - how they didn't understand the answer
266:04 - button the reason is that we changed the
266:07 - implementation of produce view so that
266:09 - it produces a button then Swift went to
266:11 - this protocol implementation in here and
266:13 - said oh produce view is producing a
266:15 - button so everywhere in this protocol
266:17 - where I see view type I'm going to
266:20 - replace it by button so it did this
266:22 - pretty much button button and button you
266:26 - can actually go ahead and test that by
266:28 - adding for instance also at the present
266:31 - function in here you can say present and
266:33 - you can see superview the view is a
266:36 - button so that's how generics work
266:38 - basically in in Swift protocols okay so
266:43 - it's very very simple when you look at
266:46 - the whole thing but if you go into
266:49 - details you can actually see there's
266:51 - lots of things to learn about how
266:53 - generics work with protocols especially
266:55 - and Associated types so just know that
266:58 - for now that protocols can become
267:00 - generics using Associated types and
267:02 - sometimes in Swift you need to know
267:04 - about them and you need to use them but
267:06 - if you're not working so much with
267:08 - generics you probably don't have to
267:10 - bother so much with Associated types but
267:12 - again if you feel intimidated by
267:15 - generics and Swift I think you need to
267:17 - tackle that fear and go ahead and
267:19 - actually play with generics so much that
267:21 - you become so comfortable with them that
267:22 - it becomes a part of your day-to-day
267:24 - tool and day-to-day way of working with
267:27 - swift okay
267:29 - now if you want to extend generic
267:32 - protocols just like you have extension
267:34 - on for instance here and you can see we
267:36 - have extension on this generic protocol
267:38 - you can go ahead and actually
267:40 - constrain your generic extensions to
267:44 - specific types so let's say that you say
267:47 - extension presentable ads View and then
267:50 - you can say where view type view type is
267:54 - equal to a button all right this way
267:57 - you're training extension on any object
267:59 - that conforms to presentable as view as
268:01 - long as that object's view type is a
268:03 - button if you did this let's see what
268:06 - Swift says actually so we're just
268:09 - creating a simple extension
268:10 - Representatives view if you add a
268:12 - function to this any object that
268:13 - conforms to presentable svu's protocol
268:15 - is going to get your extension values
268:17 - and or variables and functions however
268:20 - this way only presentable as view
268:22 - conforming objects that have a view type
268:25 - of button will get your extension all
268:27 - right so let's say func do something
268:29 - with button so we are adding a simple
268:32 - function in here and we'll say this is a
268:33 - button all right then let's go ahead and
268:36 - create a button we say button is an
268:38 - instance of my button and since my
268:41 - button conforms to the presentable ads
268:43 - view
268:44 - protocol we can say button do something
268:47 - with button right however if we went
268:49 - ahead in here and set structure table is
268:53 - also a view
268:55 - actually let's go to my button and we
268:57 - will just say my button is we copy that
269:00 - code and we go ahead in here and we save
269:02 - my table okay my table and in here where
269:06 - we have button we create another struct
269:08 - and we say table is a view and we say
269:10 - it's empty as well all right then we go
269:12 - back in here inside our my table we say
269:15 - that my table produces a table and in
269:19 - here we just create an instance of table
269:20 - and we change this as well to table all
269:23 - right so and we can remove the configure
269:26 - function as well we don't have to have
269:27 - it in there now if we go ahead and say
269:29 - my table table is an instance of my
269:33 - table if you say my table dot you can
269:35 - see that you don't have access to to do
269:38 - something with button function if you
269:40 - want my table to have the same extension
269:43 - do something with button and first of
269:45 - all you'd have to change the name of
269:47 - this function so you say do something
269:48 - with view for instance
269:51 - with View and then you also have to
269:53 - remove this generic constraint from here
269:55 - because my table doesn't produce a
269:58 - button it actually produces a table then
270:01 - your table my table will have to do
270:03 - something with view function as well all
270:06 - right so I hope that this makes generics
270:08 - a little bit more clear
270:11 - to us at at least by this point
270:14 - now apart from all of this you can also
270:17 - as I mentioned like when we saw this
270:20 - extension on array of strings let's see
270:22 - where we did that longest string okay
270:24 - you can also create other extensions on
270:27 - arrays even though there are generic
270:28 - types such as for instance calculating
270:30 - the average value of an array of
270:33 - integers so you can say extension
270:35 - int so any array and that contains
270:38 - integers and then you can say a function
270:40 - that calculates the average values and
270:42 - we say double
270:43 - and then we say self reduce this is a
270:46 - special generic function on any array
270:48 - and you start with a seed value and in
270:52 - here you do your operation you basically
270:54 - what it does is that if you have values
270:56 - one two three four it says okay I start
270:59 - with the value of 0. then I go to your
271:02 - first element then I say 0 and 1. so
271:05 - then we say Okay Plus them together it
271:07 - says okay zero and one plus together
271:09 - will be one then I will take this one
271:11 - and I will go to the next element which
271:13 - is two and I will do this operation
271:15 - between these two one plus two is three
271:18 - it says okay then I have three then I go
271:21 - to the next element and say three plus
271:22 - three okay six six is here and this is I
271:26 - go to the next element six plus four it
271:28 - will be ten all right so this is how
271:30 - reduce actually works if you take the so
271:34 - basically this com if you say lip XXX
271:37 - and then in here we say XXX you can see
271:39 - it's an integer but we want to grab the
271:42 - average then we have to divide this with
271:45 - uh the count of this array so self.count
271:48 - and we have to convert all of these to
271:50 - doubles so that they can actually
271:52 - produce a double value in here okay
271:55 - you can see now it is quite uh happy
271:57 - with the code that we're written and
271:59 - then you can say one two three and four
272:01 - and you get its average all right and
272:04 - you can see then the value printed to
272:06 - the screen right here 2.5 all right so
272:09 - if you had an array that was just like
272:10 - two and two or four and four in here
272:12 - then the average would actually be the
272:14 - same value as you've entered in here 2
272:16 - and 2 will produce two and four and four
272:19 - will produce uh four okay so that's how
272:23 - you can extend existing data types that
272:26 - are generic such as race okay I really
272:29 - hope that all of these examples made
272:31 - generics make a little bit more sense to
272:33 - you if they didn't I think it is
272:36 - important that you go back and practice
272:38 - generics yourself as well because
272:39 - without practice generics will probably
272:42 - never make sense
272:44 - good we're done with generics let's go
272:46 - ahead to the next section which is
272:48 - optionals so I'm going to create a a
272:51 - playground in here playground and we'll
272:54 - say blank and we say options which is
272:57 - also a very fun topic to talk about in
272:59 - Swift so let's just do that
273:01 - good and then in here we say import
273:03 - foundation and let's just do this so
273:07 - that it runs automatically as well and
273:09 - let's get rid of our project uh Explorer
273:12 - to the left hand side all right so
273:16 - optionals indicate a value that might or
273:18 - might not be present okay so let's say
273:23 - that you want to take a value and
273:25 - multiply it by two okay so let's create
273:27 - a function that takes a value and
273:29 - multiplies it by two so we say flunk
273:31 - multiply by two in here and then we say
273:34 - value
273:35 - and you can see it's an integer and it
273:38 - returns an integer as well all right
273:39 - then in here you just say value
273:41 - multiplied by two
273:43 - in order to turn this data to actually
273:46 - before I say in order to let me just
273:48 - explain what options then would do for
273:50 - this function and how they would make
273:51 - this function perhaps a little bit more
273:53 - fun to work with if you call this
273:55 - function multiply by 2 you always have
273:57 - to produce a value in here so you can't
273:59 - just call this function empty we're
274:02 - thinking that it will just produce zero
274:03 - if you don't pass anything to it okay
274:05 - you can see that it says okay you have
274:07 - to pass a value to me in here then if
274:09 - you don't want to do that if you just
274:11 - want to say okay if a value isn't there
274:13 - just assume it is zero okay what you
274:15 - could do is to say okay value is
274:18 - optional so you say it shouldn't it
274:21 - doesn't have to be passed on here and
274:23 - furthermore you can assign a default
274:24 - value to it so you say value is an
274:27 - optional integer that by default is not
274:30 - present
274:31 - then what you can do in here you say
274:33 - if let's value so this is the syntax of
274:36 - unwrapping an optional so you say if the
274:38 - value is present then return value
274:40 - multiplied by two otherwise return the
274:43 - value of zero like this all right and
274:47 - also there are other ways of actually
274:48 - doing this in Swift so you can see now
274:50 - this function works fine because it's
274:51 - hitting this point since a flat value
274:55 - syntax indicated that value is indeed
274:57 - nil there are other ways of doing this
275:00 - you could actually change this code to
275:02 - this and do it like this you could say
275:04 - it's an integer which by default is zero
275:07 - then it will work exactly as it did but
275:10 - I'm just trying to demonstrate how
275:11 - optionals work and how a flat works it's
275:13 - a little bit difficult to find
275:14 - hypothetical examples for using
275:17 - optionals which is a little bit a
275:19 - complicated topic to explain and even
275:21 - more complicated to find very trivial
275:23 - trivial examples of how to use them all
275:26 - right but let's just leave this example
275:28 - as it is so now you can see that you can
275:30 - call that function with either no value
275:33 - values or you could say you pass the
275:36 - value of nil and it will produce also
275:38 - zero or you could say you pass a value
275:40 - of 4 or 8 or whatever you want in here
275:43 - and this function will still work so
275:46 - even it works even with the value of nil
275:49 - I don't know why our playground isn't
275:51 - really running yet there we go so we got
275:53 - our values okay
275:55 - you can compare optionals with nil nil
275:59 - is a special value meaning that the
276:01 - absence of a value basically so you
276:03 - could say let H is an optional integer
276:06 - and it is equal to nil all right so it
276:09 - is not present basically then you could
276:11 - say if age is not nil age is there
276:15 - how odd because we expected it to not be
276:18 - there else H is now correct okay so we
276:22 - kind of expect this Branch to be to be
276:25 - executed right now and you can see that
276:27 - it is okay so that's how you can compare
276:29 - a value not being nil for instance okay
276:33 - now if you want to take an optional
276:35 - value and check whether it actually
276:37 - exists or not you should use actually
276:40 - not you don't have to use but you can
276:42 - use the if flat syntax so you say if let
276:45 - H if H is present then inside this block
276:48 - after if let age is not optional anymore
276:51 - so you can see it is right here okay so
276:54 - then you could say h is there uh how odd
276:59 - its value its value is H all right
277:03 - otherwise no age is present as expected
277:08 - because we know that age is actually nil
277:10 - and we should get this uh printed two
277:13 - that counts all right now apart from if
277:17 - let's way of unwrapping and optional you
277:19 - can also use another syntax which is
277:20 - called guard and guard does the negation
277:23 - of age basically so let's have a look at
277:25 - how Guard works so let's say we create a
277:27 - function in here we say check age all
277:29 - right and in here we want to read age we
277:32 - say we want H to be there if it isn't
277:36 - then we're just gonna return from this
277:38 - function within message but if it if it
277:41 - isn't there we return with a message but
277:42 - if it is there then we print something
277:44 - to the console for instance so you could
277:46 - say if age is nil then you could say age
277:50 - is nil as expected all right
277:54 - however there is another way of writing
277:56 - this function and the way to do that is
277:59 - you say this let's say that this entire
278:02 - function depends on this age variable
278:04 - right and however if you um if you type
278:08 - a function if you type your code like
278:10 - this anyone reading this code might not
278:12 - fully understand that this age variable
278:14 - is very important to this function's
278:16 - signature or dysfunctions functionality
278:19 - and that is why Swift has an alternative
278:22 - way of doing this check so if your
278:24 - function depends on some optional values
278:26 - and it can't really continue without
278:29 - those options optional values actually
278:31 - be being present you need to perhaps use
278:34 - the guard mechanism so in here you say
278:36 - Guard age shouldn't be nil else then you
278:41 - say age is nil as expected and then you
278:44 - return okay so you're basically saying
278:46 - make sure age is a nil if it is so this
278:50 - else reads if it is then do this and
278:53 - inside guard you always have to return
278:54 - so if you don't return you actually get
278:57 - an error so guards have this property
278:59 - that they need to return and because
279:01 - that's the whole point okay and also
279:04 - using guard you can unwrap values as
279:07 - well as we'll soon see so let's put this
279:09 - card in here and then we say the rest is
279:12 - age is not nil here strange because we
279:17 - don't expect that and then we call the
279:19 - check H function in here so we should
279:21 - now hit this Branch because age is
279:23 - indeed nil so we can't just guard that
279:25 - it isn't nil because it is nil and it
279:28 - will end up being here okay
279:30 - Now using guard you can also unwrap
279:33 - values because you can see in here if I
279:36 - say let XXX is H and in here I say XXX
279:39 - it is still an optional all right so
279:44 - um even in here if I select XXX as H you
279:47 - can see XXX is indeed optional integer
279:50 - however in here we said make sure that
279:53 - it isn't it isn't nil so it shouldn't be
279:56 - integer so I kind of expect XXX to be an
279:59 - integer all right but it isn't and the
280:01 - reason behind it is that we're not
280:03 - actually unwrapping this age we're just
280:06 - making sure that it isn't nil but the
280:09 - rest of the function doesn't understand
280:10 - and the way to fix that is to actually
280:12 - use garblet so let's say let's H2 int
280:16 - optional and we actually set a value for
280:18 - it we set a value on zero okay then we
280:21 - create another function here we say
280:22 - check age
280:24 - two and in here we say guard let H2
280:27 - otherwise so if we go in here and say
280:30 - let XXX in here let's do a return and we
280:34 - say XXX is equal to Age Two you can now
280:37 - see XXX is an unwrapped integer it's not
280:40 - optional anymore and that is simply
280:42 - because we did a guard let all right and
280:45 - then here we say age is nil how strange
280:47 - and then we return and then in here we
280:50 - say Age Two is not nil as expected uh
280:54 - value is equal to
280:56 - Age Two all right so this H2 in here is
281:01 - not uh this Valley anymore really it is
281:04 - unwrapped within this function all right
281:06 - then we can call this function as normal
281:09 - we say check H2 check H2 and we should
281:12 - then hit this line in here and you can
281:14 - see the value of H is indeed printed to
281:17 - the console value is zero you can change
281:19 - it to 10 if you want to and you can see
281:22 - that value being printed to the console
281:25 - as well all right so that's another
281:27 - syntax for guard using guard let for
281:29 - actually unwrapping an optional
281:32 - now optionals are actually an instance
281:36 - of an enumeration this enumeration is
281:38 - called optional unsurprisingly so just
281:41 - like you can switch on option on
281:44 - enumerations you can switch on options
281:46 - so you can in here go ahead and say
281:48 - switch age all right and you can get
281:51 - help from Swift to complete these for
281:52 - you this search statement you can go in
281:54 - here and say fix it for me you can see
281:56 - this optional uh enumeration actually
281:59 - has two cases let's see if we can find
282:02 - it enum optional there we go and it
282:05 - either is the value of none meaning that
282:08 - it is nil or it has some value inside it
282:10 - all right so in case of none let's just
282:13 - say age has no value as expected in case
282:18 - of sum we can unwrap it and say let's
282:21 - say value and we say age has the value
282:25 - of value like this and we can break in
282:28 - here as well break okay so age was nil
282:31 - if you remember so we kind of expect to
282:34 - hit this casing here which is none and
282:36 - it says age has no value as expected all
282:39 - right so that's how you would switch
282:42 - basically on an optional value you can
282:45 - also go ahead and do simple comparisons
282:47 - so if you could say if H2 for instance
282:50 - is equal zero so you could do that then
282:53 - you say H2 is 0 as expected and it's not
282:56 - the nil and let's go to H2 and actually
282:58 - make sure that it is zero so let's
283:00 - change it to zero and in here we say
283:03 - else age to
283:06 - is not zero how strange all right and as
283:10 - you can see the comparison is working so
283:12 - you don't so what I'm trying to say in
283:14 - here you can actually compare an
283:16 - optional value with another value like
283:18 - this without having to say if K slat or
283:21 - is it let case or case let I I always
283:24 - forget that so you don't have to unwrap
283:26 - it using a case let's or using a switch
283:30 - you can just compare it with an unwrap
283:33 - value like this as well
283:35 - okay now you can also just like we did
283:38 - this comparison you can also compare
283:41 - with the non or some cases so let's just
283:45 - copy and paste that code in here then we
283:46 - say if H2 is equal to sum
283:49 - 0 and then you say the same code in here
283:52 - so this these two are equal to each
283:54 - other I mean they're not equal but
283:56 - they're identical to each other so it is
283:58 - completely up to you how you want to do
283:59 - this code and for me if I see this code
284:02 - I don't assume that ah2 is optional but
284:06 - is indeed optional and but if you write
284:09 - your code for me I completely understand
284:11 - that oh H2 is optional so this is a
284:13 - little more descriptive of the problem
284:15 - in hand so I actually would probably
284:18 - prefer this but it is up to you and your
284:21 - team to decide on a convention on which
284:22 - one makes more sense to you okay now you
284:27 - can also do optional something called
284:28 - optional chaining and and that means you
284:31 - optionally access optional Properties or
284:34 - methods of some classes or structures so
284:37 - let's create an example for it we say
284:39 - struct person
284:40 - and we say let's name the string and we
284:43 - say left address is let's actually not
284:46 - do that at the moment let's inside this
284:48 - structure create another structure
284:49 - called address okay and in here we say
284:52 - let first line is a string and it's
284:54 - optional all right so we if we have it
284:56 - at an address then this first line might
284:59 - not be present and also uh additionally
285:01 - we go into person in here we say
285:03 - addresses itself is optional so even if
285:06 - it is present it doesn't have to have a
285:08 - first line but if it's not present it
285:10 - will be nil all right so it's like
285:12 - optional within optional so this is
285:14 - optional within this optional actually
285:17 - the other way around uh address is
285:19 - optional and within it there is another
285:21 - optional property okay let's create a
285:23 - person in here we say Foo is a person
285:25 - and we say it is equal to an instance of
285:28 - person with the name of Foo and its
285:30 - address is nil we just say we don't have
285:32 - an address okay then if we say we want
285:35 - to get this person's first line of
285:39 - address then we say if let Foo first
285:42 - address line line is equal to Foo then
285:46 - dot address and optional optionally grab
285:50 - the first line all right so it means
285:52 - address is optional we know about that
285:54 - but go and grab its first line if it is
285:56 - present then we say um
286:00 - E flat okay
286:02 - is equal to that
286:04 - then we print it out through first line
286:07 - otherwise we say Foo doesn't have an
286:10 - address with first line
286:13 - as expected so since we didn't have an
286:17 - address for Foo at all then it shouldn't
286:19 - even have a first line okay so this
286:21 - address basically Swift stops right here
286:24 - it says I can't go any further after
286:26 - address because address it itself nil so
286:28 - I can't grab the first line of it even
286:30 - if first line did exist the address
286:32 - itself doesn't exist okay so then we get
286:35 - this message printed to the console now
286:38 - we can go ahead and do another like an
286:42 - alternative way of grabbing this value
286:45 - is by first grabbing the address and
286:47 - then out of the address grabbing the
286:48 - first line it is a little bit more code
286:50 - and I don't actually think you win so
286:52 - much on it so I just wanted to show you
286:55 - how you can do that as well let's say if
286:57 - let Food address is food dot address so
287:00 - you first unwrap the address okay and
287:03 - then you say okay after that get the
287:05 - first line as first line like this is
287:08 - equal to full address DOT first line
287:09 - then you can say Food address and then
287:12 - you say first line all right but we know
287:14 - that we don't get in here because food's
287:17 - address is in fact nil so we don't even
287:21 - go inside this code in here and not in
287:24 - here either okay
287:26 - now you can compare optionals using
287:28 - chaining as well so let's go ahead in
287:30 - here and Define a bar person we say bar
287:33 - is an optional person actually and it is
287:35 - equal to person whose name is bar and
287:39 - whose address is in fact an address
287:41 - instance with the first line equal to
287:44 - nil all right so it has an address but
287:47 - its first line is now
287:49 - then we say if bars and you see we're
287:53 - accessing bar using an optional like a
287:55 - question mark simply bar simply because
287:57 - bar in itself is an optional value if
287:59 - bars name is equal to bar
288:02 - and bars address first line is equal to
288:07 - nil then we say bars name is bar and has
288:11 - no first line of address okay otherwise
288:15 - then we can say
288:17 - um seems like something isn't working
288:20 - right
288:21 - because we know that Bar's name is
288:24 - indeed bar and it has an address what
288:26 - its first line is actually nil okay but
288:29 - do you know this line of code actually
288:31 - isn't saying that it has to have an
288:34 - address but its first line should be nil
288:36 - it could actually work as well it will
288:38 - work as well if the entire dress is nil
288:41 - so let's just change it to nil and you
288:42 - can see still the same code will be
288:44 - executed all right so that's how
288:46 - optionality works it just continues
288:49 - until it can't continue any further okay
288:53 - now you can also switch on options with
288:56 - word Clauses all right using an optional
288:59 - chain so let's create a bass person in
289:02 - here I'm just going to copy paste that
289:03 - code so we don't have to create many
289:04 - persons and this time it's an optional
289:07 - person with an address that is present
289:09 - and it has a first line as well all
289:11 - right then we can go ahead and say
289:13 - switch on the per on baz address first
289:17 - line all right and in case we say in
289:21 - case of a sum we say let at first line
289:27 - and we just break in here and we say
289:29 - case and none actually let's not do that
289:33 - let's just say uh case first line and
289:36 - then we can go ahead in here and add a
289:39 - where Clause so this is pattern matching
289:42 - and so we're saying okay if the first
289:44 - line is available and using this word
289:47 - clause is pretty much just saying and
289:49 - and the first line starts with uh the
289:54 - string baths okay then we say bad's
289:58 - first address line is equal to
290:01 - first line like that then we say case
290:04 - let's sum and then we say first line and
290:07 - we don't have a word clause anymore and
290:09 - this one catches all then we say Bass
290:13 - first address line
290:15 - that didn't match the previous case and
290:20 - then we print the first line all right
290:23 - and then last but not least we also have
290:25 - to cover the non case where the value
290:27 - the optional value is indeed nil we say
290:30 - bass first address line is new
290:33 - and weird
290:35 - okay because we already know that bass
290:37 - is first address line is in fact Bas
290:38 - first line and you can see this being
290:40 - printed to the console it says Bas first
290:42 - address line is bass first line as it
290:45 - was in here so you can have where
290:47 - Clauses in your case statements for
290:49 - switching on optional
290:52 - um enumeration or enum values okay
290:56 - now you also can choose to um
291:00 - if you're using a flat or Gauntlet and
291:04 - you should do that uh as long as it
291:07 - makes sense to you all right so let's
291:09 - create a function in here let's say we
291:11 - say funk get full name and then we say
291:14 - we have first name as a string and then
291:16 - we have a last name as an optional
291:18 - string and we produce an optional string
291:21 - as well all right then we say
291:24 - we say that you have to have a last name
291:28 - all right even though the function
291:29 - signature says optional we say that okay
291:31 - you should have one we said if let last
291:33 - name
291:34 - if we can unwrap it then we return
291:37 - first name and name and space then we
291:42 - say last name all right otherwise
291:45 - otherwise we return nil all right now
291:48 - that's one way of doing it so you can
291:50 - just in here say get full name and for
291:53 - first name we say Foo and for last name
291:55 - we say nil then we call the same
291:58 - function with uh Foo and bar as names
292:02 - like this so this one has a last name of
292:05 - Nils so it should end up being here and
292:07 - you can see it's actually producing the
292:08 - value of nil and this one has both first
292:11 - name and last name therefore it is
292:13 - returning Foo bar as this result so
292:15 - that's one way of doing it but you can
292:17 - also go ahead and use guardlet so if you
292:19 - copy this code from here and then we go
292:22 - and paste it right here we say get full
292:24 - name two and in here you could say guard
292:27 - let
292:28 - last name otherwise
292:31 - return nil
292:33 - and then you switch these statements
292:35 - basically all right so you basically the
292:38 - way I usually read this is like this
292:40 - make sure last name is present otherwise
292:43 - return
292:45 - and then do this otherwise basically
292:47 - saying if last name is present okay so
292:51 - after doing a guard let all statements
292:54 - after that card let if we hit them in
292:57 - that in those statements the value that
292:59 - you unwrapped in here will be present as
293:01 - a non-optional all right so that was
293:05 - also short and sweet about optionals and
293:07 - there's lots more to actually explain
293:09 - about options and they pop up pretty
293:11 - much everywhere in Swift and especially
293:13 - Swift UI Azure as you as actually we'll
293:16 - talk about Swift UI later in this course
293:18 - as well but just know that they're there
293:20 - you need to learn them if you're working
293:22 - with Swift and it is very advantages if
293:25 - you can really master optionals and suit
293:27 - because they're pretty much everywhere I
293:30 - hope you enjoyed this section of the
293:33 - course as well and in the next core in
293:35 - the next section we're going to talk
293:37 - about error handling in Swift
293:39 - now that we've talked enough about
293:41 - optionals let's first do some cleanup
293:43 - here in our workspace so I'm just going
293:45 - to press command command W and close all
293:48 - these tabs that we have opening here
293:49 - there are quite a mini and they're not
293:52 - really contributing to so much right now
293:54 - rather they're just like making our
293:57 - workspace look a little bit dirty so I'm
293:59 - just gonna do command W in here and if
294:01 - you're in Visual Studio code for
294:02 - instance on Linux and or even actually
294:05 - replace build build oh okay I don't know
294:08 - what happened really and even if you're
294:09 - on Linux and you're for instance having
294:12 - Visual Studio code open with your Swift
294:15 - files you can also close them if you're
294:17 - not really interested in having them all
294:19 - open at the same time so as mentioned
294:21 - we're going to go and talk about error
294:23 - handling right now so I'm just gonna
294:24 - press command n and say blank in here
294:28 - and playground and let's say error Dash
294:31 - handling and I'm going to create it in
294:34 - the main workspace in here as you can
294:36 - see okay let's press create in here here
294:39 - and say import foundation and like usual
294:42 - we're going to go in here and say that
294:44 - it should automatically run all our code
294:47 - okay so error handling is one of the
294:50 - most important Concepts in any
294:52 - programming language that supports
294:53 - errors and exceptions and really the
294:56 - points of errors and exceptions are to
294:59 - tell the the caller to our code or
295:03 - whoever is using our code that something
295:04 - has gone wrong it's either the failure
295:07 - of the code that we've written such as
295:09 - an error or it's the failure of the
295:12 - person calling this function or code
295:14 - such as an exception so there is a
295:17 - little bit of a difference between
295:18 - actually errors and exceptions in
295:20 - different programming languages but in
295:21 - Swift usually we only talk about errors
295:24 - so meaning that the code found out that
295:26 - something hasn't gone according to the
295:29 - plans and then it throws an error and
295:32 - actually the word for it is actually
295:33 - throw in Swift indeed so there's a
295:36 - keyword for it called Throw okay and it
295:38 - is the same thing in many other
295:40 - programming languages actually it is
295:41 - called throw in Dart for instance as
295:43 - well
295:44 - so let's have a look at an example of
295:46 - throwing an error in Swift and catching
295:49 - it so we're going to create a person in
295:51 - here let's see if I can spell struck
295:53 - person and let's say we have a first
295:56 - name uh it's an optional and we say last
295:58 - name optional string as well okay then
296:01 - we want to create a function in here
296:03 - called get full name and this function
296:06 - should ideally return a string okay so
296:10 - we're going to say funk get full name
296:12 - and we say it returns a string right
296:16 - however how can it return a string if
296:19 - first name and last name are both
296:21 - optional meaning that they could at any
296:23 - point both be nil or one of them could
296:25 - be nil and in those cases we cannot
296:27 - produce a full name so the goal of this
296:30 - function is to return a string it
296:31 - shouldn't really return an optional
296:33 - string because the full full name
296:36 - shouldn't be optional then what we're
296:38 - going to do in here we're going to say
296:39 - okay it is going to try to produce a
296:42 - string but it may actually throw so we
296:44 - say throws okay so the function throws
296:47 - but inside is it will throw all right so
296:51 - that's how the how the verb and the noun
296:54 - basically work
296:55 - uh actually I think it is a noun yeah so
296:58 - the function is marked as thirds meaning
297:00 - that internally it can throw an error
297:02 - now we're going to go ahead and Define
297:04 - our errors inside this structure then
297:06 - you don't have to Define them inside the
297:08 - structure or the class that throws them
297:10 - but it is usually good practice to
297:12 - Define them within their enclosing
297:14 - structure or class so so to associate
297:17 - the error objects with that structure or
297:20 - class okay so we're gonna go and say
297:22 - enum errors for instance it doesn't have
297:25 - to be colors you could call it Myers or
297:27 - person errors whatever okay person
297:29 - errors also works but in here we're just
297:32 - going to call it errors and we need to
297:33 - ensure that this enum conforms to this
297:36 - error protocol okay you can see it is a
297:39 - public protocol okay so you cannot throw
297:42 - errors that are not
297:43 - um actually your enum if you're actually
297:45 - going to throw its cases the entire enum
297:49 - needs to conform to the error protocol
297:51 - so that's their role basically
297:53 - that we're going to see the first case
297:55 - of the error is for instance first name
297:57 - is nil we're going to say then last name
298:00 - is no
298:01 - and we're going to say case both names
298:03 - are nil so these are the available
298:06 - errors that this function can throw so
298:08 - these are the three things that can go
298:11 - wrong either the first name is no or the
298:13 - last name or both in any other case
298:16 - means that name and last the first name
298:18 - and last name are not nil and we can
298:20 - calculate the full name successfully all
298:23 - right so as option as we've actually
298:26 - learned in the optionals section of this
298:28 - video optional data type is a it is an
298:33 - enumeration meaning that we can do
298:35 - switch on them so if we want to
298:37 - basically learn whether these two are
298:40 - both not nil you could either do it like
298:42 - this a flat first name and let's last
298:46 - name then you can produce the first name
298:48 - and like this first name and then last
298:51 - name
298:53 - this then you should say else if first
298:56 - name is nil and last name is not nil
298:59 - then you should say throw
299:01 - and you say errors
299:03 - first name is nil then you have to do a
299:06 - lot of else statements in here to
299:07 - understand okay first name wasn't nil
299:09 - last name was nil and then throw uh last
299:13 - name is no and if both of them are
299:15 - nailed then do this so it's a lot of if
299:17 - and else statements instead of all of
299:19 - that we can just do a simple switch
299:21 - statement in here okay so let's just say
299:23 - we switch and we say we switch on the
299:26 - first name and last name alright so this
299:28 - is the first name we're doing is switch
299:29 - on two enums at the same time all right
299:33 - so the first case and we want to handle
299:36 - one third both nil so we say case the
299:38 - first one is none and the second one is
299:41 - none okay in this case both names are
299:44 - nails so we say Throw errors
299:46 - both names are name the next case we
299:49 - want to make sure that
299:51 - um we want to basically see if the first
299:54 - name is nil but the last name is not
299:56 - milk so we say first name is nil and the
300:00 - last name is not mil remember sum and
300:02 - non-30 cases of optional so if you go in
300:05 - here do you remember these none and some
300:07 - some meaning that there is a value so
300:09 - we're saying that there is no value for
300:11 - first name but there is some value for
300:13 - last name in the case I'm not having a
300:15 - first name then we throw an err and we
300:18 - say first name is no
300:19 - then we reverse these so we say in here
300:22 - we take this non we say the first name
300:25 - is sum value but the last name is no
300:27 - values and then we say last name is no
300:30 - and in the other case then we say in the
300:33 - case of actually having a first name and
300:35 - last name so we say case let sum first
300:38 - name
300:39 - and some last name
300:42 - in here then we can calculate we say
300:45 - return and we return a string with the
300:48 - first name and last name in here just
300:50 - like that okay so this is this is like
300:53 - some sort of a pattern matching you
300:56 - could say in Swift and pattern matching
300:58 - in Swift is very powerful I mean I would
301:00 - say it's even more powerful than pattern
301:02 - matching for instance in Rust which is
301:05 - also in its in its own very powerful but
301:08 - Swift has some really neat features when
301:10 - it comes to power matching with switch
301:11 - statements for instance okay
301:13 - okay so let's go ahead now and create an
301:16 - instance of this person's structure we
301:17 - say let's oops can I spell let's Foo and
301:21 - we say person
301:22 - and for the first name we're going to
301:24 - say Foo and for the last name we're
301:26 - gonna say nil all right so now we want
301:29 - to go ahead and grab the lat the full
301:32 - name of this person and knowing full
301:34 - well that the last name is no meaning
301:36 - that we're gonna get into this case
301:39 - actually no sorry this case last name is
301:41 - no all right
301:43 - so how do we do that because if we go
301:45 - ahead and say let full name is uh Foo
301:49 - get full name get full name you can see
301:53 - that we're going to get an error from
301:54 - Swift saying that actually it's very
301:56 - important that we see this in error it
301:59 - says call can throw but is not marked
302:01 - with try it says Well it can't throw
302:03 - basically it can throw an error but
302:05 - you're not trying to resolve that error
302:07 - so the key word for trying to resolve I
302:10 - know or trying to actually call a
302:11 - function for instance that can throw the
302:13 - keyword for it is try okay so you say
302:15 - try however we're gonna probably get
302:17 - another error now and it says well it
302:20 - crashed so the entire playground pretty
302:22 - much crashed and the reason is that this
302:24 - function through but we tried this
302:27 - inside a inside a context that doesn't
302:31 - have error handling so if you're using
302:33 - try then you need to be inside a context
302:35 - in where in which you're handling your
302:37 - errors and that type of context is
302:39 - created with the do keyword so you say
302:41 - do and then you place this code in here
302:43 - okay and in here then you can go ahead
302:46 - and say catch and then you say got an
302:49 - error and there is an internal error
302:52 - object in here which is just called
302:54 - error okay and you can see now we are
302:56 - getting this in here and says God error
302:58 - and it says last name is no so this is
303:01 - according to what we basically expected
303:03 - okay so just remember do and catch and
303:06 - inside the cache block if you don't
303:07 - specify anything in here and like let's
303:10 - e or something because then we're going
303:13 - to get e in here if you don't specify
303:15 - how you want to catch in into which
303:17 - variable there is an internal hidden
303:19 - variable called error inside every catch
303:22 - statement okay
303:23 - good now if you also want to I mean this
303:26 - this just catches every error any error
303:29 - pretty much okay so if you go in here
303:31 - and say
303:32 - Foo and the first name and last name for
303:35 - it is nil now you see you catch another
303:37 - error that's called both names are nil
303:39 - okay but what if you want to catch
303:42 - specific figures you don't want to catch
303:43 - every error you want to catch for
303:45 - instance specific errors you can you can
303:47 - say I just want to catch person errors
303:49 - okay and any other error that happens in
303:52 - here I don't want to catch it because
303:53 - remember inside the do statement you can
303:56 - actually have a lot of code you can have
303:58 - a lot code in here and you can say let
304:00 - blah is try something else okay and any
304:03 - of these statements that have tried
304:05 - before them they can throw and they then
304:07 - those errors that are thrown could be of
304:09 - different types So within the do
304:11 - statement you can have multiple uh lines
304:13 - of code Each of which can also throw
304:16 - different types of Errors if that is the
304:18 - case how can you catch specific errors
304:20 - and the way to do that is using the is
304:23 - keyword after catch I'll show you so
304:25 - let's copy this in here that we have and
304:28 - paste it and then we put the full name
304:30 - in here just so that we get the full
304:33 - name printed to the screen if if any but
304:35 - we already know that there will be no
304:37 - full name and in here we're going to say
304:39 - catch is person.heirs
304:42 - I like this
304:44 - okay and you can see in here this
304:46 - statement is still I mean let's see here
304:49 - okay we're gonna get rid of this one
304:51 - because we already know that is a person
304:54 - error okay
304:56 - so we have pattern matching basically on
304:58 - our catch and we can't actually grab the
305:00 - variable out of it anymore so we we
305:02 - detected that it's a person error and
305:04 - then the error variable isn't available
305:06 - to us anymore after doing this pattern
305:08 - matching okay so this is how you would
305:10 - look for specific types of errors in
305:13 - your catch statements all right now you
305:16 - can also catch specific errors I mean
305:19 - here you're basically matching the error
305:21 - against a type but then you would be
305:24 - asking yourself well but how do I know
305:26 - which one of these errors it is okay and
305:29 - you can actually catch specific errors
305:31 - just by typing catch which error okay so
305:34 - let's copy this code actually maybe
305:36 - let's create an another variable in here
305:38 - we say let bar equal to person and in
305:42 - this case we say both first name and
305:44 - last name are nil all right like this
305:46 - then we're going to copy this code that
305:48 - we have in here and right after bar
305:51 - we're going to paste that and we say
305:52 - full name is bar get full name all right
305:55 - and then in here inside catch we're
305:58 - going to change this code that we have
305:59 - and instead we say catch person errors
306:02 - and a first name is nil then we say
306:05 - first name
306:07 - is no like that
306:09 - and then I copy I'll copy this and I say
306:12 - we also want to catch last name is no
306:17 - and we say last name is no then we say
306:21 - okay we also want to catch person dot
306:24 - errors both names are now and we say
306:27 - both names are nil and otherwise at the
306:31 - end we have a catch all Block in here
306:33 - let me say some other error was thrown
306:35 - okay so now this now you see you can
306:39 - we're basically getting this error in
306:40 - here both names are nailed as expected
306:42 - first name and last name or not are
306:44 - basically nil okay so this is how you
306:46 - can catch specific errors as well this
306:49 - is how you can catch air types like
306:51 - errors of this type but inside this we
306:55 - already know that we have three specific
306:57 - errors and if you want to catch any of
306:59 - those specific errors you can do do just
307:01 - catch and that that specific here okay
307:04 - so that's another way of handling errors
307:08 - now we've had a look just at one
307:12 - function at the moment that can throw
307:13 - but uh you can also do you can basically
307:17 - throw errors inside Constructors as well
307:20 - of structures or classes meaning that
307:22 - you try to construct an object but the
307:26 - parameters that you're passing to that
307:28 - object are somehow not valid and so as
307:30 - you know the Constructor or initializer
307:32 - of classes and structures have complete
307:35 - rights to do some validation on the data
307:38 - that you're passing to them if those
307:40 - data for some reason are not correct
307:43 - according to the validation of that
307:45 - structure or class then the class or
307:47 - structure should be able to throw okay
307:49 - and I'll show you now how you can Define
307:52 - throwing
307:53 - initializers or Constructors for
307:56 - structures and classes so let's create a
307:58 - struct car in here okay and then we say
308:00 - let manufacturer and this manufacturer
308:04 - is a string
308:05 - then what we want to do is to create a a
308:09 - Constructor or initializer for this car
308:12 - that looks at the manufacturer that you
308:14 - pass to us and if it is empty then it's
308:16 - going to throw an error because at the
308:18 - moment you can say my car is a car with
308:21 - a manufacturer of empty string and this
308:22 - is not valid according I mean to our
308:24 - rules you shouldn't have a card that
308:26 - doesn't have a manufacturer okay so we
308:29 - want to basically catch this case we
308:31 - want to see okay when you pass the
308:33 - manufacturer to the structure is it
308:35 - empty if it is then we want to throw an
308:37 - error so let's go ahead and Define that
308:38 - error first so we say enum errors and of
308:41 - course we have to conform to the error
308:43 - protocol and we say case invalid
308:46 - manufacturer it is a very complicated
308:48 - word to type in my opinion then we go
308:51 - ahead and we say okay we have an
308:52 - initializer in here which takes in the
308:54 - manufacturer okay so I'm just going to
308:56 - copy this so I don't have to type it
308:58 - anymore and then in here we say this
309:00 - init function and it or initializer
309:03 - actually throws and then we say if the
309:05 - manufacturer is empty then throw errors
309:09 - dot invalid manufacturer otherwise self
309:12 - manufacture is equal to that
309:14 - manufacturer okay so you can see then we
309:17 - don't have a problem in here the only
309:18 - problem actually we have is that we're
309:20 - now calling this now Swift understands
309:22 - that this call to the initializer of car
309:24 - is throwing but we're not trying it okay
309:27 - so let's go ahead and do a try on this
309:30 - so we say do and we say we catch car
309:34 - errors
309:35 - invalid manufacturer and we just have a
309:38 - catch Hall case in here as well so we go
309:40 - into the do and we say try this code and
309:43 - in here then we say invalid manufacturer
309:47 - and we say some other error just like
309:50 - this okay now you should be able to see
309:53 - that we get this invalid manufacturer
309:55 - and pass in here so now the important
309:58 - thing is also that if you're inside this
310:00 - do clause
310:01 - and after this try statement you can
310:04 - definitely use my car so you can say my
310:06 - car that manufacturer do whatever you
310:07 - want with it but you already know that
310:09 - none of this code is going to be
310:10 - executed because the way we're calling
310:12 - this car or the initializer of the car
310:14 - structure is that it's going to throw so
310:17 - it's never going to reach this code in
310:19 - here so Swift reads this code goes and
310:21 - calls the Constructor and it gets to
310:24 - this throw and just immediately jumps
310:26 - out of this into its catch statements
310:28 - and says okay do I have any cash that
310:30 - matches the error that was just thrown
310:32 - yes and it then comes here and it
310:34 - doesn't even go here okay so you need to
310:36 - kind of follow the path of the program
310:39 - to understand what is happening really
310:42 - now you sometimes may not really care
310:45 - about the errors that are being thrown
310:47 - from functions or initializers for
310:49 - instance and the way to do that is that
310:51 - you want to grab the value of a function
310:54 - optionally so you say if this function
310:58 - is successful gets me the value for it
311:00 - so you don't actually care about the
311:01 - errors okay so let's go ahead and have a
311:04 - look at the syntax where and syntax work
311:06 - is using a flat okay so you said if let
311:09 - your car is equal to try with a question
311:12 - mark so this is simply try with a
311:14 - question mark simply means that you
311:16 - don't have to have a do and catch
311:18 - statement it says optionally try to call
311:21 - this function and if it is successful
311:23 - then give me the value back okay so we
311:25 - say Tesla and then we have access to we
311:29 - say success
311:31 - your car is a your car like this
311:34 - otherwise we say failed to construct and
311:38 - error is not accessible now so if you do
311:42 - this statement in here so you can see
311:44 - we're passing Tesla actually to the
311:46 - Constructor for our initializer for car
311:48 - therefore this logic is not going to be
311:51 - called and and a proper instance of car
311:55 - will indeed be created meaning that we
311:58 - will indeed come in here inside the
312:01 - success block all right so we optionally
312:03 - try to call this function if it was
312:05 - successful if it didn't throw then we
312:08 - come here and then we have full access
312:10 - to this variable all right otherwise we
312:13 - get to this clause and as you can see
312:15 - I've typed in here in here we lose
312:17 - access to the error that was actually
312:19 - thrown so we don't have access to the
312:21 - error object really in here okay so
312:24 - that's how you can optionally try to
312:25 - call a function that throws and grab its
312:28 - value
312:29 - now you can also in some very rare cases
312:32 - very angrily try to unwrap a the value
312:35 - of a function that can throw
312:37 - please know that in in all my years of
312:40 - working with Swift I haven't done this I
312:43 - know that it is available but you you
312:46 - and you should as a swift programmer
312:48 - know that it exists but you should
312:49 - almost never ever use it but and the
312:54 - reason behind it is that this code as I
312:56 - said angrily unwraps a function that can
312:58 - throw meaning that your program or your
313:01 - application or your IOS app or watch OS
313:02 - app or Mac OS app will indeed crash
313:05 - completely and completely close should
313:09 - the function that you're invoking
313:11 - actually throw an error and the Syntax
313:13 - for it is not with an optional try it is
313:16 - indeed with a a how do you call this
313:19 - actually exclamation mark okay so let's
313:22 - go ahead and have a look at this we say
313:23 - let their car
313:26 - is equal to try and we say car with a
313:29 - manufacturer of Ford and you can see now
313:31 - this will indeed be a valid um car
313:34 - instance and I can say their car that
313:37 - manufacturer nothing really happened and
313:39 - you think okay but why did he say that
313:42 - you should never use the syntax and the
313:43 - reason is that
313:45 - should this manufacturer be empty this
313:47 - whole playground will crash and it will
313:50 - just you can see in here and encounter a
313:54 - crash and could not finish executing
313:55 - this same thing will happen to your app
313:57 - and what whether it's a Mac OS or iOS or
314:00 - and watch OS app your app will
314:02 - completely crash it won't look as pretty
314:04 - as it did in the playground because the
314:06 - playground it still was open but it just
314:08 - told you that it crashed if it is in a
314:10 - real application the application will
314:12 - just completely close and the user will
314:13 - be baffled by what just happened so
314:15 - please don't use the syntax try to
314:17 - always do I mean ideally you should do
314:19 - do and catch if you can't do that please
314:22 - do try and please never try this never
314:26 - tried this way of unwrapping values
314:28 - unless there is a very compelling reason
314:30 - for it that you and your teammates for
314:32 - instance are completely comfortable with
314:34 - okay
314:35 - now we've already looked at throwing
314:37 - errors from functions but just know that
314:40 - you don't necessarily have to throw a
314:43 - specific type of error in here we have
314:45 - just one enum and then here we also have
314:47 - just one enum that Define our errors but
314:51 - a any function that is marked as throws
314:54 - can't throw any error it doesn't
314:56 - necessarily have to throw a errors from
314:59 - just one enumeration so let me just show
315:01 - you how that will look like let's create
315:03 - a struct in here and we call it dog all
315:05 - right
315:06 - like this and inside this let me
315:10 - actually create some empty spaces so we
315:11 - can do this so inside the dog structure
315:15 - we're going to create two variables one
315:17 - is called is injured and is sleeping
315:20 - okay so it is injured
315:22 - injured Bull and uh let is
315:26 - sleeping in here Boolean all right and
315:29 - then we go ahead and we want to create
315:31 - two functions a bark function and a run
315:34 - function so let's say funk
315:36 - Funk bark and Funk and we say run now
315:42 - inside the logic of this dog structure
315:45 - we're gonna say okay we're gonna bark
315:48 - like this but we're only gonna bark if
315:51 - we're not sleeping
315:53 - all right so we're saying if is sleeping
315:56 - like this then we want to throw on air
315:59 - so let's go ahead and Define the error
316:01 - for that so we say Ena barking errors
316:04 - and we say error and in here we say
316:06 - cannot bark is sleeping all right then
316:10 - we say if you're if if you're asked to
316:13 - bark and you're sleeping then we say
316:15 - Throw barking hers uh cannot bark is
316:19 - sleeping all right otherwise we bark and
316:22 - then we do something similar for this
316:23 - actually let's see what error we're
316:24 - getting in here throw okay because this
316:27 - function is not marked with throws so
316:29 - let's just change that to throws and
316:30 - we're also going to change this function
316:31 - to throws okay
316:33 - now we're going to go ahead and create
316:35 - another enumeration in here and we're
316:37 - going to call it uh running errors I
316:39 - think let's just say enum running errors
316:44 - errors error and then we say case cannot
316:48 - run is injured
316:50 - and we do the same thing in here so let
316:52 - me just copy this code and put it inside
316:53 - run and we say if is injured okay so we
316:58 - cannot run if we're injured then we say
316:59 - running errors cannot run is injured
317:03 - otherwise we say running or run
317:06 - something like that okay so I think you
317:08 - get the point so you cannot bark if
317:10 - you're sleeping or actually not you and
317:12 - not me either it's the dog so the dog
317:15 - cannot bark if it is sleeping and it
317:18 - cannot run if it is injured
317:20 - unfortunately okay so now that we have
317:22 - those we will also go ahead and create
317:24 - another function and we say funk bark
317:27 - and run which combines those two
317:30 - functions then we say try bark and try
317:34 - run now what happened in here we just
317:36 - said try without having it do and catch
317:38 - what happened is that we're inside a
317:41 - function that can throw and if you mark
317:43 - your function as throws you can simply
317:46 - just try things you don't have to wrap
317:49 - them inside do and can
317:50 - what happens is that if any of these
317:52 - functions that we have inside bar can
317:55 - run throws then this function itself
317:57 - will throw so if you call this function
318:00 - and you call Bark then Swift goes in
318:03 - here and it says oh is it sleeping yes
318:06 - then it throws this error
318:08 - from this function and since that that
318:11 - function was invoked from this function
318:14 - then it will throw the error idea
318:16 - essentially from this function out to
318:19 - the caller okay so if you have a
318:21 - function marked that throws inside it
318:23 - you can try statements without having to
318:25 - wrap them inside doing catch in some
318:27 - rare cases you actually want to wrap
318:29 - them inside doing catch because perhaps
318:31 - let's say that your back-end developers
318:33 - tell you that hey if someone calls this
318:36 - function and this particular function
318:38 - throws an error then I want you to
318:40 - actually send an API request to the back
318:43 - end to log that error because that
318:45 - should never happen for instance okay so
318:47 - then you can say do okay try and then
318:49 - you say catch and in here you'll do your
318:52 - API
318:53 - okay you do your API call all right and
318:56 - then you can actually rethrow this error
318:58 - as well so and we probably will talk
319:00 - about that soon as well
319:02 - but just know that inside a throwing
319:05 - function you can try your statements
319:06 - without having to wrap them with that
319:08 - within do and catch okay so let's go
319:11 - ahead and create a little dog in here
319:13 - that unfortunately is both sleeping and
319:16 - injured so we say dog it's an instance
319:18 - of dog which is injured and it's also
319:21 - sleeping all right then we go ahead and
319:24 - we create a do and catch Block in here
319:26 - we say do and we say catch dog barking
319:30 - errors cannot bark and also we want to
319:34 - catch dog
319:35 - sleeping errors actually what did we
319:38 - have running here sorry running errors
319:39 - and cannot run is injured okay so you
319:42 - can see how we're catching both of these
319:43 - errors at the same time just using a
319:45 - comma and we'll also have a catch all in
319:47 - here so we say cannot uh bark is
319:52 - sleeping or cannot run
319:56 - is injured all right and in cash we say
320:00 - some other error
320:01 - and inside do we're going to say try dog
320:04 - dot bark and run
320:07 - all right so you can see now when we do
320:10 - that we say we get this catch statement
320:12 - here that says cannot bark is sleeping
320:14 - or cannot run is injured because we've
320:16 - basically caught both of these Earths in
320:18 - the same Clause all right you can
320:20 - separate them if you want to just using
320:21 - separate try statements now if you go
320:23 - and change these to false you will see
320:26 - that none of those errors will be thrown
320:28 - meaning that we will just not see
320:30 - anything in here basically so we can say
320:32 - dog just to confirm that this try
320:34 - statement actually ran its course and
320:36 - went to the next Lifeline 115 here okay
320:39 - let's revert them back in here so we
320:42 - have this example as well
320:44 - now
320:45 - now in case you're catching errors in
320:49 - separate catch statements just know that
320:52 - only the first Throne error will be
320:55 - caught all right so in here we caught
320:57 - both of them but again Swift called this
321:01 - block not because both these errors
321:03 - happened but it called this block
321:05 - because one at least one of these
321:08 - happened because remember when a
321:10 - function throws the execution of that
321:12 - function completely stops so barking
321:14 - throws an error Swift doesn't even go to
321:17 - running meaning that this uh this error
321:20 - will never be thrown therefore only the
321:22 - bark a function will throw its error
321:24 - which is right here Swift just
321:26 - completely stops the execution of this
321:29 - function and will run I will basically
321:31 - run its course out of it a step out of
321:33 - that function this error will be thrown
321:35 - and then we will come in here okay and
321:37 - we can actually test that let's copy
321:39 - this code and paste it in here
321:42 - and then we're going to go ahead and
321:43 - separate these catch statements and we
321:46 - go in here and we say catch first cannot
321:49 - bark is sleeping and when you say cannot
321:51 - bark as a sleeping
321:53 - then we will say catch dog dot uh
321:56 - running errors cannot run is injured and
322:00 - we say
322:01 - cannot run as injured like this
322:04 - and you'll see now only at the first
322:07 - error that was thrown will be caught
322:09 - which is cannot bark as a sleeping even
322:11 - though and this dog is both injured and
322:15 - is sleeping but the Run function will
322:18 - never be caught inside the bark and run
322:20 - function simply because bark through an
322:23 - error breaking the entire function call
322:26 - basically in here okay so that's how you
322:29 - can actually understand how you can
322:33 - catch verse and I hope now you know
322:35 - basically the flow of when errors are
322:37 - caught and that you shouldn't really
322:39 - expect to be able to catch multiple
322:40 - errors at the in the same do statement
322:43 - basically all right
322:45 - now let's talk about rethrows I said
322:47 - that we're probably going to talk about
322:48 - rethrows but I think it is time and now
322:51 - to talk about it so when we talk about
322:53 - rethrows we're talking about a function
322:55 - that internally calls another function
322:58 - which can also throw so let me just
323:01 - share an example let's create a function
323:03 - here called full name okay and we take
323:06 - in a first name which is an optional
323:09 - string and then we say a last name which
323:10 - is also an optional string and we say
323:13 - okay we ourselves cannot calculate the
323:15 - the full name we actually need a
323:17 - function that can't do that for us
323:19 - inside this function so this poor little
323:21 - function can't really do anything it
323:23 - just takes the first name and last name
323:25 - and calculates the full name now this ER
323:27 - is really stupid and I mean it is really
323:30 - not how you probably want to do your uh
323:32 - write your sift code but it is just here
323:35 - for the purpose of demonstration because
323:37 - if we didn't do a simple function like
323:38 - this and which looks dumb it would have
323:41 - to go ahead and create a very
323:43 - complicated function which indeed is
323:45 - production ready and you would probably
323:46 - use it in production code but this is a
323:49 - little bit easier at least to get into
323:51 - what rethrows keyword means in Swift so
323:55 - please just bear bear with me so we say
323:58 - we have a function that actually does
324:00 - the calculation we call it calculator it
324:02 - takes in a string and it takes two
324:05 - string optional parameters and it is a
324:08 - throwing function so we say it actually
324:10 - throws and it returns a string in return
324:13 - okay and then we just do this then we
324:16 - create our own function body in here so
324:18 - all these errors are going to go away
324:20 - now since this function is going to call
324:23 - this function it has to do a try right
324:26 - because this function throws therefore
324:28 - this function should also throw so then
324:31 - we say throws
324:32 - all right and also produces an optional
324:35 - string then okay we say try calculator
324:39 - and in here we have to pass the first
324:41 - name and last name so we say first name
324:42 - and last name all right so if you look
324:45 - at this code you will now see okay we're
324:47 - trying something in here okay and our
324:50 - function is called uh it's marked as a
324:53 - throws anyone looking at this function
324:55 - will think that somewhere inside this
324:57 - function we're probably throwing a
325:00 - specific error like we're actually
325:03 - um have some errors that we know what
325:05 - they are and we're throwing them perhaps
325:07 - okay however there is another syntax for
325:10 - this and it is called rethrows and how
325:14 - this really works is that it this tells
325:17 - Swift that this function in itself
325:18 - doesn't throw anything it is gonna
325:22 - basically invoke some other functions
325:24 - that throw all right so we could have
325:27 - gone in here inside the bark and run
325:29 - function and say this rethrows okay and
325:33 - you can see that our code will let's
325:35 - actually see what happened must take a
325:37 - throwing function argument and this is
325:39 - is really good we're seeing this I mean
325:40 - this is a example and why we actually
325:43 - didn't mark this as free throws so in
325:46 - order I mean the error is a little bit
325:48 - cryptic but what it is telling us really
325:50 - is that if for a function to be able to
325:53 - be marked as a rethrows it has to it has
325:56 - to have an argument that is a closure
326:00 - which throws and it should call that
326:02 - argument and since this bar can run
326:05 - function it doesn't have any argument
326:07 - that is a closure it doesn't even have
326:10 - any arguments that it cannot be marked
326:12 - as rethrows okay and that's what that
326:13 - error was telling us however this new
326:16 - function that we have in here has an
326:18 - argument that throws and we're actually
326:20 - calling it using try and therefore we
326:23 - can Mark our function as rethrows and
326:25 - this tells Swift that this function in
326:27 - itself is just calling an argument which
326:29 - is a closure which in itself throws on
326:32 - her okay so it's just a way of telling
326:35 - Swift that hey we have a throwing
326:37 - function in here and we're calling it
326:40 - and just we re-throw the errors that
326:42 - this function might eventually produce
326:44 - okay so let's then go ahead and create
326:47 - an enum in here and then we say enum
326:50 - oops enum and name errors
326:54 - and it's a it conforms to the error
326:57 - protocol in here and we say case first
326:58 - name
326:59 - is invalid and case last name is
327:05 - invalid all right then we create a
327:07 - function that can produce a a full name
327:10 - based on a first name and last name so
327:12 - we say func Plus
327:14 - it's an operator then we say first name
327:17 - is optional string in here then we say
327:20 - last name as well as an optional string
327:22 - and we produce a an optional string in
327:26 - return okay like this and we also can
327:29 - throw all right
327:31 - good and you can see we created this
327:33 - function with first name optional last
327:35 - name optional and result optional as
327:37 - well and throws and this function
327:38 - signature matches this you see optional
327:41 - string optional string throws at returns
327:43 - an optional string and the reason we
327:45 - created this function is simply because
327:46 - we want to call this function and
327:49 - instead of the calculator we're going to
327:51 - pass a reference to this plus operator
327:53 - in here okay so let's say we want to
327:56 - ensure that both
327:58 - um both the first name and last name are
328:02 - presented so we say guardlet
328:04 - first name so we ensure that first name
328:07 - is available and we say in case the
328:10 - first name
328:12 - is
328:13 - empty okay
328:16 - so the way you should read the statement
328:19 - is that we say make sure first name is
328:21 - available and make sure first name is
328:23 - not empty otherwise this is how I
328:26 - usually read my card statements okay
328:28 - make sure something and something
328:30 - otherwise which is the sales do this
328:33 - throw name errors first name is invalid
328:36 - alright so if first name is nil or that
328:39 - it is empty then we throw this error
328:42 - then we're going to do something similar
328:43 - like this then we say guard let last
328:47 - name ensure last name is present and
328:49 - that it is not empty otherwise say last
328:52 - name is invalid so you throw that error
328:55 - and if everything then goes fine then we
328:57 - say return and that first name and last
329:01 - name and you see these variables in here
329:04 - are not optional anymore and that is
329:06 - simply because we're doing a card let
329:07 - okay after gartlett is executed I mean
329:12 - if last name is nil then you never get
329:14 - here and that's why Swift knows that if
329:17 - you did get here and it means that
329:19 - you've already checked that last name
329:20 - was not nil therefore the data type for
329:23 - last name is not an optional string
329:24 - anymore it is actually a string same
329:26 - thing with first name it is string and
329:29 - not an optional string okay
329:31 - now that we have those we can go ahead
329:33 - and try to invoke this function right
329:35 - here which is full name so we go ahead
329:38 - and say we create a do Block in here and
329:42 - we say let Foo bar is try get the full
329:45 - name
329:46 - and we say first name let's say first
329:50 - name we say nil last name is nil and for
329:53 - the calculator we pass a reference to
329:55 - our plus operator in here okay and then
329:57 - we say we have to catch some errors in
330:00 - here so let's say catch and we say name
330:02 - errors first name is invalid then we say
330:05 - first name is invalid
330:07 - then we say cash also namers last name
330:10 - is invalid last name is invalid like
330:13 - that and then we will also have a
330:16 - catch-all block in here we say catch let
330:19 - err for instance and we say some other
330:22 - error and that is equal to err okay and
330:26 - you can also put parenthesis around this
330:28 - as well but this this is completely
330:29 - optional I think actually this is a
330:30 - little bit cleaner to read so now you
330:33 - can see that we're getting first name is
330:34 - invalid thrown in here okay and that is
330:37 - simply because our code just came in
330:39 - here I was like can I unwrap first name
330:41 - is there a value in it nope then it
330:44 - throws this error so it doesn't even go
330:46 - here and it doesn't it definitely
330:48 - doesn't go in these cases either okay so
330:50 - let's change this let's change the first
330:52 - name to Foo and you will see that your
330:55 - error will be the other one which is
330:57 - last name is invalid and then you say
330:59 - last name is bar then all of a sudden
331:01 - your function is gonna produce Foo bar
331:04 - for you okay so let's let's go ahead and
331:06 - do one more test and in here you can see
331:09 - that our function which is this operator
331:12 - is marked as throws but it is still
331:15 - returning an optional string however
331:17 - internally it never returns nil it
331:20 - either throws which is caught by this
331:22 - guy or not caught by it is covered by
331:25 - the sky
331:26 - or it actually returns a valid string so
331:29 - why is it marked with returning an
331:31 - optional string
331:33 - and this is actually a really good good
331:35 - question it doesn't necessarily have to
331:37 - be an optional string it is better that
331:39 - it is not and it still matches inside
331:42 - this function signature so because this
331:46 - is a promotion the a strain is not
331:48 - optional is a promotion of an optional
331:50 - string so it can always match it but if
331:53 - the emotion will never match inside a
331:55 - function signature okay so you can if if
331:57 - this requires a string you can never use
332:00 - a function that returns an optional
332:03 - string you will actually get an error
332:05 - now or we should get an error there we
332:07 - go okay so just remember a promotion
332:09 - will work but a demotion won't and this
332:12 - is a promotion we're saying that
332:13 - although you need an optional string
332:16 - which is at a lower level meaning that
332:17 - it can be nil but we will always produce
332:19 - a string which is at a higher level
332:21 - meaning it's never optional so it is a
332:24 - promotion a promotion function
332:25 - signatures in Swift always works okay
332:28 - good we've now talk about that now let's
332:31 - also talk about results and results are
332:33 - also very important to understand
332:35 - they're kind of related to error
332:39 - handling so that's why I wanted to name
332:41 - them and they're usually useful when
332:43 - you're writing API calls okay so what we
332:46 - want to achieve in here is to create a
332:48 - function that is called get previous
332:51 - positive integer and you will pass an
332:54 - integer to this function and the res and
332:57 - the responsibility of this function
332:58 - we're going to develop is to find the
333:01 - positive integer right before the
333:03 - integer that you pass to it as an
333:05 - argument so if you pass two this
333:07 - function is going to have to return the
333:09 - value of one if you pass one this
333:11 - function has to return zero but what
333:13 - happens if you pass zero there is no
333:16 - more positive integer before zero
333:18 - because the next number if you do a
333:21 - minus one to Z basically say zero minus
333:23 - one you are going to end up with minus
333:25 - one and that's not a positive integer so
333:27 - you could say well let's just throw an
333:29 - error and you'd be right you could just
333:31 - Mark your function as throws but there
333:33 - is another way of doing that there is
333:35 - another way of saying that a function
333:36 - fails but it fails perhaps a little bit
333:39 - more gracefully it doesn't actually
333:41 - throw an error but it carries an error
333:44 - with it okay and this concept is also
333:46 - available in many other programming
333:47 - languages you have it in Dart you have
333:49 - it in Python you have it in Rust so many
333:51 - other programming languages have this
333:53 - concept and in some languages it is
333:55 - called either but in Rust sorry in Swift
333:58 - it is called results so let's first go
334:02 - ahead and Define our error so we say
334:03 - enum integer
334:06 - integer errors it is an error and then
334:08 - we say case no positive integer before
334:12 - this value okay
334:15 - enum error case did I do something
334:18 - incorrectly in here it doesn't look like
334:19 - it formatted it right but this is fine
334:21 - okay then we create our function we say
334:23 - func and we say get previous V is
334:27 - positive integer and we say from int all
334:33 - right and in here what we need to do we
334:36 - are not going to say that this function
334:37 - throws but instead we're going to say
334:38 - that this returns a result that is
334:41 - either an integer or an integer error
334:44 - like in here okay so now all of a sudden
334:47 - instead of this function just saying I
334:49 - throw anything you're saying it either
334:52 - gives you the result or it gives you an
334:55 - error of this specific type which is a
334:57 - little bit cleaner to be honest with you
334:59 - because a throwing function doesn't
335:01 - necessarily specify or it can't really
335:03 - specify the type of errors that it
335:04 - throws so the color the call side to
335:07 - that function always has to have a
335:09 - catch-all block in order to understand
335:11 - okay what error is actually being thrown
335:13 - by this function but by using a result
335:15 - you specifically say which Earth you're
335:18 - gonna throw not really throw but which
335:20 - Earth you're going to carry with you if
335:22 - any all right
335:24 - so let's guard that this integer is more
335:27 - than zero otherwise we say return a
335:30 - result that is a failure and its failure
335:34 - is indeed an integer error you can see
335:38 - in here that is no positive integer
335:40 - before this value and the value is this
335:42 - integer right here okay
335:45 - so regarding that the ins is more than
335:47 - uh zero basically because otherwise we
335:50 - can't minus one all right then after
335:52 - this we say okay in that case we wanna
335:55 - in any other case where the integer is
335:58 - more than zero then we have to return a
336:00 - successful result and we say return a
336:01 - result with success and the value is
336:04 - integer minus one
336:06 - all right so you see how this function
336:08 - is structured at the moment okay then we
336:11 - go ahead and create a create another
336:14 - function which internally calls this
336:16 - function
336:17 - so we call it funk perform get and this
336:21 - is just to add another layer of
336:23 - complexity really to our code so that we
336:25 - don't go ahead and directly call this
336:27 - function I just want to show you how you
336:28 - can call this function within another
336:30 - function okay so we say perform a get
336:32 - for a value and we say value as an INT
336:35 - and inside this function we're going to
336:37 - call the other one get previous value
336:39 - sorry get previous positive integer from
336:42 - value and then since this guy returns a
336:45 - result and if you look at results you
336:47 - can see just like optional result is an
336:50 - enumeration meaning that you can switch
336:52 - on it so let's switch on this guy and we
336:55 - say in case if we get a success and we
336:59 - say previous value
337:01 - all right uh actually success previous
337:03 - value
337:05 - maybe not previous value previous
337:07 - positive yet previous value then we say
337:09 - previous value is previous value but in
337:13 - case we get an error we say case failure
337:16 - and we say error then you can say okay
337:19 - but this error it is in itself an enum
337:23 - it is an integer errors enum we already
337:25 - know that so since it's an enum you can
337:27 - have another switch within your switch
337:29 - the first switch is switching on this
337:32 - result
337:33 - and since it gets the error which is of
337:36 - type integer errors with it itself is an
337:38 - enum then you can have another switch in
337:40 - here then you say switch error in the
337:43 - case of no positive integer you put a
337:46 - let in here and you say this value
337:49 - then they say no positive integer before
337:52 - this value all right
337:56 - so now that we have this extra logic in
337:58 - here we can go ahead and call our
338:00 - perform gets function so I'm just going
338:02 - to copy paste some code in here you can
338:04 - see first we pass 0 to this function and
338:08 - let me comment this line out
338:09 - we first we pass 0 and 0 then count so
338:13 - that zero comes in here and it's then
338:15 - passed into this function then it comes
338:17 - in here and says make sure int is more
338:20 - than zero oops it's not return the
338:23 - failure
338:24 - and then it comes in here into failure
338:26 - gets the error we switch the error is it
338:29 - no positive integer before yes it is
338:32 - indeed and then you get this line
338:34 - printed to the console no positive
338:36 - integer before zero and that's correct
338:37 - okay then we bring this go code back you
338:40 - can see now it will hit this block and
338:43 - it says previous value is one all right
338:45 - because the previous value before 2 is
338:48 - indeed one so that's short and sweet
338:51 - about error handling in so if you can
338:53 - either use throwing functions and
338:55 - throwing Constructors for instance and
338:57 - then do and catch and you also looked at
339:00 - try with a question mark which
339:01 - optionally tries a function or try with
339:04 - an exclamation mark we should try to
339:06 - always avoid actually because it can
339:08 - crash your application and then at the
339:10 - end we looked at how result also works
339:13 - in Swift and how it it goes hand in hand
339:15 - with error handling in Swift as well
339:17 - okay
339:18 - now that we're done with error handling
339:20 - in Swift let's talk about Collections
339:23 - and collections is something we've
339:25 - talked about up to this point a good
339:27 - maybe five or ten times and the five to
339:31 - ten times I would say but we haven't
339:33 - really gone into details about them so
339:35 - I'm gonna close this playground in here
339:38 - I'm going to press command n and say
339:40 - blank in here and let's create a new
339:43 - playground and we're going to call it
339:45 - collections all right and ensure that
339:47 - it's created in your main workspace and
339:51 - then we say create
339:52 - and just like normal we say import
339:55 - foundation and run this playground also
339:58 - automatically we get rid of our Explorer
340:00 - here and then we can start talking about
340:03 - collections so collections as their name
340:06 - indicates there are a collection of
340:08 - stuff all right so for instance with
340:10 - numbers and if you're I mean not if but
340:13 - since you're already familiar with other
340:15 - programming languages collections are
340:16 - also called arrays or dictionaries or
340:19 - even Json objects for instance if you're
340:20 - working with simple JavaScript you can
340:22 - just say
340:24 - const something is equal to and then you
340:27 - add your values in here value blah okay
340:29 - so this is a simple Json JavaScript and
340:32 - it's some sort of a collection and in
340:35 - Swift you also have different types of
340:36 - collections one of them is an array so
340:38 - you say let's numbers is one two three
340:41 - four for instance and then you can do
340:43 - different things with this collection
340:45 - you can say give me the first value give
340:47 - me the last value give me the count of
340:49 - objects in here or you can say numbers
340:52 - map every element to its minus
340:55 - counterpart so you can see in here then
340:59 - let me just bring this over so you can
341:01 - see we have one key one two three four
341:02 - then the first element is one last one
341:04 - is four there are four elements total
341:05 - and then here we mapped every element
341:07 - inside this numbers array to its minus
341:11 - counterpart okay so this is an operator
341:13 - in here now if you have an array in
341:16 - Swift you can also mutate it as long as
341:18 - it is a variable so let's say VAR
341:20 - mutating numbers and we say 0 1 and 2
341:24 - and then you can see mutating numbers
341:25 - append the value of three and then
341:28 - mutating numbers
341:30 - insert the value of -1 at the index of
341:34 - zero okay so index of zero is right here
341:37 - not that the zero is actually let's
341:39 - let's just say four five and six instead
341:41 - okay and then we append the value of
341:43 - seven and we then insert the value of
341:47 - three at the index of zero meaning that
341:49 - the array was four five six but at the
341:51 - end it will be three four five six seven
341:54 - you see what happened in here the index
341:56 - of zero is right here and in the index
341:58 - of one is right here index of two is
342:00 - right here because the in index is in
342:02 - arrays and any collection in pretty much
342:04 - every program language that I know about
342:06 - they start at the index of zero they're
342:08 - called zero based indexes okay
342:11 - so and apart from doing a pens and
342:14 - inserts you can also insert a whole
342:16 - array inside an array so you can say
342:18 - mutating numbers insert and then you can
342:21 - say insert the contents of for instance
342:22 - one and two at the index of zero so
342:26 - let's see what happens in here
342:29 - and then right it's not insert it is
342:31 - actually insert contents off so this API
342:34 - calls called insert contents off and you
342:36 - can see the resulting array will be one
342:38 - two three four five six and seven here
342:40 - okay you can enumerate over the elements
342:43 - inside an array by just using a for
342:46 - statement for Value in numbers so then
342:48 - you can say a value and print it to the
342:50 - console and now
342:52 - um playgrounds have an interesting way
342:55 - of showing values over time since we're
342:57 - animating over these values and there
343:00 - are four of them it can't print them all
343:01 - in the same line so you have to click
343:03 - here I believe and it gives you like a
343:06 - little graph and then you have to right
343:07 - click on it and you say value history
343:10 - then you get the values one two three
343:12 - four otherwise it shows you a graph for
343:14 - some reason okay and let's somehow
343:17 - remove this okay there we go so that's
343:20 - how you would go through values inside
343:22 - an array okay
343:24 - you can also enumerate through items
343:27 - inside an array with pattern matching
343:29 - using the where Clause so if you want to
343:31 - for instance grab all the uh all the
343:34 - even numbers inside this array so
343:37 - because you saw this printed one two
343:38 - three and four and one and three are not
343:40 - even numbers but if you want to grab
343:42 - only the even numbers you could say four
343:44 - value in numbers where
343:47 - value
343:49 - and we're basically the the result of
343:52 - dividing the value by 2 should be equal
343:55 - to zero okay so this is how you would do
343:57 - your pattern matching if you say value
343:59 - in here we can do the same thing that we
344:01 - did earlier and say value history and
344:04 - then you only get the values of 2 and 4
344:06 - in here okay so that's how you can have
344:09 - a where Clause right after your four
344:12 - statements
344:13 - now you can also map objects inside an
344:16 - array and mapping is also very important
344:18 - because it's one of the most useful
344:20 - functionalities of collections mapping
344:22 - means that you take the values inside
344:24 - that collection and you turn them into
344:26 - something completely different if you
344:28 - want to okay so let's say numbers you
344:30 - map them you see and it says okay I give
344:32 - you the number so let's say value and in
344:35 - here you can say I return anything in
344:37 - this case we've decided to return an
344:39 - integer and we say value multiplied by
344:41 - two now you can all of a sudden see that
344:43 - numbers are 2 4 6 and 8 whereas they
344:46 - were originally one two three and four
344:49 - so here you multiply them by by two
344:52 - however inside map you can't return
344:54 - anything you can say I actually return a
344:57 - stream okay and then you turn these into
345:00 - a string you can string first multiply
345:02 - them by two but then turn them into a
345:05 - string now you can see there are strings
345:06 - so map allows you to map it to anything
345:09 - all right and now that we're talking
345:11 - about mapping it to anything you can you
345:13 - can guess that this map is indeed a
345:15 - generic function because it allows you
345:18 - to change the resolved value and if you
345:20 - look at its signature you can see it in
345:22 - is it indeed giving you the elements
345:24 - inside the array but it allows you to
345:26 - throw to return anything and the result
345:28 - would be the array of that anything okay
345:31 - so if I go and say let values you can
345:34 - see values is an array of um not in this
345:37 - case but in this case values will be an
345:39 - array of string okay like this
345:43 - so values is an array of string right
345:45 - now and just a note about this at Maps
345:49 - don't necessarily have to be this
345:51 - complicated I mean um to me this and
345:54 - actually we can recommend this syntax
345:55 - more than I can recommend the next
345:57 - syntax I'm going to show you and simply
345:59 - because the more information you give to
346:01 - the Swift compiler the faster your code
346:03 - compiles in larger applications but if
346:05 - you have very simple applications you
346:07 - don't have to do this much syntax work
346:10 - in Swift you could literally just say
346:13 - okay first of all I don't want to give
346:14 - you I don't want to tell you what return
346:16 - value I have and Swift still is happy
346:19 - with that you can also remove this in
346:21 - here because Swift already knows the
346:23 - value is an integer okay and this works
346:25 - as well and you can completely remove
346:27 - that and instead of value use dollar
346:29 - zero and that works as well so your code
346:33 - could pretty much just look like this
346:34 - but again I mean this does work but it
346:38 - is it has a very little information
346:40 - about what that code is actually doing
346:42 - internally so so a new newbie software
346:46 - developer may be quite confused by it
346:47 - and also as I said this is more
346:50 - information to the compiler which allows
346:51 - it to compile your complicated codes in
346:54 - the future a little bit faster as well
346:55 - okay
346:56 - apart from mapping arrays you can also
346:58 - filter them meaning that you want to
347:00 - grab specific values out of this array
347:02 - you could say numbers
347:04 - then you filter and you say you get the
347:07 - value and you turn and return a Boolean
347:10 - and for all the objects that have to be
347:12 - included in the result of this filter
347:14 - function so you say if the value is
347:17 - greater than or equal to 3 then it
347:20 - should be returned from the result and
347:21 - you can see the result is 3 and 4. okay
347:24 - so that's how Filter Works you can also
347:27 - do compact mapping and compact mapping
347:30 - mapping is similar to map but it returns
347:33 - an optional and the values that are
347:36 - returned from this compact map which are
347:38 - nil will not be included in the results
347:40 - so it's a compact map is a combination
347:43 - of map and filter okay so let's have a
347:46 - look at that we say numbers compact map
347:48 - and we say we get the value as an
347:50 - integer and we return a string okay an
347:54 - optional string remember it should be
347:56 - optional optionality indicates a
347:58 - filtering so if it is nil it won't be
348:00 - included in the resulting array then we
348:03 - say if Val value is divisible by 2. then
348:06 - return the string of that value
348:09 - otherwise return nil so let's break it
348:11 - down into separate lines it's a little
348:13 - bit more readable okay so you can now
348:15 - see the result is at Raf strings that
348:18 - only includes two and four but it
348:20 - doesn't include three and one or one and
348:22 - three basically okay so compact map when
348:25 - you see it just know that is a is a
348:27 - combination of map and filter at the
348:29 - same times
348:31 - arrays in Swift can also contain the
348:33 - value of nil so let's say numbers uh
348:36 - numbers numbers two and it is an array
348:40 - of optional integers so meaning that it
348:42 - can contain not just integers but also
348:45 - nil then you can say one two and then
348:48 - nil four and five so this is completely
348:50 - fine all right and then if you say
348:52 - numbers two dot count you will actually
348:54 - see it is five
348:56 - because nil is one of the elements one
348:59 - of the valid elements inside this array
349:01 - and if you want to grab all the values
349:03 - inside this numbers array and that are
349:05 - not nil then you would say let's not
349:07 - snails
349:09 - is equal to numbers 2 filter so you
349:12 - basically say here's my integer and I
349:14 - return a Boolean for all the values that
349:16 - are not known then you could say
349:18 - um let's say its value its name is value
349:22 - then we say value shouldn't be nil like
349:25 - this all right and you can see the
349:28 - result of this is just one two four five
349:30 - all right however however
349:33 - this you will be like okay we've checked
349:36 - that the values are not nil and we place
349:39 - them inside this array so this array
349:41 - should now be an array of integers but
349:43 - that's not correct because if you look
349:45 - at this is is still an array of optional
349:48 - integers so what's happening here is
349:50 - that though we checked for nail values
349:52 - but we didn't tell and this so basically
349:56 - filter doesn't allow you to change the
349:57 - data type all right you can see it
350:00 - always returns the same array of the
350:02 - same element type so if our elements is
350:05 - optional integer the result of this
350:07 - function will indeed be integers as well
350:10 - in order to grab the non-null or not nil
350:14 - values out of this array and also change
350:16 - the data type you have to use compact
350:18 - map all right so
350:21 - um so you could say in here not Nails is
350:23 - numbers too and we say compact map and
350:26 - we say we take the integer
350:29 - and which is value and we actually
350:31 - return an optional integer as well and
350:33 - just return the same value all right if
350:36 - this value is nil it won't be included
350:38 - in the result and also it won't
350:41 - basically change the data type so not
350:44 - Nils is now not an array of optional
350:47 - integers okay I know it's complicated
350:49 - and it's a lot of generic code but it
350:52 - really requires that you work with these
350:54 - functions yourself to for it to
350:57 - basically click
350:58 - now arrays can also include instances of
351:02 - the same object multiple times so if you
351:04 - say numbers three and we say one two one
351:08 - two you can see that numbers three dot
351:11 - count is indeed four so it contains four
351:13 - objects it doesn't check whether there
351:16 - are unique or not okay arrays can also
351:20 - they don't necessarily have to include
351:22 - home homogeneous objects so they can be
351:24 - heterogeneous meaning that you can have
351:27 - integers and strings uh mixed up and
351:29 - Blended up in the same array so let's
351:31 - say let's stuff one and we say it is an
351:35 - array of it has an integer of one then
351:37 - it has hello then it has an integer of
351:39 - two and has a string up world but this
351:43 - will give us an error or it should
351:44 - because it says it is not a homogeneous
351:49 - array all right and it says it's a
351:51 - heterogeneous so in order to fix this
351:53 - you can see Swift is telling you to
351:55 - actually add as any to the end of this
351:58 - array and a collection literally could
352:01 - only be what is the same
352:03 - as an array of any and I mean this to me
352:07 - looks fine
352:09 - uh but I'm sure I'm not sure really what
352:12 - is the same collation level It could
352:13 - only be inferred to any add explicit
352:15 - type annotation
352:17 - um I believe we've already done that so
352:20 - I'm not really sure what it is
352:22 - complaining about let's just say stuff
352:23 - one and see if Swift has understood what
352:25 - this code is actually doing
352:28 - expected separator did I miss a
352:30 - separator somewhere let's stuff one
352:33 - to me this looks fine but not sure
352:35 - really what it is complaining about let
352:37 - me just bring it in here and then we say
352:38 - hello let's put all of these in oh
352:41 - because I've missed a comma in here I
352:43 - can see
352:44 - okay sorry about that so I've missed a
352:46 - comment there so now you can see our
352:48 - array looks fine and if I say stuff one
352:50 - count it should include the count of
352:53 - four in here okay there are four objects
352:55 - so this is a trick to get your array to
352:57 - include heterogeneous objects as well
352:59 - all right so
353:01 - um we can also go ahead and change the
353:04 - Syntax for this so if I copy this and
353:06 - paste it in here and changes the stuff
353:08 - too and then stuff to account if you
353:11 - don't want to have this as in here you
353:13 - can also tell Swift that this is in fact
353:16 - an array of any by doing this column in
353:18 - here just specifying the data type right
353:20 - there okay so that's another way of
353:22 - actually achieving the same result
353:26 - now that we've talked enough about
353:27 - arrays let's talk about uh sets a set is
353:31 - a special object it's a special
353:33 - collection that only contains unique
353:36 - values all right and the way it
353:38 - calculates uh uniqueness is based on
353:41 - hash values and equality all right and
353:44 - this is a little bit complicated a lot
353:46 - of people think it's just hash value but
353:48 - it is not it's also equality which is
353:50 - very important to understand and what
353:52 - sets so let's create a set we say unique
353:55 - numbers and then we say it is a set of
353:59 - the values one two one two and three all
354:02 - right and then we say unique numbers
354:04 - count and then unique numbers map them
354:07 - to their minus values let's just see
354:10 - what values we get in here you see after
354:12 - the creation of this set the set only
354:14 - includes the values of three one and two
354:17 - so two things are quite interesting
354:19 - about this is that it removed the
354:21 - duplicates so both twos were not
354:24 - included only one instance was included
354:25 - it and the same thing with the value of
354:28 - one only one instance was included so
354:29 - that's one thing that's interesting
354:31 - about creation of this set or and one of
354:33 - the properties that's important about
354:34 - sets it only includes unique numbers and
354:37 - the other one is that this array that we
354:39 - just passed to it it's ordering was
354:40 - completely changed within the set so
354:42 - sets in Swift cannot guarantee ordering
354:45 - as you pass the ordering to it so the
354:48 - ordering could just be mishmashed and
354:50 - the set will order the items as it
354:52 - pleases all right
354:54 - so
354:56 - sets can also contain Nils so we can go
355:00 - ahead in here just like arrays so let's
355:02 - say my numbers is a set of one two three
355:06 - and nil and five and then we say let's
355:10 - not nil numbers if we want to get the
355:13 - not nil numbers then we say it is a set
355:16 - of my numbers and then we compact map
355:19 - this guy a compact map and we grab only
355:23 - the current value you can see in here
355:25 - compact mapping let's actually break it
355:27 - down into separate lines
355:28 - so it is more readable like this and
355:32 - like this all right so we're just taking
355:34 - the same values which are inside my
355:36 - numbers returning returning them from
355:38 - compact map compact map what it does is
355:40 - if the values are nailed it removes them
355:42 - from their result and you can see the
355:44 - result of compact map inside a set it is
355:48 - an array of the values and that is the
355:51 - reason we're putting it inside another
355:52 - set because we want the return value to
355:54 - be a set as well all right and then we
355:57 - say not nil numbers
355:59 - in here you can see in here we have five
356:02 - where is it uh two three nil one five
356:05 - but in in there we have only three two
356:07 - one and five so nil was removed
356:09 - essentially by calling compact map on
356:12 - that sets okay
356:13 - now you can also create heterogeneous
356:16 - sets just like you can create
356:17 - heterogeneous arrays so a set doesn't
356:19 - necessarily have to only have integers
356:22 - for instance so the trick to do that is
356:25 - to create a set of a protocol called any
356:28 - hashable all right so you say stuff
356:30 - three for instance and we say this is a
356:33 - set of any hashable and you can look at
356:36 - the code for any hash well sorry it's
356:37 - not a protocol it's a structure and we
356:40 - say it is equal to uh one two three and
356:45 - then bounded all right then we can say
356:47 - stuff three count you will see that
356:49 - includes four values all right
356:52 - so this is the trick to create a
356:54 - heterogeneous sets as well
356:57 - now if you want to extract specific
357:00 - items uh like of specific types out of
357:04 - uh any of these sets or arrays and let's
357:09 - just focus on the sets right now
357:10 - actually let's have a look at our stuff
357:12 - one you can see our stuff one is an
357:14 - array at the moment and that is an array
357:17 - of any but if you want to grab specific
357:19 - objects out of this array which are of
357:22 - specific types for instance only the
357:24 - strings or only the integers you can use
357:27 - a keyword which is called as so let's
357:31 - say let's ins in stuff one and again
357:34 - remember stuff one is this array it has
357:37 - integers and strings and you only want
357:39 - to grab the integers out of them so then
357:42 - you could say ins in stuff one is stuff
357:45 - one and then you compact map all right
357:47 - remember compact map does map and filter
357:50 - at the same time then you get your value
357:53 - which is any and you want to optionally
357:55 - return an integer then you say value
357:57 - as ins so you compare the values type to
358:01 - an integer and optionally return it if
358:04 - it is integer okay
358:06 - and then you can see in here that the
358:09 - result of this is only your integers
358:12 - and you can do the same thing with
358:14 - strings so you can say okay let's copy
358:16 - this and then we say strings in stuff
358:19 - one and then you get the value and you
358:21 - optionally return a string and then you
358:23 - say as long as the data type is a string
358:25 - I return it okay then you get the hello
358:27 - world printed in here okay
358:31 - so if you if you are comfortable doing
358:34 - this with a race then you're probably
358:35 - also comfortable doing that with sets
358:37 - and it is very similar it's actually
358:40 - compact map on sets as well so let's
358:43 - copy this code ins in stuff one and then
358:46 - we say ins in stuff three and remember
358:49 - stuff three is a set then we go in here
358:52 - and we say stuff three and we compact
358:55 - map and the value is any hashable
358:57 - hashable and then we optionally return
359:00 - an INT and then we get the result
359:03 - printed to the screen which is two three
359:05 - one and you can see one two three van
359:07 - dot so van dot was essentially removed
359:09 - from this set but one thing to note
359:11 - about this is that as I mentioned before
359:13 - compact mapping on a set doesn't return
359:17 - a set it actually returns an array so if
359:22 - you go in here and call type of which is
359:25 - an internal function in Swift and say
359:26 - give me the type of ins in stuff three
359:28 - it will tell you that this hopefully is
359:32 - did it crash it will tell you it's an
359:34 - array it's not a set anymore though
359:36 - stuff 3 was a set uh you can see in here
359:40 - is a set but the result of compact
359:43 - mapping is set is an array okay so just
359:46 - keep that in mind
359:48 - now now that we talked about sets a
359:50 - little bit and we talked about that they
359:52 - can contain the only that they only
359:54 - contain uh unique objects then the
359:57 - question is how does it calculate
359:59 - uniqueness and and the way it does it is
360:02 - using a protocol called hashable
360:05 - now hashable a lot of people think that
360:07 - only thing it does it it contains a some
360:10 - sort of a hash value is some sort of an
360:11 - integer value that uniquely identifies
360:14 - every object but it but hashable
360:16 - protocol
360:18 - in itself also includes equality all
360:21 - right so uh without without actually me
360:24 - talking too much about that let's have a
360:26 - look at an example so let's just say we
360:28 - create a person struct in here
360:30 - struck person and then we say we have an
360:33 - ID so every person has an identifier we
360:36 - have a name of string and then we have
360:38 - an H of integer as well
360:40 - okay and then we want this person to be
360:43 - able to instances of this person to be
360:45 - able to be included inside sets Okay so
360:49 - without making and without making this
360:52 - person hashable let me show you what
360:54 - will happen if it is not hashable and
360:56 - you try to create a set out of it so
360:58 - let's say that we have a foo ID in here
361:01 - and we say it is a uuid then we say let
361:03 - Foo is a person
361:05 - with the ID of Foo ID its name is Foo
361:09 - and its age is 20. all right then we
361:12 - create a bar person in here and we say
361:15 - bar is pretty much similar to Foo and we
361:18 - say bar but we forget to change the ID
361:21 - and bar is also using the foo ID its
361:25 - name is bar and its age is 30. all right
361:28 - now we want to go ahead and create a set
361:31 - of Foo and bar so let's say we have
361:34 - people
361:35 - and we say it is a set of person and it
361:38 - is equal to Foo mbar now we should get
361:40 - an error ideally from Swift telling us
361:43 - that these objects are not hashable you
361:46 - can see it says it does not conform to
361:48 - protocol hashable all right so how do we
361:50 - do that how do we ensure that they
361:53 - conform to hashable so let's go ahead
361:55 - and say that they conform to Hash Rule
361:57 - and everything will just go fine nothing
361:59 - will happen in here you won't get any
362:01 - errors okay and if you go in here and
362:04 - say people that count
362:06 - let's go in here okay you will see
362:08 - unfortunately it is still two so what
362:11 - happening here we said that well we are
362:14 - making this person hashable and it
362:16 - should ideally not be placed twice in
362:18 - this set because uh it is pretty much
362:21 - the same but if you look I mean same
362:24 - data but what happens in here is two
362:26 - things when you when you create a
362:28 - structure and you just say it is
362:30 - hashable without having any custom logic
362:32 - in it meaning that you didn't actually
362:35 - tell Swift how to calculate the
362:37 - uniqueness of this object what Swift
362:39 - does is that it looks at all the
362:41 - properties of that object and says okay
362:44 - are all these properties unique
362:46 - themselves like are they hashable and if
362:49 - you look at uuid is indeed hashable if
362:52 - you look at string it is hashable
362:56 - uh let's see extension
362:59 - string hashable
363:01 - somewhere it should have been made
363:03 - hashable I'm not sure if it is exactly
363:05 - there we go extension string hashable
363:07 - and also if you look at the code for INT
363:09 - it should also be extension and
363:13 - hashable there we go so since all these
363:16 - three are hashable then Swift says okay
363:18 - I'm gonna calculate the hash value
363:19 - myself then it says okay you created a
363:22 - person it has the ID let's just say it's
363:24 - hash value is one let's say then it says
363:28 - oh the name is Foo the hash value is for
363:30 - instance 10. I'm just making this up
363:32 - okay and the hash value for this guy
363:34 - let's say is 20. all right then it comes
363:37 - to bar and says oh it has the same ID as
363:39 - the other ones which is has a hash value
363:41 - of one but it's its name is bar so its
363:45 - hash value is let's just say 30. and the
363:48 - age is also 30 with a hash value of 40
363:51 - for instance okay so it says okay then
363:54 - you put both of these inside a set and
363:57 - I'm gonna calculate these hashes 20 plus
363:59 - 10 plus one for instance okay this is
364:01 - not how hashes are actually calculated
364:03 - but we're just going to plus them
364:04 - together so 20 10 and 1 are going to be
364:07 - 31 and then we have 40 30 and one which
364:09 - is going to be 70 a month so at 31 and
364:12 - 71 are not the same meaning that they're
364:15 - basically not the same object and should
364:17 - both be placed inside the sets Okay so
364:20 - that's how hashing basically Works
364:22 - within Swift okay
364:23 - but what we may want to do is to tell
364:26 - Swift that hey we actually don't want
364:29 - people with the same ID to be recognized
364:33 - as different people so what we want to
364:36 - tell Swift is that if two people have
364:38 - the same ID then they're essentially the
364:40 - same person okay and in order to give
364:43 - Swift more information about how it
364:45 - should do our hashing we should go ahead
364:48 - and basically implement the hash
364:51 - functionality somehow ourselves or at
364:53 - least inject our own logic within it so
364:56 - let's create a person two object in here
364:59 - so a person to structure so now that
365:01 - we've seen that example let's say a
365:03 - struct person two okay and we're gonna
365:06 - grab let's actually grab this struct
365:09 - from here but instead we're just going
365:10 - to call it person two
365:12 - so person two in here and we said that
365:14 - it is hashable now if you make an object
365:16 - hashable you also have the ability to
365:19 - override a function in here and not
365:21 - really override but also Implement
365:23 - actually a function called hash into all
365:25 - right and this function comes in here
365:28 - because we have we've conformed to the
365:30 - hashable protocol all right then in here
365:33 - what you can do is to say hasher and
365:36 - then you combine you call the combine
365:38 - function on it and then you basically
365:41 - hash the fields that you want to be
365:43 - taken into account while Swift does its
365:45 - hashing so what this really did in here
365:48 - is that it jumped over hashing name and
365:51 - age and instead only hashed ID within
365:54 - the hashing mechanism of Swift all right
365:56 - so now that you've done that you also
365:59 - need to tell Swift whether two objects
366:01 - are Equitable because you've just
366:03 - implemented your own hashing
366:05 - functionality
366:06 - and when you say something is hashable
366:08 - by default it's also Equitable and what
366:11 - happens in here is that right now you
366:13 - set that take ID only into hashing
366:16 - mechanism but in terms of equation
366:19 - because hashing is also doing equality
366:22 - Swift if you don't intervene Swift goes
366:25 - and it says okay the hash values are the
366:27 - same but these two objects are not
366:29 - really equal because by default Swift is
366:30 - going to also equate all three
366:32 - properties so in here what we're going
366:35 - to do is to say static func equality so
366:37 - we're going to overwrite equality as
366:39 - well on the left hand side we say self
366:41 - and the right hand side itself then we
366:43 - say Boolean and we say as long as the
366:46 - left hand side's ID is equal to the
366:50 - right hand size ID then these two
366:52 - objects are equal so not only have we
366:54 - changed the way a hashing works but we
366:57 - also need to change the way equality
366:59 - Works otherwise they won't really
367:01 - come to an agreement with each other
367:03 - okay
367:05 - now that we have that let's go ahead and
367:07 - create a baz ID in here and we say it's
367:10 - a uuid all right
367:12 - and then we say we create a baz person
367:14 - in here which is person two remember
367:16 - create an object of type person two not
367:18 - person then we say baz ID its name is
367:21 - bass and then we say it has or he has
367:25 - the age of 20 or she has the age of 20.
367:27 - then we create a Cox value in here and
367:31 - we say q u x and we say person two and
367:34 - then we say baz ID and the name is Cox
367:38 - and the age is 30. all right so you can
367:41 - see now the ID is the same but all the
367:44 - other values are different however the
367:46 - way we've done our hashing and equality
367:48 - is that we only take into account the ID
367:49 - so even if their names are different but
367:52 - they're using the same ID then we
367:53 - consider them to be the same person and
367:55 - that's why you can go in here it's say
367:57 - if that's equal to Cox they are equal so
368:01 - this basically is invoking our equality
368:04 - and you can see it comes in here okay
368:06 - but that's not the point that's not what
368:08 - we're trying to do in here we actually
368:10 - want to add them to a set so let's say
368:11 - let lets people people to and we create
368:16 - a set of bars and Cox in here and if you
368:19 - look at the values inside people too it
368:21 - should just be one value
368:23 - people too that count all right simply
368:25 - because our hashing intervene in here
368:28 - and both these objects were considered
368:31 - to be the same object all right and if
368:34 - you take the first item out of this you
368:36 - can get a person person two and then you
368:38 - can say the first objects uh name give
368:41 - us the name all right and you can see it
368:43 - is pass all right so a Cox was not
368:46 - inserted into our set simply because baz
368:49 - was already there and Cox was considered
368:51 - to be the same object therefore it was
368:53 - not inserted into the set all right so
368:57 - that's how you can go ahead and
368:58 - Implement your own hashing value or hash
369:03 - value and equality all right that's
369:06 - enough about sets let's talk now about
369:08 - dictionaries now dictionaries they're
369:10 - also called Json objects and many other
369:12 - programming languages like like as such
369:14 - as um not really Json objects yeah well
369:17 - kind of Json objects yeah there there
369:19 - are keys and values basically okay and
369:20 - you define them using a square bracket
369:23 - in
369:24 - um in Swift so you say user info and you
369:27 - can create your dictionary and then you
369:29 - say keys are in this case string for
369:31 - instance with a column and you separate
369:33 - the keys from the values using a column
369:35 - and you can say the key is name the
369:37 - value is Foo this key is H and oops if
369:42 - we can spell H and its value is 20 then
369:45 - you can say I have an address field in
369:48 - here whose value is indeed another
369:49 - dictionary and you can say the address
369:52 - has a line one and it is address line
369:55 - one then we have a postcode for instance
369:58 - it's key as postcode and its value is
370:00 - one two three four five let's say all
370:03 - right and this is completely valid a
370:05 - swift object if I haven't messed
370:07 - anything up let's see Foo age address
370:09 - all right and we also have to tell Swift
370:11 - that you can see it is a heterogeneous
370:14 - values because some values are strings
370:16 - and some values are integers then we
370:18 - have to tell if there is a dictionary
370:20 - with keys equal to string and values of
370:23 - any type all right without that it won't
370:25 - work
370:26 - however if you didn't have this age in
370:28 - here and we didn't have this address in
370:30 - here we could have just gone away by
370:33 - defining our dictionary like this as
370:35 - Swift would have understood the data
370:36 - type to be of key strings and values of
370:39 - strings as well but since we have keys
370:41 - of string and value of integer and a key
370:43 - of string and a value of a dictionary
370:45 - then we have to tell Swift that the keys
370:47 - are string and values could be anything
370:49 - basically now you can grab values out of
370:52 - your dictionaries using type using
370:54 - subscripting so you say user info grab
370:57 - the name and you can see it will give
370:59 - you the value of Foo in here you can say
371:02 - give me the age user info give me the H
371:04 - so you're basically giving it the keys
371:07 - and you're extracting the values for
371:09 - those keys now you can say user info and
371:12 - then give me the address let's go in
371:15 - here address
371:16 - at rest all right and since this is an
371:20 - address dictionary coming back from here
371:21 - you may be hoping that okay since this
371:23 - is an entire dictionary maybe I can type
371:26 - a key in here as well and get the
371:28 - postcode all right and if you do this
371:29 - then you get an error because you've
371:32 - told Swift that the values that come out
371:34 - of this uh dictionary are of type any
371:37 - meaning that Swift Just believes that
371:39 - this is any and now you're trying to
371:41 - tell Swift that this is not any and it's
371:43 - in fact a dictionary and it should go
371:45 - into that dictionary and x and extract a
371:48 - value with a specific key and Swift Just
371:49 - rejects that okay there's a dangerous
371:52 - way of doing that forcing Swift to
371:54 - believe that this in itself is a
371:56 - dictionary and that is using the as
371:59 - syntax but please don't ever do this in
372:02 - production applications and there there
372:05 - are better ways of doing this so I just
372:07 - want to show you how it works you can
372:09 - say get the address
372:11 - and force cast it to a dictionary of
372:15 - type string and string you can see it
372:17 - because this has keys of string and
372:20 - values of type string as well okay
372:23 - so after doing that uh then you can go
372:26 - ahead and say give me the postcode on it
372:29 - all right and this should this should
372:30 - work but in production applications
372:33 - really is not a good idea to do this so
372:35 - let's see what happened actually found
372:37 - nil one on wrapping optional value and I
372:39 - think it's because I I misspelled
372:42 - address basically
372:43 - so it works but you should never do this
372:45 - because this will crash your application
372:47 - should this key Either not exist or that
372:50 - its value shouldn't be of type string or
372:52 - string your application will crash so
372:54 - please don't do this I'm just showing
372:57 - you so that you know this syntax also
372:59 - exists okay if you want to extract the
373:01 - keys and values out of a dictionary you
373:04 - can say user info dot keys and also you
373:06 - can say userinfo.values and this will
373:09 - give these this will give you the keys
373:11 - only you can see in here let's go in
373:14 - here the keys are age address name and
373:17 - the values are 20. let's go here 20. Foo
373:22 - uh which is let's see where it is
373:26 - it is 20.
373:28 - Foo and then this dictionary so you grab
373:31 - basically only the keys or only the
373:34 - values out of your dictionary using that
373:36 - syntax however it is more common that
373:39 - instead of just saying keys and values
373:41 - you want to enumerate over the keys and
373:44 - values and their Associated values you
373:46 - can because you can see in here we're
373:47 - only saying keys and only values but
373:49 - what if you want to grab every key and
373:51 - its Associated value the Syntax for it
373:53 - is for key and value
373:55 - in user info then you can print them out
373:58 - key and value like this okay let's see
374:02 - if the playground can help us extract
374:04 - these values so and the key says name
374:07 - value history you can see age address
374:09 - and name are the keys and the values we
374:12 - can also perhaps get their history let's
374:14 - see value
374:16 - it's oh the playground isn't so smart in
374:20 - being able to print the value so
374:22 - let's instead print the values and see
374:25 - if we can get them in the console
374:27 - uh like this so here are the values
374:30 - basically okay and you can also print
374:32 - the keys as well so let's say we print
374:33 - the keys and we print the value so uh
374:37 - the key of address has this value the
374:40 - key of name has this full value and the
374:42 - key of H has the value of 20. all right
374:45 - so we can do that as well let's just
374:47 - revert them back to how they work okay
374:48 - now you can also have a where clause in
374:52 - your enumeration over keys and values so
374:54 - let's say four key and value in user
374:59 - info where the value is an integer okay
375:03 - and then you can say key and value
375:06 - so you see the only value that was an
375:09 - integer had the key of H and it the
375:13 - value was of course the value of 20. all
375:15 - right now you can also have
375:18 - multiple word Clauses so you're not
375:21 - limited to only one where Clause so you
375:23 - can say four key and value and use for
375:26 - info were
375:27 - the value is an INT and a key that
375:33 - counts so the key is a string and we're
375:35 - saying it should contain only two uh
375:37 - more than two characters then we say
375:40 - give us the key and the value all right
375:42 - so the count is pretty much the length
375:44 - of the of the key
375:46 - and then you can see that we got the
375:49 - same result because age is three letters
375:52 - long and are conditions that it should
375:54 - be more than two but if in here we said
375:56 - more than three then this will never be
375:58 - cost so we won't get any results in here
376:00 - okay so I think that's actually quite
376:03 - enough right now about collections we
376:05 - talked about arrays we talked about sets
376:07 - and we talked about also dictionaries
376:09 - and some new formats and pattern
376:12 - matchings that you can do with these
376:13 - collections they're very very useful and
376:16 - I think you need to really get and get
376:19 - quite handy with these objects
376:21 - yourselves and in order to get a good
376:23 - grasp of how they work I can just sit
376:25 - here and explain these for ages but
376:28 - without practice and probably it will
376:30 - never really click so my advice is to go
376:33 - ahead and create some sets arrays and
376:34 - dictionaries yourselves to get a good
376:36 - grasp of how they work
376:38 - now that we talked about collections it
376:40 - is good time that we start talking about
376:43 - equality and hashing as well I mean we
376:46 - did touch upon this topic a little bit
376:48 - right now but we haven't fully covered
376:50 - them equality and hashing they're like
376:53 - their own whole world of understanding
376:55 - how they truly work and basically
376:58 - understanding them is the key to
377:00 - understanding how sets for instance work
377:02 - and how equation generally in Swift
377:06 - works and so I think it's very important
377:08 - that we dedicate it's
377:10 - um a whole section just to equality and
377:13 - hashing so and that's what we're gonna
377:15 - do right now so I'll see you there let's
377:18 - then go ahead and create a separate
377:20 - playground for this so we say
377:22 - um blank and foreground sorry playground
377:26 - and we say equality
377:29 - and hashing like this and ensure that
377:32 - you're creating it in The Roots folder
377:34 - like this and then we just say create
377:37 - and we import Foundation
377:40 - and we can get rid of the Explorer to
377:43 - the left hand side now equality in Swift
377:46 - is provided using a protocol called
377:49 - e-codable any object that conforms to
377:52 - the equilible protocol has to have a
377:55 - function a static function and which is
377:59 - an equality function like this is pretty
378:01 - much an operator and this function has
378:04 - to have two arguments one at left hand
378:06 - side and right hand side both of the
378:08 - same exact type as the current
378:10 - structural class implementing it
378:13 - now if you go ahead and create a person
378:15 - structure in here and say that this
378:18 - person is conforming to the equatable
378:22 - protocol and you say let's ID is a
378:24 - string and then you say let's name is a
378:26 - string
378:27 - then we create two instances of this we
378:29 - say let's Foo one is a person with the
378:32 - ID of one all right and then we say name
378:35 - here is Foo then we create food too
378:39 - right here and we say the name is
378:42 - actually bar then if you say if Fu one
378:46 - Foo one is equal to Food 2 then we say
378:49 - they are equal with an exclamation mark
378:51 - in here because they shouldn't be they
378:53 - are not equal otherwise okay so what
378:56 - happens in here is that by ensuring that
378:58 - this person is Equitable all right let's
379:02 - also make sure that this is running
379:03 - automatically by conforming the struct a
379:07 - person to Equitable as Swift goes in
379:09 - through all the properties of the
379:11 - structure and ensures that they are
379:13 - indeed themselves Equitable string by
379:15 - default conforms to the Equitable
379:17 - protocol and so does this one so then
379:19 - Swift says okay then I understand that
379:22 - it should be Equitable however if you go
379:23 - in here and say a struck dog and don't
379:26 - make it Equitable and in hear you say
379:28 - this person should also have a dog all
379:30 - of a sudden Swift will throw an error in
379:31 - here saying that oh I can't give you
379:33 - equal Equitable by default because dog
379:36 - which is one of the properties of this
379:38 - person's structure does not conform to
379:40 - Equitable if you want to get rid of this
379:42 - just ensure that this dog is also
379:44 - Equitable which then gets rid of the
379:47 - problem in here but the only problem we
379:48 - have in here that is that we need to
379:50 - pass a dog instance in here but we're
379:52 - gonna remove all this dog reference in
379:54 - here just wanted to show you how default
379:57 - implementation of Equitable basically
379:58 - works it looks at all the properties and
380:00 - then make sure that they're Equitable
380:01 - and then goes through all of them one by
380:03 - one compares the properties between
380:05 - these two objects that we're comparing
380:07 - okay
380:08 - now you can also override equality and
380:12 - uh you can basically say let's say that
380:14 - you in your person uh structure you want
380:17 - to say any two persons that have the
380:19 - same identifier should be considered
380:21 - equal so then you can say extension
380:24 - person
380:25 - and you can see at the moment these two
380:27 - objects right now before our extension
380:30 - they're marked as not equal all right
380:32 - simply because their names are not equal
380:34 - but if you go to extension person and
380:36 - then Define the static function equal
380:38 - equal like this and you say left hand
380:40 - side itself
380:42 - like this and right hand side itself as
380:44 - well and this function should return a
380:46 - Boolean indicating whether the two
380:47 - objects are equal or not then we say if
380:49 - the left hand side's ID is equal to
380:51 - right hand size ID then these two should
380:52 - be considered equal now all of a sudden
380:54 - you see that this will be flipped to
380:56 - they are equal
380:58 - previously before this extension this
381:00 - branch of code was being executed
381:02 - because by default there were not equal
381:04 - since they had different names however
381:06 - with our extension in place since we're
381:08 - only comparing the IDS then they're
381:10 - marked as equal so if you comment your
381:12 - code out you can see all of a sudden
381:13 - that this Branch will stop being
381:14 - executed and instead this Branch will
381:17 - get executed all right
381:19 - so that's how you can create your own
381:21 - equality on custom objects so we can
381:24 - comment this guy out
381:25 - apart from structures you can also
381:27 - Implement custom equality on
381:29 - enumerations let's say that we have an
381:31 - enum in here we call animal type and we
381:34 - have a case where a dog and we ask for
381:37 - the breed and also we have a cat and we
381:41 - ask for the breed okay now let's say
381:44 - that you want to compare these
381:46 - um to with each other if you go ahead
381:48 - and say let's dog and say is an animal
381:51 - with a type of dog with its breed is a
381:54 - labradoodle and then you say let's
381:56 - whiskers is an animal
382:00 - type another dog basically exactly of
382:03 - the same type then if you go ahead and
382:06 - say if dog equal to whiskers let's just
382:08 - change this to maybe dog two
382:11 - dog one and Dot two and then we say if
382:13 - dog one equal to dog two like this you
382:18 - can see that you get an air from Swift
382:19 - because by default animal type is not
382:21 - Equitable you can go ahead in here and
382:23 - say okay well I'll make it Equitable
382:25 - does this work you'll be surprised to
382:27 - see that actually my default what Swift
382:29 - does is it looks at these values and
382:32 - says let me let's put some values in
382:34 - here and say they are equal
382:36 - like this otherwise we say else they are
382:41 - not equal all right so since dogmon and
382:44 - dog 2 we actually are giving them the
382:46 - same values in here then suit by default
382:48 - says oh they're equal but if you change
382:50 - the value inside this breed for instance
382:52 - then Swift says they're not equal so
382:54 - Swift does the same thing that it does
382:56 - with structures as it does with enums it
382:58 - goes through all the properties of those
383:00 - enum cases and then make sure that
383:02 - they're Equitable if they are it will
383:05 - just call the equation function on those
383:07 - parameters as well and Compares them
383:09 - with each other if all those they're
383:10 - equal to each other and the case is
383:12 - equal to the other case as well then the
383:15 - enum cases are marked as equal however
383:18 - you can go ahead and change this
383:21 - implementation so you can say extension
383:24 - extension animal type and let's just
383:26 - remove the Equitable from here and we
383:28 - say animal type becomes Equitable in
383:30 - this extension all right
383:32 - and then we go ahead and Implement a an
383:35 - extension and sorry the static Funk left
383:37 - hand side itself and right hand side
383:39 - itself as well and then in here we say
383:41 - bull all right so now what we want to do
383:44 - in here is to compare the breeds with
383:46 - each other so we say we switch the left
383:49 - hand side and the right hand side then
383:51 - we say in case and we have a dog with
383:54 - the left hand side breed and another dog
383:57 - with their right hand side breed
383:59 - then they're considered equal as long as
384:02 - the left hand side breed is equal to
384:04 - right hand side breed we do the same
384:06 - thing for cats so we say if we get a cat
384:08 - in here and a cat in here then they're
384:11 - equal to each other as long as their
384:13 - breeds are equal and since this pattern
384:15 - matching is the exact same thing between
384:17 - dog and cat you can see they're getting
384:19 - left hand side breed right hand side
384:20 - Bree and the same thing in here you can
384:22 - remove this coating here and just put a
384:24 - comma and remove this case as well all
384:26 - right so they're basically doing the
384:28 - same thing
384:29 - and then you can go ahead and say
384:30 - anything else they're considered not
384:33 - equal to each other okay so as long as
384:36 - it's a dog and a dog and their breeds
384:38 - are the same then it's considered to be
384:39 - the same and if it's a cat and a cat
384:42 - then they're considered to be the same
384:43 - as well
384:45 - so let's see what we got and we got this
384:48 - oh we have to return this of course we
384:50 - can't just write that statement in the
384:52 - playground good then we can go ahead and
384:56 - um basically we've now created an animal
384:58 - type let's go ahead and create an animal
385:00 - now so we say it's struct
385:02 - and we say animal animal in here animal
385:06 - and we said let's name is a strain
385:09 - and then we say let's type is an animal
385:12 - type okay and since both string and
385:14 - animal type by this point are Equitable
385:16 - you can make this animal also conform to
385:19 - Equitable all right however what we want
385:22 - to do is to say okay the animal equality
385:25 - has to only look at the animal type we
385:27 - don't want it to look at the animal name
385:29 - that is the default behavior that Swift
385:31 - looks at all the properties but in this
385:33 - case we just want to look at the animal
385:34 - type all right so let's say that then we
385:37 - override the static oops static Funk
385:40 - equal equal and we say left hand side
385:42 - itself and right hand side itself as
385:44 - well and we return a Boolean okay and we
385:46 - only look at the types so we say left
385:48 - hand side type should be equal to right
385:50 - hand side type otherwise they're not
385:52 - equal okay
385:54 - then we can go ahead and say let cat one
385:56 - is an animal and its name is whiskers
385:59 - like this all right and it's animal type
386:03 - is actually a cat then we say it is a
386:05 - cat of type Street gap of the breed
386:09 - Street cow okay let's put that in here
386:12 - and this is also a shorthand of writing
386:15 - um the animal types instead of saying
386:17 - animal type in here you can just say dot
386:19 - cat so instead of doing this you can
386:22 - just do the shorthand and so it will
386:23 - understand the code anyways let's copy
386:25 - this code and then we say cats number
386:27 - two and its name is whoosh okay just
386:30 - like that and it's also a straight cap
386:33 - so looking at our equality functionality
386:36 - in here we only look at Types on animal
386:39 - in order to to determine if they're
386:41 - equal to each other or not so then we
386:43 - should be able to go and say if cat1 is
386:46 - equal to cat2 they are equal because of
386:51 - their breed actually type because of
386:53 - their type
386:55 - else and they are not equal all right
386:58 - and you can see that this branch of the
387:00 - code is being executed simply because
387:01 - our equality custom equality on animal
387:03 - only compares the animal types and since
387:06 - they have the exact same type of cat and
387:09 - Street cat then our code works and you
387:12 - you can actually go and remove this
387:14 - implementation on animal type because
387:16 - this pretty much is the same thing that
387:18 - Swift provides Equitable and you can see
387:21 - the code will be executed just like
387:22 - before so no difference really so it's
387:25 - up to you if you want to do custom
387:26 - implementation of Equitable or you want
387:29 - to let Swift deduce this on its own if
387:32 - Swift can already deduce this on its own
387:34 - which it can you shouldn't really go and
387:36 - write an exact same implementation so
387:38 - this this is pretty much just redundant
387:40 - but if your custom implementation of
387:42 - Equitable adds some functionality to how
387:45 - swift does it by default then please go
387:47 - ahead and add your own Equitable to your
387:49 - custom types okay so we can now we've
387:53 - had a look at Equitable let's look add a
387:55 - hashable and we've already talked about
387:57 - this a little bit before but let's just
387:59 - talk a little bit more in details about
388:01 - it just like Equitable hashable also
388:03 - looks at all properties of a struct or a
388:05 - class to make that start or class
388:07 - hashable so if you say struct house and
388:09 - we make it hashable then we say let's
388:12 - number is int and we say let number of
388:16 - bedrooms
388:17 - is an INT then we say let house one is
388:21 - house with the number of one two three
388:24 - and number of bedrooms is let's say two
388:26 - all right and then we say house one and
388:29 - you can see now you have a property in
388:31 - here called hash value and that is
388:33 - coming from the hashable protocol in
388:35 - here
388:35 - then we go ahead and create another
388:37 - house we call it house number two in
388:40 - here okay house two and its number is
388:43 - one two three but it's number of
388:45 - bedrooms is three and then we print out
388:47 - its hash value in here as well now you
388:49 - can see these hash values are different
388:51 - simply means that they basically if you
388:54 - create a set with house one and house
388:55 - two they can occupy their own space and
388:58 - not overwrite each other however if you
389:00 - go in here and say number of bedroom and
389:02 - bedrooms is two then you should ideally
389:04 - in here see the exact same hash value
389:06 - meaning that you cannot put both houses
389:09 - inside the same set and expect them both
389:12 - to basically appear in the set one is
389:14 - going to overwrite the other one okay so
389:16 - if we go ahead and create a setting here
389:18 - we say let houses is a set of house one
389:22 - and house two and please note that I
389:24 - changed this back so it's now number of
389:25 - bedrooms two and this one is three then
389:27 - if we say houses dot count then you can
389:30 - see we get two in here because none is
389:32 - overwriting the other one
389:34 - let's see if the playground is going to
389:37 - be able to update soon hopefully
389:39 - even if it doesn't show the count we can
389:41 - still see in here that we have one house
389:43 - in here and another one here and now the
389:44 - count is also being displayed right
389:46 - there okay really good you can overwrite
389:49 - the uh how hashing of course Works we've
389:52 - already had a look at this and when we
389:54 - talk about collections but let's have a
389:56 - look at another example so we say a
389:58 - struct numbered house okay and we say it
390:01 - is hashable
390:02 - like this and we say let's number is int
390:06 - and then we say let's number of
390:08 - uh bedrooms is an end and this is pretty
390:11 - much the copy of the house structure but
390:14 - we had to give it another name and
390:16 - because you can't have two structures
390:18 - with the same name in the same code
390:19 - scope in Swift okay then in here we're
390:22 - going to go and overwrite this a hashing
390:25 - mechanism so we say hash into and we say
390:27 - we only want to combine the number into
390:30 - the hasher so we say combine the number
390:32 - and this simply means that as long as
390:34 - two houses have the same number then
390:36 - they're at the same house pretty much
390:38 - when it comes to their hash values okay
390:41 - however this doesn't mean that they're
390:43 - equal you have to override equality as
390:46 - well so say static Funk equal and we say
390:48 - on the left hand side we get self and
390:50 - the right hand side we get cell self as
390:52 - well
390:53 - then we say this returns a Boolean and
390:55 - then we say as long as the numbers so we
390:57 - say left hand side number is should be
391:00 - equal to right hand sign number and then
391:02 - both houses are considered to be equal
391:04 - to each other in that case Okay so let's
391:06 - create let house three and please make
391:09 - sure you create a numbered housing here
391:11 - not a house it's house number we say one
391:13 - two three and number of bedrooms is two
391:16 - okay so as a house number one two three
391:18 - then we create another house we call it
391:21 - house four in here okay like that
391:24 - and then we say it is a numbered house
391:26 - and the exact same number as this house
391:28 - however it has three bedrooms okay then
391:31 - we create a set of these we say houses
391:33 - at three and four it is a set of house
391:37 - three and house four and then if you
391:40 - look at houses three and four count you
391:42 - can see there's only one object inside
391:44 - this set simply because house three and
391:47 - four they can only consume the same
391:49 - space in our sets and simply because
391:51 - their hash value is the same you can see
391:54 - in here and let's see if playground is
391:57 - going to be able to update our codes
391:58 - hopefully soon if I close this one maybe
392:01 - it's just gone crazy a little bit
392:03 - let's say automatically run
392:06 - hopefully it can run the code so you can
392:08 - see there's only one value in here and
392:10 - if you say houses three and four get the
392:12 - first item then it gives us a numbered
392:15 - house and then we can say get its house
392:17 - number bedrooms and it says the number
392:20 - of bedrooms is two and the reason behind
392:22 - this is that house Ford could not be
392:25 - placed in the set simply because there
392:27 - was a house already in the set with the
392:30 - same hash value and you can also look at
392:32 - the house at three hash value and house
392:35 - for hash values and they should pretty
392:38 - much be the same simply because the
392:40 - hashing algorithm is only taking the
392:42 - house number into account so you can say
392:44 - house three
392:45 - house three number dot hash value and it
392:49 - should pretty much be unique
392:51 - as well and you can see they're exactly
392:53 - the same thing okay and house for that
392:56 - number hash value there the same as the
392:59 - entire hash value of the house okay
393:02 - another example now EMS are by default
393:06 - hashable even without raw values so I'll
393:09 - show you in here we say enum car part
393:12 - car parts like this and we say case a
393:15 - roof uh case tire and case trunk
393:19 - then in here we say let's unique Parts
393:23 - is a set of car parts okay
393:26 - and it's equal to a set that contains a
393:30 - roof
393:31 - it contains Tire
393:34 - it contains another roof and then a
393:36 - trunk so since this is a set of car
393:39 - parts and it doesn't have any raw values
393:42 - like we're not doing it like this
393:45 - so they don't have raw values if you in
393:47 - here say unique part oh actually we can
393:49 - see the value already here you can see
393:50 - it only contains trunk roof and tire so
393:53 - it doesn't contain two roofs that's what
393:55 - I'm trying to get to so if you create a
393:58 - simple enum in Swift without any raw
394:00 - values or any Associated values it's by
394:02 - default hashable and Equitable all right
394:05 - that is the whole point now if you have
394:09 - an enum with
394:11 - um with Associated values then you can
394:14 - basically go ahead and change the
394:16 - hashing mechanism yourself so let's say
394:18 - that we have an enum in here we call it
394:21 - house type and it has a big house and we
394:25 - say its Associated value is a numbered
394:27 - house and we say case small house it is
394:30 - a numbered house
394:32 - like this and then you can go ahead in
394:34 - here and say this is hashable all right
394:36 - so as you do that Swift looks at the
394:39 - properties that are inside this enum and
394:40 - it understands that oh this big house is
394:44 - of course hashable because it's an inum
394:46 - case however it has an Associated value
394:48 - then it looks at the associated value
394:49 - and says is this value hashable then it
394:52 - goes to numbered house and it says yep
394:54 - it is hashable then it implements
394:56 - hashable by default for you on this
394:58 - house type okay so then you can go ahead
395:02 - and basically add these into some sort
395:07 - of a set so let's go ahead and we say we
395:10 - create two big houses we say big house
395:12 - number one is a house type
395:15 - big house like this and it has a
395:19 - numbered house inside it like this all
395:22 - right and this number it has has a few
395:25 - properties it has a number and we say
395:27 - number one and it is number of bedrooms
395:29 - is one as well so we have a big house
395:31 - and that's number one in that street for
395:34 - instance and it has one bedroom for some
395:36 - reason a big house with one bedroom only
395:38 - then we say a big house number two in
395:41 - here okay let's get rid of this Bottom
395:43 - bar then we say it is also a big house
395:46 - at number one and total number of
395:48 - bedrooms is one on that one as well then
395:51 - we create a small house so we say small
395:53 - house one and like this small house one
395:56 - it is a small house house and we say it
396:00 - is at number one as well and it's number
396:03 - of bedrooms is one all right so now we
396:06 - have three houses with the same number
396:09 - and two of them are actually the same
396:11 - house type as well so what's going to
396:13 - happen if we go and put these inside a
396:15 - set so we say all houses is a set of
396:18 - house type
396:19 - and is equal to a set with a big house
396:24 - big house one big house two and small
396:27 - house one all right
396:29 - so if you say all houses the count in
396:31 - here then let's see if the playground
396:34 - can resolve this you can see there's
396:35 - only two objects in here the reason is
396:38 - that big house one and Big House 2 are
396:40 - considered to have the same hash value
396:42 - simply because that their numbered
396:45 - houses have the same hash value and
396:47 - their cases have the same hash value
396:49 - however small house one is of type small
396:52 - house not big house though it's numbered
396:54 - house has the same hash value as the
396:56 - other numbered houses however the enum
396:58 - case itself also has a hash hash value
397:00 - therefore in here you can see if I say
397:03 - all houses first and all houses actually
397:06 - let's see if you can get the values
397:07 - inside the sets like this you can see we
397:10 - have a let's see oh you can see the
397:14 - first one is a big house at number one
397:16 - and if we say all houses last uh let's
397:20 - see if you can get the first does it
397:23 - have a last item no it doesn't we can
397:26 - get the first unfortunately and let's
397:28 - just say four value in all houses and
397:31 - then we type the value out in here let's
397:33 - maybe even print the value like this
397:37 - so you will see then the first elements
397:39 - inside all houses is a numbered house is
397:43 - a small house with that numbered house
397:45 - and the second one is a big house
397:47 - meaning that the two big houses couldn't
397:49 - actually occupy two separate spaces in
397:51 - the set simply because their hash values
397:54 - are the same okay so I think that's
397:58 - actually enough right now about equality
398:01 - and hashing we've talked quite a lot
398:03 - about them right now and I think you get
398:05 - basically the idea so there's two
398:07 - different things you have to implement
398:08 - or think about when it comes to equality
398:10 - hashing one is the hash of value which
398:12 - determines whether two objects should
398:14 - consume the same space inside a set but
398:16 - also you have to implement equality
398:18 - which determines whether two objects are
398:20 - actually equal to each other okay and
398:23 - also you may sometimes just need objects
398:25 - to be Equitable not hashable in in which
398:28 - case you can just implement it Equitable
398:30 - protocol or conform to the Equitable
398:32 - protocol as long as all the properties
398:34 - inside your structural class are
398:36 - equatable then you don't have to
398:37 - implement a custom equality static
398:39 - function however you can always go ahead
398:41 - and change the default implementation of
398:43 - both hashable and Equitable as well all
398:46 - right now we're done with equality and
398:48 - hashing so let's start talking about
398:50 - custom operators I'm going to close this
398:53 - playground in here so let's create a new
398:55 - one a blank playground
398:58 - like this and then we call this one
399:01 - custom operators all right and we create
399:04 - the playground
399:05 - then we say import Foundation like that
399:08 - and then we can get rid of the Explorer
399:10 - to the left hand side
399:12 - like this and we can run our playground
399:15 - automatically now we've talked about
399:18 - operators to this point uh quite a bit
399:21 - actually but we haven't talked about
399:22 - creating so many custom operators and
399:24 - that's what we're going to do in this
399:26 - section of the code so let's say that
399:29 - you have a first name and which is a
399:31 - string optional string and you say it is
399:33 - actually equal to Foo though it is set
399:36 - as being the optional string and then
399:39 - you create a last name in here and then
399:41 - you say bar now if you want to get the
399:43 - full name and you say it should be equal
399:46 - to first name plus last name you'll see
399:48 - that you get an error from Swift saying
399:49 - that this operator it is not defined
399:52 - between you can see there is no operator
399:54 - that exists that matches this particular
399:56 - signature left hand side optional string
399:58 - and right hand slide optional string if
400:01 - these were not optional strings then you
400:03 - would have this operator you can see
400:04 - that the error goes away let's see if we
400:06 - can get the definition actually for this
400:08 - one A Plus operator I don't think we can
400:11 - unfortunately let's see a static Funk
400:15 - Plus
400:16 - here we go there is that function
400:18 - signature all right however the Swift
400:21 - Foundation framework hasn't defined the
400:24 - same operator for optional strings so we
400:26 - can actually go ahead and do that
400:28 - ourselves so let's say we have a funk
400:31 - plus and its left hand side is an
400:34 - optional string and its right hand side
400:36 - is an optional string as well and it
400:38 - returns an optional string okay then we
400:40 - go inside the function implementation
400:42 - and we switch the left hand side and the
400:44 - right hand side if they are both none
400:48 - meaning that they're both null then we
400:50 - return nil or actually not null but nil
400:53 - Swift is one language that is chosen to
400:55 - use nil instead of null then we say okay
400:57 - if then we get the left hand side so if
401:01 - we say case let we have some value on
401:05 - the left hand side
401:06 - but no values to the right hand side
401:08 - then we return the value to the left
401:10 - hand side so if you only have the first
401:12 - name but not the last name then we
401:14 - return the first name as the full name
401:16 - we do the opposite of this for last name
401:18 - as well so if the first name is is nil
401:21 - but the right hand side has the value
401:23 - meaning that there is a is a family name
401:25 - then we say return that value all right
401:29 - and we can join these two together like
401:32 - this
401:34 - because they have the same pattern okay
401:36 - and then we say if both of them have a
401:40 - value so we say sum left hand side and
401:44 - some if I can spell some right hand side
401:47 - then we say return the left hand side
401:50 - plus the right hand side okay as soon as
401:52 - you're done writing this function you
401:54 - can see all of a sudden the errors go
401:56 - away and all of a sudden full name is
401:58 - indeed equal to Foo bar all right so
402:02 - um we can also add a space in here
402:04 - perhaps or add a space before bar so it
402:06 - becomes Foo plus bar right here okay
402:10 - so that's how you can create a simple
402:11 - custom operator in Swift okay and I
402:15 - think we've actually looked at something
402:16 - similar to this before maybe even
402:18 - something more complicated all right now
402:21 - we haven't yet created our own unary
402:23 - prefix operator this one was a binary in
402:26 - fix operator because it works with two
402:29 - or binary and things two things
402:32 - therefore binary so this is a binary in
402:34 - fix it is binary because it works with
402:36 - two operators and sorry with two
402:38 - parameters and it's an infix operator
402:40 - because it says in between two values
402:43 - okay
402:44 - however we haven't looked at unary
402:46 - prefix operators so let's create a unary
402:49 - prefix operator let's have a look at an
402:51 - example let's say that we have a
402:53 - lowercase naming here which is equal to
402:56 - foobar and we want to turn it into
402:58 - uppercase Name by saying lowercase name
403:02 - uppercase like this and this operator
403:04 - doesn't exist at the moment so you can
403:07 - see it is we want to say unary unary
403:10 - prefix it is unary because it only works
403:13 - with one argument to its left hand side
403:16 - and that's why it is called prefix
403:17 - because it is it basically works with
403:20 - some actually no that is a that is a
403:23 - suffix I would say that we need to move
403:24 - this here okay so this is a unary prefix
403:28 - because it operate cases whatever it
403:30 - comes to its right hand side so prefix
403:32 - because it is previous to the argument
403:34 - to its right hand side okay
403:36 - so what we can do then is to go ahead
403:39 - and implement this operator but before
403:41 - doing that since it is not an infix
403:43 - operator you actually have to Swift you
403:45 - have to tell Swift that it is a prefix
403:47 - operator so you do that by saying prefix
403:49 - operator it like this so you first tell
403:52 - Swift that this is a prefix operator
403:54 - then you go ahead and Define a function
403:56 - for it so you say prefix func like this
403:59 - oopsie lazy
404:01 - all right and then we work with a value
404:04 - of type screen and we return a value of
404:06 - type string then we take the value and
404:08 - we say uppercased oopsie Daisy uppercase
404:11 - like that now all of a sudden you can
404:13 - see that this error will go away and our
404:15 - Foo BAR value will turn into Foo bar as
404:18 - uppercase okay so that that is how you
404:21 - do a prefix operator
404:23 - in Swift you have to first Define it as
404:25 - a prefix operator then you create the
404:27 - function for it similar to this we can
404:30 - also create a unary postfix operators so
404:33 - let's say that we have for instance
404:35 - um a name here which is fool bar and we
404:39 - want to turn it into a star star star
404:41 - Fubar star star star like that okay so
404:45 - whatever string we give our operator we
404:47 - wanted to prefix it with three stars and
404:49 - a space and then a space and three stars
404:51 - after it okay so we say left with stars
404:54 - is equal to lowercase name and then make
404:57 - sure you start it out so meanwhon a
405:00 - unary post fix operator it is unary
405:03 - because it works only with one object to
405:06 - its left hand side and therefore it's
405:07 - called post fix because it comes after
405:09 - the element that it works with so let's
405:12 - define it we say postfix operator star
405:15 - and then we say postfix func star it
405:19 - takes a value of type string and it
405:21 - returns a string as well and what it
405:23 - does is that it just says star star
405:26 - space value star star star okay and then
405:30 - you can see the value printed here will
405:32 - then be star star Fubar space star star
405:35 - okay
405:36 - so you can also Define your own custom
405:40 - binary infix operators on completely
405:43 - unrelated types so it what we've looked
405:47 - at so far is that every time you work
405:49 - with a binary infix operators both left
405:51 - hand side and right hand side were of
405:53 - the same type however what happens if
405:55 - you have for instance a struct in here
405:57 - let's say we have a struct
406:00 - of person and we say let name is a
406:02 - string and then you have a struct family
406:05 - and then you say let members is an array
406:08 - of persons okay then you go ahead and
406:12 - you say that you for instance have a mom
406:15 - let's mom is person with the name of mom
406:20 - then we create a dad in here Dad we say
406:24 - that and then we say Sun
406:26 - sun is Sun like that then we create
406:30 - dollars so we say daughter one and his
406:33 - daughter one and daughter two all right
406:36 - now what we want to do in here is to say
406:39 - and we want to create a family we say
406:41 - family
406:42 - like this is Mom plus dad so Mom and Dad
406:46 - create a family together however this
406:48 - operator at the moment is not defined
406:50 - Swift doesn't understand what plus
406:52 - between two persons means so we can go
406:55 - ahead and actually Define that so we say
406:57 - we have a function in here we say funk
407:00 - Plus on the left hand side we take a
407:03 - person you see a person and right hand
407:06 - side another person so we say a
407:08 - left-hand side person
407:10 - and we say right hand side person I can
407:12 - understand that we said left hand side
407:13 - and right hand side are probably going
407:15 - to be different types and we've so far
407:17 - created binary infix operators with the
407:19 - same types for both parameters and we're
407:20 - going to do something different now so
407:22 - you're probably asking yourself so why
407:23 - aren't we doing something different but
407:25 - before we do that different thing that
407:27 - we're going to do we have to first
407:28 - implement this function you'll see soon
407:30 - okay so we first say if you create if
407:32 - you add two persons together we create a
407:35 - family all right then in here we say we
407:37 - create a family with members equal to
407:40 - this let's create these in separate
407:43 - lines like that
407:44 - the members are at the left hand side
407:46 - and the right hand side okay now all of
407:48 - a sudden you can see this error will go
407:50 - away and then you get a family in here
407:52 - okay
407:54 - so that's one thing now what happens if
407:56 - you then go ahead and say for instance
407:59 - family
408:00 - with sun is equal to family plus some
408:04 - hmm does this work no it won't because
408:07 - the left hand side of this operator is a
408:10 - family and the right hand side is a
408:12 - person and what we've defined is plus
408:14 - between two persons not a family and a
408:17 - person so what we're going to do is to
408:18 - go ahead and say func Plus on the LA on
408:22 - the left hand side we're going to take
408:24 - in and we're going to take in a family
408:26 - all right so we're gonna say on the left
408:28 - hand side we have family and the right
408:31 - hand side we have a person and this
408:34 - returns also a new family then we go
408:36 - ahead and we say we take the current
408:39 - families members family members then we
408:42 - append to it the current uh the person
408:46 - to the right hand side
408:48 - then we create a new family and return
408:50 - it with the given members like this all
408:52 - right
408:53 - and then you can then see that this
408:55 - error will also go away so you can say
408:58 - family dot members
409:00 - dot count and then in here you say
409:03 - family with sun members.com which should
409:06 - be one more than this family you can see
409:09 - it's three okay now what if you want to
409:12 - say family with daughters so let's say
409:14 - family
409:15 - with daughters and then you say okay
409:18 - take the family with the son and then
409:20 - add a whole array of daughters to this
409:22 - so you say daughter one and daughter two
409:25 - or S sorry not an array of daughters but
409:27 - an array of person you'll get an error
409:29 - now because we still don't have an
409:31 - operator that can work on a an object on
409:35 - the left hand side of type family and an
409:36 - object on the right hand side of type an
409:38 - array of person but we can go ahead and
409:40 - Define that okay so we can say func Plus
409:43 - on the left hand side we take a family
409:45 - and the right hand side we take an array
409:48 - of persons and this guy returns a family
409:51 - all right so the way to do it is to say
409:55 - VAR members again members
409:57 - equal to left hand side members then we
410:01 - say members
410:03 - birth append contents of the right hand
410:07 - side okay and then we return a family a
410:10 - new family with the new members
410:13 - like this all right so now you can see
410:16 - this error will also go away and if you
410:18 - say family with daughters dot members
410:21 - dot count then you should get the value
410:23 - of five printed to the console in here
410:26 - okay so you can see how easy it is to
410:28 - rationalize about how operators should
410:31 - work in Swift they're just simple
410:32 - functions except for unaryfx and urinary
410:36 - postfix which you have to also create
410:38 - these operator
410:41 - um tags kind of or declarations so this
410:44 - is the implementation of the operator
410:45 - and this is the Declaration of the
410:47 - operator okay so I think that is
410:50 - actually quite enough right now about
410:52 - custom operators in the next section
410:55 - we're going to talk about some of the
410:56 - new features uh inside Swift
410:59 - for a basically concurrency and
411:02 - asynchronous Swift and that is going to
411:04 - be the last section for this course and
411:08 - so without further Ado let's just get
411:10 - started with it I'm going to close this
411:12 - tab in here and then I'm going to create
411:14 - a new playground and then let's say
411:17 - playground
411:18 - and we call it async Swift all right and
411:23 - we just say we want to import foundation
411:25 - and here is one of the exceptions where
411:27 - we have to import three things we say
411:29 - import also playground support and then
411:31 - we import
411:32 - import concurrency concurrency like this
411:37 - and we're doing this playground support
411:39 - here simply because asynchronous code
411:41 - requires that our playground is active
411:44 - all the time and it doesn't just start
411:46 - from the beginning and ends and when the
411:49 - when it encounters the end of the file
411:51 - we just need the playground to stay
411:52 - alive simply because concurrent code and
411:55 - and asynchronous code requires that kind
411:58 - of behavior because if you make an API
412:00 - call that takes three seconds to finish
412:02 - maybe before that API call is done your
412:04 - playground has already reached its and
412:06 - it just terminates and you don't want
412:08 - that so let's go and say playground
412:10 - support sir playground page at dot
412:14 - currents page and then we say needs
412:17 - indefinite execution equal to true so if
412:20 - you're running your code on a Macintosh
412:22 - in xcode then you have to do this but if
412:24 - you're on Windows or Linux and you're in
412:26 - Visual Studio code I'm just running your
412:27 - code using simple Swift then you
412:29 - shouldn't really do this you should
412:30 - perhaps just create a simple project
412:34 - that can have a main Loop and then you
412:37 - can then execute your code inside that
412:39 - main Loop That Never Ends okay and
412:41 - however if you're in a playground then
412:43 - you will need to do this on Mac OS all
412:45 - right
412:46 - now let's say that we want to create a
412:49 - simple asynchronous function in Swift if
412:52 - you're already familiar with dart for
412:54 - instance for flutter or python or rust
412:56 - you probably have already used Tokyo
412:58 - perhaps in rust or in Dart you also have
413:01 - Futures and stream stream controllers
413:04 - you're probably already familiar with
413:06 - asynchronous code but if you're not I'll
413:08 - just quickly brief you on what it means
413:10 - it means if you have an asynchronous
413:12 - function it will not immediately return
413:15 - its result it can take any number of
413:17 - seconds or milliseconds to complete its
413:18 - work and return some value and perhaps
413:21 - it won't even return a valuesome
413:22 - asynchronous functions don't return a
413:24 - value okay so let's go ahead and create
413:26 - a simple dummy function in here which we
413:28 - call calculate full name so we say funk
413:30 - calculate full name all right then we
413:34 - say we have a first name first name is
413:36 - string and then we have a last name
413:38 - which is a string then we say it is an
413:40 - async function which returns a string
413:43 - okay so by creating this asynchronous
413:46 - function in here you'll have the ability
413:47 - to basically delay the return of your
413:51 - results so you can in here just say
413:52 - return hello you could definitely do
413:55 - that but that's not the point of async
413:58 - functions this is asynchronous function
413:59 - not an asynchronous function a
414:02 - synchronous function returns this value
414:04 - immediately and asynchronous function
414:06 - might take some time before it returns
414:08 - its value so let's go ahead and say we
414:10 - try to await on a task by sleeping for
414:15 - the duration of one second so this is
414:18 - how you would create a delay a fake
414:19 - delay in your function all right and
414:22 - we're using the try with question mark
414:24 - syntax in here because we're not
414:25 - throwing okay if this function throws
414:28 - then we didn't have to do that
414:31 - however we're saying that our function
414:33 - is an async function that doesn't throw
414:34 - let's also Mark our playground as
414:37 - automatically running
414:39 - so we say try and we say await and let's
414:42 - say cannot convert return expression
414:44 - okay and here then we can say return
414:47 - after waiting one second return the
414:49 - first name with the space and the last
414:51 - name as the result of this function all
414:53 - right that error is now going to go away
414:55 - now inside your playground if you want
414:57 - to call this asynchronous asynchronous
414:59 - function you have to create a task and
415:01 - then you can say let result 1 is equal
415:03 - to a weight on the result of calculating
415:06 - the full name the full name comes from
415:09 - the values of Foo and Bar in here okay
415:12 - and you can see the result is actually
415:15 - Foo bar all right it waited before it
415:18 - calculated the value for us then we can
415:21 - also go ahead I mean you can see in here
415:23 - we have let result equal to a weight but
415:26 - there is another syntax word in Swift
415:27 - which is called async let and you can
415:30 - say async let result 2 is calculate and
415:33 - so you can see how async is before the
415:35 - let and then we say take Foo bar again
415:38 - as the values and in here if you want to
415:40 - if you want to wait for the result of
415:42 - this you have to await on it so you say
415:44 - a way to resolve to now asynclet is a
415:47 - little bit more special because it
415:48 - creates a child task as part of this
415:51 - task you can read about it in Swift
415:52 - Evolution on GitHub and so I won't go
415:55 - too much into it but it is kind of
415:57 - similar to this guy uh but it has a
416:00 - little bit difference in like how you
416:01 - await on it because some developers
416:03 - think maybe that oh this by default
416:05 - awaits on this but it doesn't okay you
416:07 - have to wait on the result yourself
416:09 - manually okay so that's how you can
416:12 - create a simple task in asynchronous
416:14 - task and then do some async and a weight
416:16 - code inside it in Swift
416:18 - now we can go ahead and put together
416:21 - maybe an example that talks about async
416:23 - and async let's and tasks all together
416:25 - just to make it stick a little bit more
416:28 - okay so let's say we create a cloth enum
416:32 - in here and we say we have case socks we
416:35 - have shirts and trousers all right then
416:38 - let's create some asynchronous functions
416:40 - in here so we say the first function
416:41 - that we have is called buy socks all
416:45 - right and it is an async function that
416:47 - throws and we say it returns a clove and
416:50 - what it does is it says try a weight
416:53 - on a task by sleeping for a duration of
416:56 - one second and the reason this function
416:58 - throws is that we're not doing try like
417:00 - this if we did try with a question mark
417:02 - we didn't have to throw okay but we're
417:05 - doing just normal try therefore the
417:07 - function has to throw or it has to be
417:08 - inside I do but what we're indicating to
417:11 - the outside world by writing this
417:12 - function and seeing that this function
417:13 - is an asynchronous function that can
417:15 - internally actually throw an error so be
417:16 - careful while consuming its value all
417:19 - right then we return a close of type
417:21 - socks so after one second we produce an
417:24 - item of clothing
417:26 - after doing this one we can go ahead and
417:29 - create another function which is called
417:31 - by shirt like this and it produces an
417:34 - item of clothing and ins in here we just
417:37 - say shirt all right and we can create
417:39 - another one that produces a item of
417:42 - trousers so we say trousers and it says
417:45 - dot trousers all right so they're very
417:49 - similar to each other they just return a
417:50 - different result of them now you want to
417:53 - create a structure in here that is an
417:56 - ensemble an ensemble is a you can say it
418:00 - is a collection of clothing clothes
418:02 - items and you can say struct Ensemble
418:05 - all right and then we say this guy has
418:09 - clothes in it and we say it is an array
418:11 - of clothes and it has a total price
418:13 - price of type double all right doesn't
418:16 - really matter what the currency for the
418:18 - prices we also want this Ensemble to be
418:20 - printable to the console in a very nice
418:22 - format so we can form it to custom debug
418:25 - string convertible protocol and
418:27 - therefore we have to implement a new
418:29 - variable here called debug description
418:31 - like this we make it a computed property
418:35 - and then we say clothes equal to clothes
418:38 - and we say price is equal to total price
418:41 - so the value that you're producing here
418:43 - will then be printed to the debug
418:45 - console whenever you try to debug an
418:48 - instance of this Ensemble structure okay
418:50 - now we create a function in here called
418:53 - by whole ensemble
418:56 - like this and we say it it's an async
418:58 - function that throws and it produces an
419:00 - ensemble in here okay then we should go
419:03 - ahead and buy all our uh parts so we say
419:06 - async LED socks is buy socks async let
419:11 - shirt is by shirt and async lets
419:15 - trousers is by trousers all right so
419:19 - since all these are async let's then we
419:21 - need to await on them and also we should
419:23 - also sorry not also also twice now
419:26 - became four times
419:27 - so what we want to do is to go and
419:29 - create an ensemble so we say let's
419:31 - Ensemble on uh symbol is an instance of
419:35 - Ensemble and it says okay give me the
419:37 - clothes and you probably think okay I'm
419:39 - just gonna give it socks shirt and
419:40 - trousers but you can't do that because
419:42 - these are async let's items you have to
419:44 - await on them so just type a weight and
419:47 - then we go ahead in here we say socks a
419:49 - shirt trousers but since these guys are
419:52 - also throwing functions you have to try
419:54 - them okay so you say try try try
419:57 - and then for the total price we're gonna
420:00 - say the total price is 200 okay
420:03 - there we go and then we can return The
420:05 - Ensemble like this now all these errors
420:07 - are hopefully gonna go away so there we
420:10 - go
420:11 - now you can to test this you create a
420:13 - task in your playground and then you can
420:15 - say a flat
420:17 - Ensemble is equal to try a weight on buy
420:21 - hola Ensemble then you can say Ensemble
420:24 - is this otherwise something went wrong
420:27 - like that all right and then you can see
420:30 - our Ensemble debug description will be
420:33 - printed to the screen says clothes are
420:35 - this let's see if you can get the entire
420:37 - clothes maybe we could print it even so
420:40 - print
420:41 - it's a little bit easier perhaps to read
420:43 - it here
420:44 - there we go so it says is a shirt it's a
420:47 - socks trousers and also the price is 200
420:50 - dollars let's say okay now async lab can
420:54 - only be used within asynchronous
420:56 - closures and asynchronous functions or
420:59 - wherever there is a task being run so
421:01 - you cannot use asynchronous async let
421:05 - within uh anything that is not one of
421:07 - the ones that I just described so it
421:09 - should be an asynchronous closure an
421:11 - asynchronous function or wherever there
421:14 - is a task that you have such as in here
421:17 - okay so let's let's have a look at a few
421:19 - examples we go in here and we just say
421:22 - funk get full name and we ask for a
421:25 - delay a fake delay and we say it's of
421:27 - type duration and we say we have a
421:30 - calculator for
421:31 - what we calculate like how we calculate
421:33 - the full name and it is an async
421:36 - function that returns a string
421:39 - in here and then we say it is async
421:41 - function add it in itself returns a
421:44 - string so our job is just to try to
421:47 - await on this uh task sleep for this
421:52 - delay and then we return and we want to
421:55 - return the result of this function but
421:57 - it is an async function so we have to
421:59 - await on it so we say wait on the
422:01 - calculator like this all right and then
422:04 - you can see all these errors are then
422:06 - going to go away and then we have our
422:07 - print statement in here let's just
422:08 - remove it so that we don't get this
422:10 - print in the console all right
422:13 - now that we have that we can go ahead
422:15 - and actually say we have a funk and we
422:18 - call it full name and we say it's an
422:19 - async function which is an error
422:21 - function and we just for now just we say
422:24 - Foo bar all right so it is an async
422:27 - function but right now it just returns
422:28 - asynchronous result back to us full name
422:31 - like this then we can create a task and
422:34 - we can say await on get full name and we
422:37 - say uh let's break these down and then
422:41 - we say the delay is in delay in seconds
422:43 - one and its calculator is indeed uh
422:47 - let's actually see for the calculator
422:49 - let's create a a trail enclosure in here
422:53 - then we say async let name is full name
422:57 - and then we can say return awaits name
422:59 - all right so let's see if we get the
423:02 - results printed to the screen now you
423:04 - can see Fubar then being printed to the
423:06 - screen so we could use async let simply
423:09 - because we're in a an async trailing
423:12 - closure okay and also we've been able to
423:15 - use asynclet in other contexts such as
423:17 - here which we're in an async function
423:20 - all right so
423:22 - I mean there's a lot more actually to
423:24 - talk about when it comes to asynchronous
423:27 - programming with swift but this just
423:30 - gives you an idea of the basics of
423:33 - asynchronous programs very similar to
423:35 - JavaScript and typescript and you could
423:36 - also say it's very similar to actually
423:38 - Dart for instance for those of you who
423:40 - do flutter development it's a little bit
423:42 - more complicated because well it is
423:44 - Swift it has a long history of its own
423:48 - code base and there are a lot of people
423:50 - contributing to Swift as a programmable
423:52 - language not even just people just
423:54 - inside Apple so it is somehow a mishmash
423:58 - of everything the community thought was
424:00 - a good idea to add to Swift I personally
424:02 - don't like for instance async let I
424:04 - think it makes things more complicated
424:06 - almost every other program language that
424:08 - has asynchronous programming such as
424:10 - JavaScript typescript and dart don't
424:12 - need async lab they just do async and a
424:14 - weight and everything works as expected
424:16 - I think async lab adds a new layer of
424:19 - complexity to your code which is
424:20 - unnecessary
424:21 - some people may argue that it is
424:23 - actually nice but I personally don't
424:24 - like it so much but that's just my
424:27 - opinion and I think it although I don't
424:29 - like it so much I learn it and I think
424:33 - it is important that we all learn how to
424:34 - use these syntaxes that are available in
424:36 - modern Swift so with that said I think
424:39 - we can then conclude this particular
424:42 - video of the full stack with swift
424:44 - course and we've talked a lot about you
424:48 - can see we have so many playgrounds in
424:50 - here I can't even count but we talk
424:51 - about variables operators classes
424:53 - expenses generics pretty much everything
424:55 - that you can think of in Swift so now
424:58 - what we're gonna do in the course is to
425:00 - go ahead and start talking about client
425:02 - development and also back-end
425:03 - development with Swift I really hope
425:06 - that you enjoyed this video if you found
425:07 - it helpful please press the thanks
425:09 - button at the bottom of the screen or
425:11 - you can just alternatively join my
425:13 - YouTube channel so see you in the next
425:15 - video