00:00 - in this course you will learn how to
00:01 - improve your JavaScript skills by
00:03 - building a card game Gavin long teaches
00:06 - this course Gavin is a freeco camp team
00:09 - member and popular instructor hi and
00:11 - welcome I'm Gavin long I've been a
00:13 - professional software developer for many
00:16 - years and over the years I've written in
00:18 - a variety of different programming
00:19 - languages depending on the relevant
00:21 - project
00:22 - c-sharp is my main programming language
00:24 - but in spite of what your main
00:26 - programming language may be be a Java
00:28 - python c-sharp Etc
00:31 - there is always this one other
00:32 - programming language that is almost a
00:35 - mandatory programming language for every
00:36 - developer to learn that programming
00:39 - language is of course JavaScript so why
00:41 - is it so essential to learn JavaScript
00:44 - well JavaScript is a great language that
00:47 - can run both on the client and server
00:49 - side
00:50 - but it is also along with HTML and CSS a
00:53 - core technology on the world wide web
00:56 - according to Wikipedia 98 of websites
00:59 - use JavaScript on the client's side for
01:01 - web page Behavior
01:04 - sure this may change moving forward due
01:06 - to Technologies like webassembly
01:08 - which enables developers to leverage
01:10 - programming languages like for example C
01:12 - sharp for client-side web Behavior
01:15 - functionality
01:16 - but I think it's safe to say that for
01:18 - the foreseeable future JavaScript is
01:21 - still going to be the dominant
01:22 - technology for this client-side where
01:25 - Behavior functionality so in this video
01:27 - we'll exercise our JavaScript skills to
01:30 - create a browser-based basic card game
01:33 - by going through this video you'll
01:35 - hopefully learn a few things about
01:37 - JavaScript HTML CSS and visual studio
01:40 - code although you'll only create a basic
01:43 - card game you can use the concepts
01:45 - you'll learn to create more
01:46 - sophisticated card games like for
01:48 - example blackjack or poker so please
01:51 - feel free to make the application your
01:52 - own and use the code as the basis for
01:55 - your own card games at the very least
01:58 - this video provides you with a great
02:00 - JavaScript exercise I hope you enjoyed
02:02 - this video and learn a few things along
02:04 - the way
02:05 - so this tutorial demonstrates how to
02:07 - build a basic card game using vanilla
02:10 - JavaScript basic CSS and HTML code
02:15 - this tutorial not only covers creating a
02:17 - basic card game using JavaScript but
02:20 - also covers how to create Dynamic user
02:23 - interactive code using vanilla
02:24 - JavaScript
02:26 - we'll cover creating some animation
02:28 - effects responsive layout design using
02:30 - CSS grid CSS flexbox and media queries
02:35 - how to dynamically change the positions
02:37 - of grid cells so as to randomize the
02:40 - positions of the cards contained in a
02:42 - CSS grid using JavaScript local storage
02:45 - and much more
02:47 - I would say that the code is accessible
02:50 - to Learners at most levels I've kept the
02:53 - code quite simple
02:55 - if however you get lost at any point the
02:57 - code can be downloaded from GitHub
02:59 - please see a link below in the
03:01 - description to the relevant GitHub
03:03 - repository
03:05 - in this video we are going to develop a
03:07 - basic card game using vanilla JavaScript
03:11 - I'll use vs code as my code editor even
03:14 - though I'll develop the game on my Mac
03:16 - you of course can use vs code for
03:18 - Windows or Linux and the coding
03:21 - experience will be very much the same
03:29 - vs code is of course free open source
03:32 - software I'll be using the Chrome
03:34 - browser for testing purposes
03:37 - so the game that we'll develop is very
03:40 - basic I've called it hunt the ace
03:44 - here's a brief description of the game
03:45 - so we have four different cards one of
03:49 - which is the Ace of Spades
03:51 - the user clicks the play game button to
03:54 - start the game
03:55 - the cards are flipped over so that the
03:58 - user can no longer see the face of the
04:00 - cards our game then randomizes the
04:03 - positions of the cards so the cards are
04:05 - in effect shuffled the cards are then
04:08 - positioned at random locations in a grid
04:10 - layout each location corresponds to a
04:14 - random whole number between one and four
04:16 - the user can then guess where the user
04:19 - thinks the Ace of Spades is by clicking
04:22 - on the relevant card
04:23 - once the user has clicked The Chosen
04:25 - card the card then flips over and of
04:27 - course the user is made aware of whether
04:30 - the user has guessed the correct
04:31 - position of the Ace of Spades
04:34 - each game consists of four rounds
04:37 - in each round the user attempts to guess
04:40 - the location of the Ace of Spades if the
04:43 - user fails to guess the position of the
04:45 - Ace of Spades the user will not be
04:47 - awarded any points for that round if the
04:50 - user however guesses the correct
04:52 - location of the Ace of Spades the user
04:55 - is awarded points based on the round
04:56 - number
04:58 - so yes it's a simple game but I thought
05:00 - this might be a good JavaScript coding
05:02 - exercise this code is fairly simple and
05:05 - therefore this tutorial should be
05:07 - accessible to a wide audience interested
05:09 - in programming
05:11 - if you like this video please hit the
05:12 - like button for Content like this and
05:15 - much more please consider subscribing
05:17 - and please ring the bell so that you'll
05:19 - be notified of future content please
05:20 - note that I've included links Below in
05:22 - the description to additional
05:23 - information for more detail on certain
05:25 - Concepts discussed in this tutorial
05:29 - let's create the project
05:31 - so let's get started
05:33 - so all we need to do is open an empty
05:35 - folder from within Visual Studio code
05:37 - this folder is of course where our
05:39 - project files will reside
05:41 - so I've created a folder which I have
05:44 - aptly named hunt the ace to house the
05:47 - files for this project on my computer
05:51 - let's create three files within Visual
05:53 - Studio code let's create a file named
05:56 - index.html of course for our HTML code
06:07 - let's create a file named index.js of
06:10 - course for our JavaScript code
06:18 - let's create a file named style.css of
06:21 - course for our layout and styling code
06:23 - our CSS code let's create a folder to
06:26 - house the images that will be used to
06:29 - represent our cards as well as a card
06:32 - that will be used for our game's image
06:35 - logo
06:36 - you can download the relevant images
06:38 - from GitHub at this location
06:57 - great
06:58 - the live server extension
07:01 - let's start by coding basic HTML code
07:04 - So within Visual Studio code you can
07:07 - generate boilerplate HTML code for
07:10 - example the doctype tag that indicates
07:12 - that we are using HTML5 the HTML tag
07:16 - head and body tags along with relevant
07:19 - meta Tags by simply typing in the
07:22 - exclamation mark character followed by
07:24 - pressing the Tab Key like this
07:27 - so I'm going to use semantic HTML to
07:30 - create a tag named header which will
07:33 - house header related HTML code in our
07:36 - layout by semantic HTML I mean the tag
07:39 - name is descriptive as to the purpose of
07:41 - the tag rather than for example simply
07:44 - using a div tag semantic HTML elements
07:47 - are those that clearly describe their
07:49 - meaning in a human readable and machine
07:52 - readable way
07:54 - so we can type the tag name and then
07:56 - press the tab key and the code for the
07:58 - HTML element is generated for us by
08:01 - Visual Studio code
08:03 - let's include a div element that
08:05 - contains a CSS class named header Dash
08:08 - title Dash container
08:10 - so a quick way to generate the HTML code
08:12 - for the relevant tag that includes a
08:15 - specific class attribute within Visual
08:17 - Studio code is to type the tag name so
08:21 - div
08:22 - then type in a DOT followed by the class
08:25 - name you wish to include within the
08:27 - element
08:28 - then simply press the Tab Key and visual
08:30 - studio code automatically generates the
08:33 - desired HTML code
08:35 - let's include a H1 element for our
08:37 - game's header
08:39 - so we want our header to reflect the
08:41 - name of the game
08:43 - we are creating so punt the ace
08:47 - you may be familiar with a visual studio
08:49 - code extension named live server if
08:53 - you're not familiar with this extension
08:54 - it is very useful for monitoring the
08:57 - effects of changes made to your code
09:00 - in real time
09:01 - you can install the live server
09:03 - extension from this location
09:06 - so once the live server extension has
09:09 - been installed we can launch our
09:11 - application through Visual Studio code
09:12 - using live Server Like This
09:19 - we can then tile our code Editor to the
09:22 - left of our screens and our browser to
09:24 - the right of our screens and in this way
09:27 - we can easily monitor the effects of
09:28 - changes to our code without the need to
09:31 - refresh the browser window every time we
09:33 - make a change to our code
09:35 - so for example let's change our header
09:37 - text to hunt the Ace of Spades and once
09:41 - we have saved our code we can
09:42 - immediately see the effects of our code
09:45 - change within the browser window
09:52 - create cards statically with card 3D CSS
09:55 - effects
09:57 - so we are first going to create a card
09:59 - statically then later we'll dynamically
10:02 - generate the cards through JavaScript
10:04 - code
10:05 - we'll appropriately use the document
10:07 - object model to build our cards and add
10:10 - them to the Dom document object model
10:13 - let's first create the card statically
10:16 - through basic HTML and CSS code
10:19 - let's create a div tag that contains a
10:21 - class named card Dash container within
10:24 - this div tag let's create a child div
10:26 - element that contains a class named card
10:30 - within the card div element let's create
10:32 - a child div element that contains a
10:35 - class named card Dash inner
10:37 - within the card Dash in a div element
10:39 - let's create a child development that
10:42 - contains a class named card Dash front
10:46 - let's also create a child development
10:49 - that contains a class named card Dash
10:51 - back
11:03 - let's add an image element as a child
11:05 - element to the dev element that contains
11:07 - the class named card Dash front
11:10 - as you may have guessed this image will
11:12 - represent the front of the card
11:14 - so let's assign the image elements
11:17 - Source tag the path of the image that
11:20 - depicts the Jack of Clubs
11:23 - so each card will contain the same back
11:25 - image
11:26 - so we can ensure this by adding the
11:29 - appropriate image element as a child
11:30 - element to the div tag that contains the
11:33 - card dashback class like this
11:46 - so we have built our card statically
11:48 - using HTML code
11:50 - as you can see there's not much to look
11:52 - at at present
11:54 - so the next step is to style the card
11:57 - using CSS code so that we can create our
12:00 - card to look three-dimensional and
12:03 - create the desired flip effect
12:06 - our CSS code will create the illusion
12:08 - that the card is a three-dimensional
12:11 - object
12:12 - let's first reference our style.css file
12:15 - from within the index.html file
12:19 - I'm not going to go into too much detail
12:21 - explaining the CSS code because this
12:23 - tutorial is more about JavaScript
12:27 - please follow along with the code so
12:29 - that your CSS code is consistent with
12:31 - mine
12:32 - let's create the styling for the cards
12:35 - Dash container element
12:36 - by card container element I am of course
12:39 - referring to the element that contains a
12:41 - reference to the card Dash container CSS
12:44 - class
12:51 - let's create the styling for the card
12:53 - element
13:02 - let's create CSS variables to store the
13:05 - dimensions of our cards
14:51 - so basically the car dash inner element
14:53 - contains the child elements card Dash
14:56 - back and card Dash front the CSS code we
15:00 - are creating facilitates a flip effect
15:02 - between the front of the card and the
15:04 - back of the card
15:06 - we can test the flip effect by
15:09 - implementing CSS code so that when we
15:11 - hover our Mouse pointers over the
15:13 - relevant card that the flip effect
15:15 - occurs
15:16 - so we are writing code so that the inner
15:19 - Dash card element rotates 180 degrees on
15:22 - its y-axis when a mouse pointer is
15:25 - hovered over the relevant card
15:27 - and we can now test this
15:31 - excellent
15:43 - before we create our cards dynamically
15:45 - through JavaScript code and
15:47 - appropriately add the cards to the
15:49 - document object model let's create a
15:51 - grid for the game area if you like where
15:55 - the cards will be placed
15:57 - so firstly let's create four
15:58 - placeholders denoting the positions of
16:01 - each of the cards in the gameplay area
16:05 - so card Dash pause Dash a card Dash
16:09 - pause Dash B cards Dash pause Dash C and
16:13 - card Dash pause Dash D
16:17 - so you can see here in the CSS code I've
16:20 - given the body element a height of 100
16:22 - VH this simply means the height of the
16:25 - body of the HTML document
16:27 - will take up a hundred percent of the
16:30 - viewport height of the screen
16:32 - so I want the gameplay area to be
16:34 - aligned centrally within the main
16:36 - element and take up an area based on the
16:39 - width of the cards
16:41 - so let's write the code for this
16:44 - so I'm using flexbox functionality for
16:46 - the display to centrally align the
16:48 - gameplay area I.E the area that will
16:51 - contain our cards
16:53 - so I'm going to use the calc CSS
16:55 - function to calculate the width of the
16:58 - gameplay area
16:59 - two cards will reside side by side on
17:02 - each row
17:03 - the card Dash container style
17:05 - essentially denotes the gameplay area
17:50 - then to display the cards in a grid
17:53 - that will have two cards on each row we
17:56 - can use the grid functionality provided
17:58 - in CSS
18:00 - we can control where each individual
18:02 - card will reside by allocating each card
18:05 - position element a position in the grid
18:08 - by using the grid Dash template Dash
18:10 - areas property like this
18:46 - so to get a clear picture of our layout
18:49 - let's add border styles to the relevant
18:51 - HTML elements
19:18 - great
19:21 - let's give each of the grid cells
19:23 - different background colors so that we
19:26 - can get a clear picture of the layout of
19:27 - the grid
19:29 - note that each of the four cards used in
19:31 - this game will be placed in a specific
19:33 - cell within the grid
19:46 - great and we can see the grid cells
19:49 - clearly
19:50 - so we have now created the grid within
19:52 - the gameplay area
19:57 - create cards dynamically through
19:59 - JavaScript
20:01 - we have created our cards statically
20:03 - through HTML and CSS let's create the
20:06 - cards dynamically using JavaScript let's
20:09 - go to our index.js file let's create an
20:12 - array of objects each object within the
20:15 - array denotes a card or a card
20:17 - definition each object has an ID
20:20 - property and an image Path property the
20:24 - first item is the king of hearts and has
20:26 - an ID of one the second item is a jack
20:28 - of clubs and has an ID of two the third
20:31 - item is the Queen of Diamonds and has an
20:34 - idea of three
20:39 - the fourth item is the Ace of Spades and
20:42 - has an ID of four
20:46 - let's create a function named create
20:48 - card of course this function is
20:50 - responsible for creating a card
20:52 - dynamically through JavaScript code
21:00 - firstly let's create a reusable function
21:02 - responsible for creating a HTML element
21:05 - let's name this function create element
21:10 - we can create a HTML element and code
21:13 - through this line of code
21:16 - let's use our create element method to
21:19 - create the div tags that make up a card
21:23 - so here we can see the static HTML code
21:25 - that we created earlier to represent a
21:28 - card
21:31 - so that we can see what we are creating
21:33 - here in code dynamically
21:36 - so basically we have a card element
21:38 - an inner card element within the card
21:40 - element a front and back element within
21:43 - the inner card element
22:08 - we can use the create element method to
22:10 - create our image elements
22:12 - that contain the back card image and the
22:15 - front card image
22:32 - let's create a reusable method that adds
22:35 - a class to a HTML element
22:50 - let's write code to add the card class
22:52 - to the card element
23:00 - let's write a method that adds an ID
23:04 - to a HTML element so each card will be
23:07 - assigned a unique ID the ID will come
23:11 - from the array of card object
23:13 - definitions that we created earlier
23:15 - I'll create card method accepts one
23:18 - argument this argument will be an item
23:20 - from the card object definitions array
23:42 - let's write code to add the inner card
23:44 - class to the inner card element
24:00 - let's write code to add the appropriate
24:02 - class to the front dash card element
24:06 - and the back card element
24:35 - let's write a reusable method that
24:38 - assigns a path for the relevant image to
24:41 - the SRC attribute of an image element
25:03 - okay before we assign the image path
25:05 - properties for the card
25:08 - to the appropriate image elements
25:10 - let's create a const to store the path
25:13 - for the image that represents the back
25:16 - of a card
25:28 - right let's assign the image paths
25:30 - appropriately
25:40 - let's write code to assign the card Dash
25:43 - image class to the image elements
26:36 - so now that we have our basic elements
26:38 - created in code let's assign the child
26:41 - elements appropriately to their parent
26:42 - elements so let's create a reusable
26:45 - method named ADD child element
26:48 - the code within this method simply adds
26:50 - the child element passed in as an
26:52 - argument to the second parameter to the
26:54 - parent element passed in as an argument
26:56 - to the first parameter
27:01 - so let's write code to add the image
27:03 - elements to their appropriate parent
27:05 - elements
27:27 - let's write codes to add the front dash
27:29 - card element and the back dash card
27:31 - element to the inner Dash card element
27:56 - let's write code to add the inner Dash
27:59 - card element to the card element
28:09 - let's create a global const and store a
28:12 - reference to the card Dash container
28:14 - element
28:15 - we are not going to add the card
28:16 - elements directly to this element but we
28:19 - will use this element constant a bit
28:21 - later
28:22 - when we write code to alter the
28:24 - positions of the grid cells each grid
28:26 - cell will contain one of our cards the
28:29 - cells of the grid
28:31 - are child elements of the card container
28:33 - element
28:35 - we are using the CSS grid system for the
28:38 - grid functionality which represents the
28:40 - gameplay area I.E where our cards will
28:43 - be displayed
28:47 - let's write code to appropriately add
28:49 - each card element as a child element to
28:52 - their appropriate grid cell
28:54 - each grid cell is denoted by a div
28:57 - element
28:59 - we are going to map each card to its
29:02 - initial position by mapping the card
29:04 - element's ID to the appropriate element
29:07 - that represents a grid cell
29:10 - this is how our code will know as it
29:12 - were which card must be assigned to
29:15 - which positional parent div element
29:26 - so let's create a method named add card
29:29 - to grid cell
29:31 - let's create a method named Map Card ID
29:34 - to grid cell
29:35 - this method will be called within the
29:38 - add card to grid cell method so if the
29:41 - card ID is one we want this card to be
29:44 - added as a child element to the first
29:46 - position in the grid which is denoted by
29:48 - a div element with the cart Dash pause
29:51 - Dash a CSS class
29:54 - if card ID is 2 we want this card to be
29:57 - added as a child element to the second
30:00 - position in the grid which is denoted by
30:02 - a div element with the card Dash pause
30:05 - Dash B CSS class
30:08 - if card ID is three we want this card to
30:11 - be added as a child element to the third
30:13 - position in the grid which is denoted by
30:16 - a div element with the card Dash pause
30:19 - Dash C CSS class
30:21 - if card ID is four we want this card to
30:25 - be added as a child element to the
30:27 - fourth position in the grid which is
30:29 - denoted by a div element with the card
30:32 - Dash pause Dash D CSS class then within
30:36 - the add card to grid cell method let's
30:38 - write the code that finds the
30:40 - appropriate parent element for the child
30:43 - card element
30:44 - using the map grid ID to grid cell
30:47 - method and then adds the childcard
30:50 - element to its designated parent element
31:01 - then within the create card method let's
31:03 - write code to appropriately call the add
31:06 - card to grid cell method
31:18 - so let's write a method that will Loop
31:21 - through each of the objects stored
31:22 - within the card object definitions array
31:25 - create the relevant cards and add the
31:27 - cards to their appropriate grid
31:29 - positions so let's create a method named
31:32 - create cards
31:34 - then all we need to do is write code
31:36 - that calls the create card method within
31:38 - the for each Loop that Loops through
31:40 - each card definition to create the cards
31:43 - dynamically and add the cards to their
31:47 - appropriate position within the grid
32:08 - Let's test the code
32:11 - okay so we have an issue let's press F12
32:14 - within our Chrome browsers
32:16 - and card is not defined okay
32:21 - and it's because I forgot to include an
32:23 - appropriate parameter that expects a
32:25 - card element as an argument within the
32:29 - map card ID to grid cell method
32:31 - definition
32:35 - okay and it's still not adding the cards
32:37 - to the grid
32:38 - if we press F12 and inspect the elements
32:42 - it's definitely adding the cards to the
32:44 - grid cells
32:47 - ah but the IMG element is not built
32:51 - correctly
32:52 - okay so the code is currently adding the
32:56 - images to the front and back div
32:58 - elements whereas the code should be
33:01 - adding the images to the front and back
33:03 - image elements so let's fix this issue
33:17 - oh and I can see that the card Dash
33:20 - image class is being added to the div
33:23 - elements rather than the image Elements
33:25 - which is of course incorrect
33:27 - this class should be added to the
33:30 - appropriate image elements not the div
33:31 - elements
33:39 - great
33:42 - so let's modify the CSS code so that the
33:45 - cards align centrally within the grid
33:47 - cells
33:51 - and let's use the CSS flexbox
33:53 - functionality to align the card
33:55 - centrally within their parent elements
34:26 - great
34:28 - so we have now created our cards
34:30 - dynamically through JavaScript code and
34:32 - positioned the cards appropriately
34:33 - within their grid cells
34:45 - let's write a method named load game
34:48 - the method is called when the game is
34:50 - first launched
34:52 - so we want our cards to be created
34:54 - dynamically when the game is first
34:57 - launched so let's call the create cards
34:59 - method from within the load game method
35:13 - let's write a method named start game
35:16 - this method will be called when a user
35:18 - clicks a button used for starting a game
35:21 - the gameplay button if you like
35:25 - let's go to our HTML file and include a
35:29 - button element that the user can click
35:31 - to start the game
35:32 - let's first write layout related code
35:36 - for our button
35:43 - and then let's code the button element
35:45 - itself
36:12 - let's write code to create a global
36:14 - variable that will store a reference to
36:17 - an array of the card elements
36:20 - then let's write code to assign the
36:22 - results of a query for all card elements
36:25 - to our card's Global array variable
36:27 - within the load game method
36:39 - let's write code to wire up a click
36:42 - event to the start game button element
36:44 - that we just created within our HTML
36:47 - code
36:48 - let's first write code to store a
36:50 - reference to our start game button
36:52 - element in a global const
37:14 - within the load game method let's use
37:16 - the JavaScript method add event listener
37:19 - to add a click event handler to the
37:22 - start game button
37:23 - when a user clicks the start game button
37:26 - we want the start game function to be
37:28 - called
37:39 - so let's test whether our event listener
37:41 - is working
37:48 - great
37:49 - let's write a definition for a method
37:51 - that will be called to initialize a new
37:53 - game
38:08 - let's write a definition for a method
38:09 - that will be called when a new round is
38:12 - started
38:18 - let's write a definition for a method
38:20 - that will initialize a new round
38:30 - let's call the start round method from
38:32 - within the start game method
38:43 - so when the user clicks the start game
38:45 - button
38:46 - and before the cards are shuffled I.E
38:48 - their positions are randomized we want
38:51 - the user to see the cards stacked one on
38:54 - top of the other and positioned
38:56 - centrally within the gameplay area I.E
38:59 - the grid
39:00 - so to achieve this we are going to first
39:02 - collapse the grid as it were
39:05 - the collapse grid functionality simply
39:07 - involves modifying the grid area
39:09 - template property so the grid consists
39:12 - of just one cell
39:14 - then our code will add the cards to this
39:18 - one cell
39:19 - so to achieve this let's first create a
39:22 - method named collect cards
39:26 - let's create a constant to store the
39:29 - grid area template's value that will be
39:32 - assigned to the grid area templates
39:34 - property to cause the grid to collapse
39:36 - as it were
39:42 - let's create a global constant that
39:45 - stores the class of the div element that
39:47 - represents the grid cell
39:49 - that will be the only cell in the grid
39:51 - once we modify the grid area templates
39:53 - property appropriately
39:56 - so we are choosing the first cell in the
39:58 - grid to contain our Stacked Cards as it
40:01 - were
40:02 - So within the collect cards method let's
40:05 - call a method named transform grid area
40:07 - and pass the appropriate Global constant
40:10 - we have just declared as an argument to
40:13 - the transform grid area method
40:16 - let's write the transform grid area
40:18 - method
40:19 - so using the card container LM element
40:22 - that contains the grid cells this
40:25 - element has been designated through
40:28 - appropriate CSS code as our grid
40:31 - let's change its grid template areas
40:34 - property through implementing the
40:36 - appropriate JavaScript code like this
40:49 - then let's write a method to add the
40:51 - cards to the cell that at this point
40:54 - takes up the entire grid
40:56 - so the grid now consists of only one
40:58 - cell
41:25 - let's call our add cards to grid area
41:28 - cell method from within the collect
41:31 - cards method
41:41 - let's call the collect cards method from
41:44 - within the start round method Let's test
41:46 - the code
41:49 - excellent
41:52 - so before the shuffle cards process
41:55 - begins we want to flip the cards
41:57 - so that the backs of the cards are
41:59 - facing the user
42:01 - so firstly let's update the CSS code so
42:04 - that when the inner card div element
42:07 - also contains a card named flipit that
42:11 - the UI responds by rotating the card on
42:14 - its y-axis by 180 degrees I.E the
42:18 - flipped class being present in the
42:21 - relevant cards in a card element results
42:24 - in the card flipping from front to back
42:27 - as it were
42:29 - so let's go to our JavaScript code and
42:32 - create a method named flip cards this
42:35 - method contains one parameter
42:37 - if the card is on its front and the flip
42:40 - to back argument is true our code will
42:43 - flip the card so that its back is facing
42:46 - the user
42:47 - so let's create a method named flip card
42:49 - this method accepts two arguments the
42:52 - first argument will store the relevant
42:55 - card element the second argument will
42:57 - contain the Boolean flip to back value
43:02 - so as we know at this stage the inner
43:04 - card element is the element that is used
43:06 - for creating the flip effect
43:09 - so the inner element is the first child
43:12 - contained within the card element
43:14 - so we can use the relevant card elements
43:16 - first child property to reference the
43:19 - inner card element
43:22 - the logic for this method is as follows
43:25 - if the flip to back argument is true and
43:27 - the inner card element doesn't contain
43:30 - the flipped class then add the flippet
43:33 - class to the inner card element
43:36 - so if the card is already back facing we
43:40 - don't want to flip the card so that it
43:42 - is front-facing
43:44 - flip to back is true so we want the card
43:47 - to have its back facing the user else if
43:51 - the inner card element contains the flip
43:53 - it class
43:54 - we want to remove it
43:56 - the result of this will mean that the
43:59 - card is flipped so that the card's front
44:02 - is facing the user if the card is
44:04 - already facing front side up it will not
44:07 - contain the flipped class
44:09 - which is what we want in this case
44:12 - within the flipped cards method let's
44:15 - call the flip card method appropriately
44:17 - so that all cards are traversed and
44:20 - flipped as it were if appropriate
44:23 - let's use the JavaScript set timeout
44:26 - method so that each card is flipped at a
44:29 - different time this is done just to
44:31 - create a simple animation effect
44:34 - so each flip will occur
44:36 - at an interval measured in milliseconds
44:39 - which will be the index a sequential
44:42 - value from one to four incremented with
44:44 - each iteration of the loop multiplied by
44:46 - 100. so let's call the flip cards method
44:50 - from within the start round method after
44:52 - the collect cards method we want the
44:55 - cards flipped on their backs so the flip
44:57 - to back argument passed to the flip
45:00 - cards method is set to true
45:02 - Let's test the code
45:09 - excellent
45:13 - so now we want to randomize the
45:15 - positions of the cards so let's create a
45:18 - method named shuffle cards
45:20 - we are going to use JavaScript set
45:23 - interval method to run a function that
45:26 - we'll create in a bit named Shuffle
45:30 - so every 12 milliseconds the shuffle
45:33 - method will execute
45:43 - let's use a variable named Shuffle count
45:45 - to count the amount of times the shuffle
45:47 - method
45:48 - is called
45:53 - when the shuffle count variable is equal
45:55 - to 500
45:57 - we can use javascript's Clear interval
46:00 - method to stop the shuffle method being
46:03 - called
46:04 - the shuffle count variable is
46:06 - incremented every time the shuffle
46:08 - function is called
46:11 - we are going to create a method to
46:13 - randomize the positions of the cards
46:17 - within the shuffle function let's call a
46:19 - method named randomize card positions
46:22 - right so let's write the randomized card
46:25 - positions method
46:43 - so let's use javascript's math.random
46:46 - functionality appropriately so that we
46:49 - generate a random whole number between 1
46:51 - and 4.
47:39 - we want two random numbers generated
48:07 - let's create a global variable that
48:10 - stores an array of card positions within
48:12 - the grid
48:14 - then we can use these two random numbers
48:16 - to swap the position values for the
48:19 - relevant cards within the card positions
48:22 - array
48:24 - this creates a shuffle-like effect for
48:26 - our four cards
48:35 - this randomized card positions method
48:37 - will continuously be called until the
48:40 - clear interval JavaScript method is
48:43 - executed
48:44 - from within the shuffle method
48:47 - at this point the positions of the cards
48:50 - should be unpredictable to the user
48:54 - okay let's write a method named
48:57 - initialize card positions that contains
49:00 - the code to store the initial positions
49:02 - of the cards in the grid
49:04 - the gameplay area
49:06 - within the card positions array
49:10 - let's call the initialize card positions
49:12 - method from within the create card
49:15 - method so each initial position of the
49:18 - card is established when the game is
49:20 - first loaded through the relevant card
49:22 - elements ID
49:28 - I want to create a method named deal
49:30 - cards that will execute when Shuffle
49:32 - count equals 500. and therefore the deal
49:36 - cards method will be called after the
49:39 - shuffling or randomization of the card
49:41 - positions is complete
49:43 - the deal cards method will in effect
49:46 - restore the grid to contain four grid
49:48 - cells and add each card back to their
49:52 - original positions in the grid
49:54 - the div elements that make up the grid
49:56 - I.E the grid cells will then have their
49:59 - positions within the grid altered in
50:02 - accordance with the random positions
50:04 - stored in the card positions array this
50:07 - randomization of their positions
50:09 - was of course caused through the
50:12 - randomization functionality executed
50:14 - within the randomized card positions
50:16 - method
50:17 - so let's create the deal cards method
50:20 - let's create a method named add cards to
50:23 - appropriate so
50:25 - within this method let's call the add
50:27 - card to grid cell method and pass in
50:30 - each card element
50:32 - to the add card to grid cell method
50:35 - within a loop that traverses all of the
50:37 - card elements
50:39 - from within the deal cards method let's
50:41 - call the add cards to appropriate self
50:44 - method
50:45 - so this will in effect restore the grid
50:48 - back to its original state with four
50:50 - cells and each cell containing a card
50:52 - element
50:53 - the grid cells will at this point be in
50:56 - their original order
50:57 - so now let's call a method named return
51:00 - grid areas mapped to card pause this
51:04 - method will return a grid area template
51:06 - value
51:07 - containing a new positional
51:09 - configuration of the grid cells based on
51:12 - the randomized positions now stored in
51:15 - the card positions array
51:17 - this randomization of positions was
51:20 - caused through the execution of the
51:22 - randomized card positions method called
51:24 - from within the shuffle method
51:28 - let's create the return grid areas
51:30 - mapped to codpos method
51:33 - this method simply generates a grid area
51:36 - template that contains a new position
51:39 - configuration for the cells in the grid
51:42 - based on the random positions generated
51:45 - through our Shuffle functionality stored
51:48 - within the card positions array
53:01 - we can then transform the grid as it
53:04 - were to change the positions of the grid
53:06 - cells by assigning the grid the new grid
53:09 - area template value returned from The
53:12 - Returned grid areas mapped to card parse
53:15 - method
53:16 - note that I'm using the back tick
53:18 - characters to envelop the value returned
53:21 - from the return grid areas mapped to
53:24 - codpos method
53:26 - these characters allow us to interpolate
53:29 - a string by appropriately using the
53:31 - dollar symbol and curly brackets to wrap
53:34 - the relevant variables
53:36 - I've included a link in the description
53:37 - for more detail on string interpolation
53:40 - in JavaScript
53:51 - let's comment out the call to the flip
53:53 - cards method so that we can see if the
53:56 - positions of the cards are being
53:57 - randomized by our Shuffle functionality
54:19 - great
54:31 - let's uncomment the call to the flip
54:33 - cards method
54:43 - so let's first remove all the borders
54:46 - and let's also remove the background
54:48 - colors from the grid cells and see what
54:51 - our game looks like
55:22 - great
55:24 - okay so let's create functionality so
55:27 - that when a user makes a choice and
55:29 - clicks on the back of the card that the
55:32 - user believes to be the Ace of Spades
55:34 - that the card that is chosen flips to
55:36 - the front and the user is made aware of
55:39 - whether the user's choice is correct or
55:41 - not
55:42 - if the user's choice is correct the user
55:45 - is awarded points depending on the
55:47 - relevant round number
55:49 - if the user's choice is incorrect the
55:51 - user is awarded no points
55:54 - so we are now going to write the code
55:56 - that executes as a result of the user
55:59 - making a choice as to the card that the
56:02 - user believes to be the Ace of Spades
56:04 - let's first create a method named choose
56:07 - card
56:09 - let's create a method named can choose
56:12 - card which will be called from within
56:14 - the choose card method
56:17 - there are certain states that the game
56:19 - will be in where we don't want the user
56:22 - to click on the back of the cards for
56:24 - example when the cards are being
56:26 - shuffled
56:27 - so we don't want the choose card
56:30 - functionality executed while the shuffle
56:32 - process is in motion as it were
56:35 - so they can choose card method will
56:38 - return a Boolean value to the calling
56:40 - code to indicate to the calling code as
56:42 - to whether the game is in the right
56:44 - state where the choose card
56:46 - functionality can run
56:49 - this expression is basically saying that
56:52 - if the game is in process and the
56:54 - shuffling process is not in progress and
56:57 - the cards are not in the process of
56:59 - being revealed
57:00 - the expression returns true
57:03 - when the expression returns true the
57:06 - user is able to choose a card
57:09 - when the expression returns false the
57:11 - functionality in the choose card method
57:13 - will not be executed if a card is
57:16 - clicked
57:18 - let's declare and initialize the
57:20 - variables involved in the expression
57:23 - we'll set the relevant values for these
57:26 - variables appropriately as we develop
57:28 - the game
57:44 - the next functionality we want to
57:46 - express in code is the evaluation
57:48 - functionality so the code we are about
57:52 - to write evaluates the user's choice so
57:55 - let's write a method named evaluate card
57:57 - choice
57:59 - this method is responsible for
58:01 - evaluating whether the card that the
58:03 - user chooses is the Ace of Spades or not
58:07 - so let's first declare a global const
58:10 - and set its value to the ID of the Ace
58:13 - of Spades which is four
58:16 - let's write an if statement in order to
58:19 - evaluate whether the ID of the chosen
58:21 - card is equal to the ID of the Ace of
58:24 - Spades in both cases we want to Output
58:27 - appropriate feedback to the user
58:30 - if the user's choice is correct we also
58:33 - want to update the score appropriately
58:35 - we'll write the code for the update
58:38 - score method in a bit
58:40 - so let's write a reusable method to
58:42 - Output feedback to the user so if the
58:45 - user hits the target as it were
58:47 - outputs an appropriate message for a
58:49 - winning Choice else output an
58:52 - appropriate message for a losing choice
58:57 - let's declare a global const that
58:59 - references the current status element
59:03 - this is the element that is updated with
59:05 - status information dynamically through
59:07 - our code at appropriate points during a
59:09 - game
59:21 - so let's go to our HTML code and create
59:24 - the current status element
59:47 - if the user guesses the correct card we
59:50 - want to Output text in a green color if
59:53 - the user guesses an incorrect card we
59:55 - want to Output text in a red color
60:11 - let's create a method named update
60:13 - status element
60:23 - at times we only want to make the
60:26 - current status element visible or
60:28 - invisible without updating the relevant
60:30 - elements text
60:32 - so if the calling code passes in only
60:35 - two arguments we can set the display
60:38 - appropriately however if the calling
60:40 - code passes in more than two arguments
60:42 - this indicates that the calling code
60:44 - wishes to update the text of the
60:47 - relevant element
60:49 - and possibly update the color of the
60:51 - element 2. so this is a technique that
60:54 - we can use in JavaScript for method
60:57 - overloading
61:12 - and of course the choose card method and
61:14 - the evaluate card method must include a
61:17 - card parameter
61:19 - so let's write the code for the update
61:23 - score method the update score method
61:25 - calls the calculate score method the
61:28 - calculate score method discovers as it
61:30 - were the number of points to add to the
61:33 - user's score through a call to the
61:36 - calculate score to add method
61:38 - the number of points to add to the score
61:41 - depends on the round number
61:51 - so if the round num variable is 1 add
61:54 - 100 points if the round num variable is
61:58 - 2 add 50 points if the round num
62:01 - variable is 3 add 25 points else add 10
62:05 - points
62:06 - let's declare and initialize three
62:08 - Global variables round num Max rounds
62:12 - although I think this should in fact be
62:14 - a const
62:15 - and score
62:19 - in the initialize new game method let's
62:21 - set score to zero
62:23 - round num to zero and Shuffle in
62:26 - progress to false
62:37 - in the initialized new round method
62:39 - let's increment the round nump variable
62:41 - by 1.
62:43 - let's disable the gameplay button let's
62:46 - set the game and progress variable to
62:48 - true
62:59 - and let's set the card's revealed
63:01 - variable to false
63:03 - if you are not sure about the purpose of
63:05 - all these variables at the moment this
63:07 - will become clear as we develop the game
63:11 - so when around is started we want to
63:14 - update the status of the game in Black
63:16 - text let's call the update status
63:19 - element and pass in the text shuffling
63:21 - dot dot dot
64:00 - when a new round Begins the first thing
64:02 - that happens is the cards are shuffled
64:05 - let's go to our HTML file and add those
64:08 - elements responsible for outputting the
64:10 - score
64:11 - and round number to the user I'm also
64:14 - including a logo image for the game in
64:17 - the same row as the score and round
64:19 - elements which is just a stylistic
64:22 - choice
64:59 - let's create a global const to store the
65:01 - container element for the score
65:13 - let's create a global const to store the
65:16 - score element
65:19 - let's create a global const to store the
65:22 - container element for the round element
65:24 - let's create a global const to store the
65:27 - round element
65:45 - when a new game is started we want to
65:47 - make the score and round container
65:49 - elements visible
65:59 - and we want to update the score and
66:01 - round elements with the appropriate
66:03 - values
66:22 - when a new round is started we want to
66:24 - update the round element appropriately
67:03 - when a card is chosen by the user we
67:06 - want the relevant card to flip to the
67:08 - front so let's call the flip card method
67:10 - from within the choose card method
67:26 - then three seconds later we want all of
67:29 - the cards to be revealed to the user so
67:32 - that the user can see where the Ace of
67:34 - Spades is if the user did not guess
67:36 - where the Ace of Spades was correctly
67:38 - so we are using javascript's set timeout
67:41 - method to ensure that all the cards are
67:44 - flipped front side up
67:46 - three thousand milliseconds or three
67:48 - seconds after the user makes a guess
68:03 - so in order for the choose card method
68:06 - to be executed in response to a user
68:09 - clicking the back of a card we need to
68:11 - attach an appropriate event listener to
68:14 - each card element
68:22 - let's use javascript's add event
68:25 - listener method to ensure that our
68:27 - choose card method is called whenever a
68:29 - card is clicked
69:00 - let's run the code
69:02 - so don't worry about the layout I know
69:05 - the game logo here is huge we'll address
69:07 - the layout and styling issues a little
69:09 - bit later
69:15 - okay there seems to be a bug let's
69:17 - investigate
69:24 - so the issue here is that I've referred
69:27 - to round
69:29 - as opposed to the correct variable name
69:31 - which is round num so this is an easy
69:33 - fix
70:50 - so I need to make a few further
70:52 - modifications to the code to ensure that
70:55 - the choose card functionality works as
70:57 - expected
70:58 - we need to set the shuffle and progress
71:01 - variable to false at this point in the
71:03 - code IE this code executes once the
71:05 - shuffle process is completed
71:08 - at this point we also want appropriate
71:10 - output text shown to the user
71:36 - let's run the code
71:54 - great
71:56 - so
71:58 - to complete the choose card
71:59 - functionality we need to execute
72:02 - appropriate code that tests to see if
72:05 - the final round the fourth round has
72:08 - been reached by the user
72:10 - so let's write a method named end round
72:14 - so let's use the set timeout function to
72:17 - ensure that if the game is not yet over
72:19 - that the next round begins in three
72:21 - seconds or if the game is over that
72:24 - appropriate output text is presented to
72:27 - the user and a new round is not started
72:31 - so if the maximum round has been reached
72:34 - it's game over all rounds of the game
72:36 - have completed
72:38 - let's write a method named game over so
72:41 - when it's game over we want the score
72:43 - and the round number to be hidden and an
72:47 - appropriate game over output message to
72:49 - be displayed to the user notice how we
72:51 - are enveloping the relevant output in
72:53 - bactic characters
72:55 - the backtech characters allow us to
72:57 - include what is known as template
72:59 - literals in our JavaScript code
73:02 - if you'd like to read more about
73:04 - template literals please see an
73:06 - appropriate link that I've included
73:08 - Below in the description
73:34 - let's run the code
73:49 - okay I guessed where the Ace of Spades
73:51 - is correctly but the score hasn't been
73:54 - updated
73:55 - so let's update the code so that when
73:57 - the score changes the score element
73:59 - reflects this to the user
75:15 - excellent
75:31 - so when the game is first loaded we
75:34 - don't want the score and the round
75:36 - number elements displayed to the user so
75:38 - let's update the code accordingly
75:49 - great
76:58 - so we have pretty much completed the
77:01 - mechanics if you like for our game but
77:04 - the layout and style certainly needs
77:06 - attention so let's split our screen so
77:09 - that we can see our code editor next to
77:11 - our browser window let's go to our CSS
77:14 - file
77:15 - so let's update the header element so
77:18 - that the display is flex and the flex
77:21 - direction is set to column this
77:23 - positions its child elements one on top
77:25 - of the other as opposed to the default
77:28 - Direction which presents the elements
77:30 - next to each other on the same row
77:34 - and let's give the margin bottom
77:36 - property a value of 10 pixels
77:42 - let's style the header Dash title Dash
77:45 - container element and use the flexbox
77:47 - CSS functionality to Center our heading
77:51 - text
78:00 - great
78:01 - so let's use the flexgrid functionality
78:04 - for the display of the header Dash round
78:07 - Dash info Dash container element
78:10 - so that the image logo the score the
78:13 - round number are spaced evenly on the
78:16 - same row
78:18 - we'll see the effect of this styling
78:20 - code a little bit later
78:23 - so let's give all elements contained
78:25 - within the header Dash round Dash info
78:27 - Dash container element a width of 150
78:31 - pixels
78:44 - so let's horizontally and vertically
78:46 - Center all of the elements contained
78:48 - within these elements by using the
78:50 - flexbox functionality
79:14 - so that Ace of Spades image you are
79:16 - currently seeing is of course way too
79:18 - big so let's give it a height of 75
79:21 - pixels
79:25 - great
79:34 - let's round the corners of the image
79:37 - logo by setting its border radius
79:39 - property appropriately let's add in a
79:42 - border
79:47 - great
79:49 - and let's give the image a box shadow
80:01 - excellent
80:02 - lastly let's rotate the image minus
80:05 - three degrees
80:10 - great
80:13 - that looks pretty good
80:43 - let's add some color related variables
80:45 - to our CSS file
81:00 - let's style the badge class
81:03 - so that our score and round number text
81:06 - stands out
81:33 - excellent
81:34 - that play button really needs to be
81:37 - styled so let's go to this URL where we
81:40 - have a selection of button styles to
81:42 - choose from
81:49 - I like this one so let's press the
81:51 - relevant button to copy the relevant CSS
81:53 - style code to our clipboards let's paste
81:57 - the code into our style.css file
82:00 - and update the code appropriately so
82:03 - that the relevant code relates to our
82:05 - play game button
82:59 - great
83:12 - I want to use a particular Google font
83:15 - for this application
83:16 - so let's go to this URL here and let's
83:19 - copy the sample code for importing a
83:22 - font into our application from within
83:24 - our CSS stylesheet file
83:36 - then let's appropriately update the
83:38 - relevant import code
83:40 - so that we are importing the quicksand
83:42 - font
83:43 - let's create a variable to reference the
83:46 - relevant font family value
83:55 - let's set the font family property of
83:58 - our body element to the variable that we
84:00 - have just created
84:02 - great
84:04 - let's make the font size for the current
84:07 - status element bigger
84:10 - great
84:11 - let's align the text for the current
84:14 - status element centrally
84:22 - great
84:29 - the first animation I'd like to create
84:31 - is the shuffle animation
84:33 - at the moment during the shuffle process
84:36 - the cards are stacked one on top of the
84:38 - other and are motionless let's create
84:41 - the illusion through our Shuffle
84:43 - animation that the cards are literally
84:45 - being shuffled
84:47 - let's create a method named animate
84:49 - Shuffle that contains a parameter
84:52 - a numeric argument will be passed to
84:55 - this parameter which will be a numeric
84:57 - value that is incremented for every time
85:00 - the shuffle function is called
85:03 - let's create code to generate two random
85:05 - numbers between one and four
85:08 - let's reference two cards of our four
85:10 - cards randomly through the two random
85:13 - numbers that we are generating in this
85:15 - method
85:16 - then we can modify the positions of the
85:19 - cards and the relevant card elements Z
85:22 - index properties through code like this
85:26 - the mod function represented by the
85:28 - percentage character that I'm using in
85:31 - the first if statement
85:32 - means that when the result of the
85:34 - shuffle count value divided by 4 does
85:38 - not have a remainder then code will
85:40 - execute to toggle the shuffle left class
85:43 - for the relevant card element
85:46 - the mod function I'm using in the second
85:48 - if statement
85:49 - means that when the result of the
85:52 - shuffle count value divided by 10 does
85:55 - not have a remainder then code will
85:57 - execute to toggle the shuffle right
85:59 - class for the relevant card element
86:02 - the card elements are of course selected
86:04 - by our code at random this will create
86:07 - the illusion that the computer is
86:10 - shuffling the cards
86:11 - let's write the code that calls the
86:13 - animate Shuffle method from within the
86:16 - shuffle method
86:32 - let's create the CSS code for the
86:35 - shuffle left class
86:47 - and the shuffle right class
86:51 - and you can see that we are simply
86:53 - altering the positions of the cards
86:55 - through the shuffle left class and the
86:58 - shuffle right class
87:01 - you can of course play around with the
87:03 - various settings related to the shuffle
87:05 - animation until you are happy with the
87:07 - animation effect
87:09 - once shuffling is completed we want to
87:12 - make sure that none of the card elements
87:14 - contain the shuffle left clasp or the
87:17 - shuffle right class
87:53 - and that shuffle effect is not happening
87:56 - right so the reason is we need to
87:59 - include transition code for our card
88:02 - elements in the CSS file like this
88:13 - and I think that is a pretty good
88:15 - Shuffle effect but please play around
88:16 - with the relevant values and see if you
88:19 - can create an even better Shuffle effect
88:39 - the next animation effect that I want to
88:42 - create is for when the game is first
88:44 - loaded I want the cards to fly in from
88:47 - the top left hand side of the screen to
88:49 - their positions on the grid let's create
88:52 - a CSS class named flyian
88:55 - that will position the card elements
88:57 - appropriately off screen
88:59 - when the fly-in class is removed through
89:03 - our JavaScript code the card will move
89:05 - to its original position on the grid
89:07 - which ultimately results in a sort of
89:09 - fire and effect
89:12 - let's create a method named cardfly and
89:15 - effect
89:16 - that removes the fly in class from the
89:19 - card elements add controlled time
89:22 - intervals we are using the JavaScript
89:25 - set interval method to call the fly-in
89:27 - method at a predefined interval
89:38 - then we are further controlling when the
89:41 - fly and class is removed from the
89:43 - relevant card element
89:44 - through the use of an if statement
90:02 - we want to fly an effect
90:05 - to be executed when our game is first
90:07 - launched so let's call the fly and
90:09 - effect method from within the load game
90:12 - method
90:13 - let's add code so that the fly in CSS
90:17 - class is added to each card when each
90:20 - card is first created so to do this we
90:23 - can call code to add the fly and CSS
90:26 - class to the card element from within
90:29 - the create card method
90:43 - excellent the last animation effect I'd
90:46 - like to create is I want the gameplay
90:49 - button to not be visible when the game
90:52 - first loads but then slowly fade in once
90:55 - the fly-in animation effect has
90:58 - completed
91:02 - let's include keyframe functionality
91:05 - within our CSS file that controls the
91:08 - opacity of the relevant element
91:14 - let's then add this animation to our
91:16 - play game button element like this
91:31 - let's initialize the gameplay button to
91:33 - be invisible when the game is first
91:36 - launched
91:37 - then let's set its display CSS property
91:40 - to inline block after the fly and
91:43 - animation effect completes
92:06 - great but I want the height of the
92:08 - container to be static so let's set the
92:11 - height of the gameplay button container
92:13 - element within our CSS file
92:16 - I've also given this element a set width
92:32 - excellent
92:42 - so I've created our game so that it
92:44 - looks pretty good on desktop screens but
92:47 - what does our game look like on smaller
92:50 - screens like for example what would our
92:52 - game look like on an iPhone 12
92:55 - it looks pretty good as it is on smaller
92:58 - screens because we are using CSS flexbox
93:01 - and grid functionality for the layout of
93:04 - our game
93:05 - but we could improve our layout for
93:07 - smaller screens so to make our
93:10 - application layout responsive for
93:12 - smaller screens let's include an
93:14 - appropriate media query within our CSS
93:16 - file
93:19 - so we want certain CSS classes to be
93:21 - dynamically modified in response to a
93:24 - smaller screen size
93:27 - so let's say that when our screen size
93:29 - is 600 pixels or less
93:32 - we want our layout to respond in a
93:35 - certain way
93:36 - at this smaller screen size we can for
93:39 - example make our cards smaller like this
94:59 - we can also adapt our card container
95:02 - element to respond appropriately to
95:04 - smaller screens with code like this
95:19 - let's make the height of the main
95:21 - element a bit smaller
95:26 - let's make the current status element a
95:28 - bit smaller
95:32 - let's make the gameplay button a bit
95:34 - smaller
95:54 - and let's also make our game logo image
95:57 - a bit smaller
96:07 - let's check the responsiveness of our
96:10 - application through our Chrome browsers
96:31 - excellent
96:48 - so our game is pretty much complete but
96:51 - I'd like to include functionality so
96:54 - that if a user closes the browser for
96:56 - some reason before the user has
96:58 - completed a game that the user is able
97:01 - to resume the same game
97:03 - when the game is launched at a later
97:06 - point in time
97:08 - the way we are able to create this
97:10 - functionality is by using local storage
97:12 - this allows us to persist data to our
97:15 - browser
97:16 - through our JavaScript code when the
97:19 - browser is closed the data stored in
97:21 - local storage is not lost and can't be
97:24 - retrieved from local storage through
97:27 - JavaScript code at a later time when the
97:30 - relevant game or application is launched
97:32 - in the user's browser so firstly let's
97:35 - write a few reusable methods to abstract
97:38 - common local storage related
97:40 - functionality
97:52 - so let's create a method named get
97:55 - serialized object as Json
97:58 - so we are going to persist an object to
98:01 - local storage in Json format
98:04 - so when we pass an object to this method
98:06 - it will return a string value in Json
98:09 - format that represents the object passed
98:12 - into this method
98:14 - we will then be able to save the return
98:16 - to string to local storage
98:19 - let's create a method named get object
98:21 - from Json
98:23 - when we read the Json formatted string
98:25 - from local storage
98:27 - we are going to want to convert the Json
98:29 - string back into a JavaScript object
98:33 - so that we can use the object in our
98:35 - JavaScript code
98:37 - let's create a method named update local
98:40 - storage this method saves a key value
98:43 - pair to local storage
98:46 - you can see the first parameter is the
98:48 - key which is the unique identifier for
98:51 - the value that will be passed into the
98:54 - second parameter which will of course be
98:56 - a string in Json format representing a
98:59 - JavaScript object let's create a method
99:02 - named remove local storage item
99:06 - this method of course is used for
99:08 - removing a local storage item
99:11 - let's write a method named update game
99:14 - object the object that we are going to
99:16 - persist to local storage contains the
99:19 - score and the round number pertaining to
99:22 - the relevant game this method can be
99:24 - used to update the relevant game object
99:27 - the game object object where the score
99:30 - and the round number will be stored will
99:33 - have Global scope
99:36 - then let's create a method that will
99:39 - handle saving the game object to local
99:42 - storage
100:16 - let's create a unique key
100:18 - to identify an incomplete game in local
100:22 - storage
100:26 - let's create a method named check for
100:29 - incomplete game the this method checks
100:31 - local storage for a unique key
100:34 - if the relevant key exists in local
100:36 - storage that means the user has data for
100:39 - an incomplete game saved to local
100:42 - storage
100:50 - oops I forgot to create a helper method
100:53 - let's create a method that returns a
100:55 - value
100:56 - from local storage based on the key
100:59 - argument passed into this method
101:17 - if the relevant local storage item
101:19 - exists
101:28 - we want to ask the user if the user
101:30 - wishes to continue with the relevant
101:32 - unfinished game
101:34 - so we are going to use the confirm
101:36 - JavaScript dialog for this purpose
101:40 - if the user presses the OK button
101:43 - then our code will update the game with
101:46 - the score and round number from the
101:48 - previous incomplete game saved to local
101:51 - storage else the score and round number
101:54 - will be initialized to zero which means
101:56 - the user has chosen to start a new game
101:59 - so let's call the check for incomplete
102:02 - game method from within the initialize
102:04 - new game method
102:06 - let's write the code that saves the data
102:10 - pertaining to a game after the user has
102:13 - selected a card
102:20 - Let's test the code
102:59 - excellent
103:01 - if you liked this video please hit the
103:03 - like button and please feel free to
103:05 - share this video with anyone you feel
103:07 - May benefit from its content
103:10 - for Content like this and much more
103:12 - please consider subscribing and please
103:14 - ring the bell so that you'll be notified
103:17 - of future content
103:27 - the code created in this tutorial can be
103:30 - downloaded from GitHub please see the
103:33 - URL for the relevant GitHub repository
103:36 - Below in the description thank you and
103:38 - take care