00:00 - You are about to learn how to use .NET 5 to
create a Rest API. The creator of this course
00:05 - is a Senior Software Engineer at Microsoft
and he is also an excellent teacher.
00:10 - REST API allows your app or system to expose
its functionality to multiple types of clients
00:14 - both inside and outside of your network, including
clients across the internet. This is what
00:20 - you would use if you wanted to write a program
to collect data from say, Twitter, Yahoo,
00:24 - finance, or even NASA. If you're looking into
building your own REST API, and you're considering
00:30 - the dotnet platform for it, please stay with
me, as I show you how to do this end to end
00:35 - using the latest innovations provided by dotnet.
Five, I hope you enjoy it.
00:42 - In the first part of this tutorial, you're
going to learn the scenario to be used across
00:47 - a tutorial, how to create a dotnet five Web
API project from scratch,
00:53 - how to use Visual Studio code for building
and debugging the project, we're going to
00:58 - work on
01:00 - how to draw the development certificate installed
by dotnet. Five, and that's going to be needed
01:04 - for HTTPS access
01:08 - and how to use swagger UI to interact with
the API.
01:11 - To follow the tutorial, you're going to need
a few things, including the dotnet, five SDK,
01:19 - Visual Studio code
01:22 - and some basic understanding of the C sharp
C sharp language.
01:28 - Now let's talk about this scenario that we're
going to be using as a domain for this tutorial.
01:36 - So let's imagine that we have some sort of
a catalog system. And we have a bunch of items
01:42 - available in it. So in this sense, like I
am, video, video gamer, so I like to think
01:48 - of these items as items that I will use within
a video game. So items like potions, swords,
01:52 - shields and stuff like that. Right. So that's
a system that we have in place, it has a catalog.
02:01 - And of course, we're going to have users that
are going to be a would like to banish this
02:07 - catalog via their, their browser, right? They
have a browser, they want to manage these
02:12 - catalog items, somehow.
02:15 - So these are they would they would like to
do is well, how are we going to create items
02:20 - in the catalog? A How can we retrieve the
list of items currently available in this
02:26 - catalog? hunka. We update properties of the
items. And how can we delete items in this
02:33 - catalog. So as it is today, we do have the
catalog available. But we lack we don't have
02:42 - a way to expose this catalog to the internet
so that people can use go ahead and manage
02:47 - it from the browser. So that's where we're
going to introduce our REST API for this catalog.
02:52 - And during this tutorial, we're going to see
how to build this REST API from scratch using
02:58 - dotnet. Five.
03:02 - So here we are in business to recode. And
the first thing we're going to do is open
03:06 - a brand new terminal. And this terminal, we're
just going to switch to the directory, where
03:12 - we're going to create our project and create
a project, we're going to be using the dotnet
03:16 - CLR.
03:18 - So to do that, we're just going to say that,
that new and the type of product that we want
03:23 - that we want to create for our REST API, that's
going to be Web API. And the name of the project
03:29 - is going to be catalog, hit Enter.
03:33 - And that creates your race all the files,
face it on the web API template. So now I'm
03:37 - going to open that folder that got generated,
catalog.
03:44 - And a, as you open a as usual, as you open
a dotnet project in Visual Studio code, it
03:50 - will prompt you to add a few additional files
for building and debugging the project. So
03:53 - I'm going to say Jess, and those files get
d rated under Ws code. So the left side, you
03:59 - can actually see all the generated files.
And let's take a quick look at each of these
04:03 - files
04:05 - as a quick lack of love around. So the first
part we're going to look at is the ACS proc
04:10 - file. This file is used is this is called
the project file. And this is used to declare
04:15 - how we're going to build this project. In
this case, we're saying that we're going to
04:18 - be using the dotnet web SDK to build the project,
which includes a bunch of tools and tasks
04:24 - to specifically designed for web kind of projects.
The next interesting thing will be the target
04:30 - framework, a monitor or target framework,
which in our case is net five. The target
04:35 - framework defines the API's or face or what
kind of API's are going to be available to
04:41 - your project. In this case that five is perfectly
good for us. And the next thing is going to
04:46 - be a bunch of nougat packages that we're not
going to be diving into right now. But those
04:51 - are just dependencies that we already acquired
on this project. Close that and the next we
04:58 - are going to take a look at this program.
See
05:00 - His pronunciation is what we call the entry
point of the application. And what this will
05:04 - do is just pretty much race or stand up the
host. That I mean, the process is going to
05:11 - become the host of our problem. And it also
declares a bunch of defaults. And it also
05:17 - sets up what we call the startup startup class
for our project. So let's actually go to a
05:24 - startup and see what's going on there.
05:26 - Really, the main things and startup are that
05:31 - we have this property called configuration
that we receive as part of the startup constructor.
05:37 - This is you can use anytime you need to read
some configuration information from multiple
05:41 - sources, like from a environment variables
or files, different kinds of files, or a bunch
05:47 - of other places, a configuration that you
don't want to hard code is your service. The
05:52 - next interesting method is configure services.
And this is the place where you would
05:57 - register all the services that you're going
to be using across your application. And we'll
06:02 - talk about this later on in this video. And
the last interesting piece is the Configure
06:08 - method.
06:10 - This is where we configure what we call the
a
06:12 - pipeline that a request pipeline on ASP. net.
And so this just defines a bunch of typical
06:21 - middlewares, which are
06:22 - additional components that will execute before
your, before your, your controller or your
06:32 - your code actually executes. So each of the
each of these can execute
06:36 - as a request comes into, into the ASP. NET
process. And from there all the way into when
06:45 - your code executes. But we're not going to
be exploring this part in this video.
06:50 - A couple of other things are so we have a
weather forecast. So this is a model that
06:57 - gets out generated for this sample application
here just have a few very simple properties
07:02 - here. And alongside this a this model, there's
a controller. Now the controller in ASP. NET
07:11 - is just pretty much the class that handles
the route.
07:16 - Yeah, pretty much the routes that a your service
exposes, right, but we're not going to be
07:23 - using these in this video. So let's not dive
too much into that.
07:26 - A few other files a upsetted. json, this is
where you can declare configuration, that's
07:32 - going to be that you don't want to use hardcoat
into your, into your, your program your your
07:37 - source code. So And right now, it just has
some configuration for logging and the wholesaler
07:43 - allowed in the app. There's also a variant
of appsettings JSON, which is absurd in development,
07:48 - Jason. So development, I mean, the fact that
is that says a does say upsetting start developing
07:54 - that JSON means that we're running in development
environment,
07:59 - these settings will take precedence on top
of the opposite is Jason. So you could have
08:03 - a bunch of these appsettings files for each
of your environment like production, test
08:07 - integration, all of these environments.
08:09 - And I'll be talking about environments may
be a good time to take a look at the files
08:15 - era that VS code, which are a task Jason and
logic a lot Jason does, Jason is just a file
08:21 - that declares the tasks with these key concepts
and pieces to your code, you can declare tasks
08:27 - and a task is can be a bunch of things. And
in our case, the most interesting does is
08:32 - the fact that we want to use run the dotnet
build command. So dotnet build, which is going
08:37 - to be used for building our code. And in terms
of launch the JSON, this is the file that
08:43 - controls what is going to be launched or executed
when we do like an f5. Or when we start debugging
08:49 - the code in this case is already pointing
to the right DLL for start to start debugging.
08:54 - Lastly,
08:56 - we also have launch settings. So Jason are
really the only interesting part here that
09:00 - they're like to take a look at is the application
URL. Here we are defining the URLs, URLs Imperial,
09:08 - for our application, in which case in this
case, we're saying we're going to be serving
09:12 - our server in localhost 5004, the HTTPS version
will be serving in which is going to be the
09:21 - default version is going to be 5001. We also
declaring the actual a, a spinet core environment
09:28 - environment variable. And we're setting it
as development. And so
09:32 - also, in business to the code. This is not
the actual one that's been harder the one
09:38 - that will is going to be harder eating lunch,
Jason. As you see over here. This is the one
09:43 - that takes precedent if it was to recode.
So so that's good.
09:48 - Well want to do now is actually to test this
this project just to make sure that everything
09:54 - is running as expected. So what I'm going
to do is I'm going to switch to the debug
09:59 - hub.
10:00 - Hear me expand this a little bit. And so what
I would do is just click and start working.
10:06 - Let's see what happens.
10:09 - Right. So a browser pops up. And then if you're
getting these page here, a, what it means
10:20 - is pretty normal, it means that we don't have
the self signed certificate that goes without
10:26 - net, it has not been trusted. Right? So there's
a very simple way to go around decision and
10:34 - to properly trust the survey that comes with
dotnet. So let me actually just close this,
10:40 - and stop. And let's switch back to the terminal.
The actually let me open up a new terminal
10:47 - here. Yeah, there it is.
10:51 - So in order to trust a certificate that comes
bundled with the dotnet SDK, what you have
10:56 - to do is just type dotnet, def cert, https
11:05 - trust.
11:07 - When you run this, you're going to get this
pop up, asking you to confirm that you actually
11:11 - want to trust that cert, I'm going to say
yes. And then that we should do it. So I'm
11:18 - going to run it again.
11:22 - Let's see what we get.
11:28 - Alright, so yeah, so we still are not getting
pretty much anything here. But we are not
11:33 - seeing any trust issue anymore. Now if what
we want to see something meaningful here,
11:38 - although it doesn't matter too much for us
at this point, what you can do is just go
11:42 - to swagger.
11:44 - And then you're going to get this this nice
UI. So this is what we call swagger are also
11:48 - an open API specification. So this is a component
that is bundled now with dotnet, five, so
11:55 - you don't have to do anything to make it available.
As you saw, we did nothing. So it's just there.
12:01 - In the slash swagger URL. What this does is
allows you to easily describe all the operations,
12:10 - all the actions, all the routes that are available
in your API, and allows you to also interact
12:14 - with them easily. So for example, if I just
go to the get route, and I click a trade out,
12:20 - click Execute, it will go ahead and run it.
And we can see already some results for that
12:26 - route.
12:31 - And then one thing that I like to do as I
work on these projects, is to really not open
12:37 - the browser every single time that I run the
project. So let's actually switch a little
12:43 - bit the behavior of VS code so that we just
keep this window open. And then anytime we
12:49 - just hit f5, or hit Run, it will not open
more windows. So to do that, I'm going to
12:55 - stop here. And we can go to launch the JSON
and close this.
13:04 - The only thing that you have to do is just
remove this server Ready Action section here.
13:10 - And that's pretty much it. If I run again,
and by the way, you can do this by just pressing
13:15 - f5,
13:17 - which I'll do right now, five.
13:22 - That starts to host, as you can see, but we
did not he did not open any more windows,
13:27 - which is fine. Because we have the browser
ready to call right there.
13:34 - Then the last thing that I like to do in terms
of a practice set up is to simplify how we
13:38 - build our project in pieces to record. So
for that, let me minimize this and go back
13:43 - to business to recode. Stop this, close that
out I'm going to do is to go to data Jason.
13:49 - And the only thing that I'm going to do is
to add this little section here under the
13:57 - build task, which is just the what we call
the group, which is going to build and it
14:03 - says is default true. What this does is that
allows us to more easily build a project.
14:08 - So now I can go to let me just save this saved.
I can go to terminal room built tasks and
14:17 - immediately builds. Without that, we're able
to just have a pop up yet another menu to
14:23 - do the build. I can also now do Ctrl Shift
B and it will do the same thing. So yes, that
14:28 - just speeds up our situation.
14:31 - In the second part of the net five REST API
tutorial, we introduced the foundations of
14:37 - our API, which includes the core entity used
to represent the items in your catalog, the
14:42 - repository class responsible for all items,
storage related operations, and the controller
14:47 - that will handle all the requests sent to
a REST API.
14:50 - Here you will learn how to model an entity
via C sharp record types.
14:57 - How to implement an in memory repository.
15:00 - Sources
15:02 - and how to implement a controller with get
route to retrieve resources.
15:06 - Alright, so now that we are comfortable with
the initial setup of our project, it is time
15:14 - to start setting up the the entities and a
repository that's going to be used to a store
15:22 - and retrieve the items that are going to use
it across a service. So the first thing we're
15:27 - going to do is well, let's actually just close
these and the terminal. And let's get rid
15:32 - of a few of these classes that really make
no sense for our project. So I'll just delete
15:37 - weather forecast here. And I'll delete the
weather forecast controller. So we can start
15:43 - cleaner than that.
15:45 - So let's introduce our entity, the item entity.
So for that, let's add a folder here called
15:51 - entities. So people will say domain, as a
lot of people may see models, in our case,
15:58 - entities should be good enough. Let's create
a file here, let's call it
16:02 - item. That's Yes.
16:05 - Let's follow the right namespace here.
16:10 - So the next page should be catalog as he's
wearing the ntds folder, let's say entities.
16:17 - And then
16:19 - what you would usually do at this point is
declare a class, right, so you would say public
16:26 - class and let's say it. However, since a dotnet,
five and a C sharp nine, there's a new option
16:33 - here for you, which is what we call the record
types. So record types are pretty much a pretty
16:39 - much classes. But they have better support
for immutable data, immutable data models,
16:46 - right, which means that once you get a one
instance of this object, it is not possible
16:50 - to really modify it. And that's pretty convenient,
especially for objects that you receive over
16:55 - the wire. So all of these are coming from,
from the web, usually use one to take them
17:00 - and do something with them, but you don't
want to modify them. Right. Also, record types
17:07 - have this thing called with expression of
who you're going to see later on in this tutorial.
17:11 - And then also a provide ability to compare
based on a value. So validated equality is
17:18 - what they call, which this means that
17:21 - when you compare a two instances of these
a of an item, in this case,
17:27 - those instances will be equal, only if all
of the properties of that instance are the
17:32 - same, as opposed to just the identity of the
object itself, which will be the case of classes.
17:38 - So record types are pretty handy, I think
are a great option for the for the objects
17:43 - that we're going to be using here, over here.
So
17:45 - let's switch class for record. There, it is
time to introduce the properties for this
17:54 - record. So let's add just a few properties
here. So let's see. So let's use a good for
18:01 - our ID.
18:03 - And let me import that system, your system
namespace was missing there. And then before
18:10 - adding more properties, let me actually make
a small change here. So instead of using Get
18:14 - set, let's switch to it. So why you seen it.
This is another addition in the in C sharp
18:21 - nine in dotnet. Five, which it's a great fit
for,
18:27 - for a property initializers. That where we
want to only allow a setting a value during
18:37 - initialization, right. So this means that,
for instance, in the past, you could say you
18:42 - could say, Get set. What this means is that
after you create the object, you can just
18:48 - modify in this case, the ID a time. So that's
not really desirable, we want an immutable
18:53 - property. So for immutable, we will have to
set
18:58 - privates, right. So yeah, so this makes it
immutable. But now it is pretty challenging
19:02 - to construct any set of these objects. Now
we have to introduce a constructor. And then
19:06 - our customers don't have a really nicer way
to go through our objects. So to get into
19:13 - a good middle ground there, they introduced
the the init accessor here. So this means
19:20 - that
19:21 - you can use a creator creation expression
to construct this item object, as you will
19:28 - do with a with a set. But after the creation,
you can no longer modify these property. So
19:35 - it's a very nice a balance between the two
words in there. I will see how this plays
19:41 - out later on. So at this point, let's just
define our properties. So let's see. Let's
19:47 - add Of course, name.
19:51 - Name.
19:52 - It's great to be studying name
19:57 - Oh,
19:58 - Also in it, let's add,
20:03 - let's add a price for our item.
20:10 - Price, also in it.
20:17 - And finally,
20:19 - let's add
20:22 - a time offset. This is
20:27 - great.
20:29 - So this is going to be the date and time where
the item got graded in the system. Let's also
20:35 - not forget to change this to it.
20:41 - Now it is time to introduce our repository,
which is the class that is going to be in
20:44 - charge of storing the items in the system.
To keep things simple For now, we will only
20:49 - use an in memory repository. And a few episodes
later in the tutorial, we will bring in a
20:54 - proper database.
20:56 - So let's create a new folder here called depositories.
21:04 - And here, we will add a new file. Let's call
it
21:07 - hidden man itemtype was 30.
21:19 - The writing space here not forget that it's
going to be catalog that people see 30s.
21:26 - Right.
21:29 - And now, let's create a class. So
21:31 - holy class, I'll just grab the name from the
main file.
21:40 - Right?
21:41 - We're going to do here, like I said, this
is in memory. So we're just going to define
21:45 - a very simple list of items that
21:48 - are going to be the initializers that we're
going to be working with. So let's declare
21:54 - a lease here. So let's see write rate and
make it read only because it should not change.
22:01 - I mean, the instance of the lease should not
change after we construct this repository.
22:07 - object.
22:08 - It's good to be a list of item
22:11 - we used to fight him.
22:15 - And I think,
22:16 - yep, so these the item items.
22:23 - And yes, we need to import the
22:26 - couple of namespaces their collection generic
for the least. And that other entities for
22:31 - the item.
22:33 - And we want to say this is new.
22:37 - And we want to declare the list. Now these
one another addition in C sharp nine.
22:43 - As you see here in the past, you may have
needed to say okay, so this is new list of
22:48 - item, right? But that's a bit redundant. Since
we already know clearly this is a list of
22:53 - item. So why, why so much ceremony, so let's
just remove this. And that's all you need
23:00 - to do at this point. So nice addition, C sharp
nine.
23:05 - So let's add a few items here. So let's say
new item.
23:10 - And let's, let's do
23:12 - the initialization here. So let's just do
random go it.
23:19 - You go it for the ID. Again, let's import
the museum a space. And so for the name. And
23:28 - so
23:29 - like I mentioned in the introduction, I like
to play with these ideas in terms of video
23:34 - game items. So the first item that I'm going
to choose here is abortion. Super classic
23:39 - in these video games. And let's say the price
for that one is going to be just nine. And
23:46 - for created date. Well, I'll just say
23:51 - they offset
23:53 - it etc. Now. So that means right now in terms
of UTC, so not the local time, just the UTC
24:01 - time.
24:02 - And do assess we need these one, let's add
a
24:07 - couple more.
24:09 - So same a good. I mean, get a new GUI for
each of these ones. But let's call this one.
24:16 - It's going to be a idles word, resort. And
let's say it's going to be more expensive.
24:24 - Make it 20. And then for the last one, let's
say we're going to do
24:28 - rose shoot.
24:30 - Got to be a bit cheaper, let's say.
24:35 - All right. Oh, there is we have our initial
list of items ready to go.
24:42 - Now in this repository, we're going to have
to deal with a bunch of things, right. So
24:47 - how do we get an item? How do we get a collection
of items? How do we create an item update,
24:51 - delete all these things. So to get in simple,
let's start with a get. So we're going to
24:56 - do to get metals here.
24:58 - The first one is going to be get items for
getting items if we're going to do, we're
25:04 - just going to return an ienumerable of item.
25:08 - items. Right? So a nominal is pretty much
the very basic item, it is a basic interface
25:16 - that you can use to return a collection of
items.
25:22 - And then yeah, that's always got to be as
simple as say, well, as yours return, whatever
25:26 - we have in items right now, it is
25:30 - that sort of get items method. And the next
one is going to be similar. But this guy is
25:35 - going to return just one item, it's going
to be named get item.
25:44 - But this is going to need to know the ID of
the item to return. Right?
25:50 - Start. And then. So in order to retrieve the
correct item, what we're going to do is you
25:56 - say Okay, so let's return from the items collection.
26:02 - And I'm going to say where these requires
important yet another namespace sit in that
26:07 - link importing now.
26:10 - And so we're going to say, okay, so from that
list,
26:14 - where the item
26:15 - ID
26:18 - equals the ID that we got in the parameter.
26:25 - And that's going to return a collection. But
we don't want the collection, which is one,
26:29 - the one item that that he should find all
the folder where the file is going to be?
26:33 - No. So if it finds the item, it will return
it. If it doesn't find it, it will return
26:36 - null.
26:37 - All right, so that makes up our repository.
And so the next thing to bring in is controller.
26:45 - So like I said, the controller is going to
be a the class that receives a request that
26:50 - has been sent by the client and handles it
properly. So let's add our controller class
26:58 - then. So new file under the controllers, folder,
and
27:02 - scenes, the reasons we are dealing with here
is a items. So the convention will be to just
27:08 - name it. Items controller.
27:11 - That's Yes. Right. And again, security right
namespace catalog, in this case is going to
27:21 - be controllers, controllers. Alright.
27:25 - So this controller is going to be
27:26 - all the class items controller. And then the
interesting thing about controller classes
27:34 - is that you always want to inherit from controller
base
27:39 - that gives you and this also important namespace
here.
27:44 - So that will effectively turn this into a
controller class, right? So let's always inherit
27:49 - from controller base.
27:50 - That's the first thing. The next thing is
to mark this class as an API controller. Right
28:00 - there. Yeah, API controller. So this brings
in a bunch of additional default behaviors
28:06 - for your controller class, that just makes
our life easier. So yeah, don't forget to
28:11 - add API controller layer. And yeah, and by
the way, there's tons of documentation on
28:15 - each of these a attributes, or the
28:20 - next thing is to declare the route. So the
route defines a, to which a HTTP route, this
28:28 - controller is going to be responding. And,
28:32 - by default, what you would put here is just
the name of the controller. So if you do this,
28:39 - this will mean that whatever the name of the
controller is, that's going to be the route.
28:45 - Right? And so in this case, for instance,
let's say for a get,
28:51 - it will do get slash items, right? That's
going to be part of the URL that we'll be
28:58 - using.
28:59 - So yeah, I mean, you can do it either that
way. Or you can explicitly declare a route
29:04 - that you want to use, like, I could say, two
items, which is perfectly valid. And in fact,
29:09 - let's stick with that.
29:13 - And let's move forward.
29:15 - Now, here in this controller, of course,
29:19 - for any action, or any operation we're going
to do, we're going to be needing that repository
29:25 - that we worked on a moment ago. So let's bring
in an instance of that. We're going to declare
29:30 - private read only.
29:31 - Again, because it's not going to be modified
after construction.
29:39 - I suppose seat 3030. Right. And
29:46 - Yep, for any space we have ready. Now, before
moving forward. Let me just tell you that
29:53 - we'll be making a few not so ideal choices
as we move forward. Just to explain that
29:59 - A bunch of concepts, right? So the fact that
I'm introducing explicit dependency into i
30:04 - ng meme it suppository.
30:07 - It's, it's not ideal, but I just want to do
to keep things simple and then improve as
30:13 - we move forward. Right? So those just don't
take this as a final word on how you should
30:17 - do this. Now, we're going to construct these
in the in the constructor of this controller.
30:24 - So let's add a
30:25 - high def controller as the constructor.
30:29 - Okay, and then let's say yeah, so double storey
30:33 - equals new name. It was, right. So boom, we
have a suppository right there, ready to be
30:43 - used? So let's define our route state to find
a route. So let's see. How do we find a route
30:49 - to retrieve all the items? On this storage?
let's declare a method called
30:53 - Hi enumerable.
30:58 - Item? Sorry, item, get items.
31:05 - Okay, so these are methods that's going to
return an ienumerable of items just like the
31:12 - repository. Let's import the right namespaces.
Are we missing here?
31:17 - Okay.
31:18 - But then also, in order for, for this method
to actually become a route and react to some
31:26 - HTTP verb, you have to declare it the right,
the right attribute in this case, HTTP GET
31:34 - is what we what we want to declare for this.
So by doing this, it means that when somebody
31:39 - goes to perform a get against slash items,
this is a method that's going to be reacting
31:46 - to that, right? I do see how
31:48 - a few cases we pretty much have the same route,
but it is the verb that makes a distinction
31:56 - into which method is going to be invoked.
Then what do we do in this HTTP GET? So fairly
32:04 - straightforward, we're going to say, Okay,
so we have items is going to be a depository.
32:11 - You remember, we created these get items method.
So we just invoke it, we have the items, and
32:16 - then we return the items.
32:20 - And that's all it is.
32:23 - Okay, so with that, we should be able to test
this out and see how that goes. So I'm going
32:29 - to hit f5 here.
32:35 - Alright, going to go back to swagger. And
I'm going to use refresh the page that we
32:41 - get open from the previous video. As you can
see, everything got refresh. Now there's no
32:45 - more weather controller. Now we have an item's
controller. And we have our first route here
32:49 - we use a get for items.
32:51 - We not only that, we also have a schema that
describes a an item, how it will be laid out.
32:57 - If we click on items. And let's see, try it
out. Let's see what we get.
33:06 - And right here, as you can see, swagger will
show the the router boot executed, like we
33:12 - said, it's a get on slash items. This this
is here, this is our host and the port. So
33:18 - against localhost 5001 items. And
33:22 - here's the result. So we have our three items
that we declared as static. Well, the initial
33:29 - value for our items collection, right? Or
the potion, the sword and the shield, right?
33:34 - This is working great.
33:38 - Stop this and add our second route, which
is a route to return one specific item. So
33:45 - this is going to be public
33:48 - item, get item and then we receive good, right?
33:57 - And then are we missing any space? Again,
let's see. Yes, focusing in a space. That's
34:02 - where it is. And then just like before, we
just say, well, var item equals repository
34:09 - dot get item. Okay, so here's the other method
that we added to the repository, we just pass
34:14 - the ID, and we return that item.
34:18 - Now, again, we need to mark a top like that
right bear here. So it is going to be an HTTP
34:25 - GET. But in this case, there's a little additional
detail, which is the template. So we have
34:31 - to provide a template where we specify
34:36 - how we're going to treat another piece of
the route. Like in this case, the route is
34:41 - not going to be just get slash items. It's
going to be good slash items. And the the
34:48 - idea of the item, right, which is is that
piece of the big plate, I was just going to
34:53 - put it like that. So would you request the
items is slash rF cific item ID then this
35:00 - This piece is going to get executed. Right?
35:05 - So yeah, let's see how that goes. I'll do
f5 again.
35:09 - Okay, this is running back to swagger. Got
to just refresh the page. And as you can see,
35:17 - now we have our second route available. Like
I said, this is slash items slash ID. So,
35:23 - in order to execute that, let's Well,
35:27 - let's actually execute the first one items
to get a list of all of our
35:33 - items that we know about.
35:37 - And let's grab the first one.
35:40 - so dearly, we should be able to get that item
via the the other route. So gateway ad, so
35:45 - let's try it out our basic item here, so these
how in open API swagger, you can introduce
35:52 - values, right? And now execute that, see what
happens. So here's the executed route. So
35:58 - you can see slash items and the slash the
actual ID. And then
36:03 - interestingly, we are getting 204. Right?
So this means that something didn't go quite
36:11 - as suspect.
36:12 - What I'll do is I'll go back to Visual Studio
code, and I'll put a breakpoint over here,
36:20 - see what we're getting. So go back to swagger,
UI, and execute.
36:25 - Here, we got a breakpoint. And, right, we're
getting No, that's what's happening. So the
36:35 - item has not been found. So why could why
would that be? Well, let's see. Here's our
36:42 - items. And here's our get item. I made that.
36:47 - And so, yeah, so really, what was happening
here is that anytime we make a request to
36:55 - this to our controller to our, to our service,
we are actually creating, as you can see,
37:02 - over here, a new instance of the in main items
are positivity. Right? So that means that
37:10 - he's created, a brand new list is created
with a random set of new codes here. And of
37:15 - course, when we try to use our previous use
it good, it will not find it, because now
37:20 - we have a brand new list.
37:23 - So I'm going to do a five, yesterday go and
37:26 - this is a good actually a good thing, because
you have to realize that we need to deal with
37:34 - that situation properly in in the controller.
So in this get item method, we should be a
37:42 - not just returning an All right, so how do
we handle this? So let's stop it.
37:46 - So I think that we probably want to do is
to return the proper status code HTTP status
37:51 - code in the case that we can find the ID.
So
37:55 - let's say so if item
37:59 - is no all right, so let's return it something
different. So let's return
38:04 - not far. So that's the way to actually ask
a dotnet to create the proper status code
38:13 - for not found so we don't have to actually
figure out so I set a status code.
38:18 - And then yeah, if it is found, they will just
go ahead and return the item. Now we do have
38:22 - a problem here. Because now a in one branch,
we're trying to return this type, or not found
38:29 - result in these other graduates right to return
just an item. So what is it going? I mean,
38:34 - it's not like in it, right? We expecting to
always return an item. How do we deal with
38:39 - this is a by the use of the action result
type. So if we do action result,
38:49 - that actually allows us to return more than
one type from this method. So as you see,
38:55 - there's no more errors, because now this is
saying, Okay, if if if you want to return
38:59 - not found return not found, or if you want
to return the type that is in the a direct
39:02 - tie right here, you're also able to do that,
right? Or we're going to also say something
39:08 - like, Okay, if you wanted to, that's probably
fine. But now in this case, we can handle
39:15 - both cases. So let's run this again, and see
what we get used to get the proper status
39:20 - code for each of these actions to be properly
restful. So let's refresh this. Let's again,
39:27 - let's get one of these items are going to
try it out.
39:32 - Execute.
39:36 - So good. Yeah, can you just get one of these
we know it's no good to find it. But get that
39:41 - good. And then open up here, try it out
39:45 - with ad and execute. So this time, we do get
a 404, which is the correct status code word
39:52 - for not found, as you can see here,
39:57 - in this third part of the dotnet five REST
API tutorial
40:00 - We learn about the dependency injection technique,
and how to leverage it to properly inject
40:04 - a repository instance to the items controller.
We also introduce the concept of data transfer
40:10 - objects, and how to use them to establish
a clear contract with our API consumers.
40:17 - Today, you will learn what is dependency injection,
how to register and inject dependencies in
40:23 - dotnet. Five,
40:26 - how to implement data transfer objects, also
known as dtos,
40:31 - and how to map entities to details.
40:33 - In a previous video, we were able to actually
create our entities, repositories and even
40:39 - our controller to be able to get items and
our specific item. However, we find an issue
40:46 - where we try to retrieve an item, we can retrieve
it, because as we found and just go back to
40:51 - the code,
40:54 - anytime we receive a request, in our items
controller, we are creating a new instance
40:59 - of depository. And that's bringing a bunch
of new items in such a way that we are never
41:04 - able to find, right. So how can we go around
it? I mean, how can we actually fix this the
41:09 - right way?
41:11 - So for these, there's a pretty important concept
that we need to learn here, and which is called
41:18 - dependency injection. So let's talk about
that.
41:23 - So what is dependency injection? Let's think
about our class, right, so we have a class,
41:28 - which wants to make use of some other class,
where we have this kind of relationship, we
41:36 - say that this other class is a dependency
of our class, right. And, in more concrete
41:44 - terms, in our case, we have the itis controller,
which is constructor is a creating a new instance
41:51 - of the repository ready in meme items repository.
Now, what we really want to do in terms of
41:58 - dependency injection is flip things a little
bit. And instead of have a test controller
42:02 - construct that instance, and I'll just open
up my highlighter here,
42:09 - we will receive the repository in the constructor,
and then just take that, that, that reference
42:15 - into the class. So at this point, we are injecting
the repository dependency into the IDS controller
42:21 - class.
42:24 - Now this is also brings in something very
important, which is the dependency inversion
42:30 - principle, in which again, so we have a class,
and we have some dependency, let's call it
42:36 - dependency a. And well, this class depends
on dependency a, but what we want to do is
42:42 - just not take that kind of dependency, and
instead, have our our class depend on an abstraction,
42:51 - which is, in this case, in C sharp, it is
an interface, right? So the class no longer
42:57 - depends on dependency, it just depends on
some interface that dependency a will implement.
43:03 - Right? So we have inverted the dependency
by having a class only depend on an interface
43:09 - and dependency a implement that interface.
43:13 - At the same way, I mean, as we do that, we
could bring in a dependency or any other dependencies
43:21 - that also implement interface. But in this
case, you can imagine, now the repository
43:26 - that I just control receive is just an interface.
So class in this case, has no idea of which
43:32 - explicit dependency it is working with, could
be a B or any other dependency, as long as
43:38 - they implement the contract, which in this
case, is the interface. And this instruction
43:42 - class is very happy to work with it. Okay,
so that's, that is the dependency inversion
43:48 - principle. And
43:49 - well, the thing is, okay, so why why do we
want to do this? Well, really common reasons.
43:56 - And yeah, like I said, like he says, right,
so by having our codependence dependent upon
44:00 - abstractions, we're decoupling implementations
from each other. So it gives us much more
44:05 - freedom in terms of moving around these dependencies,
without ever having to touch our class. And
44:11 - this makes the coal cleaner, easier to purify,
and much easier to reuse. But I'm very wary,
44:17 - so much easier to test.
44:20 - But then, if we're going to do this, how are
we going to construct these dependencies,
44:24 - right, because now we're just receiving them
in the constructor. So if we have all these
44:29 - dependencies, dependency ABC, how are we go
the constructor constructor. So because our
44:35 - class was to receive them, right? They were
going to inject them there. So comes into
44:40 - play this thing called a service container,
which in terms of a dotnet five is an AI service
44:47 - provider.
44:49 - So what happens is that a during a application
application startup, we're going to register,
44:54 - each of these dependencies are going to be
registered into the service container.
45:00 - And then eventually, when the class gets instantiated,
the service, a service provider separate container
45:07 - is going to take care of resolving any of
the dependencies needed by this class, like
45:13 - it has a map of all the dependencies are needed
by each of our classes. So resolve the dependencies,
45:18 - construct them, if needed. Only the first
time, of course, depending Well, actually,
45:23 - depending on the application lifecycle that
has been set up for those dependencies for
45:27 - the class. So if needed constructors, otherwise,
it will reuse it. And then it rejects the
45:33 - dependencies.
45:34 - And this is, in fact, what's going to help
us with little problem that we have right
45:37 - now in the inner project where we want to
be constructed and constructing I mean, we
45:42 - don't want to get a split dependency on the
regulatory, or we don't want to construction,
45:45 - explicit construction of warnings as every
time we created the controller, we just want
45:50 - to receive an East as if it's available, a
lot of constructed getting constructed first
45:54 - time and get it all sorted by the service
container.
45:58 - Let's see now how we can use dependency injection
to our advantage. So what I'm going to do
46:03 - is I'm going to get back to the code. So let's
stop debugging close terminal. And so let's
46:08 - fix the situation where we have this explicit
dependency on email it depository. So firstly,
46:14 - we're going to need is some interfaces so
that I just controller does not really a operate
46:21 - on concrete instances of the depository. So
let's go to a main idea posit Ori, and we're
46:28 - going to do is just right click on the class
and
46:32 - actually in the light bulb, and let's extract
interface. So that's going to create a interface
46:39 - for us and makes it makes it possible to implement
that interface. Now, we probably want to take
46:46 - the interface out into its own file. So let's
do that.
46:51 - A new file,
46:56 - let's actually call it a I items depository,
should be a better name for this.
47:04 - Okay.
47:05 - And so
47:06 - thanks, space catalog, dipole stories. And
here's where we're going to bring in our interface,
47:15 - I'm going to use cut
47:19 - and paste here. It is a report a couple of
nice spaces, let's see, for the entities.
47:28 - For CS for good. Collections generic, that
should do it. Alright, so we have our interface.
47:35 - And here's the repository.
47:38 - repository implements interface. So now that
we have the interface, let's go back to our
47:43 - controller. And
47:46 - let's switch this into I mean, this type into
i a items of repository
47:58 - of policy
48:00 - items.
48:01 - For seat gaudy.
48:04 - Make sure this is off. Yeah, we have to do
the right naming here for that
48:10 - game. And now we've got the receive it here.
So I demonstrate depository. This is a boss
48:21 - story.
48:23 - And then just to not confuse things, let's
say this, that repository equals depository.
48:29 - Alright, so yeah, so now we got the pennsy
injection working here. And no longer This
48:37 - class has any idea of which repository is
going to use behind the scenes. Now, the only
48:43 - thing we have to do here is to
48:44 - what's going on here, actually, I was just
fixing that in our laboratory. The other thing
48:53 - is that we have to do the registration, right.
So to do the hyperinflation of our depository,
48:59 - or we're going to do is go to start up, configure
services. So this is the place where you register
49:04 - all the services that are going to use it
across your service. And the service that
49:09 - we need now is our history. So let's do services
that
49:13 - add Singleton. Now there's a bunch of ways
to add a URI. To register your services here,
49:21 - I'm going to be using a singleton so and a
singleton is nothing, nothing else, other
49:26 - than just having one copy of the instance
of a type across the entire lifetime of our
49:32 - service. So only one will be created. And
it will be reused wherever whenever it is
49:37 - needed. So that's going to help us resolve
the problem that we have today. And so to
49:41 - add the singleton fares, we specify the interface.
49:45 - So
49:46 - I added repository, which we may need to add.
Yes, we namespace. And then so that's the
49:54 - interface. And then the concrete instance
is
49:57 - in main items repository right?
50:02 - That's it. So that's how you register your
dependency. And so
50:08 - at this point, we should be ready to be ready
to go. So I'll do a five.
50:16 - And now I'll switch to swagger.
50:20 - So we have the same API as before, I'll refresh
anyways. And then let's try an exercise now.
50:27 - So let's see, I'll try out our items, endpoint.
So I'll get one of our items.
50:34 - And I should be able to find it now. So see,
items, Id try it out. I'll put it here and
50:41 - there, let's try to find it execute.
50:45 - You have a breakpoint here. Let's see. Yes,
this time, we can resolve no more, no, remove
50:52 - that breakpoint, run back to swagger. And
then here it is, we got our response code
50:59 - 200, for the request of that item, and here's
all the body that is crucial.
51:06 - So
51:08 - as expected, now we only have one copy of
repository hanging around, which is injected
51:13 - into the controller, and that allows us to
actually find the data we're looking for.
51:17 - Now, there's one more thing to notice here
that we should fix right away. And which is
51:24 - the fact that these
51:28 - these routes that we have enabled right now
are enabling a or are exposing our item entity
51:35 - directly to the outside. And we have to understand
that as we build REST API, we're also establishing
51:42 - a contract with any of the clients that we're
going to be using, which is a contract that
51:47 - we should not be breaking easily. And the
problem that we have right now is that since
51:51 - we're exposing item, which is the item that
we're using for dealing with persistence,
51:55 - we have versatility.
51:58 - Anytime we want to add feel, I mean, anytime
we want to modify or remove any of the fields
52:02 - that were that we're using in our inner storage,
right now, in the versatility, we can potentially
52:07 - break our clients, right, break that contract,
which is really no goal for us to build these
52:15 - REST services.
52:17 - So how can we avoid exposing these item contract
there? So let's, let's take a look, let's
52:22 - go back to the project. Let's actually find
that entity. So we have item here. And as
52:28 - we said, we are returning it both in get items
and get the item. So what we're going to do
52:33 - now is introduce what we call a DTO or a data
transfer object. So data transfer object is
52:38 - nothing else other than the the actual contract
that's going to be enabled between the client
52:45 - and our service. And to do that, we're going
to do introduce a new folder here. Let's call
52:50 - it videos.
52:56 - And let's add a new file for our item dt.
All right. All right in the deal. So again,
53:03 - namespace catalog, in this case is going to
be videos.
53:09 - And the identity is going to be fairly similar
53:14 - to our item, actually.
53:17 - So let's want to just copy
53:22 - the item.
53:24 - And so
53:26 - going to add missing spaces.
53:30 - here and there. Yep. And, yeah, I mean, in
this case, it happens to be that the item
53:36 - that we want to return in our methods is pretty
much the same as the item that we will be
53:42 - storing in a repository or retrieve the depository.
So we use, okay, seems a bit redundant right
53:49 - now. But the benefits become evident as you
move forward as you start modifying your database.
53:55 - You don't have to be touching this contract,
or you can be very careful with the contract,
53:59 - or supposed to be breaking our clients anytime.
So this gives you a lot of flexibility as
54:03 - you evolve your data store.
54:05 - So now that we have, actually let's rename
this to item DTO. Sorry for that. Okay, I
54:12 - think the deal. And now that we have that,
it is time to start using it right, so let's
54:20 - go back to iTunes controller.
54:22 - And so at this time, what we'll need to do
is to convert the iTunes or we're getting
54:29 - started with good ideas, right, we have to
convert these in from item into identities.
54:34 - One way to do this would be to just do a simple
projection with link. So we would do a select
54:44 - and then maybe missing the link a space here
to add it. I'm going to say okay, so I tend
54:51 - to
54:52 - project into a new item DTO
54:57 - and I may need to add any space here. There
it is.
55:01 - So here we're going to bringing the properties,
right, so I'm going to say alright, so Id
55:08 - is equals item.id.
55:12 - name equals item name, same thing. Price.
55:22 - Okay, so now we have a our items collection
is a collection of items, we do
55:32 - think we're missing parentheses here.
55:37 - And we return
55:38 - those items, no longer item, there has to
be item B to
55:44 - setting up the contract. Okay, so, yeah, so
that should do it, we have to inform the item,
55:49 - do it and do. And as you may guess, we have
to do pretty much the same thing over here,
55:53 - right?
55:54 - This point, it will be a bit redundant, right?
So why will want to do this transformation
56:00 - twice with exactly the same properties. So
one way that we can overcome this is by adding
56:06 - an extension method. So let me show you what
I mean by that. So I'm going to add a new
56:10 - file here, we're going to call it extensions.
56:15 - Games. So good luck. And then what extension
does addition metal does is it just will extend
56:24 - the definition of a one a type by adding a
sum a method that can be executed on that
56:30 - type. So in this case, we're going to add
a class only static class or for extension
56:36 - methods, you have to use a static class, there's
a way to go,
56:41 - extensions.
56:43 - And then we're going to declare one method
here. public static is going to return item
56:50 - DTO.
56:52 - And we're going to call it as DTO. What is
going to it's going to operate on the current
56:59 - item
57:00 - does, that's what this method means. So again,
let's add some namespaces here.
57:08 - So this method receives an item right, by
by using this here, it means the current item
57:16 - can have a method called as DTO, that returns
its identity or version.
57:21 - So at this point, we can probably take advantage
of what we did here. So let's see, this is
57:27 - what we used to create activity Oh. So we
can say well return new identity or out of
57:36 - the item that we received.
57:38 - Ladies, we have an efficient method ready
to be used. So now we will go to adjust controller,
57:43 - what we can do is instead of all of this,
we can say so item is projected into it, and
57:50 - that as the deal.
57:52 - That's all it is. Let's collapse this a bit.
57:56 - With that, we can also use the same method
over here. So when we get the item, we will
58:02 - say as you do, of course, we need to change
this into our do contract.
58:09 - And then the rest. Actually, I will do this.
So let's just get the item first. Check if
58:16 - it is no, if it's not, then we do the CTO.
58:20 - Okay, so now that we have done that, let's
see how that goes. So I'll do a five again.
58:27 - Okay, back to swagger.
58:32 - And I'm going to refresh this. And let's see
if this still works. So items, I'm going to
58:38 - try it out. Execute. And yeah, just before
we can get the list of items. But this time,
58:47 - if you scroll down, you will see the disclaimers.
The contract we're exposing to our consumers
58:52 - is no longer an item but it is item to do
with the properties posted right here.
58:59 - In these four parts of the dotnet five REST
API tutorial, we introduce additional controller
59:04 - actions for creating, updating and deleting
items. We will also learn how to validate
59:10 - the incoming dtos to prevent invalid data
from landing in the service.
59:15 - Today, you will learn how to create resources
with post how to validate the values of DTO
59:22 - properties,
59:23 - how to update resources with good
59:26 - and how to delete resources we delete.
59:32 - It is time now to introduce the rest of our,
our routes, right so route for both to create
59:38 - an item, route for update, delete, or update
the item and the route for Delete to be able
59:43 - to delete a date.
59:45 - So let's start with post. Right. And before
doing anything else, what we're going to have
59:51 - to do is to update our repository to be able
to have that create that route for creating
59:59 - an item right
60:00 - So let's do that. And I'm going to start again,
by going to the interface, that's the first
60:06 - thing to do. And so let's declare
60:09 - void, create item,
60:13 - item item. Okay, so this new method just returns
nothing. And it only just received the item
60:22 - that needs to be created into the depository.
Now let's switch back to the concrete in main,
60:29 - it depositories. And I'm going to say, implement
interface. So that brings in a new method
60:35 - right there. And CNC turning memory depositories,
this is as straightforward as just saying
60:43 - items that add
60:44 - item.
60:45 - That's all it is.
60:50 - And then now we want to expose these into
the controller, right, we start to add a route
60:55 - the controller. But before doing that, we
got to realize that so the client is going
61:00 - to be sending these, these items. And we will
have to establish another contract for receiving
61:08 - that, that item, it cannot be identity or
because we don't need as many properties as
61:13 - in identity or for the creation of an item.
So let's see what I mean by that. So I'm going
61:19 - to go to our details folder, I'm going to
create a new file, let's call it
61:23 - create identity Oh,
61:30 - and add the space
61:33 - catalog that videos. And then.
61:39 - Okay, just like before, we're going to be
using record for this pretty convenient for
61:48 - the tiers. And so now I've looked back at
it to, let's see, so what will make sense
61:55 - to be sent by the client as we create an item.
So normally, the ID is auto generated in the
62:02 - server side, right? So we don't need to be
passing in that ID, we do need a name and
62:08 - a price. And likely the created date is going
to also be generated on this service. So we're
62:13 - only going to include in these two
62:14 - lists. So we have name and price. And that
will be for our create item DTO.
62:24 - And now let's see how we can use it in the
controller. So back to the controller.
62:31 - Let's see how we declare these a post route.
So it's going to be
62:36 - public action result. Because again, we could
return more than one thing in this method,
62:45 - things could happen. And
62:46 - they call the convention for a post or a create
method is to create the item and return the
62:56 - item that got created. So if we're going to
do that, we're going to we should be fine
62:59 - to return the identity. Now that the conventions
here are going to vary. So some people will
63:05 - create their own response object here, it
doesn't have to get into to it happens to
63:09 - me that it works fine for us in this case.
So that's okay. So it's going to be called
63:14 - right in
63:16 - grade eight MBT Oh, that's going to be our
input contract. Item BPO.
63:25 - Okay, and then let's qualify these with the
right verb. So each HTTP POST, and then just
63:34 - for the communication will say so yeah. So
this is going to be invoked when somebody
63:38 - does a post into the items route with the
correct body, of course.
63:47 - So how do we create an item? So very straightforward,
we're going to say, well, item,
63:53 - item equals new, we will have to find the
type. So thanks for sharp nine.
63:59 - And then yeah, so let's just say ID equals,
here's what we actually
64:05 - generate the ID for the item. So it's going
to be good, that new good.
64:11 - So the name is identical to that name, same
for the price.
64:19 - Price, and then the created date, as as you
would expect
64:26 - a time offset that UTC now,
64:33 - that's the item. And now we have to build
we'll take advantage of the repository method
64:37 - we just created.
64:39 - Create item, and then it goes there.
64:44 - And then once the item has been created, a
convention here is to Yeah, I mean to return
64:50 - the items that were created and also a to
return a header that specifies where you can
64:55 - go ahead and get information about that graded
item. So to do that, what we can do is use
65:01 - Created add action, you can also use create
route, that's another way to do it. gradient
65:07 - action will work fine for us. Because what
we can do here is say, Okay, so what's the
65:11 - action that we want? What's the action that
reflects
65:15 - the route to get information about the item.
And that's going to be our get item action
65:19 - right here.
65:22 - So what we can do here is say, well, there's
going to be the name of get item.
65:29 - And then when you specify the ID, that's going
to pass it to that order route. So for that,
65:35 - let's create just a simple anonymous type
here.
65:38 - With ID equals ID and ID. So that's a generated
ID. And then finally, the actual object that's
65:45 - going to be returned, which is a thing. And
again, let's take advantage of our extension
65:49 - method as DTO. So we take the identical created,
and then we just converted yesterday to.
65:58 - And yeah, that's it. Let's do f5. See if this
works.
66:05 - So back to swagger. Let's refresh this. So
now we have our post route over here, as you
66:12 - can see, and also our grade identity is showing
up as a new contract that we're exposing torque
66:17 - lights. So let's go to post. Try it out. And
as you can see, now we only need to provide
66:24 - a name and a price.
66:27 - Let's see for the name. But let's see, let's
bring in something like another type of support,
66:32 - I guess, for let's see, a
66:35 - de neumes sort to be a bit expensive, let's
say 35.
66:41 - And yeah, so let's start let's execute,
66:44 - see what we get. So as you can see, here's
the request URL the same as the get. But in
66:49 - this case, it is a post, we have guarding
201, meaning a created art route. So he got
66:55 - created a new sort. And as you can see here,
we have a location here that specifies Where
67:01 - is that we can find that item.
67:04 - So if we actually take this a these code here,
we go to our collapses and go to our get route.
67:13 - Go to try it out. We're going to paste that
here. Execute. As you can see, now this is
67:20 - the route that was provided in the location
here for post. And it actually is able to
67:25 - find a developer a new source we just created.
And in fact, his use case, get the full list
67:30 - of all the items. Try it out, execute. So
now we don't have your three we have four
67:35 - items, including the deadliness.
67:41 - But then let's also try one more thing. What
happens if I try to create something without
67:46 - a name? Does that make sense? Well, let's
try it out.
67:51 - There's the V that that was accepted. And
now we have an item with a no value, which
68:00 - is totally unacceptable. And and again, in
fact, we use code to the get route and we
68:06 - say, execute, we can see
68:10 - we have an item with no, which is pretty bad.
How can we protect ourselves against that
68:17 - situation. So there's this thing called a
data annotations, which is something we can
68:22 - add to our DTO in this case, to prevent that
situation. So back into create identity, oh,
68:30 - what we can do is just request that this field
is required.
68:35 - And I'm going to add the data annotations
namespace in there. So it name has to be provided,
68:43 - and price has to be provided. For price, don't
just add, let's do one more thing, let's say
68:49 - there's going to be a range of possible values
for price because we should probably not accept
68:54 - a negative value or even zero here. So let's
say that we're only going to set values from
69:00 - let's say, from one to 1000, that should be
a valid range for us. So just by doing this,
69:06 - we are protecting the values are going to
be coming into the controller. So I'm going
69:11 - to do a five again.
69:14 - And let's see how that goes. So back in swagger,
69:18 - I'm going to be collapsing this route. So
back in post, I'll just try to do the same
69:23 - thing again. Try to execute this. And this
time.
69:30 - Now we have a 400. So bad request error. And
clearly it says here the Name field is required.
69:37 - So now data validations are coming into place.
And so we must provide a name. Let's actually
69:44 - play with the price here. Let's say I try
a negative number. Right see what happens.
69:49 - If you have price must be between one and
1000. Right. So data notations for valuations
69:56 - pretty useful for relating dot r or D do
70:00 - Now it's time to implement our update route.
So let's go back to source code, close terminal.
70:08 - And just like before, let's go back to our
a repository, I identify the interface and
70:13 - add the relevant method. So let's say this
is going to be a void. Again, update item.
70:22 - And this is going to receive the item to get
updated.
70:25 - Very similar to create item. Now, back to
the concrete implementation.
70:32 - I'm going to say, again, implement interface
70:37 - that brings in the method data item. So how
would we update this item. So since it is
70:43 - an in memory list,
70:45 - really, the only thing that we have to do
is use find the relevant item and update it
70:50 - with the incoming item, right. So to do that,
let's do this is find the index of the relevant
70:56 - item. So I'm going to say items, find index.
And then so this is the existing item.
71:08 - So you're going to find the existing item
where existing item ID matches
71:17 - item.id.
71:18 - Okay, so that's just finding the index of
the of the ID that we're looking for. And
71:22 - we've found it, we can do items, index equals
item.
71:30 - That's all it is. So we will update the item
in the right location. So it's time to go
71:35 - back to the controller, well almost like to
go back to the controller, because, as you
71:40 - may realize, at this point, we do need some
video to receive the input for the update
71:46 - route. And even when that disables, you're
going to be pretty much the same as with great
71:52 - identity, oh, these are good practice to actually
have a another a video for this case, because
71:58 - you don't know right now is the same thing.
But eventually, it could be that an update
72:02 - means something different than accurate. So
let's use to update identity Oh,
72:10 - that's a copy of great identity, oh, pretty
much has the same properties is the only thing
72:16 - that you can verify the name and the price.
And required and the range, right. So now
72:22 - let's go back to the controller, right this
controller,
72:27 - let's create out of the drought.
72:30 - So this is going to be again,
72:33 - public action result.
72:38 - In this case, a convention for output is to
actually not return anything. So use what
72:44 - we call no content. So it's going to be no
type here other than action result, it's going
72:49 - to be called update item, we receive two things,
the first thing is the good of the idea of
72:57 - the item. And then they are new update item
DTO.
73:02 - Let's call it item DTO.
73:06 - And then, let's not forget to add the correct
verb here is an HTTP put.
73:14 - And just like we did before, the route is
going to be just for documentation, when you
73:19 - to put into slash items, and then slash that's
the piece that we're missing actually here,
73:26 - we need to also specify here the template
73:31 - which is in this case is the ID. So that means
that when when we do a put, we have to certify
73:37 - the ad in such a way
73:41 - like these, right, so put items slash the
ID, and they will hit this method here. So
73:46 - let's see. So first thing, so how we will
do an update, first thing to do is a Find
73:51 - the Item. So existing item, it will use a
repository for that we already have a method
73:57 - for this, which is get item
73:58 - passing the ID. And then it will be great
to verify if this ID if these items actually
74:06 - exist. So if an existing item is no, then
well, we couldn't find it. So we will just
74:15 - return not found.
74:19 - And at the end of story for that that branch.
74:23 - And then if we find it if we found it, well,
we're going to do is just proceeded to do
74:31 - the
74:32 - we're going to create a new item, which is
the updated item in our system. So in this
74:36 - case, we're going to say is item updated item
equals it essentially our existing item.
74:44 - But with
74:47 - a couple of differences. Like we need to use
a the name
74:53 - of the provided identity. Oh, and the price
of that also provided identity. Oh
75:00 - So, now here, I just use one 190 of a record
types that I mentioned when I was talking
75:09 - about record type, which is the width expression
here. So what's happening here is that we're
75:14 - saying, Okay, so we're taking this existing
item here, are we creating a copy of it with
75:20 - the following two properties modified for
new values. So that's a very nice addition
75:25 - into
75:26 - records, and allows me to use what is really
an immutable type. But still, I can go ahead
75:33 - and modify a some properties on initialization.
So if the item is just a copy of existing
75:39 - item with a bunch of properties, like nice
addition, in record types, where we have this
75:45 - updated item, we can go ahead and say, okay,
so repository that updated the method that
75:51 - we just created, and send the bladed item.
And like I said,
75:58 - the convention is to return no content, so
nothing to report just returned.
76:04 - Let's try this out. f5.
76:09 - And back to swogger refresh.
76:13 - So here it is, our put
76:15 - our port route. And before doing a port, let's
actually get a one of our a items.
76:22 - So try it out, execute. So let's say we're
going to modify our potion here.
76:29 - Okay, so the potion, I'm going to collapse
these up and put, so for put, we have to provide
76:37 - an ID, and updated values here. So this is
a potion, let's actually rename it to, let's
76:44 - say super potion.
76:46 - Let's bump the price to I don't know, let's
say
76:53 - 29. So execute.
76:58 - And then just as expected, we get 204, which
is no content. And you can see the route that
77:04 - was executed here. And then if this succeeded,
we should be able to get a
77:10 - updated version there. So I just get the full
list of all the items that we have. Now let's
77:14 - see what happens. And there is no longer potion
super potion with updated price.
77:23 - Also, notice down here that we do have a this
update identity are available now here, the
77:31 - new contract.
77:32 - So we'll update really, the last thing to
add is our delete route. So let's go back
77:38 - to controller. So back to the project. Just
before, back to the repository interface.
77:45 - Let's do void. The title,
77:50 - we already already know we need for the reading
item is just to know the idea of it. So back
77:55 - to the repository.
77:57 - let's implement the interface
78:04 - for delete item.
78:06 - And actually, the item is going to be very
similar to update item, first thing that we
78:11 - have to do is find the item, I mean the index
of the item. And now we can just say items
78:16 - that we move at.
78:19 - Look at
78:21 - that index.
78:24 - That's all it is. Sorry, we have to say it
here.
78:29 - We had the opposite already. And now we can
look forward to the controller.
78:37 - In this case, we're not going to need another
DPO. Because the only thing that's needed
78:41 - here is to use a simple ID. So let's use implement
the controller action.
78:46 - So public action result.
78:49 - Delete item, just like with update, we're
going to return no content. So action result
78:57 - delete item, good ID.
79:01 - And let's add the verb. So this is going to
be an HTTP delete. Again, documentation. So
79:08 - these are going to haunt or delete slash items.
79:14 - And then slash, let's not forget our template,
79:18 - which is the ID slash items ID.
79:27 - And to perform the deletion, similar, certainly
with similar to update. So let's try to find
79:33 - the item first. And we'll just copy that base
79:36 - there. So not found if we can't find it. And
then we go ahead and to repository, that delete
79:44 - item and it
79:46 - just like we did before, return, no content
79:53 - and that's all it is so f5
79:59 - and by
80:00 - swogger refresh again. And now you can see
we have our delete action available. So let's
80:07 - come to the name of one of our items and see
if we can delete it to execute this. So let's
80:12 - try to delete that potion,
80:16 - copy,
80:17 - collapse, expand, try out,
80:21 - put ad and execute. So here's the route. We
got 204 is expected, no content. So if I tried
80:31 - to get the items again, let's see what happens.
80:34 - All you have to, so no more potion habido
here.
80:40 - And yeah, so that will be at the end of our
routes.
80:46 - In this episode of The dotnet five REST API
tutorial, we will see how to start our entities
80:52 - in a persistent store. Specifically in a MongoDB
database, we will implement a simple MongoDB
80:57 - repository that can replace our existing emancipatory
with minimal changes to our service.
81:04 - Today, you will learn how to implement a simple
MongoDB repository, how to run MongoDB as
81:11 - a Docker container,
81:13 - and how to use postman to interact with the
REST API.
81:15 - Starting with this episode, you will need
a couple of other things to follow the video
81:22 - step by step
81:23 - Docker, which we will use to run a local MongoDB
instance.
81:28 - And postman, which we'll use to interact with
the rest API's from Iran.
81:35 - Now let's think about the scenario as it is
right now. We have our user who is trying
81:40 - to manage his items via the browser. And he
will do that by reaching out to our REST API.
81:45 - And more specifically, by reaching out to
the IRS controller, which is where or all
81:51 - of our routes let at this point. Now, I just
controller will interact with the inmate item
81:57 - depository
81:59 - to manage these items. And the items are actually
stored inside the main depository as a simple
82:04 - items collection right.
82:07 - Now, what happens if the REST API for any
reason stops, either eat stops or is restarted,
82:15 - and it could happen, either explicitly or
unintentionally. But it is a really common
82:21 - scenario that a service would need to be restarted.
82:23 - If this happens, of course, our items collection
is going to go away, because it's just a collection
82:30 - in memory, right? This is all desired, we
need to figure out a way to keep these items
82:36 - alive beyond the lifetime of the REST API.
82:38 - So what are these, we have a few options.
And I can think of first very basic option
82:45 - will be to using files. So you can think of,
well, I'll have one file for each of the items
82:50 - in the repository.
82:51 - But really, the most common option these days
would be to use a database. And in terms of
82:58 - databases, we have 1000s of options. But you
can categorize them into relational and no
83:04 - SQL databases.
83:07 - In this tutorial, we will go for a no SQL
database. And the reason for this is well,
83:13 - because of the benefits that it offers, beyond
the fact that no SQL databases are one of
83:18 - the most popular options these days, there's
the fact that you won't need a schema or SQL
83:25 - to interact with the database. I mean, you
don't have to learn SQL yet another language
83:30 - here, you can just stick to your object oriented
programming. And in our case, today, she's
83:35 - C sharp API's.
83:37 - And you also have low latency, high performance
and these because
83:43 - there's no need for strong consistency as
it as it would be in a relational database.
83:47 - And also, these are highly scalable.
83:51 - In our case, we'll go specifically for MongoDB,
83:54 - which is it is a no SQL database, and specifically
is a document storage type of database. So
84:00 - it stores a the entities as documents, specifically
as JSON documents inside the database. So
84:07 - this is we're going to use for this tutorial.
84:09 - So you can think that now we will have this
database living outside of our race API.
84:14 - And now, when a controller receives a request,
it will actually hand it over to a new repository
84:23 - called a MongoDB. I just have visited it,
that's what we're going to create here.
84:28 - And even if our services stopped and restarted,
the database will not be restarted at all,
84:36 - our data will be saved in there. And that
way, we can keep our items beyond the lifetime
84:41 - of the REST API.
84:42 - Before we start implementing our MongoDB repository,
I wanted to show you one more tool that you
84:49 - will probably find useful as you interact
with your API's and they want to so is postman
84:56 - and you can get it in the postman downloads
page. If you had no
85:00 - done already?
85:02 - And why would you use postman for. So if you
remember, so far we've been using this page,
85:07 - the swagger UI for interacting with all of
our API's.
85:13 - However, the problem here is that eventually
you may not want to be opening, you know,
85:18 - web pages do interact with each of your API's.
And these API's may not even be in your host,
85:24 - they may be somewhere. So what else were you
there may not be a swagger UI. So you do need
85:29 - a way
85:30 - to interact with them.
85:33 - Plus, you may need some additional capabilities
that are just not available in this page.
85:38 - So that's where postman can help you. So in
this case, let me open a postman right here.
85:46 - So how we can interact with your APIs in postman.
So it's as simple as clicking the plus sign
85:51 - here. And the first thing that you have to
do is pick a verb that you're going to use.
85:56 - In our case, let's just try I get that you're
going to read the request URL, all of those
86:02 - URLs are going to start with your host. And
so in our case, let's see what's your host,
86:07 - let's do an f5 in VS code. And as you may
recall, our host Ace and is one of the last
86:14 - lines here for the HTTPS endpoint is going
to be localhost 5001. I'm going to copy this
86:21 - back to postman, paste that. And then if you
remember, our route, going back to VS code,
86:29 - now, our route is a
86:35 - starts over route, start with items right,
right here. So that will be the route that
86:40 - we want to use in postman. So just type here,
items. And that should be enough to perform
86:46 - I get. So I'm going to just going to see click
Send.
86:51 - And then if you get this problem here, this
issue that says SSL error, unable to verify
86:56 - the first certificate, this is because of
the SSL verification that postman is performing.
87:01 - But this such verification will just not work
with the self self signed certificate that
87:07 - comes with dotnet five. So in this case,
87:10 - what you want to do is just disable SSL verification,
and that should be fine. So you can just click
87:16 - here.
87:17 - And that will run the request. Again, as you
can see, it ran the request. And we have the
87:23 - resource over here. Same results that we had
in swagger UI before. But now, we are interacting
87:30 - more directly more directly with that API,
the same way that we need to get you can do
87:34 - post put and a bunch of other verbs here.
We will do so as we move forward with this
87:40 - with this episode of the tutorial.
87:41 - So now let's go back to VS code.
87:47 - And I'm going to stop the host here and close
terminal. And I'm going to close it with controller.
87:53 - So the first thing that we want to do is to
87:58 - implement a new repository
87:59 - to be able to interact with a MongoDB database.
88:05 - For that, I'm going to create a new file.
88:07 - We're going to call it Mongo DB. Items repository.
88:15 - Right.
88:16 - Thanks space.
88:19 - Got a look. depositories
88:24 - game. So it's going to be called for league
88:31 - class MongoDB. depository. And just what are
your sweet as with our email it suppository,
88:37 - we are going to implement items repository.
88:45 - We may need to import a namespace here, I
will implement the interface.
88:52 - And just by doing that we have VS code has
scaffolded all the methods that need to be
88:58 - implemented to comply with these interface.
Now in order to interact with MongoDB, we're
89:06 - going to need a what is called a MongoDB.
client. So the client is
89:13 - is a component provided by the creators of
the owners of MongoDB that you can use to
89:18 - interface will be kind of the adapter that
used to interact with MongoDB.
89:24 - So we'll need to inject that a as we as we
everything else, we need to inject that dependency
89:31 - into our repository so that we can interact
with it. So the first thing I'm going to introduce
89:34 - here is our constructor. So let's see. folic
MongoDB is capacitor.
89:43 - And here is where we need to receive an instance
of our MongoDB client.
89:48 - Where do we get this MongoDB client from?
So to do that, we'll have to add a nougat
89:52 - package. Plug the nougat package what I'm
going to do is open up a new terminal
89:58 - and here I'm just going to die
90:01 - dotnet package MongoDB that driver, enter,
90:08 - that's going to go to noget, grabs the MongoDB
nougat package. And if you go to catalog CS
90:15 - Pro, you're going to see that now we have,
we have the dependency right here.
90:19 - Oh back to the repository, we are able to
start doing the injection.
90:27 - So let's see, we're going to receive here
in the constructor is what we call an eye,
90:35 - Mongo client,
90:36 - to listen port import the correct namespace
here MongoDB driver, and we will call it Mongo
90:43 - client.
90:45 - And now what is it that we're going to store?
90:50 - We're going what we want to store here is
not really the client, but what we call a
90:54 - collection. So the collection is the way that
MongoDB associates all these entities together.
91:02 - So I'm going to declare a variable here.
91:03 - I wrote it with only
91:07 - because we only modified in constructors is
read only variable, I Mongo collection. And
91:14 - that you have to specify the type that that
of the items, the type of the entities or
91:20 - documents, actually in this collection, our
type is going to be our item entity.
91:25 - And his colleague, items collection.
91:28 - However, before we can get a collection, we
need a couple of other details, which is the
91:35 - database name, and the collection name. So
usually, like all of your document, yeah,
91:41 - all of your documents are going to be a grouped
into collections. And you can have one or
91:46 - more collections in a database. So the first
thing we have to add here is the name of our
91:51 - database. So let's just add a constant here
91:54 - is call it database name.
91:58 - And probably a good database name here would
be use catalog.
92:04 - And now let's add a collection name. So private
string,
92:13 - collection name.
92:15 - collection is going to be called items.
92:20 - Now that we have these available, this go
back to constructor,
92:22 - and we actually close the terminal for now.
92:27 - And what we can do is the following. So first,
let's get let's get an instance, let's create
92:32 - a reference to the database. So I'm going
to say I Mongo database database equals Mongo
92:41 - client that get database. So database name.
So that will get us a reference to that database.
92:49 - Now we need a reference to the collection.
So items collection,
92:54 - is the variable that we say that we declared
before equals database that get collection,
93:01 - and then the type of the item
93:04 - and then the name of the collection.
93:08 - And then the good thing about this is that
both database and the collection will be created
93:15 - the first time that they are needed. So it
doesn't matter which API we use to interact
93:18 - with the database and collection MongoDB.
Or I guess the driver will detect if we don't
93:24 - have them, and they will be created automatically
for us to we don't have to worry about it.
93:29 - So we have a few a few methods to implement.
So to get started, we'll go for the Create
93:35 - item method. And we'll start implementing
one by one and exercising each each one as
93:39 - we move forward in this video. To implement
create item, what you want to do is just make
93:44 - use of that items collection. So you can say,
items collection that insert one, and then
93:52 - you just pass the reference to the item. So
in this case, it will be just item.
93:58 - So at this point, you may be wondering, where
is this database is MongoDB database that
94:02 - we're going to interact with?
94:05 - Because Yeah, I mean, we have the code here
ready to create an item, but we don't have
94:08 - a database. So there's a couple of ways to
get a MongoDB database into your box. So you
94:13 - can either install the database via the MongoDB
installer, or you can run the database as
94:19 - part of a Docker container.
94:22 - We're actually going to go for the second
one. And the first concept to understand on
94:27 - that side is a Docker image. And
94:29 - I mean, we're not going to go deep into Docker
concepts here where we're actually going to
94:35 - talk about that in a future video. But for
now, you can think of our Docker image as
94:39 - a standalone package of software. That includes
really everything needed to run an application.
94:45 - This application in our case is MongoDB. So
everything is packaged in this Docker image.
94:51 - Then, when we run or when we execute this
Docker image, it becomes what we call a Docker
94:57 - container. So is a running instance of a Docker
image.
95:00 - That Docker container is going to run in the
Docker engine.
95:05 - So how do you get this Docker engine into
your box. So you just go to the Docker download
95:10 - page, which I can show you now, right here,
did you go to this page, you pick your platform,
95:15 - and then you can go ahead and download and
install Docker in your box. Then you have
95:20 - a Docker engine.
95:21 - And you're able to run any of the Docker images
available publicly, like MongoDB, or perhaps
95:29 - some private Docker images that you may be
storing in your own Container Registry. In
95:34 - this case, we're going to go for the A MongoDB,
a public Docker image, let's see how we can
95:41 - acquire it, we can run it. So first thing
we're going to do is go to terminal, say new
95:46 - terminal,
95:48 - we're going to type the following
95:51 - Docker run,
95:53 - then we're going to use the dash d dash dash
RM modifier This is so that we don't have
95:59 - to attach to the process. So we just let it
go. And RM is so that if the image is actually
96:06 - sorry, the container is destroyed after we
close the process. So then, we're going to
96:12 - give it a name, Mongo so that we can easily
recognize which image is this. And then we're
96:18 - going to open a port, that port is going to
be 27, zero 1727, zero 17. So this syntax
96:26 - here means that we want to open, let's say,
we're going to open kind of a window or a
96:34 - view into the Docker container. MongoDB usually
listens in Port 27, zero 17.
96:40 - So what we have to do is we have to open some
local ports as in the local machine, we have
96:45 - to open some port that can be mapped into
the MongoDB port inside the Docker container.
96:50 - So this is the way that you would do it, you
could assign actually any other port externally
96:54 - on the left side. But on the right side, you
have to point to that to the MongoDB port.
97:00 - Finally, we're going to specify a volume.
And the purpose of this is so that you don't
97:07 - lose the data that has been stored in MongoDB.
When you stop the Docker container, okay,
97:11 - if you don't do this, then you will lose all
that data as you start getting the content.
97:16 - So let's declare this volume MongoDB data
is going to be the name
97:20 - that is going to be mapped into data dB. Here,
slash data slash dp is the usual location
97:30 - where MongoDB
97:32 - is going to store the data inside the container.
And we're just saying where we're going to
97:36 - map this location called MongoDB data from
our local machine into the slash data slash
97:42 - dv directory inside the Docker container.
And finally, we have to specify the a the
97:48 - name of the image, in this case Mongo,
97:50 - then I'm going to hit enter,
97:54 - perhaps I can expand this terminal a bit.
So the very first time that you run a Docker
97:59 - image is going to pull it down from in this
case from Docker Hub, into the machine. So
98:04 - that may take a while depending on your internet
connection. But as you can see, there's there's
98:09 - multiple lines here. Each of them represents
what we call layers. So each of them has some
98:14 - piece of this Docker image, including all
the dependencies. So like I said, this is
98:18 - just the first time next time is going to
be blazing fast on as long as you have those
98:22 - people's lives already in your box. So now
we have the Docker image both into the box,
98:30 - and even Docker container running. If I actually
do docker ps, I can see that I have the Docker
98:36 - image up and running and listening in this
port 27, zero 70.
98:43 - I'm going to close the terminal. And so
98:45 - what we need to do now is to be able to point
to that to that Docker image. So to do that,
98:55 - we need to write a little bit of configuration.
So I'm going to open up settings Jason.
99:00 - So the basic two pieces of information that
we're going to need in order to talk to the
99:03 - database are the host and the port. So for
that,
99:07 - I want to introduce a new, a couple of new
settings here. And let's call these MongoDB
99:14 - settings.
99:16 - Like I said, we're going to need a host
99:26 - and we're going to need a port.
99:29 - So, in the case of a MongoDB instance that's
running in your in your machine, you can refer
99:37 - for the host you can just call it localhost.
99:41 - And as we said, the port that we opened in
the Docker container was 27, zero 70.
99:49 - Those are the details that we need to talk
to them to the to MongoDB. Now in order to
99:55 - read these settings into our service, I mean
there's a
99:59 - bunch of ways to do it. But I think the best
way is to declare a class that represents
100:05 - the settings so that we can easily interact
with the multiple settings from our C sharp
100:11 - code. To do that, we're going to introduce
a folder here, let's call it settings.
100:18 - ukoliko, call it configuration options. There's
a bunch of ways, I'll go for settings. So
100:25 - let's add a file here, let's call it
100:28 - sorry,
100:30 - Mongo DB settings.
100:32 - And, again, namespace, got a look that settings
in this case, this declared a class.
100:45 - Let's call it MongoDB. settings. And here,
we're going to declare those settings that
100:51 - we saw in app settings, Jason this, this declared
them as properties. So our first property
100:56 - is going to be
100:57 - prop string cost.
101:04 - And the next one
101:05 - public int port, so this is an integer.
101:13 - And then, let's actually take advantage of
this class here, to calculate the connection
101:20 - string that's going to be needed in order
to talk to MongoDB.
101:25 - So what we can do here is actually a read
only property.
101:30 - So let's see.
101:32 - Let's let's do this
101:35 - string, let's call it connection string.
101:44 - Okay, we're going to remove the set, we don't
need to any sailors in there, this gate, we're
101:52 - going to open up.
101:53 - So that becomes a read only property here,
we can just return the calculated connection
102:03 - string. So we need to do a little bit of string
interpolation here. So what I can say that
102:08 - they connect normally, a MongoDB connection
string looks like this. So
102:12 - MongoDB,
102:14 - lashes lash, and then here comes a host, and
then comes abort.
102:24 - So those are going to get from the properties,
host and port, the properties that we declared
102:31 - over there.
102:33 - So with these, we have an easy way to grab
the connection string, as long as we have
102:36 - populated host and port. Now that we have
this, it is time to perform the registration
102:43 - of that a MongoDB, a client, a Mongo client,
that we injected into the MongoDB, it was
102:49 - 30. So this client here
102:53 - has to be registered somewhere, right? And
as of right now, what we know is that we do
102:57 - that stuff in startup. So just open up startup.
103:02 - And here, let's go to configure services.
That's what you register all your all your
103:07 - services, we're going to do this services
at Singleton because we only want one copy
103:13 - of the Mongo, the IMO client for the entire
service.
103:18 - I'm Mongo client. We made it important namespace
here. Yep.
103:25 - And then here, instead of just declaring the
type of the explicit type of the dependency
103:32 - to inject, as we did over here, in this other
thing, you don't, what we're going to do is
103:36 - actually construct explicitly that type.
103:41 - So that it is injected with the additional
configuration we do this week, because we
103:44 - have to specify a connection string that that
a client is going to need. So to do that we're
103:50 - going to do is say, Okay, so we're going to
say service
103:54 - service provider,
103:56 - we're going to receive that service provider.
And then we open up braces, going to add column
104:04 - there. And then over here, we can do things
like First, let's actually grab the A, the
104:10 - the settings. So an instance of those settings
that we have populated in app settings. Jason,
104:15 - let's grab them via our MongoDB settings class.
How do we do that? So back in startup, it's
104:21 - two bar settings.
104:25 - You can use your configuration property, the
one that we have over here that has been populated
104:30 - by the runtime, you can use that one to say
get section.
104:35 - And then
104:37 - so now you need to get a one of the sections
in the opposite is the case and we name it
104:40 - MongoDB settings, which is the same name as
our MongoDB settings, settings class. Therefore,
104:46 - what we can say is
104:49 - just name off
104:50 - MongoDB settings
104:52 - sorry,
104:54 - Let me type this properly DB settings. And
then we need to import that namespace.
105:07 - Alright, so that will get us a section. And
then let's actually turn that an object which
105:12 - is returned as I configuration section, let's
105:17 - turn it into a proper MongoDB settings
105:20 - like this.
105:28 - So now we have a setting subject. And now
we can actually construct our Mongo client
105:33 - instance with
105:35 - return new Mongo client. And then we will
do settings that connection string, the property
105:42 - that we calculated in that class.
105:45 - So we that we should be ready to register
and inject the client into the repository.
105:52 - Now that we did that, it is time to actually
flip our service to start using our new MongoDB
106:00 - depository. So that we can do in this line,
you remember, we previously registered the
106:05 - email it was it already. So switching to this
other depository is as easy as you're saying
106:11 - here.
106:12 - Mongo DB items repository.
106:16 - That's all it is.
106:18 - And then one more thing that we're going to
do here just to make our lives a bit easier,
106:22 - is to tell the MongoDB, a client, the driver,
how to serialize a couple of types in this
106:29 - case is going to be a the codes and the date
time offsets. If you remember our entity item,
106:36 - it has both agreed on a date time offset.
And I think our MongoDB is that if you don't
106:41 - tell it, how exactly we want to reflect this,
these types in the database, they may end
106:46 - up with
106:47 - a representation that's not very friendly,
at least not for our learning purposes. So
106:53 - what I'm going to do is say, let's say these,
so I'm going to do
106:59 - these on serializer.
107:00 - See if I can get the right namespace,
107:08 - register serializer. Today, we're going to
say new COVID
107:17 - serializer.
107:21 - And it's going to be
107:24 - be some type.
107:27 - Let's collapse this coordinate space, that
string that tells delsey that anytime it sees
107:35 - a good in any of our entities, it should actually
serialize them as a string in the database,
107:42 - we're going to do something very similar with
our date, time, date time offsets. So just
107:46 - copy that line. And I'm going to say, date
time offset to your laser
107:51 - based on type string.
107:54 - And we'll see how these properties how the
data actually looks like in the database in
107:59 - a moment. But for now, we should be ready
to start testing this out. So I'm going to
108:02 - hit f5 here.
108:09 - And I'm switching again to postman.
108:13 - Here we're going to start logging in again.
Because we have not implemented that we can
108:17 - start with a post.
108:19 - So to do a post, just, I just opened a new
tab, and I'm going to switch the verb to post.
108:27 - We need the request URL. So we can grab that
from our previous proper use right here.
108:33 - Should be that same URL localhost 5001 items.
But what we're going to do, we're going to
108:39 - need in this case is a body, right, so the
body the payload that we're going to send
108:45 - to our API. So we'll switch to row here. And
then we're going to switch here to Jason.
108:51 - Let me minimize this a bit.
108:56 - So here, we will just a type, the JSON that
represents the entity that we want to create
109:02 - that JSON is going to be composed of a name,
if you remember, it's just going to be a name
109:09 - and
109:10 - a price.
109:14 - So trying to pick a name and a price. So for
our first item in their database. Let's say
109:18 - we go for a
109:20 - great x, and price is going to be let's say
22.
109:25 - So that's all we need for a post. And then
we're going to hit sent.
109:33 - And as you can see, the item got created 201
created.
109:39 - And we can see the response that we got from
the API. We got an ID, how to generate it
109:44 - in MongoDB and a created date created via
our controller.
109:48 - We can also check out the heaters that we
received here. And as soon as we returned
109:55 - a created at action. You can see how the location
heater has been populated as
109:59 - With the proper URL to retrieve the details
about that item, but then also how does this
110:06 - item actually looks like in the database if
you're curious. So how can we tell that. So
110:11 - let's go back to VS code. And let's stop this
and close terminal, what we can do is install
110:17 - a MongoDB extension for Visual Studio code.
So I'm going to open extensions hop over here.
110:24 - And I'm going to type MongoDB,
110:28 - in this case, is the first entry over there.
So just click Install.
110:32 - And with that, we have a way to talk to our
MongoDB instance, I'm going to close this
110:38 - one. And if you see, there's a new item on
the left side MongoDB when you click it,
110:45 - and then there's a connection to already establish
or defined there for localhost. 27, zero 17.
110:52 - This may fail the first time you try to connect.
So if it does fail, what you can do is just
110:58 - not going to do it, I'm going to remove this
connection, or I'm going to add it again.
111:02 - Add connection, localhost 27, zero 17 is the
default, and
111:05 - close the STS and that, and then we're not,
we're not using authentication at this point.
111:14 - So let's say no.
111:16 - And then hit Connect. And you're going to
see on the left side that you have a connection
111:19 - to your local instance of MongoDB
111:22 - going to collapse these and these.
111:27 - As you can see, there's a few databases here.
And some of them are really default databases
111:31 - for MongoDB. The one that we cared about what
those are closest, now that we care about
111:36 - is the catalog database that I'm going to
open. As you can see, we already have both
111:40 - the catalog database and the items a collection
over there.
111:45 - We disband these. And you can see that we
have one document for us open up that and
111:50 - these good here should match the good of the
item created. So let's see FCO 27, open up
111:57 - postman is right here.
112:01 - Sorry, the body of the response, FC 27. So
that's the item back to VS code. And if you
112:09 - click over there, you can see the actual data
that's stored in there. So as you can see,
112:14 - this is suspected as as of our document database,
it is storing the data as Jason directly into
112:20 - the database, we have an ID, the name, price
and degraded date. If we had not done these
112:25 - two lines here, these reducers realize it
lines here, the data you would see either
112:30 - for ID and for created date would be in pretty
much in a different format, that will not
112:35 - be very human friendly. But you may want to
play with that decision a little bit depending
112:40 - on on your requirements.
112:42 - I'm going to close this.
112:45 - And I think it's time to implement a tournament
winning auto route. Where are other methods
112:50 - in the depository, let's actually go for the
get items route. First,
112:56 - how to implement get items,
112:57 - the only thing you have to do is this. But
let's say return scope to our collection,
113:03 - I just collection, we're going to say find.
113:07 - And here, since we want all the elements in
that collection, we're going to just say new
113:12 - visa document.
113:14 - Oops, there will be some document, I'm going
to import namespace.
113:23 - And then that will find all the documents.
And then you're going to say to list.
113:32 - So that will give us a list of all the items
in the in the collection. So we found on respected
113:38 - a way to request all the items. But this is
just one of the ways to do it. There's a few
113:43 - other ways. But yeah, this will get all the
items in there. So with that, we can try to
113:49 - get items. So I'm going to do a five again.
113:54 - Back to postman.
113:58 - And happens do we already have the gate for
is open here. So it should be as easy as running
114:03 - these again. So just going to click Send.
114:07 - And there it is. We're getting our collection
of items. And
114:11 - see if you only have one right now, why not
create a few other ones just to have a small
114:17 - list here, as we had before. So I'm back into
the post page, the post tab, and I'm going
114:25 - to add a couple of other items. So let's say
How about an antidote
114:29 - as this let's make it 15. So he'd sent three
if he created and then one more let's add.
114:40 - Call this worked
114:43 - for the golden sward is going to be more pricey
say 40.
114:49 - It sent
114:52 - created and then if we go back to get it sent.
Now we have those three items available. As
114:59 - you can see
115:00 - Okay, now what if we have to get just one
item.
115:05 - So that's what we,
115:08 - for that we need to implement our get item,
or our get item method here.
115:13 - But before we can implement this, there's
one thing that we're going to need is what
115:19 - MongoDB calls as a filter definition builder.
And that's a way that you can kind of filter
115:27 - the items that you want to return as you find
them in the collection. Since this is a pretty
115:31 - common object that we're going to use across
multiple methods here, I'm going to actually
115:37 - just declare it up here as its own local variable.
115:41 - Sorry, class variable. So I'm going to say,
private read only filter defini shim builder,
115:51 - then we have to specify the type in this case
is going to be item. Let's call it filter
115:56 - builder.
115:58 - And then we're going to use the builders object
MongoDB. of type item, again, that filter,
116:07 - so that we have a reference to this filter
object that you will to see how we use it
116:11 - now. Forget it.
116:14 - So but to get item,
116:15 - we're going to do this. So first of all, to
build this a filter. So we're going to say,
116:22 - bar filter
116:26 - equals filter builder that equals So where
the item
116:34 - item that ID.
116:36 - So the ID of the item has to match the ID
that we have received as a parameter. That's
116:42 - the filter. And then we just have to do similar
to before items collection, find, we passed
116:50 - a filter.
116:53 - And then we don't want all the items, we just
want the one item that they should find. So
116:57 - we're going to say, single or default.
117:00 - That's all it is. With that, I'm going to
say five again.
117:08 - And back to postman.
117:10 - So this time, I'm going to open up another
tab, I'm going to paste the route forget.
117:16 - But now I have to specify one of the items.
So from our previous exercise, let's say that
117:22 - we want to look information about the last
insert. So I'm going to copy this
117:27 - ad. And I'm going to paste it in the route
item slash the item ID, and I'm going to hit
117:35 - send.
117:36 - And here is we were able to query for one
specific item, as opposed to all the items
117:44 - back to VS code is time to implement our update
method update item. So similarly to suit ticket
117:51 - item, we need to introduce a filter so that
we can tell which item to update.
117:58 - Here. Now, we have to really find these slightly,
because we don't want to have so many variables
118:06 - named item. So to avoid confusion. So the
item the existing item is going to be named
118:12 - existing item.
118:13 - Existing item that Id should match the item
that we got that ID, which is the item to
118:21 - update.
118:23 - And then what we do when we find it is items
collection,
118:29 - replace one
118:30 - filter item. So that we'll go ahead and replace
that item into the MongoDB database.
118:40 - Let's look at five and try it out.
118:43 - Five, back the postman.
118:47 - And then what are we going to copy the gate
route and open another tab here
118:52 - and use our put.
118:56 - So basic there.
119:00 - And then we have to switch, switch to body
row. I'm going to be again, Jason. Then we
119:06 - bring this down. And we have to put the body
here. So if we use if we do this, we're going
119:12 - to be updating our golden sword. Right? And
so I'm going to get the body of our athlete.
119:20 - Yeah, I mean the the format of this a put
request, I'm going to grab it from post.
119:27 - And so let's see what can we say about this
call this word? Let's call it actually.
119:34 - But in insert.
119:38 - Let's say that the price is actually much
more pricey. Let's say it's 35. So this should
119:44 - turn into a platinum. So with this change.
So let's see we're going to the output, click
119:49 - Send.
119:52 - We get a tool for no content as expected,
and then the item should have been modified.
119:57 - So if you go now, back to
119:59 - Or get route for that item, I'm going to run
it. And then as you can see, he has changed
120:05 - noticeably newsworthiness art price 75, we
get all the items, hit send, and we see that
120:13 - we have the readiness sword as the last item
120:19 - is great.
120:20 - So finally, it is time to implement our delete
method to back to VS code.
120:23 - Let's see delete.
120:27 - And
120:28 - yeah, the filter is going to be again, very
similar to our get item filter. So just copy
120:34 - that here.
120:39 - In this case, it's as simple as saying items
collection that
120:42 - delete one, here's the filter.
120:47 - And that will do each.
120:51 - So I'll hit f5. Once again,
120:57 - back to postman.
121:00 - And then again, I'll copy the router and use
input open a new tab, switch from gate to
121:07 - delete.
121:08 - Basic route, we don't need a body because
this is a delete. And I'll hit send.
121:15 - We got our tool for no content as expected.
And if you go to the get route once again
121:20 - and hit send.
121:22 - Now we don't have that bloodiness. You see
there's only two items. The other one has
121:28 - disappeared. If you wanted to delete yet another
one, let's say the great x call to delete
121:34 - 40. There it sent no content back to get get
all the items and there is no great x.
121:42 - So yeah, looks like it worked. And then I'll
just go back to VS code studies and close
121:49 - that what I want you to realize is that we
did not have to really touch that our items
121:55 - controller at all. The only thing that we
need really here, besides adding a few configuration
122:01 - and
122:03 - you know, registering the MongoDB client,
the only thing that we did is use create this
122:08 - new identity depository that was plugged in
into the service. And that is able to by itself
122:14 - do all the logic of interacting with interacting
with MongoDB, the rest of the service has
122:19 - not changed at all. And that's a great the
great benefit that we get from dependency
122:23 - injection and in this case, the repository
pattern.
122:27 - In this episode of The dotnet five REST API
tutorial, we will talk about the synchronous
122:32 - programming model in dotnet. Five, why you
should care about it, and how to implement
122:36 - it in your REST API by using tasks async and
await.
122:40 - Today you will learn what is a synchronous
grabbing model and how to use tasks async
122:46 - and await to add the synchronous programming
to your REST API.
122:50 - To understand the concept of a synchronous
programming, you can think of common scenario
122:57 - which is say preparing a breakfast.
123:01 - So when you prepare breakfast, you're going
to do a bunch of tasks. So for instance, you're
123:06 - going to prepare your pan
123:10 - you're going to heat it in order to after
that, you will go ahead and freezer max. And
123:16 - that will be followed by perhaps
123:18 - toasting some bread. And after that when the
bread is toasted, you may want to add some
123:26 - peanut butter or use butter or jelly which
you prefer. And finally, perhaps you also
123:31 - want to prepare a glass of juice. So a bunch
of tasks that in this case you have executed
123:37 - sequentially.
123:38 - If done in this way, it could take let's say
30 minutes to complete. But is that the way
123:45 - that you will usually do this?
123:48 - What about something like this is that so
you go ahead and you hit the pan. But instead
123:54 - of waiting for the pan to be heated up, go
ahead and immediately start tossing the bread.
124:00 - Right, you don't have to wait for the retest
to complete. And not only that, after pulling
124:05 - the bread to toast, you could also start preparing
your class of use. That's totally something
124:11 - that you can do at that point.
124:13 - And then yes, eventually, the pound would
be heated and you can go ahead and fry your
124:18 - eggs. And also while that's happening, you
can if the the bread has been toasted, you
124:25 - can go ahead and put a peanut butter jelly
what you're going to put in in that bread.
124:29 - So things are happening, a bunch of things
are happening kind of in parallel.
124:35 - And as opposed to sequentially. With this
kind of sequence of events, you can reduce
124:40 - significantly the time it takes to prepare
your breakfast, let's say all the way back
124:44 - to 15 minutes. These two models is what we
call the first one is what we call the synchronous
124:50 - programming model. I mean making an analogy
to our programming models that will be synchronous
124:55 - and then the other world will be asynchronous.
So in a synchronous manner
124:59 - model, you are not waiting for every single
task to complete before starting another one.
125:04 - So you started when you can, you will go back
to the previous task when it's time to do
125:10 - so. So then thinking back to our current scenario,
we do have a database, a MongoDB database.
125:16 - And then we do have a repository class that's
interacting with that database. Now interacting
125:22 - with the database is an expensive operation,
because you have to perform input output,
125:27 - right, you have to go over the wire and talk
to that database, that database may take time
125:33 - to give you back results, depending on where
it is, depending on how much load it has at
125:37 - that point in time. So it may take time, so
you don't want to be waiting for that database
125:40 - to finish the work to where you're going to
do is instead of doing a synchronous call
125:44 - to database, you're going to do an a synchronous
call to the database.
125:48 - So you start the work. And then you let it
finish work and work. While that's finishing,
125:54 - you just go ahead and do something else, if
you have to do something else. And the same
125:58 - way, we will have our controller talking to
the repository. But now we're going to turn
126:03 - it into an async call. So the controller will
talk to the opposite, it will not wait for
126:08 - it to finish doing whatever work it has to
do with the database, it will just keep going
126:13 - doing anything else that you can do. And then
eventually it goes back to that task to complete
126:17 - the work. And the same way, whoever calls,
our controller should also be able to call
126:23 - it in an asynchronous way, so that they don't
have to wait for our controller to finish
126:27 - whichever work is performing in order to continue
doing some other work. So this is what we
126:32 - call basically async all the way. So all your
calls a chain a is is when doing in an asynchronous
126:39 - way. And that provides a lot of performance
and efficiency to the execution of your code.
126:45 - In order to to reuse the asynchronous programming
model to our REST API, we will need to introduce
126:52 - a few changes to our depositories and our
controllers. Let's start by making the necessary
126:56 - changes to our items depository interface.
So let's open up the depositories items capacity.
127:02 - And here, there are two things that we need
to do. First one's going to be
127:09 - make sure that each of these items return
dusk, as opposed to item or ienumerable or
127:14 - void.
127:16 - And the other one is to rename each of these
methods to have an async suffix. Because that's
127:22 - a convention when you create an API or interfacing
says in this case, and you have if you have
127:27 - an synchros better, you should be fixing it
with async that tells the consumer that the
127:32 - method is Nic Nic method. And we will actually
start by doing that, because we're going to
127:37 - take advantage of the refactoring capabilities
of VS code. So that this renamed habits across
127:42 - the board as opposed to having to go to each
of the files and make the changes. So let
127:48 - me show you what I mean. So I'll just right
click on Get item. And I'll do rename symbol.
127:54 - And then we'll do is just type the new name
here. It is amazing. I'll hit Enter.
127:59 - And as you can see, not only the name, change
it here in the interface. Also if you see
128:05 - it, I just controller has been modified. And
128:10 - if we see here, where we're calling the repository,
get itis async is a new name that it is using
128:16 - already. Without us doing anything else he
may might have suppository is also now it
128:22 - has been renamed the method to get item async.
And the same for MongoDB. depository,
128:27 - get item async. So that factoring actually
goes all the way. So we're going to do the
128:35 - same thing for all of the methods. And then
to make things even faster, instead of a right
128:39 - click, and we're going to do is use heat f2
we use a shortcut for this. So you do f2 and
128:44 - then just type pacing. And I'm going to copy
this suffix here, enter F to base a seeing
128:52 - enter F to a Singh enter F to async.
128:56 - So with that all of our a or four methods
have haven't changed.
129:03 - Now, like I said, the only thing that we have
to do is make sure that each of these methods
129:08 - return task. And this is because a that is
a way to signal that this is not going to
129:14 - be a synchronous method anymore, but it's
going to be an asynchronous method. So what
129:17 - you do is you do
129:18 - task of item in this case. And let me import
the namespace system three tasks.
129:28 - And so like I said, this, this is saying that
when you get an item from this method, you're
129:33 - not going to get the item right away, it's
not a synchronous method anymore, you're going
129:36 - to get a task that represents an asynchronous
operation that eventually is going to return
129:41 - an item whenever a we have finished retrieving
that item from the from the from the database
129:46 - in this case. So that turns the metal internet
synchromed we're gonna do the same thing for
129:51 - the other methods here. So task of ienumerable
of item and then for the void cases, we just
129:58 - turn into desk
130:02 - And that is it for this interface, the interface
is ready to operate as an a synchronous interface.
130:07 - Next, we're going to go to our list open up
this a little bit
130:13 - MongoDB items have auditory.
130:16 - Okay,
130:17 - so let's see. Let's go one by one.
130:21 - So the first one in this list is great items
async. So I'm going to turn again Boyd into
130:26 - task.
130:29 - And then I'm going to import a way to import
the namespace, right namespace. And
130:35 - at this point, what we have to do is start
invoking the a synchronous version of the
130:40 - methods that in this case, MongoDB is item
collection offers. And this is a common a
130:46 - pattern, like in this case, I'm actually going
to open up the IntelliSense here, and you're
130:50 - going to see that for insert one, there's
an alternative insert one async method. And
130:55 - for in this case, for insert, many there's
insert many AZ met, this is going to be a
131:00 - common situation for many of these libraries
that have to a reach out to some external
131:05 - service. Since those operations can be expensive.
And they represent input output operations,
131:11 - you want to offer the capability of executing
the operation in an asynchronous way, as opposed
131:15 - to an asynchronous way.
131:17 - Where you do a C synchronous operation, like
we had before just insert one, you're actually
131:23 - doing a blocking call, where you're just you're
making it so that this method just stops there,
131:29 - nothing else can happen until the call comes
back into the method, right, in this case
131:33 - from the database. And that's exactly what
you don't want to do. So just turn turn into
131:38 - using the asynchronous method. And you will
not have to wait I mean, the code will not
131:42 - have to wait for that call to finish. And
and that will make your entire application
131:46 - way more efficient. So that is one piece of
whatever we have to do here to make that a
131:53 - synchronous call. However, we still have a
little problem here. And the fact is that
131:59 - we're missing one thing, which is the async
await keywords. So by doing async, here, just
132:04 - next to task and then await here, when we
made the call, we're kind of adding a little
132:11 - bit of a syntactic sugar around the whole
method to tell a dotnet five, the compiler
132:17 - that this is going to be an asynchronous call.
And that it please help us to not have to
132:22 - write even more code to tell it that how we're
going to go to go around this asynchronous
132:27 - call. So a sink and a weight, it really helps
us a lot in terms of defining that the methods
132:33 - are going to turn into async. So that we don't
have to write even more code to deal with
132:37 - task and how to break it. And that will be
it for grade item async. So now let's keep
132:43 - going with the other methods. Or let's go
with delete imazing. So same way, we'll do
132:49 - async task.
132:53 - And in this case, we're going to do a here's
the line where we call database. In this case,
132:57 - the lid one will do a weight is collection,
delete one async.
133:01 - Yep, and that's it for delete. Next one, get
item async. In this case, we're going to do
133:07 - async task of item, because we had to return
that item, but it as part of a task. And then
133:14 - we're going to do return await, I just collection
find foot by filter single or default async.
133:26 - Next one get is async will do async task of
ienumerable of item
133:35 - and then return await.
133:38 - And then here to list async.
133:42 - I think this is the last one update is async.
Once again
133:47 - async task.
133:52 - And then we just await here,
133:56 - we say we base one async.
134:01 - And that's all you have to do. Like I said,
By doing this, you're making sure that every
134:05 - time that you talk to the database, you're
not making a blocking call anymore, you're
134:10 - actually letting a framework, I mean, giving
back resources, I mean, giving back the chance
134:17 - to the framework to keep doing work while
we wait for the database operation to complete.
134:22 - And like I said that, that gives a lot of
more efficiency and performance back to Europe.
134:27 - Now Now we did this, as you can see, we still
have the problem with a with a meme is a possibility,
134:32 - which is, this is the original repository
we're using in the first videos. So we could
134:37 - choose to just delete really this repository
at this point because we're not going to be
134:40 - using it anymore. But as a learning exercise,
we can actually turn this guy also into an
134:45 - async a
134:46 - class, I guess, even when we're not going
to be calling anything external, right, so
134:51 - in this case, we're just dealing with a with
an email list of items. So there's not really
134:56 - that much of a need for async stuff here,
but we need to
135:00 - We need to handle the interface that were
implemented. So let me show you how we can
135:06 - do this.
135:08 - Let's start with a get is hazing. So same
thing we did before, this has to be async
135:13 - task of ienumerable item. And then we have
the important space.
135:21 - What we do here, we say return await. But
in this case, since we don't have anything
135:28 - to call noising, close by to to call, but
we have to say, say, Hey, I just want to do
135:32 - tasks that from result.
135:34 - And we're going to pass items. What this means
is that we want to create a task that has
135:42 - already completed. And we want to introduce
the value of these items collection into that
135:48 - task. So it's kind of the equivalent to saying,
hey, go ahead and execute this, execute this
135:52 - is this other method and wait for it to complete
and then return the results, right. But since
135:56 - we don't have anything to call, you say, hey,
just return a complete task with the items
136:00 - in it. And that's, that's always, so that's
how you can handle this situation where you
136:04 - don't have something else to call. Let's see
what we can do about get item async. So we'll
136:10 - do
136:14 - a scene async, task vitam.
136:17 - And in this case, we're going to use capture
in the case of a dynamic thing we're going
136:21 - to capture ID equals items where we capture
the item that was found, we do something similar,
136:28 - as before, await does that from result.
136:34 - Item.
136:36 - Yep, same thing, we return result, complete
task with the item that we that we found.
136:44 - For create item async. Again, we're going
to do async task.
136:49 - And in this case, we don't have really anything
to return. So the only thing that we have
136:53 - to return here is some some sort of a task,
right? So we're going to say is a weight task
136:59 - that in this case, we can do a completed task.
So this means just create some task that has
137:05 - already completed and return it without returning
anything inside it, because there's nothing
137:10 - to return. Now let's move to update a item
async. So async task.
137:17 - And then once again, copy this await task,
that completed task. Finally, we'll do the
137:25 - Delete. So async task
137:29 - and await task that completed task. Yep. So
it's as simple as that. Now, just to let you
137:39 - know,
137:40 - it is not necessarily it is not necessary
to use async and await in every single case,
137:46 - you could go around and avoid a avoid this
combination. In some cases, however, I would
137:52 - consider that to be a bit of an advanced concept
that I will not like to dive into that right
137:58 - now just because it has some pitfalls that
you have to be aware of. And it is not trivial
138:02 - to know them beforehand. So for now, I would
recommend you to stick to async await anytime
138:08 - you have to run an asynchronous INVOKANA synchronous
operation and define your own method as an
138:14 - asynchronous operation. And now let's go to
our itis controller and do the final set of
138:19 - modifications that we need to introduce here.
138:22 - So let's start with a get items. Right so
same thing.
138:25 - Let's turn this guy I mean this is a sink
all the way right so we have to turn everything
138:30 - async now async task of ienumerable identity
all these forget items. So again, importantly
138:38 - space.
138:39 - Let's not forget that this method now should
be suffixed with async because it is an asynchronous
138:45 - method. Now here what we have to do is again
do and await
138:50 - and await for the get a get is async call.
But it's it's a bit more problematic here
138:55 - because
138:56 - the weight is separated from the from the
actual method, and we're trying to chain a
139:02 - select right away, that's that's not going
to work, we have to wrap this into into these
139:08 - parentheses to tell it that first go ahead
and do this. And when that's completed, then
139:14 - go ahead and do the Select right so that is
just to comply with the with the syntax that
139:19 - the compiler is expecting from us. I'm actually
going to put this in this in a second line
139:23 - to look at it better. And just before we go
ahead to get is async await for it and when
139:30 - that's done, we select the items that we got.
We turn them sto and then we just return them
139:36 - back to the caller.
139:38 - When we learn to get item, we're going to
do now
139:40 - a sync task of actually sold it to and
139:51 - it should be get item async.
139:55 - And here when we call get item async we used
to await
140:01 - That will do it.
140:02 - When we don't do the next one post, we will
do
140:06 - async task.
140:10 - grade item pacing.
140:17 - And then here is where we create the items.
So we will do a weight, create animation.
140:22 - And then remember that now the method is actually
named the get item async here, so we have
140:26 - to do the proper rename.
140:29 - Next one update item.
140:30 - So let's say async task.
140:35 - Action result update item, a sink.
140:39 - And let's see, here's what we call it. So
we will say await get item async. And over
140:45 - here, we also have to await for the call to
update item async. And finally, let's go to
140:51 - our delete item method. It's going to be again
140:56 - async. task, action result list item async.
141:02 - And then await
141:06 - and then over here,
141:07 - wait suppository, delete item async. So now
our controller is all async and is calling
141:16 - methods that are all async. And the depositor
is also calling methods are always in. So
141:20 - we're doing async all the way basically. So
let's see how this goes. So I'm just going
141:25 - to do f5 now.
141:32 - And I'm going to open postman.
141:36 - Let's see, let's start trying out the API's.
First one here, the first one that we had
141:40 - is a the items. So let's try to get the full
list of items. So I'll hit send.
141:47 - And as you see, we do have the antidote from
the previous video still hanging around, that's
141:53 - working just fine. Now let's try to create
a brand new item, right, so how would we call
141:58 - it let's say this is going to be
142:00 - high potion. So a potion that provides increasing
strength to the player. And so the price is
142:08 - going to be, let's say 30.
142:12 - And I'm going to hit send. Let's see if that
works.
142:17 - So we do have an issue here, we're getting
a 500 internal server error, and no route
142:23 - matches the supplied values. So this here
is actually unexpected situation. This is
142:29 - because of a breaking change in ASP. NET Core
three. And let me let me show you why this
142:35 - happens. Let me go back to items controller,
I'll use a stop this, close that. And if you
142:41 - remember, what we just did a in grid item
async method is that we updated or created
142:48 - an action call here, to use a name of get
items get async as opposed to get item because
142:55 - we just rename it that method over here, get
item async. It was get it before. And now
143:01 - the breaking change that interested in ASP.
NET Core three zero is that at runtime, the
143:07 - framework is going to actually remove the
async suffix from from the mid range at runtime,
143:15 - this actually looks like just get it as opposed
to get Iam async.
143:19 - Given that when we try to do the greatest
add action call here, it is not able to find
143:25 - the route that represented by that action.
And so that breaks things. So there's a couple
143:30 - of ways to fix this. And what I'm going to
do is to actually tell a dotnet that I don't
143:36 - want that behavior, I just want to keep using
the async suffix. So to do that, what we can
143:42 - do is just go to startup
143:43 - startup, what you want to do is find your
call to our controllers. And there, you just
143:50 - have to specify a one option, which is options.
Let's see options, open curly braces, and
143:57 - then you want to do options that suppress
a theme suffix in actual names
144:04 - equals false with that, that that will not
remove the async suffix anymore from any method
144:10 - at runtime. So let's see how that goes.
144:15 - like five,
144:19 - back to postman.
144:21 - And now the one thing that you want to keep
in mind is that the creation actually succeeded.
144:26 - It just happens to be that we were not able
to be a we were not able to create to invoke
144:32 - the created our action a call, right. So just
to confirm that if you go back to get a return
144:36 - to do a get here, you will see that we do
have the high potion created. So it is there.
144:42 - But we will not we were not able to complete
the creation. I mean, we were able to call
144:46 - the Create action successfully.
144:50 - So let's actually create something else here
to not confuse these with a high portion.
144:54 - So let's call this one mega potion, or mega
potion is going to be more expensive. Like
144:59 - let's say 45
145:00 - So now I'm going to do sent.
145:03 - And this time, they actually it was actually
created successfully.
145:07 - No issues there.
145:10 - Now let's use the A this item to actually
try the get route. So just to get a for that
145:18 - item, let's see if that works.
145:19 - That works just fine. And now let's try our
put our put route for that item. As so let's
145:30 - see, we're going to use the same name, perhaps
make a potion. But let's put another price.
145:36 - Let's see what price we have. Here we have
45, let's say it's even more expensive 50
145:41 - for the mega potion.
145:43 - So I'll hit send.
145:46 - And that should have updated the mega potion.
So let's go back to the gate, make sure that
145:51 - the price changes. So hit send again. And
as you can see, price is now 50.
145:58 - And
146:00 - let's see, let's actually not delete that
makeup in we're going to try to delete route.
146:03 - But let's delete something else. Let's say
we want to delete this high portion. Actually,
146:07 - he's kind of our favorite experiment. So I'll
copy that ID. So I'll try to delete that.
146:12 - Anil he'd sent two or four new content back
to the target route. Let's see what we get.
146:20 - And as you can see, Hypatia is gone. So we
only have the antidote and the mega portion.
146:26 - You want to configure that things are actually
getting read into the database. It's as easy
146:32 - as going back to VS code, and close. And I'll
open up again, our MongoDB extension here,
146:39 - catalog items. And we do have let me refresh
this. We do have two documents, one for the
146:46 - antidote.
146:49 - And whilst they make a push, and yeah, now
you have fully a synchronous
146:55 - REST API, which is going to give you great
performance and great efficiency. And from
147:00 - here on.
147:01 - In this episode of The dotnet five REST API
tutorial, we will talk about secret management
147:05 - and health checks. We will see how to securely
store secrets during development that your
147:10 - REST API can use easily as with any other
piece of configuration. We will also learn
147:14 - about health checks and how they are a great
way to report the health of our API.
147:18 - Today, you will learn how to store and use
secrets via the dotnet secrets manager and
147:24 - how to use health checks to report the health
of the race API and its dependencies.
147:29 - So let's talk about secret management. As
you know, at this point, we do have a REST
147:34 - API that is able to talk to a database or
MongoDB database.
147:40 - And in order to be able to talk to it, we
have defined a configuration service where
147:44 - we have specified details like host and port.
So to be able to connect to that MongoDB database.
147:49 - The configuration source that we've been using
so far is our app settings, that JSON file
147:54 - right
147:55 - there, we have host localhost and Port 27,
zero 17.
148:00 - But now we are going to enable authentication
to the MongoDB database. So you're going to
148:04 - need a username and a password in order to
be able to connect to it. We have to tell
148:09 - our REST API how to how to use this information.
So for the user, we're going to add our user
148:18 - another user is setting in top settings JSON
for are going to call it just MongoDB admin
148:22 - for the username. And then we also have to
specify a password. So should we just specify
148:28 - the password directly in the app settings
JSON file? Well, the answer is no. You don't
148:33 - want to add any sort of secrets into app settings
JSON or into any of the files that you have
148:39 - that are part of your service. Right. So that's
a basic, good practice in terms of security,
148:45 - never introduce secrets in there.
148:49 - If we cannot do this, then how are we going
to pass that information into the service.
148:54 - So it tends to be that
148:55 - app service JSON is just one of the possible
set of configuration services that can feed
149:02 - into your REST API. There are other options
like you could use a command line arguments,
149:08 - you could use environment variables, or you
could even use a bunch of other cloud searches,
149:14 - searches coming from the cloud that can provide
configuration information into your REST API.
149:19 - In our case, we're going to use one that's
called the secret manager. This is just one
149:24 - more configuration source that's built in
into dotnet. And that is already pre configured
149:29 - for you, for any new brand new web API are
in that secret barrier. We can securely store
149:36 - our password, let's say pass in this case.
And without having to put that password within
149:42 - our REST API. So it's not going to be in any
of the files that compose our REST API. It
149:46 - will be in some placing our machine securely
stored, but yet, they are REST API is not
149:52 - going to have any trouble reading that. That
password because just as as anything else,
149:56 - it is coming just as a new piece of information.
149:59 - majorly from our configuration service. And
the rest the REST API can easy to consume.
150:04 - We are now going to enable authenticated access
to our Mongo database. There are a couple
150:11 - of ways to do this. But to keep things simple
and safe, this is just a development database
150:14 - for learning purposes, we will delete the
volume where Mongo container currently storing
150:19 - all the data. This allows us to start a new
container with a brand new Docker volume with
150:23 - authentication will be enabled.
150:25 - So the first thing that you may want to do
is verify if you're running the container
150:29 - already or not. So we're going to do is open
a new terminal.
150:34 - And I'm just going to do docker ps, that will
tell you if you have the container running
150:40 - already. And you are indeed, in this case,
I am. So what if the first thing that I have
150:46 - to do is to stop this container. So I'm going
to do Docker stop Mongo
150:51 - that stops the container. And now what I want
to know is, which is the volumes that I have
150:56 - available here. So Docker volume, LS, that
will give us the one volume that we care about
151:04 - right now MongoDB data. And now what I'm going
to do is just delete it. So Docker volume,
151:10 - RM MongoDB data.
151:14 - So now the volume is gone, we are free to
restart the container with a brand new volume.
151:20 - So what I'm going to do now is just a grab
the initial set of a, the initial command
151:27 - to run the container, just as we did before.
And then as you can see, the same volume is
151:32 - here, there's going to be a new one, since
we deleted it already. And what I'd like to
151:37 - do is just add a couple of environment variables
that represent the username and password that
151:44 - are going to be used at a within the database.
So if I just do dash E, and this is the file,
151:50 - the name of the variable, in this case is
going to be Mongo in it.
151:58 - dB.
151:59 - Root username.
152:03 - And here we specify the name for our user,
you could use any name here, I'm going to,
152:07 - I'm going to use Mongo admin.
152:11 - So that goes for username, and now the password
152:13 - for the password, you have to use Mongo ini
dB,
152:19 - root, password,
152:22 - equals, and then you got to pick a password.
So I'll pick something here, not super strong,
152:28 - but still
152:30 - something like these.
152:35 - And finally, the name of the of the Docker
image that we want to use in this case is
152:39 - Mongo. So with this, it's a hit Enter. And
now we do have docker ps, we do have a database
152:48 - that has authentication enabled with a user
of Mongo admin and a password of pass bout,
152:54 - we're one.
152:56 - So at this point, our database requests authentication,
but our service does not know about it yet.
153:02 - So what happens if we try to query date at
this point, what I'm going to do is just hit
153:06 - f5, the service.
153:10 - Okay, and then go into postman. And I'll just
try to query for a few items and see what
153:16 - happens. So these are items query it sent.
153:21 - And yes, command find failed command phi requires
authentication, right? So just good. authentication
153:28 - is working. It's just that our service does
not know the correct credentials to talk to
153:34 - the database. So how can we make a how can
we make this service a aware of the user and
153:41 - password needs to use. So let's go back to
VS code. Let's stop and close this. And what
153:47 - I'm going to do is, first I'm going to declare
a a configuration setting for the user. So
153:54 - I'm opening up series Jason. And in this section
where we have MongoDB settings, I'm just going
154:00 - to add a one more section here.
154:04 - For for user, let's call it user.
154:07 - And we know that the user we specify for the
database is Mongo.
154:10 - Now, we also need a password. And of course,
I could specify a password right here. But
154:18 - that it's not a good idea. You should never
specify a secret or confidential information
154:23 - in your app settings JSON file, that's a security
kind of a security hole. So you should not
154:30 - do that. Instead, we're going to take advantage
of the dotnet secret manager to store the
154:37 - password security as still we should be able
to pull that secret into the service into
154:42 - the REST API without any trouble. So to do
that, again, I'm going to open a terminal.
154:49 - And here's what I'm going to do. First, let's
initialize the secret memory for our project.
154:53 - And that we can do via dotnet user secrets
154:57 - a bit
154:59 - And if you take a quick peek into catalog
CEUs blog, you're going to see that there's
155:06 - a new entity there. User secrets ID. So this
represents a identifier of this secret configuration
155:14 - for this project.
155:17 - From here on, we can start actually adding
secrets to the for this project, and do a
155:22 - secret what you can do is.net user secrets
155:27 - set. And here you have specify the name of
the secret. Now for the name where we want
155:33 - to do is follow the convention of the settings,
155:38 - the settings property that we have defined
already, and yours a add to it in the in,
155:44 - in the in the format accepted by the net.
So in the in our case, that means is specifying
155:50 - MongoDB settings, and then we do colon, and
then we specified the actual a property that
155:58 - will represent the password, this case is
going to be use password.
156:03 - And after that, we specified the actual value,
in this case for the password, and we know
156:07 - that the password is pass bound word one,
or one.
156:13 - Okay. So just like I did here, what I'm saying
is, is that the, the, the name of the secret
156:21 - is going to start with MongoDB settings, which
matches a MongoDB series right here. And password
156:26 - is one of the properties that is going to
follow the other properties that we already
156:30 - have in the MongoDB settings class, and the
actual values passed
156:34 - out word one, hit Enter. And the secret has
been add. What we need now is a way to read
156:43 - both username, the user and the password into
a our service. To do that, we're going to
156:50 - go into our settings, settings class MongoDB
settings.
156:55 - Absolutely, let's close this.
156:59 - Let's add a couple of new properties here.
So let's add
157:05 - string, user.
157:10 - And string
157:13 - password. So these are the two properties
that will be populated at runtime by dotnet.
157:19 - into into our app.
157:24 - Now,
157:25 - the other one that we want to define is a
modified connection string because now it
157:30 - is not going to be enough to provide us whole
support. We have specify user and password.
157:34 - And the way that you do that for a MongoDB
connection string is by saying
157:38 - user colon
157:44 - password. And then we'll say at host column
port. So that's the same text that MongoDB
157:52 - is expecting from us. So just by doing that,
let's try equating again and see what happens.
157:59 - So I'll do a five.
158:03 - And I'll go to postman now. So let's see if
we can query for information sent.
158:12 - And yes, we don't get anything because remember,
these are brand new database because we modified
158:16 - the volume, but we are getting a 200. Okay,
oh, things seem to be a running just fine.
158:23 - And just to be completely sure, what we're
going to do is do a post. And we'll switch
158:27 - into the post tab here and see if we can actually
recreate this mega portion with price 45.
158:32 - And not just that, let me actually put a breakpoint
over here. And to see how these values look
158:39 - at runtime. And Cynthia Singleton, I'll have
to stop and restart our, our service. So let's
158:48 - hit f5 again.
158:49 - So the first time that the connection is needed,
we should hit this breakpoint. So go to postman.
158:54 - And I'll do send here.
158:59 - And I suspected we have a breakpoint here.
So as you can see, the user has been read
159:04 - from our app settings JSON file, and the password
has been read from the secrets manager. So
159:11 - password is not at all reading, updating JSON
is just coming from secrets manager. And
159:16 - really that that that magic that takes that
does running here is being driven by program
159:22 - CS when we do create default builder, that
piece takes care of injecting the secrets
159:28 - barrier as one more configuration serves to
our service. So you don't have to do anything
159:35 - special for that to happen. So if this happened,
and we just let it keep going.
159:41 - Go back to postman. And in fact, yeah, the
mega portion has been created. If we create
159:46 - it for them. We'll see that it is right there.
159:52 - So moving on to the next topic. Let's now
start talking about health checks and how
159:56 - to enable them. So But first, let's learn
about health checks.
160:01 - So as we know, we do have a REST API at this
point that is talking to a MongoDB database.
160:07 - However, it is not uncommon to face issues
as time goes by, right? So a REST API could
160:14 - go down for a variety of reasons. Or it could
be a good intention, right? We may be redeploying
160:20 - these REST API to our, to our server to our
cloud service or to our server wherever it
160:25 - is going. So even if temporarily, that REST
API could go down.
160:29 - And there will also be issues on the other
side with talking to our database, right?
160:34 - So for any reason, that database, we may lose
connection to the database, either temporarily
160:39 - or for a long time.
160:42 - Or something could be going on, and we're
really talking to that database, right? So
160:45 - communication issues could happen. So with
this, we may start getting equations like,
160:53 - is our REST API alive? So is it alive? Ganga,
we actually talk to this REST API. Right.
160:59 - So you may start wondering this, or you may
start wondering, Well, can we reach a database?
161:04 - So is it there? Is that connection in a good
state?
161:09 - So but really, what you're asking here is
the broader question, is it healthy? So is
161:16 - our race API healthy? Is it ready to receive
quiz? Is it ready to do the job the right
161:21 - way?
161:23 - And to answer that question, the right way
to do it is to enable what we call health
161:29 - check endpoint. So so you don't have to guess.
So we will have, you will have a natural endpoint
161:35 - that you can call is part of our universal
API. And you can call to it and it should
161:39 - be able to tell you if the service is healthy
or not. Right. And, of course, there will
161:46 - be a person or people interested in that information.
So us as, as a developer, as an engineer,
161:54 - that increases service may want to query for
that help endpoint as either services healthy.
162:00 - But really the most important case, the most
useful and original a scenario is when you
162:06 - have an orchestrator system, that will be
in charge of knowing when your service is
162:12 - ready to receive requests. So we will talk
more about this in a few episodes in the future.
162:19 - But
162:20 - having a health check endpoint is a key piece
of any REST API that you have think about
162:25 - right away.
162:26 - Now that we learned about health checks, let's
see how we can enable them for our REST API.
162:34 - So the first thing that we have to do is to
add the services for health checks and that
162:39 - we can do within startups. Yes. Before that,
let's stop debugging and close terminal and
162:45 - open up startup CS. And I'm going to head
into the Configure services method.
162:50 - In this method, we're going to go all the
way down.
162:56 - And we're going to add just one line here.
Services dot add health checks
163:01 - in now, so that's the services and now we
need to add the middleware for it. And that
163:09 - we have to do inside the US endpoints method
inside Configure. So here, we're going to
163:14 - say, endpoints that map health checks. And
then here, you get to pick the route that
163:22 - you want to use for your health endpoint.
So in my case, I'm going to go for health.
163:28 - But feel free to choose something else, like
you could do something like hc, or you could
163:33 - do health See, it's really up to you, what
do you want to use, I'll go for those held.
163:40 - And now I'm going to do a five. And let's
try it out. So that should give us a very
163:45 - basic health check endpoint for service. So
back to postman. And the way that you query
163:52 - for this health check is really very similar
to what we do for the iTunes route. So we
163:56 - just have to open up in a new tab in postman
for the get burb. And I'll go for my localhost
164:03 - colon 5001. And then you just add the URL
to route our case is held. I'll hit send.
164:13 - And here's you get a result, he says healthy.
164:17 - So with that, you have a way to almost like
being your service to see if it's in a healthy
164:24 - state. So this means that yet the services
is up and running, and everything should be
164:29 - fine.
164:30 - However, this is actually not super useful,
because even if the service is up and running,
164:37 - it means nothing if the database is down,
right, if the service is down, or if we cannot
164:41 - reach it.
164:43 - Our service is not really that much healthy.
164:46 - So how can we tell if we have any dependent
service like a database in a not in a healthy
164:51 - state? And how what how can we take advantage
of health checks for this? So let me show
164:56 - you what we can do.
165:00 - Going back here, stop that close these are
going to do is add a nougat package.
165:08 - That's called ASP. NET Core healthchecks MongoDB.
That will allow us to add health check is
165:14 - specifically designed to verify if MongoDB
is running properly. So I'm just going to
165:19 - open a new terminal here. And I'm going to
say dotnet, add package, ASP. NET Core health
165:29 - checks MongoDB.
165:31 - So this is an an open source project, it's
not part of ASP. NET Core or dotnet. Five,
165:38 - but it is a very handy project. And with these
with this package, the let me show you what
165:45 - we can do.
165:46 - Close the terminal again. And then.
165:51 - So here, what we want to do is add some options
to this call to add a health checks. But before
165:57 - we can do that, we need to pull out our MongoDB
settings in such a way that we can reduce
166:03 - them later on. So to do that, I'm just going
to grab this, this line here,
166:10 - outside and into, let's say here,
166:16 - and we will call these MongoDB settings.
166:20 - So now those MongoDB settings can be used
over here for our MongoDB client Singleton.
166:28 - But also for our purpose right now, after
saying a uthealth checks, we're going to say
166:34 - that at MongoDB. And here we will use MongoDB
settings,
166:43 - that connection string
166:45 - to specify the connection string that needs
to be used to connect to the MongoDB database,
166:50 - right or health check is going to be based
on can we reach this database or not. We will
166:56 - also add a couple of things here, like a name
used to define this specific health check.
167:03 - And we will just say MongoDB. And one more
thing is a timeout.
167:10 - This is because we don't want this healthcheck
to take a long while to tell us if the database
167:14 - is is just down. Right. So in this case, we'll
say timespan from seconds, let's give it three
167:21 - seconds. If after three seconds, we cannot
connect to the database. But we'll consider
167:26 - that this has failed write the check has failed.
So now that we did that, let's try it out.
167:33 - So I'll do f5.
167:34 - And let me actually remove this breakpoint.
167:43 - And back into postman. So here, yeah, I'm
going to say hello again sent. And it is healthy.
167:51 - And I suspected because our database is up
and running. But if I go back into VS code
167:59 - into our terminal, and I use a stop our
168:02 - MongoDB container. So let's see Docker stop
Mongo that will is Docker container, which
168:11 - is equivalent to just stopping completely
our database, right and the entire database
168:15 - services going down. So let's see what happens
as I go back to postman. And I tried to check
168:20 - her health
168:21 - will take like two seconds. And then yes,
right here. So now health check is reporting
168:29 - as unhealthy. Which is great, because now
anytime a database is down, we can easily
168:35 - tell that that as part of the health check
that we're using right here.
168:42 - Now there's one more thing that we can use
to improve the scenario. And is the fact that
168:47 - we may want to have more than one endpoint
to verify not just the fact that the services
168:54 - is up or not, but also if it is ready to receive
requests or not. And the typical pattern here
169:02 - is specify both a ready endpoint and a live
endpoint. So our ready endpoint is going to
169:08 - tell us if we are ready to well, if a service
is ready to receive every incoming request,
169:16 - right, which in our case really means so is
the database up and running Ready to go? Can
169:20 - we use it? While the live endpoint is just
going to tell us if our service a justice
169:26 - service is up or not? Is it alive or not.
169:31 - So to do this is these two endpoints, let's
actually go back to VS code. I'll stop this
169:38 - again.
169:39 - And back to startup.
169:40 - First thing that we have to do is going back
to our health check configuration, we have
169:46 - to assign an attack to our health check to
let me show you what I mean. So actually put
169:53 - these things down a bit so that we can do
the easier. So I'm going to open up a
170:00 - One more line here. And I'll say tax.
170:06 - So I'll create a little array here.
170:11 - And here, I'll say ready. So here I am attaching
a tag that I'm calling ready. That will help
170:17 - me a group, every single health check for
which I want to apply are ready endpoint.
170:24 - So the endpoint that specifies if I'm ready
to start receiving requests,
170:30 - how do we use this. So now let's go back to
our map health check section.
170:36 - And I'll add a line here.
170:39 - So now we know we need to specify in our two
endpoints, one for ready and one for life.
170:45 - So let's go for the raven first. So instead
of just having held here, I'm going to say
170:50 - okay, slash ready, it's going to be our ready,
ready endpoint. And now has specify health
170:57 - check.
170:58 - Health Check options, see for museum a space
right there.
171:07 - Okay, open up this. So at this point, we have
to specify what we call the predicate for
171:13 - the predicate is the way that you can filter
out which health checks you want to include
171:19 - in these in this endpoint. So remember that
right now, we only have one really, our that
171:24 - one has been tagged with ready. That's one
form of MongoDB. So in the case of the radium
171:30 - point, we want to include that MongoDB endpoint.
So to do that, what you do is is this, you
171:36 - say check.
171:39 - And then we'll say check tags contains.
171:46 - And then the tag name ready
171:47 - that you have already endpoint that will,
will will only include those a health checks
171:56 - that have been tagged with ready.
171:59 - And then we have to define another endpoint.
So I'm going to actually copy, copy these,
172:05 - these one is going to be just live.
172:08 - Really, for the live case, we don't have to
do much, we actually don't want to, we don't
172:13 - want to include any health check, we just
want to say a kind of the response over pink
172:17 - rice. In this case, we're saying just false.
By doing that, we are excluding every single
172:24 - health check, including the Bongo DB one,
and so that it would just come back to us
172:28 - as long as as long as the REST API is alive
as the service is alive. So that's the way
172:33 - that you can do the life. So ready, we'll
make sure that the database is ready to serve
172:39 - requests, life is just going to make sure
that our site, our service is up and running.
172:44 - So with this, let's run again. So I'll do
f5.
172:52 - And I'm back into postman. And this time,
so let's, let's see. So I'll query for, let's
172:58 - see, health, life.
172:59 - see what we get.
173:01 - So he says healthy, is expected because the
service is up and running.
173:08 - Now I'll try ready.
173:11 - see what we get.
173:14 - So after about three seconds, we do get unhealthy.
And this is because our database Docker container
173:23 - is still still down, right? as we did before.
If I go back here,
173:30 - and I go back to my terminal, let's say this
one, and actually restarted the Docker container.
173:36 - For Docker, Ron, Yep, sure, do it. That starts
a container again, go back to postman. And
173:44 - he'll sent and I get held up because the database
server and the database are they're up and
173:52 - running.
173:53 - And usually that's good enough. So that's
what you want to do to enable your your health
173:55 - checks. But if you happen to want a little
bit of more information about
174:03 - the health check that you have configured,
you can actually customize the message that
174:07 - you're getting here. This gives us the basic
thing healthy, but you can get more if you
174:11 - want to answer Let me show you how to do that.
174:15 - So back in VS code, open close,
174:19 - we're going to look for our map health checks
function. The red one in particular is interesting.
174:24 - And what we can do is take advantage of what's
called the response writer.
174:29 - This is post writer you can use to specify
how to render the message that you're getting
174:34 - as you're collecting the results of the health
checks. So I'm going to say
174:38 - async context.
174:41 - Sorry for that
174:45 - context report.
174:48 - Let's do this and then open curly braces,
and then here I'm going to collect the result
174:57 - of the of the checkout.
175:00 - So for that, I'm going to say sold equals,
I'm going to use the JSON serializer.
175:08 - The one that comes with dotnet,
175:12 - I'm going to serialize.
175:15 - Now we're going to create an anonymous type
here. So I'll just say new. And then we have
175:22 - to give it a shape. So this is the shape of
what we're going to return back into postman,
175:27 - to the collar. So the first thing that I want
to show is a status started, we can get from
175:32 - report
175:33 - dot status, just to string.
175:40 - And then we want to get the array of checks,
175:44 - which should include our MongoDB check. So
in this case, I'm going to say report entries,
175:50 - select.
175:51 - And I'll say, so I project each entry into
a new anonymous type.
175:58 - And in this type, I want to show first the
name,
176:03 - which is going to come out of entry that key,
then I'll get the status of this very specific
176:07 - check,
176:08 - which is going to come from entry value status
to string.
176:17 - And then there could be an exception coming
from the database. So let's actually capture
176:20 - that too.
176:22 - Oops, sorry.
176:24 - exception, is going to be empty that value
that exception, but we may or may not have
176:31 - an exception, depending on the status of this
check. So we're going to say is that if the
176:35 - exception is not No, we will get an entry
value, exception message. But if we don't
176:45 - have any exception, if it is no, we will just
say not.
176:49 - Finally, one last detail could be interesting
is the duration that will tell us how long
176:55 - it took to do this health check.
176:58 - And three value, duration to string.
177:02 - game, so to taste.
177:07 - And now one more thing that we can do here
is to format that output. So I'm going to
177:13 - say, context, that response that content type
equals
177:19 - media type names.
177:23 - And using something
177:26 - that application that Jason,
177:31 - that will let us render as a nice JSON string,
back in postman. And finally, I'll actually
177:36 - write this information out. So await context
response. Right?
177:46 - Right async
177:47 - result
177:49 - using one new spacer.
177:56 - And that should do it. So now we have customized
how that message should be rendered. So I'm
178:00 - going to do a five once again.
178:05 - And back into postman. So let's see what happens
when I tried my radio endpoint now, sort of
178:11 - hit send.
178:12 - And now as you can see, the result is a bit
nicer. So we do have a status of Lt. And then
178:17 - we can see the array of objects. In this case,
we have MongoDB, with a healthy state nociception
178:22 - and a duration in there. And if we wanted
to get the sample with an actual exception
178:29 - to this, you can just stop your local Docker
container again.
178:33 - stalker stop Mongo
178:37 - container stopped. I'll try again back in
postman sent.
178:43 - And after three seconds, we should get Yeah.
So now, as you can see, here, the entire health
178:48 - check is unhealthy. The specifically MongoDB
is unhealthy. And yeah, the operation has
178:53 - been canceled. So that's what we're getting
from, from dry dock to MongoDB.
179:00 - Now one last thing that I wanted to show you
is that there's actually a bunch of health
179:04 - checks already available for you. And so just
like we did a MongoDB one, let me stop and
179:11 - close this. If you remember, we did
179:14 - this here, we did the MongoDB. One, just like
this, there's a bunch of other ones already
179:21 - available for you to try out, depending on
the service that you're using. Let me point
179:25 - you to this page here, which is a page for
the open source project that I mentioned that
179:31 - has these health checks. So over here in this
GitHub project, you're going to see that so
179:37 - this will tell you everything about how to
use these health checks. But I wanted to show
179:41 - you that there's already health checks built
in for a bunch of providers, right, so SQL
179:46 - Server, MySQL, a bunch of things Cosmos TV,
send sendgrid, a few Azure services, Amazon
179:52 - services, Google stuff, here's the one that
we use MongoDB. And
179:56 - so yeah, so there's
179:59 - A bunch of providers already available. And
there's even an here's a nougat package that
180:04 - you can use. And there's even support for
let me show you the support for for a UI.
180:10 - I don't usually use this one. But if you wanted
to show a very nice UI with all your health
180:16 - checks, with a breakdown for for each of the
checks, you can actually enable these, these
180:20 - health check UI. Sorry. And yeah, and that
will just stand up another endpoint in your
180:26 - in your service that you can go to, and get
all these nice UI rendered. So that's something
180:31 - that you may want to try it out. I usually
find there's some old ways that I quantify
180:36 - the help of my services, as we're going to
see as we move forward with these videos.
180:40 - But this is another option that you can try.
180:45 - In this episode of The dotnet five REST API
tutorial, we will start our path towards getting
180:49 - our API deployed to our production environment.
We will learn about the relational challenges
180:54 - involved in getting the API beats deployed
outside of our developer box, how Docker can
180:59 - help us address these challenges, and how
to turn our existing API into a Docker container.
181:05 - Today, you will learn the challenges of deployment,
how Docker works, and why you should use it,
181:11 - how to turn the REST API into a Docker image,
and how to run your REST API as a Docker container.
181:19 - So the way that things are at this point,
you know that we do have a REST API up and
181:25 - running in our local box. And there's also
a MongoDB database running next to it as a
181:32 - Docker container.
181:33 - But now we need to figure out how we're going
to share this REST API with the world, right,
181:39 - either how to share the REST API with people
inside of our local intranet, or how to share
181:45 - the REST API with the world perhaps in the
public Internet. And that place where we're
181:50 - going to share things is what we're going
to call the production environment. The production
181:54 - environment could be anything from some server
running in your in your building, or your
182:02 - house. Or it could also be some server running
software in the internet, right. But for all
182:07 - cases, this is the production environment,
this is a place where people will be able
182:10 - to access the a REST API without having to
get access to your local box, your developer
182:17 - box. And one of the first things to think
about when we want to pick this, this server
182:23 - for production is the operating system. So
we will need to figure out when to find
182:32 - the right server with the correct version
of the operating system that our REST API
182:37 - is able to support. So in the case of for
REST API is not really that much of a big
182:42 - deal, because that five is cross platform.
So what we have built so far is to be able
182:47 - to run in really in a bunch of operating systems.
But still, we need to sell install operating
182:53 - systems. So if we say that we're going to
be running this on on Linux, then we would
182:57 - need to go ahead and make sure that we have
Linux available the correct distribution and
183:01 - version of Linux available in that production
environment.
183:06 - Then, we also know that we do need the dotnet
five runtime to be able to run a REST API,
183:13 - the REST API is built on dotnet five, therefore,
we do need the dotnet, five run time, and
183:19 - all the corresponding files of it, they need
to be placed in the right place in that production
183:24 - box. On top of that, our app may have a bunch
of dependencies, like the MongoDB driver that
183:31 - we've been using to talk to one MongoDB. So
like that, it may have a bunch of dependencies
183:35 - that they also need to be placed into the
production box. So that finally,
183:41 - our REST API can be placed alongside all of
these other components, and it can run happily.
183:48 - So it is at that point that we can, we can
continue that we have all the files and sorry
183:53 - for the REST API to be running in production.
183:57 - But then also, we have to consider that we
also have database requirements, right. So
184:01 - we have a database that we need to play somewhere
in this production environment. And it will
184:06 - have its own requirements in terms of operating
system, and dependencies that MongoDB may
184:11 - have the MongoDB and Gene, all these things
that we need to run the database in production.
184:16 - So that by itself presents another set of
requirements. So as we think about all of
184:22 - these, these things that we need to that we
need to happen to get our production up and
184:26 - running. So we need to think about a few challenges
right. So the first thing is going to be preparing
184:31 - a box. So what you really want is to make
sure that whatever box we use for production
184:37 - has everything that we that we have had so
far in our developer box, right. And then
184:43 - but you also have to think about so are we
going to pick a physical machine Are we going
184:47 - to pick a virtual machine or virtual machine
is really just average the latest version
184:51 - of operating system running on top of some
other physical machine. So any regardless
184:58 - if office
184:59 - same physical machine virtual machine, we
need to figure out well, where are we going
185:02 - to get this machine from? Where are we going
to host it? Who is going to be taking care
185:07 - of this machine? A bunch of questions just
regarding this this machine. But also way
185:11 - to figure out okay, so is it going to be Linux?
Or windows? Who's going to put the right version
185:17 - of the always in there? Who's going to make
sure that he has the right set of patches?
185:20 - And who's going to maintain these? Really,
somebody has to take care of these things?
185:26 - But also, how are we going to take the files
to the production machine, right? So we have
185:32 - all these files in their box? And somehow
they need to land in production? How are we
185:35 - going to do this? If we're going to be using
perhaps some FTP protocol, to be able to talk
185:40 - to an insanely fast to production machine?
Are we going to put the files in some USB
185:45 - or pendrive? And then just copy them using
it into the production machine? Are we going
185:50 - to send the files to some person from operations,
B, perhaps some email and then the person
185:55 - will place the files in there? How do you
make this happen? The first thing to get there?
186:00 - So one way or another?
186:02 - What happens? I mean, in this case, we're
thinking of placing, let's say that the database
186:06 - server just next to the REST API, if we're
going to do that, how are we going to make
186:10 - sure that all the dependencies of the database
and the dependencies of the REST API
186:17 - have the right versions, even when we only
were placing everything in the same machine?
186:21 - Right. So there could be version mismatch
between the things that are needed in the
186:25 - MongoDB database? And the detail needed in
the REST API? Right, starting from the previous
186:29 - system? How do we make sure that all the dependencies
are the right version for both of them? And
186:34 - if they're, if they cannot be, we have to
figure out okay, so perhaps we need to split
186:38 - his REST API into one machine and the database
server into another machine, which could not
186:43 - be that uncommon. But we have to think about
all these things. Also, what if we eventually
186:50 - decide to move to a new version of dotnet?
Right, so let's say that net six is out. We
186:55 - have to we want to move to the next six. What
does that mean? Do we have to bring in a brand
186:59 - new set of servers, physical rooftile, that
are already enabled for dotnet? Six? Do we
187:06 - want to just update the version of dotnet
in this existing server, and then somehow
187:12 - make sure that the app does not break by making
that change? How are we going to make that
187:18 - happen?
187:19 - Also, how do we start recipient the machine
because it is not just about copying the files
187:25 - in there, right? So somehow, we need to start
the dotnet app into the server, somebody has
187:31 - to do it right. So we have to bring in some
sort of automation, sort of a scripting, something
187:36 - needs to happen in that machine, to be able
to start with API and not just started but
187:40 - started fast. And we want to make sure that
as soon as we put the beats in there, the
187:45 - application starts quickly so that it can
start serving our users.
187:49 - And finally, what if one instance of the app
is not enough? So what if we start having
187:55 - so many users and us having one web server
for a REST API is not enough? And now we need
188:00 - to bring in yet another? Let's say VM virtual
machine for a recipe and then another one,
188:06 - and then another one? So who's going to take
care of provisioning all these VMs? For us?
188:10 - What about the database? What if we alternate
multiple copies of the database server to
188:14 - be able to handle the load? So how is all
this going to happen? So do we need to think
188:19 - about all these challenges? Do we need to
deal with all of this? Or is there a better
188:25 - way? So luckily, here's where Docker can help
us.
188:28 - So now, let's go back to our local box. So
yeah, so we have our local box has REST API
188:35 - and the and the database currently, and we
need to get to production. But now, instead
188:41 - of starting to worry about how to copy all
the things into production, or how to make
188:46 - sure that production has the right things
already in place,
188:50 - we can start using this thing called a Docker
file. So a local file is kind of a template
188:57 - of
188:59 - all the things that are needed by your a,
in this case, a REST API to get it deployed
189:04 - into production. So in the Docker file, you
will declare things like the operating system
189:08 - that we're going to need. So you're going
to say, I run in this specific version on
189:13 - this specific distribution of Linux, let's
say, What is his version of Windows. So he
189:19 - is already declared in that file. And so you're
saying as long as that version is available
189:25 - in the production machine, I am, I am going
to run just fine. And not only that, you can
189:30 - say, Well, I actually need the version five
zero of the dotnet, or ASP. NET Core runtime
189:37 - available in there. And
189:41 - by doing this, as long as I have all the dependencies
of the dotnet core runtime, I am able to run
189:47 - my my REST API, right, so you can declare
the runtime that you're going to be running
189:53 - on.
189:55 - You can also declare or you can prepare all
the dependencies that are needed for your
189:59 - app.
190:00 - Right, let the ongole be driver and any other
DLL or any other dependencies that need to
190:04 - be present in there, you can specify how to
place the files that you want to put in that
190:09 - in that production environment, you can say
how we're exactly what to put them. And you
190:14 - can also tell it exactly how to get started
or how to start that REST API. So that scraping
190:19 - that is needed to say how to start it, it
can also be said in this Docker file. So just
190:24 - by using the Docker file, you get, you get,
you're already handling a lot of the challenges
190:29 - that we were talking before, because this
Docker file is clearly declaring exactly how
190:35 - the how the environment needs to be built
for the REST API to run properly. And so but
190:43 - then, it is not not enough to use have this
Docker file. So now that you have Docker file,
190:47 - what you're going to do is use this thing
called the Docker engine to actually prepare
190:52 - what we call a Docker image. So what happens
here is that the Docker engine, which is just
190:57 - a process running in your in your box, the
Docker engine is going to take that Docker
191:01 - file, and it's going to tag it and and build
what we call a Docker image.
191:06 - Tagging is is really just kind of a synonym
for creating a version for your image. So
191:11 - you're going to set a version on that image,
and then you're going to build it. So building
191:16 - a Docker image means reading that Docker file
line by line,
191:20 - or executing all those instructions to prepare
the environment where a REST API is going
191:26 - to run. And that goes all the way back to
ensuring that all the exact dependencies are
191:30 - in place, put the files in the right location
and starting the app. Right. So all of that
191:36 - is encapsulated in that Docker image. But
then, once you have the Docker image, it is
191:41 - not enough to just have it running in your
machine, right? what you really want is to
191:44 - make it available in production. So how do
you take it from your box into production.
191:49 - So enter the Container Registry, the Container
Registry is a place that could be anywhere
191:54 - going from some server in your again, in your
internet, to somewhere in the cloud, it is
191:59 - the place where you can place your Docker
image, you can push your Docker image
192:04 - so that it eventually becomes available for
a your production environment. So this Container
192:10 - Registry, I mean, you don't necessarily have
to be the one that pushes the Docker images
192:15 - in there. There may be some some other images
already available in the registry. So for
192:20 - instance, in the case of MongoDB, there, we've
been using
192:25 - an instance, the Docker image of MongoDB.
Since a few episodes back, we did not actually
192:32 - create that image Damon was already there.
And that image is actually available in a
192:36 - specific Container Registry called Docker
Hub. So Docker Hub is a public registry, where
192:42 - many vendors place their Docker images for
public consumption. But just like there's
192:47 - a Docker Hub, there's also other container,
private cul de registries like a Azure Container
192:53 - Registry, or Google a registry. Amazon ECR,
I think is the name. There's also these days,
192:59 - GitHub have a registry. So there's a bunch
of versions of these available. But all of
193:04 - them are able to operate with your Docker
images in the really the same way. So what
193:09 - you have Porsche Docker image into the Container
Registry, then you're able to have your production
193:14 - box in the physical box, virtual machine,
whatever it is, it is able to pull your Docker
193:20 - image into it. And by pulling it and executing
that image, it turns into what we call a Docker
193:27 - container. So the Docker container becomes
kind of living version, our executable or
193:34 - running version of your Docker image, but
a Docker container. So
193:39 - the Docker container just has it
193:42 - has all the files and all the dependencies
that have been declared in the Docker file,
193:46 - and executes the REST API the way that you
have declared it in the Docker file, and just
193:51 - like what well, just like how we stand up
Docker container for the REST API, we can
193:57 - stand out the Docker container for our MongoDB
194:00 - Docker image. And then, of course, these containers
can talk to each other on all of these magic,
194:05 - I mean, it only works just because you also
have the Docker engine of the same Docker
194:10 - engine that you have in your box, you will
have it available in a production environment.
194:14 - So
194:15 - here, as long as you have the Docker engine
available in whichever machine, you want to
194:21 - go ahead and run your Docker image, then your
Docker image is guaranteed to be able to run
194:26 - as a Docker container in that environment
don't need that you need is a Docker engine.
194:31 - And that brings a lot of benefits along the
way. The other thing is that you not only
194:36 - just can just run one instance of your Docker
container, you can actually run multiple instances
194:40 - of your local container. So as you need to
scale up more and more, perhaps because you
194:44 - have too many users, then you can use to start
spinning up more and more copies of that Docker
194:49 - image into Docker containers in production,
without having to incur into a lot of hassles
194:55 - to be able to provision more and more environments.
So, lots of benefits about
194:59 - Docker really here, started with efficient
use a resource usage. So as opposed to the
195:05 - case of having to stand up new virtual machines
or new physical servers, you don't have to
195:11 - really enter into a lot of new resources.
spinning up a new Docker image does not take
195:16 - a lot of RAM does not take a lot of this space,
because there's a lot of caching happening
195:21 - in there by by this thing called layers in
in Docker. So a lot of caching, memory is
195:27 - going to is going to only going to increase
in terms of what, what exactly is needed by
195:31 - for your,
195:34 - for your, for your image for your service,
free REST API. And so you can really fit much
195:41 - more instances of your REST API, in this case,
also have your database, many more instances
195:47 - in the same production box.
195:49 - As you could before, just feed one instance
of your REST API, or your or your MongoDB
195:56 - container,
195:57 - or a MongoDB database, in the same production
box, right, you can fit much more.
196:02 - By using containers, there's also faster start,
because
196:09 - because Docker, the Docker engine is able
to cache all these, these layers are only
196:14 - the very first time that it needs to pull
down the Docker image, it will do that with
196:19 - all the layers apart from their own, it will
be able to just pull only the layers that
196:25 - have changed. And so that allows it to really
start very fast. So you don't have to also
196:30 - you don't have to boot up an entire operating
system, just to put a your your app, right.
196:36 - So the operating system is already in place,
you just need to start your app. And Docker
196:41 - is able to do that very, very fast.
196:43 - There's also isolation if each of these containers
is running in a in a completely isolated way.
196:49 - So it doesn't matter what's going on in the
actual production host machine, or what's
196:53 - happening in any other containers running
in the box. Each of the containers are running
196:58 - in isolation. And so from their point of view,
they are the only thing happening at that
197:02 - point in time in that environment. So that
that gives you a lot of benefits from that
197:07 - side.
197:09 - And then also you can you can think of these
containers have been able to run anywhere.
197:14 - And because like I said, as long as there's
a Docker engine running in your production
197:18 - machine, you're guaranteed to be able to run
your Docker container in there. So lots of
197:23 - portability. And finally, scalability, like
I mentioned, in the same in the same space,
197:28 - where before, you will be able to run just
one instance of your REST API, like in the
197:33 - case of virtual machine. Now you can actually
run multiple instances of your local container
197:38 - with using much, much, much less amount of
resources in there. So you can really scale
197:44 - significantly by using Docker containers.
197:48 - Let's see now what we need to do to containerize
or Docker eyes our REST API.
197:52 - To create the Docker image for a REST API,
the first thing we need to do is create the
197:58 - corresponding Docker file. However, before
doing that, and to keep things simple, we
198:04 - will update our REST API so that it no longer
performs HTTPS redirection, and allows the
198:09 - use of the HTTP address only. The use of HTTPS
from here on is a topic out of the scope of
198:15 - this tutorial.
198:17 - So what does this mean? If you remember, we
do have two URLs configured for a REST API.
198:23 - And those are configured in our lunch settings
file on their properties. And you said Lisa,
198:29 - Jason, application URL, we do have HTTPS localhost
5001 and HTTP localhost 5000.
198:37 - And the way that things are configured right
now, if anybody tries to access HTTP localhost
198:42 - 5000, they will get redirected into HTTPS
localhost 5001.
198:47 - You want to test this, what you can do is
just launch the app. So I'll do f5 here.
198:56 - And I'll open postman. And normally we would
go to HTTPS localhost 5001. But I'll change
199:01 - this into HTTP localhost 5000.
199:04 - And in this case, I'll actually open the postman
console down here
199:11 - to see what's happening behind the scenes.
And I'll do sent to query for items. The query
199:17 - succeeded. But then if you see there are two
calls in here, the first one for HTTP localhost
199:22 - 5000 slash items. It returned 307 code, which
means a redirect. And then that was followed
199:30 - by a call to HTTPS localhost 5001 slash items.
So that's a the redirect that has been configured
199:37 - right now is what we want to change for the
Docker case, at least.
199:40 - So how do we change this? Going back to VS
code, and I'll just stop the app and close
199:46 - this for now.
199:47 - This is configured in startup.cs.
199:50 - In under the Configure method, we have this
line here, up that use HTTPS redirection
200:00 - So he turns to me that when you run inside
the Docker file, well, sorry, inside the Docker
200:05 - container, the ASP net environment switches
from development into production. And this
200:12 - is what we can use to put a conditional on
this on this line. So we can say is, if, and
200:21 - that is development,
200:24 - then we will allow the HTTPS redirection,
but otherwise, we will not allow.
200:29 - That's the only change that we're going to
make here. We will see how this works. Actually,
200:34 - when we have the Docker container ready to
go.
200:36 - This point, I'll just close this. And now
we actually want to generate or actually to
200:41 - create this Docker file. So there's two ways
to create a Docker file, either you can create
200:45 - it manually, or you can generate it. For this
tutorial, we will have to speed things up,
200:49 - we will generate. So you need a Docker file.
Well, I would recommend if you're a business
200:54 - to recode, is to use a Docker extension for
Visual Studio code. And that you can find
200:59 - if you go to the extensions hub,
201:02 - you can just type Docker here.
201:06 - And then you will go ahead and install the
extension.
201:10 - And now close this. And now what you can do
is just say, view command palette, and then
201:16 - you can type Docker Docker files to workspace
is the first option there.
201:23 - Now you get to pick the platform of the Docker
image we're going to create in our case will
201:28 - be dotnet. ASP. NET Core,
201:29 - then you got to pick the operating system
of the container, in our case is going to
201:35 - be Linux, just because it's the most popular
option most of the time.
201:41 - And then you get to pick the port that you're
going to release in in in within that container.
201:48 - In our case, it's going to be Port 80.
201:50 - And finally, if you want to generate a Docker
compose file, we will not use this in this
201:57 - tutorial to hit No.
202:00 - And now if you go to our explorer here, you're
going to see there's a couple of new files,
202:05 - we have the Docker file and the Docker ignore
file. So let's start by looking at the Docker
202:10 - file.
202:11 - In the Docker file, each line that you can
see here represents a one set of instructions
202:18 - that are going to be applied as the Docker
image or Docker image is going to be built.
202:24 - And each of these lines will also generate
what we call a layer that represents the changes
202:31 - that are happening from one line to the next
line. And that's what helps a lot in terms
202:36 - of a caching of steps as we do subsequent
builds of this Docker image. So the first
202:42 - time we will build it, it will take time.
And this was a good time. So silicon times
202:46 - is going to be much faster. Now let's go one
by line by line here to understand what's
202:49 - going on.
202:51 - So the first thing that's happening is we're
saying that we will be building out our image
202:56 - base it on the dotnet ASP net image, specifically
version five, zero, right. So that's, that's
203:04 - the way that you that you start by saying,
Where do you want to go from by specifying
203:09 - dotnet. asp. net, you're guaranteed to be
building a your image based on
203:15 - working ASP net environment, in this case,
a five zero environment that has all the dependencies
203:24 - that are needed to run an ASP. NET app. And
not just that the ASP net image has a has
203:30 - a at the same time has been built based on
the correct always based on wait where you're
203:37 - running your image on in our case, since we're
going to be running it in a Linux machine.
203:40 - That will include all the dependencies to
run an ASP NET Core app, or the net five app
203:45 - in Linux.
203:47 - Now, we're also saying this is five zero as
base. This means that this is going to be
203:53 - a our first stage of the building the container.
This is
203:59 - a good segue into the concept of multistage
builds, which is what's enabled here. This
204:07 - means that there will be more than one stage
on the build process. And in each stage, you
204:12 - can specify a different set of instructions
that may have nothing to do with the instructions
204:17 - executed in some other stage. So for instance,
here we're saying, so this is the first stage
204:22 - and we'll call it a base. And in this stage,
we'll go from a dotnet. asp. net, which is
204:28 - the runtime image for ASP. NET five work there
is going to be slash app means everything
204:34 - that happens after this will happen in the
in the app directory. And then that we expose
204:39 - a port 80 this line actually means does not
mean much is just a kind of a documentation
204:45 - field. The way that you expose a port is a
bit different actually. But it is a there's
204:51 - a convention to specify the port that they
are policing in. Now that temporarily finishes
204:57 - that first stage and in the next nine
205:00 - In line five, we are going into our next stage
that we're calling built. And the interesting
205:05 - part about this stage is that it comes from
a another base image, if you notice this is
205:14 - coming from dotnet, SDK
205:16 - to dotnet. SDK five series are supposed to
dotnet. asp. net. So SDK is the image that
205:22 - has all the build tools, and all the libraries,
everything that's needed to build
205:29 - and dotnet five app, which is not the saying
that you need to just run other than five
205:37 - AP, right. So this, whatever is coming in
this ACP image is potentially much bigger.
205:42 - There's a much, much more files, compilers
and stuff in there that are needed for building
205:47 - the container, but not needed for just running.
So that means that your final image that's
205:52 - going to go actually from the base image is
potentially going to be much smaller than
205:56 - the image that we're going to use to build
your container.
206:01 - So we start with this stage, in this case,
it worked there is going to be a slash src.
206:05 - So that's where we're going to place any files
from here on. And that's exactly what we're
206:09 - doing. Then in the next line, we're saying,
Okay, so let's copy the catalog, that CS profile,
206:14 - the one that defines our project into the
root of the current location.
206:20 - And they will run a dotnet restore, on that
break. So that brings in all the nougat packages
206:24 - that are needed, then we say, OK, so we have
restored all the packages, now copy every
206:29 - other a file that's needed a folder up. So
that includes all the files that you can see
206:34 - on the left side, except for a few sections,
but most of the files are included here. And
206:39 - we'll talk about that in a moment.
206:42 - And then there's this line here, that's actually
not that much needed. Because as you can see,
206:46 - it's pretty much the same as the as line six.
So we will actually delete this in a moment.
206:51 - And then we go into the actual build process,
where we say, hey, go ahead and perform a
206:55 - dotnet built on catalog that says Prague,
we're modifying a Korean configuration to
207:01 - not be the bug anymore, we want to release
version of the app to optimize it for the
207:06 - production environment. And the results of
that build should go into the slash app slash
207:12 - build directory.
207:14 - So currently, that finishes our build stage.
So it's this section here. And then we're
207:21 - switching to yet another stage that we're
calling it publish. In the bullish stage,
207:27 - what we saying is, actually, we're going to
go from the build stage. So notice, now we're
207:31 - going from build is the stage that we just
created. And we will go from there and name
207:36 - it as bullish, and just execute the dotnet
publish command. with similar set of parameters
207:41 - and the previous one, just changing the output
directory. So that then polish, what it does
207:45 - is
207:47 - it creates a new folder, in this case called
Polish with all the files are needed in the
207:53 - right shape, to just execute the app. Now
at this point, I'd like to point out that
207:59 - I find a few of these lines are a little bit
redundant. So we could simplify things a little
208:04 - bit here. So I don't think we need to separate
both a build and abolish stage. So I'm going
208:09 - to make a couple of changes here. So I'm going
to actually remove these a warfare source
208:13 - line, because we already have these in line
six. So I'm going to remove that. And I'm
208:19 - going to also remove dotnet build just because
dotnet Polish also performs dotnet build for
208:23 - us. So there's no need for two separate lines.
208:27 - And I'm actually going to completely remove
the Polish stage because their build stage
208:30 - should be good enough for what we did here.
208:35 - So now we just have one stage called built.
One second stage called built, that will end
208:40 - up by running duct and polish. And all the
files that we need should end up being in
208:45 - Polish.
208:47 - Now in 912, we go back to our initial basic
stage, build stage, and we're going to be
208:54 - calling it as final. Right. So now we're pretty
much finishing what's what's going on here.
208:59 - So we switch again to the app directory. And
then we're saying what we're saying is, okay,
209:05 - so now let's copy from the foolish build stage,
we net, which in our case is no longer there,
209:10 - we actually opted for built. So I'm going
to actually copy this and change it into build.
209:16 - So from the build stage, go ahead and copy
whatever is in the app slash Polish directory,
209:23 - the one that will replace all the files, copy
all of that into recording directory, which
209:27 - will be slash app.
209:31 - And finally, we'll define the entry point
for our app. So this is how we define how
209:35 - to start our REST API. And in our case, that
will be just by hitting the we're executing
209:42 - the dotnet command with the catalog that dll
file. That's all that's needed to start our,
209:47 - our REST API.
209:49 - With this Docker file, we're pretty much ready
to build our image. But before doing that,
209:54 - what I wanted to do is just show you about
the dot Docker ignore file.
210:00 - So this Docker ignore file, what it does is,
it defines a series of files and directories
210:06 - that you want to exclude from the Docker image.
So there may be a one or more files that you
210:13 - don't want to include in the Docker image,
because it makes no sense to close. For instance,
210:17 - the stuff that we have on there that VS code
is really only useful for development purposes.
210:21 - But it means he has, it makes no sense to
include that into the Docker image. So for
210:27 - instance, this line here specifies Hey, use,
go ahead and exclude everything under slash
210:31 - that VS code. And the same thing for a bunch
of other files and directories. So a good
210:38 - file to not forget to keep in mind, otherwise,
your image will end up being bigger than it
210:42 - is.
210:43 - So with that, we should be ready to start
building the array image. So what I'm going
210:47 - to do is just open a new terminal.
210:51 - And to build the image, what you do is use
a Docker is Eli.
210:56 - So what we're going to say is Docker build,
211:00 - then you, you have to specify attack, I mean
the name for the image and attack for it.
211:08 - So that you do be the dash D, qualifier. And
then we will give it a name, the name will
211:14 - be catalog, and then you give it a tag, which
in our case, let's say is going to be v one.
211:20 - And finally you specify the directory from
which you're going to execute the command.
211:25 - In our case, that's going to be
211:28 - the current directory, which is specified
by the.so. I'll hit Enter.
211:34 - And that's going to go ahead and build the
image. So first thing we need to do is go
211:38 - ahead and download any of them base images.
In our case, that will be the dotnet ASP net
211:42 - image, the runtime image will go ahead and
do that. And then for the second layer for
211:47 - the second build stage needs to pull in the
dotnet SDK, a five zero SDK, a five zero image,
211:55 - which may take a little bit more because it's
speaker, and then it proceeds to perform the
211:59 - actual build process within the the image.
212:06 - So Docker restore,
212:08 - and they are to publish, and then all the
other steps that ended up creating that image.
212:12 - So at this point, we have an image ready.
And like I said, each of the lines going back
212:18 - to a local file, each of the lines here represents
one layer that maps to each of the steps that
212:23 - you see here. So he says step,
212:28 - a bunch of steps here.
212:31 - So step one of 13,
212:35 - to 13, three of 13. Each of these will correspond
to each of the lines that you can see on the
212:39 - Docker file. So these are the layers that
will be cached from here on,
212:44 - so that you don't have to do them again. So
in our case, if we don't have it, if you don't
212:48 - make any change, if you've tried to do Docker
build dash D, the same command again, I hit
212:54 - Enter, really mostly nothing happens because
everything is cached. So only if you make
212:58 - some changes, then those some of these layers
may need to be executed again.
213:03 - Now, one thing to remember is that this is
not the only container that we need for our
213:09 - REST API. We also have the MongoDB container,
which is the one that handles that access
213:14 - for us our database server, right and which
is the one that has our database. So we need
213:18 - to make sure that our new container for the
REST API is able to talk to the MongoDB container.
213:24 - And the way to do that, at least in the local
box, is by setting up what we call a Docker
213:30 - network. And having both containers join that
that Docker network. So how do we deal with
213:36 - this network to create a network, the only
thing that you have to do is just say,
213:41 - Docker, network, create, add use, give it
a name. So we will say that five tutorial
213:52 - and that crazy network
213:54 - if you want to see the the existing networks,
you can do Docker network LS.
214:02 - And you will see we have the our net 530 network
already created.
214:06 - So now when we run our containers, we should
take advantage of that network. So what I'm
214:13 - going to do is first make sure that I'm not
running the MongoDB container yet. So I'll
214:18 - do docker ps, the MongoDB container is running
right now. So I'm going to stop it
214:22 - Docker stop Mongo
214:24 - to that stopped, and I'm going to run once
again, the same command that we've been using
214:31 - so far to run our container.
214:33 - let me paste that here. Same command.
214:38 - But I'm going to add one modify here that
says network equals and the network name that
214:45 - you use was defined in this case, net five
214:47 - tutorial.
214:49 - So that makes a disk container a joint that
did work. So I'll say Mongo,
214:57 - the name of the Docker image, so hit enter.
215:00 - And then the MongoDB container is running
in that network. After doing that, we're ready
215:05 - to actually start running our a catalog container,
which by the way, if used to Docker images,
215:12 - you should be able to see our created image.
As you can see, we do have catalog be one,
215:20 - ready to be executed, as well as the Docker
images for the dotnet. SDK, and the dotnet,
215:26 - ASP net, runtime, and Mako.
215:31 - So to run our Docker image, we're going to
do something very similar to what we did with
215:35 - MongoDB. So we'll start by saying, Docker
run.
215:39 - And then instead of doing dash D, for the
dash, we'll do dash ID for interactive, that
215:44 - allows us to keep our terminal connected to
the Docker run process, just to see whatever
215:49 - whichever logs are coming out of that container.
And then we will do the RM so that whenever
215:56 - we stopped the container, it actually it gets
deleted, so we don't keep hanging around.
216:02 - And now we specify the port, similar as we
did with MongoDB. Now we have to specify which
216:06 - is the port that's going to be mapped from
our local machine into the container. In our
216:12 - case, let's pick ADHD, it doesn't have to
be it, you can use any other body port. And
216:17 - that is mapped to the internal port in the
Docker image. Now, for ASP net, and that five
216:24 - images. The base image itself, it's been a
runtime image defines or overwrite the port
216:33 - where the app executes, at least for HTTP.
So that port is 80. So regardless of the fact
216:39 - that we've been using Port 5000, for local
development, when we base our Docker image
216:45 - in the ASP NET Core runtime image, the port
is overrated into 80. So you will have to
216:51 - specify 80. And if you don't want to use 80,
there are ways to specify the port that you
216:55 - want to use in your degree in your Docker
file. But in our case, the Port 80 will be
216:59 - just fine.
217:02 - Now we have to remember that in order for
our app to connect to MongoDB, we have to
217:07 - specify a series of settings, right. So if
you remember when we go to app settings that
217:11 - Jason, we have this MongoDB Settings section,
where we specify host, port and user. And
217:18 - not only that, it will remember going back
to Settings MongoDB settings, we specify host
217:24 - port user and also password which is coming
from secret manager.
217:28 - So in this case, since we are trying to talk
to Mongo to MongoDB.
217:32 - From within the container, we can no longer
use just localhost to reach out to it.
217:39 - They remember that each of these,
217:43 - each of the apps running inside of the container,
both arrest API and MongoDB are running in
217:48 - an isolated way. And they can no longer resolve
things by localhost. So for our REST API to
217:54 - talk to the MongoDB container, it has to do
it via the name of the container of MongoDB.
217:59 - In our case, remember that we gave it the
name of Mongo.
218:04 - So we have to override the host name. To talk
to Mongo, we don't have to touch it update
218:10 - the JSON file for this, what we can do is
just take advantage of the configuration system
218:14 - of 35 to be able to override the settings.
So this one going to be setting section can
218:20 - be totally overridden by environment variables.
And that's what we're going to do now. So
218:24 - as long as we follow the convention, we should
be able to make that happen. So I'm going
218:27 - to say dash E, that's the way that you define
an environment variable in in Docker,
218:34 - I'm going to say, I'm going to use MongoDB
settings. So just copy that. And then we'll
218:40 - say colon host. And that host is going to
be Mongo, the name of the Mongo container.
218:48 - So that's how you can override this localhost
as specified here. Now the same way that we
218:52 - did that, we need to specify a password because
the password that we've been using so far
218:55 - is stored in the secret manager. And the secret
manager is only being used for development,
219:01 - a development purposes is only available in
development environment, it is not available
219:05 - in production, and the Docker image, the Docker
container is really going to be running in
219:09 - a production environment. So how do we feed
that password, same thing that we did a, just
219:15 - now we'll say MongoDB settings. Let's not
forget to also add dash in MongoDB, settings,
219:23 - password, and then we specify the password
219:25 - as bound word one.
219:31 - And that's it. And then let's not forget that
we need to join also this container into the
219:36 - same network as the previous container. They
won't go on the inner so that's going to be
219:40 - network
219:41 - med five tutorial, make sure this is exactly
the same network that you used before. And
219:47 - finally the name of the container and
219:51 - the name of the image and the deck. So that
will be catalog. Be one
219:57 - and I think I may have a couple of mistakes.
220:00 - Here. So the first thing might be, let's see,
yeah, so it should be dash dash RM as opposed
220:06 - to a dash RM.
220:08 - And the next one would be Yeah. So this one
should be equals supposed to column. And then
220:16 - I'll hit enter.
220:20 - So that has started our Docker container.
And as you can see, our hosting environment
220:27 - has now changed from development to production.
So production is the environment that will
220:32 - be reflected when you run the Docker image
as opposed to development anymore. Now let's
220:37 - see if things are working properly, we should
be able to reach out to our REST API at Port
220:42 - 8080. So let's open up postman.
220:46 - And now let's just switch from Port 5000,
to Port 8080.
220:54 - And let's see what happens send.
220:58 - And through to be told, the API keeps working.
But now as you can see, we're hitting a port
221:04 - 8080. So things are happening within the Docker
container.
221:07 - Also, notice how we did not get a redirect
anymore. So instead of getting at 307, like
221:13 - we did before, we got 200 right away. So there's
no more redirect happening in there, we're
221:18 - just going to be at the HTTP endpoint. Now
to keep things interesting, let's actually
221:25 - post one more item here via our post tab over
here. And I'll do the same thing. I'll switch
221:31 - from HTTPS to http. And then I'll do Port
8080.
221:39 - The 80. And so let's say let's say that we
bring in back that antidote for you. So sometime
221:45 - in the past, and then I'll do price 15.
221:49 - an hour heat sent.
221:54 - And as you can see, I'll just close the console.
Now,
221:59 - the audio has been created.
222:01 - Now really, the interesting part about Docker
and Docker images, is not just being able
222:08 - to create them, right, but also to be able
to share them so that they can be used by
222:13 - either other persons or some other systems.
So how could we share this Docker image that
222:20 - we have in our box now with some somebody
else, right, so use for the sake of this tutorial,
222:26 - we'll do something very simple to see how
this can happen, we're going to take advantage
222:30 - of a service called Docker Hub, which you
can find Let me open up the browser here.
222:37 - You can find at hub that docker.com. So this
is the place that the creators of Docker offer,
222:44 - so that people can publicly share their Docker
images. So creating an account here is totally
222:51 - free. So feel free to try it out. So you'd
have to come up with some Docker ID, I mean,
222:57 - some kind of a username and a password. And
then you can have your own account in Docker
223:01 - Hub.
223:03 - So how can I get my image Polish into Docker
Hub. So let's go back to Visual Studio code.
223:10 - And I'll stop my Docker container now, by
doing Ctrl. C. And the first thing that I'm
223:15 - going to do is actually logging in into Docker
Hub. So once you have an account in there,
223:21 - you should be able to do a simple Docker login
to be able to start pushing image in there
223:26 - are a way to do is just say, Docker login.
223:28 - So this is going to ask me for my user username,
my case is, will you see it will ask for my
223:36 - password.
223:40 - And now I'm logged in.
223:43 - So now in order to get our currently existing
image into Docker Hub, we just need to do
223:47 - a little bit of retagging to tell it where
we want to place this image. So let's leave
223:54 - our images that once again, local images.
So here's the mission catalog b1. So we want
224:00 - we want to do is just retag these in in this
way.
224:05 - So let's do Docker tag, catalog be one
224:09 - that's the Korean, the green tag, catalog,
big one. And then our target tag is going
224:15 - to be starting with our username, my username,
in this case, for you see, and then slash
224:21 - the name of the of the image in Docker Hub,
when you get to Docker Hub is going to be
224:28 - called a repository. And so that was during
August is going to be catalog.
224:33 - It doesn't have to be you can choose. But
I'd like to give it just the same as we had
224:37 - before. So you can typically see a slash catalog
be one, hit Enter. And like I said, this is
224:43 - just a tag. So if I do Docker images again,
we're going to find it now you have catalog
224:49 - B one, and who you see slash catalog B one.
But if you notice the image ID and you look
224:55 - closely, you'll see that the ID that both
of these images have is pretty much the same
225:00 - So it's really you can think of the stacks
as just pointers into one of the images. But
225:07 - with this retag, we are able to now actually
push the image into Docker Hub. So what I'm
225:11 - going to do now is just say, Docker push
225:16 - our new newly written image, catalog b1, hit
Enter.
225:23 - And this starts the process to upload, not
just our REST API dogri mesh, but all the
225:30 - layers that are composing these REST API needs
to go into Docker Hub. So remember that our
225:37 - Docker images Docker base is the ASP NET Core
runtime image. And that one, in turn is vetted
225:41 - in some distribution of Linux in this case.
So all of those things need to go into Docker
225:47 - Hub, so that anybody else got in the future,
just pull that image and start using. So these
225:52 - may take a while because it's an upload,
225:57 - upload task.
226:00 - Alright, so the image finish uploading. And
now if I go back to Docker Hub, where I'm
226:07 - going to do is actually sign in with my account
here.
226:18 - And as you can see, I do have my image just
uploaded a few seconds ago, who you see slash
226:23 - catalog.
226:26 - And
226:27 - here's the one fact that we have right now.
So that would be one.
226:31 - So let's see that let's play the role of somebody
that does not have this image in their system
226:38 - right now, and that they want to use it. In
that case, what they can do is either do a
226:44 - Docker pull, or just run the image. So let
me show you what I mean. So the image is now
226:48 - available in Docker Hub. So I go back to VS
code. And what I'm going to do is just completely
226:53 - remove the image that we have currently in
our system. So let's do Docker images, once
227:00 - again, and we're going to do is just remove
these two images, so that it gets completely
227:05 - out of the system. And to do that, I'll do
Docker Rmi, will you see slash catalog v one,
227:16 - and Docker Rmi,
227:17 - catalog, v one. So now there should be no
catalog image anymore.
227:23 - In my system, z only, I only have these three
images right now. So now, the only thing that
227:31 - I'm going to do is use to Docker log out
227:36 - to simulate somebody that actually has no
access to my Docker Docker registry. But since
227:43 - the image is public, they should be able to
pull it. So in order to pull the image, you
227:49 - can either do the local Docker pool operation,
so local pool, or you can run it right away.
227:55 - So we can run it in the same way that we run
it before. So let me show you is going to
228:00 - be pretty much the same command line, I'm
going to actually copy paste here.
228:05 - But now instead of you're saying catalog b1,
what we can say is polisi, slash, catalog,
228:12 - b1. So just keep in mind, so I am at this
point, I am somebody that has never,
228:19 - that has never had access to the catalog,
228:21 - REST API service, I have no access to the
Docker file or anything about how to build
228:29 - this image, I just want to run it for the
very first time. So I do this command line
228:34 - and hit enter.
228:35 - It says yeah, I cannot find this image locally.
So we'll go ahead and actually pull it from
228:40 - Docker Hub, and then run it. And as you can
see, it is already running. If I go back to
228:46 - postman,
228:48 - and I try to query for items again.
228:50 - I get my items from this Docker image. So
that's how you can publish or push your Docker
228:59 - image into what we call a Container Registry,
in this case, Docker Hub, and then it is pulled
229:04 - back, potentially in some other machine. That's
how you can share it. So we may end up using
229:11 - some other form of Docker registry in future
videos. But for now, I just wanted to show
229:14 - you how you can do the sharing of Docker images
across systems.
229:20 - In this episode of The dotnet five REST API
tutorial, we continue our path towards deploying
229:25 - the REST API to a production environment by
using Kubernetes. We will talk about the implications
229:31 - of running containers outside of the dead
box with no downtime and how Kubernetes is
229:36 - a perfect fit for these and the many other
challenges of running distributed systems
229:41 - resiliently.
229:42 - Today you will learn why a container orchestrator
is needed. What is Kubernetes and which are
229:49 - its basic components. How grenades enables
resilient distributed systems, how to stand
229:55 - up a basic units closer in your box, how to
deploy your REST API and one of the
230:00 - to coordinate this, and how to scale a Kubernetes
deployment.
230:07 - So if you remember from the previous video,
we talked about these orange box, which so
230:13 - far we've been talking about it is the production
environment, right? In this case, let's just
230:18 - call it an old Indian, this is the, this is
the either the physical, or the virtual machine,
230:25 - where we're going to be running our Docker
engine, right? These things to this Docker
230:31 - engine, that were able to run a bunch of containers
in this dog, this could be either our API
230:37 - containers, or also our MongoDB container
or many other containers, right, that we want
230:42 - to run in this node.
230:45 - However, a few interesting questions start
arising as we move forward with this approach,
230:52 - right? For instance, who takes care of pulling
and running containers. So I mean, can imagine
231:00 - that without any forter sort of automation,
somebody will have to come to this box, and
231:05 - actually start doing Docker run for each of
the containers that we want to run in this
231:10 - box? Right? So that's an interesting question.
So either some information somebody saw somebody
231:14 - has to take care of this, how to run the containers,
right? So who knows? Or where do you see the
231:23 - reading? All these different environment,
variables, secrets, and different common arguments
231:29 - that we have to fit into Docker run, to be
able to run the containers exactly the right
231:34 - way, for each of the cases?
231:38 - And what if, what if we don't have enough
container instances? Right? So what if we
231:43 - need more, so something or somebody has to
start spinning up more and more instances,
231:49 - as as needed, both for a recipe containers
or for any other containers that we want,
231:55 - we may have in this box?
231:57 - Right? And then also,
232:02 - we may win, we may not be able to fit, just
I mean, we can only fit so many containers
232:07 - in a box, right? So at some point, we may
need to introduce get way more nodes, right?
232:14 - And then somebody has to decide if the containers
are going to be created are going to go into
232:19 - in this case to node node two, node three
and two, node n. Right? So who decides this
232:25 - distance here? So do we have a person that
is looking at the different stats for each
232:32 - of these nodes, and just decides to do Docker
run in each of these indices machines? How
232:36 - does that work?
232:38 - Also, a are the containers healthy? So what
happens if one of these containers crashes?
232:44 - What do we do? Who is on point to make sure
that we bring back this failed container so
232:51 - that we keep having as many as we wanted?
To start with?
232:56 - Also, where do we store all the secrets? For
the restore to database files for MongoDB?
233:02 - database? Where do you put all these? How
do we enable containers to talk to each other?
233:08 - Right? Because we know that our REST API containers
need to talk to our MongoDB container. But
233:12 - how do we enable that communication in so
far, we've been using these Docker network,
233:16 - right to make them communicate. But as we
have more boxes, more containers, how to make
233:21 - sure that they can all talk to each other.
233:25 - And one more thing, how do we read this container
from the outside, right? Because all of these
233:29 - containers are running in the box. But all
of them are running with some port a opened
233:34 - locally. But then what if somebody comes from
the outside? What will be that public IP that
233:40 - somebody from the outside will use to talk
to these containers? And if they talk to them?
233:44 - Which of all the instances would serve the
request? Because we have so many instances
233:49 - in there who decides which is the right instance,
for the request that's coming in? So all of
233:54 - these questions? How can we solve all these
challenges? Well, this is exactly the reason
234:00 - why we want to introduce an orchestrator tool
like Kubernetes. So enter Kubernetes
234:08 - so
234:09 - as we describe what goons can do, let's they
think again about this
234:13 - These dots, right? So we have, let's say we
have these three nodes. And we need to start
234:19 - placing containers in them. And we have to
do a bunch of things to get these containers
234:24 - up and running in the right way. So instead
of having to have an individual person, or
234:31 - some sort of a script that needs to run, to
be able to allocate, and to make sure that
234:38 - everything is going properly in across these
nodes, we're going to be introducing this
234:42 - component called Well, I've got a series of
components that we call the control plane
234:46 - in Kubernetes. So the control plane has several
components that take care of all the the it's
234:52 - kind of the brain of coronaries. So he decides
how to schedule the container into the different
235:00 - nodes, he decides what to do if one of these,
one of these containers is destroyed, how
235:06 - to bring back one, one more how to let them
communicate to each other, and a bunch of
235:11 - decisions, right. So for instance, when we
want to get one new container deployed to
235:17 - one of these nodes, or we can do is via the
control plane, we can create a deployment,
235:24 - what this deployment is going to do deployments,
by the way, one of the resources inside grenades.
235:29 - And so what is flaming can do is go ahead,
find the image that we need in the Container
235:35 - Registry, and then allocate what we call a
port for that, for the container that will
235:42 - be will pulling in now the ports are really
the smallest deployable unit of computing
235:49 - that you can create, and manage inside Kubernetes.
Right. So the pod, it has a similarity to
235:55 - what we call, if you think a pot of wealth,
right that I guess that's the symbol for Docker.
236:03 - But it's a group of one or more containers
that are sharing, storage and network resources.
236:10 - And it The report also declares how to run
the containers inside them, right. So you
236:16 - will always be working more with bought that
with containers, you can read with the containers
236:21 - directly, you will only work with bots. So
for instance, in this part, we will have,
236:26 - let's say one container, which is a very common
case to use have one container per pod. But
236:32 - you don't have to have one, you can start
standing up your deployment object, you can
236:36 - start standing up more than one container
for let's say this is for catalog race API.
236:43 - But in this first note, we don't have to just
have this catalog API, right. So we could
236:48 - have some other port for some other service
that in this case has not one but two containers
236:53 - inside of it. More than that, we will have
also a port for our Mongo for a Mongo container,
237:01 - right that we need to also pull in, that has
access also to these database database needs
237:06 - to get a granted access to some storage to
be able to store the database files. But then
237:13 - the thing is that the this catalog posts don't
have to be using node one, right? So when
237:17 - we run out of space, we may want to take advantage
of other nodes like no two here, right. So
237:23 - again, the control plane will take care of
deciding where to put these these ports across
237:29 - the entire set of nodes that we have here.
So in this case, we have seen three, but you
237:33 - can think that this can be an entire form
of dozens and dozens of nodes, and then control
237:38 - plane will decide which is the node that is
the perfect fit for the ports that need to
237:44 - be allocated. Right, if Lemmon declares that
it needs three ports. So this may be Was it
237:49 - the one way that the polls are distributed?
If deployment says no, I need four pots that
237:54 - we may want to deploy get another pot pot
for into node three because notaries use free
237:59 - at this point, right? Same way with some other
pod. He may want to be allocated somewhere
238:05 - else. There's no space in node one. So let's
just put it in no tree. Let's see, just because
238:09 - no tree has so much memory available, right?
The other thing is that what three, let's
238:16 - say for three wants to talk to utterly all
of our catalog boards, we want to talk to
238:21 - the database, right? So how do they do that?
So there's this object called the service
238:26 - in coordinates. And the service allows us
to reach the other components that are available.
238:32 - So what else in the cluster? So in this case,
I'm saying, well, I want to reach out to the
238:37 - Mongo service via that Mongo service, I am
actually able to reach to the database. In
238:44 - a similar way, if we have an external client
that wants to talk to our catalog, a REST
238:50 - API, how can I reach it? So again, we stand
up a catalog service, which can reach in our
238:57 - case for now ingesting the localhost, but
eventually it could be a public IP. And then
239:03 - this client can reach to the to this service
and be at that service. It can reach not just
239:08 - one but all of the pods that are running behind
239:12 - the Behind the surface, right, so it's a way
to route to those to those bots. So all of
239:21 - these is what we call a meet all of these
components is what we call The Goonies cluster,
239:25 - right? The suit of all these components. And
now, what I'm what I'm showing here is really
239:31 - just just the tip of the iceberg in terms
of all the possible resources. And, and the
239:38 - series of configurations and the capabilities
that can be a use within coordinates. Really
239:42 - it there's a lot that can be done with coronaries
and but here, we'll just explore just a few
239:47 - of them to understand how it works. And so
in terms of benefits of using Kubernetes,
239:53 - one of the main things about this is the ability
to turn desired state into active state. So
239:58 - like I said, we create a deployment object
where we say, hey, I want three copies of
240:04 - the catalog service. So that is a solid state.
So Kubernetes via the control plane, we'll
240:11 - have to figure out how to make those four,
four instances of the catalog container available
240:19 - as support somewhere in the series of nodes
that we have available. If you have three
240:24 - nodes to find space in those two nodes, if
you just had one node, so figured out how
240:27 - to allocate that in that one node, or we could
have hundreds of nodes, right. So decided
240:32 - to stay in the Draco state is a key feature
of Kubernetes. Then, like I said, select nodes
240:39 - to run the bots. So it the control Bay has
knowledge of the stats of features installed.
240:46 - So depending on the amount of CPU, or the
amount of RAM available in each of the nodes,
240:50 - it is able to allocate the port in the right
place. It also allows for self healing. And
240:57 - so if he detects that one of the ports, let's
say port three is just easiest to destroy
241:05 - for any reason, it should be able to automatically
bring back another part. So let's say that
241:10 - a note to the entire note just goes down,
right? If that happens, then a control plane
241:18 - will know that it is able to I mean, that
is missing one note, sorry, one port, and
241:24 - then it needs to allocate that boat somewhere
else, either node one or node three in this
241:28 - case. So this is the self healing capability
of Kubernetes. That's super handy. It also
241:35 - is able to store configuration secrets. So
he has a it has a place to store all the configuration
241:40 - that you need for your for the services, and
also to store to safely store sensitive information
241:46 - and like secrets, so somewhere in there so
that they cannot be compromised. Like I said,
241:52 - he provides service discovery and load balancing.
So when the client calls and talked to the
241:56 - catalog service, it is able to be directed
to the right at one of these nodes following
242:01 - following some algorithm to load balance across
them. It also ensures no downtime. Because
242:09 - whenever it it, let's say that we want to
deploy a new version of our catalog, Docker
242:16 - image right across all of these spots, it
will not just destroy all the pods at once
242:20 - and bring back a bunch of pods with a new
image, it actually those will will slowly
242:27 - roll out the new version of the of the image
as as new ports as it starts destroying the
242:34 - older port. So only when it configures that
new, the new instances of the ports are available,
242:40 - he will start getting rid of the older ones.
So that way it keeps I mean, it makes sure
242:45 - that there's no downtime for clients. He can
also auto scale. So it can be configured to
242:54 - say hey, if there's so much CPU being used
across the across all of our nodes just spin
243:01 - up even a more pots in any order available
nodes to satisfy the demand. So, within this
243:09 - tutorial, we will be doing scaling exercise
manually, but corneas can be also configured
243:14 - be configured to do the scaling automatically
for you. It also disabled to on demand automatic
243:21 - storage, so you can easily declare that you
want so much storage for your port, and granary
243:26 - will I mean without having you don't have
to know exactly where that storage is going
243:29 - to be. You'd have to say hey, coordinates,
I need storage and grenades will be in charge
243:33 - to figure out where to find the storage and
make it available for the port. And finally,
243:38 - it provides a what we call gradual rollout
and rollback use, just like I said, it will
243:43 - gradually start bringing in new ports as needed.
And also if there's some issues with some
243:47 - ports, it is able to roll them back to a healthy
version. So now that we know what Kubernetes
243:56 - is, let's see how to get our catalog REST
API and the MongoDB database deployed into
244:02 - a local Kubernetes cluster.
244:06 - To get started with Kubernetes The first thing
that we're going to need is a Kubernetes cluster.
244:10 - locally. If you're already using Docker in
your box, you already have it An easy way
244:13 - to send up a simple local velocity for development
purposes. Let me show you how. If you go to
244:19 - your Windows taskbar, you should be able to
find this Docker icon. You can right click
244:24 - this I can select Settings. And this opens
Docker settings in your box, maximize this.
244:33 - And here, what you're looking for is the q&a
section on the left side, and then enable
244:38 - coordinators over here, so I'll just click
on it, and then click Apply, restart and then
244:46 - click Install. Now this is going to take a
while if this is the first time that you're
244:51 - enabling coronaries, because this is going
to set up a local cluster simple with just
244:55 - one node. But still it is a local cluster,
and that Docker needs to download a bunch
245:01 - of Docker images for all the components of
Kubernetes, into your box to that. So that
245:05 - may take a while. In my case, I already have
all these images downloaded, so it was a bit
245:10 - faster. What is complete we're looking for
is this message here that says grenade is
245:15 - running, it should say running and it should
be green, and then you know that you're good
245:20 - to go. So I'll just close this window now.
With the Kubernetes cluster up and running,
245:26 - one of the first things that I like to do
is to make sure that I am connected to the
245:29 - correct Kubernetes cluster. And that we can
do via the cube control command line tool,
245:34 - which is the command line tool to interact
with Kubernetes. These tools should be already
245:38 - installed for you with your Docker installation.
So you should be able to start using it right
245:43 - away. I'll open up a brand new terminal. And
what I'm going to do is just type cube control
245:52 - config. current context, hit Enter. And that
is giving me back Docker desktop. So indeed,
246:01 - Docker desktop is the is the name of the cluster
installed by Docker, once we enabled the Kubernetes
246:08 - cluster, so we are good to go on that side.
Now it is time to start creating or declaring
246:15 - how we want to deploy the components into
Kubernetes. For our REST API and database,
246:22 - do that we will need to write a few yamo files.
To make this simpler. What I'd like to do
246:29 - is to take advantage of the granaries VS code
extension. So to do that, I'll first just
246:35 - close this terminal. And I'll go to the extensions
hub. And I'll search for Grenada is this one
246:45 - here should be the first heat, I'll just say
install should take a few seconds. And now
246:53 - it's ready. So I'll close this. What I'll
do now is go back to our file explorer, and
247:01 - I'm going to create a folder to start storing
all the files that we need to deploy our resources
247:06 - to Kubernetes. So this is going to be our
Kubernetes folder, it can really be any name
247:14 - as you please. And then the first one we're
going to create here is going to be named
247:18 - catalog the job. And I'm naming it this way,
because this will declare all the resources
247:24 - that we need to deploy our catalog REST API
to Kubernetes. And also to keep things simple.
247:31 - To speed up the process, I'm going to take
advantage of that goodness extension that
247:34 - we have installed to generate a little bit
of code here. So I'll just say deploy, and
247:41 - that pops up a little bit of IntelliSense,
as you can see, and then we just have to click
247:45 - it. And that will give us a basic shape for
our deployment resource. Now the plugin resource
247:52 - is what you would use to declare the desired
state of the containers or specifically the
247:58 - ports that you want to get deployed into Kubernetes.
For in this case for a REST API. So let's
248:04 - understand what what this file means. So if
you see the first line declares what we call
248:09 - the API version, this is something that all
the coronis resources will will have. And
248:14 - this allows you to specify what is the API
surface that you want to take advantage of
248:20 - in Kubernetes. So depending on the version
you pick here, you will have access to more
248:25 - or less features of the resource that you're
configuring, in this case, a deployment resource.
248:31 - second line declares the kind as as we know,
is a payment object. And then we go to metadata
248:36 - name. Metadata name defines the name for these
deployments. So in our case, we'll use name
248:42 - it
248:44 - catalog. And then we go to the specs section.
The first part of the suspects section is
248:52 - the what we call the selector. And the selector
is what we use to specify how is this deployment
248:59 - going to select the port that is it is going
to manage. So in this case, it is saying Well,
249:05 - I'm going to say to manage all the pots that
have the following labels. And in this case,
249:11 - we just have one label, it is called app.
And then there's a value, the value that we're
249:16 - going to assign here is going to be good.
So all the ports that have an app label name
249:22 - with the value catalog, will be managed by
this deployment. Then we keep going into the
249:28 - template section. So here is where we're going
to declare all of these containers that are
249:35 - going to be included in the, in this deployment.
So one of the first things to declare here
249:42 - is the label or the labels for these for the
bots. In this case, we're going to name this
249:50 - this bot as catalog that's going to be the
label. So that's the way that we can identify
249:55 - all the bots that are related to catalog in
this case, and this one has to match exactly
250:02 - the label that we just typed a moment ago,
so that the deployment can actually manage
250:05 - these bots. Then we will forward to the most
interesting section, which is a spec on the
250:11 - template. And the first thing that we're going
to find here is containers. So here, we declare
250:16 - the list of containers that are going to be
included in this deployment. And the first
250:20 - thing that we have to do for this very first
container is we'll give it a name. So again,
250:26 - to keep things simple, we'll just name it
the catalog. And then we have to declare,
250:32 - which is the image that we are going to be
deployed. In our case, we're just going to
250:38 - be using that image that we created in the
previous video that we deployed to Docker
250:41 - Hub. And then in my case, it was blue sea
catalog, b1. So we are saying we are going
250:48 - to be pulling down into Kubernetes, this image
named who you see catalog be one that we were
250:54 - saying there, but you could specify any image
that you want here. Next, we go into the resources
251:00 - section. So here's where you declare what
resources specifically in terms of memory
251:06 - and CPU, in this case, what resources are
needed from the Kubernetes node, in order
251:12 - to run your REST API. In this case, I'm just
saying, Well, I'm going to be needing 128
251:19 - megabytes, which by the way, while may be
right will be equivalent roughly to 1024 gigabytes.
251:29 - So that is the full value here, you could
change this according to your needs. And then
251:34 - on the other side, we have the CPU where we're
saying that we want to use 500 million CPU.
251:40 - So this is an interesting notation. And what
it really means is, this is similar to say,
251:46 - I'll just type here would be kind of like
0.5 CPU, so roughly half CPU, just to understand
251:56 - it better. So 500. So basically, we're saying
we are good to go with one half CPU for our
252:05 - REST API, which would be definitely enough
for us. Next, let me scroll down a bit. We
252:15 - have the ports. So here's the word declare,
which is the port that that our container
252:21 - is exposing. And we can communicate to in
order to access the REST API. In our case,
252:30 - we're going to do just as we did in the previous
video, where we mapped into the into port
252:34 - 80. Because we said that they are base ASP
NET Core image overrides our port, and by
252:42 - using Port 80. So we will be using the same
port, or 80. So that's a port inside the container
252:49 - where we can reach the REST API. The next
thing that we're going to need in this deployment
252:55 - is a few environment variables. Because if
you remember, when we run our container, we
253:01 - had to specify both the host to be able for
it to be able to talk to our MongoDB container,
253:08 - and also the password for the user that connects
to that to that database. So how do we specify
253:16 - environment variables in this case, it's fairly
straightforward. We can use the M section,
253:21 - so you just type M. And then you have to declare
key app name value pairs for each of the environment
253:28 - variables. The first of all we're going to
declare is
253:31 - the one for host. And then if you remember,
in app settings JSON, which I'm going to open
253:37 - right now quickly, we have this hierarchy
of settings, right we have MongoDB settings.
253:41 - And in what we said is we have host or user
and password. So I'll go back to catalog jammal.
253:47 - And we have to follow that same hierarchy.
So I'll do Mongo DB settings. And then the
253:54 - way to separate add to go into the hierarchy
in in this java file will be be a double underscore.
254:03 - And remember when we run will be passing variables
into the container, we use colon, one in this
254:08 - java file, the convention we're going to use
is going to be double underscore. So that's
254:13 - How you address these different settings.
And then we'll give it a value. The value
254:19 - for the host in coronaries is going to be
MongoDB. service. And we'll see in a moment
254:25 - how we define this MongoDB service. But for
now, so yes, this is how we can address the
254:31 - MongoDB container that we're going to declare
later on. Next, we need an environment variable
254:37 - for the password. But before we can declare
it, we actually have to create this password,
254:43 - add ingredients. And luckily, coneys has this
built in support for secrets. sensitive information
254:50 - like that. So in order to do that we're going
to do is just open my terminal. And I'm going
254:55 - to actually use a shortcut here Ctrl J, that
opens up the last terminal we used and scroll
255:01 - down a little bit. And then we're going to
type here is the cube control an option to
255:09 - be able to create a secret. So that would
be cube CTL. Create secret. And then I'll
255:21 - type generic. Generic is the type of circuit
that we can use in this case, but there's
255:26 - a few other options that you that you can
also use here, then it's fine for us. We'll
255:30 - name it, catalog secrets. And I'll use spooler,
just because you can actually put multiple
255:37 - secrets in one of these secrets here. But
we're only going to be using one. And in order
255:42 - to type it directly in the command line, what
you do is say from literal. And then you have
255:50 - to specify the name and the value for the
secret. So the name is going to be MongoDB.
255:56 - Password. and the value is going to be just
like we did before as bad bound word one.
256:07 - And then I'll hit enter. So that created the
secret. Now that we have created the secret,
256:14 - we can actually go ahead and declare it and
feed it into an environment variable. To do
256:24 - that, we'll do something similar. So we'll
say name. And again, we'll follow the the
256:29 - hierarchy, right, so MongoDB settings, in
this case, double underscore is going to be
256:36 - password. And then in this case, we don't
want to use the value, we want to read it
256:42 - from the secret. And to read it from the secret
what we can say is value from Enter. And we'll
256:51 - say secret key ref. So we're referencing a
secret that's named name is going to be catalog
257:02 - secrets is the name that we gave the secret.
And the actual key within that catalog secrets
257:11 - is going to be Mongo DB. Password. So that's
how you can address a secret from the declaration
257:19 - of an environment variable in Kubernetes.
That's looking good. I'll close this terminal
257:26 - again, have more space here. And the next
thing that we want to specify here is our
257:31 - our health probes. So the health probes is
a mechanism that enables coronaries to constantly
257:39 - monitor the health of our race API, by using
the health checks that we already defined.
257:45 - If you remember, a few episodes ago, we declared
some health checks in the REST API. So now
257:50 - it's we're gonna we can actually, we can actually
use them to let us know if our containers
257:56 - are in good shape or not. And he remember
we had both liveness and readiness probe.
258:00 - So both of them we're going to be using here.
So start with the liveness probe, and to declare
258:08 - it where you can use his liveness probe. And
then the kind of probe that there's a few
258:14 - kinds of probe as well, what I'm going to
be using here is the HTTP HTTP GET type of
258:22 - probe, which is just going to call some HTTP
path with the get verb into the API.
258:29 - And so the path that it needs to use is, if
you remember, that would be held live. And
258:38 - it needs to use Port 80 for that one. And
that's it, that will be the biggest probe.
258:47 - And I'll just copy this to define our readiness
probe. readiness probe is going to be very
258:55 - similar, but it ends in red. So if you remember,
we would use the liveness probe to tell if
259:01 - our recipient is up and running, and the readiness
probe to tell if any dependencies of the REST
259:06 - API are responding correctly are ready and
basically, REST API is ready to serve requests.
259:12 - So with that we have properly declared a deployment
for our REST API. But it is not enough. So
259:23 - this will go ahead and create the bots pull
this pulls the containers, and environment
259:27 - variables and all that. But still, there's
no way to reach for anybody to reach into
259:33 - this container from the outside. And to enable
that, we need to bring in another component
259:38 - that's called service. So that service, we
could either create in another java file,
259:44 - or we can use security right here, which is
what I'm going to do. And the way that you
259:47 - separate these two different resources in
the Java file is by using three dashes. And
259:54 - then you can go ahead and start declaring
your resource. So I'll do some IntelliSense.
259:58 - Again here, so I'll just type service. And
that brings up the query service IntelliSense.
260:04 - Here, so I'll click on it. And that will scaffold
a little bit of pieces in there that we can
260:10 - take advantage of. So the service is the is
the type of resource that you use to be able
260:17 - to address resource within Kubernetes, either
internally or externally, which is what we
260:23 - need at this point, the service we need to
give, we also need to give it a name, just
260:27 - like we did with deployment. So we'll name
it the catalog service. And then one piece
260:35 - that's not listed here that, but that is important
for us is the type, there's a few types of
260:40 - services. But in our case, we want to use
a tight named load balancer. Load Balancer
260:46 - is the one that allows queries to request
natural IP, or a natural or not, I guess,
260:54 - not an IP, in this case, because it's localhost.
But it requests a way for two to open kind
261:01 - of a window to the to the outside, so that
people can actually reach out to our REST
261:07 - API from the outside. So we'll see how that
that name resolves when we run this, but you
261:14 - know, various responsibilities. Otherwise,
we cannot reach the service from the outside.
261:18 - For selector, we have to specify the port.
Well, the label for the the ports that we
261:26 - have declared before, if you remember these
ports, here, we declared the template, we
261:33 - said that the labels for all the ports that
are going to be managed by the deployment
261:37 - is going to be Catholic. So that same label
is the one that we have to use, what we declare
261:42 - the service, or the color selector with, we're
going to say, well, we're going to this service
261:48 - is going to be able to target any of the ports
that have the app label with the value catalog.
261:55 - So that's how you connect the service with
the bots. And then you also have to specify,
262:02 - okay, so which is going to be the port, that
that from the outside, people can reach into
262:10 - our API from the outside, and that has to
be mapped into a port in the in the container.
262:14 - So that port in this case is going to be we're
going to be using your ad just because it's
262:19 - the default port for HTTP. So that will allow
our clients to not even have this Wi Fi port,
262:23 - it will just be able to use call directly
into the API. So they will go into port 80.
262:28 - And the target port has to be the port that
we have specified for the container to remember,
262:33 - over here, imports, we declare container port
80. So container port 80 is the target pool
262:40 - that we want to use here. So it's really mapping
80, to 80. But it doesn't have to be like
262:45 - that, we could, we could have said, let's
say 8080 maps to 80, that will be totally
262:50 - fine, just like we did with the container.
But it is more usual to use a port 80. So
262:56 - now we should be ready to start deploying
these well, to deploy these bodies resources,
263:04 - both deployment and the service. So how do
you deploy this into Kubernetes. So we have
263:09 - to go back to our cube control tool to be
able to do that. So I'll open up my terminal
263:14 - again, Ctrl J. And I'll switch to my release
directory. The command to apply this deployment
263:23 - is called this this java file is
263:28 - cube control, apply dash F, and then the name
of the file, hit Enter. And you should get
263:37 - a couple of messages stating that they got
up the deployment has been created, and the
263:43 - service has been created. Now you want to
see a which is a deployment or what's the
263:48 - state of a deployment that should be created.
What you can do is to say cube control, get
263:55 - deployments and that will give you a list
of all the created deployments this case is
264:00 - saying we have a one deployment named Gatling
deployment and currently it is saying that
264:07 - zero of one of the bots is it is ready to
go. So it means that it is not really ready
264:14 - yet. So, let's dive in a little bit more and
get details about the actual bots got created.
264:21 - So what we can do is say, cube CTL get bought.
And so as you can see all the with one pod
264:29 - that we have declared here, the name is starts
with enable deployment. And then it gets a
264:35 - name for what we call the replica set, which
we've not, we will not talk about in this
264:40 - video. And then finally, some identify for
the actual pod. And then indeed, the port
264:45 - is not ready. So this is saying zero of one
ports are ready to be used, right to be reached
264:51 - by the outside. But still, he says running.
So this means what this really means is that
264:57 - our our liveness probe, that you remember,
we have a liveness probe is is reporting a
265:02 - healthy status, but our readiness board is
not reporting healthy status. So to find out
265:08 - a little bit more of what's going on here,
and I'll expand this a little bit more. Let's
265:12 - actually get some logs from that catalog board.
So to see cube control logs. And then the
265:25 - name of the bot hit Enter. And then we're
seeing something interesting here. Let's let
265:31 - me scroll up a little bit. Yes. So here, as
you can see, the our MongoDB readiness check
265:44 - is failing with status on healthy dubray him
was cancelled. And as you can expect this
265:51 - is well, this is not expected because we have
not really deployed any database yet. But
265:56 - this is great. This This confirms that our
readiness health check, both have checks are
266:02 - actually working properly. And we just need
to make sure that we fix this problem with
266:07 - the database, we bring it up. And then we
should be able to have an REST API up and
266:12 - running. Let's close the terminal. And let's
actually declare what we need to declare for
266:17 - our database. So I'll go back to migrate this
directory. And I'll say new file. And this
266:23 - file is going to be called Mongo DB. Because
everything we're going to declare here is
266:29 - just for the deployment of that MongoDB database.
Now, the type of resource that we're going
266:34 - to create for MongoDB is actually called a
stateful set. And see if we don't have a way
266:39 - to generate the skeleton for a stateful set.
And yet, we're going to use the deployment
266:43 - template for this. So let's use to deployment
select Windows deployment. And then what I'm
266:49 - going to do is just switch from deployment
to stateful set. So let's say Phil said he
266:57 - has similarities with the deployment. But
it is actually meant for stateful applications.
267:03 - So a stateful set provides guarantees about
the ordering and uniqueness, uniqueness of
267:09 - pots. So when you see the pots that are created
by a stateful set, they will not have random,
267:13 - random names, they will likely have some very
specific order names. So for instance, in
267:20 - the case of this one, it may be called MongoDB,
one MongoDB, two MongoDB, three. And more
267:25 - than that, if one of these ports dies, let's
say MongoDB, one dies. And when it comes back,
267:31 - he will come back as MongoDB one once again.
And this is very important in the case of
267:36 - MongoDB. Because we will attach a persistent
volume to it, which will have the database
267:44 - data files. And we want to make sure that
those files don't just get lost as as the
267:48 - port is reconstructed in the case that it
needs to be given for any reason, right? So
267:52 - we want to keep it around. So the right type
of resource to use for for a persistent service,
267:57 - like MongoDB would be a stateful set. So just
like we did with deployment, one of the first
268:04 - things to do here is to assign a name to a
stateful set. In this case, we will name it
268:09 - MongoDB stable set. And then one important
thing that's not being generated here is what
268:17 - we call the service name.
268:20 - And the service name is used to give a some
identity both to the stateful set and to the
268:26 - bots there are going to be a managed by it,
which is not actually needed for deployments.
268:31 - But for a stateful set. It's it's a requirement.
The name that we're going to give here is
268:38 - MongoDB. service. We see how the service is
died later on to the MongoDB service and back
268:49 - to the catalog later on. Then also just like
we did with deployment, we need to define
268:55 - which are the labels that the status is going
to be using at to select the ports that is
269:01 - going to be managing. So in this case, let's
say that our bots are going to have the Mongo
269:08 - DB later the MongoDB value in its app label.
And we're going to do that Then we have to
269:14 - make sure that in the pod template down here
in labels app, we have to be using the same
269:19 - value. So all our parts are going to have
an app label with a value of MongoDB. And
269:26 - then the stateful set is being configured
to manage all those pods with the MongoDB
269:30 - value in the app label. Now we keep going
down into the container section inside the
269:35 - spec. And then let's just give the name of
the container listen this name it again MongoDB.
269:42 - And then for the image will be we'll use the
same image that we've been using so far, is
269:46 - just Mongo, latest version of Mongo, then
we keep going down into the resources section.
269:52 - And we will leave these resources, they should
work just fine for us. But it's up to you
269:56 - to modify how much memory and CPU you expect
to be using for your MongoDB server and the
270:02 - MongoDB database. Moving on, we have to declare
the the port where the MongoDB container is
270:10 - listening on. And by now we know that this
port is 27, zero 17. Right. So that's the
270:15 - port that we have to use to, to connect to
that MongoDB service inside the container.
270:21 - And once again, like we did with, with gadelha
yamo, we have to define a couple of environment
270:26 - variables to be able to talk to that well
to be able to start up our MongoDB container.
270:31 - And those are the username and the password
for the for the user configured for for MongoDB.
270:38 - So let's declare and sorry, let's see clear
and M section. And here, let's start declaring.
270:51 - So the name of this environment variable is
Mongo in it, db. root user name. and the value
271:01 - that we're going to assign to it is the one
that we're using. So far more go admin. And
271:11 - then for the for the password, we're going
to be using really the same secret that we're
271:15 - using gatok. So I'm switching to catalog here.
And I'll just copy our password section into
271:22 - MongoDB. base here and fix it a datian. And
then as you see we're reading from the same
271:30 - location, but the name of the environment
variable is just a little bit different, is
271:35 - going to be Mongo in it, db. root, password,
right, so that's a, that's a username and
271:43 - password environment variables that the MongoDB
container is expecting. The next thing that
271:48 - we need to define in the case of the MongoDB
container, is what we call the persistent
271:52 - volume, right. So we need to declare some
storage way too, ask coordinators for some
271:59 - storage space to place the data files for
our database. Otherwise, I mean, yes, a database
272:07 - will exist within the MongoDB container. But
when the container and the port, the containers
272:11 - container is killed for any reason, the data
will just disappear, right? So we don't want
272:15 - that to happen. So to do that, we create what
we call a persistent volume, and greatest
272:19 - persistent volume, we're going to use what
we call as a volume claim template. So let's
272:26 - do that. And they make sure I pick the right
place for this. I should be here. So let's
272:33 - say volume claim templates. And really the
balloon claim templates is a way to declare
272:40 - or to ask Kubernetes for some space, some
storage space in the node, where the where
272:46 - the pod is going to be executed, right, so
I need some space. And we have to declare
272:51 - a some details about that space that we're
going to reclaim. So first, we're going to
272:55 - set up some metadata. And we pretty much just
need the name here. So what's the name that
273:04 - we're going to give to these to this volume,
that's going to be data.
273:09 - And then we have to specify the spec specifications
for the volume that we're going to ask for.
273:16 - So that goes into the spec section. And then
here, we have to specify an access mode access
273:23 - mode. So access mode declares, which way is
this persistent volume going to be going to
273:31 - be mounted into the note, and actually, this
should go into a previous line to do it like
273:37 - this. And, for our case, the mode of READ
WRITE, once, once it should be good enough,
273:45 - and really this one here, it means that the
volume that's going to be created that's going
273:49 - to be mounted is going to be mounted as read
write, and for a single note, so meaning that
273:55 - just one note can read and write to these
volume at a time. If you wanted to. You wanted
274:01 - to have more than one node we able to write
to this volume, you will have to use a different
274:04 - kind of access mode. And then finally, we
have to define the resources that we need
274:10 - here. So in this case, we'll declare resources
and Then requests. And finally, storage. And
274:21 - here's where we declare how much space we
want for this volume. And for our case, let's
274:27 - go for one, I think the term will be gigabyte,
similar to one gigabyte, that's going to be
274:34 - as much as storage, we're going to reclaim
for this volume, say this. So with this, we
274:40 - have reclaimed space in the note, right? For
this form for MongoDB. However, we still need
274:46 - to tell our container that such a space exists.
And we have to map that space in the in the
274:52 - host machine to space into the container.
And to do that, we're going to declare a volume
274:57 - mount, the balloon mount needs to be declared
inside the container spec. And so I'll just
275:03 - type here, balloon mounts. And here, we're
going to specify a name for it. And this name
275:13 - will have to match exactly the name that we
have specified for the in the balloon claim
275:18 - template, right. So we said it's going to
be data. So data is the name that we should
275:22 - use here. And then the mount pad is the part
where traditionally MongoDB is stored its
275:29 - data files right inside the container. So
that that space is going to be slash data
275:34 - slash dB. So what this really means is that
when MongoDB MongoDB container writes into
275:40 - its data DB directory for the data files for
the database, those files are going to end
275:45 - up into de a persistent volume that has been
declared on the site here, right, so the data
275:51 - gets read in outside of the container and
into the persistent storage in somewhere in
275:57 - the host. So this way, if the container goes
down is the port goes down for any reason,
276:03 - the data is not is not lost, and they will
come back as the port comes about with the
276:07 - same identity in the stateful set. The next
thing that we need to do, just like we did
276:12 - with the catalog yamo is declare a service
write a service that allows us to address
276:17 - or to get to the MongoDB service. And so I'll
just please, and then I'll type service for
276:26 - cleaning service, so generates just like we
did before. And just like before, we have
276:32 - to specify some name for the service, let's
call it MongoDB. service. And then one important
276:40 - missing piece here is this thing called the
cluster IP. So cluster IP is what you would
276:45 - use to specify the IP address for your service,
right. And so by default, any service will
276:52 - get local IP that that can be used to talk
to other services within the cluster. But
277:00 - in our case, we want to create what we call
a headless service. So we don't want to assign
277:04 - an IP to the service. Because
277:08 - in a stateful set, we want to address each
of the nodes for each of the pots individually.
277:12 - So in this case, we're going to say none,
so we don't want an IP in this case. So it
277:17 - turns it into a headless service. Now for
the selector, once again, we have to specify
277:23 - how is this service going to be mapped into
the ports that exist for for MongoDB. Right,
277:30 - so for that, we have to go back, once again
into the bottom plate, the bottom plate metadata
277:36 - labels app, the label that we're looking for
is AP, and the value is MongoDB. So we go
277:42 - back, copy that into this lector MongoDB.
So anytime a request comes into this service,
277:50 - it will find the nodes that sorry, the ports
that have been tagged with the MongoDB a value
277:56 - in the app label. And then that's what, that's
how it's going to find them. Finally, we need
278:03 - to specify the ports. And so just like we
did with the container, we're just going to
278:06 - do a simple mapping of 27 zero 17. So any
request that comes into 27, zero 17 should
278:12 - go should be redirected to the port where
the container is listening on. And that that
278:17 - port is again, as you can see here, 27 zero
17. I'll just copy that over here. Now that
278:27 - we have done this, it should be ready to to
get to get started with this MongoDB container.
278:33 - So I'm going to open up my my terminal again,
Ctrl J opens terminal. I'll scroll down this
278:40 - a little bit. And then I'm going to switch
to the Kubernetes directory. And here I'll
278:49 - just do cube control, apply dash F and then
our demo file MongoDB demo, and I'll hit enter.
279:02 - So both the stateful set and this service
have been graded. And so at this point, let's
279:07 - see, how does the stateful set look like right,
so let's do cube control. Get Data Sets. And
279:18 - they'll give us the one stateful set that
has been created MongoDB stateful set, which
279:23 - seems to be ready, it's healthy, it's in good
state, and it's ready to be used. Now that
279:28 - we did that, let's take a look at all the
ports that we have right now. So once again,
279:33 - cube control get hot. And as you can see,
now we have our catalog board, it is actually
279:43 - ready. So it's no longer reporting 01 is reporting
one out of one. And that is because the ad
279:50 - because the the ready the readiness probe
that was trying to reach into the, into our
279:57 - MongoDB database, it is now able to actually
do it. And that's because we now do have the
280:03 - MongoDB service available. If you remember,
when we were in catalog, Jamel, we declared
280:08 - that the MongoDB settings horse was going
to be MongoDB service, it was not available
280:12 - yet. But now that we have declared it and
we have deployed it, we do have the MongoDB
280:15 - service that I can reach out to. And then
that allows our health check to pass so we
280:20 - can connect to the database successfully.
I just like we have that board, we also have
280:24 - the port, the MongoDB stateful, set zero.
So as you can see, it is not a random random
280:29 - ID as a as in the case of deployment is more
of a very specific numbered and ordered index
280:37 - for these stateful sets. Right. So if it dies,
it needs to come back with that same number.
280:43 - Let's now see if our REST API is working properly.
Now that is running within coordinators. So
280:48 - let's open up postman. And last time that
we did a get against our REST API, we did
280:54 - it over Port 8080. So because that's the port
that we exposed when run it is as part of
280:59 - Docker. But now we have switched to Port 80.
And we can either query the API like this,
281:05 - or we can just remove ad because it's a default
HTTP port. So this should be good enough to
281:10 - do a get against the API. So let's see what
we get. And sure enough, we don't get any
281:16 - results. Because remember, this is a brand
new database that's now hosted inside Kubernetes.
281:21 - So this effectively don't have any data. But
we can go ahead and create something in there.
281:26 - And so I'm switching to the post up here.
And I'm going to also change these to just
281:33 - be HTTP localhost items. And then for body,
let's come up with something quickly. Let's
281:38 - say we're going to create a potion again,
price 12. And then hit send. And sure enough,
281:45 - the potion has been created, we can create
a just one more thing, let's say an antidote.
281:51 - With Price, let's say 17, hit send, and has
been graded to go back to the get it sent.
282:00 - We are getting our two items now. So the REST
API is working properly. But everything is
282:05 - now running within grenades. And so we talked
about this capability of grenades to self
282:11 - heal, right. So it should be able to always
enforce that desired state, regardless of
282:17 - what happens to the bots. So let's see how
how that exactly works. So I'm back in VS
282:24 - code now. And what I'm going to do is just
to get a little bit more space here to be
282:30 - able to visualize things better. So I'm going
to move this left side all the way to the
282:34 - left. And then what I'll do is spin up another
terminal with the split terminal burden. So
282:41 - that now we can have two terminals side by
side. And I'll move things around a little
282:47 - bit like this, perhaps right there. And so
what I'll do is on the left side, I'm going
282:56 - to be watching for the bots with cube control,
get pods, dash W. So that lets me see any
283:04 - changes that happen across the the current
existing bots in there. And on the right side,
283:11 - I'm going to simulate the killing of one of
these bots. So let's say that I mean, let's
283:18 - imagine that the board had some bug, and that
causes the bot to crash. Right that then what
283:23 - happens. So let's do cube control, delete
board. And so let's try our catalog board
283:31 - or only catalog board. And I'll go ahead and
delete it. So I'll hit Enter, and see on the
283:38 - left side, how right away. As soon as it starts
terminating that port, it immediately starts
283:46 - spinning up a brand new container, right.
So that's the capability of coordinators to
283:53 - always detect this discrepancy between the
desired state and the actual state. And as
283:59 - soon as you detect the situation, it needs
to do whatever it needs to be done to bring
284:03 - back things to consistency, right. So in this
case, the Newport is up and running, and then
284:08 - I'll just do Ctrl C. And I'll do get pods
again without the W and you can see that now.
284:13 - We have, again, our two bots. But now we have
a catalog but with a different identity, right?
284:19 - You can see it's not the same identity as
before. And that's because deployment type
284:25 - deployments, great bots are ephemeral, ephemeral
in nature, right? So they are just stateless.
284:31 - Now, that's not the same case. As for our
stateful sets, as we said, Our stateful sets
284:36 - should be persisting across the lifetime of
a pod, right? So if we just have these MongoDB
284:44 - stateful, sets zero here, what happens if
we deleted right? More than that what happens
284:48 - with the data that is being held by this MongoDB
bot, because we already have data in there.
284:53 - So would it survive for the data to still
be there, with the port come back, so let's
284:57 - try it out. So I'll do a wash again for the
bots. And I'll copy the name of our stateful
285:04 - set. And so I'll do cube CTL, cube control,
delete bot, and I'll do MongoDB stateful.
285:11 - Set, let's see what happens. And see on the
left side, the pod is indeed getting terminated.
285:18 - But right away, Grenada is detects that it
needs to bring it back. And it needs to bring
285:22 - it back with the same identity MongoDB safe
was at zero, because this is a stateful set,
285:26 - right. And we don't want to lose the data
that's being held by the sport. And in fact,
285:31 - if I just control CDs, and guys, I'll do get
pods, we have our two pods. And now we should
285:39 - be able to verify that the data is not gone.
So it should still be there. So if I go back
285:43 - to postman, and I query for the data, once
again, we can see that the data is still there.
285:49 - So it has not gone anywhere. So so that means
that indeed, our persistent volume got created,
285:57 - and the data is being stored outside of the
container and into the host. And that's enabled
286:02 - by our stateful set. So I'll go back to VS
code now. And we also talked about this a
286:09 - capability of grenades to easily scale the
ports and the containers inside them, without
286:15 - really much, much stronger, right. So if we
are somewhere our network we need, we have
286:20 - much more requests in our website, we do have
not just one port for catalog, but we need
286:25 - to have three, well, what would we do? And
how can Kubernetes help us with that. So once
286:30 - again, let's monitor what's happening on the
left side, get pods. And then what I'm going
286:35 - to do here is just ask Kubernetes to scale
the deployment for discovery deployment, where
286:40 - you can do is
286:41 - cube control, scale, deployments, and then
it will be catalog deployment. And then you
286:51 - have to say how much right right now we have
one. Now we want to have three. So hit enter.
286:59 - I noticed on the left side that immediately
starts provisioning a bunch of new bots to
287:06 - enforce this new decided state, right, and
this happens blazing fast, right. So if I
287:11 - just do Ctrl C, now on the left side and get
bots, again, you can see that we already have
287:16 - three bots, and we only had one just seconds
ago. So here you can tell, like the power
287:23 - of the combination of Docker containers, and
Kubernetes, right, how we can bring in a much
287:29 - more instances of our containers of our of
our REST API. In this case, without really
287:33 - much trouble just running one line, we now
have three copies of the container running.
287:39 - And now, the whole point of having these data
replicas of the pots is so that we can do
287:45 - some good load balancing between them, right.
So when a request comes, it should land in
287:49 - one or another of these bots. And how can
we verify that? Well, unfortunately, we don't
287:56 - have good means to do that right now. But
I think we can easily introduce a little bit
288:01 - of logging into the bots so that we can easily
tell which bot the request, the request is
288:07 - landing. And so to do that, what I'm going
to do first is just I'll just close the terminals
288:13 - for now. And then I'll go to our Explorer,
or go to our items controller. And here, I'm
288:20 - just going to add a little bit of logging.
To add logging where we can do is bring in
288:25 - the standard a logger interface. So I'll do
only a logger for items controller. Let's
288:37 - call it logger. So I logger is, is a standard
object available in dotnet five, so pretty
288:46 - much in any application dotnet five. And so
what you can do here, you just do dependency
288:51 - injection, as you do with any other service
built in service of dotnet five. And I'll
288:58 - come up to the logger instance right here.
Now that we have that, what we can do is just
289:08 - pick one of our API's and do some logging.
So I'll go for the easiest one, which is going
289:12 - to be our Get diverse API. So in this case,
I'll just open up here, one line. And I'm
289:18 - just going to log a little message that says
how many items we found, right. So to do that,
289:24 - what I'll do is just logger dot log information.
And then let's do a little bit of string interpolation
289:34 - here. First year I'm going to put here is
the current current time. And I'll do that
289:40 - via the date time class, I'll choose the UTC
time to string and then we'll show adjust
289:49 - the time in the format of hours, minutes and
seconds. Okay, so type format there. And then
289:58 - I'll just do corner just say retrieved. Items
that count items. Okay, so just for us to
290:12 - verify that things are landing in different
parts. So I'll save these. And then they will
290:17 - not change. What we have to do now is to create
a new version of our Docker image. So I'll
290:23 - open up our terminal now. And I'll delete
one of these, so that we only have one. And
290:29 - here I'll do what we did in the last video.
So I'll just run our Docker build command.
290:39 - And I'll be publishing this into Docker Hub.
So I'll be I'll keep using the same format
290:42 - as before, using the username first, and then
the name of the image. And then the one thing
290:48 - that I'm going to pop here is the deck because
this is a new a new version of the image.
290:53 - So we should be bumping it, let's say to be
two, this is necessary, so that coronaries
290:58 - can later tell that this is a new image, or
that it needs to pull it down from Docker
291:03 - Hub, otherwise, he will not be able to do
so then I'll say dot O, hit Enter. And then
291:10 - I'll just miss I'll just miss one parameter
here, which is the dash D for the tag, you
291:15 - enter again, this is going to build the image,
it's going to reuse some of the cache layers
291:21 - and then it's going to be just a piece that
is needed. Okay, so the image is built. Now
291:26 - I'm going to do me to login into Docker Hub
Docker login.
291:38 - And now I should be able to just push the
image shorter. So I'll do Docker push, would
291:43 - you see catalog, B to enter. And then again,
some of the layers are going to already exist
291:51 - in Docker Hub. So only the layer that's missing,
which is my little change of one line change
291:57 - here is the one that is included in this image
and this one that needs to be pushed into
292:03 - Docker Hub. Okay, so with the image in Docker
Hub, we should be able to tell Kubernetes
292:08 - that we want to start using it. So for that,
I'll go back to catalog Jamel and I'll say
292:13 - hey, cornice, I don't want to keep using a
demonstration one, I want to use version two.
292:19 - Save that. And then back in the terminal,
I'll switch to our coordinates folder. And
292:27 - here, I'll just apply this file was once again.
So cube control, apply dash F, and then we'll
292:38 - do capital gamma. Okay, and so life is if
we do cube control, get pods, watch, see what's
292:50 - happening. So as you can see, the old the
old container dope bots are getting destroyed.
292:56 - And new bots are getting immediately installed
stand up for the new image, the new misperception
293:03 - that we need to be using. So this should take
us a few seconds. And so I'll Ctrl C now.
293:12 - And I'll see the actual status of the pods.
Let's see what we got. So yeah, so we have
293:16 - three new copies of our a catalog REST API,
the replicas of the pod. And so now we should
293:24 - be able to tell if we're load balancing across
them. So to do that we're going to do is again,
293:31 - I'll just make some more space here. I'll
expand this terminal has even more. And I'll
293:39 - split the terminal now in three. So that we
can add Delta locks of the of the three pots.
293:46 - So first here, now go back one directory.
And as they could control get pots, so we
293:57 - get the names of all the pots, and then I'll
do one by one. I'm going to do cube control
294:07 - logs for these one and then I'll do dash f
so that we can tell the logs and then I'll
294:13 - do the same Here, which is our second part,
let's take a look is going to be this one
294:21 - here, dash F. And then the third one is these
guy here for our third terminal to control
294:31 - logs, dash F. Okay, so now we're tailing the
three parts. And I'm going to go back to postman
294:40 - and perhaps we can accommodate this into here
just on top of the other one to see what's
294:45 - going on. Yep. And, yeah, so one more thing,
actually that we have to change is postman
294:53 - is our heater. So let me maximize this for
a moment. Because the default behavior of
294:59 - postman is that it's going to send this a
connection heater with a value of pickle keepalive.
295:05 - And what that's going to do is actually set
up a persistent TCP connection between postman
295:11 - and our bot. And that will actually prevent
our little exercise from allowing different
295:17 - subsequent connections to go into different
bots. So just for testing purposes, and to
295:22 - see how things work, I'm going to disable
that, that heater here and see how these things
295:28 - work. And, yeah, so with that, minimize these
in this way. And let's send one request and
295:37 - see where it lands. You see, it landed in
the first part on the left side, between two
295:42 - items at 704 52. Let's send again. And now
we landed in in our second part, let's send
295:51 - the game loops. Again, in the second part,
and then at this point is going to be a little
295:58 - bit random. I mean, the algorithm that's supposed
to be using is round robin. But really, things
296:04 - can land in any pot. That is point. So there
you go, load balancing in Kubernetes, fairly
296:13 - straightforward, without you having to do
really much work on it. And if you scaled
296:17 - into 1000s of bots, then all of them will
be serving your requests appropriately. In
296:23 - this episode of The dotnet five REST API tutorial,
we talked about unit testing, test driven
296:29 - development, and how to implement them to
raise the quality of our REST API.
296:34 - Today, you will learn what is unit testing
and why it is so important. What is test driven
296:42 - development, also known as DDD, and why you
may want to consider it in your project, how
296:49 - to retest REST API controller via the x unit
testing framework, how to mock dependencies
296:54 - via the mock framework, how to write better
assertions via the fluent assertions library,
297:01 - and how to implement TDD in practice. So what
is unit testing? This is a topic that I'm
297:08 - very passionate about. And to understand it,
let me introduce a quick analogy. Imagine
297:13 - that you're a member of the team in charge
of testing the SpaceX rocket for the first
297:18 - time, the engineers have used dozens, maybe
hundreds of different parts and systems, some
297:24 - not even produced by SpaceX. To assemble this
awesome vehicle. Everybody put their top game
297:29 - to build a rocket. And now we would like to
see if everything worked as expected. launch
297:34 - day is here. And then yeah, that didn't go
as expected, there has to be you can't just
297:50 - assemble a bunch of parts and test them all
together the very first time the rocket is
297:54 - launched. Fortunately, this is not how they
usually test a rocket before launching. Without
297:59 - getting too technical about rockets, because
I'm definitely not an expert in the area.
298:04 - I just wanted to show here a simplified diagram
of the parts of a rocket that I got from the
298:09 - NASA website. All of the different components
and systems like the payload system, or the
298:14 - oxidizer are also individual units of this
entire vehicle that all need to operate properly
298:20 - before the rocket can lift off from it. And
the engineers don't just build this unit and
298:25 - send them to the assembly team to put them
on a rocket and after everything is put together,
298:30 - figure out if all the parts work or not. Each
part of the rocket is tested in isolation,
298:36 - likely several times, where before being sent
to the final assembly into rocket. This gives
298:42 - certainty to the teams behind each part that
as long as it is used according to specifications,
298:47 - that unit will work as expected. And the same
goes for the team assembling the entire thing.
298:51 - They know that they can connect all the parts
according to specification, and the rocket
298:56 - should lie. This saves time and money for
everyone. Unlikely saves a few lives along
299:01 - the way. So in terms of software engineering,
we can define the testing as a way to test
299:07 - every piece of code in isolation without external
dependencies. Now coming back to our catalog,
299:13 - REST API. Even with a simpler screen at this
point, we do have a few components that talk
299:18 - to each other, like the itis controller, or
I didn't have auditory class, the Mongo client
299:23 - instance. And finally, the MongoDB database.
Each of these components are made of a bunch
299:28 - of methods that represent the behavior that
we can get out of them. For instance, the
299:33 - ages controller has has functions like get
item, grade item, update item, delete item,
299:40 - and we will certainly keep adding more in
the future. These are the different granular
299:45 - units that must individually work correctly,
to ensure that the whole service provides
299:50 - the expected functionality. Therefore, for
each of them, really to write a series of
299:54 - unit tests that really exercise every aspect
and every corner or each of these methods
299:59 - to give us enough confidence on their quality
way before trying out the whole service from
300:04 - postman or from any other client. Beyond this,
unit testing has a bunch of benefits that
300:11 - you definitely don't want to miss. With a
unit test, you can quickly verify your code
300:15 - without having to worry about dependencies.
For instance, you can make sure that your
300:19 - class can retrieve items from the database
without having to stand up or talk to a database
300:24 - server at all. And such a test can give you
results in milliseconds as opposed to seconds
300:29 - or minutes, you can make changes without worrying
about introducing regressions. After you have
300:34 - a unit test in place. You can refactor your
code as much as needed without concerns of
300:39 - breaking the service. Because you know that
the unit test will provide you with that safety
300:43 - net unit this will catch box at the point
where it is easier and cheaper to fix them.
300:49 - Which is before merging your code to the code
base on way before getting a deploy to production.
300:55 - fixing something that is already impacting
impacting customers in prod can have an enormous
300:59 - cost, both in human hours and of course in
the amount of money lost by anybody that use
301:04 - it or service. And unit test. If don't Well,
can be the best augmentation of your REST
301:10 - API, since every use case should eventually
turn into a unit test. And those tests can't
301:15 - lie. They must represent the way that the
system works. Now that we know what unit tests
301:21 - are, let's also talk about test driven development
or TDD. So what is TDD? Simply put, TDD is
301:28 - a software development approach, where you
write a test before you write just enough
301:33 - production code to make the failing test pass.
301:36 - This translates into a cycle made of three
phases, a red phase where you write a test
301:43 - that represents your software requirement.
This test fails because you have not implemented
301:48 - any production code yet. In fact, the test
doesn't even compile at this point. A green
301:54 - phase where you write just enough production
code to make the test pass. You don't need
301:58 - to implement anything beyond what's needed
to pass a test. And inelegant or only code
302:03 - is allowed at this point. Finally, if needed,
you refactor the code you just wrote while
302:09 - you keep running the test to make sure that
they stay green. It is at this point where
302:13 - you eventually arrive to code optimize it
for readability and maintainability. You keep
302:19 - repeating this cycle for any new piece of
functionality. This is a basic cycle of DDD.
302:25 - Why would you want to embrace DDD? Well, there
are a lot of benefits of embracing this practice.
302:31 - But there are three aspects or like most we
did it, you start by focusing on the requirement,
302:37 - not on the implementation. This gives you
a lot of freedom in terms of trying to properly
302:41 - address the requirements, because you're not
constrained by an already implemented piece
302:44 - of code. When you implement the code, first,
you end up writing tests that verify only
302:49 - as much of the implemented code as you have
time or patience for because you already invested
302:53 - a lot of time and effort in that code. You
can increase it this coverage, because by
302:59 - definition, you would have not written any
more production code other than needed to
303:04 - pass a test. Again, when you don't do things
the DDD way, you might end up with multiple
303:10 - corner cases that might feel that you might
forget or might not have time to test properly
303:15 - reducing the test coverage. Finally, clean
design is enforced from the start. As you
303:21 - write a test, you will naturally start designing
the pieces of production code in such a way
303:25 - that leads to a passing test. The classes
and methods emerge from the test, and you'll
303:30 - naturally avoid the pitfalls of writing code
to Cobbold to be tested. There are three main
303:36 - unit testing framework in the dotnet ecosystem
these days, and unit, Ms test, and x unit.
303:45 - They all fulfill the same purpose of allowing
you to write and run your unit tests in an
303:49 - automated way. However, for any new project,
I strongly recommend you choose x unit. This
303:56 - framework comes from one of the original authors
of the popular end unit framework. But it
304:01 - was really meant to be more closely in line
with the dotnet platform and to help write
304:06 - clearer tests. It is also more intuitive than
ms test which requires more attributes in
304:12 - test classes. Some of them not straightforward
to use properly, especially for developers
304:17 - new to the platform. Let's see now how to
implement unit testing and TDD in practice.
304:25 - It's time to add a new test project for our
unit tests. But before we can do that, I think
304:30 - we should restructure things a bit to give
our REST API a more specific directory that
304:34 - will live side by side next to our upcoming
test project. So I'll start by going to our
304:39 - explorer view on the left side, and I'll just
look for an empty section over here. And right
304:44 - click, and I'll say New Folder, the new folder
is going to be catalog that API. And now let's
304:51 - move most of the directories and files over
there except for the VS code being catalog,
304:56 - API, and OBJ. So let's grab everything else
into catalog API move. And now that has all
305:04 - the files for the catalog REST API. Now, let's
close this. And then let's delete this directory,
305:11 - we don't need this bin directory or this OBJ
directory, those are gone. Now just to match
305:17 - the folder name, let's rename the project
name into catalog that API. And then we'll
305:24 - have to make a bunch of renames in a bunch
of files, just to match this new project,
305:29 - right file name. So I'll copy this name here,
close this, and then I'll go to search and
305:36 - replace. And we're going to replace catalog.
That's us broke into catalog that API CS broke.
305:43 - So let's just replace all, they will do the
same thing with the DLL. So gotta look that
305:47 - DLL, siapa DLL, it's gonna be renamed into
candidate API, that DLL is replaced these
305:56 - all the files. Now let's look at the namespace.
So today, we have this namespace catalog.
306:03 - And that should turn into base base catalog
that API. And then for every everywhere classes
306:13 - that are using that namespace, let's make
sure they use the new namespace. So using
306:18 - catalog should turn into using catalog that
API to that replacement. Now let's look at
306:28 - our
306:30 - to VS code. That's a JSON file, where we have
these a workplace folder slash catalog API
306:36 - stand to change that, to replace these with
slash gallery, that API slash how to using
306:44 - this file placeholder, all the entries. It's
all done. And now let's go to lunch that Jason
306:51 - and do a very similar replacement, so workplace
folder into catalog that API, or three folders
306:58 - slash catalog API, replace all this file.
And I think that's what we have to do. So
307:04 - I'll just close these two. And then I'll do
a Ctrl, Shift B to make sure everything is
307:08 - building properly. Yeah, looks like it is,
or close these around this one here, you'll
307:14 - see that nougat packages are restored, but
everything looks fine,
307:18 - or close terminal.
307:20 - Now among the things that we modified, and
they'll collapse, this one is the Docker file.
307:24 - So the Docker file is now pointing to a catalog
API that says broke. So I'll just, I just
307:31 - want to make sure that this is still building
properly. So I'll rebuild our Docker image
307:35 - now. So open my terminal. Let's open a brand
new partial terminal. And given this new directory
307:43 - structure, I'll have to go into catalog API.
And here I can run my Docker build command
307:49 - again. So just to Docker build, dash D. And
there's going to be Will you see slash catalog,
308:00 - B three. And so B three, because we were creating
a new version of this Docker image, which
308:07 - was B two last time, hit enter. Okay, so the
new image is created, I'll do Docker images.
308:15 - So it is right there, the image was created.
So everything looks just fine. So this is
308:22 - great. I'll close terminal and close this
file. So now we can actually create our display.
308:27 - So I will collect this for a moment. So we
want to create a new display you could use
308:32 - at the same level. So go back to terminal,
actually, and we're going to go up one directory.
308:37 - And to create this project, you do it very
similarly to how you do for the creation of
308:42 - the web API. So you choose to just use a dotnet
CLA. So dotnet new, and like I said before,
308:50 - they preferred this framework for this project
is x unit. So I will go for x unit. Now let's
308:58 - name this project. catalog that unit tests
hit Enter. And our unit display has been great,
309:08 - because this one over here it has a project
file and an initial class, display class.
309:14 - Are there. Now one interesting thing that
we have now here is that we need to build
309:19 - a not one, but two projects, right? And so
anytime we want to make sure that everything
309:23 - is really properly, however, our physical
environment has not been configured for that
309:28 - yet. So if you look at the JSON alkalosis,
it is configured to be only the catalog API
309:34 - CS Pro. So how can we make it so that anytime
we build it builds both projects. So there's
309:39 - a handy way to do this, that I'll show you.
And what I'll do is I'll create a new file
309:47 - at the root here, just add a route that's
going to be named, we'll call it yours, we'll
309:54 - get proud. Okay, and then I'll collapse this
for a moment. And this file is going to allow
310:01 - us to build all the projects in one shot.
So how do you how do you do? So let's declare
310:06 - the following. So you will do Raju SDK. And
here we're going to be using the build trails
310:15 - traversal SDK. So to do that, you just type
here, Microsoft dot build that traversal.
310:24 - And this was the file operation. So because
he's actually going to pull a nougat package
310:27 - down into your machine. The last version that
I found last time was 303. So I'll do that.
310:37 - Okay, let's go ahead and also, close this.
And inside this section, you have to define
310:43 - an item group. So I can group, close that
group. And here, you have to reference all
310:54 - the project files that you want to compile.
So for that, you want to type like reference,
311:00 - include equals, and then we'll just do this,
this expression. So everything, so star, that
311:11 - star, so any files that end in Brock, are
going to be compiled by this file. Okay, so
311:20 - with this file, ready, let's go back to Explorer.
let's actually go ahead and into task Jason.
311:27 - And let's ask it to no longer just build catalog
API CS, but instead is going to build
311:34 - build that block. All right. So with that
done, I'll do Ctrl Shift v.
311:44 - Yep. And now it's close to East. Let's close
that. You can see that boat. Let me just do
311:51 - this for a moment. catalog that API DLL and
Catherine, etc, they'll have been built by
311:58 - these one comment. So notice that you don't
need a Visual Studio solution for these at
312:05 - all. This is this is my preferred way of building
like all the products in solution in a solution.
312:12 - So build Prague use include all the break
files, and that will do the trick. Right,
312:17 - so close these two now. And then our test
break here, we'll need Of course, a reference
312:23 - to our API, because we're going to be testing
the API controller. So let's make sure we
312:28 - have that reference. So open terminal again,
I'll switch to my PowerShell terminal. And
312:34 - then let's see, I'll go into catalog that
API service catalog does unit tests. And then
312:41 - I'll do dotnet, add reference. And then we're
going to go into catalog that API. catalog
312:50 - API. That's Yes, bro. Right. So that adds
the reference, we look at unit tests, close
312:57 - these, it will have that reference right here.
Okay, so now the break the test probably can't
313:03 - use any of the files, or reference any of
the files in their API project was that and
313:10 - then we're going to need a couple of additional
nougat packages in this test project. Let's
313:15 - actually open these again. And these are going
to be a first we're going to need the nougat
313:21 - package for a extension plugin abstraction.
So let's do that. dotnet add Bakhash Microsoft
313:28 - extensions that logging abstractions. And
this is because we are going to be using or
313:36 - trying to test our controller class, which,
if you look at it quickly, the controller
313:43 - class does receive a logger in constructor
over here. So we're going to be needing to
313:50 - use these a logger class. And for that, we
need that to get package that we just added.
313:56 - The other package is the net package is called
Mach. Mo Q. And this is this little framework
314:07 - that can help you actually mock your your
classes, the classes you're using in your
314:12 - controller. So So that you can a test only
the pieces that you care about in controller,
314:20 - but you don't have to worry about how to create
or how or how the dependent or external dependencies
314:26 - of that class a work. And we're going to go
into those details in a moment. But yeah,
314:31 - those are the two nougat package that we need
for now. So I'll close terminal again. And
314:36 - then let's start focusing on our desk class,
this case, you need this one. Let's rename
314:43 - this class into a more appropriate name. So
rename these into items, controller tests,
314:50 - right, so the convention that we're following
here is that if the controller is named itis
314:56 - controller, that's a class name, we're going
to be using the class name with the suffix
315:02 - of tests for this class is controller tests.
That's the one that we have here. And that's
315:07 - the one that we're going to use for the, for
the class over here, titled The third test.
315:13 - I'm going to collapse this Navigation Pane
now I'll do a Ctrl, Shift V, make sure everything
315:20 - is building properly. And then, if you happen
to be getting any of these red squiggles here,
315:28 - we should not be there. But if it happens,
let me just close these, what you can do is
315:32 - use to Ctrl Shift P, and do only sharp is
dark, only sharp, or you can type that there
315:37 - on the sharp, we start on the sharp, and that
should take care of that. Now notice this
315:45 - fact attribute that was added to our audio
narrated this one method here. So fact is
315:51 - the attribute that you have to use to declare
that one of the methods in this class is actually
315:56 - this method. So that's the only way for the
test runner to recognize that it has to execute
316:00 - these tests. So use Don't forget to add fact
to each of your test methods. There are other
316:04 - ways to declare or to decorate your metals
assessments. But for this tutorial, we'll
316:09 - stick with fact. Now let's go ahead and start
writing our first unit test. But before that,
316:14 - let's look again, other items controller class.
And let's see what should be unit tested.
316:18 - We will write unit test for all of our, all
of our methods are here. But let's start with
316:26 - get it basic, just because there's a couple
of simple and nice cases that we can go across
316:32 - these these methods.
316:33 - In fact, after receiving an ad, as you remember,
we will reboot and we will try to find the
316:39 - item in the repository. And if we can, if
we cannot find it, if it is no, we will return
316:45 - not found. Otherwise, we will go ahead and
convert the item into a detail. So let's write
316:50 - a couple of unit tests for to verify this
method. So going back to our test class, one
316:57 - thing that I'd like to encourage you is to
use is to use a good naming convention for
317:02 - the unit test. This is very important because
it helps it really helps to identify what
317:06 - is this they're supposed to do what what is
it really verifying, without having to go
317:10 - into the all the details about the unit test?
So one one good naming convention that I like
317:15 - is the following. You want to use three parts
here, that's going to be unit of work. State
317:22 - under test, and expected behavior. Right.
So first part you into the work. So what is
317:31 - that you're testing? What is the function
that is going to be tested by this unit test?
317:35 - That's unit work, then state under test. So
under which conditions? Are you testing these
317:40 - these test methods, right? And then finally,
the expected behavior. And so what do we expect
317:46 - from this from this unit, as we execute these
tests after we execute the action part of
317:52 - these tests. So now translating that into
our guided async method, let me just copy
317:59 - the name here. The unit of work is in fact,
the name of this method. So gate item async.
318:06 - And the first case that I'm going to test
is what happens when we cannot find the item.
318:11 - So the item, the item is full, right this
section here. So in that for that case, I'm
318:16 - going to say with an existing item, so the
item does not exist, what will be the expected
318:24 - behavior, then it's returned returns not found.
Okay, so that should be a good name for arguing
318:33 - this refers to a test. Now, within the body
of the reading test, there's also some other
318:38 - another good convention that encourages to
encourage us to write the test in this way.
318:44 - So there's going to be three sections here.
The first one is called a range. Second one
318:49 - is called tact. And the last one is called
cert. These also a be named as AAA. Arrange,
319:00 - act assert. And the idea is that you're going
to first have an array section where you're
319:04 - going to be much set up everything to be ready
to execute the test. So just before securing
319:10 - the test, so this includes any sorts of marks.
levels and inputs that you're going to need
319:16 - to be able to figure into this. Then we go
to the x section where we actually execute
319:20 - the test, we perform the one action that we
are testing here. And finally, the assert
319:25 - section where we verify whatever needs to
be verified about the execution of of the
319:29 - of the action of the unit. Okay, so how does
that translate into a unit test? So we want
319:35 - to test is controller. And for that, we'll
have to of course, create an instance of item
319:40 - controller. However, remember that we need
two parameters here. So we need to have a
319:44 - positivity and we need a lager. Now, one thing
to remember here is that for the purpose of
319:50 - testing this unit, this get imazing method,
we don't really care about the internals of
319:58 - how the repository for instance, accusatory
behaves, so we don't care what happens. Normally,
320:03 - when you call get it basic, as you know, that
we'll go ahead and talk to the database, retrieve
320:07 - the item and all those things. But we don't
want to test that we don't want to test a
320:11 - repository, we just want to test the get itemizing
method, this is the one unit that we want
320:16 - to test. So you have to make sure that you
find a way to exclude those dependencies and
320:23 - the behavior of the dependencies from these
tests, and just focus on testing what was
320:28 - right here. So to do that, of course, we cannot
use a real a real Idaho story or a real logger.
320:35 - And here's what we have to introduce a what
we call a, what we call a stops. And so I
320:42 - stopped is going to be a kind of a fake instance,
or a fake version of these items of these
320:49 - classes that are going to be used just for
the purposes of the test. So let me show you
320:54 - how that how that looks like. For this case,
I'm going to say so we need a depository,
321:00 - right. So let's I'll say depository,
321:05 - stop equals new mock. And then mark is a con
for the from the mock library that we installed
321:13 - a moment ago, using mock. So this is a library
that allows us to mock any of the mock or
321:20 - stop any of the different dependencies of
our class. So locally, our controller, as
321:26 - we looked at the previous videos, we made
it in such a way that we can do dependency
321:29 - injection in there. So the controller really
doesn't know what kind of repository is coming
321:35 - in here, or the kind of logger comes here,
you just look, it's just looking at interfaces,
321:38 - as you can see. So that gives us the flexibility
to fake these both dependencies from or from
321:44 - the unit test. So I'll go ahead and say okay,
so this is going to be a new mock of items
321:49 - repository. Okay, let's see, if I'm using
a meeting any space. Notice that I'm naming
322:01 - this as a stop and not as a mock. And that's
a slight difference that I like to make, because
322:05 - when you do stops, you will not verify anything
on the on the on this object itself. When
322:11 - you do mocks, you will in the assert section,
you would go ahead and actually verify something
322:17 - that happened to the mock accuracy test. So
it's a slight difference, but it is good to
322:21 - it's good to to do the proper naming here
so that you understand what is the purpose
322:27 - of the variable that you're using. Okay, so
now the expectation is that when we call this
322:33 - call to controller, when we're going back
to our method, when we call the get imazing
322:38 - method, the idea is that it will return a
no. So when returns No, we should return the
322:43 - controller should return not found. So we
need to set up that isn't it? So how do we
322:47 - set up this method in the mock so that it
returns No. Going back here, what you can
322:52 - do is this repository, stop that setup. And
then you're going to say, let's say repo,
323:00 - repo that gate item async. And then comes
the parameter. Now, at this point, it really
323:08 - doesn't matter what's what's the item that
we are going to be passing in here. It's irrelevant,
323:13 - because what we want to do it revelate is
what happens with the return value. So because
323:19 - of that, what you can do is just say it is
a which is a function provided by Mark also
323:27 - any COVID This means whichever value comes
in, it doesn't matter. So Mark will take care
323:32 - of providing some value there. And then that
will do it should return a value of No, that's
323:40 - what we want. That's the expected behavior.
And then, but just so that marketers doesn't
323:45 - get confused, we have to cast this into the
item entity. And let me add Robert namespace
323:53 - right there. Okay, so this is setting up the
scenario for artists. So we're saying again,
323:58 - we're saying when whenever the controller
invokes get good at basic with any any code,
324:04 - which mark is going to provide, you have to
return a null value. That's what we need for
324:09 - this use case. And then similarly, we'll do
something With the logger, so we'll say logger
324:17 - stop equals new mark. I'll say, Hi logger,
or items. I just control. Okay, let's see
324:32 - if we're missing something again. Yep. See
dad remains in the construction space. Okay,
324:39 - so now we have two stops ready to go. And
now we need to create the actual controller.
324:44 - So now we can say, controller equals new items
controller. And then we passed it, this docks.
324:52 - So if I posit Ori, stuff, what we need to
get actually the object property of these
324:57 - because that's the real object that's going
to be passing out just a mock the mock object,
325:02 - and then logger stop that object. So that
covers the arrange phase of this unit test
325:11 - for the act phase. Here's where we execute
the action. And this is normally just one
325:16 - line where you execute what you're going to
be testing. So I'll just say, sold, equals
325:22 - await. And yeah, now that I'm using a Wait,
let me remember that we have to use a proper
325:30 - return type for these unit tests, since we're
going to be calling an async function. These
325:34 - days, it should actually switch to be an async.
task. C. So now we can do a weight controller,
325:45 - that good idea may sync. And then, like I
said, it doesn't matter what what good we
325:52 - provide here. So you'll say, cool, great.
325:57 - And that's the action. And then finally, we'll
go ahead and do the assert. So we next unit,
326:03 - you have a bunch of assert methods available.
So let's just use assert. And then what we
326:11 - want to verify here is that what we got was
indeed are not found, and they're not found,
326:15 - there's a class that is not found. So what
we can say is assert that is type not found.
326:24 - result. And then let's see if we're missing
something. Yeah, add that. And then we're
326:31 - going to pass here is result that result.
So the result object, the result variable
326:40 - represents the actual result that we received.
And the result property inside that result
326:46 - represent the actual type of result that we
got, which in our case, it should be not found
326:52 - result. And now that we have that, we can
go ahead and actually execute the test. And
326:57 - so there's a bunch of ways to actually run
this test. In VS code. One of the ways that
327:02 - I use frequently is a via via using the kotlin.
So as you can see, over here, there's these
327:07 - these set of annotations, which is, which
is introduced by kotlin is to code kotlin.
327:14 - And you have to Will you have to do is click
on Run test. And that should go ahead and
327:18 - run the test. Let's see what happens to running
test. And that this has passed, as you can
327:25 - see, the one that we have passed, which is
good. Now, there's another way to run the
327:32 - tests by using directly the dotnet. CLI. So
if you go to terminal, I'll switch to here,
327:40 - make sure that you are in the catalog unit
test directory. And here, what you can do
327:44 - is just do dotnet test. Yeah, so that will
go ahead and run not just not just one test,
327:52 - but all the tests that you have across the
desk like so difficult, more handy when you
327:56 - have you just are having more and more tests
for this test project. And as you can see,
328:00 - it passed zero failed, one passed. Now, as
the number of tests increases, you may want
328:08 - to have a better way to visualize the overall
status of your test suite, which is cases
328:13 - are passing which words are failing, and so
on. So So to do that, there's actually a nice
328:18 - Visual Studio Code extension that you can
install to provide the dissertation. So let's
328:23 - go to our extensions hub. And let's expand
this a bit. And let's look for dotnet core,
328:32 - this Explorer, just the first one here, I'll
collapse this for a moment that will cortex
328:41 - explorer by June Han is the best one that
I found so far for these kinds of tests. So
328:45 - go ahead and install it. And what you need
to do about this extension is to tell it where
328:51 - to find the the test project. And if we go
to Explorer for a moment, you'll remember
328:56 - that we have artists in this category test
folder, gather the unit test OCS proc, so
329:00 - we need to provide that location to this extension.
To do that, you can click this gear icon over
329:05 - here. Just click on that extension settings.
And if any chance these settings that you
329:10 - see over here are not showing up for you where
you can Try is just closing close to the code
329:15 - or closing the current folder and reopening
it. And then these things should show up,
329:20 - it may happen the very, very first time, but
after that, it should be just fine. Then what
329:24 - you want to do is go all the way down where
it says Internet Explorer display bad. These
329:31 - are windows specify the path of this project.
But also, do you want to go not into the into
329:37 - the user section, but into the work workspace
section. By doing that you are going to what
329:43 - you're going to type in here is going to live
alongside your project, as opposed to so in
329:48 - some place in the in your user profile. So
that's good, so that you can keep everything,
329:53 - everything together. So here, what we want
to specify is just a simple expression. So
329:57 - let me type that is a glob pattern where we're
going to say just search all over the place
330:02 - inside of our catalog directory, and in all
directories, and then look for tests that
330:10 - CS Brock, okay. And after doing that, we can
close this. And if we go to these three dots
330:16 - here, there's now a test section. And as you
can see, there's our one test is already showing
330:23 - up over there. And then to run it, you can
either click display icon here, or you can
330:28 - just click the play icon on the top, and it
will go ahead and run all the tests that are
330:32 - available there.
330:35 - So aspect that is green. And you can see the
green bar also in on top of the test. And
330:41 - if there was any error that you will get some
red squiggles in the location where we will
330:45 - test failed. So yeah, so we're using this
extension across this video to to see the
330:50 - status of our tests as we are adding them
and executing them. Okay, so now that we have
330:56 - that in place, and we have a test for checking
for the existing item case, let's add another
331:02 - test for the existing items. So what happens
when the item actually exists. So let me actually
331:08 - collapse this for a moment. So I'll do hide
sidebar. And let's add a second test here.
331:14 - Perhaps I'll just copy the header of this
test. So I'll copy that over here. Here's
331:23 - a new this method. And this one is going to
be called get item async. Wait, existing item.
331:33 - returns. expected it. Okay, now, just like
before, we will do the AAA. Arrange, act.
331:46 - And assert now for these tests is very likely
that we're going to need a again, our our
331:55 - capacity and our logger stop boat stops. So
instead of copying, then copy the instantiation
332:01 - over here, why not just declare a class level
a couple of class level fields. And that way
332:06 - we can reuse them in this test and in any
future test. So let me do that. So I'll go
332:12 - here. So I'll declare by bait read only to
be marked off items repository, then I'll
332:24 - just copy this base here, although I could
just do this. And then private with only mark
332:36 - of a logger, or items controller. And then
it will be the loggers stuff we can use to
332:50 - this. And with that, we can go to our initial
test case, and to simplify a little bit by
332:57 - not having to declare it here, because we
stop there or they stop here. Okay, so going
333:03 - back to the new test case, for this test case,
we will actually need to have an item that
333:11 - we can use across the desk. Because let's
go back to the controller quickly, I this
333:15 - controller IDs. And if remember, get item
async. In the case that we want to hit, which
333:23 - is the one that returns the DTO we need to
have an item, we need to have the repository,
333:29 - get the return an item. And then we need to
convert it to and return it. So to do that,
333:35 - we'll have to set up that item beforehand
in our test so that it can be used it over
333:41 - here. So I'll go back to the test. And instead
of just creating it on the fly for this test
333:46 - case, I think that we should have some sort
of helper function that we can use not just
333:51 - in this case, but instead of user tests to
create some random item very quickly. So I'm
333:57 - going to go ahead and create a private function
to private identify to return an item. Let's
334:02 - call it create an item 
and this is going to say just return new And
334:16 - let's specify all the properties for the new
item. So it will be ID, this make it good
334:21 - that you go in, because we don't really care
what Id it uses the same way we don't really
334:26 - care what name these random item uses, should
work with any any name. So new gu ID, to string,
334:33 - them for the price we want to do is probably
just generate some random number so that we
334:39 - don't get fixed into any specific price. So
for whatever, what I'll do is I'll actually
334:45 - create a random a variable, and let's put
it at the top over here. So I'm going to declare
334:52 - a private read only. Random and let's name
it yours around, it's going to be new. So
335:02 - this will be with us in a couple of places.
So now we can go back here. And we can say
335:09 - ran that next. And then I think we said that
the price should be between one and 1000.
335:14 - And so let's just say a maximum value of 1000.
should be enough. And Rarity is going to be
335:22 - the time of said that UTC. Okay,
335:29 - so now that we have this handy method, let's
go back to our test case, over here. And in
335:35 - terms of arrangement, what we have to do is
first prepare the item that we're going to
335:38 - deposit or is going to return. So we're going
to say bar spec, this item is create random
335:48 - item, then we have to do the setup for the
repository. And that's going to be a little
335:56 - bit similar to what we did the previous test.
So I'm going to copy this, this first line
335:59 - from the previous test there. So when we call
get item async, again, with any good on what
336:08 - to do now is return that item. So returns
async. Expected item. Okay, and then we'll
336:15 - go ahead and do pretty much the same thing
that we did in the previous day. So copy this,
336:19 - these couple of lines over here. So we declared
a controller with the two stops, and then
336:28 - we get a result, right by invoking get item
async with any GUI doesn't matter. And then
336:34 - it is time to assert a what we got. So what
would we like to assert here, so probably
336:39 - want to first make sure that we got the activity
or not some other a result, like not found
336:44 - or bad requests or something like that. So
I'll do a search that is type identity Oh.
336:54 - And let's add in a museum a space. And then
we're looking at result dot value because
337:01 - it is the value property, the one that actually
should have the deal in this case. Okay. And
337:07 - when we have asserted that well we can also
do is, what we should do is verify that all
337:11 - the properties of the return to match the
expected item. So for that, let's first take
337:18 - out that DTO. So we can do that by doing some
casting here. We sold as action result of
337:26 - identity to that value. Okay, we can do a
ser equal expected item that Id should equals
337:42 - do that ID. And just like that, we will need
to go through every single property right,
337:48 - so x with the ID now expected item. That name
should equal the to that name. And, and well,
337:57 - we'll keep going and going with the other
properties. But at this point, imagine that
338:03 - you don't have just a couple of properties,
but you have dozens of properties, right as
338:07 - objects can can get complex. So today is going
to be become very cumbersome to just keep
338:12 - searching and searching and searching. And
in fact, it's not a very good practice to
338:15 - be asserting too many things. In this case,
you should try to assert or get closer, just
338:20 - one thing in each test, that's kind of the
best practice. And so to do that, what we
338:27 - can do is instead of doing all this, we can
switch to a very handy assertion library that's
338:32 - called fluent assertions. And davon will allow
us to do this in a much more straightforward
338:37 - way. So let's bring in the terminal as well.
Ctrl J and l go to PowerShell and hoovering
338:46 - we do so make sure that you are in the catalog
that unit tests directory, and that you can
338:51 - do dotnet add package. fluent assertions.
Okay, so with that, I'll just close terminal.
339:03 - So now we can do something a little bit different.
So let me show you. What we can do is now
339:08 - we can say we sold that value And then should,
then it's important if your assertions namespace
339:22 - be equivalent to the expected item. Okay,
and then I'll remove this. What this is expected
339:33 - to do is that it should compare the values
of the properties of the resulting DTO. With
339:39 - the properties of the expected item, the item
that we created over here, right? So that
339:47 - way with this very handy method, we don't
have to go property by property, it will just
339:50 - go ahead and compare the entire thing for
us. But that the only issue here is that seeing
339:56 - suspected it is actually a record type. As
you remember, the item is a record type record
340:02 - types already. Alright, the equals method
of the of the object, and that will make it
340:09 - so that this method doesn't behave very well,
right, because he believes that you have to
340:13 - compare the DTO to the entity directly, as
opposed to comparing the properties, which
340:17 - is what we care about. So to address this,
we'll specify an additional option here.
340:23 - Which is going to be Options, Options dot
comparing by members of the item of the item
340:34 - class. Without we're saying, Hey, don't compare
the DTR directly to the to the item, just
340:43 - focus on the properties that each of them
hum and as each of them have. And as long
340:47 - as the property is the same name, compare
the values of those properties. So that way,
340:51 - you will go ahead and and issue go ahead and
tell us that the objects are the same. Yep.
340:57 - And so with that, let's go ahead and run this
test case and see what we get. So we'll go
341:01 - ahead and click Run test. Yep. And this case
is passing. And just like we did this, just
341:12 - to keep things consistent, let's also modify
the previous test to also use fluent assertions.
341:16 - So in this case, is going to be result that
result should be off date. Not Found result.
341:28 - that replaces the previous line. Okay, so
let's just verify that all these cases are
341:38 - passing, I'll go ahead and run these in Data
Explorer here. And yes, it's all looking good.
341:45 - Good. And so now let's move ahead into our
next unit test. Let's go back to the controller
341:52 - briefly. And let's see what else we got there.
Perhaps this and back in the controller, and
341:59 - what we want to test now is our first metal
here, the one that returns all the items available
342:05 - in the REST API in the repository. So remember,
these items will just go ahead, retrieve all
342:11 - the items, transfer them into DTO. And then
he returns and that's all he does. So what
342:17 - we want to verify is that for any of the items
that we that we set up for the suppository
342:22 - that we have to set up the depository, they
have to be returned as details, and they should
342:26 - match exactly the IDs that will obtain through
depository. So let's go ahead and write a
342:31 - unit test for that. So back into the test
class. Again, I'm going to copy the heater
342:36 - of these this case. And I'm going to scroll
down here, Copy that. Okay, so here, let's
342:48 - do the proper naming. So these are going to
be named get I get items a think are these
342:54 - going to be just with exceed with existing
items. He will say, returns or items. And
343:03 - again, let's bring in our arrange, act and
assert sections. And in this case, what we
343:17 - need is of course to get a series of items
from the repository. So what we have to do
343:23 - first is to declare such a set of items are
we will for that we'll create a simple array.
343:29 - So what I'll do is I'll say bar expected items
equals new and this is going to be an array.
343:38 - And we're going to be using our create random
item method here a few times perhaps less
343:44 - bringing in three items. Yep, so that will
do it. Very handy method. And now we can go
343:53 - ahead and set up the repository to return
those items. So I'll do repository stop, set
343:58 - up where the repo where they bought the gun
get it and say saying so get one gig Titan
344:06 - 16 is invoked, which should return the expected
items. Then we have to construct the controller.
344:17 - So I'll do it very similar to what we did
with the previous this case, I'll just go
344:21 - ahead and copy this line over here. And then
we will go ahead and do. So bar, act two items,
344:39 - equals a weight, controller, get items async.
Thanks, that should retrieve the items. And
344:48 - now we have to do the comparison. So once
again, we can use that very handy method of
344:52 - fluent assertions to do just an equivalence
of comparison. So we can say, items should
345:01 - be equivalent to expected items. And once
again, we'll have to do the options. Because
345:11 - we like, again, we're dealing with record
types. So otherwise things will not work,
345:17 - right. And then options that comparing by
members, I. Okay, so with that, let's go ahead
345:32 - and run this test. Let's see what we get.
345:36 - Yep, this passing. Awesome, close that. Okay,
let's move forward back to ISIS controller,
345:44 - it's time to test our great item async method.
So this is the one that goes ahead and creates
345:49 - the item in the repository. So in this case,
we have to provide great identity as an input.
345:56 - And then we can verify is that we should be
returning, we should be receiving as a return
346:01 - added to with a graded item. That's, that's
what these metals is supposed to do. And in
346:07 - fact, that return an item should include the
ID because it is not provided in there, create
346:11 - that and do so return items will have an ID
and he will also have a graded date. So let's
346:16 - write out a test that can verify all these
things. So back to items, control tests, they
346:20 - may gain grab the heater off the desk, perhaps
so I grabbed the entire thing. Just copy this,
346:29 - and then remove the space and and remove this
piece and I removed the solid piece. Okay,
346:41 - now this method will be called just start
with the name of the method, which is create
346:47 - item async. And then this will be in this
case, the current state, let's name it with
346:54 - item to create, because we're going to be
providing the idea that should be created.
347:00 - And the dissertation is that it returns the
Create a title. Right? Now in this case, the
347:10 - arrange piece involves preparing the accurate
identity. So in this case, it's going to be
347:14 - it will be tricky to try to use a created
random item, as we've been doing so far. So
347:19 - we'll be we'll be explicit in this case. So
we will say I tend to create equals new create
347:29 - item DTO. And here we'll provide the elements
of the query in detail. So we do provide a
347:37 - name, which is just going to be cool nucleoid
string, we will provide a price, which again
347:48 - is going to be just random next, with 1000
again, and I think that that will be. So let
347:56 - me go quickly to create a new table with 12
to make sure I've covered the properties we
348:02 - need. So he has a name and the price. Yep,
back here. And then in this case, I will actually
348:07 - not need to set up anything in the repository.
Because it is not interesting. What happens
348:14 - I mean, for the terms of of this test case,
it is not interested to see what happens when
348:18 - the repository is invoked, if there was a
really simple act to create the item. So if
348:24 - you look back at I just controller, what's
really going to happen here is that Jehovah
348:28 - God needs to call greet, I are amazing. And
I will go ahead and gradiated. But I will
348:33 - encourage you to be a bit careful about what
you're going to be testing here. Because you
348:38 - could also decide that no, I want to make
sure that they created amazing metal is called
348:43 - in the repository. Right. So that so that
yeah, I mean, it should get created. But that's
348:48 - going a little bit too much into the details
of the test case. So you are getting you will
348:54 - be making your test case to be very prone
to needs changes in the case of the implementation
348:59 - of this method changes, right. So ideally,
you want to treat each of your test cases
349:04 - in such a way that they only provide some
inputs to the method. And then eventually
349:09 - they validate the outputs of the method but
they don't try to make Some just sort of what
349:14 - is going to happen inside. So in this case,
we are not going to be carrying all this metal
349:19 - at all. So in fact, we're not going to be
setting it up, we will go ahead and go back
349:23 - to this case, we'll go ahead and use invoke,
invoke the action. So we will say, var greeted
349:32 - item. Sorry, it's going to be bar result equals
weight, controller dot, create item aceing.
349:44 - We provide the item to create. And then we
can go ahead and do the assert. And the first
349:53 - thing we're going to do here is try to retrieve
that identity. So what I'll do is, I'll do
349:58 - we did item is the result that result as created
an action result. Okay, that's the type of
350:11 - result we're going to receive here is a created
action result. From that one, we want to get
350:16 - the value. And that value will turn it into
an item we do a little bit convoluted for
350:22 - for this case. And now we can do the same
equivalence thing that we've been doing so
350:27 - far. So I tend to create
350:31 - should be equivalent to created by, okay,
and then we provide options. Like we said,
350:42 - there will be options that comparing by members.
And in this case, the data we're going to
350:47 - use here is actually I can be deal.
350:50 - Okay, which is the, the type of the object
that we received from the front desk
351:02 - of the creditor. Okay. But additionally, we
want to do one more thing here, because a,
351:06 - both of these a DTS don't have the same members,
if you remember, if we go to F 12, to identity,
351:12 - Oh, this one has four properties, as you can
see. But if we go into great identity, or
351:20 - this one has only two properties over here.
So that means that if you try to compare things
351:26 - like this is going to fail, because you're
going to say, Hey, what are you writing has
351:29 - more properties than the other. So this, this
doesn't make sense. So in these cases, what
351:33 - you can do is say, only look at the properties
that are common between the two objects. And
351:39 - that will simplify things in this case. So
that's all we can do. And then in the spirit
351:45 - of fluent assertions, we can use to dot excluding
missing members. And that should do it for
351:54 - that for that one assertion. Okay, so we're
comparing that the two objects are equivalent,
351:58 - but we will not pay attention to any members
that are missing from for any other. However,
352:04 - we may want to actually check for those additional
members. So for those who will be will be
352:08 - a bit more explicit. So So credit item, the
ID should not be empty. Because the the method,
352:16 - it should generate an ID for for the scooter
rider, and also create an item that create
352:22 - a date.
352:24 - Should
352:27 - we don't know exactly what, what day we're
going to get in there. But we know that it
352:30 - should be, it should be close to the current
time, right? Because this test just take milliseconds
352:35 - to execute. So we will say datetimeoffset
UTC now. And then, just to be safe, we're
352:45 - going to give it a range of precision, because
we don't know exactly how much time did basically
352:49 - today, although it should be super fast. But
we're going to give it 1000 milliseconds to
352:55 - for for the difference between the times of
when the item is created and the data we're
352:59 - checking here. Okay, so that should be should
be it for this test. Let's go ahead and run
353:04 - it from the test. see what we get. Test is
passing. It's looking good. Okay, so the next
353:14 - test we're going to look at, but less case
we're going to look at is the case of the
353:18 - update, update item async. Does remember this
method, it gets at the item to update, it
353:25 - will get it from the database. And if it doesn't
find it, it will say not found. And otherwise,
353:31 - it will create a copy of the item to become
the updated item with the updated properties.
353:36 - And then it will go ahead and update the item
in the database and finally returns no content.
353:41 - Okay, just to be to not spend too much time
here, we're only going to be covering one
353:46 - case here, which is the case of where the
item actually exists. But you can you can
353:51 - imagine how to test for the not found case,
which is a bit simpler. But then again, don't
353:57 - don't get into the trap of verifying that
the item is actually being sent to the date
354:02 - itemizing method of a depository. We want
to we will provide an input which is these
354:07 - two parameters here. We expect the output
of no content of added that's everything that
354:12 - we need to verify here. Nothing else, we don't
need to worry about the implementation of
354:17 - the method. So let's go back to I just got
a test. And let's bring in again, just I'll
354:23 - do a copy of our last test over here. And
so, this is going to be update, I think we
354:39 - take existing item returns no content, okay.
And then we will meet these who need a controller
354:50 - will need that, we will remove this species
at the end. So for the range base, as you
354:58 - remember from this controller, we will need
a when good imec, Usain Bolt, you need to
355:04 - return it right so that we can move forward
into this case. So, I think that that situation
355:09 - we covered already somewhere else. So, let
me go back a little bit up. So this one here,
355:17 - so, we will grab these from the get item async.
This case, let me grab that here. So, that
355:23 - would allow us to have an item to be returned
by the by the depositor is done. So we will
355:30 - name these one, please thing item ID, that's
the ID that exists in there. And now we need
355:39 - to declare the the actual item that we're
going to provide to the methods. So they updated
355:44 - it. So let's first grab the item ID as a variable.
So the item ID is system ID that ID. So we'll
355:54 - grab that there. And then I tend to update
355:58 - these a new update ID to 
and so we're going to provide a name naming
356:10 - scheme to be cool if you go it to string.
And perhaps
356:19 - we download line. And then for the price we
can do is just pick the price of the existing
356:29 - item price and just increase it a by somebody,
let's say by three. Okay, so that becomes
356:38 - the updated paper from this item. So we pretty
much were changing the name because we're
356:43 - getting really unusual, we're changing the
price by adding three to it. Then we create
356:48 - the controller. And I started to do the the
action. So we'll say result equals await controller
356:59 - that update async. And then here's where we
provide the item ID. And then we provide the
357:06 - item to update. And then finally we go for
the assertion, the assertion is going to be
357:12 - very simple, because like I said, we only
want to verify that we we get no content.
357:18 - So result should be of type. No content result.
That's all it is. So again, we set up the
357:32 - return of the item from the repository, we
prepare nine out of date, we modify the properties,
357:37 - we invoke a bit of the async. And at the end,
if everything went well, we should be getting
357:42 - the content result. So let's go ahead and
run this test. All best, I think we're missing
357:52 - just one method at this point. Let's go to
IRS controller. So this is delete I basic,
357:58 - right? It's got to be very simple. To verify
and very similar to update, we get an ID,
358:06 - it will have to a Find the Item. Again, we're
not going to check all the cases, for this
358:10 - case, just a case where the item exists. So
we'll make it so that it returns the item.
358:15 - And then it should return no content. And
again, we don't care what happens with the
358:19 - repository or any of the internals here, we
just care about the fact that it should return
358:23 - the content. So back to I just adore tests.
I'm going to copy your lastest case, once
358:33 - again.
358:35 - This is going to be named delete it may sync
with existing item returns no content. Yep,
358:45 - that's an appropriate name. The setup will
work just fine for this case. But then we
358:52 - don't have to prepare any item to update us
do that. Create the controller with those
358:58 - setups. And then we'll do the database sync
with the it will be just the existing ID and
359:08 - that ID and then the assert is exactly same
as before. There's should be of type knock
359:14 - on result. That's all it is. So I'll go ahead
and run this test now.
359:22 - And Yep, it is passing. And in fact, if we
go to our test Explorer, now, let's go to
359:28 - the test section here. And let's run this.
As you can see, we have a full suite of tests
359:37 - passing at this point. Okay, so this is great,
we have a bunch of test cases covering many,
359:44 - there's nothing in our controller. And what
this gives us now is actually a lot of confidence
359:51 - or making any future changes across the, across
the REST API. So what I'd like to do now is,
359:58 - there's there's been a few changes that I
wanted to make across the board. But I didn't,
360:03 - I didn't have a way to make sure that didn't
break anything. But now we do. So I'm going
360:07 - to make two critical changes here. One of
them is that I'm going to switch our entity
360:12 - to not be a record type anymore. So remember,
he's here if you go to the entities item.
360:19 - So the fact that he's a record type is actually
making things a bit inflexible, I mean text.
360:23 - Because of this, we cannot use update existing
items in the update a operation in the controller,
360:29 - and we have to create this copy that's not
really needed. So these entities should be
360:33 - actively moldable. So we don't need these
any stuff here, really. So we'll switch this
360:38 - to be a normal class. And we will also add
a description property here, so we can provide
360:43 - some description for the items. So let's make
those two changes. And let's see if our test
360:47 - cases can help us prevent breaking anything.
So like I said, This item is going to change
360:52 - from record to class. And then we will not
be using it here. But we will switch it to
360:59 - just set. So set in all of this. And now this
is a normal standard class. But also, like
361:06 - I said, we're going to be adding a description,
description for the entity. So with that done.
361:15 - The other thing that I like to do, actually,
is to simplify the way that we use videos.
361:21 - Remember that we have these three files for
the three videos. But it turns out that there's
361:26 - a much better nicer way to declare the video
such as record types, which actually provides
361:31 - even more benefits that we are doing today.
So what I'll do is I'll actually just get
361:35 - rid of all these files. Let me just delete
the CTOs folder. Perhaps collapse these a
361:42 - bit, what I'm going to do is create a new
file at the root of catalog API. Let's name
361:48 - it. videos at CS. Let's bring in some namespace,
right namespace, which would be catalog that
361:59 - KPI details, we will declare all the details
here in line in a much more a nicer way. Let
362:06 - me hide the sidebar. So for the first video
is going to be the item detail. So we will
362:11 - say what do you record it to, then we will
declare the properties as if we were creating
362:18 - like a constructor for for this property.
That's something that you can do that we will
362:22 - say good ID. And then let's see if we're missing
this system. And they will do name the new
362:32 - description property price, and they time
offset created date. Okay, so that's you know,
362:47 - that's that's what you need to do to create
to declare a record type in this other syntax.
362:51 - So as you can see, is much, much more simplified.
Now, let's declare the next one is going to
362:58 - be only record, create item DTO. And then
this is going to have no ID but the name and
363:09 - then the new description, property. And then
the price. Let's not forget that we had set
363:18 - up some attributes here to make to make sure
that we get valid inputs. So in the case of
363:22 - names, we want it to be required. It's amazing
the space and in the case of price, what we
363:31 - want is 25 range. So the range Yeah, it was
from one to 1000 Okay, we will not require
363:42 - description, and we will not require we will
not add the required attributes to price because
363:47 - price is actually validate. So it cannot ever
be no, you will get somebody there anyways.
363:52 - And we will just verify that the range is
correct. Lastly, let's add our last detail
363:58 - that we're missing. I just copy that one.
And this is going to be updated in detail.
364:05 - Yep. So that's all we need. So now in one
file we have we're declaring all the details
364:10 - that we're using across the REST API as opposed
to three files. Let's see what else we need
364:15 - to modify. So now that we make those changes,
let's look at extensions. Let's see what's
364:20 - going on here.
364:21 - Yeah, so I'll hide cyber. So now that we change
the way that we declared our details as record
364:29 - types, they have become immutable. We cannot
go through this initialization anymore. We
364:34 - must create the DTO via the constructor. It's
the only way to create instances of them from
364:38 - here on. And after construction, nobody can
change the properties of the DTO. So we will
364:44 - say new identity Oh, and then we will provide
it that ID. Id and the pain. Right? And that
364:52 - scription. I think that price, an item that
created date, right? That's always Yep, we
365:06 - got liquid in line these over here, but it
may be too much to read. So we'll just leave
365:12 - it like this. Okay, let's see what else we
have to fix. If we go back, so there's something
365:19 - going on in the controller? Let's see what
it is. Yep. So there's an issue with update
365:26 - imazing? Yep. So we cannot use this syntax
anymore. Because the item is no longer a record
365:33 - type. Now it is a standard class. And in fact,
this is this is good. This is actually exactly
365:37 - what we wanted to fix here. Because there's
no need to create this updated item, we could
365:41 - just modify the existing item. So we will
say, existing item that name equals item D
365:50 - do that name, an existing item, the price
equals identity or that the price. Yep. So
366:00 - we don't need these additional guy here. We'll
leave it like that. And then for the update,
366:07 - we'll use invoke existing IRA. Okay, so yeah,
there's no more breaks around here. Let's
366:17 - see what else. So because of API, everything
looks good in the unit tests. Let's see what's
366:22 - going on. Okay, let's hide the sidebar. Let's
see. Yep. So great identity Oh, has to be
366:29 - weighted to define the properties inside the
constructor. So we'll have to provide these
366:38 - for the name. And they probably will do the
same thing for the description. And for the
366:44 - price, the random number, perhaps, so I'll
delete this. And then I'll do it like this.
366:54 - That is it is easier to see. There. Okay.
So let's see what else we have to fix here.
367:03 - Just in case for update identity. Oh. So let
me copy this line here. So we have to provide
367:12 - that then we provide a description. And then
we provide the price, which is going to be
367:17 - existing item price plus three. Okay, remove
this. Yep. And with that, I think we don't
367:26 - have any more breaks are not in there. I can
see actually. And so let's go ahead. And now
367:32 - let's run our tests and see what we get. So
go ahead and run the tests. Yep. And, interestingly,
367:44 - we do have something failing here. Let's see
what's going on. So great. It may sync is
367:49 - the one that's failing. And as you can see,
we are getting the x over here, signaling
367:55 - that there's a problem. We get the squiggles
here, signaling that there's something in
367:59 - there. And if this if we see the message over
there, you can see it says expected member
368:05 - description to be no, but found some value
in there. Yep. And then, so what could have
368:12 - happened? So let's actually go back to our
controller. So I'll do f 12, from the controller.
368:20 - And let's go to the Create method. Over here.
Let's hide this hide sidebar. And, yeah, so
368:28 - what happens here is if you can spot that
is that we have not a percentage value for
368:34 - the description. So let me actually close
this close these. So back to the test. Yep.
368:43 - So when we declared the item to create, we
did add a description. But when we created
368:49 - the degraded item, it does not have any value
for description. That is because we have not
368:53 - specified that here anywhere. So that's something
we have to fix. And that's, that's a nice
368:58 - thing about using these should be equivalent
to because as you add more properties, and
369:04 - you don't have to be remembering to do the
proper checks in the test cases, right. Otherwise,
369:09 - anytime you you add a new property here, you
have to go back to the test and other properties
369:12 - in there to make sure that you don't Forget
what it is that this case is actually covering
369:16 - you, making sure that you don't forget to
add those properties in the place where you're
369:20 - implementing the Edit method. For this case,
369:23 - I'll do description equals identity to that
description. With that, let's go back to our
369:33 - test list, lets us run them again. It's all
green now. And then one minor improvement
369:43 - that you can also do here is to change the
way that we're doing some comparisons across
369:47 - a few test cases. So we go back to two lists
test case, erasing, we created a retrospective
369:56 - item. If you see how we're doing B, A k be
equivalent to here, these options, we need
370:01 - to do them because the item A during class
A we're able to actually record before, so
370:06 - that was causing issues. Now that it's not
a record type, we can stick to the normal
370:11 - behavior. So now we can just remove this and
do the equivalent to this way. And fearless
370:17 - agents will know what to do. Because this
is just a standard plus the same way we can
370:22 - go to the next case, and change this think.
And that should be enough. And this is only
370:30 - because like I said, because what we're comparing
here is the other classes are not record record
370:35 - type, you still have to do the other way.
So let's just make sure that the test cases
370:40 - are still passing. So I'll go ahead and run
all the tests. And everything is still all
370:49 - green. Okay, so that's working pretty well.
And now I wanted to I'd like to switch gears
370:55 - into test driven development TDD. So we talked
about TDD, it has some very nice benefits,
371:01 - because it allows you to start for the test
for the requirements really, and then move
371:07 - forward to implementation later on. So let's,
let's see, how do they work. In practice,
371:13 - what we're going to do is if we go back to
items controller, and I'll hide these for
371:19 - a moment again, let's go back to our first
method here, get items async. So as you see,
371:26 - this is the method that returns all the items.
But a new requirement to our REST API is that
371:32 - we should be able to return a the items by
a by the name. So if somebody specifies a
371:38 - name into into such a method, which should
be able to return only the items where the
371:43 - name contains the specified parameter, right.
So So if the if the, if you have items that
371:52 - have for instance, a word potion in them,
like a potion, potion, potion, all these all
371:57 - these things, which are going to return all
the items that include potion in the name,
372:00 - and not to the right, so it's a way of filtering
things. But let's see how we can go ahead
372:05 - and implement such a method by using DDD.
So I'll go back to I just controlled tests.
372:12 - So let's grab this, grab this method, get
it and pick it as a sink. And then I'll just
372:18 - copy that just under it because there's similar
methods. But in this case, we rename it to
372:27 - get either a sink, we will say, with matching
items, returns,
372:35 - returns
372:36 - matching items. Okay, so in this case, we're
going to go ahead, and we will not be using
372:46 - the random item anymore, because I actually
want to specify a name for our items. And
372:51 - in fact, that's the only thing that we cared
about, in the case of this test case. What
372:55 - do we want explicit here. So what I want to
do is rearrange this a little bit, so that
373:00 - instead of these, what we have is, let's name
these, all items are all items equals new.
373:07 - And then I'll just move these to the next
line is going to be a bit more verbose. Like
373:17 - this perhaps. And then, in each of these lines,
instead of these, we're going to create new
373:24 - items, new items, so we will say new item.
And he will will provide a name. So let's
373:31 - use something that we can use for these tests.
Like I said, Let's go for the potion. potion
373:35 - case. So we will have a potion there. And
then let's add two more. The second one is
373:49 - going to be named Let's name it something
completely different, like how to do it. And
373:54 - then the last one is going to be highbush.
So in this case, we have two items that have
374:00 - the same, the same term portion and another
one that doesn't have it. And then we'll declare
374:06 - a variable here that we're going to say its
name, name to match equals Now notice that
374:17 - we are already implemented this case for this
new method, but the method just does not exist
374:21 - at all, he has not been implemented. And that's
the right way of doing DDD. So we will start
374:26 - with a test case that will actually fail because
we don't have the method, and then we will
374:30 - move forward implementation later. Okay, so
now we're depositary inbox, get items async,
374:37 - we will return all the items that we have
prepared in here.
374:41 - Remember, this is the call to the opposite,
it is not the call to the controller get is
374:45 - async. So then we go ahead and prepare our
controller and then a constant time to make
374:53 - the call to the act.
374:55 - Now here, we're going to be a bit more explicit.
The first it will now go to us in bar on the
374:59 - left side, because we want to signal to the
to C sharp and VS code, what we're going to
375:06 - receive from this new method or method to
be created. So in this case, what we're going
375:09 - to receive is an ienumerable. of item DTO.
Are these going to be found items? And are
375:19 - we missing something? Yeah, system collection
generic was amazing. And then these are going
375:26 - to come by calling weight controller, get
items async. But not the signature, we need
375:35 - a new signature, where we can actually pipe
them async we need a new signature, we can
375:42 - receive the name to match. So we're going
to pass name to match here. Okay. And yeah,
375:51 - so yeah, that's got to be great. And then
as, as our assert, what we have to verify
375:58 - is that we only got items that were their
name, match the name to batch in this case
376:03 - potion. So to verify that we will say phone
items should only contain. And then we can
376:14 - say item where item that name should be equals
to item, it will be items soup, sorry, so
376:24 - this is all items, sub zero dot name, because
that's the first one, let's scroll up a little
376:35 - bit. So we got zero, and we got one and two.
So it should be that one. Or, and then just
376:46 - copy this should be I think name should be
equals to a lightened suit to that name. Okay,
376:54 - so that's a way that you can use fluent assertions
to verify that the items in the collection
376:58 - match some condition. So whatever we're getting,
we're getting four items, a, the item should
377:02 - match either phusion or hipolito. In this
case, okay. So if we go ahead and build this,
377:09 - I'll do Ctrl Shift v. Course it fails. Because
we don't have such a metal gate is a thing
377:16 - that receives some argument. So that's kind
of the red face of DDD. And now to start moving
377:23 - into the green phase, we need to move forward
and implement implement this is meant to do
377:30 - that, or we can do is just click here, I'll
do a Ctrl dot. And that a presents his options
377:36 - or we can do is use a generate method, I just
controller get get isolate async. So I'll
377:42 - do that. And then if I do f 12. Here, the
method now exists. And I'll move this up just
377:52 - next to the one that we have already the other
overload here. Okay, and then we could go
377:59 - ahead and try to implement these. But as you
notice, these methods are exactly the same
378:04 - thing. But one of them receives a parameter
and the other one does not receive it. So
378:08 - I think it's better to just put everything
in this one method, as opposed to try to implement
378:12 - the second one. So I'm going to just take
this parameter out of here and into there.
378:18 - Are there Okay, and then we are not expecting
to always receive the name, it depends on
378:26 - what the caller wants. So let's make so that
these a can receive no, so it is allowed to
378:32 - receive. Okay, and so with that, let's go
ahead and run or this case a once again, let's
378:38 - see what we get. I mean, at this point, you
should build just fine this verify that should
378:44 - build Yeah, it does build. Now let's run the
test. And in our suspected it is failing.
378:54 - It is failing because it is carrying a more
items than expected. And on this as a result
379:00 - found items, just getting all the items is
not getting only the ones that have been specified
379:05 - here. So let's see how we can fix this. So
let's try to get green. So what we're going
379:11 - to do is something very simple after retrieving
the list Both items, we're going to apply
379:15 - some filtering if we have to apply a filter.
So if string.is null or whitespace. Name,
379:28 - name to match. That only list, let's just
rename these to name as opposed to need to
379:34 - match. That should be enough. If name is more
whitespace if it is not known as whitespace,
379:42 - then we will apply a filter on the list of
files we have already received. So items is
379:46 - going to be items where item
379:50 - height in duck name, contain corn contains
the me. And just to make sure that we don't,
380:04 - we don't worry about casing here. Let's do
strings comparison already. Now, in our case,
380:14 - we that it doesn't matter. If you're looking
for potions for with capital P or with smaller
380:19 - p, it shouldn't matter. We don't we don't
care about that. So as long as as a name has
380:25 - been provided able to use it to do a filter
on the items, so we get a filtered list of
380:29 - items. And that should be enough to satisfy
the condition. Let's go back to the test.
380:37 - Let's run it. And this time it is passing.
So we are agreeing, this actually confirmed
380:49 - that this is true by running the entire test
suite now. And making sure that we have not
380:54 - broken anything. Yeah, as you can see, everything
is green now. And so everything looks look
381:02 - great. So that's how you how you can use a
DDD. We don't really need to do more refactoring
381:08 - here at this point. But if you needed to you
feel free to go ahead and do more refactoring.
381:13 - But we have gone through the red phase, green
phase. And now refactoring is not not dealing
381:17 - this case. What we can do now is to verify
that this new functionality actually works
381:22 - in the in the real life. So we will start
our host, and we will see how to use these
381:29 - from postman. Okay, so I'll go ahead and hit
f5. And then going to postman are here. So
381:43 - let's see. To start with, we'll see what we
have currently in our database. So I have
381:49 - here the URL to get all the items in the database.
So I'll hit send. And at this point, we have
381:58 - a potion and antidote. And we are ready verifying
that things are not broken, because we already
382:04 - in both this method that has been modified,
it can receive a parameter now, but it seems
382:08 - to be working just fine. So to properly verify
that the new functionality is working, I'm
382:13 - going to actually add a yet another another
item here via the post action. So I'll just
382:19 - copy the URL and say plus, I'll switch this
to post, pay the URL and in the body of the
382:26 - raw. And I'll do Jason. And then I'll just
copy the body of something else here, copy
382:33 - this, notice that the previous items don't
have a description, and that's fine. And the
382:38 - new item will have one let's make sure we
can have one. So let's do this. That. And
382:48 - then to keep things simple, I'll just name
this guy potion. And this is going to be stores
382:53 - a small amount of HP. And the price is going
to be let's say seven. So let's pause this.
383:04 - Okay, is there. And if we go back to our get
a operation I hit set, here we can see that
383:12 - we have the three items now create now is
where we can see if the filtering is working.
383:19 - So now I can say that name equals and are
we looking for potion right? So portion, so
383:27 - they should only give me the mega petition
and abortion. So I'll go ahead here and hit
383:31 - send. And indeed, we are only getting these
two items. Notice that it didn't matter that
383:38 - I use a smaller p here and not a capital P
that we have earlier, he was still able to
383:43 - find the items. So things are working as expected.
So yeah, that's how you can use DD to drive
383:50 - your your process to add new functionality
to the REST API. So as always, I hope this
383:56 - was useful. And if you're looking to dive
in deeper into what I have covered in this
384:00 - tutorial series, please check out the link
to my full online course in the video description
384:05 - that's been watching and I'll see you next
time.