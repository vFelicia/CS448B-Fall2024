00:00 - Welcome to the rusting Replit course. This 
course will introduce you to the rust programming  
00:04 - language. With it in the description. There are 
links to various materials used and mentioned in  
00:09 - this course. Specifically, there is a one click 
link to the interactive course powered by rapid  
00:15 - which allows you to learn rust completely 
within your browser. There is also a link  
00:19 - to the slides mentioned, which can be used 
as a cheat sheet for us. Finally, there is a  
00:25 - link to an article written by yours truly, which 
walks through rust and the interactive projects.  
00:31 - This course assumes intermediate knowledge 
in at least one other programming language.  
00:36 - If you are new to programming, why not try 
the interactive Free Code Camp curriculum.  
00:41 - This is an interactive course going over the 
basics of the rust programming language within  
00:45 - your browser. First, you will get an overview 
of rust. The course covers the basics of rust,  
00:51 - but you can also find some notes of 
this in the linked slides or article.  
00:56 - Then you can follow the interactive 
content to create your own CLI calculator.  
01:02 - Where you can perform basic arithmetic 
operations through the command line.  
01:07 - Then you will create an image 
combiner this project takes  
01:11 - two images and combines their pixels into 
one new image. First an overview of rust.  
01:18 - A quote from the official rust book rusts deals 
with low level details of memory management,  
01:23 - data representation and concurrency. The language 
is designed to guide you naturally towards  
01:29 - reliable code that is efficient in 
terms of speed and memory usage.  
01:34 - The main tooling within the rust ecosystem are 
rusty, which is the compiler that takes your  
01:40 - rust code and compiles it into a binary which is 
machine readable code rust up which is the command  
01:46 - line utility to install and update rust and cargo, 
the rust build system and package manager which  
01:53 - you will get a lot of experience using throughout 
this course. And now moving on to the first  
01:57 - project the CLI calculator. To begin, I have a 
real built using the next language in Replit.  
02:04 - This allows me to define the necessary 
tooling for the project. The link to this  
02:08 - template is available in the description 
of this video. If you want to go too long.  
02:14 - You can use cargo to create a new Ross project in 
the current working directory by typing in cargo  
02:19 - new followed by the project name, 
which we will call calculator.  
02:26 - This creates a new directory named 
calculator initializes it as a git repository  
02:32 - and add useful boilerplate for your project. 
The cargo Tamil file is the manifest used by  
02:40 - cargo to manage your project metadata. This 
is similar to a package dot json file if you  
02:46 - are familiar with those. The main.rs file is 
the default entry point for your application.  
02:53 - You can see it contains a function declaration 
using the FM keyword with the handle main  
02:59 - as well as a call to the print ln macro which 
prints to the console in rust. A macro is  
03:05 - denoted by the exclamation mark character, 
which is also known as the being symbol.  
03:12 - To run the project, navigate 
into the calculator directory  
03:23 - then you can either use the cargo Run command  
03:32 - which will compile your code and 
then run the compiled binary.  
03:35 - As you can see hello world is printed out. 
Or you can use rust C which is the compiler  
03:45 - where you pass in an argument as the location 
to your entry point file. In our case,  
03:52 - this is the source folder and the file is 
main.rs. This will compile your code into a binary  
04:05 - and it will be placed within your working 
directory then you can run the binary throughout  
04:12 - this project, I will just be using cargo to 
run the project. So let's remove that file  
04:25 - the rust standard library 
comes with an EMV module,  
04:28 - which allows access to the command line 
arguments passed when calling the program.  
04:33 - The necessary exports from the 
EMV module for this project  
04:37 - are the OGS function and the OG struct. The OGS 
function returns an instance of the OG struct  
04:46 - and is imported into the file scope with the 
following syntax use keyword followed by standard  
04:53 - the module name in V, the name of the 
function OGS, and the name of the struct  
05:01 - To get an idea of what the abstract looks 
like, you can declare a new variable named OGS  
05:08 - using the let keyword and assign the value 
of the return of calling the function OGs.  
05:18 - Then, use the print line macro to 
print the value of the OGS variable.  
05:24 - To do this, place curly brackets 
within the string as the first argument  
05:33 - and pass the variable you want 
to go within the curly brackets.  
05:45 - Now, if you run this code, you will 
see the following error Augs cannot  
05:50 - be formatted with the default format. Because 
the trait display is not implemented for OGs.  
05:56 - That's a lot to take in. But for now, 
this error comes about because the print  
06:02 - line macro does not know how to format the 
abstract. However, you can just follow the  
06:07 - compilers advice here to extend the format 
using the code on question marks syntax.  
06:16 - Now, running this code, you 
should be able to see the output.  
06:21 - As you can see, the abstract is printed to 
the console. And it contains an inner field,  
06:27 - which consists of the location 
of the compiled binary.  
06:35 - You can confirm this by running the 
application and passing it an argument  
06:42 - Free Code Camp. Now we can see Free Code Camp 
is in the inner Ray. When we ran our code,  
06:50 - you might have noticed that the compiler threw 
a warning saying we have an unused import.  
07:01 - We don't strictly have to import hogs. But if 
you want to explicitly type the OGS variable,  
07:08 - you can do so using the OG struct that we 
imported like so. Now running the code,  
07:16 - that warning should no longer be there.  
07:21 - To access the arguments within the OG struct 
within the OGS variable, you can use the Enter  
07:31 - method which exists on the OG struct. First, 
let's declare a new variable named first.  
07:39 - And assign it the value of calling the Enter 
method on OGs. Hovering over the method,  
07:45 - you can see the function definition where 
it looks like it takes in two arguments.  
07:52 - However, being a method on a struct, 
the first argument is implicit.  
07:59 - And is usually a reference to self where self 
is the struct. In this case, this is a mutable  
08:07 - reference to self. argument that needs to be 
passed in is in which is a use side a number  
08:21 - and it returns the nth element of the iterator 
which is wrapped in an option. Let's unpack what  
08:29 - all of that means. So accessing the first argument 
by passing zero is printed to the console.  
08:43 - You'll notice you will still get 
an error if you run the code.  
08:48 - This error is saying that the OGS 
variable cannot be borrowed as mutable.  
08:54 - We noticed that in the definition, the 
nth method took a mutable reference to  
09:00 - in this case OGs. So, in order to use the method, 
we need to declare OGS as immutable variable.  
09:09 - After doing that, we should 
be able to run the code.  
09:16 - And this is what the first variable is value is it 
is some wrapping the value we are interested in.  
09:23 - Some is a variant on the option enough. This will 
become more clear as we define enums later on.  
09:29 - For now. Just know that you can unwrap options 
to get the value inside. rerunning this code,  
09:37 - we should see that the value is 
no longer wrapped in sum. However,  
09:44 - in this case, if we pass in an index where there 
is no argument, running the code, you will see  
09:51 - that the application panic. Panicking is rust 12 
erroring out during runtime. You can see three  
09:59 - main panics That called optional unwrap on a non 
value. This is because when there is no value  
10:09 - to access using the end method, none is 
returned, as opposed to some with a value.  
10:16 - So instead of unwrapping, 
let's just print that value.  
10:21 - And first the variable is none. And and none 
has no value, therefore, it cannot be unwrapped.  
10:30 - To fix this, let's get the first argument out.  
10:35 - And once again, unwrap now running our code, 
you will see that we get Free Code Camp.  
10:45 - We know we want our application to take in 
three arguments, first being the first number,  
10:51 - as well as an operator being plus times divide, 
or minus. And this will be the next argument.  
11:04 - Let's unwrap that as well as a third 
argument being the second number.  
11:21 - To get an idea of all of these, let's print them 
out to the console. First operator and second.  
11:32 - Running this, let's add some arguments. We would 
expect to use this application by going one  
11:38 - plus two for example. However 
running this, our application panics  
11:45 - apparently, we are still unwrapping on a non 
value. Well, which of these is the non value, it's  
11:51 - keep adding arguments to find out. Application 
still panics for the application and still  
12:00 - panics. Now we are passing six arguments in its 
application and it is still cranking that add more  
12:12 - finally, the application doesn't panic.  
12:15 - And this is because the nth method 
returns an element of an iterator  
12:22 - and we know it needs to be the iterates over 
the OGS variable. Internally what this means is  
12:32 - the nth method will look something like this 
when we have a mutable reference to self  
12:44 - as well as n, which is the use size or the 
index. And we know this returns an option  
12:59 - where it is either a string of the value we 
want or not. Now South Quino is our OG struct.  
13:11 - But what nth does is for each n we can assume 
N in this case as an example, assume it equals  
13:23 - zero. So we are accessing the first element. 
There is some sort of iterator over self.  
13:36 - Accessing let's see that in array 
and it is calling next on that array.  
13:47 - As you can see next advances the 
iterator and returns the next value.  
13:55 - So, in accessing the first element 
when the method is called a second time  
14:06 - the iterator has passed the first element. 
So that second call calling next again  
14:17 - will result in the second element being passed.  
14:34 - Let us look at it from this 
perspective. If at this point in her  
14:39 - is equal to an array of these two arguments.  
14:47 - Calling next brings up the first argument.  
14:54 - Cooling next again, would 
bring up the second argument  
15:04 - So, as we are unwrapping here, 
and let's get rid of this  
15:11 - as we are unwrapping the variable into first, 
which in the case of our call would be one,  
15:19 - calling the method again on to this time 
starts at the plus argument, and two becomes  
15:27 - the first element after that. And then three 
is the second index of the iterator. Practice  
15:37 - Practically, this means if we want to 
access the elements we are interested in  
15:44 - what we actually need to do when we are calling 
just this code. And we don't want it to panic.  
15:53 - We want the first indexed element.  
15:58 - Running this should yield what we 
want. Now, unlike some other languages,  
16:03 - you cannot perform basic arithmetic operations 
on strings. And all of these variables that we  
16:09 - have here are strings. So we need to parse them 
into numbers, or inoculate in our case floats.  
16:22 - So we can declare a new variable first number, 
and set that equal to first which is a string,  
16:28 - use the past method on the string, 
which we can see here returns a result.  
16:34 - And a result is similar to the option enum in 
that it can be unwrapped to get the value out.  
16:45 - And we can do the same for the second number  
16:53 - to be second, dot pass dot unwrap.  
17:00 - Now, we should get a warning that rust doesn't 
know what type we want the number to be,  
17:06 - because there are many kinds of numbers in Rust,  
17:08 - we need to give it a type annotation. 
And we can do this in many ways. One  
17:14 - is to annotate the variable this way 
in which case the parse method knows  
17:23 - to take second as a string and parceled into 
NF 32. All my preferred method for doing this  
17:32 - is to use something called turbo fish 
syntax, which is fun to use and fun to say.  
17:41 - This can be done because on the parse method 
you can see it accepts F which is the type  
17:47 - and it returns a result of that type.  
17:56 - So, let's change second number to that as well.  
18:05 - Now, let us declare a new function called 
operate and this will take in the operator  
18:18 - and we can have the operator of 
your car which is the type character  
18:25 - we will need the first number which we know is 
in F 32. And the same with the second number  
18:37 - now we can use a bunch of if 
statements to compare if the operator  
18:45 - is equal to the character we 
expect for example, in this case,  
18:50 - the addition character and what we can do 
is return first number plus second number.  
19:04 - Now, first thing that we 
will come across is an error  
19:08 - that there are mismatched types which expected an 
empty tuple but found an F 32. And this is because  
19:14 - we have not added a return type annotation to 
the function we can do that with this syntax.  
19:22 - Another thing to note is the type car in Rust This 
is a character literal made using single quotes.  
19:35 - Whereas if we had used double quotes 
that would be of the type string  
19:44 - let's continue with this logic. Adam an else 
if statement. Comparing if operator is equal to  
19:54 - a minus. Then we can return 
first number minus second number  
20:04 - else if operator is equal to divide by  
20:13 - then return first number divided by second 
number. And finally, the last operation we'll need  
20:26 - is if operator is equal to an asterix, 
or the multiplication operator  
20:42 - we will get a warning that we 
don't have all of our clauses,  
20:47 - where the if statement is missing an 
else clause. This is because in Rust  
20:54 - if the operator did not match any of those, then 
the function will return an empty tuple. And as  
21:00 - we have typed the function to return an F 32, it 
cannot return an empty tuple. So we add the base  
21:06 - case otherwise, return for now we can just return 
zero. But you'll notice you cannot just type zero  
21:17 - because it expects an F 32. And 
floats require the decimal place.  
21:24 - Something else to note about rust 
is it allows implicit returns.  
21:28 - What this means is you can get rid of the return 
keyword as well as the semicolon at the end. And  
21:37 - this is exactly the same as what we had 
before. But this is the more recitation  
21:42 - way of writing the code. And we can do this 
throughout. Now, to use the function operate,  
22:02 - you can declare a new variable called result.  
22:08 - Call the function passing in the 
operator first number and second number.  
22:19 - However, you'll notice that we get a 
warning because operators have type string,  
22:24 - but the function expects the type car.  
22:28 - So we need to convert the operator into 
a character. And we can do this by using  
22:34 - the cost method on the string, which returns an 
iterator over the characters of a string slice.  
22:43 - And with the iterator we can call the next 
method to access the first element of that slice.  
22:52 - And the next method returns an option which 
we know we can unwrap if the value exists.  
23:02 - Now, we can print our result let's run the 
code to see if this all works as expected.  
23:16 - And we can see one plus two, the result is equal 
to three. However, this is not the final output we  
23:25 - want. And what we can do is declare a new function 
called output which will accept the first number  
23:32 - which we know to be an F 32 The operator which 
is a car the second number which is also an F 32.  
23:45 - And then the result which is that operation 
on the two numbers which is an F 32.  
23:53 - We will want this to return a string  
23:57 - and in order to get the output the way you 
want, we can use the format macro, which is  
24:01 - very similar to the print line macro in that the 
first argument is a reference to a string size  
24:13 - which we can pass in additional arguments 
which will be placed within the curly brackets.  
24:20 - So we want first number operator, second number 
is equal to result and format returns a string.  
24:36 - Now to use this what we can do is 
call output and pass in first number.  
24:49 - The operator the second number and the result 
Hopefully running the code gets us what we expect.  
25:07 - And that's correct, one 
plus two is equal to three.  
25:10 - Let's try something else. Let's 
try one minus two, negative one.  
25:21 - However, there's something much better we can 
do to improve the readability of the code.  
25:25 - And that is instead of a 
bunch of elsif statements,  
25:29 - we can use rusts pattern matching 
expression, which starts with match fall  
25:37 - followed by the expression to be evaluated, 
which in our case is the operator and then  
25:43 - this is called a match arm. And what this is, 
is if cooperating matches the plus character  
25:51 - then evaluate the following 
first number plus second number.  
26:02 - Now, because we are not 
including a semicolon at the end,  
26:05 - this is implicitly returned and 
we can continue with this logic.  
26:29 - Now, we will get an error, saying that we have a 
non exhaustive pattern. Because similarly to the  
26:36 - if statements, they need, where we needed an else 
clause, the match expression needs a base case,  
26:44 - which can be represented by the underscore 
and we can still return the 0.0.  
26:54 - And you will see that this code 
runs exactly the way it did before.  
27:03 - However, returning zero if the operator 
is invalid, does not make too much sense.  
27:11 - So it might make more sense to panic. And you 
can do that using the panic macro and pass it a  
27:17 - message such as invalid operator used. Now what 
this will do is if an invalid operator is used,  
27:29 - the code will panic. You can see it 
has panicked at invalid operating used.  
27:39 - But now, what if we wanted 
to extend our application  
27:43 - to not just accept more multiplication? 
What's the server say? This is an  
27:49 - interesting case where we need to escape 
the Asterix. In order to run the code.  
27:58 - To get around that, you can extend the operator 
function to not just work with an asterix, or not  
28:04 - just match with an asterix, which needs to be 
escaped each time. But it is common to multiply  
28:09 - with an x. And we can extend it further using 
bitwise OR for capital X. What this allows,  
28:17 - is instead of escaping the Asterix, we can 
just use x to represent multiplication.  
28:26 - And this will work just fine. And that is our 
application finished. All that's left to do  
28:36 - is build it and to do so you can use cargo 
build to compile the binary and you can  
28:43 - also pass the release flag. What this 
does is it provides some optimizations  
28:48 - for the compiler and removes all debugging 
information running this will compile our code.  
28:57 - The code is found in the target 
directory in the release directory  
29:05 - and it is called the binaries name.  
29:09 - We can run this code now with arguments 
add the period at the beginning  
29:22 - and that we get the same result. So 
that is the CLI calculator finished.  
29:31 - For the image combiner project, start by creating 
a new rust project using the Cago new command.  
29:38 - And let's call this combiner then 
cd into the combiner directory  
29:45 - and run the project to ensure 
it is set up correctly.  
29:52 - You should see hello world printed to the 
console. This project is bigger and more  
29:56 - complex than the calculator project. 
So to prevent this The main.rs file  
30:02 - from becoming too overwhelming, create a new 
file within the source directory called arcs.rs.  
30:16 - This file will be a new module named arcs, which 
will house the logic used to handle the command  
30:22 - line arguments. Within arcs.rs create a function 
named get enter arg which takes a U size in  
30:40 - and returns a string. Then, we know from 
the previous project that we can access the  
30:49 - EMV module inside the standard 
library and call the arcs function  
30:57 - chaining the nth method to get the nth 
argument. And let's unwrap the value.  
31:07 - Now, to group the related command line argument 
data, you can create a struct named OGs. You've  
31:14 - already encountered structs in the previous 
project. This was the string struct and the struct  
31:21 - from the EMV module. Instead of using the NV OG 
struct, you will be defining a custom arc struct  
31:28 - specifically for use in this application. 
The string struct looks something like this  
31:38 - where we can declare the struct using the 
keyword struct that contains the Vic field,  
31:46 - which is a veck of uate Vic, in this 
case is a dynamically sized array.  
31:56 - So following this syntax 
create a struct named Augs.  
32:03 - The three fields image one which is a string, 
Image two, which is also a string and output  
32:16 - to also be a string, these will be the paths to 
the images passed as arguments within main.rs.  
32:24 - The OG struct can be imported once the OGS file 
is declared as a module using the mod keyword.  
32:31 - So mod OGS declares the file as a module and 
then we can import it using the use keyword.  
32:47 - You can use the arc struct by declaring 
a new variable named arcs in this case  
32:55 - and assigning it the value of the arcs followed 
by the field name and values for those fields.  
33:24 - You will notice the error saying we cannot 
use OGS here because it is not public.  
33:32 - It is a private field in a private struct  
33:42 - it is a private struct to make it public use 
the pub keyword before the struct definition  
33:56 - now you will notice that each of the fields  
34:01 - is also private. So similarly before each 
definition, the public key word can be used  
34:09 - to declare the field as public and therefore 
accessible outside of the current module.  
34:26 - As you can see here to create a new 
string the new function has been used.  
34:30 - The reason this function can be used 
is because it has specifically been  
34:34 - implemented for the string struct the 
implementation would look something like this.  
34:56 - Where function new has been declared 
To be implemented on the string struct,  
35:04 - where it returns self being string. And as 
you can see a string is created within it  
35:10 - and implicitly returned. And the same goes 
for the new function within the veck struct.  
35:17 - Now, if you're creating many OG structs, it 
would be beneficial to be able to do the same  
35:22 - thing that is implement a new function 
on the OG struct within the OGS module.  
35:33 - So you can use the imple keyword to 
implement new on the struct OGs. We  
35:43 - new does not take in any 
arguments, no to return self.  
35:52 - Where we can take that code 
we had previously here.  
36:00 - This time, returning it from the new function, 
then we can call Augs. New to instantiate a new  
36:13 - org, you'll notice that there is again an error 
that new is private. So before the function  
36:21 - declaration, use the public keyword to make the 
new function public. If we were to print out  
36:31 - the value of ocsea You'll notice two 
things. First being that there is an error,  
36:47 - which we've encountered before saying that 
the treat display is not implemented for OGs.  
36:52 - Now, you may think that you could just 
extend this as we have done previously.  
36:59 - However, we still get error, where the debug trait 
is not implemented for arcs. In order to implement  
37:07 - the debunker trade, we can actually follow 
the compilers advice here to add this syntax  
37:19 - to the struct definition, what this does, 
this is an attribute that is deriving  
37:27 - the debug trait for the OG struct. And after 
doing this, we should be able to print out  
37:37 - the OG struct. However, you'll notice that 
currently, the fields are all empty strings.  
37:45 - This is not what is needed for the OGS fields. So,  
37:50 - we can replace the string new 
call with the get end org function  
38:00 - passing in one as argument to the 
first chord because the zeroeth  
38:05 - argument is the path to the 
binary continuing this logic  
38:13 - we can pass in to to get the second argument  
38:21 - and similarly three to get the third argument  
38:27 - now if we run our code should get an error 
because we are not passing in any any arguments.  
38:34 - So calling unwrap within the get nth 
OG function should cause a panic.  
38:41 - What we can do is test this by calling 
our application with some arguments.  
38:51 - And as we can see, image one has the 
value first image to second and output  
38:55 - third. For this application, an external crate 
called image is required to decode and encode  
39:01 - the images. Much the same way other languages have 
libraries or packages. Rust has crates you can add  
39:08 - the image creator to application by creating 
a new dependency in the Kaga dot Tamil file  
39:20 - this is the name of the crate followed by 
its version number in our case 0.2 3.1 For  
39:30 - now, running cargo run will 
fetch and install the image crate  
39:45 - whilst the image creators installing  
39:49 - a new function can be created within 
main.rs named find image From path  
40:05 - we'll take an argument path, which is a 
string. And we will set the return later.  
40:14 - The image crate comes with an IO 
module, including a reader struct,  
40:20 - we can create a new variable Image Reader 
set that equal to the reader struct.  
40:29 - And the struct implements an open function which 
takes a path to an image file and returns a result  
40:35 - containing the reader. So, we can pass in the 
path as the argument and we can unwrap the result  
40:48 - this reader can be formatted and decoded to yield 
the image format for example, a PNG or a JPEG  
40:55 - as well as the image data 
and new variable image format  
41:04 - will be assigned the unwrapped value of the dot 
format method on the reader the imagery to being  
41:09 - the variable Image Reader dot format and we 
can unwrap the value from within the format  
41:22 - and variable image can be assigned and unwrapped 
value of the decode method on the reader.  
41:40 - Now, we are interested in both the 
image and the image format variables.  
41:44 - So the two values can be returned in a 
tuple. The image as well as the image format  
41:56 - can be returned in a tuple. To get an idea of the 
types we need to return, we can explicitly type  
42:02 - our variables we know this to be a reader, but the 
reader as a type of a BufferedReader from a file  
42:13 - the image format is also a type from 
the image create which is image format.  
42:22 - And the image another type from the 
image create which is a dynamic image.  
42:29 - So, we know we need to return a tuple from this 
function and in the order to be a dynamic image  
42:42 - and an image format  
42:48 - then, the necessary imports can 
be included at the top of the file  
42:54 - that is importing from the image 
create the reader is in the IOE module  
43:03 - and from the image create the 
dynamic image and the image format  
43:11 - you'll most likely get these errors until crater 
has been installed. Now within the main function  
43:21 - the return tuple can be D structured 
into two new variables which we will call  
43:26 - image one and image format 
one from find image from path  
43:38 - parsing in the image one field from the OG 
struct and the same can be done for image two.  
43:56 - You will notice the error about missing imports 
for the explicit types within find image from  
44:03 - path. The BufferedReader and file structs 
need to be imported from the standard library.  
44:14 - BufferedReader is within the IO module. 
And file is within the FS module.  
44:26 - There is an error here in the print line 
statement. But for now, we can get rid of that  
44:31 - line because we won't be using it. It is important 
to handle errors which are likely to arise such  
44:37 - as the case where three images of different 
formats are given as arguments to combine.  
44:44 - For example, we will need some logic where if 
image one format is not equal to Image two format,  
44:56 - then only to return an error as well way of 
handling such an error is to return a result  
45:04 - we have encountered some results already. 
But a result can consist of either an okay,  
45:11 - or an error variant. What that practically 
looks like is if we find the format's are  
45:16 - not equal to each other, we return 
an error normally with a value within  
45:25 - what this means is our function 
needs to be typed to return a result  
45:32 - and that result needs to contain some values. 
But we also need the base case where if there  
45:40 - is no error of function returns okay, it is 
common to see results return an empty tuple  
45:48 - when there is no error, what this means 
is our result the type returned on okay  
45:54 - is an empty tuple. Otherwise, it will 
be some error, the error we will return  
46:00 - is an enum and this is because enums are 
useful for acting as both types. And as well  
46:06 - for now we can call our error as an image data 
error. And we will need to define this enum.  
46:16 - To do so, we use the enum keyword 
followed by the name of our enum  
46:23 - as well as the different variants on Ina. We 
have seen this for example, with the option email  
46:31 - which is defined similarly to this where it 
takes some with a value or it just returns none.  
46:46 - In our case, we will define one of the 
variants to be different image formats.  
46:54 - As such, we can turn in within our main 
function an error of image dot errors.  
47:05 - The variant different image formats, we just need 
to fix this year image format one image format to  
47:18 - to make combining the images easier, the largest 
image is resized to match the smallest image first  
47:26 - in to find the smallest image which we can do  
47:29 - using a function called Get smallest image 
or get smallest dimensions I should say.  
47:36 - Because the image will consist of 
two dimensions, each image will have  
47:41 - in this case, it will be a tuple containing 
the width as a U 32. And the height as a U 32.  
47:49 - And the second image we will pass in its 
dimensions which will be the same to use 30 twos  
47:56 - in a tuple what we will want to do is return 
the smallest dimension as a tuple to compare the  
48:09 - sizes, we can declare one variable variable being 
the number of pixels in the first dimension,  
48:16 - which will be the first dimension access the 
first element in that tuple multiplying by  
48:28 - the second element in the same tuple and 
we can do the same with the second tuple.  
48:43 - Now what we are comparing is the number of 
pixels in the image. To do this we will return  
48:55 - if the number of pixels in the first image is less 
than the number of pixels in the second image,  
49:03 - then we will return the first 
image is dimensions else  
49:11 - the second image is dimensions we will 
create a function called standardize  
49:24 - size which will take in the first 
image which we know to be a dynamic  
49:31 - image as well as the second image 
which again is a dynamic image  
49:42 - and it will return both images. We 
can again return them in a tuple  
49:50 - however, these images will be resized. And 
what we want is Using our get smaller dimension  
50:02 - function, we want to return the smallest with 
the smallest height. So, we're creating two  
50:08 - new variables by destructuring the 
return of get smallest dimension  
50:16 - passing in image one getting its 
dimensions by using the dimensions method  
50:24 - available on the dynamic image 
struct and the same with Image two.  
50:44 - Except this is good smallest dimensions there 
you go, I think it is helpful if we print out  
51:00 - the values of the width and the 
height which we can do like so  
51:12 - and we can also add a new line at the end  
51:19 - now, what we want to do is in order 
to standardize the size, we will first  
51:26 - find out if for example, Image two steam 
engines are equal to the width and the height  
51:42 - that we got from calling get smallest dimensions 
on the image, then we will know that image two  
51:48 - is the smallest image and therefore, what we 
want to do is we will want to resize image one  
51:56 - and we can use the Resize exact method which 
is implemented on the dynamic image struct.  
52:05 - immutably borrows the image and using 
the width, height and phototype arguments  
52:13 - resizes the image so, we can pass in the 
width that we want the height that we want.  
52:21 - And now we need to pass in a filter type. 
This type also comes from the image crate  
52:27 - and the type we will be wanting to use is 
triangle this is just used for its simplicity  
52:34 - as well as it generally does a very good job of 
resizing the image without distorting it too much.  
52:40 - Now, we will need to import triangle 
it exists in the image drops  
52:52 - filter type number and it is the type of 
triangle now, we are wanting to return a tuple  
53:05 - with the resized images. So, what we can 
do is after resizing the first image,  
53:12 - we will then also just return Image two along with 
it in a tuple and we will need an else clause that  
53:20 - is if image one is the smaller image then return a 
tuple with image one unchanged, resizing Image two  
53:34 - passing in the new width we want the new height 
and the filter type. You can see there are errors  
53:43 - about using the dimensions method on the 
dynamic image and this is because the  
53:51 - trade has not been brought into scope. So, 
we can follow the compilers advice to get  
53:57 - the generic image view treat 
from Image generic image view  
54:18 - and that should be enough to get rid of the errors 
for now, fixing the typo in the standardize size  
54:25 - functioning we can then have to claim the 
format declare image one image two again  
54:35 - this time destructured from the standardize  
54:44 - size function having resized whichever image is 
the largest. Now it is all in fine that we have  
54:53 - we are handling resizing the images. However, we 
know that the end goal is to create a new image  
55:00 - Using the pixels from the two input images. 
So to handle the output, a temporary struct  
55:07 - can be created to hold the metadata for the output 
image. And we can call this struct floating image.  
55:19 - And the metadata we will want is the 
width as a U 32. The height as a U 32.  
55:28 - It will contain some data being 
the pixel values as a veck of uate.  
55:35 - Because the pixel values will exist between 
zero and 255, AQa to perfectly fits that  
55:42 - number type. We also want the name of the image as 
a string. In order to create this floating image,  
55:50 - we can do as we did previously with the old 
struct and we can implement the new function  
55:59 - which will take in a width and a height  
56:07 - as well as the name and it will return a new 
floating image. And what this will look like  
56:21 - is floating image with a value 
of the input width and height.  
56:27 - We know that there will be some sort of data  
56:32 - as well as the name for the data. When we create 
the new floating, we won't have the pixel values  
56:41 - yet, but we will need to reserve the space 
for them in memory. In order to do this,  
56:47 - we can declare a buffer and that buffer could be 
a fixed value, such as et Cie buffer capacity,  
56:57 - set this to some number, for example 3,655,744. 
And then the buffer itself will be a vector  
57:15 - with the capacity of that buffer capacity  
57:24 - and then we can assign the buffer to the Stata. An 
interesting thing about rust is that you can use  
57:32 - this number format to make your numbers easier 
to read, where you separate three digits of your  
57:39 - number using an underscore. However, what we have 
here assumes that any image we input will not be  
57:46 - larger than essentially this number of bytes that 
we can more dynamically size this, based on the  
57:51 - fact that we know that our image will consist 
of a height, you can multiply that by the width.  
57:57 - And to get the number of pixels, we multiply this 
by four. The reason for this will be clearer as  
58:02 - we go through this next we will be using RGB a 
values. So we are multiplying by four because  
58:08 - there we are using the red to green, the 
blue and the alpha values for each pixel.  
58:13 - You will see we have a warning here that there are 
mismatched types with capacity function expected  
58:18 - to use size but found a u 32. The reason but 
capacities of type U 32. It's because we use  
58:24 - the height and the width to create it which are 
you 30 twos. Normally, freshmen automatically  
58:29 - convert or trying to convert the number type into 
the correct type. However, in this case, we cannot  
58:36 - be certain that this is possible. So we can follow 
the advice the compilers giving to try to convert  
58:44 - the value. Otherwise, if that's not possible, 
fail or in this case panic. So we can try into  
58:57 - and then unwrap. However, in order to use the 
train method, we need to bring it into scope  
59:05 - and it exists in the standard library and the 
Convert module of the tray into implementation.  
59:13 - So we can just bring that into scope. Now 
within main we can create an output variable  
59:23 - containing the new floating image. We will 
use image ones with and image one's height  
59:40 - as the inputs for the new function. We could use 
Image two as well. But considering image one and  
59:48 - Image two have been resized to be the same size 
the width and height will be identical anyway.  
59:53 - And we will want to pass in the output field from 
the OG struct. As this will be the name of the  
60:01 - function and the location which we will later use. 
At this point, we can deal with the error that we  
60:06 - have occurred, which is saying that the trait 
debug is not implemented for image data areas.  
60:13 - We can resolve this by following compilers advice 
to use the attribute and derive the debug trait  
60:19 - for our image dot two areas a number. The reason 
this is necessary is because main returns the  
60:27 - standard output the result of running the code 
normally either being a status of one or zero.  
60:35 - And in order to return to the 
standard output, the debug trait  
60:39 - is to be derived. From here, we can run our code 
to see if everything is working as expected.  
60:45 - What we will need are two images as inputs to 
get these images, I will just be importing them  
60:54 - into our combine a project. Within the images 
folder we have three images here. First being  
61:02 - my profile picture. The other being the 
Free Code Camp blogger on the other end  
61:09 - inverted Free Code Camp logo 
that we might use later.  
61:18 - Then in order to test our code, we can go Cago 
run passing in the arguments which we know to be  
61:28 - images folder, we can pass in my profile image 
as well as the image to the Free Code Camp.  
61:42 - But these images are PNGs we also need to 
specify an output location which we can say  
61:48 - is within images. And we can set it to test a 
PNG we have not currently implemented anything  
61:57 - for the output image to go into However, 
we still need to provide the argument  
62:04 - get a few warnings  
62:10 - code panic because I called 
the wrong folder nigga.  
62:17 - Running again we can see that 
the width and the height output.  
62:22 - So everything is working as expected.  
62:25 - As I said earlier, in order to process images, 
they are converted into a vector of RGB pixels.  
62:31 - And pixels are stored as you eight because 
the values are between zero and 255.  
62:37 - So in order to process our images, we will be 
creating a new function called combine images.  
62:46 - And this will take an image one, 
which we know to be a dynamic image  
62:56 - image to the same and this will 
return their cookie weights.  
63:11 - The dynamic instruct implements the to RGBA 
method, which returns an image buffer containing a  
63:19 - veck of UAT. And the image buffer implements the 
into vac method which returns the back itself.  
63:27 - So to visualize that a bit better, let's 
declare a new variable called veck one which  
63:32 - will be image one we will call the to RGBA eight 
method on the dynamic image you'll notice that  
63:43 - it returns an image buffer containing an RGB 
you eight as well as the back of your eight.  
63:52 - So in order to get the backs out, we can 
call the into BEC method on the image buffer.  
64:04 - Likewise, we can do for vector in image to 
in processing our images, we will want to  
64:12 - alternate the pixels of the two images. So 
what we will do is we will create a function  
64:19 - called alternate pixels. And what 
this will do taking the two vectors  
64:27 - and it will return a vector of us 
for us. So let's define that function  
64:38 - we know that it takes in too thick of  
64:53 - UAT. It also returns a vector view ID. First, we 
need to declare a variable Java can combine data  
65:02 - that will hold the data of the two images after 
they have been alternated, in essence, where we  
65:08 - are pushing the pixels from one vector and 
then putting the pixels from the next vector.  
65:14 - And in order to size, the combined data, 
we will match it using a VAC macro,  
65:22 - we want you weights. And we want the number 
of your weights to be the same length  
65:30 - as any of the vectors passed. In this case, 
they are the same, but we will just set them  
65:35 - to be the size of the first vector, what this 
reg macro does, it will create for example,  
65:42 - if Vic one dot length is equal 
to 100, or let's say five,  
65:50 - then the veck macro will create a vector 
of have you rates of that same length.  
66:02 - Now, what else we will do 
is we will use a while loop  
66:06 - to go over each pixel. In this case, we 
will refer to the pixels as indices within  
66:14 - the length of the vector. And first, we 
will need to declare this pi variable.  
66:22 - And we will know that we'll want to mutate 
our variable so we'll declare it as a mutable  
66:26 - variable starting at zero and within 
the while loop, we will increment  
66:37 - by four this is done because we are using 
our GPA sets within the vector and being  
66:44 - four values we need to increment i by four as 
we axing accessing the indices within the vector  
66:49 - using the modulo operator, we can see that 
if I modular eight is equal to zero, we will  
67:02 - splice into combined data 
the RGBA set from FX one,  
67:09 - in order to do this, we need to set the 
range in our case the range will be from I  
67:18 - until I plus three and we will need to 
get the RGBA set from the first vector.  
67:26 - To do this, we will create a little 
function set GBA what this will do, it  
67:34 - will take in the first vector, it will take in 
a starting index as well as an ending index and  
67:42 - it will return the RGBA Tet from those indices. 
Otherwise, we will want to do similarly this time  
68:00 - passing in vector  
68:08 - so, let's define that set RGBA function  
68:15 - we know that it takes in a vector 
this vector will be evaluates to  
68:23 - have a starting index, which is you size as well 
as an end index also a new size, we will want to  
68:32 - return the vacuolated. In order to do this, 
we will be declaring a mutable vector RGBA.  
68:47 - It's just a new vector. And for every index in  
68:56 - start until the end inclusive, 
you will declare any variable  
69:05 - Val we will set this equal to Feck dot get and 
pass in the index that we are interested in.  
69:14 - Then, after doing that, we will 
push that index to the RGBA vector.  
69:24 - We will push that value and then we will want 
to return that vector we have initially here  
69:31 - we get returns an option. What we could 
do, it's just unwrapped to get the value.  
69:36 - However, there is a chance that that value 
doesn't exist. So what would actually be better  
69:44 - is for us to match on get cool. And if there 
is some value. It's called bad value d.  
69:56 - What we want to do is return the value 
If there is none, what we want to do  
70:04 - is potentially panic and say 
that the index is out of bounds.  
70:20 - Now, you will notice that we get an error, telling 
that the function expected to return a vector of  
70:24 - the rates but instead is returning an empty tuple. 
To resolve that, we can return the combined data.  
70:34 - You'll notice we have an issue here where combined 
data is being spliced. So what we actually need  
70:39 - to do is declare it as mutable. And we get an 
error down here saying that it expected function  
70:48 - is expected to return evaluates however, it is 
actually returning a veck of UAT. But the UAT  
70:55 - are referenced. What this means is we are pushing 
reference values. In this case, currently, Val  
71:04 - is equal to a reference of UAT. What we want is 
for it to be just a UAT. In order to do that,  
71:11 - we can use the Asterix before the variable 
what this does is dereference the value  
71:19 - that resolves the error, however, now we 
have a new error, saying that the borrow  
71:26 - of a moved value back one where the value 
borrowed after being moved. Here, we can see that  
71:33 - vac one has been moved. Why this is is because 
within the while loop, we are passing Vic one  
71:40 - into the set RGBA function, we don't actually 
want to pass in the whole value, what we want  
71:44 - to do is we want to pass in a reference to a 
value pointer. And the same needs to be done.  
71:52 - With back to now we need to adjust the function 
definition as it's not accepting back you at  
71:58 - accepting reference to evaluate. To clarify. The 
syntax here is rusts range syntax, which allows  
72:06 - the range to be inclusive of the end value. 
So far, we haven't called these functions yet.  
72:13 - However, what we need to do first is to set 
the data of bind data into the output image  
72:19 - which we actually need to call output. A method 
on floating image needs to be defined to set  
72:27 - the data field of the output to the value of 
that combined data because currently what we  
72:31 - have for the data field is just a buffer not 
the actual pixel values we are interested in.  
72:36 - So far, you have only defined functions on struct. 
However, now we are wanting to define a method  
72:44 - methods are defined in a similar way, but they 
take an instance of the struct as their first  
72:48 - argument. You saw this with the next method. 
So we are going to define a method called  
72:56 - set data on the floating image. What this 
will do is with we'll take a mutable reference  
73:02 - to self as well as the data we are wanting 
to set which is effectively weights.  
73:10 - What this will do is return a result  
73:15 - either on okay to return an empty tuple or to 
return one of our image data error. Variance  
73:27 - what we can do is first make sure 
that data dot length is greater than  
73:36 - the current floating images capacity.  
73:42 - If the length of the data is more than the 
capacity of the current floating image, what  
73:49 - this means is we cannot store we did not reserve 
enough buffer in order to store that data. So  
73:57 - here we will return an error. 
And this type of error will be  
74:02 - image dot errors. And we'll need to 
declare a new variant and this will be  
74:07 - buffered to small. So we need to do to 
find that variant to buffer to small.  
74:22 - Otherwise, we can just set the data to 
the data that is passed into the method.  
74:29 - In that case, the result is okay. Now within 
main, we can call that method on output.  
74:47 - Passing in the combined data. You'll 
notice that again only one argument is  
74:54 - passed into set data because implicitly 
the first argument of a method is self.  
75:05 - You need to define combined data. Let's 
do that first and say that combined data  
75:12 - equal to we have the combine images function. 
And it takes in image one and Image two.  
75:20 - And what we've done is we've made that set dotta 
returns a result. And the interesting thing you  
75:27 - can do with the rest is propagate that result 
fairly, by adding a question mark at the end of  
75:32 - the expression. What this will do is essentially 
unwrap the value but it's propagated into  
75:37 - current function and as main already returns 
a result of either Okay, with an empty tuple,  
75:43 - or an error with image data errors, which 
is the same function signature as set data,  
75:49 - we can use error propagation operator. Finally, 
the new image needs to be saved to a file,  
75:57 - the image create has a safe buffer with 
format function, which works like this.  
76:04 - We can use safe buffer. With format, we need to 
pass in the path of where we want to save the  
76:13 - image, which we have stored in the Name field of 
output, we need to pass in the data from output.  
76:23 - However, this needs to be a reference to 
the data and not passing the value itself.  
76:32 - resizing the width of the new 
image. And the height of the image  
76:43 - needs to define the color type of the image,  
76:46 - we can get the color type from the image 
create. And we know that the type is RGBA.  
76:53 - And they are you eight. And finally the format 
of the image, which will be the same as image  
77:00 - one format. This function also returns a result 
so we can unwrap that. And I need to remember  
77:09 - to correctly name my variables, you'll 
see we still get an error about output,  
77:14 - where we can offer it as mutable because there's 
not declared it mutable. This is because inside  
77:18 - data as a method, it takes a mutable reference to 
self, which in this case is output. So we need to  
77:27 - declare our output variable has been beautiful. 
To test out our image combiner we can once again  
77:36 - cover run and pass in arguments, which 
we know to be images to my profile PNG  
77:44 - images to the FCC glyph. And we output 
this image into the images folder.  
77:54 - And we will call it output dot png. 
Running this will compile the code.  
78:03 - And once it has finished, we should be able 
to navigate into that images folder and  
78:09 - find the output. And there it is the profile 
image. And if we go can bluff combined into  
78:19 - one image. Although the application is finished, 
we have a lot of calls to unwrap within our code.  
78:27 - What this means is if at any point there is an 
error during runtime, our code will panic. And it  
78:34 - may not provide the best user experience all the 
best error to help develop and debug as they're  
78:39 - using the application. So, one thing we can do to 
extend this as we already have some basic error  
78:46 - handling within our main function, where we are 
returning result where if there are any errors,  
78:53 - we are returning image data areas, which is 
enough we can extend this further with some  
78:59 - more common types of error. So, for example, 
fixing up the find image from path function  
79:05 - instead of unwrapping on the reader open 
returns a result. So, what we can do is  
79:14 - we can match on the result and if the 
expression is okay, we will get the Image Reader  
79:33 - otherwise, if there is an error, we can get this 
error out in a variable named E and then we can  
79:40 - return an image data error and we will add 
a new type of unable to read image from path  
79:51 - as a variant on image dot areas you know 
and we can pass an E as a value to the INA.  
79:58 - So let us define this New variant  
80:02 - we named it unable to read image from path 
and we know it takes in some sort of error.  
80:10 - Now, this error exists in the standard library as 
standard IO error. Next, we need to move our logic  
80:26 - within this match on that we can continue 
with the next unwrap statement. However,  
80:35 - format returns an option. And the general rule 
of thumb I follow with how to handle options  
80:41 - versus results is as we have already done with 
a result we match on the result and we handle  
80:47 - the okay variant versus the error variant. 
However, if we are dealing with an option  
80:54 - what I like to do is use an if let statement and 
that looks something like this. If let there is  
81:05 - a value that is the option returns some then we 
can declare a new variable called image format.  
81:18 - And if this is the case, we can perform 
some logic else we can return an error  
81:26 - in this case, you'll need to explicitly 
return error image data errors and we will  
81:34 - declare a new variant called unable to format 
image and something we can do here is pass in  
81:43 - the path that way our error has more information 
with it as to which image that failed to read.  
81:51 - Now, we cannot pass in part as is because we are 
moving at into this open call. So what we need to  
81:58 - do is passing a reference to the path to the first 
open call and then we can define that variant  
82:06 - and we call that variable unable to 
format image and it took in a string  
82:19 - then handling the image logic as decode 
returns a result we can match on the result  
82:35 - match on the result and in the arms. If okay, we 
can get the value in a variable called image we  
82:45 - can return okay with the tuple that we expect 
to be an image as well as the image format.  
82:54 - Otherwise, if there is an error, we can get 
the error in a variable called E and return  
83:01 - that error in again another 
variant of image data errors  
83:09 - and this variant we will call unable to decode 
image and we will pass in that error as is. So,  
83:20 - to declare this new variant, which we named unable 
to decode image, it takes in a specific error from  
83:29 - the image crate which is called Image error. 
As such, we need to add it to our dependency  
83:41 - then we can remove some of this 
logic that we are no longer using  
83:44 - and means to fix up some things. So, we need 
to define our function to return a result  
83:51 - and on this result, it is either returning a 
tuple which we originally had otherwise that  
83:56 - you know it is returning one of the image data 
areas variance then as we learned earlier earlier,  
84:03 - we can propagate the errors into the main function 
as we are calling it using the error propagation  
84:10 - operator. And finally, we have one more unwrap 
to deal with and this is on the safe buffer  
84:17 - with format function. Now, what we can do with 
this is as it is returning a result however,  
84:22 - we are only actually interested in the case where 
there is an error, we will again use an if let  
84:29 - expression de structuring the error from the call.  
84:41 - This way, we can just return the error if there is 
one in a new variant called unable to save image  
84:52 - and passing that error. Otherwise we can return 
okay To define that variant, which we named unable  
85:08 - to save image, and we are passing in, again, 
an image error from the image creator, we have  
85:17 - also reject this to no longer be using these 
imports. So what we can do is just remove that.  
85:24 - And just like that they are handling our 
areas in a much better way to inform both  
85:29 - the developer and all the final user of what 
is happening when any of these areas arise.