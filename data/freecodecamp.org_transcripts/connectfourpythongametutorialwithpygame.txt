00:00 - what's up guys
00:01 - in this video i'm going to show you how
00:02 - to program connect 4 in python
00:06 - by the end of these videos you'll build
00:08 - something that looks like this
00:12 - it's a simple
00:14 - two-player connect 4 game with graphics
00:17 - i think this is a really good exercise
00:19 - for your beginner to intermediate level
00:21 - python programmers who want to build
00:22 - their skills
00:24 - i'll just finish up a game real quick
00:26 - just so you can see how
00:28 - this fully works
00:30 - as you can see i have the diagonal and
00:31 - it says player one wins cool we're gonna
00:34 - do something a little bit simpler and
00:35 - then build up to that graphic based
00:37 - connect four game
00:38 - it's a command line connect four game
00:41 - where you actually manually type in
00:42 - numbers to drop your pieces so you see
00:44 - the one there
00:45 - the two etcetera all right so let's
00:47 - start building that
00:49 - just quickly i want to mention that i'll
00:50 - be programming in python 3 and then
00:53 - using sublime text 2 as my editor i
00:55 - posted a link to a video on how to set
00:57 - up these things in the description
01:00 - so one of the first questions i asked
01:01 - myself when i was writing this game is
01:03 - what is the best way to represent the
01:04 - board
01:05 - so if i drag on a connect 4 board real
01:07 - quick you can see that it is 6 rows by 7
01:10 - columns and to me this looks like the
01:12 - perfect structure to represent as a
01:14 - matrix in python so that's what we'll do
01:17 - so we'll define a function called create
01:19 - board
01:21 - and that's not going to accept any
01:22 - inputs
01:23 - then we're going to make a
01:24 - a matrix of all zeros with the
01:26 - dimensions six by seven and to help us
01:29 - do this we're going to import a package
01:30 - called numpy
01:33 - and if you haven't already installed
01:35 - this you can open up a terminal window
01:37 - and just type in pip install numpy
01:41 - and as you can see i already have it
01:43 - so we're going to use this as follows
01:44 - we're going to say board equals
01:47 - numpy dot zeros and that's going to make
01:49 - a matrix of all zeros which is good for
01:52 - our initial state and then the
01:53 - dimensions six rows by seven columns
01:56 - cool and then we just need to return
01:58 - that board
02:00 - and we can test to make sure that worked
02:01 - by doing the following create board
02:04 - and then
02:05 - print
02:06 - board and as you can see if i run oh no
02:09 - what happened as you can see if i run
02:11 - that
02:12 - um we we do in fact have this six by
02:15 - seven matrix of all zeros so that looks
02:17 - good we can begin writing the main game
02:19 - loop now
02:21 - so we're going to write a loop that says
02:23 - while not
02:25 - game over
02:27 - and so
02:28 - our loop is going to be running as long
02:30 - as
02:31 - this game over variable is false
02:34 - and the only way it becomes true is if
02:36 - someone has a four in a row so we need
02:37 - to initialize the game over to be false
02:39 - to begin with
02:42 - equals false and the only way that's
02:43 - going to switch to true is if someone
02:45 - got a four in a row
02:47 - so now we're going to need to we're also
02:49 - going to want to real quick
02:50 - make our board initialize before we
02:52 - start the game
02:54 - just so we have something to put pieces
02:56 - into
02:56 - so we have our board we have our game
02:58 - over variable and now we're going to
03:00 - want to be able to ask
03:04 - for player 1 input
03:08 - and then we're also going to want to
03:09 - eventually be able to ask
03:13 - ask
03:14 - for player 2 input
03:18 - so this kind of leads us to the problem
03:19 - of oh how do we differentiate between
03:21 - whether it's player 1 or player 2's turn
03:23 - so we're always going to define another
03:24 - variable up here called turn that's just
03:26 - going to initialize to 0. so what we're
03:28 - going to say is
03:29 - if turn
03:31 - equals equals zero
03:33 - then we're going to want to ask for
03:34 - player one input
03:36 - all right so in python there's a
03:39 - function a built-in function called
03:40 - input as you can see it highlights blue
03:42 - for me
03:43 - so
03:44 - we're gonna say
03:46 - selection equals
03:49 - input and then
03:52 - we're gonna say player one
03:56 - make your selection so this is what the
03:58 - player one is gonna see and then the way
04:01 - we're going to initialize this game is
04:02 - we're going to just say they can type in
04:03 - between 0 and 6. so
04:06 - this is what the
04:07 - player 1 should see so if i build this
04:10 - you see we run into this error
04:12 - so this is because um sublime text
04:15 - doesn't accept this input
04:17 - function
04:18 - so my work around for this was i
04:20 - installed a package in sublime called
04:22 - sublime repl i'll put a link in the
04:24 - description on how to install this
04:26 - and i can run
04:28 - the input function through that so now
04:30 - you can see player one make your
04:32 - selection three
04:33 - and it doesn't do anything with that
04:35 - input right now but you can see that
04:37 - it's asking me that and i can type in
04:38 - hit enter
04:40 - all right cool so we also just want to
04:42 - make sure that it saves our selection
04:45 - properly so we're going to print
04:48 - selection
04:49 - and i also just want to see you know if
04:51 - i type in a number does it actually give
04:53 - me the number
04:55 - or does it give me a string that
04:56 - represents the number so i'm going to
04:57 - also print in type of selection i just
05:00 - want to see what we're getting so i'm
05:02 - going to run that again and as you can
05:03 - see error again but we're going to go to
05:06 - slime rpl and the link is in the
05:08 - description as i just said run current
05:10 - files so
05:11 - two
05:12 - and as you can see it gets two but it
05:14 - says it's a string so we're going to
05:15 - want to make sure that it's actually a
05:18 - integer
05:19 - so we can just surround this with int
05:23 - input one and this should work so let's
05:25 - see
05:26 - run that again
05:28 - and you can also run this through the
05:30 - command line so if you run this in your
05:31 - terminal go to the the directory that
05:34 - the file is in and type in python and
05:36 - then file name it will also run just as
05:39 - i'm running it in this sublime repl
05:43 - player one make your selection three
05:45 - cool and now you see it says three and
05:47 - it says the class of that is an int so
05:49 - that looks good to me
05:51 - so
05:52 - now you can save some sort of selection
05:54 - from the user and you can also
05:57 - edit this so that it
06:00 - requires you to make a specific
06:02 - num type in a specific number but we'll
06:04 - just leave it as like we'll imagine our
06:06 - players are following the directions
06:08 - right now
06:09 - all right cool we have that and then
06:11 - we're also going to want to be able to
06:12 - ask for player 2's input so that's going
06:14 - to happen else otherwise so if the turn
06:17 - is not equal to zero
06:20 - um
06:21 - then we want to ask for player two input
06:23 - so selection equals
06:26 - and we'll just copy this from above
06:31 - and we'll just have to change this to
06:32 - say player two make your selection
06:35 - all right
06:37 - cool
06:38 - and now at the end of the turn no matter
06:40 - whose turn it is we're gonna want to
06:42 - increase
06:43 - um
06:44 - our turn by one so turn plus e or plus
06:47 - equals one so i'll make it increment it
06:50 - by one and then we're also what we're
06:52 - going to also want to do is
06:54 - we're going to just make this odd even
06:56 - so
06:57 - we're going to use mod division so it's
06:59 - going to be turn mod to turn equals
07:03 - turn
07:04 - mod
07:05 - 2 and this is just basically making it
07:08 - go uh take the remainder of whatever our
07:10 - turn is divided by 2.
07:13 - so this is just going to alternate it
07:14 - between 0 and 1. so it will alternate
07:17 - between player 1's turn and player 2's
07:19 - turn so
07:20 - let's just see if this works properly so
07:24 - we're going to run this
07:26 - build python current file
07:29 - player one make your selection two
07:31 - player two make your selection four
07:32 - player one make your selection two oh
07:34 - that looks good it's alternating between
07:35 - our player one and our player two
07:38 - cool
07:39 - okay and now we're gonna wanna start
07:41 - building our actual functionality we're
07:42 - gonna wanna be able to make this
07:44 - selection right here actually drop a
07:46 - piece into our board
07:48 - so i'm going to find another function up
07:50 - here called
07:52 - definition drop
07:54 - piece
07:56 - and we might define a couple functions
07:57 - so maybe have a drop piece and then
07:59 - we'll just do pass for now and maybe
08:01 - we'll also have like
08:03 - is valid location
08:05 - so that will check whatever number that
08:07 - the
08:09 - player typed in we'll check to see if
08:11 - that's a valid location
08:14 - we'll also define a function called get
08:17 - next
08:18 - open row
08:20 - and how all these functions are going to
08:21 - work together is as follows so it all
08:24 - begins with the player making a
08:26 - selection the 0 to 6 here represents the
08:29 - column that they want to drop their
08:31 - piece in so maybe a more appropriate
08:33 - title for this would be
08:34 - col representing column
08:37 - col
08:38 - next we're going to take this column and
08:40 - the current board we have
08:42 - and pass it into this is valid location
08:45 - function so board column
08:48 - and to visualize how we can check to see
08:50 - if the column they selected is a valid
08:53 - location
08:54 - we will
08:55 - print out the board real quick
09:02 - so as you can see
09:05 - imagine this is the
09:07 - zeroth row is the first row second row
09:10 - all the way up to the fifth row here and
09:11 - then this is the zeroth column first
09:14 - column second column etc we're starting
09:16 - at zero as our first index
09:19 - so if we wanted to check if the column
09:22 - that the user selected let's just assume
09:24 - that the user always types in a valid
09:26 - number zero to six if we wanted to check
09:28 - to see if it's valid all we need to do
09:31 - is make sure that this top row
09:33 - for that specific column is not been
09:36 - filled
09:37 - so
09:38 - let's imagine that we're putting ones in
09:40 - for player one going and two's in for
09:42 - player two going so if this top row
09:45 - is still zero for the specific column we
09:48 - selected then we know that it's okay for
09:51 - us to drop a piece in that row
09:53 - or in that column it hasn't been filled
09:55 - all the way to the top
09:57 - so to do that so this is the fifth row
09:59 - so all i'm going to do is just check to
10:01 - see whether or not
10:02 - the
10:03 - position at the fifth row and let's say
10:07 - you know whatever column we select is
10:09 - zero and if it is that means the column
10:12 - is still free if it's not then
10:15 - that's not a valid location we'll have
10:16 - to have the user try something else
10:19 - so to do that let's just do board
10:21 - so we're going to return
10:23 - board
10:25 - and then the
10:27 - the row is 5
10:29 - and the column is whatever the user
10:30 - selected so here
10:33 - so
10:34 - and we're going to make sure that's
10:35 - equal equals zero so if that's true then
10:38 - we're good to
10:40 - we're good to
10:42 - let them drop the piece there
10:44 - if that's not true then that means the
10:46 - column has been filled up all the way
10:48 - and one thing i'll note that will
10:50 - probably change in a future video is
10:51 - that it's kind of getting messy my code
10:54 - a little bit with just throwing these
10:55 - random numbers here all the way all over
10:57 - the place and programming these are
10:58 - called magic numbers you kind of don't
11:00 - know where they come from so i'll clean
11:02 - those up in
11:03 - some of the future videos in this series
11:06 - so return board five column equals
11:08 - equals zero and that is just checking to
11:10 - make sure that that column has an empty
11:12 - slot okay so now that we've gotten the
11:14 - valid location let's get the next open
11:16 - row in that column
11:20 - so if we think back to our board
11:22 - that's just checking to see when we drop
11:24 - it in let's say
11:26 - the zeroth column here on the the left
11:29 - checking to see which
11:31 - row of these if the piece will fall on
11:35 - so to do this we're going to write a
11:36 - quick little loop
11:38 - so we're going to do
11:42 - for
11:44 - and we're gonna also have to pass in
11:47 - the board and the column into this one
11:50 - so the loop we're gonna write here is
11:52 - for r and range
11:55 - and i'm actually going to start
11:57 - getting rid of some of these magic
11:58 - numbers so i'm going to initialize
12:01 - a
12:03 - global variable called row count
12:06 - and often globals are capitalized just
12:08 - to show that or
12:11 - static variables that don't change or
12:12 - capitalize just to show that they're a
12:14 - non-changing variable so the number of
12:16 - rows we have is six and the number of
12:18 - columns we have
12:20 - is seven
12:22 - so i'm going to do for r so for row in
12:26 - range so the number of rows we have so
12:28 - row count
12:31 - we're going to check the board position
12:34 - we're going to see
12:37 - if board
12:39 - r
12:41 - position or so the column
12:44 - equals equals zero
12:47 - then we want to return that row so
12:50 - basically if the row is equal to zero so
12:53 - imagine we're filling this whole board
12:55 - up with ones and twos
12:57 - if the slot is still zero that means
12:59 - it's empty still so we're going to
13:01 - return the first instance that it's
13:03 - empty so
13:04 - this
13:05 - r is going to count from zero to uh
13:08 - row count minus one
13:11 - and we're going to return that first
13:12 - case where it equals zero
13:16 - okay so now we've got the next open row
13:17 - and then finally what we're going to
13:19 - want to do is drop the piece so this is
13:21 - going to take in the board
13:23 - the row
13:24 - and the column and then we'll also add
13:26 - something we'll just call it
13:28 - the piece so whether it's player one or
13:31 - two going so
13:33 - all this is going to do is go
13:35 - board
13:37 - row
13:38 - column
13:40 - equals equals the piece
13:42 - so we're going to make it fill in
13:45 - the board with whatever piece that the
13:47 - player just dropped so let's put this
13:49 - all together in our loop so first
13:52 - we got the column and now we're going to
13:53 - check
13:55 - if is valid location of the board
13:58 - in the column
14:00 - and then we can start getting the next
14:02 - empty row so row equals get next open
14:05 - row
14:06 - and that takes in the board and column
14:08 - as well so
14:09 - get next input and row
14:11 - board
14:12 - column
14:14 - and then we're going to finally drop
14:16 - piece
14:17 - and we're gonna take in the board
14:19 - the row the column and then for player
14:21 - one the piece is just the one
14:24 - and we're gonna copy this in
14:28 - to player two as well because player one
14:31 - and player two the functionality
14:33 - of what they're doing is the same but
14:35 - we'll just have to change the piece here
14:38 - to two so
14:40 - now and then finally probably after the
14:42 - player goes we'll probably want to
14:46 - print out the board so we'll print the
14:48 - board here
14:50 - and let's see what happens now so
14:54 - tools build
14:56 - oh shoot sorry supply more ipl python
15:00 - run current file so player one selection
15:02 - we're gonna drop our piece right in the
15:04 - middle so that's zero one two three this
15:06 - is the third column so three
15:10 - uh what happened why did it not fill in
15:12 - let's figure out what exactly went wrong
15:15 - there so
15:18 - should have updated the board but for
15:19 - some reason it did not
15:21 - um so let's see
15:26 - okay i see what i did wrong here so
15:30 - i accidentally put in
15:32 - two equal sign here and what we're
15:34 - really trying to do is an assignment
15:35 - we're not trying to set see if the
15:37 - boardrow column position is equal to
15:40 - that so i didn't assign it so now it
15:42 - should work so
15:44 - we'll rerun this so tools supply maripl
15:49 - python run current file player one make
15:52 - your selection
15:53 - we'll say go to the middle three
15:56 - player two make your selection we'll do
15:57 - three as well
15:59 - player one make your selection and as
16:00 - you can see one issue we're having right
16:02 - now is that the pieces are
16:04 - starting at the top and going downwards
16:06 - and so the reason for this is
16:08 - our convention was to say that this was
16:10 - the zero zero index
16:12 - but
16:13 - in the actual numpy
16:15 - they represent this right here as the
16:17 - zero zero index
16:19 - so i'm just going to add an additional
16:21 - function real quick called
16:24 - print board
16:25 - and all that's going to do
16:27 - is change the orientation
16:29 - so that what we're seeing is actually
16:30 - the
16:31 - they flipped over the way we're
16:33 - expecting to see a connect 4 board kind
16:35 - of be building
16:36 - from bottom up
16:38 - so print board and we just need to pass
16:40 - in the board and all we're going to do
16:41 - is
16:42 - there's a command
16:44 - in dumpy
16:46 - so the command is
16:50 - let me just remember it it is
16:52 - np.flip
16:55 - i'm going to do
16:57 - board and then you have to flip it over
17:00 - you have to specify the axis so the 0 is
17:01 - the axis we're going to flip the board
17:05 - over the
17:06 - x-axis
17:08 - so that should get it upside the right
17:10 - side up again so instead of doing
17:13 - a print board here we're going to now
17:14 - call our new print function so print
17:17 - board
17:18 - and then board
17:21 - and we can also do that
17:22 - down here if we want to
17:24 - print
17:27 - it doesn't matter i guess to start but
17:28 - print board whatever
17:30 - okay now let's run it again
17:33 - tools it's primary pl python run current
17:36 - file
17:37 - player will make your selection three
17:39 - three
17:40 - three and as you can see now it's
17:42 - building up from with ones and twos
17:45 - just how we expect
17:49 - the one problem with this is that if i
17:52 - actually won this game so as you can see
17:55 - i just went with player one down the
17:56 - bottom
17:57 - the game doesn't let me know at all that
17:59 - i won so we need to implement that
18:01 - functionality so we're going to define a
18:03 - function called
18:05 - winning
18:07 - move
18:09 - and we're going to have that taking the
18:11 - board and then the last piece that was
18:14 - dropped
18:17 - so winning move there's a bunch of
18:18 - different ways to implement this
18:20 - and
18:21 - the way we're going to do
18:22 - is not the most efficient method but
18:24 - it's probably the easiest to describe in
18:26 - a video so that's kind of why i'm
18:28 - selecting it but we're going to manually
18:30 - check all the different
18:32 - possible places you could win in connect
18:35 - four so all the horizontals all the
18:37 - verticals and all the diagonals
18:39 - and check to see
18:41 - if there is a winning combination on the
18:43 - board
18:44 - and because we're doing this after every
18:46 - turn we're going to pick up the first
18:47 - instance of that winning combination so
18:50 - we'll know who won
18:52 - probably the more practical way would be
18:54 - to just check around the spaces where
18:57 - the last piece was dropped but that code
19:00 - got a little bit messier when i was
19:01 - doing it before so i'm going to just do
19:03 - it this way so we're going to first
19:05 - check
19:06 - all the horizontal
19:08 - locations
19:13 - and to do that we'll have a loop that
19:15 - iterates over the columns so for c in
19:19 - ca range
19:21 - column count and so we defined a column
19:23 - count up here above and that's seven
19:26 - and one thing uh i think would be a cool
19:28 - challenge for you guys to try that i
19:30 - don't think my game is going to be able
19:32 - to do at this point in time is a very
19:34 - well designed like connect four game you
19:36 - would be able to change these numbers so
19:39 - like i could change it to say like 12 or
19:41 - something
19:42 - and this to like eight
19:44 - and the game would still be able to work
19:46 - you still have like a connect four game
19:47 - but just a bigger board and so that's a
19:49 - kind of a cool
19:51 - way to make sure like you've designed
19:52 - things
19:53 - in a smart way where you don't have just
19:56 - these random like magic numbers popping
19:57 - up all over the place and i'm actually
19:59 - going to change this real quick to row
20:01 - count
20:02 - and
20:04 - column count just because i'm going to
20:06 - try to eliminate the magic numbers where
20:08 - i can and we'll clean this up to
20:11 - uh row count
20:13 - minus one so this is the last row the
20:15 - left index of the last row okay getting
20:18 - back to winning move so
20:20 - we want to check horizontal locations
20:22 - for the win so we're going to first loop
20:23 - over all the
20:25 - columns and then we're also going to
20:27 - have a loop over all of the
20:30 - rows
20:31 - and what this loop is going to be over
20:33 - is not
20:34 - every single position but over all the
20:37 - possible starting positions for a
20:40 - horizontal wind
20:41 - so if we think about our board a
20:43 - horizontal wind can start
20:46 - this spot this spot this spot and this
20:48 - spot it can't start here because you
20:50 - can't go
20:51 - four over from this uh location so
20:55 - this is our last column the third column
20:58 - in terms of indices and then
20:59 - upwards we can go all the way to the top
21:02 - vertically because it can so
21:05 - this half sorry you can't really see but
21:08 - we're making a box around that half is
21:11 - where our starting locations can be for
21:13 - this first
21:14 - um
21:16 - this first check so we're iterating over
21:19 - the columns so it can only be
21:21 - the number of columns and then we have
21:23 - to subtract three because three of those
21:25 - columns
21:26 - couldn't actually work
21:28 - so we're subtracting three off of that
21:30 - one and then all the rows could work so
21:32 - that's totally fine so now we're going
21:34 - to check
21:35 - all the
21:36 - four in a row location so
21:39 - this is going to look like something
21:40 - like this so
21:42 - if
21:43 - board
21:45 - row
21:47 - column so this is just indexing the
21:49 - matrix
21:51 - equals equals piece
21:54 - and
21:55 - board
21:56 - row
21:58 - c plus one so this is
22:01 - taking the next one to the right so
22:03 - we're checking horizontally so we're
22:04 - only changing the columns equals equals
22:07 - piece
22:08 - and board
22:10 - our c plus two
22:14 - equals equals piece
22:16 - and then finally and board this is the
22:19 - fourth
22:20 - piece in a row board
22:23 - c plus three equals equals
22:27 - peace
22:31 - then we're going to return true
22:35 - so we want to return true the first time
22:37 - this happens we're not going to return
22:39 - this expression because that would
22:42 - return that would break out of this loop
22:43 - before we wanted it to
22:45 - okay and so what
22:47 - we write again this is not the mo the
22:49 - best way probably to write it you know
22:50 - we have these magic numbers popping up
22:53 - but it's just a very simple way to check
22:55 - for all those horizontal locations right
22:57 - so let's do the same thing with
22:59 - vertical locations
23:02 - locations for when
23:06 - and actually before i do that let's just
23:08 - uh check to see if we can get some
23:10 - functionality
23:11 - on this so if validation we're gonna
23:13 - also write a
23:15 - if statement that says if
23:17 - winning
23:18 - move
23:21 - and
23:23 - so we're going to say
23:26 - board and then the piece is one
23:30 - so if it's winning move we're gonna just
23:32 - print out
23:34 - uh player
23:37 - one
23:38 - wins
23:40 - congrats
23:41 - yay
23:45 - okay let's just see if that works with
23:46 - the horizontal real quick and then we're
23:48 - also going to want to set this game over
23:50 - variable
23:52 - uh to true because the game is in fact
23:54 - over if the move is winning so let's
23:56 - just run that real quick
23:59 - python run current file okay player one
24:02 - make your selection three
24:10 - yay it says player one wins and we i
24:12 - guess accidentally printed the board out
24:14 - one extra time but you know we did get
24:17 - that functionality it did check that
24:18 - horizontal wind so i think that looks
24:20 - good
24:21 - obviously
24:22 - um
24:23 - you'd want to test these like very
24:26 - thoroughly
24:27 - but for the sake of the time of this
24:29 - video i'm going to just start going to
24:31 - the horizontal the vertical location so
24:34 - think about where vertical locations can
24:36 - start
24:37 - um
24:38 - can start
24:39 - we need four up so it can start it's
24:41 - pretty much the opposite of the
24:43 - horizontal so vertical could start
24:46 - all of this bottom section because we
24:49 - need four up but it can be in any column
24:51 - so it's gonna be pretty similar to the
24:53 - last
24:54 - loop but we're gonna have to change the
24:56 - row
24:59 - so you'll see in a sec shift tab tab
25:05 - we're gonna have to change
25:06 - instead of the column count doing uh for
25:09 - c and column count minus three we're
25:10 - gonna have to do row count minus three
25:12 - because we can't start at the top row
25:15 - and then we're gonna have to add these
25:17 - pluses to the rows actually
25:21 - row plus one
25:24 - row plus
25:26 - two and the last one is
25:30 - row plus three and
25:32 - once again like
25:34 - see if you could figure out how to
25:36 - manipulate this
25:38 - um these equations to work for
25:41 - any length of a board and also let's say
25:44 - maybe we wanted to make a game that was
25:45 - like connect six like it would be a cool
25:47 - challenge for you guys to try to
25:49 - build these functions so that they could
25:51 - be any
25:53 - number of columns any number of rows and
25:55 - any number of
25:57 - pieces for the winning length okay so
25:59 - let's check to see if the vertical
26:00 - locations now work we're going to run
26:02 - this again
26:03 - real quick
26:04 - so tools
26:07 - python
26:08 - current file
26:10 - three
26:15 - cool it works again so we see you have
26:18 - the four in a row with the ones right
26:20 - here and it says player one wins
26:21 - congrats
26:22 - so that looks good
26:24 - uh now we have to get to the little bit
26:25 - of the trickier
26:28 - um
26:28 - things we're gonna have to check for the
26:32 - first we'll check for the positively
26:37 - sloped diagonals
26:40 - and we're also going to
26:43 - make a separate method to check for the
26:46 - negatively sloped
26:49 - and you'll see why we need to do this in
26:51 - a sec diagonals
26:55 - all right so let's think about it we're
26:57 - going to think about it the same way
26:58 - where are our possible starting
27:00 - locations
27:01 - that we could have a positively sloped
27:04 - diagonal
27:05 - well we can start here and go up we can
27:07 - start here and go up here and go up
27:10 - so i think the last piece we can start
27:13 - here and go up so this is going to be
27:16 - the top row
27:17 - and we can't go any farther than this
27:19 - piece right here so that looks like
27:21 - we're doing
27:22 - row count minus three and column count
27:24 - minus three
27:27 - so
27:30 - all right
27:32 - so we're gonna we'll just copy this code
27:34 - see oh no what happened
27:37 - see and i'll paste that in right here
27:40 - all right so we're gonna have to
27:41 - subtract three from column count and
27:43 - from row count and then how this is
27:45 - going to increment is you start with
27:47 - that initial starting location and then
27:49 - we need to plus one
27:51 - to both things because it's a
27:54 - slope it's not just a horizontal or
27:56 - vertical now so we have to
27:58 - do the addition step for both of these
28:02 - okay cool and as we've been doing let's
28:04 - just check to see if we can get a
28:06 - diagonal win here
28:10 - so player one maker selection i'll just
28:11 - start in the
28:23 - all right we're almost there
28:30 - uh so close
28:32 - don't screw this up now keith okay and
28:35 - we'll check here
28:37 - cool the diagonal there worked so that
28:39 - looks like it's working too
28:42 - and then finally we need to do the
28:43 - negatively sloped diagonals
28:48 - and so if we think about negatively
28:50 - slope diagonals they can start at the
28:52 - top and go downwards
28:54 - but they couldn't start any lower than
28:56 - this right here this is the the last one
28:59 - they could start at because they have to
29:01 - go down four
29:02 - so
29:03 - that looks like it would be
29:05 - the top rows
29:07 - and then also
29:09 - the
29:11 - columns minus three so we're going to
29:13 - start the rows at three
29:15 - and we're going to have to start the
29:18 - columns in the normal normal location so
29:21 - this is going to start from
29:23 - three to
29:25 - the row count
29:27 - and so it's three because
29:29 - if you think about it z this is the
29:31 - zeroth row
29:32 - this is the first row second row
29:35 - third row so even though it's actually
29:37 - the fourth up it's third index so that's
29:39 - why we're starting at three
29:41 - and that's going to go all the way to
29:42 - the top and the column count is actually
29:44 - good as it is and so this is going to
29:46 - have to now go
29:48 - it's going to go
29:50 - positively over in the column direction
29:52 - but it's going to go down a row so
29:54 - negative 1 here
29:57 - negative 2 here
29:59 - and this is just a negative slope you
30:01 - you know you have one direction positive
30:03 - one direction negative
30:05 - and this will be
30:06 - negative three so let's test to see if
30:08 - this works come on
30:11 - rpl python
30:14 - current file
30:17 - okay
30:18 - we'll just build up the left side first
30:27 - okay
30:28 - two
30:31 - okay
30:34 - okay okay okay we're almost into the
30:36 - negative diagonal there so player one
30:38 - you can go three
30:40 - and then player two
30:42 - two and then two
30:44 - cool the negative diagonals work now too
30:46 - okay so that looks like we have all the
30:48 - possible winning directions you should
30:50 - more thoroughly test to make sure the
30:51 - all the edge cases work but to me that
30:54 - looks pretty good so we're also going to
30:57 - implement the functionality for
30:59 - player 2 in this main game loop
31:04 - okay so this is player two
31:07 - player two wins congrats game over true
31:11 - okay
31:13 - and if you wanted to you could just
31:15 - break out of the
31:17 - the loop
31:19 - if you didn't want to see this board and
31:20 - the turns changing at the end okay so
31:23 - that's
31:24 - we've now finished the
31:26 - command line version of the game
31:31 - so we're going to take this game
31:34 - and we're going to expand on it to
31:35 - actually make it look nice so the first
31:37 - thing we're going to do to do that is
31:38 - import a library called pie game
31:42 - and just like the numpy library if you
31:44 - don't have pi game installed just open
31:45 - up a new terminal window and type in pip
31:47 - install pi game
31:50 - as you can see i already have it
31:52 - cool
31:53 - all right and now what we're going to do
31:54 - is we're going to have to start out by
31:56 - initializing pot pie game so this you
31:58 - have to do in any pie game project so
32:00 - before our game loop starts we're going
32:02 - to do pie game dot init
32:09 - okay
32:10 - and then what we're going to have to do
32:11 - is define our screen size how big do we
32:14 - want our game to be
32:15 - so
32:16 - if i real quick just build the finished
32:18 - version i have
32:20 - you can see that you know it's
32:23 - pretty
32:24 - you know you can kind of break this game
32:26 - down into squares i would say you have
32:29 - squares that represent each column in
32:30 - each row
32:32 - and then i have this one extra row at
32:34 - the top
32:35 - so we're going to define each one of
32:36 - those squares
32:38 - as
32:40 - 100 pixels so
32:42 - the sizes we're going to talk about
32:43 - right now are all in pixels so the
32:45 - square size is going to be 100 pixels
32:48 - and then our width
32:49 - for our screen is going to be
32:51 - the number of columns so the column
32:53 - count
32:54 - times the square size
32:57 - cool
32:58 - and the height
33:00 - is going to be the row count
33:02 - times the square size
33:05 - and actually if you saw my
33:07 - the game i just dragged in i'll drag it
33:08 - in one more time
33:11 - i actually added one additional row
33:13 - because i wanted this spot where i could
33:15 - display this circle that i'm dropping
33:18 - so we'll actually make this row count
33:20 - plus one times square size for the
33:23 - height
33:25 - and that will be packaged together
33:27 - nicely in a variable called size which
33:29 - will be a tuple of width comma height
33:32 - and then to get pygame to actually read
33:34 - that we need to type in the following
33:37 - screen
33:39 - equals pie game dot display dot set
33:43 - mode
33:45 - and then
33:46 - we'll
33:47 - have it read in the size
33:50 - and if you're wondering where i'm kind
33:52 - of just magically getting these
33:53 - functions from i'm looking at the
33:56 - documentation on the pi game site so if
33:58 - you go to pygame.org docs you can find
34:02 - all the kind of functions that i'm using
34:04 - i'll post a link to that in the
34:06 - description
34:13 - i'm going to real quick test to see our
34:14 - screen is actually working so you can
34:16 - just
34:17 - run control b
34:19 - and as you can see the window popped up
34:20 - and then it disappeared we'll handle why
34:23 - it's disappearing in a second
34:25 - so it looked like though it is reading
34:27 - in that screen
34:28 - cool so let's now create a function
34:31 - called
34:34 - do a couple things
34:35 - so i think first we'll define a function
34:37 - called drawboard
34:39 - and this will just be like print board
34:41 - that we defined up here but now we're
34:43 - actually going to draw it with the
34:46 - pi game graphic so draw board is gonna
34:48 - have to take in the board and that's
34:49 - about it and i'll actually pass this for
34:52 - now because we're gonna make some
34:53 - changes to our loop before we
34:55 - do this draw board
34:57 - so the first major change we're going to
34:59 - do to our loop
35:01 - is pi game is an event based
35:03 - game library
35:05 - so pi game kind of works and allows you
35:07 - to function in the game by just reading
35:10 - all of your movements of your you know
35:12 - the keys you press the mouse buttons you
35:14 - click the mouse like how you move your
35:16 - mouse it reads those all in as
35:17 - individual events so that looks like
35:20 - something like this so for event
35:22 - in pygame dot event dot get
35:26 - and as i just said events are like mouse
35:28 - motion mouse button down key down
35:31 - etc
35:34 - so we're going to read in we're going to
35:36 - drop a piece by clicking down so that's
35:38 - one of the important events we'll have
35:39 - to get
35:41 - so we're going to first do just kind of
35:44 - follow me on this one event type
35:46 - if event type equals equals pie game dot
35:49 - quit
35:51 - so this is just something you want to
35:52 - handle in all of your games that you
35:53 - make
35:54 - just allowing your game to properly exit
35:57 - out if you click the button here in the
35:59 - top right that x out x is out of it so
36:02 - if that happens
36:04 - we have to do a system exit just so it
36:06 - properly shuts down
36:08 - and to get this cis right here we're
36:10 - gonna have to import that into our
36:11 - project as well that means system and
36:13 - that comes default in any python
36:15 - installation
36:18 - okay
36:19 - system exit now to get to the more
36:21 - interesting stuff
36:23 - the event that we really are gonna care
36:25 - about to start is
36:29 - mouse button down so if event dot type
36:31 - equals equals pie game dot mouse button
36:36 - down and all the different events you
36:37 - can also find on the
36:39 - pie game website under the docs
36:43 - the game is going to run by us
36:46 - clicking down on a specific spot on the
36:48 - screen where we want to drop the piece
36:51 - so instead of reading in the column we
36:53 - want to drop it in as we did previously
36:55 - now this column is going to be populated
36:57 - by where we click
36:59 - so i'm going to real quick
37:01 - put all of this stuff all this behavior
37:04 - into this mouse button down event type
37:07 - because now the events of us dropping
37:10 - the piece always happen when we click
37:11 - the mouse button down so we don't want
37:13 - it to happen otherwise we don't want it
37:14 - to be asking for this input
37:16 - alright so column equals
37:18 - and this is going to be where we click
37:20 - on the screen so just
37:22 - for now i'm going to
37:26 - just kind of comment out this stuff just
37:28 - so it doesn't run on us while we're
37:30 - testing
37:32 - control
37:33 - and that's just real quick see if this
37:35 - fixed our error of
37:38 - the screen disappearing right when it
37:40 - pops up
37:42 - ah what happened
37:52 - print
37:56 - and as you can see now we have this
37:58 - screen and it's
38:00 - not
38:00 - you know it's staying here so that's
38:03 - because we actually added in this event
38:05 - loop here
38:06 - it knows to kind of continue while these
38:08 - events are happening and the exit out
38:10 - will be handled properly by this the
38:12 - system exit cool
38:14 - all right so
38:15 - we have our screen looking pretty good
38:17 - but doesn't have any
38:19 - graphics obviously
38:25 - so we're going to implement the
38:26 - drawboard function now
38:29 - so if we think about it
38:31 - i'll drag in the finished one i have
38:33 - again
38:34 - we're going to draw
38:36 - some sort of
38:37 - rectangle for each of these slots and
38:40 - then a black circle inside those
38:42 - rectangles
38:44 - and then we'll have to draw this
38:45 - afterwards this piece that we drop and
38:47 - then whenever we do drop a piece
38:49 - the the one or two that's in our command
38:51 - line based game will become like a red
38:53 - circle or a yellow circle based on
38:56 - what we're doing so
38:58 - let's uh implement this
39:02 - so
39:05 - first we're going to iterate through
39:08 - kind of every spot in our board so for
39:11 - r
39:12 - or for
39:13 - we'll say c in
39:15 - range
39:17 - column count
39:19 - and then we'll do the same thing for
39:21 - r and range
39:24 - row
39:26 - count just as we did above here when
39:29 - we're editing through all the the spots
39:32 - well
39:33 - we need to initially just draw it as
39:35 - like an open
39:38 - you know a
39:39 - blue blue rectangle and then in that
39:41 - blue rectangle we want a black circle so
39:44 - we're going to
39:45 - do a pie game.draw function so first
39:48 - we're going to draw a
39:49 - blue rectangle
39:52 - so that looks like kind of our game
39:54 - board and then the black circle inside
39:56 - of that will be the open slot
39:58 - so we're going to draw that on the
40:00 - screen and i'm going to drag in again
40:02 - the
40:03 - the light the library so i can see
40:06 - exactly what i'm doing so as you can see
40:08 - here pygame.dry wrecked we need to take
40:11 - in the surface the color
40:13 - the rectangle we want to draw
40:15 - and then the width
40:17 - so
40:18 - the screen is the surface we want to
40:20 - draw it on the color is we want a blue
40:22 - color so i'm going to define blue as a
40:25 - global variable a global static variable
40:27 - up above this is going to be an rgb
40:29 - value so we're going to say it's 0 0
40:33 - comma 200 and that means or 255 or so so
40:36 - that's going to be a very blue
40:38 - um
40:40 - rgb value because this means red this
40:42 - means green and this means blue and the
40:44 - only color that's
40:45 - actually has some value is the blue here
40:48 - so the color we're going to say is blue
40:50 - we just defined that that's the rgb
40:52 - value now we need to find our rectangle
40:56 - so our rectangle
40:57 - is going to be
41:00 - the you need to have four different
41:02 - things to define your rectangle you need
41:04 - to have
41:05 - the size of the width and height and
41:07 - then also the position
41:10 - so the position is going to be this
41:12 - might be take a little playing around
41:13 - with to get this but it's going to be c
41:16 - times so these are numbers 0 to
41:19 - you know the column count and zero to
41:21 - the row count there's gonna be c times
41:24 - square size
41:26 - because we want the actual this is the
41:28 - top left corner of it
41:30 - and
41:32 - that's going to the
41:43 - and then our
41:44 - position on the y-axis is going to be r
41:47 - times the square size
41:53 - and our height and width
41:56 - are going to be the other two parameters
41:58 - of this
41:59 - what that make up a rectangle object and
42:01 - that's just going to be it's going to be
42:03 - a square so it's square size square size
42:05 - height and width are the same
42:07 - and the width op argument that i showed
42:10 - was in the documentation as you can see
42:12 - it's defined as 0 so that's optional i
42:15 - think that's just the
42:16 - outline like uh the line that surrounds
42:19 - the square so we don't need to implement
42:21 - that all right let's test to see if just
42:23 - these rectangles draw properly so
42:26 - down here we'll just do a
42:29 - draw a board
42:31 - taking the board
42:33 - um as we did here and then what we have
42:35 - to do whenever we want to update our
42:37 - display is do pi game dot display dot
42:40 - update and that will make sure that we
42:41 - actually see what we're supposed to see
42:43 - so we'll build that real quick
42:45 - oh and as you can see we have this just
42:47 - giant mound of blue and the one problem
42:50 - i see right now is it's not actually
42:51 - opening up the i wanted the top to be
42:53 - open so we could have a piece that uh
42:55 - swings around it so it shows us where
42:57 - we're dropping it
42:58 - so i think the problem with that is
43:00 - because our axis starts at zero zero
43:02 - we actually need to
43:04 - to shift down by one square size to kind
43:07 - of account for that
43:09 - offset that we left for that space so
43:12 - we're gonna have to add a square size
43:14 - here
43:16 - now we build this again and as you can
43:18 - see it looks proper
43:19 - now we'll need to fill in some circles
43:21 - to represent the
43:23 - the slots
43:25 - so we'll do that by drawing a circle in
43:27 - pi game and that's also in the
43:28 - documentation so we go
43:29 - pygame.draw.circle
43:33 - and that's going to take in the surface
43:35 - of a screen
43:36 - and now we need a color
43:38 - so i think a good color
43:41 - would be just black so we'll define
43:43 - black up above too
43:45 - and black in rgb is just zero everything
43:49 - zero
43:50 - zero zero
43:53 - okay so this is black
43:56 - and then let's drag in the documentation
43:58 - real quick to see how we're going to
44:00 - finish off this circle so circle circle
44:02 - circle
44:04 - okay position and then radius so this is
44:06 - going to be the position of the center
44:08 - of the circle as you see in the
44:09 - documentation and the radius will
44:10 - probably want to be a little bit smaller
44:12 - than our square size just so there's
44:16 - the circles aren't touching
44:18 - so let's define a radius 2.
44:21 - so our radius is going to be
44:25 - define that under
44:26 - the width and height and whatnot so our
44:29 - radius is going to be
44:31 - a little bit less than the square size
44:33 - so
44:34 - we'll do i'm going to make this also
44:36 - they have to be integer values i believe
44:38 - so once we start getting into division
44:40 - it might get a little bit messy so it's
44:42 - going to be int square size
44:45 - divided by 2 because it needs to be the
44:47 - radius is half the diameter and the
44:49 - diameter would be the full square size
44:51 - then we'll just minus an arbitrary like
44:54 - integer value off of that
44:57 - so now we can draw our circle with that
45:00 - radius
45:01 - but we'll have to do the position first
45:04 - so the position
45:05 - where is it i forget oh it's in
45:07 - dropboard
45:09 - the position is going to be so if this
45:10 - is the top left of the rectangle
45:14 - our position for the center of the
45:15 - circle is going to have to
45:17 - be that
45:19 - and then with some offset
45:21 - so square size then r times
45:25 - square size
45:26 - plus square size
45:30 - and the offset is going to have to be
45:31 - like half of it because we're talking
45:33 - about the radius so half of the
45:35 - rectangle is going to be
45:37 - adding an additional square size
45:40 - divided by 2.
45:45 - adding a square size
45:48 - divided by two
45:50 - all right let's see what happens now oh
45:52 - and then actually we're gonna have to do
45:53 - the
45:54 - actually specify the radius so the
45:55 - radius is what we defined just a second
45:57 - ago
45:58 - build
46:00 - what happened uh
46:02 - yeah integer argument expected
46:04 - okay so it looks like this division
46:06 - caused us to have some floats in our
46:08 - code so we're gonna have to actually
46:09 - make this int
46:10 - yeah pi game it seems like only accepts
46:13 - integers so make sure that everything
46:15 - you
46:16 - every position and radius
46:18 - value you make a integer
46:21 - come on baby let's go
46:26 - cool yeah we got a board
46:30 - we'll finish implementing this graphics
46:32 - we'll implement the piece dropping and
46:34 - then a nice little piece follower up
46:36 - here
46:37 - so to start this video
46:39 - navigate down to the main game loop
46:43 - before when we were selecting which
46:44 - column we wanted to drop a piece in
46:47 - we mainly typed in a number between 0
46:49 - and 6 to specify this
46:52 - now that we have a graphic
46:54 - we want the column that we dropped the
46:56 - piece in to be dependent on where we
46:58 - click so if i click on the left side of
46:59 - the screen
47:01 - we want it to drop the piece in the left
47:02 - column if i click the middle the middle
47:04 - column etc
47:06 - so where we drop the piece depends on
47:08 - the x position
47:11 - of our mouse pointer
47:13 - so luckily for us pygame makes
47:16 - using the getting the x position of your
47:18 - mouse
47:19 - super easy
47:21 - so if you go to the pi game
47:23 - documentations under the events
47:26 - it lists all of these events and then it
47:27 - lists the properties you can get on
47:29 - these events so for us we care about
47:31 - mouse button down
47:33 - and we care about
47:35 - the position so position gives us an x
47:37 - comma y tuple
47:39 - of where we clicked
47:42 - and i can use that as follows
47:44 - so i can do print
47:46 - event dot position
47:49 - and then i can rerun our game and so as
47:52 - i click on the screen you'll be able to
47:53 - see in the bottom left the
47:55 - positions where i'm clicking so if i
47:58 - click in the top left of the screen it's
48:00 - about zero comma zero that's where our
48:02 - axis starts if i click on the bottom
48:04 - right of the screen that's the
48:06 - the full dimension of our game and we
48:08 - specified that to be 700 700 so these
48:11 - are the pixel values of where we're
48:13 - clicking
48:16 - to develop a
48:18 - kind of way to select the column based
48:21 - on where we click we need to try to find
48:22 - a pattern on clicking in these different
48:26 - columns so i'm going to do that real
48:28 - quick
48:29 - and if we look at all these clicks i
48:30 - just made we can see the first click is
48:33 - between 0 and 100 second click is
48:35 - between 100 and 200
48:38 - 200 and 300 etc so the last column is
48:41 - between 600 and 700 so we can somehow
48:44 - round these numbers down to just give us
48:46 - zero to six we're back at where we were
48:49 - when we mainly typed in those numbers
48:52 - so we're going to do that real quick so
48:54 - let's we can go ahead and uncomment
48:57 - all this code and actually this is
48:59 - supposed to be a comment so we can
49:00 - uncomment
49:02 - this code right here and we can just
49:04 - comment this out for now
49:07 - so
49:08 - column so we want that to be
49:12 - we'll say that the x position so this is
49:14 - a tuple in the x values first so the
49:17 - position of x
49:18 - is equal to event dot position and then
49:22 - it's the zeroth element of that
49:27 - the column now is going to be so this is
49:29 - between 0 and 700.
49:33 - so the column we can get using we're
49:36 - going to also just to make this our
49:37 - lives easier we're going to import a
49:38 - library called math this comes default
49:40 - in any python installation
49:43 - so we are going to get what we want to
49:46 - drop it by doing
49:54 - position x
49:56 - then
49:57 - we're gonna divide everything by a
49:58 - hundred because this would give us a
50:00 - range between zero and seven instead of
50:03 - zero in seven hundred so the first thing
50:05 - we're gonna do is divide it by a hundred
50:08 - and a hundred remember is what we define
50:10 - our square size sizes so to make our
50:11 - code a little bit more robust to changes
50:14 - we're going to do position x divided by
50:16 - square size
50:18 - and then we want this to be a whole
50:21 - number an integer value so we're going
50:22 - to have to take the floor of this
50:24 - division so that will round it down to
50:26 - the nearest integer so we're going to do
50:29 - math.floor
50:32 - and then the final change we're going to
50:34 - have to make
50:35 - is we just need to make sure that the
50:37 - column is an integer
50:39 - because we don't we can't take the index
50:41 - of a float value of decimal value so
50:44 - we'll just
50:45 - ensure that it's integer by just
50:46 - surrounding it with an int
50:49 - and now we should be able to see when we
50:53 - click on the screen we should see our
50:55 - board building up and we can copy the
50:57 - same thing for player two
50:59 - and we'll uncomment this
51:03 - comment that
51:05 - uncomment all of this and then we'll
51:08 - make player two be able to select the
51:10 - piece in the same way so
51:13 - we'll say position x equals event event
51:15 - opposition zero
51:17 - and then
51:19 - the column
51:21 - now
51:24 - oh my god messy
51:27 - okay we'll delete this line cool so
51:30 - let's see what happens when we build the
51:32 - game
51:33 - so now we have this uh where's the
51:36 - actual game window what happened oh it
51:38 - like didn't pop up for some reason
51:41 - so click down the middle
51:43 - if you can see over here in the bottom
51:45 - right our game did pick up that click so
51:47 - i click on the middle again
51:49 - keep clicking on the middle and it keeps
51:51 - reading that i'm dropping the pieces in
51:53 - so that looks really good now we
51:54 - actually have to just represent that on
51:56 - the screen
51:58 - so to do this we'll just make a small
52:00 - change to our
52:01 - draw board function that draws the
52:04 - graphics
52:06 - so navigate to drawboard
52:09 - and we'll just do a if statement here
52:12 - just say so the rectangle is always
52:15 - drawn the blue rectangles that make up
52:17 - the the board the black circle
52:19 - represents the empty square so
52:21 - if
52:23 - board
52:24 - i mean uh
52:25 - board
52:26 - row
52:29 - column
52:30 - equals equals zero then we want it to be
52:32 - a black we want it to be empty
52:35 - if
52:38 - else if board
52:40 - our
52:42 - row column so this is just indexing our
52:44 - matrix equals equals one so that's what
52:46 - we see here player one dropped it in the
52:49 - middle
52:50 - then we want to draw a circle so we can
52:53 - just copy this line because we know this
52:55 - is in the right position
52:57 - but we're just gonna have to change the
52:58 - color up
53:01 - so
53:02 - we don't want it to be black we'll just
53:03 - use red and yellow player one will be
53:05 - red so this is going to be red
53:08 - and this is not a built-in thing we're
53:10 - gonna have to define red
53:12 - so we'll define red right below black
53:15 - these are rgb values so r needs to be
53:18 - have a value and the other two can be
53:20 - zeros so this will give us a nice bright
53:23 - red
53:24 - and then while i'm up here doing this
53:26 - i'm also going to define yellow
53:28 - yellow is both red and green it's a
53:31 - combination of both red and green and
53:32 - rgb so 255 235 0.
53:35 - so now we have red and yellow for
53:38 - player 1 and player 2.
53:44 - where was that
53:45 - okay yeah it's red and then one last
53:48 - line
53:49 - which will be
53:53 - the else condition that'll be if board r
53:57 - comma or r c is two
54:00 - so that's going to be pi game well
54:02 - actually i'll just paste this in again
54:03 - pi game and then instead of black
54:06 - we'll make this one
54:08 - yellow
54:13 - and then one thing that might not be
54:15 - intuitive is that whenever we
54:18 - make changes to our
54:20 - game board
54:22 - after this is all done this loop has
54:23 - been iterated through we're going to
54:25 - want to call
54:26 - pygame.display.update that will
54:28 - re-render the screen with the new
54:30 - changes
54:32 - so let us let us and also we're going to
54:33 - have to add
54:35 - the drawboard we used we were printing
54:37 - board on every turn but we're going to
54:39 - draw a board
54:40 - here as well
54:43 - okay moment of truth clicking right here
54:47 - no what happened
54:50 - so it looks like it's populating it's
54:52 - just populating it in the wrong spot
54:54 - and the reason for this is because of
54:57 - how our axis is set up
55:00 - so
55:02 - as you recall when i click down on the
55:04 - top left this is the zero zero
55:07 - and this is the 700 700 space
55:11 - so
55:12 - in our game though this is the zero zero
55:16 - piece
55:17 - but it just kind of flipped so when we
55:19 - printed the board we called that np.flip
55:21 - function so we're just going to have to
55:23 - figure out a way to offset
55:25 - this to actually be on the bottom of the
55:27 - screen as opposed to the top
55:29 - so
55:30 - to do that
55:31 - we can just
55:32 - use our height smartly so what we really
55:35 - need to do is we're starting at the
55:37 - bottom
55:38 - so we need to subtract whatever we're
55:40 - actually trying to build up from the
55:41 - bottom
55:42 - from our height so height
55:44 - minus this
55:46 - height
55:49 - minus this let's try running this
55:54 - what is happening
55:56 - all right
55:57 - so we still having our issue and the
55:59 - reason we're now having an issue is
56:01 - because this
56:03 - piece right here is still filling in the
56:04 - old fashioned way so they're kind of
56:06 - like filling in black and red and yellow
56:08 - tiles all on different axes
56:11 - so what we're going to do make our lives
56:12 - easier
56:14 - is we're going to
56:16 - take out
56:18 - these two lines into another loop
56:22 - so i'm going to delete those real quick
56:25 - and
56:26 - we're just going to do a whole another
56:27 - loop
56:28 - of so just try to bear with me here i'm
56:31 - going to copy this stuff we're going to
56:33 - iterate through everything again
56:35 - this might not be the smartest way but
56:37 - it's just going to be very clean for us
56:38 - to deal with because we're always going
56:41 - to
56:43 - build our
56:45 - we're always going to build our
56:46 - background and then fill in the piece
56:48 - afterwards as opposed to like try to
56:50 - fill in our pieces as we're building the
56:52 - back round
56:54 - so i'm thinking this will work well uh
56:57 - this spacing is just messing me up and
56:59 - these lines are so long
57:01 - there we go
57:02 - okay so
57:04 - if board rc is one we're going to fill
57:07 - it with that
57:08 - then we can just delete this line
57:12 - bring this back
57:15 - okay so now we have two loops running
57:17 - but this will kind of
57:19 - fix our problem of
57:20 - them
57:21 - building our board out on different
57:23 - axises so let's try running it again
57:26 - what the heck
57:29 - if board rc equals one uh we're gonna
57:32 - have to make this an elsif otherwise
57:33 - it's gonna fill out the board uh
57:38 - for all the empty spaces at the start of
57:40 - the game equals two
57:43 - all right
57:44 - cool let's see what happens now
57:48 - it looks like it's working properly but
57:49 - it's just offset by one
57:52 - square size and that's because of this
57:55 - right here we are initially accounting
57:57 - when we're building downwards we're
57:58 - initially accounting for this but now
58:00 - that we're building upwards we can
58:01 - delete that from it
58:03 - from the height so we're going to delete
58:05 - this square size here
58:07 - we're going to delete this square size
58:09 - here
58:09 - and we should now fully have it working
58:13 - build
58:16 - yay it looks pretty good huh
58:20 - all right cool so now that we've pretty
58:22 - much fully implemented a game with
58:23 - graphics we're going to add a couple
58:25 - additional features so the first feature
58:27 - we're going to add is add this little
58:29 - scroll wheel so that before we drop a
58:31 - piece we can see what color the piece is
58:33 - and where we're going to drop it so to
58:36 - do that we're going to add a new event
58:38 - we're going to track a new event
58:40 - and that's going to be the event type
58:42 - equal to pie game dot mouse motion and
58:46 - once again all the different events you
58:48 - can use are listed in the
58:50 - pi game documentation
58:52 - and just like
58:54 - mouse button down
58:55 - the
58:56 - mouse motion also has
59:00 - a position property so i can do position
59:05 - x equals event dot position zero so this
59:09 - is going to get me a lot more events
59:11 - though because it's always tracking
59:12 - whenever i'm making any motion
59:14 - so this is going to be constantly
59:15 - updating so now we're going to use this
59:18 - position
59:19 - and
59:20 - draw some circles based on where that
59:22 - position is so if the turn
59:24 - equals equals zero
59:27 - that's a player one's going then we're
59:28 - gonna do pygame dot draw dot circle
59:33 - screen
59:34 - to the surface color is red because it's
59:37 - player one
59:38 - um
59:40 - the next thing we need to put in the
59:41 - circle is the position so the x position
59:43 - this is the center of the circle it's
59:45 - going to be at position x wherever our
59:47 - mouse is
59:48 - then we just want it to be offset enough
59:50 - so that the full circle can draw so
59:52 - we'll just make this
59:54 - square size
59:55 - divided by two
59:57 - and then finally we need to specify the
59:59 - height of
60:01 - or the the radius of the circle and
60:02 - that's just the radius we've been using
60:04 - for all the tiles
60:05 - else
60:06 - this means it's turn equals equals one
60:08 - it's player two's turn and we'll just
60:11 - copy this
60:12 - and draw it
60:15 - and now it's going to be actually yellow
60:17 - so let's look what that looks like if we
60:19 - build that
60:24 - all right
60:25 - build
60:27 - oh okay i forgot to get the display
60:30 - update just like we did in
60:32 - the draw function so
60:33 - pygame.display.update
60:37 - build
60:39 - oh it looks good but it's just not ever
60:41 - deleting the circles so what we're going
60:43 - to do to fix this is right before we
60:46 - actually
60:48 - draw the circle we'll just draw a
60:51 - rectangle that's black that will black
60:52 - out any previous circles that we have
60:54 - drawn so pygame.draw.rectangle
60:58 - surfaces of the screen
61:00 - color is black
61:03 - position is going to start at the top
61:04 - left so that's zero zero
61:07 - it's going to have width the whole width
61:09 - of the screen and then the height will
61:11 - be a square size because that's how big
61:13 - that buffer bar kind of at the top is
61:16 - and
61:17 - that should be good
61:19 - i think i might have one extra no oh
61:22 - yeah i have one extra
61:24 - parenthesis there
61:26 - yay looks good so now we have this game
61:28 - over drop
61:31 - drop
61:32 - drop
61:34 - drop
61:35 - drop
61:36 - that looks good cool
61:38 - and so one thing that you also might
61:40 - want to change is that if i win the game
61:42 - so i'll win the game real quick with red
61:46 - it automatically closes right away so
61:48 - one thing we can do
61:49 - is we can add a weight pi game has a
61:52 - built-in weight
61:53 - function so what we can do is if the
61:56 - game over condition is true so if game
61:59 - over we'll call pygame.time.wait
62:03 - and this is the milliseconds you want to
62:05 - wait so 3000 would equal three seconds
62:07 - so if i run this again
62:12 - one
62:13 - two
62:13 - three
62:15 - it'll shut down automatically
62:17 - cool
62:18 - and then right before it shuts down we
62:19 - wanted some notification that the player
62:21 - actually won so initially we were
62:22 - printing it but now we'll actually
62:24 - render the print function on our screen
62:27 - so that will look something like
62:31 - as
62:32 - follows so we're going to
62:35 - delete the line that says player 1 wins
62:38 - and we're going to initialize
62:40 - a font up top so that will look like
62:44 - we'll do it right below the first update
62:47 - so we'll do my font equals
62:50 - pygame dot font dot system font this is
62:54 - all in the documentation i'm just
62:55 - copying some previous code i wrote
62:57 - and the last time i wrote this i'd use a
62:59 - font called mono
63:01 - but there's other options you can look
63:03 - at the documentation for all the details
63:05 - and we'll do font size 75
63:08 - that's just an arbitrary number that i
63:09 - found worked and then if we go down
63:12 - below
63:13 - to actually render that on the screen
63:15 - horizontally
63:16 - i can type the following i can say
63:19 - label
63:20 - equals my font dot render
63:24 - player one
63:26 - wins exclamation
63:28 - and then
63:30 - i believe this one right here that i
63:31 - just put in specifies the axes
63:34 - that it's on i'm not actually sure i
63:36 - might play around with that to check
63:38 - and then we want the color to be red
63:40 - because uh it's rendering that text red
63:43 - because player one one and then what we
63:45 - have to do to get that on the screen
63:47 - do it quickly we could also use the
63:48 - pygame
63:50 - display.update function but i'm gonna do
63:51 - something a little different here
63:53 - i'm gonna do a screen.blit and that just
63:56 - updates that specific part of the screen
63:58 - and i
64:00 - toyed around with these values before i
64:02 - found that
64:03 - the xy pair where this will start at the
64:05 - top left of corner of this text starting
64:07 - at 40 comma 10 worked pretty well so
64:09 - let's see what happens when i run that
64:11 - so we're gonna have red win
64:15 - player one wins
64:18 - and
64:25 - the one thing is that tile gets in the
64:26 - way
64:28 - um
64:29 - what we could potentially do we could
64:30 - potentially draw another black rectangle
64:32 - if we wanted to
64:34 - um
64:36 - i don't know i'm not too bothered by it
64:37 - we'll fix it in one sec we're going to
64:38 - copy this for player two
64:44 - and i'll say player two wins and the
64:46 - color is gonna be yellow now
64:51 - build so what happens if yellow wins
64:57 - i'm making this so hard on myself
65:01 - player two wins yay
65:05 - all right and
65:08 - maybe what we'll do is at the start of
65:10 - the mouse button down
65:12 - we will draw that black rectangle as
65:14 - well so we don't have that annoying
65:18 - annoying tile getting in our way so
65:20 - right before we click the mouse button
65:21 - down that will make the thing disappear
65:24 - run it one more time
65:29 - player one wins it looks good and you
65:31 - can mess around with that as you see fit
65:34 - okay i mean that's like a pretty
65:36 - good game i'm pretty happy with it if
65:38 - you have any questions about it leave a
65:40 - comment below
65:41 - peace