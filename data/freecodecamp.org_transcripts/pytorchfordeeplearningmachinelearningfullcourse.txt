00:00 - This comprehensive course will teach you the foundations of machine learning and deep learning
00:05 - using PyTorch. PyTorch is a machine learning framework written in Python. You'll learn machine
00:11 - learning by writing PyTorch code. So when in doubt, run the provided code and experiment.
00:17 - Your teacher for this course is Daniel Bourke. Daniel is a machine learning engineer and popular
00:23 - course creator. So enjoy the course and don't watch the whole thing in one sitting.
00:28 - Hello, welcome to the video. It's quite a big one. But if you've come here to learn machine
00:34 - learning and deep learning and PyTorch code, well, you're in the right place. Now, this video and
00:40 - tutorial is focused for beginners who have got about three to six months of Python coding experience.
00:46 - So we're going to cover a whole bunch of important machine learning concepts
00:50 - by writing PyTorch code. Now, if you get stuck, you can leave a comment below or post on the course
00:57 - GitHub discussions page. And on GitHub is where you'll be able to find all the materials that we cover,
01:02 - as well as on learn pytorch.io. There's an online readable book version of this course there.
01:10 - But if you finish this video and you find that, hey, I would still like to learn more PyTorch.
01:15 - I mean, you can't really cover all the PyTorch in a day that video titles just apply on words of
01:19 - the length of video. That's an aside. There is five more chapters available at learn pytorch.io,
01:25 - covering everything from transfer learning to model deployment to experiment tracking.
01:30 - And all the videos to go with those are available at zero to mastery.io. But that's enough for me.
01:37 - Having machine learning and I'll see you inside.
01:45 - Hello, my name is Daniel and welcome to the deep learning with
01:50 - PyTorch course. Now, that was too good not to watch twice. Welcome to the deep learning with
02:01 - cools at fire PyTorch course. So this is very exciting. Are you going to see that animation
02:07 - quite a bit because, I mean, it's fun and PyTorch's symbol is a flame because of torch.
02:13 - But let's get into it. So naturally, if you've come to this course, you might have already
02:17 - researched what is deep learning, but we're going to cover it quite briefly.
02:21 - And just in the sense of how much you need to know for this course, because we're going to be
02:26 - more focused on, rather than just definitions, we're going to be focused on getting practical
02:30 - and seeing things happen. So if we define what machine learning is, because as we'll see in a
02:36 - second, deep learning is a subset of machine learning. Machine learning is turning things
02:41 - data, which can be almost anything, images, text, tables of numbers, video, audio files,
02:49 - almost anything can be classified as data into numbers. So computers love numbers,
02:55 - and then finding patterns in those numbers. Now, how do we find those patterns? Well,
03:01 - the computer does this part specifically a machine learning algorithm or a deep learning
03:05 - algorithm of things that we're going to be building in this course. How? Code and math. Now,
03:11 - this course is code focused. I want to stress that before you get into it. We're focused on
03:16 - writing code. Now, behind the scenes, that code is going to trigger some math to find patterns in
03:21 - those numbers. If you would like to deep dive into the math behind the code, I'm going to be
03:26 - linking extra resources for that. However, we're going to be getting hands on and writing lots of
03:32 - code to do lots of this. And so if we keep going to break things down a little bit more,
03:37 - machine learning versus deep learning, if we have this giant bubble here of artificial
03:43 - intelligence, you might have seen something similar like this on the internet. I've just
03:48 - copied that and put it into pretty colors for this course. So you've got this overarching
03:54 - big bubble of the topic of artificial intelligence, which you could define as, again, almost anything
04:00 - you want. Then typically, there's a subset within artificial intelligence, which is known as machine
04:04 - learning, which is quite a broad topic. And then within machine learning, you have another topic
04:10 - called deep learning. And so that's what we're going to be focused on working with PyTorch,
04:16 - writing deep learning code. But again, you could use PyTorch for a lot of different machine
04:22 - learning things. And truth be told, I kind of use these two terms interchangeably. Yes, ML is the
04:29 - broader topic and deep learning is a bit more nuanced. But again, if you want to form your
04:36 - own definitions of these, I'd highly encourage you to do so. This course is more focused on,
04:41 - rather than defining what things are, is seeing how they work. So this is what we're focused on doing.
04:47 - Just to break things down, if you're familiar with the fundamentals of machine learning,
04:52 - you probably understand this paradigm, but we're going to just rehash on it anyway. So if we
04:58 - consider traditional programming, let's say you'd like to write a computer program that's enabled to,
05:04 - or has the ability to reproduce your grandmother's favorite or famous roast chicken dish. And so we
05:12 - might have some inputs here, which are some beautiful vegetables, a chicken that you've raised on the
05:17 - farm. You might write down some rules. This could be your program, cut the vegetables, season the
05:24 - chicken, preheat the oven, cook the chicken for 30 minutes and add vegetables. Now, it might not
05:28 - be this simple, or it might actually be because your Sicilian grandmother is a great cook. So she's
05:33 - put things into an art now and can just do it step by step. And then those inputs combined with
05:39 - those rules makes this beautiful roast chicken dish. So that's traditional programming. Now,
05:46 - a machine learning algorithm typically takes some inputs and some desired outputs and then
05:52 - figures out the rules. So the patterns between the inputs and the outputs. So where in traditional
05:59 - program, we had to hand write all of these rules, the ideal machine learning algorithm will figure
06:05 - out this bridge between our inputs and our idealized output. Now, in the machine learning sense, this
06:12 - is typically described as supervised learning, because you will have some kind of input with
06:18 - some kind of output, also known as features, and also known as labels. And the machine learning
06:24 - algorithm's job is to figure out the relationships between the inputs or the features and the outputs
06:30 - or the label. So if we wanted to write a machine learning algorithm to figure out our Sicilian
06:36 - grandmother's famous roast chicken dish, we would probably gather a bunch of inputs of ingredients
06:42 - such as these delicious vegetables and chicken, and then have a whole bunch of outputs of the
06:47 - finished product and see if our algorithm can figure out what we should do to go from these
06:53 - inputs to output. So that's almost enough to cover of the difference between traditional programming
07:00 - and machine learning as far as definitions go. We're going to get hands on encoding these sort
07:05 - of algorithms throughout the course. For now, let's go to the next video and ask the question,
07:12 - why use machine learning or deep learning? And actually, before we get there, I'd like you to
07:17 - think about that. So going back to what we just saw, the paradigm between traditional programming
07:22 - and machine learning, why would you want to use machine learning algorithms rather than
07:28 - traditional programming? So if you had to write all these rules, could that get cumbersome?
07:34 - So have a think about it and we'll cover it in the next video.
07:41 - Welcome back. So in the last video, we covered briefly the difference between
07:45 - traditional programming and machine learning. And again, I don't want to spend too much time
07:49 - on definitions. I'd rather you see this in practice. And I left you with the question,
07:54 - why would you want to use machine learning or deep learning? Well, let's think of a good reason.
08:01 - Why not? I mean, if we had to write all those handwritten rules to reproduce Alsace and grandmother's
08:06 - roast chicken dish all the time, that would be quite cumbersome, right? Well, let's draw a line
08:13 - on that. Why not? What's a better reason? And kind of what we just said, right? For a complex
08:18 - problem, can you think of all the rules? So let's imagine we're trying to build a self-driving car.
08:24 - Now, if you've learned to drive, you've probably done so in maybe 20 hours, 100 hours. But now,
08:30 - I'll give you a task of writing down every single rule about driving. How do you back out of your
08:34 - driveway? How do you turn left and go down the street? How do you park a reverse park? How do
08:40 - you stop at an intersection? How do you know how fast to go somewhere? So we just listed half a
08:45 - dozen rules. But you could probably go a fair few more. You might get into the thousands.
08:50 - And so for a complex problem, such as driving, can you think of all the rules? Well, probably not.
08:56 - So that's where machine learning and deep learning come in to help. And so this is a beautiful comment
09:02 - I like to share with you on one of my YouTube videos is my 2020 machine learning roadmap.
09:08 - And this is from Yashawing. I'm probably going to mispronounce this if I even try to.
09:13 - But Yashawing says, I think you can use ML. So ML is machine learning. I'm going to use that
09:18 - a lot throughout the course, by the way. ML is machine learning, just so you know.
09:22 - For literally anything, as long as you can convert it into numbers, ah, that's what we said before,
09:27 - machine learning is turning something into computer readable numbers. And then programming it to find
09:33 - patterns, except with a machine learning algorithm, typically we write the algorithm and it finds
09:38 - the patterns, not us. And so literally it could be anything, any input or output from the universe.
09:44 - That's pretty darn cool about machine learning, right? But should you always use it just because
09:51 - it could be used for anything? Well, I'd like to also introduce you to Google's number one rule
09:58 - of machine learning. Now, if you can build a simple rule based system such as the step of five
10:05 - rules that we had to map the ingredients to our Sicilian grandmothers roast chicken dish,
10:10 - if you can write just five steps to do that, that's going to work every time, well, you should
10:15 - probably do that. So if you can build a simple rule based system that doesn't require machine
10:20 - learning, do that. And of course, maybe it's not so very simple, but maybe you can just write some
10:26 - rules to solve the problem that you're working on. And this is from a wise software engineer,
10:31 - which is, I kind of hinted at it before, rule one of Google's machine learning handbook. Now,
10:36 - I'm going to highly recommend you read through that, but we're not going to go through that in
10:39 - this video. So check that out. You can Google that otherwise the links will be where you get links.
10:45 - So just keep that in mind, although machine learning is very powerful and very fun and very
10:49 - excited, it doesn't mean that you should always use it. I know this is quite the thing to be saying
10:54 - at the start of a deep learning machine learning course, but I just want you to keep in mind,
10:59 - simple rule based systems are still good. Machine learning isn't a solve all for everything.
11:05 - Now, let's have a look at what deep learning is good for, but I'm going to leave you on a
11:09 - clip hammock because we're going to check this out in the next video. See you soon.
11:14 - In the last video, we familiarized ourselves with Google's number one rule of machine learning,
11:20 - which is basically if you don't need it, don't use it. And with that in mind,
11:25 - what should we actually be looking to use machine learning or deep learning for?
11:30 - Well, problems with long lists of rules. So when the traditional approach fails to
11:35 - remember the traditional approach is you have some sort of data input, you write a list of rules for
11:40 - that data to be manipulated in some way, shape, or form, and then you have the outputs that you
11:45 - know. But if you have a long, long list of rules, like the rules of driving a car, which could be
11:50 - hundreds, could be thousands, could be millions, who knows, that's where machine learning and
11:54 - deep learning may help. And it kind of is at the moment in the world of self-driving cars,
11:59 - machine learning and deep learning are the state of the art approach.
12:03 - Continually changing environments. So whatever the benefits of deep learning is that it can
12:08 - keep learning if it needs to. And so it can adapt and learn to new scenarios. So if you update the
12:15 - data that your model was trained on, it can adjust to new different kinds of data in the future.
12:21 - So similarly to if you are driving a car, you might know your own neighborhood very well.
12:26 - But then when you go to somewhere you haven't been before, sure you can draw on the foundations
12:30 - of what you know, but you're going to have to adapt. How fast should you go? Where should you
12:35 - stop? Where should you park? These kinds of things. So with problems with long lists of rules,
12:40 - or continually changing environments, or if you had a large, large data set. And so this is where
12:48 - deep learning is flourishing in the world of technology. So let's give an example. One of my
12:55 - favorites is the food 101 data set, which you can search for online, which is images of 101
13:00 - different kinds of foods. Now we briefly looked at what a rule list might look like for cooking
13:07 - your grandmother's famous Sicilian roast chicken dish. But can you imagine if you wanted to build
13:14 - an app that could take photos of different food, how long your list of rules would be to differentiate
13:19 - 101 different foods? It'd be so long. You need rule sets for every single one. Let's just take
13:24 - one food, for example. How do you write a program to tell what a banana looks like? I mean you'd
13:32 - have to code what a banana looks like, but not only a banana, what everything that isn't a banana
13:36 - looks like. So keep this in mind. What deep learning is good for? Problems with long lists of rules,
13:42 - continually changing environments, or discovering insights within large collections of data.
13:48 - Now, what deep learning is not good for? And I'm going to write typically here because,
13:53 - again, this is problem specific. Deep learning is quite powerful these days and things might
13:57 - change in the future. So keep an open mind, if there's anything about this course, it's not for
14:01 - me to tell you exactly what's what. It's for me to spark a curiosity into you to figure out what's
14:07 - what, or even better yet, what's not what. So when you need explainability, as we'll see,
14:13 - the patterns learned by a deep learning model, which is lots of numbers, called weights and biases,
14:19 - we'll have a look at that later on, are typically uninterpretable by a human. So some of the times
14:24 - deep learning models can have a million, 10 million, 100 million, a billion, some models are getting
14:30 - into the trillions of parameters. When I say parameters, I mean numbers or patterns in data.
14:36 - Remember, machine learning is turning things into numbers and then writing a machine learning model
14:40 - to find patterns in those numbers. So sometimes those patterns themselves can be lists of numbers
14:46 - that are in the millions. And so can you imagine looking at a list of numbers that has a million
14:50 - different things going on? That's going to be quite hard. I find it hard to understand
14:54 - three or four numbers, let alone a million. And when the traditional approach is a better option,
15:00 - again, this is Google's rule number one of machine learning. If you can do what you need to do with
15:05 - a simple rule based system, well, maybe you don't need to use machine learning or deep learning.
15:12 - Again, I'm going to use the deep learning machine learning terms interchangeably.
15:15 - I'm not too concerned with definitions. You can form your own definitions, but just so you know,
15:20 - from my perspective, ML and deep learning are quite similar. When arrows are unacceptable.
15:26 - So since the outputs of a deep learning model aren't always predictable, we'll see that deep
15:31 - learning models are probabilistic. That means they're when they predict something, they're making a
15:35 - probabilistic bet on it. Whereas in a rule based system, you kind of know what the outputs are
15:42 - going to be every single time. So if you can't have errors based on probabilistic errors,
15:48 - well, then you probably shouldn't use deep learning and you'd like to go back to a simple rule based
15:53 - system. And then finally, when you don't have much data, so deep learning models usually require a
15:59 - fairly large amount of data to produce great results. However, there's a caveat here, you know,
16:04 - at the start, I said typically, we're going to see some techniques of how to get great results
16:09 - without huge amounts of data. And again, I wrote typically here because there are techniques,
16:14 - you can just research deep learning explainability. You're going to find a whole bunch of stuff.
16:18 - You can look up examples of when machine learning versus deep learning. And then when arrows are
16:24 - unacceptable, again, there are ways to make your model reproducible. So it predicts you know what's
16:30 - going to come out. So we do a lot of testing to verify this as well. And so what's next? Ah,
16:37 - we've got machine learning versus deep learning, and we're going to have a look at some different
16:40 - problem spaces in a second, and mainly breaking down in terms of what kind of data you have.
16:46 - Not going to do this now prevent this video from getting too long. We'll cover all these
16:50 - colorful beautiful pictures in the next video. Welcome back. So in the last video, we covered a
16:57 - few things of what deep learning is good for and what deep learning is typically not good for.
17:02 - So let's dive in to a little more of a comparison of machine learning versus deep learning. Again,
17:08 - I'm going to be using these terms quite interchangeably. But there are some specific things that
17:15 - typically you want traditional style of machine learning techniques versus deep learning. However,
17:21 - this is constantly changing. So again, I'm not talking in absolutes here. I'm more just talking
17:28 - in general. And I'll leave it to you to use your own curiosity to research the specific
17:34 - differences between these two. But typically, for machine learning, like the traditional style of
17:40 - algorithms, although they are still machine learning algorithms, which is kind of a little
17:44 - bit confusing where deep learning and machine learning differ is you want to use traditional
17:49 - machine learning algorithms on structured data. So if you have tables of numbers, this is what I
17:54 - mean by structured rows and columns, structured data. And possibly one of the best algorithms
18:02 - for this type of data is a gradient boosted machine, such as xg boost. This is an algorithm
18:08 - that you'll see in a lot of data science competitions, and also used in production settings. When I
18:12 - say production settings, I mean, applications that you may interact with on the internet,
18:17 - or use on a day to day. So that's production. xg boost is typically the favorite algorithm for
18:23 - these kinds of situations. So again, if you have structured data, you might look into xg boost
18:29 - rather than building a deep learning algorithm. But again, the rules aren't set in stone. That's
18:35 - where deep learning and machine learning is kind of an art kind of a science is that sometimes
18:40 - xg boost is the best for structured data, but there might be exceptions to the rule. But for deep
18:45 - learning, it is typically better for unstructured data. And what I mean by that is data that's kind
18:51 - of all over the place. It's not in your nice, standardized rows and columns. So say you had
18:57 - natural language such as this tweet by this person, whose name is quite similar to mine,
19:02 - and has the same Twitter account as me. Oh, maybe I wrote that. How do I learn machine learning? What
19:07 - you need to hear? Learn Python, learn math, start probability, software engineering, build.
19:12 - What you need to do? Google it, go down the rabbit hole, resurfacing six to nine months,
19:16 - and ring assess. I like that. Or if you had a whole bunch of texts such as the definition for
19:21 - deep learning on Wikipedia, again, this is the reason why I'm not covering as many definitions
19:27 - in this course is because look how simple you can look these things up. Wikipedia is going to
19:31 - be able to define deep learning far better than what I can. I'm more focused on just getting involved
19:36 - in working hands on with this stuff than defining what it is. And then we have
19:42 - images. If we wanted to build a burger, take a photo app thing, you would work with image data,
19:50 - which doesn't really have much of a structure. Although we'll see that there are ways for deep
19:55 - learning that we can turn this kind of data to have some sort of structure through the beauty
20:01 - of a tensor. And then we might have audio files such as if you were talking to your voice assistant.
20:06 - I'm not going to say one because a whole bunch of my devices might go crazy if I say the name of
20:11 - my voice assistant, which rhymes with I'm not even going to say that out loud. And so typically,
20:18 - for unstructured data, you'll want to use a neural network of some kind. So structured data,
20:24 - gradient boosted machine, or a random forest, or a tree based algorithm, such as extra boost,
20:30 - and unstructured data, neural networks. So let's keep going. Let's have a look at some of the
20:38 - common algorithms that you might use for structured data, machine learning versus unstructured data,
20:44 - deep learning. So random forest is one of my favorites, gradient boosted models,
20:49 - native base nearest neighbor, support vector machine, SVM, and then many more. But since
20:56 - the advent of deep learning, these are often referred to as shallow algorithms. So deep learning,
21:01 - why is it called deep learning? Well, as we'll see is that it can have many different layers
21:06 - of algorithm, you might have an input layer, 100 layers in the middle, and then an output layer.
21:11 - But we'll get hands on with this later on. And so common algorithms for deep learning and neural
21:16 - networks, fully connected neural network, convolutional neural network, recurrent neural network,
21:21 - transformers have taken over over the past couple years, and of course, many more. And the beautiful
21:27 - thing about deep learning and neural networks is is almost as many problems that it can be applied
21:33 - to is as many different ways that you can construct them. So this is why I'm putting all these
21:39 - dot points on the page. And I can understand if you haven't had much experience of machine
21:42 - learning or deep learning, this can be a whole bunch of information overload. But good news is
21:49 - what we're going to be focused on building with PyTorch is neural networks, fully connected neural
21:54 - networks and convolutional neural networks, the foundation of deep learning. But the excellent
21:59 - thing is, the exciting thing is, is that if we learn these foundational building blocks,
22:03 - we can get into these other styles of things here. And again, part art, part science of machine
22:09 - learning and deep learning is depending on how you represent your problem, depending on what your
22:14 - problem is, many of the algorithms here and here can be used for both. So I know I've just kind of
22:21 - bedazzled you and saying that, Oh, well, you kind of use these ones for deep learning, you kind of
22:26 - use these ones for machine learning. But depending on what your problem is, you can also use both.
22:30 - So that's a little bit of confusion to machine learning. But that's a fun part about it too,
22:35 - is use your curiosity to figure out what's best for whatever you're working on. And with all this
22:41 - talk about neural networks, how about in the next video, we cover what are neural networks. Now,
22:48 - I'd like you to Google this before we watch the next video, because it's going to be hundreds of
22:52 - definitions of what they are. And I'd like you to start forming your own definition of what a
22:57 - neural network is. I'll see you in the next video. Welcome back. In the last video, I left you with
23:05 - the cliffhanger of a question. What are neural networks? And I gave you the challenge of
23:09 - Googling that, but you might have already done that by the time you've got here.
23:13 - Let's just do that together. If I type in what are neural networks, I've already done this.
23:20 - What are neural networks? Explain neural networks, neural network definition. There are hundreds
23:25 - of definitions of things like this online neural network in five minutes. Three blue one brown.
23:30 - I'd highly recommend that channel series on neural networks. That's going to be in the
23:35 - extracurricular stat quest is also amazing. So there's hundreds of different definitions on here,
23:40 - and you can read 10 of them, five of them, three of them, make your own definition.
23:45 - But for the sake of this course, here's how I'm going to find neural networks.
23:50 - So we have some data of whatever it is. We might have images of food. We might have
23:55 - tweets or natural language, and we might have speech. So these are some examples of inputs
24:00 - for unstructured data, because they're not rows and columns. So these are the input data that
24:05 - we have. And then how do we use them with a neural network? Well, before data can be used in a neural
24:13 - network, it needs to be turned into numbers, because humans, we like looking at images of Raman and
24:18 - spaghetti. We know that that's Raman. We know that that's spaghetti after we've seen it one or two
24:23 - times. And we like reading good tweets, and we like listening to amazing music or hearing our
24:30 - friend talk on the phone in audio file. However, before a computer understands what's going on
24:35 - in these inputs, it needs to turn them into numbers. So this is what I call a numerical
24:41 - encoding or a representation. And this numerical encoding, these square brackets indicate that
24:47 - it's part of a matrix or a tensor, which we're going to get very hands on with throughout this
24:52 - course. So we have our inputs, we've turned it into numbers, and then we pass it through a neural
24:58 - network. And now this is a graphic for a neural network. However, the graphics for neural networks,
25:05 - as we'll see, can get quite involved. But they all represent the same fundamentals. So if we go to
25:13 - this one, for example, we have an input layer, then we have multiple hidden layers. However,
25:18 - you define this, you can design these and how you want. Then we have an output layer. So our
25:23 - inputs will go in some kind of data. The hidden layers will perform mathematical operations on the
25:30 - input. So the numbers, and then we'll have an output. Oh, there's three blue one brown neural
25:35 - networks from the ground up. Great video. Highly recommend you check that out. But then if we come
25:41 - back to this, so we've got our inputs, we've turned it into numbers. And we've got our neural
25:45 - networks that we put the input in. This is typically the input layer, hidden layer. This can be as
25:50 - many different layers as you want, as many different, each of these little dots is called a node.
25:54 - There's a lot of information here, but we're going to get hands-on with seeing what this looks
25:58 - like. And then we have some kind of output. Now, which neural network should you use? Well,
26:04 - you can choose the appropriate neural network for your problem, which could involve you
26:07 - hand coding each one of these steps. Or you could find one that has worked on problems similar to
26:13 - your own, such as for images, you might use a CNN, which is a convolutional neural network.
26:19 - For natural language, you might use a transformer. For speech, you might also use a transformer.
26:24 - But fundamentally, they all follow the same principle of inputs, manipulation, outputs.
26:29 - And so the neural network will learn a representation on its own. We want to find what it learns.
26:35 - So it's going to manipulate these patterns in some way, shape, or form. And when I say
26:40 - learns representation, I'm going to also refer to it as learns patterns in the data.
26:44 - A lot of people refer to it as features. A feature may be the fact that the word do comes out to how,
26:51 - usually, in across a whole bunch of different languages. A feature can be almost anything you
26:57 - want. And again, we don't define this. The neural network learns these representations,
27:02 - patterns, features, also called weights on its own. And then where do we go from there? Well,
27:08 - we've got some sort of numbers, numerical encoding turned our data into numbers. Our neural network
27:14 - has learned a representation that it thinks best represents the patterns in our data.
27:20 - And then it outputs those representation outputs, which we can use. And often you'll
27:26 - hear this referred to as features or weight matrix or weight tensor.
27:31 - Learned representation is also another common one. There's a lot of different terms for these
27:36 - things. And then it will output. We can convert these outputs into human understandable outputs.
27:44 - So if we were to look at these, this could be, again, I said representations or patterns that
27:49 - are neural network learns can be millions of numbers. This is only nine. So imagine if these
27:54 - were millions of different numbers, I can barely understand the nine numbers that is going on here.
28:00 - So we need a way to convert these into human understandable terms. So for this example,
28:05 - we might have some input data, which are images of food. And then we want our neural network to
28:10 - learn the representations between an image of ramen and an image of spaghetti.
28:15 - And then eventually we'll take those patterns that it's learned and we'll convert them into
28:19 - whether it thinks that this is an image of ramen or spaghetti. Or in the case of this tweet,
28:25 - is this a tweet for a natural disaster or not a natural disaster? So our neural network has,
28:31 - well, we've written code to turn this into numbers. Pass it through our neural network. Our neural
28:36 - network has learned some kind of patterns. And then we ideally want it to represent this tweet
28:42 - as not a disaster. And then we can write code to do each of these steps here. And the same thing
28:48 - for these inputs going as speech, turning into something that you might say to your smart speaker,
28:54 - which I'm not going to say because a whole bunch of my devices might go off. And so let's cover
29:00 - the anatomy of neural networks. We've hinted at this a little bit already. But this is like
29:05 - neural network anatomy 101. Again, this is highly customizable what this thing actually is. We're
29:11 - going to see it in PyTorch code later on. But the data goes into the input layer. And in this case,
29:18 - the number of units slash neurons slash nodes is two hidden layers. You can have, I put a s here
29:26 - because you can have one hidden layer, or the deep in deep learning comes from having lots of
29:33 - layers. So this is only showing four layers. You might have, well, this is three layers as well.
29:40 - It might be very deep neural networks such as ResNet 152. This is 152 different layers.
29:50 - So again, you can, or this is 34, because this is only ResNet 34. But ResNet 152 has 152 different
29:59 - layers. So that's a common computer vision or a popular computer vision algorithm, by the way.
30:05 - Lots of terms we're throwing out here. But with time, you'll start to become familiar with them.
30:10 - So hidden layers can be almost as many as you want. We've only got pictured one here. And in this
30:15 - case, there's three hidden units slash neurons. And then we have an output layer. So the outputs
30:21 - learned representation or prediction probabilities from here, depending on how we set it up, which
30:27 - again, we will see what these are later on. And in this case, it has one hidden unit. So two input,
30:35 - three, one output, you can customize the number of these, you can customize how many layers there
30:40 - are, you can customize what goes into here, you can customize what goes out of there. So now,
30:47 - if we talk about the overall architecture, which is describing all of the layers combined. So that's,
30:56 - when you hear neural network architecture, it talks about the input, the hidden layers,
31:01 - which may be more than one, and the output layer. So that's a terminology for overall architecture.
31:05 - Now, I say patterns is an arbitrary term. You can hear embedding embedding might come from hidden
31:13 - layers, weights, feature representation, feature vectors, all referring to similar things. So,
31:18 - again, how do we turn our data into some numerical form, build a neural network to figure out patterns
31:25 - to output some desired output that we want. And now to get more technical, each layer is usually a
31:31 - combination of linear, so straight lines, and nonlinear, non-straight functions. So what I mean by that
31:38 - is a linear function is a straight line, a nonlinear function is a non-straight line.
31:43 - If I asked you to draw whatever you want with unlimited straight lines and not straight lines,
31:49 - so you can use straight lines or curved lines, what kind of patterns could you draw?
31:55 - At a fundamental level, that is basically what a neural network is doing. It's using a combination
32:00 - of linear, straight lines, and not straight lines to draw patterns in our data. We'll see what
32:05 - this looks like later on. Now, from the next video, let's dive in briefly to different kinds of
32:12 - learning. So we've looked at what a neural network is, the overall algorithm, but there are also
32:17 - different paradigms of how a neural network learns. I'll see you in the next video.
32:22 - Welcome back. We've discussed a brief overview of an anatomy of what a neural network is,
32:30 - but let's now discuss some learning paradigms. So the first one is supervised learning,
32:37 - and then we have unsupervised and self-supervised learning, and transfer learning. Now supervised
32:43 - learning is when you have data and labels, such as in the example we gave at the start, which was
32:48 - how you would build a neural network or a machine learning algorithm to figure out the rules to
32:55 - cook your Sicilian grandmother's famous roast chicken dish. So in the case of supervised learning,
33:00 - you'd have a lot of data, so inputs, such as raw ingredients as vegetables and chicken,
33:06 - and a lot of examples of what that inputs should ideally look like. Or in the case of discerning
33:13 - photos between a cat and a dog, you might have a thousand photos of a cat and a thousand photos
33:19 - of a dog that you know which photos are cat and which photos are dog, and you pass those photos
33:25 - to a machine learning algorithm to discern. So in that case, you have data, the photos, and the
33:31 - labels, aka cat and dog, for each of those photos. So that's supervised learning, data and labels.
33:39 - Unsupervised and self-supervised learning is you just have the data itself.
33:43 - You don't have any labels. So in the case of cat and dog photos, you only have the photos.
33:48 - You don't have the labels of cat and dog. So in the case of self-supervised learning,
33:54 - you could get a machine learning algorithm to learn an inherent representation of what,
33:59 - and when I say representation, I mean patterns and numbers, I mean weights, I mean features,
34:04 - a whole bunch of different names describing the same thing. You could get a self-supervised
34:08 - learning algorithm to figure out the fundamental patterns between a dog and a cat image, but
34:16 - it wouldn't necessarily know the difference between the two.
34:19 - That's where you could come in later and go show me the patterns you've learned,
34:22 - and it might show you the patterns and you could go, okay, the patterns that look like this,
34:26 - a dog and the patterns that look like that, a cat. So self-supervised and unsupervised learning
34:31 - learn solely on the data itself. And then finally, transfer learning is a very, very
34:36 - important paradigm in deep learning. It's taking the patterns that one model has learned
34:42 - of a data set and transferring it to another model, such in the case of if we were trying to
34:48 - build a supervised learning algorithm for discerning between cat and dog photos.
34:53 - We might start with a model that has already learned patterns and images
34:57 - and transfer those foundational patterns to our own model so that our model gets a head start.
35:03 - This is transfer learning is a very, very powerful technique, but as for this course,
35:08 - we're going to be writing code to focus on these two supervised learning and transfer learning,
35:12 - which are two of the most common paradigms or common types of learning in machine learning
35:16 - and deep learning. However, this style of code though can be adapted across different learning
35:21 - paradigms. Now, I just want to let you know there is one that I haven't mentioned here,
35:25 - which is kind of in its own bucket, and that is reinforcement learning. So I'll leave this
35:33 - as an extension if you wanted to look it up. But essentially, this is a good one.
35:37 - That's a good photo, actually. So shout out to Katie Nuggets. The whole idea of reinforcement
35:43 - learning is that you have some kind of environment and an agent that does actions in that environment,
35:48 - and you give rewards and observations back to that agent. So say, for example,
35:54 - you wanted to teach your dog to urinate outside. Well, you would reward its actions of urinating
36:01 - outside and possibly not reward its actions of urinating all over your couch. So reinforcement
36:07 - learning is again, it's kind of in its own paradigm. This picture has a good explanation
36:13 - between unsupervised learning, supervised learning to separate two different things,
36:17 - and then reinforcement learning is kind of like that. But again, I will let you research the
36:22 - different learning paradigms a little bit more in your own time. As I said, we're going to be
36:27 - focused on writing code to do supervised learning and transfer learning, specifically pytorch code.
36:34 - Now with that covered, let's get a few examples of what is deep learning actually used for. And
36:41 - before we get into the next video, I'm going to issue you a challenge to search this question
36:45 - yourself and come up with some of your own ideas for what deep learning is currently used for.
36:51 - So give that a shot and I'll see you in the next video. How'd you go? Did you do some research?
36:58 - Did you find out what deep learning is actually used for? I bet you found a treasure trail of
37:02 - things. And hey, I mean, if you're reading this course, chances are that you probably already
37:06 - know some use cases for deep learning. You're like, Daniel, hurry up and get to the code. Well,
37:11 - we're going to get there, don't you worry? But let's have a look at some things that deep
37:16 - learning can be used for. But before, I just want to remind you of this comment. This is from
37:20 - Yasha Sway on the 2020 machine learning roadmap video. I think you can use ML and remember,
37:26 - ML is machine learning. And remember, deep learning is a part of ML for literally anything as long
37:31 - as you can convert it into numbers and program it to find patterns. Literally, it could be anything,
37:36 - any input or output from the universe. So that's a beautiful thing about machine learning is that
37:42 - if you can encode it something into numbers, chances are you can build a machine learning
37:48 - algorithm to find patterns in those numbers. Will it work? Well, again, that's the reason machine
37:53 - learning and deep learning is part art, part science. A scientist would love to know that their
37:57 - experiments would work. But an artist is kind of excited about the fact that, I don't know,
38:02 - this might work, it might not. And so that's something to keep in mind. Along with the rule
38:07 - number one of machine learning is if you don't need it, you don't use it. But if you do use it,
38:12 - it can be used for almost anything. And let's get a little bit specific and find out some deep
38:17 - learning use cases. And I've put some up there for a reason because there are lots. These are just
38:22 - some that I interact with in my day to day life, such as recommendation, we've got a programming
38:27 - video, we've got a programming podcast, we got some jujitsu videos, we've got some RuneScape
38:33 - videos, a soundtrack from my favorite movie. Have you noticed, whenever you go to YouTube,
38:38 - you don't really search for things anymore. Well, sometimes you might, but the recommendation
38:44 - page is pretty darn good. That's all powered by deep learning. And in the last 10 years,
38:48 - have you noticed that translation has got pretty good too? Well, that's powered by deep learning
38:54 - as well. Now, I don't have much hands on experience with this. I did use it when I was in Japan.
39:00 - I speak a very little amount of Japanese and even smaller amount of Mandarin. But if I wanted to
39:05 - translate deep learning as epic to Spanish, it might come out as el aprendise, profando es ebiko.
39:16 - Now, all of the native Spanish speakers watching this video can laugh at me because that was a very
39:21 - Australian version of saying deep learning is epic in Spanish. But that's so cool. All the Google
39:27 - Translate is now powered by deep learning. And the beautiful thing, if I couldn't say it myself,
39:32 - I could click this speaker and it would say it for me. So that speech recognition that's powered
39:37 - by deep learning. So if you were to ask your voice assistant who's the biggest big dog of them all,
39:41 - of course, they're going to say you, which is what I've set up, my voice assistant to say.
39:45 - That's part of speech recognition. And in computer vision, oh, look at this. You see this? Where is
39:51 - this photo from? This photo is from this person driving this car. Did a hit and run on my car,
39:57 - at the front of my house, my apartment building, my car was parked on the street, this car, the
40:02 - trailer came off, ran into the back of my car, basically destroyed it, and then they drove off.
40:07 - However, my next door neighbors security camera picked up on this car. Now, I became a detective
40:14 - for a week, and I thought, hmm, if there was a computer vision algorithm built into that camera,
40:19 - it could have detected when the car hit. I mean, it took a lot of searching to find it,
40:24 - it turns out the car hit about 3.30am in the morning. So it's pitch black. And of course,
40:28 - we didn't get the license plate. So this person is out there somewhere in the world after doing
40:32 - a hit and run. So if you're watching this video, just remember computer vision might catch you one
40:37 - day. So this is called object detection, where you would place a box around the area where the
40:42 - pixels most represent the object that you're looking for. So for computer vision, we could
40:46 - train an object detector to capture cars that drive past a certain camera. And then if someone
40:52 - does a hit and run on you, you could capture it. And then fingers crossed, it's not too dark
40:55 - that you can read the license plate and go, hey, excuse me, please, this person has hit my car
40:59 - and wrecked it. So that's a very close to home story of where computer vision could be used.
41:03 - And then finally, natural language processing. Have you noticed as well, your spam detector on
41:09 - your email inbox is pretty darn good? Well, some are powered by deep learning, some not,
41:14 - it's hard to tell these days what is powered by deep learning, what isn't. But natural language
41:19 - processing is the process of looking at natural language text. So unstructured text. So whatever
41:25 - you'd write an email in a story in a Wikipedia document and deciding or getting your algorithm
41:31 - to find patterns in that. So for this example, you would find that this email is not spam.
41:36 - This deep learning course is incredible. I can't wait to use what I've learned. Thank you so much.
41:40 - And by the way, that is my real email. So if you want to email me, you can. And then this is spam.
41:45 - Hey, Daniel, congratulations, you win a lot of money. Wow, I really like that a lot of money.
41:52 - But somebody said, I don't think that this is real. So that would probably go to my spam inbox.
41:57 - Now, with that being said, if we wanted to put these problems in a little bit more of a
42:05 - classification, this is known as sequence to sequence because you put one sequence in
42:09 - and get one sequence out. Same as this, you have a sequence of audio waves and you get some
42:15 - text out. So sequence to sequence, sec to sec. This is classification slash regression. In this
42:22 - case, the regression is predicting a number. That's what a regression problem is. You would predict
42:28 - the coordinates of where these box corners should be. So say this should be at however many pixels
42:33 - in from the X angle and however many pixels down from the Y angle, that's that corner.
42:38 - And then you would draw in between the corners. And then the classification part would go,
42:43 - Hey, this is that car that did a hit and run on us. And in this case, this is classification.
42:48 - Classification is predicting whether something is one thing or another, or perhaps more than one
42:52 - thing or another in the class of multi class classification. So this email is not spam. That's
42:58 - a class and this email is spam. So that's also a class. So I think we've only got one direction
43:06 - to go now that we've sort of laid the foundation for the course. And that is
43:12 - Well, let's start talking about PyTorch. I'll see you in the next video.
43:18 - Well, let's now cover some of the foundations of
43:24 - PyTorch. But first, you might be asking, what is PyTorch? Well, of course, we could just go to
43:31 - our friend, the internet, and look up PyTorch.org. This is the homepage for PyTorch.
43:38 - This course is not a replacement for everything on this homepage. This should be your ground truth
43:43 - for everything PyTorch. So you can get started. You've got a big ecosystem. You've got a way to
43:49 - set up on your local computer. You've got resources. You've got docs. PyTorch. You've got the GitHub.
43:55 - You've got search. You've got blog, everything here. This website should be the place you're
44:00 - visiting most throughout this course as we're writing PyTorch code. You're coming here.
44:06 - You're reading about it. You're checking things out. You're looking at examples.
44:10 - But for the sake of this course, let's break PyTorch down. Oh, there's a little flame animation
44:18 - I just forgot about. What is PyTorch? I didn't sync up the animations. That's all right. So
44:28 - PyTorch is the most popular research deep learning framework. I'll get to that in a second.
44:36 - It allows you to write fast deep learning code in Python. If you know Python, it's a very user-friendly
44:42 - programming language. PyTorch allows us to write state-of-the-art deep learning code
44:47 - accelerated by GPUs with Python. It enables you access to many pre-built deep learning models
44:55 - from Torch Hub, which is a website that has lots of, if you remember, I said transfer learning is
45:01 - a way that we can use other deep learning models to power our own. Torch Hub is a resource for that.
45:07 - Same as Torch Vision.Models. We'll be looking at this throughout the course.
45:10 - It provides an ecosystem for the whole stack of machine learning. From pre-processing data,
45:16 - getting your data into tenses, what if you started with some images? How do you represent them as
45:20 - numbers? Then you can build models such as neural networks to model that data. Then you can even
45:25 - deploy your model in your application slash cloud, well, deploy your PyTorch model. Application slash
45:31 - cloud will be depending on what sort of application slash cloud that you're using, but generally it
45:37 - will run some kind of PyTorch model. And it was originally designed and used in-house by Facebook
45:43 - slash meta. I'm pretty sure Facebook have renamed themselves meta now, but it is now open source
45:48 - and used by companies such as Tesla, Microsoft and OpenAI. And when I say it is the most popular
45:53 - deep learning research framework, don't take my word for it. Let's have a look at papers with code
45:58 - dot com slash trends. If you're not sure what papers with code is, it is a website that tracks
46:03 - the latest and greatest machine learning papers and whether or not they have code. So we have some
46:08 - other languages here, other deep learning frameworks, PyTorch, TensorFlow, Jax is another one, MXNet,
46:13 - paddle paddle, the original torch. So PyTorch is an evolution of torch written in Python,
46:18 - CAF2, Mindspore. But if we look at this, when is this? Last date is December 2021. We have,
46:26 - oh, this is going to move every time I move it. No. So I'll highlight PyTorch at 58% there.
46:33 - So by far and large, the most popular research machine learning framework used to write the code
46:40 - for state of the art machine learning algorithms. So this is browse state of the art papers with
46:45 - code.com amazing website. We have semantic segmentation, image classification, object detection, image
46:51 - generation, computer vision, natural language processing, medical, I'll let you explore this.
46:56 - It's one of my favorite resources for staying up to date on the field. But as you see, out of the
47:00 - 65,000 papers with code that this website is tracked, 58% of them are implemented with PyTorch.
47:08 - How cool is that? And this is what we're learning. So let's jump into there. Why PyTorch? Well,
47:14 - other than the reasons that we just spoke about, it's a research favorite. This is highlighting.
47:20 - There we go. So there we go. I've highlighted it here. PyTorch, 58%, nearly 2,500 repos. If
47:27 - you're not sure what a repo is, a repo is a place where you store all of your code online.
47:31 - And generally, if a paper gets published in machine learning, if it's fantastic research,
47:37 - it will come with code, code that you can access and use for your own applications or your own
47:44 - research. Again, why PyTorch? Well, this is a tweet from Francois Chale, who's the author of
47:51 - Keras, which is another popular deep learning framework. But with tools like Colab, we're going
47:57 - to see what Colab is in a second, Keras and TensorFlow. I've added in here and PyTorch.
48:02 - Virtually anyone can solve in a day with no initial investment problems that would have
48:06 - required an engineering team working for a quarter and $20,000 in hardware in 2014. So this is just
48:12 - to highlight how good the space of deep learning and machine learning tooling has become. Colab,
48:18 - Keras and TensorFlow are all fantastic. And now PyTorch is added to this list. If you want to
48:24 - check that out, there's Francois Chale on Twitter. Very, very prominent voice in the machine learning
48:31 - field. Why PyTorch? If you want some more reasons, well, have a look at this. Look at all the
48:37 - places that are using PyTorch. It's just coming up everywhere. We've got Andre Kapathi here,
48:42 - who's the director of AI at Tesla. So if we go, we could search this, PyTorch
48:51 - at Tesla. We've got a YouTube talk there, Andre Kapathi, director of AI at Tesla.
48:59 - And so Tesla are using PyTorch for the computer vision models of autopilot. So if we go to videos
49:08 - or maybe images, does it come up there? Things like this, a car detecting what's going on in the scene.
49:16 - Of course, there'll be some other code for planning, but I'll let you research that.
49:22 - When we come back here, OpenAI, which is one of the biggest open artificial intelligence
49:28 - research firms, open in the sense that they publish a lot of their research methodologies,
49:34 - however, recently there's been some debate about that. But if you go to openai.com,
49:40 - let's just say that they're one of the biggest AI research entities in the world,
49:45 - and they've standardized on PyTorch. So they've got a great blog, they've got great research,
49:50 - and now they've got OpenAI API, which is, you can use their API to access some of the models
49:56 - that they've trained. Presumably with PyTorch, because this blog post from January 2020 says
50:02 - that OpenAI is now standardized across PyTorch. There's a repo called the incredible PyTorch,
50:07 - which collects a whole bunch of different projects that are built on top of PyTorch.
50:11 - That's the beauty of PyTorch is that you can build on top of it, you can build with it
50:15 - AI for AG, for agriculture. PyTorch has been used. Let's have a look. PyTorch in agriculture.
50:22 - There we go. Agricultural robots use PyTorch. This is a medium article.
50:31 - It's everywhere. So if we go down here, this is using object detection. Beautiful.
50:38 - Object detection to detect what kind of weeds should be sprayed with fertilizer. This is just
50:43 - one of many different things, so PyTorch on a big tractor like this. It can be used almost
50:49 - anywhere. If we come back, PyTorch builds the future of AI and machine learning at Facebook,
50:53 - so Facebook, which is also MetaAI, a little bit confusing, even though it says MetaAI,
50:58 - it's on AI.facebook.com. That may change by the time you watch this. They use PyTorch in-house
51:03 - for all of their machine learning applications. Microsoft is huge in the PyTorch game.
51:09 - It's absolutely everywhere. So if that's not enough reason to use PyTorch,
51:14 - well, then maybe you're in the wrong course. So you've seen enough reasons of why to use PyTorch.
51:19 - I'm going to give you one more. That is that it helps you run your code, your machine learning code
51:25 - accelerated on a GPU. We've covered this briefly, but what is a GPU slash a TPU,
51:30 - because this is more of a newer chip these days. A GPU is a graphics processing unit,
51:36 - which is essentially very fast at crunching numbers. Originally designed for video games,
51:41 - if you've ever designed or played a video game, you know that the graphics are quite intense,
51:45 - especially these days. And so to render those graphics, you need to do a lot of numerical calculations.
51:50 - And so the beautiful thing about PyTorch is that it enables you to leverage a GPU through an
51:56 - interface called CUDA, which is a lot of words I'm going to throw out you here, a lot of acronyms
52:01 - in the deep learning space, CUDA. Let's just search CUDA. CUDA toolkit. So CUDA is a parallel
52:08 - computing platform and application programming interface, which is an API that allows software
52:12 - to use certain types of graphics processing units for general purpose computing. That's what
52:18 - we want. So PyTorch leverages CUDA to enable you to run your machine learning code on NVIDIA
52:25 - GPUs. Now, there is also an ability to run your PyTorch code on TPUs, which is a tensor processing
52:32 - unit. However, GPUs are far more popular when running various types of PyTorch code. So we're
52:39 - going to focus on running our PyTorch code on the GPU. And to just give you a quick example,
52:45 - PyTorch on TPU, let's see that. Getting started with PyTorch on cloud TPUs, there's plenty of
52:51 - guys for that. But as I said, GPUs are going to be far more common in practice. So that's what
52:57 - we're going to focus on. And with that said, we've said tensor processing unit. Now, the reason
53:04 - why these are called tensor processing units is because machine learning and deep learning
53:08 - deals a lot with tensors. And so in the next video, let's answer the question, what is a tensor?
53:16 - But before I go through and answer that from my perspective, I'd like you to research this
53:21 - question. So open up Google or your favorite search engine and type in what is a tensor and
53:27 - see what you find. I'll see you in the next video. Welcome back. In the last video, I left you on
53:34 - the cliffhanger question of what is a tensor? And I also issued you the challenge to research
53:40 - what is a tensor. Because as I said, this course isn't all about telling you exactly what things
53:45 - are. It's more so sparking a curiosity in you so that you can stumble upon the answers to these
53:50 - things yourself. But let's have a look. What is a tensor? Now, if you remember this graphic,
53:56 - there's a lot going on here. But this is our neural network. We have some kind of input,
54:00 - some kind of numerical encoding. Now, we start with this data. In our case, it's unstructured data
54:05 - because we have some images here, some text here, and some audio file here. Now, these necessarily
54:11 - don't go in all at the same time. This image could just focus on a neural network specifically
54:17 - for images. This text could focus on a neural network specifically for text. And this sound bite
54:23 - or speech could focus on a neural network specifically for speech. However, the field is sort of also
54:29 - moving towards building neural networks that are capable of handling all three types of inputs.
54:34 - For now, we're going to start small and then build up the algorithms that we're going to focus on
54:39 - are neural networks that focus on one type of data. But the premise is still the same. You have
54:45 - some kind of input. You have to numerically encode it in some form, pass it to a neural network
54:50 - to learn representations or patterns within that numerical encoding, output some form of
54:55 - representation. And then we can convert that representation into things that humans understand.
55:01 - And you might have already seen these, and I might have already referenced the fact that
55:07 - these are tensors. So when the question comes up, what are tensors? A tensor could be almost
55:13 - anything. It could be almost any representation of numbers. We're going to get very hands on with
55:18 - tensors. And that's actually the fundamental building block of PyTorch aside from neural network
55:23 - components is the torch dot tensor. We're going to see that very shortly. But this is a very
55:31 - important takeaway is that you have some sort of input data. You're going to numerically encode
55:36 - that data, turn it into a tensor of some kind. Whatever that kind is will depend on the problem
55:41 - you're working with. Then you're going to pass it to a neural network, which will perform mathematical
55:47 - operations on that tensor. Now, a lot of those mathematical operations are taken care of by
55:54 - PyTorch behind the scenes. So we'll be writing code to execute some kind of mathematical
55:59 - operations on these tensors. And then the neural network that we create, or the one that's already
56:06 - been created, but we just use for our problem, we'll output another tensor, similar to the input,
56:12 - but has been manipulated in a certain way that we've sort of programmed it to. And then we can take
56:17 - this output tensor and change it into something that a human can understand. So to remove a lot
56:25 - of the text around it, make it a little bit more clearer. If we were focusing on building an image
56:30 - classification model, so we want to classify whether this was a photo of Raman or spaghetti,
56:35 - we would have images as input. We would turn those images into numbers, which are represented
56:40 - by a tensor. We would pass that tensor of numbers to a neural network, or there might be lots of
56:45 - tensors here. We might have 10,000 images. We might have a million images. Or in some cases,
56:50 - if you're Google or Facebook, you might be working with 300 million or a billion images at a time.
56:56 - The principle still stands that you encode your data in some form of numerical representation,
57:02 - which is a tensor, pass that tensor, or lots of tensors to a neural network. The neural network
57:08 - performs mathematical operations on those tensors, outputs a tensor, we convert that tensor into
57:14 - something that we can understand as humans. And so with that being said, we've covered a lot of
57:20 - the fundamentals. What is machine learning? What is deep learning? What is neural network? Well,
57:24 - we've touched the surface of these things. You can get as deep as you like. We've covered
57:28 - why use PyTorch. What is PyTorch? Now, the fundamental building block of deep learning
57:33 - is tensors. We've covered that. Let's get a bit more specific in the next video
57:37 - of what we're going to cover code-wise in this first module. I'm so excited we're going to start
57:43 - codes in. I'll see you in the next video. Now it's time to get specific about what we're going to
57:50 - cover code-wise in this fundamentals module. But I just want to reiterate the fact that
57:56 - going back to the last video where I challenge you to look up what is a tensor, here's exactly
58:01 - what I would do. I would come to Google. I would type in the question, what is a tensor? There we go.
58:06 - What is a tensor in PyTorch? It knows Google knows that using that deep learning data that we want
58:11 - to know what a tensor is in PyTorch. But a tensor is a very general thing. It's not
58:15 - associated with just PyTorch. Now we've got tensor on Wikipedia. We've got tensor. This is probably
58:21 - my favorite video on what is a tensor. By Dan Flesch. Flesch, I'm probably saying that wrong,
58:26 - but good first name. This is going to be your extra curriculum for this video and the previous
58:33 - video is to watch this on what is a tensor. Now you might be saying, well, what gives? I've come to
58:38 - this course to learn PyTorch and all this guy's doing, all you're doing, Daniel, is just Googling
58:43 - things when a question comes up. Why don't you just tell me what it is? Well, if I was to tell you
58:49 - everything about deep learning and machine learning and PyTorch and what it is and what it's not,
58:53 - that course would be far too long. I'm doing this on purpose. I'm searching questions like this on
58:58 - purpose because that's exactly what I do day to day as a machine learning engineer. I write code
59:04 - like we're about to do. And then if I don't know something, I literally go to whatever search engine
59:09 - I'm using, Google most of the time, and type in whatever error I'm getting or PyTorch, what is
59:14 - a tensor, something like that. So I want to not only tell you that it's okay to search questions
59:20 - like that, but it's encouraged. So just keep that in mind as we go through the whole course,
59:25 - you're going to see me do it a lot. Let's get into what we're going to cover. Here we go.
59:31 - Now, this tweet is from Elon Musk. And so I've decided, you know what, let's base the whole
59:36 - course on this tweet. We have learning MLDL from university, you have a little bit of a small brain.
59:41 - Online courses, well, like this one, that brain's starting to explode and you get some little fireworks
59:47 - from YouTube. Oh, you're watching this on YouTube. Look at that shiny brain from articles. My goodness.
59:54 - Lucky that this course comes in article format. If you go to learn pytorch.io, all of the course
60:03 - materials are in online book format. So we're going to get into this fundamental section very
60:08 - shortly. But if you want a reference, the course materials are built off this book. And by the
60:13 - time you watch this, there's going to be more chapters here. So we're covering all the bases
60:17 - here. And then finally, from memes, you would ascend to some godlike creature. I think that's
60:23 - hovering underwater. So that is the best way to learn machine learning. So this is what we're
60:27 - going to start with MLDL from university online courses, YouTube from articles from memes. No,
60:33 - no, no, no. But kind of here is what we're going to cover broadly. So now in this module,
60:42 - we are going to cover the pytorch basics and fundamentals, mainly dealing with tensors and
60:47 - tensor operations. Remember, a neural network is all about input tensors, performing operations on
60:52 - those tensors, creating output operations. Later, we're going to be focused on pre-processing data,
60:59 - getting it into tensors, so turning data from raw form, images, whatever, into a numerical
61:06 - encoding, which is a tensor. Then we're going to look at building and using pre-trained deep
61:09 - learning models, specifically neural networks. We're going to fit a model to the data. So we're
61:14 - going to show our model or write code for our model to learn patterns in the data that we've
61:18 - pre-processed. We're going to see how we can make predictions with our model, because that's
61:22 - what deep learning and machine learning is all about, right, using patterns from the past to
61:26 - predict the future. And then we're going to evaluate our model's predictions. We're going to learn
61:30 - how to save and load our models. For example, if you wanted to export your model from where we're
61:34 - working to an application or something like that. And then finally, we're going to see how we can
61:39 - use a trained model to make predictions on our own data on custom data, which is very fun. And
61:46 - how? Well, you can see that the scientist has faded out a little bit, but that's not really that true.
61:51 - We're going to do it like cooks, not chemists. So chemists are quite precise. Everything has to be
61:56 - exactly how it is. But cooks are more like, oh, you know what, a little bit of salt, a little bit of
62:01 - butter. Does it taste good? Okay, well, then we're on. But machine learning is a little bit of both.
62:06 - It's a little bit of science, a little bit of art. That's how we're going to do it. But
62:11 - I like the idea of this being a machine learning cooking show. So welcome to cooking with machine
62:15 - learning, cooking with PyTorch with Daniel. And finally, we've got a workflow here, which we have
62:25 - a PyTorch workflow, which is one of many. We're going to kind of use this throughout the entire
62:29 - course is step one, we're going to get our data ready. Step two, we're going to build a
62:34 - pick a pre trained model to suit whatever problem we're working on. Step two point one,
62:38 - pick a loss function and optimizer. Don't worry about what they are. We're going to cover them
62:42 - soon. Step two point two, build a training loop. Now this is kind of all part of the parcel of
62:47 - step two, hence why we've got two point one and two point two. You'll see what that means later on.
62:52 - Number three, we're going to fit the model to the data and make a prediction. So say we're working
62:55 - on image classification for Raman or spaghetti. How do we build a neural network or put our
63:01 - images through that neural network to get some sort of idea of what's in an image? We'll see
63:06 - how to do that. Well, the value weight our model to see if it's predicting BS or it's actually
63:11 - going all right. Number five, we're going to improve through experimentation. That's another
63:16 - big thing that you'll notice throughout machine learning throughout this course is that it's
63:20 - very experimental part art, part science. Number six, save and reload your trained model. Again,
63:27 - I put these with numerical order, but they can kind of be mixed and matched depending on where
63:33 - you are in the journey. But numerical order is just easy to understand for now. Now we've got
63:40 - one more video, maybe another one before we get into code. But in the next video, I'm going to
63:45 - cover some very, very important points on how you should approach this course. I'll see you there.
63:54 - Now you might be asking, how should I approach this course? You might not be asking, but we're
63:58 - going to answer it anyway. How to approach this course? This is how I would recommend approaching
64:03 - this course. So I'm a machine learning engineer day to day and learning machine learning to
64:10 - coding machine learning, a kind of two different things. I remember when I first learned it was
64:14 - kind of, you learned a lot of theory rather than writing code. So not to take away from the theory
64:18 - of being important, this course is going to be focusing on writing machine learning specifically
64:24 - PyTorch code. So the number one step to approaching this course is to code along. Now because this
64:31 - course is focused on purely writing code, I will be linking extracurricular resources for you to
64:37 - learn more about what's going on behind the scenes of the code. My idea of teaching is that if we
64:43 - can code together, write some code, see how it's working, that's going to spark your curiosity to
64:48 - figure out what's going on behind the scenes. So motto number one is if and out, run the code,
64:55 - write it, run the code, see what happens. Number two, I love that. Explore an experiment again.
65:05 - Approach this with the idea, the mind of a scientist and a chef or science and art. Experiment,
65:13 - experiment, experiment. Try things with rigor like a scientist would, and then just try things
65:18 - for the fun of it like a chef would. Number three, visualize what you don't understand. I can't
65:25 - emphasize this one enough. We have three models so far. If and out, run the code, you're going to
65:29 - hear me say this a lot. Experiment, experiment, experiment. And number three, visualize, visualize,
65:34 - visualize. Why is this? Well, because we've spoken about machine learning and deep learning
65:39 - deals with a lot of data, a lot of numbers. And so I find it that if I visualize some numbers in
65:45 - whatever form that isn't just numbers all over a page, I tend to understand it better.
65:51 - And there are some great extracurricular resources that I'm going to link that also turn what we're
65:57 - doing. So writing code into fantastic visualizations. Number four, ask questions, including the dumb
66:07 - questions. Really, there's no such thing as a dumb question. Everyone is just on a different
66:11 - part of their learning journey. And in fact, if you do have a quote unquote dumb question,
66:15 - it turns out that a lot of people probably have that one as well. So be sure to ask questions.
66:20 - I'm going to link a resource in a minute of where you can ask those questions, but
66:24 - please, please, please ask questions, not only to the community, but to Google to the internet
66:29 - to wherever you can, or just yourself. Ask questions of the code and write code to figure
66:33 - out the answer to those questions. Number five, do the exercises. There are some
66:38 - great exercises that I've created for each of the modules. If we go, have we got the book version
66:44 - of the course up here? We do. Within all of these chapters here, down the bottom is going to be
66:51 - exercises and extra curriculum. So we've got some exercises. I'm not going to jump into them,
66:56 - but I would highly recommend don't just follow along with the course and code after I code.
67:02 - Please, please, please give the exercises a go because that's going to stretch your knowledge.
67:09 - We're going to have a lot of practice writing code together, doing all of this stuff here.
67:13 - But then the exercises are going to give you a chance to practice what you've learned.
67:16 - And then of course, extra curriculum. Well, hey, if you want to learn more, there's plenty of
67:22 - opportunities to do so there. And then finally, number six, share your work. I can't emphasize
67:30 - enough how much writing about learning deep learning or sharing my work through GitHub or
67:36 - different code resources or with the community has helped with my learning. So if you learn
67:42 - something cool about PyTorch, I'd love to see it. Link it to me somehow in the Discord chat
67:47 - or on GitHub or whatever. There'll be links of where you can find me. I'd love to see it. Please
67:53 - do share your work. It's a great way to not only learn something because when you share it, when
67:58 - you write about it, it's like, how would someone else understand it? But it's also a great way to
68:02 - help others learn too. And so we said how to approach this course. Now, let's go how not to
68:10 - approach this course. I would love for you to avoid overthinking the process. And this is your brain,
68:16 - and this is your brain on fire. So avoid having your brain on fire. That's not a good place to be.
68:21 - We are working with PyTorch, so it's going to be quite hot. Just playing on words with the name
68:27 - torch. But avoid your brain catching on fire. And avoid saying, I can't learn,
68:33 - I've said this to myself lots of times, and then I've practiced it and it turns out I can
68:38 - actually learn those things. So let's just draw a red line on there. Oh, I think a red line.
68:42 - Yeah, there we go. Nice and thick red line. We'll get that out there. It doesn't really make sense
68:46 - now that this says avoid and crossed out. But don't say I can't learn and prevent your brain from
68:52 - catching on fire. Finally, we've got one more video that I'm going to cover before this one
68:58 - gets too long of the resources for the course before we get into coding. I'll see you there.
69:03 - Now, there are some fundamental resources that I would like you to be aware of before we
69:10 - go any further in this course. These are going to be paramount to what we're working with.
69:14 - So for this course, there are three things. There is the GitHub repo. So if we click this link,
69:22 - I've got a pinned on my browser. So you might want to do the same while you're going through
69:25 - the course. But this is Mr. D. Burks in my GitHub slash PyTorch deep learning. It is still a work
69:32 - in progress at the time of recording this video. But by the time you go through it, it won't look
69:35 - too much different, but there just be more materials. You'll have materials outline,
69:40 - section, what does it cover? As you can see, some more are coming soon at the time of recording
69:44 - this. So these will probably be done by the time you watch this exercise in extra curriculum.
69:49 - There'll be links here. Basically, everything you need for the course will be in the GitHub repo.
69:54 - And then if we come back, also on the GitHub repo, the same repo. So Mr. D. Burks slash PyTorch
70:02 - deep learning. If you click on discussions, this is going to be the Q and A. This is just the same
70:08 - link here, the Q and A for the course. So if you have a question here, you can click new discussion,
70:13 - you can go Q and A, and then type in video, and then the title PyTorch Fundamentals, and then go
70:25 - in here. Or you could type in your error as well. What is N-DIM for a tensor? And then in here,
70:35 - you can type in some stuff here. Hello. I'm having trouble on video X, Y, Z. Put in the name of the
70:42 - video. So that way I can, or someone else can help you out. And then code, you can go three
70:48 - back ticks, write Python, and then you can go import torch, torch dot rand n, which is going to
70:54 - create a tensor. We're going to see this in a second. Yeah, yeah, yeah. And then if you post that
70:59 - question, the formatting of the code is very helpful that we can understand what's going on,
71:05 - and what's going on here. So this is basically the outline of how I would ask a question video.
71:11 - This is going on. What is such and such for whatever's going on? Hello. This is what I'm having
71:16 - trouble with. Here's the code, and here's what's happening. You could even include the error message,
71:21 - and then you can just click start discussion, and then someone, either myself or someone else from
71:26 - the course will be able to help out there. And the beautiful thing about this is that it's all in
71:30 - one place. You can start to search it. There's nothing here yet because the course isn't out yet,
71:34 - but as you go through it, there will probably be more and more stuff here. Then if you have any
71:38 - issues with the code that you think needs fixed, you can also open a new issue there. I'll let you
71:44 - read more into what's going on. I've just got some issues here already about the fact that I
71:48 - need to record videos for the course. I need to create some stuff. But if you think there's
71:52 - something that could be improved, make an issue. If you have a question about the course,
71:57 - ask a discussion. And then if we come back to the keynote, we have one more resource. So that
72:02 - was the course materials all live in the GitHub. The course Q&A is on the course
72:06 - GitHub's discussions tab, and then the course online book. Now, this is a work of art.
72:13 - This is quite beautiful. It is some code to automatically turn all of the materials from the
72:18 - GitHub. So if we come into here code, if we click on notebook zero zero, this is going to sometimes
72:24 - if you've ever worked with Jupiter notebooks on GitHub, they can take a while to load.
72:29 - So all of the materials here automatically get converted into this book. So the beautiful
72:35 - thing about the book is that it's got different headings here. It's all readable. It's all online.
72:40 - It's going to have all the images there. And you can also search some stuff here,
72:43 - PyTorch training steps, creating a training loop in PyTorch. Beautiful. We're going to see
72:50 - this later on. So they're the three big materials that you need to be aware of, the three big resources
72:56 - for this specific course materials on GitHub course Q&A course online book, which is
73:03 - learn pytorch.io, simple URL to remember, all the materials will be there. And then
73:09 - specifically for PyTorch or things PyTorch, the PyTorch website and the PyTorch forums.
73:15 - So if you have a question that's not course related, but more PyTorch related, I'd highly
73:20 - recommend you go to the PyTorch forums, which is available at discuss.pytorch.org. We've got a link
73:25 - there. Then the PyTorch website, PyTorch.org, this is going to be your home ground for everything
73:30 - PyTorch of course. We have the documentation here. And as I said, this course is not a replacement
73:36 - for getting familiar with the PyTorch documentation. This, the course actually is built off all of
73:42 - the PyTorch documentation. It's just organized in a slightly different way. So there's plenty of
73:47 - amazing resources here on everything to do with PyTorch. This is your home ground. And you're
73:52 - going to see me referring to this a lot throughout the course. So just keep these in mind, course
73:58 - materials on GitHub, course discussions, learnpytorch.io. This is all for the course. And all things
74:05 - PyTorch specific, so not necessarily this course, but just PyTorch in general, the PyTorch website
74:11 - and the PyTorch forums. With that all being said, we've come so far. We've covered a lot already,
74:18 - but guess what time it is? Let's write some code. I'll see you in the next video.
74:25 - We've covered enough of the fundamentals so far. Well, from a theory point of view,
74:32 - let's get into coding. So I'm going to go over to Google Chrome. I'm going to introduce you to
74:36 - the tool. One of the main tools we're going to be using for the entire course. And that is Google
74:41 - Colab. So the way I would suggest following along with this course is remember, one of the major
74:47 - ones is to code along. So we're going to go to colab.research.google. I've got a typo here.
74:52 - Classic. You're going to see me do lots of typos throughout this course. Colab.research.google.com.
74:58 - This is going to load up Google Colab. Now, you can follow along with what I'm going to do,
75:03 - but if you'd like to find out how to use Google Colab from a top-down perspective,
75:09 - you can go through some of these. I'd probably recommend going through overview of
75:13 - Collaboratory Features. But essentially, what Google Colab is going to enable us to do is
75:18 - create a new notebook. And this is how we're going to practice writing PyTorch code.
75:23 - So if you refer to the reference document of learnpytorch.io, these are actually
75:30 - Colab notebooks just in book format, so online book format. So these are the basis materials
75:37 - for what the course is going to be. There's going to be more here, but every new module,
75:42 - we're going to start a new notebook. And I'm going to just zoom in here.
75:46 - So this one, the first module is going to be zero, zero, because Python code starts at zero,
75:51 - zero. And we're going to call this PyTorch Fundamentals. I'm going to call mine video,
75:57 - just so we know that this is the notebook that I wrote through the video. And what this is going
76:02 - to do is if we click Connect, it's going to give us a space to write Python code. So here we can go
76:08 - print. Hello, I'm excited to learn PyTorch. And then if we hit shift and enter, it comes out like
76:16 - that. But another beautiful benefit of Google Colab are PS. I'm using the pro version, which
76:22 - costs about $10 a month or so. That price may be different depending on where you're from.
76:26 - The reason I'm doing that is because I use Colab all the time. However, you do not have to use
76:31 - the paid version for this course. Google Colab comes with a free version, which you'll be able
76:36 - to use to complete this course. If you see it worthwhile, I find the pro version is worthwhile.
76:42 - Another benefit of Google Colab is if we go here, we can go to runtime. Let me just show you that
76:47 - again. Runtime, change runtime type, hardware accelerator. And we can choose to run our code
76:55 - on an accelerator here. Now we've got GPU and TPU. We're going to be focused on using
77:00 - GPU. If you'd like to look into TPU, I'll leave that to you. But we can click GPU, click save.
77:06 - And now our code, if we write it in such a way, will run on the GPU. Now we're going to see this
77:13 - later on code that runs on the GPU is a lot faster in terms of compute time, especially for deep
77:20 - learning. So if we write here in a video SMI, we now have access to a GPU. In my case, I have a
77:27 - Tesla P100. It's quite a good GPU. You tend to get the better GPUs. If you pay for Google Colab,
77:34 - if you don't pay for it, you get the free version, you get a free GPU. It just won't be as fast as
77:39 - the GPUs you typically get with the paid version. So just keep that in mind. A whole bunch of stuff
77:44 - that we can do here. I'm not going to go through it all because there's too much. But we've covered
77:50 - basically what we need to cover. So if we just come up here, I'm going to write a text cell. So
77:56 - oo dot pytorch fundamentals. And I'm going to link in here resource notebook. Now you can come
78:07 - to learn pytorch.io and all the notebooks are going to be in sync. So 00, we can put this in here.
78:14 - Resource notebook is there. That's what this notebook is going to be based off. This one here.
78:20 - And then if you have a question about what's going on in this notebook,
78:24 - you can come to the course GitHub. And then we go back, back. This is where you can see what's
78:31 - going on. This is pytorch deep learning projects as you can see what's happening. At the moment,
78:35 - I've got pytorch course creation because I'm in the middle of creating it. But if you have a question,
78:40 - you can come to Mr. D Burke slash pytorch deep learning slash discussions, which is this tab here,
78:45 - and then ask a question by clicking new discussion. So any discussions related to this notebook,
78:51 - you can ask it there. And I'm going to turn this right now. This is a code cell.
78:56 - CoLab is basically comprised of code and text cells. I'm going to turn this into a text cell
79:01 - by pressing command mm, shift and enter. Now we have a text cell. And then if we wanted another
79:07 - code cell, we could go like that text code text code, yada, yada, yada. But I'm going to delete this.
79:14 - And to finish off this video, we're going to import pytorch. So we're going to import torch.
79:20 - And then we're going to print torch dot dot version. So that's another beautiful thing about Google
79:27 - Colab is that it comes with pytorch pre installed and a lot of other common Python data science
79:33 - packages, such as we could also go import pandas as PD, import NumPy as MP import mapplot lib
79:43 - lib dot pyplot as PLT. This is Google Colab is by far the easiest way to get started with this
79:53 - course. You can run things locally. If you'd like to do that, I'd refer to you to pytorch deep
80:00 - learning is going to be set up dot MD, getting set up to code pytorch. We've just gone through
80:06 - number one setting up with Google Colab. There is also another option for getting started locally.
80:12 - Right now, this document's a work in progress, but it'll be finished by the time you watch this
80:15 - video. This is not a replacement, though, for the pytorch documentation for getting set up
80:20 - locally. So if you'd like to run locally on your machine, rather than going on Google Colab,
80:25 - please refer to this documentation or set up dot MD here. But if you'd like to get started
80:31 - as soon as possible, I'd highly recommend you using Google Colab. In fact, the entire course
80:36 - is going to be able to be run through Google Colab. So let's finish off this video, make sure
80:40 - we've got pytorch ready to go. And of course, some fundamental data science packages here.
80:47 - Wonderful. This means that we have pytorch 1.10.0. So if your version number is far greater than this,
80:55 - maybe you're watching this video a couple of years in the future, and pytorch is up to 2.11,
81:00 - maybe some of the code in this notebook won't work. But 1.10.0 should be more than enough for
81:05 - what we're going to do. And plus Q111, CU111, stands for CUDA version 11.1, I believe. And what
81:15 - that would mean is if we came in here, and we wanted to install it on Linux, which is what
81:20 - Colab runs on, there's Mac and Windows as well. We've got CUDA. Yeah. So right now, as of recording
81:27 - this video, the latest pytorch build is 1.10.2. So you'll need at least pytorch 1.10 to complete
81:33 - this course and CUDA 11.3. So that's CUDA toolkit. If you remember, CUDA toolkit is NVIDIA's
81:44 - programming. There we go. NVIDIA developer. CUDA is what enables us to run our pytorch code on
81:51 - NVIDIA GPUs, which we have access to in Google Colab. Beautiful. So we're set up ready to write code.
82:00 - Let's get started in the next video writing some pytorch code. This is so exciting. I'll see you
82:05 - there. So we've got set up. We've got access to pytorch. We've got a Google Colab instance running
82:13 - here. We've got a GPU because we've gone up to runtime, change runtime type, hardware accelerator.
82:18 - You won't necessarily need a GPU for this entire notebook, but I just wanted to show you how to
82:23 - get access to a GPU because we're going to be using them later on. So let's get rid of this.
82:30 - And one last thing, how I'd recommend going through this course is in a split window fashion.
82:36 - So for example, you might have the video where I'm talking right now and writing code on the
82:40 - left side, and then you might have another window over the other side with your own Colab
82:46 - window. And you can go new notebook, call it whatever you want, my notebook. You could call it very
82:55 - similar to what we're writing here. And then if I write code over on this side, on this video,
83:01 - you can't copy it, of course, but you'll write the same code here and then go on and go on and
83:05 - go on. And if you get stuck, of course, you have the reference notebook and you have an
83:10 - opportunity to ask a question here. So with that being said, let's get started. The first thing
83:15 - we're going to have a look at in PyTorch is an introduction to tenses. So tenses are the main
83:23 - building block of deep learning in general, or data. And so you may have watched the video,
83:29 - what is a tensor? For the sake of this course, tenses are a way to represent data, especially
83:37 - multi dimensional data, numeric data that is, but that numeric data represents something else.
83:43 - So let's go in here, creating tenses. So the first kind of tensor we're going to create is
83:49 - actually called a scalar. I know I'm going to throw a lot of different names of things at you,
83:53 - but it's important that you're aware of such nomenclature. Even though in PyTorch, almost
83:58 - everything is referred to as a tensor, there are different kinds of tenses. And just to
84:03 - exemplify the fact that we're using a reference notebook, if we go up here, we can see we have
84:10 - importing PyTorch. We've done that. Now we're up to introduction to tenses. We've got creating
84:16 - tenses, and we've got scalar, etc, etc, etc. So this is what we're going to be working through.
84:22 - Let's do it together. So scalar, the way to, oops, what have I done there? The way to create a
84:29 - tensor in PyTorch, we're going to call this scalar equals torch dot tensor. And we're going to fill
84:36 - it with the number seven. And then if we press or retype in scalar, what do we get back? Seven,
84:42 - wonderful. And it's got the tensor data type here. So how would we find out about what torch dot
84:48 - tensor actually is? Well, let me show you how I would. We go to torch dot tensor. There we go.
84:55 - We've got the documentation. So this is possibly the most common class in PyTorch other than
85:00 - one we're going to see later on that you'll use, which is torch dot nn. Basically, everything in
85:06 - PyTorch works off torch dot tensor. And if you'd like to learn more, you can read through here.
85:11 - In fact, I would encourage you to read through this documentation for at least 10 minutes
85:15 - after you finish some videos here. So with that being said, I'm going to link that in here.
85:20 - So PyTorch tensors are created using torch dot tensor. And then we've got that link there.
85:32 - Oops, typos got law Daniel. Come on. They're better than this. No, I'm kidding. There's going to be
85:38 - typos got law through the whole course. Okay. Now, what are some attributes of a scalar? So
85:44 - some details about scalars. Let's find out how many dimensions there are. Oh, and by the way,
85:49 - this warning, perfect timing. Google Colab will give you some warnings here, depending on whether
85:55 - you're using a GPU or not. Now, the reason being is because Google Colab provides GPUs to you and
86:01 - I for free. However, GPUs aren't free for Google to provide. So if we're not using a GPU, we can
86:08 - save some resources, allow someone else to use a GPU by going to none. And of course, we can
86:14 - always switch this back. So I'm going to turn my GPU off so that someone else out there,
86:20 - I'm not using the GPU at the moment, they can use it. So what you're also going to see is if
86:25 - your Google Colab instance ever restarts up here, we're going to have to rerun these cells. So if
86:33 - you stop coding for a while, go have a break and then come back and you start your notebook again,
86:38 - that's one downside of Google Colab is that it resets after a few hours. How many hours? I don't
86:46 - know exactly. The reset time is longer if you have the pro subscription, but because it's a free
86:51 - service and the way Google calculate usage and all that sort of stuff, I can't give a conclusive
86:56 - evidence or conclusive answer on how long until it resets. But just know, if you come back, you might
87:02 - have to rerun some of your cells and you can do that with shift and enter. So a scalar has no
87:07 - dimensions. All right, it's just a single number. But then we move on to the next thing. Or actually,
87:13 - if we wanted to get this number out of a tensor type, we can use scalar dot item, this is going
87:19 - to give it back as just a regular Python integer. Wonderful, there we go, the number seven back,
87:26 - get tensor back as Python int. Now, the next thing that we have is a vector. So let's write
87:37 - in here vector, which again is going to be created with torch dot tensor. But you will also hear
87:44 - the word vector used a lot too. Now, what is the deal? Oops, seven dot seven. Google Colab's auto
87:52 - complete is a bit funny. It doesn't always do the thing you want it to. So if we see a vector,
87:57 - we've got two numbers here. And then if we really wanted to find out what is a vector.
88:02 - So a vector usually has magnitude and direction. So what we're going to see later on is, there we
88:10 - go, magnitude, how far it's going and which way it's going. And then if we plotted it, we've got,
88:15 - yeah, a vector equals the magnitude would be the length here and the direction would be where it's
88:20 - pointing. And oh, here we go, scalar vector matrix tensor. This is what we're working on as well.
88:26 - So the thing about vectors, how they differ with scalars is how I just remember them is
88:33 - rather than magnitude and direction is a vector typically has more than one number.
88:38 - So if we go vector and dim, how many dimensions does it have?
88:44 - It has one dimension, which is kind of confusing. But when we see tensors with more than one
88:50 - dimension, it'll make sense. And another way that I remember how many dimensions something
88:55 - has is by the number of square brackets. So let's check out something else. Maybe we go vector
89:03 - dot shape shape is two. So the difference between dimension. So dimension is like number of square
89:12 - brackets. And when I say, even though there's two here, I mean number of pairs of closing square
89:18 - brackets. So there's one pair of closing square brackets here. But the shape of the vector is two.
89:24 - So we have two by one elements. So that means a total of two elements. Now if we wanted to step
89:31 - things up a notch, let's create a matrix. So this is another term you're going to hear.
89:37 - And you might be wondering why I'm capitalizing matrix. Well, I'll explain that in the second
89:42 - matrix equals torch dot tensor. And we're going to put two square brackets here. You might be
89:50 - thinking, what could the two square brackets mean? Or actually, that's a little bit of a challenge.
89:55 - If one pair of square brackets had an endem of one, what will the endem be number of dimensions
90:02 - of two square brackets? So let's create this matrix. Beautiful. So we've got another tensor here.
90:12 - Again, as I said, these things have different names, like the traditional name of scalar,
90:18 - vector matrix, but they're all still a torch dot tensor. That's a little bit confusing,
90:24 - but the thing you should remember in PyTorch is basically anytime you encode data into numbers,
90:29 - it's of a tensor data type. And so now how many n number of dimensions do you think a matrix has?
90:38 - It has two. So there we go. We have two square brackets. So if we wanted to get matrix,
90:43 - let's index on the zeroth axis. Let's see what happens there. Ah, so we get seven and eight.
90:50 - And then we get off the first dimension. Ah, nine and 10. So this is where the square brackets,
90:58 - the pairings come into play. We've got two square bracket pairings on the outside here.
91:02 - So we have an endem of two. Now, if we get the shape of the matrix, what do you think the shape will be?
91:08 - Ah, two by two. So we've got two numbers here by two. So we have a total of four elements in there.
91:22 - So we're covering a fair bit of ground here, nice and quick, but that's going to be the
91:25 - teaching style of this course is we're going to get quite hands on and writing a lot of code and
91:30 - just interacting with it rather than continually going back over and discussing what's going on
91:36 - here. The best way to find out what's happening within a matrix is to write more code that's similar
91:42 - to these matrices here. But let's not stop at matrix. Let's upgrade to a tensor now. So I might
91:48 - put this in capitals as well. And I haven't explained what the capitals mean yet, but we'll see that
91:54 - in a second. So let's go torch dot tensor. And what we're going to do is this time,
92:01 - we've done one square bracket pairing. We've done two square bracket pairings. Let's do three
92:07 - square bracket pairings and just get a little bit adventurous. All right. And so you might be thinking
92:11 - at the moment, this is quite tedious. I'm just going to write a bunch of random numbers here. One,
92:16 - two, three, three, six, nine, two, five, four. Now you might be thinking, Daniel, you've said
92:23 - tensors could have millions of numbers. If we had to write them all by hand, that would be
92:28 - quite tedious. And yes, you're completely right. The fact is, though, that most of the time,
92:35 - you won't be crafting tensors by hand. PyTorch will do a lot of that behind the scenes. However,
92:41 - it's important to know that these are the fundamental building blocks of the models
92:45 - and the deep learning neural networks that we're going to be building. So tensor capitals as well,
92:51 - we have three square brackets. So, or three square bracket pairings. I'm just going to refer to three
92:57 - square brackets at the very start because they're going to be paired down here. How many n dim or
93:04 - number of dimensions do you think our tensor will have? Three, wonderful. And what do you think the
93:11 - shape of our tensor is? We have three elements here. We have three elements here, three elements
93:17 - here. And we have one, two, three. So maybe our tensor has a shape of one by three by three.
93:29 - Hmm. What does that mean? Well, we've got three by one, two, three. That's the second square
93:38 - bracket there by one. Ah, so that's the first dimension there or the zeroth dimension because
93:44 - we remember PyTorch is zero indexed. We have, well, let's just instead of talking about it,
93:49 - let's just get on the zeroth axis and see what happens with the zeroth dimension. There we go.
93:54 - Okay. So there's, this is the far left one, zero, which is very confusing because we've got a one
94:01 - here, but so we've got, oops, don't mean that. What this is saying is we've got one three by three
94:12 - shape tensor. So very outer bracket matches up with this number one here. And then this three
94:20 - matches up with the next one here, which is one, two, three. And then this three matches up with
94:28 - this one, one, two, three. Now, if you'd like to see this with a pretty picture, we can see it here.
94:36 - So dim zero lines up. So the blue bracket, the very outer one, lines up with the one. Then dim
94:44 - equals one, this one here, the middle bracket, lines up with the middle dimension here. And then
94:52 - dim equals two, the very inner lines up with these three here. So again, this is going to take a lot
95:01 - of practice. It's taken me a lot of practice to understand the dimensions of tensors. But
95:07 - to practice, I would like you to write out your own tensor of, you can put however many square
95:14 - brackets you want. And then just interact with the end dim shape and indexing, just as I've done
95:20 - here, but you can put any combination of numbers inside this tensor. That's a little bit of practice
95:25 - before the next video. So give that a shot and then we'll move on to the next topic.
95:30 - I'll see you there. Welcome back. In the last video, we covered the basic building blocks of data
95:39 - representation in deep learning, which is the tensor, or in PyTorch, specifically torch.tensor.
95:45 - But within that, we had to look at what a scalar is. We had to look at what a vector is. We had to
95:51 - look at a matrix. We had to look at what a tensor is. And I issued you the challenge to get as
95:57 - creative as you like with creating your own tensor. So I hope you gave that a shot because as you'll
96:01 - see throughout the course and your deep learning journey, a tensor can represent or can be of almost
96:07 - any shape and size and have almost any combination of numbers within it. And so this is very important
96:13 - to be able to interact with different tensors to be able to understand what the different names of
96:18 - things are. So when you hear matrix, you go, oh, maybe that's a two dimensional tensor. When you
96:24 - hear a vector, maybe that's a one dimensional tensor. When you hear a tensor, that could be any
96:28 - amount of dimensions. And just for reference for that, if we come back to the course reference,
96:33 - we've got a scalar. What is it? A single number, number of dimensions, zero. We've got a vector,
96:38 - a number with direction, number of dimensions, one, a matrix, a tensor. And now here's another little
96:45 - tidbit of the nomenclature of things, the naming of things. Typically, you'll see a variable name
96:52 - for a scalar or a vector as a lowercase. So a vector, you might have a lowercase y storing that
96:58 - data. But for a matrix or a tensor, you'll often see an uppercase letter or variable in Python in
97:06 - our case, because we're writing code. And so I am not exactly sure why this is, but this is just
97:12 - what you're going to see in machine learning and deep learning code and research papers
97:16 - across the board. This is a typical nomenclature. Scalars and vectors, lowercase, matrix and tensors,
97:22 - uppercase, that's where that naming comes from. And that's why I've given the tensor uppercase here.
97:28 - Now, with that being said, let's jump in to another very important concept with tensors.
97:34 - And that is random tensors. Why random tensors? I'm just writing this in a code cell now.
97:40 - I could go here. This is a comment in Python, random tensors. But we'll get rid of that. We could
97:48 - just start another text cell here. And then three hashes is going to give us a heading, random tensors
97:54 - there. Or I could turn this again into a markdown cell with command mm when I'm using Google Colab.
98:02 - So random tensors. Let's write down here. Why random tensors? So we've done the tedious thing
98:10 - of creating our own tensors with some numbers that we've defined, whatever these are. Again,
98:15 - you could define these as almost anything. But random tensors is a big part in pytorch because
98:21 - let's write this down. Random tensors are important because the way many neural networks learn is
98:34 - that they start with tensors full of random numbers and then adjust those random numbers
98:42 - to better represent the data. So seriously, this is one of the big concepts of neural networks.
98:52 - I'm going to write in code here, which is this is what the tick is for. Start with random numbers.
98:58 - Look at data, update random numbers. Look at data, update random numbers. That is the crux
99:19 - of neural networks. So let's create a random tensor with pytorch. Remember how I said that
99:25 - pytorch is going to create tensors for you behind the scenes? Well, this is one of the ways that
99:30 - it does so. So we create a random tensor and we give it a size of random tensor of size or shape.
99:40 - Pytorch use these independently. So size, shape, they mean the different versions of the same thing.
99:47 - So random tensor equals torch dot rand. And we're going to type in here three, four. And the beautiful
99:58 - thing about Google Colab as well is that if we wait long enough, it's going to pop up with the doc
100:02 - string of what's going on. I personally find this a little hard to read in Google Colab,
100:07 - because you see you can keep going down there. You might be able to read that. But what can we do?
100:13 - Well, we can go to torch dot rand. Then we go to the documentation. Beautiful. Now there's a whole
100:19 - bunch of stuff here that you're more than welcome to read. We're not going to go through all that.
100:24 - We're just going to see what happens hands on. So we'll copy that in here. And write this in notes,
100:31 - torch random tensors. Done. Just going to make some code cells down here. So I've got some space.
100:37 - I can get this a bit up here. Let's see what our random tensor looks like. There we go. Beautiful
100:46 - of size three, four. So we've got three or four elements here. And then we've got three deep
100:53 - here. So again, there's the two pairs. So what do you think the number of dimensions will be
100:59 - for random tensor? And dim. Two beautiful. And so we have some random numbers here. Now the
101:09 - beautiful thing about pie torch again is that it's going to do a lot of this behind the scenes. So
101:14 - if we wanted to create a size of 10 10, in some cases, we won't want one dimension here. And then
101:20 - it's going to go 10 10. And then if we check the number of dimensions, how many do you think it
101:24 - will be now three? Why is that? Because we've got one 10 10. And then if we wanted to create 10 10 10.
101:32 - What's the number of dimensions going to be? It's not going to change. Why is that?
101:36 - We haven't run that cell yet, but we've got a lot of numbers here.
101:42 - We can find out what 10 times 10 times 10 is. And I know we can do that in our heads, but
101:47 - the beauty of collab is we've got a calculator right here. 10 times 10 times 10. We've got a
101:51 - thousand elements in there. But sometimes tenses can be hundreds of thousands of elements or
101:57 - millions of elements. But pie torch is going to take care of a lot of this behind the scenes. So
102:01 - let's clean up a bit of space here. This is a random tensor. Random numbers beautiful of now
102:10 - it's got two dimensions because we've got three by four. And if we put another one in the front
102:15 - there, we're going to have how many dimensions three dimensions there. But again, this number
102:20 - of dimensions could be any number. And what's inside here could be any number. Let's get rid of that.
102:26 - And let's get a bit specific because right now this is just a random tensor of whatever dimension.
102:31 - How about we create a random tensor with similar shape to an image tensor. So a lot of the time
102:44 - when we turn images, image size tensor, when we turn images into tenses, they're going to have,
102:51 - let me just write it in code for you first, size equals a height, a width, and a number of color
102:58 - channels. And so in this case, it's going to be height with color channels. And the color channels
103:06 - are red, green, blue. And so let's create a random image tensor. Let's view the size of it or the
103:15 - shape. And then random image size tensor will view the end dim. Beautiful. Okay, so we've got
103:28 - torch size, the same size two, two, four, two, four, three, height, width, color channels. And we've got
103:36 - three dimensions, one, four, height, width, color channels. Let's go and see an example of this. This
103:42 - is the PyTorch Fundamentals notebook. If we go up to here, so say we wanted to encode this image
103:50 - of my dad eating pizza with thumbs up of a square image of two, two, four by two, two, four.
103:56 - This is an input. And if we wanted to encode this into tensor format, well, one of the ways of
104:02 - representing an image tensor, very common ways is to split it into color channels because with
104:07 - red, green, and blue, you can create almost any color you want. And then we have a tensor
104:12 - representation. So sometimes you're going to see color channels come first. We can switch this
104:17 - around and our code quite easily by going color channels here. But you'll also see color channels
104:24 - come at the end. I know I'm saying a lot that we kind of haven't covered yet. The main takeaway
104:28 - from here is that almost any data can be represented as a tensor. And one of the common ways to represent
104:35 - images is in the format color channels, height, width, and how these values are will depend on
104:42 - what's in the image. But we've done this in a random way. So the takeaway from this video is
104:48 - that PyTorch enables you to create tensors quite easily with the random method. However, it is
104:55 - going to do a lot of this creating tensors for you behind the scenes and why a random tensor is so
105:02 - valuable because neural networks start with random numbers, look at data such as image tensors,
105:08 - and then adjust those random numbers to better represent that data. And they repeat those steps
105:15 - onwards and onwards and onwards. Let's finish this video here. I'm going to challenge for you
105:20 - just to create your own random tensor of whatever size and shape you want. So you could have 5, 10,
105:26 - 10 here and see what that looks like. And then we'll keep coding in the next video.
105:33 - I hope you took on the challenge of creating random tensor of your own size. And just a little
105:37 - tidbit here. You might have seen me in the previous video. I didn't use the size parameter. But in
105:42 - this case, I did here, you can go either way. So if we go torch dot rand size equals, we put in a
105:49 - tuple here of three three, we've got that tensor there three three. But then also if we don't put
105:55 - the size in there, it's the default. So it's going to create a very similar tensor. So whether you
106:01 - have this size or not, it's going to have quite a similar output depending on the shape that you
106:07 - put in there. But now let's get started to another kind of tensor that you might see zeros and ones.
106:16 - So say you wanted to create a tensor, but that wasn't just full of random numbers,
106:21 - you wanted to create a tensor of all zeros. This is helpful for if you're creating some form of
106:30 - mask. Now, we haven't covered what a mask is. But essentially, if we create a tensor of all zeros,
106:41 - what happens when you multiply a number by zero? All zeros. So if we wanted to multiply
106:48 - these two together, let's do zeros times random tensor.
106:53 - There we go, all zeros. So maybe if you're working with this random tensor and you wanted to mask
107:04 - out, say all of the numbers in this column for some reason, you could create a tensor of zeros in
107:10 - that column, multiply it by your target tensor, and you would zero all those numbers. That's telling
107:15 - your model, hey, ignore all of the numbers that are in here because I've zeroed them out. And then
107:20 - if you wanted to create a tensor of all ones, create a tensor of all ones, we can go ones equals
107:28 - torch dot ones, size equals three, four. And then if we have a look, there's another parameter I
107:37 - haven't showed you yet, but this is another important one is the D type. So the default data type,
107:43 - so that's what D type stands for, is torch dot float. We've actually been using torch dot float
107:49 - the whole time, because that's whenever you create a tensor with pytorch, we're using a pytorch
107:54 - method, unless you explicitly define what the data type is, we'll see that later on, defining
107:58 - what the data type is, it starts off as torch float 32. So these are float numbers. So that
108:06 - is how you create zeros and ones zeros is probably I've seen more common than ones in use, but just
108:13 - keep these in mind, you might come across them. There are lots of different methods to creating
108:17 - tensors. And truth be told, like random is probably one of the most common, but you might see zeros
108:25 - and ones out in the field. So now we've covered that. Let's move on into the next video, where
108:31 - we're going to create a range. So have a go at creating a tensor full of zeros and whatever size
108:36 - you want, and a tensor full of ones and whatever size you want. And I'll see you in the next video.
108:42 - Welcome back. I hope you took on the challenge of creating a torch tensor of zeros of your
108:47 - own size and ones of your own size. But now let's investigate how we might create a range of
108:55 - tensors and tensors like. So these are two other very common methods of creating tensors.
109:05 - So let's start by creating a range. So we'll first use torch dot range, because depending on
109:12 - when you're watching this video, torch dot range may be still in play or it may be deprecated.
109:19 - If we write in torch dot range right now with the pie torch version that I'm using, which is
109:25 - torch dot version, which is torch or pie torch 1.10 point zero torch range is deprecated and
109:33 - will be removed in a future release. So just keep that in mind. If you come across some code that's
109:37 - using torch dot range, maybe out of whack. So the way to get around that is to fix that is to use
109:44 - a range instead. And if we just write in torch dot a range, we've got tensors of zero to nine,
109:52 - because it of course starts at zero index. If we wanted one to 10, we could go like this.
109:57 - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. And we can go zero, or we go 1, 2, 10, equals torch a range.
110:10 - Wonderful. And we can also define the step. So let's let's type in some start and where can we
110:17 - find the documentation on a range? Sometimes in Google Colab, you can press shift tab,
110:22 - but I find that it doesn't always work for me. Yeah, you could hover over it, but we can also just
110:28 - go torch a range and look for the documentation torch a range. So we've got start and step. Let's
110:36 - see what all of these three do. Maybe we start at zero, and maybe we want it to go to a thousand,
110:44 - and then we want a step of what should our step be? What's a fun number? 77. So it's not one to 10
110:53 - anymore, but here we go. We've got start at zero, 77 plus 77 plus 77, all the way up to it finishes
111:01 - at a thousand. So if we wanted to take it back to one to 10, we can go up here. 110, and the default
111:09 - step is going to be one. Oops, we needed the end to be that it's going to finish at end minus one.
111:17 - There we go. Beautiful. Now we can also create tensors like. So creating tensors like. So tensors
111:27 - like is say you had a particular shape of a tensor you wanted to replicate somewhere else, but you
111:32 - didn't want to explicitly define what that shape should be. So what's the shape of one to 10?
111:42 - One to 10. Now if we wanted to create a tensor full of zeros that had the same shape as this,
111:47 - we can use tensor like or zeros like. So 10 zeros, zeros equals, I'm not even sure if I'm
111:57 - spelling zeros right then, zeros. Well, I might have a typo spelling zeros here, but you get what
112:03 - I'm saying is torch zeros. Oh, torch spell it like that. That's why I'm spelling it like that.
112:10 - Zeros like one to 10. And then the input is going to be one to 10. And we have a look at 10 zeros.
112:19 - My goodness, this is taking quite the while to run. This is troubleshooting on the fly.
112:28 - If something's happening like this, you can try to stop. If something was happening like that,
112:33 - you can click run and then stop. Well, it's running so fast that I can't click stop. If you do also
112:38 - run into trouble, you can go runtime, restart runtime. We might just do that now just to show you.
112:44 - Restart and run all is going to restart the compute engine behind the collab notebook.
112:48 - And run all the cells to where we are. So let's just see that we restart and run runtime. If you're
112:53 - getting errors, sometimes this helps. There is no set in stone way to troubleshoot errors. It's
113:00 - guess and check with this. So there we go. We've created 10 zeros, which is torch zeros like
113:07 - our one to 10 tensor. So we've got zeros in the same shape as one to 10. So if you'd like to create
113:14 - tensors, use torch arrange and get deprecated message. Use torch arrange instead for creating
113:26 - a range of tensors with a start and end in a step. And then if you wanted to create tensors
113:31 - or a tensor like something else, you want to look for the like method. And then you put an input,
113:38 - which is another tensor. And then it'll create a similar tensor with whatever this method here
113:43 - is like in that fashion or in the same shape as your input. So with that being said,
113:49 - give that a try, create a range of tensors, and then try to replicate that range shape that you've
113:54 - made with zeros. I'll see you in the next video. Welcome back. Let's now get into a very important
114:04 - topic of tensor data types. So we've briefly hinted on this before. And I said that let's create
114:12 - a tensor to begin with float 32 tensor. And we're going to go float 32 tensor equals torch
114:20 - dot tensor. And let's just put in the numbers three, six, nine. If you've ever played need for
114:29 - speed underground, you'll know where three, six, nine comes from. And then we're going to go
114:34 - D type equals, let's just put none and see what happens, hey, float 32 tensor. Oh, what is the
114:45 - data type? float 32, tensor dot D type. float 32, even though we put none, this is because
114:54 - the default data type in pytorch, even if it's specified as none is going to come out as float 32.
115:00 - What if we wanted to change that to something else? Well, let's type in here float 16.
115:07 - And now we've got float 32 tensor. This variable name is a lie now because it's a float 16 tensor.
115:14 - So we'll leave that as none. Let's go there. There's another parameter when creating tensors.
115:20 - It's very important, which is device. So we'll see what that is later on. And then there's a
115:26 - final one, which is also very important, which is requires grad equals false. Now this could be
115:32 - true, of course, we're going to set this as false. So these are three of the most important parameters
115:38 - when you're creating tensors. Now, again, you won't necessarily always have to enter these when
115:43 - you're creating tensors, because pytorch does a lot of tensor creation behind the scenes for you.
115:49 - So let's just write out what these are. Data type is what data type is the tensor, e.g. float 32,
115:58 - or float 16. Now, if you'd like to look at what data types are available for pytorch tensors,
116:04 - we can go torch tensor and write up the top unless the documentation changes. We have data types.
116:11 - It's so important that data types is the first thing that comes up when you're creating a tensor.
116:17 - So we have 32-bit floating point, 64-bit floating point, 16, 16, 32-bit complex. Now,
116:24 - the most common ones that you will likely interact with are 32-bit floating point and 16-bit floating
116:30 - point. Now, what does this mean? What do these numbers actually mean? Well, they have to do with
116:36 - precision in computing. So let's look up that. Precision in computing. Precision computer science.
116:44 - So in computer science, the precision of a numerical quantity, we're dealing with numbers, right?
116:50 - As a measure of the detail in which the quantity is expressed. This is usually measured in bits,
116:55 - but sometimes in decimal digits. It is related to precision in mathematics, which describes the
117:01 - number of digits that are used to express a value. So, for us, precision is the numerical quantity,
117:08 - is a measure of the detail, how much detail in which the quantity is expressed. So, I'm not going
117:14 - to dive into the background of computer science and how computers represent numbers. The important
117:19 - takeaway for you from this will be that single precision floating point is usually called float
117:25 - 32, which means, yeah, a number contains 32 bits in computer memory. So if you imagine, if we have
117:33 - a tensor that is using 32 bit floating point, the computer memory stores the number as 32 bits.
117:40 - Or if it has 16 bit floating point, it stores it as 16 bits or 16 numbers representing or 16.
117:46 - I'm not sure if a bit equates to a single number in computer memory. But what this means is that
117:52 - a 32 bit tensor is single precision. This is half precision. Now, this means that it's the default
117:59 - of 32, float 32, torch dot float 32, as we've seen in code, which means it's going to take up
118:05 - a certain amount of space in computer memory. Now, you might be thinking, why would I do anything
118:10 - other than the default? Well, if you'd like to sacrifice some detail in how your number is
118:16 - represented. So instead of 32 bits, it's represented by 16 bits, you can calculate faster on numbers
118:25 - that take up less memory. So that is the main differentiator between 32 bit and 16 bit. But if
118:32 - you need more precision, you might go up to 64 bit. So just keep that in mind as you go forward.
118:38 - Single precision is 32. Half precision is 16. What do these numbers represent? They represent
118:45 - how much detail a single number is stored in memory. That was a lot to take in. But we're talking
118:53 - about 10 to data types. I'm spending a lot of time here, because I'm going to put a note here,
118:58 - note, tensor data types is one of the three big issues with pytorch and deep learning or
119:11 - not not issues, they're going to be errors that you run into and deep learning. Three big
119:17 - errors, you'll run into with pytorch and deep learning. So one is tensors, not right data type.
119:29 - Two tensors, not right shape. We've seen a few shapes of four and three tensors, not on the right
119:39 - device. And so in this case, if we had a tensor that was float 16 and we were trying to do computations
119:48 - with a tensor that was float 32, we might run into some errors. And so that's the tensors not
119:53 - being in the right data type. So it's important to know about the D type parameter here. And then
119:58 - tensors not being the right shape. Well, that's once we get onto matrix multiplication, we'll see
120:03 - that if one tensor is a certain shape and another tensor is another shape and those shapes don't
120:08 - line up, we're going to run into shape errors. And this is a perfect segue to the device.
120:13 - Device equals none. By default, this is going to be CPU. This is why we are using Google Colab
120:19 - because it enables us to have access to, oh, we don't want to restart, enables us to have access
120:25 - to a GPU. As I've said before, a GPU enables us. So we could change this to CUDA. That would be,
120:32 - we'll see how to write device agnostic code later on. But this device, if you try to do
120:39 - operations between two tensors that are not on the same device. So for example, you have one tensor
120:46 - that lives on a GPU for fast computing, and you have another tensor that lives on a CPU and you
120:51 - try to do something with them, while pytorch is going to throw you an error. And then finally,
120:56 - this last requirement is grad is if you want pytorch to track the gradients, we haven't covered
121:01 - what that is of a tensor when it goes through certain numerical calculations. This is a bit of
121:06 - a bombardment, but I thought I'd throw these in as important parameters to be aware of since
121:12 - we're discussing data type. And really, it would be reminiscent of me to discuss data type without
121:17 - discussing not the right shape or not the right device. So with that being said, let's write down
121:24 - here what device is your tensor on, and whether or not to track gradients with this tensor's
121:36 - operations. So we have a float 32 tensor. Now, how might we change the tensor data type of this?
121:44 - Let's create float 16 tensor. And we saw that we could explicitly write in float 16 tensor.
121:52 - Or we can just type in here, float 16 tensor equals float 32 tensor dot type. And we're going to type
122:00 - in torch dot float 16, why float 16, because well, that's how we define float 16, or we could use
122:07 - half. So the same thing, these things are the same, let's just do half, or float 16 is more
122:14 - explicit for me. And then let's check out float 16 tensor. Beautiful, we've converted our float
122:25 - 32 tensor into float 16. So that is one of the ways that you'll be able to tackle the tensors
122:31 - not in the right data type issue that you run into. And just a little note on the precision
122:37 - and computing, if you'd like to read more on that, I'm going to link this in here. And this is all
122:43 - about how computers store numbers. So precision in computing. There we go. I'll just get rid of that.
122:53 - Wonderful. So give that a try, create some tensors, research, or go to the documentation of torch
122:59 - dot tensor and see if you can find out a little bit more about D type device and requires grad,
123:04 - and create some tensors of different data types. Play around with whatever the ones you want here,
123:09 - and see if you can run into some errors, maybe try to multiply two tensors together. So if you go
123:15 - float 16 tensor times float 32 tensor, give that a try and see what happens. I'll see you in the next
123:23 - video. Welcome back. In the last video, we covered a little bit about tensor data types,
123:30 - as well as some of the most common parameters you'll see past to the torch dot tensor method.
123:36 - And so I should do the challenge at the end of the last video to create some of your own tensors
123:40 - of different data types, and then to see what happens when you multiply a float 16 tensor by a
123:45 - float 32 tensor. Oh, it works. And but you've like Daniel, you said that you're going to have tensors
123:52 - not the right data type. Well, this is another kind of gotcha or caveat of pie torch and deep
123:58 - learning in general, is that sometimes you'll find that even if you think something may error
124:03 - because these two tensors are different data types, it actually results in no error. But then
124:08 - sometimes you'll have other operations that you do, especially training large neural networks,
124:13 - where you'll get data type issues. The important thing is to just be aware of the fact that some
124:18 - operations will run an error when your tensors are not in the right data type. So let's try another
124:23 - type. Maybe we try a 32 bit integer. So torch dot in 32. And we try to multiply that by a float.
124:32 - Wonder what will happen then? So let's go into 32 in 32 tensor equals torch dot tensor. And we'll
124:45 - just make it three. Notice that there's no floats there or no dot points to make it a float.
124:52 - Three, six, nine and D type can be torch in 32. And then in 32 tensor, what does this look like?
125:04 - Typo, of course, one of many in 32 tensor. So now let's go float 32 tensor and see what happens.
125:12 - Can we get pie torch to throw an error in 32 tensor?
125:17 - Huh, it worked as well. Or maybe we go into 64. What happens here?
125:28 - Still works. Now, see, this is again one of the confusing parts of doing tensor operations.
125:34 - What if we do a long tensor? Torch to long. Is this going to still work?
125:41 - Ah, torch has no attribute called long. That's not a data type issue.
125:45 - I think it's long tensor. Long tensor. Does this work? D type must be torch D type.
125:58 - Torch long tensor. I could have sworn that this was torch dot tensor.
126:08 - Oh, there we go. Torch dot long tensor. That's another word for 64 bit.
126:12 - So what is this saying? CPU tensor. Okay, let's see. This is some troubleshooting on the fly here.
126:23 - Then we multiply it. This is a float 32 times a long. It works. Okay, so it's actually a bit
126:29 - more robust than what I thought it was. But just keep this in mind when we're training models,
126:33 - we're probably going to run into some errors at some point of our tensor's not being the
126:36 - right data type. And if pie torch throws us an error saying your tensors are in the wrong data
126:40 - type, well, at least we know now how to change that data type or how to set the data type if we
126:46 - need to. And so with that being said, let's just formalize what we've been doing a fair bit already.
126:53 - And that's getting information from tensors. So the three big things that we'll want to get
126:59 - from our tensors in line with the three big errors that we're going to face in neural networks and
127:04 - deep lining is let's copy these down. Just going to get this, copy this down below. So if we want
127:13 - to get some information from tensors, how do we check the shape? How do we check the data type?
127:18 - How do we check the device? Let's write that down. So to get information from this, to get
127:24 - D type or let's write data type from a tensor can use tensor dot D type. And let's go here to get
127:39 - shape from a tensor can use tensor dot shape. And to get device from a tensor, which devices it on
127:52 - CPU or GPU can use tensor dot device. Let's see these three in action. So if we run into one of
128:02 - the three big problems in deep learning and neural networks in general, especially with PyTorch,
128:07 - tensor's not the right data type, tensor's not the right shape or tensor's not on the right device.
128:12 - Let's create a tensor and try these three out. We've got some tensor equals torch dot
128:19 - rand and we'll create it a three four. Let's have a look at what it looks like.
128:25 - There we go. Random numbers of shape three and four. Now let's find out some details about it.
128:32 - Find out details about some tensor. So print or print some tensor.
128:39 - And oops, didn't want that print. And let's format it or make an F string of shape of tensor.
128:50 - Oh, let's do data type first. We'll follow that order.
128:56 - Data type of tensor. And we're going to go, how do we do this? Some tensor dot what?
129:02 - Dot d type. Beautiful. And then we're going to print tensors not in the right shape. So let's go
129:13 - shape of tensor equals some tensor dot shape. Oh, I went a bit too fast, but we could also use
129:22 - size. Let's just confirm that actually. We'll code that out together. From my experience,
129:28 - some tensor dot size, and some tensor dot shape result in the same thing. Is that true? Oh, function.
129:40 - Oh, that's what it is. Some tensor dot size is a function, not an attribute.
129:49 - There we go. Which one should you use? For me, I'm probably more used to using shape. You may come
129:54 - across dot size as well, but just realize that they do quite the same thing except one's a function
129:59 - and one's an attribute. An attribute is written dot shape without the curly brackets. A function
130:06 - or a method is with the brackets at the end. So that's the difference between these are attributes
130:12 - here. D type size. We're going to change this to shape. Tensor attributes. This is what we're
130:18 - getting. I should probably write that down. This is tensor attributes. That's the formal name for
130:27 - these things. And then finally, what else do we want? Tensors, what device are we looking for?
130:32 - Let's get rid of this, get rid of this. And then print f device tensor is on. By default,
130:41 - our tensor is on the CPU. So some tensor dot device. There we go. So now we've got our tensor
130:52 - here, some tensor. The data type is a torch float 32 because we didn't change it to anything else.
130:57 - And torch float 32 is the default. The shape is three four, which makes a lot of sense because
131:02 - we passed in three four here. And the device tensor is on is the CPU, which is, of course,
131:07 - the default, unless we explicitly say to put it on another device, all of the tensors that we
131:12 - create will default to being on the CPU, rather than the GPU. And we'll see later on how to put
131:18 - tensors and other things in torch onto a GPU. But with that being said, give it a shot,
131:25 - create your own tensor, get some information from that tensor, and see if you can change
131:29 - these around. So see if you could create a random tensor, but instead of float 32, it's a float 16.
131:36 - And then probably another extracurricular, we haven't covered this yet. But see how to change
131:41 - the device a pytorch tensor is on. Give that a crack. And I'll see you in the next video.
131:49 - Welcome back. So in the last video, we had a look at a few tensor attributes, namely the data
131:55 - type of a tensor, the shape of a tensor, and the device that a tensor lives on. And I alluded to
132:01 - the fact that these will help resolve three of the most common issues in building neural networks,
132:08 - deep learning models, specifically with pytorch. So tensor has not been the right data type,
132:13 - tensor has not been the right shape, and tensor has not been on the right device. So now let's
132:19 - get into manipulating tensors. And what I mean by that, so let's just write here the title,
132:26 - manipulating tensors. And this is going to be tensor operations. So when we're building neural
132:32 - networks, neural networks are comprised of lots of mathematical functions that pytorch code is going
132:39 - to run behind the scenes for us. So let's go here, tensor operations include addition,
132:51 - subtraction, and these are the regular addition, subtraction, multiplication. There's two types
133:02 - of multiplication in that you'll typically see referenced in deep learning and neural networks,
133:09 - division, and matrix multiplication. And these, the ones here, so addition, subtraction,
133:17 - multiplication, division, your typical operations that you're probably familiar with matrix multiplication.
133:25 - The only different one here is matrix multiplication. We're going to have a look at that in a minute.
133:30 - But to find patterns in numbers of a data set, a neural network will combine these functions
133:37 - in some way, shape or form. So it takes a tensor full of random numbers, performs some kind of
133:43 - combination of addition, subtraction, multiplication, division, matrix multiplication. It doesn't have
133:48 - to be all of these. It could be any combination of these to manipulate these numbers in some way
133:53 - to represent a data set. So that's how a neural network learns is it will just comprise these
133:59 - functions, look at some data to adjust the numbers of a random tensor, and then go from there. But
134:05 - with that being said, let's look at a few of these. So we'll begin with addition. First thing we need
134:11 - to do is create a tensor. And to add something to a tensor, we'll just go torch tensor. Let's go one,
134:22 - two, three, add something to a tensor is tensor plus, we can use plus as the addition operator,
134:31 - just like in Python, tensor plus 10 is going to be tensor 11, 12, 13, tensor plus 100 is going to be
134:42 - as you'd expect plus 100. Let's leave that as plus 10 and add 10 to it. And so you might be
134:49 - able to guess how we would multiply it by 10. So let's go multiply tensor by 10. We can go tensor,
134:59 - star, which are my keyboard shift eight, 10. We get 10, 10, 10. And because we didn't reassign it,
135:10 - our tensor is still 123. So if we go, if we reassign it here, tensor equals tensor by 10,
135:19 - and then check out tensor, we've now got 10 2030. And the same thing here, we'll have 10 2030. But
135:26 - then if we go back from the top, if we delete this reassignment, oh, what do we get there, tensor
135:36 - by 10. Oh, what's happened here? Oh, because we've got, yeah, okay, I see, tensor by 10, tensor,
135:47 - still 123. What should we try now? How about subtract subtract 10 equals tensor minus 10.
135:58 - And you can also use, well, there we go, one minus 10, eight minus 10, three minus 10.
136:05 - You can also use like torch has inbuilt functions or pytorch. So try out pytorch
136:12 - inbuilt functions. So torch dot mall is short for multiply. We can pass in our tensor here,
136:24 - and we can add in 10. That's going to multiply each element of tensor by 10. So just taking
136:30 - the original tensor that we created, which is 123. And performing the same thing as this,
136:35 - I would recommend where you can use the operators from Python. If for some reason, you see torch
136:42 - dot mall, maybe there's a reason for that. But generally, these are more understandable if you
136:48 - just use the operators, if you need to do a straight up multiplication, straight up addition, or straight
136:53 - up subtraction, because torch also has torch dot add, torch dot add, is it torch dot add? It might
137:00 - be torch dot add. I'm not sure. Oh, there we go. Yeah, torch dot add. So as I alluded to before,
137:07 - there's two different types of multiplication that you'll hear about element wise and matrix
137:12 - multiplication. We're going to cover matrix multiplication in the next video. As a challenge,
137:18 - though, I would like you to search what is matrix multiplication. And I think the first website that
137:26 - comes up, matrix multiplication, Wikipedia, yeah, math is fun. It has a great guide. So before we
137:32 - get into matrix multiplication, jump into math is fun to have a look at matrix multiplying,
137:38 - and have a think about how we might be able to replicate that in pie torch. Even if you're not
137:43 - sure, just have a think about it. I'll see you in the next video. Welcome back. In the last video,
137:52 - we discussed some basic tensor operations, such as addition, subtraction, multiplication,
137:58 - element wise, division, and matrix multiplication. But we didn't actually go through what matrix
138:04 - multiplication is. So now let's start on that more particularly discussing the difference between
138:09 - element wise and matrix multiplication. So we'll come down here, let's write another heading,
138:15 - matrix multiplication. So there's two ways, or two main ways. Yeah, let's write that two main
138:23 - ways of performing multiplication in neural networks and deep learning. So one is the simple
138:33 - version, which is what we've seen, which is element wise multiplication. And number two is matrix
138:42 - multiplication. So matrix multiplication is actually possibly the most common tensor operation you
138:49 - will find inside neural networks. And in the last video, I issued the extra curriculum of having a
138:57 - look at the math is fun dot com page for how to multiply matrices. So the first example they go
139:04 - through is element wise multiplication, which just means multiplying each element by a specific
139:11 - number. In this case, we have two times four equals eight, two times zero equals zero, two times one
139:18 - equals two, two times negative nine equals negative 18. But then if we move on to matrix
139:23 - multiplication, which is multiplying a matrix by another matrix, we need to do the dot product.
139:30 - So that's something that you'll also hear matrix multiplication referred to as the dot product.
139:35 - So these two are used interchangeably matrix multiplication or dot product. And if we just
139:42 - look up the symbol for dot product, you'll find that it's just a dot. There we go, a heavy dot,
139:50 - images. There we go, a dot B. So this is vector a dot product B. A few different options there,
140:00 - but let's look at what it looks like in pytorch code. But first, there's a little bit of a
140:05 - difference here. So how did we get from multiplying this matrix here of one, two, three, four, five,
140:10 - six, times seven, eight, nine, 10, 11, 12? How did we get 58 there? Well, we start by going,
140:17 - this is the difference between element wise and dot product, by the way, one times seven.
140:23 - We'll record that down there. So that's seven. And then two times nine. So this is first row,
140:29 - first column, two times nine is 18. And then three times 11 is 33. And if we add those up,
140:36 - seven plus 18, plus 33, we get 58. And then if we were to do that for each other element that's
140:44 - throughout these two matrices, we end up with something like this. So that's what I'd encourage
140:50 - you to go through step by step and reproduce this a good challenge would be to reproduce this by
140:56 - hand with pytorch code. But now let's go back and write some pytorch code to do both of these. So
141:04 - I just want to link here as well, more information on multiplying matrices. So I'm going to turn
141:12 - this into markdown. Let's first see element wise, element wise multiplication. We're going to start
141:18 - with just a rudimentary example. So if we have our tensor, what is it at the moment? It's 123.
141:27 - And then if we multiply that by itself, we get 149. But let's print something out so it looks a bit
141:33 - prettier than that. So print, I'm going to turn this into a string. And then we do that. So if we
141:42 - print tensor times tensor, element wise multiplication is going to give us print equals. And then
141:51 - let's do in here tensor times tensor. We go like that. Wonderful. So we get one times one
142:00 - equals one, two times two equals four, three times three equals nine. Now for matrix multiplication,
142:08 - pytorch stores matrix multiplication, similar to torch dot mall in the torch dot mat mall space,
142:19 - which stands for matrix multiplication. So let's just test it out. Let's just true the exact
142:25 - same thing that we did here, instead of element wise, we'll do matrix multiplication on our 123
142:30 - tensor. What happens here? Oh my goodness, 14. Now why did we get 14 instead of 149? Can you guess
142:41 - how we got to 14 or think about how we got to 14 from these numbers? So if we recall back,
142:49 - we saw that for we're only multiplying two smaller tensors, by the way, 123. This example is with
142:58 - a larger one, but the same principle applies across different sizes of tensors or matrices.
143:04 - And when I say matrix multiplication, you can also do matrix multiplication between tensors.
143:10 - And in our case, we're using vectors just to add to the confusion. But what is the difference
143:16 - here between element wise and dot product? Well, we've got one main addition. And that is addition.
143:22 - So if we were to code this out by hand, matrix multiplication by hand, we'd have recall that
143:32 - the elements of our tensor are 123. So if we wanted to matrix multiply that by itself,
143:40 - we'd have one times one, which is the equivalent of doing one times seven in this visual example.
143:49 - And then we'd have plus, it's going to be two times two, two times two. What does that give us?
143:58 - Plus three times three. What does it give us? Three times three. That gives us 14. So that's how
144:08 - we got to that number there. Now we could do this with a for loop. So let's have a gaze at when I
144:14 - say gaze, it means have a look. That's a Australian colloquialism for having a look. But I want to
144:20 - show you the time difference in it might not actually be that big a difference if we do it by hand
144:27 - versus using something like matmore. And that's another thing to note is that if PyTorch has a
144:32 - method already implemented, chances are it's a fast calculating version of that method. So I know
144:40 - for basic operators, I said it's usually best to just use this straight up basic operator.
144:45 - But for something like matrix multiplication or other advanced operators instead of the basic
144:50 - operators, you probably want to use the torch version rather than writing a for loop, which is
144:55 - what we're about to do. So let's go value equals zero. This is matrix multiplication by hand. So
145:02 - for I in range, len tensor, so for each element in the length of our tensor, which is 123, we want to
145:11 - update our value to be plus equal, which is doing this plus reassignment here. The ith element in
145:19 - each tensor times the ith element. So times itself. And then how long is this going to take?
145:29 - Let's now return the value. We should get 14, print 14. There we go. So 1.9 milliseconds on
145:42 - whatever CPU that Google collab is using behind the scenes. But now if we time it and use the torch
145:49 - method torch dot matmore, it was tensor dot sensor. And again, we're using a very small tensor. So
145:55 - okay, there we go. It actually showed how much quicker it is, even with such a small tensor.
146:02 - So this is 1.9 milliseconds. This is 252 microseconds. So this is 10 times slower using a for loop,
146:13 - then pie torches vectorized version. I'll let you look into that if you want to find out what
146:18 - vectorization means. It's just a type of programming that rather than writing for loops, because as
146:24 - you could imagine, if this tensor was, let's say, had a million elements instead of just three,
146:30 - if you have to loop through each of those elements one by one, that's going to be quite cumbersome.
146:36 - So a lot of pie torches functions behind the scenes implement optimized functions to perform
146:45 - mathematical operations, such as matrix multiplication, like the one we did by hand,
146:49 - in a far faster manner, as we can see here. And that's only with a tensor of three elements.
146:56 - So you can imagine the speedups on something like a tensor with a million elements.
147:01 - But with that being said, that is the crux of matrix multiplication. For a little bit more,
147:06 - I encourage you to read through this documentation here by mathisfun.com. Otherwise,
147:12 - let's look at a couple of rules that we have to satisfy for larger versions of matrix multiplication.
147:17 - Because right now, we've done it with a simple tensor, only 123. Let's step things up a notch
147:22 - in the next video. Welcome back. In the last video, we were introduced to matrix multiplication,
147:30 - which although we haven't seen it yet, is one of the most common operations in neural networks.
147:38 - And we saw that you should always try to use torches implementation of certain operations,
147:46 - except if they're basic operations, like plus multiplication and whatnot,
147:51 - because chances are it's a lot faster version than if you would do things by hand. And also,
147:57 - it's a lot less code. Like compared to this, this is pretty verbose code compared to just a matrix
148:04 - multiply these two tensors. But there's something that we didn't allude to in the last video.
148:10 - There's a couple of rules that need to be satisfied when performing matrix multiplication.
148:14 - It worked for us because we have a rather simple tensor. But once you start to build larger tensors,
148:20 - you might run into one of the most common errors in deep learning. I'm going to write this down
148:25 - actually here. This is one to be very familiar with. One of the most common errors in deep
148:32 - learning, we've already alluded to this as well, is shape errors. So let's jump back to this in a
148:39 - minute. I just want to write up here. So there are two rules that performing or two main rules
148:50 - that performing matrix multiplication needs to satisfy. Otherwise, we're going to get an error.
148:57 - So number one is the inner dimensions must match. Let's see what this means.
149:06 - So if we want to have two tensors of shape, three by two, and then we're going to use the at symbol.
149:15 - Now, we might be asking why the at symbol. Well, the at symbol is another, is a like an operator
149:21 - symbol for matrix multiplication. So I just want to give you an example. If we go tensor at
149:29 - at stands for matrix multiplication, we get tensor 14, which is exactly the same as what we got there.
149:34 - Should you use at or should you use mat mall? I would personally recommend to use mat mall.
149:39 - It's a little bit clearer at sometimes can get confusing because it's not as common as seeing
149:43 - something like mat mall. So we'll get rid of that, but I'm just using it up here for brevity.
149:50 - And then we're going to go three, two. Now, this won't work. We'll see why in a second.
149:56 - But if we go two, three, at, and then we have three, two, this will work. Or, and then if we go
150:06 - the reverse, say threes on the outside, twos here. And then we have twos on the inside and threes
150:13 - on the outside, this will work. Now, why is this? Well, this is the rule number one. The inner
150:19 - dimensions must match. So the inner dimensions are what I mean by this is let's create torch
150:26 - round or create of size 32. And then we'll get its shape. So we have, so if we created a tensor
150:36 - like this, three, two, and then if we created another tensor, well, let me just show you straight
150:42 - up torch dot mat mall torch dot ran to watch this won't work. We'll get an error. There we go. So
150:53 - this is one of the most common errors that you're going to face in deep learning is that matrix
150:59 - one and matrix two shapes cannot be multiplied because it doesn't satisfy rule number one.
151:04 - The inner dimensions must match. And so what I mean by inner dimensions is this dimension multiplied
151:11 - by this dimension. So say we were trying to multiply three, two by three, two, these are the inner
151:19 - dimensions. Now this will work because why the inner dimensions match. Two, three by three, two,
151:29 - two, three by three, two. Now notice how the inner dimensions, inner, inner match. Let's see what
151:40 - comes out here. Look at that. And now this is where rule two comes into play. Two. The resulting
151:48 - matrix has the shape of the outer dimensions. So we've just seen this one two, three at three, two,
152:04 - which is at remember is matrix multiply. So we have a matrix of shape, two, three,
152:12 - matrix multiply a matrix of three, two, the inner dimensions match. So it works. The resulting shape
152:20 - is what? Two, two. Just as we've seen here, we've got a shape of two, two. Now what if we did
152:31 - the reverse? What if we did this one that also will work? Three on the outside. What do you think
152:38 - is going to happen here? In fact, I encourage you to pause the video and give it a go. So this
152:44 - is going to result in a three three matrix. But don't take my word for it. Let's have a look. Three,
152:50 - put two on the inside and we'll put two on the inside here and then three on the outside. What
152:57 - does it give us? Oh, look at that. A three three. One, two, three. One, two, three. Now what if we
153:05 - were to change this? Two and two. This can be almost any number you want. Let's change them both
153:11 - to 10. What's going to happen? Will this work? What's the resulting shape going to be? So the
153:18 - inner dimensions match? What's rule number two? The resulting matrix has the shape of the outer
153:24 - dimension. So what do you think is going to be the shape of this resulting matrix multiplication?
153:29 - Well, let's have a look. It's still three three. Wow. Now what if we go 10? 10 on the outside
153:40 - and 10 and 10 on the inside? What do we get? Well, we get, I'm not going to count all of those,
153:46 - but if we just go shape, we get 10 by 10. Because these are the two main rules of matrix multiplication
153:54 - is if you're running into an error that the matrix multiplication can't work. So let's say this was
153:58 - 10 and this was seven. Watch what's going to happen? We can't multiply them because the inner
154:05 - dimensions do not match. We don't have 10 and 10. We have 10 and seven. But then when we change
154:10 - this so that they match, we get 10 and 10. Beautiful. So now let's create a little bit more of a
154:17 - specific example. We'll create two tenses. We'll come down. Actually, to prevent this video from
154:23 - being too long, I've got an error in the word error. That's funny. We'll go on with one of those
154:28 - common errors in deep learning shape errors. We've just seen it, but I'm going to get a little bit
154:32 - more specific with that shape error in the next video. Before we do that, have a look at matrix
154:38 - multiplication. There's a website, my other favorite website. I told you I've got two. This is my
154:43 - other one. Matrix multiplication dot XYZ. This is your challenge before the next video. Put in
154:49 - some random numbers here, whatever you want, two, 10, five, six, seven, eight, whatever you want. Change
154:57 - these around a bit, three, four. Well, that's a five, not a four. And then multiply and just watch
155:05 - what happens. That's all I'd like you to do. Just watch what happens and we're going to replicate
155:10 - something like this in PyTorch code in the next video. I'll see you there.
155:16 - Welcome back. In the last video, we discussed a little bit more about matrix multiplication,
155:22 - but we're not done there. We looked at two of the main rules of matrix multiplication,
155:29 - and we saw a few errors of what happens if those rules aren't satisfied, particularly if the
155:34 - inner dimensions don't match. So this is what I've been alluding to as one of the most common
155:41 - errors in deep learning, and that is shape errors. Because neural networks are comprised of lots of
155:46 - matrix multiplication operations, if you have some sort of tensor shape error somewhere
155:52 - in your neural network, chances are you're going to get a shape error. So now let's investigate
155:59 - how we can deal with those. So let's create some tenses, shapes for matrix multiplication.
156:06 - And I also showed you the website, sorry, matrix multiplication dot xyz. I hope you had a go at
156:12 - typing in some numbers here and visualizing what happens, because we're going to reproduce
156:15 - something very similar to what happens here, but with PyTorch code. Shapes for matrix multiplication,
156:22 - we have tensor a, let's create this as torch dot tensor. We're going to create a tensor with
156:29 - just the elements one, two, all the way up to, let's just go to six, hey, that'll be enough. Six,
156:36 - wonderful. And then tensor b can be equal to a torch tensor
156:47 - of where we're going to go for this one. Let's go seven, 10, this will be a little bit confusing
156:53 - this one, but then we'll go eight, 11, and this will go up to 12, nine, 12. So it's the same
157:04 - sort of sequence as what's going on here, but they've been swapped around. So we've got the
157:09 - vertical axis here, instead of one, two, three, four, this is just seven, eight, nine, 10, 11, 12.
157:14 - But let's now try and perform a matrix multiplication. How do we do that?
157:19 - Torch dot mat mall for matrix multiplication. PS torch also has torch dot mm, which stands
157:25 - for matrix multiplication, which is a short version. So I'll just write down here so that you know
157:30 - tensor a, tensor b. I'm going to write torch dot mm is the same as torch dot mat mall. It's an alias
157:42 - for writing less code. This is literally how common matrix multiplications are in PyTorch
157:50 - is that they've made torch dot mm as an alias for mat mall. So you have to type four less characters
157:56 - using torch dot mm instead of mat mall. But I like to write mat mall because it's a little bit
158:02 - like it explains what it does a little bit more than mm. So what do you think's going to happen
158:09 - here? It's okay if you're not sure. But what you could probably do to find out is check the
158:14 - shapes of these. Does this operation matrix multiplication satisfy the rules that we just
158:20 - discussed? Especially this one. This is the main one. The inner dimensions must match.
158:25 - Well, let's have a look, hey? Oh, no, mat one and mat two shapes cannot be multiplied.
158:34 - Three by two and three by two. This is very similar to what we went through in the last video.
158:39 - But now we've got some actual numbers there. Let's check the shape.
158:44 - Oh, torch size three two. Torch size three two now. In the last video we created a random tensor
158:51 - and we could adjust the shape on the fly. But these tensors already exist. How might we adjust
158:57 - the shape of these? Well, now I'm going to introduce you to another very common operation or tensor
159:05 - manipulation that you'll see. And that is the transpose. To fix our tensor shape issues,
159:13 - we can manipulate the shape of one of our tensors using a transpose. And so, all right here,
159:32 - we're going to see this anyway, but I'm going to define it in words. A transpose switches the
159:38 - axes or dimensions of a given tensor. So let's see this in action. If we go, and the way to do it,
159:48 - is you can go tensor b dot t. Let's see what happens. Let's look at the original tensor b as well.
160:01 - So dot t stands for transpose. And that's a little bit hard to read, so we might do these on
160:06 - different lines, tensor b. We'll get rid of that. So you see what's happened here. Instead of
160:18 - tensor b, this is the original one. We might put the original on top. Instead of the original one
160:24 - having seven, eight, nine, 10, 11, 12 down the vertical, the transpose has transposed it to seven,
160:30 - eight, nine across the horizontal and 10, 11, 12 down here. Now, if we get the shape of this,
160:36 - tensor b dot shape, let's have a look at that. Let's have a look at the original shape, tensor b dot
160:43 - shape. What's happened? Oh, no, we've still got three, two. Oh, that's what I've missed out here.
160:55 - I've got a typo. Excuse me. I thought I was, you think code that you've written is working,
161:00 - but then you realize you've got something as small as just a dot t missing, and it throws off your
161:06 - whole train of thought. So you're seeing these arrows on the fly here. Now, tensor b is this,
161:13 - but its shape is torch dot size three, two. And if we try to matrix multiply three, two, and three,
161:19 - two, tensor a and tensor b, we get an error. Why? Because the inner dimensions do not match.
161:26 - But if we perform a transpose on tensor b, we switch the dimensions around. So now,
161:35 - we perform a transpose with tensor b dot t, t's for transpose. We have, this is the important
161:43 - point as well. We still have the same elements. It's just that they've been rearranged. They've
161:49 - been transposed. So now, tensor b still has the same information encoded, but rearranged.
161:56 - So now we have torch size two, three. And so when we try to matrix multiply these,
162:02 - we satisfy the first criteria. And now look at the output of the matrix multiplication of tensor a
162:09 - and tensor b dot t transposed is three, three. And that is because of the second rule of matrix
162:17 - multiplication. The resulting matrix has the shape of the outer dimensions. So we've got three,
162:23 - two matrix multiply two, three results in a shape of three, three. So let's predify some of this,
162:31 - and we'll print out what's going on here. Just so we know, we can step through it,
162:36 - because right now we've just got codal over the place a bit. Let's see here, the matrix
162:41 - multiplication operation works when tensor b is transposed. And in a second, I'm going to
162:54 - show you what this looks like visually. But right now we've done it with pytorch code,
162:58 - which might be a little confusing. And that's perfectly fine. Matrix multiplication takes a
163:03 - little while and a little practice. So original shapes is going to be tensor a dot shape. Let's
163:10 - see what this is. And tensor b equals tensor b dot shape. But the reason why we're spending so
163:20 - much time on this is because as you'll see, as you get more and more into neural networks and
163:26 - deep learning, the matrix multiplication operation is one of the most or if not the most common.
163:32 - Same shape as above, because we haven't changed tensor a shape, we've only changed tensor b shape,
163:40 - or we've transposed it. And then in tensor b dot transpose equals, we want tensor b dot
163:50 - t dot shape. Wonderful. And then if we print, let's just print out, oops,
163:57 - print, I spelled the wrong word there, print. We want, what are we multiplying here? This is
164:06 - one of the ways, remember our motto of visualize, visualize, visualize, well, this is how I visualize,
164:11 - visualize, visualize things, shape, let's do the at symbol for brevity, tensor, and let's get b dot
164:19 - t dot shape. We'll put down our little rule here, inner dimensions must match. And then print,
164:29 - let's get the output output, I'll put that on a new line. The output is going to equal
164:37 - torch dot, or our outputs already here, but we're going to rewrite it for a little bit of practice,
164:43 - tensor a, tensor b dot t. And then we can go print output. And then finally, print, let's get it on a
164:55 - new line as well, the output shape, a fair bit going on here. But we're going to step through it,
165:00 - and it's going to help us understand a little bit about what's going on. That's the data visualizes
165:06 - motto. There we go. Okay, so the original shapes are what torch size three two, and torch size three
165:16 - two, the new shapes tensor a stays the same, we haven't changed tensor a, and then we have tensor
165:23 - b dot t is torch size two three, then we multiply a three by two by a two by three. So the inner
165:31 - dimensions must match, which is correct, they do match two and two. Then we have an output of tensor
165:37 - at 27, 30, 33, 61, 68, 75, etc. And the output shape is what the output shape is the outer
165:45 - dimensions three three. Now, of course, you could rearrange this maybe transpose tensor a instead of
165:52 - tensor b, have a play around with it. See if you can create some more errors trying to multiply these
165:58 - two, and see what happens if you transpose tensor a instead of tensor b, that's my challenge. But
166:03 - before we finish this video, how about we just recreate what we've done here with this cool website
166:11 - matrix multiplication. So what did we have? We had tensor a, which is one to six, let's recreate
166:17 - this, remove that, this is going to be one, two, three, four, five, six, and then we want to increase
166:28 - this, and this is going to be seven, eight, nine, 10, 11, 12. Is that the right way of doing things?
166:38 - So this is already transposed, just to let you know. So this is the equivalent of tensor b
166:43 - on the right here, tensor b dot t. So let me just show you, if we go tensor b dot transpose,
166:55 - which original version was that, but we're just passing in the transpose version to our matrix
167:01 - multiplication website. And then if we click multiply, this is what's happening behind the
167:06 - scenes with our pytorch code of matmore. We have one times seven plus two times 10. Did you see
167:12 - that little flippy thing that it did? That's where the 27 comes from. And then if we come down here,
167:17 - what's our first element? 27 when we matrix multiply them. Then if we do the same thing,
167:22 - the next step, we get 30 and 61, from a combination of these numbers, do it again,
167:29 - 33, 68, 95, from a combination of these numbers, again, and again, and finally we end up with
167:36 - exactly what we have here. So that's a little bit of practice for you to go through is to create
167:44 - some of your own tensors can be almost whatever you want. And then try to matrix multiply them
167:49 - with different shapes. See what happens when you transpose and what different values you get.
167:54 - And if you'd like to visualize it, you could write out something like this. That really
167:57 - helps me understand matrix multiplication. And then if you really want to visualize it,
168:01 - you can go through this website and recreate your target tensors in something like this.
168:07 - I'm not sure how long you can go. But yeah, that should be enough to get started.
168:12 - So give that a try and I'll see you in the next video.
168:17 - Welcome back. In the last few videos, we've covered one of the most fundamental operations
168:22 - in neural networks. And that is matrix multiplication. But now it's time to move on.
168:27 - And let's cover tensor aggregation. And what I mean by that is finding the min, max, mean,
168:37 - sum, et cetera, tensor aggregation of certain tensor values. So for whatever reason, you may
168:44 - want to find the minimum value of a tensor, the maximum value, the mean, the sum, what's going on
168:49 - there. So let's have a look at some few PyTorch methods that are in built to do all of these.
168:54 - And again, if you're finding one of these values, it's called tensor aggregation because you're
168:59 - going from what's typically a large amount of numbers to a small amount of numbers. So the min
169:04 - of this tensor would be 27. So you're turning it from nine elements to one element, hence
169:12 - aggregation. So let's create a tensor, create a tensor, x equals torch dot, let's use a range.
169:20 - We'll create maybe a zero to 100 with a step of 10. Sounds good to me. And we can find the min
169:30 - by going, can we do torch dot min? Maybe we can. Or we could also go
169:38 - x dot min.
169:39 - And then we can do the same, find the max torch dot max and x dot max. Now how do you think we
169:52 - might get the average? So let's try it out. Or find the mean, find the mean torch dot mean
170:03 - x. Oops, we don't have an x. Is this going to work? What's happened? Mean input data type
170:13 - should be either floating point or complex D types got long instead. Ha ha. Finally,
170:19 - I knew the error would show its face eventually. Remember how I said it right up here that
170:24 - we've covered a fair bit already. But right up here, some of the most common errors that
170:29 - you're going to run into is tensor is not the right data type, not the right shape. We've seen
170:33 - that with matrix multiplication, not the right device. We haven't seen that yet. But not the
170:36 - right data type. This is one of those times. So it turns out that the tensor that we created,
170:42 - x is of the data type, x dot D type.
170:48 - In 64, which is long. So if we go to, let's look up torch tensor.
170:53 - This is where they're getting long from. We've seen long before is N64. Where's that or long?
171:04 - Yeah. So long tenter. That's what it's saying. And it turns out that the torch mean function
171:09 - can't work on tensors with data type long. So what can we do here? Well, we can change
171:15 - the data type of x. So let's go torch mean x type and change it to float 32. Or before we do that,
171:25 - if we go to torch dot mean, is this going to tell us that it needs a D type? Oh, D type.
171:32 - One option on the desired data type. Does it have float 32? It doesn't tell us. Ah, so this is
171:48 - another one of those little hidden things that you're going to come across. And you only really
171:52 - come across this by writing code is that sometimes the documentation doesn't really tell you explicitly
171:58 - what D type the input should be, the input tensor. However, we find out that with this error message
172:06 - that it should either be a floating point or a complex D type, not along. So we can convert it
172:12 - to torch float 32. So all we've done is gone x type as type float 32. Let's see what happens here.
172:19 - 45 beautiful. And then the same thing, if we went, can we do x dot mean? Is that going to work as well?
172:29 - Oh, same thing. So if we go x dot type torch dot float 32, get the mean of that. There we go.
172:38 - So that is, I knew it would come up eventually. A beautiful example of finding the right data
172:44 - type. Let me just put a note here. Note the torch dot mean function requires a tensor of float 32.
172:57 - So so far, we've seen two of the major errors in PyTorch is data type and shape issues. What's
173:05 - another one that we said? Oh, some. So find the sum. Find the sum we want x dot sum or maybe we
173:12 - just do torch dot sum first. Keep it in line with what's going on above and x dot sum.
173:18 - Which one of these should you use like torch dot something x or x dot sum? Personally,
173:24 - I prefer torch dot max, but you'll also probably see me at points right this. It really depends
173:30 - on what's going on. I would say pick whichever style you prefer. And because behind the scenes,
173:35 - they're calling the same methodology. Picture whichever style you prefer and stick with that
173:40 - throughout your code. For now, let's leave it at that tensor aggregation. There's some
173:47 - finding min max mean sum. In the next video, we're going to look at finding the positional
173:53 - min and max, which is also known as arg max and arg min or vice versa. So actually, that's a
174:00 - little bit of a challenge for the next video is see how you can find out what the positional
174:05 - min and max is of this. And what I mean by that is which index does the max value occur at and
174:12 - which index of this tensor does the min occur at? You'll probably want to look into the methods
174:17 - arg min torch dot arg min for that one and torch dot arg max for that. But we'll cover that in the
174:23 - next video. I'll see you there. Welcome back. In the last video, we learned all about tensor
174:32 - aggregation. And we found the min the max the mean and the sum. And we also ran into one of the most
174:37 - common issues in pie torch and deep learning and neural networks in general. And that was wrong
174:44 - data types. And so we solved that issue by converting because some functions such as torch dot mean
174:50 - require a specific type of data type as input. And we created our tensor here, which was of by
174:56 - default torch in 64. However, torch dot mean requires torch dot float 32. We saw that in an error.
175:03 - We fix that by changing the type of the inputs. I also issued you the challenge of finding
175:10 - finding the positional min and max. And you might have found that you can use the
175:17 - arg min for the minimum. Let's remind ourselves of what x is x. So this means at tensor index of
175:30 - tensor x. If we find the argument, that is the minimum value, which is zero. So at index zero,
175:36 - we get the value zero. So that's at zero there. Zero there. This is an index value. So this is
175:44 - what arg min stands for find the position in tensor that has the minimum value with arg min.
175:57 - And then returns index position of target tensor
176:05 - where the minimum value occurs. Now, let's just change x to start from one,
176:18 - just so there we go. So the arg min is still position zero, position zero. So this is an index
176:27 - value. And then if we index on x at the zeroth index, we get one. So the minimum value in
176:34 - x is one. And then the maximum, you might guess, is find the position in tensor that has the maximum
176:43 - value with arg max. And it's going to be the same thing, except it'll be the maximum, which is,
176:51 - which position index nine. So if we go zero, one, two, three, four, five, six, seven, eight,
177:00 - nine. And then if we index on x for the ninth element, we get 91 beautiful. Now these two are
177:09 - useful for if yes, you want to define the minimum of a tensor, you can just use min. But if you
177:17 - sometimes you don't want the actual minimum value, you just want to know where it appears,
177:22 - particularly with the arg max value. This is helpful for when we use the soft max activation
177:28 - function later on. Now we haven't covered that yet. So I'm not going to allude too much to it.
177:32 - But just remember to find the positional min and max, you can use arg min and arg max.
177:39 - So that's all we need to cover with that. Let's keep going in the next video. I'll see you then.
177:47 - Welcome back. So we've covered a fair bit of ground. And just to let you know, I took a little break
177:53 - after going through all of these. And I'd just like to show you how I get back to where I'm at,
177:57 - because if we tried to just write x here and press shift and enter, because our collab
178:04 - was disconnected, it's now connecting because as soon as you press any button in collab, it's
178:08 - going to reconnect. It's going to try to connect, initialize, and then x is probably not going to
178:15 - be stored in memory anymore. So there we go. Name x is not defined. That's because the collab
178:21 - state gets reset if you take a break for a couple of hours. This is to ensure Google can keep
178:26 - providing resources for free. And it deletes everything to ensure that there's no compute
178:31 - resources that are being wasted. So to get back to here, I'm just going to go restart and run all.
178:38 - You don't necessarily have to restart the notebook. You could also go, do we have run all? Yeah,
178:44 - we could do run before. That'll run every cell before this. We could run after we could run the
178:48 - selection, which is this cell here. I'm going to click run all, which is just going to go through
178:53 - every single cell that we've coded above and run them all. However, it will also stop at the errors
179:01 - where I've left in on purpose. So remember when we ran into a shape error? Well, because this error,
179:06 - we didn't fix it. I left it there on purpose so that we could keep seeing a shape error. It's
179:11 - going to stop at this cell. So we're going to have to run every cell after the error cell.
179:17 - So see how it's going to run these now. They run fine. And then we get right back to where we were,
179:22 - which was X. So that's just a little tidbit of how I get back into coding. Let's now cover reshaping,
179:32 - stacking, squeezing, and unsqueezing. You might be thinking, squeezing and unsqueezing. What are
179:39 - you talking about, Daniel? Well, it's all to do with tenses. And you're like, are we going to
179:45 - squeeze our tenses? Give them a hug. Are we going to let them go by unsqueezing them?
179:50 - Well, let's quickly define what these are. So reshaping is we saw before one of the most common
179:56 - errors in machine learning and deep learning is shape mismatches with matrices because they
180:01 - have to satisfy certain rules. So reshape reshapes an input tensor to a defined shape.
180:10 - Now, we're just defining these things in words right now, but we're going to see it in code in
180:15 - just a minute. There's also view, which is return a view of an input tensor of certain shape,
180:26 - but keep the same memory as the original tensor. So we'll see what view is in a second.
180:34 - Reshaping and view are quite similar, but a view always shares the same memory as the original
180:40 - tensor. It just shows you the same tensor, but from a different perspective, a different shape.
180:46 - And then we have stacking, which is combine multiple tensors on top of each other. This is a V stack
180:55 - for vertical stack or side by side. H stack. Let's see what different types of torch stacks there are.
181:05 - Again, this is how I research different things. If I wanted to learn something new, I would search
181:09 - torch something stack concatenate a sequence of tensors along a new dimension. Okay. So maybe we
181:16 - not H stack or V stack, we can just define what dimension we'd like to combine them on.
181:21 - I wonder if there is a torch V stack. Torch V stack. Oh, there it is. And is there a torch H stack for
181:28 - horizontal stack? There is a H stack. Beautiful. So we'll focus on just the plain stack. If you
181:34 - want to have a look at V stack, it'll be quite similar to what we're going to do with stack
181:39 - and same with H stack. Again, this is just words for now. We're going to see the code in a minute.
181:43 - So there's also squeeze, which removes all one dimensions. I'm going to put one in code,
181:52 - dimensions from a tensor. We'll see what that looks like. And then there's unsqueeze,
181:58 - which adds a one dimension to our target tensor. And then finally, there's permute, which is return
182:11 - a view of the input with dimensions permuted. So swapped in a certain way. So a fair few methods
182:25 - here. But essentially the crust of all of these, the main point of all of these is to manipulate
182:32 - our tensors in some way to change their shape or change their dimension. Because again, one of the
182:39 - number one issues in machine learning and deep learning is tensor shape issues. So let's start
182:45 - off by creating a tensor and have a look at each of these. Let's create a tensor. And then we're
182:51 - going to just import torch. We don't have to, but this will just enable us to run the notebook
182:56 - directly from this cell if we wanted to, instead of having to run everything above here. So let's
183:02 - create another X torch dot a range because range is deprecated. I'm just going to add a few code
183:09 - cells here so that I can scroll and that's in the middle of the screen there. Beautiful. So let's
183:15 - just make it between one and 10 nice and simple. And then let's have a look at X and X dot shape.
183:22 - What does this give us? Okay, beautiful. So we've got the numbers from one to nine. Our tensor is
183:30 - of shape torch size nine. Let's start with reshape. So how about we add an extra dimension. So then
183:40 - we have X reshaped equals X dot reshape. Now a key thing to keep in mind about the reshape
183:48 - is that the dimensions have to be compatible with the original dimensions. So we're going to
183:54 - change the shape of our original tensor with a reshape. And we try to change it into the shape
183:59 - one seven. Does that work with the number nine? Well, let's find out, hey, let's check out X reshaped.
184:06 - And then we'll look at X reshaped dot shape. What's this going to do? Oh, why do we get an error there?
184:16 - Well, it's telling us here, this is what pie torch is actually really good at is giving us
184:21 - errors for what's going wrong. We have one seven is invalid for input size of nine.
184:26 - Well, why is that? Well, we're trying to squeeze nine elements into a tensor of one
184:32 - times seven into seven elements. But if we change this to nine, what do we get? Ah, so do you notice
184:40 - what just happened here? We just added a single dimension. See the single square bracket with
184:45 - the extra shape here. What if we wanted to add two? Can we do that? No, we can't. Why is that?
184:51 - Well, because two nine is invalid for input size nine, because two times nine is what?
184:57 - 18. So we're trying to double the amount of elements without having double the amount of elements.
185:02 - So if we change this back to one, what happens if we change these around nine one? What does this
185:07 - do? Oh, a little bit different there. So now instead of adding one on the first dimension or
185:14 - the zeroth dimension, because Python is zero indexed, we added it on the first dimension,
185:21 - which is giving us a square bracket here if we go back. So we add it to the outside here,
185:27 - because we've put the one there. And then if we wanted to add it on the inside,
185:32 - we put the one on the outside there. So then we've got the torch size nine one. Now, let's try
185:37 - change the view, change the view. So just to reiterate, the reshape has to be compatible
185:45 - with the original size. So how about we change this to one to 10? So we have a size of 10,
185:50 - and then we can go five, two, what happens there? Oh, it's compatible because five times two equals
185:57 - 10. And then what's another way we could do this? How about we make it up to 12? So we've got 12
186:05 - elements, and then we can go three, four, a code cells taking a little while run here.
186:12 - Then we'll go back to nine, just so we've got the original there.
186:22 - Whoops, they're going to be incompatible. Oh, so this is another thing. This is good.
186:31 - We're getting some errors on the fly here. Sometimes you'll get saved failed with Google
186:35 - CoLab, and automatic saving failed. What you can do to fix this is just either keep coding,
186:40 - keep running some cells, and CoLab will fix itself in the background, or restart the notebook,
186:46 - close it, and open again. So we've got size nine, or size eight, sorry, incompatible.
186:54 - But this is good. You're seeing the errors that come up on the fly, rather than me sort of just
186:59 - telling you what the errors are, you're seeing them as they come up for me. I'm trying to live
187:03 - code this, and this is what's going to happen when you start to use Google CoLab, and subsequently
187:09 - other forms of Jupyter Notebooks. But now let's get into the view, so we can go z equals,
187:16 - let's change the view of x. View will change it to one nine, and then we'll go z, and then z dot shape.
187:29 - Ah, we get the same thing here. So view is quite similar to reshape. Remember, though, that a
187:36 - view shares the memory with the original tensor. So z is just a different view of x. So z shares
187:44 - the same memory as what x does. So let's exemplify this. So changing z changes x, because a view of
187:54 - a tensor shares the same memory as the original input. So let's just change z, change the first
188:04 - element by using indexing here. So we're targeting one, we'll set this to equal five, and then we'll
188:11 - see what z and x equal. Yeah, so see, we've got z, the first one here, we change the first element,
188:19 - the zero element to five. And the same thing happens with x, we change the first element of z.
188:25 - So because z is a view of x, the first element of x changes as well. But let's keep going. How
188:32 - about we stack some tenses on top of each other? And we'll see what the stack function does in
188:37 - torch. So stack tenses on top of each other. And I'll just see if I press command S to save,
188:48 - maybe we'll get this fixed. Or maybe it just will fix itself. Oh, notebook is saved.
188:56 - Unless you've made some extensive changes that you're worried about losing, you could just
189:01 - download this notebook, so file download, and upload it to collab. But usually if you click yes,
189:08 - it sort of resolves itself. Yeah, there we go. All changes saved. So that's beautiful
189:13 - troubleshooting on the fly. I like that. So x stack, let's stack some tenses together,
189:18 - equals torch stack. Let's go x x x, because if we look at what the doc string of stack is,
189:25 - will we get this in collab? Or we just go to the documentations? Yeah. So list, it takes a list of
189:32 - tenses and concatenates a sequence of tenses along a new dimension. And we define the dimension,
189:37 - the dimension by default is zero. That's a little bit hard to read for me. So tenses,
189:42 - dim equals zero. If we come into here, the default dimension is zero. Let's see what happens when
189:46 - we play around with the dimension here. So we've got four x's. And the first one, we'll just do it
189:52 - by default, x stack. Okay, wonderful. So they're stacked vertically. Let's see what happens if we
190:01 - change this to one. Oh, they rearranged a little and stack like that. What happens if we change it
190:07 - to two? Does it have a dimension to? Oh, we can't do that. Well, that's because the original shape
190:13 - of x is incompatible with using dimension two. So the only real way to get used to what happens
190:19 - here by stacking them on top of each other is to play around with the different values for the
190:23 - dimension. So dim zero, dim one, they look a little bit different there. Now they're on top of each
190:30 - other. And so the first zero index is now the zeroth tensor. And then same with two being there,
190:37 - three and so on. But we'll leave it at the default. And there's also v stack and h stack. I'll leave
190:44 - that to you to to practice those. But I think from memory v stack is using dimension equals zero.
190:52 - Or h stack is like using dimension equals one. I may have those back the front. You can correct me
190:57 - if I'm wrong there. Now let's move on. We're going to now have a look at squeeze and unsqueeze.
191:05 - So actually, I'm going to get you to practice this. So see if you can look up torch squeeze
191:10 - and torch unsqueeze. And see if you can try them out. We've created a tensor here. We've used
191:16 - reshape and view and we've used stack. The usage of squeeze and unsqueeze is quite similar. So give
191:22 - that a go. And to prevent this video from getting too long, we'll do them together in the next video.
191:29 - Welcome back. In the last video, I issued the challenge of trying out torch dot squeeze,
191:36 - which removes all single dimensions from a target tensor. And how would you try that out? Well,
191:45 - here's what I would have done. I'd go to torch dot squeeze and see what happens. Open up the
191:51 - documentation. Squeeze input dimension returns a tensor with all the dimensions of input size
191:58 - one removed. And does it have some demonstrations? Yes, it does. Wow. Okay. So you could copy this in
192:04 - straight into a notebook, copy it here. But what I'd actually encourage you to do quite often is
192:11 - if you're looking up a new torch method you haven't used, code all of the example by hand. And then
192:17 - just practice what the inputs and outputs look like. So x is the input here. Check the size of x,
192:23 - squeeze x, well, set the squeeze of x to y, check the size of y. So let's replicate something
192:30 - similar to this. We'll go into here, we'll look at x reshaped and we'll remind ourselves of x reshaped
192:38 - dot shape. And then how about we see what x reshaped dot squeeze looks like. Okay. What happened here?
192:50 - Well, we started with two square brackets. And we started with a shape of one nine
192:55 - and removes all single dimensions from a target tensor. And now if we call the squeeze method on
193:02 - x reshaped, we only have one square bracket here. So what do you think the shape of x reshaped dot
193:09 - squeeze is going to be? We'll check the shape here. It's just nine. So that's the squeeze method,
193:17 - removes all single dimensions. If we had one one nine, it would remove all of the ones. So it would
193:24 - just end up being nine as well. Now, let's write some print statements so we can have a little
193:31 - pretty output. So previous tensor, this is what I like to do. This is a form of visualize, visualize,
193:39 - visualize. If I'm trying to get my head around something, I print out each successive change
193:46 - to see what's happening. That way, I can go, Oh, okay. So that's what it was there. And then I
193:51 - called that line of code there. Yes, it's a bit tedious. But you do this half a dozen times, a
193:57 - fair few times. I mean, I still do it a lot of the time, even though I've written thousands of lines
194:02 - of machine learning code. But it starts to become instinct after a while, you start to go, Oh, okay,
194:07 - I've got a dimension mismatch on my tensors. So I need to squeeze them before I put them into a
194:13 - certain function. For a little while, but with practice, just like riding a bike, right? But that
194:23 - try saying is like when you first start, you're all wobbly all over the place having to look up
194:27 - the documentation, not that there's much documentation for riding a bike, you just kind of keep trying.
194:32 - But that's the style of coding. I'd like you to adopt is to just try it first. Then if you're stuck,
194:38 - go to the documentation, look something up, print it out like this, what we're doing,
194:42 - quite cumbersome. But this is going to give us a good explanation for what's happening. Here's our
194:47 - previous tensor x reshaped. And then if we look at the shape of x reshaped, it's one nine. And then
194:53 - if we call the squeeze method, which removes all single dimensions from a target tensor,
194:57 - we have the new tensor, which is has one square bracket removed. And the new shape is all single
195:04 - dimensions removed. So it's still the original values, but just a different dimension. Now,
195:09 - let's do the same as what we've done here with unsqueeze. So we've given our tensors a hug and
195:14 - squeezed out all the single dimensions of them. Now we're going to unsqueeze them. We're going to
195:18 - take a step back and let them grow a bit. So torch unsqueeze adds a single dimension
195:26 - to a target tensor at a specific dim dimension. Now that's another thing to note in PyTorch whenever
195:34 - it says dim, that's dimension as in this is a zeroth dimension, first dimension. And if there
195:40 - was more here, we'd go two, three, four, five, six, et cetera. Because why tensors can have
195:45 - unlimited dimensions. So let's go previous target can be excused. So we'll get this squeezed version
195:56 - of our tensor, which is x squeezed up here. And then we'll go print. The previous shape
196:02 - is going to be x squeezed dot shape. And then we're going to add an extra dimension with unsqueeze.
196:17 - There we go, x unsqueezed equals x squeezed. So our tensor before that we remove the single
196:24 - dimension. And we're going to put in unsqueeze, dim, we'll do it on the zeroth dimension. And I
196:32 - want you to have a think about what this is going to output even before we run the code.
196:35 - Just think about, because we've added an extra dimension on the zeroth dimension,
196:39 - what's the new shape of the unsqueeze tensor going to be? So we're going to go x unsqueezed.
196:47 - And then we're going to go print, we'll get our new tensor shape, which is going to be x unsqueezed
196:56 - dot shape. All right, let's have a look. There we go. So there's our previous tensor,
197:04 - which is the squeezed version, just as a single dimension here. And then we have our new tensor,
197:10 - which with the unsqueeze method on dimension zero, we've added a square bracket on the zeroth
197:16 - dimension, which is this one here. Now what do you think's going to happen if I change this to one?
197:20 - Where's the single dimension going to be added? Let's have a look. Ah, so instead of adding the
197:28 - single dimension on the zeroth dimension, we've added it on the first dimension here. It's quite
197:34 - confusing because Python is zero index. So I kind of want to my brain's telling me to say first,
197:40 - but it's really the zeroth index here or the zeroth dimension. Now let's change this back to
197:45 - zero. But that's just another way of exploring things. Every time there's like a parameter that
197:52 - we have here, dim equals something like that could be shape, could be size, whatever, try
197:58 - changing the values. That's what I'd encourage you to do. And even write some print code like
198:02 - we've done here. Now there's one more we want to try out. And that's permute. So torch dot permute
198:09 - rearranges the dimensions of a target tensor in a specified order. So if we wanted to check out,
198:23 - let's get rid of some of these extra tabs. Torch dot permute. Let's have a look. This one took me
198:30 - a little bit of practice to get used to. Because again, working with zeroth dimensions, even though
198:36 - it seems like the first one. So returns a view. Okay. So we know that a view shares the memory of
198:41 - the original input tensor with its dimensions permuted. So permuted for me, I didn't really know
198:47 - what that word meant. I just have mapped in my own memory that permute means rearrange dimensions.
198:53 - So the example here is we start with a random tensor, we check the size, and then we'd have
198:58 - torch permute. We're going to swap the order of the dimensions. So the second dimension is first,
199:04 - the zeroth dimension is in the middle, and the first dimension is here. So these are dimension
199:10 - values. So if we have torch random two, three, five, two, zero, one has changed this one to be
199:17 - over here. And then zero, one is two, three, and now two, three there. So let's try something similar
199:24 - to this. So one of the common places you'll be using permute, or you might see permute being
199:30 - used is with images. So there's a data specific data format. We've kind of seen a little bit
199:37 - before, not too much. Original equals torch dot rand size equals. So an image tensor,
199:44 - we go height width color channels on the end. So I'll just write this down. So this is height
199:50 - width color channels. Remember, much of, and I'm going to spell color Australian style,
199:57 - much of deep learning is turning your data into numerical representations. And this is quite common
200:04 - numerical representation of image data. You have a tensor dimension for the height, a tensor dimension
200:10 - for the width, and a tensor dimension for the color channels, which is red, green, and blue,
200:14 - because a certain number of red, green, and blue creates almost any color. Now, if we want to
200:20 - permute this, so permute the original tensor to rearrange the axis or dimension, axis or dimension,
200:31 - are kind of used in the same light for tensors or dim order. So let's switch the color channels
200:40 - to be the first or the zeroth dimension. So instead of height width color channels,
200:45 - it'll be color channels height width. How would we do that with permute? Let's give it a shot.
200:51 - X permuted equals X original dot permute. And we're going to take the second dimension,
201:01 - because this takes a series of dims here. So the second dimension is color channels. Remember,
201:06 - zero, one, two. So two, we want two first, then we want the height, which is a zero. And then we
201:13 - want the width, which is one. And now let's do this shifts, axis, zero to one, one to two,
201:24 - and two to zero. So this is the order as well. This two maps to zero. This zero maps to the first
201:35 - index. This one maps to this index. But that's enough talk about it. Let's see what it looks like.
201:41 - So print, previous shape, X original dot shape. And then we go here, print new shape. This will
201:51 - be the permuted version. We want X permuted dot shape. Let's see what this looks like. Wonderful.
202:01 - That's exactly what we wanted. So you see, let's just write a little note here. Now this is
202:06 - color channels, height, width. So the same data is going to be in both of these tenses. So X
202:14 - original X permuted, it's just viewed from a different point of view. Because remember, a
202:20 - permute is a view. And what did we discuss? A view shares the same memory as the original tensor.
202:26 - So X permuted will share the same place in memory as X original, even though it's from a different
202:32 - shape. So a little challenge before we move on to the next video for you, or before you move
202:37 - on to the next video, try change one of the values in X original. Have a look at X original.
202:46 - And see if that same value, it could be, let's get one of this zero, zero, get all of the dimensions
202:54 - here, zero. See what that is? Or can we get a single value maybe? Oops. Oh, no, we'll need a zero
203:07 - here, getting some practice on indexing here. Oh, zero, zero, zero. There we go. Okay, so maybe
203:14 - we set that to some value, whatever you choose, and see if that changes in X permuted. So give
203:22 - that a shot, and I'll see you in the next video. Welcome back. In the last video, we covered
203:29 - squeezing, unsqueezing, and permuting, which I'm not going to lie, these concepts are quite a
203:36 - lot to take in, but just so you're aware of them. Remember, what are they working towards? They're
203:41 - helping us fix shape and dimension issues with our tensors, which is one of the most common
203:46 - issues in deep learning and neural networks. And I usually do the little challenge of changing a
203:51 - value of X original to highlight the fact that permute returns a different view of the original
203:58 - tensor. And a view in PyTorch shares memory with that original tensor. So if we change the value
204:04 - at zero, zero, zero of X original to, in my case, 728218, it happens the same value gets copied across
204:12 - to X permuted. So with that being said, we looked at selecting data from tensors here, and this is
204:20 - using a technique called indexing. So let's just rehash that, because this is another thing that
204:25 - can be a little bit of a hurdle when first working with multi dimensional tensors. So let's see how
204:30 - we can select data from tensors with indexing. So if you've ever done indexing, indexing,
204:39 - with PyTorch is similar to indexing with NumPy. If you've ever worked with NumPy,
204:46 - and you've done indexing, selecting data from arrays, NumPy uses an array as its main data type,
204:51 - PyTorch uses tensors. It's very similar. So let's again start by creating a tensor.
204:58 - And again, I'm just going to add a few code cells here, so I can make my screen right in the middle.
205:04 - Now we're going to import torch. Again, we don't need to import torch all the time,
205:10 - just so you can run the notebook from here later on. X equals torch dot. Let's create a range again,
205:18 - just nice and simple. This is how I like to work out the fundamentals too, is just create the small
205:24 - range, reshape it, and the reshape has to be compatible with the original dimension. So we go
205:30 - one, three, three, and why is this because torch a range is going to return us nine values, because
205:35 - it's from the start here to the end minus one, and then one times three times three is what is
205:43 - nine. So let's have a look x x dot shape. Beautiful. So we have one, two, three, four, five, six,
205:53 - seven, eight, nine of size one. So we have this is the outer bracket here, which is going to contain
205:59 - all of this. And then we have three, which is this one here, one, two, three. And then we have three,
206:09 - which is one, two, three. Now let's work with this. Let's index on our new tensor. So let's see what
206:19 - happens when we get x zero, this is going to index on the first bracket. So we get this one here. So
206:29 - we've indexed on the first dimension here, the zero dimension on this one here, which is why we get
206:35 - what's inside here. And then let's try again, let's index on the middle bracket. So dimension
206:47 - one. So we got to go x, and then zero, and then zero. Let's see what happens there. Now is this the
206:56 - same as going x zero, zero? It is, there we go. So it depends on what you want to use. Sometimes
207:04 - I prefer to go like this. So I know that I'm getting the first bracket, and then the zeroth
207:10 - version of that first bracket. So then we have these three values here. Now what do you think
207:15 - what's going to happen if we index on third dimension or the second dimension here? Well,
207:20 - let's find out. So let's index on the most in our bracket, which is last dimension.
207:31 - So we have x zero, zero, zero. What numbers is going to give us back of x zero,
207:39 - on the zero dimension gives us back this middle tensor. And then if x zero, zero gives us back
207:44 - the zeroth index of the middle tensor. If we go x zero, zero, zero is going to give us the zeroth
207:52 - tensor, the zeroth index, and the zeroth element. A lot to take in there. But what we've done is
207:59 - we've just broken it down step by step. We've got this first zero targets this outer bracket
208:06 - and returns us all of this. And then zero, zero targets this first because of this first zero,
208:14 - and then the zero here targets this. And then if we go zero, zero, zero, we target this,
208:22 - then we target this, and then we get this back because we are getting the zeroth index here.
208:27 - So if we change this to one, what do we get back? Two. And if we change these all to one,
208:34 - what will we get? This is a bit of trivia here, or a challenge. So we're going one, one, one.
208:45 - Let's see what happens. Oh, no, did you catch that before I ran the code? I did that one quite
208:50 - quickly. We have index one is out of bounds. Why is that? Well, because this dimension is only one
208:56 - here. So we can only index on the zero. That's where it gets a little bit confusing because this
209:00 - says one, but because it's only got zero dimension, we can only index on the zero if to mention. But
209:05 - what if we do 011? What does that give us? Five. Beautiful. So I'd like to issue you the challenge
209:13 - of how about getting number nine? How would you get number nine? So rearrange this code to get
209:20 - number nine. That's your challenge. Now, I just want to show you as well, is you can use,
209:24 - you can also use, you might see this, the semicolon to select all of a target dimension. So let's say
209:37 - we wanted to get all of the zeroth dimension, but the zero element from that. We can get 123.
209:46 - And then let's say we want to say get all values of the zeroth and first dimensions,
209:51 - but only index one of the second dimension. Oh, that was a mouthful. But get all values of
209:58 - zeroth and first dimensions, but only index one of second dimension. So let's break this
210:06 - down step by step. We want all values of zeroth and first dimensions, but only index one of the
210:14 - second dimension. We press enter, shift enter, 258. So what did we get there? 258. Okay. So we've
210:22 - got all elements of the zeroth and first dimension, but then so which will return us this thing here.
210:30 - But then we only want 258, which is the first element here of the second dimension, which is
210:37 - this three there. So quite confusing. But with some practice, you can figure out how to select
210:43 - almost any numbers you want from any kind of tensor that you have. So now let's try again,
210:49 - get all values of the zero dimension, but only the one index value of the first and second
210:59 - dimension. So what might this look like? Let's break it down again. So we come down here x,
211:05 - and we're going to go all values of the zero dimension because zero comes first. And then we
211:09 - want only the one index value of the first and only the one index value of the second.
211:15 - What is this going to give us five? Oh, we selected the middle tensor. So really,
211:20 - this line of code is exactly the same as this line of code here, except we've got the square
211:27 - brackets on the outside here, because we've got this semicolon there. So if we change this to a zero,
211:34 - we remove that. But because we've got the semicolon there, we've selected all the
211:38 - dimensions. So we get back the square bracket there, something to keep in mind. Finally,
211:45 - let's just go one more. So get index zero of zero and first dimension, and all values of second
211:57 - dimension. So x zero, zero. So zero, the index of zero and first dimension, zero, zero,
212:06 - and all values of the second dimension. What have we just done here? We've got tensor one,
212:11 - two, three, lovely. This code again is equivalent to what we've done up here. This has a semicolon
212:19 - on the end. But what this line explicitly says without the semicolon is, hey, give us all the
212:24 - values on the remaining dimension there. So my challenge for you is to take this tensor that we
212:30 - have got here and index on it to return nine. So I'll write down here, index on x to return nine.
212:42 - So if you have a look at x, as well as index on x to return three, six, nine. So these values
212:54 - here. So give those both a go and I'll see you in the next video. Welcome back. How'd you go?
213:02 - Did you give the challenge ago? I finished the last video with issuing the challenge to index on
213:07 - x to return nine and index on x to return three, six, nine. Now here's what I came up with. Again,
213:13 - there's a few different ways that you could approach both of these. But this is just what
213:16 - I've found. So because x is one, three, three of size, well, that's his dimensions. If we want to
213:25 - select nine, we need zero, which is this first outer bracket to get all of these elements. And
213:31 - then we need two to select this bottom one here. And then we need this final two to select the
213:37 - second dimension of this bottom one here. And then for three, six, nine, we need all of the
213:43 - elements in the first dimension, all of the in the zeroth dimension, all of the elements in the
213:47 - first dimension. And then we get two, which is this three, six, nine set up here. So that's how I
213:56 - would practice indexing, start with whatever shape tensor you like, create it something like this,
214:00 - and then see how you can write different indexing to select whatever number you pick.
214:05 - So now let's move on to the next part, which is PyTorch tensors and NumPy. So NumPy is a
214:18 - popular scientific, very popular. PyTorch actually requires NumPy when you install PyTorch. Popular
214:25 - scientific Python numerical computing library, that's a bit of a mouthful. And because of this,
214:37 - PyTorch has functionality to interact with it. So quite often, you might start off with,
214:46 - let's change this into Markdown, you might start off with your data, because it's numerical format,
214:52 - you might start off with data in NumPy, NumPy array, want in PyTorch tensor. Because your
215:03 - data might be represented by NumPy because it started in NumPy, but say you want to do
215:07 - some deep learning on it and you want to leverage PyTorch's deep learning capabilities,
215:12 - well, you might want to change your data from NumPy to a PyTorch tensor. And PyTorch has a
215:17 - method to do this, which is torch from NumPy, which will take in an ND array, which is NumPy's
215:26 - main data type, and change it into a torch tensor. We'll see this in a second. And then if you want
215:31 - to go from PyTorch tensor to NumPy because you want to use some sort of NumPy method,
215:38 - well, the method to do this is torch dot tensor, and you can call dot NumPy on it. But this is all
215:47 - just talking about in words, let's see it in action. So NumPy array to tensor. Let's try this out
215:55 - first. So we'll import torch so we can run this cell on its own, and then import NumPy as np,
216:04 - the common naming convention for NumPy, we're going to create an array in NumPy. And we're
216:10 - going to just put one to eight, a range. And then we're going to go tensor equals torch from NumPy
216:20 - because we want to go from NumPy array to a torch tensor. So we use from NumPy, and then we pass
216:26 - in array, and then we have array and tensor. Wonderful. So there's our NumPy array, and our torch
216:35 - tensor with the same data. But what you might notice here is that the D type for the tensor is
216:41 - torch dot float 64. Now why is this? It's because NumPy's default data type. Oh, D type
216:49 - is float 64. Whereas tensor, what have we discussed before? What's pytorch's default data type?
216:58 - float 64. Well, that's not pytorch's default data type. If we were to create torch, a range,
217:06 - 1.0 to 8.0, by default, pytorch is going to create it in
217:10 - float 32. So just be aware of that. If you are going from NumPy to pytorch, the default NumPy
217:21 - data type is float 64. And pytorch reflects that data type when you use the from NumPy method.
217:28 - I wonder if there's a D type. Can we go D type equals torch dot float 32? Takes no keyword.
217:36 - Okay. But how could we change the data type here? Well, we could go type torch float 32.
217:44 - Yeah, that will give us a tensor D type of float 32 instead of float 64. Beautiful. I'll just keep
217:52 - that there so you know, warning when converting from NumPy pytorch, pytorch reflects NumPy's
218:06 - default data type of float 64, unless specified. Otherwise, because what have we discussed,
218:17 - when you're trying to perform certain calculations, you might run into a data type issue. So you might
218:24 - need to convert the type from float 64 to float 32. Now, let's see what happens. What do you think
218:32 - will happen if we change the array? We change the value of an array. Well, let's find out.
218:40 - So change the value of array. The question is, what will this do to tensor? Because we've used
218:52 - the from NumPy method, do you think if we change the array, the tensor will change? So let's try
218:58 - this array equals array plus one. So we're just adding one to every value in the array. Now,
219:06 - what is the array and the tensor going to look like? Uh huh. So array, we only change the first
219:15 - value there. Oh, sorry, we change every value because we have one to seven. Now it's two, three,
219:21 - four, five, six, seven, eight. We change the value from the array. It doesn't change the
219:26 - value of the tensor. So that's just something to keep in mind. If you use from NumPy, we get
219:32 - a new tensor in memory here. So the original, the new tensor doesn't change if you change the
219:37 - original array. So now let's go from tensor to NumPy. If you wanted to go back to NumPy,
219:43 - tensor to NumPy array. So we'll start with a tensor. We could use the one we have right now,
219:49 - but we're going to create another one, but we'll create one of ones just for fun.
219:53 - One rhymes with fun. NumPy tensor equals. How do we go to NumPy? Well, we have
220:01 - torch dot tensor dot NumPy. So we just simply call NumPy on here. And then we have tensor
220:08 - and NumPy tensor. What data type do you think the NumPy tensor is going to have?
220:14 - Because we've returned it to NumPy. Pi torches, default data type is
220:21 - Flight 32. So if we change that to NumPy, what's going to be the D type of the NumPy tensor?
220:26 - NumPy tensor dot D type. It reflects the original D type of what you set the tensor as. So just
220:36 - keep that in mind. If you're going between PyTorch and NumPy, default data type of NumPy is
220:41 - float 64, whereas the default data type of PyTorch is float 32. So that may cause some errors if
220:47 - you're doing different kinds of calculations. Now, what do you think is going to happen if we
220:51 - went from our tensor to an array, if we change the tensor, change the tensor, what happens to
221:01 - NumPy tensor? So we get tensor equals tensor plus one. And then we go NumPy tensor.
221:11 - Oh, we'll get tensor as well. So our tensor is now all twos because we added one to the ones.
221:19 - But our NumPy tensor remains the same. Remains unchanged. So this means they don't share memory.
221:24 - So that's how we go in between PyTorch and NumPy. If you'd like to look up more, I'd encourage
221:31 - you to go PyTorch and NumPy. So warm up NumPy, beginner. There's a fair few tutorials here on
221:40 - PyTorch because NumPy is so prevalent, they work pretty well together. So have a look at that.
221:45 - There's a lot going on there. There's a few more links, I'd encourage you to check out,
221:50 - but we've covered some of the main ones that you'll see in practice. With that being said,
221:54 - let's now jump into the next video where we're going to have a look at the concept of reproducibility.
222:00 - If you'd like to look that up, I'd encourage you to search PyTorch's reproducibility and see
222:05 - what you can find. Otherwise, I'll see you in the next video. Welcome back. It's now time for us
222:12 - to cover the topic of reproducibility. If I could even spell it, that would be fantastic.
222:19 - Reproducibility. Trying to take the random out of random. So we've touched upon the concept of
222:30 - neural networks harnessing the power of randomness. And what I mean by that is we haven't actually
222:35 - built our own neural network yet, but we will be doing that. And we've created tenses full of random
222:40 - values. And so in short, how our neural network learns is start with random numbers, perform tensor
222:53 - operations, update random numbers to try and make them better representations of the data. Again,
223:05 - again, again, again, again. However, if you're trying to do reproducible experiments, sometimes
223:18 - you don't want so much randomness. And what I mean by this is if we were creating random tensors,
223:23 - from what we've seen so far is that every time we create a random tensor, let's create one here,
223:28 - torch dot rand, and we'll create it of three three. Every time we run this cell, it gives us new numbers.
223:36 - So 7 7 5 2. There we go. Rand again. Right. So we get a whole bunch of random numbers here.
223:45 - Every single time. But what if you were trying to share this notebook with a friend,
223:50 - so say you went up share and you clicked the share link and you sent that to someone and you're like,
223:55 - hey, try out this machine learning experiment I did. And you wanted a little less randomness
224:00 - because neural networks start with random numbers. How might you do that? Well, let's
224:06 - this write down to reduce the randomness in neural networks. And pytorch comes the concept of a
224:20 - random seed. So we're going to see this in action. But essentially, let's write this down,
224:27 - essentially what the random seed does is flavor the randomness. So because of how computers work,
224:41 - they're actually not true randomness. And actually, there's arguments against this,
224:46 - and it's quite a big debate in the computer science topic, whatnot, but I am not a computer
224:50 - scientist, I am a machine learning engineer. So computers are fundamentally deterministic.
224:56 - It means they run the same steps over and over again. So what the randomness we're doing here
225:01 - is referred to as pseudo randomness or generated randomness. And the random seed,
225:06 - which is what you see a lot in machine learning experiments, flavors that randomness. So let's
225:11 - see it in practice. And at the end of this video, I'll give you two resources that I'd recommend
225:16 - to learn a little bit more about the concept of pseudo randomness and reproducibility in pytorch.
225:22 - Let's start by importing torch so you could start this notebook right from here. Create two random
225:28 - tensors. We'll just call this random tensor a equals torch dot rand and we'll go three four
225:38 - and we'll go random tensor b equals torch dot rand same size three four. And then if we have a
225:48 - look at let's go print random tensor a print random tensor b. And then let's print to see if
225:59 - they're equal anywhere random tensor a equals equals equals random tensor b. Now what do you
226:08 - think this is going to do? If we have a look at one equals one, what does it return? True.
226:16 - So this is comparison operator to compare two different tensors. We're creating two random
226:21 - tensors here. We're going to have a look at them. We'd expect them to be full of random values.
226:25 - Do you think any of the values in each of these random tensors is going to be equal to each other?
226:31 - Well, there is a chance that they are, but it's highly unlikely. I'll be quite surprised if they are.
226:36 - Oh, again, my connection might be a little bit. Oh, there we go. Beautiful. So we have tensor a
226:44 - tensor of three four with random numbers. And we have tensor b of three four with random numbers.
226:51 - So if we were, if I was to share this notebook with my friend or my colleague or even you,
226:56 - if you ran this cell, you are going to get random numbers as well. And you have every chance of
227:00 - replicating one of these numbers. But again, it's highly unlikely. So again, I'm getting that
227:05 - automatic save failed. You might get that if your internet connection is dropping out, maybe that's
227:10 - something going on with my internet connection. But again, as we've seen, usually this resolves
227:15 - itself. If you try a few times, I'll just keep coding. If it really doesn't resolve itself,
227:20 - you can go file is a download notebook or save a copy and drive download. You can download the
227:26 - notebook, save it to your local machine, re upload it to upload notebook and start again in another
227:32 - Google Colab instance. But there we go. It fixed itself. Wonderful troubleshooting on the fly.
227:38 - So the way we make these reproducible is through the concept of a random seed. So let's have a
227:45 - look at that. Let's make some random, but reproducible tenses. So import torch. And we're going to
227:58 - set the random seed by going torch dot manual seed random. Oh, we don't have random set yet.
228:14 - I'm going to set my random seed. You set the random seed to some numerical value. 42 is a common
228:20 - one. You might see zero. You might see one, two, three, four. Essentially, you can set it to whatever
228:26 - you want. And each of these, you can think of 77, 100, as different flavors of randomness. So
228:33 - I like to use 42, because it's the answer to the universe. And then we go random seed. And now
228:39 - let's create some random tenses. Random tensor C with the flavor of our random seed. Three,
228:50 - four. And then we're going to go torch tensor D equals torch dot rand three, four. Now, let's
228:59 - see what happens. We'll print out random tensor C. And we'll print out random tensor D. And then
229:10 - we'll print out to see if they're equal anywhere. Random tensor C equals random tensor D. So let's
229:20 - find out what happens. Huh, what gives? Well, we've got randomness. We set the random seed. We're
229:32 - telling pytorch a flavor our randomness with 42 torch manual seed. Hmm, let's try set the manual
229:42 - seed each time we call a random method. We go there. Ah, much better. So now we've got some
229:52 - flavored randomness. So a thing to keep in mind is that if you want to use the torch manual seed,
229:59 - generally it only works for one block of code if you're using a notebook. So that's just
230:06 - something to keep in mind. If you're creating random tensors, one after the other, we're using
230:10 - assignment like this, you should use torch dot manual seed every time you want to call the rand
230:15 - method or some sort of randomness. However, if we're using other torch processes, usually what
230:20 - you might see is torch manual seed is set right at the start of a cell. And then a whole bunch
230:25 - of code is done down here. But because we're calling subsequent methods here, we have to reset
230:31 - the random seed. Otherwise, if we don't do this, we comment this line, it's going to flavor the
230:36 - randomness of torch random tensor C with torch manual seed. But then random tensor D is just
230:42 - going to have no flavor. It's not going to use a random seed. So we reset it there. Wonderful.
230:48 - So I wonder, does this have a seed method? Let's go torch dot rand. Does this have seed?
230:57 - Sometimes they have a seed method. Seed, no, it doesn't. Okay, that's all right.
231:03 - The more you learn, but there's documentation for torch dot rand. And I said that I was going to
231:08 - link at the end of this video. So the manual seed is a way to, or the random seed, but in
231:14 - torch, it's called a manual seed is a way to flavor the randomness. So these numbers, as you see,
231:19 - are still quite random. But the random seed just makes them reproducible. So if I was to share this
231:24 - with you, if you had to run this block of code, ideally, you're going to get the same numerical
231:28 - output here. So with that being said, I'd like to refer to you to the pie torch reproducibility
231:35 - document, because we've only quite scratched the surface of this of reproducibility. We've covered
231:40 - one of the main ones. But this is a great document on how to go through reproducibility in pie torch.
231:48 - So this is your extra curriculum for this, even if you don't understand what's going on in a lot
231:53 - of the code here, just be aware of reproducibility, because it's an important topic in machine
231:58 - learning and deep learning. So I'll put this here, extra resources for reproducibility.
232:06 - As we go pie torch randomness, we'll change this into markdown. And then finally, the concept
232:14 - of a random seed is Wikipedia random seed. So random seeds quite a universal concept,
232:22 - not just for pie torch, there's a random seed and NumPy as well. So if you'd like to see what
232:27 - this means, yeah, initialize a pseudo random number generator. So that's a big word, pseudo random
232:33 - number generator. But if you'd like to learn about more random number generation computing,
232:38 - and what a random seed does is I'd refer to you to check out this documentation here.
232:44 - Whoo, far out, we have covered a lot. But there's a couple more topics you should really be aware
232:50 - of to finish off the pie torch fundamentals. You got this. I'll see you in the next video.
232:55 - Welcome back. Now, let's talk about the important concept of running tenses or pie
233:04 - torch objects. So running tenses and pie torch objects on GPUs and making faster computations.
233:17 - So we've discussed that GPUs, let me just scroll down a little bit here, GPUs equal faster
233:26 - computation on numbers. Thanks to CUDA plus NVIDIA hardware plus pie torch working behind the
233:40 - scenes to make everything hunky dory. Good. That's what hunky dory means, by the way,
233:50 - if you never heard that before. So let's have a look at how we do this. Now, we first need to
233:55 - talk about, let's go here one getting a GPU. There's a few different ways we've seen one before.
234:02 - Number one easiest is to use what we're using right now. Use Google Colab for a free GPU.
234:13 - But there's also Google Colab Pro. And I think there might even be, let's look up Google Colab
234:19 - Pro. Choose the best that's right for you. I use Google Colab Pro because I use it almost every day.
234:25 - So yeah, I pay for Colab Pro. You can use Colab for free, which is might be what you're using.
234:32 - There's also Colab Pro Plus, which has a lot more advantages as well. But Colab Pro is giving me
234:38 - faster GPUs, so access to faster GPUs, which means you spend less time waiting while your code is running.
234:45 - More memory, longer run time, so it'll last a bit longer if you leave it running idle.
234:50 - And then Colab Pro again is a step up from that. I personally haven't had a need yet to use
234:55 - Google Colab Pro Plus. You can complete this whole course on the free tier as well. But as you start
235:01 - to code more, as you start to run bigger models, as you start to want to compute more, you might
235:06 - want to look into something like Google Colab Pro. Or let's go here. Options to upgrade as well.
235:14 - And then another way is use your own GPU. Now this takes a little bit of setup and requires
235:26 - the investment of purchasing a GPU. There's lots of options. So one of my favorite posts for
235:39 - getting a GPU is, yeah, the best GPUs for deep learning in 2020, or something like this.
235:51 - What do we got? Deep learning? Tim Detmos. This is, yeah, which GPUs to get for deep learning?
236:00 - Now, I believe at the time of this video, I think it's been updated since this date. So don't take
236:07 - my word for it. But this is a fantastic blog post for figuring out what GPUs see this post
236:14 - for what option to get. And then number three is use cloud computing. So such as
236:28 - GCP, which is Google Cloud Platform AWS, which is Amazon Web Services or Azure.
236:33 - These services, which is Azure is by Microsoft, allow you to rent computers on the cloud and access
236:45 - them. So the first option using Google Colab, which is what we're using is by far the easiest
236:51 - and free. So there's big advantages there. However, the downside is that you have to use a website
236:57 - here, Google Colab, you can't run it locally. You don't get the benefit of using cloud computing,
237:01 - but my personal workflow is I run basically all of my small scale experiments and things like
237:07 - learning new stuff in Google Colab. And then if I want to upgrade things, run video experiments,
237:13 - I have my own dedicated deep learning PC, which I have built with a big powerful GPU. And then
237:18 - also I use cloud computing if necessary. So that's my workflow. Start with Google Colab.
237:25 - And then these two, if I need to do some larger experiments. But because this is the beginning
237:30 - of course, we can just stick with Google Colab for the time being. But I thought I'd make you aware
237:34 - of these other two options. And if you'd like to set up a GPU, so four, two, three, PyTorch plus
237:44 - GPU drivers, which is CUDA takes a little bit of setting up to do this, refer to PyTorch
237:56 - setup documentation. So if we go to pytorch.org, they have some great setup guides here,
238:07 - get started. And we have start locally. This is if you want to run on your local machine,
238:12 - such as a Linux setup. This is what I have Linux CUDA 11.3. It's going to give you a
238:18 - conda install command to use conda. And then if you want to use cloud partners, which is Alibaba
238:26 - Cloud, Amazon Web Services, Google Cloud Platform, this is where you'll want to go. So I'll just link
238:31 - this in here. But for this course, we're going to be focusing on using Google Colab. So now,
238:38 - let's see how we might get a GPU in Google Colab. And we've already covered this, but I'm going to
238:43 - recover it just so you know. We're going to change the runtime type. You can go in any notebook and
238:50 - do this, runtime type, hardware accelerator, we can select GPU, click save. Now this is going to
238:58 - restart our runtime and connect us to our runtime, aka a Google compute instance with a GPU. And so
239:07 - now if we run NVIDIA SMI, I have a Tesla P100 GPU. So let's look at this Tesla P100
239:21 - GPU. Do we have an image? Yeah, so this is the GPU that I've got running, not the Tesla car,
239:28 - the GPU. So this is quite a powerful GPU. That is because I have upgraded to Colab Pro. Now,
239:35 - if you're not using Colab Pro, you might get something like a Tesla K80, which is a slightly
239:40 - less powerful GPU than a Tesla P100, but still a GPU nonetheless and will still work faster than
239:48 - just running PyTorch code on the pure CPU, which is the default in Google Colab and the default
239:53 - in PyTorch. And so now we can also check to see if we have GPU access with PyTorch. So let's go
240:02 - here. This is number two now. Check for GPU access with PyTorch. So this is a little command that's
240:11 - going to allow us or tell us if PyTorch, just having the GPU here, this is by the way, another
240:20 - thing that Colab has a good setup with, is that all the connections between PyTorch and the NVIDIA
240:27 - GPU are set up for us. Whereas when you set it up on your own GPU or using cloud computing,
240:34 - there are a few steps you have to go through, which we're not going to cover in this course.
240:38 - I'd highly recommend you go through the getting started locally set up if you want to do that,
240:43 - to connect PyTorch to your own GPU. So let's check for the GPU access with PyTorch.
240:49 - This is another advantage of using Google Colab. Almost zero set up to get started. So import
240:58 - torch and then we're going to go torch dot cuda dot is available. And remember, cuda is
241:08 - NVIDIA's programming interface that allows us to use GPUs for numerical computing. There we go,
241:16 - beautiful. So big advantage of Google Colab is we get access to a free GPU. In my case, I'm paying
241:22 - for the faster GPU, but in your case, you're more than welcome to use the free version.
241:26 - All that means it'll be slightly slower than a faster GPU here. And we now have access to GPUs
241:34 - with PyTorch. So there is one more thing known as device agnostic code. So set up device agnostic
241:44 - code. Now, this is an important concept in PyTorch because wherever you run PyTorch, you might not
241:50 - always have access to a GPU. But if there was access to a GPU, you'd like it to use it if it's
241:57 - available. So one of the ways that this is done in PyTorch is to set the device variable. Now,
242:05 - really, you could set this to any variable you want, but you're going to see it used as device
242:09 - quite often. So cuda if torch dot cuda is available. Else CPU. So all this is going to say, and we'll
242:21 - see where we use the device variable later on is set the device to use cuda if it's available. So
242:29 - it is so true. If it's not available, if we don't have access to a GPU that PyTorch can use,
242:35 - just default to the CPU. So with that being said, there's one more thing. You can also count the
242:41 - number of GPUs. So this won't really apply to us for now because we're just going to stick with
242:45 - using one GPU. But as you upgrade your PyTorch experiments and machine learning experiments,
242:51 - you might have access to more than one GPU. So you can also count the devices here.
242:57 - We have access to one GPU, which is this here. So the reason why you might want to count the number
243:02 - of devices is because if you're running huge models on large data sets, you might want to run one
243:08 - model on a certain GPU, another model on another GPU, and so on and so on. But final thing before
243:16 - we finish this video is if we go PyTorch device agnostic code, cuda semantics, there's a little
243:24 - section in here called best practices. This is basically what we just covered there is setting
243:31 - the device argument. Now this is using the arg pass, but so yeah, there we go. args.device,
243:37 - torch.device, cuda, args.device, torch.device, CPU. So this is one way to set it from the Python
243:45 - arguments when you're running scripts, but we're using the version of running it through a notebook.
243:51 - So check this out. I'll just link this here, device agnostic code. It's okay if you're not sure
243:57 - of what's going on here. We're going to cover it a little bit more later on throughout the course,
244:01 - but right here for PyTorch, since it's capable of running compute on the GPU or CPU,
244:12 - it's best practice to set up device agnostic code, e.g. run on GPU if available,
244:29 - else default to CPU. So check out the best practices for using cuda, which is namely setting up
244:37 - device agnostic code. And let's in the next video, see what I mean about setting our PyTorch tensors
244:44 - and objects to the target device. Welcome back. In the last video, we checked out a few different
244:51 - options for getting a GPU, and then getting PyTorch to run on the GPU. And for now we're using
244:58 - Google Colab, which is the easiest way to get set up because it gives us free access to a GPU,
245:04 - faster ones if you set up with Colab Pro, and it comes with PyTorch automatically set up to
245:11 - use the GPU if it's available. So now let's see how we can actually use the GPU. So to do so,
245:20 - we'll look at putting tensors and models on the GPU. So the reason we want our tensors slash models
245:33 - on the GPU is because using GPU results in faster computations. And if we're getting our machine
245:43 - learning models to find patterns and numbers, GPUs are great at doing numerical calculations.
245:48 - And the numerical calculations we're going to be doing are tensor operations like we saw above.
245:53 - So the tensor operations, well, we've covered a lot. Somewhere here, tensor operations,
245:59 - there we go, manipulating tensor operations. So if we can run these computations faster,
246:04 - we can discover patterns in our data faster, we can do more experiments, and we can work towards
246:10 - finding the best possible model for whatever problem that we're working on. So let's see,
246:15 - we'll create a tensor, as usual, create a tensor. Now the default is on the CPU.
246:21 - So tensor equals torch dot tensor. And we'll just make it a nice simple one, one, two, three.
246:30 - And let's write here, tensor not on GPU will print out tensor. And this is where we can use,
246:39 - we saw this parameter before device. Can we pass it in here? Device equals CPU.
246:47 - Let's see what this comes out with. There we go. So if we print it out, tensor 123 is on the CPU.
246:54 - But even if we got rid of that device parameter, by default, it's going to be on the CPU. Wonderful.
247:02 - So now PyTorch makes it quite easy to move things to, and I'm saying to for a reason,
247:08 - to the GPU, or to, even better, the target device. So if the GPU is available, we use CUDA.
247:18 - If it's not, it uses CPU. This is why we set up the device variable. So let's see,
247:24 - move tensor to GPU. If available,
247:28 - tensor on GPU equals tensor dot two device. Now let's have a look at this, tensor on GPU.
247:43 - So this is going to shift the tensor that we created up here to the target device.
247:50 - Wonderful. Look at that. So now our tensor 123 is on device CUDA zero. Now this is the index of
247:57 - the GPU that we're using, because we only have one, it's going to be at index zero. So later on,
248:02 - when you start to do bigger experiments and work with multiple GPUs, you might have different tensors
248:06 - that are stored on different GPUs. But for now, we're just sticking with one GPU, keeping it nice
248:12 - and simple. And so you might have a case where you want to move, oh, actually, the reason why we
248:18 - set up device agnostic code is again, this code would work if we run this, regardless if we had,
248:25 - so it won't error out. But regardless if we had a GPU or not, this code will work. So whatever device
248:32 - we have access to, whether it's only a CPU or whether it's a GPU, this tensor will move to whatever
248:38 - target device. But since we have a GPU available, it goes there. You'll see this a lot. This two
248:44 - method moves tensors and it can be also used for models. We're going to see that later on. So just
248:50 - keep two device in mind. And then you might want to, for some computations, such as using NumPy,
248:58 - NumPy only works with the CPU. So you might want to move tensors back to the CPU, moving tensors back
249:06 - to the CPU. So can you guess how we might do that? It's okay if you don't know. We haven't covered a
249:13 - lot of things, but I'm going to challenge you anyway, because that's the fun part of thinking
249:17 - about something. So let's see how we can do it. Let's write down if tensor is on GPU, can't transform
249:27 - it to NumPy. So let's see what happens if we take our tensor on the GPU and try to go NumPy.
249:34 - What happens? Well, we get an error. So this is another huge error. Remember the top three
249:39 - errors in deep learning or pytorch? There's lots of them, but number one, shape errors,
249:44 - number two, data type issues. And with pytorch, number three is device issues. So can't convert
249:51 - CUDA zero device type tensor to NumPy. So NumPy doesn't work with the GPU. Use tensor dot CPU
249:58 - to copy the tensor to host memory first. So if we call tensor dot CPU, it's going to bring our
250:04 - target tensor back to the CPU. And then we should be able to use it with NumPy. So
250:10 - to fix the GPU tensor with NumPy issue, we can first set it to the CPU. So tensor back on CPU
250:27 - equals tensor on GPU dot CPU. We're just taking what this said here. That's a beautiful thing
250:34 - about pytorch is very helpful error messages. And then we're going to go NumPy.
250:39 - And then if we go tensor back on CPU, is this going to work? Let's have a look. Oh, of course,
250:45 - it's not because I typed it wrong. And I've typed it again twice. Third time, third time's a charm.
250:54 - There we go. Okay, so that works because we've put it back to the CPU first before calling NumPy.
251:00 - And then if we refer back to our tensor on the GPU, because we've reassociated this, again,
251:07 - we've got typos galore classic, because we've reassigned tensor back on CPU, our tensor on
251:14 - GPU remains unchanged. So that's the four main things about working with pytorch on the GPU.
251:22 - There are a few more tidbits such as multiple GPUs, but now you've got the fundamentals. We're
251:26 - going to stick with using one GPU. And if you'd like to later on once you've learned a bit more
251:30 - research into multiple GPUs, well, as you might have guessed, pytorch has functionality for that too.
251:36 - So have a go at getting access to a GPU using colab, check to see if it's available, set up device
251:42 - agnostic code, create a few dummy tensors and just set them to different devices, see what happens
251:48 - if you change the device parameter, run a few errors by trying to do some NumPy calculations
251:53 - with tensors on the GPU, and then bring those tensors on the GPU back to NumPy and see what happens
251:58 - there. So I think we've covered, I think we've reached the end of the fundamentals. We've covered
252:05 - a fair bit. Introduction to tensors, the minmax, a whole bunch of stuff inside the introduction
252:10 - to tensors, finding the positional minmax, reshaping, indexing, working with tensors and NumPy,
252:16 - reproducibility, using a GPU and moving stuff back to the GPU far out. Now you're probably wondering,
252:24 - Daniel, we've covered a whole bunch. What should I do to practice all this? Well, I'm glad you asked.
252:29 - Let's cover that in the next video. Welcome back. And you should be very proud of your
252:35 - self right now. We've been through a lot, but we've covered a whole bunch of PyTorch fundamentals.
252:41 - These are going to be the building blocks that we use throughout the rest of the course.
252:45 - But before moving on to the next section, I'd encourage you to try out what you've learned
252:51 - through the exercises and extra curriculum. Now, I've set up a few exercises here based off
252:59 - everything that we've covered. If you go into learn pytorch.io, go to the section that we're
253:05 - currently on. This is going to be the case for every section, by the way. So just keep this in mind,
253:10 - is we're working on PyTorch fundamentals. Now, if you go to the PyTorch fundamentals notebook,
253:15 - this is going to refresh, but that if you scroll down to the table of contents at the bottom of
253:20 - each one is going to be some exercises and extra curriculum. So these exercises here,
253:26 - such as documentation reading, because a lot you've seen me refer to the PyTorch documentation
253:31 - for almost everything we've covered a lot, but it's important to become familiar with that.
253:36 - So exercise number one is read some of the documentation. Exercise number two is create a
253:42 - random tensor with shape, seven, seven. Three, perform a matrix multiplication on the tensor from two
253:48 - with another random tensor. So these exercises are all based off what we've covered here.
253:53 - So I'd encourage you to reference what we've covered in whichever notebook you choose,
253:59 - could be this learn pytorch.io, could be going back through the one we've just coded together
254:04 - in the video. So I'm going to link this here, exercises, see exercises for this notebook here.
254:16 - So then how should you approach these exercises? So one way would be to just read them here,
254:23 - and then in collab we'll go file new notebook, wait for the notebook to load. Then you could call this
254:32 - zero zero pytorch exercises or something like that, and then you could start off by importing
254:40 - torch, and then away you go. For me, I'd probably set this up on one side of the screen, this one
254:46 - up on the other side of the screen, and then I just have the exercises here. So number one,
254:51 - I'm not going to really write much code for that, but you could have documentation reading here.
254:57 - And then so this encourages you to read through torch.tensor and go through there
255:04 - for 10 minutes or so. And then for the other ones, we've got create a random tensor with shape
255:08 - seven seven. So we just comment that out. So torch, round seven seven, and there we go.
255:17 - Some are as easy as that. Some are a little bit more complex. As we go throughout the course,
255:22 - these exercises are going to get a little bit more in depth as we've learned more.
255:26 - But if you'd like an exercise template, you can come back to the GitHub. This is the home for all
255:32 - of the course materials. You can go into extras and then exercises. I've created templates for
255:38 - each of the exercises. So pytorch fundamentals exercises. If you open this up, this is a template
255:46 - for all of the exercises. So you see there, create a random tensor with shape seven seven.
255:51 - These are all just headings. And if you'd like to open this in CoLab and work on it,
255:55 - how can you do that? Well, you can copy this link here. Come to Google CoLab. We'll go file,
256:03 - open notebook, GitHub. You can type in the link there. Click search. What's this going to do?
256:11 - Boom. Pytorch fundamentals exercises. So now you can go through all of the exercises. This
256:17 - will be the same for every module on the course and test your knowledge. Now it is open book. You
256:23 - can use the notebook here, the ones that we've coded together. But I would encourage you to try
256:30 - to do these things on your own first. If you get stuck, you can always reference back. And then
256:35 - if you'd like to see an example solutions, you can go back to the extras. There's a solutions folder
256:41 - as well. And that's where the solutions live. So the fundamental exercise solutions. But again,
256:46 - I would encourage you to try these out, at least give them a go before having a look at the solutions.
256:53 - So just keep that in mind at the end of every module, there's exercises and extra curriculum.
256:58 - The exercises will be code based. The extra curriculum is usually like reading based.
257:03 - So spend one hour going through the Pytorch basics tutorial. I recommend the quick start
257:07 - in tensor sections. And then finally to learn more on how a tensor can represent data,
257:12 - watch the video what's a tensor which we referred to throughout this. But massive effort on finishing
257:17 - the Pytorch fundamentals section. I'll see you in the next section. Friends, welcome back to
257:31 - the Pytorch workflow module. Now let's have a look at what we're going to get into.
257:36 - So this is a Pytorch workflow. And I say a because it's one of many. When you get into
257:43 - deep learning machine learning, you'll find that there's a fair few ways to do things. But here's
257:47 - the rough outline of what we're going to do. We're going to get our data ready and turn it into
257:51 - tensors because remember a tensor can represent almost any kind of data. We're going to pick or
257:56 - build or pick a pre-trained model. We'll pick a loss function and optimize it. Don't worry if
258:00 - you don't know what they are. We're going to cover this. We're going to build a training loop,
258:03 - fit the model to make a prediction. So fit the model to the data that we have. We'll learn how
258:09 - to evaluate our models. We'll see how we can improve through experimentation and we'll save
258:14 - and reload our trained model. So if you wanted to export your model from a notebook and use it
258:19 - somewhere else, this is what you want to be doing. And so where can you get help? Probably the most
258:25 - important thing is to follow along with the code. We'll be coding all of this together.
258:29 - Remember model number one. If and out, run the code. Try it for yourself. That's how I learn best.
258:35 - Is I write code? I try it. I get it wrong. I try again and keep going until I get it right.
258:41 - Read the doc string because that's going to show you some documentation about the functions that
258:46 - we're using. So on a Mac, you can use shift command and space in Google Colab or if you're on a Windows
258:51 - PC, it might be control here. If you're still stuck, try searching for it. You'll probably come
258:56 - across resources such as stack overflow or the PyTorch documentation. We've already seen this
259:01 - a whole bunch and we're probably going to see it a lot more throughout this entire course actually
259:05 - because that's going to be the ground truth of everything PyTorch. Try again. And finally,
259:11 - if you're still stuck, ask a question. So the best place to ask a question will be
259:15 - at the PyTorch deep learning slash discussions tab. And then if we go to GitHub,
259:20 - that's just under here. So Mr. Deeburg PyTorch deep learning. This is all the course materials.
259:25 - We see here, this is your ground truth for the entire course. And then if you have a question,
259:30 - go to the discussions tab, new discussion, you can ask a question there. And don't forget to
259:36 - please put the video and the code that you're trying to run. That way we can reference
259:41 - what's going on and help you out there. And also, don't forget, there is the book version of the
259:47 - course. So learn pytorch.io. By the time you watch this video, it'll probably have all the chapters
259:52 - here. But here's what we're working through. This is what the videos are based on. All of this,
259:56 - we're going to go through all of this. How fun is that? But this is just reference material.
260:00 - So you can read this at your own time. We're going to focus on coding together. And speaking of coding.
260:09 - Let's code. I'll see you over at Google Colab.
260:14 - Oh, right. Well, let's get hands on with some code. I'm going to come over to colab.research.google.com.
260:21 - You may already have that bookmark. And I'm going to start a new notebook. So we're going to do
260:28 - everything from scratch here. We'll let this load up. I'm just going to zoom in a little bit.
260:35 - Beautiful. And now I'm going to title this 01 pytorch workflow. And I'm going to put the video
260:45 - ending on here so that you know that this notebook's from the video. Why is that? Because in the
260:50 - course resources, we have the original notebook here, which is what this video notebook is going
260:54 - to be based off. You can refer to this notebook as reference for what we're going to go through.
260:59 - It's got a lot of pictures and beautiful text annotations. We're going to be focused on the
261:03 - code in the videos. And then of course, you've got the book version of the notebook as well,
261:08 - which is just a different formatted version of this exact same notebook. So I'm going to link
261:14 - both of these up here. So let's write in here, pytorch workflow. And let's explore an example,
261:25 - pytorch end to end workflow. And then I'm going to put the resources. So ground truth notebook.
261:36 - We go here. And I'm also going to put the book version.
261:44 - Book version of notebook. And finally, ask a question, which will be where at the discussions
261:58 - page. Then we'll go there. Beautiful. Let's turn this into markdown. So let's get started. Let's
262:04 - just jump right in and start what we're covering. So this is the trend I want to start getting
262:10 - towards is rather than spending a whole bunch of time going through keynotes and slides,
262:14 - I'd rather we just code together. And then we explain different things as they need to be
262:19 - explained because that's what you're going to be doing if you end up writing a lot of pytorch is
262:23 - you're going to be writing code and then looking things up as you go. So I'll get out of these
262:29 - extra tabs. I don't think we need them. Just these two will be the most important. So what we're
262:34 - covering, let's create a little dictionary so we can check this if we wanted to later on.
262:39 - So referring to our pytorch workflows, at least the example one that we're going to go through,
262:45 - which is just here. So we're going to go through all six of these steps, maybe a little bit of
262:51 - each one, but just to see it going from this to this, that's what we're really focused on. And then
262:57 - we're going to go through through rest the course like really dig deep into all of these. So what
263:04 - we're covering number one is data preparing and loading. Number two is we're going to see how we
263:10 - can build a machine learning model in pytorch or a deep learning model. And then we're going
263:16 - to see how we're going to fit our model to the data. So this is called training. So fit is another
263:23 - word. As I said in machine learning, there's a lot of different names for similar things,
263:27 - kind of confusing, but you'll pick it up with time. So we're going to once we've trained a model,
263:32 - we're going to see how we can make predictions and evaluate those predictions,
263:37 - evaluating a model. If you make predictions, it's often referred to as inference. I typically
263:43 - say making predictions, but inference is another very common term. And then we're going to look
263:47 - at how we can save and load a model. And then we're going to put it all together. So a little bit
263:54 - different from the visual version we have of the pytorch workflow. So if we go back to here,
264:02 - I might zoom in a little. There we go. So we're going to focus on this one later on,
264:08 - improve through experimentation. We're just going to focus on the getting data ready,
264:12 - building a model, fitting the model, evaluating model, save and reload. So we'll see this one more,
264:18 - like in depth later on, but I'll hint at different things that you can do
264:21 - for this while we're working through this workflow. And so let's put that in here.
264:26 - And then if we wanted to refer to this later, we can just go what we're covering.
264:34 - Oh, this is going to connect, of course. Beautiful. So we can refer to this later on,
264:39 - if we wanted to. And we're going to start by import torch. We're going to get pytorch ready
264:45 - to go import nn. So I'll write a note here. And then we haven't seen this one before, but
264:52 - we're going to see a few things that we haven't seen, but that's okay. We'll explain it as we go.
264:56 - So nn contains all of pytorch's building blocks for neural networks.
265:03 - And how would we learn more about torch nn? Well, if we just go torch.nn, here's how I'd
265:10 - learn about it, pytorch documentation. Beautiful. Look at all these. These are the basic building
265:15 - blocks for graphs. Now, when you see the word graph, it's referring to a computational graph,
265:20 - which is in the case of neural networks, let's look up a photo of a neural network.
265:24 - Images, this is a graph. So if you start from here, you're going to go towards the right.
265:33 - There's going to be many different pictures. So yeah, this is a good one. Input layer. You have
265:38 - a hidden layer, hidden layer to output layer. So torch and n comprises of a whole bunch of
265:45 - different layers. So you can see layers, layers, layers. And each one of these, you can see input
265:50 - layer, hidden layer one, hidden layer two. So it's our job as data scientists and machine
265:57 - learning engineers to combine these torch dot nn building blocks to build things such as these.
266:03 - Now, it might not be exactly like this, but that's the beauty of pytorch is that you can
266:08 - combine these in almost any different way to build any kind of neural network you can imagine.
266:14 - And so let's keep going. That's torch nn. We're going to get hands on with it,
266:19 - rather than just talk about it. And we're going to need map plot lib because what's our other
266:24 - motto? Our data explorers motto is visualize, visualize, visualize. And let's check our pytorch
266:31 - version. Pytorch version torch dot version. So this is just to show you you'll need
266:39 - at least this version. So 1.10 plus CUDA 111. That means that we've got CU stands for CUDA.
266:46 - That means we've got access to CUDA. We don't have a GPU on this runtime yet,
266:50 - because we haven't gone to GPU. We might do that later.
266:56 - So if you have a version that's lower than this, say 1.8, 0.0, you'll want pytorch 1.10 at least.
267:02 - If you have a version higher than this, your code should still work. But that's about enough
267:08 - for this video. We've got our workflow ready to set up our notebook, our video notebook.
267:13 - We've got the resources. We've got what we're covering. We've got our dependencies.
267:17 - Let's in the next one get started on one data, preparing and loading.
267:26 - I'll see you in the next video.
267:29 - Let's now get on to the first step of our pytorch workflow. And that is data, preparing and loading.
267:36 - Now, I want to stress data can be almost anything in machine learning.
267:44 - I mean, you could have an Excel spreadsheet, which is rows and columns,
267:51 - nice and formatted data. You could have images of any kind. You could have videos. I mean,
267:58 - YouTube has lots of data. You could have audio like songs or podcasts. You could have even DNA
268:09 - these days. Patents and DNA are starting to get discovered by machine learning. And then, of course,
268:14 - you could have text like what we're writing here. And so what we're going to be focusing on
268:20 - throughout this entire course is the fact that machine learning is a game of two parts.
268:26 - So one, get data into a numerical representation to build a model to learn patterns in that
268:41 - numerical representation. Of course, there's more around it. Yes, yes, yes. I understand you can
268:47 - get as complex as you like, but these are the main two concepts. And machine learning, when I say
268:52 - machine learning, saying goes for deep learning, you need some kind of, oh, number a call. Number
268:59 - a call. I like that word, number a call representation. Then you want to build a model to learn patterns
269:04 - in that numerical representation. And if you want, I've got a nice pretty picture that describes that
269:11 - machine learning a game of two parts. Let's refer to our data. Remember, data can be almost
269:16 - anything. These are our inputs. So the first step that we want to do is create some form
269:22 - of numerical encoding in the form of tenses to represent these inputs, how this looks will be
269:28 - dependent on the data, depending on the numerical encoding you choose to use. Then we're going to
269:33 - build some sort of neural network to learn a representation, which is also referred to as
269:38 - patterns features or weights within that numerical encoding. It's going to output that
269:45 - representation. And then we want to do something without representation, such as in the case of
269:50 - this, we're doing image recognition, image classification, is it a photo of Raman or spaghetti?
269:55 - Is this tweet spam or not spam? Is this audio file saying what it says here? I'm not going to say
270:02 - this because my audio assistant that's also named to this word here is close by and I don't want it
270:08 - to go off. So this is our game of two parts. One here is convert our data into a numerical
270:16 - representation. And two here is build a model or use a pre trained model to find patterns in
270:23 - that numerical representation. And so we've got a little stationary picture here, turn data into
270:29 - numbers, part two, build a model to learn patterns in numbers. So with that being said,
270:34 - now let's create some data to showcase this. So to showcase this, let's create some known
270:49 - data using the linear regression formula. Now, if you're not sure what linear regression is,
270:56 - or the formula is, let's have a look linear regression formula. This is how I'd find it.
271:03 - Okay, we have some fancy Greek letters here. But essentially, we have y equals a function of x
271:09 - and b plus epsilon. Okay. Well, there we go. A linear regression line has the equation in the
271:16 - form of y equals a plus bx. Oh, I like this one better. This is nice and simple. We're going to
271:20 - start from as simple as possible and work up from there. So y equals a plus bx, where x is the
271:27 - explanatory variable, and y is the dependent variable. The slope of the line is b. And the
271:34 - slope is also known as the gradient. And a is the intercept. Okay, the value of when y
271:42 - when x equals zero. Now, this is just text on a page. This is formula on a page. You know how I
271:48 - like to learn things? Let's code it out. So let's write it here. We'll use a linear regression formula
271:59 - to make a straight line with known parameters. I'm going to write this down because parameter
272:10 - is a common word that you're going to hear in machine learning as well. So a parameter is
272:16 - something that a model learns. So for our data set, if machine learning is a game of two parts,
272:22 - we're going to start with this. Number one is going to be done for us, because we're going to
272:27 - start with a known representation, a known data set. And then we want our model to learn that
272:35 - representation. This is all just talk, Daniel, let's get into coding. Yes, you're right. You're
272:40 - right. Let's do it. So create known parameters. So I'm going to use a little bit different
272:46 - names to what that Google definition did. So weight is going to be 0.7 and bias is going to be 0.3.
272:55 - Now weight and bias are another common two terms that you're going to hear in neural networks.
273:01 - So just keep that in mind. But for us, this is going to be the equivalent of our weight will be B
273:08 - and our bias will be A. But forget about this for the time being. Let's just focus on the code.
273:15 - So we know these numbers. But we want to build a model that is able to estimate these numbers.
273:23 - How? By looking at different examples. So let's create some data here. We're going to create a
273:28 - range of numbers. Start equals zero and equals one. We're going to create some numbers between
273:34 - zero and one. And they're going to have a gap. So the step the gap is going to be 0.02.
273:41 - Now we're going to create an X variable. Why is X a capital here?
273:47 - Well, it's because typically X in machine learning you'll find is a matrix or a tensor.
273:52 - And if we remember back to the fundamentals, a capital represents a matrix or a tensor
273:58 - and a lowercase represents a vector. But now case it's going to be a little confusing because
274:03 - X is a vector. But later on, X will start to be a tensor and a matrix. So for now,
274:09 - we'll just keep the capital, not capital notation.
274:15 - We're going to create the formula here, which is remember how I said our weight is in this case,
274:24 - the B and our bias is the A. So we've got the same formula here. Y equals weight times X plus
274:31 - bias. Now let's have a look at these different numbers. So we'll view the first 10 of X and we'll
274:38 - view the first 10 of Y. We'll have a look at the length of X and we'll have a look at the length of
274:43 - Y. Wonderful. So we've got some values here. We've got 50 numbers of each. This is a little
274:55 - confusing. Let's just view the first 10 of X and Y first. And then we can have a look at the
274:59 - length here. So what we're going to be doing is building a model to learn some values,
275:12 - to look at the X values here and learn what the associated Y value is and the relationship
275:20 - between those. Of course, we know what the relationship is between X and Y because we've
275:25 - coded this formula here. But you won't always know that in the wild. That is the whole premise of
275:32 - machine learning. This is our ideal output and this is our input. The whole premise of machine
275:38 - learning is to learn a representation of the input and how it maps to the output. So here are our
275:44 - input numbers and these are our output numbers. And we know that the parameters of the weight and
275:51 - bias are 0.7 and 0.3. We could have set these to whatever we want, by the way. I just like the
275:55 - number 7 and 3. You could set these to 0.9, whatever, whatever. The premise would be the same.
276:02 - So, oh, and what I've just done here, I kind of just coded this without talking.
276:06 - But I just did torch a range and it starts at 0 and it ends at 1 and the step is 0.02. So there
276:14 - we go, 000 by 0.02, 04. And I've unsqueezed it. So what does unsqueezed do? Removes the extra
276:22 - dimensions. Oh, sorry, ads are extra dimension. You're getting confused here. So if we remove that,
276:31 - we get no extra square bracket. But if we add unsqueeze, you'll see that we need this later on
276:37 - for when we're doing models. Wonderful. So let's just leave it at that. That's enough for this
276:42 - video, we've got some data to work with. Don't worry if this is a little bit confusing for now,
276:47 - we're going to keep coding on and see what we can do to build a model to infer patterns in this
276:52 - data. But right now, I want you to have a think, this is tensor data, but it's just numbers on a
276:58 - page. What might be a better way to hint, this is a hint by the way, visualize it. What's our
277:05 - data explorer's motto? Let's have a look at that in the next video. Welcome back. In the last
277:12 - video, we created some numbers on a page using the linear regression formula with some known
277:18 - parameters. Now, there's a lot going on here, but that's all right. We're going to keep building
277:22 - upon what we've done and learn by doing. So in this video, we're going to cover one of the most
277:28 - important concepts in machine learning in general. So splitting data into training and test sets.
277:35 - One of the most important concepts in machine learning in general. Now, I know I've said this
277:45 - already a few times. One of the most important concepts, but truly, this is possibly, in terms
277:52 - of data, this is probably the number one thing that you need to be aware of. And if you've come
277:58 - from a little bit of a machine learning background, you probably well and truly know all about this.
278:02 - But we're going to recover it anyway. So let's jump in to some pretty pictures. Oh, look at that
278:08 - one speaking of pretty pictures. But that's not what we're focused on now. We're looking at the
278:13 - three data sets. And I've written down here possibly the most important concept in machine
278:18 - learning, because it definitely is from a data perspective. So the course materials,
278:24 - imagine you're at university. So this is going to be the training set. And then you have the
278:29 - practice exam, which is the validation set. Then you have the final exam, which is the test set.
278:34 - And the goal of all of this is for generalization. So let's step back. So say you're trying to learn
278:41 - something at university or through this course, you might have all of the materials, which is your
278:46 - training set. So this is where our model learns patterns from. And then to practice what you've
278:54 - done, you might have a practice exam. So the mid semester exam or something like that. Now,
279:01 - let's just see if you're learning the course materials well. So in the case of our model,
279:06 - we might tune our model on this plastic exam. So we might find that on the validation set,
279:14 - our model doesn't do too well. And we adjusted a bit, and then we retrain it, and then it does
279:20 - better. Before finally, at the end of semester, the most important exam is your final exam. And
279:27 - this is to see if you've gone through the entire course materials, and you've learned some things.
279:32 - Now you can adapt to unseen material. And that's a big point here. We're going to see this in
279:36 - practice is that when the model learns something on the course materials, it never sees the validation
279:44 - set or the test set. So say we started with 100 data points, you might use 70 of those data points
279:51 - for the training material. You might use 15% of those data points, so 15 for the practice.
279:57 - And you might use 15 for the final exam. So this final exam is just like if you're at university
280:03 - learning something is to see if, hey, have you learned any skills from this material at all?
280:08 - Are you ready to go into the wild into the quote unquote real world? And so this final exam is to
280:15 - test your model's generalization, because it's never seen this data is, let's define generalization
280:22 - is the ability for a machine learning model or a deep learning model to perform well on data it
280:27 - hasn't seen before, because that's our whole goal, right? We want to build a machine learning model
280:32 - on some training data that we can deploy in our application or production setting. And then
280:38 - more data comes in that it hasn't seen before. And it can make decisions based on that new data
280:44 - because of the patterns it's learned in the training set. So just keep this in mind,
280:48 - three data sets training validation test. And if we jump in to the learn pytorch book,
280:54 - we've got split data. So we're going to create three sets. Or in our case, we're only going to
281:04 - create two or training in a test. Why is that? Because you don't always need a validation set.
281:10 - There is often a use case for a validation set. But the main two that are always used is the training
281:18 - set and the testing set. And how much should you split? Well, usually for the training set,
281:23 - you'll have 60 to 80% of your data. If you do create a validation set, you'll have somewhere
281:27 - between 10 and 20. And if you do create a testing set, it's a similar split to the validation set,
281:33 - you'll have between 10 and 20%. So training, always testing always validation often, but
281:40 - not always. So with that being said, I'll let you refer to those materials if you want. But now
281:46 - let's create a training and test set with our data. So we saw before that we have 50 points,
281:55 - we have X and Y, we have one to one ratio. So one value of X relates to one value of Y.
282:01 - And we know that the split now for the training set is 60 to 80%. And the test set is 10 to 20%.
282:09 - So let's go with the upper bounds of each of these, 80% and 20%, which is a very common split,
282:14 - actually 80, 20. So let's go create a train test split. And we're going to go train split.
282:25 - We'll create a number here so we can see how much. So we want an integer of 0.8, which is 80%
282:32 - of the length of X. What does that give us? Train split should be about 40 samples. Wonderful.
282:39 - So we're going to create 40 samples of X and 40 samples of Y. Our model will train on those 40
282:46 - samples to predict what? The other 10 samples. So let's see this in practice. So X train,
282:55 - Y train equals X. And we're going to use indexing to get all of the samples up until the train
283:03 - split. That's what this colon does here. So hey, X up until the train split, Y up until the train
283:10 - split, and then for the testing. Oh, thanks for that. Auto correct cola, but didn't actually need that
283:17 - one. X test. Y test equals X. And then we're going to get everything from the train split onwards.
283:25 - So the index onwards, that's what this notation means here. And Y from the train split onwards as
283:36 - well. Now, there are many different ways to create a train and test split. Ours is quite simple here,
283:43 - but that's because we're working with quite a simple data set. One of the most popular methods
283:48 - that I like is scikit learns train test split. We're going to see this one later on. It adds a
283:53 - little bit of randomness into splitting your data. But that's for another video, just to make you
283:59 - aware of it. So let's go length X train. We should have 40 training samples to
284:09 - how many testing samples length X test and length Y test. Wonderful 40 40 10 10 because we have
284:24 - training features, training labels, testing features, testing labels. So essentially what we've
284:31 - created here is now a training set. We've split our data. Training set could also be referred to
284:37 - as training split yet another example of where machine learning has different names for different
284:43 - things. So set split same thing training split test split. This is what we've created. Remember,
284:48 - the validation set is used often, but not always because our data set is quite simple. We're just
284:53 - sticking with the necessities training and test. But keep this in mind. One of your biggest,
285:00 - biggest, biggest hurdles in machine learning will be creating proper training and test sets. So
285:06 - it's a very important concept. With that being said, I did issue the challenge in the last video
285:11 - to visualize these numbers on a page. We haven't done that in this video. So let's move towards
285:17 - that next. I'd like you to think of how could you make these more visual? Right. These are just
285:22 - numbers on a page right now. Maybe that plot lib can help. Let's find out. Hey, hey, hey, welcome
285:33 - back. In the last video, we split our data into training and test sets. And now later on,
285:40 - we're going to be building a model to learn patterns in the training data to relate to the
285:44 - testing data. But as I said, right now, our data is just numbers on a page. It's kind of
285:50 - hard to understand. You might be able to understand this, but I prefer to get visual. So let's write
285:54 - this down. How might we better visualize our data? And I'm put a capital here. So we're grammatically
286:04 - correct. And this is where the data Explorers motto comes in. Visualize, visualize, visualize.
286:18 - Ha ha. Right. So if ever you don't understand a concept, one of the best ways to start
286:23 - understanding it more for me is to visualize it. So let's write a function to do just that.
286:29 - We're going to call this plot predictions. We'll see why we call it this later on. That's the
286:34 - benefit of making these videos is that I've got a plan for the future. Although it might seem
286:39 - like I'm winging it, there is a little bit of behind the scenes happening here. So we'll have
286:43 - the train data, which is our X train. And then we'll have the train labels, which is our Y train.
286:51 - And we'll also have the test data. Yeah, that's a good idea. X test. And we'll also have the test
286:58 - labels, equals Y test. Excuse me. I was looking at too many X's there. And then the predictions.
287:05 - And we'll set this to none, because we don't have any predictions yet. But as you might have guessed,
287:11 - we might have some later on. So we'll put a little doc string here, so that we're being nice and
287:16 - Pythonic. So plots training data, test data, and compares predictions. Nice and simple.
287:28 - Nothing too outlandish. And then we're going to create a figure. This is where map plot lib comes
287:33 - in. Plot figure. And we'll go fig size equals 10, seven, which is my favorite hand in poker.
287:41 - And we'll plot the training data in blue also happens to be a good dimension for a map plot.
287:47 - Plot dot scatter. Train data. Creating a scatter plot here. We'll see what it does in a second.
287:55 - Color. We're going to give this a color of B for blue. That's what C stands for in map plot lib
288:00 - scatter. We'll go size equals four and label equals training data. Now, where could you find
288:09 - information about this scatter function here? We've got command shift space. Is that going to
288:14 - give us a little bit of a doc string? Or sometimes if command not space is not working,
288:19 - you can also hover over this bracket. I think you can even hover over this.
288:26 - There we go. But this is a little hard for me to read. Like it's there, but it's got a lot going
288:32 - on. X, Y, S, C, C map. I just like to go map plot lib scatter. There we go. We've got a whole
288:46 - bunch of information there. A little bit easier to read for me here. And then you can see some
288:52 - examples. Beautiful. So now let's jump back into here. So in our function plot predictions,
288:58 - we've taken some training data, test data. We've got the training data plotting in blue. What
289:03 - color should we use for the testing data? How about green? I like that idea. Plot.scatter.
289:10 - Test data. Green's my favorite color. What's your favorite color? C equals G. You might be
289:17 - able to just plot it in your favorite color here. Just remember though, it'll be a little bit
289:22 - different from the videos. And then we're going to call this testing data. So just the exact same
289:26 - line is above, but with a different set of data. Now, let's check if there are predictions. So
289:33 - are there predictions? So if predictions is not none, let's plot the predictions, plot the
289:44 - predictions, if they exist. So plot scatter test data. And why are we plotting the test data?
289:58 - Remember, what is our scatter function? Let's go back up to here. It takes in x and y. So
290:04 - our predictions are going to be compared to the testing data labels. So that's the whole
290:10 - game that we're playing here. We're going to train our model on the training data.
290:15 - And then to evaluate it, we're going to get our model to predict the y values
290:20 - as with the input of x test. And then to evaluate our model, we compare how good our models
290:28 - predictions are. In other words, predictions versus the actual values of the test data set.
290:35 - But we're going to see this in practice. Rather than just talk about it. So let's do our predictions
290:42 - in red. And label equals predictions. Wonderful. So let's also show the legend, because, I mean,
290:55 - we're legends. So we could just put in a mirror here. Now I'm kidding. Legend is going to show
291:01 - our labels on the map plot. So prop equals size and prop stands for properties. Well,
291:11 - it may or may not. I just like to think it does. That's how I remember it. So we have a beautiful
291:16 - function here to plot our data. Should we try it out? Remember, we've got hard coded inputs here,
291:24 - so we don't actually need to input anything to our function. We've got our train and test data
291:28 - ready to go. If in doubt, run the code, let's check it out. Did we make a mistake in our plot
291:32 - predictions function? You might have caught it. Hey, there we go. Beautiful. So because we don't
291:40 - have any predictions, we get no red dots. But this is what we're trying to do. We've got a simple
291:46 - straight line. You can't get a much more simple data set than that. So we've got our training data
291:51 - in blue, and we've got our testing data in green. So the whole idea of what we're going to be doing
291:56 - with our machine learning model is we don't actually really need to build a machine learning
292:00 - model for this. We could do other things, but machine learning is fun. So we're going to take
292:05 - in the blue dots. There's quite a pattern here, right? This is the relationship we have an x value
292:11 - here, and we have a y value. So we're going to build a model to try and learn the pattern
292:17 - of these blue dots, so that if we fed our model, our model, the x values of the green dots,
292:25 - could it predict the appropriate y values for that? Because remember, these are the test data set.
292:29 - So pass our model x test to predict y test. So blue dots as input, green dots as the ideal output.
292:37 - This is the ideal output, a perfect model would have red dots over the top of the green dots. So
292:42 - that's what we will try to work towards. Now, we know the relationship between x and y.
292:48 - How do we know that? Well, we set that up above here. This is our weight and bias.
292:53 - We created that line y equals weight times x plus bias, which is the simple version of the
292:59 - linear regression formula. So mx plus c, you might have heard that in high school algebra,
293:05 - so gradient plus intercept. That's what we've got. With that being said,
293:11 - let's move on to the next video and build a model. Well, this is exciting. I'll see you there.
293:16 - Welcome back. In the last video, we saw how to get visual with our data. We followed the data
293:24 - explorer's motto of visualize, visualize, visualize. And we've got an idea of the training data that
293:31 - we're working with and the testing data that we're trying to build a model to learn the patterns
293:36 - in the training data, essentially this upwards trend here, to be able to predict the testing data.
293:44 - So I just want to give you another heads up. I took a little break after the recording last
293:49 - video. And so now my colab notebook has disconnected. So I'm going to click reconnect.
293:55 - And my variables here may not work. So this is what might happen on your end. If you take a break
294:02 - from using Google Colab and come back, if I try to run this function, they might have been saved,
294:08 - it looks like they have. But if not, you can go restart and run all. This is typically one of the
294:14 - most helpful troubleshooting steps of using Google Colab. If a cell, say down here isn't working,
294:23 - you can always rerun the cells above. And that may help with a lower cell here, such as if this
294:32 - function wasn't instantiated because this cell wasn't run, and we couldn't run this cell here,
294:38 - which calls this function here, we just have to rerun this cell above so that we can run this one.
294:43 - But now let's get into building our first PyTorch model. We're going to jump straight into the code.
294:51 - So our first PyTorch model. Now this is very exciting.
294:58 - Let's do it. So we'll turn this into Markdown. Now we're going to create a linear regression model.
295:09 - So look at linear regression formula again, we're going to create a model that's essentially going
295:15 - to run this computation. So we need to create a model that has a parameter for A, a parameter for B,
295:23 - and in our case it's going to be weight and bias, and a way to do this forward computation.
295:29 - What I mean by that, we're going to see with code. So let's do it. We'll do it with pure PyTorch.
295:36 - So create a linear regression model class. Now if you're not experienced with using Python classes,
295:44 - I'm going to be using them throughout the course, and I'm going to call this one linear regression
295:49 - model. If you haven't dealt with Python classes before, that's okay. I'm going to be explaining
295:56 - what we're doing as we're doing it. But if you'd like a deeper dive, I'd recommend you to real Python
296:04 - classes. OOP in Python three. That's a good rhyming. So I'm just going to link this here.
296:12 - Because we're going to be building classes throughout the course,
296:23 - I'd recommend getting familiar with OOP, which is object oriented programming, a little bit of a
296:31 - mouthful, hence the OOP in Python. To do so, you can use the following resource from real Python.
296:43 - But when I'm going to go through that now, I'd rather just code it out and talk it out while we
296:48 - do it. So we've got a class here. Now the first thing you might notice is that the class inherits
296:53 - from nn.module. And you might be wondering, well, what's nn.module? Well, let's write down here,
297:00 - almost everything in PyTorch inherits from nn.module. So you can imagine nn.module as the
297:12 - Lego building bricks of PyTorch model. And so nn.module has a lot of helpful inbuilt things that's
297:20 - going to help us build our PyTorch models. And of course, how could you learn more about it?
297:25 - Well, you could go nn.module, PyTorch. Module. Here we go. Base class for all neural network
297:33 - modules. Wonderful. Your models should also subclass this class. So that's what we're building. We're
297:38 - building our own PyTorch model. And so the documentation here says that your models should
297:44 - also subclass this class. And another thing with PyTorch, this is what makes it, it might seem very
297:49 - confusing when you first begin. But modules can contain other modules. So what I mean by being a
297:56 - Lego brick is that you can stack these modules on top of each other and make progressively more
298:01 - complex neural networks as you go. But we'll leave that for later on. For now, we're going to start
298:08 - with something nice and simple. And let's clean up our web browser. So we're going to create a
298:15 - constructor here, which is with the init function. It's going to take self as a parameter. If you're
298:23 - not sure of what's going on here, just follow along with the code for now. And I'd encourage you
298:29 - to read this documentation here after the video. So then we have super dot init. I know when I
298:37 - first started learning this, I was like, why do we have to write a knit twice? And then what's
298:40 - super and all that jazz. But just for now, just take this as being some required Python syntax.
298:48 - And then we have self dot weights. So that means we're going to create a weights parameter. We'll
298:54 - see why we do this in a second. And to create that parameter, we're going to use nn dot parameter.
299:00 - And just a quick reminder that we imported nn from torch before. And if you remember,
299:08 - nn is the building block layer for neural networks. And within nn, so nn stands for neural network
299:15 - is module. So we've got nn dot parameter. Now, we're going to start with random parameters.
299:25 - So torch dot rand n. One, we're going to talk through each of these in a second. So I'm also
299:32 - going to put requires, requires grad equals true. We haven't touched any of these, but that's okay.
299:40 - D type equals torch dot float. So let's see what nn parameter tells us. What do we have here?
299:53 - A kind of tensor that is to be considered a module parameter. So we've just created a module
299:58 - using nn module. Parameters are torch tensor subclasses. So this is a tensor in itself
300:05 - that have a very special property when used with modules. When they're assigned as a module
300:09 - attribute, they are automatically added to the list of its parameters. And we'll appear e g
300:14 - in module dot parameters iterator. Oh, we're going to see that later on. Assigning a tensor
300:20 - doesn't have such effect. So we're creating a parameter here. Now requires grad. What does that
300:28 - mean? Well, let's just rather than just try to read the doc string collab, let's look it up.
300:32 - nn dot parameter. What does it say requires grad optional. If the parameter requires gradient.
300:43 - Hmm. What does requires gradient mean? Well, let's come back to that in a second. And then
300:51 - for now, I just want you to think about it. D type equals torch dot float. Now,
300:56 - the data type here torch dot float is, as we've discussed before, is the default
301:02 - for pytorch to watch dot float. This could also be torch dot float 32. So we're just going to
301:08 - leave it as torch float 32, because pytorch likes to work with flight 32. Now, do we have
301:17 - this by default? We do. So we don't necessarily have to set requires grad equals true. So just
301:24 - keep that in mind. So now we've created a parameter for the weights. We also have to create a parameter
301:33 - for the bias. Let's finish creating this. And then we'll write the code, then we'll talk about it.
301:41 - So rand n. Now requires grad equals true. And d type equals torch dot float. There we go.
301:52 - And now we're going to write a forward method. So forward method to define the computation
302:02 - in the model. So let's go def forward, which self takes in a parameter x, which is data,
302:14 - which X is expected to be of type torch tensor. And it returns a torch dot tensor. And then we go
302:23 - here. And so we say X, we don't necessarily need this comment. I'm just going to write it anyway.
302:28 - X is the input data. So in our case, it might be the training data. And then from here, we want
302:36 - it to return self dot weights times X plus self dot bias. Now, where have we seen this before?
302:47 - Well, this is the linear regression formula. Now, let's take a step back into how we created our data.
302:56 - And then we'll go back through and talk a little bit more about what's going on here.
302:59 - So if we go back up to our data, where did we create that? We created it here. So you see how
303:08 - we've created known parameters, weight and bias. And then we created our y variable, our target,
303:16 - using the linear regression formula, wait times X plus bias, and X were a range of numbers.
303:23 - So what we've done with our linear regression model that we've created from scratch,
303:29 - if we go down here, we've created a parameter, weights. This could just be weight, if we wanted to.
303:38 - We've created a parameter here. So when we created our data, we knew what the parameters weight and
303:44 - bias were. The whole goal of our model is to start with random numbers. So these are going to be
303:52 - random parameters. And to look at the data, which in our case will be the training samples,
303:59 - and update those random numbers to represent the pattern here. So ideally, our model, if it's
304:07 - learning correctly, will take our weight, which is going to be a random value, and our bias,
304:13 - which is going to be a random value. And it will run it through this forward calculation,
304:18 - which is the same formula that we use to create our data. And it will adjust the weight and bias
304:25 - to represent as close as possible, if not perfect, the known parameters. So that's the premise of
304:34 - machine learning. And how does it do this? Through an algorithm called gradient descent. So I'm just
304:41 - going to write this down because we've talked a lot about this, but I'd like to just tie it together
304:46 - here. So what our model does, so start with random values, weight and bias, look at training data,
305:01 - and adjust the random values to better represent the, or get closer to the ideal values. So the
305:21 - weight and bias values we use to create the data. So that's what it's going to do. It's going to
305:33 - start with random values, and then continually look at our training data to see if it can adjust
305:39 - those random values to be what would represent this straight line here. Now, how does it do so?
305:46 - How does it do so? Through two main algorithms. So one is gradient descent, and two is back
306:01 - propagation. So I'm going to leave it here for the time being, but we're going to continue talking
306:12 - about this gradient descent is why we have requires grad equals true. And so what this is going to
306:21 - do is when we run computations using this model here, pytorch is going to keep track of the gradients
306:28 - of our weights parameter and our bias parameter. And then it's going to update them through a
306:36 - combination of gradient descent and back propagation. Now, I'm going to leave this as extracurricular
306:43 - for you to look through and gradient descent and back propagation. I'm going to add some
306:46 - resources here. There will also be plenty of resources in the pytorch workflow fundamentals
306:51 - book chapter on how these algorithms work behind the scenes. We're going to be focused on the code,
306:57 - the pytorch code, to trigger these algorithms behind the scenes. So pytorch, lucky for us,
307:02 - has implemented gradient descent and back propagation for us. So we're writing the higher level code
307:09 - here to trigger these two algorithms. So in the next video, we're going to step through this a
307:14 - little bit more, and then further discuss some of the most useful and required modules of pytorch,
307:21 - particularly an N and a couple of others. So let's leave it there, and I'll see you in the next video.
307:27 - Welcome back. In the last video, we covered a whole bunch in creating our first pytorch model
307:35 - that inherits from nn.module. We talked about object oriented programming and how a lot of
307:40 - pytorch uses object oriented programming. I can't say that. I might just say OOP for now.
307:45 - What I've done since last video, though, is I've added two resources here for gradient descent
307:51 - and back propagation. These are two of my favorite videos on YouTube by the channel three blue
307:57 - one brown. So this is on gradient descent. I would highly recommend watching this entire series,
308:02 - by the way. So that's your extra curriculum for this video, in particular, and for this course overall
308:08 - is to go through these two videos. Even if you're not sure entirely what's happening,
308:13 - you will gain an intuition for the code that we're going to be writing with pytorch.
308:17 - So just keep that in mind as we go forward, a lot of what pytorch is doing behind the scenes for us
308:23 - is taking care of these two algorithms for us. And we also created two parameters here in our model
308:32 - where we've instantiated them as random values. So one parameter for each of the ones that we use,
308:39 - the weight and bias for our data set. And now I want you to keep in mind that we're working
308:44 - with a simple data set here. So we've created our known parameters. But in a data set that you
308:50 - haven't created by yourself, you've maybe gathered that from the internet, such as images,
308:55 - you won't be necessarily defining these parameters. Instead, another module from nn will define the
309:02 - parameters for you. And we'll work out what those parameters should end up being. But since we're
309:10 - working with a simple data set, we can define our two parameters that we're trying to estimate.
309:16 - This is a key point here is that our model is going to start with random values. That's the
309:21 - annotation I've added here. Start with a random weight value using torch random. And then we've
309:27 - told it that it can update via gradient descent. So pytorch is going to track the gradients of
309:32 - this parameter for us. And then we've told it that the D type we want is float 32. We don't
309:37 - necessarily need these two set explicitly, because a lot of the time the default in pytorch is to
309:43 - set these two requires grad equals true and d type equals torch dot float. Does that for us
309:49 - behind the scenes? But just to keep things as fundamental and as straightforward as possible,
309:54 - we've set all of this explicitly. So let's jump into the keynote. I'd just like to explain
310:01 - what's going on one more time in a visual sense. So here's the exact code that we've
310:06 - just written. I've just copied it from here. And I've just made it a little bit more colorful.
310:13 - But here's what's going on. So when you build a model in pytorch, it subclasses the nn.modgable
310:21 - class. This contains all the building blocks for neural networks. So our class of model, subclasses
310:27 - nn.modgable. Now, inside the constructor, we initialize the model parameters. Now, as we'll see,
310:36 - later on with bigger models, we won't necessarily always explicitly create the weights and biases.
310:45 - We might initialize whole layers. Now, this is a concept we haven't touched on yet, but
310:50 - we might initialize a list of layers or whatever we need. So basically, what happens in here is that
310:57 - we create whatever variables that we need for our model to use. And so these could be different
311:04 - layers from torch.nn, single parameters, which is what we've done in our case, hard coded values,
311:10 - or even functions. Now, we've explicitly set requires grad equals true for our model parameters.
311:19 - So this, in turn, means that pytorch behind the scenes will track all of the gradients
311:24 - for these parameters here for use with torch.auto grad. So torch.auto grad module of pytorch is what
311:31 - implements gradient descent. Now, a lot of this will happen behind the scenes for when we write
311:36 - our pytorch training code. So if you'd like to know what's happening behind the scenes,
311:41 - I'd highly recommend you checking out these two videos, hence is why I've linked them here.
311:46 - Oh, and for many pytorch.nn modules requires grad is true is set by default.
311:53 - Finally, we've got a forward method. Now, any subclass of nn.modgable, which is what we've done,
312:00 - requires a forward method. Now, we can see this in the documentation. If we go torch
312:06 - dot nn.modgable.
312:10 - Click on module. Do we have forward?
312:16 - Yeah, there we go. So forward, we've got a lot of things built into an nn.modgable.
312:22 - So you see here, this is a subclass of an nn.modgable. And then we have forward.
312:28 - So forward is what defines the computation performed at every call. So if we were
312:34 - to call linear regression model and put some data through it, the forward method is the
312:39 - operation that this module does that this model does. And in our case, our forward method is
312:46 - the linear regression function. So keep this in mind, any subclass of nn.modgable needs to
312:52 - override the forward method. So you need to define a forward method if you're going to subclass
312:56 - nn.modgable. We'll see this very hands on. But for now, I believe that's enough coverage of what
313:03 - we've done. If you have any questions, remember, you can ask it in the discussions. We've got a
313:10 - fair bit going on here. But I think we've broken it down a fair bit. The next step is for us to,
313:17 - I know I mentioned this in a previous video is to cover some PyTorch model building essentials.
313:22 - But we're going to cover a few more of them. We've seen some already. But the next way to really
313:27 - start to understand what's going on is to check the contents of our model, train one, and make
313:33 - some predictions with it. So let's get hands on with that in the next few videos. I'll see you there.
313:42 - Welcome back. In the last couple of videos, we stepped through creating our first PyTorch model.
313:47 - And it looks like there's a fair bit going on here. But some of the main takeaways is that almost
313:52 - every model in PyTorch inherits from nn.modgable. And if you are going to inherit from nn.modgable,
314:00 - you should override the forward method to define what computation is happening in your model.
314:05 - And for later on, when our model is learning things, in other words, updating its weights and
314:10 - bias values from random values to values that better fit the data, it's going to do so via
314:17 - gradient descent and back propagation. And so these two videos are some extra curriculum
314:22 - for what's happening behind the scenes. But we haven't actually written any code yet to trigger
314:27 - these two. So I'll refer back to these when we actually do write code to do that. For now,
314:33 - we've just got a model that defines some forward computation. But speaking of models, let's have
314:41 - a look at a couple of PyTorch model building essentials. So we're not going to write too much
314:45 - code for this video, and it's going to be relatively short. But I just want to introduce you to some
314:50 - of the main classes that you're going to be interacting with in PyTorch. And we've seen
314:54 - some of these already. So one of the first is torch.nn. So contains all of the building blocks
315:02 - for computational graphs. Computational graphs is another word for neural networks.
315:09 - Well, actually computational graphs is quite general. I'll just write here, a neural network
315:15 - can be considered a computational graph. So then we have torch.nn.parameter. We've seen this.
315:28 - So what parameters should our model try and learn? And then we can write here often a PyTorch
315:38 - layer from torch.nn will set these for us. And then we've got torch.nn.module, which is
315:50 - what we've seen here. And so torch.nn.module is the base class for all neural network modules.
316:03 - If you subclass it, you should overwrite forward, which is what we've done here. We've created our
316:13 - own forward method. So what else should we cover here? We're going to see these later
316:19 - on, but I'm going to put it here, torch.optim. This is where the optimizers in PyTorch live.
316:29 - They will help with gradient descent. So optimizer, an optimizer is, as we've said before,
316:39 - that our model starts with random values. And it looks at training data and adjusts the random
316:44 - values to better represent the ideal values. The optimizer contains algorithm that's going to
316:51 - optimize these values, instead of being random, to being values that better represent our data.
316:59 - So those algorithms live in torch.optim. And then one more for now, I'll link to extra resources.
317:08 - And we're going to cover them as we go. That's how I like to do things, cover them as we need them.
317:13 - So all nn.module. So this is the forward method. I'm just going to explicitly say here that all
317:19 - nn.module subclasses require you to overwrite forward. This method defines what happens
317:31 - in the forward computation. So in our case, if we were to pass some data to our linear regression
317:39 - model, the forward method would take that data and perform this computation here.
317:45 - And as your models get bigger and bigger, ours is quite straightforward here.
317:49 - This forward computation can be as simple or as complex as you like, depending on what you'd
317:54 - like your model to do. And so I've got a nice and fancy slide here, which basically reiterates
318:02 - what we've just discussed. PyTorch is central neural network building modules.
318:06 - So the module torch.nn, torch.nn.module, torch.optim, torch.utils.dataset. We haven't actually talked
318:17 - about this yet. And I believe there's one more data loader. We're going to see these two later on.
318:22 - But these are very helpful when you've got a bit more of a complicated data set. In our case,
318:27 - we've got just 50 integers for our data set. We've got a simple straight line. But when we need
318:32 - to create more complex data sets, we're going to use these. So this will help us build models.
318:39 - This will help us optimize our models parameters. And this will help us load data. And if you'd
318:45 - like more, one of my favorite resources is the PyTorch cheat sheet. Again, we're referring
318:50 - back to the documentation. See, all of this documentation, right? As I said, this course is
318:56 - not a replacement for the documentation. It's just my interpretation of how one should best
319:01 - become familiar with PyTorch. So we've got imports, the general import torch from torch.utils.dataset
319:08 - data loader. Oh, did you look at that? We've got that mentioned here, data, data set data loader.
319:14 - And torch, script and jit, neural network API. I want an X. I'll let you go through here.
319:21 - We're covering some of the most fundamental ones here. But there's, of course, PyTorch is
319:26 - quite a big library. So some extra curricula for this video would be to go through this for
319:32 - five to 10 minutes and just read. You don't have to understand them all. We're going to start to
319:36 - get more familiar with all of these. We're not all of them because, I mean, that would require
319:40 - making videos for the whole documentation. But a lot of these through writing them via code.
319:47 - So that's enough for this video. I'll link this PyTorch cheat sheet in the video here.
319:54 - And in the next video, how about we, we haven't actually checked out what happens if we do
320:01 - create an instance of our linear regression model. I think we should do that. I'll see you there.
320:09 - Welcome back. In the last video, we covered some of the PyTorch model building essentials. And look,
320:16 - I linked a cheat sheet here. There's a lot going on. There's a lot of text going on in the page.
320:21 - Of course, the reference material for here is in the Learn PyTorch book. PyTorch model building
320:27 - essentials under 0.1, which is the notebook we're working on here. But I couldn't help myself.
320:32 - I wanted to add some color to this. So before we inspect our model, let's just add a little bit
320:37 - of color to our text on the page. We go to whoa. Here's our workflow. This is what we're covering
320:43 - in this video, right? Or in this module, 0.1. But to get data ready, here are some of the most
320:50 - important PyTorch modules. Torchvision.transforms. We'll see that when we cover computer vision later
320:55 - on. Torch.utils.data.data set. So that's if we want to create a data set that's a little bit
321:00 - more complicated than because our data set is so simple, we haven't used either of these
321:05 - data set creator or data loader. And if we go build a picker model, well, we can use torch.nn.
321:12 - We've seen that one. We've seen torch.nn.module. So in our case, we're building a model. But if we
321:19 - wanted a pre-trained model, well, there's some computer vision models that have already been
321:22 - built for us in torchvision.models. Now torchvision stands for PyTorch's computer vision
321:28 - module. So we haven't covered that either. But this is just a spoiler for what's coming on
321:34 - later on. Then if the optimizer, if we wanted to optimize our model's parameters to better
321:39 - represent a data set, we can go to torch.optim. Then if we wanted to evaluate the model,
321:45 - well, we've got torch metrics for that. We haven't seen that, but we're going to be
321:49 - hands-on with all of these later on. Then if we wanted to improve through experimentation,
321:53 - we've got torch.utils.tensorboard. Hmm. What's this? But again, if you want more,
322:00 - there's some at the PyTorch cheat sheet. But now this is just adding a little bit of color
322:04 - and a little bit of code to our PyTorch workflow. And with that being said, let's get a little bit
322:09 - deeper into what we've built, which is our first PyTorch model. So checking the contents of our
322:18 - PyTorch model. So now we've created a model. Let's see what's inside. You might already be able
322:30 - to guess this by the fact of what we've created in the constructor here in the init function.
322:36 - So what do you think we have inside our model? And how do you think we'd look in that? Now,
322:42 - of course, these are questions you might not have the answer to because you've just, you're like,
322:45 - Daniel, I'm just starting to learn PyTorch. I don't know these, but I'm asking you just to start
322:49 - thinking about these different things, you know? So we can check out our model parameters or what's
322:59 - inside our model using, wait for it, dot parameters. Oh, don't you love it when things are nice and
323:11 - simple? Well, let's check it out. Hey, well, first things we're going to do is let's create a random
323:16 - seed. Now, why are we creating a random seed? Well, because recall, we're creating these parameters
323:25 - with random values. And if we were to create them with outer random seed, we would get different
323:32 - values every time. So for the sake of the educational sense, for the sake of this video,
323:38 - we're going to create a manual seed here, torch dot manual seed. I'm going to use 42 or maybe 43,
323:44 - I could use 43 now 42 because I love 42. It's the answer to the universe. And we're going to create
323:52 - an instance of the model that we created. So this is a subclass of an end up module.
324:02 - So let's do it. Model zero, because it's going to be the zeroth model, the first model that
324:07 - we've ever created in this whole course, how amazing linear regression model, which is what
324:15 - our class is called. So we can just call it like that. That's all I'm doing, just calling this class.
324:21 - And so let's just see what happens there. And then if we go model zero, what does it give us? Oh,
324:27 - linear regression. Okay, it doesn't give us much. But we want to find out what's going on in here.
324:32 - So check out the parameters. So model zero dot parameters. What do we get from this? Oh, a generator.
324:45 - Well, let's turn this into a list that'll be better to look at. There we go. Oh, how exciting is that?
324:53 - So parameter containing. Look at the values tensor requires grad equals true parameter containing
325:01 - wonderful. So these are our model parameters. So why are they the values that they are? Well,
325:11 - it's because we've used torch rand n. Let's see what happens if we go, let's just create torch dot
325:20 - rand n one, what happens? We get a value like that. And now if we run this again,
325:28 - we get the same values. But if we run this again, so keep this in one two, three, four,
325:32 - five, actually, that's, wow, that's pretty cool that we got a random value that was all in order,
325:38 - four in a row. Can we do it twice in a row? Probably not. Oh, we get it the same one. Now,
325:44 - why is that? Oh, we get a different one. Did we just get the same one twice? Oh, my gosh,
325:49 - we got the same value twice in a row. You saw that. You saw that. That's incredible. Now,
325:55 - the reason why we get this is because this one is different every time because there's no random
326:01 - seed. Watch if we put the random seed here, torch dot manual seed, 42, 3, 3, 6, 7, what happens?
326:13 - 3, 3, 6, 7, what happens? 3, 3, 6, 7. Okay. And what if we commented out the random seed
326:20 - here, initialized our model, different values, two, three, five, two, three, four, five, it must
326:27 - like that value. Oh, my goodness. Let me know if you get that value, right? So if we keep going,
326:34 - we get different values every single time. Why is this? Why are we getting different values
326:39 - every single time? You might be, Daniel, you sound like a broken record, but I'm trying to
326:43 - really drive home the fact that we initialize our models with random parameters. So this is the
326:49 - essence of what our machine learning models and deep learning models are going to do. Start with
326:53 - random values, weights and bias. Maybe we've only got two parameters here, but the future models
326:59 - that we build might have thousands. And so of course, we're not going to do them all by hand.
327:03 - We'll see how we do that later on. But for now, we start with random values. And our ideal model
327:08 - will look at the training data and adjust these random values. But just so that we can get
327:13 - reproducible results, I'll get rid of this cell. I've set the random seed here. So you should be
327:20 - getting similar values to this. If you're not, because there's maybe some sort of pytorch update
327:24 - and how the random seeds calculated, you might get slightly different values. But for now,
327:29 - we'll use torch.manualc.42. And I want you to just be aware of this can be a little bit confusing.
327:37 - If you just do the list of parameters, for me, I understand it better if I list the name parameters.
327:45 - So the way we do that is with model zero, and we call state dict on it. This is going to give us
327:54 - our dictionary of the parameters of our model. So as you can see here, we've got weights,
327:59 - and we've got bias, and they are random values. So where did weights and bias come from? Well,
328:06 - of course, they came from here, weights, bias. But of course, as well up here,
328:12 - we've got known parameters. So now our whole goal is what? Our whole goal is to build code,
328:22 - or write code, that is going to allow our model to look at these blue dots here,
328:28 - and adjust this weight and bias value to be weights as close as possible to weight and bias.
328:40 - Now, how do we go from here and here to here and here? Well, we're going to see that in future
328:49 - videos, but the closer we get these values to these two, the better we're going to be able to
328:58 - predict and model our data. Now, this principle, I cannot stress enough, is the fundamental
329:05 - entire foundation, the fundamental foundation. Well, good description, Daniel. The entire
329:10 - foundation of deep learning, we start with some random values, and we use gradient descent and
329:16 - back propagation, plus whatever data that we're working with to move these random values as close
329:22 - as possible to the ideal values. And in most cases, you won't know what the ideal values are.
329:30 - But in our simple case, we already know what the ideal values are.
329:33 - So just keep that in mind going forward. The premise of deep learning is to start with random
329:38 - values and make them more representative closer to the ideal values. With that being said,
329:46 - let's try and make some predictions with our model as it is. I mean, it's got random values.
329:50 - How do you think the predictions will go? So I think in the next video, we'll make some predictions
329:55 - on this test data and see what they look like. I'll see you there. Welcome back. In the last
330:03 - video, we checked out the internals of our first PyTorch model. And we found out that because we're
330:10 - creating our model with torch dot or the parameters of our model, with torch dot rand, they begin as
330:17 - random variables. And we also discussed the entire premise of deep learning is to start with random
330:22 - numbers and slowly progress those towards more ideal numbers, slightly less random numbers based
330:28 - on the data. So let's see, before we start to improve these numbers, let's see what their predictive
330:36 - power is like right now. Now you might be able to guess how well these random numbers will be
330:41 - able to predict on our data. You're not sure what that predicting means? Let's have a look. So making
330:47 - predictions using torch dot inference mode, something we haven't seen. But as always, we're going to
330:56 - discuss it while we use it. So to check our models predictive power, let's see how well
331:07 - it predicts Y test based on X test. Because remember again, another premise of a machine
331:18 - learning model is to take some features as input and make some predictions close to some sort of
331:24 - labels. So when we pass data through our model, it's going to run it through the forward method.
331:41 - So here's where it's a little bit confusing. We defined a forward method and it takes X as input.
331:47 - Now I've done a little X, but we're going to pass it in a large X as its input. But the reason why I've
331:52 - done a little X is because oftentimes in pytorch code, you're going to find all over the internet
331:57 - is that X is quite common, commonly used in the forward method here, like this as the input data.
332:03 - So I've just left it there because that's what you're going to find quite often.
332:07 - So let's test it out. We haven't discussed what inference mode does yet, but we will make predictions
332:13 - with model. So with torch dot inference mode, let's use it. And then we will discuss what's going
332:19 - on. Y threads equals a model zero X test. So that's all we're doing. We're passing the X test data
332:34 - through our model. Now, when we pass this X test in here, let's remind ourselves of what X test is.
332:41 - X test 10 variables here. And we're trying to our ideal model will predict the exact values of Y test.
332:51 - So this is what our model will do if it's a perfect model. It will take these X test values as input,
332:58 - and it will return these Y test values as output. That's an ideal model. So the predictions are the
333:06 - exact same as the test data set. How do you think our model will go considering it's starting with
333:11 - random values as its parameters? Well, let's find out, hey. So what can that Y threads?
333:20 - Oh, what's happened here? Not implemented error. Ah, this is an error I get quite often in Google
333:27 - Colab when I'm creating a high-torch model. Now, it usually happens. I'm glad we've stumbled upon
333:33 - this. And I think I know the fix. But if not, we might see a little bit of troubleshooting in this
333:38 - video is that when we create this, if you see this not implemented error, right, it's saying that
333:46 - the Ford method. Here we go. Ford implemented. There we go. It's a little bit of a rabbit hole
333:52 - this not implemented area. I've come across it a fair few times and it took me a while to figure
333:57 - out that for some reason the spacing. So in Python, you know how you have space space and that defines
334:04 - a function space space. There's another thing there and another line there. For some reason,
334:09 - if you look at this line in my notebook, and by the way, if you don't have these lines or if you
334:13 - don't have these numbers, you can go into tools, settings, editor, and then you can define them here.
334:19 - So show line numbers, show notation guides, all that sort of jazz there. You can customize what's
334:25 - going on. But I just have these two on because I've run into this error a fair few times. And so
334:31 - it's because that this Ford method is not in line with this bracket here. So we need to highlight
334:39 - this and click shift tab, move it over. So now you see that it's in line here. And then if we run
334:45 - this, won't change any output there. See, that's the hidden gotcha. Is that when we ran this before,
334:51 - it found no error. But then when we run it down here, it works. So just keep that in mind. I'm
335:01 - really glad we stumbled upon that because indentation errors, not implemented errors,
335:07 - one of the most common errors you'll find in PyTorch, or in, well, when you're writing PyTorch
335:12 - code in Google CoLab, I'm not sure why, but it just happens. So these are our models predictions
335:18 - so far by running the test data through our models Ford method that we defined. And so if
335:24 - we look at Y test, are these close? Oh my gosh, they are shocking. So why don't we visualize them?
335:33 - Plot predictions. And we're going to put in predictions equals Y threads.
335:40 - Let's have a look. Oh my goodness. All the way over here. Remember how we discussed before
335:46 - that an ideal model will have, what, red dots on top of the green dots because our ideal model
335:52 - will be perfectly predicting the test data. So right now, because our model is initialized with
335:57 - random parameters, it's basically making random predictions. So they're extremely far from where
336:04 - our ideal predictions are, is that we'll have some training data. And our model predictions,
336:09 - when we first create our model will be quite bad. But we want to write some code that will
336:14 - hopefully move these red dots closer to these green dots. I'm going to see how we can do that in
336:20 - later videos. But we did one thing up here, which we haven't discussed, which is with torch dot
336:26 - inference mode. Now this is a context manager, which is what happens when we're making predictions.
336:33 - So making predictions, another word for predictions is inference torch uses inference. So I'll try
336:38 - to use that a bit more, but I like to use predictions as well. We could also just go
336:43 - Y preds equals model zero dot X test. And we're going to get quite a similar output.
336:56 - Right. But I've put on inference mode because I want to start making that a habit for later on,
337:02 - when we make predictions, put on inference mode. Now why do this? You might notice something different.
337:07 - What's the difference here between the outputs? Y preds equals model. There's no inference mode
337:12 - here, no context manager. Do you notice that there's a grad function here? And we don't need to go
337:19 - into discussing what exactly this is doing here. But do you notice that this one is lacking that
337:24 - grad function? So do you remember how behind the scenes I said that pie torch does a few things
337:31 - with requires grad equals true, it keeps track of the gradients of different parameters so that
337:36 - they can be used in gradient descent and back propagation. Now what inference mode does is it
337:44 - turns off that gradient tracking. So it essentially removes all of the, because when we're doing
337:53 - inference, we're not doing training. So we don't need to keep track of the gradient. So we don't
337:56 - need to do to keep track of how we should update our models. So inference mode disables all of the
338:03 - useful things that are available during training. What's the benefit of this? Well, it means that
338:09 - pie torch behind the scenes is keeping track of less data. So in turn, it will, with our small
338:15 - data set, it probably won't be too dramatic. But with a larger data set, it means that your
338:20 - predictions will potentially be a lot faster because a whole bunch of numbers aren't being
338:26 - kept track of or a whole bunch of things that you don't need during prediction mode or inference
338:31 - mode. That's why it's called inference mode. I'm not being saved to memory. If you'd like to
338:37 - learn more about this, you go pie torch inference mode Twitter. I just remember to search for Twitter
338:44 - because they did a big tweet storm about it. Here we go. So oh, this is another thing that we can
338:53 - cover. I'm going to copy this in here. But there's also a blog post about what's going on behind
338:57 - the scenes. Long story short, it makes your code faster. Want to make your inference code and pie
339:03 - torch run faster? Here's a quick thread on doing exactly that. And that's what we're doing. So
339:09 - I'm going to write down here. See more on inference mode here.
339:17 - And I just want to highlight something as well is that they referenced torch no grad with the
339:24 - torch inference mode context manager. Inference mode is fairly new in pie torch. So you might
339:29 - see a lot of code existing pie torch code with torch dot no grad. You can use this as well.
339:35 - Why? Preds equals model zero. And this will do much of the same as what inference mode is doing.
339:40 - But inference mode has a few things that are advantages over no grad, which are discussed in
339:45 - this thread here. But if we do this, we get very similar output to what we got before.
339:51 - Grad function. But as you'll read in here and in the pie torch documentation, inference mode is
339:58 - the favored way of doing inference for now. I just wanted to highlight this. So you can also do
340:05 - something similar with torch dot no grad. However, inference mode is preferred. Alrighty. So I'm
340:26 - just going to comment this out. So we just have one thing going on there. The main takeaway
340:32 - from this video is that when we're making predictions, we use the context manager torch
340:38 - dot inference mode. And right now, because our models variables or internal parameters are
340:44 - randomly initialized, our models predictions are as good as random. So they're actually not too far
340:51 - off where our values are. At least the red dots aren't like scattered all over here. But in the
340:58 - upcoming videos, we're going to be writing some pie torch training code to move these values
341:04 - closer to the green dots by looking at the training data here. So with that being said,
341:12 - I'll see you in the next video. Friends, welcome back. In the last video, we saw that our model
341:20 - performs pretty poorly. Like, ideally, these red dots should be in line with these green dots.
341:26 - And we know that because why? Well, it's because our model is initialized with random parameters.
341:33 - And I just want to put a little note here. You don't necessarily have to initialize your model
341:38 - with random parameters. You could initialize it with this could be zero. Yeah, these two values,
341:43 - weights can bias could be zero and you could go from there. Or you could also use the parameters
341:49 - from another model. But we're going to see that later on. That's something called transfer learning.
341:53 - That's just a little spoiler for what's to come. And so we've also discussed that an ideal model
342:00 - will replicate these known parameters. So in other words, start with random unknown parameters,
342:09 - these two values here. And then we want to write some code for our model to move towards estimating
342:17 - the ideal parameters here. Now, I just want to be explicit here and write down some intuition
342:22 - before we jump into the training code. But this is very exciting. We're about to get into
342:27 - training our very first machine learning model. So what's right here, the whole idea of training
342:34 - is for a model to move from some unknown parameters, these may be random to some known parameters.
342:49 - Or in other words, from a poor representation, representation of the data to a better representation
343:02 - of the data. And so in our case, would you say that our models representation of the green dots
343:09 - here with this red dots, is that a good representation? Or is that a poor representation?
343:14 - I mean, I don't know about you, but I would say that to me, this is a fairly poor representation.
343:21 - And one way to measure the representation between your models outputs, in our case, the red dots,
343:28 - the predictions, and the testing data, is to use a loss function. So I'm going to write
343:36 - this down here. This is what we're moving towards. We're moving towards training, but we need a
343:40 - way to measure how poorly our models predictions are doing. So one way to measure how poor or how
343:49 - wrong your models predictions are, is to use a loss function. And so if we go pytorch loss
344:00 - functions, we're going to see that pytorch has a fair few loss functions built in. But the essence
344:06 - of all of them is quite similar. So just wait for this to load my internet's going a little bit
344:11 - slow today, but that's okay. We're not in a rush here. We're learning something fun.
344:16 - If I search here for loss, loss functions, here we go. So yeah, this is torch in N. These are the
344:20 - basic building blocks for graphs, whole bunch of good stuff in here, including loss functions.
344:25 - Beautiful. And this is another thing to note as well, another one of those scenarios where
344:29 - there's more words for the same thing. You might also see a loss function referred to as a criterion.
344:36 - There's another word called cost function. So I might just write this down so you're aware of it.
344:42 - Yeah, cost function versus loss function. And maybe some formal definitions about what all of these
344:47 - are. Maybe they're used in different fields. But in the case of we're focused on machine learning,
344:51 - right? So I'm just going to go note, loss function may also be called cost function or criterion in
345:03 - different areas. For our case, we're going to refer to it as a loss function. And let's
345:13 - just formally define a loss function here, because we're going to go through a fair few steps in
345:17 - the upcoming videos. So this is a warning, nothing we can't handle. But I want to put some formal
345:22 - definitions on things. We're going to see them in practice. That's what I prefer to do,
345:26 - rather than just sit here defining stuff. This lecture has already had enough text on the page.
345:30 - So hurry up and get into coding Daniel. A loss function is a function to measure how wrong your
345:38 - models predictions are to the ideal outputs. So lower is better. So ideally, think of a measurement,
345:50 - how could we measure the difference between the red dots and the green dots? One of the
345:55 - simplest ways to do so would be just measure the distance here, right? So if we go, let's just
346:00 - estimate this is 035 to 0.8. They're abouts. So what's the difference there? About 0.45.
346:09 - Then we could do the same again for all of these other dots, and then maybe take the average of that.
346:15 - Now, if you've worked with loss functions before, you might have realized that I've just
346:19 - reproduced mean absolute error. But we're going to get to that in a minute. So we need a loss
346:25 - function. I'm going to write down another little dot point here. This is just setting up intuition.
346:30 - Things we need to train. We need a loss function. This is PyTorch. And this is machine learning
346:37 - in general, actually. But we're focused on PyTorch. We need an optimizer. What does the optimizer do?
346:43 - Takes into account the loss of a model and adjusts the model's parameters. So the parameters recall
346:52 - our weight and bias values. Weight and biases. We can check those or bias. We can check those by
347:01 - going model dot parameter or parameters. But I also like, oh, that's going to give us a generator,
347:10 - isn't it? Why do we not define the model yet? What do we call our model? Oh, model zero. Excuse me.
347:17 - I forgot where. I'm going to build a lot of models in this course. So we're giving them numbers.
347:24 - Modeled up parameters. Yeah, we've got a generator. So we'll turn that into a list.
347:28 - But model zero, if we want to get them labeled, we want state dict here.
347:35 - There we go. So our weight is this value. That's a random value we've set. And there's the bias.
347:39 - And now we've only got two parameters for our model. So it's quite simple. However, the principles
347:45 - that we're learning here are going to be the same principles, taking a loss function,
347:50 - trying to minimize it, so getting it to lower. So the ideal model will predict exactly what our
347:55 - test data is. And an optimizer will take into account the loss and will adjust a model's parameter.
348:02 - And our case weights and bias to be, let's finish this definition takes into account the
348:08 - loss of a model and adjust the model's parameters, e.g. weight and bias, in our case, to improve the
348:15 - loss function. And specifically, for PyTorch, we need a training loop and a testing loop.
348:32 - Now, this is what we're going to work towards building throughout the next couple of videos.
348:40 - We're going to focus on these two first, the loss function and optimizer. There's the formal
348:44 - definition of those. You're going to find many different definitions. That's how I'm going to
348:47 - find them. Loss function measures how wrong your model's predictions are, lower is better,
348:52 - optimizer takes into account the loss of your model. So how wrong it is, and starts to move
348:57 - these two values into a way that improves where these red dots end up. But these, again, these
349:04 - principles of a loss function and an optimizer can be for models with two parameters or models
349:11 - with millions of parameters, can be for computer vision models, or could be for simple models like
349:17 - ours that predict the dots on a straight line. So with that being said, let's jump into the next
349:22 - video. We'll start to look a little deeper into loss function, row problem, and an optimizer.
349:28 - I'll see you there. Welcome back. We're in the exciting streak of videos coming up here. I mean,
349:36 - the whole course is fun. Trust me. But this is really exciting because training your first machine
349:40 - learning model seems a little bit like magic, but it's even more fun when you're writing the code
349:45 - yourself what's going on behind the scenes. So we discussed that the whole concept of training
349:50 - is from going unknown parameters, random parameters, such as what we've got so far
349:54 - to parameters that better represent the data. And we spoke of the concept of a loss function.
349:59 - We want to minimize the loss function. That is the whole idea of a training loop in PyTorch,
350:04 - or an optimization loop in PyTorch. And an optimizer is one of those ways that can
350:10 - nudge the parameters of our model. In our case, weights or bias towards values rather than just
350:18 - being random values like they are now towards values that lower the loss function. And if we
350:24 - lower the loss function, what does a loss function do? It measures how wrong our models
350:29 - predictions are compared to the ideal outputs. So if we lower that, well, hopefully we move
350:34 - these red dots towards the green dots. And so as you might have guessed, PyTorch has some built
350:40 - in functionality for implementing loss functions and optimizers. And by the way, what we're covering
350:47 - so far is in the train model section of the PyTorch workflow fundamentals, I've got a little
350:52 - nice table here, which describes a loss function. What does it do? Where does it live in PyTorch?
350:57 - Common values, we're going to see some of these hands on. If you'd like to read about it,
351:02 - of course, you have the book version of the course here. So loss functions in PyTorch,
351:07 - I'm just in docstorch.nn. Look at this. Look at all these loss functions. There's far too many
351:11 - for us to go through all in one hit. So we're just going to focus on some of the most common ones.
351:16 - Look at that. We've got about what's our 15 loss functions, something like that? Well, truth be
351:22 - told is that which one should use? You're not really going to know unless you start to work hands
351:28 - on with different problems. And so in our case, we're going to be looking at L1 loss. And this is
351:34 - an again, once more another instance where different machine learning libraries have different names
351:39 - for the same thing, this is mean absolute error, which we kind of discussed in the last video,
351:46 - which is if we took the distance from this red dot to this green dot and say at 0.4, they're about
351:51 - 0.4, 0.4, and then took the mean, well, we've got the mean absolute error. But in PyTorch,
351:58 - they call it L1 loss, which is a little bit confusing because then we go to MSE loss,
352:03 - which is mean squared error, which is L2. So naming conventions just takes a little bit of getting
352:09 - used to this is a warning for you. So let's have a look at the L1 loss function. Again,
352:16 - I'm just making you aware of where the other loss functions are. We'll do with some binary
352:19 - cross entropy loss later in the course. And maybe even is that categorical cross entropy?
352:26 - We'll see that later on. But all the others will be problem specific. For now, a couple of loss
352:31 - functions like this, L1 loss, MSE loss, we use for regression problems. So that's predicting a number.
352:38 - Cross entropy loss is a loss that you use with classification problems. But we'll see those hands
352:43 - on later on. Let's have a look at L1 loss. So L1 loss creates a criterion. As I said, you might
352:49 - hear the word criterion used in PyTorch for a loss function. I typically call them loss functions.
352:55 - The literature typically calls it loss functions. That measures the mean absolute error. There we
352:59 - go. L1 loss is the mean absolute error between each element in the input X and target Y. Now,
353:07 - your extracurricular measure might have guessed is to read through the documentation for the
353:11 - different loss functions, especially L1 loss. But for the sake of this video, let's just implement
353:16 - it for ourselves. Oh, and if you want a little bit of a graphic, I've got one here. This is where
353:22 - we're up to, by the way, picking a loss function optimizer for step two. This is a fun part, right?
353:28 - We're getting into training a model. So we've got mean absolute error. Here's that graph we've
353:33 - seen before. Oh, look at this. Okay. So we've got the difference here. I've actually measured
353:38 - this before in the past. So I kind of knew what it was. Mean absolute error is if we repeat for
353:44 - all samples in our set that we're working with. And if we take the absolute difference between
353:50 - these two dots, well, then we take the mean, we've got mean absolute error. So MAE loss equals
353:56 - torch mean we could write it out. That's the beauty of pine torch, right? We could write this out.
354:01 - Or we could use the torch and N version, which is recommended. So let's jump in. There's a colorful
354:08 - slide describing what we're about to do. So let's go set up a loss function. And then we're also
354:14 - going to put in here, set up an optimizer. So let's call it loss FN equals NN dot L1 loss.
354:29 - Simple as that. And then if we have a look at what's our loss function, what does this say?
354:34 - Oh my goodness. My internet is going quite slow today.
354:38 - It's raining outside. So there might be some delays somewhere. But that's right. Gives us a
354:42 - chance to sit here and be mindful about what we're doing. Look at that. Okay. Loss function.
354:48 - L1 loss. Beautiful. So we've got a loss function. Our objective for training a machine learning
354:53 - model will be two. Let's go back. Look at the colorful graphic will be to minimize these
354:58 - distances here. And in turn, minimize the overall value of MAE. That is our goal.
355:05 - If our red dots line up with our green dots, we will have a loss value of zero, the ideal point
355:12 - for a model to be. And so let's go here. We now need an optimizer. As we discussed before,
355:18 - the optimizer takes into account the loss of a model. So these two work in tandem.
355:23 - That's why I've put them as similar steps if we go back a few slides.
355:28 - So this is why I put these as 2.1. Often picking a loss function and optimizer and pytorch
355:34 - come as part of the same package because they work together. The optimizer's objective is to
355:40 - give the model values. So parameters like a weight and a bias that minimize the loss function.
355:45 - They work in tandem. And so let's see what an optimizer optimizes. Where might that be?
355:53 - What if we search here? I typically don't use this search because I prefer just using Google
355:59 - search. But does this give us optimizer? Hey, there we go. So again, pytorch has torch.optim
356:09 - which is where the optimizers are. Torch.optim. Let me put this link in here.
356:17 - This is another bit of your extracurricular. If you want to read more about different optimizers
356:21 - in pytorch, as you might have guessed, they have a few. Torch.optim is a package implementing
356:26 - various optimization algorithms. Most commonly used methods are already supported and the interface
356:32 - is general enough so that more sophisticated ones can also be easily integrated into the future.
356:38 - So if we have a look at what algorithms exist here, again, we're going to throw a lot of names
356:42 - at you. But in the literature, a lot of them that have made it into here are already good working
356:50 - algorithms. So it's a matter of picking whichever one's best for your problem. How do you find that
356:55 - out? Well, SGD, stochastic gradient descent, is possibly the most popular. However, there are
357:04 - some iterations on SGD, such as Adam, which is another one that's really popular. So again,
357:11 - this is one of those other machine learning is part art, part science is trial and error of
357:16 - figuring out what works best for your problem for us. We're going to start with SGD because
357:20 - it's the most popular. And if you were paying attention to a previous video, you might have
357:25 - seen that I said, look up gradient descent, wherever we got this gradient descent. There we go.
357:32 - So this is one of the main algorithms that improves our models. So gradient descent and back
357:38 - propagation. So if we have a look at this stochastic gradient descent, bit of a tongue twister,
357:43 - is random gradient descent. So that's what stochastic means. So basically, our model
357:49 - improves by taking random numbers, let's go down here, here, and randomly adjusting them
357:58 - so that they minimize the loss. And once how optimizer, that's right here, once how optimizer
358:04 - torch dot opt in, let's implement SGD, SGD stochastic gradient descent. We're going to write this here,
358:11 - stochastic gradient descent. It starts by randomly adjusting these values. And once it's found
358:20 - some random values or random steps that have minimized the loss value, we're going to see
358:26 - this in action later on, it's going to continue adjusting them in that direction. So say it says,
358:32 - oh, weights, if I increase the weights, it reduces the loss. So it's going to keep increasing the
358:37 - weights until the weights no longer reduce the loss. Maybe it gets to a point at say 0.65.
358:44 - If you increase the weights anymore, the loss is going to go up. So the optimizer is like,
358:48 - well, I'm going to stop there. And then for the bias, the same thing happens. If it decreases the
358:53 - bias and finds that the loss increases, well, it's going to go, well, I'm going to try increasing
358:57 - the bias instead. So again, one last summary of what's going on here, a loss function measures
359:04 - how wrong our model is. And the optimizer adjust our model parameters, no matter whether there's
359:09 - two parameters or millions of them to reduce the loss. There are a couple of things that
359:15 - an optimizer needs to take in. It needs to take in as an argument, params. So this is if we go to
359:23 - SGD, I'm just going to link this as well. SGD, there's the formula of what SGD does. I look at this
359:30 - and I go, hmm, there's a lot going on here. And take me a while to understand that. So I like to
359:35 - see it in code. So we need params. This is short for what parameters should I optimize as an optimizer.
359:43 - And then we also need an LR, which stands for, I'm going to write this in a comment, LR equals
359:49 - learning rate, possibly the most, oh, I didn't even type rate, did I possibly the most important
359:55 - hyper parameter you can set? So let me just remind you, I'm throwing lots of words out here, but I'm
360:02 - kind of like trying to write notes about what we're doing. Again, we're going to see these in action
360:07 - in a second. So check out our models and parameters. So a parameter is a value that the model sets
360:21 - itself. So learning rate equals possibly the most important learning hyper parameter. I don't
360:32 - need learning there, do I? Hyper parameter. And a hyper parameter is a value that us as a data scientist
360:39 - or a machine learning engineer set ourselves, you can set. So the learning rate is, in our case,
360:46 - let's go 0.01. You're like, Daniel, where did I get this value from? Well, again, these type of
360:52 - values come with experience. I think it actually says it in here, LR, LR 0.1. Yeah, okay, so the
361:00 - default is 0.1. But then if we go back to Optim, I think I saw it somewhere. Did I see it somewhere?
361:07 - 0.0? Yeah, there we go. Yeah, so a lot of the default settings are pretty good in torch optimizers.
361:16 - However, the learning rate, what does it actually do? We could go 0.01. These are all common values
361:22 - here. Triple zero one. I'm not sure exactly why. Oh, model, it's model zero. The learning rate says
361:30 - to our optimizer, yes, it's going to optimize our parameters here. But the higher the learning
361:36 - rate, the more it adjusts each of these parameters in one hit. So let's say it's 0.01. And it's going
361:43 - to optimize this value here. So it's going to take that big of a step. If we changed it to here,
361:49 - it's going to take a big step on this three. And if we changed it to all the way to the end 0.01,
361:56 - it's only going to change this value. So the smaller the learning rate, the smaller the change
362:01 - in the parameter, the larger the learning rate, the larger the change in the parameter.
362:06 - So we've set up a loss function. We've set up an optimizer. Let's now move on to the next step
362:13 - in our training workflow. And that's by building a training loop. Far out. This is exciting. I'll
362:20 - see you in the next video. Welcome back. In the last video, we set up a loss function. And we set
362:29 - up an optimizer. And we discussed the roles of each. So loss function measures how wrong our model
362:35 - is. The optimizer talks to the loss function and goes, well, if I change these parameters a certain
362:41 - way, does that reduce the loss function at all? And if it does, yes, let's keep adjusting them in
362:47 - that direction. If it doesn't, let's adjust them in the opposite direction. And I just want to show
362:53 - you I added a little bit of text here just to concretely put down what we were discussing.
362:58 - Inside the optimizer, you'll often have to set two parameters, params and lr, where params is
363:05 - the model parameters you'd like to optimize for an example, in our case, params equals our model
363:10 - zero parameters, which were, of course, a weight and a bias. And the learning rate, which is lr
363:16 - in optimizer, lr stands for learning rate. And the learning rate is a hyper parameter. Remember,
363:22 - a hyper parameter is a value that we the data scientist or machine learning engineer sets,
363:27 - whereas a parameter is what the model sets itself defines how big or smaller optimizer changes
363:35 - the model parameters. So a small learning rate, so the smaller this value results in small
363:41 - changes, a large learning rate results in large changes. So another question might be,
363:47 - well, very valid question. Hey, I put this here already, is which loss function and which optimizer
363:53 - should I use? So this is another tough one, because it's problem specific. But with experience
363:58 - and machine learning, I'm showing you one example here, you'll get an idea of what works for your
364:02 - particular problem for a regression problem, like ours, a loss function of l1 loss, which is mai
364:08 - and pytorch. And an optimizer like torch dot opt in slash s gd like sarcastic gradient descent
364:14 - will suffice. But for a classification problem, we're going to see this later on.
364:18 - Not this one specifically, whether a photo is a cat of a dog, that's just an example of a binary
364:23 - classification problem, you might want to use a binary classification loss. But with that being
364:28 - said, we now are moving on to, well, here's our whole goal is to reduce the MAE of our model.
364:35 - Let's get the workflow. We've done these two steps. Now we want to build a training loop. So
364:40 - let's get back into here. There's going to be a fair few steps going on. We've already covered
364:44 - a few, but hey, nothing we can't handle together. So building a training loop in pytorch.
364:56 - So I thought about just talking about what's going on in the training loop, but we can talk
365:01 - about the steps after we've coded them. How about we do that? So we want to build a training loop
365:06 - and a testing loop. How about we do that? So a couple of things we need in a training loop.
365:16 - So there's going to be a fair few steps here if you've never written a training loop before,
365:20 - but that is completely fine because you'll find that the first couple of times that you write this,
365:25 - you'll be like, oh my gosh, there's too much going on here. But then when you have practice,
365:28 - you'll go, okay, I see what's going on here. And then eventually you'll write them with your
365:33 - eyes closed. I've got a fun song for you to help you out remembering things. It's called the
365:38 - unofficial pytorch optimization loop song. We'll see that later on, or actually, I'll probably leave
365:43 - that as an extension, but you'll see that you can also functionize these things, which we will do
365:48 - later in the course so that you can just write them once and then forget about them. But we're
365:53 - going to write it all from scratch to begin with so we know what's happening. So we want to,
365:57 - or actually step zero, is loop through the data. So we want to look at the data multiple times
366:06 - because our model is going to, at first, start with random predictions on the data, make some
366:11 - predictions. We're trying to improve those. We're trying to minimize the loss to make those
366:15 - predictions. We do a forward pass. So forward pass. Why is it called a forward pass? So this
366:23 - involves data moving through our model's forward functions. Now that I say functions because there
366:34 - might be plural, there might be more than one. And the forward method recall, we wrote in our model
366:39 - up here. Ford. A forward pass is our data going through this function here. And if you want to
366:46 - look at it visually, let's look up a neural network graphic. Images, a forward pass is just
366:55 - data moving from the inputs to the output layer. So starting here input layer moving through the
367:01 - model. So that's a forward pass, also called forward propagation. Another time we'll have
367:07 - more than one name is used for the same thing. So we'll go back down here, forward pass. And
367:14 - I'll just write here also called forward propagation, propagation. Wonderful. And then we need to
367:22 - calculate the loss. So forward pass. Let me write this. To calculate or to make predictions,
367:33 - make predictions on data. So calculate the loss, compare forward pass predictions. Oh, there's
367:46 - an undergoing in the background here of my place. We might be in for a storm. Perfect time to write
367:50 - code, compare forward pass predictions to ground truth labels. We're going to see all this in code
367:56 - in a second, calculate the loss. And then we're going to go optimise a zero grad. We haven't
368:01 - spoken about what this is, but that's okay. We're going to see that in a second. I'm not going to
368:04 - put too much there. Loss backward. We haven't discussed this one either. There's probably three
368:09 - steps that we haven't really discussed. We've discussed the idea behind them, but not too much
368:15 - in depth. Optimise our step. So this one is loss backwards is move backwards. If the forward pass
368:23 - is forwards, like through the network, the forward pass is data goes into out. The backward pass
368:29 - data goes, our calculations happen backwards. So we'll see what that is in a second. Where were
368:35 - we over here? We've got too much going on. I'm getting rid of these moves backwards through
368:41 - the network to calculate the gradients. Oh, oh, the gradients of each of the parameters
368:53 - of our model with respect to the loss. Oh my gosh, that is an absolute mouthful,
368:58 - but that'll do for now. Optimise a step. This is going to use the optimiser to adjust our
369:06 - model's parameters to try and improve the loss. So remember how I said in a previous video
369:16 - that I'd love you to watch the two videos I linked above. One on gradient descent and one
369:21 - on back propagation. If you did, you might have seen like there's a fair bit of math going on in
369:25 - there. Well, that's essentially how our model goes from random parameters to better parameters,
369:33 - using math. Many people, one of the main things I get asked from machine learning is how do I
369:37 - learn machine learning if I didn't do math? Well, the beautiful thing about PyTorch is that it
369:42 - implements a lot of the math of back propagation. So this is back propagation. I'm going to write
369:47 - this down here. This is an algorithm called back, back propagation, hence the loss backward. We're
369:53 - going to see this in code in a second, don't you worry? And this is gradient descent. So these
370:00 - two algorithms drive the majority of our learning. So back propagation, calculate the gradients of
370:06 - the parameters of our model with respect to the loss function and optimise our step,
370:11 - we'll trigger code to run gradient descent, which is to minimise the gradients because what is a
370:16 - gradient? Let's look this up. What is a gradient? I know we haven't written a code yet, but we're
370:24 - going to do that. Images. Gradient, there we go. Changing y, changing x. Gradient is from high
370:32 - school math. Gradient is a slope. So if you were on a hill, let's find a picture of a hill.
370:38 - Picture of a hill. There we go. This is a great big hill. So if you were on the top of this hill,
370:50 - and you wanted to get to the bottom, how would you get to the bottom? Well, of course, you just
370:56 - walked down the hill. But if you're a machine learning model, what are you trying to do? Let's
371:00 - imagine your loss is the height of this hill. You start off with your losses really high, and you
371:05 - want to take your loss down to zero, which is the bottom, right? Well, if you measure the gradient
371:10 - of the hill, the bottom of the hill is in the opposite direction to where the gradient is steep.
371:18 - Does that make sense? So the gradient here is an incline. We want our model to move towards the
371:23 - gradient being nothing, which is down here. And you could argue, yeah, the gradient's probably
371:27 - nothing up the top here, but let's just for argument's sake say that we want to get to the
371:31 - bottom of the hill. So we're measuring the gradient, and one of the ways an optimisation algorithm
371:35 - works is it moves our model parameters so that the gradient equals zero, and then if the gradient
371:43 - of the loss equals zero, while the loss equals zero two. So now let's write some code. So we're
371:48 - going to set up a parameter called or a variable called epochs. And we're going to start with one,
371:53 - even though this could be any value, let me define these as we go. So we're going to write code to
371:59 - do all of this. So epochs, an epoch is one loop through the data dot dot dot. So epochs, we're
372:10 - going to start with one. So one time through all of the data, we don't have much data. And so
372:15 - for epoch, let's go this, this is step zero, zero, loop through the data. By the way, when I say
372:25 - loop through the data, I want you to do all of these steps within the loop. And do dot dot dot
372:33 - loop through the data. So for epoch in range epochs, even though it's only going to be one,
372:39 - we can adjust this later. And because epochs, we've set this ourselves, it is a,
372:45 - this is a hyper parameter, because we've set it ourselves. And I know you could argue that,
372:55 - hey, our machine learning parameters of model zero, or our model parameters, model zero aren't
373:01 - actually parameters, because we've set them. But in the models that you build in the future,
373:06 - they will likely be set automatically rather than you setting them explicitly like we've done when
373:12 - we created model zero. And oh my gosh, this is taking quite a while to run. That's all right.
373:17 - We don't need it to run fast. We just, we need to write some more code, then you'll come on.
373:20 - There's a step here I haven't discussed either. Set the model to training mode. So pytorch models
373:27 - have a couple of different modes. The default is training mode. So we can set it to training
373:32 - mode by going like this. Train. So what does train mode do in a pytorch model? My goodness.
373:40 - Is there a reason my engineer is going this slide? That's all right. I'm just going to
373:44 - discuss this with talking again list. Train mode. Train mode in pytorch sets. Oh, there we go.
373:57 - Requires grad equals true. Now I wonder if we do with torch dot no grad member no grad is similar
374:06 - to inference mode. Will this adjust? See, I just wanted to take note of requires grad equals
374:14 - true. Actually, what I might do is we do this in a different cell. Watch this. This is just going
374:19 - to be rather than me just spit words at you. I reckon we might be able to get it work in doing
374:24 - this. Oh, that didn't list the model parameters. Why did that not come out? Model zero dot eval.
374:33 - So there's two modes of our mode and train mode model dot eval parameters. Hey, we're experimenting
374:40 - together on the fly here. And actually, this is what I want you to do is I want you to experiment
374:44 - with different things. It's not going to say requires grad equals false. Hmm. With torch dot no
374:53 - grad. Model zero dot parameters. I don't know if this will work, but it definitely works behind
375:03 - the scenes. And what I mean by works behind the scenes are not here. It works behind the scenes
375:07 - when calculations have been made, but not if we're trying to explicitly print things out.
375:12 - Well, that's an experiment that I thought was going to work and it didn't work. So train
375:16 - mode in pytorch sets all parameters that require gradients to require gradients.
375:27 - So do you remember with the picture of the hill? I spoke about how we're trying to minimize the
375:32 - gradient. So the gradient is the steepness of the hill. If the height of the hill is a loss function
375:37 - and we want to take that down to zero, we want to take the gradient down to zero. So same thing
375:42 - with the gradients of our model parameters, which are here with respect to the loss function,
375:49 - we want to try and minimize that gradient. So that's gradient descent is take that gradient down to
375:54 - zero. So model dot train. And then there's also model zero dot a vowel. So turns off gradient
376:05 - tracking. So we're going to see that later on. But for now, I feel like this video is getting far
376:12 - too long. Let's finish the training loop in the next video. I'll see you there.
376:19 - Friends, welcome back. In the last video, I promised a lot of code, but we didn't get there. We
376:24 - discussed some important steps. I forgot how much behind the scenes there is to apply towards training
376:29 - loop. And I think it's important to spend the time that we did discussing what's going on,
376:34 - because there's a fair few steps. But once you know what's going on, I mean, later on, we don't
376:38 - have to write all the code that we're going to write in this video, you can functionize it. We're
376:42 - going to see that later on in the course, and it's going to run behind the scenes for us. But we're
376:47 - spending a fair bit of time here, because this is literally the crux of how our model learns. So
376:52 - let's get into it. So now we're going to implement the forward pass, which involves our model's
376:58 - forward function, which we defined up here. When we built our model, the forward pass runs through
377:05 - this code here. So let's just write that. So in our case, because we're training, I'm just
377:12 - going to write here. This is training. We're going to see dot of our later on. We'll talk
377:19 - about that when it comes. Let's do the forward pass. So the forward pass, we want to pass data
377:25 - through our model's forward method. We can do this quite simply by going y pred. So y predictions,
377:31 - because remember, we're trying to use our ideal model is using x test to predict y test
377:38 - on our test data set. We make predictions on our test data set. We learn on our training data set.
377:44 - So we're passing, which is going to get rid of that because we don't need that. So we're
377:49 - passing our model x train and model zero is going to be our current model. There we go. So we learn
377:56 - patterns on the training data to evaluate our model on the test data. Number two, where we are.
378:05 - So we have to calculate the loss. Now, in a previous video, we set up a loss function.
378:10 - So this is going to help us calculate the what what kind of loss are we using? We want to calculate
378:15 - the MAE. So the difference or the distance between our red dot and a green dot. And the formula would
378:21 - be the same if we had 10,000 red dots and 10,000 green dots, we're calculating how far they are
378:27 - apart. And then we're taking the mean of that value. So let's go back here. So calculate the loss.
378:38 - And in our case, we're going to set loss equal to our loss function, which is L one loss in
378:42 - PyTorch, but it is MAE. Y-pred and Y-train. So we're calculating the difference between our models
378:53 - predictions on the training data set and the ideal training values. And if you want to go into
379:00 - torch dot NN loss functions, that's going to show you the order because sometimes this confuses me
379:08 - to what order the values go in here, but it goes prediction first, then labels and I may be wrong
379:14 - there because I get confused here. My dyslexia kicks in, but I'm pretty sure it's predictions first,
379:20 - then actual labels. Do we have an example of where it's used? Yeah, import first, target next.
379:30 - So there we go. And truth be told, because it's mean absolute error, it shouldn't actually matter
379:35 - too much. But in the case of staying true to the documentation, let's do inputs first and then
379:40 - targets next for the rest of the course. Then we're going to go optimizer zero grad. Hmm,
379:48 - haven't discussed this one, but that's okay. I'm going to write the code and then I'm going to
379:52 - discuss what it does. So what does this do? Actually, before we discuss this, I'm going to write
379:59 - these two steps because they kind of all work together. And it's a lot easier to discuss what
380:04 - optimizer zero grad does in the context of having everything else perform back propagation
380:14 - on the loss with respect to the parameters of the model. Back propagation is going to take
380:24 - the loss value. So lost backward, I always say backwards, but it's just backward. That's the code
380:29 - there. And then number five is step the optimizer. So perform gradient descent. So optimizer dot
380:41 - step. Oh, look at us. We just wrote the five major steps of a training loop. Now let's discuss
380:47 - how all of these work together. So it's kind of strange, like the ordering of these, you might
380:54 - think, Oh, what should I do the order? Typically the forward pass and the loss come straight up.
380:59 - Then there's a little bit of ambiguity around what order these have to come in. But the optimizer
381:05 - step should come after the back propagation. So I just like to keep this order how it is because
381:12 - this works. Let's just keep it that way. But what happens here? Well, it also is a little bit
381:17 - confusing in the first iteration of the loop because we've got zero grad. But what happens here is
381:23 - that the optimizer makes some calculations in how it should adjust model parameters with regards to
381:29 - the back propagation of the loss. And so by default, these will by default, how the optimizer
381:38 - changes will accumulate through the loop. So we have to zero them above in step three
381:54 - for the next iteration of the loop. So a big long comment there. But what this is saying is,
382:01 - let's say we go through the loop and the optimizer chooses a value of one, change it by one. And
382:06 - then it goes through a loop again, if we didn't zero it, if we didn't take it to zero, because
382:10 - that's what it is doing, it's going one to zero, it would go, okay, next one, two, three, four,
382:16 - five, six, seven, eight, all through the loop, right? Because we're looping here. If this was
382:21 - 10, it would accumulate the value that it's supposed to change 10 times. But we want it to start
382:27 - again, start fresh each iteration of the loop. And now the reason why it accumulates, that's
382:32 - pretty deep in the pytorch documentation. From my understanding, there's something to do with
382:37 - like efficiency of computing. If you find out what the exact reason is, I'd love to know.
382:42 - So we have to zero it, then we perform back propagation. If you recall, back propagation is
382:49 - discussed in here. And then with optimizer step, we form gradient descent. So the beauty of pytorch,
382:57 - this is the beauty of pytorch, is that it will perform back propagation, we're going to have a
383:02 - look at this in second, and gradient descent for us. So to prevent this video from getting too long,
383:10 - I know we've just written code, but I would like you to practice writing a training loop
383:15 - yourself, just write this code, and then run it and see what happens. Actually, you can comment
383:19 - this out, we're going to write the testing loop in a second. So your extra curriculum for this
383:23 - video is to, one, rewrite this training loop, is to, two, sing the pytorch optimization loop
383:31 - song, let's go into here. If you want to remember the steps, well, I've got a song for you. This is
383:37 - the training loop song, we haven't discussed the test step, but maybe you could try this yourself.
383:42 - So this is an old version of the song, actually, I've got a new one for you. But let's sing this
383:47 - together. It's training time. So we do the forward pass, calculate the loss, optimise a zero grad,
383:54 - loss backwards, optimise a step, step, step. Now you only have to call optimise a step once,
384:01 - this is just for jingle purposes. But for test time, let's test with torch no grad, do the forward
384:08 - pass, calculate the loss, watch it go down, down, down. That's from my Twitter, but this is a way
384:15 - that I help myself remember the steps that are going on in the code here. And if you want the
384:22 - video version of it, well, you're just going to have to search unofficial pytorch optimisation loop
384:31 - song. Oh, look at that, who's that guy? Well, he looks pretty cool. So I'll let you check that
384:38 - out in your own time. But for now, go back through the training loop steps. I've got a colorful
384:46 - graphic coming up in the next video, we're going to write the testing steps. And then we're going
384:50 - to go back one more time and talk about what's happening in each of them. And again, if you'd
384:55 - like some even more extra curriculum, don't forget the videos I've shown you on back propagation
384:59 - and gradient descent. But for now, let's leave this video here. I'll see you in the next one.
385:05 - Friends, welcome back. In the last few videos, we've been discussing the steps in a training
385:12 - loop in pytorch. And there's a fair bit going on. So in this video, we're going to step back
385:17 - through what we've done just to recap. And then we're going to get into testing. And it's nice
385:23 - and early where I am right now. The sun's about to come up. It's a very, very beautiful morning
385:28 - to be writing code. So let's jump in. We've got a little song here for what we're doing in the
385:34 - training steps. For an epoch in a range, comodel.train, do the forward pass, calculate the loss of the
385:42 - measure zero grad, last backward of the measure step step step. That's the little jingle I use to
385:51 - remember the steps in here, because the first time you write it, there's a fair bit going on.
385:55 - But subsequent steps and subsequent times that you do write it, you'll start to memorize this.
386:01 - And even better later on, we're going to put it into a function so that we can just call it
386:06 - over and over and over and over again. With that being said, let's jump in to a colorful slide,
386:13 - because that's a lot of code on the page. Let's add some color to it, understand what's happening.
386:18 - That way you can refer to this and go, Hmm, I see what's going on now. So for the loop, this is why
386:24 - it's called a training loop. We step through a number of epochs. One epoch is a single forward
386:30 - pass through the data. So pass the data through the model for a number of epochs. Epox is a
386:36 - hyper parameter, which means you could set it to 100, you could set it to 1000, you could set it
386:42 - to one as we're going to see later on in this video. We skip this step with the colors, but
386:49 - we put the model in we call model.train. This is the default mode that the model is in.
386:55 - Essentially, it sets up a whole bunch of settings behind the scenes in our model parameters so that
387:01 - they can track the gradients and do a whole bunch of learning behind the scenes with these
387:07 - functions down here. PyTorch does a lot of this for us. So the next step is the forward pass.
387:14 - We perform a forward pass on the training data in the training loop. This is an important note.
387:18 - In the training loop is where the model learns patterns on the training data. Whereas in the
387:24 - testing loop, we haven't got to that yet is where we evaluate the patterns that our model has learned
387:30 - or the parameters that our model has learned on unseen data. So we pass the data through the model,
387:36 - this will perform the forward method located within the model object. So because we created
387:41 - a model object, you can actually call your models whatever you want, but it's good practice to
387:46 - you'll often see it just called model. And if you remember, we'll go back to the code.
387:51 - We created a forward method in our model up here, which is this, because our linear regression model,
387:59 - class, subclasses, nn.module, we need to create our own custom forward method. So that's why it's
388:06 - called a forward pass is because not only does it, well, the technical term is forward propagation.
388:11 - So if we have a look at a neural network picture, forward propagation just means going through
388:20 - the network from the input to the output, there's a thing called back propagation, which we're going
388:26 - to discuss in a second, which happens when we call loss.backward, which is going backward through
388:31 - the model. But let's return to our colorful slide. We've done the forward pass, call a forward method,
388:40 - which performs some calculation on the data we pass it. Next is we calculate the loss value,
388:48 - how wrong the model's predictions are. And this will depend on what loss function you use,
388:53 - what kind of predictions your model is outputting, and what kind of true values you have.
388:58 - But that's what we're doing here. We're comparing our model's predictions on the training data
389:03 - to what they should ideally be. And these will be the training labels. The next step, we zero
389:11 - the optimizer gradients. So why do we do this? Well, it's a little confusing for the first epoch in
389:17 - the loop. But as we get down to optimizer dot step here, the gradients that the optimizer
389:23 - calculates accumulate over time so that for each epoch for each loop step, we want them to go back
389:30 - to zero. And now the exact reason behind why the optimizer accumulates gradients is buried somewhere
389:37 - within the pie torch documentation. I'm not sure of the exact reason from memory. It's because of
389:43 - compute optimization. It just adds them up in case you wanted to know what they were. But if
389:48 - you find out exactly, I'd love to know. Next step is to perform back propagation on the loss function.
389:57 - That's what we're calling loss. backward. Now back propagation is we compute the gradient of
390:02 - every parameter with requires grad equals true. And if you recall, we go back to our code.
390:08 - We've set requires grad equals true for our parameters. Now the reason we've set requires
390:16 - grad equals true is not only so back propagation can be performed on it. But let me show you what
390:23 - the gradients look like. So let's go loss function curve. That's a good idea. So we're looking for
390:30 - so we're looking for some sort of convex curve here. There we go. L two loss. We're using L one loss
390:38 - at the moment. Is there a better one here? All we need is just a nice looking curve. Here we go.
390:44 - So this is why we keep track of the gradients behind the scenes. Pie torch is going to create
390:51 - some sort of curve for all of our parameters that looks like this. Now this is just a 2d plot.
390:56 - So the reason why we're just using an example from Google images is one, because you're going to
391:02 - spend a lot of your time Googling different things. And two, in practice, when you have your own
391:08 - custom neural networks, right now we only have two parameters. So it's quite easy to visualize a
391:14 - loss function curve like this. But when you have say 10 million parameters, you basically can't
391:21 - visualize what's going on. And so pie torch again will take care of these things behind the scenes.
391:27 - But what it's doing is when we say requires grad pie torch is going to track the gradients
391:33 - of each of our parameters. And so what we're trying to do here with back propagation and
391:39 - subsequently gradient descent is calculate where the lowest point is. Because this is a loss function,
391:46 - this is MSC loss, we could trade this out to be MAE loss in our case or L1 loss for our specific
391:53 - problem. But this is some sort of parameter. And we calculate the gradients because what is the
391:59 - gradient? Let's have a look. What is a gradient? A gradient is an inclined part of a road or railway.
392:11 - Now we want it in machine learning. What's it going to give us in machine learning, a gradient
392:17 - is a derivative of a function that has more than one input variable. Okay, let's dive in a little
392:23 - deeper. See, here's some beautiful loss landscapes. We're trying to get to the bottom of here. This
392:28 - is what gradient descent is all about. So oh, there we go. So this is a cost function, which is also a
392:35 - loss function. We start with a random initial variable. What have we done? We started with a
392:40 - random initial variable. Right? Okay. And then we take a learning step. Beautiful. This is W. So
392:47 - this could be our weight parameter. Okay, we're connecting the dots here. This is exciting.
392:52 - We've got a lot of tabs here, but that's all right. We'll bring this all together in a second.
392:57 - And what we're trying to do is come to the minimum. Now, why do we need to calculate the gradients?
393:02 - Well, the gradient is what? Oh, value of weight. Here we go. This is even better.
393:08 - I love Google images. So this is our loss. And this is a value of a weight. So we calculate the
393:14 - gradients. Why? Because the gradient is the slope of a line or the steepness. And so if we
393:23 - calculate the gradient here, and we find that it's really steep right up the top of this,
393:29 - this incline, we might head in the opposite direction to that gradient. That's what gradient
393:34 - descent is. And so if we go down here, now, what are these step points? There's a little thing that
393:40 - I wrote down in the last video at the end of the last video I haven't told you about yet,
393:44 - but I was waiting for a moment like this. And if you recall, I said kind of all of these three steps
393:50 - optimizes zero grad loss backward, optimizes step are all together. So we calculate the
393:55 - gradients because we want to head in the opposite direction of that gradient to get to a gradient
393:59 - value of zero. And if we get to a gradient value of zero with a loss function, well, then the loss
394:05 - is also zero. So that's why we keep track of a gradient with requires grad equals true.
394:10 - And again, PyTorch does a lot of this behind the scenes. And if you want to dig more into
394:15 - what's going on here, I'm going to show you some extra resources for back propagation,
394:20 - which is calculating this gradient curve here, and gradient descent, which is finding the bottom
394:25 - of it towards the end of this video. And again, if we started over this side, we would just go
394:30 - in the opposite direction of this. So maybe this is a positive gradient here, and we just go in the
394:36 - opposite direction here. We want to get to the bottom. That is the main point of gradient descent.
394:42 - And so if we come back, I said, just keep this step size in mind here. If we come back to where
394:50 - we created our loss function and optimizer, I put a little tidbit here for the optimizer.
394:57 - Because we've written a lot of code, and we haven't really discussed what's going on, but
395:00 - I like to do things on the fly as we need them. So inside our optimizer, we'll have main two
395:06 - parameters, which is params. So the model parameters you'd like to optimize,
395:11 - params equals model zero dot parameters in our case. And then PyTorch is going to create
395:17 - something similar to this curve, not visually, but just mathematically behind the scenes for
395:22 - every parameter. Now, this is a value of weight. So this would just be potentially the weight
395:27 - parameter of our network. But again, if you have 10 million parameters, there's no way you could
395:32 - just create all of these curves yourself. That's the beauty of PyTorch. It's doing this behind the
395:36 - scenes through a mechanism called torch autograd, which is auto gradient calculation. And there's
395:43 - beautiful documentation on this. If you'd like to read more on how it works, please go through
395:48 - that. But essentially behind the scenes, it's doing a lot of this for us for each parameter.
395:53 - That's the optimizer. Then within the optimizer, once we've told it what parameters to optimize,
395:58 - we have the learning rate. So the learning rate is another hyper parameter that defines how big or
396:04 - small the optimizer changes the parameters with each step. So a small learning rate results in
396:11 - small changes, whereas a large learning rate is in large changes. And so if we look at this
396:16 - curve here, we might at the beginning start with large steps, so we can get closer and closer to
396:22 - the bottom. But then as we get closer and closer to the bottom, to prevent stepping over to this
396:27 - side of the curve, we might do smaller and smaller steps. And the optimizer in PyTorch,
396:34 - there are optimizers that do that for us. But there is also another concept called learning
396:39 - rate scheduling, which is, again, something if you would like to look up and do more. But
396:46 - learning rate scheduling essentially says, hey, maybe start with some big steps. And then as we
396:51 - get closer and closer to the bottom, reduce how big the steps are that we take. Because if you've
396:57 - ever seen a coin, coin at the back of couch. This is my favorite analogy for this. If you've ever
397:04 - tried to reach a coin at the back of a couch, like this excited young chap, if you're reaching
397:11 - towards the back of a couch, you take quite big steps as you say your arm was over here,
397:17 - you would take quite big steps until you get to about here. And in the closer you get to the coin,
397:22 - the smaller and smaller your steps are. Otherwise, what's going to happen? The coin is going to be
397:27 - lost. Or if you took two small steps, you'd never get to the coin. It would take forever to get there.
397:34 - So that's the concept of learning rate. If you take two big steps, you're going to just end up
397:40 - over here. If you take two small steps, it's going to take you forever to get to the bottom here.
397:46 - And this bottom point is called convergence. That's another term you're going to come across. I
397:49 - know I'm throwing a lot of different terms at you, but that's the whole concept of the learning
397:53 - rate. How big is your step down here? In gradient descent. Gradient descent is this. Back propagation
397:59 - is calculating these derivative curves or the gradient curves for each of the parameters in our
398:05 - model. So let's get out of here. We'll go back to our training steps. Where were we? I think we're
398:12 - up to back propagation. Have we done backward? Yes. So the back propagation is where we do the
398:19 - backward steps. So the forward pass, forward propagation, go from input to output. Back propagation,
398:25 - we take the gradients of the loss function with respect to each parameter in our model
398:30 - by going backwards. That's what happens when we call loss.backward. PyTorch does that for us
398:35 - behind the scenes. And then finally, step number five is step the optimizer. We've kind of discussed
398:43 - that. As I said, if we take a step, let's get our loss curve back up. Loss function curve.
398:51 - Doesn't really matter what curve we use. The optimizer step is taking a step this way to try
398:59 - and optimize the parameters so that we can get down to the bottom here. And I also just noted
399:06 - here that you can turn all of this into a function so we don't necessarily have to remember to
399:09 - write these every single time. The ordering of this, you'll want to do the forward pass first.
399:15 - And then calculate the loss because you can't calculate the loss unless you do the forward pass.
399:19 - I like this ordering here of these three as well. But you also want to do the optimizer step
399:24 - after the loss backward. So this is my favorite ordering. It works. If you like this ordering,
399:29 - you can take that as well. With that being said, I think this video has gotten long enough.
399:35 - In the next video, I'd like to step through this training loop one epoch at a time so that we can
399:42 - see, I know I've just thrown a lot of words at you that this optimizer is going to try and
399:47 - optimize our parameters each step. But let's see that in action how our parameters of our model
399:53 - actually change every time we go through each one of these steps. So I'll see you in the next video.
400:00 - Let's step through our model. Welcome back. And we've spent a fair bit of time on the training loop
400:09 - and the testing loop. Well, we haven't even got to that yet, but there's a reason behind this,
400:13 - because this is possibly one of the most important things aside from getting your data ready,
400:17 - which we're going to see later on in PyTorch deep learning is writing the training loop,
400:22 - because this is literally like how your model learns patterns and data. So that's why we're
400:27 - spending a fair bit of time on here. And we'll get to the testing loop, because that's how you
400:31 - evaluate the patterns that your model has learned from data, which is just as important as learning
400:35 - the patterns themselves. And following on from the last couple of videos, I've just linked some
400:42 - YouTube videos that I would recommend for extra curriculum for back propagation,
400:46 - which is what happens when we call loss stop backward down here. And for the optimizer step,
400:54 - gradient descent is what's happening there. So I've linked some extra resources for what's going
400:59 - on behind the scenes there from a mathematical point of view. Remember, this course focuses on
401:04 - writing PyTorch code. But if you'd like to dive into what math PyTorch is triggering behind the
401:09 - scenes, I'd highly recommend these two videos. And I've also added a note here as to which
401:15 - loss function and optimizer should I use, which is a very valid question. And again,
401:20 - it's another one of those things that's going to be problem specific. But with experience over time,
401:26 - you work with machine learning problems, you write a lot of code, you get an idea of what works
401:30 - and what doesn't with your particular problem set. For example, like a regression problem,
401:35 - like ours, regression is again predicting a number. We use MAE loss, which PyTorch causes
401:41 - L1 loss. You could also use MSE loss and an optimizer like torch opt-in stochastic gradient
401:48 - descent will suffice. But for classification, you might want to look into a binary classification,
401:53 - a binary cross entropy loss, but we'll look at a classification problem later on in the course.
401:59 - For now, I'd like to demonstrate what's going on in the steps here. So let's go model zero.
402:07 - Let's look up the state dict and see what the parameters are for now.
402:10 - Now they aren't the original ones I don't think. Let's re-instantiate our model so we get
402:17 - re new parameters. Yeah, we recreated it here. I might just get rid of that. So we'll rerun our
402:27 - model code, rerun model state dict. And we will create an instance of our model and just make
402:35 - sure your parameters should be something similar to this. If it's not exactly like that, it doesn't
402:40 - matter. But yeah, I'm just going to showcase you'll see on my screen what's going on anyway.
402:46 - State dict 3367 for the weight and 012888 for the bias. And again, I can't stress enough. We've
402:55 - only got two parameters for our model and we've set them ourselves future models that you build
403:00 - and later ones in the course will have much, much more. And we won't actually explicitly set any
403:05 - of them ourselves. We'll check out some predictions. They're going to be terrible because we're using
403:11 - random parameters to begin with. But we'll set up a new loss function and an optimizer. Optimizer
403:17 - is going to optimize our model zero parameters, the weight and bias. The learning rate is 0.01,
403:24 - which is relatively large step. That would be a bit smaller. Remember, the larger the learning rate,
403:30 - the bigger the step, the more the optimizer will try to change these parameters every step.
403:34 - But let's stop talking about it. Let's see it in action. I've set a manual seed here too, by the way,
403:40 - because the optimizer steps are going to be quite random as well, depending on how the models
403:45 - predictions go. But this is just to try and make it as reproduces possible. So keep this in mind,
403:50 - if you get different values to what we're going to output here from my screen to your screen,
403:55 - don't worry too much. What's more important is the direction they're going. So ideally,
404:02 - we're moving these values here. This is from we did one epoch before. We're moving these values
404:08 - closer to the true values. And in practice, you won't necessarily know what the true values are.
404:15 - But that's where evaluation of your model comes in. We're going to cover that when we write a
404:19 - testing loop. So let's run one epoch. Now I'm going to keep that down there. Watch what happens.
404:26 - We've done one epoch, just a single epoch. We've done the forward pass. We've calculated the loss.
404:33 - We've done optimizer zero grad. We've performed back propagation. And we've stepped the optimizer.
404:39 - What is stepping the optimizer do? It updates our model parameters to try and get them further
404:45 - closer towards the weight and bias. If it does that, the loss will be closer to zero. That's what
404:51 - it's trying to do. How about we print out the loss at the same time. Print loss and the loss.
405:00 - Let's take another step. So the loss is 0301. Now we check the weights and the bias. We've changed
405:08 - again three, three, four, four, five, one, four, eight, eight. We go again. The loss is going down.
405:17 - Check it. Hey, look at that. The values are getting closer to where they should be if over so slightly.
405:25 - Loss went down again. Oh my goodness, this is so amazing. Look, we're training our,
405:31 - let's print this out in the same cell. Print our model. State dict. We're training our first
405:39 - machine learning model here, people. This is very exciting, even if it's only step by step and it's
405:44 - only a small model. This is very important. Loss is going down again. Values are getting closer to
405:50 - where they should be. Again, we won't really know where they should be in real problems, but for
405:55 - now we do. So let's just get excited. The real way to sort of measure your model's progress and
406:00 - practice is a lower loss value. Remember, lower is better. A loss value measures how wrong your
406:06 - model is. We're going down. We're going in the right direction. So that's what I meant by,
406:11 - as long as your values are going in the similar direction. So down, we're writing similar code
406:16 - here, but if your values are slightly different in terms of the exact numbers, don't worry too
406:21 - much because that's inherent to the randomness of machine learning, because the steps that the
406:26 - optimizer are taking are inherently random, but they're sort of pushed in a direction.
406:32 - So we're doing gradient descent here. This is beautiful. How low can we get the loss? How about
406:37 - we try to get to 0.1? Look at that. We're getting close to 0.1. And then, I mean, we don't have to
406:43 - do this hand by hand. The bias is getting close to where it exactly should be. We're below 0.1.
406:51 - Beautiful. So that was only about, say, 10 passes through the data, but now you're seeing it in
406:56 - practice. You're seeing it happen. You're seeing gradient descent. Let's go gradient descent work
407:02 - in action. We've got images. This is what's happening. We've got our cost function. J is
407:08 - another term for cost function, which is also our loss function. We start with an initial weight.
407:13 - What have we done? We started with an initial weight, this value here. And what are we doing?
407:20 - We've measured the gradient pytorch has done that behind the scenes for us. Thank you pytorch.
407:24 - And we're taking steps towards the minimum. That's what we're trying to do. If we minimize the
407:29 - gradient of our weight, we minimize the cost function, which is also a loss function. We could
407:36 - keep going here for hours and get as long as we want. But my challenge for you, or actually,
407:43 - how about we make some predictions with our model we've got right now? Let's make some predictions.
407:47 - So with torch dot inference mode, we'll make some predictions together. And then I'm going
407:52 - to set you a challenge. How about you run this code here for 100 epochs after this video,
407:58 - and then you make some predictions and see how that goes. So why preds? Remember how
408:02 - poor our predictions are? Why preds new equals, we just do the forward pass here. Model zero
408:09 - on the test data. Let's just remind ourselves quickly of how poor our previous predictions were.
408:16 - Plot predictions, predictions equals y. Do we still have this saved? Why preds?
408:23 - Hopefully, this is still saved. There we go. Shocking predictions, but we've just done 10 or so
408:30 - epochs. So 10 or so training steps have our predictions. Do they look any better? Let's run
408:35 - this. We'll copy this code. You know my rule. I don't really like to copy code, but in this case,
408:41 - I just want to exemplify a point. I like to write all the code myself. What do we got? Why preds
408:47 - new? Look at that. We are moving our predictions close at the red dots closer to the green dots.
408:54 - This is what's happening. We're reducing the loss. In other words, we're reducing the difference
408:59 - between our models predictions and our ideal outcomes through the power of back propagation
409:05 - and gradient descent. So this is super exciting. We're training our first machine learning model.
409:10 - My challenge to you is to run this code here. Change epochs to 100. See how low you can get this
409:17 - loss value and run some predictions, plot them. And I think it's time to start testing. So give
409:24 - that a go yourself, and then we'll write some testing code in the next video. I'll see you there.
409:32 - Welcome back. In the last video, we did something super excited. We saw our loss go down. So the
409:38 - loss is remember how different our models predictions are to what we'd ideally like them. And we saw
409:44 - our model update its parameters through the power of back propagation and gradient descent, all
409:50 - taken care of behind the scenes for us by PyTorch. So thank you, PyTorch. And again, if you'd like
409:57 - some extra resources on what's actually happening from a math perspective for back propagation and
410:03 - gradient descent, I would refer to you to these. Otherwise, this is also how I learn about things.
410:08 - Gradient descent. There we go. How does gradient descent work? And then we've got back propagation.
410:15 - And just to reiterate, I am doing this and just Googling these things because that's what you're
410:21 - going to do in practice. You're going to come across a lot of different things that aren't
410:25 - covered in this course. And this is seriously what I do day to day as a machine learning engineer
410:31 - if I don't know what's going on. Just go to Google, read, watch a video, write some code,
410:37 - and then I build my own intuition for it. But with that being said, I also issued you the challenge
410:43 - of trying to run this training code for 100 epochs. Did you give that a go? I hope you did. And
410:50 - how low did your loss value? Did the weights and bias get anywhere close to where they should have
410:55 - been? How do the predictions look? Now, I'm going to save that for later on, running this code for
411:01 - 100 epochs. For now, let's write some testing code. And just a note, you don't necessarily have to
411:07 - write the training and testing loop together. You can functionize them, which we will be doing later
411:11 - on. But for the sake of this intuition, building and code practicing and first time where we're
411:17 - writing this code together, I'm going to write them together. So testing code, we call model.ofour,
411:23 - what does this do? So this turns off different settings in the model not needed for evaluation
411:33 - slash testing. This can be a little confusing to remember when you're writing testing code. But
411:39 - we're going to do it a few times until it's habit. So just make it a habit. If you're training your
411:44 - model, call model dot train to make sure it's in training mode. If you're testing or evaluating
411:50 - your model. So that's what a vowel stands for evaluate, call model dot a vowel. So it turns off
411:55 - different settings in the model not needed for evaluation. So testing, this is things like drop
412:00 - out. We haven't seen what drop out is slash batch norm layers. But if we go into torch dot
412:06 - and end, I'm sure you'll come across these things in your future machine learning endeavors. So drop
412:12 - out drop out layers. There we go. And batch norm. Do we have batch batch norm? There we go. If you'd
412:21 - like to work out what they are, feel free to check out the documentation. Just take it from me for
412:27 - now that model of our turns off different settings not needed for evaluation and testing. Then we
412:34 - set up with torch dot inference mode, inference mode. So what does this do? Let's write down here.
412:42 - So this turns off gradient tracking. So as we discussed, if we have parameters in our model,
412:49 - and it turns off actually a few more things and a couple more things behind the scenes,
412:57 - these are things again, not needed for testing. So we discussed that if parameters in our model
413:03 - have requires grad equals true, which is the default for many different parameters in pytorch,
413:08 - pytorch will behind the scenes keep track of the gradients of our model and use them in
413:14 - lost up backward and optimizer step for back propagation and gradient descent. However,
413:21 - we only need those two back propagation and gradient descent during training because that
413:26 - is when our model is learning. When we are testing, we are just evaluating the parameters the patterns
413:31 - that our model has learned on the training data set. So we don't need to do any learning
413:36 - when we're testing. So we turn off the things that we don't need. And is this going to have
413:41 - the correct spacing for me? I'm not sure we'll find out. So we still do the forward pass
413:49 - in testing mode, do the forward pass. And if you want to look up torch inference mode,
413:53 - just go torch inference mode. There's a great tweet about it that pytorch did, which explains
413:58 - what's happening. I think we've covered this before, but yeah, want to make your inference
414:05 - code and pytorch run faster. Here's a quick thread on doing exactly that. So inference
414:11 - mode is torch no grad. Again, you might see torch no grad. I think I'll write that down just to
414:17 - let you know. But here's what's happening behind the scenes. A lot of optimization code,
414:22 - which is beautiful. This is why we're using pytorch so that our code runs nice and far.
414:26 - Let me go there. You may also see with torch dot no grad in older pytorch code. It does
414:33 - similar things, but inference mode is the faster way of doing things according to the thread.
414:39 - And according to there's a blog post attached to there as well, I believe.
414:44 - So you may also see torch dot no grad in older pytorch code, which would be valid. But again,
414:55 - inference mode is the better way of doing things. So do forward pass. So let's get our model. We
415:01 - want to create test predictions here. So we're going to go model zero. There's a lot of code
415:06 - going on here, but I'm going to just step by step it in a second. We'll go back through it all.
415:12 - And then number two is calculate the loss. Now we're doing the test predictions here,
415:17 - calculate the loss test predictions with model zero. So now we want to calculate the what we want
415:24 - to calculate the test loss. So this will be our loss function, the difference between the test
415:31 - pred and the test labels. That's important. So for testing, we're working with test data,
415:37 - for training, we're working with training data. Model learns patterns on the training data,
415:43 - and it evaluates those patterns that it's learned, the different parameters on the testing data. It
415:48 - has never seen before, just like in a university course, you'd study the course materials, which
415:53 - is the training data, and you'd evaluate your knowledge on materials you'd hopefully never
415:58 - seen before, unless you sort of were friends with your professor, and they gave you the exam before
416:03 - the actual exam that would be cheating right. So that's a very important point for the test data
416:08 - set. Don't let your model see the test data set before you evaluate it. Otherwise, you'll get
416:15 - poor results. And that's putting it out what's happening. Epoch, we're going to go Epoch,
416:21 - and then I will introduce you to my little jingle to remember all of these steps because
416:25 - there's a lot going on. Don't you worry. I know there's a lot going on, but again, with practice,
416:31 - we're going to know what's happening here. Like it's the back of our hand. All right.
416:41 - So do we need this? Oh, yeah, we could say that. Oh, no, we don't need test here. Loss. This is
416:49 - loss, not test. Print out what's happening. Okay. And we don't actually need to do this
416:59 - every epoch. We could just go say if epoch divided by 10 equals zero, print out what's happening.
417:06 - Let's do that rather than clutter everything up, print it out, and we'll print out this.
417:12 - So let's just step through what's happening. We've got 100 epochs. That's what we're about to run,
417:17 - 100 epochs. Our model is trained for about 10 so far. So it's got a good base. Maybe we'll just
417:22 - get rid of that base. Start a new instance of our model. So we'll come right back down.
417:33 - So our model is back to randomly initialized parameters, but of course, randomly initialized
417:38 - flavored with a random seed of 42. Lovely, lovely. And so we've got our training code here. We've
417:44 - discussed what's happening there. Now, we've got our testing code. We call model dot eval,
417:49 - which turns off different settings in the model, not needed for evaluation slash testing. We call
417:54 - with torch inference mode context manager, which turns off gradient tracking and a couple more
417:59 - things behind the scenes to make our code faster. We do the forward pass. We do the test predictions.
418:05 - We pass our model, the test data, the test features to calculate the test predictions.
418:11 - Then we calculate the loss using our loss function. We can use the same loss function that we used
418:15 - for the training data. And it's called the test loss, because it's on the test data set.
418:21 - And then we print out what's happening, because we want to know what's happening while our
418:25 - model's training, we don't necessarily have to do this. But the beauty of PyTorch is you can
418:30 - use basic Python printing statements to see what's happening with your model. And so,
418:35 - because we're doing 100 epochs, we don't want to clutter up everything here. So we'll just
418:38 - print out what's happening every 10th epoch. Again, you can customize this as much as you like
418:44 - what's printing out here. This is just one example. If you had other metrics here, such as calculating
418:49 - model accuracy, we might see that later on, hint hint. We might print out our model accuracy.
418:55 - So this is very exciting. Are you ready to run 100 epochs? How low do you think our loss can go?
419:02 - This loss was after about 10. So let's just save this here. Let's give it a go. Ready?
419:07 - Three, two, one. Let's run. Oh my goodness. Look at that. Waits. Here we go. Every 10 epochs
419:17 - were printing out what's happening. So the zero epoch, we started with losses 312. Look at it go
419:22 - down. Yes, that's what we want. And our weights and bias, are they moving towards our ideal weight
419:28 - and bias values of 0.7 and 0.3? Yes, they're moving in the right direction here. The loss is
419:34 - going down. Epoch 20, wonderful. Epoch 30, even better. 40, 50, going down, down, down. Yes,
419:43 - this is what we want. This is what we want. Now, we're predicting a straight line here. Look how
419:48 - low the loss gets. After 100 epochs, we've got about three times less than what we had before.
419:55 - And then we've got these values are quite close to where they should be, 0.5629, 0.3573. We'll make
420:03 - some predictions. What do they look like? Why preds new? This is the original predictions
420:08 - with random values. And if we make why preds new, look how close it is after 100 epochs.
420:15 - Now, what's our, do we print out the test loss? Oh no, we're printing out loss as well.
420:21 - Let's get rid of that. I think this is this. Yeah, that's this statement here. Our code would have
420:25 - been a much cleaner if we didn't have that, but that's all right. Life goes on. So our test loss,
420:30 - because this is the test predictions that we're making, is not as low as our training loss.
420:36 - I wonder how we could get that lower. What do you think we could do? We just trained it for
420:42 - longer. And what happened? How do you think you could get these red dots to line up with these
420:46 - green dots? Do you think you could? So that's my challenge to you for the next video.
420:51 - Think of something that you could do to get these red dots to match up with these green dots,
420:56 - maybe train for longer. How do you think you could do that? So give that a shot. And I'll see
421:01 - in the next video, we'll review what our testing code is doing. I'll see you there.
421:10 - Welcome back. In the last video, we did something super exciting. We trained our model for 100 epochs
421:15 - and look how good the predictions got. But I finished it off with challenging you to see if you could
421:21 - align the red dots with the green dots. And it's okay if you're not sure how the best way to do
421:27 - that. That's what we're here for. We're here to learn what are the best way to do these things
421:31 - together. But you might have had the idea of potentially training the model for a little bit
421:36 - longer. So how could we do that? Well, we could just rerun this code. So the model is going to
421:43 - remember the parameters that it has from what we've done here. And if we rerun it, well, it's going
421:49 - to start from where it finished off, which is already pretty good for our data set. And then
421:55 - it's going to try and improve them even more. This is, I can't stress enough, like what we are
421:59 - doing here is going to be very similar throughout the entire rest of the course for training more
422:04 - and more models. So this step that we've done here for training our model and evaluating it
422:10 - is seriously like the fundamental steps of deep learning with PyTorch is training and evaluating
422:18 - a model. And we've just done it. Although I'll be it to predict some red dots and green dots.
422:25 - That's all right. So let's try to line them up, hey, red dots onto green dots. I reckon if we
422:29 - train it for another 100 epochs, we should get pretty darn close. Ready? Three, two, one. I'm
422:36 - going to run this cell again. Runs really quick because our data's nice and simple. But
422:41 - look at this, lastly, we started 0244. Where do we get down to? 008. Oh my goodness. So we've
422:49 - improved it by another three X or so. And now this is where our model has got really good.
422:55 - On the test loss, we've gone from 00564. We've gone down to 005. So almost 10X improvement there.
423:04 - And so we make some more predictions. What are our model parameters? Remember the ideal ones here.
423:10 - We won't necessarily know them in practice, but because we're working with a simple data set,
423:15 - we know what the ideal parameters are. Model zero state dig weights. These are what they
423:21 - previously were. What are they going to change to? Oh, would you look at that? Oh,
423:27 - 06990. Now, again, if yours are very slightly different to mine, don't worry too much. That is
423:34 - the inherent randomness of machine learning and deep learning. Even though we set a manual seed,
423:39 - it may be slightly different. The direction is more important. So if your number here is not
423:46 - exactly what mine is, it should still be quite close to 0.7. And the same thing with this one.
423:52 - If it's not exactly what mine is, don't worry too much. The same with all of these loss values
423:57 - as well. The direction is more important. So we're pretty darn close. How do these predictions
424:03 - look? Remember, these are the original ones. We started with random. And now we've trained a model.
424:10 - So close. So close to being exactly that. So a little bit off. But that's all right. We could
424:16 - tweak a few things to improve this. But I think that's well and truly enough for this example
424:21 - purpose. You see what's happened. Of course, we could just create a model and set the parameters
424:26 - ourselves manually. But where would be the fun in that? We just wrote some machine learning code
424:30 - to do it for us with the power of back propagation and gradient descent. Now in the last video,
424:38 - we wrote the testing loop. We discussed a few other steps here. But now let's go over it with
424:43 - a colorful slide. Hey, because I mean, code on a page is nice, but colors are even nicer. Oh,
424:49 - we haven't done this. We might set up this in this video too. But let's just discuss what's going on.
424:56 - Create an empty list for storing useful value. So this is helpful for tracking model progress.
425:00 - How can we just do this right now? Hey, we'll go here and we'll go.
425:07 - So what did we have? Epoch count equals that. And then we'll go
425:14 - lost values. So why do we keep track of these? It's because
425:21 - if we want to monitor our models progress, this is called tracking experiments. So track
425:27 - different values. If we wanted to try and improve upon our current model with a future model. So
425:33 - our current results, such as this, if we wanted to try and improve upon it, we might build an
425:39 - entire other model. And we might train it in a different setup. We might use a different learning
425:43 - rate. We might use a whole bunch of different settings, but we track the values so that we
425:48 - can compare future experiments to past experiments, like the brilliant scientists that we are.
425:54 - And so where could we use these lists? Well, we're calculating the loss here. And we're calculating
426:02 - the test loss here. So maybe we each time append what's going on here as we do a status update.
426:13 - So epoch count dot append, and we're going to go a current epoch. And then we'll go loss values
426:24 - dot append, a current loss value. And then we'll do test loss values dot append, the current test
426:34 - loss values. Wonderful. And now let's re-instantiate our model so that it starts from fresh. So this
426:41 - is just create another instance. So we're just going to re-initialize our model parameters to
426:46 - start from zero. If we wanted to, we could functionize all of this so we don't have to
426:50 - go right back up to the top of the code. But just for demo purposes, we're doing it how we're doing
426:55 - it. And I'm going to run this for let's say 200 epochs, because that's what we ended up doing,
427:00 - right? We ran it for 200 epochs, because we did 100 epochs twice. And I want to show you something
427:06 - beautiful, one of the most beautiful sites in machine learning. So there we go, we run it for
427:10 - 200 epochs, we start with a fairly high training loss value and a fairly high test loss value. So
427:17 - remember, what is our loss value? It's ma e. So if we go back, yeah, this is what we're measuring
427:23 - for loss. So this means for the test loss on average, each of our dot points here, the red
427:30 - predictions are 0.481. That's the average distance between each dot point. And then ideally, what
427:38 - are we doing? We're trying to minimize this distance. That's the ma e. So the mean absolute error.
427:45 - And we get it right down to 0.05. And if we make predictions, what do we have here, we get very
427:51 - close to the ideal weight and bias, make our predictions, have a look at the new predictions.
427:58 - Yeah, very small distance here. Beautiful. That's a low loss value.
428:03 - Ideally, they'd line up, but we've got as close as we can for now. So this is one of the most
428:08 - beautiful sites in machine learning. So plot the loss curves. So let's make a plot, because what
428:15 - we're doing, we were tracking the value of epoch count, loss values and test loss values.
428:24 - Let's have a look at what these all look like. So epoch count goes up, loss values ideally go down.
428:31 - So we'll get rid of that. We're going to create a plot p l t dot plot. We're going to step back
428:36 - through the test loop in a second with some colorful slides, label equals train loss.
428:48 - And then we're going to go plot. You might be able to tell what's going on here. Test loss
428:53 - values. We're going to visualize it, because that's the data explorer's motto, right, is visualize,
429:00 - visualize, visualize. This is equals. See, collab does this auto correct. That doesn't really work
429:06 - very well. And I don't know when it does it and why it doesn't. And we got, I know, we didn't,
429:13 - we didn't say loss value. So that's a good auto correct. Thank you, collab.
429:18 - So training and loss and test loss curves. So this is another term you're going to come across
429:24 - often is a loss curve. Now you might be able to think about a loss curve. If we're doing a loss
429:30 - curve, and it's starting at the start of training, what do we want that curve to do?
429:36 - What do we want our loss value to do? We want it to go down. So what should an ideal loss
429:42 - curve look like? Well, we're about to see a couple. Let's have a look. Oh, what do we got wrong?
429:47 - Well, we need to, I'll turn it into NumPy. Is this what we're getting wrong? So why is this wrong?
429:58 - Loss values. Why are we getting an issue? Test loss values.
430:05 - Ah, it's because they're all tens of values. So I think we should, let's,
430:13 - I might change this to NumPy. Oh, can I just do that? If I just call this as a NumPy array,
430:22 - we're going to try and fix this on the fly. People, NumPy array, we'll just turn this into a NumPy
430:28 - array. Let's see if we get NumPy. I'm figuring these things out together. NumPy as NumPy,
430:37 - because mapplotlib works with NumPy. Yeah, there we go. So can we do loss values? Maybe
430:45 - I'm going to try one thing, torch dot tensor, loss values, and then call
430:53 - CPU dot NumPy. See what happens here.
430:58 - There we go. Okay, so let's just copy this. So what we're doing here is
431:06 - our loss values are still on PyTorch, and they can't be because mapplotlib works with
431:14 - NumPy. And so what we're doing here is we're converting our loss values of the training loss
431:19 - to NumPy. And if you call from the fundamental section, we call CPU and NumPy, I wonder if we
431:25 - can just do straight up NumPy, because we're not working on there. Yeah, okay, we don't need
431:31 - CPU because we're not working on the GPU yet, but we might need that later on. Well, this work.
431:36 - Beautiful. There we go. One of the most beautiful sides in machine learning is a declining loss
431:40 - curve. So this is how we keep track of our experiments, or one way, quite rudimentary. We'd like to
431:47 - automate this later on. But I'm just showing you one way to keep track of what's happening.
431:53 - So the training loss curve is going down here. The training loss starts at 0.3, and then it goes
431:58 - right down. The beautiful thing is they match up. If there was a two bigger distance behind the
432:03 - train loss and the test loss, or sorry, between, then we're running into some problems. But if they
432:09 - match up closely at some point, that means our model is converging and the loss is getting as
432:14 - close to zero as it possibly can. If we trained for longer, maybe the loss will go almost basically
432:20 - to zero. But that's an experiment I'll leave you to try to train that model for longer.
432:25 - Let's just step back through our testing loop to finish off this video. So we did that. We created
432:32 - empty lists for strong useful values, storing useful values, strong useful values. Told the
432:37 - model what we want to evaluate or that we want to evaluate. So we put it in an evaluation mode.
432:43 - It turns off functionality used for training, but not evaluations, such as drop out and batch
432:47 - normalization layers. If you want to learn more about them, you can look them up in the documentation.
432:52 - Turn on torch inference mode. So this is for faster performance. So we don't necessarily need this,
432:58 - but it's good practice. So I'm going to say that yes, turn on torch inference mode. So this
433:03 - disables functionality such as gradient tracking for inference. Gradient tracking is not needed
433:08 - for inference only for training. Now we pass the test data through the model. So this will call
433:14 - the models implemented forward method. The forward pass is the exact same as what we did in the
433:19 - training loop, except we're doing it on the test data. So big notion there, training loop,
433:25 - training data, testing loop, testing data. Then we calculate the test loss value,
433:32 - how wrong the models predictions are on the test data set. And of course, lower is better.
433:37 - And finally, we print out what's happening. So we can keep track of what's going on during
433:43 - training. We don't necessarily have to do this. You can customize this print value to print out
433:47 - almost whatever you want, because it's pie torches, basically very beautifully interactive with pure
433:54 - Python. And then we keep track of the values of what's going on on epochs and train loss and test
434:00 - loss. We could keep track of other values here. But for now, we're just going, okay, what's the loss
434:06 - value at a particular epoch for the training set? And for the test set. And of course, all of this
434:11 - could be put into a function. And that way we won't have to remember these steps off by heart.
434:16 - But the reason why we've spent so much time on this is because we're going to be using this
434:21 - training and test functionality for all of the models that we build throughout this course.
434:26 - So give yourself a pat in the back for getting through all of these videos. We've written a lot
434:31 - of code. We've discussed a lot of steps. But if you'd like a song to remember what's happening,
434:37 - let's finish this video off with my unofficial PyTorch optimization loop song.
434:43 - So for an epoch in a range, go model dot train, do the forward pass, calculate the loss, optimize
434:51 - a zero grad, loss backward, optimize a step, step, step. No, you only have to call this once.
434:59 - But now let's test, go model dot eval with torch inference mode, do the forward pass,
435:05 - calculate the loss. And then the real song goes for another epoch because you keep going back
435:11 - through. But we finish off with print out what's happening. And then of course, we evaluate what's
435:18 - going on. With that being said, it's time to move on to another thing. But if you'd like to review
435:23 - what's happening, please, please, please try to run this code for yourself again and check out the
435:29 - slides and also check out the extra curriculum. Oh, by the way, if you want to link to all
435:35 - of the extra curriculum, just go to the book version of the course. And it's all going to be in here.
435:41 - So that's there ready to go. Everything I link is extra curriculum will be in the extra curriculum
435:47 - of each chapter. I'll see you in the next video. Welcome back. In the last video, we saw how to
435:57 - train our model and evaluate it by not only looking at the loss metrics and the loss curves,
436:03 - but we also plotted our predictions and we compared them. Hey, have a go at these random
436:07 - predictions. Quite terrible. But then we trained a model using the power of back propagation and
436:12 - gradient descent. And now look at our predictions. They're almost exactly where we want them to be.
436:18 - And so you might be thinking, well, we've trained this model and it took us a while to
436:22 - write all this code to get some good predictions. How might we run that model again? So I've took
436:28 - in a little break after the last video, but now I've come back and you might notice that my Google
436:33 - Colab notebook has disconnected. So what does this mean if I was to run this? Is it going to work?
436:41 - I'm going to connect to a new Google Colab instance. But will we have all of the code that we've run
436:47 - above? You might have already experienced this if you took a break before and came back to the
436:53 - videos. Ah, so plot predictions is no longer defined. And do you know what that means? That
436:59 - means that our model is also no longer defined. So we would have lost our model. We would have
437:04 - lost all of that effort of training. Now, luckily, we didn't train the model for too long. So we can
437:10 - just go run time, run all. And it's going to rerun all of the previous cells and be quite quick.
437:17 - Because we're working with a small data set and using a small model. But we've been through all
437:21 - of this code. Oh, what have we got wrong here? Model zero state dict. Well, that's all right.
437:26 - This is good. We're finding errors. So if you want to as well, you can just go run after. It's going
437:31 - to run all of the cells after. Beautiful. And we come back down. There's our model training.
437:38 - We're getting very similar values to what we got before. There's the lost curves. Beautiful.
437:42 - Still going. Okay. Now our predictions are back because we've rerun all the cells and we've got
437:47 - our model here. So what we might cover in this video is saving a model in PyTorch. Because if
437:58 - we're training a model and you get to a certain point, especially when you have a larger model,
438:03 - you probably want to save it and then reuse it in this particular notebook itself. Or you might
438:09 - want to save it somewhere and send it to your friend so that your friend can try it out. Or you
438:13 - might want to use it in a week's time. And if Google Colab is disconnected, you might want to
438:18 - be able to load it back in somehow. So now let's see how we can save our models in PyTorch. So
438:25 - I'm going to write down here. There are three main methods you should know about
438:34 - for saving and loading models in PyTorch because of course with saving comes loading. So we're
438:40 - going to over the next two videos discuss saving and loading. So one is torch.save. And as you might
438:47 - guess, this allows you to save a PyTorch object in Python's pickle format. So you may or may not
439:01 - be aware of Python pickle. There we go. Python object serialization. There we go. So we've got
439:09 - the pickle module implements a binary protocols or implements binary protocols for serializing
439:15 - and deserializing a Python object. So serializing means I understand it is saving and deserializing
439:21 - means that it's loading. So this is what PyTorch uses behind the scenes, which is from pure Python.
439:28 - So if we go back here in Python's pickle format, number two is torch.load, which you might be able
439:35 - to guess what that does as well, allows you to load a saved PyTorch object. And number three is
439:44 - also very important is torch.nn.module.loadStatedict. Now what does this allow you to do? Well,
439:54 - this allows you to load a model's saved dictionary or save state dictionary. Yeah, that's what we'll
440:02 - call it. Save state dictionary. Beautiful. And what's the model state dict? Well, let's have a look,
440:08 - model zero dot state dict. The beauty of PyTorch is that it stores a lot of your model's important
440:14 - parameters in just a simple Python dictionary. Now it might not be that simple because our model,
440:21 - again, only has two parameters. In the future, you may be working with models with millions of
440:25 - parameters. So looking directly at the state deck may not be as simple as what we've got here.
440:32 - But the principle is still the same. It's still a dictionary that holds the state of your model.
440:39 - And so I've got these three methods I want to show you where from because this is going to be
440:43 - your extra curriculum, save and load models, your extra curriculum for this video.
440:50 - If we go into here, this is a very, very, very important piece of PyTorch documentation,
440:56 - or maybe even a tutorial. So your extra curriculum for this video is to go through it.
441:02 - Here we go. We've got torch, save, torch, load, torch, module, state deck. That's where, or load
441:07 - state deck, that's where I've got the three things that we've just written down. And there's a fair
441:12 - few different pieces of information. So what is a state deck? So in PyTorch, the learnable
441:17 - parameters, i.e. the weights and biases of a torch and end module, which is our model.
441:22 - Remember, our model subclasses and end module are contained in the model's parameters. Access
441:27 - with model.parameters, a state deck is simply a Python dictionary object that maps each layer
441:33 - to its parameter tensor. That's what we've seen. And so then if we define a model,
441:39 - we can initialize the model. And if we wanted to print the state decked, we can use that.
441:44 - The optimizer also has a state deck. So that's something to be aware of. You can go optimizer.state
441:49 - deck. And then you get an output here. And this is our saving and loading model for inference. So
441:55 - inference, again, is making a prediction. That's probably what we want to do in the future at some
442:00 - point. For now, we've made predictions right within our notebook. But if we wanted to use our model
442:05 - outside of our notebook, say in an application, or in another notebook that's not this one,
442:11 - you'll want to know how to save and load it. So the recommended way of saving and loading a
442:16 - PyTorch model is by saving its state deck. Now, there is another method down here,
442:21 - which is saving and loading the entire model. So your extracurricular for this lesson,
442:29 - we're going to go through the code to do this. But your extracurricular is to read all of the
442:34 - sections in here, and then figure out what the pros and cons are of saving and loading the entire
442:40 - model versus saving and loading just the state deck. So that's a challenge for you for this video.
442:46 - I'm going to link this in here. And now let's write some code to save our model.
442:50 - So PyTorch save and load code. Code tutorial plus extracurricular. So if we go
443:10 - saving our PyTorch model. So what might we want? What do you think the save parameter takes?
443:16 - If we have torch.save, what do you think it takes inside it? Well, let's find out together.
443:24 - Hey, so let's import part lib. We're going to see why in a second. This is Python's
443:29 - module for dealing with writing file paths. So if we wanted to save something to this is Google
443:35 - Colab's file section over here. But just remember, if we do save this from within Google Colab,
443:41 - the model will disappear if our Google Colab notebook instance disconnects. So I'll show you
443:48 - how to download it from Google Colab if you want. Google Colab also has a way save from Google Colab
443:57 - Google Colab to Google Drive to save it to your Google Drive if you wanted to. But I'll leave you
444:02 - to look at that on your own if you like. So we're first going to create a model directory.
444:09 - So create models directory. So this is going to help us create a folder over here called models.
444:15 - And of course, we could create this by hand by adding a new folder here somewhere. But I like
444:21 - to do it with code. So model path, we're going to set this to path, which is using the path library
444:28 - here to create us a path called models. Simple. We're just going to save all of our models to
444:34 - models to the models file. And then we're going to create model path, we're going to make that
444:41 - directory model path dot mkdir for make directory. We're going to set parents to equals true.
444:49 - And we're also going to set exist okay equals to true. That means if it already existed,
444:53 - it won't throw us an error. It will try to create it. But if it already exists, it'll just recreate
444:59 - the parents directory or it'll leave it there. It won't error out on us. We're also going to
445:04 - create a model save path. This way, we can give our model a name. Right now, it's just model zero.
445:12 - We want to save it under some name to the models directory. So let's create the model name.
445:18 - Model name equals 01. I'm going to call it 01 for the section. That way, if we have more models
445:25 - later on the course, we know which ones come from where you might create your own naming
445:30 - convention, model workflow, pytorch workflow, model zero dot pth. And now this is another
445:37 - important point. Pytorch objects usually have the extension dot pth for pytorch or dot pth.
445:46 - So if we go in here, and if we look up dot pth, yeah, a common convention is to save models
445:52 - using either a dot pth or dot pth file extension. I'll let you choose which one you like. I like
445:58 - dot pth. So if we go down here dot pth, they both result in the same thing. You just have to remember
446:05 - to make sure you write the right loading path and right saving path. So now we're going to create
446:11 - our model save path, which is going to be our model path. And because we're using the path lib,
446:17 - we can use this syntax that we've got here, model path slash model name. And then if we just print out
446:23 - model save path, what does this look like? There we go. So it creates a supposic path
446:32 - using the path lib library of models slash 01 pytorch workflow model zero dot pth. We haven't
446:40 - saved our model there yet. It's just got the path that we want to save our model ready. So if we
446:45 - refresh this, we've got models over here. Do we have anything in there? No, we don't yet. So now
446:52 - is our step to save the model. So three is save the model state dict. Why are we saving the state
446:59 - dict? Because that's the recommended way of doing things. If we come up here, saving and loading the
447:04 - model for inference, save and load the state dict, which is recommended. We could also save the entire
447:09 - model. But that's part of your extra curriculum to look into that. So let's use some syntax. It's
447:15 - quite like this torch dot save. And then we pass it an object. And we pass it a path of where to
447:20 - save it. We already have a path. And good thing is we already have a model. So we just have to call
447:24 - this. Let's try it out. So let's go print f saving model to and we'll put in the path here.
447:37 - Model save path. I like to print out some things here and there that way. We know what's going on.
447:44 - And I don't need that capital. Why do I? Getting a little bit trigger happy here with the typing.
447:51 - So torch dot save. And we're going to pass in the object parameter here. And if we looked up torch
447:57 - save, we can go. What does this code take? So torch save object f. What is f? A file like object.
448:07 - Okay. Or a string or OS path like object. Beautiful. That's what we've got. A path like
448:13 - object containing a file name. So let's jump back into here. The object is what? It's our model zero
448:21 - dot state dict. That's what we're saving. And then the file path is model save path. You ready?
448:29 - Let's run this and see what happens. Beautiful. Saving model to models. So it's our model path.
448:35 - And there's our model there. So if we refresh this, what do we have over here?
448:39 - Wonderful. We've saved our trained model. So that means we could potentially if we wanted to,
448:44 - you could download this file here. That's going to download it from Google CoLab to your local
448:49 - machine. That's one way to do it. But there's also a guide here to save from Google Collaboratory
448:56 - to Google Drive. That way you could use it later on. So there's many different ways.
449:01 - The beauty of pie torches is flexibility. So now we've got a saved model. But let's just check
449:06 - using our LS command. We're going to check models. Yeah, let's just check models. This is going to
449:15 - check here. So this is list. Wonderful. There's our 01 pie torch workflow model zero dot pth. Now,
449:23 - of course, we've saved a model. How about we try loading it back in and seeing how it works. So if
449:29 - you want to challenge, read ahead on the documentation and try to use torch dot load to bring our model
449:35 - back in. See what happens. I'll see in the next video. Welcome back. In the last video, we wrote
449:42 - some code here to save our pie torch model. I'm just going to exit out of this couple of things
449:47 - that we don't need just to clear up the screen. And now we've got our dot pth file, because remember
449:53 - dot pth or dot pth is a common convention for saving a pie torch model. We've got it saved there,
449:58 - and we didn't necessarily have to write all of this path style code. But this is just handy for
450:03 - later on if we wanted to functionize this and create it in say a save dot pie file over here,
450:11 - so that we could just call our save function and pass it in a file path where we wanted to save
450:16 - like a directory and a name, and then it'll save it exactly how we want it for later on.
450:22 - But now we've got a saved model. I issued a challenge of trying to load that model in.
450:27 - So do we have torch dot load in here? Did you try that out? We've got, oh, we've got a few options
450:33 - here. Wonderful. But we're using one of the first ones. So let's go back up here. If we wanted to
450:39 - check the documentation for torch dot load, we've got this option here, load. What happens? Loads
450:46 - and objects saved with torch dot save from a file. Torch dot load uses Python's unpickling
450:52 - facilities, but treat storages which underlie tenses specially. They are firstly serialized
450:59 - on the CPU, and then I moved the device they were saved from. Wonderful. So this is moved to the
451:05 - device. If later on when we're using a GPU, this is just something to keep in mind. We'll see that
451:11 - when we start to use a CPU and a GPU. But for now, let's practice using the torch dot load method
451:17 - and see how we can do it. So we'll come back here and we'll go loading a pytorch model.
451:24 - And since we, she's going to start writing here, since we saved our models state debt,
451:32 - so just the dictionary of parameters from a model, rather than
451:36 - the entire model, we'll create a new instance of our model class and load the state deck,
451:49 - load the saved state deck. That's better state deck into that.
451:55 - Now, this is just words on a page. Let's see this in action. So to load in a state deck,
452:01 - which is what we say, we didn't save the entire model itself, which is one option.
452:05 - That's extra curriculum, but we saved just the model state deck. So if we remind ourselves what
452:11 - model zero dot state deck looks like, we saved just this. So to load this in, we have to
452:20 - instantiate a new class or a new instance of our linear regression model class. So to load in a
452:27 - saved state deck, we have to instantiate a new instance of our model class. So let's call this
452:40 - loaded model zero. I like that. That way we can differentiate because it's still going to be the
452:46 - same parameters as model zero, but this way we know that this instance is the loaded version,
452:52 - not just the version we've been training before. So we'll create a new version of it here,
452:57 - linear regression model. This is just the code that we wrote above, linear regression model.
453:03 - And then we're going to load the saved state deck of model zero. And so this will update the new
453:14 - instance with updated parameters. So let's just check before we load it, we haven't written any
453:23 - code to actually load anything. What does loaded model zero? What does the state deck look like here?
453:28 - It won't have anything. It'll be initialized with what?
453:31 - Oh, loaded. That's what I called it loaded. See how it's initialized with random parameters.
453:38 - So essentially all we're doing when we load a state dictionary into our new instance of our
453:43 - model is that we're going, hey, take the saved state deck from this model and plug it into this.
453:49 - So let's see what happens when we do that. So loaded model zero. Remember how I said there's
453:56 - a method to also be aware of up here, which is torch nn module dot load state deck. And because
454:03 - our model is a what, it's a subclass of torch dot nn dot module. So we can call load state deck
454:09 - on our model directly or on our instance. So recall linear regression model is a subclass
454:16 - of nn dot module. So let's call in load state deck. And this is where we call the torch dot load
454:24 - method. And then we pass it the model save path. Is that what we call it? Because torch dot load,
454:31 - it takes in F. So what's F a file like object or a string or a OS path like object. So that's
454:39 - why we created this path like object up here. Model save path. So all we're doing here,
454:45 - we're creating a new instance, linear regression model, which is a subclass of nn dot module.
454:51 - And then on that instance, we're calling in load state deck of torch dot load model save path.
454:58 - Because what's saved at the model save path, our previous models state deck, which is here.
455:04 - So if we run this, let's see what happens. All keys match successfully. That is beautiful.
455:09 - And so see the values here, loaded state deck of model zero. Well, let's check the loaded version
455:15 - of that. We now have wonderful, we have the exact same values as above. But there's a little
455:22 - way that we can test this. So how about we go make some predictions. So make some predictions.
455:30 - Just to make sure with our loaded model. So let's put it in a valve mode. Because when you make
455:39 - predictions, you want it in evaluation mode. So it goes a little bit faster. And we want to
455:45 - also use inference mode. So with torch dot inference mode for making predictions. We want to write
455:53 - this loaded model preds, we're going to make some predictions on the test data as well. So loaded
455:58 - model zero, we're going to forward pass on the X test data. And then we can have a look at the
456:04 - loaded model preds. Wonderful. And then to see if the two models are the same, we can compare
456:14 - loaded model preds with original model preds. So why preds? These should be equivalent equals
456:23 - equals loaded model preds. Do we have the same thing? False, false, false, what's going on here?
456:32 - Why preds? How much different are they? Oh, where's that happened? Have we made some
456:42 - model preds with this yet? So how about we make some model preds? This is troubleshooting on
456:50 - the fly team. So let's go model zero dot eval. And then with torch dot inference mode,
457:00 - this is how we can check to see that our two models are actually equivalent. Why preds equals,
457:06 - I have a feeling why preds actually save somewhere else equals model zero. And then we pass it the
457:13 - X test data. And then we might move this above here. And then have a look at what why preds equals.
457:23 - Do we get the same output? Yes, we should. Wonderful. Okay, beautiful. So now we've covered
457:30 - saving and loading models or specifically saving the models state deck. So we saved it here with
457:36 - this code. And then we loaded it back in with load state deck plus torch load. And then we
457:42 - checked to see by testing equivalents of the predictions of each of our models. So the original
457:48 - one that we trained here, model zero, and the loaded version of it here. So that's saving and
457:53 - loading a model in pytorch. There are a few more things that we could cover. But I'm going to leave
457:58 - that for extra curriculum. We've covered the two main things or three main things. One, two, three.
458:04 - If you'd like to read more, I'd highly encourage you to go through and read this tutorial here.
458:09 - But with that being said, we've covered a fair bit of ground over the last few videos. How about
458:14 - we do a few videos where we put everything together just to reiterate what we've done.
458:20 - I think that'll be good practice. I'll see you in the next video.
458:25 - Welcome back. Over the past few videos, we've covered a whole bunch of ground in a pytorch
458:30 - workflow, starting with data, then building a model. Well, we split the data, then we built a
458:35 - model. We looked at the model building essentials. We checked the contents of our model. We made
458:41 - some predictions with a very poor model because it's based off random numbers. We spent a whole
458:46 - bunch of time figuring out how we could train a model. We figured out what the loss function is.
458:50 - We saw an optimizer. We wrote a training and test loop. We then learned how to save and load a
458:57 - model in pytorch. So now I'd like to spend the next few videos putting all this together. We're
459:03 - not going to spend as much time on each step, but we're just going to have some practice together
459:07 - so that we can reiterate all the things that we've done. So putting it all together,
459:14 - let's go back through the steps above and see it all in one place. Wonderful.
459:24 - So we're going to start off with 6.1 and we'll go have a look at our workflow. So 6.1 is data,
459:35 - but we're going to do one step before that. And I'm just going to get rid of this so we have a bit
459:39 - more space. So we've got our data ready. We've turned it into tenses way back at the start.
459:46 - Then we built a model and then we picked a loss function and an optimizer. We built a training
459:50 - loop. We trained our model. We made some predictions. We saw that they were better. We evaluated our
459:55 - model. We didn't use torch metrics, but we got visual. We saw our red dots starting to line up
460:00 - with the green dots. We haven't really improved through experimentation. We did a little bit of
460:04 - it though, as in we saw that if we trained our model for more epochs, we got better results.
460:10 - So you could argue that we have done a little bit of this, but there are other ways to experiment.
460:14 - We're going to cover those throughout the course. And then we saw how to save and reload a trained
460:19 - model. So we've been through this entire workflow, which is quite exciting, actually.
460:24 - So now let's go back through it, but we're going to do it a bit quicker than what we've done before,
460:29 - because I believe you've got the skills to do so now. So let's start by importing pytorch.
460:36 - So you could start the code from here if you wanted to. And that plot live. And actually,
460:41 - if you want, you can pause this video and try to recode all of the steps that we've done
460:46 - by putting some headers here, like data, and then build a model and then train the model,
460:50 - save and load a model, whatever, and try to code it out yourself. If not, feel free to follow along
460:57 - with me and we'll do it together. So import torch from torch import. Oh, would help if I could spell
461:05 - torch import and n because we've seen that we use an n quite a bit. And we're going to also
461:10 - import map plot live because we like to make some plots because we like to get visual.
461:15 - Visualize visualize visualize as PLT. And we're going to check out pytorch version.
461:24 - That way we know if you're on an older version, some of the code might not work here. But if you're
461:28 - on a newer version, it should work. If it doesn't, let me know. There we go. 1.10. I'm using 1.10
461:34 - for this. By the time you watch this video, there may be a later version out. And we're also going
461:39 - to let's create some device agnostic code. So create device agnostic code, because I think we're
461:46 - up to this step now. This means if we've got access to a GPU, our code will use it for potentially
461:59 - faster computing. If no GPU is available, the code will default to using CPU. We don't necessarily
462:15 - need to use a GPU for our particular problem that we're working on right now because it's a small
462:19 - model and it's a small data set, but it's good practice to write device agnostic code. So that
462:25 - means our code will use a GPU if it's available, or a CPU by default, if a GPU is not available.
462:31 - So set up device agnostic code. We're going to be using a similar setup to this throughout the
462:38 - entire course from now on. So that's why we're bringing it back. CUDA is available. So remember
462:43 - CUDA is NVIDIA's programming framework for their GPUs, else use CPU. And we're going to print
462:50 - what device are we using? Device. So what we might do is if we ran this, it should be just a CPU
463:00 - for now, right? Yours might be different to this if you've enabled a GPU, but let's change this
463:06 - over to use CUDA. And we can do that if you're using Google Colab, we can change the runtime type
463:12 - by selecting GPU here. And then I'm going to save this, but what's going to happen is it's
463:17 - going to restart the runtime. So we're going to lose all of the code that we've written above.
463:22 - How can we get it all back? Well, we can go. Run all. This is going to run all of the cells
463:30 - above here. They should all work and it should be quite quick because our model and data aren't
463:35 - too big. And if it all worked, we should have CUDA as our device that we can use here. Wonderful.
463:42 - So the beauty of Google Colab is that they've given us access to on a video GPU. So thank you,
463:48 - Google Colab. Just once again, I'm paying for the paid version of Google Colab. You don't have to.
463:54 - The free version should give you access to a GPU, or be it it might not be as a later version as
464:00 - GPU as the pro versions give access to. But this will be more than enough for what we're about to
464:06 - recreate. So I feel like that's enough for this video. We've got some device agnostic code ready
464:12 - to go. And for the next few videos, we're going to be rebuilding this except using device agnostic
464:18 - code. So give it a shot yourself. There's nothing in here that we haven't covered before. So I'll
464:24 - see you in the next video. Let's create some data. Welcome back. In the last video, we set up some
464:32 - device agnostic code and we got ready to start putting everything we've learned together.
464:36 - So now let's continue with that. We're going to recreate some data. Now we could just copy this
464:41 - code, but we're going to write it out together so we can have some practice creating a dummy data
464:46 - set. And we want to get to about this stage in this video. So we want to have some data that we can
464:51 - plot so that we can build a model to once again, learn on the blue dots to predict the green dots.
464:58 - So we'll come down here data. I'm going to get out of this as well so that we have a bit more room.
465:03 - Let's now create some data using the linear regression formula of y equals weight times
465:19 - features plus bias. And you may have heard this as y equals mx plus c or mx plus b or something like
465:29 - that, or you can substitute these for different names. Images when I learned this in high school,
465:34 - it was y equals mx plus c. Yours might be slightly different. Yeah, bx plus a. That's what they use
465:41 - here. A whole bunch of different ways to name things, but they're all describing the same thing.
465:45 - So let's see this in code rather than formulaic examples. So we're going to create our weight,
465:51 - which is 0.7 and a bias, which is 0.3. These are the values we previously used for a challenge you
465:58 - could change these to 0.1 maybe and 0.2. These could be whatever values you'd like to set them as.
466:05 - So weight and bias, the principle is going to be the same thing. We're going to try and build a
466:11 - model to estimate these values. So we're going to start at 0 and we're going to end at 1.
466:19 - So we can just create a straight line and we're going to fill in those between 0 and 1 with a
466:24 - step of 0.02. And now we'll create the x and y features x and y, which is features and labels
466:32 - actually. So x is our features and y are our labels. x equals torch dot a range and x is a
466:40 - capital Y is that because typically x is a feature matrix. Even though ours is just a vector now,
466:47 - we're going to unsqueeze this so we don't run into dimensionality issues later on.
466:50 - You can check this for yourself without unsqueeze, errors will pop up and y equals weight times
467:00 - x plus bias. You see how we're going a little bit faster now? This is sort of the pace that we're
467:05 - going to start going for things that we've already covered. If we haven't covered something, we'll
467:11 - slow down, but if we have covered something, I'm going to step it through. We're going to start
467:15 - speeding things up a little. So if we get some values here, wonderful. We've got some x values
467:22 - and they correlate to some y values. We're going to try and use the training values of x to predict
467:28 - the training values of y and subsequently for the test values. Oh, and speaking of training and test
467:34 - values, how about we split the data? So let's split the data. Split data. So we'll create the
467:41 - train split equals int 0.8. We're going to use 80%, which is where 0.8 comes from,
467:47 - for the length of x. So we use 80% of our samples for the training, which is a typical
467:52 - training and test split, 80, 20. They're abouts. You could use like 70, 30. You could use 90, 10.
467:59 - It all depends on how much data you have. There's a lot of things in machine learning that are
468:04 - quite flexible. Train split, we're going to index on our data here so that we can create our splits.
468:10 - Google Colab auto corrected my code in a non-helpful way just then. And we're going to do the
468:19 - opposite split for the testing data. Now let's have a look at the lengths of these. If my calculations
468:27 - are correct, we should have about 40 training samples and 10 testing samples. And again, this
468:37 - may change in the future. When you work with larger data sets, you might have 100,000 training
468:42 - samples and 20,000 testing samples. The ratio will often be quite similar. And then let's plot
468:50 - what's going on here. So plot the data and note, if you don't have the plot predictions
468:59 - function loaded, this will error. So we can just run plot predictions here if we wanted to. And
469:08 - we'll pass it in X train, Y train, X test, Y test. And this should come up with our
469:17 - plot. Wonderful. So we've just recreated the data that we've been previously using. We've got
469:22 - blue dots to predict green dots. But if this function errors out because you've started the notebook
469:26 - from here, right from this cell, and you've gone down from there, just remember, you'll just have
469:33 - to go up here and copy this function. We don't have to do it because we've run all the cells,
469:40 - but if you haven't run that cell previously, you could put it here and then run it, run it,
469:46 - and we'll get the same outcome here. Wonderful. So what's next? Well, if we go back to our workflow,
469:54 - we've just created some data. And have we turned it into tenses yet? I think it's just still, oh,
470:00 - yeah, it is. It's tenses because we use PyTorch to create it. But now we're up to building or
470:07 - picking a model. So we've built a model previously. We did that back in build model. So you could
470:12 - refer to that code and try to build a model to fit the data that's going on here. So that's
470:16 - your challenge for the next video. So building a PyTorch linear model. And why do we call it linear?
470:23 - Because linear refers to a straight line. What's nonlinear? Non-straight. So I'll see you in the
470:29 - next video. Give it a shot before we get there. But we're going to build a PyTorch linear model.
470:39 - Welcome back. We're going through some steps to recreate everything that we've done. In the last
470:44 - video, we created some dummy data. And we've got a straight line here. So now by the workflow,
470:51 - we're up to building a model or picking a model. In our case, we're going to build one
470:54 - to suit our problem. So we've got some linear data. And I've put building a PyTorch linear model
471:00 - here. I issued you the challenge of giving it a go. You could do exactly the same steps that
471:04 - we've done in build model. But I'm going to be a little bit cheeky and introduce something
471:09 - new here. And that is the power of torch.nn. So let's see it. What we're going to do is we're
471:17 - going to create a linear model by subclassingnn.module because why a lot of PyTorch models,
471:28 - subclass, and then module. So class linear regression, what should we call this one?
471:34 - Linear regression model v2. How about that? And we'll subclassnn.module. So much similar code to
471:41 - what we've been writing so far. Or when we first created our linear regression model.
471:46 - And then we're going to put the standard constructor code here, def init underscore underscore.
471:53 - And it's going to take as an argument self. And then we're going to call super dot another
471:59 - underscore init underscore underscore brackets. But we're going to instead of if you recall above
472:08 - back in the build model section, we initialized these parameters ourselves. And I've been hinting
472:15 - at in the past in videos we've seen before that oftentimes you won't necessarily initialize the
472:23 - parameters yourself. You'll instead initialize layers that have the parameters in built in those
472:31 - layers. We still have to create a forward method. But what we're going to see is how we can use our
472:37 - torch linear layer to do these steps for us. So let's write the code and then we'll step through it.
472:43 - So we'll go usenn.linear because why we're building linear regression model and our data is linear.
472:53 - And in the past, our previous model has implemented linear regression formula. So for creating the
473:00 - model parameters. So we can go self dot linear layer equals. So this is constructing a variable
473:11 - that this class can use self linear layer equals nn dot linear. Remember, nn in PyTorch stands for
473:20 - neural network. And we have in features as one of the parameters and out features as another
473:27 - parameter. This means we want to take as input of size one and output of size one. Where does that
473:35 - come from? Well, if we have a look at x train and y train, we have one value of x. Maybe there's
473:46 - too many here. x five will be the first five five and five. So recall, we have one value of x
473:58 - equates to one value of y. So that means within this linear layer, we want to take as one feature
474:04 - x to output one feature y. And we're using just one layer here. So the input and the output shapes
474:11 - of your model in features, out features, what data goes in and what data comes out. These values
474:18 - will be highly dependent on the data that you're working with. And we're going to see different
474:23 - data or different examples of input features and output features all throughout this course. So
474:29 - but that is what's happening. We have one in feature to one out feature. Now what's happening
474:34 - inside nn.linear. Let's have a look torch and then linear. We go the documentation
474:43 - applies a linear transformation to the incoming data. Where have we seen this before?
474:49 - y equals x a t plus b. Now they're using different letters, but we've got the same formula as
474:55 - what's happening up here. Look at the same formula as our data. Wait times x plus bias. And then if
475:03 - we look up linear regression formula once again, linear regression formula. We've got this formula
475:11 - here. Now again, these letters can be replaced by whatever letters you like. But this linear layer
475:19 - is implementing the linear regression formula that we created in our model before. So it's
475:27 - essentially doing this part for us. And behind the scenes, the layer creates these parameters for us.
475:34 - So that's a big piece of the puzzle of pie torch is that as I've said, you won't always be
475:39 - initializing the parameters your model yourself. You'll generally initialize layers. And then you'll
475:45 - use those layers in some Ford computation. So let's see how we could do that. So we've got a linear
475:52 - layer which takes us in features one and out features one. What should we do now? Well, because
475:58 - we've subclassed nn.module we need to override the Ford method. So we need to tell our model
476:05 - what should it do as the Ford computation. And in here it's going to take itself as input,
476:10 - as well as x, which is conventional for the input data. And then we're just going to return
476:15 - here, self dot linear layer x. Right. And actually, we might use some typing here to say that this
476:24 - should be a torch tensor. And it's also going to return a torch dot tensor. That's using Python's
476:31 - type ins. So this is just saying, hey, X should be a torch tensor. And I'm going to return you a
476:37 - torch tensor, because I'm going to pass x through the linear layer, which is expecting one in feature
476:43 - and one out feature. And it's going to this linear transform. That's another word for it. Again,
476:48 - pytorch and machine learning in general has many different names of the same thing. I would call
476:53 - this linear layer. I'm going to write here, also called linear transform, probing layer,
477:03 - fully connected layer, dense layer, intensive flow. So a whole bunch of different names for
477:12 - the same thing, but they're all implementing a linear transform. They're all implementing a
477:17 - version of linear regression y equals x, a ranspose plus b, in features, out features,
477:24 - wonderful. So let's see this in action. So we're going to go set the manual seed so we can
477:32 - get reproducibility as well, torch dot manual seed. And we're going to set model one equals
477:42 - linear regression. This is model one, because we've already got model zero, linear regression
477:48 - V two, and we're going to check model one, and we're going to check its state dictionary,
477:55 - state dict. There we go. What do we have inside this ordered dict? Has that not created anything
478:01 - for us? Model one, dot state dinked, ordered dink. We haven't got anything here in the regression
478:14 - model V two. Ideally, this should be outputting a weight and a bias. Yeah, variables, weight,
478:24 - and bias. Let's dig through our code line by line and see what we've got wrong. Ah, did you notice
478:29 - this? The init function so the constructor had the wrong amount of underscores. So it was never
478:34 - actually constructing this linear layer troubleshooting on the fly team. There we go. Beautiful. So we
478:42 - have a linear layer, and we have it is created for us inside a weight and a bias. So effectively,
478:50 - we've replaced the code we wrote above for build model, initializing a weight and bias parameter
478:55 - with the linear layer. And you might be wondering why the values are slightly different, even though
479:01 - we've used the manual seed. This goes behind the scenes of how PyTorch creates its different
479:07 - layers. It's probably using a different form of randomness to create different types of
479:11 - variables. So just keep that in mind. And to see this in action, we have a conversion here.
479:18 - So this is what's going on. We've converted, this is our original model class, linear regression.
479:24 - We initialize our model parameters here. We've got a weight and a bias. But instead, we've
479:29 - swapped this in our linear regression model V2. This should be V2 to use linear layer. And then
479:36 - in the forward method, we had to write the formula manually here when we initialize the parameters
479:42 - manually. But because of the power of torch.nn, we have just passed it through the linear layer,
479:48 - which is going to perform some predefined forward computation in this layer. So this
479:54 - style of what's going on here is how you're going to see the majority of your PyTorch
479:59 - deep learning models created using pre-existing layers from the torch.nn module. So if we go back
480:07 - into torch.nn, torch.nn, we have a lot of different layers here. So we have convolutional layers,
480:14 - pooling layers, padding layers, normalization, recurrent, transformer, linear, we're using a
480:19 - linear layer, dropout, et cetera, et cetera. So for all of the common layers in deep learning,
480:24 - because that's what neural networks are, they're layers of different mathematical transformations,
480:29 - PyTorch has a lot of pre-built implementations. So that's a little bit of a sneaky trick that
480:34 - I've done to alter our model. But we've still got basically the exact same model as we had before.
480:39 - So what's next? Well, it's to train this model. So let's do that in the next video.
480:44 - Welcome back. So in the last video, we built a PyTorch linear model, nice and simple using a
480:54 - single nn.linear layer with one in feature, one out feature. And we over read the forward method
481:01 - of nn.module using the linear layer that we created up here. So what's going to happen is when we do
481:09 - the forward parser on our model, we're going to put some data in and it's going to go through
481:13 - this linear layer, which behind the scenes, as we saw with torch and n linear,
481:20 - behind the scenes, it's going to perform the linear regression formula here. So y equals x,
481:27 - a t plus b. But now case, we've got weight and bias. So let's go back. It's now time to write
481:35 - some training code. But before we do, let's set the model to use the target device. And so in
481:43 - our case, we've got a device of CUDA. But because we've written device agnostic code, if we didn't
481:50 - have access to a CUDA device, a GPU, our default device would be a CPU. So let's check the model
481:57 - device. We can do that first up here, check the model current device, because we're going to use
482:04 - the GPU here, or we're going to write device agnostic code. That's better to say device agnostic code.
482:12 - That's the proper terminology device. What device are we currently using? This is the CPU, right?
482:19 - So by default, the model will end up on the CPU. But if we set it to model one call dot two device,
482:27 - what do you think it's going to do now? If our current target device is CUDA, we've seen what
482:31 - two does in the fundamental section, two is going to send the model to the GPU memory. So now let's
482:38 - check whether parameters of our model live dot device. If we send them to the device previously,
482:45 - it was the CPU, it's going to take a little bit longer while the GPU gets fired up and goes,
482:50 - PyTorch goes, Hey, I'm about to send you this model. You ready for it? Boom, there we go. Wonderful.
482:56 - So now our model is on the device or the target device, which is CUDA. And if CUDA wasn't available,
483:02 - the target device would be CPU. So this would just come out just exactly how we've got it here.
483:07 - But with that being said, now let's get on to some training code. And this is the fun part.
483:13 - What do we have to do? We've already seen this for training. I'm just going to clear up our
483:18 - workspace a little bit here. For training, we need, this is part of the PyTorch workflow,
483:25 - we need a loss function. What does a loss function do? Measures how wrong our model is,
483:29 - we need an optimizer, we need a training loop and a testing loop. And the optimizer, what does that
483:37 - do? Well, it optimizes the parameters of our model. So in our case, model one dot state dig,
483:44 - what do we have? So we have some parameters here within the linear layer, we have a weight,
483:50 - and we have a bias. The optimizer is going to optimize these random parameters so that they
483:56 - hopefully reduce the loss function, which remember the loss function measures how wrong our model
484:01 - is. So in our case, because we're working with the regression problem, let's set up the loss
484:06 - function. And by the way, all of these steps are part of the workflow. We've got data ready,
484:12 - we've built or picked a model, we're using a linear model. Now we're up to here 2.1 pick a loss
484:17 - function and an optimizer, we're going to do build a training loop in the same session,
484:22 - because you know what, we're getting pretty darn good at this, loss function equals what?
484:27 - Well, we're going to use l one loss. So let's set that up and then dot l one loss, which is the
484:32 - same as ma and if we wanted to set up our optimizer, what optimizer could we use? Well, pytorch offers
484:42 - a lot of optimizers in torch dot opt in SGD. That's stochastic gradient descent, because remember
484:49 - gradient descent is the algorithm that optimizes our model parameters. Adam is another popular option.
484:56 - For now, we're going to stick with SGD. LR, which stands for learning rate. In other words,
485:01 - how big of a step will our optimizer change our parameters with every iteration, a smaller
485:07 - learning rate. So such as 0001 will be a small step. And then a large learning rate, such as 0.1
485:15 - will be a larger step. Too big of a step. Our model learns too much. And it explodes too small of a
485:22 - step. Our model never learns anything. But oh, we actually have to pass params first. I forgot
485:28 - about that. I got ahead of myself with a learning rate. Params is the parameters we'd like our
485:33 - optimizer to optimize. So in our case, it's model one dot parameters, because model one is our current
485:39 - target model. Beautiful. So we've got a loss function and an optimizer. Now, let's write a training
485:47 - loop. So I'm going to set torch manual seeds so we can try and get as reproducible as results as
485:54 - possible. Remember, if you get different numbers to what I'm getting, don't worry too much if they're
485:59 - not exactly the same, the direction is more important. So that means if my loss function is
486:05 - getting smaller, yours should be getting smaller too. Don't worry too much if your fourth decimal
486:10 - place isn't the same as what my values are. So we have a training loop ready to be written here.
486:17 - Epox, how many should we do? Well, we did 200 last time and that worked pretty well. So let's do 200
486:22 - again. Did you go through the extra curriculum yet? Did you watch the video for the unofficial
486:28 - PyTorch optimization loop song yet? This one here, listen to the unofficial PyTorch optimization
486:36 - loop song. If not, it's okay. Let's sing it together. So for an epoch in range, epochs, we're going to
486:45 - go through the song in a second. We're going to set the model to train. In our case, it's model one,
486:51 - model to train. Now, step number one is what? Do the forward pass. This is where we calculate
486:57 - the predictions. So we calculate the predictions by passing the training data through our model.
487:03 - And in our case, because the forward method in model one implements the linear layer,
487:09 - this data is going to go through the linear layer, which is torch.nn.linear and go through
487:15 - the linear regression formula. And then we calculate the loss, which is how wrong our models predictions
487:21 - are. So the loss value equals loss fn. And here we're going to pass in y-pred and y-train.
487:31 - Then what do we do? We zero the optimizer, optimizer zero grad, which because by default,
487:37 - the optimizer is going to accumulate gradients behind the scenes. So every epoch, we want to
487:44 - reduce those back to zero. So it starts from fresh. We're going to perform back propagation here,
487:50 - back propagation, by calling loss, stop backwards. If the forward pass goes forward through the
487:57 - network, the backward pass goes backwards through the network, calculating the gradients for the
488:03 - loss function with respect to each parameter in the model. So optimizer step, this next part,
488:09 - is going to look at those gradients and go, you know what? Which way should I optimize the parameters?
488:15 - So because the optimizer is optimizing the model parameters, it's going to look at the
488:20 - loss and go, you know what? I'm going to adjust the weight to be increased. And I'm going to lower
488:26 - the bias and see if that reduces the loss. And then we can do testing. We can do both of these in
488:32 - the same hit. Now we are moving quite fast through this because we spent a whole bunch of time
488:36 - discussing what's going on here. So for testing, what do we do? We set the model into evaluation
488:42 - mode. That's going to turn off things like dropout and batch normalization layers. We don't have any
488:47 - of that in our model for now, but just it's good practice to always call a vowel whenever you're
488:53 - doing testing. And same with inference mode. We don't need to track gradients and a whole bunch of
488:58 - other things PyTorch does behind the scenes when we're testing or making predictions. So we use
489:02 - the inference mode context manager. This is where we're going to create test pred, which is going
489:08 - to be our test predictions, because here we're going to pass the test data features, forward
489:13 - pass through our model. And then we can calculate the test loss, which is our loss function. And we're
489:20 - going to compare the test pred to Y test. Wonderful. And then we can print out what's happening.
489:28 - So what should we print out? How about if epoch divided by 10 equals zero. So every 10 epochs,
489:40 - let's print something out, print. We'll do an F string here, epoch is epoch. And then we'll go
489:51 - loss, which is the training loss, and just be equal to the loss. And then we'll go test loss is
489:58 - equal to test loss. So do you think this will work? It's okay if you're not sure. But let's find
490:08 - out together, hey, oh, we've got a, we need a bracket there. Oh my goodness, what's going on?
490:15 - Run time error. Expected all tenses to be on the same device. Oh, of course. Do you know what's
490:22 - happening here? But we found at least two devices, CUDA and CPU. Yes, of course, that's what's happened.
490:28 - So what have we done? Up here, we put our model on the GPU. But what's going on here? Our data?
490:36 - Has our data on the GPU? No, it's not. By default, it's on the CPU. So we haven't written device
490:43 - agnostic code for our data. So let's write it here, put data on the target device.
490:52 - Device agnostic code for data. So remember, one of the biggest issues with pytorch aside from
490:59 - shape errors is that you should have your data or all of the things that you're computing with
491:06 - on the same device. So that's why if we set up device agnostic code for our model,
491:11 - we have to do the same for our data. So now let's put X train to device. Y train equals Y train
491:20 - to device. This is going to create device agnostic code. In our case, it's going to use CUDA because
491:25 - we have access to a CUDA device. But if we don't, this code will still work. It will still default
491:32 - to CPU. So this is good. I like that we got that error because that's the sum of the things you're
491:38 - going to come across in practice, right? So now let's run this. What's happening here?
491:43 - Hey, look at that. Wonderful. So our loss starts up here nice and high. And then it starts to go
491:50 - right down here for the training data. And then the same for the testing data. Beautiful.
491:56 - Right up here. And then all the way down. Okay. So this looks pretty good on the test data set. So
492:02 - how can we check this? How can we evaluate our model? Well, one way is to check its state
492:08 - deck. So state decked. What do we got here? What are our weight and bias? Oh my gosh, so close.
492:16 - So we just set weight and bias before to be 0.7 and 0.3. So this is what our model has estimated
492:24 - our parameters to be based on the training data. 0.6968. That's pretty close to 0.7,
492:31 - nearly perfect. And the same thing with the bias 0.3025 versus the perfect value is 0.93. But remember,
492:38 - in practice, you won't necessarily know what the ideal parameters are. This is just to exemplify
492:44 - what our model is doing behind the scenes. It's moving towards some ideal representative
492:50 - parameters of whatever data we're working with. So in the next video, I'd like you to give it a go
492:56 - of before we get to the next video, make some predictions with our model and plot them on the
493:02 - original data. How close to the green dots match up with the red dots? And you can use this plot
493:08 - predictions formula or function that we've been using in the past. So give that a go and I'll
493:14 - see you in the next video. But congratulations. Look how quickly we just trained a model using
493:19 - the steps that we've covered in a bunch of videos so far and device agnostic code. So good.
493:25 - I'll see you soon. In the last video, we did something very, very exciting. We worked through
493:33 - training an entire neural network. Some of these steps took us an hour or so worth of videos to
493:38 - go back through before. But we coded that in one video. So you're ready listening the song just to
493:43 - remind ourselves of what's going on. For an epoch in a range, call model dot train, do the forward
493:49 - pass, calculate the loss, optimizer zero grad, loss backward, optimizer step, step, step, let's
493:59 - test, come on a dot eval with torch inference mode, do the forward pass, calculate the loss,
494:06 - print out what's happening. And then we do it again, again, again, for another epoch in a range.
494:15 - Now I'm kidding. We'll just leave it there. We'll just leave it there. But that's the
494:18 - unofficial pytorch optimization loop song. We created some device agnostic code so that we could
494:24 - make the calculations on the same device as what our model is because the models also using device
494:29 - agnostic code. And so now we've got to evaluate our models. We've looked at the loss and the test
494:36 - lost here. And we know that our models loss is going down. But what does this actually equate to
494:41 - when it makes predictions? That's what we're most interested in, right? And we've looked at the
494:45 - parameters. They're pretty close to the ideal parameters. So at the end of last video, I issued
494:51 - you the challenge to making and evaluating predictions to make some predictions and plot them. I hope
495:00 - you gave it a shot. Let's see what it looks like together. Hey, so turn the model into evaluation
495:08 - mode. Why? Because every time we're making predictions or inference, we want our model to be in a
495:13 - vowel mode. And every time we're training, we want our model to be in training mode. And then we're
495:18 - going to make predictions on the test data, because we train on the train data, and we evaluate our
495:26 - model on the test data data that our model has never actually seen, except for when it makes
495:31 - predictions. With torch inference mode, we turn on inference mode whenever we make inference or
495:37 - predictions. So we're going to set Y threads equal to model one, and the test data goes in here.
495:43 - Let's have a look at what the Y threads look like. Wonderful. So we've got a tensor here. It shows
495:50 - us that they're still on the device CUDA. Why is that? Well, that's because previously we set the
495:56 - model one to the device, the target device, the same with the test data. So subsequently,
496:03 - our predictions are also on the CUDA device. Now, let's bring in the plot predictions function here.
496:09 - So check out our model predictions visually. We're going to adhere to the data explorer's motto
496:17 - of visualize visualize visualize plot predictions. And predictions are going to be set to
496:26 - equals Y threads. And let's have a look. How good do these look? Oh, no.
496:35 - Oh, we've got another error type error. Can't convert CUDA device type tensor to NumPy.
496:41 - Oh, of course. Look what we've done. So our plot predictions function, if we go back up,
496:48 - where did we define that? What does our plot predictions function use? It uses matplotlib,
496:53 - of course, and matplotlib works with NumPy, not pytorch. And NumPy is CPU based. So of course,
497:01 - we're running into another error down here, because we just said that our predictions are on the CUDA
497:07 - device. They're not on the CPU. They're on a GPU. So it's giving us this helpful information here.
497:13 - Use tensor dot CPU to copy the tensor to host memory first. So this is our tensor. Let's call
497:19 - dot CPU and see what happens then. Is that going to go to CPU? Oh, my goodness. Look at that.
497:27 - Look at that. Go the linear layer. The red dots, the predictions are basically on top of the testing
497:34 - data. That is very exciting. Now again, you may not get the exact same numbers here, and that is
497:38 - perfectly fine. But the direction should be quite similar. So your red dots should be basically on
497:43 - top of the green dots, if not very slightly off. But that's okay. That's okay. We just want to focus
497:50 - on the direction here. So thanks to the power of back propagation here and gradient descent,
497:57 - our models random parameters have updated themselves to be as close as possible to the ideal parameters.
498:05 - And now the predictions are looking pretty darn good for what we're trying to predict.
498:09 - But we're not finished there. We've just finished training this model. What would happen if our
498:13 - notebook disconnected right now? Well, that wouldn't be ideal, would it? So in the next part,
498:18 - we're going to move on to 6.5, saving, and loading a trained model. So I'm going to give you a
498:27 - challenge here as well, is to go ahead and go back and refer to this code here, saving model
498:33 - in PyTorch, loading a PyTorch model, and see if you can save model one, the state dictionary of
498:39 - model one, and load it back in and get something similar to this. Give that a shot, and I'll see you
498:45 - in the next video. Welcome back. In the last video, we saw the power of the torch.nn.linear layer,
498:53 - and back propagation and gradient descent. And we've got some pretty darn good predictions
498:58 - out of our model. So that's very exciting. Congratulations. You've now trained two machine
499:03 - learning models. But it's not over yet. We've got to save and load our trained model. So I
499:10 - issued you the challenge in the last video to try and save and load the model yourself. I hope
499:14 - you gave that a go. But we're going to do that together in this video. So we're going to start
499:19 - by importing path because we would like a file path to save our model to. And the first step we're
499:26 - going to do is create models directory. We don't have to recreate this because I believe we already
499:32 - have one. But I'm going to put the code here just for completeness. And this is just so if you
499:37 - didn't have a models directory, this would create one. So model path is going to go to path
499:48 - models. And then we'd like to model path dot maker, we're going to call maker for make directory.
499:56 - We'll set parents equal to true. And if it exists, okay, that'll also be true. So we won't get an error.
500:03 - Oh my gosh, Google collab. I didn't want that. We won't get an error if it already exists.
500:08 - And two, we're going to create a model save path. So if you recall that pytorch objects in general
500:15 - have the extension of what? There's a little pop quiz before we get to the end of this sentence.
500:21 - So this is going to be pytorch workflow for this module that we're going through. This one here,
500:27 - chapter 01 pytorch workflow model one. And they usually have the extension dot PT for pytorch or
500:35 - PT H for pytorch as well. I like PT H. But just remember, sometimes you might come across slightly
500:43 - different versions of that PT or PT H. And we're going to create the model save name or the save
500:49 - path. It's probably a better way to do it is going to be model path. And then we can use because we're
500:55 - using the path lib module from Python, we can save it under model name. And so if we look at this,
501:02 - what do we get model save path? We should get Oh, path is not defined. Oh, too many capitals here,
501:11 - Daniel. The reason why I'm doing these in capitals is because oftentimes hyper parameters such as epochs
501:18 - in machine learning are set as hyper parameters LR could be learning rate. And then you could have
501:25 - as well model name equals Yeah, yeah, yeah. But that's just a little bit of nomenclature trivia for
501:33 - later on. And model save path, we've done that. Now we're going to save the model state dictionary
501:39 - rather than the whole model, save the model state deck, which you will find the pros and cons of
501:46 - in where in the pytorch documentation for saving and loading model, which was a little bit of extra
501:53 - curriculum for a previous video. But let's have a look at our model save path will print it out.
501:58 - And we'll go torch save, we'll set the object that we're trying to save to equal model one dot state
502:06 - deck, which is going to contain our trained model parameters. We can inspect what's going on in here,
502:12 - state deck. They'll show us our model parameters. Remember, because we're only using a single linear
502:18 - layer, we only have two parameters. But in practice, when you use a model with maybe hundreds of layers
502:24 - or tens of millions of parameters, viewing the state deck explicitly, like we are now,
502:30 - might not be too viable of an option. But the principle still remains a state deck contains
502:35 - all of the models trained or associated parameters, and what state they're in. And the file path we're
502:43 - going to use is, of course, the model save path, which we've seen here is a POSIX path. Let's save
502:49 - our model. Wonderful saving model to this file path here. And if we have a look at our folder,
502:57 - we should have two saved models now, beautiful to save models. This one for us from the workflow
503:02 - we did before up here, saving a model in PyTorch, loading a PyTorch model. And now the one we've got,
503:08 - of course, model one is the one that we've just saved. Beautiful. So now let's load a model. We're
503:15 - going to do both of these in one video. Load a PyTorch model. You know what, because we've had a
503:19 - little bit of practice so far, and we're going to pick up the pace. So let's go loaded, let's call
503:25 - it, we'll create a new instance of loaded model one, which is, of course, our linear regression model
503:31 - V2, which is the version two of our linear regression model class, which subclasses, what?
503:37 - Subclasses and n.module. So if we go back here up here to where we created it. So linear regression
503:43 - model V2 uses a linear layer rather than the previous iteration of linear regression model,
503:50 - which we created right up here. If we go up to here, which explicitly defined the parameters,
503:59 - and then implemented a linear regression formula in the forward method, the difference between
504:03 - what we've got now is we use PyTorch's pre-built linear layer, and then we call that linear layer
504:10 - in the forward method, which is probably the far more popular way of building PyTorch models,
504:15 - is stacking together pre-built NN layers, and then calling them in some way in the forward method.
504:21 - So let's load it in. So we'll create a new instance of linear regression model V2, and now what do
504:32 - we do? We've created a new instance, I'm just going to get out of this, make some space for us.
504:38 - We want to load the model state deck, the saved model one state deck, which is the state deck that
504:45 - we just saved beforehand. So we can do this by going loaded model one, calling the load state
504:52 - decked method, and then passing it torch dot load, and then the file path of where we saved that
504:58 - PyTorch object before. But the reason why we use the path lib is so that we can just call model
505:05 - save path in here. Wonderful. And then let's check out what's going on. Or actually, we need to
505:13 - put the target model or the loaded model to the device. The reason being is because we're doing all
505:22 - our computing with device agnostic code. So let's send it to the device. And I think that'll be about
505:30 - it. Let's see if this works. Oh, there we go. Linear regression model V2 in features one,
505:36 - out features one, bias equals true. Wonderful. Let's check those parameters. Hey, next loaded model
505:43 - one dot parameters. Are they on the right device? Let's have a look. Beautiful. And let's just check
505:51 - the loaded state dictionary of loaded model one. Do we have the same values as we had previously?
505:57 - Yes, we do. Okay. So to conclusively make sure what's going on, let's evaluate the loaded model.
506:04 - Evaluate loaded model, loaded model one. What do we do for making predictions? Or what do we do to
506:11 - evaluate? We call dot a vowel. And then if we're going to make some predictions, we use torch
506:17 - inference mode with torch inference mode. And then let's create loaded model one, threads
506:24 - equals loaded model one. And we'll pass it the test data. And now let's check for a quality
506:32 - between Y threads, which is our previous model one preds that we made up here, Y threads.
506:39 - And we're going to compare them to the fresh loaded model one preds. And should they be the same?
506:50 - Yes, they are beautiful. And we can see that they're both on the device CUDA. How amazing is that? So
506:57 - I want to give you a big congratulations, because you've come such a long way. We've gone through
507:02 - the entire PyTorch workflow from making data, preparing and loading it to building a model.
507:08 - All of the steps that come in building a model, there's a whole bunch there, making predictions,
507:13 - training a model, we spent a lot of time going through the training steps. But trust me, it's
507:18 - worth it, because we're going to be using these exact steps all throughout the course. And in fact,
507:23 - you're going to be using these exact steps when you build PyTorch models after this course. And
507:27 - then we looked at how to save a model so we don't lose all our work, we looked at loading a model,
507:32 - and then we put it all together using the exact same problem, but in far less time. And as you'll
507:37 - see later on, we can actually make this even quicker by functionalizing some of the code we've already
507:42 - written. But I'm going to save that for later. I'll see you in the next video, where I'm just
507:47 - going to show you where you can find some exercises and all of the extra curriculum I've been talking
507:51 - about throughout this section 01 PyTorch workflow. I'll see you there. Welcome back. In the last
508:00 - video, we finished up putting things together by saving and loading our trained model, which is
508:06 - super exciting, because let's come to the end of the PyTorch workflow section. So now, this section
508:12 - is going to be exercises and extra curriculum, or better yet, where you can find them. So I'm
508:18 - going to turn this into markdown. And I'm going to write here for exercises and extra curriculum.
508:27 - Refer to. So within the book version of the course materials, which is at learnpytorch.io,
508:35 - we're in the 01 section PyTorch workflow fundamentals. There'll be more here by the time you watch
508:40 - this video likely. And then if we go down here, at the end of each of these sections, we've got
508:45 - the table of contents over here. We've got exercises and extra curriculum. I listed a bunch of things
508:51 - throughout this series of 01 videos, like what's gradient descent and what's back propagation. So
508:58 - I've got plenty of resources to learn more on that. There's the loading and saving PyTorch
509:04 - documentation. There's the PyTorch cheat sheet. There's a great article by Jeremy Howard for a
509:09 - deeper understanding of what's going on in torch.nn. And there's, of course, the unofficial PyTorch
509:14 - optimization loop song by yours truly, which is a bit of fun. And here's some exercises. So
509:21 - the exercises here are all based on the code that we wrote throughout section 01. So there's
509:27 - nothing in the exercises that we haven't exactly covered. And if so, I'll be sure to put a note
509:32 - in the exercise itself. But we've got create a straight line data set using the linear regression
509:37 - formula. And then build a model by subclassing and end up module. So for these exercises, there's an
509:44 - exercise notebook template, which is, of course, linked here. And in the PyTorch deep learning
509:50 - GitHub, if we go into here, and then if we go into extras, and if we go into exercises, you'll
509:56 - find all of these templates here. They're numbered by the same section that we're in. This is PyTorch
510:01 - workflow exercises. So if you wanted to complete these exercises, you could click this notebook
510:07 - here, open in Google CoLab. I'll just wait for this to load. There we go. And you can start to
510:16 - write some code here. You could save a copy of this in your own Google Drive and go through this.
510:21 - It's got some notes here on what you should be doing. You can, of course, refer to the text-based
510:26 - version of them. They're all here. And then if you want an example of what some solutions look
510:31 - like, now, please, I can't stress enough that I would highly, highly recommend trying the exercises
510:36 - yourself. You can use the book that we've got here. This is just all the code from the videos.
510:43 - You can use this. You can use, I've got so many notebooks here now, you can use all of the code
510:47 - that we've written here to try and complete the exercises. But please give them a go yourself.
510:52 - And then if you go back into the extras folder, you'll also find solutions. And this is just one
510:57 - example solutions for section 01. But I'm going to get out of that so you can't cheat and look
511:03 - at the solutions first. But there's a whole bunch of extra resources all contained within
511:09 - the PyTorch deep loaning repo, extras, exercises, solutions, and they're also in the book version
511:16 - of the course. So I'm just going to link this in here. I'm going to put this right at the bottom
511:21 - here. Wonderful. But that is it. That is the end of the section 01 PyTorch workflow.
511:28 - So exciting. We went through basically all of the steps in a PyTorch workflow,
511:33 - getting data ready, turning into tenses, build or pick a model, picking a loss function on an
511:38 - optimizer. We built a training loop. We fit the model to the data. We made a prediction.
511:42 - We evaluated our model. We improved through experimentation by training for more epochs.
511:47 - We'll do more of this later on. And we saved and reload our trained model.
511:51 - But that's going to finish 01. I will see you in the next section. Friends, welcome back.
512:02 - We've got another very exciting module. You ready? Neural network classification with
512:10 - PyTorch. Now combining this module once we get to the end with the last one, which was
512:15 - regression. So remember classification is predicting a thing, but we're going to see this in a second.
512:20 - And regression is predicting a number. Once we've covered this, we've covered two of the
512:25 - the biggest problems in machine learning, predicting a number or predicting a thing.
512:30 - So let's start off with before we get into any ideas or code, where can you get help?
512:38 - First things first is follow along with the code. If you can, if in doubt, run the code.
512:44 - Try it for yourself. Write the code. I can't stress how important this is.
512:48 - If you're still stuck, press shift, command, and space to read the doc string of any of the
512:53 - functions that we're running. If you are on Windows, it might be control. I'm on a Mac, so I put command
512:59 - here. If you're still stuck, search for your problem. If an error comes up, just copy and paste
513:04 - that into Google. That's what I do. You might come across resources like Stack Overflow or,
513:09 - of course, the PyTorch documentation. We'll be referring to this a lot again throughout this
513:14 - section. And then finally, oh wait, if you're still stuck, try again. If in doubt, run the code.
513:21 - And then finally, if you're still stuck, don't forget, you can ask a question. The best place to
513:25 - do so will be on the course GitHub, which will be at the discussions page, which is linked here.
513:32 - If we load this up, there's nothing here yet, because as I record these videos, the course
513:36 - hasn't launched yet, but press new discussion. Talk about what you've got. Problem with XYZ.
513:42 - Let's go ahead. Leave a video number here and a timestamp, and that way, we'll be able to help
513:48 - you out as best as possible. So video number, timestamp, and then your question here, and you
513:54 - can select Q&A. Finally, don't forget that this notebook that we're about to go through is based
514:01 - on chapter two of the Zero to Mastery Learn PyTorch for deep learning, which is neural network
514:05 - classification with PyTorch. All of the text-based code that we're about to write is here. That
514:11 - was a little spoiler. And don't forget, this is the home page. So my GitHub repo slash PyTorch
514:17 - deep learning for all of the course materials, everything you need will be here. So that's very
514:23 - important. How can you get help? But this is the number one. Follow along with the code and try
514:28 - to write it yourself. Well, with that being said, when we're talking about classification,
514:32 - what is a classification problem? Now, as I said, classification is one of the main problems of
514:38 - machine learning. So you probably already deal with classification problems or machine learning
514:43 - powered classification problems every day. So let's have a look at some examples. Is this email
514:50 - spam or not spam? Did you check your emails this morning or last night or whenever? So chances are
514:57 - that there was some sort of machine learning model behind the scenes. It may have been a neural
515:00 - network. It may have not that decided that some of your emails won't spam. So to Daniel,
515:07 - at mrdberg.com, hey, Daniel, this steep learning course is incredible. I can't wait to use what
515:11 - I've learned. Oh, that's such a nice message. If you want to send that email directly to me,
515:15 - you can. That's my actual email address. But if you want to send me this email, well, hopefully
515:21 - my email, which is hosted by some email service detects this as spam because although that is a
515:27 - lot of money and it would be very nice, I think if someone can't spell too well, are they really
515:32 - going to pay me this much money? So thank you email provider for classifying this as spam. And now
515:37 - because this is one thing or another, not spam or spam, this is binary classification. So in this
515:44 - case, it might be one here and this is a zero or zero or one. So one thing or another, that's binary
515:51 - classification. If you can split it into one thing or another, binary classification. And then we
515:57 - have an example of say we had the question, we asked our photos app on our smartphone or whatever
516:04 - device you're using. Is this photo of sushi steak or pizza? We wanted to search our photos for every
516:10 - time we've eaten sushi or every time we've eaten steak or every time we've eaten pizza far out
516:15 - and this looks delicious. But this is multi class classification. Now, why is this? Because we've
516:21 - got more than two things. We've got 123. And now this could be 10 different foods. It could be 100
516:27 - different foods. It could be 1000 different categories. So the image net data set, which is a popular
516:33 - data set for computer vision, image net, we go to here, does it say 1000 anywhere, 1k or 1000?
516:43 - No, it doesn't. But if we go image net 1k, download image net data, maybe it's here.
516:50 - It won't say it, but you just, oh, there we go, 1000 object classes. So this is multi class
516:58 - classification because it has 1000 classes, that's a lot, right? So that's multi class classification,
517:05 - more than one thing or another. And finally, we might have multi label classification,
517:13 - which is what tags should this article have when I first got into machine learning, I got these
517:17 - two mixed up a whole bunch of times. Multi class classification has multiple classes such as sushi
517:22 - steak pizza, but assigns one label to each. So this photo would be sushi in an ideal world. This is
517:28 - steak and this is pizza. So one label to each. Whereas multi label classification means you could
517:35 - have multiple different classes. But each of your target samples such as this Wikipedia article,
517:41 - what tags should this article have? It may have more than one label. It might have three labels,
517:47 - it might have 10 labels. In fact, what if we went to the Wikipedia page for deep learning Wikipedia
517:54 - and does it have any labels? Oh, there we go. Where was that? I mean, you can try this yourself.
518:01 - This is just the Wikipedia page for deep learning. There is a lot, there we go categories deep
518:05 - learning, artificial neural networks, artificial intelligence and emerging technologies. So that
518:10 - is an example. If we wanted to build a machine learning model to say, read all of the text in
518:15 - here and then go tell me what are the most relevant categories to this article? It might come up
518:21 - with something like these. In this case, because it has one, two, three, four, it has multiple labels
518:26 - rather than just one label of deep learning, it could be multi label classification. So we'll go
518:33 - back. But there's a few more. These will get you quite far in the world of classification.
518:38 - So let's dig a little deeper on binary versus multi class classification. You may have already
518:45 - experienced this. So in my case, if I search on my phone in the photos app for photos of a dog,
518:52 - it might come here. If I search for photos of a cat, it might come up with this. But if I wanted
518:56 - to train an algorithm to detect the difference between photos of these are my two dogs.
519:01 - Aren't they cute? They're nice and tired and they're sleeping like a person. This is seven.
519:06 - Number seven, that's her name. And this is Bella. This is a cat that me and my partner rescued.
519:11 - And so I'm not sure what this cat's name is actually. So I'd love to give it a name, but I can't.
519:16 - So binary classification, if we wanted to build an algorithm, we wanted to feed it, say, 10,000
519:22 - photos of dogs and 10,000 photos of cats. And then we wanted to find a random image on the
519:27 - internet and pass it through to our model and say, hey, is this a dog or is this a cat? It would
519:32 - be binary classification because the options are one thing or another dog or cat. But then for
519:39 - multi-class classification, let's say we've been working on a farm and we've been taking some photos
519:44 - of chickens because they groovy, right? Well, we updated our model and added some chicken photos
519:49 - in there. We would now be working with a multi-class classification problem because we've got more
519:54 - than one thing or another. So let's jump in to what we're going to cover. This is broadly,
520:01 - by the way, because this is just text on a page. You know, I like to just write code of what we're
520:06 - actually doing. So we're going to look at the architecture of a neural network classification
520:10 - model. We're going to check what the input shapes and output shapes of a classification model are
520:15 - features and labels. In other words, because remember, machine learning models, neural networks
520:20 - love to have numerical inputs. And those numerical inputs often come in tenses. Tenses have different
520:27 - shapes, depending on what data you're working with. We're going to see all of this in code, creating
520:32 - custom data to view, fit and predict on. We're going to go back through our steps in modeling.
520:36 - We covered this a fair bit in the previous section, but creating a model for neural network classification.
520:41 - It's a little bit different to what we've done, but not too out landishly different. We're going to
520:45 - see how we can set up a loss function and an optimizer for a classification model. We'll
520:50 - recreate a training loop and a evaluating loop or a testing loop. We'll see how we can save and
520:56 - load our models. We'll harness the power of nonlinearity. Well, what does that even mean? Well,
521:01 - if you think of what a linear line is, what is that? It's a straight line. So you might be
521:07 - able to guess what a nonlinear line looks like. And then we'll look at different classification
521:12 - evaluation methods. So ways that we can evaluate our classification models. And how are we going
521:17 - to do all of this? Well, of course, we're going to be part cook, part chemist, part artist, part
521:24 - science. But for me, I personally prefer the cook side of things because we're going to be cooking
521:30 - up lots of code. So in the next video, before we get into coding, let's do a little bit more on
521:36 - what are some classification inputs and outputs. I'll see you there. Welcome back. In the last
521:44 - video, we had a little bit of a brief overview of what a classification problem is. But now,
521:48 - let's start to get more hands on by discussing what the actual inputs to a classification problem
521:53 - look like and the outputs look like. And so let's say we had our beautiful food photos from before,
521:59 - and we were trying to build this app here called maybe food vision to understand what
522:04 - foods are in the photos that we take. And so what might this look like? Well, let's break it down
522:13 - to inputs, some kind of machine learning algorithm, and then outputs. In this case,
522:18 - the inputs we want to numerically represent these images in some way, shape or form. Then we want
522:24 - to build a machine learning algorithm. Hey, one might actually exist. We're going to see this later
522:29 - on in the transfer learning section for our problem. And then we want some sort of outputs. And in
522:33 - the case of food vision, we want to know, okay, this is a photo of sushi. And this is a photo of
522:39 - steak. And this is a photo of pizza. You could get more hands on and technical and complicated, but
522:46 - we're just going to stick with single label multi class classification. So it could be a sushi photo,
522:52 - it could be a steak photo, or it could be a pizza photo. So how might we numerically represent
522:58 - these photos? Well, let's just say we had a function in our app that every photo that gets taken
523:05 - automatically gets resized into a square into 224 width and 224 height. This is actually quite a
523:11 - common dimensionality for computer vision problems. And so we've got the width dimension, we've got
523:18 - the height, and then we've got this C here, which isn't immediately recognizable. But in the case
523:23 - of pictures, they often get represented by width, height color channels. And the color channels is
523:29 - red, green and blue, which is each pixel in this image has some value of red, green or blue, that
523:37 - makes whatever color is displayed here. And this is one way that we can numerically represent an
523:43 - image by taking its width, its height and color channels, and whatever number makes up this
523:50 - particular image. We're going to see this later on when we work with computer vision problems.
523:55 - So we create a numerical encoding, which is the pixel values here. Then we import the pixel values
524:01 - of each of these images into a machine learning algorithm, which is often already exists. And if
524:07 - it doesn't exist for our particular problem, hey, well, we're learning the skills to build them now,
524:12 - we could use pytorch to build a machine learning algorithm for this. And then outputs, what might
524:17 - these look like? Well, in this case, these are prediction probabilities, which the outputs of
524:23 - machine learning models are never actually discrete, which means it is definitely pizza.
524:28 - It will give some sort of probability value between zero and one for say the closer to one,
524:35 - the more confident our model is that it's going to be pizza. And the closer to zero is means that,
524:42 - hey, this photo of pizza, let's say this one, and we're trying to predict sushi. Well,
524:48 - it doesn't think that it's sushi. So it's giving it quite a low value here. And then the same for
524:53 - steak, but it's really high, the value here for pizza. We're going to see this hands on. And then
524:58 - it's the opposite here. So it might have got this one wrong. But with more training and more data,
525:03 - we could probably improve this prediction. That's the whole idea of machine learning,
525:07 - is that if you adjust the algorithm, if you adjust the data, you can improve your predictions. And so
525:16 - the ideal outputs that we have here, this is what our models going to output. But for our case of
525:22 - building out food vision, we want to bring them back to. So we could just put all of these numbers
525:28 - on the screen here, but that's not really going to help people. We want to put out labels of what's
525:33 - going on here. So we can write code to transfer these prediction probabilities into these labels
525:39 - too. And so how did these labels come about? How do these predictions come about? Well,
525:44 - it comes from looking at lots of different samples. So this loop, we could keep going,
525:48 - improve these, find the ones where it's wrong, add more images here, train the model again,
525:54 - and then make our app better. And so if we want to look at this from a shape perspective,
526:01 - we want to create some tenses for an image classification example. So we're building food vision.
526:08 - We've got an image again, this is just reiterating on some of the things that we've discussed.
526:12 - We've got a width of 224 and a height of 224. This could be different. This could be 300, 300.
526:17 - This could be whatever values that you decide to use. Then we numerically encoded in some way,
526:23 - shape or form. We use this as the inputs to our machine learning algorithm, because of what?
526:27 - Computers and machine learning algorithms, they love numbers. They can find patterns in here
526:31 - that we couldn't necessarily find. Or maybe we could, if you had a long enough time,
526:35 - but I'd rather write an algorithm to do it for me. Then it has some outputs,
526:39 - which comes in the formal prediction probabilities, the closer to one, the more confident model is
526:44 - and saying, hey, I'm pretty damn confident that this is a photo of sushi. I don't think it's a
526:49 - photo of steak. So I'm giving that zero. It might be a photo of pizza, but I don't really think so.
526:55 - So I'm giving it quite a low prediction probability. And so if we have a look at what the shapes are
527:01 - for our tenses here, if this doesn't make sense, don't worry. We're going to see the code to do
527:05 - all of this later on. But for now, we're just focusing on a classification input and output.
527:11 - The big takeaway from here is numerical encoding, outputs and numerical encoding. But we want to
527:17 - change these numerical codings from the outputs to something that we understand, say the word sushi.
527:22 - But this tensor may be batch size. We haven't seen what batch size is. That's all right. We're
527:28 - going to cover it. Color channels with height. So this is represented as a tensor of dimensions.
527:33 - It could be none here. None is a typical value for a batch size, which means it's blank. So when
527:38 - we use our model and we train it, all the code that we write with pytorch will fill in this behind
527:43 - the scenes. And then we have three here, which is color channels. And we have 224, which is the width.
527:50 - And we have 224 as well, which is the height. Now there is some debate in the field on the ordering.
527:55 - We're using an image as our particular example here on the ordering of these shapes. So say,
528:01 - for example, you might have height width color channels, typically width and height come together
528:06 - in this order. Or they're just side by side in the tensor in terms of their whether dimension
528:10 - appears. But color channels sometimes comes first. That means after the batch size or at the end here.
528:17 - But pytorch, the default for now is color channels with height, though you can write code to change
528:22 - this order because tenses are quite flexible. And so or the shape could be 32 for the batch size,
528:30 - three, two, two, four, two, two, four, because 32 is a very common batch size. And you don't believe me?
528:35 - Well, let's go here. Yarn LeCoon 32 batch size. Now what is a batch size? Great tweet. Just keep
528:46 - this in mind for later on. Training with large mini batches is bad for your health. More importantly,
528:51 - it's bad for your test error. Friends don't let friends use mini batches larger than 32. So this
528:55 - is quite an old tweet. However, it still stands quite true. Because like today, it's 2022 when
529:03 - I'm recording these videos, there are batch sizes a lot larger than 32. But 32 works pretty darn
529:08 - well for a lot of problems. And so this means that if we go back to our slide, that if we use
529:16 - a batch size of 32, our machine learning algorithm looks at 32 images at a time. Now why does it do
529:22 - this? Well, because sadly, our computers don't have infinite compute power. In an ideal world,
529:27 - we look at thousands of images at a time, but it turns out that using a multiple of eight here
529:32 - is actually quite efficient. And so if we have a look at the output shape here, why is it three?
529:39 - Well, because we're working with three different classes, one, two, three. So we've got shape equals
529:45 - three. Now, of course, as you could imagine, these might change depending on the problem you're working
529:52 - with. So say if we just wanted to predict if a photo was a cat or a dog, we still might have this
529:58 - same representation here because this is the image representation. However, the shape here
530:03 - may be two, or will be two because it's cat or dog, rather than three classes here, but a little
530:09 - bit confusing as well with binary classification, you could have the shape just being one here.
530:13 - But we're going to see this all hands on. Just remember, the shapes vary with whatever problem
530:19 - you're working on. The principle of encoding your data as a numerical representation stays the same
530:26 - for the inputs. And the outputs will often be some form of prediction probability based on whatever
530:33 - class you're working with. So in the next video, right before we get into coding, let's just discuss
530:39 - the high level architecture of a classification model. And remember, architecture is just like
530:45 - the schematic of what a neural network is. I'll see you there. Welcome back. In the last video,
530:52 - we saw some example classification inputs and outputs. The main takeaway that the inputs to a
530:58 - classification model, particularly a neural network, want to be some form of numerical
531:02 - representation. And the outputs are often some form of prediction probability. So let's discuss
531:09 - the typical architecture of a classification model. And hey, this is just going to be text
531:13 - on a page, but we're going to be building a fair few of these. So we've got some hyper parameters
531:19 - over here. We've got binary classification. And we've got multi class classification. Now,
531:26 - there are some similarities between the two in terms of what problem we're working with.
531:30 - But there also are some differences here. And by the way, this has all come from, if we go
531:36 - to the book version of the course, we've got what is a classification problem. And we've got
531:41 - architecture of a classification neural network. So all of this text is available at learnpytorch.io
531:47 - and in section two. So we come back. So the input layer shape, which is typically
531:53 - decided by the parameter in features, as you can see here, is the same of number of features.
531:59 - So if we were working on a problem, such as we brought it to predict whether someone had
532:04 - heart disease or not, we might have five input features, such as one for age, a number for age,
532:09 - it might be in my case, 28, sex could be male, height, 180 centimeters. If I've been growing
532:16 - overnight, it's really close to 177. Wait, well, it depends on how much I've eaten, but it's around
532:21 - about 75 kilos and smoking status, which is zero. So it could be zero or one, because remember,
532:27 - we want numerical representation. So for sex, it could be zero for males, one for female,
532:33 - height could be its number, weight could be its number as well. All of these numbers could be
532:37 - more, could be less as well. So this is really flexible. And it's a hyper parameter. Why? Because
532:43 - we decide the values for each of these. So in the case of our image prediction problem,
532:48 - we could have in features equals three for number of color channels. And then we go
532:54 - hidden layers. So there's the blue circle here. I forgot that this was all timed and colorful.
532:59 - But let's just discuss hidden layers. Each of these is a layer and n dot linear and n dot linear
533:05 - and n dot relu and n dot linear. So that's the kind of the syntax you'll see in PyTorch for a
533:11 - layer is nn dot something. Now, there are many different types of layers in this in PyTorch.
533:15 - If we go torch and n, basically everything in here is a layer in a neural network. And then if we
533:22 - look up what a neural network looks like, neural network, recall that all of these are different
533:30 - layers of some kind of mathematical operation. Input layer, hidden layer, you could have as
533:37 - many hidden layers as you want. Do we have ResNet architecture? The ResNet architecture,
533:44 - some of them have 50 layers. Look at this. Each one of these is a layer. And this is only the
533:50 - 34 layer version. I mean, there's ResNet 152, which is 152 layers. We're not at that yet.
533:56 - But we're working up the tools to get to that stage. Let's come back to here. The neurons per
534:02 - hidden layer. So we've got these, out features, the green circle, the green square. Now, this is,
534:09 - if we go back to our neural network picture, this is these. Each one of these little things
534:17 - is a neuron, some sort of parameter. So if we had 100, what would that look like? Well,
534:24 - we'd have a fairly big graphic. So this is why I like to teach with code because you could customize
534:30 - this as flexible as you want. So behind the scenes, PyTorch is going to create 100 of these little
534:35 - circles for us. And within each circle is what? Some sort of mathematical operation.
534:41 - So if we come back, what do we got next? Output layer shape. So this is how many output features
534:45 - we have. So in the case of binary classification is one, one class or the other. We're going to
534:50 - see this later on. Multi-class classification is you might have three output features,
534:56 - one per class, e.g., one for food, person or dog, if you're building a food, person or dog,
535:02 - image classification model. Hidden layer activation, which is, we haven't seen these yet.
535:08 - Relu, which is a rectified linear unit, but can be many others because PyTorch, of course, has what?
535:15 - Has a lot of non-linear activations. We're going to see this later on. Remember, I'm kind of planting
535:19 - the seed here. We've seen what a linear line is, but I want you to imagine what a non-linear line is.
535:25 - It's going to be a bit of a superpower for our classification problem. What else do we have?
535:30 - Output activation. We haven't got that here, but we'll also see this later on, which could be
535:35 - sigmoid for, which is generally sigmoid for binary classification, but softmax for multi-class
535:41 - classification. A lot of these things are just names on a page. We haven't seen them yet.
535:45 - I like to teach them as we see them, but this is just a general overview of what we're going to
535:49 - cover. Loss function. What loss function or what does a loss function do? It measures how
535:55 - wrong our model's predictions are compared to what the ideal predictions are. So for binary
536:00 - classification, we might use binary cross entropy loss in PyTorch, and for multi-class
536:06 - classification, we might just use cross entropy rather than binary cross entropy. Get it?
536:12 - Binary classification? Binary cross entropy? And then optimizer. SGD is stochastic gradient descent.
536:18 - We've seen that one before. Another common option is the atom optimizer, and of course,
536:24 - the torch.optim package has plenty more options. So this is an example multi-class classification
536:32 - problem. This network here. Why is that? And we haven't actually seen an end up sequential,
536:37 - but as you could imagine, sequential stands for it just goes through each of these steps.
536:42 - So multi-class classification, because it has three output features, more than one thing or
536:47 - another. So three for food, person or dog, but going back to our food vision problem,
536:53 - we could have the input as sushi, steak, or pizza. So we've got three output features,
537:00 - which would be one prediction probability per class of image. We have three classes, sushi,
537:06 - steak, or pizza. Now, I think we've done enough talking here, and enough just pointing to text
537:13 - on slides. How about in the next video? Let's code. I'll see you in Google CoLab.
537:22 - Welcome back. Now, we've done enough theory of what a classification problem is, what the inputs
537:28 - and outputs are and the typical architecture. Let's get in and write some code. So I'm going to
537:33 - get out of this, and going to go to colab.research.google.com, so we can start writing some PyTorch code.
537:42 - I'm going to click new notebook. We're going to start exactly from scratch. I'm going to name this
537:48 - section two, and let's call it neural network classification with PyTorch. I'm going to put
537:58 - underscore video, because I'll just show you, you'll see this in the GitHub repo. But for all the
538:04 - video notebooks, the ones that I write code during these videos that you're watching, the exact code
538:09 - is going to be saved on the GitHub repo under video notebooks. So there's 00, which is the
538:14 - fundamentals, and there's the workflow underscore video. But the reference notebook with all the
538:19 - pretty pictures and stuff is in the main folder here. So PyTorch classification that I pi and b
538:26 - are actually, maybe we'll just rename it that PyTorch classification. But we know it's with
538:32 - neural networks. PyTorch classification. Okay, and let's go here. We'll add a nice title. So O2,
538:40 - neural network classification with PyTorch. And so we'll remind ourselves, classification is a
538:49 - problem of predicting whether something is one thing or another. And there can be multiple
539:02 - things as the options, such as email, spam or not spam, photos of dogs or cats or pizza or
539:09 - sushi or steak. Lots of talk about food. And then I'm just going to link in here, this resource,
539:19 - because this is the book version of the course. These are what the videos are based off. So book
539:25 - version of this notebook. And then all the resources are in here. All other resources
539:34 - in the GitHub, and then stuck. Ask a question here, which is under the discussions tab. We'll
539:46 - copy that in here. That way we've got everything linked and ready to go. But as always, what's our
539:51 - first step in our workflow? This is a little test. See if you remember. Well, it's data, of course,
539:58 - because all machine learning problems start with some form of data. We can't write a machine
540:03 - learning algorithm to learn patterns and data that doesn't exist. So let's do this video. We're
540:09 - going to make some data. Of course, you might start with some of your own that exists. But for now,
540:14 - we're going to focus on just the concepts around the workflow. So we're going to make our own
540:18 - custom data set. And to do so, I'll write the code first, and then I'll show you where I get it from.
540:24 - We're going to import the scikit loan library. One of the beautiful things about Google Colab
540:29 - is that it has scikit loan available. You're not sure what scikit loan is. It's a very popular
540:36 - machine learning library. PyTorch is mainly focused on deep learning, but scikit loan is
540:42 - focused on a lot of things around machine learning. So Google Colab, thank you for having scikit
540:47 - loan already installed for us. But we're going to import the make circles data set. And rather
540:53 - than talk about what it does, let's see what it does. So make 1000 samples. We're going to go N
541:00 - samples equals 1000. And we're going to create circles. You might be wondering why circles. Well,
541:10 - we're going to see exactly why circles later on. So X and Y, we're going to use this variable.
541:16 - How would you say nomenclature as capital X and Y. Why is that? Because X is typically a matrix
541:23 - features and labels. So let's go here. Mate circles. And we're going to make N samples. So 1000 different
541:32 - samples. We're going to add some noise in there. Just put a little bit of randomness. Why not?
541:36 - You can increase this as you want. I found that 0.03 is fairly good for what we're doing. And
541:42 - then we're going to also pass in the random state variable, which is equivalent to sitting a random
541:46 - or setting a random seed. So we're flavoring the randomness here. Wonderful. So now let's
541:53 - have a look at the length of X, which should be what? And length of Y. Oh, we don't have Y
542:00 - underscore getting a bit trigger happy with this keyboard here. 1000. So we have 1000 samples of
542:07 - X caught with 1000 or paired with 1000 samples of Y features labels. So let's have a look at the
542:14 - first five of X. So print first five samples of X. And then we'll put in here X. And we can index
542:24 - on this five because we're adhering to the data, explorer's motto of visualize visualize visualize
542:34 - first five samples of Y. And then we're going to go why same thing here.
542:39 - Wonderful. Let's have a look. Maybe we'll get a new line in here. Just so
542:50 - looks a bit better. Wonderful. So numerical. Our samples are already numerical. This is one of
542:57 - the reasons why we're creating our own data set. We'll see later on how we get non numerical data
543:01 - into numbers. But for now, our data is numerical, which means we can learn it with our model or
543:07 - we can build a model to learn patterns in here. So this sample has the label of one. And this
543:14 - sample has the label of one as well. Now, how many features do we have per sample? If I highlight
543:19 - this line, how many features is this? It would make it a bit easier if there was a comma here,
543:26 - but we have two features of X, which relates to one label of Y. And so far, we've only seen,
543:33 - let's have a look at all of Y. We've got zero on one. So we've got two classes. What does this
543:39 - mean? Zero or one? One thing or another? Well, it looks like binary classification to me,
543:46 - because we've got only zero or only one. If there was zero, one, two, it would be
543:53 - multi class classification, because we have more than two things. So let's X out of this.
543:57 - Let's keep going and do a little bit more data exploration. So how about we make a data frame?
544:03 - With pandas of circle data. There is truly no real definite way of how to explore data.
544:11 - For me, I like to visualize it multiple different ways, or even look at random samples. In the case
544:17 - of large data sets, such as images or text or whatnot. If you have 10 million samples, perhaps
544:26 - visualizing them one by one is not the best way to do so. So random can help you out there.
544:34 - So we're going to create a data frame, and we can insert a dictionary here. So I'm going to call
544:39 - the features in this part of X, X1, and these are going to be X2. So let's say I'll write some code
544:47 - to index on this. So everything in the zero index will be X1. And everything in the first index,
544:59 - there we go, will be X2. Let me clean up this code. This should be on different lines,
545:05 - enter. And then we've got, let's put in the label as Y. So this is just a dictionary here.
545:15 - So X1 key to X0. X2, a little bit confusing because of zero indexing, but X feature one,
545:22 - X feature two, and the label is Y. Let's see what this looks like. We'll look at the first 10 samples.
545:29 - Okay, beautiful. So we've got X1, some numerical value, X2, another numerical value, correlates
545:36 - to or matches up with label zero. But then this one, 0442208, and negative that number matches up
545:46 - with label zero. So I can't tell what the patterns are just looking at these numbers. You might be
545:52 - able to, but I definitely can't. We've got some ones. All these numbers look the same to me. So
545:57 - what can we do next? Well, how about we visualize, visualize, visualize, and instead of just numbers
546:04 - in a table, let's get graphical this time, visualize, visualize, visualize. So we're going to bring in
546:11 - our friendly mapplotlib, import mapplotlib, which is a very powerful plotting library. I'm just
546:19 - going to add some cells here. So we've got some space, mapplotlib.pyplot as PLT. That's right.
546:28 - We've got this plot.scatter. We're going to do a scatterplot equals X. And we want the first index.
546:35 - And then Y is going to be X as well. So that's going to appear on the Y axis. And then we want to
546:43 - color it with labels. We're going to see what this looks like in a second. And then the color map,
546:49 - C map stands for color map is going to be plot dot color map PLT. And then red, yellow, blue,
546:56 - one of my favorite color outputs. So let's see what this looks like. You ready?
547:03 - Ah, there we go. There's our circles. That's a lot better for me. So what do you think we're
547:10 - going to try and do here? If this is our data and we're working on classification,
547:16 - we're trying to predict if something is one thing or another. So our problem is we want to
547:22 - try and separate these two circles. So say given a number here or given two numbers and X one
547:29 - and an X two, which are coordinates here, we want to predict the label. Is it going to be a blue
547:34 - dot or is it going to be a red dot? So we're working with binary classification. So we have
547:40 - one thing or another. Do we have a blue dot or a red dot? So this is going to be our toy data here.
547:46 - And a toy problem is, let me just write this down. This is a common thing that you'll also
547:50 - hear in machine learning. Note, the data we're working with is often referred to as a toy data set,
548:02 - a data set that is small enough to experiment on, but still sizable enough to practice the
548:15 - fundamentals. And that's what we're really after in this notebook is to practice the fundamentals
548:20 - of neural network classification. So we've got a perfect data set to do this. And by the way,
548:27 - we've got this from scikit-learn. So this little function here made all of these samples for us.
548:32 - And how could you find out more about this function here? Well, you could go scikit-learn
548:39 - classification data sets. There are actually a few more in here that we could have done.
548:43 - I just like the circle one. Toy data sets, we saw that. So this is like a toy box of different
548:49 - data sets. So if you'd like to learn more about some data sets that you can have a look in here
548:54 - and potentially practice on with neural networks or other forms of machine learning models from
548:59 - scikit-learn, check out this scikit-learn. I can't speak highly enough. I know this is a pie-torch
549:04 - course. We're not focused on this, but they kind of all come together in terms of the machine
549:08 - learning and deep learning world. You might use something from scikit-learn, like we've done here,
549:12 - to practice something. And then you might use pie-torch for something else, like what we're
549:17 - doing here. Now, with that being said, what are the input and output shapes of our problem?
549:25 - Have a think about that. And also have a think about how we'd split this into training and test.
549:31 - So give those a go. We covered those concepts in some previous videos,
549:36 - but we'll do them together in the next video. I'll see you there.
549:39 - Welcome back. In the last video, we made some classification data so that we can
549:46 - practice building a neural network in pie-torch to separate the blue dots from the red dots.
549:52 - So let's keep pushing forward on that. And I'll just clean up here a little bit,
549:56 - but where are we in our workflow? What have we done so far? Well, we've got our data ready a
550:02 - little bit. We haven't turned it into tenses. So let's do that in this video, and then we'll
550:06 - keep pushing through all of these. So in here, I'm going to make this heading 1.1. Check input
550:14 - and output shapes. The reason we're focused a lot on input and output shapes is why,
550:20 - because machine learning deals a lot with numerical representations as tenses. And input and output
550:27 - shapes are some of the most common errors, like if you have a mismatch between your input and
550:32 - output shapes of a certain layer of an output layer, you're going to run into a lot of errors
550:36 - there. So that's why it's good to get acquainted with whatever data you're using, what are the
550:42 - input shapes and what are the output shapes you'd like. So in our case, we can go x dot shape
550:50 - and y dot shape. So we're working with NumPy arrays here if we just look at x. That's what the
550:56 - make circles function is created for us. We've got an array, but as our workflow says,
551:02 - we'd like it in tenses. If we're working with PyTorch, we want our data to be represented as
551:06 - PyTorch tenses of that data type. And so we've got a shape here, we've got a thousand samples,
551:13 - and x has two features, and y has no features. It's just a single number. It's a scalar. So it
551:19 - doesn't have a shape here. So there's a thousand samples of y, thousand samples of x, two samples
551:23 - of x equals one y label. Now, if you're working with a larger problem, you might have a thousand
551:30 - samples of x, but x is represented by 128 different numbers, or 200 numbers, or as high as you want,
551:38 - or just 10 or something like that. So just keep in mind that this number is quite flexible of how
551:44 - many features represent a label. Why is the label here? But let's keep going. So view the first
551:52 - example of features and labels. So let's make it explicit with what we've just been discussing.
552:01 - We'll write some code to do so. We'll get the first sample of x, which is the zero index,
552:06 - and we'll get the first sample of y, which is also the zero index. We could get really anyone
552:13 - because they're all of the same shape. But print values for one sample of x. What does this equal?
552:22 - X sample, and the same for y, which is y sample. And then we want to go print f string for one
552:34 - sample of x. We'll get the shape here. X sample dot shape, and the same for y, and then we'll get
552:45 - y sample dot shape. Beautiful. What's this going to do? Well, we've got one sample of x. So this
552:53 - sample here of these numbers, we've got a lot going on here. 75424625 and 0231 48074. I mean,
553:02 - you can try to find some patterns in those. If you do, all the best here, and the same for y. So this
553:07 - is, we have the y sample, this correlates to a number one, a label of one. And then we have
553:14 - shapes for one sample of x, which is two. So we have two features for y. It's a little bit confusing
553:20 - here because y is a scalar, which doesn't actually have a shape. It's just one value. So for me,
553:26 - in terms of speaking this, teaching it out loud, we'll be two features of x trying to predict
553:31 - one number for y. And so let's now create another heading, which is 1.2. Let's get our data into
553:39 - tenses, turn data into tenses. We have to convert them from NumPy. And we also want to create
553:46 - train and test splits. Now, even though we're working with a toy data set here, the principle
553:51 - of turning data into tenses and creating train and test splits will stay around for almost any
553:57 - data set that you're working with. So let's see how we can do that. So we want to turn data
554:02 - into tenses. And for this, we need to import torch, get pytorch and we'll check the torch version.
554:11 - It has to be at least 1.10. And I might just put this down in the next cell. Just make sure we can
554:20 - import pytorch. There we go, 1.10 plus CUDA 111. If your version is higher than that, that is okay.
554:27 - The code below should still work. And if it doesn't, let me know. So x equals torch dot
554:34 - from NumPy. Why are we doing this? Well, it's because x is a NumPy array. And if we go x dot,
554:42 - does it have a d type attribute float 64? Can we just go type or maybe type? Oh, there we go.
554:52 - NumPy and DRA. We can just go type x. NumPy and DRA. So we want it in a torch tensor. So we're
555:01 - going to go from NumPy. We saw this in the fundamental section. And then we're going to change it into
555:05 - type torch dot float. A float is an alias for float 32. We could type the same thing. These two are
555:12 - equivalent. I just going to type torch float for writing less code. And then we're going to go
555:19 - the same with why torch from NumPy. Now, why do we turn it into a torch float? Well, that's
555:24 - because if you recall, the default type of NumPy arrays is, if we go might just put out this in
555:33 - a comma x dot D type is float 64. There we go. However, pytorch, the default type is float 32.
555:41 - So we're changing it into pytorch's default type. Otherwise, if we didn't have this little
555:46 - section of code here dot type torch dot float, our tensors would be of float 64 as well. And that
555:51 - may cause errors later on. So we're just going for the default data type within pytorch. And so
555:58 - now let's have a look at the first five values of x and the first five values of y. What do we
556:04 - have? Beautiful. We have tensor data types here. And now if we check the data type of x and we
556:11 - check the data type of y, what do we have? And then one more, we'll just go type x. So we have
556:19 - our data into tensors. Wonderful. But now so it's torch dot tensor. Beautiful. But now we would like
556:27 - training and test sets. So let's go split data into training and test sets. And a very, very popular
556:38 - way to split data is a random split. So before I issued the challenge of how you would split this
556:45 - into a training and test set. So because these data points are kind of scattered all over the
556:50 - place, we could split them randomly. So let's see what that looks like. To do so, I'm going to
556:58 - use our faithful scikit learn again. Remember how I said scikit learn has a lot of beautiful methods
557:05 - and functions for a whole bunch of different machine learning purposes. Well, one of them is
557:09 - for a train test split. Oh my goodness, pytorch I didn't want auto correct there. Train test split.
557:16 - Now you might be able to guess what this does. These videos are going to be a battle between me and
557:20 - code labs auto correct. Sometimes it's good. Other times it's not. So we're going to set this code
557:26 - up. I'm going to write it or we're going to write it together. So we've got x train for our training
557:31 - features and X tests for our testing features. And then we also want our training labels and
557:36 - our testing labels. That order is the order that train test split works in. And then we have train
557:43 - test split. Now if we wrote this function and we wanted to find out more, I can press command
557:48 - ship space, which is what I just did to have this. But truly, I don't have a great time reading all
557:53 - of this. You might. But for me, I just like going train test split. And possibly one of the first
558:01 - functions that appears, yes, is scikit learn. How good is that? So scikit learn dot model selection
558:06 - dot train test split. Now split arrays or matrices into random train and test subsets. Beautiful.
558:13 - We've got a code example of what's going on here. You can read what the different parameters do.
558:19 - But we're going to see them in action. This is just another example of where machine learning
558:23 - libraries such as scikit learn, we've used matplotlib, we've used pandas, they all interact
558:29 - together to serve a great purpose. But now let's pass in our features and our labels.
558:35 - This is the order that they come in, by the way. Oh, and we have the returns splitting. So the
558:41 - order here, I've got the order goes x train x test y train y test took me a little while to
558:47 - remember this order. But once you've created enough training test splits with this function,
558:51 - you kind of know this off by heart. So just remember features first train first and then labels.
558:57 - And we jump back in here. So I'm going to put in the test size parameter of 0.2.
559:02 - This is percentage wise. So let me just write here 0.2 equals 20% of data will be test.
559:10 - And 80% will be train. If we wanted to do a 50 50 split, that kind of split doesn't usually
559:19 - happen, but you could go 0.5. But the test size says, hey, how big and percentage wise do you want
559:27 - your test data to be? And so behind the scenes train test split will calculate what's 20% of
559:33 - our x and y samples. So we'll see how many there is in a second. But let's also put a random state
559:39 - in here. Because if you recall back in the documentation, train test split splits data
559:45 - randomly into random train and test subsets. And random state, what does that do for us? Well,
559:52 - this is a random seed equivalent of very similar to torch dot manual seed. However, because we are
560:00 - using scikit learn, setting torch dot manual seed will only affect pytorch code rather than
560:07 - scikit learn code. So we do this so that we get similar random splits. As in, I get a similar
560:14 - random split to what your random split is. And in fact, they should be exactly the same. So let's
560:20 - run this. And then we'll check the length of x train. And length of x test. So if we have 1000
560:30 - total samples, and I know that because above in our make circles function, we said we want
560:35 - 1000 samples, that could be 10,000, that could be 100. That's the beauty of creating your own
560:40 - data set. And we have length y train. If we have 20% testing values, how many samples are going
560:47 - to be dedicated to the test sample, 20% of 1000 years, 200, and 80%, which is because training is
560:57 - going to be training here. So 100 minus 20% is 80%. So 80% of 1000 years, let's find out.
561:07 - Run all beautiful. So we have 800 training samples, 200 testing samples. This is going to be the
561:15 - data set that we're going to be working with. So in the next video, we've now got training and
561:20 - test sets, we've started to move through our beautiful pytorch workflow here. We've got our
561:26 - data ready, we've turned it into tenses, we've created a training and test split. Now it's time
561:30 - to build or pick a model. So I think we're still in the building phase. Let's do that in the next
561:36 - video. Welcome back. In the last video, we split our data into training and test sets. And because
561:45 - we did 80 20 split, we've got about 800 samples to train on, and 200 samples to test on. Remember,
561:51 - the training set is so that the model can learn patterns, patterns that represent this data set
561:59 - here, the circles data set, red dots or blue dots. And the test data set is so that we can
562:04 - evaluate those patterns. And I took a little break before, but you can tell that because my
562:10 - notebook is disconnected. But if I wanted to reconnect it, what could I do? We can go here,
562:15 - run time, run before that's going to run all of the cells before. It shouldn't take too long
562:19 - because we haven't done any large computations. But this is good timing because we're up to part
562:25 - two, building a model. And so there's a fair few steps here, but nothing that we haven't covered
562:32 - before, we're going to break it down. So let's build a model to classify our blue and red dots.
562:43 - And to do so, we want to tenses. I want to not tenses. That's all right. So let me just make
562:55 - some space here. There we go. So number one, let's set up device agnostic code. So we get in the
563:01 - habit of creating that. So our code will run on an accelerator. I can't even spell accelerator.
563:11 - It doesn't matter. You know what I mean? GPU. If there is one. Two. What should we do next?
563:20 - Well, we should construct a model. Because if we want to build a model, we need a model.
563:24 - Construct a model. And we're going to go by subclassing and then dot module.
563:31 - Now we saw this in the previous section, we subclassed and then module. In fact, all models
563:36 - in PyTorch subclass and end up module. And let's go define loss function and optimizer.
563:47 - And finally, good collabs auto correct is not ideal. And then we'll create a training
563:56 - and test loop. Though this will probably be in the next section. We'll focus on building a model
564:00 - here. And of course, all of these steps are in line with what they're in line with this.
564:05 - So we don't have device agnostic code here, but we're just going to do it enough so that we have
564:09 - a habit. These are the main steps. Pick or build a pre-trained model, suit your problem, pick a
564:13 - loss function and optimizer, build a training loop. So let's have a look. How can we start this off?
564:19 - So we will import PyTorch. And and then we've already done this, but we're going to do it anyway
564:26 - for completeness, just in case you wanted to run your code from here, import and then. And we're
564:34 - going to make device agnostic code. So we'll set the device equal to CUDA if torch dot CUDA
564:45 - is available else CPU, which will be the default. The CPU is the default. If there's no GPU,
564:53 - which means that CUDA is available, all of our PyTorch code will default to using the CPU
564:58 - device. Now we haven't set up a GPU yet so far. You may have, but as you see, my target device is
565:05 - currently CPU. How about we set up a GPU? We can go into here runtime change runtime type
565:11 - GPU. And I'm going to click save. Now this is going to restart the runtime and reconnect.
565:18 - So once it reconnects beautiful, we could actually just run this code cell here.
565:23 - This is going to set up the GPU device, but because we're only running this cell, if we were to just
565:29 - set up X train, we've not been defined. So because we restarted our runtime, let's run all or we can
565:37 - just run before. So this is going to rerun all of these cells here. And do we have X train now?
565:45 - Let's have a look. Wonderful. Yes, we do. Okay, beautiful. So we've got device agnostic code.
565:51 - In the next video, let's get on to constructing a model. I'll see you there.
565:58 - Welcome back. In the last video, we set up some device agnostic code. So this is going to come in
566:04 - later on when we send our model to the target device, and also our data to the target device.
566:09 - This is an important step because that way, if someone else was able to run your code or you
566:13 - were to run your code in the future, because we've set it up to be device agnostic,
566:17 - quite a fault it will run on the CPU. But if there's an accelerator present,
566:22 - well, that means that it might go faster because it's using a GPU rather than just using a CPU.
566:28 - So we're up to step two here construct a model by subclassing and in module. I think we're going to
566:33 - write a little bit of text here just to plan out the steps that we're doing. Now we've
566:38 - set up device agnostic code. Let's create a model that we're going to break it down. We've got some
566:48 - sub steps up here. We're going to break it down even this one down into some sub-sub steps. So number
566:55 - one is we're going to subclass and then got module. And a reminder here, I want to make some space,
567:04 - just so we're coding in about the middle of the page. So almost all models in pytorch,
567:11 - subclass, and then got module because there's some great things that it does for us behind the
567:17 - scenes. And step two is we're going to create two and then dot linear layers. And we want these
567:29 - that are capable to handle our data. So that are capable of handling the shapes of our data.
567:37 - Step three, we want to define or defines a forward method. Why do we want to define a forward method?
567:46 - Well, because we're subclassing an end dot module, right? And so the forward method defines a forward
567:52 - method that outlines the forward pass or forward computation of the model. And number four, we want
568:07 - to instantiate, well, this doesn't really have to be the part of creating it, but we're going to do
568:12 - anyway, and instantiate an instance of our model class and send it to the target device. So I'm
568:27 - going to be a couple of little different steps here, but nothing too dramatic that we haven't really
568:31 - covered before. So let's go number one, construct a model that subclasses an end dot module.
568:39 - So I'm going to code this all out. Well, we're going to code this all out together. And then we'll
568:44 - go back through and discuss it, and then maybe draw a few pictures or something to check out
568:49 - what's actually happening. So circle model V one, because we're going to try and split some circles,
568:56 - red and blue circles. This is our data up here. This is why it's called circle model, because we're
569:02 - trying to separate the blue and red circle using a neural network. So we've subclassed an end dot
569:09 - module. And when we create a class in Python, we'll create a constructor here, a net, and then
569:15 - put in super dot underscore a net. And then inside the constructor, we're going to create our
569:22 - layers. So this is number two, create two and then linear layers, capable of handling the shapes
569:27 - of our data. So I'm going to write this down here to create two, two, and then dot linear layers, capable
569:39 - of handling the shapes of our data. And so if we have a look at X train, what are the shapes here?
569:47 - What's the input shape? Because X train is our features, right? Now features are going to go
569:52 - into our model. So we have 800 training samples. This is the first number here of size two each.
570:01 - So 800 of these and inside each is two numbers. Again, depending on the data set you're working
570:07 - with, your features may be 100 in length, a vector of 100, or maybe a different size tensor all
570:13 - together, or there may be millions. It really depends on what data set you're working with.
570:18 - Because we're working with a simple data set, we're going to focus on that. But the principal
570:21 - is still the same. You need to define a neural network layer that is capable of handling your
570:27 - input features. So we're going to make layer one equals an n dot linear. And then if we wanted
570:33 - to find out what's going on an n n dot linear, we could run shift command space on my computer,
570:38 - because it's a Mac, maybe shift control space if you're on Windows. So we're going to define the
570:43 - n features. What would n features be here? Well, we just decided that our X has two features.
570:50 - So n features are going to be two. And now what is the out features? This one is a little bit tricky.
570:58 - So in our case, we could have out features equal to one if we wanted to just pass a single linear
571:04 - layer, but we want to create two linear layers here. So why would out features be one? Well,
571:10 - that's because if we have a look at the first sample of Y train, we would want us to input,
571:16 - or maybe we'll look at the first five. We want to map one sample of X to one sample of Y and Y
571:25 - has a shape of one. Oh, well, really, it's nothing because it's a scalar, but we would still put
571:29 - one here so that it outputs just one number. But we're going to change this up. We're going to put
571:34 - it into five and we're going to create a second layer. Now, this is an important point of joining
571:40 - together neural networks in features here. What do you think the in features of our second layer is
571:47 - going to be? If we've produced an out feature of five here, now this number is arbitrary. We could
571:52 - do 128. We could do 256. Generally, it's multiples of 8, 64. We're just doing five now because we're
572:00 - keeping it nice and simple. We could do eight multiples of eight is because of the efficiency
572:04 - of computing. I don't know enough about computer hardware to know exactly why that's the case,
572:09 - but that's just a rule of thumb in machine learning. So the in features here has to match up with the
572:14 - out features of a previous layer. Otherwise, we'll get shape mismatch errors. And so let's go here
572:20 - out features. So we're going to treat this as the output layer. So this is the out features equals
572:26 - one. So takes in two features and upscales to five features. So five numbers. So what this does,
572:35 - what this layer is going to do is take in these two numbers of X, perform an end up linear. Let's
572:41 - have a look at what equation it does. An end up linear is going to perform this function here
572:48 - on the inputs. And it's going to upscale it to five features. Now, why would we do that? Well,
572:56 - the rule of thumb here, because this is denoted as a hidden unit, or how many hidden neurons there
573:01 - are. The rule of thumb is that the more hidden features there are, the more opportunity our model
573:06 - has to learn patterns in the data. So to begin with, it only has two numbers to learn patterns on,
573:11 - but at when we upscale it to five, it has five numbers to learn patterns on. Now, you might think,
573:18 - why don't we just go straight to like 10,000 or something? But there is like an upper limit here
573:22 - to sort of where the benefits start to trail off. We're just using five because it keeps it nice
573:27 - and simple. And then the in features of the next layer is five, so that these two line up. We're
573:32 - going to map this out visually in a moment, but let's keep coding. We've got in features two for
573:37 - X. And now this is the output layer. So takes in five features from previous layer and outputs
573:46 - a single feature. And now this is same shape. Same shape as why. So what is our next step? We
573:55 - want to define a Ford method, a Ford computation of Ford pass. So the Ford method is going to
574:01 - define the Ford computation. And as an input, it's going to take X, which is some form of data.
574:07 - And now here's where we can use layer one and layer two. So now let's just go return.
574:14 - Or we'll put a note here of what we're doing. Three, we're going to go define a Ford method
574:19 - that outlines the Ford pass. So Ford, and we're going to return. And here's some notation we
574:28 - haven't quite seen yet. And then we're going to go self layer two. And inside the brackets we'll
574:34 - have self layer one inside those brackets. We're going to have X. So the way this goes is X goes
574:41 - into layer one. And then the output of layer one goes into layer two. So whatever data we have,
574:50 - so our training data, X train goes into layer one performs the linear calculation here. And then
574:58 - it goes into layer two. And then layer two is going to output, go to the output. So X is the input,
575:07 - layer one computation layer two output. So we've done that. Now let's do step four, which is
575:16 - instantiate an instance of our model class. And send it to the target device. So this is our model
575:27 - class, circle model V zero. We're just going to create a model because it's the first model we've
575:33 - created up this section. Let's call it model zero. And we're going to go circle model V one. And then
575:41 - we're going to go to two. And we're going to pass in device, because that's our target device.
575:47 - Let's now have a look at model zero. And then Oh, typo. Yeah, classic.
575:54 - What did we get wrong here? Oh, did we not pass in self self? Oh, there we go.
576:06 - Little typo classic. But the beautiful thing about creating a class here is that we could put
576:11 - this into a Python file, such as model dot pi. And then we wouldn't necessarily have to rewrite
576:16 - this all the time, we could just call it. And so let's just check what the vice it's on.
576:21 - So target device is CUDA, because we've got a GPU, thank you, Google Colab. And then if we wanted
576:27 - to, let's go next model zero dot parameters, we'll call the parameters, and then we'll go device.
576:38 - CUDA beautiful. So that means our models parameters are on the CUDA device. Now we've covered enough
576:44 - code in here for this video. So if you want to understand it a little bit more, go back through
576:49 - it. But we're going to come back in the next video and make it a little bit more visual. So I'll see
576:54 - you there. Welcome back. In the last video, we did something very, very exciting. We created our
577:02 - first multi layer neural network. But right now, this is just code on a page. But truly, this is
577:07 - what the majority of building machine learning models in PyTorch is going to look like. You're
577:12 - going to create some layers, or a simple or as complex as you like. And then you're going to
577:18 - use those layers in some form of Ford computation to create the forward pass. So let's make this a
577:26 - little bit more visual. If we go over to the TensorFlow playground, and now TensorFlow is another
577:32 - deep learning framework similar to PyTorch, it just allows you to write code such as this,
577:38 - to build neural networks, fit them to some sort of data to find patterns and data,
577:43 - and then use those machine learning models in your applications. But let's create this. Oh,
577:50 - by the way, this is playground.tensorFlow.org. This is a neural network that we can train in
577:55 - the browser if we really wanted to. So that's pretty darn cool. But we've got a data set here,
578:01 - which is kind of similar to the data set that we're working with. We have a look at our circles one.
578:07 - Let's just say it's close enough. It's circular. That's what we're after. But if we increase this,
578:12 - we've got five neurons now. We've got two features here, X1 and X2. Where is this
578:17 - reminding you of what's happening? There's a lot of things going on here that we haven't covered
578:21 - yet, but don't worry too much. We're just focused on this neural network here. So we've got some
578:25 - features as the input. We've got five hidden units. This is exactly what's going on with the model
578:31 - that we just built. We pass in X1 and X2, our values. So if we go back to our data set,
578:38 - these are X1 and X2. We pass those in. So we've got two input features. And then we pass them to a
578:46 - hidden layer, a single hidden layer, with five neurons. What have we just built? If we come down
578:52 - into here to our model, we've got in features two, out features five. And then that feeds into
578:59 - another layer, which has in features five and out features one. So this is the exact same model
579:05 - that we've built here. Now, if we just turn this back to linear activation, because we're sticking
579:10 - with linear for now, we'll have a look at different forms of activation functions later on. And maybe
579:15 - we put the learning rate, we've seen the learning rate to 0.01. We've got epochs here, got classification.
579:21 - And we're going to try and fit this neural network to this data. Let's see what happens.
579:25 - Oh, the test loss, it's sitting about halfway 0.5. So about 50% loss. So if we only have two
579:37 - classes and we've got a loss of 50%, what does that mean? Well, the perfect loss was zero.
579:44 - And the worst loss was one. Then we just divide one by two and get 50%. But we've only got two
579:50 - classes. So that means if our model was just randomly guessing, it would get a loss of about 0.5,
579:57 - because you could just randomly guess whatever data point belongs to blue or orange in this case.
580:02 - So in a binary classification problem, if you have the same number of samples in each class,
580:07 - in this case, blue dots and orange dots, randomly guessing will get you about 50%. Just like tossing
580:12 - a coin, toss a coin 100 times and you get about 50 50 might be a little bit different, but it's
580:18 - around about that over the long term. So we've just fit for 3000 epochs. And we're still not getting
580:24 - any better loss. Hmm. I wonder if that's going to be the case for our neural network. And so to
580:30 - draw this in a different way, I'm going to come to a little tool called fig jam, which is just a
580:35 - whiteboard that we can put shapes on and it's based on the browser. So this is going to be nothing
580:40 - fancy. It's going to be a simple diagram. Say this is our input. And I'm going to make this green
580:49 - because my favorite color is green. And then we're going to have, let's make some different
580:54 - colored dots. I want a blue dot here. So this can be dot one, and dot two, I'll put another dot
581:03 - here. I'll zoom out a little so we have a bit more space. Well, maybe that was too much. 50%
581:11 - looks all right. So let me just move this around, move these up a little. So we're building a neural
581:17 - network here. This is exactly what we just built. And so we'll go here. Well, maybe we'll put this
581:24 - as input X one. So this will make a little bit more sense. And then we'll maybe we can copy this.
581:29 - Now this is X two. And then we have some form of output. Let's make this one. And we're going to
581:39 - color this orange. So output. Right. So you can imagine how we got connected dots here.
581:48 - They will connect these. So our inputs are going to go through all of these. I wonder if I can
581:54 - draw here. Okay, this is going to be a little bit more complex, but that's all right. So this
581:59 - is what we've done. We've got two input features here. And if we wanted to keep drawing these,
582:04 - we could all of these input features are going to go through all of these hidden units that we
582:09 - have. I just drew the same arrow twice. That's okay. But this is what's happening in the forward
582:14 - computation method. It can be a little bit confusing for when we coded it out. Why is that? Well,
582:20 - from here, it looks like we've only got an input layer into a single hidden layer in the blue.
582:27 - And an output layer. But truly, this is the same exact shape. You get the point. And then all of
582:34 - these go to the output. But we're going to see this computationally later on. So whatever data set
582:40 - you're working with, you're going to have to manufacture some form of input layer. Now this
582:45 - may be you might have 10 of these if you have 10 features. Or four of them if you have four
582:51 - features. And then if you wanted to adjust these, well, you could increase the number of hidden
582:58 - units or the number of out features of a layer. What just has to match up is that the layer it's
583:03 - going into has to have a similar shape as the what's coming out of here. So just keep that in mind
583:09 - as you're going on. And in our case, we only have one output. So we have the output here,
583:15 - which is why. So this is a visual version. We've got the TensorFlow playground. You could play
583:20 - around with that. You can change this to increase. Maybe you want five hidden layers with five neurons
583:26 - in each. This is a fun way to explore. This is a challenge, actually, go to playground.tensorflow.org,
583:34 - replicate this network and see if it fits on this type of data. What do you think, will it?
583:39 - Well, we're going to have to find out in the next few videos. So I'm going to show you in the
583:43 - next video another way to create the network that we just created. This one here with even less
583:50 - code than what we've done before. I'll see you there. Welcome back. In the last video, what we
583:58 - discussed, well, actually, in the previous video to last, we coded up this neural network here,
584:02 - circle model V zero. By subclassing an end or module, we created two linear layers, which are
584:08 - capable of handling the shape of our data in features two because why we have two X features.
584:14 - Out features were upscaling the two features to five so that it gives our network more of a
584:19 - chance to learn. And then because we've upscaled it to five features, the next subsequent layer
584:24 - has to be able to handle five features as input. And then we have one output feature because that's
584:29 - the same shape as our Y here. Then we got a little bit visual by using the TensorFlow
584:34 - playground. Did you try out that challenge, make five in layers with five neurons? Did it work?
584:41 - And then we also got a little bit visual in Figma as well. This is just another way of
584:45 - visualizing different things. You might have to do this a fair few times when you first start
584:49 - with neural networks. But once you get a bit of practice, you can start to infer what's going on
584:55 - through just pure code. So now let's keep pushing forward. How about we replicate this
585:01 - with a simpler way? Because our network is quite simple, that means it only has two layers.
585:07 - That means we can use. Let's replicate the model above using nn.sequential. And I'm going to code
585:17 - this out. And then we can look up what nn.sequential is. But I think you'll be able to comprehend what's
585:22 - happening by just looking at it. So nn, which is torch.nn. We can do torch.nn, but we've already
585:29 - imported nn. We're going to call nn.sequential. And then we're going to go nn.linear. And what
585:37 - was the in features of our nn.linear? Well, it was two because we have two in features. And then
585:45 - we're going to replicate the same out features. Remember, we could customize this to whatever we
585:50 - want 10, 100, 128. I'm going to keep it at five, nice and simple. And then we go nn.linear. And
585:59 - the in features of this next layer is going to be five because the out features of the previous
586:03 - layer was five. And then finally, the out features here is going to be one because we want one y
586:09 - value to our two x features. And then I'm going to send that to the device. And then I'm going to
586:15 - have a look at model zero. So this is, of course, going to override our previous model zero. But
586:24 - have a look. The only thing different is that this is from the circle model V zero class. We
586:28 - subclassed an n dot module. And the only difference is the name here. This is just from sequential.
586:36 - And so can you see what's going on here? So as you might have guessed sequential,
586:43 - it implements most of this code for us behind the scenes. Because we've told it that it's going
586:49 - to be sequential, it's just going to go, hey, step the code through this layer, and then step
586:53 - the code through this layer. And outputs basically the same model, rather than us creating our own
587:00 - forward method, you might be thinking, Daniel, why don't you show us this earlier? That looks
587:04 - like such an easy way to create a neural network compared to this. Well, yes, you're 100% right.
587:10 - That is an easier way to create a neural network. However, the benefit of subclassing, and that's
587:17 - why I started from here, is that when you have more complex operations, such as things you'd
587:22 - like to construct in here, and a more complex forward pass, it's important to know how to
587:29 - build your own subclasses of nn dot module. But for simple straightforward stepping through
587:34 - each layer one by one, so this layer first, and then this layer, you can use nn dot sequential.
587:39 - In fact, we could move this code up into here. So we could do this self dot, we'll call this
587:49 - two linear layers equals nn dot sequential. And we could have layer one, we could go self,
588:01 - self dot layer one. And or actually, we'll just recode it, we'll go nn dot linear. So it's so
588:10 - it's the same code is what we've got below in features. If I could type that'll be great,
588:16 - n features equals two, out features equals five. And then we go nn dot linear. And then we go
588:24 - n features equals what equals five, because it has to line up out features equals one.
588:32 - And then we've got two linear layers. And then if we wanted to get rid of this, return
588:36 - to linear layers, and we'll pass it X remake it. There we go. Well, because we've created these as
588:48 - well, let's get rid of that. Beautiful. So that's the exact same model, but just using nn dot
588:55 - sequential. Now I'm going to get rid of this so that our code is not too verbose. That means a lot
589:00 - going on. But this is the flexibility of PyTorch. So just keep in mind that there's a fair few ways
589:08 - to make a model. The simplest is probably sequential. And then subclassing is this is a little bit
589:16 - more complicated than what we've got. But this can extend to handle lot more complex neural networks,
589:22 - which you'll likely have to be building later on. So let's keep pushing forward. Let's see what
589:28 - happens if we pass some data through here. So we'll just rerun this cell to make sure we've got
589:32 - our model zero instantiated. We'll make some predictions with the model. So of course, if we
589:38 - have a look at our model zero dot state deck, oh, this will be a good experiment. So look at this.
589:46 - So we have weight, a weight tensor, a bias tensor, a weight tensor, and a bias tensor. So this is
589:53 - for the first of the zeroth layer, these two here with the zero dot, and then the one dot weight is
589:59 - four, of course, the first index layer. Now have a look inside here. Now you see how out features
590:06 - is five. Well, that's why our bias parameter has five values here. And the same thing for this weight
590:14 - value here. And the weight value here, why is this have 10 samples? One, two, three, four, five, six,
590:23 - seven, eight, nine, 10, because two times five equals 10. So this is just with a simple two layer
590:31 - network, look at all the numbers that are going on behind the scenes. Imagine coding all of these
590:36 - by hand. Like there's something like 20 numbers or something here. Now we've only done two layers
590:43 - here. Now the beauty of this is that in the previous section, we created all of the weight
590:48 - and biases using an end dot parameter and random values. You'll notice that these are all random
590:53 - two. Again, if yours are different to mine, don't worry too much, because they're going to be started
590:59 - randomly and we haven't set a random seed. But the thing to note here is that PyTorch is creating
591:05 - all of these parameters for us behind the scenes. And now when we do back propagation and gradient
591:10 - descent, when we code our training loop, the optimizer is going to change all of these values
591:15 - ever so slightly to try and better fit or better represent the data so that we can split our two
591:20 - circles. And so you can imagine how verbose this could get if we had say 50 layers with 128 different
591:31 - features of each. So let's change this up, see what happens. Watch how quickly the numbers get
591:36 - out of hand. Look at that. We just changed one value and look how many parameters our model has.
591:41 - So you might be able to calculate that by hand, but I personally don't want to. So we're going to
591:48 - let PyTorch take care of a lot of that for us behind the scenes. So for now we're keeping it simple,
591:53 - but that's how we can crack our models open and have a look at what's going on. Now that was a
591:59 - little detour. It's time to make some predictions with random numbers. I just wanted to highlight
592:03 - the fact that our model is in fact instantiated with random numbers here. So the untrained threads
592:09 - model zero, we're going to pass in X test. And of course, we have to send the test data to the
592:15 - device. Otherwise, if it's on a different device, we'll get errors because PyTorch likes to make
592:21 - calculations on the same device. So we'll go print. Let's do a nice print statement of length of
592:28 - predictions. We're going to go length or then untrained threads, we'll pass that in there.
592:36 - And then we'll go, oh no, we need to squiggle. And then we'll go shape. Shape is going to be
592:43 - untrained spreads dot shape. So this is again, following the data explorer's motto of visualize,
592:51 - visualize, visualize. And sometimes print is one of the best ones to do so. So length of test samples,
592:58 - you might already know this, or we've already checked this together, haven't we? X test.
593:04 - And then we're going to get the shape, which is going to be X test dot shape. Wonderful. And then
593:11 - we're going to print. What's our little error here? Oh no, collabs tricking me. So let's go first
593:19 - 10 predictions. And we're going to go untrained threads. So how do you think these predictions will
593:28 - fare? They're doing it with random numbers. And what are we trying to predict again? Well,
593:34 - we're trying to predict whether a dot is a red dot or a blue dot or zero or one. And then we'll go
593:41 - first 10 labels is going to be, we'll get this on the next line. And we'll go Y test.
593:52 - Beautiful. So let's have a look at this untrained predictions. So we have length of predictions
593:59 - is 200. Length of test samples is 200. But the shapes are different. What's going on here?
594:05 - Y test. And let's have a look at X test. Oh, well, I better just have a look at Y test.
594:18 - Why don't we have a two there? Oh, I've done X test dot shape. Oh, let's test samples. That's
594:26 - okay. And then the predictions are one. Oh, yes. So Y test. Let's just check the first 10 X test.
594:32 - So a little bit of clarification needed here with your shapes. So maybe we'll get this over here
594:38 - because I like to do features first and then labels. What did we miss here? Oh, X test 10
594:46 - and Y test. See, we're troubleshooting on the fly here. This is what you're going to do with
594:50 - a lot of your code. So there's our test values. There's the ideal labels. But our predictions,
594:54 - they don't look like our labels. What's going on here? We can see that they're on the CUDA device,
594:58 - which is good. We said that. We can see that they got gradient tracking. Oh, we didn't with
595:05 - touch. We didn't do inference mode here. That's a poor habit of us. Excuse me. Let's inference
595:10 - mode this. There we go. So you notice that the gradient tracking goes away there. And so our
595:16 - predictions are nowhere near what our test labels are. But also, they're not even in the same like
595:22 - ball park. Like these are whole numbers, one or zero. And these are all floats between one and
595:29 - zero. Hmm. So maybe rounding them. Will that do something? So where's our threads here? So
595:36 - we go torch dot round. What happens there? Oh, they're all zero. Well, our model is probably
595:45 - going to get about 50% accuracy. Why is that? Because all the predictions look like they're
595:49 - going to be zero. And they've only got two options, basically head or tails. So when we create our
595:57 - model and when we evaluate it, we want our predictions to be in the same format as our labels. But
596:02 - we're going to cover some steps that we can take to do that in a second. What's important to take
596:06 - away from this is that there's another way to replicate the model we've made above using
596:10 - nn dot sequential. We've just replicated the same model as what we've got here. And n dot
596:15 - sequential is a simpler way of creating a pytorch model. But it's limited because it literally
596:21 - just sequentially steps through each layer in order. Whereas in here, you can get as creative as you
596:26 - want with the forward computation. And then inside our model, pytorch has behind the scenes
596:32 - created us some weight and bias tensors for each of our layers with regards to the shapes that
596:38 - we've set. And so the handy thing about this is that if we got quite ridiculous with our layers,
596:46 - pytorch would still do the same thing behind the scenes, create a whole bunch of random numbers for
596:50 - us. And because our numbers are random, it looks like our model isn't making very good predictions.
596:56 - But we're going to fix this in the next few videos when we move on to
597:02 - fitting the model to the data and making a prediction. But before we do that, we need to
597:06 - pick up a loss function and an optimizer and build a training loop. So let's get on to these two things.
597:13 - Welcome back. So over the past few videos, we've been setting up a classification model to deal
597:19 - with our specific shape of data. Now recall, depending on the data set that you're working
597:23 - with will depend on what layers you use for now we're keeping it simple and n dot linear is one
597:28 - of the most simple layers in pytorch. We've got two input features, we're upscaling that to five
597:33 - output features. So we have five hidden units, and then we have one output feature. And that's in line
597:38 - with the shape of our data. So two features of x equals one number for y. So now let's continue
597:46 - on modeling with where we're up to. We have build or pick a model. So we've built a model. Now we
597:52 - need to pick a loss function and optimizer. We're getting good at this. So let's go here,
597:59 - set up loss function and optimizer. Now here comes the question. If we're working on classification
598:06 - previously, we used, let's go to the next one, and an dot L one loss for regression, which is
598:13 - MAE mean absolute error, just a heads up that won't necessarily work with a classification problem.
598:19 - So which loss function or optimizer should you use? So again, this is problem specific. But with
598:31 - a little bit of practice, you'll get used to using different ones. So for example, for regression,
598:38 - you might want, which is regressions predicting a number. And I know it can get fusing because
598:43 - it looks like we're predicting a number here, we are essentially predicting a number. But this
598:47 - relates to a class. So for regression, you might want MAE or MSE, which is mean absolute
598:56 - absolute error, or mean squared error. And for classification, you might want binary cross entropy
599:09 - or categorical cross entropy, which is sometimes just referred to as cross entropy. Now, where would
599:16 - you find these things out? Well, through the internet, of course. So you could go, what is
599:24 - binary cross entropy? I'm going to leave you this for your extra curriculum to read through this.
599:30 - We've got a fair few resources here. Understanding binary cross entropy slash log loss
599:36 - by Daniel Godoy. Oh, yes. Great first name, my friend. This is actually the article that I
599:42 - would recommend to if you want to learn what's going on behind the scenes through binary cross
599:46 - entropy. For now, there's a lot of math there. We're going to be writing code to implement this. So
599:51 - PyTorch has done this for us. Essentially, what does a loss function do? Let's remind ourselves.
599:58 - Go down here. As a reminder, the loss function measures how wrong your models' predictions are.
600:09 - So I also going to leave a reference here to I've got a little table here in the book version of
600:17 - this course. So 0.2 neural network classification with PyTorch set up loss function and optimizer.
600:23 - So we've got some example loss functions and optimizers here, such as stochastic gradient
600:27 - descent or SGD optimizer, atom optimizer is also very popular. So I've got problem type here,
600:32 - and then the PyTorch code that we can implement this with. We've got binary cross entropy loss.
600:37 - We've got cross entropy loss, mean absolute error, MAE, mean squared error, MSE. So you want to use
600:44 - these two for regression. There are other different loss functions you could use, but these are some
600:48 - of the most common. That's what I'm focusing on, the most common ones that are going to get you
600:52 - through a fair few problems. We've got binary classification, multi-class classification. What
600:57 - are we working with? We're working with binary classification. So we're going to look at torch.nn
601:03 - BCE, which stands for binary cross entropy, loss with logits. What the hell is a logit?
601:10 - And BCE loss. Now this is confusing. Then trust me, when I first started using PyTorch,
601:14 - I got a little bit confused about why they have two here, but we're going to explore that anyway.
601:18 - So what is a logit? So if you search what is a logit, you'll get this and you'll get statistics
601:26 - and you'll get the log odds formula. In fact, if you want to read more, I would highly encourage it.
601:30 - So you could go through all of this. We're going to practice writing code for it instead.
601:35 - Luckily PyTorch does this for us, but logit is kind of confusing in deep learning. So if we go
601:42 - what is a logit in deep learning, it kind of means a different thing. It's kind of just a name of what
601:49 - yeah, there we go. What is the word logits in TensorFlow? As I said, TensorFlow is another
601:55 - deep learning framework. So let's close this. What do we got? We've got a whole bunch of
602:00 - definitions here. Logits layer. Yeah. This is one of my favorites. In context of deep learning,
602:08 - the logits layer means the layer that feeds into the softmax. So softmax is a form of activation.
602:13 - We're going to see all of this later on because this is just words on a page right now. Softmax
602:17 - or other such normalization. So the output of the softmax are the probabilities for the
602:22 - classification task and its input is the logit's layer. Whoa, there's a lot going on here. So let's
602:29 - just take a step back and get into writing some code. And for optimizers, I'm just going to complete
602:35 - this. And for optimizers, two of the most common and useful are SGD and Adam. However, PyTorch
602:48 - has many built in options. And as you start to learn more about the world of machine learning,
602:55 - you'll find that if you go to torch.optim or torch.nn. So if we have.nn, what do we have in here?
603:04 - Loss functions. There we go. Beautiful. That's what we're after. L1 loss, which is MAE,
603:09 - MSC loss, cross entropy loss, CTC loss, all of these different types of loss here will depend
603:14 - on the problem you're working on. But I'm here to tell you that for regression and classification,
603:18 - two of the most common of these. See, this is that confusion again. BCE loss, BCE with
603:24 - logit's loss. What the hell is a logit? My goodness. Okay, that's enough. And Optim,
603:30 - these are different optimizers. We've got probably a dozen or so here. Algorithms.
603:35 - Add a delta, add a grad. Adam, this can be pretty full on when you first get started. But for now,
603:40 - just stick with SGD and the atom optimizer. They're two of the most common. Again, they may not
603:46 - perform the best on every single problem, but they will get you fairly far just knowing those.
603:51 - And then you'll pick up some of these extra ones as you go. But let's just get rid of all of,
603:57 - maybe we'll, so I'll put this in here, this link. So we'll create our loss function. For the loss
604:05 - function, we're going to use torch.nn.bce with logit's loss. This is exciting. For more on what
604:21 - binary cross entropy, which is BCE, a lot of abbreviations in machine learning and deep learning
604:27 - is check out this article. And then for a definition on what a logit is, we're going to see a
604:39 - logit in a second in deep learning. Because again, deep learning is one of those fields,
604:44 - a machine learning, which likes to be a bit rebellious, you know, likes to be a bit different
604:48 - from the pure mathematics type of fields and statistics in general. It's this beautiful
604:53 - gestaltism and for different optimizers, see torch dot opt in. But we've covered a few of these
605:03 - things before. And finally, I'm going to put up here, and then for some common choices of loss
605:11 - functions and optimizers. Now, don't worry too much. This is why I'm linking all of these extra
605:17 - resources. A lot of this is covered in the book. So as we just said, set up loss function,
605:23 - optimizer, we just talked about these things. But I mean, you can just go to this book website
605:27 - and reference it. Oh, we don't want that. We want this link. Come on, I knew you can't even
605:33 - copy and paste. How are you supposed to code? I know I've been promising code this whole time,
605:37 - so let's write some. So let's set up the loss function. What did we say it was? We're going to
605:43 - call it L O double S F N for loss function. And we're going to call B C E with logit's loss. So B
605:54 - C E with logit's loss. This has the sigmoid activation function built in. And we haven't covered what
606:01 - the sigmoid activation function is, but we are going to don't you worry about that built in.
606:07 - In fact, if you wanted to learn what the sigmoid activation function is, how could you find out
606:11 - sigmoid activation function? But we're going to see it in action. Activation functions in neural
606:17 - networks. This is the beautiful thing about machine learning. There's so much stuff out there.
606:21 - People have written some great articles. You've got formulas here. PyTorch has implemented that
606:26 - behind the scenes for us. So thank you, PyTorch. But if you recall, sigmoid activation function
606:33 - built in, where did we discuss the architecture of a classification network? What do we have here?
606:38 - Right back in the zeroth chapter of this little online book thing that we heard here. Binary
606:44 - classification. We have output activation. Oh, oh, look at that. So sigmoid torch dot sigmoid and
606:52 - pytorch. All right. And then for multi class classification, we need the softmax. Okay. Names
606:59 - on a page again, but this is just a reference table so we can keep coming back to. So let's just
607:04 - keep going with this. I just want to highlight the fact that nn dot BCE loss also exists. So
607:12 - this requires BCE loss equals requires inputs to have gone through the sigmoid activation function
607:24 - prior to input to BCE loss. And so let's look up the documentation. I'm going to comment that
607:33 - out because we're going to stick with using this one. Now, why would we stick with using this one?
607:37 - Let's check out the documentation, hey, torch dot nn. And I realized this video is all over the
607:41 - place, but we're going to step back through BCE loss with logits. Did I even say this right?
607:49 - With logits loss. So with I got the width around the wrong way. So let's check this out. So this
607:55 - loss combines a sigmoid layer with the BCE loss in one single class. So if we go back to the code,
608:02 - BCE loss is this. So if we combined an n dot sequential, and then we passed in an n dot sigmoid,
608:11 - and then we went and then dot BCE loss, we'd get something similar to this. But if we keep reading
608:22 - in the documentation, because that's just I just literally read that it combines sigmoid with BCE
608:27 - loss. But if we go back to the documentation, why do we want to use it? So this version is more
608:33 - numerically stable than using a plain sigmoid by a BCE loss, followed by a BCE loss. As by
608:41 - combining the operations into one layer, we take advantage of the log sum x trick for numerical
608:47 - stability, beautiful. So if we use this log function, loss function for our binary cross entropy,
608:53 - we get some numeric stability. Wonderful. So there's our loss function. We've got the sigmoid
608:59 - activation function built in. And so we're going to see the difference between them later on,
609:05 - like in the flesh, optimizer, we're going to choose, hmm, let's stick with SGD, hey,
609:11 - old faithful stochastic gradient descent. And we have to set the parameters here, the parameters
609:17 - parameter params equal to our model parameters would be like, hey, stochastic gradient descent,
609:23 - please update. If we get another code cell behind here, please update our model parameters model
609:32 - with respect to the loss, because we'd like our loss function to go down. So these two are going
609:37 - to work in tandem again, when we write our training loop, and we'll set our learning rate to 0.1.
609:42 - We'll see where that gets us. So that's what the optimizer is going to do. It's going to optimize
609:46 - all of these parameters for us, which is amazing. And the principal would be the same, even if there
609:52 - was 100 layers here, and 10,000, a million different parameters here. So we've got a loss function,
609:59 - we've got an optimizer. And how about we create an evaluation metric. So let's calculate
610:06 - accuracy at the same time. Because that's very helpful with classification problems is accuracy.
610:11 - Now, what is accuracy? Well, we could look up formula for accuracy. So true positive over true
610:21 - positive plus true negative times 100. Okay, let's see if we can implement something similar to that
610:25 - just using pure pytorch. Now, why would we want accuracy? Because the accuracy is out of 100
610:32 - examples. What percentage does our model get right? So for example, if we had a coin toss,
610:42 - and we did 100 coin tosses in our model predicted heads 99 out of 100 times, and it was right
610:50 - every single time, it might have an accuracy of 99%, because it got one wrong. So 99 out of 100,
610:56 - it gets it right. So dev accuracy FN accuracy function, we're going to pass it y true. So
611:07 - remember, any type of evaluation function or loss function is comparing the predictions to
611:12 - the ground truth labels. So correct equals, this is going to see how many of our y true
611:19 - or y threads are correct. So torch equal stands for, hey, how many of these samples y true are
611:27 - equal to y pred? And then we're going to get the sum of that, and we need to get the item from
611:32 - that because we want it as a single value in Python. And then we're going to calculate the
611:38 - accuracy, ACC stands for accuracy, equals correct, divided by the length of samples that we have
611:45 - as input. And then we're going to times that by 100, and then return the accuracy. Wonderful.
611:52 - So we now have an accuracy function, we're going to see how all the three of these come into play
611:57 - when we write a training loop, which we might as we get started on the next few videos, hey,
612:02 - I'll see you there. Welcome back. In the last video, we discussed some different loss function
612:09 - options for our classification models. So we learned that if we're working with binary cross
612:15 - entropy or binary classification problems, we want to use binary cross entropy. And pie torch
612:21 - has two different times of binary cross entropy, except one is a bit more numerically stable.
612:27 - That's the BCE with logit's loss, because it has a sigmoid activation function built in.
612:31 - So that's straight from the pie to its documentation. And that for optimizer wise, we have a few
612:37 - different choices as well. So if we check out this section here on the pie torch book, we have a
612:42 - few different loss functions and optimizers for different problems and the pie torch code that
612:47 - we can implement. But the premise is still the same across the board of different problems.
612:52 - The loss function measures how wrong our model is. And the goal of the optimizer is to optimize
612:58 - the model parameters in such a way that the loss function goes down. And we also implemented our
613:05 - own accuracy function metric, which is going to evaluate our models predictions using accuracy
613:13 - as an evaluation metric, rather than just loss. So let's now work on training a model.
613:22 - So what should we do first? Well, do you remember the steps in a pie torch training loop?
613:28 - So to train our model, we're going to need to build a training loop. So if you watch the video
613:39 - on the pie torch, so if you can Google unofficial pie torch song, you should find my, there we go,
613:47 - the unofficial pie torch optimization loop song. We're not going to watch that. That's going to
613:51 - be a little tidbit for the steps that we're going to code out. But that's just a fun little jingle
613:56 - to remember these steps here. So if we go into the book section, this is number three train model,
614:01 - exactly where we're up to here. But we have pie torch training loop steps. Remember, for an
614:07 - epoch in a range, do the forward pass, calculate the loss, optimizer zero grand, loss backward,
614:16 - optimizer step, step, step. We keep singing this all day. You could keep reading those steps all
614:22 - day, but it's better to code them. But let's write this out. So forward pass to calculate the loss,
614:31 - three, optimizer zero grad, four. What do we do? Loss backward. So back propagation,
614:40 - I'll just write that up in here back propagation. We've linked to some extra resources. If you'd
614:45 - like to find out what's going on in back propagation, we're focused on code here, and then gradient
614:51 - descent. So optimizer step. So build a training loop with the following steps. However, I've kind
615:06 - of mentioned a few things that need to be taken care of before we talk about the forward pass.
615:10 - So we've talked about logits. We looked up what the hell is a logit. So if we go into this stack
615:16 - overflow answer, we saw machine learning, what is a logit? How about we see that? We need to
615:21 - do a few steps. So I'm going to write this down. Let's get a bit of clarity about us, Daniel.
615:27 - We're kind of all over the place at the moment, but that's all right. That's the exciting part
615:30 - of machine learning. So let's go from going from raw logits to prediction probabilities
615:40 - to prediction labels. That's what we want. Because to truly evaluate our model, we want to
615:47 - so let's write in here our model outputs going to be raw logit. So that's the definition of a
615:56 - logit in machine learning and deep learning. You might read some few other definitions, but for us,
616:00 - the raw outputs of our model, model zero are going to be referred to as logits. So then model zero,
616:07 - so whatever comes out of here are logits. So we can convert these logits into prediction probabilities
616:20 - by passing them to some kind of activation function, e.g. sigmoid for binary cross entropy
616:33 - and softmax for multi-class classification. I've got binary class e-fication. I have to
616:45 - sound it out every time I spell it for binary classification. So class e-fication. So we're
616:51 - going to see multi-class classification later on, but we want some prediction probabilities.
616:57 - We're going to see what they look like in a minute. So we want to go from logits to prediction
617:02 - probabilities to prediction labels. Then we can convert our model's prediction probabilities to
617:15 - prediction labels by either rounding them or taking the argmax.
617:24 - So round is for binary classification and argmax will be for the outputs of the softmax activation
617:34 - function, but let's see it in action first. So I've called the logits are the raw outputs of our
617:41 - model with no activation function. So view the first five outputs of the forward pass
617:49 - on the test data. So of course, our model is still instantiated with random values. So we're
617:56 - going to set up a variable here, y logits, and model zero, we're going to pass at the test data.
618:02 - So x test, not text, two device, because our model is currently on our CUDA device and we need
618:09 - our test data on the same device or target device. Remember, that's why we're writing device
618:15 - agnostic codes. So this would work regardless of whether there's a GPU active or not. Let's have
618:20 - a look at the logits. Oh, okay. Right now, we've got some positive values here. And we can see that
618:27 - they're on the CUDA device. And we can see that they're tracking gradients. Now, ideally,
618:34 - we would have run torch dot inference mode here, because we're making predictions. And the rule
618:40 - of thumb is whenever you make predictions with your model, you turn it into a vowel mode.
618:44 - We just have to remember to turn it back to train when we want to train and you run torch dot
618:48 - inference mode. So we get a very similar set up here. We just don't have the gradients being
618:53 - tracked anymore. Okay. So these are called logits. The logits are the raw outputs of our model,
619:00 - without being passed to any activation function. So an activation function is something a little
619:06 - separate from a layer. So if we come up here, we've used layer. So in the neural networks that we
619:13 - start to build and the ones that you'll subsequently build are comprised of layers and activation
619:19 - functions, we're going to make the concept of an activation function a little bit more clear later
619:24 - on. But for now, just treat it all as some form of mathematical operation. So if we were to pass
619:30 - data through this model, what is happening? Well, it's going through the linear layer. Now recall,
619:35 - we've seen this a few times now torch and then linear. If we pass data through a linear layer,
619:40 - it's applying the linear transformation on the incoming data. So it's performing this
619:47 - mathematical operation behind the scenes. So why the output equals the input x multiplied by a
619:53 - weight tensor a this could really be w which is transposed so that this is doing a dot product
619:59 - plus a bias term here. And then if we jump into our model state deck, we've got weight
620:05 - and we've got bias. So that's the formula that's happening in these two layers. It will be different
620:09 - depending on the layer that we choose. But for now, we're sticking with linear. And so that the
620:14 - raw output of our data going through our two layers, the logits is going to be this information
620:21 - here. However, it's not in the same format as our test data. And so if we want to make a comparison
620:30 - to how good our model is performing, we need apples to apples. So we need this in the same format
620:36 - as this, which is not of course. So we need to go to a next step. Let's use the sigmoid. So use the
620:44 - sigmoid activation function on our model logits. So why are we using sigmoid? Well, recall in a
620:54 - binary classification architecture, the output activation is the sigmoid function here. So now
621:02 - let's jump back into here. And we're going to create some predprobs. And what this stands for
621:07 - on our model logits to turn them into prediction probabilities, probabilities. So why predprobs
621:16 - equals torch sigmoid, why logits? And now let's have a look at why predprobs. What do we get from
621:23 - this? Oh, when we still get numbers on a page, goodness gracious me. But the important point
621:29 - now is that they've gone through the sigmoid activation function, which is now we can pass these
621:37 - to a torch dot round function. Let's have a look at this torch dot round. And what do we get?
621:42 - Predprobs. Oh, the same format as what we've got here. Now you might be asking like, why don't we
621:52 - just put torch dot round here? Well, that's a little, this step is required to, we can't just do it on
621:59 - the raw logits. We need to use the sigmoid activation function here to turn it into prediction
622:04 - probabilities. And now what is a prediction probability? Well, that's a value usually between 0 and 1
622:10 - for how likely our model thinks it's a certain class. And in the case of binary cross entropy,
622:16 - these prediction probability values, let me just write this out in text. So for our prediction
622:24 - probability values, we need to perform a range style rounding on them. So this is a decision
622:39 - boundary. So this will make more sense when we go why predprobs, if it's equal to 0.5 or greater
622:48 - than 0.5, we set y equal to one. So y equal one. So class one, whatever that is, a red dot or a
622:59 - blue dot, and then why predprobs, if it is less than 0.5, we set y equal to zero. So this is class
623:08 - zero. You can also adjust this decision boundary. So say, if you wanted to increase this value,
623:18 - so anything over 0.7 is one. And below that is zero. But generally, most commonly, you'll find
623:28 - it split at 0.5. So let's keep going. Let's actually see this in action. So how about we
623:35 - recode this? So find the predicted probabilities. And so we want no, sorry, we want the predicted
623:47 - labels, that's what we want. So when we're evaluating our model, we want to convert the outputs of
623:52 - our model, the outputs of our model are here, the logits, the raw outputs of our model are
623:58 - logits. And then we can convert those logits to prediction probabilities using the sigmoid function
624:06 - on the logits. And then we want to find the predicted labels. So we go raw logits output of our model,
624:14 - prediction probabilities after passing them through an activation function, and then prediction labels.
624:19 - This is the steps we want to take with the outputs of our model. So find the predicted labels.
624:26 - Let's go in here a little bit different to our regression problem previously, but nothing we can't
624:31 - handle. Torch round, we're going to go y-pred-probs. So I like to name it y-pred-probs for prediction
624:39 - probabilities and y-preds for prediction labels. Now let's go in full if we wanted to. So y-pred
624:47 - labels equals torch dot round torch dot sigmoid. So sigmoid activation function for binary cross
624:54 - entropy and model zero x test dot two device. Truly this should be within inference mode code,
625:01 - but for now we'll just leave it like this to have a single example of what's going on here.
625:08 - Now I just need to count one, two, there we want. That's where we want the index. We just want it
625:13 - on five examples. So check for equality. And we want print torch equal. We're going to check
625:22 - y-pred's dot squeeze is equal to y-pred labels. So just we're doing the exact same thing. And we
625:34 - need squeeze here to get rid of the extra dimension that comes out. You can try doing this without
625:38 - squeeze. So get rid of extra dimension once again. We want y-pred's dot squeeze. Fair bit of code
625:49 - there, but this is what's happened here. We create y-pred's. So we turn the y-pred
625:56 - probes into y-pred's. And then we just do the full step over again. So we make predictions with
626:03 - our model, we get the raw logits. So this is logits to pred probes to pred labels. So the raw
626:13 - outputs of our model are logits. We turn the logits into prediction probabilities using torch
626:18 - sigmoid. And we turn the prediction probabilities into prediction labels using torch dot round.
626:25 - And we fulfill this criteria here. So everything above 0.5. This is what torch dot round does.
626:31 - Turns it into a 1. Everything below 0.5 turns it into a 0. The predictions right now are going to
626:37 - be quite terrible because our model is using random numbers. But y-pred's found with the steps above
626:44 - is the same as y-pred labels doing the more than one hit. Thanks to this check for equality using
626:50 - torch equal y-pred's dot squeeze. And we just do the squeeze to get rid of the extra dimensions.
626:56 - And we have out here some labels that look like our actual y-test labels. They're in the same format,
627:03 - but of course they're not the same values because this model is using random weights to make predictions.
627:10 - So we've done a fair few steps here, but I believe we are now in the right space to start building
627:17 - a training a test loop. So let's write that down here 3.2 building a training and testing loop.
627:24 - You might want to have a go at this yourself. So we've got all the steps that we need to do the
627:29 - forward pass. But the reason we've done this step here, the logits, then the pred probes and the
627:35 - pred labels, is because the inputs to our loss function up here, this requires, so BCE with
627:43 - logits loss, requires what? Well, we're going to see that in the next video, but I'd encourage
627:50 - you to give it a go at implementing these steps here. Remember the jingle for an epoch in a range,
627:55 - do the forward pass, calculate the loss, which is BC with logits loss, optimise a zero grad,
628:02 - which is this one here, last backward, optimise a step, step, step. Let's do that together in the
628:10 - next video. Welcome back. In the last few videos, we've been working through creating a model for
628:17 - a classification problem. And now we're up to training a model. And we've got some steps here,
628:22 - but we started off by discussing the concept of logits. Logits are the raw output of the model,
628:29 - whatever comes out of the forward functions of the layers in our model. And then we discussed how
628:33 - we can turn those logits into prediction probabilities using an activation function,
628:38 - such as sigmoid for binary classification, and softmax for multi class classification.
628:44 - We haven't seen softmax yet, but we're going to stick with sigmoid for now because we have
628:48 - binary classification data. And then we can convert that from prediction probabilities
628:54 - to prediction labels. Because remember, when we want to evaluate our model, we want to compare
628:58 - apples to apples. We want our models predictions to be in the same format as our test labels.
629:06 - And so I took a little break after the previous video. So my collab notebook has once again
629:12 - disconnected. So I'm just going to run all of the cells before here. It's going to reconnect up
629:17 - here. We should still have a GPU present. That's a good thing about Google collab is that if you
629:22 - change the runtime type to GPU, it'll save that wherever it saves the Google collab notebook,
629:30 - so that when you restart it, it should still have a GPU present. And how can we check that,
629:36 - of course, while we can type in device, we can run that cell. And we can also check
629:42 - Nvidia SMI. It'll tell us if we have an Nvidia GPU with CUDA enabled ready to go.
629:48 - So what's our device? CUDA. Wonderful. And Nvidia SMI. Excellent. I have a Tesla P100 GPU.
629:58 - Ready to go. So with that being said, let's start to write a training loop. Now we've done this before,
630:03 - and we've got the steps up here. Do the forward pass, calculate the loss. We've spent enough on
630:09 - this. So we're just going to start jumping into write code. There is a little tidbit in this one,
630:14 - though, but we'll conquer that when we get to it. So I'm going to set a manual seed,
630:20 - torch top manual seed. And I'm going to use my favorite number 42. This is just to ensure
630:26 - reproducibility, if possible. Now I also want you to be aware of there is also another
630:32 - form of random seed manual seed, which is a CUDA random seed. Do we have the PyTorch?
630:39 - Yeah, reproducibility. So torch dot CUDA dot manual seed dot seed. Hmm. There is a CUDA
630:51 - seed somewhere. Let's try and find out. CUDA. I think PyTorch have just had an upgrade to
631:02 - their documentation. Seed. Yeah, there we go. Okay. I knew it was there. So torch dot CUDA
631:09 - dot manual seed. So if we're using CUDA, we have a CUDA manual seed as well. So let's see what
631:15 - happens if we put that to watch that CUDA dot manual seed 42. We don't necessarily have to put
631:21 - these. It's just to try and get as reproducible as numbers as possible on your screen and my screen.
631:26 - Again, what is more important is not necessarily the numbers exactly being the same lining up
631:31 - between our screens. It's more so the direction of which way they're going. So let's set the number
631:36 - of epochs. We're going to train for 100 epochs. epochs equals 100. But again, as you might have
631:43 - guessed, the CUDA manual seed is for if you're doing operations on a CUDA device, which in our
631:48 - case, we are. Well, then perhaps we'd want them to be as reproducible as possible. So speaking of
631:54 - CUDA devices, let's put the data to the target device because we're working with or we're writing
632:00 - data agnostic code here. So I'm going to write x train y train equals x train two device,
632:06 - comma y train dot two device, that'll take care of the training data. And I'm going to do the
632:12 - same for the testing data equals x test two device. Because if we're going to run our model
632:20 - on the CUDA device, we want our data to be there too. And the way we're writing our code,
632:25 - our code is going to be device agnostic. Have I said that enough yet? So let's also build our
632:31 - training and evaluation loop. Because we've covered the steps in here before, we're going to start
632:35 - working a little bit faster through here. And don't worry, I think you're up to it. So for an epoch
632:41 - in a range of epochs, what do we do? We start with training. So let me just write this.
632:48 - Training model zero dot train. That's the model we're working with. We call the train,
632:53 - which is the default, but we're going to do that anyway. And as you might have guessed,
632:57 - the code that we're writing here is, you can functionize this. So we're going to do this later
633:02 - on. But just for now, the next couple of videos, the next module or two, we're going to keep
633:07 - writing out the training loop in full. So this is the part, the forward pass, where there's a
633:14 - little bit of a tidbit here compared to what we've done previously. And that is because we're
633:18 - outputting raw logits here, if we just pass our data straight to the model. So model zero
633:24 - x train. And we're going to squeeze them here to get rid of an extra dimension. You can try to
633:30 - see what the output sizes look like without squeeze. But we're just going to call squeeze
633:34 - here. Remember, squeeze removes an extra one dimension from a tensor. And then to convert it
633:39 - into prediction labels, we go torch dot round. And torch dot sigmoid, because torch dot sigmoid
633:47 - is an activation function, which is going to convert logits into what convert the logits
633:53 - into prediction probabilities. So why logits? And I'm just going to put a note here. So this
633:57 - is going to go turn logits into pred probes into pred labels. So we've done the forward pass.
634:08 - So that's a little tidbit there. We could have done all of this in one step, but I'll show you
634:12 - why we broke this apart. So now we're going to calculate loss slash accuracy. We don't necessarily
634:19 - have to calculate the accuracy. But we did make an accuracy function up here. So that we can
634:26 - calculate the accuracy during training, we could just stick with only calculating the loss. But
634:31 - sometimes it's cool to visualize different metrics loss plus a few others while your model is training.
634:37 - So let's write some code to do that here. So we'll start off by going loss equals loss
634:44 - f n and y logits. Ah, here's the difference of what we've done before. Previously in the notebook
634:53 - zero one, up to zero two now, we passed in the prediction right here. But because what's our
634:58 - loss function? Let's have a look at our loss function. Let's just call that see what it returns.
635:04 - BCE with logits loss. So the BCE with logits expects logits as input. So as you might have guessed,
635:15 - loss function without logits. If we had nn dot BCE loss, notice how we haven't got with logits.
635:25 - And then we called loss f n, f n stands for function, by the way, without logits. What do we get?
635:32 - So BCE loss. So this loss expects prediction probabilities as input. So let's write some code
635:40 - to differentiate between these two. As I said, we're going to be sticking with this one.
635:45 - Why is that because if we look up torch BCE with logits loss, the documentation states that it's
635:53 - more numerically stable. So this loss combines a sigmoid layer and the BCE loss into one single
635:59 - class, and is more numerically stable. So let's come back here, we'll keep writing some code.
636:06 - And the accuracy is going to be accuracy f n. So our accuracy function, there's a little bit of a
636:13 - difference here is why true equals y train for the training data. So this will be the training
636:19 - accuracy. And then we have y pred equals y pred. So this is our own custom accuracy function
636:29 - that we wrote ourselves. This is a testament to the Pythonic nature of PyTorch as well.
636:33 - We've just got a pure Python function that we've slotted into our training loop,
636:37 - which is essentially what the loss function is behind the scenes.
636:41 - Now, let's write here, and then dot BCE with logits loss expects raw logits. So the raw output
636:52 - of our model as input. Now, what if we were using a BCE loss on its own here? Well, let's just write
637:00 - some code for that. So let's call loss function. And then we want to pass in y pred. Or we can
637:07 - just go why or torch sigmoid. So why would we pass in torch sigmoid on the logits here? Because
637:14 - remember, calling torch dot sigmoid on our logits turns our logits into prediction probabilities.
637:21 - And then we would pass in y train here. So if this was BCE loss expects this expects prediction
637:32 - probabilities as input. So does that make sense? That's the difference between with logits. So
637:40 - our loss function requires logits as input. Whereas if we just did straight up BCE loss,
637:45 - we need to call torch dot sigmoid on the logits because it expects prediction probabilities as
637:52 - input. Now, I'm going to comment that out because our loss function is BCE with logits loss. But
637:59 - just keep that in mind. For some reason, you stumble across some pytorch code that's using BCE loss,
638:04 - not BCE with logits loss. And you find that torch dot sigmoid is calling here, or you come across
638:10 - some errors, because your inputs to your loss function are not what it expects. So with that
638:16 - being said, we can keep going with our other steps. So we're up to optimizer zero grad. So
638:23 - optimizer dot zero grad. Oh, this is step three, by the way. And what's after this? Once we've
638:32 - zero grad the optimizer, we do number four, which is loss backward. We can go last backward. And then
638:40 - we go what's next? Optimizer step step step. So optimizer dot step. And I'm singing the unofficial
638:48 - pytorch optimization loop song there. This is back propagation. Calculate the gradients with respect
638:56 - to all of the parameters in the model. And the optimizer step is update the parameters to reduce
639:01 - the gradients. So gradient descent, hence the descent. Now, if we want to do testing,
639:09 - well, we know what to do here now, we go model zero, what do we do? We call model dot of
639:14 - al when we're testing. And if we're making predictions, that's what we do when we test,
639:18 - we make predictions on the test data set, using the patterns that our model has learned on the
639:24 - training data set, we turn on inference mode, because we're doing inference, we want to do the
639:29 - forward pass. And of course, we're going to compute the test logits, because logits are the raw output
639:36 - of our model with no modifications. X test dot squeeze, we're going to get rid of an extra one
639:42 - dimension there. Then we create the test pred, which is we have to do a similar calculation to
639:48 - what we've done here for the test pred, which is torch dot round. For our binary classification,
639:54 - we want prediction probabilities, which we're going to create by calling the sigmoid function
639:59 - on the test logits, prediction probabilities that are 0.5 or above to go to one, and prediction
640:05 - probabilities under 0.5 to go to level zero. So two is calculate the test loss, test loss
640:15 - slash accuracy. How would we do this? Well, just if we've done before, and we're going to go
640:22 - loss FN test logits, because our loss function, we're using what we're using BCE with logits loss,
640:29 - expects logits as input, where do we find that out in the documentation, of course,
640:34 - then we come back here, test logits, we're going to compare that to the Y test labels.
640:40 - And then for the test accuracy, what are we going to do? We're going to call accuracy FN
640:45 - on Y true equals Y test, and Y pred equals test pred. Now you might be thinking, why did I switch
640:55 - up the order here for these? Oh, and by the way, this is important to know with logits loss.
641:03 - So with these loss functions, the order here matters of which way you put in your parameters.
641:09 - So predictions come first, and then true labels for our loss function. You might be
641:13 - wondering why I've done it the reverse for our accuracy function, Y true and Y pred. That's just
641:19 - because I like to be confusing. Well, not really. It's because if we go to scikit-learn, I base a
641:24 - lot of my structured code of how scikit-learn structures things. The scikit-learn metrics accuracy
641:32 - score goes Y true Y pred. So I base it off that order, because the scikit-learn metrics package
641:40 - is very helpful. So I've based our metric evaluation metric function off this one. Whereas PyTorch's
641:48 - loss function does it in the reverse order, and it's important to get these in the right order.
641:53 - Exactly why they do it in that order. I couldn't tell you why. And we've got one final step, which
641:59 - is to print out what's happening. So how about we go, we're doing a lot of epochs here, 100 epochs.
642:10 - So we'll divide the epoch by 10 to print out every epoch or every 10th epoch, sorry. And we have a
642:17 - couple of different metrics that we can print out this time. So we're going to print out the epoch
642:22 - number epoch. And then we're going to print out the loss. So loss, how many decimal points?
642:31 - We'll go point five here. This is going to be the training loss. We'll also do the accuracy,
642:36 - which will be the training accuracy. We could write trainiac here for our variable to be a little bit,
642:42 - make them a little bit more understandable. And then we go here, but we're just going to leave
642:46 - it as loss and accuracy for now, because we've got test loss over here, test loss. And we're
642:54 - going to do the same five decimal points here. And then we're going to go test accuracy as well.
643:01 - Test act dot, we'll go to for the accuracy. And because it's accuracy, we want a percentage. This
643:08 - is the percent out of 100 guesses. What's the percentage that our model gets right on the training
643:13 - data and the testing data, as long as we've coded all the functions correctly. Now,
643:18 - we've got a fair few steps here. My challenge to you is to run this. And if there are any errors,
643:23 - try to fix them. No doubt there's probably one or two or maybe more that we're going to have to
643:27 - fix in the next video. But speaking of next videos, I'll see you there. Let's train our first
643:33 - classification model. Well, this is very exciting. I'll see you soon.
643:38 - Welcome back. In the last video, we wrote a mammoth amount of code, but nothing that we
643:46 - can't handle. We've been through a lot of these steps. We did have to talk about a few tidbits
643:50 - between using different loss functions, namely the BCE loss, which is binary cross entropy loss,
643:56 - and the BCE with logit's loss. We discussed that the BCE loss in PyTorch expects prediction
644:02 - probabilities as input. So we have to convert our model's logits. Logits are the raw output of the
644:08 - model to prediction probabilities using the torch dot sigmoid activation function. And if we're using
644:16 - BCE with logits loss, it expects raw logits as input as sort of the name hints at. And so we
644:23 - just pass it straight away the raw logits. Whereas our own custom accuracy function compares labels
644:29 - to labels. And that's kind of what we've been stepping through over the last few videos,
644:34 - is going from logits to predprobs to pred labels, because that's the ideal output of our model is
644:39 - some kind of label that we as humans can interpret. And so let's keep pushing forward. You may have
644:46 - already tried to run this training loop. I don't know if it works. We wrote all this code to get
644:50 - them in the last video. And it's probably an error somewhere. So you ready? We're going to train
644:54 - our first classification model together for 100 epochs. If it all goes to plan in three, two,
645:00 - one, let's run. Oh my gosh, it actually worked the first time. I promise you, I didn't change
645:07 - anything in here from the last video. So let's inspect what's going on. It trains pretty fast.
645:13 - Why? Well, because we're using a GPU, so it's going to be accelerated as much as it can anyway.
645:18 - And our data set is quite small. And our network is quite small. So you won't always
645:22 - get networks training this fast. They did 100 epochs in like a second. So the loss. Oh,
645:29 - 0.69973. It doesn't go down very much. The accuracy even starts high and then goes down.
645:38 - What's going on here? Our model doesn't seem to be learning anything. So what would an ideal
645:43 - accuracy be? An ideal accuracy is 100. And what's an ideal loss value? Well, zero, because lower
645:49 - is better for loss. Hmm, this is confusing. And now if we go, have a look at our blue and red
645:56 - dots. Where's our data? So I reckon, do we still have a data frame here? How many samples do we
646:05 - have of each? Let's inspect. Let's do some data analysis. Where do we create a data frame here?
646:13 - Now, circles, do we still have this instantiated circles dot label dot? We're going to call on
646:20 - pandas here, value counts. Is this going to output how many of each? Okay. Wow, we've got 500 of
646:28 - class one and 500 of class zero. So we have 500 red dots and blue dots, which means we have a
646:36 - balanced data set. So if we're getting, we're basically trying to predict heads or tails here.
646:42 - So if we're getting an accuracy of under 50%, or about 50%, if you rounded it up.
646:49 - Our model is basically doing as well as guessing. Well, what gives? Well, I think we should get
646:54 - visual with this. So let's make some predictions with our model, because these are just numbers
646:59 - on the page. It's hard to interpret what's going on. But our intuition now is because we have 500
647:04 - samples of each, or in the case of the training data set, we have 400 of each because we have
647:09 - 800 samples in the training data set. And we have in the testing data set, we have 200 total
647:15 - samples. So we have 100 of each. We're basically doing a coin flip here. Our model is as good as
647:20 - guessing. So turn to investigate why our model is not learning. And one of the ways we can do
647:28 - that is by visualizing our predictions. So let's write down here from the metrics. It looks like
647:35 - our model isn't learning anything. So to inspect it, let's make some predictions and make them
647:48 - visual. And we're right down here. In other words, visualize, visualize, visualize. All right.
648:00 - So we've trained a model. We've at least got the structure for the training code here.
648:04 - But this is the right training code. We've written this code before. So you know that this set up
648:08 - for training code does allow a model to train. So there must be something wrong with either
648:12 - how we've built our model, the data set. But let's keep going and investigate together.
648:17 - So to do so, I've got a function that I've pre-built earlier. Did I mention that we're learning side
648:24 - by side of a machine learning cooking show? So this is an ingredient I prepared earlier,
648:28 - a part of a dish. So to do so, we're going to import a function called plot decision,
648:39 - or maybe I'll turn this into code, plot decision boundary.
648:44 - Welcome to the cooking show, cooking with machine learning. What model will we cook up today?
648:50 - So if we go to pytorch deep learning, well, it's already over here, but this is the home repo for
648:59 - the course, the link for this will be scattered everywhere. But there's a little function here
649:03 - called helper functions dot py, which I'm going to fill up with helper functions throughout the
649:08 - course. And this is the one I'm talking about here, plot decision boundary. Now we could just
649:13 - copy this into our notebook, or I'm going to write some code to import this programmatically,
649:18 - so we can use other functions from in here. Here's our plot predictions function that we made in
649:22 - the last section, zero one, but this plot decision boundary is a function that I got inspired by
649:30 - to create from madewithml.com. Now this is another resource, a little bit of an aside,
649:36 - I highly recommend going through this by Goku Mohandas. It gives you the foundations of neural
649:41 - networks and also ml ops, which is a field, which is based on getting your neural networks and machine
649:49 - learning models into applications that other people can use. So I can't recommend this resource
649:56 - enough. So please, please, please check that out if you want another resource for machine learning,
650:02 - but this is where this helper function came from. So thank you, Goku Mohandas. I've made a little
650:06 - bit of modifications for this course, but not too many. So we could either copy that, paste it in
650:12 - here, or we could write some code to import it for us magically, or using the power of the internet,
650:20 - right, because that's what we are. We're programmers, we're machine learning engineers, we're data
650:24 - scientists. So from pathlib, so the request module in Python is a module that allows you to make
650:31 - requests, a request is like going to a website, hey, I'd like to get this code from you, or this
650:36 - information from you, can you please send it to me? So that's what that allows us to do,
650:40 - and pathlib, we've seen pathlib before, but it allows us to create file parts. Because why? Well,
650:46 - we want to save this helper function dot pi script to our Google collab files. And so we can do this
650:54 - with a little bit of code. So download helper functions from learn pytorch repo. If it's not
651:04 - already downloaded. So let's see how we can do that. So we're going to write some if else code to
651:13 - check to see if the path of helper functions dot pi already exist, we don't want to download it again.
651:23 - So at the moment, it doesn't exist. So this if statement is going to return false. So let's just
651:30 - print out what it does if it returns true helper functions dot pi already exists. We might we could
651:37 - even probably do a try and accept looping about if else will help us out for now. So if it exists
651:43 - else, print downloading helper functions dot pi. So ours doesn't exist. So it's going to make a
651:53 - request or let's set up our request request dot get. And here's where we can put in a URL. But we
652:02 - need the raw version of it. So this is the raw version. If we go back, this is just pytorch deep
652:09 - learning the repo for this course slash helper functions. If I click raw, I'm going to copy that.
652:16 - Oh, don't want to go in there want to go into request get type that in this has to be in a
652:21 - string format. So we get the raw URL. And then we're going to go with open, we're going to open
652:28 - a file called helper functions dot pi. And we're going to set the context to be right binary,
652:39 - which is wb as file F is a common short version of writing file. Because we're going to call
652:46 - file dot write, and then request dot content. So this code is basically saying hey requests,
652:53 - get the information that's at this link here, which is of course, all of this code here,
652:59 - which is a Python script. And then we're going to create a file called helper functions dot pi,
653:05 - which gives us write permissions. We're going to name it F, which is short for file. And then
653:09 - we're going to call on it file dot write the content of the request. So instead of talking
653:17 - through it, how about we see it in action? We'll know if it works if we can from helper functions
653:22 - import plot predictions, we're going to use plot predictions later on, as well as plot decision
653:28 - boundary. So plot predictions we wrote in the last section. Wonderful. I'm going to write here,
653:35 - downloading helper functions dot pi did at work. We have helper functions dot pi. Look at that,
653:42 - we've done it programmatically. Can we view this in Google column? Oh my goodness, yes we can.
653:47 - And look at that. So this may evolve by the time you do the course, but these are just some general
653:52 - helper functions rather than writing all of this out. If you would like to know what's going on
653:56 - in plot decision boundary, I encourage you to read through here. And what's going on,
654:01 - you can step by step at yourself. There is nothing here that you can't tackle yourself. It's all
654:07 - just Python code, no secrets just Python code. We've got we're making predictions with a
654:12 - PyTorch model. And then we're testing for multi class or binary. So we're going to get out of that.
654:17 - But now let's see the ultimate test is if the plot decision boundary function works. So again,
654:23 - we could discuss plot decision boundary of the model. We could discuss what it does behind the scenes
654:33 - to the cows come home. But we're going to see it in real life here. I like to get visual.
654:38 - So fig size 12, six, we're going to create a plot here, because we are adhering to the data
654:45 - explorer's motto of visualize visualize visualize. And we want to subplot because we're going to
654:51 - compare our training and test sets here, train. And then we're going to go PLT, or actually we'll
654:59 - plot the first one, plot decision boundary. Now, because we're doing a training plot here,
655:05 - we're going to pass in model zero and X train and Y train. Now, this is the order that the
655:11 - parameters go in. If we press command shift space, I believe Google collab, if it's working with me,
655:18 - we'll put up a doc string. There we go, plot decision boundary. Look at the inputs that it
655:25 - takes model, which is torch and end up module. And we've got X, which is our X value, which is a
655:31 - torch tensor, and Y, which is our torch tensor value here. So that's for the training data.
655:36 - Now, let's do the same for the testing data, plot dot subplot. This is going to be one, two,
655:42 - two for the index. This is just number of rows of the plot, number of columns. And this is the
655:47 - index. So this plot will appear on the first slot. We're going to see this anyway. Anything
655:52 - below this code will appear on the second slot, PLT dot title. And we're going to call this one
655:58 - test. Then we're going to call plot decision boundary. If this works, this is going to be some
656:04 - serious magic. I love visualization functions in machine learning. Okay, you ready? Three,
656:11 - two, one, let's check it out. How's our model doing? Oh, look at that. Oh, now it's clear.
656:19 - So behind the scenes, this is the plots that plot decision boundary is making. Of course,
656:24 - this is the training data. This is the testing data, not as many dot points here, but the same
656:28 - sort of line of what's going on. So this is the line that our model is trying to draw through the
656:33 - data. No wonder it's getting about 50% accuracy and the loss isn't going down. It's just trying
656:38 - to split the data straight through the middle. It's drawing a straight line. But our data is
656:43 - circular. Why do you think it's drawing a straight line? Well, do you think it has anything to do
656:50 - with the fact that our model is just made with using pure linear layers? Let's go back to our model.
656:55 - What's it comprised on? Just a couple of linear layers. What's a linear line? If we look up linear
657:01 - line, is this going to work with me? I don't actually think it might. There we go. Linear line,
657:06 - all straight lines. So I want you to have a think about this, even if you're completely
657:10 - new to deep learning, can we? You can answer this question. Can we ever separate this circular data
657:17 - with straight lines? I mean, maybe we could if we drew straight lines here, but then trying to
657:24 - curve them around. But there's an easier way. We're going to see that later on. For now,
657:29 - how about we try to improve our model? So the model that we built, we've got 100 epochs.
657:35 - I wonder if our model will improve if we trained it for longer. So that's a little bit of a challenge
657:39 - before the next video. See if you can train the model for 1000 epochs. Does that improve the
657:46 - results here? And if it doesn't improve the results here, have a think about why that might be.
657:52 - I'll see you in the next video. Welcome back. In the last video, we wrote some code to download
657:59 - a series of helper functions from our helper functions dot pi. And later on, you'll see why
658:04 - this is quite standard practice as you write more and more code is to write some code, store them
658:10 - somewhere such as a Python script like this. And then instead of us rewriting everything that we
658:15 - have and helper functions, we just import them and then use them later on. This is similar to
658:20 - what we've been doing with PyTorch. PyTorch is essentially just a collection of Python scripts
658:25 - that we're using to build neural networks. Well, there's a lot more than what we've just done.
658:30 - I mean, we've got one here, but PyTorch is a collection of probably hundreds of different
658:34 - Python scripts. But that's beside the point. We're trying to train a model here to separate
658:39 - blue and red dots. But our current model is only drawing straight lines. And I got you to
658:45 - have a think about whether our straight line model, our linear model could ever separate this data.
658:50 - Maybe it could. And I issued the challenge to see if it could if you trained for 1000 epochs.
658:56 - So did it improve at anything? Is the accuracy any higher? Well, speaking of training for more
659:05 - epochs, we're up to section number five, improving a model. This is from a model perspective. So now
659:13 - let's discuss some ways. If you were getting results after you train a machine learning model or a
659:20 - deep learning model, whatever kind of model you're working with, and you weren't happy with those
659:24 - results. So how could you go about improving them? So this is going to be a little bit of an overview
659:30 - of what we're going to get into. So one way is to add more layers. So give the model more chances
659:37 - to learn about patterns in the data. Why would that help? Because if our model currently has two
659:45 - layers, model zero dot state dinked. Well, we've got however many numbers here, 20 or so. So this
659:56 - is zero flayer. This is the first layer. If we had 10 of these, well, we'd have 10 times the
660:00 - amount of parameters to try and learn the patterns in this data, a representation of this data.
660:06 - Another way is to add more hidden units. So what I mean by that is we created this model here,
660:16 - and each of these layers has five hidden units. The first one outputs, out features equals five,
660:24 - and this one takes in features equals five. So we could go from, go from five hidden units to
660:31 - 10 hidden units. The same principle as above applies here is that the more parameters our model has
660:41 - to represent our data, the potentially now I say potentially here because some of these things
660:46 - might not necessarily work. So our data sets quite simple. So maybe if we added too many layers,
660:52 - our models trying to learn things that are too complex, it's trying to adjust too many numbers
660:56 - for the data set that we have the same thing for more hidden units. What other options do we
661:01 - have? Well, we could fit for longer, give the model more of a chance to learn because every epoch
661:08 - is one pass through the data. So maybe 100 times looking at this data set wasn't enough.
661:13 - So maybe you could fit for 1000 times, which was the challenge. Then there's change in the
661:18 - activation functions, which we're using sigmoid at the moment, which is generally the activation
661:23 - function you use for a binary classification problem. But there are also activation functions
661:28 - you can put within your model. Hmm, there's a little hint that we'll get to that later.
661:34 - Then there's change the learning rate. So the learning rate is the amount the optimizer will
661:40 - adjust these every epoch. And if it's too small, our model might not learn anything because it's
661:46 - taking forever to change these numbers. But if also on the other side of things, if the learning
661:52 - rate is too high, these updates might be too large. And our model might just explode. There's an
661:58 - actual problem in machine learning called exploding gradient problem, where the numbers just get
662:05 - too large. On the other side, there's also a vanishing gradients problem, where the gradients
662:10 - just go basically to zero too quickly. And then there's also change the loss function. But I feel
662:17 - like for now, sigmoid and binary cross entropy, pretty good, pretty standard. So we're going to
662:23 - have a look at some options here, add more layers and fit for longer, maybe changing the learning
662:28 - rate. But let's just add a little bit of color to what we've been talking about. Right now,
662:33 - we've fit the model to the data and made a prediction. I'm just going to step through this.
662:38 - Where are we up to? We've done this, we've done this, we've done these two, we've built a training
662:42 - loop, we've fit the model to the data, made a prediction, we've evaluated our model visually,
662:46 - and we're not happy with that. So we're up to number five, we're going to improve through
662:50 - experimentation. We don't need to use TensorBoard just yet, we're going to talk about this as our
662:54 - high level. TensorBoard is a tool or a utility from PyTorch, which helps you to monitor experiments.
663:01 - We'll see that later on. And then we'll get to this, we won't save our model until we've got one
663:05 - that we're happy with. And so if we look at what we've just talked about improving a model from a
663:10 - model's perspective, let's talk about the things we've talked about with some color this time. So
663:16 - say we've got a model here, this isn't the exact model that we're working with, but it's similar
663:21 - structure. We've got one, two, three, four layers, we've got a loss function BC with Logit's loss,
663:27 - we've got an optimizer, optimizer stochastic gradient descent, and if we did write some training code,
663:32 - this is 10 epochs. And then the testing code here, I've just cut it out because it wouldn't fit on
663:38 - the slide. Then if we wanted to go to a larger model, let's add some color here so we can highlight
663:43 - what's happening, adding layers. Okay, so this one's got one, two, three, four, five, six layers.
663:50 - And we've got another color here, which is I'd say this is like a little bit of a greeny blue
663:56 - increase the number of hidden units. Okay, so the hidden units are these features here.
664:01 - We've gone from 100 to 128 to 128. Remember, the out features of a previous layer have to line up
664:08 - with the in features of a next layer. Then we've gone to 256. Wow. So remember how I said multiples
664:14 - of eight are pretty good generally in deep learning? Well, this is where these numbers come from.
664:19 - And then what else do we have change slash add activation functions? We haven't seen this before
664:25 - and end up relu. If you want to jump ahead and have a look at what and end up relu is,
664:29 - how would you find out about it? Well, I just Google and end up relu. But we're going to have
664:35 - a look at what this is later on. We can see here that this one's got one, but this larger model has
664:41 - some relu's scattered between the linear layers. Hmm, maybe that's a hint. If we combine a linear
664:48 - layer with a relu, what's a relu layer? I'm not going to spoil this. We're going to find out
664:54 - later on change the optimization function. Okay. So we've got SGD. Do you recall how I said
665:00 - Adam is another popular one that works fairly well across a lot of problems as well. So Adam
665:05 - might be a better option for us here. The learning rate as well. So maybe this learning rate was a
665:11 - little too high. And so we've divided it by 10. And then finally, fitting for longer. So instead
665:16 - of 10 epochs, we've gone to 100. So how about we try to implement some of these with our own model
665:21 - to see if it improves what we've got going on here? Because frankly, like, this isn't
665:27 - satisfactory. We're trying to build a neural network here. Neural networks are supposed to be
665:30 - these models that can learn almost anything. And we can't even separate some blue dots from
665:35 - some red dots. So in the next video, how about we run through writing some code to do some of
665:41 - these steps here? In fact, if you want to try yourself, I'd highly encourage that. So I'd start
665:46 - with trying to add some more layers and add some more hitting units and fitting for longer. You can
665:51 - keep all of the other settings the same for now. But I'll see you in the next video. Welcome back.
665:59 - In the last video, we discussed some options to improve our model from a model perspective. And
666:05 - namely, we're trying to improve it so that the predictions are better, so that the patterns it
666:08 - learns better represent the data. So we can separate blue dots from red dots. And you might be wondering
666:14 - why we said from a model perspective here. So let me just write these down. These options are all
666:23 - from a models perspective, because they deal directly with the model, rather than the data.
666:36 - So there's another way to improve a models results is if the model was sound already,
666:41 - in machine learning and deep learning, you may be aware that generally if you have more data samples,
666:47 - the model learns or gets better results because it has more opportunity to learn. There's a few
666:53 - other ways to improve a model from a data perspective, but we're going to focus on improving a model
666:59 - from a models perspective. So, and because these options are all values we as machine learning
667:13 - engineers and data scientists can change, they are referred to as hyper parameters.
667:26 - So a little bit of an important distinction here. Parameters are the numbers within a model.
667:33 - The parameters here, like these values, the weights and biases are parameters,
667:37 - are the values a model updates by itself. Hyper parameters are what we as machine learning
667:43 - engineers and data scientists, such as adding more layers, more hidden units, fitting for longer
667:48 - number of epochs, activation functions, learning rate, loss functions are hyper parameters because
667:54 - they're values that we can change. So let's change some of the hyper parameters of our model.
668:01 - So we'll create circle model v1. We're going to import from nn.module as well. We could write this
668:08 - model using nn.sequential, but we're going to subclass nn.module for practice.
668:15 - Why would we use nn.sequential? Well, because as you'll see, our model is not too complicated,
668:21 - but we subclass nn.module. In fact, nn.sequential. So if we write here, nn.sequential is also a
668:31 - version of nn.module. But we subclass nn.module here for one for practice and for later on,
668:40 - if we wanted to, or if you wanted to make more complex models, you're going to see a subclass
668:45 - of nn.module a lot in the wild. So the first change we're going to update is the number
668:52 - of hidden units. So out features, I might write this down before we do it. Let's try and improve
669:01 - our model by adding more hidden units. So this will go from five and we'll increase it to 10.
669:14 - And we want to increase the number of layers. So we want to go from two to three. We'll add an
669:23 - extra layer and then increase the number of epochs. So we're going to go from 100 to 1,000. Now,
669:33 - what can you, we're going to put on our scientist hats for a second. What would be the problem with
669:39 - the way we're running this experiment? If we're doing all three things in one hit, why might that
669:45 - be problematic? Well, because we might not know which one offered the improvement if there is
669:52 - any improvement or degradation. So just to keep in mind going forward, I'm just doing this as an
669:57 - example of how we can change all of these. But generally, when you're doing machine learning
670:02 - experiments, you'd only like to change one value at a time and track the results. So that's called
670:10 - experiment tracking and machine learning. We're going to have a look at experiment tracking a
670:14 - little later on in the course, but just keep that in mind. A scientist likes to change one
670:20 - variable of what's going on so that they can control what's happening. But we're going to
670:25 - create this next layer here layer two. And of course, it takes the same number of out features as
670:32 - in features as the previous layer. This is two because why our X train has. Let's look at just
670:40 - the first five samples has two features. So now we're going to create self layer three, which
670:47 - equals an n dot linear. The in features here is going to be 10. Why? Because the layer above
670:53 - has out features equals 10. So what we've changed here so far is we've got hidden units previously
670:58 - in the zero of this model was five. And now we've got a third layout, which previously before was
671:05 - two. So these are two of our main changes here. And out features equals one, because why? Let's
671:12 - have a look at speaking of why. Our why is just one number. So remember the shapes, the input and
671:19 - output shapes of a model is one of the most important things in deep learning. We're going to see
671:23 - different values for the shapes later on. But because we're working with this data set, we're
671:28 - focused on two in features and one out feature. So now that we've got our layers prepared,
671:34 - what's next? Well, we have to override the forward method, because every subclass of
671:41 - an n dot module has to implement a forward method. So what are we going to do here? Well, we could,
671:49 - let me just show you one option. We could go z, which would be z for logits. Logits is actually
671:55 - represented by z, fun fact. But you could actually put any variable here. So this could be x one,
672:03 - or you could reset x if you wanted to. I just look putting a different one because it's a little
672:07 - less confusing for me. And then we could go update z by going self layer two. And then the,
672:14 - because z above is the output of layer one, it now goes into here. And then if we go z,
672:22 - again, equals self layer three, what's this going to take? It's going to take z from above.
672:28 - So this is saying, hey, give me x, put it through layer one, assign it to z. And then
672:33 - create a new variable z or override z with self layer two with z from before as the input. And
672:39 - then we've got z again, the output of layer two has the input for layer three. And then we could
672:44 - return z. So that's just passing our data through each one of these layers here. But a way that
672:51 - you can leverage speedups in PyTorch is to call them all at once. So layer three, and we're going
673:00 - to put self dot layer two. And this is generally how I'm going to write them. But it also behind
673:07 - the scenes, because it's performing all the operations at once, you leverage whatever speed
673:13 - ups you can get. Oh, this should be layer one. So it goes in order here. So what's happening?
673:20 - Well, it's computing the inside of the brackets first. So layer one, x is going through layer one.
673:26 - And then the output of x into layer one is going into layer two. And then the same again,
673:33 - for layer three. So this way, this way of writing operations, leverages, speed ups, where possible
673:47 - behind the scenes. And so we've done our Ford method there. We're just passing our data through
673:54 - layers with an extra hidden units, and an extra layer overall. So now let's create an instance of
674:01 - circle model v one, which we're going to set to model one. And we're going to write circle model
674:07 - v one. And we're going to send it to the target device, because we like writing device agnostic code.
674:14 - And then we're going to check out model one. So let's have a look at what's going on there.
674:18 - Beautiful. So now we have a three layered model with more hidden units. So I wonder if we trained
674:25 - this model for longer, are we going to get improvements here? So my challenge to you is we've already
674:31 - done these steps before. We're going to do them over the next couple of videos for completeness.
674:38 - But we need to what create a loss function. So I'll give you a hint. It's very similar to the one
674:45 - we've already used. And we need to create an optimizer. And then once we've done that, we need to
674:52 - write a training and evaluation loop for model one. So give that a shot. Otherwise, I'll see you
675:01 - in the next video. We'll do this all together. Welcome back. In the last video, we subclassed
675:09 - nn.module to create circle model V one, which is an upgrade on circle model V zero. In the
675:15 - fact that we added more hidden units. So from five to 10. And we added a whole extra layer.
675:23 - And we've got an instance of it ready to go. So we're up to in the workflow. We've got our data.
675:28 - Well, we haven't changed the data. So we've built our new model. We now need to pick a loss function.
675:33 - And I hinted at before that we're going to use the same loss function as before.
675:36 - The same optimizer. You might have already done all of these steps. So you may know whether this
675:41 - model works on our data set or not. But that's what we're going to work towards finding out in
675:45 - this video. So we've built our new model. Now let's pick a loss function and optimizer. We could
675:50 - almost do all of this with our eyes closed now, build a training loop, fit the model to the data,
675:54 - make a prediction and evaluate the model. We'll come back here. And let's set up a loss function.
676:00 - And by the way, if you're wondering, like, why would adding more features here, we've kind of
676:07 - hinted at this before. And why would an extra layer improve our model? Well, again, it's back
676:12 - to the fact that if we add more neurons, if we add more hidden units, and if we add more layers,
676:19 - it just gives our model more numbers to adjust. So look at what's going on here, layer one,
676:24 - layer two. Look how many more we have compared to model zero dot state date.
676:36 - We have all of these. This is model zero. And we just upgraded it. Look how many more we have
676:41 - from just adding an extra layer and more hidden units. So now we have our optimizer can change
676:47 - these values to hopefully create a better representation of the data we're trying to fit.
676:53 - So we just have more opportunity to learn patterns in our target data set. So that's the theory
677:00 - behind it. So let's get rid of ease. Let's create a loss function. What are we going to use? Well,
677:06 - we're going to use nn dot BCE with logit's loss. And our optimizer is going to be what? We're
677:15 - going to keep that as the same as before, torch dot opt in dot SGD. But we have to be aware that
677:21 - because we're using a new model, we have to pass in params of model one. These are the parameters
677:28 - we want to optimize. And the LR is going to be 0.1. Is that the same LR we use before learning
677:34 - rate? 0.1. Oh, potentially that our learning rate may be too big. 0.1. Where do we create our
677:42 - optimizer? So we've written a lot of code here. Optimizer. There we go. 0.1. That's all right.
677:48 - So we'll keep it at 0.1 just to keep as many things the same as possible. So we're going to set up
677:54 - torch dot manual seed 42 to make training as reproducible as possible torch dot CUDA dot manual
678:02 - seed 42. Now, as I said before, don't worry too much if your numbers aren't exactly the same as mine.
678:10 - The direction is more important, whether it's good or bad direction. So now let's set up epochs.
678:17 - We want to train for longer this time as well. So 1000 epochs. This is one of our three improvements
678:25 - that we're trying to do. Adding more hidden units, increase the number of layers and increase the
678:30 - number of epochs. So we're going to give our model 1000 looks at the data to try and improve
678:35 - its patterns. So put data on the target device. We want to write device agnostic code. And yes,
678:43 - we've already done this, but we're going to write it out again for practice because even though we
678:49 - could functionize a lot of this, it's good while we're in still the foundation stages to practice
678:54 - what's going on here, because I want you to be able to do this with your eyes closed before we
679:00 - start to functionize it. So put the training data and the testing data to the target device,
679:06 - whatever it is, CPU or GPU. And then we're going to, well, what's our song? For an epoch in range.
679:16 - Let's loop through the epochs. We're going to start off with training. What do we do for training? Well,
679:20 - we set model one to train. And then what's our first step? Well, we have to forward pass. What's
679:27 - our outputs of the model? Well, the raw outputs of a model are logits. So model one, we're going
679:33 - to pass it the training data. We're going to squeeze it so that we get rid of an extra one
679:37 - dimension. If you don't believe me that we would like to get rid of that one dimension,
679:41 - try running the code without that dot squeeze. And why pred equals torch dot round.
679:48 - And torch dot sigmoid, why we're calling sigmoid on our logits to go from logits to prediction
679:57 - probabilities to prediction labels. And then what do we do next? Well, we calculate the loss
680:09 - slash accuracy to here. And remember, accuracy is optional, but loss is not optional. So we're
680:18 - going to pass in here, our loss function is going to take in. I wonder if it'll work with just straight
680:23 - up why pred? I don't think it will because we're using we need logits in here. Why logits and why
680:30 - train? Because why? Oh, Google collab correcting the wrong thing. We have why logits because we're
680:37 - using BCE with logits loss here. So let's keep pushing forward. We want our accuracy now,
680:44 - which is our accuracy function. And we're going to pass in the order here, which is the reverse
680:49 - of above, a little confusing, but I've kept the evaluation function in the same order as
680:55 - scikit loan. Why pred equals y pred? Three, we're going to zero the gradients of the optimizer,
681:03 - optimizer zero grad. And you might notice that we've started to pick up the pace a little.
681:08 - That is perfectly fine. If I'm typing too fast, you can always slow down the video,
681:13 - or you could just watch what we're doing and then code it out yourself afterwards,
681:17 - the code resources will always be available. We're going to take the last backward
681:22 - and perform back propagation. The only reason we're going faster is because we've covered
681:28 - these steps. So anything that we sort of spend time here, we've covered in a previous video,
681:34 - optimizer step. And this is where the adjustments to all of our models parameters are going to take
681:39 - place to hopefully create a better representation of the data. And then we've got testing. What's
681:46 - the first step that we do in testing? Well, we call model one dot a vowel to put it in evaluation
681:51 - mode. And because we're making predictions, we're going to turn on torch inference mode
681:55 - predictions. I call them predictions. Some other places call it inference.
682:01 - Remember machine learning has a lot of different names for the same thing.
682:05 - Forward pass. So we're going to create the test logits here. Equals model one X test.
682:11 - And we're going to squeeze them because we won't don't want the extra one dimension. Just going to
682:16 - add some code cells here so that we have more space and I'm typing in the middle of the screen.
682:22 - Then I'm going to put in test pred here. How do we get from logits to predictions? Well,
682:26 - we go torch dot round. And then we go torch dot sigmoid y sigmoid because we're working with a
682:32 - binary classification problem. And to convert logits from a binary classification problem
682:37 - to prediction probabilities, we use the sigmoid activation function. And then we're going to
682:43 - calculate the loss. So how wrong is our model on the test data? So test last equals loss function.
682:53 - We're going to pass it in the test logits. And then we're going to pass it in Y test for the ideal
683:00 - labels. And then we're going to also calculate test accuracy. And test accuracy is going to
683:06 - take in Y true equals Y test. So the test labels and Y pred equals test pred. So the test predictions
683:17 - test predictions here. And our final step is to print out what's happening. So print out what's
683:25 - happening. Oh, every tutorial needs a song. If I could, I'd teach everything with song.
683:31 - Song and dance. So because we're training for 1000 epochs, how about every 100 epochs we print
683:38 - out something. So print f string, and we're going to write epoch in here. So we know what epoch our
683:45 - models on. And then we're going to print out the loss. Of course, this is going to be the training
683:50 - loss. Because the test loss has test at the front of it. And then accuracy here. Now, of course,
683:57 - this is going to be the training accuracy. We go here. And then we're going to pipe. And we're
684:05 - going to print out the test loss. And we want the test loss here. We're going to take this to five
684:11 - decimal places. Again, when we see the printouts of the different values, do not worry too much
684:17 - about the exact numbers on my screen appearing on your screen, because that is inherent to the
684:24 - randomness of machine learning. So have we got the direction is more important? Have we got,
684:31 - we need a percentage sign here, because that's going to be a bit more complete for accuracy.
684:35 - Have we got any errors here? I don't know. I'm just, we've just all coded this free hand,
684:40 - right? There's a lot of code going on here. So we're about to train our next model,
684:44 - which is the biggest model we've built so far in this course, three layers, 10 hidden units on
684:49 - each layer. Let's see what we've got. Three, two, one, run. Oh, what? What? A thousand epochs,
685:02 - an extra hidden layer, more hidden units. And we still, our model is still basically a coin toss.
685:08 - 50%. Now, this can't be for real. Let's plot the decision boundary.
685:12 - Plot the decision boundary. To find out, let's get a bit visual. Plot figure, actually, to prevent us
685:22 - from writing out all of the plot code, let's just go up here, and we'll copy this. Now, you know,
685:28 - I'm not the biggest fan of copying code. But for this case, we've already written it. So there's
685:32 - nothing really new here to cover. And we're going to just change this from model zero to model one,
685:38 - because why it's our new model that we just trained. And so behind the scenes, plot decision
685:42 - boundary is going to make predictions with the target model on the target data set and put it
685:48 - into a nice visual representation for us. Oh, I said nice visual representation. What does this
685:56 - look like? We've just got a coin toss on our data set. Our model is just again, it's trying
686:01 - to draw a straight line to separate circular data. Now, why is this? Our model is based on linear,
686:08 - is our data nonlinear? Hmm, maybe I've revealed a few of my tricks. I've done a couple of reveals
686:18 - over the past few videos. But this is still quite annoying. And it can be fairly annoying
686:24 - when you're training models and they're not working. So how about we verify that this model
686:30 - can learn anything? Because right now it's just basically guessing for our data set.
686:36 - So this model looks a lot like the model we built in section 01. Let's go back to this.
686:42 - This is the learn pytorch.io book pytorch workflow fundamentals. Where did we create a model model
686:48 - building essentials? Where did we build a model? Linear regression model? Yeah, here. And then
686:55 - dot linear. But we built this model down here. So all we've changed from 01 to here is we've added
687:05 - a couple of layers. The forward computation is quite similar. If this model can learn something
687:11 - on a straight line, can this model learn something on a straight line? So that's my challenge to you
687:18 - is grab the data set that we created in this previous notebook. So data, you could just
687:25 - reproduce this in exact data set. And see if you can write some code to fit the model that we built
687:31 - here. This one here on the data set that we created in here. Because I want to verify that
687:40 - this model can learn anything. Because right now it seems like it's not learning anything at all.
687:46 - And that's quite frustrating. So give that a shot. And I'll see you in the next video.
687:50 - Welcome back. In the past few videos, we've tried to build a model to separate the blue from red
687:58 - dots yet. Our previous efforts have proven futile, but don't worry. We're going to get there. I promise
688:04 - you we're going to get there. And I may have a little bit of inside information here. But we're
688:08 - going to build a model to separate these blue dots from red dots, a fundamental classification model.
688:14 - And we tried a few things in the last couple of videos, such as training for longer, so more epochs.
688:20 - We added another layer. We increased the hidden units because we learned of a few methods to
688:26 - improve a model from a model perspective, such as upgrading the hyperparameters, such as number
688:30 - of layers, more hidden units, fitting for longer, changing the activation functions,
688:36 - changing the learning rate, we haven't quite done that one yet, and changing the loss function.
688:41 - One way that I like to troubleshoot problems is I'm going to put a subheading here, 5.1.
688:47 - We're going to prepare or preparing data to see if our model can fit a straight line.
688:56 - So one way to troubleshoot, this is my trick for troubleshooting problems, especially neural
689:06 - networks, but just machine learning in general, to troubleshoot a larger problem is to test out
689:13 - a smaller problem. And so why is this? Well, because we know that we had something working
689:21 - in a previous section, so 01, PyTorch, workflow fundamentals, we built a model here that worked.
689:29 - And if we go right down, we know that this linear model can fit a straight line. So we're going
689:36 - to replicate a data set to fit a straight line to see if the model that we're building here
689:40 - can learn anything at all, because right now it seems like it can't. It's just tossing a coin
689:46 - displayed between our data here, which is not ideal. So let's make some data. But yeah, this is the,
689:54 - let's create a smaller problem, one that we know that works, and then add more complexity to try
690:00 - and solve our larger problem. So create some data. This is going to be the same as notebook 01.
690:05 - And I'm going to set up weight equals 0.7 bias equals 0.3. We're going to move quite quickly
690:13 - through this because we've seen this in module one, but the overall takeaway from this is we're
690:19 - going to see if our model works on any kind of problem at all, or do we have something fundamentally
690:25 - wrong, create data. We're going to call it x regression, because it's a straight line, and we
690:33 - want it to predict a number rather than a class. So you might be thinking, oh, we might have to change
690:38 - a few things of our model architecture. Well, we'll see that in a second dot unsqueeze. And we're
690:47 - going to go on the first dimension here or dim equals one. And why regression, we're going to use
690:53 - the linear regression formula as well, wait times x, x regression, that is, because we're working
691:00 - with a new data set here, plus the bias. So this is linear regression formula. Without epsilon. So it's a simplified version of linear regression, but the same formula that we've seen in a previous section. So now let's check the data. Nothing we really haven't covered here, but we're going to do a sanity check on it to make sure that we're dealing with what we're dealing with.
691:29 - What we're dealing with is not just a load of garbage. Because it's all about the data and machine learning. I can't stress to you enough. That's the data explorer's motto is to visualize, visualize, visualize. Oh, what did we get wrong here? Unsqueeze. Did you notice that typo? Why didn't you say something? I'm kidding. There we go. Okay, so we've got 100 samples of x. We've got a different step size here, but that's all right. Let's have a little bit of fun with this. And we've got one x-value, which is, you know, a little bit more.
691:58 - One x value per y value is a very similar data set to what we use before. Now, what do we do once we have a data set? Well, if we haven't already got training and test splits, we better make them. So create train and test splits.
692:14 - And then we're going to go train split. We're going to use 80% equals int 0.8 times the length of, or we could just put 100 in there.
692:27 - But we're going to be specific here. And then we're going to go x train regression, y train regression equals. What are these equal? Well, we're going to go on x regression.
692:40 - And we're going to index up to the train split on the x. And then for the y, y regression, we're going to index up to the train split.
692:55 - Wonderful. And then we can do the same on the test or creating the test data. Nothing really new here that we need to discuss. We're creating training and test sets. What do they do for each of them?
693:09 - Well, the model is going to hopefully learn patterns in the training data set that is able to model the testing data set. And we're going to see that in a second.
693:21 - So if we check the length of each, what do we have? Length x train regression. We might just check x train x test regression. What do we have here?
693:37 - And then we're going to go length y train regression. Long variable names here. Excuse me for that. But we want to keep it separate from our already existing x and y data. What values do we have here?
693:52 - 80, 20, 80, 20, beautiful. So 80 training samples to 100 testing samples. That should be enough. Now, because we've got our helper functions file here. And if you don't have this, remember, we wrote some code up here before to where is it?
694:12 - To download it from the course GitHub, and we imported plot predictions from it. Now, if we have a look at helper functions.py, it contains the plot predictions function that we created in the last section, section 0.1. There we go. Plot predictions.
694:30 - So we're just running this exact same function here, or we're about to run it. It's going to save us from re typing out all of this. That's the beauty of having a helper functions.py file.
694:41 - So if we come down here, let's plot our data to visually inspected. Right now, it's just numbers on a page. And we're not going to plot really any predictions because we don't have any predictions yet.
694:52 - But we'll pass in the train data is equal to X train regression. And then the next one is the train labels, which is equal to Y train regression.
695:06 - And then we have the test data, which is equal to X test regression. And then we have the test labels. Now, I think this should be labels too. Yeah, there we go. Y test progression might be proven wrong as we try to run this function.
695:27 - Okay, there we go. So we have some training data and we have some testing data. Now, do you think that our model model one, we have a look what's model one could fit this data.
695:42 - Does it have the right amount of in and out features? We may have to adjust these slightly. So I'd like you to think about that. Do we have to change the input features to our model for this data set?
695:53 - And do we have to change the out features of our model for this data set? We'll find out in the next video.
696:00 - Welcome back. We're currently working through a little side project here, but really the philosophy of what we're doing. We just created a straight line data set because we know that we've built a model in the past back in section 01 to fit a straight line data set.
696:16 - And why are we doing this? Well, because the model that we've built so far is not fitting or not working on our circular data set here on our classification data set.
696:26 - And so one way to troubleshoot a larger problem is to test out a smaller problem first. So later on, if you're working with a big machine learning data set, you'd probably start with a smaller portion of that data set first.
696:38 - Likewise, with a larger machine learning model, instead of starting with a huge model, you'll start with a small model.
696:46 - So we're taking a step back here to see if our model is going to learn anything at all on a straight line data set so that we can improve it for a non-straight line data set.
696:55 - And there's another hint. Oh, we're going to cover it in a second. I promise you. But let's see how now we can adjust model one to fit a straight line.
697:07 - And I should do the question at the end of last video. Do we have to adjust the parameters of model one in any way shape or form to fit this straight line data?
697:16 - And you may have realized or you may not have that our model one is set up for our classification data, which has two X input features.
697:26 - Whereas this data, if we go X train regression, how many input features do we have? We just get the first sample.
697:37 - There's only one value. Or maybe we get the first 10. There's only one value per, let's remind ourselves, this is input and output shapes, one of the most fundamental things in machine learning and deep learning.
697:52 - And trust me, I still get this wrong all the time. So that's why I'm harping on about it. We have one feature per one label. So we have to adjust our model slightly.
698:01 - We have to change the end features to be one instead of two. The out features can stay the same because we want one number to come out.
698:08 - So what we're going to do is code up a little bit different version of model one. So same architecture as model one. But using NN dot sequential, we're going to do the faster way of coding a model here.
698:23 - Let's create model two and NN dot sequential. The only thing that's going to change is the number of input features.
698:30 - So this will be the exact same code as model one. And the only difference, as I said, will be features or in features is one. And then we'll go out features equals 10.
698:42 - So 10 hidden units in the first layer. And of course, the second layer, the number of features here has to line up with the out features of the previous layer.
698:51 - This one's going to output 10 features as well. So we're scaling things up from one feature to 10 to try and give our model as much of a chance or as many parameters as possible.
699:01 - Of course, we could make this number quite large. We could make it a thousand features if we want. But there is an upper bound on these things.
699:08 - And I'm going to let you find those in your experience as a machine learning engineer and a data scientist.
699:14 - But for now, we're keeping it nice and small. So we can run as many experiments as possible. Beautiful. Look at that. We've created a sequential model. What happens with NN dot sequential?
699:23 - Data goes in here, passes through this layer. Then it passes through this layer. Then it passes through this layer. And what happens when it goes through the layer?
699:31 - It triggers the layers forward method, the internal forward method. In the case of NN dot linear, we've seen it. It's got the linear regression formula.
699:39 - So if we go NN dot linear, it performs this mathematical operation, the linear transformation. But we've seen that before. Let's keep pushing forward.
699:50 - Let's create a loss and an optimizer loss and optimize. We're going to work through our workflow. So loss function, we have to adjust this slightly.
700:00 - We're going to use the L1 loss because why we're dealing with a regression problem here rather than a classification problem. And our optimizer, what can we use for our optimizer?
700:10 - How about we bring in just the exact same optimizer SGD that we've been using for our classification data. So model two dot params or parameters.
700:21 - Always get a little bit confused. And we'll give it an LR of 0.1 because that's what we've been using so far. This is the params here.
700:30 - So we want our optimizer to optimize our model two parameters here with a learning rate of 0.1. The learning rate is what?
700:38 - The amount each parameter will be or the multiplier that will be applied to each parameter each epoch.
700:47 - So now let's train the model. Do you think we could do that in this video? I think we can. So we might just train it on the training data set and then we can evaluate it on the test data set separately.
701:00 - So we'll set up both manual seeds, CUDA and because we've set our model to the device up here. So it should be on the GPU or whatever device you have active.
701:13 - So set the number of epochs. How many epochs should we set? Well, we set a thousand before, so we'll keep it at that.
701:21 - epochs equals a thousand. And now we're getting really good at this sort of stuff here. Let's put our data. Put the data on the target device.
701:30 - And I know we've done a lot of the similar steps before, but there's a reason for that. I've kept all these in here because I'd like you to buy the end of this course is to sort of know all of this stuff off by heart.
701:42 - And even if you don't know it all off my heart, because trust me, I don't, you know where to look.
701:47 - So X train regression, we're going to send this to device. And then we're going to go Y train regression, just a reminder or something to get you to think while we're writing this code.
702:00 - What would happen if we didn't put our data on the same device as a model? We've seen that error come up before, but what happens?
702:09 - Well, I've just kind of given away, haven't you Daniel? Well, that was a great question. Our code will air off.
702:16 - Oh, well, don't worry. There's plenty of questions I've been giving you that I haven't given the answer to yet.
702:22 - Device a beautiful. We've got a device agnostic code for the model and for the data. And now let's loop through epochs.
702:30 - So train. We're going to for epoch in range epochs for an epoch in a range. Do the forward pass.
702:39 - Calculate the loss. So Y pred equals model two. This is the forward pass. X train regression.
702:49 - It's all going to work out hunky Dory because our model and our data are on the same device loss equals what we're going to bring in our loss function.
702:58 - Then we're going to compare the predictions to Y train regression to the Y labels. What do we do next?
703:09 - Optimize a zero grad. Optimize a dot zero grad. We're doing all of this with our comments. Look at us go.
703:16 - Loss backward and what's next? Optimize a step, step, step. And of course, we could do some testing here.
703:24 - Testing. We'll go model two dot a vowel. And then we'll go with torch dot inference mode.
703:33 - We'll do the forward pass. We'll create the test predictions equals model two dot X test regression.
703:41 - And then we'll go the test loss equals loss FN on the test predictions and versus the Y test labels.
703:51 - Beautiful. Look at that. We've just done an optimization loop, something we spent a whole hour on before, maybe even longer, in about ten lines of code.
704:00 - And of course, we could shorten this by making these a function. But we're going to see that later on.
704:05 - I'd rather us give a little bit of practice while this is still a bit fresh. Print out what's happening.
704:13 - Let's print out what's happening. What should we do? So because we're training for a thousand epochs, I like the idea of printing out something every 100 epochs.
704:21 - That should be about enough of a step. Epoch. What do we got? We'll put in the epoch here with the F string and then we'll go to loss, which will be loss.
704:33 - And maybe we'll get the first five of those five decimal places that is. We don't have an accuracy, do we?
704:42 - Because we're working with regression. And we'll get the test loss out here. And that's going to be.5F as well.
704:50 - Beautiful. Have we got any mistakes? I don't think we do. We didn't even run this code cell before. We'll just run these three again, see if we got...
704:58 - Look at that. Oh my goodness. Is our loss... Our loss is going down.
705:04 - So that means our model must be learning something.
705:09 - Now, what if we adjusted the learning rate here? I think if we went 0.01 or something, will that do anything?
705:17 - Oh, yes. Look how low our loss gets on the test data set. But let's confirm that. We've got to make some predictions.
705:25 - Well, maybe we should do that in the next video. Yeah, this one's getting too long. But how good's that?
705:30 - We created a straight line data set and we've created a model to fit it. We set up a loss and an optimizer already.
705:37 - And we put the data on the target device. We trained and we tested so our model must be learning something.
705:43 - But I'd like you to give a shot at confirming that by using our plot predictions function.
705:48 - So make some predictions with our trained model. Don't forget to turn on inference mode. And we should see some red dots here fairly close to the green dots on the next plot.
705:58 - Give that a shot and I'll see you in the next video.
706:02 - Welcome back. In the last video, we did something very exciting. We solved a smaller problem that's giving us a hint towards our larger problem.
706:11 - So we know that the model that we've previously been building, model two, has the capacity to learn something.
706:17 - Now, how did we know that? Well, it's because we created this straight line data set. We replicated the architecture that we used for model one.
706:25 - Recall that model one didn't work very well on our classification data. But with a little bit of an adjustment such as changing the number of in features.
706:35 - And not too much different training code except for a different loss function because, well, we use MAE loss with regression data.
706:44 - And we changed the learning rate slightly because we found that maybe our model could learn a bit better.
706:50 - And again, I'd encourage you to play around with different values of the learning rate. In fact, anything that we've changed, try and change it yourself and just see what happens.
706:59 - That's one of the best ways to learn what goes on with machine learning models.
707:04 - But we trained for the same number of epochs. We set up device agnostic code. We did a training and testing loop.
707:10 - Look at this looks. Oh, my goodness. Well done. And our loss went down.
707:15 - So, hmm. What does that tell us? Well, it tells us that model two or the specific architecture has some capacity to learn something.
707:23 - So we must be missing something. And we're going to get to that in a minute, I promise you.
707:28 - But we're just going to confirm that our model has learned something and it's not just numbers on a page going down by getting visual.
707:35 - So turn on. We're going to make some predictions and plot them. And you may have already done this because I issued that challenge at the last of at the end of the last video.
707:43 - So turn on evaluation mode. Let's go model two dot eval. And let's make predictions, which are also known as inference.
707:53 - And we're going to go with torch dot inference mode inference mode with torch dot inference mode.
708:02 - Make some predictions. We're going to save them as why preds and we're going to use model two and we're going to pass it through ex test regression.
708:10 - This should all work because we've set up device agnostic code, plot data and predictions.
708:16 - To do this, we can of course use our plot predictions function that we imported via our helper functions dot pi function.
708:23 - The code for that is just a few cells above if you'd like to check that out.
708:27 - But let's set up the train data here. Train data parameter, which is x train regression.
708:33 - And my goodness. Google collab. I'm already typing fast enough. You don't have to slow me down by giving me the wrong auto corrects train label equals y train regression.
708:48 - And then we're going to pass in our test data equals ex test regression.
708:53 - And then we're going to pass in test labels, which is why test regression got too many variables going on here. My goodness gracious.
709:03 - We could have done better with naming, but this will do for now is why preds.
709:08 - And then if we plot this, what does it look like? Oh, no, we got an error.
709:13 - Now secretly, I kind of knew that that was coming ahead of time. That's the advantage of being the host of this machine learning cooking show. So type error. How do we fix this?
709:23 - Remember how I asked you in one of the last videos what would happen if our data wasn't on the same device as our model? Well, we get an error, right? But this is a little bit different as well.
709:34 - We've seen this one before. We've got CUDA device type tensa to NumPy. Where is this coming from? Well, because our plot predictions function uses mapplotlib.
709:45 - And behind the scenes, mapplotlib references NumPy, which is another numerical computing library. However, NumPy uses a CPU rather than the GPU.
709:55 - So we have to call dot CPU, this helpful message is telling us, call tensa dot CPU before we use our tensors with NumPy. So let's just call dot CPU on all of our tensor inputs here and see if this solves our problem.
710:11 - Wonderful. Looks like it does. Oh my goodness. Look at those red dots so close. Well, okay. So this just confirms our suspicions. What we kind of already knew is that our model did have some capacity to learn.
710:22 - It's just the data set when we changed the data set it worked. So, hmm. Is it our data that our model can't learn on? Like this circular data, or is the model itself?
710:34 - Remember, our model is only comprised of linear functions. What is linear? Linear is a straight line, but is our data made of just straight lines?
710:44 - I think it's got some nonlinearities in there. So the big secret I've been holding back will reveal itself starting from the next video. So if you want a head start of it, I'd go to torch and end.
710:58 - And if we have a look at the documentation, we've been speaking a lot about linear functions. What are these nonlinear activations? And I'll give you another spoiler. We've actually seen one of these nonlinear activations throughout this notebook.
711:15 - So go and check that out. See what you can infer from that. And I'll see you in the next video. Let's get started with nonlinearities. Welcome back.
711:27 - In the last video, we saw that the model that we've been building has some potential to learn. I mean, look at these predictions. You could get a little bit better, of course, get the red dots on top of the green dots.
711:38 - But we're just going to leave that the trend is what we're after. Our model has some capacity to learn, except this is straight line data.
711:47 - And we've been hinting at it a fair bit is that we're using linear functions. And if we look up linear data, what does it look like?
711:57 - Well, it has a quite a straight line. If we go linear and just search linear, what does this give us? Linear means straight. There we go, straight.
712:05 - And then what happens if we search for nonlinear? I kind of hinted at this as well. Nonlinear. Oh, we get some curves. We get curved lines.
712:14 - So linear functions. Straight. Nonlinear functions. Hmm.
712:20 - Now, this is one of the beautiful things about machine learning. And I'm not sure about you, but when I was in high school, I kind of learned a concept called line of best fit, or y equals mx plus c, or
712:34 - y equals mx plus b. And it looks something like this. And then if you wanted to go over these, you use quadratic functions and a whole bunch of other stuff.
712:41 - But one of the most fundamental things about machine learning is that we build neural networks and deep down neural networks are just a combination.
712:51 - It could be a large combination of linear functions and nonlinear functions.
712:56 - So that's why in torch.nn, we have nonlinear activations and we have all these other different types of layers. But essentially, what they're doing deep down is combining straight lines with, if we go back up to our data, non straight lines.
713:11 - So, of course, our model didn't work before because we've only given it the power to use linear lines. We've only given it the power to use straight lines.
713:21 - But our data is what? It's curved. Although it's simple, we need nonlinearity to be able to model this data set.
713:29 - And now, let's say we were building a pizza detection model. So let's look up some images of pizza, one of my favorite foods, images.
713:38 - Pizza, right? So could you model pizza with just straight lines?
713:43 - You're thinking, Daniel, you can't be serious. A computer vision model doesn't look for just straight lines in this. And I'd argue that, yes, it does, except we also add some curved lines in here.
713:53 - That's the beauty of machine learning. Could you imagine trying to write the rules of an algorithm to detect that this is a pizza? Maybe you could put in, oh, it's a curve here.
714:02 - And if you see red, no, no, no, no. Imagine if you're trying to do a hundred different foods. Your program would get really large. Instead, we give our machine learning models, if we come down to the model that we created.
714:14 - We give our deep learning models the capacity to use linear and nonlinear functions. We haven't seen any nonlinear layers just yet.
714:22 - Or maybe we've hinted at some, but that's all right. So we stack these on top of each other, these layers.
714:27 - And then the model figures out what patterns in the data it should use, what lines it should draw to draw patterns to not only pizza, but another food such as sushi.
714:38 - If we wanted to build a food image classification model, it would do this. The principle remains the same. So the question I'm going to pose to you, we'll get out of this, is, we'll come down here.
714:50 - We've unlocked the missing piece or about to. We're going to cover it over the next couple of videos, the missing piece of our model.
714:58 - And this is a big one. This is going to follow you out throughout all of machine learning and deep learning, nonlinearity.
715:05 - So the question here is, what patterns could you draw if you were given an infinite amount of straight and non straight lines?
715:25 - Or in machine learning terms, an infinite amount, but really it is finite. By infinite in machine learning terms, this is a technicality.
715:39 - It could be a million parameters. It could be as we've got probably a hundred parameters in our model.
715:45 - So just imagine a large amount of straight and non straight lines, an infinite amount of linear and nonlinear functions.
715:56 - You could draw some pretty intricate patterns, couldn't you? And that's what gives machine learning and especially neural networks the capacity to not only fit a straight line here, but to separate two different circles.
716:10 - But also to do crazy things like drive a self-driving car, or at least power the vision system of a self-driving car.
716:19 - Of course, after that, you need some programming to plan what to actually do with what you see in an image.
716:24 - But we're getting ahead of ourselves here. Let's now start diving into nonlinearity.
716:29 - And the whole idea here is combining the power of linear and nonlinear functions.
716:35 - Straight lines and non straight lines. Our classification data is not comprised of just straight lines. It's circles, so we need nonlinearity here.
716:44 - So recreating nonlinear data, red and blue circles. We don't need to recreate this, but we're going to do it anyway for completeness.
716:54 - So let's get a little bit of a practice. Make and plot data. This is so that you can practice the use of nonlinearity on your own.
717:01 - And that plot little bit dot pie plot as PLT. We're going to go a bit faster here because we've covered this code above.
717:09 - So import make circles. We're just going to recreate the exact same circle data set that we've created above.
717:15 - Number of samples. We'll create a thousand. And we're going to create x and y equals what?
717:21 - Make circles. Pass it in number of samples. Beautiful.
717:25 - Colab, please. I wonder if I can turn off autocorrect and colab. I'm happy to just see all of my errors in the flesh. See? Look at that. I don't want that.
717:33 - I want noise like that. Maybe I'll do that in the next video. We're not going to spend time here looking around how to do it.
717:40 - We can work that out on the fly later. For now, I'm too excited to share with you the power of nonlinearity.
717:46 - So here, x, we're just going to plot what's going on. We've got two x features and we're going to color it with the flavor of y because we're doing a binary classification.
717:55 - And we're going to use one of my favorite C maps, which is color map. And we're going to go PLT dot CM for C map and red blue.
718:08 - What do we get?
718:10 - Okay, red circle, blue circle. Hey, is it the same color as what's above? I like this color better.
718:19 - Did we get that right up here?
718:23 - Oh, my goodness. Look how much code we've written. Yeah, I like the other blue. I'm going to bring this down here.
718:28 - It's all about aesthetics and machine learning. It's not just numbers on a page, don't you? How could you be so crass? Let's go there.
718:37 - Okay, that's better color red and blue. That's small lively, isn't it? So now let's convert to train and test.
718:43 - And then we can start to build a model with nonlinearity. Oh, this is so good.
718:47 - Okay, convert data to tenses and then to train and test splits. Nothing we haven't covered here before.
718:58 - So import torch, but it never hurts to practice code, right? Import torch from sklearn dot model selection.
719:08 - Import train test split so that we can split our red and blue dots randomly. And we're going to turn data into tenses.
719:18 - And we'll go X equals torch from NumPy and we'll pass in X here. And then we'll change it into type torch dot float.
719:28 - Why do we do this? Well, because, oh, my goodness, autocorrect. It's getting the best of me here.
719:33 - You know, watching me live code this stuff and battle with autocorrect. That's what this whole course is.
719:38 - And we're really teaching pie torch. Am I just battling with Google collab's autocorrect?
719:44 - We are turning it into torch dot float with a type here because why NumPy's default, which is what makes circles users behind the scenes.
719:52 - NumPy is actually using a lot of other machine learning libraries, pandas, built on NumPy, scikit learn, does a lot of NumPy.
719:59 - Matplotlib, NumPy. That's just showing there. What's the word? Is it ubiquitous, ubiquity? I'm not sure, maybe.
720:06 - If not, you can correct me. The ubiquity of NumPy.
720:10 - And test sets, but we're using pie torch to leverage the power of autograd, which is what powers our gradient descent.
720:17 - And the fact that it can use GPUs.
720:21 - So we're creating training test splits here with train test split X Y.
720:30 - And we're going to go test size equals 0.2. And we're going to set random.
720:36 - Random state equals 42. And then we'll view our first five samples. Are these going to be?
720:46 - Tenses. Fingers crossed. We haven't got an error. Beautiful. We have tenses here.
720:52 - Okay. Now we're up to the exciting part. We've got our data set back.
720:56 - I think it's time to build a model with nonlinearity.
720:59 - So if you'd like to peek ahead, check out TorchNN again. This is a little bit of a spoiler.
721:06 - Go into the nonlinear activation. See if you can find the one that we've already used. That's your challenge.
721:12 - Can you find the one we've already used? And go into here and search what is our nonlinear function.
721:21 - So give that a go and see what comes up. I'll see you in the next video.
721:28 - Welcome back. Now put your hand up if you're ready to learn about nonlinearity.
721:34 - And I know I can't see your hands up, but I better see some hands up or I better feel some hands up
721:38 - because my hands up because nonlinearity is a magic piece of the puzzle that we're about to learn about.
721:44 - So let's title this section building a model with nonlinearity.
721:50 - So just to re-emphasize linear equals straight lines and in turn nonlinear equals non-straight lines.
722:03 - And I left off the end of the last video, giving you the challenge of checking out the TorchNN module,
722:09 - looking for the nonlinear function that we've already used.
722:13 - Now where would you go to find such a thing and oh, what do we have here? Nonlinear activations.
722:19 - And there's going to be a fair few things here, but essentially all of the modules within TorchNN
722:27 - are either some form of layer in a neural network if we recall.
722:31 - Let's go to a neural network. We've seen the anatomy of a neural network.
722:35 - Generally you'll have an input layer and then multiple hidden layers and some form of output layer.
722:41 - Well, these multiple hidden layers can be almost any combination of what's in TorchNN.
722:49 - And in fact, they can almost be any combination of function you could imagine.
722:53 - Whether they work or not is another question.
722:57 - But PyTorch implements some of the most common layers that you would have as hidden layers.
723:02 - And they might be pooling layers, padding layers, activation functions.
723:07 - And they all have the same premise. They perform some sort of mathematical operation on an input.
723:14 - And so if we look into the nonlinear activation functions, you might have find an n dot sigmoid.
723:22 - Where have we used this before? There's a sigmoid activation function in math terminology.
723:27 - It takes some input x, performs this operation on it.
723:31 - And here's what it looks like if we did it on a straight line, but I think we should put this in practice.
723:36 - And if you want an example, well, there's an example there.
723:39 - All of the other nonlinear activations have examples as well.
723:43 - But I'll let you go through all of these in your own time.
723:46 - Otherwise we're going to be here forever.
723:48 - And then dot relu is another common function.
723:50 - We saw that when we looked at the architecture of a classification network.
723:54 - So with that being said, how about we start to code a classification model with nonlinearity.
724:02 - And of course, if you wanted to, you could look up what is a nonlinear function.
724:08 - If you wanted to learn more, nonlinear means the graph is not a straight line.
724:12 - Oh, beautiful. So that's how I'd learn about nonlinear functions.
724:16 - But while we're here together, how about we write some code.
724:20 - So let's go build a model with nonlinear activation functions.
724:28 - And just one more thing before, just to re-emphasize what we're doing here.
724:33 - Before we write this code, I've got, I just remembered, I've got a nice slide,
724:38 - which is the question we posed in the previous video, the missing piece, nonlinearity.
724:43 - But the question I want you to think about is what could you draw if you had an unlimited amount of straight,
724:50 - in other words, linear, and non-straight, nonlinear line.
724:54 - So we've seen previously that we can build a model, a linear model to fit some data that's in a straight line, linear data.
725:02 - But when we're working with nonlinear data, well, we need the power of nonlinear functions.
725:09 - So this is circular data. And now, this is only a 2D plot, keep in mind there.
725:14 - Whereas neural networks and machine learning models can work with numbers that are in hundreds of dimensions,
725:19 - impossible for us humans to visualize, but since computers love numbers, it's a piece of cake to them.
725:25 - So from torch, import, and then we're going to create our first neural network with nonlinear activations.
725:32 - This is so exciting. So let's create a class here.
725:36 - We'll create circle model. We've got circle model V1 already. We're going to create circle model V2.
725:42 - And we'll inherit from an end dot module. And then we'll write the constructor, which is the init function,
725:50 - and we'll pass in self here. And then we'll go self, or super sorry, too many S words.
725:57 - Dot underscore underscore init, underscore. There we go. So we've got the constructor here.
726:04 - And now let's create a layer one, self dot layer one equals just the same as what we've used before. And then dot linear.
726:13 - We're going to create this quite similar to the model that we've built before, except with one added feature.
726:20 - And we're going to create in features, which is akin to the number of X features that we have here.
726:26 - Again, if this was different, if we had three X features, we might change this to three.
726:31 - But because we're working with two, we'll leave it as that. We'll keep out features as 10, so that we have 10 hidden units.
726:38 - And then we'll go layer two, and then dot linear. Again, these values here are very customizable because why, because they're hyper parameters.
726:47 - So let's line up the out features of layer two, and we'll do the same with layer three.
726:53 - Because layer three is going to take the outputs of layer two. So it needs in features of 10.
726:59 - And we want layer three to be the output layer, and we want one number as output, so we'll set one here.
727:06 - Now, here's the fun part. We're going to introduce a nonlinear function. We're going to introduce the relu function.
727:13 - Now, we've seen sigmoid. Relu is another very common one. It's actually quite simple.
727:18 - But let's write it out first, and then dot relu.
727:22 - So remember, torch dot nn stores a lot of existing nonlinear activation functions, so that we don't necessarily have to code them ourselves.
727:32 - However, if we did want to code a relu function, let me show you. It's actually quite simple.
727:37 - If we dive into nn dot relu, or relu, however you want to say it, I usually say relu, applies the rectified linear unit function element wise.
727:48 - So that means element wise on every element in our input tensor.
727:52 - And so it stands for rectified linear unit, and here's what it does. Basically, it takes an input.
727:58 - If the input is negative, it turns the input to zero, and it leaves the positive inputs how they are.
728:06 - And so this line is not straight.
728:08 - Now, you could argue, yeah, well, it's straight here and then straight there, but this is a form of a nonlinear activation function.
728:14 - So it goes boom, if it was linear, it would just stay straight there like that.
728:19 - But let's see it in practice. Do you think this is going to improve our model?
728:23 - Well, let's find out together, hey, forward, we need to implement the forward method.
728:28 - And here's what we're going to do. Where should we put our nonlinear activation functions?
728:38 - So I'm just going to put a node here. Relu is a nonlinear activation function.
728:48 - And remember, wherever I say function, it's just performing some sort of operation on a numerical input.
728:55 - So we're going to put a nonlinear activation function in between each of our layers.
729:01 - So let me show you what this looks like, self dot layer three.
729:05 - We're going to start from the outside in self dot relu, and then we're going to go self dot layer two.
729:12 - And then we're going to go self dot relu.
729:16 - And then there's a fair bit going on here, but nothing we can't handle layer one. And then here's the X.
729:21 - So what happens is our data goes into layer one, performs a linear operation with an end up linear.
729:30 - Then we pass the output of layer one to a relu function.
729:34 - So we, where's relu up here, we turn all of the negative outputs of our model of our of layer one to zero,
729:42 - and we keep the positives how they are.
729:45 - And then we do the same here with layer two.
729:48 - And then finally, the outputs of layer three stay as they are. We've got out features there.
729:53 - We don't have a relu on the end here, because we're going to pass the outputs to the sigmoid function later on.
729:58 - And if we really wanted to, we could put self dot sigmoid here equals an end dot sigmoid.
730:04 - But I'm going to, that's just one way of constructing it.
730:08 - We're just going to apply the sigmoid function to the logits of our model, because what are the logits, the raw output of our model.
730:16 - And so let's instantiate our model. This is going to be called model three, which is a little bit confusing, but we're up to model three,
730:22 - which is circle model V two, and we're going to send that to the target device.
730:28 - And then let's check model three. What does this look like?
730:35 - Wonderful. So it doesn't actually show us where the relu's appear, but it just shows us what are the parameters of our circle model V two.
730:45 - Now, I'd like you to have a think about this. And my challenge to you is to go ahead and see if this model is capable of working on our data, on our circular data.
730:56 - So we've got the data sets ready. You need to set up some training code.
731:01 - My challenge to you is write that training code and see if this model works.
731:06 - But we're going to go through that over the next few videos.
731:09 - And also, my other challenge to you is to go to the TensorFlow Playground and recreate our neural network here.
731:17 - You can have two hidden layers. Does this go to 10? Well, it only goes to eight. We'll keep this at five.
731:23 - So build something like this. So we've got two layers with five. It's a little bit different to ours because we've got two layers with 10.
731:29 - And then put the learning rate to 0.01. What do we have? 0.1 with stochastic gradient descent.
731:36 - We've been using 0.1, so we'll leave that. So this is the TensorFlow Playground.
731:40 - And then change the activation here. Instead of linear, which we've used before, change it to relu, which is what we're using.
731:49 - And press play here and see what happens. I'll see you in the next video.
731:54 - Welcome back. In the last video, I left off leaving the challenge of recreating this model here.
732:00 - It's not too difficult to do. We've got two hidden layers and five neurons. We've got our data set, which looks kind of like ours.
732:06 - But the main points here are have to learning rate of 0.1, which is what we've been using.
732:11 - But to change it from, we've previously used a linear activation to change it from linear to relu, which is what we've got set up here in the code.
732:20 - Now, remember, relu is a popular and effective nonlinear activation function.
732:25 - And we've been discussing that we need nonlinearity to model nonlinear data.
732:31 - And so that's the crux to what neural networks are.
732:36 - Artificial neural networks, not to get confused with the brain neural networks, but who knows?
732:40 - This might be how they work, too. I don't know. I'm not a neurosurgeon or a neuroscientist.
732:44 - Artificial neural networks are a large combination of linear.
732:51 - So this is straight and non-straight nonlinear functions, which are potentially able to find patterns in data.
733:05 - And so for our data set, it's quite small. It's just a blue and a red circle.
733:09 - But this same principle applies for larger data sets and larger models combined linear and nonlinear functions.
733:17 - So we've got a few tabs going on here. Let's get rid of some. Let's come back to here.
733:21 - Did you try this out? Does it work? Do you think it'll work?
733:24 - I don't know. Let's find out together. Ready? Three, two, one.
733:29 - Look at that.
733:31 - Almost instantly the training loss goes down to zero and the test loss is basically zero as well. Look at that.
733:37 - That's amazing. We can stop that there. And if we change the learning rate, maybe a little lower, let's see what happens.
733:45 - It takes a little bit longer to get to where it wants to go to.
733:49 - See, that's the power of changing the learning rate. Let's make it really small. What happens here?
733:53 - So that was about 300 epochs. The loss started to go down.
733:57 - If we change it to be really small, oh, we're getting a little bit of a trend.
734:01 - Is it starting to go down? We're already surpassed the epochs that we had.
734:06 - So see how the learning rate is much smaller? That means our model is learning much slower.
734:11 - So this is just a beautiful visual way of demonstrating different values of the learning rate.
734:17 - We could sit here all day and that might not get to lower, but let's increase it by 10x.
734:21 - And that was over 1,000 epochs and it's still at about 0.5, let's say.
734:27 - Oh, we got a better. Oh, we're going faster already.
734:31 - So not even at 500 or so epochs, we're about 0.4.
734:37 - That's the power of the learning rate. We'll increase it by another 10x.
734:41 - We'll reset. Start again. Oh, would you look at that much faster this time.
734:45 - That is beautiful. Oh, there's nothing better than watching a loss curve go down.
734:50 - In the world of machine learning, that is. And then we reset that again.
734:55 - And let's change it right back to what we had. And we get to 0 in basically under 100 epochs.
735:01 - So that's the power of the learning rate, little visual representation.
735:05 - Working on learning rates, it's time for us to build an optimizer and a loss function.
735:10 - So that's right here. We've got our nonlinear model set up loss and optimizer.
735:15 - You might have already done this because the code, this is code that we've written before,
735:19 - but we're going to redo it for completeness and practice.
735:23 - So we want a loss function. We're working with logits here and we're working with binary cross entropy.
735:28 - So what loss do we use?
735:30 - Binary cross entropy. Sorry, we're working with a binary classification problem.
735:34 - Blue dots or red dots, torch dot opt in.
735:38 - What are some other binary classification problems that you can think of?
735:42 - We want model three dot parameters.
735:46 - They're the parameters that we want to optimize this model here.
735:49 - And we're going to set our LR to 0.1, just like we had in the TensorFlow playground.
735:57 - Beautiful. So some other binary classification problems I can think of would be email.
736:03 - Spam or not spam credit cards.
736:07 - So equals fraud or not fraud.
736:12 - What else? You might have insurance claims.
736:15 - Equals who's at fault or not at fault.
736:19 - If someone puts in a claim speaking about a car crash, whose fault was it?
736:23 - Was the person submitting the claim? Were they at fault?
736:26 - Or was the person who was also mentioned in the claim? Are they not at fault?
736:30 - So there's many more, but they're just some I can think of up the top of my head.
736:34 - But now let's train our model with nonlinearity.
736:38 - Oh, we're on a roll here.
736:42 - Training a model with nonlinearity.
736:45 - So we've seen that if we introduce a nonlinear activation function within a model,
736:50 - remember this is a linear activation function, and if we train this, the loss doesn't go down.
736:56 - But if we just adjust this to add a relu in here, we get the loss going down.
737:01 - So hopefully this replicates with our pure PyTorch code.
737:06 - So let's do it, hey?
737:09 - So we're going to create random seeds.
737:12 - Because we're working with CUDA, we'll introduce the CUDA random seed as well.
737:16 - Torch.manual seed. Again, don't worry too much if your numbers on your screen aren't exactly what mine are.
737:22 - That's due to the inherent randomness of machine learning.
737:26 - In fact, stochastic gradient descent stochastic again stands for random.
737:31 - And we're just setting up the seeds here so that they can be as close as possible.
737:35 - But the direction is more important.
737:38 - So if my loss goes down, your loss should also go down on target device.
737:45 - And then we're going to go Xtrain.
737:48 - So this is setting up device agnostic code. We've done this before.
737:52 - But we're going to do it again for completeness.
737:55 - Just to practice every step of the puzzle. That's what we want to do.
737:59 - We want to have experience. That's what this course is. It's a momentum builder.
738:03 - So that when you go to other repos and machine learning projects that use PyTorch, you can go, oh, does this code set device agnostic code?
738:13 - What problem are we working on? Is it binary or multi-class classification?
738:18 - So let's go loop through data.
738:22 - Again, we've done this before, but we're going to set up the epochs.
738:26 - Let's do 1000 epochs. Why not?
738:29 - So we can go for epoch in range epochs.
738:33 - What do we do here? Well, we want to train. So this is training code.
738:37 - We set our model model three dot train.
738:40 - And I want you to start to think about how could we functionalize this training code?
738:44 - We're going to start to move towards that in a future video.
738:47 - So one is forward pass. We've got the logits. Why the logits?
738:51 - Well, because the raw output of our model without any activation functions towards the final layer.
738:57 - Classified as logits or called logits.
739:00 - And then we create y-pred as in prediction labels by rounding the output of torch dot sigmoid of the logits.
739:10 - So this is going to take us from logits to prediction probabilities to prediction labels.
739:20 - And then we can go to, which is calculate the loss.
739:26 - That's from my unofficial pytorch song. Calculate the last.
739:30 - We go loss equals loss FN y logits.
739:35 - Because remember, we've got BCE with logits loss and takes in logits as first input.
739:48 - And that's going to calculate the loss between our models, logits and the y training labels.
739:53 - And we will go here, we'll calculate accuracy using our accuracy function.
739:58 - And this one is a little bit backwards compared to pytorch, but we pass in the y training labels first.
740:06 - But it's constructed this way because it's in the same style as scikit line.
740:12 - Three, we go optimizer zero grad. We zero the gradients of the optimizer so that it can start from fresh.
740:21 - Calculating the ideal gradients every epoch.
740:25 - So it's going to reset every epoch, which is fine.
740:28 - Then we're going to perform back propagation pytorch is going to take care of that for us by calling loss backwards.
740:34 - And then we will perform gradient descent. So step the optimizer to see how we should improve our model parameters.
740:42 - So optimizer dot step.
740:45 - Oh, and I want to show you speaking of model parameters. Let's check our model three dot state dig.
740:50 - So the relu activation function actually doesn't have any parameters.
740:56 - So you'll notice here, we've got weight, we've got bias of layer one, layer two, and a layer three.
741:02 - So the relu function here doesn't have any parameters to optimize. If we go nn dot relu.
741:09 - Does it say what it implements? There we go.
741:12 - So it's just the maximum of zero or x. So it takes the input and takes the max of zero or x.
741:19 - And so when it takes the max of zero or x, if it's a negative number, zero is going to be higher than a negative number.
741:26 - So that's why it zeroes all of the negative inputs.
741:29 - And then it leaves the positive inputs how they are because the max of a positive input versus zero is the positive input.
741:38 - So this has no parameters to optimize. That's why it's so effective because you think about it.
741:43 - Every parameter in our model needs some little bit of computation to adjust.
741:47 - And so the more parameters we add to our model, the more compute that is required.
741:51 - So generally, the kind of trade-off in machine learning is that, yes, more parameters have more of an ability to learn, but you need more compute.
742:00 - So let's go model three dot a vowel. And we're going to go with torch dot inference mode.
742:07 - If I could spell inference, that'd be fantastic. We're going to do what? We're going to do the forward pass.
742:13 - So test logits equals model three on the test data.
742:17 - And then we're going to calculate the test pred labels by calling torch dot round on torch dot sigmoid on the test logits.
742:29 - And then we can calculate the test loss. How do we do that?
742:33 - And then we can also calculate the test accuracy. I'm just going to give myself some more space here.
742:43 - So I can code in the middle of the screen equals accuracy function on what we're going to pass in y true equals y test.
742:54 - We're going to pass in y true equals y test. And then we will pass in y pred equals test pred.
743:04 - Beautiful. A final step here is to print out what's happening.
743:08 - Now, this will be very important because one, it's fun to know what your model is doing.
743:13 - And two, if our model does actually learn, I'd like to see the loss values go down and the accuracy values go up.
743:20 - As I said, there's nothing much more beautiful in the world of machine learning than watching a loss function go down or a loss value go down and watching a loss curve go down.
743:30 - So let's print out the current epoch and then we'll print out the loss, which will just be the training loss.
743:36 - And we'll take that to four decimal places. And then we'll go accuracy here.
743:41 - And this will be a and we'll take this to two decimal places and we'll put a little percentage sign there and then we'll break it up by putting in the test loss here and we'll put in the test loss.
743:54 - Because remember our model learns patterns on the training data set and then evaluates those patterns on the test data set.
744:03 - So, and we'll pass in test act here and no doubt there might be an error or two within all of this code, but we're going to try and run this because we've seen this code before, but I think we're ready.
744:14 - We're training our first model here with non-linearities built into the model.
744:19 - You ready? Three, two, one, let's go.
744:24 - Oh, of course. Module torch CUDA has no attribute manuals are just a typo standard man you out.
744:36 - There we go. Have to sound that out.
744:38 - Another one. What do we get wrong here? Oh, target size must be same as input size. Where did it mess up here?
744:46 - What do we get wrong? Test loss, test logits on Y test. Hmm.
744:55 - So these two aren't matching up. Model three X test and Y test. What's the size of?
745:05 - So let's do some troubleshooting on the fly. Hey, not everything always works out as you want.
745:10 - So length of X test, we've got a shape issue here. Remember how I said one of the most common issues in deep learning is a shape issue?
745:18 - We've got the same shape here.
745:21 - Let's check test logits dot shape and Y test dot shape. We'll print this out.
745:33 - So 200. Oh, here's what we have to do. That's what we missed dot squeeze. Oh, see how I've been hinting at the fact that we needed to call dot squeeze.
745:42 - So this is where the discrepancy is. Our test logits dot shape. We've got an extra dimension here.
745:48 - And what are we getting here? A value error on the target size, which is a shape mismatch.
745:53 - So we've got target size 200 must be the same input size as torch size 201.
745:59 - So did we squeeze this? Oh, that's why the training worked. Okay, so we've missed this.
746:04 - Let's just get rid of this. So we're getting rid of the extra one dimension by using squeeze, which is the one dimension here.
746:12 - We should have everything lined up. There we go. Okay. Look at that. Yes.
746:19 - Now accuracy has gone up, albeit not by too much. It's still not perfect.
746:24 - So really we'd like this to be towards 100% lost to be lower. But I feel like we've got a better performing model. Don't you?
746:32 - Now that is the power of non linearity. All we did was we added in a relu layer or just two of them.
746:38 - Relu here, relu here. But what did we do? We gave our model the power of straight lines. Oh, straight linear of straight lines and non straight lines.
746:51 - So it can potentially draw a line to separate these circles.
746:56 - So in the next video, let's draw a line, plot our model decision boundary using our function and see if it really did learn anything.
747:05 - I'll see you there.
747:08 - Welcome back. In the last video, we trained our first model, and as you can tell, I've got the biggest smile on my face,
747:14 - but we trained our first model that harnesses both the power of straight lines and non straight lines or linear functions and non linear functions.
747:22 - And by the 1000th epoch, we look like we're getting a bit better results than just pure guessing, which is 50%.
747:29 - Because we have 500 samples of red dots and 500 samples of blue dots. So we have evenly balanced classes.
747:36 - Now, we've seen that if we added a relu activation function with a data set similar to ours with a TensorFlow playground, the model starts to fit.
747:46 - But it doesn't work with just linear. There's a few other activation functions that you could play around with here.
747:51 - You could play around with the learning rate, regularization. If you're not sure what that is, I'll leave that as extra curriculum to look up.
747:57 - But we're going to retire the TensorFlow program for now because we're going to go back to writing code.
748:03 - So let's get out of that. Let's get out of that. We now have to evaluate our model because right now it's just numbers on a page.
748:09 - So let's write down here 6.4. What do we like to do to evaluate things? It's visualize, visualize, visualize.
748:18 - So evaluating a model trained with nonlinear activation functions.
748:25 - And we also discussed the point that neural networks are really just a big combination of linear and nonlinear functions trying to draw patterns in data.
748:34 - So with that being said, let's make some predictions with our Model 3, our most recently trained model.
748:41 - We'll put it into a Val mode and then we'll set up inference mode.
748:46 - And then we'll go yprads equals torch dot round and then torch dot sigmoid.
748:55 - We could functionalize this, of course, Model 3 and then pass in X test.
749:00 - And you know what? We're going to squeeze these here because we ran into some troubles in the previous video.
749:06 - I actually really liked that we did because then we got to troubleshoot a shape error on the fly because that's one of the most common issues you're going to come across in deep learning.
749:14 - So yprads, let's check them out and then let's check out y test.
749:21 - You want y test 10.
749:23 - So remember, when we're evaluating predictions, we want them to be in the same format as our original labels.
749:31 - We want to compare apples to apples.
749:33 - And if we compare the format here, do these two things look the same?
749:36 - Yes, they do. They're both on CUDA and they're both floats.
749:39 - We can see that it's got this one wrong.
749:42 - Whereas the other ones look pretty good. Hmm, this might look pretty good if we visualize it.
749:47 - So now let's, you might have already done this because I issued the challenge of plotting the decision boundaries.
749:53 - Plot decision boundaries and let's go PLT dot figure and we're going to set up the fig size to equal 12.6 because, again, one of the advantages of hosting a machine learning cooking show is that you can code ahead of time.
750:08 - And then we can go PLT dot title is train.
750:13 - And then we're going to call our plot decision boundary function, which we've seen before.
750:18 - Plot decision boundary.
750:20 - And we're going to pass this one in.
750:22 - We could do model three, but we could also pass it in our older models to model one that doesn't use it on the reality.
750:28 - In fact, I reckon that'll be a great comparison.
750:31 - So we'll also create another plot here for the test data and this will be on index number two.
750:39 - So remember, subplot is a number of rows, number of columns, index where the plot appears.
750:46 - We'll give this one a title.
750:48 - Plot dot title.
750:50 - This will be test and Google Colab.
750:53 - I didn't want that.
750:54 - As I said, this course is also a battle between me and Google Colab's autocorrect.
751:00 - So we're going model three and we'll pass in the test data here.
751:04 - And behind the scenes, our plot decision boundary function will create a beautiful graphic for us,
751:10 - perform some predictions on the X, the features input, and then we'll compare them with the Y values.
751:17 - Let's see what's going on here.
751:19 - Oh, look at that.
751:21 - Yes, our first nonlinear model.
751:25 - Okay, it's not perfect, but it is certainly much better than the models that we had before.
751:29 - Look at this.
751:30 - Model one has no linearity.
751:32 - Model one equals no nonlinearity.
751:35 - I've got double negative there.
751:38 - Whereas model three equals has nonlinearity.
751:44 - So do you see the power of nonlinearity or better yet the power of linearity or linear straight lines with non straight lines?
751:51 - So I feel like we could do better than this, though.
751:55 - Here's your challenge is to can you improve model three to do better?
752:02 - What did we get?
752:05 - 79% accuracy to do better than 80% accuracy on the test data.
752:13 - I think you can.
752:15 - So that's the challenge.
752:16 - And if you're looking for hints on how to do so, where can you look?
752:20 - Well, we've covered this improving a model.
752:22 - So maybe you add some more layers, maybe you add more hidden units.
752:26 - Maybe you fit for longer.
752:27 - Maybe you if you add more layers, you put a relio activation function on top of those as well.
752:32 - Maybe you lower the learning rate because right now we've got 0.1.
752:36 - So give this a shot, try and improve it.
752:39 - I think you can do it.
752:40 - But we're going to push forward.
752:42 - That's going to be your challenge for some extra curriculum.
752:45 - I think in the next section, we've seen our nonlinear activation functions in action.
752:51 - Let's write some code to replicate them.
752:54 - I'll see you there.
752:57 - Welcome back.
752:58 - In the last video, I left off with the challenge of improving model three to do better than
753:02 - 80% accuracy on the test data.
753:04 - I hope you gave it a shot.
753:06 - But here are some of the things I would have done.
753:08 - As I potentially add more layers, I maybe increase the number of hidden units,
753:12 - and then if we needed to fit for longer and maybe lower the learning rate to 0.01.
753:17 - But I'll leave that for you to explore because that's the motto of the data scientists, right?
753:22 - Is to experiment, experiment, experiment.
753:25 - So let's go in here.
753:27 - We've seen our nonlinear activation functions in practice.
753:31 - Let's replicate them.
753:33 - So replicating nonlinear activation functions.
753:38 - And remember neural networks rather than us telling the model what to learn.
753:46 - We give it the tools to discover patterns in data.
753:52 - And it tries to figure out the best patterns on its own.
754:01 - And what are these tools?
754:04 - That's right down here.
754:06 - We've seen this in action.
754:07 - And these tools are linear and nonlinear functions.
754:13 - So a neural network is a big stack of linear and nonlinear functions.
754:18 - For us, we've only got about four layers or so, four or five layers.
754:21 - But as I said, other networks can get much larger.
754:24 - But the premise remains.
754:26 - Some form of linear and nonlinear manipulation of the data.
754:30 - So let's get out of this.
754:32 - Let's make our workspace a little bit more cleaner.
754:36 - Replicating nonlinear activation functions.
754:38 - So let's create a tensor to start with.
754:40 - Everything starts from the tensor.
754:43 - And we'll go A equals torch A range.
754:47 - And we're going to create a range from negative 10 to 10 with a step of one.
754:52 - And we can set the D type here to equal torch dot float 32.
754:57 - But we don't actually need to.
754:59 - That's going to be the default.
755:00 - So if we set A here, A dot D type.
755:06 - Then we've got torch float 32 and I'm pretty sure if we've got rid of that.
755:10 - Oh, we've got torch in 64.
755:13 - Why is that happening?
755:15 - Well, let's check out A.
755:18 - Oh, it's because we've got integers as our values because we have a step as one.
755:23 - If we turn this into a float, what's going to happen?
755:26 - We get float 32.
755:28 - But we'll keep it.
755:29 - Otherwise, this is going to be what?
755:31 - About a hundred numbers?
755:32 - Yeah, no, that's too many.
755:33 - Let's keep it at negative 10 to 10 and we'll set the D type here to torch float 32.
755:41 - Beautiful.
755:42 - So it looks like PyTorch's default data type for integers is in 64.
755:46 - But we're going to work with float 32 because float 32, if our data wasn't float 32 with
755:52 - the functions we're about to create, we might run into some errors.
755:56 - So let's visualize this data.
755:59 - I want you to guess, is this a straight line or non-straight line?
756:04 - You've got three seconds.
756:05 - One, two, three.
756:09 - Straight line.
756:11 - There we go.
756:12 - We've got negative 10 to positive 10 up here or nine.
756:16 - Close enough.
756:17 - And so how would we turn this straight line?
756:19 - If it's a straight line, it's linear.
756:22 - How would we perform the relu activation function on this?
756:26 - Now, we could of course call torch relu on A.
756:31 - Actually, let's in fact just plot this.
756:34 - PLT dot plot on torch relu.
756:37 - What does this look like?
756:39 - Boom, there we go.
756:40 - But we want to replicate the relu function.
756:42 - So let's go nn dot relu.
756:44 - What does it do?
756:46 - We've seen this before.
756:48 - So we need the max.
756:49 - We need to return based on an input.
756:51 - We need the max of zero and x.
756:54 - So let's give it a shot.
756:56 - We'll come here.
756:58 - Again, we need more space.
757:00 - There can never be enough code space here.
757:02 - I like writing lots of code.
757:03 - I don't know about you.
757:04 - But let's go relu.
757:06 - We'll take an input x, which will be some form of tensor.
757:09 - And we'll go return torch dot maximum.
757:13 - I think you could just do torch dot max.
757:15 - But we'll try maximum.
757:17 - Torch dot tensor zero.
757:21 - So the maximum is going to return the max between whatever this is.
757:26 - One option and whatever the other option is.
757:29 - So inputs must be tensors.
757:34 - So maybe we could just give a type hint here that this is torch dot tensor.
757:40 - And this should return a tensor too.
757:42 - Return torch dot tensor.
757:44 - Beautiful.
757:45 - You're ready to try it out.
757:47 - Let's see what our relu function does.
757:49 - Relu A.
757:51 - Wonderful.
757:52 - It looks like we got quite a similar output to before.
757:55 - Here's our original A.
757:57 - So we've got negative numbers.
757:59 - There we go.
758:00 - So recall that the relu activation function turns all negative numbers into zero
758:05 - because it takes the maximum between zero and the input.
758:08 - And if the input's negative, well then zero is bigger than it.
758:11 - And it leaves all of the positive values as they are.
758:15 - So that's the beauty of relu.
758:17 - Quite simple, but very effective.
758:20 - So let's plot relu activation function.
758:25 - Our custom one.
758:26 - We will go PLT dot plot.
758:29 - We'll call our relu function on A.
758:33 - Let's see what this looks like.
758:36 - Oh, look at us go.
758:38 - Well done.
758:39 - Just the exact same as the torch relu function.
758:42 - Easy as that.
758:43 - And what's another nonlinear activation function that we've used before?
758:48 - Well, I believe one of them is if we go down to here, what did we say before?
758:54 - Sigmoid.
758:55 - Where is that?
758:56 - Where are you, Sigmoid?
758:57 - Here we go.
758:58 - Hello, Sigmoid.
758:59 - Oh, this has got a little bit more going on here.
759:02 - One over one plus exponential of negative x.
759:06 - So Sigmoid or this little symbol for Sigmoid of x, which is an input.
759:12 - We get this.
759:13 - So let's try and replicate this.
759:15 - I might just bring this one in here.
759:18 - Right now, let's do the same for Sigmoid.
759:23 - So what do we have here?
759:26 - Well, we want to create a custom Sigmoid.
759:29 - And we want to have some sort of input, x.
759:32 - And we want to return one divided by, do we have the function in Sigmoid?
759:39 - One divided by one plus exponential.
759:43 - One plus torch dot exp for exponential on negative x.
759:50 - And we might put the bottom side in brackets so that it does that operation.
759:55 - I reckon that looks all right to me.
759:58 - So one divided by one plus torch exponential of negative x.
760:04 - Do we have that?
760:05 - Yes, we do.
760:06 - Well, there's only one real way to find out.
760:08 - Let's plot the torch version of Sigmoid.
760:11 - Torch dot Sigmoid and we'll pass in x.
760:14 - See what happens.
760:16 - And then, oh, we have a.
760:19 - My bad.
760:20 - A is our tensor.
760:21 - What do we get?
760:22 - We get a curved line.
760:24 - Wonderful.
760:25 - And then we go plt dot plot.
760:27 - And we're going to use our Sigmoid function on a.
760:30 - Did we replicate torch's Sigmoid function?
760:33 - Yes, we did.
760:35 - Ooh, now.
760:38 - See, this is what's happening behind the scenes with our neural networks.
760:41 - Of course, you could do more complicated activation functions or layers and whatnot.
760:45 - And you can try to replicate them.
760:47 - In fact, that's a great exercise to try and do.
760:49 - But we've essentially across the videos and the sections that we've done, we've replicated our linear layer.
760:54 - And we've replicated the relu.
760:56 - So we've actually built this model from scratch, or we could if we really wanted to.
761:00 - But it's a lot easier to use PyTorch's layers because we're building neural networks here like Lego bricks,
761:06 - stacking together these layers in some way, shape, or form.
761:08 - And because they're a part of PyTorch, we know that they've been error-tested and they compute as fast as possible
761:14 - behind the scenes and use GPU and get a whole bunch of benefits.
761:18 - PyTorch offers a lot of benefits by using these layers rather than writing them ourselves.
761:23 - And so this is what our model is doing.
761:25 - It's literally like to learn these values and decrease the loss function and increase the accuracy.
761:31 - It's combining linear layers and nonlinear layers or nonlinear functions.
761:37 - Where's our relu function here?
761:39 - A relu function like this behind the scenes.
761:41 - So just combining linear and nonlinear functions to fit a data set.
761:47 - And that premise remains even on our small data set and on very large data sets and very large models.
761:54 - So with that being said, I think it's time for us to push on.
761:58 - We've covered a fair bit of code here.
762:00 - But we've worked on a binary classification problem.
762:04 - Have we worked on a multi-class classification problem yet?
762:08 - Do we have that here? Where's my fun graphic?
762:11 - We have multi-class classification.
762:15 - I think that's what we cover next.
762:17 - We're going to put together all of the steps in our workflow that we've covered for binary classification.
762:22 - But now let's move on to a multi-class classification problem.
762:26 - If you're with me, I'll see you in the next video.
762:32 - Welcome back.
762:33 - In the last few videos we've been harnessing the power of nonlinearity.
762:37 - Specifically non-straight line functions and we replicated some here.
762:41 - And we learned that a neural network combines linear and nonlinear functions to find patterns in data.
762:49 - And for our simple red versus blue dots, once we added a little bit of nonlinearity,
762:53 - we found the secret source of to start separating our blue and red dots.
762:58 - And I also issued you the challenge to try and improve this and I think you can do it.
763:02 - So hopefully you've given that a go.
763:04 - But now let's keep pushing forward.
763:06 - We're going to reiterate over basically everything that we've done,
763:09 - except this time from the point of view of a multi-class classification problem.
763:15 - So I believe we're up to section eight, putting it all together with a multi-class classification problem.
763:26 - Beautiful.
763:27 - And recall the difference between binary classification equals one thing or another such as cat versus dog.
763:37 - If you were building a cat versus dog image classifier, spam versus not spam for say emails that were spam or not spam or
763:47 - even internet posts on Facebook or Twitter or one of the other internet services.
763:52 - And then fraud or not fraud for credit card transactions.
763:57 - And then multi-class classification is more than one thing or another.
764:05 - So we could have cat versus dog versus chicken.
764:11 - So I think we've got all the skills to do this.
764:14 - Our architecture might be a little bit different for a multi-class classification problem.
764:18 - But we've got so many building blocks now.
764:20 - It's not funny.
764:21 - Let's clean up this and we'll add some more code cells and just to reiterate.
764:27 - So we've gone over nonlinearity.
764:29 - The question is what could you draw if you had an unlimited amount of straight linear and non-straight,
764:34 - nonlinear lines, I believe you could draw some pretty intricate patterns.
764:38 - And that is what our neural networks are doing behind the scenes.
764:41 - And so we also learned that if we wanted to just replicate some of these nonlinear functions,
764:47 - some of the ones that we've used before, we could create a range.
764:51 - Linear activation is just the line itself.
764:54 - And then if we wanted to do sigmoid, we get this curl here.
765:00 - And then if we wanted to do relu, well, we saw how to replicate the relu function as one.
765:07 - These both are nonlinear.
765:09 - And of course, torch.nn has far more nonlinear activations where they came from just as it has far more different layers.
765:18 - And you'll get used to these with practice.
765:20 - And that's what we're doing here.
765:22 - So let's go back to the keynote.
765:24 - So this is what we're going to be working on.
765:26 - Multi-class classification.
765:27 - So there's one of the big differences here.
765:29 - We use the softmax activation function versus sigmoid.
765:33 - There's another big difference here.
765:35 - Instead of binary cross entropy, we use just cross entropy.
765:39 - But I think most of it's going to stay the same.
765:42 - We're going to see this in action in a second.
765:44 - But let's just describe our problem space.
765:48 - Just to go visual, we've covered a fair bit here.
765:52 - Well done, everyone.
765:53 - So binary versus multi-class classification.
765:56 - Binary one thing or another.
765:59 - Zero or one.
766:00 - Multi-class could be three things.
766:02 - Could be a thousand things.
766:04 - Could be 5,000 things.
766:05 - Could be 25 things.
766:07 - So more than one thing or another.
766:09 - But that's the basic premise we're going to go with.
766:12 - Let's create some data, hey?
766:14 - 8.1.
766:15 - Creating a 20 multi-class data set.
766:21 - And so to create our data set, we're going to import our dependencies.
766:26 - We're going to re-import torch, even though we already have it.
766:29 - Just for a little bit of completeness.
766:31 - And we're going to go map plotlib.
766:33 - So we can plot, as always, we like to get visual where we can.
766:37 - Visualize, visualize, visualize.
766:40 - We're going to import from scikitlearn.datasets.
766:44 - Let's get make blobs.
766:47 - Now, where would I get this from?
766:49 - SKlearn.datasets.
766:51 - What do we get?
766:53 - 20 data sets.
766:54 - Do we have classification?
766:57 - 20 data sets.
766:58 - Do we have blobs?
767:02 - If we just go make scikitlearn.
767:06 - Classification data sets.
767:10 - What do we get?
767:12 - Here's one option.
767:15 - There's also make blobs.
767:17 - Beautiful.
767:18 - Make blobs.
767:19 - This is a code for that.
767:20 - So let's just copy this in here.
767:22 - And make blobs.
767:23 - We're going to see this in action anyway.
767:25 - Make blobs.
767:26 - As you might have guessed, it makes some blobs for us.
767:29 - I like blobs.
767:31 - It's a fun word to say.
767:33 - Blobs.
767:34 - So we want train test split because we want to make a data set and then we want to split
767:39 - it into train and test.
767:40 - Let's set the number of hyper parameters.
767:42 - So set the hyper parameters for data creation.
767:48 - Now I got these from the documentation here.
767:51 - Number of samples.
767:52 - How many blobs do we want?
767:53 - How many features do we want?
767:55 - So say, for example, we wanted two different classes.
767:58 - That would be binary classification.
768:00 - Say, for example, you wanted 10 classes.
768:02 - You could set this to 10.
768:03 - And we're going to see what the others are in practice.
768:05 - But if you want to read through them, you can well and truly do that.
768:09 - So let's set up.
768:12 - We want num classes.
768:13 - Let's double what we've been working with.
768:15 - We've been working with two classes, red dots or blue dots.
768:18 - Let's step it up a notch.
768:19 - We'll go to four classes.
768:20 - Watch out, everyone.
768:21 - And we're going to go number of features will be two.
768:24 - So we have the same number of features.
768:26 - And then the random seed is going to be 42.
768:28 - You might be wondering why these are capitalized.
768:31 - Well, generally, if we do have some hyper parameters that we say set at the start of a notebook,
768:38 - you'll find it's quite common for people to write them as capital letters just to say
768:43 - that, hey, these are some settings that you can change.
768:46 - You don't have to, but I'm just going to introduce that anyway because you might stumble upon it yourself.
768:51 - So create multi-class data.
768:54 - We're going to use the make blobs function here.
768:58 - So we're going to create some x blobs, some feature blobs and some label blobs.
769:02 - Let's see what these look like in a second.
769:04 - I know I'm just saying blobs a lot.
769:08 - But we pass in here, none samples.
769:11 - How many do we want?
769:12 - Let's create a thousand as well.
769:14 - That could really be a hyper parameter, but we'll just leave that how it is for now.
769:17 - Number of features is going to be num features.
769:23 - Centres equals num classes.
769:29 - So we're going to create four classes because we've set up num classes equal to four.
769:33 - And then we're going to go center standard deviation.
769:36 - We'll give them a little shake up, add a little bit of randomness in here.
769:41 - Give the clusters a little shake up.
769:45 - We'll mix them up a bit.
769:46 - Make it a bit hard for our model.
769:48 - But we'll see what this does in a second.
769:50 - Random state equals random seed, which is our favorite random seed 42.
769:55 - Of course, you can set it whatever number you want, but I like 42.
769:59 - Oh, and we need a comma here, of course.
770:02 - Beautiful.
770:03 - Now, what do we have to do here?
770:05 - Well, because we're using scikit-learn and scikit-learn leverages NumPy.
770:09 - So let's turn our data into tenses.
770:12 - Turn data into tenses.
770:14 - And how do we do that?
770:16 - Well, we grab x blob and we call torch from NumPy from NumPy.
770:22 - If I could type, that would be fantastic.
770:24 - That's all right.
770:25 - We're doing pretty well today.
770:26 - Haven't made too many typos.
770:28 - We did make a few in a couple of videos before, but hey.
770:31 - I'm only human.
770:33 - So we're going to torch from NumPy and we're going to pass in the y blob.
770:39 - And we'll turn it into torch dot float because remember NumPy defaults as float 64, whereas
770:45 - PyTorch likes float 32.
770:47 - So split into training and test.
770:53 - And we're going to create x blob train y or x test.
770:58 - x blob test.
771:01 - We'll keep the blob nomenclature here.
771:04 - y blob train and y blob test.
771:08 - And here's again where we're going to leverage the train test split function from scikit-learn.
771:13 - So thank you for that scikit-learn.
771:15 - x blob and we're going to pass the y blob.
771:18 - So features, labels, x is the features, y are the labels.
771:22 - And a test size, we've been using a test size of 20%.
771:25 - That means 80% of the data will be for the training data.
771:29 - That's a fair enough split with our data set.
771:31 - And we're going to set the random seed to random seed because generally normally train test split is random,
771:37 - but because we want some reproducibility here, we're passing random seeds.
771:42 - Finally, we need to get visual.
771:45 - So let's plot the data.
771:46 - Right now we've got a whole bunch of code and a whole bunch of talking, but not too much visuals going on.
771:51 - So we'll write down here, visualize, visualize, visualize.
771:56 - And we can call in plot.figure.
772:00 - What size do we want?
772:02 - I'm going to use my favorite hand in poker, which is 10-7, because it's generally worked out to be a good plot size.
772:09 - In my experience, anyway, we'll go x blob.
772:16 - And we want the zero index here, and then we'll grab x blob as well.
772:22 - And you might notice that we're visualizing the whole data set here.
772:25 - That's perfectly fine.
772:27 - We could visualize, train and test separately if we really wanted to, but I'll leave that as a level challenge to you.
772:33 - And we're going to go red, yellow, blue.
772:38 - Wonderful.
772:40 - What do we get wrong?
772:41 - Oh, of course we got something wrong.
772:43 - Santa STD, did we spell center wrong?
772:46 - Cluster STD.
772:47 - That's what I missed.
772:49 - So, cluster STD.
772:52 - Standard deviation.
772:53 - What do we get wrong?
772:54 - Random seed.
772:55 - Oh, this needs to be random state.
772:57 - Oh, another typo.
772:59 - You know what?
773:00 - Just as I said, I wasn't getting too many typos.
773:02 - I'll get three.
773:03 - There we go.
773:04 - Look at that.
773:05 - Our first multi-class classification data set.
773:08 - So if we set this to zero, what does it do to our clusters?
773:11 - Let's take note of what's going on here, particularly the space between all of the dots.
773:15 - Now, if we set this cluster STD to zero, what happens?
773:20 - We get dots that are really just, look at that.
773:23 - That's too easy.
773:24 - Let's mix it up, all right?
773:26 - Now, you can pick whatever value you want here.
773:28 - I'm going to use 1.5, because now we need to build a model that's going to draw some lines between these four colors.
773:34 - Two axes, four different classes.
773:36 - But it's not going to be perfect because we've got some red dots that are basically in the blue dots.
773:42 - And so, what's our next step?
773:45 - Well, we've got some data ready.
773:47 - It's now time to build a model.
773:49 - So, I'll see you in the next video.
773:51 - Let's build our first multi-class classification model.
773:57 - Welcome back.
773:58 - In the last video, we created our multi-class classification data set,
774:03 - using scikit-learn's make-blobs function.
774:06 - And now, why are we doing this?
774:08 - Well, because we're going to put all of what we've covered so far together.
774:12 - But instead of using binary classification or working with binary classification data,
774:17 - we're going to do it with multi-class classification data.
774:20 - So, with that being said, let's get into building our multi-class classification model.
774:26 - So, we'll create a little heading here.
774:29 - Building a multi-class classification model in PyTorch.
774:36 - And now, I want you to have a think about this.
774:39 - We spent the last few videos covering non-linearity.
774:42 - Does this data set need non-linearity?
774:46 - As in, could we separate this data set with pure straight lines?
774:51 - Or do we need some non-straight lines as well?
774:54 - Have a think about that.
774:56 - It's okay if you're not sure, we're going to be building a model to fit this data anyway,
775:01 - or draw patterns in this data anyway.
775:03 - And now, before we get into coding a model,
775:06 - so for multi-class classification, we've got this.
775:10 - For the input layer shape, we need to define the in features.
775:14 - So, how many in features do we have for the hidden layers?
775:18 - Well, we could set this to whatever we want, but we're going to keep it nice and simple for now.
775:23 - For the number of neurons per hidden layer, again, this could be almost whatever we want,
775:28 - but because we're working with a relatively small data set,
775:32 - we've only got four different classes, we've only got a thousand data points,
775:36 - we'll keep it small as well, but you could change this.
775:39 - Remember, you can change any of these because they're hyper parameters.
775:43 - For the output layer shape, well, how many output features do we want?
775:49 - We need one per class, how many classes do we have?
775:53 - We have four clusters of different dots here, so we'll need four output features.
775:59 - And then if we go back, we have an output activation of softmax, we haven't seen that yet,
776:03 - and then we have a loss function, rather than binary cross entropy, we have cross entropy.
776:09 - And then optimizer as well is the same as binary classification, two of the most common
776:15 - are SGDs, stochastic gradient descent, or the atom optimizer,
776:19 - but of course, the torch.optim package has many different options as well.
776:23 - So let's push forward and create our first multi-class classification model.
776:28 - First, we're going to create, we're going to get into the habit of creating
776:33 - device agnostic code, and we'll set the device here, equals CUDA,
776:39 - nothing we haven't seen before, but again, we're doing this to put it all together,
776:44 - so that we have a lot of practice.
776:47 - Is available, else CPU, and let's go device.
776:54 - So we should have a GPU available, beautiful CUDA.
776:58 - Now, of course, if you don't, you can go change runtime type, select GPU here,
777:03 - that will restart the runtime, you'll have to run all of the code that's before this cell as well,
777:08 - but I'm going to be using a GPU.
777:11 - You don't necessarily need one because our data set's quite small,
777:14 - and our models aren't going to be very large, but we set this up so we have device agnostic code.
777:20 - And so let's build a multi-class classification model.
777:25 - Look at us go, just covering all of the foundations of classification in general here,
777:31 - and we now know that we can combine linear and non-linear functions to create
777:38 - neural networks that can find patterns in almost any kind of data.
777:42 - So I'm going to call my class here blob model, and it's going to, of course,
777:46 - inherit from nn.module, and we're going to upgrade our class here.
777:51 - We're going to take some inputs here, and I'll show you how to do this.
777:54 - If you're familiar with Python classes, you would have already done stuff like this,
777:58 - but we're going to set some parameters for our models,
778:01 - because as you write more and more complex classes, you'll want to take inputs here.
778:05 - And I'm going to pre-build the, or pre-set the hidden units parameter to eight.
778:11 - Because I've decided, you know what, I'm going to start off with eight hidden units,
778:15 - and if I wanted to change this to 128, I could.
778:19 - But in the constructor here, we've got some options.
778:22 - So we have input features.
778:24 - We're going to set these programmatically as inputs to our class when we instantiate it.
778:28 - The same with output features as well.
778:31 - And so here, we're going to call self.
778:35 - Oh, no, super.
778:36 - Sorry.
778:37 - I always get this mixed up dot init.
778:40 - And underscore underscore.
778:42 - Beautiful.
778:43 - So we could do a doc string here as well.
778:46 - So let's write in this.
778:48 - Initializes multi-class classification.
778:55 - If I could spell class e-fication model.
779:01 - Oh, this is great.
779:03 - And then we have some arcs here.
779:05 - This is just a standard way of writing doc strings.
779:08 - If you want to find out, this is Google Python doc string guide.
779:13 - There we go.
779:15 - Google Python style guide.
779:16 - This is where I get mine from.
779:19 - You can scroll through this.
779:20 - This is just a way to write Python code.
779:22 - Yeah, there we go.
779:23 - So we've got a little sentence saying what's going on.
779:26 - We've got arcs.
779:27 - We've got returns and we've got errors if something's going on.
779:31 - So I highly recommend checking that out.
779:33 - Just a little tidbit.
779:34 - So this is if someone was to use our class later on.
779:37 - They know what the input features are.
779:39 - Input features, which is an int, which is number of input features to the model.
779:48 - And then, of course, we've got output features, which is also an int.
779:52 - Which is number of output features of the model.
779:56 - And we've got the red line here is telling us we've got something wrong, but that's okay.
780:00 - And then the hidden features.
780:01 - Oh, well, this is number of output classes for the case of multi-class classification.
780:07 - And then the hidden units.
780:13 - Int and then number of hidden units between layers and then the default is eight.
780:23 - Beautiful.
780:24 - And then under that, we'll just do that.
780:26 - Is that going to fix itself?
780:29 - Yeah, there we go.
780:30 - We could put in what it returns.
780:32 - Returns, whatever it returns.
780:34 - And then an example use case, but I'll leave that for you to fill out.
780:40 - If you like.
780:41 - So let's instantiate some things here.
780:44 - What we might do is write self dot linear layer stack.
780:50 - Self dot linear layer stack.
780:52 - And we will set this as nn dot sequential.
780:56 - Ooh, we haven't seen this before.
780:58 - But we're just going to look at a different way of writing a model here.
781:01 - Previously, when we created a model, what did we do?
781:04 - Well, we instantiated each layer as its own parameter here.
781:10 - And then we called on them one by one, but we did it in a straightforward fashion.
781:15 - So that's why we're going to use sequential here to just step through our layers.
781:19 - We're not doing anything too fancy, so we'll just set up a sequential stack of layers here.
781:24 - And recall that sequential just steps through, passes the data through each one of these layers one by one.
781:30 - And because we've set up the parameters up here, input features can equal to input features.
781:38 - And output features, what is this going to be?
781:41 - Is this going to be output features or is this going to be hidden units?
781:45 - It's going to be hidden units because it's not the final layer.
781:48 - We want the final layer to output our output features.
781:53 - So input features, this will be hidden units because remember the subsequent layer needs to line up with the previous layer.
781:59 - Output features, we're going to create another one that outputs hidden units.
782:04 - And then we'll go in n.linear in features equals hidden units because it takes the output features of the previous layer.
782:16 - So as you see here, the output features of this feeds into here.
782:19 - The output features of this feeds into here.
782:22 - And then finally, this is going to be our final layer.
782:25 - We'll do three layers.
782:26 - Output features equals output features.
782:31 - Wonderful. So how do we know the values of each of these?
782:35 - Well, let's have a look at xtrain.shape and ytrain.shape.
782:43 - So in the case of x, we have two input features.
782:46 - And in the case of y, well, this is a little confusing as well because y is a scalar.
782:51 - But what do you think the values for y are going to be?
782:55 - Well, let's go NP. Or is there torch.unique? I'm not sure. Let's find out together, hey?
783:01 - Torch unique.
783:03 - Zero on one, ytrain. Oh, we need y blob train. That's right, blob.
783:07 - I'm too used to writing blob.
783:11 - And we need blob train, but I believe it's the same here.
783:15 - And then blob.
783:18 - There we go. So we have four classes.
783:22 - So we need an output features value of four.
783:26 - And now if we wanted to add nonlinearity here, we could put it in between our layers here like this.
783:34 - But I asked the question before, do you think that this data set needs nonlinearity?
783:41 - Well, let's leave it in there to begin with.
783:43 - And one of the challenges for you, oh, do we need commerce here?
783:46 - I think we need commerce here.
783:48 - One of the challenges for you will be to test the model with nonlinearity
783:54 - and without nonlinearity.
783:56 - So let's just leave it in there for the time being.
783:59 - What's missing from this?
784:01 - Well, we need a forward method.
784:03 - So def forward self X. What can we do here?
784:07 - Well, because we've created this as a linear layer stack using nn.sequential,
784:12 - we can just go return linear layer stack and pass it X.
784:18 - And what's going to happen?
784:20 - Whatever input goes into the forward method is just going to go through these layers sequentially.
784:25 - Oh, we need to put self here because we've initialized it in the constructor.
784:30 - Beautiful.
784:31 - And now let's create an instance of blob model and send it to the target device.
784:41 - We'll go model four equals blob model.
784:45 - And then we can use our input features parameter, which is this one here.
784:51 - And we're going to pass it a value of what?
784:54 - Two.
784:55 - And then output features. Why? Because we have two X features.
784:58 - Now, the output feature is going to be the same as the number of classes that we have for.
785:02 - If we had 10 classes, we'd set it to 10.
785:05 - So we'll go four.
785:06 - And then the hidden units is going to be eight by default.
785:09 - So we don't have to put this here, but we're going to put it there anyway.
785:12 - And then, of course, we're going to send this to device.
785:17 - And then we're going to go model four.
785:24 - What do we get wrong here?
785:26 - Unexpected keyword argument output features.
785:30 - Do we spell something wrong?
785:31 - No doubt. We've got a spelling mistake.
785:33 - Output features. Output features.
785:40 - Oh, out features.
785:42 - Ah, that's what we needed. Out features, not output.
785:48 - I've got a little confused there.
785:50 - Okay.
785:51 - There we go. Okay, beautiful.
785:53 - So just recall that the parameter here for an end up linear.
785:56 - Did you pick up on that?
785:57 - Is out features not output features.
785:59 - Output features, a little confusing here, is our final layout output layers number of features there.
786:05 - So we've now got a multi-class classification model that lines up with the data that we're using.
786:11 - So the shapes line up. Beautiful.
786:13 - Well, what's next?
786:15 - Well, we have to create a loss function. And, of course, a training loop.
786:20 - So I'll see you in the next few videos. And let's do that together.
786:25 - Welcome back. In the last video, we created our multi-class classification model.
786:31 - And we did so by subclassing an end up module.
786:35 - And we set up a few parameters for our class constructor here.
786:39 - So that when we made an instance of the blob model, we could customize the input features.
786:44 - The output features. Remember, this lines up with how many features X has.
786:49 - And the output features here lines up with how many classes are in our data.
786:54 - So if we had 10 classes, we could change this to 10. And it would line up.
786:58 - And then if we wanted 128 hidden units, well, we could change that.
787:02 - So we're getting a little bit more programmatic with how we create models here.
787:07 - And as you'll see later on, a lot of the things that we've built in here can also be functionalized in a similar matter.
787:14 - But let's keep pushing forward. What's our next step?
787:16 - If we build a model, if we refer to the workflow, you'd see that we have to create a loss function.
787:23 - And an optimizer for a multi-class classification model.
787:32 - And so what's our option here for creating a loss function?
787:36 - Where do we find loss functions in PyTorch? I'm just going to get out of this.
787:39 - And I'll make a new tab here. And if we search torch.nn
787:44 - Because torch.nn is the basic building box for graphs. In other words, neural networks.
787:50 - Where do we find loss functions? Hmm, here we go. Beautiful.
787:55 - So we've seen that L1 loss or MSE loss could be used for regression, predicting a number.
788:00 - And I'm here to tell you as well that for classification, we're going to be looking at cross entropy loss.
788:07 - Now, this is for multi-class classification. For binary classification, we work with BCE loss.
788:14 - And of course, there's a few more here, but I'm going to leave that as something that you can explore on your own.
788:20 - Let's jump in to cross entropy loss.
788:24 - So what do we have here? This criterion computes. Remember, a loss function in PyTorch is also referred to as a criterion.
788:30 - You might also see loss function referred to as cost function, C-O-S-T.
788:36 - But I call them loss functions. So this criterion computes the cross entropy loss between input and target.
788:43 - Okay, so the input is something, and the target is our target labels.
788:49 - It is useful when training a classification problem with C classes. There we go.
788:54 - So that's what we're doing. We're training a classification problem with C classes, C is a number of classes.
789:00 - If provided the optional argument, weight should be a 1D tensor assigning a weight to each of the classes.
789:06 - So we don't have to apply a weight here, but why would you apply a weight? Well, it says, if we look at weight here,
789:15 - this is particularly useful when you have an unbalanced training set. So just keep this in mind as you're going forward.
789:20 - If you wanted to train a dataset that has imbalanced samples, in our case we have the same number of samples for each class,
789:29 - but sometimes you might come across a dataset with maybe you only have 10 yellow dots.
789:33 - And maybe you have 500 blue dots and only 100 red and 100 light blue dots.
789:39 - So you have an unbalanced dataset. So that's where you can come in and have a look at the weight parameter here.
789:44 - But for now, we're just going to keep things simple. We have a balanced dataset, and we're going to focus on using this loss function.
789:51 - If you'd like to read more, please, you can read on here. And if you wanted to find out more, you could go, what is cross entropy loss?
789:59 - And I'm sure you'll find a whole bunch of loss functions. There we go. There's the ML cheat sheet. I love that.
790:05 - The ML glossary, that's one of my favorite websites. Towards data science, you'll find that website, Wikipedia.
790:11 - Machine learning mastery is also another fantastic website. But you can do that all in your own time.
790:17 - Let's code together, hey. We'll set up a loss function. Oh, and one more resource before we get into code is that we've got the architecture,
790:26 - well, the typical architecture of a classification model. The loss function for multi-class classification is cross entropy or torch.nn.cross entropy loss.
790:37 - Let's code it out. If in doubt, code it out. So create a loss function for multi-class classification.
790:51 - And then we go, loss fn equals, and then dot cross entropy loss. Beautiful. And then we want to create an optimizer.
791:03 - Create an optimizer for multi-class classification. And then the beautiful thing about optimizers is they're quite flexible.
791:12 - They can go across a wide range of different problems. So the optimizer. So two of the most common, and I say most common because they work quite well.
791:20 - Across a wide range of problems. So that's why I've only listed two here. But of course, within the torch dot opt in module, you will find a lot more different optimizers.
791:30 - But let's stick with SGD for now. And we'll go back and go optimizer equals torch dot opt in for optimizer SGD for stochastic gradient descent.
791:43 - The parameters we want our optimizer to optimize model four, we're up to our fourth model already. Oh my goodness.
791:51 - Model four dot parameters. And we'll set the learning rate to 0.1. Of course, you could change the learning rate if you wanted to.
792:00 - In fact, I'd encourage you to see what happens if you do because why the learning rate is a hyper parameter.
792:09 - I'm better at writing code than I am at spelling. You can change. Wonderful. So we've now got a loss function and an optimizer for a multi class classification problem.
792:22 - What's next? Well, we could start to build.
792:26 - Building a training loop. We could start to do that, but I think we have a look at what the outputs of our model are.
792:35 - So more specifically, so getting prediction probabilities for a multi class pie torch model.
792:47 - So my challenge to you before the next video is to have a look at what happens if you pass x blob test through a model.
792:56 - And remember, what is a model's raw output? What is that referred to as?
793:01 - Oh, I'll let you have a think about that before the next video. I'll see you there.
793:06 - Welcome back. In the last video, we created a loss function and an optimizer for our multi class classification model.
793:13 - And recall the loss function measures how wrong our model's predictions are.
793:21 - And the optimizer optimizer updates our model parameters to try and reduce the loss.
793:35 - So that's what that does. And I also issued the challenge of doing a forward pass with model four, which is the most recent model that we created.
793:44 - And oh, did I just give you some code that wouldn't work? Did I do that on purpose? Maybe, maybe not, you'll never know.
793:53 - So if this did work, what are the raw outputs of our model? Let's get some raw outputs of our model.
794:00 - And if you recall, the raw outputs of a model are called logits.
794:04 - So we got a runtime error expected. All tensors to be on the same device are of course. Why did this come up?
794:11 - Well, because if we go next model for dot parameters, and if we check device, what happens here?
794:20 - Oh, we need to bring this in. Our model is on the CUDA device, whereas our data is on the CPU still.
794:29 - Can we go X? Is our data a tensor? Can we check the device parameter of that? I think we can.
794:35 - I might be proven wrong here. Oh, it's on the CPU. Of course, we're getting a runtime error.
794:41 - Did you catch that one? If you did, well done. So let's see what happens.
794:45 - But before we do a forward pass, how about we turn our model into a vowel mode to make some predictions with torch dot inference mode?
794:53 - We'll make some predictions. We don't necessarily have to do this because it's just tests, but it's a good habit.
794:59 - Oh, why prads? Equals, what do we get? Why prads? And maybe we'll just view the first 10.
795:08 - What do we get here? Oh, my goodness. How much are numbers on a page? Is this the same format as our data or our test labels?
795:17 - Let's have a look. No, it's not. Okay. Oh, we need why blob test. Excuse me.
795:25 - We're going to make that mistake a fair few times here. So we need to get this into the format of this. Hmm.
795:33 - How can we do that? Now, I want you to notice one thing as well is that we have one value here per one value, except that this is actually four values.
795:42 - Now, why is that? We have one, two, three, four. Well, that is because we set the out features up here. Our model outputs four features per sample.
795:54 - So each sample right now has four numbers associated with it. And what are these called? These are the logits.
796:01 - Now, what we have to do here, so let's just write this down in order to evaluate and train and test our model.
796:10 - We need to convert our model's outputs, outputs which are logits to prediction probabilities, and then to prediction labels.
796:25 - So we've done this before, but for binary classification. So we have to go from logits to predprobs to pred labels.
796:34 - All right, I think we can do this. So we've got some logits here. Now, how do we convert these logits to prediction probabilities?
796:43 - Well, we use an activation function. And if we go back to our architecture, what's our output activation here?
796:50 - For a binary classification, we use sigmoid. But for multi-class classification, these are the two main differences between multi-class classification and binary classification.
797:00 - One uses softmax, one uses cross entropy. And it's going to take a little bit of practice to know this off by heart.
797:06 - It took me a while, but that's why we have nice tables like this. And that's why we write a lot of code together.
797:11 - So we're going to use a softmax function here to convert out logits. Our models raw outputs, which is this here, to prediction probabilities.
797:20 - And let's see that. So convert our models, logit outputs to prediction probabilities.
797:30 - So let's create why predprobs. So I like to call prediction probabilities predprobs for short.
797:39 - So torch dot softmax. And then we go why logits. And we want it across the first dimension.
797:47 - So let's have a look. If we print why logits, we'll get the first five values there. And then look at the conversion here.
797:55 - Why logits? Oh, why predprobs? That's what we want to compare. Predprobs. Five. Let's check this out.
798:06 - Oh, what did we get wrong here? Why logits? Do we have why logits? Oh, no. We should change this to why logits, because really that's the raw output of our model here.
798:16 - Why logits? Let's rerun that. Check that. We know that these are different to these, but we ideally want these to be in the same format as these, our test labels.
798:26 - These are our models predictions. And now we should be able to convert. There we go. Okay, beautiful. What's happening here? Let's just get out of this.
798:36 - And we will add a few code cells here. So we have some space. Now, if you wanted to find out what's happening with torch dot softmax, what could you do?
798:45 - We could go torch softmax. See what's happening. Softmax. Okay, so here's the function that's happening. We replicated some nonlinear activation functions before.
798:57 - So if you wanted to replicate this, what could you do? Well, if in doubt, code it out. You could code this out. You've got the tools to do so.
799:04 - We've got softmax to some X input takes the exponential of X. So torch exponential over the sum of torch exponential of X. So I think you could code that out if you wanted to.
799:16 - But let's for now just stick with what we've got. We've got some logits here, and we've got some softmax, some logits that have been passed through the softmax function.
799:27 - So that's what's happened here. We've passed our logits as the input here, and it's gone through this activation function.
799:35 - These are prediction probabilities. And you might be like, Daniel, these are still just numbers on a page. But you also notice that none of them are negative.
799:43 - Okay, and there's another little tidbit about what's going on here. If we sum one of them up, let's get the first one.
799:50 - Will this work? And if we go torch dot sum, what happens?
799:58 - Ooh, they all sum up to one. So that's one of the effects of the softmax function. And then if we go torch dot max of Y-pred probes.
800:09 - So this is a prediction probability.
800:12 - For multi class, you'll find that for this particular sample here, the 0th sample, this is the maximum number. And so our model, what this is saying is our model is saying, this is the prediction probability.
800:25 - This is how much I think it is class 0. This number here, it's in order. This is how much I think it is class 1. This is how much I think it is class 2.
800:34 - This is how much I think it is class 3. And so we have one value for each of our four classes, a little bit confusing because it's 0th indexed.
800:43 - But the maximum value here is this index. And so how would we get the particular index value of whatever the maximum number is across these values?
800:55 - Well, we can take the argmax and we get tensor 1. So for this particular sample, this one here, our model, and these guesses or these predictions aren't very good.
801:08 - Why is that? Well, because our model is still just predicting with random numbers, we haven't trained it yet. So this is just random output here, basically.
801:17 - But for now, the premise still remains that our model thinks that for this sample using random numbers, it thinks that index 1 is the right class or class number 1 for this particular sample.
801:30 - And then for this next one, what's the maximum number here? I think it would be the 0th index and the same for the next one. What's the maximum number here?
801:39 - Well, it would be the 0th index as well. But of course, these numbers are going to change once we've trained our model.
801:46 - So how do we get the maximum index value of all of these? So this is where we can go, convert our model's prediction probabilities to prediction labels.
802:02 - So let's do that. We can go ypreds equals torch dot argmax on ypredprobs. And if we go across the first dimension as well. So now let's have a look at ypreds.
802:18 - Do we have prediction labels in the same format as our ylob test? Beautiful. Yes, we do. Although many of them are wrong, as you can see, ideally they would line up with each other.
802:36 - But because our model is predicting or making predictions with random numbers, so they haven't been our model hasn't been trained. All of these are basically random outputs.
802:44 - So hopefully once we train our model, it's going to line up the values of the predictions are going to line up with the values of the test labels.
802:52 - But that is how we go from our model's raw outputs to prediction probabilities to prediction labels for a multi-class classification problem.
803:03 - So let's just add the steps here, logits, raw output of the model, predprobs, to get the prediction probabilities, use torch dot softmax or the softmax activation function, pred labels, take the argmax of the prediction probabilities.
803:25 - So we're going to see this in action later on when we evaluate our model, but I feel like now that we know how to go from logits to prediction probabilities to pred labels, we can write a training loop.
803:37 - So let's set that up. 8.5, create a training loop, and testing loop for a multi-class pytorch model. This is so exciting.
803:51 - I'll see you in the next video. Let's build our first training and testing loop for a multi-class pytorch model, and I'll give you a little hint.
803:59 - It's quite similar to the training and testing loops we've built before, so you might want to give it a shot. I think you can.
804:05 - Otherwise, we'll do it together in the next video.
804:09 - Welcome back. In the last video, we covered how to go from raw logits, which is the output of the model, the raw output of the model for a multi-class pytorch model.
804:20 - Then we turned our logits into prediction probabilities using torch.softmax, and then we turn those prediction probabilities into prediction labels by taking the argmax, which returns the index of where the maximum value occurs in the prediction probability.
804:38 - So for this particular sample, with these four values, because it outputs four values, because we're working with four classes, if we were working with 10 classes, it would have 10 values, the principle of these steps would still be the same.
804:51 - So for this particular sample, this is the value that's the maximum, so we would take that index, which is 1. For this one, the index 0 has the maximum value.
805:03 - For this sample, same again, and then same again, I mean, these prediction labels are just random, right? So they're quite terrible.
805:11 - But now we're going to change that, because we're going to build a training and testing loop for our multi-class model.
805:17 - Let's do that. So fit the multi-class model to the data.
805:24 - Let's go set up some manual seeds.
805:29 - Torch dot manual seed, again, don't worry too much if our numbers on the page are not exactly the same. That's inherent to the randomness of machine learning.
805:38 - We're setting up the manual seeds to try and get them as close as possible, but these do not guarantee complete determinism, which means the same output.
805:47 - But we're going to try. The direction is more important.
805:51 - Set number of epochs. We're going to go epochs. How about we just do 100? I reckon we'll start with that. We can bump it up to 1000 if we really wanted to.
806:01 - Let's put the data to the target device. What's our target device? Well, it doesn't really matter because we've set device agnostic code.
806:10 - So whether we're working with a CPU or a GPU, our code will use whatever device is available. I'm typing blog again.
806:18 - So we've got x blob train, y blob train. This is going to go where? It's going to go to the device.
806:27 - And y blob train to device. And we're going to go x blob test. And then y blob test equals x blob test to device.
806:43 - Otherwise, we'll get device issues later on, and we'll send this to device as well. Beautiful. Now, what do we do now? Well, we loop through data.
806:54 - Loop through data. So for an epoch in range epochs for an epoch in a range.
807:01 - Epox. I don't want that auto correct. Come on, Google Colab. Work with me here.
807:05 - We're training our first multi-class classification model. This is serious business. No, I'm joking. It's actually quite fun.
807:12 - So model four dot train. And let's do the forward pass. I'm not going to put much commentary here because we've been through this before.
807:21 - But what are the logits? The logits are raw outputs of our model. So we'll just go x blob train.
807:29 - And x test. I didn't want that. X blob train. Why did that do that? I need to turn off auto correct in Google Colab. I've been saying it for a long time.
807:41 - Y pred equals torch dot softmax. So what are we doing here? We're going from logits to prediction probabilities here.
807:50 - So torch softmax. Y logits. Across the first dimension. And then we can take the argmax of this and dim equals one.
808:03 - In fact, I'm going to show you a little bit of, oh, I've written blog here. Maybe auto correct would have been helpful for that.
808:08 - A little trick. You don't actually have to do the torch softmax. The logits. If you just took the argmax of the logits is a little test for you.
808:16 - Just take the argmax of the logits. And see, do you get the same similar outputs as what you get here?
808:23 - So I've seen that done before, but for completeness, we're going to use the softmax activation function because you'll often see this in practice.
808:31 - And now what do we do? We calculate the loss. So the loss FM. We're going to use categorical cross entropy here or just cross entropy loss.
808:41 - So if we check our loss function, what do we have? We have cross entropy loss. We're going to compare our models, logits to y blob train.
808:52 - And then what are we going to do? We're going to calculate the accuracy because we're working with the classification problem.
808:58 - It'd be nice if we had accuracy as well as loss. Accuracy is one of the main classification evaluation metrics.
809:06 - y pred equals y pred. y pred. And now what do we do? Well, we have to zero grab the optimizer. Optimizer zero grad.
809:18 - Then we go loss backward. And then we step the optimizer. Optimizer step, step, step.
809:25 - So none of these steps we haven't covered before. We do the forward pass. We calculate the loss and any evaluation metric we choose to do so.
809:33 - We zero the optimizer. We perform back propagation on the loss. And we step the optimizer.
809:39 - The optimizer will hopefully behind the scenes update the parameters of our model to better represent the patterns in our training data.
809:47 - And so we're going to go testing code here. What do we do for testing code? Well, or inference code.
809:53 - We set our model to a vowel mode.
809:58 - That's going to turn off a few things behind the scenes that our model doesn't need such as dropout layers, which we haven't covered.
810:04 - But you're more than welcome to check them out if you go torch and end.
810:10 - Dropout layers. Do we have dropout? Dropout layers. Beautiful. And another one that it turns off is match norm.
810:18 - Beautiful. And also you could search this. What does model dot a vowel do?
810:24 - And you might come across stack overflow question. One of my favorite resources.
810:29 - So there's a little bit of extra curriculum. But I prefer to see things in action.
810:34 - So with torch inference mode, again, this turns off things like gradient tracking and a few more things.
810:40 - So we get as fast as code as possible because we don't need to track gradients when we're making predictions.
810:45 - We just need to use the parameters that our model has learned.
810:49 - We want X blob test to go to our model here for the test logits. And then for the test preds, we're going to do the same step as what we've done here.
810:57 - We're going to go torch dot softmax on the test logits across the first dimension.
811:04 - And we're going to call the argmax on that to get the index value of where the maximum prediction probability value occurs.
811:12 - We're going to calculate the test loss or loss function. We're going to pass in what the test logits here.
811:19 - Then we're going to pass in why blob test compare the test logits behind the scenes.
811:24 - Our loss function is going to do some things that convert the test logits into the same format as our test labels and then return us a value for that.
811:32 - Then we'll also calculate the test accuracy here by passing in the why true as why blob test.
811:40 - And we have the y pred equals y pred.
811:43 - Wonderful.
811:44 - And then what's our final step?
811:46 - Well, we want to print out what's happening because I love seeing metrics as our model trains.
811:53 - It's one of my favorite things to watch.
811:55 - If we go if epoch, let's do it every 10 epochs because we've got 100 so far.
812:00 - It equals zero.
812:02 - Let's print out a nice f string with epoch.
812:08 - And then we're going to go loss.
812:11 - What do we put in here?
812:12 - We'll get our loss value, but we'll take it to four decimal places and we'll get the training accuracy, which will be acc.
812:20 - And we'll take this to two decimal places and we'll get a nice percentage sign there.
812:26 - And we'll go test loss equals test loss and we'll go there.
812:33 - And finally, we'll go test act at the end here, test act.
812:38 - Now, I'm sure by now we've written a fair few of these.
812:41 - You're either getting sick of them or you're like, wow, I can actually do the steps through here.
812:46 - And so don't worry, we're going to be functionalizing all of this later on,
812:49 - but I thought I'm going to include them as much as possible so that we can practice as much as possible together.
812:54 - So you ready?
812:55 - We're about to train our first multi-class classification model.
812:59 - In three, two, one, let's go.
813:03 - No typos.
813:04 - Of course.
813:05 - What do we get wrong here?
813:07 - Oh, this is a fun error.
813:09 - Runtime error.
813:11 - NLL loss for reduced CUDA kernel to the index not implemented for float.
813:16 - Okay, that's a pretty full on bunch of words there.
813:19 - I don't really know how to describe that.
813:21 - But here's a little hint.
813:22 - We've got float there.
813:23 - So we know that float is what?
813:25 - Float is a form of data.
813:26 - It's a data type.
813:28 - So potentially because that's our hint.
813:31 - We said not implemented for float.
813:33 - So maybe we've got something wrong up here.
813:35 - Our data is of the wrong type.
813:38 - Can you see anywhere where our data might be the wrong type?
813:43 - Well, let's print it out.
813:45 - Where's our issue here?
813:47 - Why logits?
813:48 - Why blob train?
813:50 - Okay.
813:51 - Why blob train?
813:53 - And why logits?
813:54 - What does why blob train look like?
813:57 - Why blob train?
814:01 - Okay.
814:02 - And what's the D type here?
814:08 - Float.
814:09 - Okay.
814:10 - So it's not implemented for float.
814:13 - Hmm.
814:14 - Maybe we have to turn them into a different data type.
814:16 - What if we went type torch long tensor?
814:26 - What happens here?
814:28 - Expected all tensors to be on the same device but found at least two devices.
814:31 - Oh, my goodness.
814:32 - What do we got wrong here?
814:34 - Type torch long tensor.
814:37 - Friends.
814:38 - Guess what?
814:39 - I found it.
814:40 - And so it was to do with this pesky little data type issue here.
814:44 - So if we run this again and now this one took me a while to find and I want you to know that,
814:49 - that behind the scenes, even though, again, this is a machine learning cooking show,
814:53 - it still takes a while to troubleshoot code and you're going to come across this.
814:56 - But I thought rather than spend 10 minutes doing it in a video, I'll show you what I did.
815:00 - So we went through this and we found that, hmm, there's something going on here.
815:04 - I don't quite know what this is.
815:06 - And that seems quite like a long string of words, not implemented for float.
815:11 - And then we looked back at the line where it went wrong.
815:14 - And so that we know that maybe the float is hinting at that one of these two tensors is of the wrong data type.
815:21 - Now, why would we think that it's the wrong data type?
815:24 - Well, because anytime you see float or int or something like that, it generally hints at one of your data types being wrong.
815:32 - And so the error is actually right back up here where we created our tensor data.
815:40 - So we turned our labels here into float, which generally is okay in PyTorch.
815:45 - However, this one should be of type torch dot long tensor, which we haven't seen before.
815:51 - But if we go into torch long tensor, let's have a look torch dot tensor.
815:58 - Do we have long tensor?
816:01 - Here we go.
816:02 - 64 bit integer signed.
816:04 - So why do we need torch dot long tensor?
816:08 - And again, this took me a while to find.
816:10 - And so I want to express this that in your own code, you probably will butt your head up against some issues and errors that do take you a while to find.
816:20 - And data types is one of the main ones.
816:22 - But if we look in the documentation for cross entropy loss, the way I kind of found this out was this little hint here.
816:29 - The performance of the criteria is generally better when the target contains class indices, as this allows for optimized computation.
816:36 - But I read this and it says target contains class indices.
816:40 - I'm like, hmm, alza indices already, but maybe they should be integers and not floats.
816:46 - But then if you actually just look at the sample code, you would find that they use d type equals torch dot long.
816:54 - Now, that's the thing with a lot of code around the internet is that sometimes the answer you're looking for is a little bit buried.
817:03 - But if in doubt, run the code and butt your head up against a wall for a bit and keep going.
817:10 - So let's just rerun all of this and see do we have an error here?
817:14 - Let's train our first multi-class classification model together.
817:19 - No arrows, fingers crossed.
817:20 - But what did we get wrong here?
817:22 - OK, so we've got different size.
817:24 - We're slowly working through all of the errors in deep learning here.
817:27 - Value error, input batch size 200 to match target size 200.
817:31 - So this is telling me maybe our test data, which is of size 200, is getting mixed up with our training data, which is of size 800.
817:40 - So we've got test loss, the test logits, model four.
817:49 - What's the size?
817:50 - Let's print out print test logits dot shape and wine blob test.
817:57 - So troubleshooting on the fly here, everyone.
818:01 - What do we got?
818:03 - Torch size 800.
818:06 - Where are our test labels coming from?
818:09 - Wine blob test equals, oh, there we go.
818:13 - Ah, did you catch that before?
818:15 - Maybe you did, maybe you didn't.
818:17 - But I think we should be right here.
818:19 - Now if we just comment out this line, so we've had a data type issue and we've had a shape issue.
818:24 - Two of the main and machine learning, oh, and again, we've had some issues.
818:28 - Wine blob test.
818:29 - What's going on here?
818:30 - I thought we just changed the shape.
818:33 - Oh, no, we have to go up and reassign it again because now this is definitely why blob, yes.
818:41 - Let's rerun all of this, reassign our data.
818:49 - We are running into every single error here, but I'm glad we're doing this because otherwise you might not see how to
818:53 - troubleshoot these type of things.
818:56 - So the size of a tensor much match the size.
818:59 - Oh, we're getting the issue here.
819:01 - Test spreads.
819:03 - Oh, my goodness.
819:04 - We have written so much code here.
819:06 - Test spreads.
819:07 - So instead of wire spread, this should be test spreads.
819:12 - Fingers crossed.
819:13 - Are we training our first model yet or what?
819:15 - There we go.
819:16 - Okay, I'm going to printing out some stuff.
819:18 - I don't really want to print out that stuff.
819:20 - I want to see the loss go down, so I'm going to.
819:23 - So friends, I hope you know that we've just been through some of the most fundamental troubleshooting steps.
819:29 - And you might say, oh, Daniel, there's a cop out because you're just coding wrong.
819:32 - And in fact, I code wrong all the time.
819:36 - But we've now worked out how to troubleshoot them shape errors and data type errors.
819:42 - But look at this.
819:43 - After all of that, thank goodness.
819:46 - Our loss and accuracy go in the directions that we want them to go.
819:51 - So our loss goes down and our accuracy goes up.
819:55 - Beautiful.
819:56 - So it looks like that our model is working on a multi-class classification data set.
820:01 - So how do we check that?
820:03 - Well, we're going to evaluate it in the next step by visualize, visualize, visualize.
820:08 - So you might want to give that a shot.
820:10 - See if you can use our plot decision boundary function.
820:14 - We'll use our model to separate the data here.
820:17 - So it's going to be much the same as what we did for binary classification.
820:21 - But this time we're using a different model and a different data set.
820:25 - I'll see you there.
820:28 - Welcome back.
820:29 - In the last video, we went through some of the steps that we've been through before
820:33 - in terms of training and testing a model.
820:36 - But we also butted our heads up against two of the most common issues in machine learning and deep learning in general.
820:42 - And that is data type issues and shape issues.
820:45 - But luckily we were able to resolve them.
820:48 - And trust me, you're going to run across many of them in your own deep learning and machine learning endeavors.
820:54 - So I'm glad that we got to have a look at them and sort of I could show you what I do to troubleshoot them.
820:59 - But in reality, it's a lot of experimentation.
821:02 - Run the code, see what errors come out, Google the errors, read the documentation, try again.
821:08 - But with that being said, it looks like that our model, our multi-class classification model has learned something.
821:16 - The loss is going down, the accuracy is going up.
821:19 - But we can further evaluate this by making and evaluating predictions with a PyTorch multi-class model.
821:31 - So how do we make predictions?
821:33 - We've seen this step before, but let's reiterate.
821:36 - Make predictions, we're going to set our model to what mode, a vowel mode.
821:40 - And then we're going to turn on what context manager, inference mode.
821:44 - Because we want to make inference, we want to make predictions.
821:47 - Now what do we make predictions on?
821:49 - Or what are the predictions? They're going to be logits because why?
821:52 - They are the raw outputs of our model.
821:55 - So we'll take model four, which we just trained and we'll pass it the test data.
821:59 - Well, it needs to be blob test, by the way.
822:02 - I keep getting that variable mixed up.
822:04 - We just had enough problems with the data, Daniel.
822:06 - We don't need any more. You're completely right.
822:09 - I agree with you.
822:10 - But we're probably going to come across some more problems in the future.
822:13 - Don't you worry about that.
822:14 - So let's view the first 10 predictions.
822:17 - Why logits? What do they look like?
822:21 - All right, just numbers on the page. They're raw logits.
822:23 - Now how do we go from go from logits to prediction probabilities?
822:31 - How do we do that?
822:32 - With a multi-class model, we go y-pred-probs equals torch.softmax on the y-logits.
822:40 - And we want to do it across the first dimension.
822:43 - And what do we have when we go pred-probs?
822:46 - Let's go up to the first 10.
822:50 - Are we apples to apples yet?
822:52 - What does our y-blog test look like?
822:58 - We're not apples to apples yet, but we're close.
823:00 - So these are prediction probabilities.
823:02 - You'll notice that we get some fairly different values here.
823:04 - And remember, the one closest to one here, the value closest to one,
823:08 - which looks like it's this, the index of the maximum value
823:12 - is going to be our model's predicted class.
823:15 - So this index is index one.
823:17 - And does it correlate here? Yes.
823:19 - One, beautiful.
823:20 - Then we have index three, which is the maximum value here.
823:23 - Three, beautiful.
823:25 - And then we have, what do we have here?
823:27 - Index two, yes.
823:30 - Okay, wonderful.
823:31 - But let's not step through that.
823:32 - We're programmers.
823:33 - We can do this with code.
823:34 - So now let's go from pred-probs to pred-labels.
823:40 - So y-pred-equals, how do we do that?
823:44 - Well, we can do torch.argmax on the y-pred-probs.
823:50 - And then we can pass dim equals one.
823:52 - We could also do it this way.
823:54 - So y-pred-probs call dot-argmax.
823:57 - There's no real difference between these two.
823:59 - But we're just going to do it this way, called torch.argmax.
824:03 - y-pred-es, let's view the first 10.
824:05 - Are we now comparing apples to apples when we go y-blob test?
824:12 - Yes, we are.
824:14 - Have a go at that.
824:15 - Look, one, three, two, one, zero, three, one, three, two, one, zero, three.
824:20 - Beautiful.
824:21 - Now, we could line these up and look at and compare them all day.
824:24 - I mean, that would be fun.
824:25 - But I know what something that would be even more fun.
824:29 - Let's get visual.
824:30 - So plot dot figure.
824:33 - And we're going to go fig size equals 12.6, just because the beauty of this
824:39 - being a cooking show is I kind of know what ingredients work from ahead of time.
824:43 - Despite what you saw in the last video with all of that trouble shooting.
824:46 - But I'm actually glad that we did that because seriously.
824:50 - Shape issues and data type issues.
824:53 - You're going to come across a lot of them.
824:55 - The two are the main issues I troubleshoot, aside from device issues.
824:59 - So let's go x-blob train and y-blob train.
825:05 - And we're going to do another plot here.
825:08 - We're going to get subplot one, two, two.
825:11 - And we're going to do this for the test data.
825:14 - Test and then plot decision boundary.
825:17 - Plot decision boundary with model four on x-blob test and y-blob test as well.
825:30 - Let's see this.
825:31 - Did we train a multi-class?
825:32 - Oh my goodness.
825:33 - Yes, we did.
825:34 - Our code worked faster than I can speak.
825:37 - Look at that beautiful looking plot.
825:39 - We've separated our data almost as best as what we could.
825:42 - Like there's some here that are quite inconspicuous.
825:45 - And now what's the thing about these lines?
825:48 - With this model have worked, I posed the question a fair few videos ago,
825:52 - whenever we created our multi-class model that could we separate this data
825:56 - without nonlinear functions.
825:59 - So how about we just test that?
826:01 - Since we've got the code ready, let's go back up.
826:04 - We've got nonlinear functions here.
826:06 - We've got relu here.
826:07 - So I'm just going to recreate our model there.
826:10 - So I just took relu out.
826:11 - That's all I did.
826:12 - Commented it out, this code will still all work.
826:15 - Or fingers crossed it will.
826:16 - Don't count your chickens before they hatch.
826:18 - Daniel, come on.
826:19 - We're just going to rerun all of these cells.
826:21 - All the code's going to stay the same.
826:23 - All we did was we took the nonlinearity out of our model.
826:26 - Is it still going to work?
826:28 - Oh my goodness.
826:29 - It still works.
826:31 - Now why is that?
826:33 - Well, you'll notice that the lines are a lot more straighter here.
826:36 - Did we get different metrics?
826:38 - I'll leave that for you to compare.
826:39 - Maybe these will be a little bit different.
826:41 - I don't think they're too far different.
826:43 - But that is because our data is linearly separable.
826:48 - So we can draw straight lines only to separate our data.
826:51 - However, a lot of the data that you deal with in practice
826:54 - will require linear and nonlinear.
826:57 - Hence why we spent a lot of time on that.
826:59 - Like the circle data that we covered before.
827:01 - And let's look up an image of a pizza.
827:03 - If you're building a food vision model to take photos of food
827:08 - and separate different classes of food,
827:11 - could you do this with just straight lines?
827:14 - You might be able to, but I personally don't think
827:17 - that I could build a model to do such a thing.
827:19 - And in fact, PyTorch makes it so easy to add nonlinearities
827:22 - to our model, we might as well have them in
827:24 - so that our model can use it if it needs it
827:27 - and if it doesn't need it, well, hey,
827:29 - it's going to build a pretty good model as we saw before
827:32 - if we included the nonlinearities in our model.
827:35 - So we could uncomment these and our model is still
827:37 - going to perform quite well.
827:38 - That is the beauty of neural networks,
827:40 - is that they decide the numbers that should
827:43 - represent outdated the best.
827:45 - And so, with that being said, we've evaluated our model,
827:49 - we've trained our multi-class classification model,
827:51 - we've put everything together, we've gone from binary
827:54 - classification to multi-class classification.
827:57 - I think there's just one more thing that we should cover
828:00 - and that is, let's go here, section number nine,
828:04 - a few more classification metrics.
828:08 - So, as I said before, evaluating a model,
828:12 - let's just put it here, to evaluate our model,
828:15 - our classification models, that is,
828:18 - evaluating a model is just as important as training a model.
828:22 - So, I'll see you in the next video.
828:24 - Let's cover a few more classification metrics.
828:28 - Welcome back.
828:29 - In the last video, we evaluated our
828:31 - multi-class classification model visually.
828:34 - And we saw that it did pretty darn well,
828:36 - because our data turned out to be linearly separable.
828:39 - So, our model, even without non-linear functions,
828:41 - could separate the data here.
828:43 - However, as I said before, most of the data that you deal with
828:46 - will require some form of linear and non-linear function.
828:50 - So, just keep that in mind, and the beauty of PyTorch is
828:53 - that it allows us to create models with linear
828:56 - and non-linear functions quite flexibly.
828:59 - So, let's write down here.
829:01 - If we wanted to further evaluate our classification models,
829:04 - we've seen accuracy.
829:06 - So, accuracy is one of the main methods
829:08 - of evaluating classification models.
829:10 - So, this is like saying, out of 100 samples,
829:14 - how many does our model get right?
829:18 - And so, we've seen our model right now
829:21 - is that testing accuracy of nearly 100%.
829:23 - So, it's nearly perfect.
829:25 - But, of course, there were a few tough samples,
829:27 - which I mean a little bit hard.
829:29 - Some of them are even within the other samples,
829:31 - so you can forgive it a little bit here
829:33 - for not being exactly perfect.
829:36 - What are some other metrics here?
829:38 - Well, we've also got precision,
829:41 - and we've also got recall.
829:44 - Both of these will be pretty important
829:46 - when you have classes with different amounts of values in them.
829:50 - So, precision and recall.
829:52 - So, accuracy is pretty good to use when you have balanced classes.
829:57 - So, this is just text on a page for now.
830:00 - F1 score, which combines precision and recall.
830:03 - There's also a confusion matrix,
830:05 - and there's also a classification report.
830:09 - So, I'm going to show you a few code examples
830:12 - of where you can access these,
830:14 - and I'm going to leave it to you as extra curriculum
830:17 - to try each one of these out.
830:20 - So, let's go into the keynote.
830:23 - And by the way, you should pay yourself on the back here
830:25 - because we've just gone through all of the PyTorch workflow
830:28 - for a classification problem.
830:30 - Not only just binary classification,
830:32 - we've done multi-class classification as well.
830:35 - So, let's not stop there, though.
830:38 - Remember, building a model,
830:40 - evaluating a model is just as important as building a model.
830:43 - So, we've been through non-linearity.
830:46 - We've seen how we could replicate non-linear functions.
830:49 - We've talked about the machine learning explorer's motto,
830:52 - visualize, visualize, visualize.
830:55 - Machine learning practitioners motto is experiment, experiment, experiment.
830:58 - I think I called that the machine learning or data scientist motto.
831:01 - Same thing, you know?
831:03 - And steps in modeling with PyTorch.
831:05 - We've seen this in practice,
831:06 - so we don't need to look at these slides.
831:08 - I mean, they'll be available on the GitHub if you want them,
831:10 - but here we are.
831:11 - Some common classification evaluation methods.
831:14 - So, we have accuracy.
831:15 - There's the formal formula if you want,
831:17 - but there's also code, which is what we've been focusing on.
831:20 - So, we wrote our own accuracy function, which replicates this.
831:23 - By the way, Tp stands for not toilet paper,
831:26 - it stands for true positive,
831:28 - Tn is true negative, false positive, Fp, false negative, Fn.
831:33 - And so, the code, we could do torch metrics.
831:36 - Oh, what's that?
831:37 - But when should you use it?
831:38 - The default metric for classification problems.
831:40 - Note, it is not the best for imbalanced classes.
831:43 - So, if you had, for example,
831:45 - 1,000 samples of one class,
831:48 - so, number one, label number one,
831:50 - but you had only 10 samples of class zero.
831:54 - So, accuracy might not be the best to use for then.
831:58 - For imbalanced data sets,
832:00 - you might want to look into precision and recall.
832:03 - So, there's a great article called,
832:05 - I think it's beyond accuracy, precision and recall,
832:09 - which gives a fantastic overview of, there we go.
832:12 - This is what I'd recommend.
832:14 - There we go, by Will Coestron.
832:17 - So, I'd highly recommend this article as some extra curriculum here.
832:22 - See this article for when to use precision recall.
832:29 - We'll go there.
832:31 - Now, if we look back,
832:32 - there is the formal formula for precision,
832:35 - true positive over true positive plus false positive.
832:38 - So, higher precision leads to less false positives.
832:41 - So, if false positives are not ideal,
832:44 - you probably want to increase precision.
832:46 - If false negatives are not ideal,
832:49 - you want to increase your recall metric.
832:51 - However, you should be aware that there is such thing as a precision recall trade-off.
832:55 - And you're going to find this in your experimentation.
832:58 - Precision recall trade-off.
833:01 - So, that means that, generally, if you increase precision,
833:05 - you lower recall.
833:07 - And, inversely, if you increase precision, you lower recall.
833:11 - So, check out that, just to be aware of that.
833:14 - But, again, you're going to learn this through practice of evaluating your models.
833:18 - If you'd like some code to do precision and recall,
833:21 - you've got torchmetrics.precision, or torchmetrics.recall,
833:24 - as well as scikit-learn.
833:26 - So scikit-learn has implementations for many different classification metrics.
833:30 - Torchmetrics is a PyTorch-like library.
833:34 - And then we have F1 score, which combines precision and recall.
833:38 - So, it's a good combination if you want something in between these two.
833:42 - And then, finally, there's a confusion matrix.
833:45 - I haven't listed here a classification report, but I've listed it up here.
833:49 - And we can see a classification report in scikit-learn.
833:53 - Classification report.
833:55 - Classification report kind of just puts together all of the metrics that we've talked about.
833:59 - And we can go there.
834:03 - But I've been talking a lot about torchmetrics.
834:06 - So let's look up torchmetrics' accuracy.
834:09 - Torchmetrics.
834:11 - So this is a library.
834:13 - I don't think it comes with Google Colab at the moment,
834:16 - but you can import torchmetrics, and you can initialize a metric.
834:19 - So we've built our own accuracy function, but the beauty of using torchmetrics
834:24 - is that it uses PyTorch-like code.
834:27 - So we've got metric, preds, and target.
834:31 - And then we can find out what the value of the accuracy is.
834:36 - And if you wanted to implement your own metrics, you could subclass the metric class here.
834:42 - But let's just practice this.
834:44 - So let's check to see if I'm going to grab this and copy this in here.
834:51 - If you want access to a lot of PyTorch metrics, see torchmetrics.
835:00 - So can we import torchmetrics?
835:03 - Maybe it's already in Google Colab.
835:08 - No, not here.
835:09 - But that's all right.
835:10 - We'll go pip install torchmetrics.
835:13 - So Google Colab has access to torchmetrics.
835:16 - And that's going to download from torchmetrics.
835:19 - It shouldn't take too long.
835:20 - It's quite a small package.
835:21 - Beautiful.
835:22 - And now we're going to go from torchmetrics import accuracy.
835:29 - Wonderful.
835:30 - And let's see how we can use this.
835:33 - So setup metric.
835:34 - So we're going to go torchmetric underscore accuracy.
835:38 - We could call it whatever we want, really.
835:40 - But we need accuracy here.
835:42 - We're just going to set up the class.
835:44 - And then we're going to calculate the accuracy of our multi-class model by calling torchmetric accuracy.
835:53 - And we're going to pass it Y threads and Y blob test.
835:58 - Let's see what happens here.
836:01 - Oh, what did we get wrong?
836:04 - Runtime error.
836:05 - Expected all tensors to be on the same device, but found at least two devices.
836:08 - Oh, of course.
836:11 - Now, remember how I said torchmetrics implements PyTorch like code?
836:16 - Well, let's check what device this is on.
836:20 - Oh, it's on the CPU.
836:22 - So something to be aware of that if you use torchmetrics, you have to make sure your metrics
836:27 - are on the same device by using device agnostic code as your data.
836:32 - So if we run this, what do we get?
836:34 - Beautiful.
836:35 - We get an accuracy of 99.5%, which is in line with the accuracy function that we coded ourselves.
836:43 - So if you'd like a lot of pre-built metrics functions, be sure to see either
836:47 - scikit-learn for any of these or torchmetrics for any PyTorch like metrics.
836:53 - But just be aware, if you use the PyTorch version, they have to be on the same
836:56 - device.
836:57 - And if you'd like to install it, what do we have?
837:01 - Where's the metrics?
837:02 - Module metrics?
837:03 - Do we have classification?
837:05 - There we go.
837:06 - So look how many different types of classification metrics there are from torchmetrics.
837:11 - So I'll leave that for you to explore.
837:13 - The resources for this will be here.
837:16 - This is an extracurricular article for when to use precision recall.
837:20 - And another extracurricular would be to go through the torchmetrics module for 10 minutes
837:26 - and have a look at the different metrics for classification.
837:30 - So with that being said, I think we've covered a fair bit.
837:36 - But I think it's also time for you to practice what you've learned.
837:40 - So let's cover some exercises in the next video.
837:43 - I'll see you there.
837:46 - Welcome back.
837:47 - In the last video, we looked at a few more classification metrics, a little bit of a high
837:52 - level overview for some more ways to evaluate your classification models.
837:57 - And I linked some extracurricular here that you might want to look into as well.
838:01 - But we have covered a whole bunch of code together.
838:04 - But now it's time for you to practice some of this stuff on your own.
838:07 - And so I have some exercises prepared.
838:10 - Now, where do you go for the exercises?
838:12 - Well, remember on the learnpytorch.io book, for each one of these chapters, there's
838:16 - a section.
838:17 - Now, just have a look at how much we've covered.
838:19 - If I scroll, just keep scrolling.
838:21 - Look at that.
838:22 - We've covered all of that in this module.
838:23 - That's a fair bit of stuff.
838:24 - But down the bottom of each one is an exercises section.
838:28 - So all exercises are focusing on practicing the code in the sections above, all of these
838:32 - sections here.
838:33 - I've got number one, two, three, four, five, six, seven.
838:39 - Yeah, seven exercises, nice, writing plenty of code.
838:42 - And then, of course, extracurricular.
838:44 - So these are some challenges that I've mentioned throughout the entire section zero two.
838:50 - But I'm going to link this in here.
838:52 - Exercises.
838:53 - But, of course, you can just find it on the learnpytorch.io book.
838:57 - So if we come in here and we just create another heading.
839:01 - Exercises.
839:02 - And extracurricular.
839:10 - And then we just write in here.
839:14 - See exercises and extracurricular.
839:18 - Here.
839:20 - And so if you'd like a template of the exercise code, you can go to the PyTorch deep learning
839:27 - repo.
839:28 - And then within the extras folder, we have exercises and solutions.
839:32 - You might be able to guess what's in each of these exercises.
839:35 - We have O2 PyTorch classification exercises.
839:39 - This is going to be some skeleton code.
839:41 - And then, of course, we have the solutions as well.
839:44 - Now, this is just one form of solutions.
839:46 - But I'm not going to look at those because I would recommend you looking at the exercises
839:51 - first before you go into the solutions.
839:54 - So we have things like import torch.
839:57 - Set up device agnostic code.
839:59 - Create a data set.
840:01 - Turn data into a data frame.
840:03 - And then et cetera, et cetera.
840:05 - For the things that we've done throughout this section.
840:08 - So give that a go.
840:10 - Try it on your own.
840:11 - And if you get stuck, you can refer to the notebook that we've coded together.
840:15 - All of this code here.
840:16 - You can refer to the documentation, of course.
840:21 - And then you can refer to as a last resort, the solutions notebooks.
840:26 - So give that a shot.
840:28 - And congratulations on finishing.
840:31 - Section 02 PyTorch classification.
840:35 - Now, if you're still there, you're still with me.
840:38 - Let's move on to the next section.
840:39 - We're going to cover a few more things of deep learning with PyTorch.
840:43 - I'll see you there.
840:48 - Hello, and welcome back.
840:50 - We've got another section.
840:52 - We've got computer vision and convolutional neural networks with.
840:56 - PyTorch.
840:58 - Now, computer vision is one of my favorite, favorite deep learning topics.
841:03 - But before we get into the materials, let's answer a very important question.
841:06 - And that is, where can you get help?
841:09 - So, first and foremost, is to follow along with the code as best you can.
841:13 - We're going to be writing a whole bunch of PyTorch computer vision code.
841:16 - And remember our motto.
841:17 - If and out, run the code.
841:19 - See what the inputs and outputs are of your code.
841:22 - And that's try it yourself.
841:24 - If you need the doc string to read about what the function you're using does,
841:28 - you can press shift command and space in Google CoLab.
841:31 - Or it might be control if you're on Windows.
841:33 - Otherwise, if you're still stuck, you can search for the code that you're running.
841:37 - You might come across stack overflow or the PyTorch documentation.
841:40 - We've spent a bunch of time in the PyTorch documentation already.
841:43 - And we're going to be referencing a whole bunch in the next module in section three.
841:48 - We're up to now.
841:49 - If you go through all of these four steps, the next step is to try it again.
841:53 - If and out, run the code.
841:55 - And then, of course, if you're still stuck, you can ask a question on the PyTorch deep learning repo.
842:00 - Discussions tab.
842:02 - Now, if we open this up, we can go new discussion.
842:06 - And you can write here section 03 for the computer vision.
842:09 - My problem is, and then in here, you can write some code.
842:15 - Be sure to format it as best you can.
842:17 - That way it'll help us answer it.
842:19 - And then go, what's happening here?
842:23 - Now, why do I format the code in these back ticks here?
842:27 - It's so that it looks like code and that it's easier to read when it's formatted on the GitHub discussion.
842:32 - Then you can select a category.
842:33 - If you have a general chat, an idea, a poll, a Q&A, or a show and tell of something you've made,
842:39 - or what you've learned from the course.
842:41 - For question and answering, you want to put it as Q&A.
842:43 - Then you can click start discussion.
842:45 - And it'll appear here.
842:47 - And that way, they'll be searchable and we'll be able to help you out.
842:50 - So I'm going to get out of this.
842:52 - And oh, speaking of resources, we've got the PyTorch deep learning repo.
842:56 - The links will be where you need the links.
842:58 - All of the code that we're going to write in this section is contained within the section 3 notebook.
843:04 - PyTorch computer vision.
843:06 - Now, this is a beautiful notebook annotated with heaps of text and images.
843:09 - You can go through this on your own time and use it as a reference to help out.
843:13 - If you get stuck on any of the code we write through the videos, check it out in this notebook because it's probably here somewhere.
843:19 - And then finally, let's get out of these.
843:22 - If we come to the book version of the course,
843:24 - this is learnpytorch.io.
843:26 - We've got home.
843:27 - This will probably be updated by the time you look at that.
843:30 - But we have section 03, which is PyTorch computer vision.
843:34 - It's got all of the information about what we're going to cover in a book format.
843:39 - And you can, of course, skip ahead to different subtitles.
843:42 - See what we're going to write here.
843:44 - All of the links you need and extra resources will be at learnpytorch.io.
843:49 - And for this section, it's PyTorch computer vision.
843:52 - With that being said, speaking of computer vision, you might have the question,
843:57 - what is a computer vision problem?
844:00 - Well, if you can see it, it could probably be phrased at some sort of computer vision problem.
844:06 - That's how broad computer vision is.
844:08 - So let's have a few concrete examples.
844:11 - We might have a binary classification problem,
844:14 - such as if we wanted to have two different images.
844:17 - Is this photo of steak or pizza?
844:19 - We might build a model that understands what steak looks like in an image.
844:22 - This is a beautiful dish that I cooked, by the way.
844:24 - This is me eating pizza at a cafe with my dad.
844:27 - And so we could have binary classification, one thing or another.
844:31 - And so our machine learning model may take in the pixels of an image
844:35 - and understand the different patterns that go into what a steak looks like
844:39 - and the same thing with a pizza.
844:41 - Now, the important thing to note is that we won't actually be telling our model what to learn.
844:46 - It will learn those patterns itself from different examples of images.
844:50 - Then we could step things up and have a multi-class classification problem.
844:55 - You're noticing a trend here.
844:56 - We've covered classification before, but classification can be quite broad.
845:00 - It can be across different domains, such as vision or text or audio.
845:06 - But if we were working with multi-class classification for an image problem,
845:09 - we might have, is this a photo of sushi, steak or pizza?
845:13 - And then we have three classes instead of two.
845:15 - But again, this could be 100 classes, such as what Nutrify uses,
845:19 - which is an app that I'm working on.
845:21 - We go to Nutrify.app.
845:23 - This is bare bones at the moment.
845:25 - But right now, Nutrify can classify up to 100 different foods.
845:29 - So if you were to upload an image of food, let's give it a try.
845:33 - Nutrify, we'll go into images, and we'll go into sample food images.
845:39 - And how about some chicken wings?
845:41 - What does it classify this as?
845:43 - Chicken wings. Beautiful.
845:45 - And then if we upload an image of not food, maybe.
845:49 - Let's go to Nutrify.
845:50 - This is on my computer, by the way.
845:52 - You might not have a sample folder set up like this.
845:54 - And then if we upload a photo of a Cybertruck, what does it say?
845:57 - No food found.
845:58 - Please try another image.
846:00 - So behind the scenes, Nutrify is using the pixels of an image
846:04 - and then running them through a machine learning model
846:06 - and classifying it first, whether it's food or not food.
846:09 - And then if it is food, classifying it as what food it is.
846:13 - So right now it works for 100 different foods.
846:16 - So if we have a look at all these, it can classify apples,
846:18 - artichokes, avocados, barbecue sauce.
846:21 - Each of these work at different levels of performance,
846:24 - but that's just something to keep in mind of what you can do.
846:27 - So the whole premise of Nutrify is to upload a photo of food
846:30 - and then learn about the nutrition about it.
846:33 - So let's go back to our keynote.
846:35 - What's another example?
846:37 - Well, we could use computer vision for object detection,
846:40 - where you might answer the question is,
846:42 - where's the thing we're looking for?
846:44 - So for example, this car here, I caught them on security camera,
846:48 - actually did a hit and run on my new car,
846:51 - wasn't that much of an expensive car, but I parked it on the street
846:54 - and this person, the trailer came off the back of their car
846:57 - and hit my car and then they just picked the trailer up
847:00 - and drove away.
847:02 - But I went to my neighbor's house and had to look at their security footage
847:06 - and they found this car.
847:08 - So potentially, you could design a machine learning model
847:11 - to find this certain type of car.
847:13 - It was an orange jute, by the way, but the images were in black and white
847:16 - to detect to see if it ever recognizes a similar car
847:19 - that comes across the street and you could go,
847:21 - hey, did you crash into my car the other day?
847:23 - I didn't actually find who it was.
847:25 - So sadly, it was a hit and run.
847:27 - But that's object detection, finding something in an image.
847:30 - And then you might want to find out
847:32 - whether the different sections in this image.
847:34 - So this is a great example at what Apple uses on their devices,
847:38 - iPhones and iPads and whatnot, to segregate or segment
847:43 - the different sections of an image, so person one, person two,
847:46 - skin tones, hair, sky, original.
847:49 - And then it enhances each of these sections in different ways.
847:53 - So that's a practice known as computational photography.
847:56 - But the whole premise is how do you segment different portions of an image?
848:00 - And then there's a great blog post here
848:02 - that talks about how it works and what it does
848:04 - and what kind of model that's used.
848:06 - I'll leave that as extra curriculum if you'd like to look into it.
848:10 - So if you have these images, how do you enhance the sky?
848:13 - How do you make the skin tones look how they should?
848:16 - How do you remove the background if you really wanted to?
848:19 - So all of this happens on device.
848:21 - So that's where I got that image from, by the way.
848:24 - Semantic Mars.
848:26 - And this is another great blog, Apple Machine Learning Research.
848:29 - So to keep this in mind, we're about to see another example for computer vision,
848:33 - which is Tesla Computer Vision.
848:35 - A lot of companies have websites such as Apple Machine Learning Research
848:39 - where they share a whole bunch of what they're up to in the world of machine learning.
848:44 - So in Tesla's case, they have eight cameras on each of their self-driving cars
848:48 - that fuels their full self-driving beta software.
848:52 - And so they use computer vision to understand what's going on in an image
848:56 - and then plan what's going on.
848:58 - So this is three-dimensional vector space.
849:00 - And what this means is they're basically taking these different viewpoints
849:04 - from the eight different cameras, feeding them through some form of neural network,
849:08 - and turning the representation of the environment around the car into a vector.
849:13 - So a long string of numbers.
849:15 - And why will it do that?
849:17 - Well, because computers understand numbers far more than they understand images.
849:20 - So we might be able to recognize what's happening here.
849:23 - But for a computer to understand it, we have to turn it into vector space.
849:27 - And so if you want to have a look at how Tesla uses computer vision,
849:30 - so this is from Tesla's AI Day video.
849:33 - I'm not going to play it all because it's three hours long,
849:35 - but I watched it and I really enjoyed it.
849:38 - So there's some information there.
849:40 - And there's a little tidbit there.
849:42 - If you go to two hours and one minute and 31 seconds on the same video,
849:45 - have a look at what Tesla do.
849:48 - Well, would you look at that? Where have we seen that before?
849:52 - That's some device-agnostic code, but with Tesla's custom dojo chip.
849:56 - So Tesla uses PyTorch.
849:58 - So the exact same code that we're writing,
850:00 - Tesla uses similar PyTorch code to, of course,
850:03 - they write PyTorch code to suit their problem.
850:05 - But nonetheless, they use PyTorch code to train their machine learning models
850:09 - that power their self-driving software.
850:12 - So how cool is that?
850:14 - And if you want to have a look at another example,
850:16 - there's plenty of different Tesla self-driving videos.
850:19 - So, oh, we can just play it right here.
850:21 - I was going to click the link.
850:22 - So look, this is what happens.
850:24 - If we have a look in the environment,
850:26 - Tesla, the cameras, understand what's going on here.
850:29 - And then it computes it into this little graphic here
850:31 - on your heads-up display in the car.
850:33 - And it kind of understands, well, I'm getting pretty close to this car.
850:35 - I'm getting pretty close to that car.
850:37 - And then it uses this information about what's happening,
850:40 - this perception, to plan where it should drive next.
850:43 - And I believe here it ends up going into it.
850:49 - It has to stop.
850:51 - Yeah, there we go.
850:53 - Because we've got a stop sign.
850:54 - Look at that.
850:55 - It's perceiving the stop sign.
850:56 - It's got two people here.
850:57 - It just saw a car drive pass across this street.
850:59 - So that is pretty darn cool.
851:00 - That's just one example of computer vision, one of many.
851:03 - And how would you find out what computer vision can be used for?
851:07 - Here's what I do.
851:09 - What can computer vision be used for?
851:12 - Plenty more resources.
851:14 - So, oh, there we go.
851:15 - 27 most popular computer vision applications in 2022.
851:19 - So we've covered a fair bit there.
851:22 - But what are we going to cover specifically with PyTorch code?
851:25 - Well, broadly, like that.
851:28 - We're going to get a vision data set to work with using torch vision.
851:32 - So PyTorch has a lot of different domain libraries.
851:35 - Torch vision helps us deal with computer vision problems.
851:38 - And there's existing data sets that we can leverage to play around with computer vision.
851:42 - We're going to have a look at the architecture of a convolutional neural network,
851:45 - also known as a CNN with PyTorch.
851:47 - We're going to look at an end-to-end multi-class image classification problem.
851:51 - So multi-class is what?
851:53 - More than one thing or another?
851:54 - Could be three classes, could be a hundred.
851:56 - We're going to look at steps at modeling with CNNs in PyTorch.
851:59 - So we're going to create a convolutional network with PyTorch.
852:02 - We're going to pick a last function and optimize it to suit our problem.
852:05 - We're going to train a model, training a model a model.
852:08 - A little bit of a typo there.
852:10 - And then we're going to evaluate a model, right?
852:12 - So we might have typos with our text, but we'll have less typos in the code.
852:15 - And how are we going to do this?
852:17 - Well, we could do it cook, so we could do it chemis.
852:20 - Well, we're going to do it a little bit of both.
852:22 - Part art, part science.
852:24 - But since this is a machine learning cooking show, we're going to be cooking up lots of code.
852:29 - So in the next video, we're going to cover the inputs and outputs of a computer vision problem.
852:34 - I'll see you there.
852:36 - So in the last video, we covered what we're going to cover, broadly.
852:40 - And we saw some examples of what computer vision problems are.
852:43 - Essentially, anything that you're able to see, you can potentially turn into a computer vision problem.
852:48 - And we're going to be cooking up lots of machine learning, or specifically pie torch, computer vision code.
852:54 - You see I fixed that typo.
852:56 - Now let's talk about what the inputs and outputs are of a typical computer vision problem.
853:00 - So let's start with a multi-classification example.
853:04 - And so we wanted to take photos of different images of food and recognize what they were.
853:09 - So we're replicating the functionality of Nutrify.
853:13 - So take a photo of food and learn about it.
853:16 - So we might start with a bunch of food images that have a height and width of some sort.
853:22 - So we have width equals 224, height equals 224, and then they have three color channels.
853:27 - Why three?
853:28 - Well, that's because we have a value for red, green and blue.
853:32 - So if we look at this up, if we go red, green, blue image format.
853:40 - So 24-bit RGB images.
853:43 - So a lot of images or digital images have some value for a red pixel, a green pixel and a blue pixel.
853:51 - And if you were to convert images into numbers, they get represented by some value of red, some value of green and some value of blue.
853:58 - That is exactly the same as how we'd represent these images.
854:02 - So for example, this pixel here might be a little bit more red, a little less blue, and a little less green because it's close to orange.
854:09 - And then we convert that into numbers.
854:11 - So what we're trying to do here is essentially what we're trying to do with all of the data that we have with machine learning is represented as numbers.
854:18 - So the typical image format to represent an image because we're using computer vision.
854:23 - So we're trying to figure out what's in an image.
854:25 - The typical way to represent that is in a tensor that has a value for the height, width and color channels.
854:31 - And so we might numerically encode these.
854:34 - In other words, represent our images as a tensor.
854:37 - And this would be the inputs to our machine learning algorithm.
854:40 - And in many cases, depending on what problem you're working on, an existing algorithm already exists for many of the most popular computer vision problems.
854:49 - And if it doesn't, you can build one.
854:51 - And then you might fashion this machine learning algorithm to output the exact shapes that you want.
854:57 - In our case, we want three outputs.
854:59 - We want one output for each class that we have.
855:02 - We want a prediction probability for sushi.
855:05 - We want a prediction probability for steak.
855:07 - And we want a prediction probability for pizza.
855:09 - Now in our case, in this iteration, looks like our model got one of them wrong because the highest value was assigned to the wrong class here.
855:17 - So for the second image, it assigned a prediction probability of 0.81 for sushi.
855:21 - Now, keep in mind that you could change these classes to whatever your particular problem is.
855:26 - I'm just simplifying this and making it three.
855:29 - You could have a hundred.
855:31 - You could have a thousand.
855:32 - You could have five.
855:34 - It's just, it depends on what you're working with.
855:37 - And so we might use these predicted outputs to enhance our app.
855:43 - So if someone wants to take a photo of their plate of sushi, our app might say,
855:46 - hey, this is a photo of sushi.
855:48 - Here's some information about those, the sushi rolls or the same for steak, the same for pizza.
855:53 - Now it might not always get it right because after all, that's what machine learning is.
855:57 - It's probabilistic.
855:59 - So how would we improve these results here?
856:02 - Well, we could show our model more and more images of sushi steak and pizza
856:08 - so that it builds up a better internal representation of said images.
856:12 - So when it looks at images it's never seen before or images outside its training data set,
856:17 - it's able to get better results.
856:19 - But just keep in mind this whole process is similar no matter what computer vision problem you're working with.
856:24 - You need a way to numerically encode your information.
856:27 - You need a machine learning model that's capable of fitting the data
856:30 - in the way that you would like it to be fit in our case classification.
856:34 - You might have a different type of model if you're working with object detection,
856:37 - a different type of model if you're working with segmentation.
856:40 - And then you need to fashion the outputs in a way that best suit your problem as well.
856:44 - So let's push forward.
856:47 - Oh, by the way, the model that often does this is a convolutional neural network.
856:52 - In other words, a CNN.
856:54 - However, you can use many other different types of machine learning algorithms here.
856:58 - It's just that convolutional neural networks typically perform the best with image data.
857:03 - Although with recent research, there is the transformer architecture or deep learning model
857:09 - that also performs fairly well or very well with image data.
857:13 - So just keep that in mind going forward.
857:15 - But for now we're going to focus on convolutional neural networks.
857:18 - And so we might have input and output shapes because remember one of the chief machine learning problems
857:23 - is making sure that your tensor shapes line up with each other, the input and output shapes.
857:30 - So if we encoded this image of stake here, we might have a dimensionality of batch size
857:35 - with height color channels.
857:37 - And now the ordering here could be improved.
857:39 - It's usually height then width.
857:41 - So alphabetical order.
857:42 - And then color channels last.
857:44 - So we might have the shape of none, two, two, four, two, four, three.
857:47 - Now where does this come from?
857:48 - So none could be the batch size.
857:50 - Now it's none because we can set the batch size to whatever we want, say for example 32.
857:56 - Then we might have a height of two to four and a width of two to four and three color channels.
858:02 - Now height and width are also customizable.
858:05 - You might change this to be 512 by 512.
858:08 - What that would mean is that you have more numbers representing your image.
858:11 - And in sense would take more computation to figure out the patterns because there is simply more information encoded in your image.
858:19 - But two, two, four, two, four is a common starting point for images.
858:23 - And then 32 is also a very common batch size, as we've seen in previous videos.
858:28 - But again, this could be changed depending on the hardware you're using, depending on the model you're using.
858:33 - You might have a batch size to 64.
858:35 - You might have a batch size of 512.
858:37 - It's all problem specific.
858:39 - And that's this line here.
858:41 - These will vary depending on the problem you're working on.
858:44 - So in our case, our output shape is three because we have three different classes for now.
858:49 - But again, if you have a hundred, you might have an output shape of a hundred.
858:53 - If you have a thousand, you might have an output shape of a thousand.
858:56 - The same premise of this whole pattern remains though.
859:00 - Numerically encode your data, feed it into a model, and then make sure the output shape fits your specific problem.
859:07 - And so, for this section, Computer Vision with PyTorch, we're going to be building CNNs to do this part.
859:15 - We're actually going to do all of the parts here, but we're going to focus on building a convolutional neural network
859:21 - to try and find patterns in data, because it's not always guaranteed that it will.
859:25 - Finally, let's look at one more problem.
859:28 - Say you had grayscale images of fashion items, and you have quite small images.
859:34 - They're only 28 by 28.
859:36 - The exact same pattern is going to happen.
859:38 - You numerically represent it, use it as inputs to a machine learning algorithm,
859:42 - and then hopefully your machine learning algorithm outputs the right type of clothing that it is.
859:46 - In this case, it's a t-shirt.
859:48 - But I've got dot dot dot here because we're going to be working on a problem that uses ten different types of items of clothing.
859:55 - And the images are grayscale, so there's not much detail.
859:58 - So hopefully our machine learning algorithm can recognize what's going on in these images.
860:02 - There might be a boot, there might be a shirt, there might be pants, there might be a dress,
860:05 - etc, etc.
860:07 - But we numerically encode our images into dimensionality of batch size, height with color channels.
860:14 - This is known as NHWC, or number of batches, or number of images in a batch, height with C, or color channels.
860:23 - This is color channels last.
860:25 - Why am I showing you two forms of this?
860:27 - Do you notice color channels in this one is color channels first?
860:31 - So color channels height width?
860:33 - Well, because you come across a lot of different representations of data full stop,
860:38 - but particularly image data in PyTorch and other libraries,
860:42 - many libraries expect color channels last.
860:45 - However, PyTorch currently at the time of recording this video may change in the future,
860:49 - defaults to representing image data with color channels first.
860:53 - Now this is very important because you will get errors if your dimensionality is in the wrong order.
860:59 - And so there are ways to go in between these two, and there's a lot of debate of which format is the best.
861:05 - It looks like color channels last is going to win over the long term, just because it's more efficient,
861:09 - but again, that's outside the scope, but just keep this in mind.
861:12 - We're going to write code to interact between these two, but it's the same data just represented in different order.
861:19 - And so we could rearrange these shapes to how we want color channels last or color channels first.
861:25 - And once again, the shapes will vary depending on the problem that you're working on.
861:31 - So with that being said, we've covered the input and output shapes.
861:35 - How are we going to see them with code?
861:37 - Well, of course we're going to be following the PyTorch workflow that we've done.
861:43 - So we need to get our data ready, turn it into tenses in some way, shape or form.
861:47 - We can do that with taught division transforms.
861:49 - Oh, we haven't seen that one yet, but we will.
861:52 - We can use torchutilsdata.datasetutils.data.data loader.
861:57 - We can then build a model or pick a pre-trained model to suit our problem.
862:00 - We've got a whole bunch of modules to help us with that, torchNN module, torchvision.models.
862:06 - And then we have an optimizer and a loss function.
862:11 - We can evaluate the model using torch metrics, or we can code our own metric functions.
862:16 - We can of course improve through experimentation, which we will see later on,
862:20 - which we've actually done that, right?
862:21 - We've done improvement through experimentation.
862:23 - We've tried different models, we've tried different things.
862:25 - And then finally, we can save and reload our trained model if we wanted to use it elsewhere.
862:31 - So with that being said, we've covered the workflow.
862:33 - This is just a high-level overview of what we're going to code.
862:36 - You might be asking the question, what is a convolutional neural network, or a CNN?
862:41 - Let's answer that in the next video.
862:43 - I'll see you there.
862:46 - Welcome back.
862:47 - In the last video, we saw examples of computer vision input and output shapes.
862:52 - And we kind of hinted at the fact that convolutional neural networks are deep learning models, or CNNs,
862:58 - that are quite good at recognizing patterns in images.
863:02 - So we left off the last video with the question, what is a convolutional neural network?
863:07 - And where could you find out about that?
863:09 - What is a convolutional neural network?
863:13 - Here's one way to find out.
863:15 - And I'm sure, as you've seen, there's a lot of resources for such things.
863:19 - A comprehensive guide to convolutional neural networks.
863:22 - Which one of these is the best?
863:24 - Well, it doesn't really matter.
863:26 - The best one is the one that you understand the best.
863:28 - So there we go.
863:29 - There's a great video from Code Basics.
863:31 - I've seen that one before, simple explanation of convolutional neural network.
863:34 - I'll leave you to research these things on your own.
863:38 - And if you wanted to look at images, there's a whole bunch of images.
863:42 - I prefer to learn things by writing code.
863:45 - Because remember, this course is code first.
863:47 - As a machine learning engineer, 99% of my time is spent writing code.
863:51 - So that's what we're going to focus on.
863:53 - But anyway, here's the typical architecture of a CNN.
863:56 - In other words, a convolutional neural network.
863:58 - If you hear me say CNN, I'm not talking about the news website.
864:01 - In this course, I'm talking about the architecture convolutional neural network.
864:05 - So this is some PyTorch code that we're going to be working towards building.
864:11 - But we have some hyperparameters slash layer types here.
864:14 - We have an input layer.
864:15 - So we have an input layer, which takes some in channels, and an input shape.
864:19 - Because remember, it's very important in machine learning and deep learning to line up your
864:23 - input and output shapes of whatever model you're using, whatever problem you're working with.
864:27 - Then we have some sort of convolutional layer.
864:30 - Now, what might happen in a convolutional layer?
864:33 - Well, as you might have guessed, as what happens in many neural networks, is that the layers
864:39 - perform some sort of mathematical operation.
864:42 - Now, convolutional layers perform convolving window operation across an image or across
864:48 - a tensor.
864:49 - And discover patterns using, let's have a look, actually.
864:53 - Let's go, nn.com2d.
864:59 - There we go.
865:01 - This is what happens.
865:02 - So the output of our network equals a bias plus the sum of the weight tensor over the
865:10 - convolutional channel out, okay, times input.
865:14 - Now, if you want to dig deeper into what is actually going on here, you're more than welcome to
865:19 - do that.
865:20 - But we're going to be writing code that leverages the torch nn.com2d.
865:23 - And we're going to fix up all of these hyperparameters here so that it works with our problem.
865:29 - Now, what you need to know here is that this is a bias term.
865:33 - We've seen this before.
865:34 - And this is a weight matrix.
865:36 - So a bias vector typically and a weight matrix.
865:39 - And they operate over the input.
865:42 - But we'll see these later on with code.
865:45 - So just keep that in mind.
865:47 - This is what's happening.
865:48 - As with every layer in a neural network, some form of operation is happening on our input
865:53 - data.
865:54 - These operations happen layer by layer until eventually, hopefully, they can be turned into
865:59 - some usable output.
866:02 - So let's jump back in here.
866:04 - Then we have an hidden activation slash nonlinear activation because why do we use nonlinear
866:09 - activations?
866:10 - Well, it's because if our data was nonlinear, non-straight lines, we need the help of straight
866:17 - and non-straight lines to model it, to draw patterns in it.
866:21 - Then we typically have a pooling layer.
866:24 - And I want you to take this architecture.
866:26 - I've said typical here for a reason because these type of architectures are changing all
866:31 - the time.
866:32 - So this is just one typical example of a CNN.
866:34 - It's about as basic as a CNN as you can get.
866:37 - So over time, you will start to learn to build more complex models.
866:40 - You will not only start to learn to build them, you will just start to learn to use them,
866:44 - as we'll see later on in the transfer learning section of the course.
866:47 - And then we have an output layer.
866:49 - So do you notice the trend here?
866:51 - We have an input layer and then we have multiple hidden layers that perform some sort of mathematical
866:55 - operation on our data.
866:56 - And then we have an output slash linear layer that converts our output into the ideal shape
867:02 - that we'd like.
867:03 - So we have an output shape here.
867:05 - And then how does this look in process?
867:08 - While we put in some images, they go through all of these layers here because we've used
867:11 - an end up sequential.
867:12 - And then hopefully this forward method returns x in a usable status or usable state that
867:18 - we can convert into class names.
867:20 - And then we could integrate this into our computer vision app in some way, shape or form.
867:25 - And here's the asterisk here.
867:28 - Note, there are almost an unlimited amount of ways you could stack together a convolutional
867:32 - neural network.
867:33 - This slide only demonstrates one.
867:35 - So just keep that in mind, only demonstrates one.
867:38 - But the best way to practice this sort of stuff is not to stare at a page.
867:41 - It's to if and out, code it out.
867:44 - So let's code, I'll see you in Google CoLab.
867:49 - Welcome back.
867:50 - Now, we've discussed a bunch of fundamentals about computer vision problems and convolutional
867:54 - neural networks.
867:55 - But rather than talk to more slides, well, let's start to code them out.
867:58 - I'm going to meet you at colab.research.google.com.
868:02 - She's going to clean up some of these tabs.
868:05 - And I'm going to start a new notebook.
868:08 - And then I'm going to name this one, this is going to be 03 PyTorch computer vision.
868:15 - And I'm going to call mine video.
868:17 - So just so it has the video tag, because if we go in here, if we go video notebooks of
868:24 - the PyTorch deep learning repo, the video notebooks are stored in here.
868:28 - They've got the underscore video tag.
868:29 - So the video notebooks have all of the code I write exactly in the video.
868:33 - But there are some reference notebooks to go along with it.
868:36 - Let me just write a heading here, PyTorch computer vision.
868:40 - And I'll put a resource here, see reference notebook.
868:45 - Now, of course, this is the one that's the ground truth.
868:48 - It's got all of the code that we're going to be writing.
868:54 - I'm going to put that in here.
868:56 - Explain with text and images and whatnot.
868:58 - And then finally, as we got see reference online book.
869:03 - And that is at learnpytorch.io at section number three, PyTorch computer vision.
869:09 - I'm going to put that in there.
869:11 - And then I'm going to turn this into markdown with command mm.
869:14 - Beautiful.
869:15 - So let's get started.
869:16 - I'm going to get rid of this, get rid of this.
869:18 - How do we start this off?
869:20 - Well, I believe there are some computer vision libraries that you should be aware of.
869:26 - Computer vision libraries in PyTorch.
869:29 - So this is just going to be a text based cell.
869:32 - But the first one is torch vision, which is the base domain library for PyTorch computer vision.
869:43 - So if we look up torch vision, what do we find?
869:47 - We have torch vision 0.12.
869:50 - That's the version that torch vision is currently up to at the time of recording this.
869:54 - So in here, this is very important to get familiar with if you're working on computer vision problems.
869:59 - And of course, in the documentation, this is just another tidbit.
870:03 - We have torch audio for audio problems.
870:05 - We have torch text for text torch vision, which is what we're working on torch rack for recommendation systems
870:11 - torch data for dealing with different data pipelines torch serve, which is for serving PyTorch models
870:18 - and PyTorch on XLA.
870:20 - So I believe that stands for accelerated linear algebra devices.
870:24 - You don't have to worry about these ones for now.
870:26 - We're focused on torch vision.
870:28 - However, if you would like to learn more about a particular domain, this is where you would go to learn more.
870:33 - So there's a bunch of different stuff that's going on here.
870:36 - Transforming and augmenting images.
870:38 - So fundamentally, computer vision is dealing with things in the form of images.
870:42 - Even a video gets converted to an image.
870:45 - We have models and pre-trained weights.
870:47 - So as I referenced before, you can use an existing model that works on an existing computer vision problem for your own problem.
870:53 - We're going to cover that in section, I think it's six, for transfer learning.
870:57 - And then we have data sets, which is a bunch of computer vision data sets, utils, operators, a whole bunch of stuff here.
871:03 - So PyTorch is really, really good for computer vision.
871:07 - I mean, look at all the stuff that's going on here.
871:09 - But that's enough talking about it.
871:11 - Let's just put it in here.
871:12 - Torch vision. This is the main one.
871:14 - I'm not going to link to all of these.
871:16 - All of the links for these, by the way, is in the book version of the course PyTorch Computer Vision.
871:20 - And we have what we're going to cover.
871:23 - And finally, computer vision libraries in PyTorch.
871:27 - Torch vision, data sets, models, transforms, et cetera.
871:30 - But let's just write down the other ones.
871:32 - So we have torch vision, not data sets, something to be aware of.
871:38 - So get data sets and data loading functions for computer vision here.
871:47 - Then we have torch vision.
871:50 - And from torch vision, models is get pre-trained computer vision.
871:55 - So when I say pre-trained computer vision models, we're going to cover this more in transfer learning, as I said.
872:00 - Pre-trained computer vision models are models that have been already trained on some existing vision data
872:06 - and have trained weights, trained patterns that you can leverage for your own problems,
872:11 - that you can leverage for your own problems.
872:16 - Then we have torch vision.transforms.
872:20 - And then we have functions for manipulating your vision data, which is, of course, images to be suitable for use with an ML model.
872:35 - So remember, what do we have to do when we have image data or almost any kind of data?
872:41 - For machine learning, we have to prepare it in a way so it can't just be pure images, so that's what transforms help us out with.
872:47 - Transforms helps to turn our image data into numbers so we can use it with a machine learning model.
872:53 - And then, of course, we have some, these are the torch utils.
872:57 - This is not vision specific, it's entirety of PyTorch specific, and that's data set.
873:02 - So if we wanted to create our own data set with our own custom data, we have the base data set class for PyTorch.
873:10 - And then we have finally torch utils data.
873:15 - These are just good to be aware of because you'll almost always use some form of data set slash data loader with whatever PyTorch problem you're working on.
873:22 - So this creates a Python iterable over a data set.
873:29 - Wonderful.
873:30 - I think these are most of the libraries that we're going to be using in this section.
873:33 - Let's import some of them, hey, so we can see what's going on.
873:37 - Let's go import PyTorch.
873:41 - Import PyTorch.
873:43 - So import torch.
873:46 - We're also going to get NN, which stands for neural network.
873:49 - What's in NN?
873:50 - Well, in NN, of course, we have lots of layers, lots of loss functions, a whole bunch of different stuff for building neural networks.
873:57 - We're going to also import torch vision.
874:02 - And then we're going to go from torch vision.
874:05 - Import data sets because we're going to be using data sets later on to get a data set to work with from torch vision.
874:13 - Well, import transforms.
874:16 - You could also go from torch vision dot transforms import to tensor.
874:23 - This is one of the main ones you'll see for computer vision problems to tensor.
874:26 - You can imagine what it does.
874:28 - But let's have a look.
874:29 - Transforms to tensor.
874:33 - Transforming and augmenting images.
874:36 - So look where we are.
874:37 - We're in pytorch.org slash vision slash stable slash transforms.
874:41 - Over here.
874:42 - So we're in the torch vision section.
874:44 - And we're just looking at transforming and augmenting images.
874:47 - So transforming.
874:49 - What do we have?
874:50 - Transforms are common image transformations of our and the transforms module.
874:53 - They can be trained together using compose.
874:56 - Beautiful.
874:57 - So if we have two tensor, what does this do?
875:01 - Convert a pill image on NumPy and the array to a tensor.
875:05 - Beautiful.
875:06 - That's what we want to do later on, isn't it?
875:08 - Well, this is kind of me giving you a spoiler is we want to convert our images into tensors so that we can use those with our models.
875:14 - But there's a whole bunch of different transforms here and actually one of your extra curriculum is to be to read through each of these packages for 10 minutes.
875:22 - So that's about an hour of reading, but it will definitely help you later on if you get familiar with using the pytorch documentation.
875:29 - After all, this course is just a momentum builder.
875:32 - We're going to write heaves of pytorch code.
875:34 - But fundamentally, you'll be teaching yourself a lot of stuff by reading the documentation.
875:38 - Let's keep going with this.
875:40 - Where were we up to?
875:42 - When we're getting familiar with our data, mapplotlib is going to be fundamental for visualization.
875:48 - Remember, the data explorer's motto, visualize, visualize, visualize, become one with the data.
875:55 - So we're going to import mapplotlib.pyplot as PLT.
876:00 - And then finally, let's check the versions.
876:03 - So print torch.version or underscore, underscore version and print torch vision.
876:10 - So by the time you watch this, there might be a newer version of each of these modules out.
876:15 - If there's any errors in the code, please let me know.
876:18 - But this is just a bare minimum version that you'll need to complete this section.
876:22 - I believe at the moment, Google Colab is running 1.11 for torch and maybe 1.10.
876:32 - We'll find out in a second.
876:34 - It just connected.
876:35 - So we're importing pytorch.
876:38 - Okay, there we go.
876:40 - So my pytorch version is 1.10 and it's got CUDA available and torch vision is 0.11.
876:46 - So just make sure if you're running in Google Colab, if you're running this at a later date,
876:50 - you probably have at minimum these versions, you might even have a later version.
876:54 - So these are the minimum versions required for this upcoming section.
876:58 - So we've covered the base computer vision libraries in pytorch.
877:02 - We've got them ready to go.
877:03 - How about in the next video, we cover getting a data set.
877:07 - I'll see you there.
877:09 - Welcome back.
877:11 - So in the last video, we covered some of the fundamental computer vision libraries in pytorch.
877:15 - The main one being torch vision and then modules that stem off torch vision.
877:19 - And then of course, we've got torch utils dot data dot data set, which is the base data set class for pytorch
877:25 - and data loader, which creates a Python irritable over a data set.
877:29 - So let's begin where most machine learning projects do.
877:32 - And that is getting a data set, getting a data set.
877:36 - I'm going to turn this into markdown.
877:38 - And the data set that we're going to be used to demonstrating some computer vision techniques is fashion amnest.
877:46 - Which is a take of the data set we'll be using is fashion amnest, which is a take on the original amnest data set,
877:57 - amnest database, which is modified national institute of standards and technology database, which is kind of like the hello world
878:05 - in machine learning and computer vision, which is these are sample images from the amnest test data set,
878:11 - which are grayscale images of handwritten digits.
878:15 - So this, I believe was originally used for trying to find out if you could use computer vision at a postal service
878:21 - to, I guess, recognize post codes and whatnot.
878:24 - I may be wrong about that, but that's what I know.
878:27 - Yeah, 1998.
878:29 - So all the way back at 1998, how cool is that?
878:32 - So this was basically where convolutional neural networks were founded.
878:36 - I'll let you read up on the history of that.
878:38 - But neural network started to get so good that this data set was quite easy for them to do really well.
878:44 - And that's when fashion amnest came out.
878:46 - So this is a little bit harder if we go into here.
878:50 - This is by Zalando research fashion amnest.
878:53 - And it's of grayscale images of pieces of clothing.
878:58 - So like we saw before the input and output, what we're going to be trying to do is turning these images of clothing into numbers
879:06 - and then training a computer vision model to recognize what the different styles of clothing are.
879:11 - And here's a dimensionality plot of all the different items of clothing.
879:15 - Visualizing where similar items are grouped together, there's the shoes and whatnot.
879:19 - Is this interactive?
879:21 - Oh no, it's a video.
879:23 - Excuse me.
879:24 - There we go.
879:25 - To serious machine learning researchers.
879:27 - We are talking about replacing amnest.
879:29 - Amnest is too easy.
879:31 - Amnest is overused.
879:32 - Amnest cannot represent modern CV tasks.
879:35 - So even now fashion amnest I would say has also been pretty much sold, but it's a good way to get started.
879:41 - Now, where could we find such a data set?
879:43 - We could download it from GitHub.
879:45 - But if we come back to the taught division documentation, have a look at data sets.
879:50 - We have a whole bunch of built-in data sets.
879:52 - And remember, this is your extra curricular to read through these for 10 minutes or so each.
879:56 - But we have an example.
879:58 - We could download ImageNet if we want.
880:02 - We also have some base classes here for custom data sets.
880:05 - We'll see that later on.
880:07 - But if we scroll through, we have image classification data sets.
880:10 - Caltech 101.
880:11 - I didn't even know what all of these are.
880:13 - There's a lot here.
880:14 - CFAR 100.
880:15 - So that's an example of 100 different items.
880:18 - So that would be a 100 class, multi-class classification problem.
880:22 - CFAR 10 is 10 classes.
880:24 - We have amnest.
880:26 - We have fashion amnest.
880:28 - Oh, that's the one we're after.
880:29 - But this is basically what you would do to download a data set from taughtvision.datasets.
880:36 - You would download the data in some way, shape, or form.
880:39 - And then you would turn it into a data loader.
880:41 - So ImageNet is one of the most popular or is probably the gold standard data set for computer vision evaluation.
880:51 - It's quite a big data set.
880:52 - It's got millions of images.
880:53 - But that's the beauty of taught vision is that it allows us to download example data sets
880:58 - that we can practice on.
881:00 - I don't even perform research on from a built-in module.
881:03 - So let's now have a look at the fashion amnest data set.
881:07 - How might we get this?
881:09 - So we've got some example code here, or this is the documentation.
881:12 - taughtvision.datasets.fashion amnest.
881:15 - We have to pass in a root.
881:16 - So where do we want to download the data set?
881:19 - We also have to pass in whether we want the training version of the data set
881:22 - or whether we want the testing version of the data set.
881:24 - Do we want to download it?
881:26 - Yes or no?
881:27 - Should we transform the data in any way shape or form?
881:31 - So we're going to be downloading images through this function call or this class call.
881:36 - Do we want to transform those images in some way?
881:39 - What do we have to do to images before we can use them with a model?
881:42 - We have to turn them into a tensor, so we might look into that in a moment.
881:45 - And target transform is do we want to transform the labels in any way shape or form?
881:50 - So often the data sets that you download from taughtvision.datasets
881:54 - are pre formatted in a way that they can be quite easily used with PyTorch.
881:59 - But that won't always be the case with your own custom data sets.
882:02 - However, what we're about to cover is just important to get an idea of what the computer vision workflow is.
882:07 - And then later on you can start to customize how you get your data in the right format to be used with the model.
882:13 - Then we have some different parameters here and whatnot.
882:15 - Let's just rather than look at the documentation, if and down, code it out.
882:20 - So we'll be using fashion MNIST and we'll start by, I'm going to just put this here, from taughtvision.datasets.
882:31 - And we'll put the link there and we'll start by getting the training data.
882:36 - Set up training data.
882:38 - I'm just going to make some code cells here so that I can code in the middle of the screen.
882:43 - Set up training data. Training data equals data sets dot fashion MNIST.
882:50 - Because recall, we've already from taughtvision.
882:55 - We don't need to import this again, I'm just doing it for demonstration purposes, but from taughtvision import data sets
883:01 - so we can just call data sets dot fashion MNIST.
883:04 - And then we're going to type in root.
883:06 - See how the doc string comes up and tells us what's going on.
883:09 - I personally find this a bit hard to read in Google Colab, so if I'm looking up the documentation,
883:15 - I like to just go into here.
883:17 - But let's code it out.
883:19 - So root is going to be data, so where to download data to.
883:25 - We'll see what this does in a minute.
883:27 - Then we're going to go train.
883:28 - We want the training version of the data set.
883:31 - So as I said, a lot of the data sets that you find in taughtvision.datasets
883:36 - have been formatted into training data set and testing data set already.
883:40 - So this Boolean tells us do we want the training data set?
883:47 - So if that was false, we would get the testing data set of fashion MNIST.
883:51 - Do we want to download it?
883:53 - Do we want to download?
883:56 - Yes, no.
883:57 - So yes, we do. We're going to set that to true.
884:00 - Now what sort of transform do we want to do?
884:03 - So because we're going to be downloading images and what do we have to do to our images
884:07 - to use them with a machine-loading model, we have to convert them into tensors.
884:11 - So I'm going to pass the transform to tensor, but we could also just go torchvision.transforms.to tensor.
884:20 - That would be the exact same thing as what we just did before.
884:23 - And then the target transform, do we want to transform the labels?
884:27 - No, we don't.
884:28 - We're going to see how they come, or the target, sorry.
884:31 - High torch, this is another way, another naming convention.
884:34 - Often uses target for the target that you're trying to predict.
884:37 - So using data to predict the target, which is I often use data to predict a label.
884:42 - They're the same thing.
884:44 - So how do we want to transform the data?
884:49 - And how do we want to transform the labels?
884:56 - And then we're going to do the same for the test data.
885:01 - So we're going to go data sets.
885:03 - You might know what to do here.
885:05 - It's going to be the exact same code as above, except we're going to change one line.
885:09 - We want to store it in data.
885:11 - We want to download the training data set as false because we want the testing version.
885:16 - Do we want to download it?
885:18 - Yes, we do.
885:19 - Do we want to transform it the data?
885:21 - Yes, we do, we want to use to tensor to convert our image data to tensors.
885:26 - And do we want to do a target transform?
885:29 - Well, no, we don't.
885:30 - We want to keep the label slash the targets as they are.
885:33 - Let's see what happens when we run this.
885:35 - Oh, downloading fashion, Evan is beautiful.
885:39 - So this is going to download all of the labels.
885:41 - What do we have?
885:42 - Train images, train labels, lovely, test images, test labels, beautiful.
885:47 - So that's how quickly we can get a data set by using torch vision data sets.
885:52 - Now, if we have a look over here, we have a data folder because we set the root to be
885:56 - data.
885:57 - Now, if we look what's inside here, we have fashion MNIST, exactly what we wanted.
886:00 - Then we have the raw, and then we have a whole bunch of files here, which torch vision has
886:05 - converted into data sets for us.
886:08 - So let's get out of that.
886:10 - And this process would be much the same if we used almost any data set in here.
886:16 - They might be slightly different depending on what the documentation says and depending
886:19 - on what the data set is.
886:21 - But that is how easy torch vision data sets makes it to practice on example computer vision
886:27 - data sets.
886:29 - So let's go back.
886:31 - Let's check out some parameters or some attributes of our data.
886:35 - How many samples do we have?
886:38 - So we'll check the lengths.
886:45 - So we have 60,000 training examples and 10,000 testing examples.
886:51 - So what we're going to be doing is we're going to be building a computer vision model to
886:54 - find patterns in the training data and then use those patterns to predict on the test
887:00 - data.
887:01 - And so let's see a first training example.
887:04 - See the first training example.
887:08 - So we can just index on the train data.
887:12 - Let's get the zero index and then we're going to have a look at the image and the label.
887:18 - Oh my goodness.
887:19 - A whole bunch of numbers.
887:21 - Now you see what the two tensor has done for us?
887:26 - So we've downloaded some images and thanks to this torch vision transforms to tensor.
887:30 - How would we find the documentation for this?
887:32 - Well, we could go and see what this does transforms to tensor.
887:36 - We could go to tensor.
887:40 - There we go.
887:41 - What does this do?
887:42 - Convert a pill image.
887:43 - So that's Python image library image on NumPy array to a tensor.
887:47 - This transform does not support torch script.
887:49 - So converts a pill image on NumPy array height with color channels in the range 0 to 255
887:55 - to a torch float tensor of shape.
887:57 - See here?
887:58 - This is what I was talking about how PyTorch defaults with a lot of transforms to CHW.
888:03 - So color channels first height then width in that range of zero to one.
888:07 - So typically red, green and blue values are between zero and 255.
888:12 - But neural networks like things between zero and one.
888:15 - And in this case, it is now in the shape of color channels first, then height, then width.
888:21 - However, some other machine learning libraries prefer height, width, then color channels.
888:26 - Just keep that in mind.
888:27 - We're going to see this in practice later on.
888:29 - So we've got an image.
888:30 - We've got a label.
888:31 - Let's check out some more details about it.
888:33 - Remember how we discussed?
888:34 - Oh, there's our label, by the way.
888:36 - So nine, we can go traindata.classes, find some information about our class names.
888:45 - Class names.
888:46 - Beautiful.
888:48 - So number nine would be 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
888:55 - So this particular tensor seems to relate to an ankle boot.
888:59 - How would we find that out?
889:00 - Well, one second.
889:01 - I'm just going to show you one more thing, class to IDX.
889:04 - Let's go traindata.class to IDX.
889:07 - What does this give us?
889:09 - Class to IDX.
889:10 - This is going to give us a dictionary of different labels and their corresponding index.
889:16 - So if our machine learning model predicted nine or class nine, we can convert that to
889:20 - ankle boot using this attribute of the train data.
889:24 - There are more attributes that you can have a look at if you like.
889:26 - You can go traindata.dot, then I just push tab to find out a bunch of different things.
889:32 - You can go data.
889:33 - That'll be the images, and then I believe you can also go targets.
889:37 - So targets, that's all the labels, which is one big long tensor.
889:43 - Now let's check the shape.
889:45 - Check the shape of our image.
889:49 - So image.shape and label.shape.
889:53 - What are we going to get from that?
889:55 - Oh, label doesn't have a shape.
889:58 - Why is that?
889:59 - Well, because it's only an integer.
890:01 - So oh, beautiful.
890:02 - Look at that.
890:03 - So our image shape is we have a color channel of one.
890:06 - So let me print this out in something prettier, print image shape, which is going to be image
890:13 - shape.
890:14 - Remember how I said it's very important to be aware of the input and output shapes of
890:19 - your models and your data.
890:20 - It's all part of becoming one with the data.
890:23 - So that is what our image shape is.
890:28 - And then if we go next, this is print image label, which is label, but we'll index on
890:36 - class names for label.
890:39 - And then we'll do that wonderful.
890:44 - So our image shape is currently in the format of color channels height width.
890:47 - We got a bunch of different numbers that's representing our image.
890:50 - It's black and white.
890:51 - It only has one color channel.
890:54 - Why do you think it only has one color channel?
890:56 - Because it's black and white, so if we jump back into the keynote, fashion, we've already
891:00 - discussed this, grayscale images have one color channel.
891:04 - So that means that for black, the pixel value is zero.
891:07 - And for white, it's some value for whatever color is going on here.
891:12 - So if it's a very high number, say it's one, it's going to be pure white.
891:16 - If it's like 0.001, it might be a faint white pixel.
891:20 - But if it's exactly zero, it's going to be black.
891:23 - So color images have three color channels for red, green and blue, grayscale have one
891:27 - color channel.
891:29 - But I think we've done enough of visualizing our images as numbers.
891:34 - How about in the next video, we visualize our image as an image?
891:39 - I'll see you there.
891:42 - Welcome back.
891:43 - So in the last video, we checked the input output shapes of our data, and we downloaded
891:49 - the fashion MNIST data set, which is comprised of images or grayscale images of T-shirts,
891:54 - trousers, pullovers, dress, coat, sandal, shirt, sneaker, bag, ankle boot.
892:00 - Now we want to see if we can build a computer vision model to decipher what's going on in
892:06 - fashion MNIST.
892:07 - So to separate, to classify different items of clothing based on their numerical representation.
892:14 - And part of becoming one with the data is, of course, checking the input output shapes
892:18 - of it.
892:19 - So this is a fashion MNIST data set from Zalando Research.
892:24 - Now if you recall, why did we look at our input and output shapes?
892:27 - Well, this is what we looked at before.
892:29 - We have 28 by 28 grayscale images that we want to represent as a tensor.
892:34 - We want to use them as input into a machine learning algorithm, typically a computer vision
892:37 - algorithm, such as a CNN.
892:39 - And we want to have some sort of outputs that are formatted in the ideal shape that we'd
892:45 - like.
892:46 - So in our case, we have 10 different types of clothing.
892:49 - So we're going to have an output shape of 10, but our input shape is what?
892:54 - So by default, PyTorch turns tensors into color channels first.
892:59 - So we have an input shape of none, one, 28, 28.
893:03 - So none is going to be our batch size, which of course we can set that to whatever we'd
893:07 - like.
893:08 - Now input shape format is in NCHW, or in other words, color channels first.
893:15 - But just remember, if you're working with some other machine learning libraries, you
893:18 - may want to use color channels last.
893:21 - So let's have a look at where that might be the case.
893:24 - We're going to visualize our images.
893:27 - So I make a little heading here, 1.2.
893:30 - Now this is all part of becoming one with the data.
893:35 - In other words, understanding its input and output shapes, how many samples there are,
893:39 - what they look like, visualize, visualize, visualize.
893:44 - Let's import mapplotlib.
893:45 - I'm just going to add a few code cells here, import mapplotlib.pyplot as PLT.
893:56 - Now let's create our image and label is our train data zero, and we're going to print
894:03 - the image shape so we can understand what inputs are going into our mapplotlib function.
894:10 - And then we're going to go plot.imshow, and we're going to pass in our image and see
894:15 - what happens, because recall what does our image look like, image?
894:21 - Our image is this big tensor of numbers.
894:24 - And we've got an image shape, 128, 128.
894:27 - Now what happens if we call plot.imshow?
894:29 - What happens there?
894:31 - Oh, we get an error in valid shape, 128, 128 for image data.
894:40 - Now as I said, this is one of the most common errors in machine learning is a shape issue.
894:45 - So the shape of your input tensor doesn't match the expected shape of that tensor.
894:50 - So this is one of those scenarios where our data format, so color channels first, doesn't
894:56 - match up with what mapplotlib is expecting.
894:59 - So mapplotlib expects either just height and width, so no color channel for gray style
895:04 - images, or it also expects the color channels to be last.
895:08 - So we'll see that later on, but for grayscale, we can get rid of that extra dimension by
895:12 - passing in image.squeeze.
895:16 - So do you recall what squeeze does?
895:18 - It's going to remove that singular dimension.
895:21 - If we have a look at what goes on now, beautiful, we get an ankle boot.
895:25 - Well, that's a very pixelated ankle boot, but we're only dealing with 28 by 28 pixels,
895:31 - so not a very high definition image.
895:33 - Let's add the title to it.
895:34 - We're going to add in the label.
895:37 - Beautiful.
895:41 - So we've got the number nine here.
895:43 - So where if we go up to here, that's an ankle boot.
895:46 - Now let's plot this in grayscale.
895:48 - How might we do that?
895:49 - We can do the same thing.
895:50 - We can go plotplt.imshow.
895:52 - We're going to pass in image.squeeze.
895:56 - And we're going to change the color map, C map equals gray.
896:00 - So in mapplotlib, if you ever have to change the colors of your plot, you want to look
896:03 - into the C map property or parameter, or sometimes it's also shortened to just C.
896:09 - But in this case, M show is C map, and we want to plot title, and we're going to pull
896:14 - it in class names and the label integer here.
896:19 - So we have a look at it now.
896:21 - We have an ankle boot, and we can remove the accesses to if we wanted to plot.access,
896:25 - and turn that off.
896:27 - That's going to remove the access.
896:28 - So there we go.
896:29 - That's the type of images that we're dealing with.
896:30 - But that's only a singular image.
896:33 - How about we harness the power of randomness and have a look at some random images from
896:38 - our data set?
896:39 - So how would we do this?
896:42 - Let's go plot more images.
896:44 - We'll set a random seed.
896:46 - So you and I are both looking at as similar as possible images, 42.
896:51 - Now we'll create a plot by calling plot.figure, and we're going to give it a size.
896:57 - We might create a nine by nine grid.
896:59 - So we want to see nine random images from our data set.
897:03 - So rows, calls, or sorry, maybe we'll do four by four.
897:06 - That'll give us 16.
897:07 - We're going to go four i in range, and we're going to go one to rows times columns plus
897:16 - one.
897:17 - So we can print i.
897:18 - What's that going to give us?
897:20 - We want to see 16 images.
897:21 - Oh, they're about.
897:24 - So 16 random images, but used with a manual C to 42 of our data set.
897:30 - This is one of my favorite things to do with any type of data set that I'm looking
897:33 - at, whether it be text, image, audio, doesn't matter.
897:36 - I like to randomly have a look at a whole bunch of samples at the start so that I can
897:41 - become one with the data.
897:45 - With that being said, let's use this loop to grab some random indexes.
897:50 - We can do so using tortures, rand, int, so random integer between zero and length of
897:55 - the training data.
897:57 - This is going to give us a random integer in the range of zero and however many training
898:01 - samples we have, which in our case is what, 60,000 or thereabouts.
898:06 - So we want to create the size of one, and we want to get the item from that so that we
898:11 - have a random index.
898:12 - What is this going to give us?
898:14 - Oh, excuse me, maybe we print that out.
898:19 - There we go.
898:20 - So we have random images.
898:21 - Now, because we're using manual seed, it will give us the same numbers every time.
898:25 - So we have three, seven, five, four, two, three, seven, five, four, two.
898:30 - And then if we just commented out the random seed, we'll get different numbers every time.
898:36 - But this is just to demonstrate, we'll keep the manual seed there for now.
898:39 - You can comment that out if you want different numbers or different images, different indexes
898:43 - each time.
898:45 - So we'll create the image and the label by indexing on the training data at the random
898:49 - index that we're generating.
898:53 - And then we'll create our plot.
898:55 - So Fig or we'll add a subplot, Fig add subplot, and we're going to go rows, calls, I.
899:02 - So at the if index, we're going to add a subplot.
899:06 - Remember, we set rows and columns up to here.
899:08 - And then we're going to go PLT dot in show, we're going to show what we're going to show
899:13 - our image, but we have to squeeze it to get rid of that singular dimension as the color
899:17 - channel.
899:18 - Otherwise, we end up with an issue with map plot lib.
899:20 - We're going to use a color map of gray.
899:21 - So it looks like the image we plotted above.
899:24 - And then for our title, it's going to be our class names indexed with our label.
899:28 - And then we don't want the accesses because that's going to clutter up our plot.
899:31 - Let's see what this looks like.
899:32 - Oh my goodness, look at that.
899:35 - It worked first.
899:36 - Go.
899:37 - Usually visualizations take a fair bit of trial and error.
899:40 - So we have ankle boots, we have shirts, we have bags, we have ankle boots, sandal, shirt,
899:45 - pull over.
899:46 - Oh, do you notice something about the data set right now, pull over and shirt?
899:52 - To me, they look quite similar.
899:53 - Do you think that will cause an issue later on when our model is trying to predict between
899:57 - a pull over and a shirt?
899:59 - How about if we look at some more images?
900:02 - We'll get rid of the random seed so we can have a look at different styles.
900:06 - So have a sandal ankle boot coat, t-shirt, top, shirt, oh, is that a little bit confusing
900:13 - that we have a class for t-shirt and top and shirt?
900:16 - Like I'm not sure about you, but what's the difference between a t-shirt and a shirt?
900:24 - This is just something to keep in mind as a t-shirt and top, does that look like it could
900:27 - be maybe even a dress?
900:30 - Like the shape is there.
900:32 - So this is just something to keep in mind going forward.
900:34 - The chances are if we get confused on our, like you and I looking at our data set, if
900:39 - we get confused about different samples and what they're labeled with, our model might
900:43 - get confused later on.
900:45 - So let's have a look at one more and then we'll go into the next video.
900:50 - So we have sneaker, trouser, shirt, sandal, dress, pull over, bag, bag, t-shirt, oh, that's
900:56 - quite a difficult one.
900:57 - It doesn't look like there's even much going on in that image.
901:00 - But the whole premise of building machine learning models to do this would be could you
901:05 - write a program that would take in the shapes of these images and figure out, write a rule-based
901:10 - program that would go, hey, if it's looked like a rectangle with a buckle in the middle,
901:14 - it's probably a bag?
901:16 - I mean, you probably could after a while, but I prefer to write machine learning algorithms
901:22 - to figure out patterns and data.
901:24 - So let's start moving towards that.
901:26 - We're now going to go on figuring out how we can prepare this data to be loaded into
901:30 - a model.
901:31 - I'll see you there.
901:33 - All right, all right, all right.
901:36 - So we've got 60,000 images of clothing that we'd like to build a computer vision model
901:42 - to classify into 10 different classes.
901:44 - And now that we've visualized a fair few of these samples, do you think that we could
901:49 - model these with just linear lines, so straight lines, or do you think we'll need a model
901:54 - with nonlinearity?
901:56 - So I'm going to write that down.
901:58 - So do you think these items of clothing images could be modeled with pure linear lines, or
902:13 - do you think we'll need nonlinearity?
902:17 - Don't have to answer that now.
902:20 - We could test that out later on.
902:21 - You might want to skip ahead and try to build a model yourself with linear lines or nonlinearities.
902:26 - We've covered linear lines and nonlinearities before, but let's now start to prepare our
902:32 - data even further to prepare data loader.
902:38 - So right now, our data is in the form of PyTorch data sets.
902:46 - So let's have a look at it.
902:48 - Same data.
902:52 - There we go.
902:53 - So we have data set, which is of fashion MNIST.
902:55 - And then if we go test data, we see a similar thing except we have a different number of
903:01 - data points.
903:02 - We have the same transform on each, we've turned them into tenses.
903:05 - So we want to convert them from a data set, which is a collection of all of our data,
903:09 - into a data loader.
903:10 - Paul, that a data loader, turns our data set into a Python iterable.
903:22 - So I'm going to turn this into Markdown, beautiful.
903:26 - More specifically, specific Galilee, can I spell right?
903:31 - I don't know, we want to just code right, we're not here to learn spelling.
903:35 - We want to turn our data into batches, or mini batches.
903:45 - Why would we do this?
903:48 - Well, we may get away with it by building a model to look at all 60,000 samples of our
903:54 - current data set, because it's quite small.
903:56 - It's only comprised of images of 28 by 28 pixels.
904:01 - And when I say quite small, yes, 60,000 images is actually quite small for a deep learning
904:07 - scale data set.
904:08 - Modern data sets could be in the millions of images.
904:12 - But if our computer hardware was able to look at 60,000 samples of 28 by 28 at one time,
904:20 - it would need a fair bit of memory.
904:22 - So we have RAM space up here, we have GPU memory, we have compute memory.
904:28 - But chances are that it might not be able to store millions of images in memory.
904:33 - So what you do is you break a data set from say 60,000 into groups of batches or mini
904:40 - batches.
904:41 - So we've seen batch size before, why would we do this?
904:45 - Well, one, it is more computationally efficient, as in your computing hardware may not be able
904:58 - to look store in memory at 60,000 images in one hit.
905:06 - So we break it down to 32 images at a time.
905:11 - This would be batch size of 32.
905:14 - Now again, 32 is a number that you can change.
905:17 - 32 is just a common batch size that you'll see with many beginner style problems.
905:22 - As you go on, you'll see different batch sizes.
905:24 - This is just to exemplify the concept of mini batches, which is very common in deep
905:29 - learning.
905:30 - And why else would we do this?
905:32 - The second point or the second main point is it gives our neural network more chances
905:41 - to update its gradients per epoch.
905:45 - So what I mean by this, this will make more sense when we write a training loop.
905:48 - But if we were to just look at 60,000 images at one time, we would per epoch.
905:54 - So per iteration through the data, we would only get one update per epoch across our entire
905:59 - data set.
906:00 - Whereas if we look at 32 images at a time, our neural network updates its internal states,
906:06 - its weights, every 32 images, thanks to the optimizer.
906:10 - This will make a lot more sense once we write our training loop.
906:12 - But these are the two of the main reasons for turning our data into mini batches in the
906:17 - form of a data loader.
906:18 - Now if you'd like to learn more about the theory behind this, I would highly recommend
906:22 - looking up Andrew Org mini batches.
906:25 - There's a great lecture on that.
906:28 - So yeah, large-scale machine learning, mini batch gradient descent, mini batch gradient
906:33 - descent.
906:34 - Yeah, that's what it's called mini batch gradient descent.
906:36 - If you look up some results on that, you'll find a whole bunch of stuff.
906:39 - I might just link this one, I'm going to pause that, I'm going to link this in there.
906:48 - So for more on mini batches, see here.
906:56 - Now to see this visually, I've got a slide prepared for this.
907:00 - So this is what we're going to be working towards.
907:02 - There's our input and output shapes.
907:03 - We want to create batch size of 32 across all of our 60,000 training images.
907:08 - And we're actually going to do the same for our testing images, but we only have 10,000
907:12 - testing images.
907:14 - So this is what our data set's going to look like, batched.
907:17 - So we're going to write some code, namely using the data loader from torch.util.data.
907:23 - We're going to pass it a data set, which is our train data.
907:26 - We're going to give it a batch size, which we can define as whatever we want.
907:28 - For us, we're going to use 32 to begin with.
907:31 - And we're going to set shuffle equals true if we're using the training data.
907:35 - Why would we set shuffle equals true?
907:38 - Well, in case our data set for some reason has order, say we had all of the pants images
907:43 - in a row, we had all of the T-shirt images in a row, we had all the sandal images in
907:47 - a row.
907:48 - We don't want our neural network to necessarily remember the order of our data.
907:51 - We just want it to remember individual patterns between different classes.
907:56 - So we shuffle up the data, we mix it, we mix it up.
907:59 - And then it looks something like this.
908:02 - So we might have batch number zero, and then we have 32 samples.
908:06 - Now I ran out of space when I was creating these, but we got, that was fun up to 32.
908:12 - So this is setting batch size equals 32.
908:14 - So we look at 32 samples per batch.
908:17 - We mix all the samples up, and we go batch, batch, batch, batch, batch, and we'll have,
908:22 - however many batches we have, we'll have number of samples divided by the batch size.
908:26 - So 60,000 divided by 32, what's that, 1800 or something like that?
908:31 - So this is what we're going to be working towards.
908:33 - I did want to write some code in this video, but I think to save it getting too long, we're
908:36 - going to write this code in the next video.
908:38 - If you would like to give this a go on your own, here's most of the code we have to do.
908:42 - So there's the train data loader, do the same for the test data loader.
908:46 - And I'll see you in the next video, and we're going to batchify our fashion MNIST data set.
908:53 - Welcome back.
908:54 - In the last video, we had a brief overview of the concept of mini batches.
908:59 - And so rather than our computer looking at 60,000 images in one hit, we break things down.
909:05 - We turn it into batches of 32.
909:07 - Again, the batch size will vary depending on what problem you're working on.
909:11 - But 32 is quite a good value to start with and try out.
909:15 - And we do this for two main reasons, if we jump back to the code, why would we do this?
909:20 - It is more computationally efficient.
909:22 - So if we have a GPU with, say, 10 gigabytes of memory, it might not be able to store all
909:27 - 60,000 images in one hit.
909:29 - In our data set, because it's quite small, it may be hour or two, but it's better practice
909:35 - for later on to turn things into mini batches.
909:38 - And it also gives our neural network more chances to update its gradients per epoch,
909:42 - which will make a lot more sense once we write our training loop.
909:45 - But for now, we've spoken enough about the theory.
909:48 - Let's write some code to do so.
909:50 - So I'm going to import data loader from torch dot utils dot data, import data loader.
909:57 - And this principle, by the way, preparing a data loader goes the same for not only images,
910:02 - but for text, for audio, whatever sort of data you're working with, mini batches will
910:08 - follow you along or batches of data will follow you along throughout a lot of different deep
910:13 - learning problems.
910:15 - So set up the batch size hyper parameter.
910:18 - Remember, a hyper parameter is a value that you can set yourself.
910:23 - So batch size equals 32.
910:25 - And it's practice.
910:27 - You might see it typed as capitals.
910:29 - You won't always see it, but you'll see it quite often a hyper parameter typed as capitals.
910:34 - And then we're going to turn data sets into iterables.
910:38 - So batches.
910:40 - So we're going to create a train data loader here of our fashion MNIST data set.
910:46 - We're going to use data loader.
910:47 - We're going to see what the doc string is.
910:49 - Or actually, let's look at the documentation torch data loader.
910:56 - This is some extra curriculum for you too, by the way, is to read this data page torch
911:01 - utils not data because no matter what problem you're going with with deep learning or pytorch,
911:05 - you're going to be working with data.
911:07 - So spend 10 minutes just reading through here.
911:09 - I think I might have already assigned this, but this is just so important that it's worth
911:13 - going through again.
911:15 - Read through all of this.
911:17 - Even if you don't understand all of it, what's going on, it's just it helps you know where
911:20 - to look for certain things.
911:22 - So what does it take?
911:23 - Data loader takes a data set.
911:25 - We need to set the batch size to something is the default of one.
911:28 - That means that it would create a batch of one image at a time in our case.
911:32 - Do we want to shuffle it?
911:33 - Do we want to use a specific sampler?
911:35 - There's a few more things going on.
911:37 - Number of workers.
911:39 - Number of workers stands for how many cores on our machine do we want to use to load data?
911:44 - Generally the higher the better for this one, but we're going to keep most of these as
911:47 - the default because most of them are set to pretty good values to begin with.
911:51 - I'll let you read more into the other parameters here.
911:55 - We're going to focus on the first three data set batch size and shuffle true or false.
912:00 - Let's see what we can do.
912:02 - So data set equals our train data, which is 60,000 fashion MNIST.
912:08 - And then we have a batch size, which we're going to set to our batch size hyper parameter.
912:12 - So we're going to have a batch size of 32.
912:15 - And then finally, do we want to shuffle the training data?
912:17 - Yes, we do.
912:19 - And then we're going to do the same thing for the test data loader, except we're not
912:23 - going to shuffle the test data.
912:25 - Now, you can shuffle the test data if you want, but in my practice, it's actually easier
912:31 - to evaluate different models when the test data isn't shuffled.
912:36 - So you shuffle the training data to remove order.
912:39 - And so your model doesn't learn order.
912:41 - But for evaluation purposes, it's generally good to have your test data in the same order
912:46 - because our model will never actually see the test data set during training.
912:51 - We're just using it for evaluation.
912:53 - So the order doesn't really matter to the test data loader.
912:56 - It's just easier if we don't shuffle it, because then if we evaluate it multiple times, it's
913:01 - not been shuffled every single time.
913:03 - So let's run that.
913:05 - And then we're going to check it out, our train data loader and our test data loader.
913:14 - Beautiful.
913:15 - Instances of torch utils data, data loader, data loader.
913:20 - And now let's check out what we've created, hey, I always like to print different attributes
913:25 - of whatever we make, check out what we've created.
913:28 - This is all part of becoming one with the data.
913:32 - So print F, I'm going to go data loaders, and then pass in, this is just going to output
913:40 - basically the exact same as what we've got above.
913:43 - This data loader.
913:45 - And we can also see what attributes we can get from each of these by going train data
913:50 - loader.
913:51 - I don't need caps lock there, train data loader, full stop.
913:54 - And then we can go tab.
913:55 - We've got a whole bunch of different attributes.
913:57 - We've got a batch size.
913:58 - We've got our data set.
913:59 - Do we want to drop the last as in if our batch size overlapped with our 60,000 samples?
914:05 - Do we want to get rid of the last batch?
914:07 - Say for example, the last batch only had 10 samples.
914:10 - Do we want to just drop that?
914:11 - Do we want to pin the memory that's going to help later on if we wanted to load our
914:14 - data faster?
914:15 - A whole bunch of different stuff here.
914:18 - If you'd like to research more, you can find all the stuff about what's going on here in
914:22 - the documentation.
914:24 - But let's just keep pushing forward.
914:26 - What else do we want to know?
914:27 - So let's find the length of the train data loader.
914:31 - We will go length train data loader.
914:37 - So this is going to tell us how many batches there are, batches of, which of course is batch
914:42 - size.
914:44 - And we want print length of test data loader.
914:51 - We want length test data loader batches of batch size dot dot dot.
914:59 - So let's find out some information.
915:01 - What do we have?
915:02 - Oh, there we go.
915:03 - So just we're seeing what we saw before with this one.
915:06 - But this is more interesting here.
915:08 - Length of train data loader.
915:09 - Yeah, we have about 1,875 batches of 32.
915:13 - So if we do 60,000 training samples divided by 32, yeah, it comes out to 1,875.
915:20 - And if we did the same with 10,000 for testing samples of 32, it comes out at 313.
915:26 - This gets rounded up.
915:27 - So this is what I meant, that the last batch will have maybe not 32 because 32 doesn't
915:32 - divide evenly into 10,000, but that's okay.
915:36 - And so this means that our model is going to look at 1,875 individual batches of 32
915:44 - images, rather than just one big batch of 60,000 images.
915:49 - Now of course, the number of batches we have will change if we change the batch size.
915:55 - So we have 469 batches of 128.
915:58 - And if we reduce this down to one, what do we get?
916:01 - We have a batch per sample.
916:03 - So 60,000 batches of 1, 10,000 batches of 1, we're going to stick with 32.
916:09 - But now let's visualize.
916:10 - So we've got them in train data loader.
916:12 - How would we visualize a batch or a single image from a batch?
916:17 - So let's show a sample.
916:18 - I'll show you how you can interact with a data loader.
916:21 - We're going to use randomness as well.
916:25 - So we'll set a manual seed and then we'll get a random index, random idx equals torch
916:31 - rand int.
916:33 - We're going to go from zero to length of train features batch.
916:37 - Oh, where did I get that from?
916:39 - Excuse me.
916:40 - Getting ahead of myself here.
916:42 - I want to check out what's inside the training data loader.
916:48 - We'll check out what's inside the training data loader because the test data load is
916:51 - going to be similar.
916:53 - So we want the train features batch.
916:55 - So I say features as in the images themselves and the train labels batch is going to be
917:01 - the labels of our data set or the targets in pytorch terminology.
917:05 - So next idar data loader.
917:08 - So because our data loader has 1875 batches of 32, we're going to turn it into an iterable
917:16 - with ita and we're going to get the next batch with next and then we can go here train features
917:24 - batch.shape and we'll get train labels batch.shape.
917:32 - What do you think this is going to give us?
917:34 - Well, there we go.
917:35 - Look at that.
917:36 - So we have a tensor.
917:37 - Each batch we have 32 samples.
917:40 - So this is batch size and this is color channels and this is height and this is width.
917:45 - And then we have 32 labels associated with the 32 samples.
917:49 - Now where have we seen this before, if we go back through our keynote input and output
917:56 - shapes.
917:57 - So we have shape equals 32, 28, 28, 1.
918:00 - So this is color channels last, but ours is currently in color channels first.
918:06 - Now again, I sound like a broken record here, but these will vary depending on the problem
918:11 - you're working with.
918:12 - If we had larger images, what would change or the height and width dimensions would change.
918:17 - If we had color images, the color dimension would change, but the premise is still the
918:21 - same.
918:22 - We're turning our data into batches so that we can pass that to a model.
918:26 - Let's come back.
918:27 - Let's keep going with our visualization.
918:30 - So we want to visualize one of the random samples from a batch and then we're going to
918:36 - go image label equals train features batch and we're going to get the random IDX from
918:44 - that and we'll get the train labels batch and we'll get the random IDX from that.
918:50 - So we're matching up on the, we've got one batch here, train features batch, train labels
918:56 - batch and we're just getting the image and the label at a random index within that batch.
919:03 - So excuse me, I need to set this equal there.
919:07 - And then we're going to go PLT dot in show, what are we going to show?
919:13 - We're going to show the image but we're going to have to squeeze it to remove that singular
919:16 - dimension and then we'll set the C map equal to gray and then we'll go PLT dot title, we'll
919:23 - set the title which is going to be the class names indexed by the label integer and then
919:29 - we can turn off the accesses.
919:32 - You can use off here or you can use false, depends on what you'd like to use.
919:37 - Let's print out the image size because you can never know enough about your data and
919:43 - then print, let's also get the label, label and label shape or label size.
919:55 - Our label will be just a single integer so it might not have a shape but that's okay.
920:02 - Let's have a look.
920:03 - Oh, bag.
920:04 - See, look, that's quite hard to understand.
920:07 - I wouldn't be able to detect that that's a bag.
920:10 - Can you tell me that you could write a program to understand that?
920:12 - That just looks like a warped rectangle to me.
920:15 - But if we had to look at another one, we'll get another random, oh, we've got a random
920:19 - seed so it's going to produce the same image each time.
920:23 - So we have a shirt, okay, a shirt.
920:25 - So we see the image size there, 128, 28.
920:28 - Now, recall that the image size is, it's a single image so it doesn't have a batch dimension.
920:34 - So this is just color channels height width.
920:37 - We'll go again, label four, which is a coat and we could keep doing this to become more
920:44 - and more familiar with our data.
920:45 - But these are all from this particular batch that we created here, coat and we'll do one
920:52 - more, another coat.
920:53 - We'll do one more just to make sure it's not a coat.
920:55 - There we go.
920:56 - We've got a bag.
920:57 - Beautiful.
920:58 - So we've now turned our data into data loaders.
921:02 - So we could use these to pass them into a model, but we don't have a model.
921:07 - So I think it's time in the next video, we start to build model zero.
921:12 - We start to build a baseline.
921:14 - I'll see you in the next video.
921:17 - Welcome back.
921:18 - So in the last video, we got our data sets or our data set into data loaders.
921:24 - So now we have 1,875 batches of 32 images off of the training data set rather than 60,000
921:31 - in a one big data set.
921:33 - And we have 13 or 313 batches of 32 for the test data set.
921:38 - Then we learned how to visualize it from a batch.
921:41 - And we saw that we have still the same image size, one color channel, 28, 28.
921:47 - All we've done is we've turned them into batches so that we can pass them to our model.
921:52 - And speaking of model, let's have a look at our workflow.
921:55 - Where are we up to?
921:56 - Well, we've got our data ready.
921:58 - We've turned it into tensors through a combination of torch vision transforms, torch utils data
922:03 - dot data set.
922:04 - We didn't have to use that one because torch vision dot data sets did it for us with the
922:08 - fashion MNIST data set, but we did use that one.
922:11 - We did torch utils dot data, the data loader to turn our data sets into data loaders.
922:18 - Now we're up to building or picking a pre-trained model to suit your problem.
922:21 - So let's start simply.
922:23 - Let's build a baseline model.
922:25 - And this is very exciting because we're going to build our first model, our first computer
922:29 - vision model, albeit a baseline, but that's an important step.
922:33 - So I'm just going to write down here.
922:35 - When starting to build a series of machine learning modeling experiments, it's best practice
922:46 - to start with a baseline model.
922:48 - I'm going to turn this into markdown.
922:55 - A baseline model.
922:57 - So a baseline model is a simple model.
923:01 - You will try and improve upon with subsequent models, models slash experiments.
923:12 - So you start simply, in other words, start simply and add complexity when necessary because
923:22 - neural networks are pretty powerful, right?
923:24 - And so they have a tendency to almost do too well on our data set.
923:28 - That's a concept known as overfitting, which we'll cover a little bit more later.
923:33 - But we built a simple model to begin with, a baseline.
923:35 - And then our whole goal will be to run experiments, according to the workflow, improve through
923:40 - experimentation.
923:41 - Again, this is just a guide.
923:43 - It's not set in stone, but this is the general pattern of how things go.
923:47 - Get data ready, build a model, fit the model, evaluate, improve the model.
923:51 - So the first model that we build is generally a baseline.
923:54 - And then later on, we want to improve through experimentation.
923:57 - So let's start building a baseline.
923:59 - But I'm going to introduce to you a new layer that we haven't seen before.
924:03 - That is creating a flatten layer.
924:06 - Now what is a flatten layer?
924:07 - Well, this is best seen when we code it out.
924:11 - So let's create a flatten model, which is just going to be nn.flatten.
924:15 - And where could we find the documentation for this?
924:18 - We go nn flatten, flatten in pytorch, what does it do?
924:24 - Flattens a continuous range of dims into a tensor, for use with sequential.
924:30 - So there's an example there, but I'd rather, if and doubt, code it out.
924:35 - So we'll create the flatten layer.
924:36 - And of course, all nn.flatten or nn.modules could be used as a model on their own.
924:42 - So we're going to get a single sample.
924:48 - So x equals train features batch.
924:52 - Let's get the first one, zero.
924:54 - What does this look like?
924:56 - So it's a tensor, x, maybe we get the shape of it as well, x shape.
925:04 - What do we get?
925:05 - There we go.
925:06 - So that's the shape of x.
925:07 - Keep that in mind when we pass it through the flatten layer.
925:09 - Do you have an inkling of what flatten might do?
925:13 - So our shape to begin with is what, 128, 28.
925:18 - Now let's flatten the sample.
925:22 - So output equals, we're going to pass it to the flatten model, x.
925:28 - So this is going to perform the forward pass internally on the flatten layer.
925:32 - So perform forward pass.
925:34 - Now let's print out what happened.
925:37 - Print, shape before flattening equals x dot shape.
925:49 - And we're going to print shape after flattening equals output dot shape.
925:56 - So we're just taking the output of the flatten model and printing its shape here.
926:02 - Oh, do you notice what happened?
926:06 - Well we've gone from 128, 28 to 1784.
926:12 - Wow what does the output look like?
926:16 - Output.
926:17 - Oh, the values are now in all one big vector and if we squeeze that we can remove the extra
926:23 - dimension.
926:24 - So we've got one big vector of values.
926:27 - Now where did this number come from?
926:29 - Well, if we take this and this is what shape is it?
926:33 - We've got color channels.
926:34 - We've got height.
926:35 - We've got width and now we've flattened it to be color channels, height, width.
926:46 - So we've got one big feature vector because 28 by 28 equals what?
926:53 - We've got one value per pixel, 784.
926:58 - One value per pixel in our output vector.
927:02 - Now where did we see this before?
927:06 - If we go back to our keynote, if we have a look at Tesla's takes eight cameras and then
927:10 - it turns it into a three dimensional vector space, vector space.
927:16 - So that's what we're trying to do here.
927:17 - We're trying to encode whatever data we're working with in Tesla's case.
927:22 - They have eight cameras.
927:24 - Now theirs has more dimensions than ours because they have the time aspect because they're
927:28 - dealing with video and they have multiple different camera angles.
927:30 - We're just dealing with a single image here.
927:32 - But regardless, the concept is the same.
927:34 - We're trying to condense information down into a single vector space.
927:39 - And so if we come back to here, why might we do this?
927:43 - Well, it's because we're going to build a baseline model and we're going to use a linear
927:48 - layer as the baseline model.
927:50 - And the linear layer can't handle multi dimensional data like this.
927:53 - We want it to have a single vector as input.
927:56 - Now this will make a lot more sense after we've coded up our model.
928:00 - Let's do that from torch import and then we're going to go class, fashion, amnest, model
928:11 - V zero.
928:12 - We're going to inherit from an end dot module.
928:16 - And inside here, we're going to have an init function in the constructor.
928:19 - We're going to pass in self.
928:22 - We're going to have an input shape, which we'll use a type hint, which will take an integer
928:26 - because remember, input shape is very important for machine learning models.
928:31 - We're going to define a number of hidden units, which will also be an integer, and then we're
928:34 - going to define our output shape, which will be what do you think our output shape will
928:38 - be?
928:39 - How many classes are we dealing with?
928:41 - We're dealing with 10 different classes.
928:43 - So our output shape will be, I'll save that for later on.
928:47 - I'll let you guess for now, or you might already know, we're going to initialize it.
928:53 - And then we're going to create our layer stack.
928:56 - self.layer stack equals nn.sequential, recall that sequential, whatever you put inside sequential,
929:02 - if data goes through sequential, it's going to go through it layer by layer.
929:06 - So let's create our first layer, which is going to be nn.flatten.
929:10 - So that means anything that comes into this first layer, what's going to happen to it?
929:15 - It's going to flatten its external dimensions here.
929:18 - So it's going to flatten these into something like this.
929:22 - So we're going to flatten it first, flatten our data.
929:25 - Then we're going to pass in our linear layer.
929:28 - And we're going to have how many n features this is going to be input shape, because we're
929:33 - going to define our input shape here.
929:36 - And then we're going to go out features, equals hidden units.
929:43 - And then we're going to create another linear layer here.
929:46 - And we're going to set up n features, equals hidden units.
929:50 - Why are we doing this?
929:51 - And then out features equals output shape.
929:54 - Why are we putting the same out features here as the n features here?
929:58 - Well, because subsequent layers, the input of this layer here, its input shape has to
930:05 - line up with the output shape of this layer here.
930:09 - Hence why we use out features as hidden units for the output of this nn.linear layer.
930:15 - And then we use n features as hidden units for the input value of this hidden layer here.
930:22 - So let's keep going.
930:24 - Let's go def.
930:25 - We'll create the forward pass here, because if we subclass nn.module, we have to override
930:30 - the forward method.
930:31 - The forward method is going to define what?
930:33 - It's going to define the forward computation of our model.
930:38 - So we're just going to return self.layer stack of x.
930:43 - So our model is going to take some input, x, which could be here, x.
930:49 - In our case, it's going to be a batch at a time, and then it's going to pass each sample
930:53 - through the flatten layer.
930:54 - It's going to pass the output of the flatten layer to this first linear layer, and it's
930:59 - going to pass the output of this linear layer to this linear layer.
931:04 - So that's it.
931:05 - Our model is just two linear layers with a flatten layer.
931:08 - The flatten layer has no learnable parameters.
931:11 - Only these two do.
931:13 - And we have no nonlinearities.
931:16 - So do you think this will work?
931:18 - Does our data set need nonlinearities?
931:21 - Well, we can find out once we fit our model to the data, but let's set up an instance
931:26 - of our model.
931:27 - So torch dot manual seed.
931:33 - Let's go set up model with input parameters.
931:38 - So we have model zero equals fashion MNIST model, which is just the same class that we
931:44 - wrote above.
931:47 - And here's where we're going to define the input shape equals 784.
931:53 - Where will I get that from?
931:56 - Well, that's here.
931:59 - That's 28 by 28.
932:00 - So the output of flatten needs to be the input shape here.
932:04 - So we could put 28 by 28 there, or we're just going to put 784 and then write a comment
932:10 - here.
932:11 - This is 28 by 28.
932:14 - Now if we go, I wonder if nn.linear will tell us, nn.linear will tell us what it expects
932:22 - as in features.
932:25 - Size of each input sample, shape, where star means any number of dimensions, including
932:32 - none in features, linear weight, well, let's figure it out.
932:38 - Let's see what happens if in doubt coded out, hey, we'll see what we can do.
932:43 - In units equals, let's go with 10 to begin with.
932:47 - How many units in the hidden layer?
932:53 - And then the output shape is going to be what?
932:57 - Output shape is length of class names, which will be 1 for every class.
933:06 - Beautiful.
933:07 - And now let's go model zero.
933:09 - We're going to keep it on the CPU to begin with.
933:11 - We could write device-agnostic code, but to begin, we're going to send it to the CPU.
933:16 - I might just put that up here, actually, to CPU.
933:20 - And then let's have a look at model zero.
933:25 - Wonderful.
933:26 - So we can try to do a dummy forward pass and see what happens.
933:29 - So let's create dummy x equals torch, rand, we'll create it as the same size of image.
933:37 - Just a singular image.
933:38 - So this is going to be a batch of one, color channel one, height 28, height 28.
933:43 - And we're going to go model zero and pass through dummy x.
933:50 - So this is going to send dummy x through the forward method.
933:54 - Let's see what happens.
933:56 - Okay, wonderful.
933:59 - So we get an output of 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 logits.
934:06 - Beautiful.
934:07 - That's exactly what we want.
934:08 - We have one logit value per class that we have.
934:11 - Now what would happen if we got rid of flatten?
934:15 - Then we ran this, ran this, ran this.
934:18 - What do we get?
934:20 - Oh, mat one and mat two shapes cannot be multiplied.
934:25 - So we have 28 by 28 and 7.
934:29 - Okay, what happens if we change our input shape to 28?
934:34 - We're getting shape mismatches here.
934:37 - What happens here?
934:38 - Oh, okay, we get an interesting output, but this is still not the right shape, is it?
934:45 - So that's where the flatten layer comes in.
934:46 - What is the shape of this?
934:48 - Oh, we get 1, 1, 28, 10.
934:52 - Oh, so that's why we put in flatten so that it combines it into a vector.
934:58 - So we get rid of this, see if we just leave it in this shape?
935:01 - We get 28 different samples of 10, which is not what we want.
935:05 - We want to compress our image into a singular vector and pass it in.
935:09 - So let's reinstanceuate the flatten layer and let's make sure we've got the right input
935:13 - shape here, 28 by 28, and let's pass it through, torch size 110.
935:19 - That's exactly what we want, 1 logit per class.
935:22 - So this could be a bit fiddly when you first start, but it's also a lot of fun once you
935:27 - get it to work.
935:28 - And so just keep that in mind, I showed you what it looks like when you have an error.
935:32 - One of the biggest errors that you're going to face in machine learning is different tensor
935:37 - shape mismatches.
935:39 - So just keep in mind the data that you're working with and then have a look at the documentation
935:43 - for what input shape certain layers expect.
935:48 - So with that being said, I think it's now time that we start moving towards training
935:51 - our model.
935:53 - I'll see you in the next video.
935:56 - Welcome back.
935:57 - In the last video, we created model zero, which is going to be our baseline model for
936:02 - our computer vision problem of detecting different types of clothing in 28 by 28 gray scale
936:08 - images.
936:09 - And we also learned the concept of making sure our or we rehashed on the concept of
936:14 - making sure our input and output shapes line up with where they need to be.
936:19 - We also did a dummy forward pass with some dummy data.
936:22 - This is a great way to troubleshoot to see if your model shapes are correct.
936:26 - If they come out correctly and if the inputs are lining up with where they need to be.
936:32 - And just to rehash on what our model is going to be or what's inside our model, if we check
936:37 - model zero state dict, what we see here is that our first layer has a weight tensor.
936:44 - It also has a bias and our next layer has a weight tensor and it also has a bias.
936:51 - So these are of course initialized with random values, but the whole premise of deep learning
936:56 - and machine learning is to pass data through our model and use our optimizer to update
937:02 - these random values to better represent the features in our data.
937:07 - And I keep saying features, but I just want to rehash on that before we move on to the
937:10 - next thing.
937:12 - Featuring data could be almost anything.
937:14 - So for example, the feature of this bag could be that it's got a rounded handle at the
937:17 - top.
937:18 - It has a edge over here.
937:19 - It has an edge over there.
937:21 - Now, we aren't going to tell our model what features to learn about the data.
937:25 - The whole premise of it is to, or the whole fun, the whole magic behind machine learning
937:29 - is that it figures out what features to learn.
937:33 - And so that is what the weights and bias matrices or tensors will represent is different features
937:39 - in our images.
937:40 - And there could be many because we have 60,000 images of 10 classes.
937:45 - So let's keep pushing forward.
937:46 - It's now time to set up a loss function and an optimizer.
937:50 - Speaking of optimizers, so 3.1 set up loss optimizer and evaluation metrics.
937:58 - Now recall in notebook two, I'm going to turn this into markdown.
938:02 - We created, oh, I don't need an emoji there.
938:06 - So this is, by the way, we're just moving through this workflow.
938:10 - We've got our data ready into tensors.
938:11 - We've built a baseline model.
938:12 - It's now time to pick a loss function and an optimizer.
938:16 - So we go back to Google Chrome.
938:20 - That's right here.
938:21 - Loss function.
938:22 - What's our loss function going to be?
938:24 - Since we're working with multi-class data, our loss function will be NN dot cross entropy
938:35 - loss.
938:37 - And our optimizer, we've got a few options here with the optimizer, but we've had practice
938:43 - in the past with SGD, which stands for stochastic gradient descent and the atom optimizer.
938:49 - So our optimizer, let's just stick with SGD, which is kind of the entry level optimizer
938:56 - torch opt in SGD for stochastic gradient descent.
939:05 - And finally, our evaluation metric, since we're working on a classification problem, let's
939:17 - use accuracy as our evaluation metric.
939:25 - So recall that accuracy is a classification evaluation metric.
939:28 - Now, where can we find this?
939:30 - Well, if we go into learnpytorch.io, this is the beauty of having online reference material.
939:37 - In here, neural network classification with PyTorch, in this notebook, section 02, we
939:42 - created, do we have different classification methods?
939:45 - Yes, we did.
939:47 - So we've got a whole bunch of different options here for classification evaluation metrics.
939:51 - We've got accuracy, precision, recall, F1 score, a confusion matrix.
939:56 - Now we have some code that we could use.
939:57 - If we wanted to use torch metrics for accuracy, we could.
940:02 - And torch metrics is a beautiful library that has a lot of evaluation.
940:06 - Oh, it doesn't exist.
940:09 - What happened to torch metrics?
940:11 - Maybe I need to fix that.
940:13 - Link.
940:15 - Torch metrics has a whole bunch of different PyTorch metrics.
940:20 - So very useful library.
940:23 - But we also coded a function in here, which is accuracy FN.
940:29 - So we could copy this, straight into our notebook here.
940:35 - Or I've also, if we go to the PyTorch deep learning GitHub, I'll just bring it over here.
940:40 - I've also put it in helper functions.py.
940:43 - And this is a script of common functions that we've used throughout the course, including
940:48 - if we find accuracy function here.
940:51 - Calculate accuracy.
940:52 - Now, how would we get this helper functions file, this Python file, into our notebook?
940:58 - One way is to just copy the code itself, straight here.
941:01 - But let's import it as a Python script.
941:04 - So import request, and we're going to go from pathlib import path.
941:09 - So we want to download, and this is actually what you're going to see, very common practice
941:14 - in larger Python projects, especially deep learning and machine learning projects, is
941:20 - different functionality split up in different Python files.
941:24 - And that way, you don't have to keep rewriting the same code over and over again.
941:27 - Like you know how we've written a training and testing loop a fair few times?
941:30 - Well, if we've written it once and it works, we might want to save that to a.py file so
941:35 - we can import it later on.
941:37 - So let's now write some code to import this helper functions.py file into our notebook
941:42 - here.
941:43 - So download helper functions from learn pytorch repo.
941:49 - So we're going to check if our helper functions.py, if this already exists, we don't want
941:57 - to download it.
941:59 - So we'll print helper functions.py already exists, skipping download, skipping download
942:07 - .dot.
942:08 - And we're going to go else here.
942:11 - If it doesn't exist, so we're going to download it, downloading helper functions.py.
942:20 - And we're going to create a request here with the request library equals request.get.
942:27 - Now here's where we have to pass in the URL of this file.
942:31 - It's not this URL here.
942:33 - When dealing with GitHub, to get the actual URL to the files, many files, you have to
942:38 - click the raw button.
942:39 - So I'll just go back and show you, click raw here.
942:43 - And we're going to copy this raw URL.
942:45 - See how it's just text here?
942:47 - This is what we want to download into our co-lab notebook.
942:50 - And we're going to write it in there, request equals request.get.
942:54 - And we're going to go with open, and here's where we're going to save our helper functions
942:59 - .py.
943:01 - We're going to write binary as file, F is for file.
943:05 - We're going to go F.write, request.content.
943:10 - So what this is saying is Python is going to create a file called helper functions.py
943:16 - and give it write binary permissions as F, F is for file, short for file.
943:22 - And then we're going to say F.write, request, get that information from helper functions
943:28 - .py here, and write your content to this file here.
943:33 - So let's give that a shot.
943:39 - Beautiful.
943:41 - So downloading helper functions.py, let's have a look in here.
943:45 - Do we have helper functions.py?
943:47 - Yes, we do.
943:49 - Wonderful.
943:50 - We can import our accuracy function.
943:53 - Where is it?
943:54 - There we go.
943:55 - Import accuracy function.
943:57 - So this is very common practice when writing lots of Python code is to put helper functions
944:02 - into.py scripts.
944:04 - So let's import the accuracy metric.
944:10 - Accuracy metric from helper functions.
944:13 - Of course, we could have used torch metrics as well.
944:15 - That's another perfectly valid option, but I just thought I'd show you what it's like
944:19 - to import your own helper function script.
944:23 - Of course, you can customize helper functions.py to have whatever you want in there.
944:27 - So see this?
944:28 - We've got from helper functions, import accuracy function.
944:32 - What's this saying?
944:33 - Could not be resolved.
944:34 - Is this going to work?
944:37 - It did.
944:38 - And where you can go accuracy function, do we get a doc string?
944:43 - Hmm.
944:45 - Seems like colab isn't picking things up, but that's all right.
944:47 - It looks like it still worked.
944:48 - We'll find out later on if it actually works when we train our model.
944:52 - So set up loss function and optimizer.
944:58 - So I'm going to set up the loss function equals nn dot cross entropy loss.
945:04 - And I'm going to set up the optimizer here as we discussed before as torch dot opt-in
945:10 - dot SGD for stochastic gradient descent.
945:13 - The parameters I want to optimize are the parameters from model zero, our baseline model,
945:18 - which we had a look at before, which are all these random numbers.
945:21 - We'd like our optimizer to tweak them in some way, shape, or form to better represent our
945:25 - data.
945:26 - And then I'm going to set the learning rate here.
945:28 - How much should they be tweaked each epoch?
945:30 - I'm going to set it to 0.1.
945:32 - Nice and high because our data set is quite simple.
945:36 - It's 28 by 28 images.
945:37 - There are 60,000 of them.
945:39 - But again, if this doesn't work, we can always adjust this and experiment, experiment,
945:44 - experiment.
945:45 - So let's run that.
945:46 - We've got a loss function.
945:47 - Is this going to give me a doc string?
945:49 - There we go.
945:50 - So calculates accuracy between truth and predictions.
945:54 - Now, where does this doc string come from?
945:55 - Well, let's have a look, hope of functions.
945:59 - That's what we wrote before.
946:02 - Good on us for writing good doc strings, accuracy function.
946:06 - Well, we're going to test all these out in the next video when we write a training loop.
946:12 - So, oh, actually, I think we might do one more function before we write a training loop.
946:18 - How about we create a function to time our experiments?
946:21 - Yeah, let's give that a go in the next video.
946:24 - I'll see you there.
946:27 - Welcome back.
946:28 - In the last video, we downloaded our helper functions.py script and imported our accuracy
946:32 - function that we made in notebook two.
946:35 - But we could really beef this up, our helper functions.py file.
946:40 - We could put a lot of different helper functions in there and import them so we didn't have
946:43 - to rewrite them.
946:44 - That's just something to keep in mind for later on.
946:46 - But now, let's create a function to time our experiments.
946:51 - So creating a function to time our experiments.
946:55 - So one of the things about machine learning is that it's very experimental.
947:00 - You've probably gathered that so far.
947:03 - So let's write here.
947:04 - So machine learning is very experimental.
947:10 - Two of the main things you'll often want to track are, one, your model's performance
947:18 - such as its loss and accuracy values, et cetera.
947:24 - And two, how fast it runs.
947:29 - So usually you want a higher performance and a fast model, that's the ideal scenario.
947:36 - However, you could imagine that if you increase your model's performance, you might have
947:40 - a bigger neural network.
947:41 - It might have more layers.
947:43 - It might have more hidden units.
947:45 - It might degrade how fast it runs because you're simply making more calculations.
947:49 - So there's often a trade-off between these two.
947:52 - And how fast it runs will really be important if you're running a model, say, on the internet
947:58 - or say on a dedicated GPU or say on a mobile device.
948:02 - So these are two things to really keep in mind.
948:05 - So because we're tracking our model's performance with our loss value and our accuracy function,
948:10 - let's now write some code to check how fast it runs.
948:14 - And I did on purpose above, I kept our model on the CPU.
948:18 - So we're also going to compare later on how fast our model runs on the CPU versus how
948:23 - fast it runs on the GPU.
948:25 - So that's something that's coming up.
948:28 - Let's write a function here.
948:30 - We're going to use the time module from Python.
948:32 - So from time it, import the default timer, as I'm going to call it timer.
948:37 - So if we go Python default timer, do we get the documentation for, here we go, time it.
948:44 - So do we have default timer, wonderful.
948:49 - So the default timer, which is always time.perf counter, you can read more about Python timing
948:55 - functions in here.
948:57 - But this is essentially just going to say, hey, this is the exact time that our code
949:01 - started.
949:02 - And then we're going to create another stop for when our code stopped.
949:05 - And then we're going to compare the start and stop times.
949:07 - And that's going to basically be how long our model took to train.
949:11 - So we're going to go def print train time.
949:16 - This is just going to be a display function.
949:18 - So start, we're going to get the float type hint, by the way, start an end time.
949:24 - So the essence of this function will be to compare start and end time.
949:29 - And we're going to set the torch or the device here, we'll pass this in as torch dot device.
949:36 - And we're going to set that default to none, because we want to compare how fast our model
949:40 - runs on different devices.
949:42 - So I'm just going to write a little doc string here, prints, difference between start and
949:49 - end time.
949:51 - And then of course, we could add more there for the arguments, but that's a quick one liner.
949:54 - Tell us what our function does.
949:56 - So total time equals end minus start.
949:59 - And then print, we're going to write here train time on, whichever device we're using
950:05 - might be CPU, might be GPU.
950:08 - Total time equals, we'll go to three and we'll say seconds, three decimal places that is
950:16 - and return total time.
950:20 - Beautiful.
950:21 - So for example, we could do start time equals timer, and then end time equals timer.
950:32 - And then we can put in here some code between those two.
950:37 - And then if we go print train, oh, maybe we need a timer like this, we'll find out if
950:44 - and out code it out, you know, we'll see if it works.
950:48 - Start time and end equals end time and device equals.
950:57 - We're running on the CPU right now, CPU, let's see if this works, wonderful.
951:04 - So it's a very small number here.
951:07 - So train time on CPU, very small number, because the start time is basically on this
951:13 - exact line, comment basically it takes no time to run, then end time is on here, we get
951:19 - 3.304 times 10 to the power of negative five.
951:25 - So quite a small number, but if we put some modeling code in here, it's going to measure
951:30 - the start time of this cell, it's going to model our code in there, then we have the
951:35 - end time, and then we find out how long our model took the train.
951:39 - So with that being said, I think we've got all of the pieces of the puzzle for creating
951:44 - some training and testing functions.
951:47 - So we've got a loss function, we've got an optimizer, we've got a valuation metric, we've
951:50 - got a timing function, we've got a model, we've got some data.
951:55 - How about we train our first baseline computer vision model in the next video?
951:59 - I'll see you there.
952:01 - Good morning.
952:04 - Well might not be morning wherever you are in the world.
952:06 - It's nice and early here, I'm up recording some videos, because we have a lot of momentum
952:10 - going with this, but look at this, I took a little break last night, I have a runtime
952:14 - disconnected, but this is just what's going to happen if you're using Google Colab.
952:19 - Since I use Google Colab Pro, completely unnecessary for the course, but I just found it worth
952:24 - it for how much I use Google Colab, I get longer idle timeouts, so that means that my
952:30 - Colab notebook will stay persistent for a longer time.
952:33 - But of course overnight it's going to disconnect, so I click reconnect, and then if I want to
952:38 - get back to wherever we were, because we downloaded some data from torchvision.datasets, I have
952:45 - to rerun all of these cells.
952:47 - So a nice shortcut, we might have seen this before, is to just come down to where we were,
952:53 - and if all the code above works, oh there we go, I wrote myself some notes of where we're
952:58 - up to.
953:01 - Let's go run before, so this is just going to run all the cells above, and we're up
953:05 - to here, 3.3 creating a training loop, and training a model on batches of data.
953:11 - So that's going to be a little bit interesting, and I wrote myself another reminder here, this
953:15 - is a little bit of behind the scenes, the optimise will update a model's parameters
953:20 - once per batch rather than once per epoch.
953:23 - So let's hold myself to that note, and make sure I let you know.
953:28 - So we're going to make another title here.
953:32 - Let's go creating a training loop, and training a model on batches of data.
953:40 - So something a little bit different to what we may have seen before if we haven't created
953:44 - batches of data using data loader, and recall that just up above here, we've got something
953:52 - like 1800 there, there we go.
953:55 - So we've split our data into batches, rather than our model looking at 60,000 images of
954:00 - fashion MNIST data at one time, it's going to look at 1875 batches of 32, so 32 images
954:07 - at the time, of the training data set, and 313 batches of 32 of the test data set.
954:14 - So let's go to training loop and train our first model.
954:19 - So I'm going to write out a few steps actually, because we have to do a little bit differently
954:23 - to what we've done before.
954:25 - So one, we want to loop through epochs, so a number of epochs.
954:31 - Loop through training batches, and by the way, you might be able to hear some birds singing,
954:35 - the sun is about to rise, I hope you enjoy them as much as I do.
954:39 - So we're going to perform training steps, and we're going to calculate calculate the
954:45 - train loss per batch.
954:49 - So this is going to be one of the differences between our previous training loops.
954:54 - And this is going to, after number two, we're going to loop through the testing batches.
954:59 - So we'll train and evaluate our model at the same step, or same loop.
955:04 - And we're going to perform testing steps.
955:08 - And then we're going to calculate the test loss per batch as well, per batch.
955:17 - Wonderful, four, we're going to, of course, print out what's happening.
955:23 - You may have seen the unofficial PyTorch optimization loop theme song.
955:28 - And we're going to time it all for fun, of course, because that's what our timing function
955:33 - is for.
955:34 - So let's get started.
955:36 - There's a fair few steps here, but nothing that we can't handle.
955:40 - And remember the motto, if and out, code it out.
955:43 - Well, there's another one, if and out, run the code, but we haven't written any code to
955:46 - run just yet.
955:48 - So we're going to import TQDM for a progress bar.
955:52 - If you haven't seen TQDM before, it's a very good Python progress bar that you can add
955:57 - with a few lines of code.
955:59 - So this is just the GitHub.
956:00 - It's open source software, one of my favorite pieces of software, and it's going to give
956:05 - us a progress bar to let us know how many epochs our training loop has gone through.
956:12 - It doesn't have much overhead, but if you want to learn more about it, please refer
956:15 - to the TQDM GitHub.
956:17 - However, the beautiful thing is that Google CoLab has TQDM built in because it's so good
956:23 - and so popular.
956:25 - So we're going to import from TQDM.auto.
956:28 - So there's a few different types of TQDM progress bars.auto is just going to recognize what
956:34 - compute environment we're using.
956:37 - And it's going to give us the best type of progress bar for what we're doing.
956:41 - So for example, Google CoLab is running a Jupyter Notebook behind the scenes.
956:45 - So the progress bar for Jupyter Notebooks is a little bit different to Python scripts.
956:52 - So now let's set the seed and start the timer.
956:58 - We want to write all of our training loop in this single cell here.
957:03 - And then once it starts, once we run this cell, we want the timer to start so that we
957:08 - can time how long the entire cell takes to run.
957:12 - So we'll go train time start on CPU equals, we set up our timer before, beautiful.
957:24 - Now we're going to set the number of epochs.
957:28 - Now we're going to keep this small for faster training time so we can run more experiments.
957:34 - So we'll keep this small for faster training time.
957:39 - That's another little tidbit.
957:41 - Do you notice how quickly all of the cells ran above?
957:43 - Well, that's because we're using a relatively small data set.
957:48 - In the beginning, when you're running experiments, you want them to run quite quickly so that
957:51 - you can run them more often.
957:53 - So you can learn more about your data so that you can try different things, try different
957:57 - models.
957:59 - So this is why we're using number of epochs equals three.
958:02 - We start with three so that our experiment runs in 30 seconds or a minute or so.
958:07 - That way, if something doesn't work, we haven't wasted so much time waiting for a model to
958:11 - train.
958:12 - Later on, we could train it for 100 epochs if we wanted to.
958:16 - So we're going to create a training and test loop.
958:18 - So for epoch in TQDM range epochs, let's get this going.
958:25 - So for TQDM to work, we just wrap our iterator with TQDM and you'll see later on how this
958:31 - tracks the progress.
958:32 - So I'm going to put out a little print statement here.
958:36 - We'll go epoch.
958:39 - This is just going to say what epoch we're on.
958:41 - We'll go here.
958:44 - That's something that I like to do quite often is put little print statements here and there
958:48 - so that we know what's going on.
958:51 - So let's set up the training.
958:53 - We're going to have to instantiate the train loss.
958:55 - We're going to set that to zero to begin with.
958:57 - And we're going to cumulatively add some values to the train loss here and then we'll
959:03 - see later on how this accumulates and we can calculate the training loss per batch.
959:09 - Let's what we're doing up here, calculate the train loss per batch.
959:12 - And then finally, at the end of the loop, we will divide our training loss by the number
959:17 - of batches so we can get the average training loss per batch and that will give us the training
959:22 - loss per epoch.
959:24 - Now that's a lot of talking.
959:25 - If that doesn't make sense, remember.
959:27 - But if and out, code it out.
959:29 - So add a loop to loop through the training batches.
959:34 - So because our data is batchified now and I've got a crow or maybe a cooker bar sitting
959:40 - on the roof across from my apartment, it's singing its song this morning, lovely.
959:47 - So we're going to loop through our training batch data.
959:51 - So I've got four batch, comma x, y, because remember our training batches come in the
959:57 - form of X.
959:59 - So that's our data or our images and why, which is label.
960:02 - You could call this image label or target as part of which would, but it's convention
960:09 - to often call your features X and your labels Y.
960:13 - We've seen this before in we're going to enumerate the train data loader as well.
960:20 - We do this so we can keep track of the number of batches we've been through.
960:23 - So that will give us batch there.
960:25 - I'm going to set model zero to training mode because even though that's the default, we
960:31 - just want to make sure that it's in training mode.
960:34 - Now we're going to do the forward pass.
960:35 - If you remember, what are the steps in apply to our optimization loop?
960:39 - We do the forward pass.
960:40 - We calculate the loss of the minus zero grad, last backwards, up to minus a step, step,
960:47 - step.
960:48 - So let's do that.
960:49 - Hey, model zero, we'll put the features through there and then we're going to calculate the
960:54 - loss.
960:57 - We've been through these steps before.
960:58 - So we're not going to spend too much time on the exact steps here, but we're just going
961:03 - to practice writing them out.
961:04 - And of course, later on, you might be thinking, then you'll, how come we haven't functionalized
961:08 - this training loop already?
961:09 - We've seemed to write the same generic code over and over again.
961:12 - Well, that's because we like to practice writing PyTorch code, right?
961:17 - We're going to functionalize them later on.
961:18 - Don't you worry about that.
961:20 - So here's another little step that we haven't done before is we have the training loss.
961:24 - And so because we've set that to zero to begin with, we're going to accumulate the training
961:28 - loss values every batch.
961:31 - So we're going to just add it up here.
961:33 - And then later on, we're going to divide it by the total number of batches to get the
961:37 - average loss per batch.
961:39 - So you see how this loss calculation is within the batch loop here?
961:45 - So this means that one batch of data is going to go through the model.
961:49 - And then we're going to calculate the loss on one batch of data.
961:53 - And this loop is going to continue until it's been through all of the batches in the train
961:57 - data loader.
961:59 - So 1875 steps or whatever there was.
962:03 - So accumulate train loss.
962:07 - And then we're going to optimize a zero grad, optimizer dot zero grad.
962:15 - And then number four is what?
962:18 - Loss backward.
962:20 - Loss backward.
962:21 - We'll do the back propagation step.
962:22 - And then finally, we've got number five, which is optimizer step.
962:27 - So this is where I left my little note above to remind me and to also let you know, highlight
962:35 - that the optimizer will update a model's parameters once per batch rather than once per epoch.
962:40 - So you see how we've got a for loop inside our epoch loop here.
962:45 - So the batch loop.
962:46 - So this is what I meant that the optimizer, this is one of the advantages of using mini
962:50 - batches is not only is it more memory efficient because we're not loading 60,000 images into
962:55 - memory at a time.
962:57 - We are updating our model's parameters once per batch rather than waiting for it to see
963:04 - the whole data set with every batch.
963:07 - Our model is hopefully getting slightly better.
963:12 - So that is because the optimizer dot step call is within the batch loop rather than the
963:17 - epoch loop.
963:20 - So let's now print out what's happening.
963:24 - Print out what's happening.
963:26 - So if batch, let's do it every 400 or so batches because we have a lot of batches.
963:32 - We don't want to print out too often, otherwise we'll just fill our screen with numbers.
963:37 - That might not be a bad thing, but 400 seems a good number.
963:41 - That'll be about five printouts if we have 2000 batches.
963:45 - So print looked at, and of course you can adjust this to whatever you would like.
963:51 - That's the flexibility of PyTorch, flexibility of Python as well.
963:56 - So looked at how many samples have we looked at?
963:58 - So we're going to take the batch number, multiply it by X, the length of X is going
964:02 - to be 32 because that is our batch size.
964:07 - Then we're going to just write down here the total number of items that we've got now
964:13 - of data set, and we can access that by going train data loader dot data set.
964:19 - So that's going to give us length of the data set contained within our train data loader,
964:24 - which is you might be able to guess 60,000 or should be.
964:30 - Now we have to, because we've been accumulating the train loss, this is going to be quite
964:37 - high because we've been adding every single time we've calculated the loss, we've been
964:41 - adding it to the train loss, the overall value per batch.
964:45 - So now let's adjust if we wanted to find out, see how now we've got this line, we're outside
964:50 - of the batch loop.
964:51 - We want to adjust our training loss to get the average training loss per batch per epoch.
964:59 - So we're coming back to the epoch loop here.
965:01 - A little bit confusing, but you just line up where the loops are, and this is going to
965:06 - help you figure out what context you're computing in.
965:09 - So now we are in the epoch loop.
965:12 - So divide total train loss by length of train data loader, oh, this is so exciting, training
965:21 - our biggest model yet.
965:23 - So train loss equals or divide equals, we're going to reassign the train loss, we're going
965:29 - to divide it by the length of the train data loader.
965:32 - So why do we do this?
965:33 - Well, because we've accumulated the train loss here for every batch in the train data
965:38 - loader, but we want to average it out across how many batches there are in the train data
965:43 - loader.
965:45 - So this value will be quite high until we readjust it to find the average loss per epoch, because
965:51 - we are in the epoch loop.
965:53 - All right, there are a few steps going on, but that's all right, we'll figure this out,
965:57 - or what should happening in a minute, let's code up the testing loop.
966:01 - So testing, what do we have to do for testing?
966:03 - Well, let's set up a test loss variable.
966:06 - Why don't we do accuracy for testing as well?
966:10 - Did we do accuracy for training?
966:14 - We didn't do accuracy for training, but that's all right, we'll stick to doing accuracy for
966:17 - testing.
966:18 - We'll go model zero dot eval, we'll put it in evaluation mode, and we'll turn on our
966:25 - inference mode context manager with torch dot inference mode.
966:30 - Now we'll do the same thing for x, y in test data loader, we don't need to keep track
966:36 - of the batches here again in the test data loader.
966:40 - So we'll just loop through x, so features, images, and labels in our test data loader.
966:46 - We're going to do the forward pass, because the test loop, we don't have an optimization
966:51 - step, we are just passing our data through the model and evaluating the patterns it learned
966:57 - on the training data.
966:58 - So we're going to pass in x here.
967:01 - This might be a little bit confusing, let's do this x test, y test.
967:08 - That way we don't get confused with our x above for the training set.
967:12 - Now we're going to calculate the loss, a cum, relatively might small that wrong app to
967:20 - sound that out.
967:21 - What do we have here?
967:22 - So we've got our test loss variable that we just assigned to zero above, just up here.
967:28 - So we're going to do test loss plus equals.
967:30 - We're doing this in one step here.
967:32 - Test spread, y test.
967:35 - So we're comparing our test prediction to our y test labels, our test labels.
967:40 - Now we're going to back out of the for loop here, because that's all we have to do, the
967:44 - forward pass and calculate the loss for the test data set.
967:47 - Oh, I said we're going to calculate the accuracy.
967:50 - Silly me.
967:51 - So calculate accuracy.
967:53 - Let's go test act.
967:57 - And we've got plus equals.
967:59 - We can bring out our accuracy function here.
968:02 - That's what we downloaded from our helper functions dot pi before, y true equals y test.
968:07 - And then y pred equals test, pred dot arg max, dim equals one.
968:13 - Why do we do this?
968:14 - Well, because recall that the outputs of our model, the raw outputs of our model are going
968:18 - to be logits and our accuracy function expects our true labels and our predictions to be
968:25 - in the same format.
968:27 - If our test pred is just logits, we have to call arg max to find the logit value with
968:32 - the highest index, and that will be the prediction label.
968:35 - And so then we're comparing labels to labels.
968:39 - That's what the arg max does here.
968:42 - So we can back out of the batch loop now, and we're going to now calculate Cal queue
968:49 - length, the test loss, average per batch.
968:58 - So let's go here, test loss, divide equals length test data loader.
969:05 - So because we were in the context of the loop here of the batch loop, our test lost and
969:11 - test accuracy values are per batch and accumulated every single batch.
969:17 - So now we're just dividing them by how many batches we had, test data loader, and the
969:22 - same thing for the accuracy, calculate the ACK or test ACK average per batch.
969:30 - So this is giving us test loss and test accuracy per epoch, test ACK divided equals length,
969:39 - test data loader, wonderful, we're so close to finishing this up.
969:44 - And now we'll come back to where's our epoch loop.
969:47 - We can, these lines are very helpful in Google CoLab, we scroll down.
969:52 - I believe if you want them, you can go settings or something like that, yeah, settings.
969:57 - That's where you can get these lines from if you don't have them.
969:59 - So print out what's happening.
970:03 - We are going to print f equals n, let's get the train loss in here.
970:12 - Ten loss and we'll print that to four decimal places.
970:16 - And then we'll get the test loss, of course, test loss and we'll go, we'll get that to four
970:22 - decimal places as well.
970:24 - And then we'll get the test ACK, test accuracy, we'll get that to four decimal places as well.
970:35 - For f, wonderful.
970:38 - And then finally, one more step, ooh, we've written a lot of code in this video.
970:44 - We want to calculate the training time because that's another thing that we want to track.
970:48 - We want to see how long our model is taken to train.
970:51 - So train time end on CPU is going to equal the timer and then we're going to get the
971:01 - total train time model zero so we can set up a variable for this so we can compare our
971:06 - modeling experiments later on.
971:09 - We're going to go print train time, start equals train time, start on CPU and equals
971:20 - train time end on CPU.
971:23 - And finally, the device is going to be string next model zero dot parameters.
971:32 - So we're just, this is one way of checking where our model zero parameters live.
971:37 - So beautiful, all right.
971:43 - Have we got enough brackets there?
971:44 - I don't think we do.
971:46 - Okay.
971:47 - There we go.
971:48 - Whoo.
971:49 - I'll just show you what the output of this is.
971:52 - So next, model zero dot parameters, what does this give us?
971:59 - Oh, can we go device here?
972:05 - Oh, what do we have here?
972:12 - Model zero dot parameters.
972:14 - I thought this was a little trick.
972:20 - And then if we go next parameter containing.
972:29 - I thought we could get device, oh, there we go.
972:34 - Excuse me.
972:35 - That's how we get it.
972:36 - That's how we get the device that it's on.
972:37 - So let me just turn this.
972:41 - This is what the output of that's going to be CPU.
972:45 - That's what we're after.
972:47 - So troubleshooting on the fly here.
972:50 - Hopefully all of this code works.
972:51 - So we went through all of our steps.
972:53 - We're looping through epochs at the top level here.
972:56 - We looped through the training batches, performed the training steps.
972:59 - So our training loop, forward pass, loss calculation, optimizer zero grad, loss backwards, calculate
973:04 - the loss per batch, accumulate those.
973:06 - We do the same for the testing batches except without the optimizer steps and print out
973:11 - what's happening and we time it all for fun.
973:14 - A fair bit going on here, but if you don't think there's any errors, give that a go, run
973:18 - that code.
973:19 - I'm going to leave this one on a cliffhanger and we're going to see if this works in the
973:24 - next video.
973:25 - I'll see you there.
973:28 - Welcome back.
973:29 - The last video was pretty full on.
973:32 - We did a fair few steps, but this is all good practice.
973:35 - The best way to learn PyTorch code is to write more PyTorch code.
973:38 - So did you try it out?
973:41 - Did you run this code?
973:42 - Did it work?
973:43 - Did we probably have an error somewhere?
973:44 - Well, let's find out together.
973:46 - You ready?
973:47 - Let's train our biggest model yet in three, two, one, bomb.
973:51 - Oh, of course we did.
973:54 - What do we have?
973:55 - What's going on?
973:57 - Indentation error.
973:58 - Ah, classic.
974:00 - So print out what's happening.
974:03 - Do we not have an indent there?
974:06 - Oh, is that not in line with where it needs to be?
974:12 - Excuse me.
974:14 - Okay.
974:15 - Why is this not in line?
974:16 - So this is strange to me, enter.
974:19 - How did this all get off by one?
974:23 - I'm not sure, but this is just what you'll face.
974:25 - Like sometimes you'll write this beautiful code that should work, but the main error
974:29 - of your entire code is that it's off by a single space.
974:33 - I'm not sure how that happened, but we're just going to pull this all into line.
974:39 - We could have done this by selecting it all, but we're going to do it line by line just
974:43 - to make sure that everything's in the right order, beautiful, and we print out what's
974:50 - happening.
974:51 - Three, two, one, round two.
974:54 - We're going.
974:55 - Okay.
974:56 - So this is the progress bar I was talking about.
974:57 - Look at that.
974:58 - How beautiful is that?
974:59 - Oh, we're going quite quickly through all of our samples.
975:01 - I need to talk faster.
975:03 - Oh, there we go.
975:04 - We've got some good results.
975:05 - We've got the tests, the train loss, the test loss and the test accuracy is pretty darn
975:09 - good.
975:10 - Oh my goodness.
975:11 - This is a good baseline already, 67%.
975:15 - So this is showing us it's about seven seconds per iteration.
975:19 - Remember TQDM is tracking how many epochs.
975:21 - We're going through.
975:22 - So we have three epochs and our print statement is just saying, hey, we've looked at zero
975:27 - out of 60,000 samples and we looked at 12,000 out of 60,000 samples and we finished on
975:33 - an epoch two because it's zero indexed and we have a train loss of 0.4550 and a test
975:41 - loss 476 and a test accuracy 834265 and a training time about just over 21 seconds or
975:49 - just under 22.
975:50 - So keep in mind that your numbers may not be the exact same as mine.
975:55 - They should be in the same realm as mine, but due to inherent randomness of machine learning,
976:02 - even if we set the manual seed might be slightly different.
976:05 - So don't worry too much about that and what I mean by in the same realm, if your accuracy
976:10 - is 25 rather than 83, well then probably something's wrong there.
976:15 - But if it's 83.6, well then that's not too bad.
976:20 - And the same with the train time on CPU, this will be heavily dependent, how long it takes
976:24 - to train will be heavily dependent on the hardware that you're using behind the scenes.
976:30 - So I'm using Google Colab Pro.
976:32 - Now that may mean I get a faster CPU than the free version of Google Colab.
976:37 - It also depends on what CPU is available in Google's computer warehouse where Google
976:44 - Colab is hosting of how fast this will be.
976:47 - So just keep that in mind.
976:49 - If your time is 10 times that, then there's probably something wrong.
976:53 - If your time is 10 times less than that, well, hey, keep using that hardware because that's
976:58 - pretty darn good.
976:59 - So let's keep pushing forward.
977:01 - This will be our baseline that we try to improve upon.
977:04 - So we have an accuracy of 83.5 and we have a train time of 20 or so seconds.
977:10 - So we'll see what we can do with a model on the GPU later and then also later on a
977:16 - convolutional neural network.
977:18 - So let's evaluate our model where we up to what we just did.
977:22 - We built a training loop.
977:23 - So we've done that.
977:24 - That was a fair bit of code.
977:25 - But now we're up to we fit the model to the data and make a prediction.
977:30 - Let's do these two combined, hey, we'll evaluate our model.
977:34 - So we'll come back.
977:36 - Number four is make predictions and get model zero results.
977:42 - Now we're going to create a function to do this because we want to build multiple models
977:47 - and that way we can, if we have, say, model 0123, we can pass it to our function to evaluate
977:54 - that model and then we can compare the results later on.
977:58 - So that's something to keep in mind.
977:59 - If you're going to be writing a bunch of code multiple times, you probably want to
978:04 - functionize it and we could definitely do that for our training and last loops.
978:09 - But we'll see that later on.
978:11 - So let's go deaf of our model.
978:14 - So evaluate a given model, we'll pass it in a model, which will be a torch dot nn dot
978:19 - module, what of type.
978:21 - And we'll pass it in a data loader, which will be of type torch dot utils dot data dot
978:29 - data loader.
978:32 - And then we'll pass in the loss function so that it can calculate the loss.
978:38 - We could pass in an evaluation metric if we wanted to track that too.
978:41 - So this will be torch nn dot module as well.
978:44 - And then, oh, there we go.
978:47 - Speaking of an evaluation function, let's pass in our accuracy function as well.
978:51 - And I don't want L, I want that.
978:54 - So we want to return a dictionary containing the results of model predicting on data loader.
979:06 - So that's what we want.
979:07 - We're going to return a dictionary of model results.
979:10 - That way we could call this function multiple times with different models and different
979:14 - data loaders and then compare the dictionaries full of results depending on which model we
979:20 - passed in here.
979:21 - So let's set up loss and accuracy equals zero, zero, we'll start those off.
979:27 - We'll go, this is going to be much the same as our testing loop above, except it's going
979:32 - to be functionalized and we're going to return a dictionary.
979:35 - So we'll turn on our context manager for inferencing with torch dot inference mode.
979:41 - Now we're going to loop through the data loader and we'll get the x and y values.
979:46 - So the x will be our data, the y will be our ideal labels, we'll make predictions with
979:51 - the model.
979:52 - In other words, do the forward pass.
979:53 - So we'll go y pred equals model on x.
979:57 - Now we don't have to specify what model it is because we've got the model parameter up
980:02 - here.
980:03 - So we're starting to make our functions here or this function generalizable.
980:08 - So it could be used with almost any model and any data loader.
980:12 - So we want to accumulate the loss and accuracy values per batch because this is within the
980:20 - batch loop here per batch.
980:22 - And then we're going to go loss plus equals loss function, we'll pass it in the y pred
980:28 - and the y the true label and we'll do the same with the accuracy.
980:33 - So except this time we use our accuracy function, we'll send in y true equals y and y pred equals
980:41 - y pred dot argmax because the raw outputs of our model are logits.
980:47 - And if we want to convert them into labels, we could take the softmax for the prediction
980:51 - probabilities, but we could also take the argmax and just by skipping the softmax step, the
980:56 - argmax will get the index where the highest value load it is, dim equals one.
981:03 - And then we're going to make sure that we're still within the context manager here.
981:07 - So with torch inference mode, but outside the loop.
981:11 - So that'll be this line here.
981:14 - We're going to scale the loss and act to find the average loss slash act per batch.
981:24 - So loss will divide and assign to the length of the data loader.
981:30 - So that'll divide and reassign it to however many batches are in our data loader that we
981:35 - pass into our of our model function, then we'll do the same thing for the accuracy here.
981:41 - Length data loader, beautiful.
981:44 - And now we're going to return a dictionary here.
981:48 - So return, we can return the model name by inspecting the model.
981:54 - We get an attribute of the model, which is its class name.
981:58 - I'll show you how you can do that.
982:00 - So this is helpful to track if you've created multiple different models and given them different
982:06 - class names, you can access the name attribute.
982:10 - So this only works when model was created with a class.
982:17 - So you just have to ensure that your models have different class names.
982:19 - If you want to do it like that, because we're going to do it like that, we can set the model
982:24 - name to be its class name.
982:26 - We'll get the model loss, which is just this value here.
982:29 - After it's been scaled, we'll turn it into a single value by taking dot item.
982:34 - And then we'll go model dot act, or we'll get model underscore act for the models accuracy.
982:39 - We'll do the same thing here.
982:41 - Act.
982:42 - I don't think we need to take the item because accuracy comes back in a different form.
982:47 - We'll find out, if in doubt, code it out.
982:50 - So calculate model zero results on test data set.
982:53 - And I want to let you know that you can create your own functions here to do almost whatever
982:57 - you want.
982:58 - I've just decided that this is going to be helpful for the models and the data that
983:01 - we're building.
983:03 - But keep that in mind that your models, your data sets might be different and will likely
983:07 - be different in the future.
983:09 - So you can create these functions for whatever use case you need.
983:14 - Model zero results equals a vowel model.
983:21 - So we're just going to call our function that we've just created here.
983:25 - Model is going to equal model zero.
983:27 - The data loader is going to equal what?
983:30 - The test data loader, of course, because we want to evaluate it on the test data set.
983:35 - And we're going to send in our loss function, which is loss function that we assigned above
983:40 - just before our training loop.
983:42 - If we come up here, our loss function is up here, and then if we go back down, we have
983:49 - our accuracy function is equal to our accuracy function.
983:54 - We just pass another function in there, beautiful.
983:57 - And let's see if this works.
983:59 - Model zero results.
984:00 - Did you see any typos likely or errors in our code?
984:04 - How do you think our model did?
984:06 - Well, let's find out.
984:08 - Oh, there we go.
984:11 - We got model accuracy.
984:12 - Can you see how we could reuse this dictionary later on?
984:15 - So if we had model one results, model two results, we could use these dictionaries and compare
984:20 - them all together.
984:21 - So we've got our model name.
984:22 - Our version zero, the model has an accuracy of 83.42 and a loss of 0.47 on the test data
984:29 - loader.
984:30 - Again, your numbers may be slightly different.
984:32 - They should be in the same realm.
984:34 - But if they're not the exact same, don't worry too much.
984:37 - If they're 20 accuracy points less and the loss is 10 times higher, then you should probably
984:44 - go back through your code and check if something is wrong.
984:47 - And I believe if we wanted to do a progress bar here, could we do that?
984:51 - TQDM.
984:52 - Let's have a look, eh?
984:55 - Oh, look at that progress bar.
984:57 - That's very nice.
984:58 - So that's nice and quick because it's only on 313 batches.
985:02 - It goes quite quick.
985:04 - So now, what's next?
985:06 - Well, we've built model one, we've got a model zero, sorry, I'm getting ahead myself.
985:11 - We've got a baseline here.
985:12 - We've got a way to evaluate our model.
985:15 - What's our workflow say?
985:16 - So we've got our data ready.
985:17 - We've done that.
985:18 - We've picked or built a model.
985:19 - We've picked a loss function.
985:20 - We've built an optimizer.
985:21 - We've created a training loop.
985:23 - We've fit the model to the data.
985:24 - We've made a prediction.
985:26 - We've evaluated the model using loss and accuracy.
985:29 - We could evaluate it by making some predictions, but we'll save that for later on as in visualizing
985:34 - some predictions.
985:36 - I think we're up to improving through experimentation.
985:39 - So let's give that a go, hey?
985:41 - Do you recall that we trained model zero on the CPU?
985:45 - How about we build model one and start to train it on the GPU?
985:50 - So in the next section, let's create number five, is set up device agnostic code.
985:55 - So we've done this one together for using a GPU if there is one.
986:01 - So my challenge to you for the next video is to set up some device agnostic code.
986:07 - So you might have to go into CoLab if you haven't got a GPU active, change runtime type
986:11 - to GPU, and then because it might restart the runtime, you might have to rerun all of
986:16 - the cells above so that we get our helper functions file back and the data and whatnot.
986:20 - So set up some device agnostic code and I'll see you in the next video.
986:27 - How'd you go?
986:28 - You should give it a shot, did you set up some device agnostic code?
986:31 - I hope you gave it a go, but let's do it together.
986:34 - This won't take too long.
986:35 - The last two videos have been quite long.
986:38 - So if I wanted to set device agnostic code, I want to see if I have a GPU available, do
986:43 - I?
986:44 - I can check it from the video SMI.
986:47 - That fails because I haven't activated a GPU in CoLab yet.
986:50 - I can also check here, torch CUDA is available.
986:55 - That will PyTorch will check if there's a GPU available with CUDA and it's not.
987:00 - So let's fix these two because we want to start using a GPU and we want to set up device
987:06 - agnostic code.
987:07 - So no matter what hardware our system is running, PyTorch leverages it.
987:12 - So we're going to select GPU here, I'm going to click save and you'll notice that our Google
987:18 - CoLab notebook will start to reset and we'll start to connect.
987:22 - There we go.
987:23 - We've got a GPU on the back end, Python, three Google Compute Engine back end GPU.
987:28 - Do we have to reset this?
987:31 - NVIDIA SMI, wonderful, I have a Tesla T4 GPU with 16 gigabytes of memory, that is wonderful.
987:39 - And now do we have a GPU available?
987:40 - Oh, torch is not defined.
987:43 - Well, do you notice the numbers of these cells?
987:46 - One, two, that means because we've reset our runtime to have a GPU, we have to rerun
987:52 - all the cells above.
987:54 - So we can go run before, that's going to run all the cells above, make sure that we download
987:58 - the data, make sure that we download the helper functions file, we go back up, we should see
988:03 - our data may be downloading.
988:05 - It shouldn't take too long.
988:07 - That is another advantage of using a relatively small data set that is already saved on PyTorch
988:12 - data sets.
988:14 - Just keep in mind that if you use a larger data set and you have to re-download it into
988:17 - Google Colab, it may take a while to run, and if you build bigger models, they may take
988:22 - a while to run.
988:23 - So just keep that in mind for your experiments going forward, start small, increase when
988:27 - necessary.
988:28 - So we'll re-run this, we'll re-run this, and finally we're going to, oh, there we go,
988:34 - we've got a GPU, wonderful, but we'll write some device-agnostic code here, set up device-agnostic
988:41 - code.
988:42 - So import-torch, now realistically you quite often do this at the start of every notebook,
988:48 - but I just wanted to highlight how we might do it if we're in the middle, and I wanted
988:52 - to practice running a model on a CPU only before stepping things up and going to a GPU.
988:58 - So device equals CUDA, this is for our device-agnostic code, if torch dot CUDA is available, and it
989:06 - looks like this is going to return true, else use the CPU.
989:11 - And then we're going to check device, wonderful, CUDA.
989:16 - So we've got some device-agnostic code ready to go, I think it's time we built another
989:20 - model.
989:22 - And I asked the question before, do you think that the data set that we're working with
989:26 - requires nonlinearity?
989:28 - So the shirts, and the bags, and the shoes, do we need nonlinear functions to model this?
989:34 - Well it looks like our baseline model without nonlinearities did pretty well at modeling
989:40 - our data, so we've got a pretty good test accuracy value, so 83%, so out of 100 images
989:47 - it predicts the right one, 83% of the time, 83 times out of 100, it did pretty well without
989:53 - nonlinearities.
989:55 - Why don't we try a model that uses nonlinearities and it runs on the GPU?
990:00 - So you might want to give that a go, see if you can create a model with nonlinear functions,
990:04 - try nn.relu, run it on the GPU, and see how it goes, otherwise we'll do it together in
990:11 - the next video, I'll see you there.
990:15 - Hello everyone, and welcome back, we are making some terrific progress, let's see how far
990:20 - we've come, we've got a data set, we've prepared our data loaders, we've built a baseline model,
990:24 - and we've trained it, evaluated it, now it's time, oh, and the last video we set up device
990:30 - diagnostic code, but where are we in our little framework, we're up to improving through experimentation,
990:37 - and quite often that is building a different model and trying it out, it could be using
990:40 - more data, it could be tweaking a whole bunch of different things.
990:44 - So let's get into some coding, I'm going to write it here, model one, I believe we're
990:49 - up to section six now, model one is going to be building a better model with nonlinearity,
990:56 - so I asked you to do the challenge in the last video to give it a go, to try and build
991:00 - a model with nonlinearity, I hope you gave it a go, because if anything that this course,
991:05 - I'm trying to impart on you in this course, it's to give things a go, to try things out
991:09 - because that's what machine learning and coding is all about, trying things out, giving it
991:13 - a go, but let's write down here, we learned about the power of nonlinearity in notebook
991:22 - O2, so if we go to the learnpytorch.io book, we go to section number two, we'll just wait
991:31 - for this to load, and then if we come down here, we can search for nonlinearity, the missing
991:36 - piece nonlinearity, so I'm going to get this and just copy that in there, if you want to
991:41 - see what nonlinearity helps us do, it helps us model nonlinear data, and in the case of
991:47 - a circle, can we model that with straight lines, in other words, linear lines?
991:51 - All linear means straight, nonlinear means non-straight, and so we learned that through
991:57 - the power of linear and nonlinear functions, neural networks can model almost any kind
992:02 - of data if we pair them in the right way, so you can go back through and read that there,
992:08 - but I prefer to code things out and try it out on our data, so let's create a model with
992:15 - nonlinear and linear layers, but we also saw that our model with just linear layers can
992:24 - model our data, it's performing quite well, so that's where the experimentation side of
992:29 - things will come into play, sometimes you won't know what a model will do, whether it
992:34 - will work or won't work on your data set, but that is where we try different things
992:39 - out, so we come up here, we look at our data, hmm, that looks actually quite linear to
992:45 - me as a bag, like it's just some straight lines, you could maybe model that with just
992:49 - straight lines, but there are some things which you could potentially classify as nonlinear
992:54 - in here, it's hard to tell without knowing, so let's give it a go, let's write a nonlinear
993:00 - model which is going to be quite similar to model zero here, except we're going to interspurse
993:06 - some relu layers in between our linear layers, so recall that relu is a nonlinear activation
993:13 - function, and relu has the formula, if something comes in and it's a negative value, relu is
993:19 - going to turn that negative into a zero, and if something is positive, relu is just going
993:23 - to leave it there, so let's create another class here, fashion MNIST model V1, and we're
993:32 - going to subclass from nn.module, beautiful, and then we're going to initialize our model,
993:39 - it's going to be quite the same as what we created before, we want an input shape, that's
993:45 - going to be an integer, and then we want a number of hidden units, and that's going
993:50 - to be an int here, and then we want an output shape, int, and I want to stress as well that
993:57 - although we're creating a class here with these inputs, classes are as flexible as functions,
994:03 - so if you need different use cases for your modeling classes, just keep that in mind that
994:08 - you can build that functionality in, self dot layer stack, we're going to spell layer stack
994:14 - correctly, and we're going to set this equal to nn dot sequential, because we just want
994:21 - a sequential set of layers, the first one's going to be nn dot flatten, which is going
994:26 - to be flatten inputs into a single vector, and then we're going to go nn dot linear,
994:36 - because we want to flatten our stuff because we want it to be the right shape, if we don't
994:39 - flatten it, we get shape issues, input shape, and then the out features of our linear layer
994:46 - is going to be the hidden units, hidden units, I'm just going to make some code cells here
994:53 - so that my code goes into the middle of the screen, then here is where we're going to
994:58 - add a nonlinear layer, so this is where we're going to add in a relu function, and where
995:03 - might we put these? Well, generally, you'll have a linear function followed by a nonlinear
995:08 - function in the construction of neural networks. However, neural networks are as customizable
995:13 - as you can imagine, whether they work or not is a different question. So we'll go output
995:19 - shape here, as the out features, oh, do we miss this one up? Yes, we did. This needs
995:25 - to be hidden units. And why is that? Well, it's because the output shape of this linear
995:33 - layer here needs to match up with the input shape of this linear layer here. The relu
995:38 - layer won't change the shape of our data. And you could test that out by printing the
995:42 - different shapes if you'd like. And then we're going to finish off with another nonlinear
995:47 - layer at the end. Relu. Now, do you think that this will improve our model's results
995:54 - or not? Well, it's hard to tell without trying it out, right? So let's continue building
995:59 - our model. We have to override the forward method. Self X is going to be, we'll give
996:05 - a type in here, this is going to be a torch tensor as the input. And then we're just going
996:09 - to return what's happening here, we go self dot layer stack X. So that just means that
996:16 - X is going to pass through our layer stack here. And we could customize this, we could
996:20 - try it just with one nonlinear activation. This is actually our previous network, just
996:26 - with those commented out. All we've done is added in two relu functions. And so I'm
996:31 - going to run that beautiful. And so what should we do next? Well, we shouldn't stand
996:38 - shaded but previously we ran our last model model zero on if we go parameters. Do we run
996:46 - this on the GPU or the CPU? On the CPU. So how about we try out our fashion MNIST model
996:54 - or V one running on the device that we just set up which should be CUDA. Wonderful. So
997:00 - we can instantiate. So create an instance of model one. So we want model one or actually
997:09 - we'll set up a manual seed here so that whenever we create a new instance of a model, it's
997:14 - going to be instantiated with random numbers. We don't necessarily have to set a random
997:18 - seed, but we do so anyway so that our values are quite similar on your end and my end input
997:25 - shape is going to be 784. Where does that come from? Well, that's because this is the
997:32 - output of the flatten layer after our 28 by 28 image goes in. Then we're going to set
997:42 - up the hidden units. We're going to use the same number of hidden units as before, which
997:45 - is going to be 10. And then the output shape is what? We need one value, one output neuron
997:51 - for each of our classes. So length of the class names. And then we're going to send
997:56 - this to the target device so we can write send to the GPU if it's available. So now
998:03 - that we've set up device agnostic code in the last video, we can just put two device
998:08 - instead of hard coding that. And so if we check, so this was the output for model zero's device,
998:16 - let's now check model one's device, model one parameters, and we can check where those
998:23 - parameters live by using the device attribute. Beautiful. So our model one is now living
998:31 - on the GPU CUDA at index zero. Index zero means that it's on the first GPU that we have
998:37 - available. We only have one GPU available. So it's on this Tesla T for GPU. Now, we've
998:44 - got a couple more things to do. Now that we've created another model, we can recreate if
998:49 - we go back to our workflow, we've just built a model here. What do we have to do after
998:53 - we built a model? We have to instantiate a loss function and an optimizer. Now we've
998:58 - done both of those things for model zero. So that's what we're going to do in the next
999:02 - video. But I'd like you to go ahead and try to create a loss function for our model and
999:07 - optimizer for model one. The hint is that they can be the exact same loss function and
999:11 - optimizer as model zero. So give that a shot and I'll see you in the next video. Welcome
999:19 - back. In the last video, we created another model. So we're continuing with our modeling
999:24 - experiments. And the only difference here between fashion MNIST model V1 and V0 is that
999:29 - we've added in nonlinear layers. Now we don't know for now we could think or guess whether
999:35 - they would help improve our model. And with practice, you can start to understand how
999:39 - different functions will influence your neural networks. But I prefer to, if in doubt, code
999:44 - it out, run lots of different experiments. So let's continue. We now have to create
999:49 - a loss function, loss, optimizer, and evaluation metrics. So we've done this for model zero.
999:58 - So we're not going to spend too much time explaining what's going on here. And we've
1000:01 - done this a fair few times now. So from helper functions, which is the script we downloaded
1000:06 - before, we're going to import our accuracy function. And we're going to set up a loss
1000:11 - function, which is we're working with multi class classification. So what loss function
1000:16 - do we typically use? And then dot cross entropy loss. And as our optimizer is going to be
1000:25 - torch dot opt in dot SGD. And we're going to optimize this time. I'll put in the params
1000:31 - keyword here, model one dot parameters. And the learning rate, we're just going to keep
1000:37 - it the same as our previous model. And that's a thing to keep a note for your experiments.
1000:42 - When you're running fair few experiments, you only really want to tweak a couple of things
1000:46 - or maybe just one thing per experiment, that way you can really narrow down what actually
1000:51 - influences your model and what improves it slash what doesn't improve it. And a little
1000:55 - pop quiz. What does a loss function do? This is going to measure how wrong our model is.
1001:05 - And what does the optimizer do? Tries to update our models parameters to reduce the
1001:15 - loss. So that's what these two functions are going to be doing. The accuracy function is
1001:21 - of a course going to be measuring our models accuracy. We measure the accuracy because that's
1001:26 - one of the base classification metrics. So we'll run this. Now what's next? We're getting
1001:33 - quite good at this. We've picked a loss function and an optimizer. Now we're going to build
1001:38 - a training loop. However, we spent quite a bit of time doing that in a previous video.
1001:43 - If we go up here, that was our vowel model function. Oh, that was helpful. We turned it
1001:49 - into a function. How about we do the same with these? Why don't we make a function for
1001:55 - our training loop as well as our testing loop? So I think you can give this a go. We're going
1002:03 - to make a function in the next video for training. We're going to call that train step. And
1002:09 - we'll create a function for testing called test step. Now they'll both have to take in
1002:14 - some parameters. I'll let you figure out what they are. But otherwise, we're going to code
1002:18 - that up together in the next video. So I'll see you there.
1002:24 - So we've got a loss function ready and an optimizer. What's our next step? Well, it's
1002:28 - to create training and evaluation loops. So let's make a heading here. We're going to
1002:32 - call this functionizing training and evaluation or slash testing loops because we've written
1002:40 - similar code quite often for training and evaluating slash testing our models. Now we're
1002:48 - going to start moving towards functionizing code that we've written before because that's
1002:52 - not only a best practice, it helps reduce errors because if you're writing a training
1002:56 - loop all the time, we may get it wrong. If we've got one that works for our particular
1003:01 - problem, hey, we might as well save that as a function so we can continually call that
1003:05 - over and over and over again. So how about we, and this is going to be very rare that
1003:11 - I'm going to allow you to do this is that is we're going to copy this training and you
1003:15 - might have already attempted to create this. That is the function called, let's create
1003:22 - a function for one training loop. And we're going to call this train step. And we're going
1003:34 - to create a function for the testing loop. You're going to call this test step. Now these
1003:39 - are just what I'm calling them. You can call them whatever you want. I just understand
1003:44 - it quite easily by calling it train step. And then we can for each epoch in a range,
1003:50 - we call our training step. And then the same thing for each epoch in a range, we can call
1003:55 - a testing step. This will make a lot more sense once we've coded it out. So let's put
1004:01 - the training code here. To functionize this, let's start it off with train step. Now what
1004:07 - parameters should our train step function take in? Well, let's think about this. We
1004:12 - need a model. We need a data loader. We need a loss function. And we need an optimizer.
1004:21 - We could also put in an accuracy function here if we wanted to. And potentially it's
1004:28 - not here, but we could put in what target device we'd like to compute on and make our
1004:33 - code device agnostic. So this is just the exact same code we went through before. We
1004:38 - loop through a data loader. We do the forward pass. We calculate the loss. We accumulate
1004:43 - it. We zero the optimizer. We perform backpropagation in respect to the loss with the parameters
1004:49 - of the model. And then we step the optimizer to hopefully improve the parameters of our
1004:54 - model to better predict the data that we're trying to predict. So let's craft a train
1005:00 - step function here. We'll take a model, which is going to be torch nn.module, type hint.
1005:08 - And we're going to put in a data loader, which is going to be of type torch utils dot data
1005:16 - dot data loader. Now we don't necessarily need to put this in these type hints, but
1005:21 - they're relatively new addition to Python. And so you might start to see them more and
1005:24 - more. And it also just helps people understand what your code is expecting. So the loss
1005:30 - function, we're going to put in an optimizer torch dot opt in, which is a type optimizer.
1005:38 - We also want an accuracy function. We don't necessarily need this either. These are a
1005:42 - lot of nice to habs. The first four are probably the most important. And then the device. So
1005:47 - torch is going to be torch dot device equals device. So we'll just hard code that to be
1005:55 - our already set device parameter. And we'll just write in here, performs training step
1006:04 - with model, trying to learn on data loader. Nice and simple, we could make that more
1006:15 - explanatory if we wanted to, but we'll leave it at that for now. And so right at the start,
1006:20 - we're going to set up train loss and train act equals zero zero. We're going to introduce
1006:25 - accuracy here. So we can get rid of this. Let's just go through this line by line. What
1006:30 - do we need to do here? Well, we've got four batch XY in enumerate train data loader. But
1006:37 - we're going to change that to data loader up here. So we can just change this to data
1006:42 - loader. Wonderful. And now we've got model zero dot train. Do we want that? Well, no,
1006:50 - because we're going to keep this model agnostic, we want to be able to use any model with this
1006:54 - function. So let's get rid of this model dot train. We are missing one step here is
1006:59 - put data on target device. And we could actually put this model dot train up here. Put model
1007:10 - into training mode. Now, this will be the default for the model. But just in case we're
1007:15 - going to call it anyway, model dot train, put data on the target device. So we're going
1007:21 - to go XY equals X dot two device, Y dot two device. Wonderful. And the forward pass, we
1007:31 - don't need to use model zero anymore. We're just going to use model that's up here. The
1007:36 - loss function can stay the same because we're passing in a loss function up there. The train
1007:42 - loss can be accumulated. That's fine. But we might also accumulate now the train accuracy,
1007:48 - limit loss, and accuracy per batch. So train act equals or plus equals our accuracy function
1007:57 - on Y true equals Y and Y pred equals Y pred. So the outputs here, Y pred, we need to take
1008:08 - because the raw outputs, outputs, the raw logits from the model, because our accuracy
1008:14 - function expects our predictions to be in the same format as our true values. We need
1008:20 - to make sure that they are we can call the argmax here on the first dimension. This is
1008:24 - going to go from logits to prediction labels. We can keep the optimizer zero grab the same
1008:33 - because we're passing in an optimizer up here. We can keep the loss backwards because the
1008:37 - loss is just calculated there. We can keep optimizer step. And we could print out what's
1008:43 - happening. But we might change this up a little bit. We need to divide the total train loss
1008:50 - and accuracy. I just want to type in accuracy here because now we've added in accuracy metric
1008:55 - act. So train act divided equals length train data loader. Oh, no, sorry. We can just use
1009:04 - the data loader here, data loader, data loader. And we're not going to print out per batch
1009:13 - here. I'm just going to get rid of this. We'll make at the end of this step, we will make
1009:18 - our print out here, print. Notice how it's at the end of the step because we're outside
1009:23 - the for loop now. So we're going to here, we're accumulating the loss on the training
1009:30 - data set and the accuracy on the training data set per batch. And then we're finding
1009:35 - out at the end of the training steps. So after it's been through all the batches in
1009:39 - the data loader, we're finding out what the average loss is per batch. And the average
1009:45 - accuracy is per batch. And now we're going to go train loss is going to be the train
1009:53 - loss on 0.5. And then we're going to go train act is going to be train act. And we're going
1010:07 - to set that to 0.2 F. Get that there, percentage. Wonderful. So if all this works, we should
1010:20 - be able to call our train step function and pass it in a model, a data loader, a loss
1010:25 - function, an optimizer, an accuracy function and a device. And it should automatically
1010:30 - do all of these steps. So we're going to find that out in a later video. In the next video,
1010:34 - we're going to do the same thing we've just done for the training loop with the test step.
1010:39 - But here's your challenge for this video is to go up to the testing loop code we wrote
1010:43 - before and try to recreate the test step function in the same format that we've done here. So
1010:49 - give that a go. And I'll see you in the next video. Welcome back. In the last video, we
1010:56 - functionalized our training loop. So now we can call this train step function. And instead
1011:01 - of writing all this training loop code again, well, we can train our model through the art
1011:06 - of a function. Now let's do the same for our testing loop. So I issued you the challenge
1011:11 - in the last video to give it a go. I hope you did because that's the best way to practice
1011:15 - PyTorch code is to write more pytorch code. Let's put in a model, which is going to be
1011:20 - torch and then dot module. And we're going to put in a data loader. Because we need a
1011:28 - model and we need data, the data loader is going to be, of course, the test data load
1011:33 - here, torch dot utils dot data dot data loader. And then we're going to put in a loss function,
1011:38 - which is going to be torch and end up module as well. Because we're going to use an end
1011:44 - up cross entropy loss. We'll see that later on. We're going to put in an accuracy function.
1011:49 - We don't need an optimizer because we're not doing any optimization in the testing loop.
1011:53 - We're just evaluating. And the device can be torch dot device. And we're going to set
1011:58 - that as a default to the target device parameter. Beautiful. So we'll put a little doctoring
1012:04 - here. So performs a testing loop step on model going over data loader. Wonderful. So now
1012:18 - let's set up a test loss and a test accuracy, because we'll measure test loss and accuracy
1012:23 - without testing loop function. And we're going to set the model into, I'll just put a comment
1012:28 - here, put the model in a vowel mode. So model dot a vowel, we don't have to use any underscore
1012:38 - here as in model zero, because we have a model coming in the top here. Now, what should we
1012:44 - do? Well, because we're performing a test step, we should turn on inference mode. So
1012:50 - turn on inference mode, inference mode context manager. Remember, whenever you're performing
1012:57 - predictions with your model, you should put it in model dot a vowel. And if you want as
1013:02 - many speedups as you can get, make sure the predictions are done within the inference
1013:07 - mode. Because remember, inference is another word for predictions within the inference
1013:12 - mode context manager. So we're going to loop through our data loader for X and Y in data
1013:18 - loader. We don't have to specify that this is X test. For Y test, we could if we wanted
1013:24 - to. But because we're in another function here, we can just go for X, Y in data loader,
1013:31 - we can do the forward pass. After we send the data to the target device, target device,
1013:40 - so we're going to have X, Y equals X dot two device. And the same thing with Y, we're
1013:48 - just doing best practice here, creating device agnostic code. Then what should we do? Well,
1013:53 - we should do the thing that I said before, which is the forward pass. Now that our data
1013:56 - and model be on the same device, we can create a variable here test pred equals model, we're
1014:02 - going to pass in X. And then what do we do? We can calculate the loss. So to calculate
1014:09 - the loss slash accuracy, we're going to accumulate it per batch. So we'll set up test loss equals
1014:17 - loss function. Oh, plus equals loss function. We're going to pass it in test pred and Y,
1014:25 - which is our truth label. And then the test act where you will accumulate as well, using
1014:30 - our accuracy function, we'll pass in Y true equals Y. And then Y pred, what do we have
1014:36 - to do to Y pred? Well, our test pred, we have to take the argmax to convert it from.
1014:43 - So this is going to outputs raw logits. Remember, a models raw output is referred to as logits.
1014:51 - And then here, we have to go from logits to prediction labels. Beautiful. Oh, little typo
1015:01 - here. Did you catch that one? Tab, tab. Beautiful. Oh, look how good this function is looking.
1015:07 - Now we're going to adjust the metrics. So adjust metrics and print out. You might notice
1015:14 - that we're outside of the batch loop here, right? So if we draw down from this line for
1015:21 - and we write some code here, we're still within the context manager. This is important because
1015:25 - if we want to adapt a value created inside the context manager, we have to modify it
1015:33 - still with inside that context manager, otherwise pytorch will throw an error. So try to write
1015:39 - this code if you want outside the context manager and see if it still works. So test loss, we're
1015:46 - going to adjust it to find out the average test loss and test accuracy per batch across
1015:54 - a whole step. So we're going to go length data loader. Now we're going to print out
1016:00 - what's happening. Print out what's happening. So test loss, which we put in here, well,
1016:06 - we're going to get the test loss. Let's get this to five decimal places. And then we're
1016:11 - going to go test act. And we will get that to two decimal places. You could do this as
1016:18 - many decimal as you want. You could even times it by 100 to get it in proper accuracy format.
1016:24 - And we'll put a new line on the end here. Wonderful. So now it looks like we've got functions.
1016:31 - I haven't run this cell yet for a training step and a test step. So how do you think we
1016:37 - could replicate if we go back up to our training loop that we wrote before? How do you think
1016:42 - we could replicate the functionality of this, except this time using our functions? Well,
1016:51 - we could still use this for epoch and TQDM range epochs. But then we would just call
1016:56 - our training step for this training code, our training step function. And we would call
1017:01 - our testing step function, passing in the appropriate parameters for our testing loop.
1017:07 - So that's what we'll do in the next video. We will leverage our two functions, train
1017:12 - step and test step to train model one. But here's your challenge for this video. Give
1017:18 - that a go. So use our training step and test step function to train model one for three
1017:24 - epochs and see how you go. But we'll do it together in the next video. Welcome back.
1017:31 - How'd you go? Did you create a training loop or a PyTorch optimization loop using our training
1017:37 - step function and a test step function? Were there any errors? In fact, I don't even know.
1017:43 - But how about we find out together? Hey, how do we combine these two functions to create
1017:46 - an optimization loop? So I'm going to go torch dot manual seed 42. And I'm going to measure
1017:54 - the time of how long our training and test loop takes. This time we're using a different
1017:58 - model. So this model uses nonlinearities and it's on the GPU. So that's the main thing
1018:03 - we want to compare is how long our model took on CPU versus GPU. So I'm going to import
1018:08 - from time it, import default timer as timer. And I'm going to start the train time. Train
1018:16 - time start on GPU equals timer. And then I'm just right here, set epochs. I'm going to
1018:27 - set epochs equal to three, because we want to keep our training experiments as close
1018:32 - to the same as possible. So we can see what little changes do what. And then it's create
1018:38 - a optimization and evaluation loop using train step and test step. So we're going to loop
1018:51 - through the epochs for epoch in TQDM. So we get a nice progress bar in epochs. Then we're
1018:59 - going to print epoch. A little print out of what's going on. Epoch. And we'll get a new
1019:08 - line. And then maybe one, two, three, four, five, six, seven, eight or something like
1019:12 - that. Maybe I'm miscounted there. But that's all right. Train step. What do we have to
1019:16 - do for this? Now we have a little doc string. We have a model. What model would we like
1019:21 - to use? We'd like to use model one. We have a data loader. What data loader would we
1019:26 - like to use? Well, we'd like to use our train data loader. We also have a loss function,
1019:32 - which is our loss function. We have an optimizer, which is our optimizer. And we have an accuracy
1019:44 - function, which is our accuracy function. And oops, forgot to put FM. And finally, we have
1019:53 - a device, which equals device, but we're going to set that anyway. So how beautiful is that
1019:58 - for creating a training loop? Thanks to the code that we've functionalized before. And
1020:02 - just recall, we set our optimizer and loss function in a previous video. You could bring
1020:07 - these down here if you really wanted to, so that they're all in one place, either way
1020:12 - up. But we can just get rid of that because we've already set it. Now we're going to do
1020:17 - the same thing for our test step. So what do we need here? Let's check the doc string.
1020:22 - We could put a little bit more information in this doc string if we wanted to to really
1020:25 - make our code more reusable, and so that if someone else was to use our code, or even
1020:30 - us in the future knows what's going on. But let's just code it out because we're just
1020:35 - still fresh in our minds. Model equals model one. What's our data loader going to be for
1020:40 - the test step? It's going to be our test data loader. Then we're going to set in a loss
1020:45 - function, which is going to be just the same loss function. We don't need to use an optimizer
1020:49 - here because we are only evaluating our model, but we can pass in our accuracy function.
1020:56 - Accuracy function. And then finally, the device is already set, but we can just pass
1021:00 - it in anyway. Look at that. Our whole optimization loop in a few lines of code. Isn't that beautiful?
1021:08 - So these functions are something that you could put in, like our helper functions dot
1021:12 - pi. And that way you could just import it later on. And you don't have to write your
1021:17 - training loops all over again. But we'll see a more of an example of that later on in
1021:22 - the course. So let's keep going. We want to measure the train time, right? So we're
1021:30 - going to create, once it's been through these steps, we're going to create train time end
1021:34 - on CPU. And then we're going to set that to the timer. So all this is going to do is
1021:41 - measure at value in time, once this line of code is run, it's going to run all of these
1021:46 - lines of code. So it's going to perform the training and optimization loop. And then it's
1021:50 - going to, oh, excuse me, this should be GPU. It's going to measure a point in time here.
1021:57 - So once all this codes run, measure a point in time there. And then finally, we can go
1022:01 - total train time for model one is equal to print train time, which is our function that
1022:08 - we wrote before. And we pass it in a start time. And it prints the difference between
1022:14 - the start and end time on a target device. So let's do that. Start equals what? Train
1022:21 - time start on GPU. The end is going to be train time end on GPU. And the device is going
1022:31 - to be device. Beautiful. So are you ready to run our next modeling experiment model one?
1022:42 - We've got a model running on the GPU, and it's using nonlinear layers. And we want to
1022:46 - compare it to our first model, which our results were model zero results. And we have total
1022:53 - train time on model zero. Yes, we do. So this is what we're going for. Does our model
1023:00 - one beat these results? And does it beat this result here? So three, two, one, do we
1023:06 - have any errors? No, we don't. Okay. Train step got an unexpected keyword loss. Oh, did
1023:14 - you catch that? I didn't type in loss function. Let's run it again. There we go. Okay, we're
1023:20 - running. We've got a progress bar. It's going to output at the end of each epoch. There
1023:25 - we go. Training loss. All right. Test accuracy, training accuracy. This is so exciting. I
1023:32 - love watching neural networks train. Okay, we're improving per epoch. That's a good sign.
1023:38 - But we've still got a fair way to go. Oh, okay. So what do we have here? Well, we didn't
1023:45 - beat our, hmm, it looks like we didn't beat our model zero results with the nonlinear
1023:51 - layers. And we only just slightly had a faster training time. Now, again, your numbers might
1023:58 - not be the exact same as what I've got here. Right? So that's a big thing about machine
1024:02 - learning is that it uses randomness. So your numbers might be slightly different. The direction
1024:08 - should be quite similar. And we may be using different GPUs. So just keep that in mind.
1024:13 - Right now I'm using a new video, SMI. I'm using a Tesla T4, which is at the time of
1024:18 - recording this video, Wednesday, April 20, 2022 is a relatively fast GPU for making
1024:25 - inference. So just keep that in mind. Your GPU in the future may be different. And your
1024:29 - CPU that you run may also have a different time here. So if these numbers are like 10
1024:35 - times higher, you might want to look into seeing if your code is there's some error.
1024:40 - If they're 10 times lower, well, hey, you're running it on some fast hardware. So it looks
1024:44 - like my code is running on CUDA slightly faster than the CPU, but not dramatically faster.
1024:52 - And that's probably akin to the fact that our data set isn't too complex and our model
1024:57 - isn't too large. What I mean by that is our model doesn't have like a vast amount of
1025:01 - layers. And our data set is only comprised of like, this is the layers our model has.
1025:07 - And our data set is only comprised of 60,000 images that are 28 by 28. So as you can imagine,
1025:13 - the more parameters in your model, the more features in your data, the higher this time
1025:18 - is going to be. And you might sometimes even find that your model is faster on CPU. So
1025:25 - this is the train time on CPU. You might sometimes find that your model's training
1025:32 - time on a CPU is in fact faster for the exact same code running on a GPU. Now, why might
1025:38 - that be? Well, let's write down this here. Let's go note. Sometimes, depending on your
1025:48 - data slash hardware, you might find that your model trains faster on CPU than GPU. Now,
1026:00 - why is this? So one of the number one reasons is that one, it could be that the overhead
1026:09 - for copying data slash model to and from the GPU outweighs the compute benefits offered
1026:22 - by the GPU. So that's probably one of the number one reasons is that you have to, for
1026:28 - data to be processed on a GPU, you have to copy it because it is by default on the CPU.
1026:35 - If you have to copy it to that GPU, you have some overhead time for doing that copy into
1026:40 - the GPU memory. And then although the GPU will probably compute faster on that data
1026:45 - once it's there, you still have that back and forth of going between the CPU and the
1026:50 - GPU. And the number two reason is that the hardware you're using has a better CPU in
1027:01 - terms of compute capability than the GPU. Now, this is quite a bit rarer. Usually if
1027:08 - you're using a GPU like a fairly modern GPU, it will be faster at computing, deep learning
1027:14 - or running deep learning algorithms than your general CPU. But sometimes these numbers
1027:21 - of compute time are really dependent on the hardware that you're running. So you'll get
1027:24 - the biggest benefits of speedups on the GPU when you're running larger models, larger
1027:29 - data sets, and more compute intensive layers in your neural networks. And so if you'd like
1027:34 - a great article on how to get the most out of your GPUs, it's a little bit technical,
1027:39 - but this is something to keep in mind as you progress as a machine learning engineer is
1027:43 - how to make your GPUs go burr. And I mean that burr from first principles. There we
1027:54 - go. Making deep learning go burr as in your GPU is going burr because it's running so
1028:01 - fast from first principles. So this is by Horace He who works on PyTorch. And it's
1028:08 - great. It talks about compute as a first principle. So here's what I mean by copying
1028:13 - memory and compute. There might be a fair few things you're not familiar with here,
1028:17 - but that's okay. But just be aware bandwidth. So bandwidth costs are essentially the cost
1028:21 - paid to move data from one place to another. That's what I was talking about copying stuff
1028:26 - from the CPU to the GPU. And then also there's one more, where is it overhead? Overhead is
1028:32 - basically everything else. I called it overhead. There are different terms for different things.
1028:37 - This article is excellent. So I'm going to just copy this in here. And you'll find this
1028:43 - in the resources, by the way. So for more on how to make your models compute faster,
1028:51 - see here. Lovely. So right now our baseline model is performing the best in terms of results.
1028:59 - And in terms of, or actually our model computing on the GPU is performing faster than our CPU.
1029:05 - Again yours might be slightly different. For my case, for my particular hardware, CUDA
1029:10 - is faster. Except model zero, our baseline is better than model one. So what's to do
1029:16 - next? Well, it's to keep experimenting, of course. I'll see you in the next video. Welcome
1029:24 - back. Now, before we move on to the next modeling experiment, let's get a results dictionary
1029:29 - for our model one, a model that we trained on. So just like we've got one for model zero,
1029:35 - let's create one of these for model one results. And we can create that without a vowel model
1029:39 - function. So we'll go right back down to where we were. I'll just get rid of this cell.
1029:45 - And let's type in here, get model one results dictionary. This is helpful. So later on,
1029:51 - we can compare all of our modeling results, because they'll all be in dictionary format.
1029:56 - So we're going to model one results equals a vowel model on a model equals model one.
1030:05 - And we can pass in a data loader, which is going to be our test data loader. Then we
1030:12 - can pass in a loss function, which is going to equal our loss function. And we can pass
1030:16 - in our accuracy function equals accuracy function. Wonderful. And then if we check out our model
1030:25 - one results, what do we get? Oh, no, we get an error. Do we get the code right? That looks
1030:34 - right to me. Oh, what does this say runtime error expected all tensors to be on the same
1030:41 - device, but found at least two devices, CUDA and CPU. Of course. So why did this happen?
1030:49 - Well, let's go back up to our of our model function, wherever we defined that. Here we
1030:54 - go. Ah, I see. So this is a little gotcha in pytorch or in deep learning in general. There's
1031:02 - a saying in the industry that deep learning models fail silently. And this is kind of
1031:05 - one of those ones. It's because our data and our model are on different devices. So remember
1031:13 - how I said the three big errors are shape mismatches with your data and your model device
1031:19 - mismatches, which is what we've got so far. And then data type mismatches, which is if
1031:24 - your data is in the wrong data type to be computed on. So what we're going to have to
1031:28 - do to fix this is let's bring down our vowel model function down to where we were. And
1031:35 - just like we've done in our test step and train step functions, where we've created
1031:42 - device agnostic data here, we've sent our data to the target device, we'll do that exact
1031:47 - same thing in our vowel model function. And this is just a note for going forward. It's
1031:52 - always handy to where you can create device agnostic code. So we've got our new of our
1031:58 - model function here for x, y in our data loader. Let's make our data device agnostic. So just
1032:07 - like our model is device agnostic, we've sent it to the target device, we will do the same
1032:12 - here, x dot two device, and then y dot two device. Let's see if that works. We will
1032:20 - just rerun this cell up here. I'll grab this, we're just going to write the exact same
1032:25 - code as what we did before. But now it should work because we've sent our, we could actually
1032:30 - also just pass in the target device here, device equals device. That way we can pass
1032:36 - in whatever device we want to run it on. And we're going to just add in device here,
1032:41 - device equals device. And let's see if this runs correctly. Beautiful. So if we compare
1032:50 - this to our model zero results, it looks like our baseline's still out in front. But that's
1032:57 - okay. We're going to in the next video, start to step things up a notch and move on to convolutional
1033:02 - neural networks. This is very exciting. And by the way, just remember, if your numbers
1033:07 - here aren't exactly the same as mine, don't worry too much. If they're out landishly different,
1033:12 - just go back through your code and see if it's maybe a cell hasn't been run correctly
1033:16 - or something like that. If there are a few decimal places off, that's okay. That's due
1033:20 - to the inherent randomness of machine learning and deep learning. But with that being said,
1033:26 - I'll see you in the next video. Let's get our hands on convolutional neural networks.
1033:33 - Welcome back. In the last video, we saw that our second modeling experiment, model one,
1033:38 - didn't quite beat our baseline. But now we're going to keep going with modeling experiments.
1033:42 - And we're going to move on to model two. And this is very exciting. We're going to build
1033:46 - a convolutional neural network, which are also known as CNN. CNNs are also known as
1033:55 - com net. And CNNs are known for their capabilities to find patterns in visual data. So what are
1034:10 - we going to do? Well, let's jump back into the keynote. We had a look at this slide before
1034:14 - where this is the typical architecture of a CNN. There's a fair bit going on here, but
1034:18 - we're going to step through it one by one. We have an input layer, just like any other
1034:23 - deep learning model. We have to input some kind of data. We have a bunch of hidden layers
1034:29 - in our case in a convolutional neural network, you have convolutional layers. You often have
1034:34 - hidden activations or nonlinear activation layers. You might have a pooling layer. You
1034:38 - generally always have an output layer of some sort, which is usually a linear layer. And
1034:44 - so the values for each of these different layers will depend on the problem you're working
1034:48 - on. So we're going to work towards building something like this. And you'll notice that
1034:53 - a lot of the code is quite similar to the code that we've been writing before for other
1034:57 - PyTorch models. The only difference is in here is that we're going to use different
1035:02 - layer types. And so if we want to visualize a CNN in a colored block edition, we're going
1035:09 - to code this out in a minute. So don't worry too much. We have a simple CNN. You might
1035:13 - have an input, which could be this image of my dad eating some pizza with two thumbs
1035:18 - up. We're going to preprocess that input. We're going to, in other words, turn it into
1035:22 - a tensor in red, green and blue for an image. And then we're going to pass it through a
1035:29 - combination of convolutional layers, relu layers and pooling layers. Now again, this
1035:36 - is a thing to note about deep learning models. I don't want you to get too bogged down in
1035:40 - the order of how these layers go, because they can be combined in many different ways.
1035:45 - In fact, research is coming out almost every day, every week about how to best construct
1035:50 - these layers. The overall principle is what's more important is how do you get your inputs
1035:56 - into an idolized output? That's the fun part. And then of course, we have the linear output
1036:01 - layer, which is going to output however many classes or value for however many classes
1036:06 - that we have in the case of classification. And then if you want to make your CNN deeper,
1036:13 - this is where the deep comes from deep learning, you can add more layers. So the theory behind
1036:19 - this, or the practice behind this, is that the more layers you add to your deep learning
1036:24 - model, the more chances it has to find patterns in the data. Now, how does it find these patterns?
1036:30 - Well, each one of these layers here is going to perform, just like what we've seen before,
1036:35 - a different combination of mathematical operations on whatever data we feed it. And each subsequent
1036:41 - layer receives its input from the previous layer. In this case, there are some advanced
1036:48 - networks that you'll probably come across later in your research and machine learning
1036:52 - career that use inputs from layers that are kind of over here or the way down here or
1036:57 - something like that. They're known as residual connections. But that's beyond the scope of
1037:02 - what we're covering for now. We just want to build our first convolutional neural network.
1037:06 - And so let's go back to Google Chrome. I'm going to show you my favorite website to learn
1037:11 - about convolutional neural networks. It is the CNN explainer website. And this is going
1037:17 - to be part of your extra curriculum for this video is to spend 20 minutes clicking and
1037:22 - going through this entire website. We're not going to do that together because I would
1037:26 - like you to explore it yourself. That is the best way to learn. So what you'll notice up
1037:30 - here is we have some images of some different sort. And this is going to be our input. So
1037:36 - let's start with pizza. And then we have a convolutional layer, a relu layer, a conv
1037:41 - layer, a relu layer, max pool layer, com to relu to com to relu to max pool to this
1037:47 - architecture is a convolutional neural network. And it's running live in the browser. And
1037:51 - so we pass this image, you'll notice that it breaks down into red, green and blue. And
1037:57 - then it goes through each of these layers and something happens. And then finally, we
1038:01 - have an output. And you notice that the output has 10 different classes here, because we
1038:07 - have one, two, three, four, five, six, seven, eight, nine, 10, different classes of image
1038:14 - in this demo here. And of course, we could change this if we had 100 classes, we might
1038:19 - change this to 100. But the pieces of the puzzle here would still stay quite the same.
1038:25 - And you'll notice that the class pizza has the highest output value here, because our
1038:30 - images of pizza, if we change to what is this one, espresso, it's got the highest
1038:35 - value there. So this is a pretty well performing convolutional neural network. Then we have
1038:40 - a sport car. Now, if we clicked on each one of these, something is going to happen. Let's
1038:45 - find out. We have a convolutional layer. So we have an input of an image here that 64
1038:52 - 64 by three. This is color channels last format. So we have a kernel. And this kernel, this
1038:58 - is what happens inside a convolutional layer. And you might be going, well, there's a lot
1039:02 - going on here. And yes, of course, there is if this is the first time you ever seen this.
1039:06 - But essentially, what's happening is a kernel, which is also known as a filter, is going
1039:11 - over our image pixel values, because of course, they will be in the format of a tensor. And
1039:17 - trying to find small little intricate patterns in that data. So if we have a look here, and
1039:22 - this is why it's so valuable to go through this and just play around with it, we start
1039:26 - in a top left corner, and then slowly move along, you'll see on the output on the right
1039:29 - hand side, we have another little square. And do you notice in the middle all of those
1039:33 - numbers changing? Well, that is the mathematical operation that's happening as a convolutional
1039:38 - layer convolves over our input image. How cool is that? And you might be able to see on the
1039:44 - output there that there's some slight values for like, look around the headlight here. Do
1039:49 - you notice on the right how there's some activation? There's some red tiles there? Well, that
1039:57 - just means that potentially this layer or this hidden unit, and I want to zoom out for
1040:02 - a second, is we have 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 hidden units. Each one of these is
1040:10 - going to learn a different feature about the data. And now the beauty of deep learning,
1040:15 - but also one of the curses of deep learning is that we don't actually control what each
1040:20 - one of these learns. The magic of deep learning is that it figures it out itself what is
1040:26 - best to learn. We go into here, notice that each one we click on has a different representation
1040:32 - on the right hand side. And so this is what's going to happen layer by layer as it goes
1040:37 - through the convolutional neural network. And so if you want to read about what is a convolutional
1040:42 - neural network, you can go through here. But we're going to replicate this exact neural
1040:46 - network here with PyTorch code. That's how I'd prefer to learn it. But if you want the
1040:51 - intuition behind it, the math behind it, you can check out all of these resources here.
1040:55 - That is your extra curriculum for this video. So we have an input layer, we have a convolutional
1041:01 - layer, you can see how the input gets modified by some sort of mathematical operation, which
1041:06 - is of course, the convolutional operation. And we have there all different numbers finding
1041:12 - different patterns and data. This is a really good example here. You notice that the outputs
1041:17 - eyes slightly changes, that'll be a trend throughout each layer. And then we can understand
1041:21 - the different hyper parameters, but I'm going to leave this for you to explore on your own.
1041:25 - In the next video, we're going to start to write PyTorch code to replicate everything
1041:30 - that's going on here. So I'm going to link this in here to find out what's happening
1041:40 - inside CNN. See this website here. So join me in the next video. This is super exciting.
1041:50 - We're going to build our first convolutional neural network for computer vision. I'll see
1041:55 - you there. Welcome back. In the last video, we went briefly through the CNN explainer
1042:02 - website, which is my favorite resource for learning about convolutional neural networks.
1042:07 - And of course, we could spend 20 minutes clicking through everything here to find out what's
1042:11 - going on with a convolutional neural network, or we could start to code one up. So how about
1042:17 - we do that? Hey, if and down, code it out. So we're going to create a convolutional neural
1042:25 - network. And what I'm going to do is I'm going to build this, or we're going to build this
1042:30 - model together in this video. And then because it's going to use layers or PyTorch layers
1042:35 - that we haven't looked at before, we're going to spend the next couple of videos stepping
1042:40 - through those layers. So just bear with me, as we code this entire model together, we'll
1042:45 - go break it down in subsequent videos. So let's build our first convolutional neural
1042:50 - network. That's a mouthful, by the way, I'm just going to probably stick to saying CNN.
1042:55 - Fashion MNIST, we're up to model V2. We're going to subclass nn.module, as we always do
1043:02 - when we're building a PyTorch model. And in here, we're going to say model architecture
1043:10 - that replicates the tiny VGG. And you might be thinking, where did you get that from, Daniel?
1043:17 - Model from CNN explainer website. And so oftentimes, when convolutional neural networks or new
1043:27 - types of architecture come out, the authors of the research paper that present the model
1043:31 - get to name the model. And so that way, in the future, you can refer to different types of
1043:36 - model architectures with just a simple name, like tiny VGG. And people kind of know what's going on.
1043:42 - So I believe somewhere on here, it's called tiny VGG, tiny VGG. We have nothing. Yeah,
1043:50 - there we go. In tiny VGG. And do we have more than one tiny, tiny, yeah, tiny VGG. And if we
1043:59 - look up VGG, conv net, VGG 16 was one of the original ones, VGG, very deep convolutional neural
1044:08 - networks of VGG net. There's also ResNet, which is another convolutional neural network.
1044:16 - You can also, I don't want to give you my location, Google, you can go popular CNN
1044:21 - architectures. And this will give you a fair few options. Lynette is one of the first AlexNet,
1044:28 - ZF net, whole bunch of different resources. And also, how could you find out more about a
1044:33 - convolutional neural network? What is a convolutional neural network? You can go through that. But
1044:38 - let's stop that for a moment. Let's code this one up together. So we're going to initialize our
1044:44 - class here, def init. We're going to pass it in an input shape, just like we often do.
1044:50 - We're going to put in a number of hidden units, which is an int. And we're going to put in an
1044:57 - output shape, which is an int. Wonderful. So nothing to outlandish that we haven't seen before there.
1045:04 - And we're going to go super dot init to initialize our initializer for lack of a better way of
1045:13 - putting it. Now, we're going to create our neural network in a couple of blocks this time. And
1045:18 - you might often hear in when you learn more about convolutional neural networks, or I'll just tell
1045:24 - you that things are referred to are often referred to as convolutional blocks. So if we go back to
1045:29 - our keynote, this here, this combination of layers might be referred to as a convolutional block.
1045:36 - And a convolutional block, a deeper CNN, might be comprised of multiple convolutional blocks.
1045:42 - So to add to the confusion, a block is comprised of multiple layers. And then an overall architecture
1045:50 - is comprised of multiple blocks. And so the deeper and deeper your models get, the more blocks
1045:56 - it might be comprised of, and the more layers those blocks may be comprised of within them.
1046:02 - So it's kind of like Lego, which is very fun. So let's put together an an ensequential.
1046:09 - Now, the first few layers here that we're going to create in conv block one, uh,
1046:14 - nn.com 2d. Oh, look at that. Us writing us our first CNN layer. And we have to define something
1046:21 - here, which is in channels. So this channels refers to the number of channels in your visual data.
1046:29 - And we're going to put in input shape. So we're defining the input shape. This is going to be
1046:33 - the first layer in our model. The input shape is going to be what we define when we instantiate
1046:39 - this class. And then the out channels. Oh, what's the out channels going to be? Well, it's going
1046:44 - to be hidden units, just like we've done with our previous models. Now the difference here
1046:49 - is that in nn.com 2d, we have a number of different hyper parameters that we can set.
1046:55 - I'm going to set some pretty quickly here, but then we're going to step back through them,
1046:59 - not only in this video, but in subsequent videos. We've got a fair bit going on here.
1047:04 - We've got in channels, which is our input shape. We've got out channels, which are our hidden units.
1047:08 - We've got a kernel size, which equals three. Or this could be a tuple as well, three by three.
1047:14 - But I just like to keep it as three. We've got a stride and we've got padding. Now,
1047:21 - because these are values, we can set ourselves. What are they referred to as?
1047:26 - Let's write this down. Values, we can set ourselves in our neural networks.
1047:32 - In our nn's neural networks are called hyper parameters. So these are the hyper parameters
1047:40 - of nn.com 2d. And you might be thinking, what is 2d for? Well, because we're working with
1047:46 - two-dimensional data, our images have height and width. There's also com 1d for one-dimensional data,
1047:51 - 3d for three-dimensional data. We're going to stick with 2d for now.
1047:56 - And so what do each of these hyper parameters do? Well, before we go through what each one of them
1048:02 - do, we're going to do that when we step by step through this particular layer. What we've just done
1048:07 - is we've replicated this particular layer of the CNN explainer website. We've still got the
1048:14 - relu. We've still got another conv and a relu and a max pool and a conv and a relu and a
1048:18 - conv and a relu and a max pool. But this is the block I was talking about. This is one block here
1048:25 - of this neural network, or at least that's how I've broken it down. And this is another block.
1048:30 - You might notice that they're comprised of the same layers just stacked on top of each other.
1048:34 - And then we're going to have an output layer. And if you want to learn about where the hyper
1048:39 - parameters came from, what we just coded, where could you learn about those? Well, one, you could
1048:45 - go, of course, to the PyTorch documentation, PyTorch, and then com 2d. You can read about it there.
1048:53 - There's the mathematical operation that we talked about or briefly stepped on before,
1048:58 - or touched on, stepped on. Is that the right word? So create a conv layer. It's there.
1049:06 - But also this is why I showed you this beautiful website so that you can read about these
1049:10 - hyper parameters down here. Understanding hyper parameters. So your extra curriculum for this
1049:15 - video is to go through this little graphic here and see if you can find out what padding means,
1049:21 - what the kernel size means, and what the stride means. I'm not going to read through this for you.
1049:25 - You can have a look at this interactive plot. We're going to keep coding because that's what
1049:31 - we're all about here. If and out, code it out. So we're going to now add a relu layer.
1049:37 - And then after that, we're going to add another conv 2d layer. And the in channels here is going
1049:43 - to be the hidden units, because we're going to take the output size of this layer and use it as
1049:50 - the input size to this layer. We're going to keep going here. Out channels equals hidden units again
1049:56 - in this case. And then the kernel size is going to be three as well. Stride will be one. Padding
1050:03 - will be one. Now, of course, we can change all of these values later on, but just bear with me
1050:08 - while we set them how they are. We'll have another relu layer. And then we're going to finish off
1050:14 - with a nn max pool 2d layer. Again, the 2d comes from the same reason we use comf2d. We're working
1050:23 - with 2d data here. And we're going to set the kernel size here to be equal to two. And of course,
1050:29 - this can be a tuple as well. So it can be two two. Now, where could you find out about nn max
1050:33 - pool 2d? Well, we go nn max pool 2d. What does this do? applies a 2d max pooling over an input
1050:42 - signal composed of several input planes. So it's taking the max of an input. And we've got some
1050:50 - parameters here, kernel size, the size of the window to take the max over. Now, where have we
1050:55 - seen a window before? I'm just going to close these. We come back up. Where did we see a window?
1051:01 - Let's dive into the max pool layer. See where my mouse is? Do you see that two by two? Well,
1051:08 - that's a window. Now, look at the difference between the input and the output. What's happening?
1051:13 - Well, we have a tile that's two by two, a window of four. And the max, we're taking the max of that
1051:19 - tile. In this case, it's zero. Let's find the actual value. There we go. So if you look at those
1051:23 - four numbers in the middle inside the max brackets, we have 0.07, 0.09, 0.06, 0.05. And the max of
1051:33 - all those is 0.09. And you'll notice that the input and the output shapes are different. The
1051:39 - output is half the size of the input. So that's what max pooling does, is it tries to take the max
1051:46 - value of whatever its input is, and then outputs it on the right here. And so as our data,
1051:54 - this is a trend in all of deep learning, actually. As our image moves through, this is what you'll
1051:59 - notice. Notice all the different shapes here. Even if you don't completely understand what's going
1052:04 - on here, you'll notice that the two values here on the left start to get smaller and smaller as
1052:09 - they go through the model. And what our model is trying to do here is take the input and learn a
1052:14 - compressed representation through each of these layers. So it's going to smoosh and smoosh and
1052:20 - smoosh trying to find the most generalizable patterns to get to the ideal output. And that
1052:27 - input is eventually going to be a feature vector to our final layer. So a lot going on there,
1052:33 - but let's keep coding. What we've just completed is this first block. We've got a cons layer,
1052:39 - a relu layer, a cons layer, a relu layer, and a max pool layer. Look at that, cons layer,
1052:44 - relu layer, cons layer, relu layer, max pool. Should we move on to the next block? We can do this
1052:49 - one a bit faster now because we've already coded the first one. So I'm going to do nn.sequential as
1052:55 - well. And then we're going to go nn.com2d. We're going to set the in channels. What should the
1053:02 - in channels be here? Well, we're going to set it to hidden units as well because our network is
1053:08 - going to flow just straight through all of these layers. And the output size of this is going to
1053:13 - be hidden units. And so we want the in channels to match up with the previous layers out channels.
1053:19 - So then we're going to go out channels equals hidden units as well. We're going to set the
1053:28 - kernel size, kernel size equals three, stride equals one, padding equals one, then what comes
1053:36 - next? Well, because the two blocks are identical, the con block one and com two, we can just go
1053:43 - the exact same combination of layers. And then relu and n.com2d in channels equals hidden units.
1053:53 - Out channels equals, you might already know this, hidden units. Then we have kernel size
1053:59 - equals three, oh, 32, don't want it that big, stride equals one, padding equals one,
1054:06 - and what comes next? Well, we have another relu layer, relu, and then what comes after that?
1054:13 - We have another max pool. And then max pool 2d, kernel size equals two, beautiful. Now,
1054:22 - what have we coded up so far? We've got this block, number one, that's what this one on the inside
1054:27 - here. And then we have com two, relu two, com two, relu two, max pool two. So we've built these
1054:33 - two blocks. Now, what do we need to do? Well, we need an output layer. And so what did we do before
1054:41 - when we made model one? We flattened the inputs of the final layer before we put them to the last
1054:49 - linear layer. So flatten. So this is going to be the same kind of setup as our classifier layer.
1054:57 - Now, I say that on purpose, because that's what you'll generally hear the last output layer
1055:02 - in a classification model called is a classifier layer. So we're going to have these two layers
1055:07 - are going to be feature extractors. In other words, they're trying to learn the patterns that
1055:12 - best represent our data. And this final layer is going to take those features and classify them
1055:18 - into our target classes. Whatever our model thinks best suits those features, or whatever our model
1055:24 - thinks those features that it learned represents in terms of our classes. So let's code it out.
1055:29 - We'll go down here. Let's build our classifier layer. This is our biggest neural network yet.
1055:37 - You should be very proud. We have an end of sequential again. And we're going to pass in
1055:44 - an end of flatten, because the output of these two blocks is going to be a multi-dimensional tensor,
1055:53 - something similar to this size 131310. So we want to flatten the outputs into a single feature
1056:00 - vector. And then we want to pass that feature vector to an nn.linear layer. And we're going to
1056:05 - go in features equals hidden units times something times something. Now, the reason I do this is
1056:13 - because we're going to find something out later on, or time zero, just so it doesn't error. But
1056:20 - sometimes calculating what you're in features needs to be is quite tricky. And I'm going to
1056:25 - show you a trick that I use later on to figure it out. And then we have out features relates
1056:30 - to our output shape, which will be the length of how many classes we have, right? One value for
1056:35 - each class that we have. And so with that being said, let's now that we've defined all of the
1056:42 - components of our tiny VGG architecture. There is a lot going on, but this is the same methodology
1056:49 - we've been using the whole time, defining some components, and then putting them together to
1056:55 - compute in some way in a forward method. So forward self X. How are we going to do this?
1057:03 - Are we going to set X is equal to self, comp block one X. So X is going to go through comp block one,
1057:11 - it's going to go through the comp 2D layer, relu layer, comp 2D layer, relu layer, max pool layer,
1057:18 - which will be the equivalent of an image going through this layer, this layer, this layer,
1057:22 - this layer, this layer, and then ending up here. So we'll set it to that. And then we can print out
1057:29 - X dot shape to get its shape. We'll check this later on. Then we pass X through comp block two,
1057:38 - which is just going to go through all of the layers in this block, which is equivalent to
1057:42 - the output of this layer going through all of these layers. And then because we've constructed a
1057:48 - classifier layer, we're going to take the output of this block, which is going to be here, and we're
1057:54 - going to pass it through our output layer, or what we've termed it, our classifier layer. I'll just
1057:59 - print out X dot shape here, so we can track the shape as our model moves through the architecture.
1058:04 - X equals self dot classifier X. And then we're going to return X. Look at us go. We just built
1058:15 - our first convolutional neural network by replicating what's on a CNN explainer website.
1058:22 - Now, that is actually very common practice in machine learning is to find some sort of architecture
1058:28 - that someone has found to work on some sort of problem and replicate it with code and see if it
1058:35 - works on your own problem. You'll see this quite often. And so now let's instantiate a model.
1058:42 - Go torch dot manual C. We're going to instantiate our first convolutional neural network.
1058:48 - Model two equals fashion amnest. We will go model V two. And we are going to set the input shape.
1058:57 - Now, what will the input shape be? Well, I'll come to the layer up here. The input shape
1059:04 - is the number of channels in our images. So do we have an image ready to go image shape?
1059:12 - This is the number of color channels in our image. We have one. If we had color images,
1059:18 - we would set the input shape to three. So the difference between our convolutional neural network,
1059:23 - our CNN, tiny VGG, and the CNN explainer tiny VGG is that they are using color images. So
1059:30 - their input is three here. So one for each color channel, red, green and blue. Whereas we have
1059:37 - black and white images. So we have only one color channel. So we set the input shape to one.
1059:42 - And then we're going to go hidden units equals 10, which is exactly the same as what tiny VGG
1059:48 - has used. 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. So that sets the hidden units value of each of our
1059:57 - layers. That's the power of creating an initializer with hidden units. And then finally, our output
1060:04 - shape is going to be what we've seen this before. This is going to be the length of our class names,
1060:09 - one value for each class in our data set. And of course, we're going to send this model to the
1060:14 - device. We're going to hit shift and enter. Oh, no, what did we get wrong? Out channels,
1060:21 - output shape. Where did I spell wrong? Out channels, out channels, out channels. I forgot an L.
1060:28 - Of course, typo. Oh, kernel size and other typo. Did you notice that?
1060:34 - Kernel size, kernel size, kernel size, kernel size. Where did we spell this wrong? Oh, here.
1060:44 - Kernel size. Are there any other typos? Probably.
1060:50 - A beautiful. There we go. Okay, what have we got? Initializing zero, obtenses and non-op.
1060:55 - Oh, so we've got an issue here and error here because I've got this. But this is just to,
1061:00 - there's a trick to calculating this. We're going to cover this in another video. But
1061:07 - pay yourself on the back. We've written a fair bit of code here. This is a convolutional neural
1061:13 - network that replicates the tiny VGG architecture on the CNN explainer website. Now, don't forget,
1061:19 - your extra curriculum is to go through this website for at least 20 minutes and read about
1061:24 - what's happening in our models. We're focused on code here. But this is particularly where you
1061:29 - want to pay attention to. If you read through this understanding hyper parameters and play around
1061:33 - with this, the next couple of videos will make a lot more sense. So read about padding,
1061:37 - read about kernel size and read about stride. I'll see you in the next video. We're going to go
1061:43 - through our network step by step. Welcome back. Now, I'm super stoked because in the last video,
1061:51 - we coded together our first ever convolutional neural network in PyTorch. So well done. We
1061:58 - replicated the tiny VGG architecture from the CNN explainer website, my favorite place for learning
1062:03 - about CNNs in the browser. So now we introduced two new layers that we haven't seen before,
1062:10 - conv2d and maxpool2d. But they all have the same sort of premise of what we've been doing so far
1062:17 - is that they're trying to learn the best features to represent our data in some way, shape or form.
1062:23 - Now, in the case of maxpool2d, it doesn't actually have any learnable parameters. It just takes
1062:29 - the max, but we're going to step through that later on. Let's use this video to step through
1062:34 - and then conv2d. We're going to do that with code. So I'll make a new heading here. 7.1
1062:43 - stepping through and then conv2d. Beautiful. Now, where could we find out what's going on
1062:52 - in an end comp2d? Well, of course, we have the documentation and then comp2d. We've got PyTorch.
1063:00 - So if you want to learn the mathematical operation that's happening, we have this value here, this
1063:06 - operation here. Essentially, it's saying the output is equal to the bias term times something,
1063:11 - plus the sum of the weight times something times the input. So do you see how just the weight
1063:18 - matrix, the weight tensor and the bias value, manipulating our input in some way equals the output?
1063:24 - Now, if we map this, we've got batch size, channels in, height, width, channels out, out, out,
1063:34 - et cetera, et cetera. But we're not going to focus too much on this. If you'd like to
1063:37 - read more into that, you can. Let's try it with code. And we're going to reproduce this particular
1063:44 - layer here, the first layer of the CNN explainer website. And we're going to do it with a dummy input.
1063:50 - In fact, that's one of my favorite ways to test things. So I'm just going to link here the documentation.
1063:58 - See the documentation for an end comp2d here. And if you'd like to read through more of this,
1064:09 - of course, this is a beautiful place to learn about what's going on.
1064:12 - There's the shape how to calculate the shape, height out, width out, et cetera. That's very
1064:18 - helpful if you need to calculate input and output shapes. But I'll show you my trick for doing so
1064:22 - later on. We have here, let's create some dummy data. So I'm going to set torch manual seed. We
1064:30 - need it to be the same size as our CNN explainer data. So 64, 64, 3. But we're going to do it
1064:38 - pie torch style. This is color channels last. We're going to do color channels first. So how
1064:44 - about we create a batch of images, we're going to be writing torch dot rand n. And we're going to
1064:52 - pass in size equals 32, three, 64, 64. And then we're going to create a singular image by taking
1065:01 - the first of that. So image is zero. Now, let's get the image batch shape. Because a lot of
1065:09 - machine learning, as I've said before, and deep learning is making sure your data has the right
1065:15 - shape. So let's check images dot shape. And let's check single image shape. We're going to go test
1065:25 - image dot shape. And finally, we're going to print, what does the test image look like?
1065:34 - We'll get this on a new line, hey, new line test image, this is of course not going to be an
1065:39 - actual image is just going to be a collection of random numbers. And of course, that is what
1065:44 - our model is currently comprised of model two, if we have a look at what's on the insides,
1065:49 - we are going to see a whole bunch of random numbers. Look at all this. What do we have?
1065:54 - We scroll up is going to give us a name for something. We have comp block two, two, we have a weight,
1066:02 - we have a bias, keep going up, we go right to the top, we have another weight, keep going down,
1066:08 - we have a bias, a weight, et cetera, et cetera. Now, our model is comprised of random numbers,
1066:13 - and what we are trying to do is just like all of our other models is pass data in and adjust the
1066:19 - random numbers within these layers to best represent our data. So let's see what happens
1066:25 - if we pass some random data through one of our comp2d layers. So let's go here, we're going to
1066:33 - create a single comp2d layer. So comp layer equals, what is it equal? And then comp2d,
1066:46 - and we're going to set the in channels is equal to what? Oh, revealed the answer too quickly.
1066:52 - Three. Why is it three? Well, it's because the in channels is the same number of color channels
1066:59 - as our images. So if we have a look at our test image shape, what do we have? Three, it has three
1067:09 - color channels. That is the same as the value here, except the order is reversed. This is color
1067:14 - channels last, pytorch defaults to color channels first. So, or for now it does, in the future this
1067:20 - may change. So just keep that in mind. So out channels equals 10. This is equivalent to the
1067:25 - number of hidden units we have. One. Oh, I don't want that one just yet. One, two, three, four,
1067:32 - five, six, seven, eight, nine, 10. So we have that 10 there. So we have 10 there. And then we have
1067:39 - kernel size. Oh, what is the kernel? Well, it's not KFC. I can tell you that. And then we have
1067:44 - stride. And then we have padding. We're going to step through these in a second. But let's check
1067:48 - out the kernel. And this kernel can also be three by three. But it's a shortcut to just type in three.
1067:55 - So that's what it actually means. If you just type in a single number, it's equivalent to typing in
1067:59 - a tuple. Now, of course, you could find that out by reading through the documentation here.
1068:04 - But where did I get that value? Well, let's dive into this beautiful website. And let's see what
1068:09 - happening. So we have a kernel here, which is also called a filter. So the thing I'm talking about
1068:15 - is this little square here, this kernel. Oh, we can see the weights there at the top. This is how
1068:21 - beautiful this website is. So if we go over there, this is what's going to happen. This is a convolution.
1068:28 - It starts with this little square, and it moves pixel by pixel across our image. And you'll notice
1068:36 - that the output is creating some sort of number there. And you'll notice in the middle, we have a
1068:41 - mathematical operation. This operation here is what's happening here. I wait times the input.
1068:50 - That's what we've got there. Now, the beauty of PyTorch is it does all of this behind the
1068:54 - scenes for us. So again, if you'd like to dig more into the mathematical operation behind the
1068:59 - scenes, you've got the resource here. And you've also got plenty of other resources online. We're
1069:03 - going to focus on code for now. So if we keep doing this across our entire image, we get this
1069:09 - output over here. So that's the kernel. And now where did I get three by three from? Well, look at
1069:14 - this. One, two, three, one, two, three, one, two, three, three by three, we have nine squares. Now,
1069:23 - if we scroll down, this was your extracurricular for the last video, understanding hyperparameters.
1069:28 - What happens if we change the kernel size to three by three? Have a look at the red square on the
1069:33 - left. Now, if we change it to two by two, it changed again. Three by three. This is our kernel,
1069:38 - or also known as a filter, passing across our image, performing some sort of mathematical
1069:43 - operation. And now the whole idea of a convolutional layer is to try and make sure that this kernel
1069:50 - performs the right operation to get the right output over here. Now, what do these kernels learn?
1069:55 - Well, that is entirely up to the model. That's the beauty of deep learning is that it
1070:00 - learns how to best represent our data, hopefully, on its own by looking at more data. And then so
1070:08 - if we jump back in here, so that's the equivalent of setting kernel size three by three. What if
1070:13 - we set the stride equal to one? Have we got this in the right order? It doesn't really matter.
1070:17 - Let's go through stride next. If we go to here, what does stride say? Stride of the convolution
1070:26 - of the convolving kernel. The default is one. Wonderful. Now, if we set the stride,
1070:32 - or if we keep it at one, it's a default one, it's going to hop over, watch the red square on the
1070:36 - left. It's going to hop over one pixel at a time. So the convolution, the convolving, happens one
1070:43 - pixel at a time. That's what the stride sets. Now, watch what happens when I change the stride
1070:48 - value to the output shape. Wow. Do you notice that it went down? So we have here, the kernel size
1070:58 - is still the same. But now we're jumping over two pixels at a time. Notice how on the left,
1071:04 - two pixels become available. And then if I jump over again, two pixels. So the reason why the
1071:09 - output compresses is because we're skipping some pixels as we go across the image. And now this
1071:14 - pattern happens throughout the entire network. That's one of the reasons why you see the size
1071:23 - of our input or the size of each layer go down over time. What our convolutional layer is doing,
1071:31 - and in fact, a lot of deep learning neural networks do, is they try to compress the input
1071:36 - into some representation that best suits the data. Because it would be no point of just memorizing
1071:43 - the exact patterns, you want to compress it in some way. Otherwise, you just might as well move
1071:47 - your input data around. You want to learn generalizable patterns that you can move around. And so we
1071:53 - keep going. We've got padding equals zero. Let's see what happens here. If we change the padding
1071:58 - value, what happens? Up, down. Notice the size here. Oh, we've added two extra pixels around the
1072:06 - edge. Now if we go down, one extra pixel. Now if we go zero, now why might we do that?
1072:13 - If we add some padding on the end, well, that's so that our kernel can operate on what's going on
1072:18 - here in the corner. In case there's some information on the edges of our image. Then you might be
1072:23 - thinking, Daniel, there's a whole bunch of values here. How do we know what to set them?
1072:28 - Well, you notice that I've just copied exactly what is going on here.
1072:33 - There's a three by three kernel. There's no padding on the image. And the stride is just going
1072:39 - one by one. And so that's often very common in machine learning, is that when you're just getting
1072:44 - started and you're not sure what values to set these values to, you just copy some existing
1072:49 - values from somewhere and see if it works on your own problem. And then if it doesn't, well,
1072:54 - you can adjust them. So let's see what happens when we do that. So pass the data through
1073:02 - the convolutional layer. So let's see what happens. Conv output equals conv layer.
1073:09 - Let's pass it our test image. And we'll check the conv output. What happens?
1073:17 - Oh no, we get an error. Of course we get a shape error. One of the most common issues of machine
1073:22 - learning and deep learning. So this is saying that our input for the conv layer expects a four
1073:28 - dimensional tensor, except it got a three dimensional input size of 364 64. Now, how do we add an
1073:35 - extra dimension to our test image? Let's have a look. How would we add a batch dimension over on
1073:44 - the left here? We can go unsqueeze zero. So now we have a four dimensional tensor. Now, just keep
1073:53 - in mind that if you're running this layer and then com2d on a pytorch version, that is, I believe
1073:59 - they fixed this or they changed it in pytorch. What am I on? I think this Google collab instance is
1074:08 - on 1.10. I think you might not get this error if you're running 1.11. So just keep that in mind.
1074:14 - Like this should work if you're running 1.11. But if it doesn't, you can always unsqueeze here.
1074:22 - And let's see what happens. Look at that. We get another tensor output. Again,
1074:28 - this is just all random numbers though, because our test image is just random numbers. And our
1074:32 - conv layer is instantiated with random numbers. But we'll set the manual seed here. Now, if our
1074:38 - numbers are different to what's, if your numbers are different to what's on my screen, don't worry
1074:41 - too much. Why is that? Because our conv layer is instantiated with random numbers. And our test
1074:48 - image is just random numbers as well. What we're paying attention to is the input and output shapes.
1074:55 - Do you see what just happened? We put our input image in there with three channels.
1074:59 - And now because we've set out channels to be 10, we've got 10. And we've got 62, 62. And this is
1075:05 - just the batch size. It just means one image. So essentially our random numbers, our test image,
1075:10 - have gone through the convolutional layer that we created, have gone through this mathematical
1075:15 - operation with regards to all the values that we've set, we've put the weight tensor, well,
1075:19 - actually PyTorch created that for us. PyTorch has done this whole operation for us. Thank you,
1075:24 - PyTorch. It's gone through all of these steps across. You could code this all by hand if you want,
1075:29 - but it's a lot easier and simpler to use a PyTorch layer. And it's done this. And now it's
1075:34 - created this output. Now, whatever this output is, I don't know, it is random numbers, but this
1075:41 - same process will happen if we use actual data as well. So let's see what happens if we change
1075:47 - the values kernel size we increase. Notice how our output has gotten smaller because we're using
1075:54 - a bigger kernel to convolve across the image. What if we put this to three, three back to what it
1075:59 - was and stride of two? What do you think will happen? Well, our output size basically halves
1076:04 - because we're skipping two pixels at a time. We'll put that back to one. What do you think will
1076:08 - happen if we set padding to one? 64, 64. We get basically the same size because we've added an
1076:16 - extra pixel around the edges. So you can play around with this. And in fact, I encourage you to
1076:21 - do this is what we just did. Padding one, we just added an extra dummy zero pixel around the edges.
1076:27 - So practice with this, see what happens as you pass our test image, random numbers,
1076:34 - through a conv 2d layer with different values here. What do you think will happen if you change
1076:40 - this to 64? Give that a shot and I'll see you in the next video. Who's ready to step through
1076:48 - the nn max pool 2d layer? Put your hand up. I've got my hand up. So let's do it together, hey,
1076:55 - we've got 7.2. Now you might have already given this a shot yourself. Stepping through
1077:03 - nn max pool 2d. And this is this is what I do for a lot of different concepts that I haven't
1077:12 - gone through before is I just write some test code and see what the inputs and outputs are.
1077:18 - And so where could we find out about max pool 2d? Well, of course, we've got the documentation.
1077:23 - I'm just going to link this in here. Max pool 2d. In the simplest case, the output value of
1077:30 - layer with input size nchw output nch out w out. By the way, this is number of batches,
1077:38 - color channels, height, width. And this is the output of that layer. And kernel size, which is
1077:44 - a parameter up here, k h k w can be precisely described as out is going to be the max of some
1077:52 - value, depending on the kernel size and the stride. So let's have a look at that in practice.
1077:59 - And of course, you can read further through the documentation here. I'll just grab the link for
1078:03 - this actually. So it's here. Wonderful. And let's now first try it with our test image that we
1078:13 - created above. So just highlight what the test image is. A bunch of random numbers in the same
1078:20 - shape as what a single image would be if we were to replicate the image size of the CNN explainer.
1078:28 - By the way, we'll have a look at a visual in a second of max pool here. But you can go through
1078:33 - that on your own time. Let's if in doubt, code it out. So we're going to print out the original
1078:39 - image shape without unsqueezed dimension. Because recall that we had to add an extra dimension to
1078:48 - pass it through our com2d layer. Now, if you're using a later version of PyTorch, you might not
1078:53 - get an error if you only use a three dimensional image tensor and pass it through a comp layer.
1078:59 - So we're going to pass it in test image, original shape, test image dot shape. So this is just going
1079:08 - to tell us what the line of code in the cell above tells us. But that's fine. I like to make
1079:13 - pretty printouts, you know, test image with unsqueezed dimension. So this is just going to be our test
1079:21 - image. And we're going to see what happens when we unsqueeze a dimension, unsqueeze on zero
1079:28 - for dimension. That is about to say first, but it's the zero. Now we're going to create a sample
1079:34 - nn max pool 2d layer. Because remember, even layers themselves in torch dot nn are models
1079:45 - of their own accord. So we can just create a single, this is like creating a single layer model here.
1079:50 - We'll set the kernel size equal to two. And recall, if we go back to CNN explainer,
1079:55 - kernel size equal to two results in a two by two square, a two by two kernel that's going to
1080:01 - convolve over our image, like so. And this is an example input, an example output. And you can see
1080:09 - the operation that max pooling does here. So just keep that in mind as we pass some sample data
1080:15 - through our max pool layer. And now let's pass data through it. I actually will pass it through
1080:21 - just the conv layer first, through just the conv layer. Because that's sort of how you might stack
1080:28 - things, you might put a convolutional layer and then a max pool layer on top of that convolutional
1080:32 - layer. So test image through conv. We'll create a variable here, equals our conv layer.
1080:41 - Is going to take as an input, our test image dot unsqueeze on the zero dimension again.
1080:50 - Beautiful. Now we're going to print out the shape here. This is just highlighting how I
1080:55 - like to troubleshoot things is I do one step, print the shape, one step, print the shape,
1081:00 - see what is happening as our data moves through various layers. So test image through conv.shape,
1081:08 - we'll see what our conv layer does to the shape of our data. And then we're going to pass data through
1081:19 - max pool layer, which is the layer we created a couple of lines above this one here.
1081:24 - So let's see what happens. Test image through current type at the moment through conv and max
1081:34 - pool. So quite a long variable name here, but this is to help us avoid confusion of what's
1081:41 - going on. So we go test image through conv. So you notice how we're taking the output of our
1081:47 - convolutional layer, this here, and we're passing it through our max pool layer, which has another
1081:53 - typo. Wonderful. And finally, we'll print out the shape, shape after going through conv layer
1082:04 - and max pool layer. What happens here? So we want test image through conv and max pool.
1082:13 - Let's see how our max pool layer manipulates our test images shape. You ready? Three, two,
1082:21 - one, let's go. What do we get? Okay. So we have the test image original shape,
1082:27 - recall that our test image is just a collection of random numbers. And of course, our conv layer
1082:33 - is going to be instantiated with random numbers. And max pool actually has no parameters. It just
1082:39 - takes the maximum of a certain range of inner tensor. So when we unsqueeze the test image as the
1082:48 - input, we get an extra dimension here. When we pass it through our conv layer. Oh, where did this
1082:55 - 64 come from? 164 64 64 64. Let's go back up to our conv layer. Do you notice how that we get the
1083:03 - 64 there because we changed the out channels value? If we change this back to 10, like what's in the
1083:09 - CNN explainer model? One, two, three, four, five, six, seven, eight, nine, 10. What do you think will
1083:17 - happen there? Well, we get a little highlight here. 10. Then we keep going. I'll just get rid of
1083:25 - this extra cell. We don't need to check the version anymore. We'll check the test image
1083:29 - shapes still three 64 64. But then as we pass it through the conv layer here, we get a different
1083:36 - size now. So it originally had three channels as the input for color channels, but we've upscaled
1083:42 - it to 10 so that we have 10 hidden units in our layer. And then we have 64 64. Now, again,
1083:51 - these shapes will change if we change the values of what's going on here. So we might put padding
1083:56 - to zero. What happens there? Instead of 64 64, we get 62 62. And then what happens after we pass
1084:05 - it through the conv layer and then through the max pool layer? We've got 110 64 64. And now we have
1084:15 - 110 32 32. Now, why is that? Well, let's go back into the CNN explainer, jump into this max pool
1084:23 - layer here. Maybe this one because it's got a bit more going on. Do you notice on the left here is
1084:27 - the input? And we've got a two by two kernel here. And so the max pooling layer, what it does is it
1084:33 - takes the maximum of whatever the input is. So you'll notice the input is 60 60 in this case.
1084:40 - Whereas the output over here is 30 30. Now, why is that? Well, because the max operation here is
1084:47 - reducing it from section of four numbers. So let's get one with a few different numbers.
1084:55 - There we go. That'll do. So it's taking it from four numbers and finding the maximum value within
1085:01 - those four numbers here. Now, why would it do that? So as we've discussed before, what deep learning
1085:09 - neural network is trying to do or in this case, a CNN is take some input data and figure out
1085:15 - what features best represent whatever the input data is and compress them into a feature vector
1085:21 - that is going to be our output. Now, the reason being for that is because you could consider it
1085:28 - from a neural networks perspective is that intelligence is compression. So you're trying to
1085:32 - compress the patterns that make up actual data into a smaller vector space, go from a higher
1085:39 - dimensional space to a smaller vector space in terms of dimensionality of a tensor. But still,
1085:46 - this smaller dimensionality space represents the original data and can be used to predict on future
1085:52 - data. So that's the idea behind Max Paul is, hey, if we've got these learned features from our
1085:59 - convolutional layers, will the patterns, will the most important patterns stay around if we just
1086:05 - take the maximum of a certain section? So do you notice how the input here, we still have,
1086:11 - you can still see the outline of the car here, albeit a little bit more pixelated,
1086:16 - but just by taking the max of a certain region, we've got potentially the most important feature
1086:21 - of that little section. And now, of course, you could customize this value here. If when we
1086:27 - create our max pool layer, you could increase the kernel size to four by four. What do you think
1086:32 - will happen if we can increase it to four? So here, we've got a two by two kernel. If we increase it
1086:38 - to four by four, what happens? Ah, do you notice that we've gone from 62 to 15, we've essentially
1086:46 - divided our feature space by four, we've compressed it even further. Now, will that work? Well,
1086:53 - I'm not sure. That's part of the experimental nature of machine learning, but we're going to
1086:57 - keep it at two for now. And so this is with our tensor here 6464. But now let's do the same as
1087:04 - what we've done above, but we'll do it with a smaller tensor so that we can really visualize
1087:09 - things. And we're going to just replicate the same operation that's going on here. So let's go here,
1087:17 - we'll create another random tensor. We'll set up the manual seed first. And we're going to create
1087:25 - a random tensor with a similar number of dimensions. Now, recall dimensions don't tell you, so this
1087:35 - is a dimension 1364 64. That is a dimension. The dimensions can have different values within
1087:43 - themselves. So we want to create a four dimensional tensor to our images. So what that means is,
1087:50 - let me just show you it's way easy to explain things when we've got code is torch dot rand n.
1087:57 - And we're going to set it up as size equals one, one, two, two. We can have a look at this random
1088:05 - tensor. It's got four dimensions. One, two, three, four. So you could have a batch size,
1088:12 - color channels, and height width, a very small image, but it's a random image here. But this is
1088:18 - quite similar to what we've got going on here, right? Four numbers. Now, what do you think will
1088:24 - happen if we create a max pool layer, just like we've done above, create a max pool layer. So we
1088:31 - go max pool layer, just repeating the code that we have in the cell above, that's all right,
1088:36 - a little bit of practice. Kernel size equals two. And then we're going to pass the random tensor
1088:46 - through the max pool layer. So we'll go max pool tensor equals max pool layer. And we're going
1089:05 - to pass it in the random tensor. Wonderful. And then we can print out some shapes and print
1089:10 - out some tenses. As we always do to visualize, visualize, visualize. So we're going to write in
1089:15 - here max pool tensor on a new line. We'll get in the max pool tensor. We'll see what this looks
1089:24 - like. And we'll also print out max pool tensor shape. And we can probably print out random tensor
1089:32 - itself, as well as its shape as well. We'll get the shape here, dot shape. And we'll do the same
1089:39 - for the random tensor. So print, get a new line, random tensor, new line, random tensor. And then
1089:52 - we'll get the shape. Random tensor shape, random tensor. Oh, a lot of coding here. That's, that's
1090:02 - the fun part about machine learning, right? You get to write lots of code. Okay. So we're
1090:06 - visualizing what's going on with our random tensor. This is what's happening within the max pool layer.
1090:11 - We've seen this from a few different angles now. So we have a random tensor of numbers,
1090:15 - and we've got a size here. But the max pool tensor, once we pass our random tensor,
1090:21 - through the max pool layer, what happens? Well, we have 0.3367, 1288, 2345, 2303. Now,
1090:30 - what's the max of all these? Well, it takes the max here is 3367. Oh, and we've got the random
1090:37 - tensor down there. We don't want that. And see how we've reduced the shape from two by two to one
1090:44 - by one. Now, what's going on here? Just for one last time to reiterate, the convolutional layer
1090:52 - is trying to learn the most important features within an image. So if we jump into here,
1090:59 - now, what are they? Well, we don't decide what a convolutional layer learns. It learns these
1091:06 - features on its own. So the convolutional layer learns those features. We pass them through a
1091:12 - relu nonlinear activation in case our data requires nonlinear functions. And then we pass
1091:18 - those learned features through a max pool layer to compress them even further. So the convolutional
1091:24 - layer can compress the features into a smaller space. But the max pooling layer really compresses
1091:29 - them. So that's the entire idea. One more time, we start with some input data. We design a neural
1091:36 - network, in this case, a convolutional neural network, to learn a compressed representation
1091:41 - of what our input data is, so that we can use this compressed representation to later on make
1091:46 - predictions on images of our own. And in fact, you can try that out if you wanted to click here
1091:52 - and add your own image. So I'd give that a go. That's your extension for this video. But now we've
1091:58 - stepped through the max pool 2D layer and the conv 2D layer. I think it's time we started to try
1092:06 - and use our tiny VGG network. This is your challenge is to create a dummy tensor and pass it through
1092:14 - this model. Pass it through its forward layer and see what happens to the shape of your dummy tensor
1092:21 - as it moves through conv block 1 and conv block 2. And I'll show you my trick to calculating
1092:28 - the in features here for this final layer, which is equivalent to this final layer here.
1092:34 - I'll see you in the next video.
1092:37 - Over the last few videos, we've been replicating the tiny VGG architecture
1092:42 - from the CNN explainer website. And I hope you know that this is this actually quite exciting
1092:47 - because years ago, this would have taken months of work. And we've just covered we've broken it
1092:53 - down over the last few videos and rebuilt it ourselves with a few lines of PyTorch code.
1092:58 - So that's just goes to show how powerful PyTorch is and how far the deep learning field has come.
1093:04 - But we're not finished yet. Let's just go over to our keynote. This is what we've done.
1093:10 - CNN explainer model. We have an input layer. We've created that. We have com2d layers.
1093:18 - We've created those. We have relo activation layers. We've created those.
1093:24 - And finally, we have pulling layers. And then we finish off with an output layer.
1093:30 - But now let's see what happens when we actually pass some data through this entire model.
1093:34 - And as I've said before, this is actually quite a common practice is you replicate a model
1093:41 - that you found somewhere and then test it out with your own data. So we're going to start off
1093:46 - by using some dummy data to make sure that our model works. And then we're going to pass through.
1093:53 - Oh, I've got another slide for this. By the way, here's a breakdown of torch and
1093:58 - N com2d. If you'd like to see it in text form, nothing here that we really haven't discussed before, but
1094:04 - this will be in the slides if you would like to see it. Then we have a video animation.
1094:10 - We've seen this before, though. And plus, I'd rather you go through the CNN explainer website
1094:14 - on your own and explore this different values rather than me just keep talking about it.
1094:19 - Here's what we're working towards doing. We have a fashion MNIST data set. And we have
1094:24 - our inputs. We're going to numerically encode them. We've done that already. Then we have our
1094:30 - convolutional neural network, which is a combination of convolutional layers, nonlinear activation
1094:35 - layers, pooling layers. But again, these could be comprised in many different ways, shapes and
1094:40 - forms. In our case, we've just replicated the tiny VGG architecture. And then finally,
1094:46 - we want to have an output layer to predict what class of clothing a particular input image is.
1094:52 - And so let's go back. We have our CNN model here. And we've got model two. So let's just practice
1095:02 - a dummy forward pass here. We're going to come back up a bit to where we were. We'll make sure
1095:06 - we've got model two. And we get an error here because I've times this by zero. So I'm going to
1095:15 - just remove that and keep it there. Let's see what happens if we create a dummy tensor and pass it
1095:21 - through here. Now, if you recall what our image is, do we have image? This is a fashion MNIST
1095:29 - image. So I wonder if we can go plot dot M not M show image. And I'm going to squeeze that.
1095:38 - And I'm going to set the C map equal to gray. So this is our current image. Wonderful.
1095:48 - So there's our current image. So let's create a tensor. Or maybe we just try to pass this through
1095:56 - the model and see what happens. How about we try that model image? All right, we're going to try
1096:02 - the first pass forward pass. So pass image through model. What's going to happen? Well, we get an
1096:12 - error. Another shape mismatch. We've seen this before. How do we deal with this? Because what
1096:17 - is the shape of our current image? 128, 28. Now, if you don't have this image instantiated,
1096:26 - you might have to go back up a few cells. Where did we create image? I'll just find this. So
1096:33 - just we created this a fairly long time ago. So I'm going to probably recreate it down the
1096:38 - bottom. My goodness, we've written a lot of code. Well, don't do us. We could create a dummy tensor
1096:45 - if we wanted to. How about we do that? And then if you want to find, oh, right back up here,
1096:51 - we have an image. How about we do that? We can just do it with a dummy tensor. That's fine.
1096:58 - We can create one of the same size. But if you have image instantiated, you can try that out.
1097:03 - So there's an image. Let's now create an image that is, or a random tensor, that is the same
1097:10 - shape as our image. So rand image tensor equals what torch dot rand n. And we're going to pass in
1097:21 - size equals 128, 28. Then if we get rand image tensor,
1097:32 - we check its shape. What do we get? So the same shape as our test image here,
1097:37 - but it's just going to be random numbers. But that's okay. We just want to highlight a point
1097:40 - here of input and output shapes. We want to make sure our model works. Can our random image tensor
1097:45 - go all the way through our model? That's what we want to find out. So we get an error here.
1097:50 - We have four dimensions, but our image is three dimensions. How do we add an extra dimension
1097:54 - for batch size? Now you might not get this error if you're running a later version of pie torch.
1097:58 - Just keep that in mind. So unsqueeze zero. Oh, expected all tensors to be on the same device,
1098:07 - but found at least two devices. Again, we're going through all the three major issues in deep
1098:12 - learning. Shape mismatch, device mismatch, data type mismatch. So let's put this on the device,
1098:17 - two target device, because we've set up device agnostic code.
1098:21 - That one and that two shapes cannot be multiplied. Oh, but we can output here.
1098:28 - That is very exciting. So what I might do is move this a couple of cells up so that we can
1098:34 - tell what's going on. I'm going to delete this cell. So where do these shapes come from?
1098:42 - Well, we printed out the shapes there. And so this is what's happened when our,
1098:46 - I'll just create our random tensor. I'll bring our random tensor up a bit too. Let's bring this up.
1098:53 - There we go. So we pass our random to image tensor through our model, and we've made sure it's
1099:01 - got four dimensions by unsqueeze zero. And we make sure it's on the same device as our model,
1099:07 - because our model has been sent to the GPU. And this is what happens as we pass our random
1099:12 - image tensor. We've got 12828 instead of previously we've seen 6464.3, which is going to clean this
1099:19 - up a bit. And we get different shapes here. So you'll notice that as our input, if it was 6464.3
1099:27 - goes through these layers, it gets shaped into different values. Now this is going to be universal
1099:33 - across all of the different data sets you work on, you will be working with different shapes.
1099:38 - So it's important to, and also quite fun, to troubleshoot what shapes you need to use for
1099:44 - your different layers. So this is where my trick comes in. To find out the shapes for different
1099:48 - layers, I often construct my models, how we've done here, as best I can with the information
1099:53 - that I've got, such as replicating what's here. But I don't really know what the output
1099:58 - shape is going to be before it goes into this final layer. And so I recreate the model as best
1100:03 - I can. And then I pass data through it in the form of a dummy tensor in the same shape as my
1100:10 - actual data. So we could customize this to be any shape that we wanted. And then I print the
1100:15 - shapes of what's happening through each of the forward past steps. And so if we pass it through
1100:21 - this random tensor through the first column block, it goes through these layers here. And then it
1100:27 - outputs a tensor with this size. So we've got 10, because that's how many output channels we've
1100:33 - set. And then 14, 14, because our 2828 tensor has gone through a max pool 2d layer and gone through
1100:41 - a convolutional layer. And then it goes through the next block, column block two, which is because
1100:47 - we've put it in the forward method here. And then it outputs the shape. And if we go back down,
1100:53 - we have now a shape of one 10, seven, seven. So our previous tensor, the output of column block one,
1100:59 - has gone from 1414 to seven seven. So it's been compressed. So let me just write this down here,
1101:06 - output shape of column block one, just so we get a little bit more information.
1101:15 - And I'm just going to copy this, put it in here, that will become block two.
1101:23 - And then finally, I want to know if I get an output shape of classifier.
1101:31 - So if I rerun all of this, I don't get an output shape of classifier. So my model is running into
1101:39 - trouble. Once it gets to, so I get the output of conv block one, I don't get an output of classifier.
1101:45 - So this is telling me that I have an issue with my classifier layer. Now I know this, but I'm
1101:51 - not. Now I know this because, well, I've coded this model before, and the in features here,
1101:57 - we need a special calculation. So what is going on with our shapes?
1102:02 - Mat one and mat two shapes cannot be multiplied. So do you see here, what is the rule of matrix
1102:07 - multiplication? The inner dimensions here have to match. We've got 490. Where could that number
1102:12 - have come from? And we've got 10 times 10. Now, okay, I know I've set hidden units to 10.
1102:21 - So maybe that's where that 10 came from. And what is the output layer of the output shape of conv
1102:28 - block two? So if we look, we've got the output shape of conv block two. Where does that go?
1102:38 - The output of conv block two goes into our classifier model. And then it gets flattened.
1102:45 - So that's telling us something there. And then our NN linear layer is expecting the output of
1102:51 - the flatten layer as it's in features. So this is where my trick comes into play. I pass the
1102:59 - output of conv block two into the classifier layer. It gets flattened. And then that's what
1103:06 - my NN not linear layer is expecting. So what happens if we flatten this shape here? Do we get
1103:16 - this value? Let's have a look. So if we go 10 times seven times seven, 490. Now, where was this 10?
1103:28 - Well, that's our hidden units. And where were these sevens? Well, these sevens are the output
1103:38 - of conv block two. So that's my trick. I print the shapes of previous layers and see whether or
1103:45 - not they line up with subsequent layers. So if we go time seven times seven, we're going to have
1103:52 - hidden units equals 10 times seven times seven. Where do we get the two sevens? Because that is
1103:58 - the output shape of conv block two. Do you see how this can be a little bit hard to calculate ahead
1104:03 - of time? Now, you could calculate this by hand if you went into n conv 2d. But I prefer to write
1104:10 - code to calculate things for me. You can calculate that value by hand. If you go through,
1104:16 - H out W out, you can add together all of the different parameters and multiply them and divide
1104:22 - them and whatnot. You can calculate the input and output shapes of your convolutional layers.
1104:28 - You're more than welcome to try that out by hand. But I prefer to code it out. If and out code it
1104:34 - out. Now, let's see what happens if we run our random image tensor through our model. Now,
1104:42 - do you think it will work? Well, let's find out. All we've done is we've added this little line
1104:47 - here, times seven times seven. And we've calculated that because we've gone, huh, what if we pass a
1104:53 - tensor of this dimension through a flattened layer? And what is our rule of matrix multiplication?
1105:00 - The inner dimensions here must match. And why do we know that these are matrices? Well,
1105:06 - mat one and mat two shapes cannot be multiplied. And we know that inside a linear layer
1105:10 - is a matrix multiplication. So let's now give this a go. We'll see if it works.
1105:22 - Oh, ho ho. Would you look at that? That is so exciting. We have the output shape of the classifier
1105:28 - is one and 10. We have a look, we have one number one, two, three, four, five, six, seven, eight,
1105:35 - nine, 10, one number for each class in our data set. Wow. Just like the CNN explain a website,
1105:45 - we have 10 outputs here. We just happen to have 10 classes as well. Now, this number again could be
1105:51 - whatever you want. It could be 100, could be 30, could be three, depending on how many classes
1105:55 - you have. But we have just figured out the input and output shapes of each layer in our model.
1106:01 - So that's very exciting. I think it's now time we've passed a random tensor through. How about we
1106:08 - pass some actual data through our model? In the next video, let's use our train and test step
1106:14 - functions to train our first convolutional neural network. I'll see you there.
1106:24 - Well, let's get ready to train our first CNN. So what do we need? Where are we up to in the
1106:28 - workflow? Well, we've built a model and we've stepped through it. We know what's going on,
1106:33 - but let's really see what's going on by training this CNN or see if it trains because we don't
1106:39 - always know if it will on our own data set, which is of fashion MNIST. So we're going to set up a
1106:46 - loss function and optimizer for model two. And just as we've done before, model two, turn that
1106:54 - into markdown. I'll just show you the workflow again. So this is what we're doing. We've got some
1107:00 - inputs. We've got a numerical encoding. We've built this architecture and hopefully it helps us
1107:06 - learn or it helps us make a predictive model that we can input images such as grayscale images of
1107:13 - clothing and predict. And if we look where we are at the PyTorch workflow, we've got our data ready.
1107:21 - We've built our next model. Now here's where we're up to picking a loss function and an optimizer.
1107:29 - So let's do that, hey, loss function, or we can do evaluation metrics as well. So set up loss
1107:38 - function slash eval metrics slash optimizer. And we want from helper functions, import accuracy
1107:47 - function, we don't need to reimport it, but we're going to do it anyway for completeness. Loss
1107:52 - function equals nn dot cross entropy loss, because we are working with a multi class classification
1107:58 - problem. And the optimizer, we're going to keep the same as what we've used before, torch dot
1108:03 - opt in SGD. And we'll pass it in this time, the params that we're trying to optimize are the
1108:09 - parameters of model two parameters. And we'll use a learning rate of 0.1. Run that. And just
1108:17 - to reiterate, here's what we're trying to optimize model two state dig. We have a lot of random
1108:25 - weights in model two. Have a look at all this. There's the bias, there's the weight. We're going
1108:31 - to try and optimize these to help us predict on our fashion MNIST data set. So without any further
1108:37 - ado, let's in the next video, go to the workflow, we're going to build our training loop. But thanks
1108:44 - to us before, we've now got functions to do this for us. So if you want to give this a go,
1108:50 - use our train step and test step function to train model two. Try that out. And we'll do it
1108:58 - together in the next video. We're getting so close to training our model. Let's write some code to
1109:06 - train our first thing in that model. Training and testing, I'm just going to make another heading
1109:11 - here. Model two, using our training and test functions. So we don't have to rewrite all of the
1109:21 - steps in a training loop and a testing loop, because we've already created that functionality
1109:25 - before through our train step function. There we go. Performs the training, or this should be
1109:32 - performs a training step with model trying to learn on data loader. So let's set this up.
1109:39 - We're going to set up torch manual seed 42, and we can set up a CUDA manual seed as well.
1109:46 - Just to try and make our experiments as reproducible as possible, because we're going to be using
1109:51 - CUDA, we're going to measure the time because we want to compare our models, not only their
1109:56 - performance in evaluation metrics, but how long they take to train from time it, because there's
1110:02 - no point having a model that performs really, really well, but takes 10 times longer to train.
1110:10 - Well, maybe there is, depending on what you're working on. Model two equals timer,
1110:19 - and we're going to train and test model, but the time is just something to be aware of,
1110:24 - is that usually a better performing model will take longer to train. Not always the case, but
1110:29 - just something to keep in mind. So for epoch in, we're going to use TQDM to measure the progress.
1110:37 - We're going to create a range of epochs. We're just going to train for three epochs,
1110:40 - keeping our experiment short for now, just to see how they work, epoch, and we're going to
1110:48 - print a new line here. So for an epoch in a range, we're going to do the training step,
1110:54 - which is our train step function. The model is going to be equal to model two, which is our
1111:00 - convolutional neural network, our tiny VGG. The data loader is just going to be equal to the
1111:05 - train data loader, the same one we've used before. The loss function is going to be equal to the
1111:10 - loss function that we've set up above, loss FN. The optimizer as well is going to be
1111:17 - the optimizer in our case, stochastic gradient descent, optimizer equals optimizer,
1111:22 - then we set up the accuracy function, which is going to be equal to our accuracy function,
1111:27 - and the device is going to be the target device. How easy was that? Now we do the same for the
1111:36 - train or the testing step, sorry, the model is going to be equal to model two, and then the data
1111:41 - loader is going to be the test data loader, and then the loss function is going to be our same
1111:51 - our same loss function. And then we have no optimizer for this, we're just going to pass in the
1111:56 - accuracy function here. And then of course, the device is going to be equal to the device.
1112:03 - And then what do we do now? Well, we can measure the end time so that we know how long the code
1112:12 - here took to run. So let's go train time end for model two. This will be on the GPU, by the way,
1112:20 - but this time it's using a convolutional neural network. And the total train time,
1112:25 - total train time for model two is going to be equal to print train time, our function that we
1112:32 - created before as well, to help us measure start and end time. So we're going to pass in train
1112:37 - to time start model two, and then end is going to be train time end model two. And then we're going
1112:46 - to print out the device that it's using as well. So you're ready? Are you ready to train our first
1112:52 - convolutional neural network? Hopefully this code works. We've created these functions before,
1112:58 - so it should be all right. But if and out, code it out, if and out, run the code, let's see what
1113:04 - happens. Oh my goodness. Oh, of course. Oh, we forgot to comment out the output shapes.
1113:13 - So we get a whole bunch of outputs for our model, because what have we done? Back up here,
1113:21 - we forgot to. So this means every time our data goes through the forward pass, it's going to
1113:25 - be printing out the output shapes. So let's just comment out these. And I think this cell is going
1113:33 - to take quite a long time to run because it's got so many printouts. Yeah, see, streaming output
1113:40 - truncated to the last 5,000 lines. So we're going to try and stop that. Okay, there we go.
1113:46 - Beautiful. That actually worked. Sometimes it doesn't stop so quickly. So we're going to rerun
1113:52 - our fashion MSV to model cell so that we comment out these print lines. And then we'll just rerun
1114:00 - these cells down here. Just go back through fingers crossed, there's no errors. And we'll train our
1114:07 - model again. Beautiful. Not as many printouts this time. So here we go. Our first CNN is training.
1114:12 - How do you think it'll go? Well, that's what we have printouts, right? So we can see the progress.
1114:18 - So you can see here all the functions that are being called behind the scenes from PyTorch. So
1114:23 - thank you to PyTorch for that. There's our, oh, our train step function was in there.
1114:28 - Train step. Wonderful. Beautiful. So there's epoch zero. Oh, we get a pretty good test accuracy.
1114:35 - How good is that? Test accuracy is climbing as well. Have we beaten our baseline? We're looking at
1114:41 - about 14 seconds per epoch here. And then the final epoch. What do we finish at? Oh, 88.5. Wow.
1114:51 - In 41.979 or 42 there about seconds. Again, your mileage may vary. Don't worry too much if these
1115:00 - numbers aren't exactly the same on your screen and same with the training time because we might
1115:06 - be using slightly different hardware. What GPU do I have today? I have a Tesla P100 GPU. You might
1115:15 - not have the same GPU. So the training time, if this training time is something like 10 times
1115:21 - higher, you might want to look into what's going on. And if these values are like 10% lower or 10%
1115:28 - higher, you might want to see what's going on with your code as well. But let's now calculate
1115:33 - our Model 2 results. I think it is the best performing model that we have so far. Let's get
1115:38 - a results dictionary. Model 2 results is so exciting. We're learning the power of convolutional neural
1115:44 - networks. Model 2 results equals a vowel model. And this is a function that we've created before.
1115:52 - So returns a dictionary containing the results of a model predicting on data loader.
1115:57 - So now let's pass in the model, which will be our trained model to, and then we'll pass in the
1116:02 - data loader, which will be our test data loader. And then, oops, excuse me, typo, our loss function
1116:09 - will be, of course, our loss function. And the accuracy function will be accuracy function.
1116:17 - And the device is already set, but we can reset anyway, device equals device. And we'll check
1116:23 - out the Model 2 results. Make some predictions. Oh, look at that. Model accuracy 88. Does that
1116:34 - beat our baseline? Model 0 results. Oh, we did beat our baseline with a convolutional neural network.
1116:43 - All right. So I feel like that's, uh, that's quite exciting. But now let's keep going on. And, uh,
1116:50 - let's start to compare the results of all of our models. I'll see you in the next video.
1116:59 - Welcome back. Now, in the last video, we trained our first convolutional neural network. And
1117:04 - from the looks of things, it's improved upon our baseline. But let's make sure by comparing,
1117:10 - this is another important part of machine learning experiments is comparing the results
1117:14 - across your experiments. So and training time. Now, we've done that in a way where we've got
1117:21 - three dictionaries here of our model zero results, model one results, model two results. So how
1117:28 - about we create a data frame comparing them? So let's import pandas as PD. And we're going to
1117:36 - compare results equals PD dot data frame. And because our model results dictionaries, uh,
1117:45 - all have the same keys. Let's pass them in as a list. So model zero results, model one results,
1117:53 - and model two results to compare them. Wonderful. And what it looks like when we compare the results.
1118:00 - All righty. So recall our first model was our baseline V zero was just two linear layers.
1118:09 - And so we have an accuracy of 83.4 and a loss of 0.47. The next model was we trained on the GPU
1118:18 - and we introduced nonlinearities. So we actually found that that was worse off than our baseline.
1118:26 - But then we brought in the big guns. We brought in the tiny VGG architecture from the CNN explainer
1118:32 - website and trained our first convolutional neural network. And we got the best results so far.
1118:38 - But there's a lot more experiments that we could do. We could go back through our
1118:43 - tiny VGG and we could increase the number of hidden units. Where do we create our model up here?
1118:50 - We could increase this to say 30 and see what happens. That would be a good experiment to
1118:55 - try. And if we found that nonlinearities didn't help with our second model, we could comment out
1119:01 - the relu layers. We could of course change the kernel size, change the padding, change the max
1119:07 - pool. A whole bunch of different things that we could try here. We could train it for longer.
1119:12 - So maybe if we train it for 10 epochs, it would perform better. But these are just things to
1119:16 - keep in mind and try out. I'd encourage you to give them a go yourself. But for now, we've kept
1119:20 - all our experiments quite the same. How about we see the results we add in the training time?
1119:26 - Because that's another important thing that we've been tracking as well. So we'll add
1119:32 - training time to results comparison. So the reason why we do this is because
1119:42 - if this model is performing quite well, even compared to our CNN, so a difference in about
1119:47 - 5% accuracy, maybe that's tolerable in the space that we're working, except that this model
1119:54 - might actually train and perform inference 10 times faster than this model. So that's just
1119:59 - something to be aware of. It's called the performance speed trade off. So let's add another column
1120:05 - here, compare results. And we're going to add in, oh, excuse me, got a little error there. That's
1120:12 - all right. Got trigger happy on the shift and enter. Training time equals, we're going to add in,
1120:18 - we've got another list here is going to be total train time for model zero, and total train time
1120:27 - for model one, and total train time for model two. And then we have a look at our
1120:37 - how compare results dictionary, or sorry, compare results data frame. Wonderful. So we see, and
1120:46 - now this is another thing. I keep stressing this to keep in mind. If your numbers aren't exactly
1120:50 - of what I've got here, don't worry too much. Go back through the code and see if you've set up
1120:55 - the random seeds correctly, you might need a koodle random seed. We may have missed one of those.
1121:00 - If your numbers are out landishly different to these numbers, then you should go back through
1121:03 - your code and see if there's something wrong. And again, the training time will be highly
1121:08 - dependent on the compute environment you're using. So if you're running this notebook locally,
1121:12 - you might get faster training times. If you're running it on a different GPU to what I have,
1121:17 - NVIDIA SMI, you might get different training times. So I'm using a Tesla P100, which is quite a fast
1121:23 - GPU. But that's because I'm paying for Colab Pro, which generally gives you faster GPUs.
1121:28 - And model zero was trained on the CPU. So depending on what compute resource Google allocates to you
1121:36 - with Google Colab, this number might vary here. So just keep that in mind. These values training
1121:43 - time will be very dependent on the hardware you're using. But if your numbers are dramatically
1121:48 - different, well, then you might want to change something in your code and see what's going on.
1121:52 - And how about we finish this off with a graph? So let's go visualize our model results. And while
1122:01 - we're doing this, have a look at the data frame above. Is the performance here 10 seconds longer
1122:08 - training time worth that extra 5% of the results on the accuracy? Now in our case, we're using a
1122:15 - relatively toy problem. What I mean by toy problem is quite a simple data set to try and test this
1122:21 - out. But in your practice, that may be worth doing. If your model takes longer to train,
1122:27 - but gets quite a bit better performance, it really depends on the problem you're working with.
1122:33 - Compare results. And we're going to set the index as the model name, because I think that's
1122:38 - what we want our graph to be, not the model name. And then we're going to plot, we want to compare
1122:43 - the model accuracy. And we want to plot, the kind is going to be equal to bar h, horizontal bar chart.
1122:53 - We've got p x label, we're going to get accuracy as a percentage. And then we're going to go py label.
1123:02 - This is just something that you could share. If someone was asking, how did your modeling
1123:06 - experiments go on fashion MNIST? Well, here's what I've got. And then they ask you, well,
1123:10 - what's the fashion MNIST model V2? Well, you could say that's a convolutional neural network that
1123:14 - trained, that's replicates the CNN explainer website that trained on a GPU. How long did that
1123:20 - take to train? Well, then you've got the training time here. We could just do it as a vertical bar
1123:25 - chart. I did it as horizontal so that this looks a bit funny to me. So horizontal like that.
1123:32 - So the model names are over here. Wonderful. So now I feel like we've got a trained model.
1123:40 - How about we make some visual predictions? Because we've just got numbers on a page here,
1123:45 - but our model is trained on computer vision data. And the whole point of making a machine
1123:51 - learning model on computer vision data is to be able to visualize predictions. So let's give
1123:57 - that a shot, hey, in the next video, we're going to use our best performing model, fashion MNIST
1124:02 - model V2 to make predictions on random samples from the test data set. You might want to give
1124:08 - that a shot, make some predictions on random samples from the test data set, and plot them out with
1124:13 - their predictions as the title. So try that out. Otherwise, we'll do it together in the next video.
1124:19 - In the last video, we compared our models results. We tried three experiments. One was a basic linear
1124:28 - model. One was a linear model with nonlinear activations. And fashion MNIST model V2 is a
1124:34 - convolutional neural network. And we saw that from an accuracy perspective, our convolutional neural
1124:40 - network performed the best. However, it had the longest training time. And I just want to exemplify
1124:45 - the fact that the training time will vary depending on the hardware that you run on. We spoke about
1124:50 - this in the last video. However, I took a break after finishing the last video, reran all of the
1124:56 - cells that we've written, all of the code cells up here by coming back to the notebook and going
1125:01 - run all. And as you'll see, if you compare the training times here to the last video, we get
1125:06 - some different values. Now, I'm not sure exactly what hardware Google collab is using behind the
1125:11 - scenes. But this is just something to keep in mind, at least from now on, we know how to track
1125:16 - our different variables, such as how long our model takes to train and what its performance
1125:22 - values are. But it's time to get visual. So let's create another heading, make and evaluate. This
1125:30 - is one of my favorite steps after training a machine learning model. So make and evaluate random
1125:37 - predictions with the best model. So we're going to follow the data explorer's model of getting
1125:44 - visual visual visual or visualize visualize visualize. Let's make a function called make
1125:49 - predictions. And it's going to take a model, which will be a torch and end module type.
1125:56 - It's also going to take some data, which can be a list. It'll also take a device type,
1126:02 - which will be torch dot device. And we'll set that by default to equal the default device that
1126:07 - we've already set up. And so what we're going to do is create an empty list for prediction
1126:12 - probabilities. Because what we'd like to do is just take random samples from the test data set,
1126:20 - make predictions on them using our model, and then plot those predictions. We want to visualize
1126:26 - them. And so we'll also turn our model into evaluation mode, because if you're making predictions with
1126:32 - your model, you should turn on evaluation mode. We'll also switch on the inference mode context
1126:37 - manager, because predictions is another word for inference. And we're going to loop through
1126:43 - for each sample in data. Let's prepare the sample. So this is going to take in
1126:52 - a single image. So we will unsqueeze it, because we need to add a batch size dimension
1126:58 - on the sample, we'll set dim equals to zero, and then we'll pass that to the device. So
1127:06 - add a batch dimension, that's with the unsqueeze, and pass to target device. That way, our data and
1127:14 - model are on the same device. And we can do a forward pass. Well, we could actually up here go
1127:21 - model dot two device. That way we know that we've got device agnostic code there.
1127:26 - Now let's do the forward pass, forward pass model outputs raw logits. So recall that if we have a
1127:33 - linear layer at the end of our model, it outputs raw logits. So pred logit for a single sample is
1127:39 - going to equal model. We pass the sample to our target model. And then we're going to get the
1127:45 - prediction probability. How do we get the prediction probability? So we want to go from
1127:50 - logit to prediction probability. Well, if we're working with a multi class classification problem,
1127:59 - we're going to use the softmax activation function on our pred logit. And we're going to squeeze
1128:05 - it so it gets rid of an extra dimension. And we're going to pass in dim equals zero. So that's going
1128:11 - to give us our prediction probability for a given sample. Now let's also turn our prediction
1128:17 - probabilities into prediction labels. So get pred. Well, actually, I think we're just going
1128:25 - to return the pred probes. Yeah, let's see what that looks like, because we've got a
1128:31 - an empty list up here for pred probes. So for matplotlib, we're going to have to use our data
1128:37 - on the CPU. So let's make sure it's on the CPU, because matplotlib doesn't work with the GPU.
1128:43 - So get pred prob off GPU for further calculations. So we're just hard coded in here to make sure
1128:51 - that our prediction probabilities off the GPU. So pred probs, which is our list up here. We're
1128:58 - going to append the pred prob that we just calculated. But we're going to put it on the CPU. And then
1129:06 - let's go down here. And we're going to. So if we've done it right, we're going to have a list of
1129:12 - prediction probabilities relating to particular samples. So we're going to stack the pred probs
1129:19 - to turn list into a tensor. So this is only one way of doing things. There are many different ways
1129:25 - that you could make predictions and visualize them. I'm just exemplifying one way. So we're
1129:30 - going to torch stack, which is just going to say, hey, concatenate everything in the list to a
1129:34 - single tensor. So we might need to tab that over, tab, tab. Beautiful. So let's try this function
1129:49 - in action and see what happens. I'm going to import random. And then I'm going to set the random
1129:54 - seed to 42. And then I'm going to create test samples as an empty list, because we want an empty
1130:00 - or we want a list of test samples to iterate through. And I'm going to create test labels also as an
1130:06 - empty list. So that remember, when we are evaluating predictions, we want to compare them to the
1130:10 - ground truth. So we want to get some test samples. And then we want to get their actual labels so
1130:15 - that when our model makes predictions, we can compare them to their actual labels. So for sample,
1130:22 - comma label, in, we're going to use random to sample the test data. Now note that this is not
1130:29 - the test data loader. This is just test data. And we're going to set k equals to nine. And recall,
1130:36 - if you want to have a look at test data, what do we do here? We can just go test data,
1130:41 - which is our data set, not converted into a data loader yet. And then if we wanted to get the first
1130:47 - 10 samples, can we do that? Only one element tensors can be converted into Python scalars. So if we
1130:53 - get the first zero, and maybe we can go up to 10. Yeah, there we go. And what's the shape of this?
1131:03 - Tuple has no object shape. Okay, so we need to go image label equals that. And then can we check
1131:10 - the shape of the image label? Oh, because the labels are going to be integers.
1131:18 - Wonderful. So that's not the first 10 samples, but that's just what we get if we iterate through
1131:25 - the test data, we get an image tensor, and we get an associated label. So that's what we're doing
1131:32 - with this line here, we're just randomly sampling nine samples. And this could be any number you
1131:37 - want. I'm going to use nine, because this is a spoiler for later on, we're going to create a
1131:41 - three by three plot. So that just nine is just a fun number. So get some random samples from the
1131:48 - test data set. And then we can go test samples dot append sample. And we will go test labels dot
1131:55 - append label. And then let's go down here, view the first, maybe we go first sample shape.
1132:06 - So test samples zero dot shape.
1132:11 - And then if we get test samples, zero, we're going to get a tensor of image values. And then
1132:19 - if we wanted to plot that, can we go PLT, M show, C map, equals gray. And we may have to squeeze
1132:28 - this, I believe, to remove the batch tensor. Let's see what happens batch dimension. There we go.
1132:35 - Beautiful. So that's to me, a shoe, a high heel shoe of some sort. If we get the title,
1132:41 - PLT dot title, test labels, let's see what this looks like. It's a five, which is, of course,
1132:50 - class names will index on that. Sandal. Okay, beautiful. So we have nine random samples,
1132:59 - nine labels that are associated with that sample. Now let's make some predictions. So make predictions.
1133:06 - And this is one of my favorite things to do. I can't stress it enough is to randomly pick data
1133:13 - samples from the test data set and predict on them and do it over and over and over again to see
1133:18 - what the model is doing. So not only at the start of a problem, I'll just get the prediction
1133:23 - probabilities here. We're going to call our make predictions function. So not only at the start of
1133:29 - a problem should you become one with the data, even after you've trained a model, you'll want to
1133:34 - further become one with the data, but this time become one with your models predictions on the
1133:39 - data and see what happens. So view the first two prediction probabilities list. So we're just
1133:46 - using our make predictions function that we created before, passing at the model, the train model
1133:51 - to, and we're passing at the data, which is the test samples, which is this list that we just
1133:55 - created up here, which is comprised of random samples from the test data set. Wonderful. So
1134:03 - let's go. Pred probes. Oh, we don't want to view them all. That's going to give us
1134:13 - Oh, we want to the prediction probabilities for a given sample. And so how do we convert
1134:19 - prediction probabilities into labels? Because if we're trying to, if we have a look at test
1134:25 - labels, if we're trying to compare apples to apples, when we're evaluating our model, we want to,
1134:32 - we can't really necessarily compare the prediction probabilities straight to the test labels. So we
1134:37 - need to convert these prediction probabilities into prediction labels. So how can we do that?
1134:44 - Well, we can use argmax to take whichever value here, the index, in this case, this one,
1134:51 - the index of whichever value is the highest of these prediction probabilities. So let's see that
1134:58 - in action. Convert prediction probabilities to labels. So we'll go pred classes equals
1135:08 - pred probes, and we'll get the argmax across the first dimension. And now let's have a look at the
1135:14 - pred classes. Wonderful. So are they in the same format as our test labels? Yes, they are. So if
1135:23 - you'd like to go ahead, in the next video, we're going to plot these and compare them. So we're
1135:28 - going to write some code to create a mapplotlib plotting function that's going to plot nine
1135:33 - different samples, along with their original labels, and their predicted label. So give that a shot,
1135:41 - we've just written some code here to make some predictions on random samples. If you'd like them
1135:44 - to be truly random, you can comment out the seed here, but I've just kept the seed at 42. So that
1135:51 - our random dot sample selects the same samples on your end and on my end. So in the next video,
1135:58 - let's plot these. Let's now continue following the data explorer's motto of visualize visualize
1136:08 - visualize. We have some prediction classes. We have some labels we'd like to compare them to.
1136:12 - You can compare them visually. It looks like our model is doing pretty good. But let's,
1136:17 - since we're making predictions on images, let's plot those images along with the predictions.
1136:22 - So I'm going to write some code here to plot the predictions. I'm going to create a matplotlib
1136:27 - figure. I'm going to set the fig size to nine and nine. Because we've got nine random samples,
1136:34 - you could, of course, change this to however many you want. I just found that a three by three
1136:39 - plot works pretty good in practice. And I'm going to set n rows. So for my matplotlib plot, I want
1136:45 - three rows. And I want three columns. And so I'm going to enumerate through the samples in test
1136:53 - samples. And then I'm going to create a subplot for each sample. So create a subplot. Because this
1137:02 - is going to create a subplot because it's within the loop. Each time it goes through a new sample,
1137:07 - create a subplot of n rows and calls. And the index it's going to be on is going to be i plus
1137:17 - one, because it can't start at zero. So we just put i plus one in there. What's going on here?
1137:24 - Enumerate. Oh, excuse me. In enumerate, wonderful. So now we're going to plot the target image.
1137:31 - We can go plot dot in show, we're going to get sample dot squeeze. Because we need to remove the
1137:40 - batch dimension. And then we're going to set the C map is equal to gray. What's this telling me
1137:47 - up here? Oh, no, that's correct. Next, we're going to find the prediction label in text form,
1137:57 - because we don't want it in a numeric form, we could do that. But we want to look at things
1138:02 - visually with human readable language, such as sandal for whatever class sandal is, whatever number
1138:08 - class that is. So we're going to set the pred label equals class names. And we're going to index
1138:15 - using the pred classes I value. So right now we're going to plot our sample. We're going to find
1138:22 - its prediction. And now we're going to get the truth label. So we also want this in text form.
1138:30 - And what is the truth label going to be? Well, the truth label is we're going to have to index
1138:35 - using class names and index on that using test labels I. So we're just matching up our indexes
1138:42 - here. Finally, we're going to create a title, create a title for the plot. And now here's what I like
1138:50 - to do as well. If we're getting visual, well, we might as well get really visual, right? So I
1138:54 - think we can change the color of the title text, depending if the prediction is right or wrong.
1138:59 - So I'm going to create a title using an F string, pred is going to be a pred label,
1139:04 - and truth label. We could even plot the prediction probabilities here if we wanted to. That might
1139:10 - be an extension that you might want to try. And so here we're going to check for equality
1139:16 - between pred and truth and change color of title text. So what I mean by this, it's going to be a
1139:26 - lot easier to explain if we just if and doubt coded out. So if the pred label equals the truth
1139:33 - label, so they're equal, I want the plot dot title to be the title text. But I want the font size,
1139:41 - well, the font size can be the same 10. I want the color to equal green. So if they're so green text,
1139:50 - if prediction, same as truth, and else I'm going to set the plot title to have title text font
1140:00 - size equals 10. And the color is going to be red. So does that make sense? All we're doing is we're
1140:07 - enumerating through our test samples that we got up here, test samples that we found randomly from
1140:13 - the test data set. And then each time we're creating a subplot, we're plotting our image,
1140:19 - we're finding the prediction label by indexing on the class names with our pred classes value,
1140:24 - we're getting the truth label, and we're creating a title for the plot that compares the pred label
1140:29 - to the truth. And we're changing the color of the title text, depending if the pred label is
1140:36 - correct or not. So let's see what happens. Did we get it right? Oh, yes, we did. Oh, I'm going to
1140:45 - do one more thing. I want to turn off the accesses, just so we get more real estate. I love these
1140:51 - kind of plots. It helps that our model got all of these predictions right. So look at this,
1140:58 - pred sandal, truth, sandal, pred trouser, truth trouser. So that's pretty darn good, right? See how,
1141:05 - for me, I much appreciate, like, I much prefer visualizing things numbers on a page look good,
1141:10 - but there's something, there's nothing quite like visualizing your machine learning models
1141:15 - predictions, especially when it gets it right. So how about we select some different random samples
1141:19 - up here, we could functionize this as well to do like all of this code in one hit, but that's all
1141:24 - right. We'll be a bit hacky for now. So this is just going to randomly sample with no seed at all.
1141:31 - So your samples might be different to mine, nine different samples. So this time we have an ankle
1141:36 - boot, we'll make some predictions, we'll just step through all of this code here. And oh,
1141:41 - there we go. It got one wrong. So all of these are correct. But this is more interesting as
1141:47 - well is where does your model get things wrong? So it predicted address, but this is a coat.
1141:52 - Now, do you think that this could be potentially address? To me, I could see that as being addressed.
1141:58 - So I kind of understand where the model's coming from there. Let's make some more random predictions.
1142:03 - We might do two more of these before we move on to the next video.
1142:07 - Oh, all correct. We're interested in getting some wrong here. So our model seems to be too good.
1142:16 - All correct again. Okay, one more time. If we don't get any wrong, we're going on to the next
1142:20 - video. But this is just really, oh, there we go. Too wrong. Beautiful. So predicted address,
1142:27 - and that's a shirt. Okay. I can kind of see where the model might have stuffed up there.
1142:31 - It's a little bit long for a shirt for me, but I can still understand that that would be a shirt.
1142:36 - And this is a pullover, but the truth is a coat. So maybe, maybe there's some issues with the labels.
1142:42 - And that's probably what you'll find in a lot of data sets, especially quite large ones.
1142:46 - Just with a sheer law of large numbers, there may be some truth labels in your data sets that
1142:51 - you work with that are wrong. And so that's why I like to see, compare the models predictions
1142:57 - versus the truth on a bunch of random samples to go, you know what, is our models results
1143:02 - better or worse than they actually are. And that's what visualizing helps you do is figure out,
1143:07 - you know what, our model is actually, it says it's good on the accuracy. But when we visualize
1143:13 - the predictions, it's not too good. And vice versa, right? So you can keep playing around with this,
1143:19 - try, look at some more random samples by running this again. We'll do one more for good luck.
1143:24 - And then we'll move on to the next video. We're going to go on to another way. Oh,
1143:29 - see, this is another example. Some labels here could be confusing. And speaking of confusing,
1143:35 - well, that's going to be a spoiler for the next video. But do you see how the prediction is a
1143:40 - t-shirt top, but the truth is a shirt? To me, that label is kind of overlapping. Like, I don't know,
1143:46 - what's the difference between a t-shirt and a shirt? So that's something that you'll find
1143:52 - as you train models is maybe your model is going to tell you about your data as well.
1143:58 - And so we hinted that this is going to be confused. The model is confused between t-shirt top and
1144:04 - shirt. How about we plot a confusion matrix in the next video? I'll see you there.
1144:10 - We're up to a very exciting point in evaluating our machine learning model.
1144:18 - And that is visualizing, visualizing, visualizing. And we saw that in the previous video, our model
1144:25 - kind of gets a little bit confused. And in fact, I would personally get confused at the difference
1144:30 - between t-shirt slash top and a shirt. So these kind of insights into our model predictions
1144:38 - can also give us insights into maybe some of our labels could be improved. And another way to
1144:44 - check that is to make a confusion matrix. So let's do that, making a confusion matrix for further
1144:53 - prediction evaluation. Now, a confusion matrix is another one of my favorite ways of evaluating
1145:00 - a classification model, because that's what we're doing. We're doing multi class classification.
1145:04 - And if you recall, if we go back to section two of the lone pytorch.io book,
1145:11 - and then if we scroll down, we have a section here, more classification evaluation metrics.
1145:16 - So accuracy is probably the gold standard of classification evaluation.
1145:20 - There's precision, there's recall, there's F1 score, and there's a confusion matrix here.
1145:25 - So how about we try to build one of those? I want to get this and copy this.
1145:30 - So, and write down a confusion matrix is a fantastic way of evaluating your classification models
1145:43 - visually. Beautiful. So we're going to break this down. First of all, we need to plot a
1145:52 - confusion matrix. We need to make predictions with our trained model on the test data set.
1145:58 - Number two, we're going to make a confusion matrix. And to do so, we're going to leverage
1146:05 - torch metrics tricks have to figure out how to spell metrics and confusion matrix. So recall
1146:12 - that torch metrics we've touched on this before is a great package torch metrics for a whole
1146:18 - bunch of evaluation metrics of machine learning models in pytorch flavor. So if we find we've
1146:25 - got classification metrics, we've got audio image detection. Look how this is beautiful,
1146:30 - a bunch of different evaluation metrics. And if we go down over here, we've got confusion
1146:34 - matrix. So I only touched on five here, but or six. But if you look at torch metrics, they've got,
1146:43 - how many is that about 25 different classification metrics? So if you want some extra curriculum,
1146:48 - you can read through these. But let's go to confusion matrix. And if we look at some code here,
1146:54 - we've got torch metrics, confusion matrix, we need to pass in number of classes. We can
1147:00 - normalize if we want. And do you notice how this is quite similar to the pytorch documentation?
1147:05 - Well, that's the beautiful thing about torch metrics is that it's created with pytorch in mind.
1147:12 - So let's try out if you wanted to try it out on some
1147:16 - tester code, you could do it here. But since we've already got some of our own code,
1147:19 - let's just bring in this. And then number three is to plot it. We've got another helper package here,
1147:29 - plot the confusion matrix using ML extend. So this is another one of my favorite helper
1147:37 - libraries for machine learning things. It's got a lot of functionality that you can code up
1147:41 - yourself, but you often find yourself coding at a few too many times, such as plotting a confusion
1147:47 - matrix. So if we look up ML extend plot confusion matrix, this is a wonderful library. I believe it was
1147:58 - it was created by Sebastian Rushka, who's a machine learning researcher and also author of
1148:06 - a great book. There he is. Yeah, this is a side note machine learning with pytorch and
1148:11 - scikit loan. I just got this book it just got released in the start of 2022. And it's a great
1148:17 - book. So that's a little side note for learning more about machine learning with pytorch and scikit
1148:22 - loan. So shout out to Sebastian Rushka. Thank you for this package as well. This is going to
1148:27 - just help us plot a confusion matrix like this. So we'll have our predicted labels on the bottom
1148:32 - and our true labels on the side here. But we can just copy this code in here.
1148:36 - Link sorry, and then confusion matrix, we can copy that in here. The thing is that torch
1148:44 - metrics doesn't come with Google Colab. So if you're using Google Colab, I think ML extend does,
1148:51 - but we need a certain version of ML extend that Google Colab doesn't yet have yet. So we actually
1148:58 - need version 0.19.0. But we're going to import those in a second. Let's first make some predictions
1149:05 - across our entire test data set. So previously, we made some predictions only on nine random samples.
1149:13 - So random sample, we selected nine. You could, of course, change this number to make it on more.
1149:19 - But this was only on nine samples. Let's write some code to make predictions across our entire
1149:25 - test data set. So import tqdm.auto for progress bar tracking.
1149:32 - So tqdm.auto. We don't need to re-import it. I believe we've already got it above, but I'm just
1149:37 - going to do it anyway for completeness. And so we're going to make, this is step one, above,
1149:45 - make predictions, make predictions with trained model. Our trained model is model two. So let's
1149:53 - create an empty predictions list. So we can add our predictions to that. We're going to set our
1149:59 - model into evaluation mode. And we're going to set with torch inference mode as our context manager.
1150:06 - And then inside that, let's just build the same sort of code that we used for our testing loop,
1150:12 - except this time we're going to append all of our predictions to a list.
1150:18 - So we're going to iterate through the test data loader. And we can give our tqdm description.
1150:25 - We're going to say making predictions dot dot dot. You'll see what that looks like in a minute.
1150:31 - And here we are going to send the data and targets to target device. So x, y equals x
1150:42 - to device and y to device. Wonderful. And we're going to do the forward pass.
1150:50 - So we're going to create y logit. Remember, the raw outputs of a model with a linear layer at the
1150:56 - end are referred to as logits. And we don't need to calculate the loss, but we want to turn predictions
1151:03 - from logits to prediction probabilities to prediction labels. So we'll set here y pred equals torch
1151:15 - dot softmax. You could actually skip the torch softmax step if you wanted to and just take the
1151:20 - argmax of the logits. But we will just go from prediction probabilities to pred labels for completeness.
1151:27 - So squeeze and we're going to do it across the first dimension or the zeroth dimension. And then
1151:33 - we'll take the argmax of that across the first dimension as well. And a little tidbit. If you
1151:40 - take different dimensions here, you'll probably get different values. So just check the inputs
1151:44 - and outputs of your code to make sure you're using the right dimension here. And so let's go
1151:49 - put predictions on CPU for evaluation. Because if we're going to plot anything, that plot lib will
1151:56 - want them on the CPU. So we're going to append our predictions to y preds, y pred dot CPU.
1152:04 - Beautiful. And because we're going to have a list of different predictions, we can use concatenate
1152:10 - a list of predictions into a tensor. So let's just print out y preds. And so I can show you what
1152:17 - it looks like. And then if we go y pred tensor, this is going to turn our list of predictions
1152:24 - into a single tensor. And then we'll go y pred tensor. And we'll view the first 10. Let's see if this
1152:33 - works. So making predictions. Oh, would you look at that? Okay, so yeah, here's our list of
1152:39 - predictions. A big list of tensors. Right, we don't really want it like that. So if we get rid of
1152:46 - that, and there's our progress bar, it's going through each batch in the test data load, so there's
1152:51 - 313 batches of 32. So if we comment out print y preds, this line here torch dot cat y preds is
1153:00 - going to turn this these tensors into a single tensor, or this list of tensors into a single
1153:07 - tensor concatenate. Now, if we have a look, there we go, beautiful. And if we have a look at the
1153:13 - whole thing, we're making predictions every single time here, but that's all right. They are pretty
1153:17 - quick. There we go. One big long tensor. And then if we check length y pred tensor, there should be
1153:25 - one prediction per test sample. 10,000 beautiful. So now we're going to, we need to install torch
1153:34 - metrics because torch metrics doesn't come with Google Colab at the time of recording. So let
1153:38 - me just show you if we tried to import torch metrics. It doesn't, it might in the future, so just keep
1153:45 - that in mind, it might come with Google Colab because it's a pretty useful package. But let's
1153:50 - now install see if required packages are installed. And if not, install them. So we'll just install
1154:02 - torch metrics. We'll finish off this video by trying to import. We'll set up a try and accept
1154:08 - loop. So Python is going to try import torch metrics and ML extend. I write it like this,
1154:13 - because you may already have to which metrics and ML extend if you're running this code on a local
1154:18 - machine. But if you're running it in Google Colab, which I'm sure many of you are, we are
1154:23 - going to try and import it anyway. And if it doesn't work, we're going to install it.
1154:29 - So ML extend, I'm just going to check the version here because we need version for our plot confusion
1154:35 - matrix function. This one, we need version 0.19.0 or higher. So I'm just going to write a little
1154:43 - statement here. Assert int ML extend dot version. So if these two, if this condition in the try
1154:54 - loop is or try block is accepted, it will skip the next step dot split. And I'm just going to check
1155:02 - the first index string equals is greater than or equal to 19. Otherwise, I'm going to return an
1155:10 - error saying ML extend version should be 0.19.0 or higher. And so let me just show you what this
1155:20 - looks like. If we run this here, string and int, did I not turn it into a string? Oh, excuse me.
1155:32 - There we go. And I don't need that bracket on the end. There we go. So that's what I'm saying.
1155:40 - So this is just saying, hey, the version of ML extend that you have should be 0 or should be
1155:47 - 19 or higher. Because right now Google Colab by default has 14, this may change in the future.
1155:53 - So let's finish off this accept block. If the above condition fails, which it should,
1155:59 - we are going to pip install. So we're going to install this into Google Colab torch metrics.
1156:05 - We're going to do it quietly. And we're also going to pass the U tag for update ML extend.
1156:11 - So import torch metrics, ML extend afterwards, after it's been installed and upgraded. And print,
1156:20 - we're going to go ML extend version, going to go ML extend underscore version. And let's see what
1156:32 - happens if we run this. So we should see, yeah, some installation happening here. This is going
1156:38 - to install torch metrics. Oh, do we not have ML extend the upgraded version? Let's have a look.
1156:45 - We may need to restart our Google Colab instance. Ah, okay, let's take this off. Quiet.
1156:55 - Is this going to tell us to restart Google Colab?
1157:00 - Well, let's restart our runtime. After you've run this cell, if you're using Google Colab,
1157:06 - you may have to restart your runtime to reflect the fact that we have the updated version of ML
1157:11 - extend. So I'm going to restart my runtime now. Otherwise, we won't be able to plot our confusion
1157:19 - matrix. We need 0.19.0. And I'm going to run all of these cells. So I'm going to pause the video
1157:25 - here, run all of the cells by clicking run all. Note, if you run into any errors, you will have
1157:31 - to run those cells manually. And then I'm going to get back down to this cell and make sure that I
1157:35 - have ML extend version 0.1.9. I'll see in a few seconds.
1157:46 - I'm back. And just a little heads up. If you restart your runtime and click run all,
1157:50 - your Colab notebook will stop running cells if it runs into an error. So this is that error we
1157:56 - found in a previous video where our data and model were on different devices. So to skip past that,
1158:01 - we can just jump to the next cell and we can click run after. There we go. And it's going to run all
1158:09 - of the cells after for us. It's going to retrain our models. Everything's going to get rerun.
1158:15 - And then we're going to come right back down to where we were before trying to install the
1158:20 - updated version of ML extend. I'm going to write some more code while our code is running import
1158:25 - ML extend. And then I'm going to just make sure that we've got the right version here. You may
1158:31 - require a runtime restart. You may not. So just try to see after you've run this install of
1158:38 - torch metrics and upgrade of ML extend. See if you can re import ML extend. And if you have the
1158:43 - version 0.19.0 or above, we should be able to run the code. Yeah, there we go. Wonderful.
1158:50 - ML extend 0.19.0. And we've got ML extend version, assert, import. Beautiful. So we've got a lot
1159:02 - of extra code here. In the next video, let's move forward with creating a confusion matrix.
1159:08 - I just wanted to show you how to install and upgrade some packages in Google Colab if you
1159:12 - don't have them. But now we've got predictions across our entire test data set. And we're going
1159:18 - to be moving towards using confusion matrix function here to compare our predictions versus the target
1159:25 - data of our test data set. So I'll see in the next video, let's plot a confusion matrix.
1159:36 - Welcome back. In the last video, we wrote a bunch of code to import some extra libraries that we
1159:40 - need for plotting a confusion matrix. This is really helpful, by the way. Google Colab comes
1159:45 - with a lot of prebuilt installed stuff. But definitely later on down the track, you're going to need
1159:50 - to have some experience installing stuff. And this is just one way that you can do it. And we also
1159:55 - made predictions across our entire test data set. So we've got 10,000 predictions in this tensor.
1160:01 - And what we're going to do with a confusion matrix is confirm or compare these predictions
1160:06 - to the target labels in our test data set. So we've done step number one. And we've prepared
1160:13 - ourselves for step two and three, by installing torch metrics, and installing ML extend or the
1160:20 - later version of ML extend. So now let's go through step two, making a confusion matrix,
1160:25 - and step three plotting that confusion matrix. This is going to look so good. I love how good
1160:30 - confusion matrix is look. So because we've got torch metrics now, we're going to import the
1160:35 - confusion matrix class. And from our ML extend, we're going to go into the plotting module,
1160:42 - and import plot confusion matrix. Recall that the documentation for both of these are
1160:50 - within torch metrics here, and within ML extend here. Let's see what they look like. So number two
1160:58 - is set up confusion matrix instance, and compare predictions to targets. That's what evaluating a
1161:07 - model is, right? Comparing our models predictions to the target predictions. So I'm going to set
1161:11 - up a confusion matrix under the variable conf mat, then I'm going to call the confusion matrix class
1161:18 - from torch metrics. And to set up an instance of it, I need to pass in the number of classes that
1161:24 - we have. So because we have 10 classes, they are all contained within class names. Recall that
1161:31 - class names is a list of all of the different classes that we're working with. So I'm just going
1161:36 - to pass in the number of classes as the length of our class names. And then I can use that
1161:41 - conf mat instance, confusion matrix instance, to create a confusion matrix tensor by passing
1161:48 - into conf mat, which is what I've just created up here. Conf mat, just like we do with our loss
1161:55 - function, I'm going to pass in preds equals our Y pred tensor, which is just above Y pred tensor
1162:03 - that we calculated all of the predictions on the test data set. There we go. That's our preds.
1162:10 - And our target is going to be equal to test data dot targets. And this is our test data data set
1162:18 - that we've seen before. So if we go test data and press tab, we've got a bunch of different
1162:24 - attributes, we can get the classes. And of course, we can get the targets, which is the labels.
1162:32 - PyTorch calls labels targets. I usually refer to them as labels, but the target is the test data
1162:38 - target. So we want to compare our models predictions on the test data set to our test data targets.
1162:44 - And so let's keep going forward. We're up to step number three now. So this is going to create
1162:49 - our confusion matrix tensor. Oh, let's see what that looks like, actually. Conf mat tensor.
1162:58 - Oh, okay. So we've got a fair bit going on here. But let's turn this into a pretty version of this.
1163:06 - So along the bottom is going to be our predicted labels. And along the side here is going to be
1163:12 - our true labels. But this is where the power of ML extend comes in. We're going to plot our
1163:17 - confusion matrix. So let's create a figure and an axes. We're going to call the function plot
1163:25 - confusion matrix that we've just imported above. And we're going to pass in our conf mat equals
1163:32 - our conf mat tensor. But because we're working with map plot lib, it'll want it as NumPy.
1163:39 - So I'm just going to write here, map plot lib likes working with NumPy. And we're going to
1163:47 - pass in the class names so that we get labels for each of our rows and columns. Class names,
1163:53 - this is just a list of our text based class names. And then I'm going to set the fig size
1163:58 - to my favorite hand and poker, which is 10, seven. Also happens to be a good dimension for
1164:05 - Google Colab. Look at that. Oh, that is something beautiful to see. Now a confusion matrix. The
1164:12 - ideal confusion matrix will have all of the diagonal rows darkened with all of the values
1164:18 - and no values here, no values here. Because that means that the predicted label lines up with the
1164:23 - true label. So in our case, we have definitely a very dark diagonal here. But let's dive into
1164:29 - some of the highest numbers here. It looks like our model is predicting shirt when the true label
1164:34 - is actually t shirt slash top. So that is reflective of what we saw before. Do we still have that
1164:40 - image there? Okay, we don't have an image there. But in a previous video, we saw that when we plotted
1164:46 - our predictions, the model predicted t shirt slash top when it was actually a shirt. And of course,
1164:52 - vice versa. So what's another one here? Looks like our model is predicting shirt when it's
1164:58 - actually a coat. And now this is something that you can use to visually inspect your data to see
1165:05 - if the the errors that your model is making make sense from a visual perspective. So it's getting
1165:12 - confused by predicting pull over when the actual label is coat, predicting pull over when the
1165:16 - actual label is shirt. So a lot of these things clothing wise and data wise may in fact look
1165:22 - quite the same. Here's a relatively large one as well. It's predicting sneaker when it should be
1165:27 - an ankle boot. So it's confusing two different types of shoes there. So this is just a way to
1165:33 - further evaluate your model and start to go. Hmm, maybe our labels are a little bit confusing.
1165:38 - Could we expand them a little bit more? So keep that in mind, a confusion matrix is one of the
1165:43 - most powerful ways to visualize your classification model predictions. And a really, really, really
1165:50 - helpful way of creating one is to use torch metrics confusion matrix. And to plot it,
1165:56 - you can use plot confusion matrix from ML extend. However, if you're using Google Colab for these,
1166:02 - you may need to import them or install them. So that's a confusion matrix. If you'd like
1166:08 - more classification metrics, you've got them here. And you've got, of course, more in torch
1166:13 - metrics. So give that a look. I think in the next video, we've done a fair bit of evaluation.
1166:20 - Where are we up to in our workflow? I believe it's time we saved and loaded our best trained model.
1166:25 - So let's give that a go. I'll see you in the next video.
1166:31 - In the last video, we created a beautiful confusion matrix with the power of torch metrics
1166:37 - and ML extend. But now it's time to save and load our best model. Because if we, if we evaluated it,
1166:44 - our convolutional neural network and go, you know what, this model is pretty good. Let's export
1166:48 - it to a file so we can use it somewhere else. Let's see how we do that. And by the way, if we go into
1166:54 - our keynote, we've got a value at model torch metrics. We've been through this a fair few times
1167:02 - now. We've improved through experimentation. We haven't used tensor board yet, but that'll be
1167:06 - in a later video and save and reload your trained model. So here's where we're up to. If we've gone
1167:12 - through all these steps enough times and we're like, you know what, let's save our model so we
1167:16 - can use it elsewhere. And we can reload it in to make sure that it's, it's saved correctly.
1167:21 - Let's go through with this step. We want number 11. We're going to go save and load
1167:26 - best performing model. You may have already done this before. So if you've been through the other
1167:31 - parts of the course, you definitely have. So if you want to give that a go, pause the video now
1167:35 - and try it out yourself. I believe we did it in notebook number one. We have here we go,
1167:43 - saving and loading a pie torch model. You can go through this section of section number one
1167:48 - on your own and see if you can do it. Otherwise, let's code it out together. So I'm going to start
1167:53 - from with importing path from path lib, because I like to create a model directory path.
1168:01 - So create model directory path. So my model path is going to be set equal to path. And I'm going
1168:08 - to save it to models. This is where I want to, I want to create file over here called models
1168:14 - and save my models to their model path dot MKD for make directory parents. Yes, I wanted to make
1168:22 - the parent directories if they don't exist and exist. Okay. Also equals true. So if we try to
1168:28 - create it, but it's already existing, we're not going to get an error. That's fine. And next,
1168:33 - we're going to create a model save path. Just going to add some code cells here. So we have
1168:38 - more space. Let's pass in here a model name. Going to set this equal to, since we're on section three,
1168:48 - I'm going to call this O three pie torch, computer vision, model two is our best model. And I'm going
1168:56 - to save it to PTH for pie torch. You can also save it to dot PT. I like to use PTH. And we're
1169:04 - going to go model save path equal model path slash model name. So now if we have a look at this,
1169:13 - we're going to have a path called model save path. But it's going to be a POSIX path in models
1169:20 - O three pie torch computer vision, model two dot PTH. And if we have a look over here,
1169:25 - we should have, yeah, we have a models directory now. That's not going to have anything in it at
1169:30 - the moment. We've got our data directory that we had before there's fashion MNIST. This is a good
1169:34 - way to start setting up your directories, break them down data models, helper function files,
1169:40 - etc. But let's keep going. Let's save, save the model state dict. We're going to go print,
1169:49 - saving model to just going to give us some information about what's happening. Model save
1169:56 - path. And we can save a model by calling torch dot save. And we pass in the object that we want
1170:03 - to save using the object parameter, OBJ. When we get a doc string there, we're going to go model
1170:10 - two, we want to save the state dict, recall that the state dict is going to be our models what
1170:17 - our models learned parameters on the data set, so that all the weights and biases and all that
1170:21 - sort of jazz. Beautiful. So when we first created model two, these were all random numbers. They've
1170:29 - been or since we trained model two on our training data, these have all been updated to represent
1170:34 - the training images. And we can leverage these later on, as you've seen before, to make predictions.
1170:40 - So I'm not going to go through all those, but that's what we're saving. And the file path is
1170:45 - going to be our model save path. So let's run this and see what happens. Beautiful. We're saving our
1170:52 - model to our model directory. And now let's have a look in here. Do we have a model? Yes, we do.
1170:58 - Beautiful. So that's how quickly we can save a model. Of course, you can customize what the name is,
1171:03 - where you save it, et cetera, et cetera. Now, let's see what happens when we load it in.
1171:09 - So create a new instance, because we only saved the state dict of model two,
1171:14 - we need to create a new instance of our model two, or how it was created, which was with
1171:20 - our class fashion MNIST V two. If we saved the whole model, we could just import it to a new
1171:27 - variable. But I'll let you read back more on that on the different ways of saving a model in here.
1171:32 - There's also a link to the pytorch documentation would highly recommend that. But let's see it in
1171:38 - action, we need to create a new instance of our fashion MNIST model V two, which is our convolution
1171:45 - or neural network. So I'm going to set the manual seed. That way when we create a new instance,
1171:50 - it's instantiated with the same random numbers. So we're going to set up loaded model two,
1171:56 - equals fashion MNIST V two. And it's important here that we set it up with the same parameters
1172:04 - as our original saved model. So fashion MNIST V two. Oh, we've got a typo here.
1172:11 - I'll fashion MNIST model V two. Wonderful. So the input shape is going to be one,
1172:17 - because that is the number of color channels in our test, in our images, test image dot shape.
1172:22 - Do we still have a test image should be? Oh, well, we've created a different one, but our image size,
1172:29 - our image shape is 12828 image shape for color channels height width. Then we create it with
1172:39 - hidden units, we use 10 for hidden units. So we can just set that here. This is important,
1172:43 - they just have to otherwise if the shapes aren't the same, what are we going to get? We're going
1172:46 - to get a shape mismatch error. And our output shape is what is also going to be 10 or
1172:52 - length of class names. If you have the class names variable instantiated, that is. So we're
1172:59 - going to load in the saved state dict, the one that we just saved. So we can go loaded model two,
1173:07 - dot load state dict. And we can pass in torch dot load in here. And the file that we want to load
1173:15 - or the file path is model save path up here. This is why I like to just save my path variables
1173:22 - to a variable so that I can just use them later on, instead of re typing out this all the time,
1173:28 - which is definitely prone to errors. So we're going to send the model to the target device.
1173:34 - Loaded model two dot two device. Beautiful. Let's see what happens here.
1173:46 - Wonderful. So let's now evaluate the loaded model. So evaluate loaded model. The results
1173:54 - should be very much the same as our model two results. So model two results.
1174:00 - So this is what we're looking for. We want to make sure that our saved model saved these results
1174:07 - pretty closely. Now I say pretty closely because you might find some discrepancies in this lower
1174:12 - these lower decimals here, just because of the way files get saved and something gets lost,
1174:18 - et cetera, et cetera. So that's just to do with precision and computing. But as long as the first
1174:24 - few numbers are quite similar, well, then we're all gravy. So let's go torch manual seed.
1174:33 - Remember, evaluating a model is almost as well is just as important as training a model. So this
1174:39 - is what we're doing. We're making sure our model save correctly. Before we deployed it, if it didn't
1174:44 - if we deployed it, it didn't save correctly. Well, then we'd get our we would get less than ideal
1174:49 - results, wouldn't we? So model equals loaded model two, we're going to use our same
1174:54 - of our model function, by the way. And of course, we're going to evaluate it on the same test data
1175:00 - set that we've been using test data loader. And we're going to create a loss function or just
1175:05 - put in our loss function that we've created before. And our accuracy function is the accuracy
1175:10 - function we've been using throughout this notebook. So now let's check out loaded model two results.
1175:15 - They should be quite similar to this one. We're going to make some predictions. And then if we go
1175:20 - down, do we have the same numbers? Yes, we do. So we have five, six, eight, two, nine, five, six,
1175:28 - eight, two, nine, wonderful. And three, one, three, five, eight, three, one, three, five, eight,
1175:33 - beautiful. It looks like our loaded model gets the same results as our previously trained model
1175:41 - before we even saved it. And if you wanted to check if they were close, you can also use torch
1175:47 - dot is close, check if model results, if you wanted to check if they were close programmatically,
1175:52 - that is, because we just looked at these visually, check if model results are close to each other.
1175:58 - Now we can go torch is close, we're going to pass in torch dot tensor, we have to turn these
1176:04 - values into a tensor. We're going to go model two results. And we'll compare the model loss.
1176:13 - How about we do that? We want to make sure the loss values are the same. Or very close,
1176:18 - that is with torch dot is close. Torch dot tensor model. Or we want this one to be loaded model two
1176:25 - results. Model loss. Another bracket on the end there. And we'll see how close they are true,
1176:35 - wonderful. Now, if this doesn't return true, you can also adjust the tolerance levels in here.
1176:41 - So we go atal equals, this is going to be the absolute tolerance. So if we do one to the negative
1176:47 - eight, it's saying like, Hey, we need to make sure our results are basically the same up to eight
1176:53 - decimal points. That's probably quite low. I would say just make sure they're at least within two.
1177:00 - But if you're getting discrepancies here between your saved model and your loaded model, or sorry,
1177:05 - this model here, the original one and your loaded model, if they are quite large, so they're like
1177:10 - more than a few decimal points off in this column or even here, I'd go back through your code and
1177:15 - make sure that your model is saving correctly, make sure you've got random seeds set up. But
1177:19 - if they're pretty close, like in terms of within three or two decimal places of each other,
1177:24 - well, then I'd say that's that's close enough. But you can also adjust the tolerance level here
1177:29 - to check if your model results are close enough, programmatically. Wow, we have covered a fair bit
1177:37 - here. We've gone through this entire workflow for a computer vision problem. Let's in the next
1177:43 - video, I think that's enough code for this section, section three, pytorch computer vision. I've got
1177:49 - some exercises and some extra curriculum lined up for you. So let's have a look at those in the
1177:53 - next video. I'll see you there. My goodness. Look how much computer vision pytorch code
1178:03 - we've written together. We started off right up the top. We looked at the reference notebook and
1178:08 - the online book. We checked out computer vision libraries and pytorch, the main one being torch
1178:12 - vision. Then we got a data set, namely the fashion MNIST data set. There are a bunch more data sets
1178:17 - that we could have looked at. And in fact, I'd encourage you to try some out in the torch vision
1178:21 - dot data sets, use all of the steps that we've done here to try it on another data set. We repaired
1178:28 - our data loaders. So turned our data into batches. We built a baseline model, which is an important
1178:34 - step in machine learning, because the baseline model is usually relatively simple. And it's going
1178:39 - to serve as a baseline that you're going to try and improve upon through just go back to the keynote
1178:45 - through various experiments. We then made predictions with model zero. We evaluated it.
1178:53 - We timed our predictions to see if running our models on the GPU was faster when we learned that
1178:57 - sometimes a GPU won't necessarily speed up code if it's a relatively small data set because of the
1179:02 - overheads between copying data from CPU to GPU. We tried a model with non-linearity and we saw that
1179:09 - it didn't really improve upon our baseline model. But then we brought in the big guns, a convolutional
1179:15 - neural network, replicating the CNN explainer website. And by gosh, didn't we spend a lot of time
1179:21 - here? I'd encourage you as part of your extra curriculum to go through this again and again.
1179:27 - I still even come back to refer to it too. I referred to it a lot making the materials for this
1179:32 - video section and this code section. So be sure to go back and check out the CNN explainer website
1179:37 - for more of what's going on behind the scenes of your CNNs. But we coded one using pure pytorch.
1179:44 - That is amazing. We compared our model results across different experiments. We found that our
1179:50 - convolutional neural network did the best, although it took a little bit longer to train. And we also
1179:55 - learned that the training time values will definitely vary depending on the hardware you're using.
1180:01 - So that's just something to keep in mind. We made an evaluated random predictions with our best
1180:07 - model, which is an important step in visualizing, visualizing, visualizing your model's predictions,
1180:13 - because you could get evaluation metrics. But until you start to actually visualize what's going on,
1180:18 - well, in my case, that's how I best understand what my model is thinking. We saw a confusion
1180:24 - matrix using two different libraries torch metrics and ML extend a great way to evaluate
1180:30 - your classification models. And we saw how to save and load the best performing model to file
1180:36 - and made sure that the results of our saved model weren't too different from the model that
1180:41 - we trained within the notebook. So now it is time I'd love for you to practice what
1180:49 - you've gone through. This is actually really exciting now because you've gone through an end-to-end
1180:52 - computer vision problem. I've got some exercises prepared. If you go to the learn pytorch.io website
1180:58 - in section 03, scroll down. You can read through all of this. This is all the materials that we've
1181:04 - just covered in pure code. There's a lot of pictures in this notebook too that are helpful to learn
1181:09 - things what's going on. We have some exercises here. So all of the exercises are focused on
1181:14 - practicing the code and the sections above. We have two resources. We also have some extra
1181:19 - curriculum that I've put together. If you want an in-depth understanding of what's going on
1181:23 - behind the scenes in the convolutional neural networks, because we've focused a lot on code,
1181:28 - I'd highly recommend MIT's induction to deep computer vision lecture. You can spend 10 minutes
1181:34 - clicking through the different options in the pytorch vision library, torch vision, look up most
1181:39 - common convolutional neural networks in the torch vision model library, and then for a larger number
1181:44 - of pre-trained pytorch computer vision models, and if you get deeper into computer vision,
1181:48 - you're probably going to run into the torch image models library, otherwise known as 10,
1181:54 - but I'm going to leave that as extra curriculum. I'm going to just link this exercises section
1181:59 - here. Again, it's at learn pytorch.io in the exercises section. We come down. There we go.
1182:07 - But there is also resource here, an exercise template notebook. So we've got one, what are
1182:13 - three areas in industry where computer vision is being currently used. Now this is in the
1182:17 - pytorch deep learning repo, extras exercises number three. I've put out some template code here
1182:25 - for you to fill in these different sections. So some of them are code related. Some of them
1182:30 - are just text based, but they should all be able to be completed by referencing what we've gone
1182:35 - through in this notebook here. And just as one more, if we go back to pytorch deep learning,
1182:43 - this will probably be updated by the time you get here, you can always find the exercise in
1182:47 - extra curriculum by going computer vision, go to exercise in extra curriculum, or if we go into
1182:53 - the extras file, and then we go to solutions. I've now also started to add video walkthroughs
1183:00 - of each of the solutions. So this is me going through each of the exercises myself and coding
1183:07 - them. And so you'll get to see the unedited videos. So they're just one long live stream.
1183:12 - And I've done some for O2, O3, and O4, and there will be more here by the time you watch this video.
1183:18 - But if you'd like to see how I figure out the solutions to the exercises, you can watch those
1183:22 - videos and go through them yourself. But first and foremost, I would highly recommend trying out
1183:28 - the exercises on your own first. And then if you get stuck, refer to the notebook here,
1183:34 - refer to the pytorch documentation. And finally, you can check out what I would have coded as a
1183:40 - potential solution. So there's number three, computer vision, exercise solutions. So congratulations
1183:47 - on going through the pytorch computer vision section. I'll see you in the next section. We're
1183:52 - going to look at pytorch custom data sets, but no spoilers. I'll see you soon.
1184:04 - Hello, hello, hello, and welcome to section number four of the Learn pytorch for deep learning course.
1184:11 - We have custom data sets with pytorch. Now, before we dive into what we're going to cover,
1184:20 - let's answer the most important question. Where can you get help? Now, we've been through this
1184:25 - a few times now, but it's important to reiterate. Follow along with the code as best you can. We're
1184:31 - going to be writing a bunch of pytorch code. Remember the motto, if and out, run the code.
1184:37 - That's in line with try it for yourself. If you'd like to read or read the doxtring,
1184:42 - you can press shift command plus space in Google Colab. Or if you're on Windows, command might
1184:47 - be control. Then if you're still stuck, you can search for it. Two of the resources you will
1184:52 - probably come across is stack overflow or the wonderful pytorch documentation, which we've
1184:57 - had a lot of experience with so far. Then, of course, try again, go back through your code,
1185:03 - if and out, code it out, or if and out, run the code. And then finally, if you're still stuck,
1185:09 - ask a question on the pytorch deep learning discussions GitHub page. So if I click this link,
1185:16 - we come to Mr. D Burke slash pytorch deep learning, the URL is here. We've seen this before. If you
1185:22 - have a trouble or a problem with any of the course, you can start a discussion and you can
1185:28 - select the category, general ideas, polls, Q and A, and then we can go here, video,
1185:34 - put the video number in. So 99, for example, my code doesn't do what I'd like it to. So say
1185:43 - your problem and then come in here, write some code here, code here, and then my question is
1185:54 - something, something, something, click start discussion, and then we can help out. And then if
1185:59 - we come back to the discussions, of course, you can search for what's going on. So if you have an
1186:03 - error and you feel like someone else might have seen this error, you can, of course, search it
1186:07 - and find out what's happening. Now, I just want to highlight again, the resources for this course
1186:12 - are at learn pytorch.io. We are up to section four. This is a beautiful online book version of
1186:17 - all the materials we are going to cover in this section. So spoiler alert, you can use this as a
1186:23 - reference. And then, of course, in the GitHub, we have the same notebook here, pytorch custom
1186:29 - data sets. This is the ground truth notebook. So check that out if you get stuck. So I'm just
1186:35 - going to exit out of this. We've got pytorch custom data sets at learn pytorch.io. And then,
1186:40 - of course, the discussions tab for the Q&A. Now, if we jump back to the keynote, what do we have?
1186:46 - We might be asking, what is a custom data set? Now, we've built a fair few pytorch deeplining
1186:53 - neural networks so far on various data sets, such as fashion MNIST. But you might be wondering,
1186:59 - hey, I've got my own data set, or I'm working on my own problem. Can I build a model with pytorch
1187:05 - to predict on that data set? And the answer is yes. However, you do have to go through a few
1187:11 - pre processing steps to make that data set compatible with pytorch. And that's what we're
1187:17 - going to be covering in this section. And so I'd like to highlight the pytorch domain libraries.
1187:23 - Now, we've had a little bit of experience before with torch vision, such as if we wanted to classify
1187:28 - whether a photo was a pizza, steak, or sushi. So a computer vision image classification problem.
1187:35 - Now, there's also text, such as if these reviews are positive or negative. And you can use torch
1187:43 - text for that. But again, these are only just one problem within the vision space within the text
1187:48 - space. I want you to just understand that if you have any type of vision data, you probably
1187:54 - want to look into torch vision. And if you have any kind of text data, you probably want to look
1187:59 - into torch text. And then if you have audio, such as if you wanted to classify what song was playing,
1188:05 - this is what Shazam does, it uses the input sound of some sort of music, and then runs a neural network
1188:12 - over it to classify it to a certain song, you can look into torch audio for that. And then if you'd
1188:18 - like to recommend something such as you have an online store, or if your Netflix or something
1188:23 - like that, and you'd like to have a homepage that updates for recommendations, you'd like to look
1188:29 - into torch rec, which stands for recommendation system. And so this is just something to keep in mind.
1188:36 - Because each of these domain libraries has a data sets module that helps you work with different
1188:43 - data sets from different domains. And so different domain libraries contain data loading functions
1188:49 - for different data sources. So torch vision, let's just go into the next slide, we have problem space
1188:56 - vision for pre built data sets, so existing data sets like we've seen with fashion MNIST,
1189:02 - as well as functions to load your own vision data sets, you want to look into torch vision
1189:07 - dot data sets. So if we click on this, we have built in data sets, this is the pie torch documentation.
1189:14 - And if we go here, we have torch audio, torch text, torch vision, torch rec, torch data. Now,
1189:20 - at the time of recording, which is April 2022, this is torch data is currently in beta. But it's
1189:26 - going to be updated over time. So just keep this in mind, updated over time to add even more ways
1189:32 - to load different data resources. But for now, we're just going to get familiar with torch vision
1189:38 - data sets. If we went into torch text, there's another torch text dot data sets. And then if we
1189:45 - went into torch audio, we have torch audio dot data sets. And so you're noticing a trend here
1189:52 - that depending on the domain you're working in, whether it be vision, text, audio, or your data
1189:57 - is recommendation data, you'll probably want to look into its custom library within pie torch.
1190:03 - And of course, the bonus is torch data. It contains many different helper functions for loading data,
1190:09 - and is currently in beta as of April 2022. So 2022. So the by the time you watch this torch data
1190:14 - may be out of beta. And then that should be something that's extra curriculum on top of what we're
1190:20 - going to cover in this section. So let's keep going. So this is what we're going to work towards
1190:26 - building food vision mini. So we're going to load some data, namely some images of pizza,
1190:35 - sushi, and steak from the food 101 data set, we're going to build an image classification model,
1190:42 - such as the model that might power a food vision recognition app or a food image recognition app.
1190:48 - And then we're going to see if it can classify an image of pizza as pizza, an image of sushi as sushi,
1190:55 - and an image of steak as steak. So this is what we're going to focus on. We want to load,
1191:00 - say we had images existing already of pizza, sushi, and steak, we want to write some code
1191:06 - to load these images of food. So our own custom data set for building this food vision mini model,
1191:13 - which is quite similar to if you go to this is the project I'm working on personally,
1191:17 - neutrify.app. This is a food image recognition model. Here we go. So it's still a work in progress as
1191:27 - I'm going through it, but you can upload an image of food and neutrify will try to classify
1191:33 - what type of food it is. So do we have steak? There we go. Let's upload that. Beautiful steak.
1191:41 - So we're going to be building a similar model to what powers neutrify. And then there's the
1191:45 - macro nutrients for the steak. If you'd like to find out how it works, I've got all the links here,
1191:50 - but that's at neutrify.app. So let's keep pushing forward. We'll go back to the keynote.
1191:57 - This is what we're working towards. As I said, we want to load these images into PyTorch so that
1192:02 - we can build a model. We've already built a computer vision model. So we want to figure out
1192:07 - how do we get our own data into that computer vision model. And so of course we'll be adhering
1192:13 - to our PyTorch workflow that we've used a few times now. So we're going to learn how to load a
1192:20 - data set with our own custom data rather than an existing data set within PyTorch. We'll see how
1192:26 - we can build a model to fit our own custom data set. We'll go through all the steps that's involved
1192:31 - in training a model such as picking a loss function and an optimizer. We'll build a training loop.
1192:36 - We'll evaluate our model. We'll improve through experimentation. And then we can see save and reloading
1192:44 - our model. But we're also going to practice predicting on our own custom data, which is a very,
1192:50 - very important step whenever training your own models. So what we're going to cover broadly,
1192:57 - we're going to get a custom data set with PyTorch. As we said, we're going to become one with the
1193:01 - data. In other words, preparing and visualizing it. We'll learn how to transform data for use with
1193:07 - a model, very important step. We'll see how we can load custom data with pre-built functions
1193:12 - and our own custom functions. We'll build a computer vision model, aka food vision mini,
1193:18 - to classify pizza, steak, and sushi images. So a multi-class classification model. We'll compare
1193:24 - models with and without data augmentation. We haven't covered that yet, but we will later on.
1193:29 - And finally, we'll see how we can, as I said, make predictions on custom data. So this means
1193:35 - data that's not within our training or our test data set. And how are we going to do it? Well,
1193:42 - we could do it cooks or chemists. But I like to treat machine learning as a little bit of an art,
1193:47 - so we're going to be cooking up lots of code. With that being said, I'll see you in Google Colab.
1193:54 - Let's code. Welcome back to the PyTorch cooking show. Let's now learn how we can cook up some
1194:03 - custom data sets. I'm going to jump into Google Colab. So colab.research.google.com.
1194:12 - And I'm going to click new notebook. I'm just going to make sure this is zoomed in enough for
1194:18 - the video. Wonderful. So I'm going to rename this notebook 04 because we're up to section 04.
1194:27 - And I'm going to call it PyTorch custom data sets underscore video because this is going to be one
1194:33 - of the video notebooks, which has all the code that I write during the videos, which is of course
1194:37 - contained within the video notebooks folder on the PyTorch deep learning repo. So if you'd like
1194:44 - the resource or the ground truth notebook for this, I'm going to just put a heading here.
1194:49 - 04 PyTorch custom data sets video notebook, make that bigger, and then put resources.
1195:01 - So book version of the course materials for 04. We'll go there, and then we'll go ground truth
1195:12 - version of notebook 04, which will be the reference notebook that we're going to use
1195:17 - for this section. Come into PyTorch custom data sets. And then we can put that in there.
1195:25 - Wonderful. So the whole synopsis of this custom data sets section is we've used some data sets
1195:34 - with PyTorch before, but how do you get your own data into PyTorch? Because that's what you
1195:44 - want to start working on, right? You want to start working on problems of your own. You want to
1195:49 - come into any sort of data that you've never worked with before, and you want to figure out how do
1195:53 - you get that into PyTorch. So one of the ways to do so is via custom data sets. And then I want
1196:03 - to put a note down here. So we're going to go zero section zero is going to be importing
1196:09 - PyTorch and setting up device agnostic code. But I want to just stress here that domain libraries.
1196:23 - So just to reiterate what we went through last video. So depending on what you're working on,
1196:31 - whether it be vision, text, audio, recommendation, something like that, you'll want to look into
1196:41 - each of the PyTorch domain libraries for existing data loader or data loading functions and
1196:52 - customizable data loading functions. So just keep that in mind. We've seen some of them. So if we
1197:00 - go torch vision, which is what we're going to be looking at, torch vision, we've got data sets,
1197:07 - and we've got documentation, we've got data sets for each of the other domain libraries here as
1197:12 - well. So if you're working on a text problem, it's going to be a similar set of steps to what
1197:18 - we're going to do with our vision problem when we build food vision mini. What we have is a data
1197:23 - set that exists somewhere. And what we want to do is bring that into PyTorch so we can build a
1197:28 - model with it. So let's import the libraries that we need. So we're going to import torch and
1197:35 - we'll probably import an N. So we'll import that from PyTorch. And I'm just going to check the
1197:42 - torch version here. So note, we need PyTorch 1.10.0 plus is required for this course. So if you're
1197:54 - using Google Colab at a later date, you may have a later version of PyTorch. I'm just going to
1197:59 - show you what version I'm using. Just going to let this load. We're going to get this ready.
1198:08 - We're going to also set up device agnostic code right from the start this time because this is
1198:13 - best practice with PyTorch. So this way, if we have a CUDA device available, our model is going
1198:19 - to use that CUDA device. And our data is going to be on that CUDA device. So there we go. Wonderful.
1198:25 - We've got PyTorch 1.10.0 plus CUDA. 111. Maybe that's 11.1. So let's check if CUDA.is available.
1198:34 - Now, I'm using Google Colab. We haven't set up a GPU yet. So it probably won't be available yet.
1198:40 - Let's have a look. Wonderful. So because we've started a new Colab instance, it's going to use
1198:49 - the CPU by default. So how do we change that? We come up to runtime, change runtime type. I'm going
1198:56 - to go hard there accelerator GPU. We've done this a few times now. I am paying for Google Colab Pro.
1199:02 - So one of the benefits of that is that it our Google Colab reserves faster GPUs for you. You do
1199:09 - don't need Google Colab Pro. As I've said to complete this course, you can use the free version,
1199:15 - but just recall Google Colab Pro tends to give you a better GPU just because GPUs aren't free.
1199:23 - Wonderful. So now we've got access to a GPU CUDA. What GPU do I have?
1199:30 - Nvidia SMI. I have a Tesla P100 with 16 gigabytes of memory, which will be more than enough for
1199:36 - the problem that we're going to work on in this video. So I believe that's enough to cover for
1199:43 - the first coding video. Let's in the next section, we are working with custom datasets after all.
1199:49 - Let's in the next video. Let's get some data, hey.
1199:55 - Now, as I said in the last video, we can't cover custom datasets without some data. So let's get
1200:01 - some data and just remind ourselves what we're going to build. And that is food vision mini.
1200:07 - So we need a way of getting some food images. And if we go back to Google Chrome,
1200:14 - torch vision datasets has plenty of built-in datasets. And one of them is the food 101 dataset.
1200:22 - Food 101. So if we go in here, this is going to take us to the original food 101 website.
1200:30 - So food 101 is 101 different classes of food. It has a challenging dataset of 101 different
1200:37 - food categories with 101,000 images. So that's a quite a beefy dataset. And so for each class,
1200:44 - 250 manually reviewed test images are provided. So we have per class, 101 classes, 250 testing
1200:52 - images, and we have 750 training images. Now, we could start working on this entire dataset
1201:00 - straight from the get go. But to practice, I've created a smaller subset of this dataset,
1201:06 - and I'd encourage you to do the same with your own problems. Start small and upgrade when necessary.
1201:13 - So I've reduced the number of categories to three and the number of images to 10%.
1201:18 - Now, you could reduce this to an arbitrary amount, but I've just decided three is enough to begin with
1201:26 - and 10% of the data. And then if it works, hey, you could upscale that on your own accord.
1201:32 - And so I just want to show you the notebook that I use to create this dataset and as extra curriculum,
1201:38 - you could go through this notebook. So if we go into extras, 04 custom data creation,
1201:43 - this is just how I created the subset of data. So making a dataset to use with notebook number
1201:50 - four, I created it in custom image data set or image classification style. So we have a top level
1201:58 - folder of pizza, steak, and sushi. We have a training directory with pizza, steak, and sushi
1202:03 - images. And we have a test directory with pizza, steak, and sushi images as well. So you can go
1202:09 - through that to check it out how it was made. But now, oh, and also, if you go to loan pytorch.io
1202:16 - section four, there's more information here about what food 101 is. So get data. Here we go.
1202:23 - There's all the information about food 101. There's some resources, the original food 101 data set,
1202:28 - torch vision data sets, food 101, how I created this data set, and actually downloading the data.
1202:35 - But now we're going to write some code, because this data set, the smaller version that I've created
1202:40 - is on the pytorch deep learning repo, under data. And then we have pizza, steak, sushi.zip.
1202:46 - Oh, this one is a little spoiler for one of the exercises for this section. But you'll see that
1202:53 - later. Let's go in here. Let's now write some code to get this data set from GitHub,
1203:01 - pizza, steak, sushi.zip. And then we'll explore it, we'll become one with the data.
1203:05 - So I just want to write down here, our data set is a subset of the food 101 data set.
1203:14 - Food 101 starts with 101 different classes of food. So we could definitely build computer
1203:23 - vision models for 101 classes, but we're going to start smaller. Our data set starts with three
1203:29 - classes of food, and only 10% of the images. So what's right here? And 1000 images per class,
1203:42 - which is 750 training, 250 testing. And we have about 75 training images per class,
1203:54 - and about 25 testing images per class. So why do this? When starting out ML projects,
1204:05 - it's important to try things on a small scale and then increase the scale when necessary.
1204:15 - The whole point is to speed up how fast you can experiment.
1204:21 - Because there's no point trying to experiment on things that if we try to train on 100,000
1204:27 - images to begin with, our models might train take half an hour to train at a time. So at the
1204:32 - beginning, we want to increase the rate that we experiment at. And so let's get some data.
1204:39 - We're going to import requests so that we can request something from GitHub to download this
1204:45 - URL here. Then we're also going to import zip file from Python, because our data is in the form
1204:52 - of a zip file right now. Then we're going to get path lib, because I like to use paths whenever
1204:57 - I'm dealing with file paths or directory paths. So now let's set up a path to a data folder.
1205:05 - And this, of course, will depend on where your data set lives, what you'd like to do. But I
1205:10 - typically like to create a folder over here called data. And that's just going to store all of my
1205:15 - data for whatever project I'm working on. So data path equals path data. And then we're going to go
1205:24 - image path equals data path slash pizza steak sushi. That's how we're going to have images
1205:34 - from those three classes. Pizza steak and sushi are three of the classes out of the 101 in food
1205:40 - 101. So if the image folder doesn't exist, so if our data folder already exists, we don't want to
1205:48 - redownload it. But if it doesn't exist, we want to download it and unzip it. So if image path
1205:55 - is der, so we want to print out the image path directory already exists skipping download.
1206:09 - And then if it doesn't exist, we want to print image path does not exist, creating one. Beautiful.
1206:19 - And so we're going to go image path dot mk der to make a directory. We want to make its parents
1206:25 - if we need to. So the parent directories and we want to pass exist, okay, equals true. So we don't
1206:30 - get any errors if it already exists. And so then we can write some code. I just want to show you
1206:36 - what this does if we run it. So our target directory data slash pizza steak sushi does not exist.
1206:44 - It's creating one. So then we have now data and inside pizza steak sushi. Wonderful. But we're
1206:51 - going to fill this up with some images so that we have some data to work with. And then the whole
1206:55 - premise of this entire section will be loading this data of just images into PyTorch so that we
1207:02 - can build a computer vision model on it. But I just want to stress that this step will be very
1207:06 - similar no matter what data you're working with. You'll have some folder over here or maybe it'll
1207:11 - live on the cloud somewhere. Who knows wherever your data is, but you'll want to write code to
1207:16 - load it from here into PyTorch. So let's download pizza steak and sushi data. So I'm going to use
1207:24 - width. I'll just X over here. So we have more screen space with open. I'm going to open the data
1207:32 - path slash the file name that I'm trying to open, which will be pizza steak sushi dot zip. And I'm
1207:39 - going to write binary as F. So this is essentially saying I'm doing this in advance because I know
1207:47 - I'm going to download this folder here. So I know the the file name of it, pizza steak sushi dot zip.
1207:54 - I'm going to download that into Google collab and I want to open it up. So request equals request
1208:04 - dot get. And so when I want to get this file, I can click here. And then if I click download,
1208:13 - it's going to what do you think it's going to do? Well, let's see. If I wanted to download it
1208:19 - locally, I could do that. And then I could come over here. And then I could click upload if I
1208:25 - wanted to. So upload the session storage. I could upload it from that. But I prefer to write code
1208:30 - so that I could just run this cell over again and have the file instead of being download to
1208:35 - my local computer. It just goes straight into Google collab. So to do that, we need the URL
1208:42 - from here. And I'm just going to put that in there. It needs to be as a string.
1208:49 - Excuse me. I'm getting trigger happy on the shift and enter. Wonderful. So now I've got a request
1208:57 - to get the content that's in here. And GitHub can't really show this because this is a zip file
1209:04 - of images, spoiler alert. Now let's keep going. We're going to print out that we're downloading
1209:11 - pizza, stake and sushi data dot dot dot. And then I'm going to write to file the request dot content.
1209:21 - So the content of the request that I just made to GitHub. So that's request is here.
1209:26 - Using the Python request library to get the information here from GitHub. This URL could be
1209:32 - wherever your file has been stored. And then I'm going to write the content of that request
1209:38 - to my target file, which is this. This here. So if I just copy this, I'm going to write the data
1209:46 - to here data path slash pizza, stake sushi zip. And then because it's a zip file, I want to unzip it.
1209:55 - So unzip pizza, stake sushi data. Let's go with zip file. So we imported zip file up there,
1210:03 - which is a Python library to help us deal with zip files. We're going to use zip file dot zip
1210:09 - file. We're going to pass it in the data path. So just the path that we did below,
1210:14 - data path slash pizza, stake sushi dot zip. And this time, instead of giving it right permissions,
1210:23 - so that's what wb stands for, stands for right binary. I'm going to give it read permissions.
1210:29 - So I want to read this target file instead of writing it. And I'm going to go as zip ref.
1210:36 - We can call this anything really, but zip ref is kind of, you'll see this a lot in
1210:41 - different Python examples. So we're going to print out again. So unzipping pizza, stake,
1210:48 - and sushi data. Then we're going to go zip underscore ref dot extract all. And we're going to go image
1210:59 - path. So what this means is it's taking the zip ref here. And it's extracting all of the
1211:06 - information that's within that zip ref. So within this zip file, to the image path,
1211:14 - which is what we created up here. So if we have a look at image path, let's see that.
1211:22 - Image path. Wonderful. So that's where all of the contents of that zip file are going to go
1211:29 - into this file. So let's see it in action. You're ready. Hopefully it works. Three, two, one, run.
1211:37 - File is not a zip file. Oh, no, what do we get wrong? So did I type this wrong?
1211:47 - Got zip data path. Oh, we got the zip file here. Pizza, stake, sushi, zip, read data path.
1211:59 - Okay, I found the error. So this is another thing that you'll have to keep in mind.
1212:03 - And I believe we've covered this before, but I like to keep the errors in these videos so that
1212:08 - you can see where I get things wrong, because you never write code right the first time.
1212:13 - So we have this link in GitHub. We have to make sure that we have the raw link address. So if I
1212:18 - come down to here and copy the link address from the download button, you'll notice a slight
1212:24 - difference if we come back into here. So I'm just going to copy that there. So if we step
1212:29 - through this GitHub, Mr. D Burke pytorch deep learning, we have raw instead of blob. So that
1212:35 - is why we've had an error is that our code is correct. It's just downloading the wrong data.
1212:42 - So let's change this to the raw. So just keep that in mind, you must have raw here.
1212:47 - And so let's see if this works.
1212:52 - Do we have the correct data? Oh, we might have to delete this. Oh, there we go.
1212:56 - Test. Beautiful. Train. Pizza steak sushi. Wonderful. So it looks like we've got some data. And if we
1213:03 - open this up, what do we have? We have various JPEGs. Okay. So this is our testing data. And if
1213:09 - we click on there, we've got an image of pizza. Beautiful. So we're going to explore this a
1213:15 - little bit more in the next video. But that is some code that we've written to download data sets
1213:21 - or download our own custom data set. Now, just recall that we are working specifically on a pizza
1213:27 - steak and sushi problem for computer vision. However, our whole premise is that we have some
1213:33 - custom data. And we want to convert these. How do we get these into tenses? That's what we want
1213:38 - to do. And so the same process will be for your own problems. We'll be loading a target data set
1213:45 - and then writing code to convert whatever the format the data set is in into tenses for PyTorch.
1213:52 - So I'll see you in the next video. Let's explore the data we've downloaded.
1214:00 - Welcome back. In the last video, we wrote some code to download a target data set, our own custom
1214:06 - data set from the PyTorch deep learning data directory. And if you'd like to see how that
1214:13 - data set was made, you can go to PyTorch deep learning slash extras. It's going to be in the
1214:18 - custom data creation notebook here for 04. So I've got all the code there. All we've done is take
1214:24 - data from the food 101 data set, which you can download from this website here, or from torch
1214:31 - vision. So if we go to torch vision, food 101. We've got the data set built into PyTorch there.
1214:40 - So I've used that data set from PyTorch and broken it down from 101 classes to three classes so that
1214:46 - we can start with a small experiment. So there we go. Get the training data, data sets food 101,
1214:52 - and then I've customized it to be my own style. So if we go back to CoLab, we've now got
1215:00 - pizza steak sushi, a test folder, which will be our testing images, and a train folder,
1215:04 - which will be our training images. This data is in standard image classification format. But we'll
1215:10 - cover that in a second. All we're going to do in this video is kick off section number two,
1215:16 - which is becoming one with the data, which is one of my favorite ways to refer to data preparation
1215:25 - and data exploration. So we're coming one with the data. And I'd just like to show you one of my
1215:35 - favorite quotes from Abraham loss function. So if I had eight hours to build a machine learning model,
1215:41 - I'd spend the first six hours preparing my data set. And that's what we're going to do. Abraham
1215:48 - loss function sounds like he knows what is going on. But since we've just downloaded some data,
1215:53 - let's explore it. Hey, and we'll write some code now to walk through each of the directories. How
1216:00 - you explore your data will depend on what data you've got. So we've got a fair few different
1216:07 - directories here with a fair few different folders within them. So how about we walk through each
1216:12 - of these directories and see what's going on. If you have visual data, you probably want to
1216:18 - visualize an image. So we're going to do that in the second two, write a little doc string for
1216:22 - this helper function. So walks through the path, returning its contents. Now, just in case you didn't
1216:33 - know Abraham loss function does not exist as far as I know. But I did make up that quote. So we're
1216:39 - going to use the OS dot walk function, OS dot walk. And we're going to pass it in a dirt path. And
1216:46 - what does walk do? We can get the doc string here. Directory tree generator. For each directory
1216:55 - in the directory tree rooted at the top, including top itself, but in excluding dot and dot dot,
1217:01 - yields a three tuple, derpath, der names, and file names. You can step through this in the Python
1217:08 - documentation, if you'd like. But essentially, it's just going to go through our target directory,
1217:12 - which in this case will be this one here. And walk through each of these directories printing out
1217:17 - some information about each one. So let's see that in action. This is one of my favorite things to do
1217:23 - if we're working with standard image classification format data. So there are lane, length,
1217:31 - der names, directories. And let's go land, land, file names. We say at length, like I've got the
1217:41 - G on the end, but it's just land images in, let's put in here, derpath. So a little bit confusing
1217:50 - if you've never used walk before, but it's so exciting to see all of the information in all
1217:54 - of your directories. Oh, we didn't read and run it. Let's check out function now walk through der.
1218:00 - And we're going to pass it in the image path, which is what? Well, it's going to show us.
1218:05 - How beautiful. So let's compare what we've got in our printout here. There are two directories
1218:11 - and zero images in data, pizza, steak sushi. So this one here, there's zero images, but there's
1218:17 - two directories test and train wonderful. And there are three directories in data, pizza, steak, sushi,
1218:24 - test. Yes, that looks correct. Three directories, pizza, steak, sushi. And then we have zero
1218:31 - directories and 19 images in pizza, steak, sushi, slash test, steak. We have a look at this. So that
1218:38 - means there's 19 testing images for steak. Let's have a look at one of them. There we go. Now,
1218:44 - again, these are from the food 101 data set, the original food 101 data set, which is just a whole
1218:49 - bunch of images of food, 100,000 of them. There's some steak there. Wonderful. And we're trying to
1218:55 - build a food vision model to recognize what is in each image. Then if we jump down to here,
1219:01 - we have three directories in the training directory. So we have pizza, steak, sushi. And then we have
1219:07 - 75 steak images, 72 sushi images and 78 pizza. So slightly different, but very much the same
1219:15 - numbers. They're not too far off each other. So we've got about 75 or so training images,
1219:20 - and we've got about 25 or so testing images per class. Now these were just randomly selected
1219:26 - from the food 101 data set 10% of three different classes. So let's keep pushing forward. And we're
1219:34 - going to set up our training and test parts. So I just want to show you, we'll just set up this,
1219:44 - and then I'll just show you the standard image classification setup, image path.train. And we're
1219:52 - going to go tester. So if you're working on image classification problem, we want to set this up
1219:57 - as test. And then if we print out the trainer and the tester, this is what we're going to be
1220:04 - trying to do. We're going to write some code to go, Hey, look at this path for our training images.
1220:09 - And look at this path for our testing images. And so this is the standard image classification
1220:17 - data format is that you have your overall data set folder. And then you have a training folder
1220:22 - dedicated to all of the training images that you might have. And then you have a testing folder
1220:27 - dedicated to all of the testing images that you might have. And you could have a validation
1220:31 - data set here as well if you wanted to. But to label each one of these images, the class name
1220:39 - is the folder name. So all of the pizza images live in the pizza directory, the same for steak,
1220:46 - and the same for sushi. So depending on your problem, your own data format will depend on
1220:52 - whatever you're working on, you might have folders of different text files or folders of
1220:57 - different audio files. But the premise remains, we're going to be writing code to get our data here
1221:04 - into tenses for use with PyTorch. And so where does this come from? This image data classification
1221:11 - format. Well, if we go to the torch vision dot data sets documentation, as you start to work
1221:18 - with more data sets, you'll start to realize that there are standardized ways of storing
1221:23 - specific types of data. So if we come down to here, base classes for custom data sets,
1221:28 - we'll be working towards using this image folder data set. But this is a generic data
1221:33 - loader where the images are arranged in this way by default. So I've specifically formatted our data
1221:40 - to mimic the style that this pre built data loading function is for. So we've got a root directory
1221:48 - here in case of we were classifying dog and cat images, we have root, then we have a dog folder,
1221:54 - then we have various images. And the same thing for cat, this would be dog versus cat. But the only
1222:00 - difference for us is that we have food images, and we have pizza steak sushi. If we wanted to use the
1222:06 - entire food 101 data set, we would have 101 different folders of images here, which is totally
1222:12 - possible. But to begin with, we're keeping things small. So let's keep pushing forward. As I said,
1222:18 - we're dealing with a computer vision problem. So what's another way to explore our data,
1222:22 - other than just walking through the directories themselves. Let's visualize an image, hey? But
1222:28 - we've done that before with just clicking on the file. How about we write some code to do so.
1222:35 - We'll replicate this but with code. I'll see you in the next video.
1222:42 - Welcome back. In the last video, we started to become one with the data. And we learned that we
1222:49 - have about 75 images per training class and about 25 images per testing class. And we also learned
1222:56 - that the standard image classification data structure is to have the steak images within the steak
1223:04 - folder of the training data set and the same for test, and the pizza images within the pizza
1223:09 - folder, and so on for each different image classification class that we might have.
1223:14 - So if you want to create your own data set, you might format it in such a way that your training
1223:19 - images are living in a directory with their classification name. So if you wanted to classify
1223:25 - photos of dogs and cats, you might create a training folder of train slash dog train slash
1223:30 - cat, put images of dogs in the dog folder, images of cats in the cat folder, and then the same for
1223:37 - the testing data set. But the premise remains, I'm going to sound like a broken record here.
1223:42 - We want to get our data from these files, whatever files they may be in, whatever data structure
1223:48 - they might be in, into tenses. But before we do that, let's keep becoming one with the data.
1223:53 - And we're going to visualize an image. So visualizing an image, and you know how much I love randomness.
1224:00 - So let's select a random image from all of the files that we have in here. And let's plot it,
1224:07 - hey, because we could just click through them and visualize them. But I like to do things with
1224:11 - code. So specifically, let's let's plan this out. Let's write some code to number one is get all
1224:20 - of the image paths. We'll see how we can do that with the path path lib library. We then want to
1224:28 - pick a random image path using we can use Python's random for that. Python's random dot choice will
1224:36 - pick a single image random dot choice. Then we want to get the image class name. And this is where
1224:45 - part lib comes in handy. Class name, recall that whichever target image we pick, the class name will
1224:51 - be whichever directory that it's in. So in the case of if we picked a random image from this directory,
1224:57 - the class name would be pizza. So we can do that using, I think it's going to be path lib dot path.
1225:04 - And then we'll get the parent folder, wherever that image lives. So the parent image parent
1225:09 - folder that parent directory of our target random image. And we're going to get the stem of that.
1225:15 - So we have stem, stem is the last little bit here. Number four, what should we do? Well,
1225:23 - we want to open the image. So since we're working with images, let's open the image
1225:31 - with Python's pill, which is Python image library, but we'll actually be pillow. So if we go Python
1225:38 - pillow, a little bit confusing when I started to learn about Python image manipulation. So pillow
1225:45 - is a friendly pill for, but it's still called pill. So just think of pillow as a way to process
1225:53 - images with Python. So pill is the Python imaging library by Frederick Lund. And so Alex Clark and
1226:01 - contributors have created pillow. So thank you, everyone. And let's go to number five. What do
1226:09 - we want to do as well? We want to, yeah, let's get some metadata about the image. We'll then show
1226:14 - the image and print metadata. Wonderful. So let's import random, because machine learning is all
1226:22 - about harnessing the power of randomness. And I like to use randomness to explore data as well
1226:28 - as model it. So let's set the seed. So we get the same image on both of our ends. So random dot seed.
1226:38 - I'm going to use 42. You can use whatever you'd like. But if you'd like to get the same image as me,
1226:43 - I'd suggest using 42 as well. Now let's get all the image paths. So we can do this because our image
1226:54 - path list, we want to get our image path. So recall that our image path
1227:02 - is this. So this folder here, I'm just going to close all this. So this is our image path,
1227:08 - this folder here, you can also go copy path if you wanted to, we're just going to get something
1227:13 - very similar there. That's going to error out. So I'll just comment that. So it doesn't error.
1227:20 - That's our path. But we're going to keep it in the POSIX path format. And we can go list. Let's
1227:28 - create a list of image path dot glob, which stands for grab. I don't actually know what glob stands
1227:34 - for. But to me, it's like glob together. All of the images that are all of the files that suit
1227:42 - a certain pattern. So glob together for me means stick them all together. And you might be able
1227:48 - to correct me if I've got the wrong meaning there. I'd appreciate that. And so we're going to pass
1227:54 - in a certain combination. So we want star slash star. And then we want star dot jpg. Now why are
1228:02 - we doing this? Well, because we want every image path. So star is going to be this first
1228:10 - directory here. So any combination, it can be train or test. And then this star means anything for
1228:16 - what's inside tests. And let's say this first star is equal to test. This second star is equal to
1228:24 - anything here. So it could be any of pizza, steak or sushi. And then finally, this star,
1228:30 - let's say it was test pizza. This star is anything in here. And that is before dot jpg.
1228:37 - So it could be any one of these files here. Now this will make more sense once we print it out.
1228:42 - So image path list, let's have a look. There we go. So now we've got a list of every single image
1228:50 - that's within pizza steak sushi. And this is just another way that I like to visualize data is to
1228:57 - just get all of the paths and then randomly visualize it, whether it be an image or text or
1229:03 - audio, you might want to randomly listen to it. Recall that each each of the domain libraries have
1229:08 - different input and output methods for different data sets. So if we come to torch vision, we have
1229:13 - utils. So we have different ways to draw on images, reading and writing images and videos. So we
1229:21 - could load an image via read image, we could decode it, we could do a whole bunch of things.
1229:27 - I'll let you explore that as extra curriculum. But now let's select a random image from here
1229:33 - and plot it. So we'll go number two, which was our step up here, pick a random image. So pick a
1229:42 - random image path. Let's get rid of this. And so we can go random image path equals random
1229:51 - dot choice, harness the power of randomness to explore our data. Let's get a random image from
1229:58 - image path list, and then we'll print out random image path, which one was our lucky image that
1230:02 - we selected. Beautiful. So we have a test pizza image is our lucky random image. And
1230:13 - because we've got a random seed, it's going to be the same one each time. Yes, it is.
1230:19 - And if we comment out the random seed, we'll get a different one each time. We've got a stake
1230:22 - image. We've got another stake image. Another stake image. Oh, three in a row, four in a row.
1230:29 - Oh, pizza. Okay, let's keep going. So we'll get the image class
1230:36 - from the path name. So the image class is the name of the directory, because our image data is
1230:44 - in standard image classification format, where the image is stored. So let's do that image class
1230:52 - equals random image path dot parent dot stem. And then we're going to print image class. What do we
1231:03 - get? So we've got pizza. Wonderful. So the parent is this folder here. And then the stem is the end
1231:12 - of that folder, which is pizza. Beautiful. Well, now what are we up to now? We're working with
1231:17 - images. Let's open up the image so we can open up the image using pill. We could also open up the
1231:22 - image with pytorch here. So with read image, but we're going to use pill to keep things a little
1231:29 - bit generic for now. So open image, image equals image. So from pill import image, and the image
1231:37 - class has an open function. And we're just going to pass it in here, the random image path. Note
1231:42 - if this is corrupt, if your images corrupt, this may error. So then you could potentially use this
1231:48 - to clean up your data set. I've imported a lot of images with image dot open of our target data
1231:55 - set here. I don't believe any of them are corrupt. But if they are, please let me know. And we'll find
1232:00 - out later on when our model tries to train on it. So let's print some metadata. So when we open our
1232:06 - image, we get some information from it. So let's go our random image path is what? Random image path.
1232:15 - We're already printing this out, but we'll do it again anyway. And then we're going to go the image
1232:22 - class is equal to what will be the image class. Wonderful. And then we can print out, we can get
1232:32 - some metadata about our images. So the image height is going to be IMG dot height. We get that
1232:37 - metadata from using the pill library. And then we're going to print out image width. And we'll get
1232:43 - IMG dot width. And then we'll print the image itself. Wonderful. And we can get rid of this,
1232:50 - and we can get rid of this. Let's now have a look at some random images from our data set.
1232:59 - Lovely. We've got an image of pizza there. Now I will warn you that the downsides of working with
1233:05 - food data is it does make you a little bit hungry. So there we've got some sushi. And then we've got
1233:10 - some more sushi. Some steak. And we have a steak, we go one more for good luck. And we finish off
1233:22 - with some sushi. Oh, that could be a little bit confusing to me. I thought that might be steak
1233:25 - to begin with. And this is the scene. Now we'll do one more. Why it's important to sort of visualize
1233:31 - your images randomly, because you never know what you're going to come across. And this way,
1233:35 - once we visualize enough images, you could do this a hundred more times. You could do this
1233:39 - 20 more times until you feel comfortable to go, Hey, I feel like I know enough about the data now.
1233:45 - Let's see how well our model goes on this sort of data. So I'll finish off on this steak image.
1233:50 - And now I'll set your little challenge before the next video is to visualize an image like we've
1233:56 - done here. But this time do it with matplotlib. So try to visualize an image with matplotlib.
1234:03 - That's your little challenge before the next video. So give that a go. We want to do a random
1234:09 - image as well. So quite a similar set up to this. But instead of printing out things like this,
1234:14 - we want to visualize it using matplotlib. So try that out and we'll do it together in the next video.
1234:24 - Oh, we are well on the way to creating our own PyTorch custom data set. We've started to
1234:30 - become one with the data. But now let's continue to visualize another image. I set you the challenge
1234:37 - in the last video to try and replicate what we've done here with the pill library with matplotlib.
1234:43 - So now let's give it a go. Hey, and why use matplotlib? Well, because matplotlib and I'm going to
1234:49 - import numpy as well, because we're going to have to convert this image into an array. That was a
1234:53 - little trick that I didn't quite elaborate on. But I hope you tried to decode it out and figure
1234:59 - it out from the errors you received. But matplotlib is one of the most fundamental data science
1235:06 - libraries. So you're going to see it everywhere. So it's just important to be aware of how to plot
1235:11 - images and data with matplotlib. So turn the image into an array. So we can go image as array. And
1235:21 - I'm going to use the numpy method NP as array. We're going to pass it in the image, recall that
1235:29 - the image is the same image that we've just set up here. And we've already opened it with pill.
1235:36 - And then I'm going to plot the image. So plot the image with matplotlib. plt.figure.
1235:46 - And then we can go fig size equals 10, seven. And then we're going to go plt.im show image as
1235:56 - array, pass it in the array of numbers. I'm going to set the title here as an f string. And then
1236:03 - I'm going to pass in image class, equals image class. Then I'm going to pass in image shape. So
1236:11 - we can get the shape here. Now this is another important thing to be aware of of your different
1236:15 - datasets when you're exploring them is what is the shape of your data? Because what's one of the
1236:20 - main errors in machine learning and deep learning? It's shape mismatch issues. So if we know the
1236:25 - shape of our data where we can start to go, okay, I kind of understand what shape I need my model
1236:31 - layers to be in what what shape I need my other data to be in. And I'm going to turn the axes off
1236:36 - here. Beautiful. So look at what we've got. Now I've just thrown this in here without really
1236:44 - explaining it. But we've seen this before in the computer vision section. As our image shape is
1236:49 - 512 3063. Now the dimensions here are height is 512 pixels. The width is 306 pixels. And it has
1236:59 - three color channels. So what format is this? This is color channels last, which is the default
1237:08 - for the pill library. There's also the default for map plot lib. But pytorch recall is default
1237:14 - if we put the color channels at the start color channels first. Now there is a lot of debate as
1237:20 - I've said over which is the best order. It looks like it's leading towards going towards this. But
1237:24 - for now pytorch defaults to color channels first. But that's okay. Because we can manipulate these
1237:30 - dimensions to what we need for whatever code that we're writing. And the three color channels is what
1237:36 - red, green and blue. So if you combine red, green and blue in some way, shape or form,
1237:41 - you get the different colors here that represent our image. And so if we have a look at our image
1237:47 - as a ray. Our image is in numerical format. Wonderful. So okay. We've got one way to do this for
1237:59 - one image. I think we start moving towards scaling this up to do it for every image in our data
1238:07 - folder. So let's just finish off this video by visualizing one more image. What do we get? Same
1238:13 - premise. The image is now as an array, different numerical values. We've got a delicious looking
1238:19 - pizza here of shave 512 512 with color channels last. And we've got the same thing up here. So
1238:28 - that is one way to become one with the data is to visualize different images, especially random
1238:33 - images. You could do the same thing visualizing different text samples that you're working with
1238:38 - or listening to different audio samples. It depends what domain you're working in. So now in the
1238:43 - next video, let's start working towards turning all of the images in here. Now that we visualize
1238:49 - some of them and become one with the data, we've seen that the shapes are varying in terms of
1238:54 - height and width. But they all look like they have three color channels because we have color images.
1238:59 - But now we want to write code to turn all of these images into pytorch tenses.
1239:05 - So let's start moving towards that. I'll see you in the next video.
1239:12 - Hello and welcome back. In the last video, we converted an image to a NumPy array.
1239:18 - And we saw how an image can be represented as an array. But what if we'd like to get this image
1239:25 - from our custom data set over here, pizza steak sushi into pytorch? Well, let's cover that in
1239:33 - this video. So I'm going to create a new heading here. And it's going to be transforming data.
1239:40 - And so what we'd like to do here is I've been hinting at the fact the whole time is we want
1239:45 - to get our data into tensor format, because that is the data type that pytorch accepts.
1239:50 - So let's write down here before we can use our image data with pytorch. Now this goes for images,
1239:59 - other vision data, it goes for text, it goes to audio, basically whatever kind of data set you're
1240:05 - working with, you need some way to turn it into tenses. So that's step number one. Turn your target
1240:12 - data into tenses. In our case, it's going to be a numerical representation of our images.
1240:24 - And number two is turn it into a torch dot utils dot data dot data set. So recall from a previous
1240:35 - video that we've used the data set to house all of our data in tensor format. And then subsequently,
1240:43 - we've turned our data sets, our pytorch data sets into torch dot utils dot data dot data loader.
1240:55 - And a data loader creates an iterable or a batched version of our data set. So for short, we're going
1241:02 - to call these data set and data loader. Now, as I discussed previously, if we go to the pytorch
1241:11 - documentation torch vision for torch vision, this is going to be quite similar for torch audio torch
1241:19 - text, torch rec torch data eventually when it comes out of beta, there are different ways to
1241:25 - create such data sets. So we can go into the data sets module, and then we can find built-in data
1241:33 - sets, and then also base classes for custom data sets. But if we go into here, image folder,
1241:43 - there's another parameter I'd like to show you, and this is going to be universal across many of
1241:47 - your different data types is the transform parameter. Now, the transform parameter is
1241:54 - a parameter we can use to pass in some transforms on our data. So when we load our data sets from an
1242:01 - image folder, it performs a transform on those data samples that we've sent in here as the target
1242:08 - data folder. Now, this is a lot more easier to understand through illustration, rather than just
1242:13 - talking about it. So let's create a transform. And the main transform we're going to be doing is
1242:20 - transforming our data, and we're turning it into tenses. So let's see what that looks like. So we're
1242:24 - going to just going to re import all of the main libraries that we're going to use. So from torch
1242:29 - utils dot data, let's import data loader. And we're going to import from torch vision. I'm going to
1242:38 - import data sets. And I'm also going to import transforms. Beautiful. And I'm going to create
1242:47 - another little heading here, this is going to be 3.1, transforming data with torch vision dot
1242:55 - transform. So the main transform we're looking to here is turning out images from JPEGs.
1243:04 - If we go into train, and then we go into any folder, we've got JPEG images.
1243:09 - And we want to turn these into tensor representation. So there's some pizza there.
1243:13 - We'll get out of this. Let's see what we can do. How about we create a transform here,
1243:20 - write a transform for image. And let's start off by calling it data transform.
1243:27 - And I'm going to show you how we can combine a few transforms together. If you want to
1243:32 - combine transforms together, you can use transforms dot compose. You can also use
1243:38 - an n dot sequential to combine transforms. But we're going to stick with transforms dot
1243:45 - compose for now. And it takes a list. And so let's just write out three transforms to begin with.
1243:53 - And then we can talk about them after we do so. So we want to resize our images
1243:59 - to 6464. Now, why might we do this? Well, do you recall in the last section computer vision,
1244:06 - we use the tiny VGG architecture. And what size were the images that the tiny VGG architecture took?
1244:14 - Well, we replicated the CNN website version or the CNN explainer website version, and they took
1244:19 - images of size 6464. So perhaps we want to leverage that computer vision model later on.
1244:25 - So we're going to resize our images to 6464. And then we're going to create another transform.
1244:32 - And so this is, I just want to highlight how transforms can help you manipulate your data in a
1244:37 - certain way. So if we wanted to flip the images, which is a form of data augmentation, in other
1244:42 - words, artificially increasing the diversity of our data set, we can flip the images randomly on
1244:49 - the horizontal. So transforms dot random horizontal flip. And I'm going to put a probability in here
1244:59 - of p equals 0.5. So that means 50% of the time, if an image goes through this transform pipeline,
1245:09 - it will get flipped on the horizontal axis. As I said, this makes a lot more sense when we
1245:13 - visualize it. So we're going to do that very shortly. And finally, we're going to turn the image into
1245:19 - a torch tensor. So we can do this with transforms dot to tensor. And now where might you find such
1245:31 - transforms? So this transform here says to tensor, if we have a look at the doc string,
1245:37 - we got convert a pill image, which is what we're working with right now, or a NumPy array to a
1245:42 - tensor. This transform does not support torch script. If you'd like to find out what that is,
1245:47 - I'd like to read the documentation for that. It's essentially turning your pytorch code into a
1245:51 - Python script. It converts a pill image or a NumPy array from height with color channels in the range
1245:59 - 0 to 255, which is what our values are up here. They're from 0 to 255, red, green and blue,
1246:06 - to a torch float tensor of shape color channels height width in the range 0 to 1. So it will
1246:14 - take our tensor values here or our NumPy array values from 0 to 255 and convert them into a torch
1246:21 - tensor in the range 0 to 1. We're going to see this later on in action. But this is our first
1246:27 - transform. So we can pass data data through that. In fact, I'd encourage you to try that out.
1246:34 - See what happens when you pass in data transform. What happens when you pass it in our image as a
1246:40 - ray? Image as a ray. Let's see what happens. Hey, oh, image should be pill image got class NumPy
1246:52 - array. What if we just pass in our straight up image? So this is a pill image. There we go.
1246:58 - Beautiful. So if we look at the shape of this, what do we get?
1247:01 - 3 64 64. There's 64. And if what if we wanted to change this to 224, which is another common value for
1247:11 - computer vision models to 24 to 24. Do you see how powerful this is? This little transforms
1247:17 - module, the torch vision library will change that back to 64 64. And then if we have a look at what
1247:23 - D type of our transform tensor is, we get torch float 32. Beautiful. So now we've got a way to
1247:31 - transform our images into tensors. And so, but we're still only doing this with one image.
1247:37 - How about we progress towards doing it for every image in our data folder here?
1247:44 - But before we do that, I'd like to visualize what this looks like. So in the next video,
1247:49 - let's write some code to visualize what it looks like to transform multiple images at a time.
1247:54 - And I think it'd be a good idea to compare the transform that we're doing to the original image.
1247:59 - So I'll see you in the next video. Let's write some visualization code.
1248:06 - Let's now follow our data explorer's motto of visualizing our transformed images. So we saw what it looks
1248:13 - like to pass one image through a data transform. And if we wanted to find more documentation on
1248:18 - torch vision transforms, where could we go? There is a lot of these. So transforming and augmenting
1248:25 - images, this is actually going to be your extra curriculum for this video. So transforms are
1248:31 - common image transformations available in the transforms module. They can be chained together
1248:36 - using compose, which is what we've already done. Beautiful. And so if you'd like to go through all
1248:41 - of these, there's a whole bunch of different transforms that you can do, including some data
1248:45 - augmentation transforms. And then if you'd like to see them visually, I'd encourage you to check
1248:50 - out illustration of transforms. But let's write some code to explore our own transform visually
1248:55 - first. So I'll leave this as a link. So I'm going up here, right here, transforms
1249:06 - help you get your images ready to be used with a model slash perform data augmentation.
1249:17 - Wonderful. So we've got a way to turn images into tenses. That's what we want for our model.
1249:24 - We want our images as pytorch tenses. The same goes for any other data type that you're working
1249:29 - with. But now I'd just like to visualize what it looks like if we plot a number of transformed
1249:35 - images. So we're going to make a function here that takes in some image paths, a transform,
1249:41 - a number of images to transform at a time and a random seed here, because we're going to harness
1249:46 - the power of randomness. And sometimes we want to set the seed. Sometimes we don't. So we have
1249:53 - an image path list that we've created before, which is just all of the image paths that we have
1249:59 - of our data set. So data, pizza, steak sushi. Now how about we select some random image paths
1250:09 - and then take the image from that path, run it through our data transform, and then compare the
1250:15 - original image of what it looks like and the transformed image and what that looks like.
1250:22 - Let's give it a try, hey? So I'm going to write a doc string of what this does,
1250:26 - and then selects random images from a path of images and loads slash transforms them,
1250:35 - then plots the original verse, the transformed version. So that's quite a long doc string,
1250:45 - but that'll be enough. We can put in some stuff for the image paths, transforms, and seed. We'll
1250:51 - just code this out. Let's go random seed, we'll create the seed. Maybe we do it if seed, random seed.
1251:00 - Let's put that, and we'll set seed to equal none by default. That way we can, we'll see if this works,
1251:08 - hey, if in doubt, coded out random image paths, and then we're going to go random sample from the
1251:14 - image paths and the number of sample that we're going to do. So random sample is going to, this will
1251:19 - be a list on which part in here that this is a list. So we're going to randomly sample
1251:25 - k, which is going to be n. So three images from our image path list. And then we're going to go for
1251:34 - image path, we're going to loop through the randomly sampled image parts. You know how much I love
1251:40 - harnessing the power of randomness for visualization. So for image path in random image paths, let's
1251:46 - open up that image using pill image dot open image path as f. And then we're going to create a
1251:54 - figure and an axes. And we're going to create a subplot with my plot lib. So subplots. And we
1252:02 - want it to create one row. So it goes n rows and calls. One row and n calls equals two. And then
1252:13 - on the first or the zeroth axis, we're going to plot the original image. So in show, we're just
1252:20 - going to pass it straight in f. And then if we want to go x zero, we're going to set the title. So
1252:27 - set title, we're going to set it to be the original. So we'll create this as an f string, original,
1252:35 - and then new line will create a size variable. And this is going to be f dot size. So we're just
1252:40 - getting the size attribute from our file. So we'll keep going, and we'll turn off the axes here.
1252:48 - So axis, and we're going to set that to false. Now let's transform on the first axes plot. We're
1252:57 - going to transform and plot target image. This is so that our images are going to be side by side,
1253:03 - the original and the transformed version. So there's one thing that we're going to have to do. I'll
1253:08 - just, I'll code it out in a wrong way first. I think that'll be a good way to illustrate what's
1253:14 - going on. f. So I'm just going to put a note here. Note, we will need to change shape for
1253:23 - matplotlib, because we're going to come back here. Because what does this do? What have we
1253:29 - noticed that our transform does? If we check the shape here, oh, excuse me, it converts our image
1253:35 - to color channels first. Whereas matplotlib prefers color channels last. So just keep that
1253:45 - in mind for when we're going forward. This code, I'm writing it, it will error on purpose. So
1253:51 - transformed image. And then we're going to go axe one as well. We're going to set the title,
1253:58 - which is going to be transformed. And then we'll create a new line and we'll say size is going to be
1254:07 - transformed image dot shape. Or probably a bit of, yeah, we could probably go shape here. And then
1254:17 - finally, we're going to go axe one, we're going to turn the axis, we're going to set that to false.
1254:23 - You can also set it to off. So you could write false, or you could write off, you might see that
1254:28 - different versions of that somewhere. And I'm going to write a super title here, which we'll see what
1254:36 - this looks like class is going to be image path. So we're getting the target image path. And we're
1254:41 - just going to get the attribute or the parent attribute, and then the stem attribute from that,
1254:46 - just like we did before, to get the class name. And then I'm going to set this to a larger font
1254:51 - size, so that we make some nice looking plots, right? If we're going to visualize our data,
1254:57 - we might as well make our plots visually appealing. So let's plot some transformed data or transformed
1255:03 - images. So image paths, we're going to set this to image part list, which is just the variable we
1255:08 - have down below, which is the part list, a list containing all of our image paths. Our transform,
1255:15 - we're going to set our transform to be equal to our data transform. So this just means that if
1255:21 - we pass the transform in, our image is going to go through that transform, and then go through all
1255:26 - of these is going to be resized, it's going to be randomly horizontally flipped, and it's going to
1255:31 - be converted to a tensor. And then so we're going to set that data transfer there or data transform,
1255:37 - sorry, and is going to be three. So we plot three images, and we'll set the seed to 42 to begin with.
1255:43 - Let's see if this works. Oh, what did we get wrong? We have invalid shape. As I said, I love seeing
1255:52 - this error, because we have seen this error many times, and we know what to do with it. We know that
1255:57 - we have to rearrange the shapes of our data in some way, shape or form. Wow, I said shape a lot
1256:02 - there. That's all right. Let's go here, permute. This is what we have to do. We have to permute,
1256:07 - we have to swap the order of the axes. So right now, our color channels is first. So we have to
1256:12 - bring this color channel axis or dimension to the end. So we need to shuffle these across. So 64
1256:18 - into here, 64 into here, and three on the end. We need to, in other words, turn it from color
1256:22 - channels first to color channels last. So we can do that by permuting it to have the first
1256:29 - axis come now in the zero dimension spot. And then number two was going to be in the first
1256:35 - dimension spot. And then number zero was going to be at the back end. So this is essentially going
1256:40 - from C H W, and we're just changing the order to be H W C. So the exact same data is going to be
1256:53 - within that tensor. We're just changing the order of the dimensions. Let's see if this works.
1257:00 - Look at that. Oh, I love seeing some manipulated data. We have a class of pizza and the original
1257:07 - image is there, and it's 512 by 512. But then we've resized it using our transform. Notice that
1257:13 - it's a lot more pixelated now, but that makes sense because it's only 64 64 pixels. Now, why
1257:18 - might we do such a thing? Well, one, if is this image still look like that? Well, to me, it still
1257:25 - does. But the most important thing will be does it look like that to our model? Does it still look
1257:29 - like the original to our model? Now 64 by 64, there is less information encoded in this image.
1257:36 - So our model will be able to compute faster on images of this size. However, we may lose
1257:42 - some performance because not as much information is encoded as the original image. Again, the size
1257:48 - of an image is something that you can control. You can set it to be a hyper parameter. You can
1257:53 - tune the size to see if it improves your model. But I've just decided to go 60 64 64 3 in line
1258:01 - with the CNN explainer website. So a little hint, we're going to be re replicating this model that
1258:08 - we've done before. Now you notice that our images are now the same size 64 64 3 as what the CNN
1258:15 - explainer model uses. So that's where I've got that from. But again, you could change this to
1258:19 - size to whatever you want. And we see, oh, we've got a stake image here. And you notice that our
1258:25 - image has been flipped on the horizontal. So the horizontal access, our image has just been flipped
1258:30 - same with this one here. So this is the power of torch transforms. Now there are a lot more
1258:37 - transforms, as I said, you can go through them here to have a look at what's going on. Illustrations
1258:42 - of transforms is a great place. So there's resize, there's center crop, you can crop your
1258:48 - images, you can crop five different locations, you can do grayscale, you can change the color,
1258:54 - a whole bunch of different things. I'd encourage you to check this out. That's your extra curriculum
1259:02 - for this video. But now that we've visualized a transform, this is what I hinted at before that
1259:09 - we're going to use this transform for when we load all of our images in, using into a torch
1259:17 - data set. So I just wanted to make sure that they had been visualized first. We're going to use our
1259:23 - data transform in the next video when we load all of our data using a torch vision dot data sets
1259:31 - helper function. So let's give that a go. I'll see you in the next video.
1259:38 - Have a look at that beautiful plot. We've got some original images and some transformed
1259:43 - images. And the beautiful thing about our transformed images is that they're in tensor format,
1259:48 - which is what we need for our model. That's what we've been slowly working towards.
1259:52 - We've got a data set. And now we've got a way to turn it into tensors ready for a model. So
1259:58 - let's just visualize what another, I'll turn the seed off here so we can look at some more random
1260:03 - images. There we go. Okay, so we've got stake pixelated because we're downsizing 64, 64, 3.
1260:11 - Same thing for this one. And it's been flipped on the horizontal. And then same thing for this
1260:16 - pizza image and we'll do one more to finish off. Wonderful. So that is the premise of transforms
1260:26 - turning our images into tensors and also manipulating those images if we want to.
1260:32 - So let's get rid of this. I'm going to make another heading. We're up to section or part four now.
1260:38 - And this is going to be option one. So loading image data using image folder. And now I'm going
1260:49 - to turn that into markdown. And so let's go torch vision data sets. So recall how each one of the
1260:59 - torch vision domain libraries has its own data sets module that has built in functions for
1261:03 - helping you load data. In this case, we have an image folder. And there's a few others here if
1261:09 - you'd like to look into those. But an image folder, this class is going to help us load in data that
1261:16 - is in this format, the generic image classification format. So this is a prebuilt data sets function.
1261:22 - Just like there's prebuilt data sets, we can use prebuilt data set functions. Now option two
1261:29 - later on, this is a spoiler, is we're going to create our own custom version of a data set loader.
1261:35 - But we'll see that in a later video. So let's see how we can use image folder to load all of our
1261:42 - custom data, our custom images into tensors. So this is where the transform is going to come in
1261:48 - helpful. So let's write here, we can load image classification data using, let's write this,
1261:57 - let's write the full path name, torch vision dot data sets dot image folder. Put that in there,
1262:07 - beautiful. And so let's just start it out, use image folder to create data sets. Now in a previous
1262:16 - video, I hinted at the fact that we can pass a transform to our image folder class. That's going
1262:22 - to be right here. So let's see what that looks like in practice. So from torch vision, I'm going
1262:30 - to import data sets, because that's where the image folder module lives. And then we can go train
1262:35 - data equals data sets dot image folder. And we're going to pass in the root, which is our train
1262:43 - der, because we're going to do it for the training directory first. And then we're going to pass
1262:48 - in a transform, which is going to be equal to our data transform. And then we're going to pass in
1262:54 - a target transform, but we're going to leave this as none, which is the default, I believe,
1262:59 - we go up to here. Yeah, target transform is optional. So what this means is this is going to be a
1263:08 - transform for the data. And this is going to be a transform for the label slash target.
1263:17 - PyTorch likes to use target, I like to use label, but that's okay. So this means that we don't need
1263:23 - a target transform, because our labels are going to be inferred by the target directory where the
1263:29 - images live. So our pizza images are in this directory, and they're going to have pizza as the label,
1263:35 - because our data set is in standard image classification format. Now, if your data set wasn't in a
1263:42 - standard image classification format, you might use a different data loader here. A lot of them
1263:47 - will have a transform for the data. So this transform is going to run our images, whatever images are
1263:54 - loaded from these folders, through this transform that we've created here, it's going to resize them,
1264:00 - randomly flip them on the horizontal, and then turn them into tenses, which is exactly how we
1264:04 - want them for our PyTorch models. And if we wanted to transform the labels in some way, shape or form,
1264:11 - we could pass in a target transform here. But in our case, we don't need to transform the labels.
1264:18 - So let's now do the same thing for the test data. And so that's why I wanted to visualize
1264:23 - our transforms in the previous videos, because otherwise we're just passing them in as a transform.
1264:30 - So really, what's going to happen behind the scenes is all of our images are going to go
1264:35 - through these steps. And so that's what they're going to look like when we turn them into a data
1264:39 - set. So let's create the test data here or the test data set. The transform, we're going to
1264:45 - transform the test data set in the same way we've transformed our training data set. And we're
1264:50 - just going to leave that like that. So let's now print out what our data sets look like,
1264:57 - train data, and test data. Beautiful. So we have a data set, a torch data set,
1265:06 - which is an image folder. And we have number of data points. This is going to be for the training
1265:10 - data set. We have 225. So that means about 75 images per class. And we have the root location,
1265:17 - which is the folder we've loaded them in from, which is our training directory. We've set these
1265:22 - two up before, trained and tester. And then we have a transform here, which is a standard transform,
1265:30 - a resize, followed by random horizontal flip, followed by two tensor. Then we've got basically
1265:36 - the same output here for our test directory, except we have less samples there. So let's get a few
1265:43 - little attributes from the image folder. This is one of the benefits of using a pytorch prebuilt
1265:49 - data loader, is that or data set loader is that it comes with a fair few attributes. So we could
1265:54 - go to the documentation, find this out from in here, inherits from data set folder, keep digging
1266:00 - into there, or we could just come straight into Google collab. Let's go get class names as a list.
1266:07 - Can we go train data dot and then press tab? Beautiful. So we've got a fair few things here
1266:12 - that are attributes. Let's have a look at classes. This is going to give us a list of the class names,
1266:20 - class names. This is very helpful later on. So we've got pizza steak sushi. We're trying to
1266:27 - do everything with code here. So if we have this attribute of train data dot classes,
1266:34 - we can use this list later on for when we plot images straight from our data set,
1266:38 - or make predictions on them and we want to label them. You can also get class names as a dictionary,
1266:45 - map to their integer index, that is, so we can go train data dot and press tab. We've got class
1266:54 - to ID X. Let's see what this looks like. Class decked. Wonderful. So then we've got our string
1267:02 - class names mapped to their integer. So we've got pizza is zero, steak is one, sushi is two. Now,
1267:10 - this is where the target transform would come into play. If you wanted to transform those
1267:16 - these labels here in some way, shape or form, you could pass a transform into here.
1267:20 - And then if we keep going, let's check the lengths of what's going on. Check the lengths
1267:27 - of our data set. So we've seen this before, but this is going to just give us how many samples
1267:32 - that we have length, train data, length, test data, beautiful. And then of course, if you'd like
1267:39 - to explore more attributes, you can go train data dot, and then we've got a few other things,
1267:44 - functions, images, loader, samples, targets. If you wanted to just see the images, you can go dot
1267:50 - samples. If you wanted to see just the labels, you can go dot targets. This is going to be all
1267:55 - of our labels. Look at that. And I believe they're going to be an order. So we're going to have
1267:59 - zero, zero, zero, one, one, one, two, two, and then if we wanted to have a look, let's say we have a
1268:05 - look at the first sample, hey, we have data, pizza, steak sushi, train, pizza. There's the image path,
1268:15 - and it's a label zero for pizza. Wonderful. So now we've done that. How about we, we've been
1268:23 - visualizing this whole time. So let's keep up that trend. And let's visualize a sample and a label
1268:30 - from the train data data set. So in this video, we've used image folder to load our images
1268:37 - into tenses. And because our data is already in standard image classification format,
1268:43 - we can use one of torch vision dot data sets prebuilt functions.
1268:49 - So let's do some more visualization in the next video. I'll see you there.
1268:53 - Welcome back. In the last video, we used data sets dot image folder to turn all of our
1269:04 - image data into tenses. And we did that with the help of our data transform, which is a little
1269:11 - pipeline up here to take in some data, or specifically an image, resize it to a value that we've set in
1269:18 - our k6464 randomly flip it along the horizontal. We don't necessarily need this, but I've just put
1269:24 - that in there to indicate what happens when you pass an image through a transforms pipeline.
1269:29 - And then most importantly, we've turned our images into a torch tensor. So that means that our data,
1269:35 - our custom data set, this is so exciting, is now compatible to be used with a pytorch model.
1269:42 - So let's keep pushing forward. We're not finished yet. We're going to visualize some samples
1269:47 - from the train data data set. So let's, how can we do this? Let's get, we can index on the train data
1269:56 - data set to get a single image and a label. So if we go, can we do train data zero? What does that
1270:06 - give us? Okay, so this is going to give us an image tensor. And it's associated label. In this
1270:13 - case, it's an image of pizza, because why it's associated label is pizza. So let's take the zero
1270:22 - zero. So this is going to be our image. And the label is going to be train data zero. And we're
1270:29 - just going to get the first index item there, which is going to be one. And then if we have a look
1270:35 - at them separately, image and label, beautiful. So now one of our target images is in tensor format,
1270:44 - exactly how we want it. And it's label is in numeric format as well, which is also exactly how
1270:49 - we want it. And then if we wanted to convert this back to a non label, we can go class names
1270:57 - and index on that. And we see pizza. And I mean, non label is in non numeric, we can get it back
1271:03 - to string format, which is human understandable. We can just index on class names. So let's print
1271:09 - out some information about what's going on here. Print F, we're going to go image tensor.
1271:15 - I love F strings if you haven't noticed yet. Image tensor. And we're going to set in
1271:21 - new line, we're going to pass it in our image, which is just the image that we've got here.
1271:26 - Then we'll print in some more information about that. This is still all becoming one with the
1271:30 - data right where we're slowly finding out information about our data set so that if errors arise later
1271:36 - on, we can go, hmm, our image or we're getting a shape error. And I know our images are of this
1271:41 - shape or we're getting a data type error, which is why I've got the dot D type here. And that
1271:47 - might be why we're getting a data type issue. So let's do one more with the image label,
1271:53 - label, oh, well, actually, we'll do one more. We'll do print, we'll get the label data type as well.
1272:01 - Label, this will be important to take note of later on. Type, as I said, three big issues.
1272:08 - Shape mismatch, device mismatch, and data type mismatch. Can we get the type of our label?
1272:15 - Beautiful. So we've got our image tensor and we've got its shape. It's of torch size 36464.
1272:25 - That's exactly how we want it. The data type is torch float 32, which is the default data type
1272:31 - in PyTorch. Our image label is zero and the label data type is of integer. So let's try and plot
1272:39 - this and see what it looks like, hey, using matplotlib. So first of all, what do we have to do? Well,
1272:45 - we have to rearrange the order of dimensions. In other words, matplotlib likes color channels
1272:53 - last. So let's see what looks this looks like. We'll go image per mute. We've done this before,
1272:59 - image.permute 120 means we're reordering the dimensions. Zero would usually be here,
1273:06 - except that we've taken the zero dimension, the color channels and put it on the end
1273:10 - and shuffled the other two forward. So let's now print out different shapes. I love printing
1273:17 - out the change in shapes. It helps me really understand what's going on. Because sometimes
1273:22 - I look at a line like this and it doesn't really help me. But if I print out something of what
1273:26 - the shapes were originally and what they changed to, well, hey, that's a big help. That's what
1273:31 - Jupiter notebooks are all about, right? So this is going to be color channels first, height,
1273:38 - width. And depending on what data you're using, if you're not using images, if you're using text,
1273:45 - still knowing the shape of your data is a very good thing. We're going to go image per mute.shape
1273:52 - and this should be everything going right is height with color channels on the end here.
1273:58 - And we're just going to plot the image. You can never get enough plotting practice.
1274:04 - Plot the image. You're going to go PLT dot figure, we'll pass in fig size equals 10, 7.
1274:13 - And then we're going to PLT dot in show. We'll pass in the permuted image,
1274:20 - image underscore permutes, and then we'll turn off the axes. And we will set the title to be
1274:27 - class names. And we're going to index on the label, just as we did before. And we're going to set
1274:33 - the font size equal to 14. So it's nice and big. Here we go. Beautiful. There is our image of pizza.
1274:41 - It is very pixelated because we're going from about 512 as the original size 512 by 512 to 64,
1274:47 - 64. I would encourage you to try this out. Potentially, you could use a different image here. So we've
1274:54 - indexed on sample zero. Maybe you want to change this to just be a random image and go through these
1274:59 - steps here. And then if you'd like to see different transforms, I'd also encourage you to try
1275:05 - changing this out, our transform pipeline here, maybe increase the size and see what it looks
1275:10 - like. And if you're feeling really adventurous, you can go into torch vision and look at the
1275:16 - transforms library here and then try one of these and see what it does to our images.
1275:21 - But we're going to keep pushing forward. We are going to look at another way. Or actually,
1275:28 - I think for completeness, let's now turn, we've got a data set. We want to, we wrote up here before
1275:37 - that we wanted to turn our images into a data set, and then subsequently a torch utils data
1275:43 - data loader. So we've done this before, by batching our images, or batching our data that we've
1275:49 - been working with. So I'd encourage you to give this a shot yourself. Try to go through the next
1275:56 - video and create a train data loader using our train data, wherever that is train data,
1276:02 - and a test data loader using our test data. So give that a shot and we'll do it together in the
1276:10 - next video. We'll turn our data sets into data loaders. Welcome back. How'd you go? In the last
1276:19 - video, I issued you the challenge to turn our data sets into data loaders. So let's do that
1276:26 - together now. I hope you gave it a shot. That's the best way to practice. So turn loaded images
1276:30 - into data loaders. So we're still adhering to our PyTorch workflow here. We've got a custom
1276:38 - data set. We found a way to turn it into tenses in the form of data sets. And now we're going to
1276:43 - turn it into a data loader. So we can turn our data sets into iterables or batchify our data.
1276:50 - So let's write down here, a data loader is going to help us turn our data sets into iterables.
1277:01 - And we can customize the batch size, write this down. So our model can see batch size
1277:11 - images at a time. So this is very important. As we touched on in the last section computer vision,
1277:19 - we create a batch size because if we had 100,000 images, chances are if they were all in one data
1277:25 - set, there's 100,000 images in the food 101 data set. We're only working with about 200.
1277:31 - If we try to load all 100,000 in one hit, chances are our hardware may run out of memory. And so
1277:37 - that's why we matchify our images. So if we have a look at this, NVIDIA SMI, our GPU only has 16
1277:45 - gigabytes. I'm using a Tesla T4 right now, well, has about 15 gigabytes of memory. So if we tried
1277:52 - to load 100,000 images into that whilst also computing on them with a PyTorch model,
1277:58 - potentially we're going to run out of memory and run into issues. So instead, we can turn them
1278:03 - into a data loader so that our model looks at 32 images at a time and can leverage all of the
1278:09 - memory that it has rather than running out of memory. So let's turn our train and test data sets
1278:18 - into data loaders, turn train and test data sets into data loaders. Now, this is not just for image
1278:25 - data. This is for all kinds of data in PyTorch. Images, text, audio, you name it. So import data
1278:36 - loader, then we're going to create a train data loader. We're going to set it equal to data loader.
1278:42 - We're going to pass in a data set. So let's set this to train data. Let's set the batch size.
1278:49 - What should we set the batch size to? I'm going to come up here and set a laser capital variable.
1278:54 - I'm going to use 32 because 32 is a good batch size. So we'll go 32 or actually,
1279:01 - let's start small. Let's just start with a batch size of one and see what happens.
1279:05 - Batch size one, number of workers. So this parameter is going to be, this is an important one. I'm going
1279:11 - to, I potentially have covered it before, but I'm going to introduce it again. Is this going to be
1279:15 - how many cores or how many CPU cores that is used to load your data? So the higher the better usually
1279:23 - and you can set this via OS CPU count, which will count how many CPUs your compute hardware has.
1279:32 - So I'll just show you how this works. Import OS and this is a Python OS module. We can do
1279:39 - CPU count to find out how many CPUs our Google Colab instance has. Mine has two,
1279:45 - your number may vary, but I believe most Colab instances have two CPUs. If you're running this on
1279:51 - your local machine, you may have more. If you're running it on dedicated deep learning hardware,
1279:55 - you may even have even more, right? So generally, if you set this to one, it will use one CPU core,
1280:03 - but if you set it to OS dot CPU count, it will use as many as possible. So we're just going to
1280:10 - leave this as one right now. You can customize this to however you want. And I'm going to shuffle
1280:16 - the training data because I don't want my model to recognize any order in the training data. So I'm
1280:21 - going to mix it up. And then I'm going to create the test data loader. Data set equals test data.
1280:29 - And batch size equals one, num workers, I'm going to set this to equal one as well. Again,
1280:36 - you can customize each of these, their hyper parameters to whatever you want. Number of workers
1280:41 - generally the more the better. And then I'm going to set shuffle equals false for the test data so
1280:47 - that if we want to evaluate our models later on, our test data set is always in the same order.
1280:53 - So now let's have a look at train data loader, see what happens. And test data loader.
1281:03 - Wonderful. So we get two instances of torch utils dot data dot data loader. And now we can
1281:09 - see if we can visualize something from the train data loader, as well as the test data loader.
1281:17 - I actually maybe we just visualize something from one of them. So we're not just double
1281:21 - handling everything. We get a length here. Wonderful. Because we're using a batch size of one,
1281:26 - our lengths of our data loaders are the same as our data sets. Now, of course, this would change
1281:34 - if we set, oh, we didn't even set this to the batch size parameter batch size. Let's come down
1281:42 - here and do the same here batch size. So we'll watch this change. If we wanted to look at 32
1281:48 - images at a time, we definitely could do that. So now we have eight batches, because 22, 225
1281:54 - divided by 32 equals roughly eight. And then 75 divided by 32 also equals roughly three. And
1282:02 - remember, these numbers are going to be rounded if there are some overlaps. So let's get rid of,
1282:08 - we'll change this back to one. And we'll keep that there. We'll get rid of these two.
1282:14 - And let's see what it looks like to plot an image from our data loader. Or at least have a look at it.
1282:22 - Check out the shapes. That's probably the most important point at this time. We've already
1282:25 - plotted in our things. So let's iterate through our train data loader. And we'll grab the next one.
1282:32 - We'll grab the image and the label. And we're going to print out here. So batch size will now be one.
1282:40 - You can change the batch size if you like. This is just again, another way of getting familiar
1282:46 - with the shapes of our data. So image shape. Let's go image dot shape. And we're going to
1282:57 - write down here. This shape is going to be batch size. This is what our data loader is going to
1283:03 - add to our images is going to add a batch dimension, color channels, height, width. And then print.
1283:12 - Let's check out that label shape. Same thing with the labels. It's going to add a batch
1283:18 - dimension. Label. And let's see what happens. Oh, we forgot the end of the bracket. Beautiful.
1283:28 - So we've got image shape. Our label shape is only one because we have a batch size of one.
1283:34 - And so now we've got batch size one, color channels three, height, width. And if we change this to
1283:41 - 32, what do you think's going to happen? We get a batch size of 32, still three color channels,
1283:49 - still 64, still 64. And now we have 32 labels. So that means within each batch, we have 32
1283:55 - images. And we have 32 labels. We could use this with a model. I'm going to change this back to one.
1284:02 - And I think we've covered enough in terms of loading our data sets. How cool is this?
1284:11 - We've come a long way. We've downloaded a custom data set. We've loaded it into a data set using
1284:16 - image folder turned it into tenses using our data transform and now batchified our custom data set
1284:23 - in data loaders. We've used these with models before. So if you wanted to, you could go right
1284:29 - ahead and build a convolutional neural network to try and find patterns in our image tenses.
1284:34 - But in the next video, let's pretend we didn't have this data loader,
1284:41 - this image folder class available to us. How could we load our image data set so that it's
1284:50 - compatible? Like our image data set here, how could we replicate this image folder class?
1284:58 - So that we could use it with a data loader. Because data load is part of torch utils.data,
1285:04 - you're going to see these everywhere. Let's pretend we didn't have the torch vision.data sets
1285:10 - image folder helper function. And we'll see in the next video, how we can replicate that functionality.
1285:15 - I'll see you there. Welcome back. So over the past few videos, we've been working out how to get
1285:25 - how to get our data from our data folder, pizza, steak, and sushi. We've got images of different
1285:31 - food data here. And we're trying to get it into Tensor format. So we've seen how to do that
1285:35 - with an existing data loader helper function or data set function in image folder. However,
1285:44 - what if image folder didn't exist? And we need to write our own custom data loading function.
1285:50 - Now the premise of this is although it does exist, it's going to be good practice because you might
1285:56 - come across a case where you're trying to use a data set where a prebuilt function doesn't exist.
1286:01 - So let's replicate the functionality of image folder by creating our own data loading class.
1286:08 - So we want a few things. We want to be able to get the class names as a list from our loaded data.
1286:15 - And we want to be able to get our class names as a dictionary as well. So the whole goal of this
1286:22 - video is to start writing a function or a class that's capable of loading data from here into
1286:29 - Tensor format, capable of being used with the PyTorch's data loader class, like we've done here. So we
1286:36 - want to create a data set. Let's start it off. We're going to create another heading here. This is
1286:41 - going to be number five, option two, loading image data with a custom data set. So we want a few
1286:53 - functionality steps here. Number one is one, two, be able to load images from file to one,
1287:03 - two, be able to get class names from the data set, and three, one, two, be able to get classes
1287:13 - as dictionary from the data set. And so let's briefly discuss the pros and cons of creating
1287:21 - your own custom data set. We saw option one was to use a pre-existing data set loader helping
1287:31 - function from torch vision. And it's going to be quite similar if we go torch vision data sets.
1287:39 - Quite similar if you're using other domain libraries here, there we're going to be data
1287:44 - loading utilities. But at the base level of PyTorch is torchutils.data.dataset. Now this is
1287:51 - the base data set class. So we want to build on top of this to create our own image folder loading
1287:58 - class. So what are the pros and cons of creating your own custom data set? Well, let's discuss some
1288:05 - pros. So one pro would be you can create a data set out of almost anything as long as you write
1288:16 - the right code to load it in. And another pro is that you're not limited to PyTorch pre-built
1288:25 - data set functions. A couple of cons would be that even though this is to point number one.
1288:35 - So even though you could create a data set out of almost anything, it doesn't mean that it will
1288:44 - automatically work. It will work. And of course, you can verify this through extensive testing,
1288:50 - seeing if your model actually works, if it actually loads data in the way that you want it. And another
1288:56 - con is that using a custom data set requires us to write more code. So often results in us
1289:05 - writing more code, which could be prone to errors or performance issues. So typically if
1289:14 - something makes it into the PyTorch standard library or the PyTorch domain libraries,
1289:22 - if functionality makes it into here, it's generally been tested many, many times. And it can kind of
1289:28 - be verified that it works quite well with, or if you do use it, it works quite well. Whereas if
1289:34 - we write our own code, sure, we can test it ourselves, but it hasn't got the robustness to begin with,
1289:40 - that is, we could fix it over time, as something that's included in say the PyTorch standard library.
1289:45 - Nonetheless, it's important to be aware of how we could create such a custom data set.
1289:50 - So let's import a few things that we're going to use. We'll import OS, because we're going to be
1289:55 - working with Python's file system over here. We're going to import path lib, because we're going to
1290:02 - be working with file paths. We'll import torch, we don't need to again, but I'm just doing this
1290:06 - for completeness. We're going to import image from pill, the image class, because we want to be
1290:14 - opening images. I'm going to import from torch utils dot data. I'm going to import data set,
1290:20 - which is the base data set. And as I said over here, we can go to data sets, click on torch utils
1290:26 - data dot data set. This is an abstract class representing a data set. And you'll find that this
1290:32 - data set links to itself. So this is the base data set class. Many of the data sets in PyTorch,
1290:38 - the prebuilt functions, subclass this. So this is what we're going to be doing it.
1290:44 - And as a few notes here, all subclasses should overwrite get item. And you should optionally
1290:49 - overwrite land. These two methods, we're going to see this in a future video. For now, we're just
1290:54 - we're just setting the scene here. So from torch vision, we're going to import transforms, because
1291:01 - we want to not only import our images, but we want to transform them into tenses. And from the
1291:08 - Python's typing module, I'm going to import tuple dict and list. So we can put type hints
1291:15 - when we create our class and loading functions. Wonderful. So this is our instance of torch vision
1291:25 - dot data sets image folder, torch vision dot data sets dot image folder. Let's have a look
1291:32 - at the train data. So we want to write a function that can replicate getting the classes from a
1291:38 - particular directory, and also turning them into an index or dictionary that is. So let's build
1291:46 - a helper function to replicate this functionality here. In other words, I'd like to write a helper
1291:52 - function that if we pass it in a file path, such as pizza steak sushi or this data folder,
1291:58 - it's going to go in here. And it's going to return the class names as a list. And it's also going
1292:04 - to turn them into a dictionary, because it's going to be helpful for later on when we'd like to access
1292:10 - the classes and the class to ID X. And if we really want to completely recreate image folder,
1292:17 - well, image folder has this functionality. So we'd like that too. So this is just a little high level
1292:23 - overview of what we're going to be doing. I might link in here that we're going to subclass this.
1292:29 - So all custom data sets in pie torch, often subclass this. So here's what we're going to be doing.
1292:39 - Over the next few videos, we want to be able to load images from a file. Now you could replace
1292:44 - images with whatever data that you're working with the same premise will be here. You want to be
1292:49 - able to get the class names from the data set and want to be able to get classes as a dictionary
1292:53 - from the data set. So we're going to map our samples, our image samples to that class name
1293:00 - by just passing a file path to a function that we're about to write. And some pros and cons of
1293:09 - creating a custom data set. We've been through that. Let's in the next video, start coding up a
1293:14 - helper function to retrieve these two things from our target directory. In the last video,
1293:23 - we discussed the exciting concept of creating a custom data set. And we wrote down a few things
1293:29 - that we want to get. We discussed some pros and cons. And we learned that many custom data sets
1293:34 - inherit from torch dot utils dot data data set. So that's what we'll be doing later on. In this
1293:40 - video, let's focus on writing a helper function to recreate this functionality. So I'm going to
1293:46 - title this 5.1, creating a helper function to get class names. I'm going to turn this into
1293:55 - markdown. And if I go into here, so we want to function to let's write down some steps and then
1294:02 - we'll code it out. So we'll get the class names, we're going to use OS dot scanner. So it's going
1294:09 - to scanner directory to traverse a target directory. And ideally, the directory is in standard image
1294:22 - classification format. So just like the image folder class, our custom data class is going to
1294:31 - require our data already be formatted. In the standard image classification format, such as
1294:37 - train and test for training and test images, and then images for a particular class are in a
1294:42 - particular directory. So let's keep going. And number two, what else do we want it to do? We want
1294:49 - it to raise an error if the class names aren't found. So if this happens, there might be,
1294:57 - we want this to enter the fact that there might be something wrong with the directory structure.
1295:04 - And number three, we also want to turn the class names into our dict and a list and return them.
1295:15 - Beautiful. So let's get started. Let's set up the path directory
1295:19 - for the target directory. So our target directory is going to be what the directory we want to load
1295:28 - directory, if I could spell, we want to load our data from, let's start with the training
1295:33 - der, just for an example. So target directory, what do we get? So we're just going to use the
1295:41 - training folder as an example to begin with. And we'll go print target der, we'll put in the target
1295:49 - directory, just want to exemplify what we're doing. And then we're going to get the class names
1295:57 - from the target directory. So I'll show you the functionality of our scanner. Of course,
1296:03 - you could look this up in the Python documentation. So class names found, let's set this to be sorted.
1296:11 - And then we'll get the entry name, entry dot name for entry in list. So we're going to get OS list
1296:22 - scanner of the image path slash target directory. Let's see what happens when we do this.
1296:32 - Target directory have we got the right brackets here.
1296:35 - Now, is this going to work? Let's find out. Oh, image path slash target directory.
1296:48 - What do we get wrong? Oh, we don't need the image path there. Let's put, let's just put target
1296:53 - directory there. There we go. Beautiful. So we set up our target directory as been the training
1297:01 - to. And so if we just go, let's just do list. What happens if we just run this function here?
1297:09 - Oh, a scanner. Yeah, so there we go. So we have three directory entries. So this is where we're
1297:15 - getting entry dot name for everything in the training directory. So if we look in the training
1297:21 - directory, what do we have train? And we have one entry for pizza, one entry for sushi, one entry
1297:27 - for steak. Wonderful. So now we have a way to get a list of class names. And we could quite easily
1297:33 - turn this into a dictionary, couldn't we? Which is exactly what we want to do. We want to recreate
1297:38 - this, which we've done. And we want to recreate this, which is also done. So now let's take this
1297:44 - functionality here. And let's turn that into a function. All right, what can we do? What do we
1297:51 - call this? I'm going to call this def fine classes. And I'm going to say that it takes in a directory
1297:58 - which is a string. And it's going to return. This is where I imported typing from Python type and
1298:05 - imported tuple. And I'm going to return a list, which is a list of strings and a dictionary,
1298:13 - which is strings map to integers. Beautiful. So let's keep going. We want to, we want this
1298:24 - function to return given a target directory, we want it to return these two things. So we've seen
1298:30 - how we can get a list of the directories in a target directory by using OS scanner. So let's
1298:36 - write finds the classes are the class folder names in a target directory. Beautiful. And we know
1298:47 - that it's going to return a list and a dictionary. So let's do step number one, we want to get the
1298:54 - class names by scanning the target directory. We'll go classes, just we're going to replicate the
1299:04 - functionality we've done about, but for any given directory here. So classes equals sorted entry
1299:11 - dot name for entry in OS scanner. And we're going to pass at the target directory. If entry dot is
1299:24 - dirt, we're just going to make sure it's a directory as well. And so if we just return classes and see
1299:31 - what happens. So find classes, let's pass it in our target directory, which is our training directory.
1299:39 - What do we get? Beautiful. So we need to also return class to ID X. So let's keep going. So number
1299:49 - two is let's go raise an error. If class names could not be found. So if not classes, let's say
1300:00 - raise file, we're going to raise a file not found error. And then let's just write in here F
1300:09 - couldn't find any classes in directory. So we're just writing some error checking code here.
1300:19 - So if we can't find a class list within our target directory, we're going to raise this
1300:23 - error and say couldn't find any classes in directory, please check file structure. And there's another
1300:32 - checkup here that's going to help us as well to check if the entry is a directory. So finally,
1300:38 - let's do number three. What do we want to do? So we want to create a dictionary of index labels.
1300:44 - So computers, why do we do this? Well, computers prefer numbers rather than strings as labels. So we
1300:55 - can do this, we've already got a list of classes. So let's just create class to ID X equals class
1301:03 - name, I for I class name in enumerate classes. Let's see what this looks like.
1301:18 - So we go class names, and then class to ID X, or we can just return it actually. Do we spell
1301:25 - enumerate role? Yes, we did. So what this is going to do is going to map a class name to an integer
1301:31 - or to I for I class name in enumerate classes. So it's going to go through this, and it's going
1301:37 - to go for I. So the first one zero is going to be pizza. Ideally, one will be steak,
1301:42 - two will be sushi. Let's see how this goes. Beautiful. Look at that. We've just replicated
1301:49 - the functionality of image folder. So now we can use this helper function in our own custom
1301:56 - data set, find classes to traverse through a target directory, such as train, we could do the
1302:02 - same for test if we wanted to to. And that way, we've got a list of classes. And we've also got
1302:09 - a dictionary mapping those classes to integers. So now let's in the next video move towards sub
1302:17 - classing torch utils dot data dot data set. And we're going to fully replicate image folder. So I'll see you there.
1302:30 - In the last video, we wrote a great helper function called find classes that takes in a target
1302:35 - directory and returns a list of classes and a dictionary mapping those class names to an integer.
1302:42 - So let's move forward. And this time, we're going to create a custom data set. To replicate
1302:50 - image folder. Now we don't necessarily have to do this, right, because image folder already exists.
1302:56 - And if something already exists in the pie torch library, chances are it's going to be tested well,
1303:01 - it's going to work efficiently. And we should use it if we can. But if we needed some custom
1303:08 - functionality, we can always build up our own custom data set by sub classing torch dot utils
1303:14 - dot data data set. Or if a pre built data set function didn't exist, well, we're probably going
1303:20 - to want to subclass torch utils data dot data set anyway. And if we go into the documentation here,
1303:26 - there's a few things that we need to keep in mind when we're creating our own custom data set.
1303:30 - All data sets that represent a map from keys to data samples. So that's what we want to do.
1303:35 - We want to map keys, in other words, targets or labels to data samples, which in our case are
1303:41 - food images. So we should subclass this class here. Now to note, all subclasses should overwrite
1303:50 - get item. So get item is a method in Python, which is going to get an item or get a sample,
1303:57 - supporting fetching a data sample for a given key. So for example, if we wanted to get sample
1304:03 - number 100, this is what get item should support and should return us sample number 100.
1304:09 - And subclasses could also optionally override land, which is the length of a data set. So return
1304:15 - the size of the data set by many sampler implementations and the default options of data
1304:20 - loader, because we want to use this custom data set with data loader later on. So we should keep
1304:27 - this in mind when we're building our own custom subclasses of torch utils data data set. Let's see
1304:34 - this hands on, we're going to break it down. It's going to be a fair bit of code, but that's all right.
1304:38 - Nothing that we can't handle. So to create our own custom data set, we want to number one,
1304:48 - first things first is we're going to subclass subclass torch dot utils dot data dot data set.
1304:55 - Two, what do we want to do? We want to init our subclass with target directory. So the directory
1305:07 - we'd like to get data from, as well as a transform, if we'd like to transform our data. So just like
1305:18 - when we used image folder, we could pass a transform to our data set, so that we could transform the
1305:25 - data that we were loading. We want to do the same thing. And we want to create several attributes.
1305:33 - Let's write them down here. We want paths, which will be the parts of our images. What else do
1305:41 - we want? We want transform, which will be the transform we'd like to use. We want classes,
1305:50 - which is going to be a list of the target classes. And we want class to ID X, which is going to be
1306:00 - a dict of the target classes, mapped to integer labels. Now, of course, these attributes will
1306:10 - differ depending on your data set. But we're replicating image folder here. So these are just
1306:16 - some of the things that we've seen that come with image folder. But regardless of what data set
1306:22 - you're working with, there are probably some things that you want to cross them universal.
1306:26 - You probably want all the paths of where your data is coming from, the transforms you'd like to
1306:31 - perform on your data, what classes you're working with, and a map of those classes to an index.
1306:37 - So let's keep pushing forward. We want to create a function to load images, because after all,
1306:44 - we want to open some images. So this function will open an image. Number five, we want to
1306:52 - overwrite the LAN method to return the length of our data set. So just like it said in the documentation,
1307:05 - if you subclass using torch.utils.data, the data set, you should overwrite get item,
1307:12 - and you should optionally overwrite LAN. So we're going to, instead of optionally, we are going to
1307:17 - overwrite length. And number six, we want to overwrite the get item method to return a given sample
1307:29 - when passed an index. Excellent. So we've got a fair few steps here. But if they don't make
1307:39 - sense now, it's okay. Let's code it out. Remember our motto, if and doubt, code it out. And if
1307:45 - and doubt, run the code. So we're going to write a custom data set. This is so exciting, because
1307:51 - when you work with prebuilt data sets, it's pretty cool in machine learning. But when you can write
1307:57 - code to create your own data sets, and that's, well, that's magic. So number one is we're going to,
1308:05 - or number zero is we're going to import torch utils data set, we don't have to rewrite this,
1308:11 - we've already imported it, but we're going to do it anyway for completeness. Now step number one
1308:16 - is to subclass it subclass torch utils data, the data set. So just like when we built a model,
1308:25 - we're going to subclass and in module, but in this time, we're going to call us our class
1308:30 - image folder custom. And we're going to inherit from data set. This means that all the functionality
1308:37 - that's contained within torch utils data data set, we're going to get for our own custom class.
1308:44 - Number two, let's initialize. So we're going to initialize
1308:49 - our custom data set. And there's a few things that we'd like, and into our subclass with the
1308:54 - target directory, the directory we'd like to get data from, as well as the transform if we'd
1309:00 - like to transform our data. So let's write a knit function, a knit, and we're going to go self,
1309:07 - target, and target is going to be a string. And we're going to set a transform here,
1309:15 - we'll set it equal to none. Beautiful. So this way we can pass in a target directory of images
1309:24 - that we'd like to load. And we can also pass in a transform, just similar to the transforms that
1309:29 - we've created previously. So now we're up to number three, which is create several attributes. So
1309:35 - let's see what this looks like, create class attributes. So we'll get all of the image paths.
1309:44 - So we can do this just like we've done before, self paths equals list, path lib dot path,
1309:52 - because what's our target directory going to be? Well, I'll give you a spoiler alert,
1309:56 - it's going to be a path like the test directory, or it's going to be the train directory.
1310:02 - Because we're going to use this once for our test directory and our train directory,
1310:08 - just like we use the original image folder. So we're going to go through the target directory
1310:15 - and find out all of the paths. So this is getting all of the image paths that support
1310:23 - or that follow the file name convention of star star dot jpg. So if we have a look at this,
1310:31 - we passed in the test folder. So test is the folder star would mean any of these 123 pizza
1310:38 - steak sushi, that's the first star, then slash would go into the pizza directory. The star here
1310:44 - would mean any of the file combinations here that end in dot jpg. So this is getting us a list of
1310:50 - all of the image paths within a target directory. In other words, within the test directory and
1310:56 - within the train directory, when we call these two separately. So let's keep going, we've got all
1311:02 - of the image parts, what else did we have to do? We want to create transforms. So let's set up
1311:06 - transforms, self dot transforms equals transform. Oh, we'll just call that transform actually,
1311:16 - set up transform equals transform. So we're going to get this from here. And I put it as
1311:25 - none because it transform can be optional. So let's create classes and class to ID X attributes,
1311:33 - which is the next one on our list, which is here classes and class to ID X. Now, lucky us,
1311:39 - in the previous video, we created a function to return just those things. So let's go self dot
1311:46 - classes and self dot class to ID X equals find classes. And we're going to pass in the target
1311:56 - der or the target der from here. Now, what's next? We've done step number three, we need
1312:05 - number four is create a function to load images. All right, let's see what this looks like. So
1312:10 - number four, create a function to load images. So let's call it load image. And we're going to
1312:20 - pass in self. And we'll also pass in an index. So the index of the image we'd like to load.
1312:26 - And this is going to return an image dot image. So where does that come from? Well, previously,
1312:33 - we imported from pill. So we're going to use Python image library or pillow to import our
1312:39 - images. So we're going to give on a file path from here, such as pizza, we're going to import
1312:45 - it with the image class. And we can do that using, I believe it's image dot open. So let's give that
1312:50 - a try. I'll just write a note in here, opens an image via a path and returns it. So let's write
1313:00 - image path equals self. This is why we got all of the image paths above. So self dot paths. And
1313:08 - we're going to index it on the index. Beautiful. And then let's return image dot open image path.
1313:17 - So we're going to get a particular image path. And then we're just going to open it.
1313:22 - So now we're up to step number five, override the land method to return the length of our data set.
1313:29 - This is optional, but we're going to do it anyway. So overwrite.
1313:34 - Len. So this just wants to return how many samples we have in our data set. So let's write that
1313:43 - def, Len. So if we call Len on our data set instance, it's going to return just how many numbers there
1313:51 - are. So let's write this down. Returns the total number of samples. And this is just going to be
1313:59 - simply return length or Len of self dot paths. So for our target directory, if it was the training
1314:08 - directory, we'd return the number of image paths that this code has found out here. And same for the
1314:16 - test directory. So next, I'm going to go number six is we want to overwrite, we put this up here,
1314:26 - the get item method. So this is required if we want to subclass torch utils data data set. So
1314:32 - this is in the documentation here. All subclasses should override get item. So we want get item to,
1314:38 - if we pass it an index to our data set, we want it to return that particular item. So let's see
1314:43 - what this looks like. Override the get item method to return our particular sample.
1314:51 - And now this method is going to leverage get item, all of the code that we've created above.
1315:00 - So this is going to go take in self, which is the class itself. And it's going to take in an index,
1315:06 - which will be of an integer. And it's going to return a tuple of torch dot tensor and an integer,
1315:15 - which is the same thing that gets returned when we index on our training data. So if we have a
1315:21 - look image label equals train data, zero, get item is going to replicate this. We pass it an index here.
1315:33 - Let's check out the image and the label. This is what we have to replicate. So remember train
1315:39 - data was created with image folder from torch vision dot data sets. And so we will now get item
1315:45 - to return an image and a label, which is a tuple of a torch tensor, where the image is of a tensor
1315:51 - here. And the label is of an integer, which is the label here, the particular index as to which
1315:59 - this image relates to. So let's keep pushing forward. I'm going to write down here, returns one sample
1316:08 - of data, data and label, X and, or we'll just go XY. So we know that it's a tuple. Beautiful.
1316:20 - So let's set up the image. What do we want the image to be? Well, this is where we're going to
1316:28 - call on our self dot load image function, which is what we've created up here. Do you see the
1316:34 - customization capabilities of creating your own class? So we've got a fair bit of code here,
1316:40 - right? But essentially, all we're doing is we're just creating functions that is going to help us
1316:44 - load our images into some way, shape or form. Now, again, I can't stress this enough, regardless
1316:50 - of the data that you're working on, the pattern here will be quite similar. You'll just have to
1316:55 - change the different functions you use to load your data. So let's load an image of a particular
1317:02 - index. So if we pass in an index here, it's going to load in that image. Then what do we do? Well,
1317:08 - we want to get the class name, which is going to be self dot paths. And we'll get the index here,
1317:15 - and we can go parent dot name. So this expects path in format data,
1317:24 - folder slash class name slash image dot JPG. That's just something to be aware of. And the class
1317:33 - ID X is going to be self dot class to ID X. And we will get the class name here.
1317:42 - So now we have an image by loading in the image here. We have a class name by because our data
1317:50 - is going to be or our data is currently in standard image classification format. You may have to
1317:55 - change this depending on the format your data is in, we can get the class name from that,
1317:59 - and we can get the class ID X by indexing on our attribute up here, our dictionary of class names
1318:06 - to indexes. Now we have one small little step. This is transform if necessary. So remember our
1318:16 - transform parameter up here. If we want to transform our target image, well, let's put in if self dot
1318:22 - transform if the transform exists, let's pass the image through that transform, transform image
1318:29 - and then we're going to also return the class ID X. So do you notice how we've returned a
1318:37 - tuple here? This is going to be a torch tensor. If our transform exists and the class ID X is also
1318:44 - going to be returned, which is what we want here, X and Y, which is what gets returned here,
1318:51 - image as a tensor label as an integer. So return data label X, Y, and then if the transform doesn't
1319:02 - exist, let's just return image class ID X, return untransformed image and label. Beautiful. So
1319:17 - that is a fair bit of code there. So you can see the pro of subclassing torch utils data that data
1319:24 - set is that we can customize this in almost any way we wanted to to load whatever data that we're
1319:29 - working with, well, almost any data. However, because we've written so much code, this may be
1319:34 - prone to errors, which we're going to find out in the next video to see if it actually works.
1319:39 - But essentially, all we've done is we've followed the documentation here torch dot utils data
1319:43 - dot data set to replicate the functionality of an existing data loader function, namely image folder.
1319:51 - So if we scroll back up, ideally, if we've done it right, we should be able to write code like this,
1319:58 - passing in a root directory, such as a training directory, a particular data transform.
1320:03 - And we should get very similar instances as image folder, but using our own custom data set class.
1320:10 - So let's try that out in the next video. So now we've got a custom image folder class
1320:20 - that replicates the functionality of the original image folder, data loader class,
1320:26 - or data set class, that is, let's test it out. Let's see if it works on our own custom data.
1320:32 - So we're going to create a transform here so that we can transform our images raw jpeg images into tenses,
1320:43 - because that's the whole goal of importing data into pytorch. So let's set up a train transforms
1320:49 - compose. We're going to set it to equal to transforms dot compose. And I'm going to pass in a list here,
1320:57 - that it's going to be transforms, we're going to resize it to 6464. Whatever the image size will
1321:05 - reduce it down to 6464. Then we're going to go transforms dot random horizontal flip. We don't
1321:12 - need to necessarily flip them, but we're going to do it anyway, just to see if it works. And then
1321:18 - let's put in here transforms dot to tensor, because our images are getting opened as a pill image,
1321:25 - using image dot open. But now we're using the to transform transform from pytorch or torch
1321:33 - visions dot transforms. So I'll just put this here. From torch vision dot transforms, that way you
1321:41 - know where importing transforms there. And let's create one for the test data set as well, test
1321:47 - transforms, we'll set this up. Oh, excuse me, I need to just go import transforms. And let's go
1321:56 - transforms dot compose. And we'll pass in another list, we're going to do the exact same as above,
1322:01 - we'll set up resize, and we'll set the size equal to 6464. And then transforms, we're going to go
1322:10 - dot to tensor, we're going to skip the data augmentation for test data. Because typically,
1322:16 - you don't manipulate your test data in terms of data augmentation, you just convert it into a
1322:23 - tensor, rather than manipulate its orientation, shape, size, etc, etc. So let's run this.
1322:31 - And now let's see how image folder custom class works. Test out image folder custom.
1322:41 - Let's go, we'll set up the train data custom is equal to image folder custom. And then we'll set up
1322:50 - the target, which is equal to the training directory. And then we'll pass in the transform,
1322:56 - which is equal to the train transforms, which we just created above train transforms. And then
1323:04 - we're going to, I think that's all we need, actually, we only had two parameters that we're not going
1323:09 - to use a target transform, because our labels, we've got to help a function to transform our labels.
1323:13 - So test data custom is going to be image folder custom. And I'm going to set up the target to be
1323:20 - equal to the test directory. And the transform is going to be the test transforms from the cell
1323:26 - above there. And what's co lab telling me there? Oh, I'm going to set that up. Did we spell
1323:34 - something? Oh, we spelled it wrong train transforms. There we go. Beautiful. Now let's have a look at
1323:40 - our train data and test data custom. See if it worked. What do we have? Or we have an image folder
1323:49 - custom. Well, it doesn't give us as much rich information as just checking it out as it does
1323:54 - for the train data. But that's okay. We can still inspect these. So this is our original one made
1324:01 - with image folder. And we've got now train data custom and test data custom. Let's see if we can
1324:07 - get some information from there. So let's check the original length of the train data and see if
1324:13 - we can use the land method on our train data custom. Did that work? Wonderful. Now how about we do it
1324:19 - for the original test data made with image folder and our custom version made with test data or
1324:26 - image folder custom. Beautiful. That's exactly what we want. And now let's have a look at the
1324:32 - train data custom. Let's see if the classes attribute comes up. Dot classes. And we'll just leave that
1324:40 - there. We'll do the class dot ID X. Yes, it is. So this attribute here is I wonder if we get
1324:49 - information from Google co lab loading. What do we get? Oh, classes to ID X classes load image
1324:54 - paths transform. So if we go back up here, all these attributes are from here paths transform
1325:03 - classes class to ID X as well as load image. So this is all coming from the code that we wrote
1325:09 - our custom data set class. So let's keep pushing forward. Let's have a look at the class to ID X.
1325:16 - Do we get the same as what we wanted before? Yes, we do beautiful a dictionary containing our
1325:21 - string names and the integer associations. So let's now check for equality. We can do this by going
1325:31 - check for equality between original image folder data set and image folder custom data set. Now
1325:43 - we've kind of already done that here, but let's just try it out. Let's go print. Let's go train
1325:49 - data custom dot classes. Is that equal to train? Oh, I don't want three equals train data. The
1325:58 - original one classes and also print. Let's do test data custom dot classes. Is this equal to
1326:08 - test data? The original one classes. True and true. Now you could try this out. In fact,
1326:16 - it's a little exercise to try it out to compare the others. But congratulations to us, we have
1326:24 - replicated the main functionality of the image folder data set class. And so the takeaways from
1326:30 - this is that whatever data you have, PyTorch gives you a base data set class to inherit from.
1326:37 - And then you can write a function or a class that somehow interacts with whatever data you're
1326:43 - working with. So in our case, we load in an image. And then you, as long as you override the land
1326:49 - method and the get item method and return some sort of values, well, you can create your own
1326:56 - data set loading function. How beautiful is that? So that's going to help you work with your own
1327:02 - custom data sets in PyTorch. So let's keep pushing forward. We've seen analytically that
1327:08 - our custom data set is quite similar to the original PyTorch, torch vision dot data sets
1327:14 - image folder data set. But you know what I like to do? I like to visualize things. So let's in
1327:20 - the next video, create a function to display some random images from our trained data custom class.
1327:27 - It's time to follow the data explorer's motto of visualize, visualize, visualize. So let's
1327:37 - create another section. I'm going to write here a title called create a function to display random
1327:46 - images. And sure, we've, we've had a look at the different attributes of our custom data set.
1327:52 - We see that it gives back a list of different class names. We see that the lengths are similar
1327:57 - to the original, but there's nothing quite like visualizing some data. So let's go in here. We're
1328:04 - going to write a function, a helper function. So step number one, we need to take in a data set.
1328:11 - So one of the data sets that we just created, whether it be trained data custom or trained data.
1328:15 - And a number of other parameters, such as class names and how many images to visualize. And then
1328:29 - step number two is to prevent the display getting out of hand. Let's cap the number of
1328:39 - images to see at 10. Because look, if our data set is going to be thousands of images and we want
1328:45 - to put in a number of images to look at, let's just make sure it's the maximum is 10. That should
1328:50 - be enough. So we'll set the random seed for reproducibility. Number four is, let's get a list of random
1329:00 - samples. So we want random sample indexes, don't just get rid of this s from what do we want it from
1329:08 - from the target data set. So we want to take in a data set, and we want to count the number of
1329:15 - images we're seeing, we want to set a random seed. And do you see how much I use randomness here to
1329:21 - really get an understanding of our data? I really, really, really love harnessing the power of
1329:26 - randomness. So we want to get a random sample of indexes from all of our data set. And then we're
1329:32 - going to set up a matplotlib plot. Then we want to loop through the random sample images.
1329:41 - And plot them with matplotlib. And then as a side to this one, step seven is we need to make sure
1329:50 - the dimensions of our images line up with matplotlib. So matplotlib needs a height width color channels.
1330:00 - All right, let's take it on, hey? So number one is create a function to take in a data set.
1330:10 - So we're going to call this def, let's call it def display random images going to be one of our
1330:16 - helper functions. We've created a few type of functions like this. But let's take in a data set,
1330:21 - which is torch utils of type that is of type data set. Then we're going to take in classes,
1330:27 - which is going to be a list of different strings. So this is going to be our class names for
1330:32 - whichever data set we're using. I'm going to set this equal to none. And then we're going to take in
1330:38 - n, which is the number of images we'd like to plot. And I'm going to set this to 10 by default. So
1330:43 - we can see 10 images at a time, 10 random images, that is, do we want to display the shape? Let's
1330:49 - set that equal to true, so that we can display what the shape of the images, because we're passing
1330:54 - it through our transform as it goes into a data set. So we want to see what the shape of our
1331:01 - images are just to make sure that that's okay. And we can also let's set up a seed, which is
1331:07 - going to be an integer, and we'll set that to none to begin with as well. Okay, so step number two,
1331:13 - what do we have above? We have to prevent the display getting out of hand, let's cap the number
1331:17 - of images to see at 10. So we've got n is by default, it's going to be 10, but let's just make
1331:23 - sure that it stays there. Adjust display, if n is too high. So if n is greater than 10,
1331:32 - let's just readjust this, let's set n equal to 10, and display shape, we'll turn off the
1331:39 - display shape, because if we have 10 images, our display may get out of hand. So just print out
1331:45 - here for display purposes, and shouldn't be larger than 10, setting to 10, and removing
1331:57 - shape display. Now I only know this because I've had experience cooking this dish before.
1332:01 - In other words, I've written this type of code before. So you can customize the beautiful thing
1332:06 - about Python and PyTorch, as you can customize these display functions in any way you see fit.
1332:12 - So step number three, what are we doing? Set the random seed for reproducibility. Okay,
1332:17 - set the seed. So if seed, let's set random dot seed equal to that seed value, and then we can keep
1332:25 - and then we can keep going. So number four is let's get some random sample indexes. So we can do
1332:32 - that by going get random sample indexes, which is step number four here. So we've got a target
1332:39 - data set that we want to inspect. We want to get some random samples from that. So let's create a
1332:45 - random samples IDX list. And I'm going to randomly sample from a length of our data set, or sorry,
1332:54 - a range of the length of our data set. And I'll show you what this means in a second.
1333:00 - And the K, excuse me, have we got enough brackets there? I always get confused with the brackets.
1333:06 - The K is going to be n. So in this case, I want to randomly sample 10 images from the length of
1333:11 - our data set or 10 indexes. So let's just have a look at what this looks like. We'll put in here,
1333:18 - our train data custom here. So this is going to take a range of the length of our train data
1333:24 - custom, which is what 225. We looked at that before, just up here, length of this. So between zero
1333:32 - and 255, we're going to get 10 indexes if we've done this correctly. Beautiful. So there's 10
1333:37 - random samples from our train data custom, or 10 random indexes, that is. So we're up to step number
1333:44 - five, which was loop through the random sample images or indexes. Let's create this to indexes,
1333:53 - indexes and plot them with matplotlib. So this is going to give us a list here.
1333:59 - So let's go loop through random indexes and plot them with matplotlib. Beautiful. So for
1334:10 - i tug sample in enumerate, let's enumerate through the random, random samples, idx list.
1334:22 - And then we're going to go tug image and tug label, because all of the samples in our target
1334:30 - data set are in the form of tuples. So we're going to get the target image and the target label,
1334:36 - which is going to be data set tug sample. We'll take the index. So it might be one of these values
1334:43 - here. We'll index on that. And the zero index will be the image. And then we'll go on the data set as
1334:51 - well. We'll take the tug sample index. And then the index number one will be the label of our target
1334:58 - sample. And then number seven, oh, excuse me, we've missed a step. That should be number six.
1335:08 - Did you catch that? Number five is setup plot. So we can do this quite easily by going plot
1335:14 - figure. This is so that each time we iterate through another sample, we're going to have
1335:20 - quite a big figure here. So we set up the plot outside the loop so that we can add a plot to this
1335:27 - original plot here. And now this is number seven, where we make sure the dimensions of our images
1335:34 - line up with matplotlib. So if we recall by default, pytorch is going to turn our image dimensions into
1335:39 - what color channels first, however, matplotlib prefers color channels last. So let's go adjust,
1335:47 - tensor dimensions for plotting. So let's go tag image. Let's call this tag image adjust equals
1335:58 - tag image dot commute. And we're going to alter the order of the indexes. So this is going to go
1336:06 - from color channels or the dimensions that is height width. And we're going to change this width,
1336:14 - if I could spell, to height width color channels. Beautiful. That one will probably catch you off
1336:23 - guard a few times. But we've seen it a couple of times now. So we're going to keep going with this
1336:29 - plot adjusted samples. So now we can add a subplot to our matplotlib plot. And we want to create,
1336:36 - we want one row of n images, this will make a lot more sense when we visualize it. And then for
1336:44 - the index, we're going to keep track of i plus one. So let's keep going. So then we're going to go
1336:52 - plot in show. And I'm going to go tug image adjust. So I'm going to plot this image here. And then
1337:01 - let's turn off the axis. And we can go if the classes variable exists, which is up here, a list
1337:11 - of classes, let's adjust the title of the plot to be the particular index in the class list. So
1337:18 - title equals f class. And then we're going to put in here classes. And we're going to index on that
1337:26 - with the target label index, which is going to come from here. Because that's going to be a new
1337:31 - numerical format. And then if display shape, let's set the title equal to title plus f. We're going
1337:42 - to go new line shape. This is going to be the shape of the image, tug image adjust dot shape.
1337:50 - And then we'll set the title to PLT dot title. So you see how if we have display shape, we're
1337:57 - just adjusting the title variable that we created here. And then we're putting the title onto the
1338:02 - plot. So let's see how this goes. That is quite a beautiful function. Let's pass in one of our
1338:09 - data sets and see what it looks like. Let's plot some random images. So which one should we start
1338:15 - with first? So let's display random images from the image folder created data sets. So this is the
1338:23 - inbuilt pytorch image folder. Let's go display random images, the function we just created above.
1338:30 - We're going to pass in the train data. And then we can pass in the number of images. Let's have
1338:34 - a look at five. And the classes is going to be the class names, which is just a list of our
1338:41 - different class names. And then we can set the seed, we want it to be random. So we'll just set
1338:46 - the seed to equal none. Oh, doesn't that look good? So this is from our original train data
1338:55 - made with image folder. So option number one up here, option one, there we go. And we've
1339:02 - passed in the class name. So this is sushi resize to 64, 64, three, same with all of the others,
1339:08 - but from different classes. Let's set the seed to 42, see what happens. I get these images,
1339:14 - we got a sushi, we got a pizza, we got pizza, sushi pizza. And then if we try a different one,
1339:21 - we just go none. We get random images again, wonderful. Now let's write the same code,
1339:29 - but this time using our train data custom data set. So display random images from the image folder
1339:38 - custom data set. So this is the one that we created display random images. I'm going to pass
1339:46 - in train data custom, our own data set. Oh, this is exciting. Let's set any equal to 10 and just see
1339:53 - see how far we can go with with our plot. Or maybe we set it to 20 and just see if our
1339:58 - code for adjusting the plot makes sense. Class names and seed equals, I'm going to put in 42 this time.
1340:08 - There we go. For display purposes, and shouldn't be larger than 10 setting to 10 and removing shape
1340:13 - display. So we have a stake image, a pizza image, pizza, steak pizza, pizza, pizza, pizza, steak,
1340:21 - pizza. If we turn off the random seed, we should get another 10 random images here.
1340:26 - Beautiful. Look at that. Steak, steak, sushi, pizza, steak, sushi class. I'm reading out
1340:34 - the different things here. Pizza, pizza, pizza, pizza. Okay. So it looks like our custom data set
1340:41 - is working from both a qualitative standpoint, looking at the different images and a quantitative.
1340:48 - How about we change it to five and see what it looks like? Do we have a different shape? Yes,
1340:52 - we do the same shape as above. Wonderful. Okay. So we've got train data custom.
1341:00 - And we've got train data, which is made from image folder. But the premises remain, we've built up
1341:05 - a lot of different ideas. And we're looking at things from different points of view. We are
1341:10 - getting our data from the folder structure here into tensor format. So there's still one more
1341:17 - step that we have to do. And that's go from data set to data loader. So in the next video,
1341:23 - let's see how we can turn our custom loaded images, train data custom, and test data custom
1341:30 - into data loaders. So you might want to go ahead and give that a try yourself. We've done it before
1341:35 - up here. Turn loaded images into data loaders. We're going to replicate the same thing as we did
1341:40 - in here for our option number two, except this time we'll be using our custom data set.
1341:45 - I'll see you in the next video. I'll take some good looking images and even better that they're
1341:54 - from our own custom data set. Now we've got one more step. We're going to turn our data set into a
1342:00 - data loader. In other words, we're going to batchify all of our images so they can be used with the
1342:05 - model. And I gave you the challenge of trying this out yourself in the last video. So I hope
1342:12 - you gave that a go. But let's see what that might look like in here. So I'm going to go 5.4.
1342:17 - Let's go. What should we call this? So turn custom loaded images into data loaders. So this
1342:26 - is just goes to show that we can write our own custom data set class. And we can still use it
1342:33 - with PyTorch's data loader. So let's go from utils torch dot utils that is utils dot data import
1342:42 - data loader. We'll get that in here. We don't need to do that again, but I'm just doing it for
1342:47 - completeness. So we're going to set this to train data loader custom. And I'm going to create an
1342:52 - instance of data loader here. And then inside I'm going to pass the data set, which is going to be
1342:59 - train data custom. I'm just going to set a universal parameter here in capitals for batch size equals
1343:05 - 32. Because we can come down here, we can set the batch size, we're going to set this equal to 32.
1343:12 - Or in other words, the batch size parameter we set up there, we can set the number of workers
1343:17 - here as well. If you set to zero, let's go see what the default is actually torch utils data loader.
1343:26 - What's the default for number of workers? Zero. Okay, beautiful. And recall that number of workers
1343:34 - is going to set how many cores load your data with a data loader. And generally higher is better.
1343:41 - But you can also experiment with this value and see what value suits your model and your
1343:46 - hardware the best. So just keep in mind that number of workers is going to alter how much
1343:52 - compute your hardware that you're running your code on uses to load your data. So by default,
1343:59 - it's set to zero. And then we're going to shuffle the training data. Wonderful. And let's do the
1344:05 - same for the test data loader. We'll create test data loader custom. And I'm going to create a
1344:10 - new instance. So let me make a few code cells here of data loader, and create a data set or pass
1344:18 - in the data set parameter as the test data custom. So again, these data sets are what we've created
1344:24 - using our own custom data set class. I'm going to set the batch size equal to batch size. And
1344:32 - let's set the number workers equal to zero. In a previous video, we've also set it to CPU count.
1344:38 - You can also set it to one. You can hard code it to four all depends on what hardware you're using.
1344:46 - I like to use OPA OS dot CPU count. And then we're not going to shuffle the test data.
1344:56 - False. Beautiful. And let's have a look at what we get here. Train data loader custom and test
1345:06 - data loader custom. And actually, I'm just going to reset this instead of being OOS CPU count.
1345:10 - I'm going to put it back to zero, just so we've got it in line with the one above.
1345:14 - And of course, numb workers, we could also set this numb workers equals zero or OS dot CPU count.
1345:22 - And then we could come down here and set this as numb workers and numb workers.
1345:30 - And let's have a look to see if it works. Beautiful. So we've got two instances of utils.data.data
1345:38 - loader. Now, let's just get a single sample from the train data loader here, just to make sure the
1345:43 - image shape and batch size is correct. Get image and label from custom data loader. We want image
1345:52 - custom. And I'm going to go label custom equals next. And I'm going to iter over the train data
1345:59 - loader custom. And then let's go print out the shapes. We want image custom dot shape and label
1346:10 - custom. Do we get a shape here? Beautiful. There we go. So we have shape here of 32,
1346:18 - because that is our batch size. Then we have three color channels, 64, 64, which is in line with
1346:24 - what? Which is in line with our transform that we set all the way up here. Transform. We transform
1346:31 - our image. You may want to change that to something different depending on the model you're using,
1346:35 - depending on how much data you want to be comprised within your image. Recall, generally a larger
1346:41 - image size encodes more information. And this is all coming from our original image folder
1346:47 - custom data set class. So look at us go. And I mean, this is a lot of code here or a fair bit of
1346:53 - code, right? But you could think of this as like you write it once. And then if your data set continues
1346:59 - to be in this format, well, you can use this over and over again. So you might put this, this image
1347:05 - folder custom into a helper function file over here, such as data set dot pie or something like
1347:11 - that. And then you could call it in future code instead of rewriting it all the time. And so that's
1347:18 - just exactly what pytorch is done with taught vision dot data sets dot image folder. So we've
1347:23 - got some shapes here. And if we wanted to change the batch size, what do we do? We just change it
1347:27 - like that 64. Remember, a good batch size is also a multiple of eight, because that's going to help
1347:32 - out computing. And batch size equals one. We get a batch size equal of one. We've been through a
1347:43 - fair bit. But we've covered a very important thing. And that is loading your own data with a custom
1347:49 - data set. So generally, you will be able to load your own data with an existing data loading function
1347:54 - or data set function from one of the torch domain libraries, such as torch audio, torch text,
1348:01 - torch vision, torch rack. And later on, when it's out of beta, torch data. But if you need to create
1348:07 - your own custom one, while you can subclass torch dot utils dot data, dot data set, and then add
1348:13 - your own functionality to it. So let's keep pushing forward. Previously, we touched a little bit on
1348:19 - transforming data. And you may have heard me say that torch vision transforms can be used for data
1348:25 - augmentation. And if you haven't, that is what the documentation says here. But data augmentation
1348:33 - is manipulating our images in some way, shape or form, so that we can artificially increase the
1348:39 - diversity of our training data set. So let's have a look at that more in the next video. I'll see you
1348:46 - there. Over the last few videos, we've created functions and classes to load in our own custom
1348:56 - data set. And we learned that one of the biggest steps in loading a custom data set is transforming
1349:03 - your data, particularly turning your target data into tenses. And we also had a brief look at the
1349:10 - torch vision transforms module. And we saw that there's a fair few different ways that we can
1349:14 - transform our data. And that one of the ways that we can transform our image data is through
1349:21 - augmentation. And so if we went into the illustration of transforms, let's have a look at all the
1349:27 - different ways we can do it. We've got resize going to change the size of the original image.
1349:33 - We've got center crop, which will crop. We've got five crop. We've got grayscale. We've got random
1349:39 - transforms. We've got Gaussian blur. We've got random rotation, random caffeine, random crop.
1349:46 - We could keep going. And in fact, I'd encourage you to check out all of the different options here.
1349:51 - But oh, there's auto augment. Wonderful. There's random augment. This is what I was hinting at.
1349:58 - Data augmentation. Do you notice how the original image gets augmented in different ways here?
1350:04 - So it gets artificially changed. So it gets rotated a little here. It gets dark and a little
1350:09 - here or maybe brightened, depending how you look at it, it gets shifted up here. And then the colors
1350:15 - kind of change here. And so this process is known as data augmentation, as we've hinted at.
1350:21 - And we're going to create another section here, which is number six, other forms of transforms.
1350:31 - And this is data augmentation. So how could you find out about what data augmentation is?
1350:37 - Well, you could go here. What is data augmentation? And I'm sure there's going to be plenty of
1350:42 - resources here. Wikipedia. There we go. Data augmentation in data analysis are techniques
1350:48 - used to increase the amount of data by adding slightly modified copies of already existing data
1350:55 - or newly created synthetic data from existing data. So I'm going to write down here,
1351:02 - data augmentation is the process of artificially adding diversity to your training data.
1351:11 - Now, in the case of image data, this may mean applying various image transformations to the
1351:23 - training images. And we saw a whole bunch of those in the torch vision transformed package.
1351:30 - But now let's have a look at one type of data augmentation in particular. And that is trivial
1351:35 - augment. But just to illustrate this, I've got a slide here ready to go. We've got what is data
1351:41 - augmentation. And it's looking at the same image, but from different perspectives. And we do this,
1351:47 - as I said, to artificially increase the diversity of a data set. So if we imagine our original
1351:54 - images over here on the left, and then if we wanted to rotate it, we could apply a rotation
1351:59 - transform. And then if we wanted to shift it on the vertical and the horizontal axis,
1352:04 - we could apply a shift transform. And if we wanted to zoom in on the image, we could apply
1352:10 - a zoom transform. And there are many different types of transforms. As I've got a note here,
1352:16 - there are many different kinds of data augmentation, such as cropping, replacing,
1352:20 - shearing. And this slide only demonstrates a few. But I'd like to highlight another type of data
1352:26 - augmentation. And that is one used to recently train pytorch torch vision image models to state
1352:34 - of the art levels. So let's take a look at one particular type of data augmentation,
1352:43 - used to train pytorch vision models to state of the art levels.
1352:54 - Now, just in case you're not sure why we might do this, we would like to increase
1352:59 - the diversity of our training data so that our images become harder for our model to learn. Or
1353:06 - it gets a chance to view the same image from different perspectives so that when you use your
1353:11 - image classification model in practice, it's seen the same sort of images, but from many different
1353:18 - angles. So hopefully it learns patterns that are generalizable to those different angles.
1353:23 - So this practice, hopefully, results in a model that's more generalizable to unseen data.
1353:36 - And so if we go to torch vision, state of the art, here we go. So this is a recent blog post
1353:48 - by the pytorch team, how to train state of the art models, which is what we want to do,
1353:51 - state of the art means best in business, otherwise known as soda. You might see this acronym quite
1353:57 - often using torch visions latest primitives. So torch vision is the package that we've been
1354:03 - using to work with vision data. And torch vision has a bunch of primitives, which are,
1354:08 - in other words, functions that help us train really good performing models. So blog post here.
1354:16 - And if we jump into this blog post and if we scroll down, we've got some improvements here.
1354:23 - So there's an original ResNet 50 model. ResNet 50 is a common computer vision architecture.
1354:29 - So accuracy at one. So what do we have? Well, let's just say they get a boost in what the previous
1354:35 - results were. So if we scroll down, there is a type of data augmentation here. So if we add up
1354:43 - all of the improvements that they used, so there's a whole bunch here. Now, as your extra curriculum,
1354:48 - I'd encourage you to look at what the improvements are. You're not going to get them all the first
1354:53 - go, but that's all right. Blog posts like this come out all the time and the recipes are continually
1354:58 - changing. So even though I'm showing you this now, this may change in the future. So I just
1355:04 - scroll down to see if this table showed us what the previous results were. Doesn't look like it does.
1355:09 - Oh, no, there's the baseline. So 76 and with all these little additions, it got right up to nearly
1355:15 - 81. So nearly a boost of 5% accuracy. And that's pretty good. So what we're going to have a look
1355:21 - at is trivial augment. So there's a bunch of different things such as learning rate optimization,
1355:26 - training for longer. So these are ways you can improve your model. Random erasing of image data,
1355:32 - label smoothing, you can add that as a parameter to your loss functions, such as cross entropy loss,
1355:37 - mix up and cut mix, weight decay tuning, fixed res mitigations, exponential moving average,
1355:44 - which is EMA, inference resize tuning. So there's a whole bunch of different recipe items here,
1355:49 - but we're going to focus on what we're going to break it down. Let's have a look at trivial
1355:52 - augment. So we'll come in here. Let's look at trivial augment. So if we wanted to look at
1356:01 - trivial augment, can we find it in here? Oh, yes, we can. It's right here. Trivial augment.
1356:06 - So as you'll see, if you pass an image into trivial augment, it's going to change it in a few
1356:12 - different ways. So if we go into here, let's write that down. So let's see this in action on some
1356:21 - of our own data. So we'll import from torch vision, import transforms. And we're going to create a
1356:30 - train transform, which is equal to transforms dot compose. We'll pass it in there. And this is
1356:41 - going to be very similar to what we've done before in terms of composing a transform. What do we
1356:45 - want to do? Well, let's say we wanted to resize one of our images or an image going through this
1356:51 - transform. Let's change its size to 224224, which is a common size in image classification. And
1356:59 - then it's going to go through transforms. We're going to pass in trivial augment wide. And there's
1357:07 - a parameter here, which is number of magnitude bins, which is basically a number from 0 to 31,
1357:14 - 31 being the max of how intense you want the augmentation to happen. So say we, we only put this as
1357:22 - 5, our augmentation would be of intensity from 0 to 5. And so in that case, the maximum wouldn't
1357:29 - be too intense. So if we put it to 31, it's going to be the max intensity. And what I mean by intensity
1357:35 - is say this rotation, if we go on a scale of 0 to 31, this may be a 10, whereas 31 would be
1357:43 - completely rotating. And same with all these others, right? So the lower this number, the less the
1357:50 - maximum up a bound of the applied transform will be. Then if we go transforms dot to tensor,
1357:59 - wonderful. So there we've just implemented trivial augment. How beautiful is that? That is from
1358:07 - the PyTorch torch vision transforms library. We've got trivial augment wide. And it was used
1358:13 - trivial augment to train the latest state of the art vision models in the PyTorch torch vision
1358:21 - models library or models repository. And if you wanted to look up trivial augment, how could you
1358:25 - find that? You could search it. Here is the paper if you'd like to read it. Oh, it's implemented.
1358:31 - It's actually a very, very, I would say, let's just say trivial augment. I didn't want to say
1358:36 - simple because I don't want to downplay it. Trivial augment leverages the power of randomness
1358:40 - quite beautifully. So I'll let you read more on there. I would rather try it out on our data
1358:45 - and visualize it first. Test transform. Let's go transforms compose. And you might have the
1358:52 - question of which transforms should I use with my data? Well, that's the million dollar question,
1358:58 - right? That's the same thing as asking, which model should I use for my data? There's a fair
1359:02 - few different answers there. And my best answer will be try out a few, see what work for other
1359:09 - people like we've done here by finding that trivial augment worked well for the PyTorch team.
1359:14 - Try that on your own problems. If it works well, excellent. If it doesn't work well,
1359:19 - well, you can always excuse me. We've got a spelling mistake. If it doesn't work well,
1359:24 - well, you can always set up an experiment to try something else. So let's test out our
1359:29 - augmentation pipeline. So we'll get all the image paths. We've already done this, but we're
1359:34 - going to do it anyway. Again, just to reiterate, we've covered a fair bit here. So I might just
1359:39 - rehash on a few things. We're going to get list, image path, which is our, let me just show you
1359:47 - our image path. We just want to get all of the images within this file.
1359:52 - So we'll go image path dot glob, glob together all the files and folders that match this pattern.
1359:59 - And then if we check, what do we get? We'll check the first 10. Beautiful. And then we can
1360:07 - leverage our function from the four to plot some random images, plot random images.
1360:14 - We'll pass in or plot transformed random transformed images. That's what we want.
1360:20 - Let's see what it looks like when it goes through our trivial augment. So image paths,
1360:26 - equals image part list. This is a function that we've created before, by the way, transform equals
1360:34 - train transform, which is the transform we just created above that contains trivial augment.
1360:40 - And then we're going to put n equals three for five images. And we'll do seed equals none
1360:45 - to plot. Oh, sorry, n equals three for three images, not five. Beautiful. And we'll set the
1360:52 - seed equals none, by the way. So look at this. We've got class pizza. Now trivial augment,
1360:58 - it resized this. Now, I'm not quite sure what it did to transform it per se. Maybe it got a little
1361:03 - bit darker. This one looks like it's been the colors have been manipulated in some way, shape,
1361:09 - or form. And this one looks like it's been resized and not too much has happened to that one from
1361:16 - my perspective. So if we go again, let's have a look at another three images. So trivial augment
1361:22 - works. And what I said before, it harnesses the power of randomness. It kind of selects randomly
1361:28 - from all of these other augmentation types, and applies them at some level of intensity.
1361:34 - So all of these ones here, trivial augment is just going to select summit random, and then
1361:38 - apply them some random intensity from zero to 31, because that's what we've set on our data.
1361:44 - And of course, you can read a little bit more in the documentation, or sorry, in the paper here.
1361:49 - But I like to see it happening. So this one looks like it's been cut off over here a little bit.
1361:54 - This one again, the colors have been changed in some way, shape, or form. This one's been darkened.
1361:59 - And so do you see how we're artificially adding diversity to our training data set? So instead
1362:04 - of all of our images being this one perspective like this, we're adding a bunch of different
1362:09 - angles and telling our model, hey, you got to try and still learn these patterns, even if they've
1362:14 - been manipulated. So we'll try one more of these. So look at that one. That's pretty
1362:20 - manipulated there, isn't it? But it's still an image of stake. So that's what we're trying to
1362:25 - get our model to do is still recognize this image as an image of stake, even though it's been
1362:28 - manipulated a bit. Now, will this work or not? Hey, it might, it might not, but that's all the
1362:34 - nature of experimentation is. So play around. I would encourage you to go in the transforms
1362:40 - documentation like we've just done, illustrations, change this one out, trivial augment wine,
1362:46 - for another type of augmentation that you can find in here, and see what it does to some of
1362:51 - our images randomly. I've just highlighted trivial augment because it's what the PyTorch team have
1362:57 - used in their most recent blog post for their training recipe to train state-of-the-art vision
1363:02 - models. So speaking of training models, let's move forward and we've got to build our first model
1363:09 - for this section. I'll see you in the next video.
1363:15 - Welcome back. In the last video, we covered how the PyTorch team used trivial augment
1363:21 - wide, which is the latest state-of-the-art in data augmentation at the time of recording this
1363:26 - video to train their latest state-of-the-art computer vision models that are within
1363:31 - torch vision. And we saw how easily we could apply trivial augment thanks to torch vision
1363:37 - dot transforms. And we'll just see one more of those in action, just to highlight what's going on.
1363:45 - So it doesn't look like much happened to that image when we augmented, but we see this one has
1363:49 - been moved over. We've got some black space there. This one has been rotated a little,
1363:53 - and now we've got some black space there. But now's time for us to build our first
1363:59 - computer vision model on our own custom data set. So let's get started. We're going to go model zero.
1364:05 - We're going to reuse the tiny VGG architecture, which we covered in the computer vision section.
1364:11 - And the first experiment that we're going to do, we're going to build a baseline,
1364:15 - which is what we do with model zero. We're going to build it without data augmentation.
1364:19 - So rather than use trivial augment, which we've got up here, which is what the PyTorch team used
1364:26 - to train their state-of-the-art computer vision models, we're going to start by training our
1364:30 - computer vision model without data augmentation. And then so later on, we can try one to see
1364:36 - with data augmentation to see if it helps or doesn't. So let me just put a link in here,
1364:42 - CNN explainer. This is the model architecture that we covered in depth in the last section.
1364:48 - So we're not going to go spend too much time here. All you have to know is that we're going
1364:52 - to have an input of 64, 64, 3 into multiple different layers, such as convolutional layers,
1364:58 - relio layers, max pool layers. And then we're going to have some output layer that suits the
1365:03 - number of classes that we have. In this case, there's 10 different classes, but in our case,
1365:09 - we have three different classes, one for pizza, steak, and sushi. So let's replicate the tiny VGG
1365:17 - architecture from the CNN explainer website. And this is going to be good practice, right?
1365:26 - We're not going to spend too much time referencing their architecture. We're going to spend more
1365:29 - time coding here. But of course, before we can train a model, what do we have to do? Well,
1365:35 - let's go 7.1. We're going to create some transforms and loading data. We're going to load data for
1365:43 - model zero. Now, we could of course use some of the variables that we already have loaded. But
1365:51 - we're going to recreate them just to practice. So let's create a simple transform. And what is
1365:57 - our whole premise of loading data for model zero? We want to get our data from the data folder,
1366:05 - from pizza, steak sushi, from the training and test folders, from their respective folders,
1366:10 - we want to load these images and turn them into tenses. Now we've done this a few times now.
1366:16 - And one of the ways that we can do that is by creating a transform equals transforms dot compose.
1366:24 - And we're going to pass in, let's resize it. So transforms dot resize, we're going to resize our
1366:32 - images to be the same size as the tiny VGG architecture on the CNN explainer website. 64
1366:40 - 64 three. And then we're also going to pass in another transform to tensor. So that our
1366:48 - images get resized to 64 64. And then they get converted into tenses. And particularly,
1366:55 - these values within that tensor are going to be between zero and one. So there's our transform.
1367:02 - Now we're going to load some data. If you want to pause the video here and try to load it yourself,
1367:07 - I'd encourage you to try out option one, loading image data using the image folder class,
1367:12 - and then turn that data set, that image folder data set into a data loader. So batchify it so
1367:20 - that we can use it with a pytorch model. So give that a shot. Otherwise, let's go ahead and do
1367:26 - that together. So one, we're going to load and transform data. We've done this before,
1367:33 - but let's just rehash on it what we're doing. So from torch vision import data sets, then we're
1367:39 - going to create the train data simple. And I call this simple because we're going to use at first
1367:46 - a simple transform, one with no data augmentation. And then later on for another modeling experiment,
1367:52 - we're going to create another transform one with data augmentation. So let's put this here
1367:58 - data sets image folder. And let's go the route equals the training directory. And then the
1368:06 - transform is going to be what? It's going to be our simple transform that we've got above.
1368:11 - And then we can put in test data simple here. And we're going to create data sets dot image
1368:17 - folder. And then we're going to pass in the route as the test directory. And we'll pass in the
1368:22 - transform is going to be the simple transform again above. So we're performing the same
1368:26 - transformation here on our training data, and on our testing data. Then what's the next step
1368:33 - we can do here? Well, we can to turn the data sets into data loaders. So let's try it out.
1368:42 - First, we're going to import OS, then from torch dot utils dot data, we're going to import data
1368:49 - loader. And then we're going to set up batch size and number of workers. So let's go batch size.
1368:58 - We're going to use a batch size of 32 for our first model.
1369:03 - Numb workers, which will be the number of excuse me, got a typo up here classic number of workers,
1369:09 - which will be the what the number of CPU cores that we dedicate towards loading our data.
1369:16 - So let's now create the data loaders. We're going to create train data loader simple,
1369:24 - which will be equal to data loader. And the data set that goes in here will be train data
1369:32 - simple. Then we can set the batch size equal to the batch size parameter that we just created,
1369:37 - or hyper parameter that is, recall a hyper parameter is something that you can set yourself. We
1369:43 - would like to shuffle the training data. And we're going to set numb workers equal to numb workers.
1369:51 - So in our case, how many calls does Google Colab have? Let's just run this. Find out how many
1369:58 - numb workers there are. I think there's going to be two CPUs. Wonderful. And then we're going to do
1370:05 - the same thing for the test data loader. Test data loader simple. We're going to go data loader.
1370:14 - We'll pass in the data set here, which is going to be the test data simple. And then we're going
1370:19 - to go batch size equals batch size. We're not going to shuffle the test data set. And then the
1370:27 - numb workers will just set it to the same thing as we've got above. Beautiful. So I hope you gave
1370:35 - that a shot, but now do you see how quickly we can get our data loaded if it's in the right format?
1370:41 - I know we spent a lot of time going through all of these steps over multiple videos and
1370:46 - writing lots of code, but this is how quickly we can get set up to load our data. We create a
1370:51 - simple transform, and then we load in and transform our data at the same time. And then we turn the
1370:57 - data sets into data loaders just like this. Now we're ready to use these data loaders with a model.
1371:03 - So speaking of models, how about we build the tiny VGG architecture in the next video? And in
1371:10 - fact, we've already done this in notebook number three. So if you want to refer back to the model
1371:15 - that we built there, right down here, which was model number two, if you want to refer back to
1371:21 - this section and give it a go yourself, I'd encourage you to do so. Otherwise, we'll build tiny VGG
1371:27 - architecture in the next video. Welcome back. In the last video, we got set up starting to get
1371:36 - ready to model our first custom data set. And I issued you the challenge to try and replicate
1371:41 - the tiny VGG architecture from the CNN explainer website, which we covered in notebook number
1371:47 - three. But now let's see how fast we can do that together. Hey, I'm going to write down here section
1371:53 - seven point two. And I know we've already coded this up before, but it's good practice to see what
1371:59 - it's like to build pytorch models from scratch, create tiny VGG model class. So the model is going
1372:07 - to come from here. Previously, we created our model, there would have been one big change from
1372:12 - the model that we created in section number three, which is that our model in section number three
1372:18 - used black and white images. But now the images that we have are going to be color images. So
1372:24 - there's going to be three color channels rather than one. And there might be a little bit of a
1372:30 - trick that we have to do to find out the shape later on in the classifier layer. But let's get
1372:35 - started. We've got class tiny VGG, we're going to inherit from nn.module. This is going to be
1372:44 - the model architecture copying tiny VGG from CNN explainer. And remember that it's a it's
1372:55 - quite a common practice in machine learning to find a model that works for a problem similar to
1373:00 - yours and then copy it and try it on your own problem. So I only want two underscores there.
1373:06 - We're going to initialize our class. We're going to give it an input shape, which will be an int.
1373:13 - We're going to say how many hidden units do we want, which will also be an int. And we're going
1373:17 - to have an output shape, which will be an int as well. And it's going to return something none
1373:25 - of type none. And if we go down here, we can initialize it with super dot underscore init.
1373:34 - Beautiful. And now let's create the first COM block. So COM block one, which we'll recall
1373:40 - will be this section of layers here. So COM block one, let's do an nn.sequential to do so.
1373:48 - Now we need com relu com relu max pool. So let's try this out. And then com to D.
1373:57 - The in channels is going to be the input shape of our model. The input shape parameter.
1374:04 - The out channels is going to be the number of hidden units we have, which is from
1374:10 - Oh, I'm gonna just put enter down here input shape hidden units. We're just getting those
1374:15 - to there. Let's set the kernel size to three, which will be how big the convolving window will be
1374:20 - over our image data. There's a stride of one and the padding equals one as well. So these are the
1374:27 - similar parameters to what the CNN explainer website uses. And we're going to go and then
1374:34 - relu. And then we're going to go and then com to D. And I want to stress that even if someone
1374:43 - else uses like certain values for these, you don't have to copy them exactly. So just keep that in
1374:48 - mind. You can try out various values of these. These are all hyper parameters that you can set
1374:53 - yourself. Hidden units, out channels, equals hidden units as well. Then we're going to go kernel
1375:01 - size equals three stride equals one. And we're going to put padding equals one as well.
1375:09 - Then we're going to have another relu layer. And I believe I forgot my comma up here.
1375:15 - Another relu layer here. And we're going to finish off
1375:21 - with an N dot max pool 2D. And we're going to put in the kernel size.
1375:27 - These equals two and the stride here equals two. Wonderful. So oh, by the way, for max
1375:39 - pool 2D, the default stride value is same as the kernel size. So let's have a go here.
1375:47 - What can we do now? Well, we could just replicate this block as block two. So how about we copy this
1375:55 - down here? We've already had enough practice writing this sort of code. So we're going to
1376:00 - go comp block two, but we need to change the input shape here. The input shape of this block
1376:05 - two is going to receive the output shape here. So we need to line those up. This is going to be
1376:10 - hidden units. Hidden units. And I believe that's all we need to change there. Beautiful. So let's
1376:21 - create the classifier layer. And the classifier layer recall is going to be this output layer
1376:27 - here. So we need at some point to add a linear layer. That's going to have a number of outputs
1376:33 - equal to the number of classes that we're working with. And in this case, the number of classes is
1376:37 - 10. But in our case, our custom data set, we have three classes, pizza, steak, sushi. So let's
1376:45 - create a classifier layer, which will be an end sequential. And then we're going to pass in an end
1376:51 - dot flatten to turn the outputs of our convolutional blocks into feature vector into a feature vector
1376:57 - site. And then we're going to have an end dot linear. And the end features, do you remember my
1377:03 - trick for calculating the shape in features? I'm going to put hidden units here for the time being.
1377:09 - Out features is going to be output shape. So I put hidden units here for the time being because
1377:16 - we don't quite yet know what the output shape of all of these operations is going to be. Of course,
1377:22 - we could calculate them by hand by looking up the formula for input and output shapes of convolutional
1377:28 - layers. So the input and output shapes are here. But I prefer to just do it programmatically and let
1377:34 - the errors tell me where I'm wrong. So we can do that by doing a forward pass. And speaking of a
1377:40 - forward pass, let's create a forward method, because every time we have to subclass an end
1377:45 - dot module, we have to override the forward method. We've done this a few times. But as you can see,
1377:51 - I'm picking up the pace a little bit because you've got this. So let's pass in the conv block one,
1377:57 - we're going to go X, then we're going to print out x dot shape. And then we're going to reassign
1378:03 - X to be self.com block two. So we're passing it through our second block of convolutional layers,
1378:10 - print X dot shape to check the shape here. Now this is where our model will probably error
1378:15 - is because the input shape here isn't going to line up in features, hidden units, because we've
1378:20 - passed all of the output of what's going through comp block one, comp block two to a flatten layer,
1378:26 - because we want a feature vector to go into our nn.linear layer, our output layer, which has an
1378:32 - out features size of output shape. And then we're going to return X. So I'm going to print x dot
1378:38 - shape here. And I just want to let you in on one little secret as well. We haven't covered this
1378:43 - before, but we could rewrite this entire forward method, this entire stack of code,
1378:48 - by going return self dot classifier, and then going from the outside in. So we could pass in
1378:55 - comp block two here, comp block two, and then self comp block one, and then X on the inside.
1379:03 - So that is essentially the exact same thing as what we've done here, except this is going to
1379:10 - benefits from operator fusion. Now this topic is beyond the scope of this course,
1379:17 - essentially, all you need to know is that operator fusion behind the scenes speeds up
1379:22 - how your GPU performs computations. So all of these are going to happen in one step,
1379:27 - rather than here, we are reassigning X every time we make a computation through these layers.
1379:33 - So we're spending time going from computation back to memory, computation back to memory,
1379:40 - whereas this kind of just chunks it all together in one hit. If you'd like to read
1379:44 - more about this, I'd encourage you to look up the blog post, how to make your GPUs go
1379:49 - bur from first principles, and bur means fast. That's why I love this post, right?
1379:58 - Because it's half satire, half legitimately, like GPU computer science. So if you go in here,
1380:04 - yeah, here's what we want to avoid. We want to avoid all of this transportation between
1380:08 - memory and compute. And then if we look in here, we might have operator fusion. There we go.
1380:14 - This is operator fusion, the most important optimization in deep learning compilers. So
1380:20 - I will link this, making deep learning go bur from first principles by Horace Hare,
1380:25 - a great blog post that I really like, right here. So if you'd like to read more on that,
1380:31 - it's also going to be in the extracurricular section of the course. So don't worry, it'll be there.
1380:35 - Now, we've got a model. Oh, where do we, where do we forget a comma? Right here, of course we did.
1380:47 - And we've got another, we forgot another comma up here. Did you notice these?
1380:53 - Beautiful. Okay. So now we can create our model by going torch or an instance of the tiny VGG
1380:59 - to see if our model holds up. Let's create model zero equals tiny VGG. And I'm going to pass in
1381:07 - the input shape. What is the input shape? It's going to be the number of color channels of our
1381:11 - image. So number of color channels in our image data, which is three, because we have color images.
1381:19 - And then we're going to put in hidden units, equals 10, which will be the same number of
1381:24 - hidden units as the tiny VGG architecture. One, two, three, four, five, six, seven, eight, nine,
1381:31 - 10. Again, we could put in 10, we could put in 100, we could put in 64, which is a good multiple
1381:39 - of eight. So let's just leave it at 10 for now. And then the output shape is going to be what?
1381:44 - It's going to be the length of our class names, because we want one hidden unit or one output unit
1381:49 - per class. And then we're going to send it to the target device, which is of course CUDA. And then
1381:55 - we can check out our model zero here. Beautiful. So that took a few seconds, as you saw there,
1382:05 - to move to the GPU memory. So that's just something to keep in mind for when you build
1382:09 - large neural networks and you want to speed up their computation, is to use operator fusion
1382:14 - where you can, because as you saw, it took a few seconds for our model to just move from the CPU,
1382:19 - which is the default to the GPU. So we've got our architecture here. But of course, we know that
1382:26 - this potentially is wrong. And how would we find that out? Well, we could find the right hidden
1382:32 - unit shape or we could find that it's wrong by passing some dummy data through our model. So
1382:38 - that's one of my favorite ways to troubleshoot a model. Let's in the next video pass some dummy
1382:43 - data through our model and see if we've implemented the forward pass correctly. And also check the
1382:49 - input and output shapes of each of our layers. I'll see you there. In the last video, we replicated
1383:00 - the tiny VGG architecture from the CNN explainer website, very similar to the model that we built
1383:05 - in section 03. But this time, we're using color images instead of grayscale images. And we did
1383:13 - it quite a bit faster than what we previously did, because we've already covered it, right?
1383:18 - And you've had some experience now building pilotage models from scratch.
1383:21 - So we're going to pick up the pace when we build our models. But let's now go and try a dummy
1383:28 - forward pass to check that our forward method is working correctly and that our input and output
1383:34 - shapes are correct. So let's create a new heading. Try a forward pass on a single image. And this
1383:42 - is one of my favorite ways to test the model. So let's first get a single image. Get a single
1383:51 - image. We want an image batch. Maybe we get an image batch, get a single image batch, because
1383:58 - we've got images that are batches already image batch. And then we'll get a label batch. And we'll
1384:07 - go next, it a train data loader. Simple. That's the data loader that we're working with for now.
1384:16 - And then we'll check image batch dot shape and label batch dot shape.
1384:25 - Wonderful. And now let's see what happens. Try a forward pass.
1384:29 - Oh, I spelled single wrong up here. Try a forward pass. We could try this on a single image trying
1384:38 - it on a same batch will result in similar results. So let's go model zero. And we're just going to
1384:45 - pass it in the image batch and see what happens. Oh, no. Of course, we get that input type,
1384:54 - torch float tensor and wait type torch CUDA float tensor should be the same or input should be.
1385:00 - So we've got tensors on a different device, right? So this is on the CPU, the image batch,
1385:06 - whereas our model is, of course, on the target device. So we've seen this error a number of times.
1385:12 - Let's see if this fixes it. Oh, we get an other error. And we kind of expected this type of error.
1385:20 - We've got runtime error amount one and mat two shapes cannot be multiplied. 32. So that looks
1385:26 - like the batch size 2560 and 10. Hmm, what is 10? Well, recall that 10 is the number of hidden
1385:35 - units that we have. So this is the size here. That's 10 there. So it's trying to multiply
1385:42 - a matrix of this size by this size. So 10 has got something going on with it. We need to get
1385:48 - these two numbers, the middle numbers, to satisfy the rules of matrix multiplication,
1385:53 - because that's what happens in our linear layer. We need to get these two numbers the same.
1386:00 - And so our hint and my trick is to look at the previous layer. So if that's our batch size,
1386:07 - where does this value come from? Well, could it be the fact that a tensor of this size goes
1386:15 - through the flatten layer? Recall that we have this layer up here. So we've printed out the shape
1386:22 - here of the conv block, the output of conv block one. Now this shape here is the output of conv
1386:29 - block two. So we've got this number, the output of conv block one, and then the output of conv
1386:36 - block two. So that must be the input to our classifier layer. So if we go 10 times 16 times 16,
1386:43 - what do we get? 2560. Beautiful. So we can multiply our hitting units 10 by 16 by 16, which is the
1386:55 - shape here. And we get 2560. Let's see if that works. We'll go up here, times 16 times 16.
1387:05 - And let's see what happens. We'll rerun the model, we'll rerun the image batch, and then we'll pass
1387:10 - it. Oh, look at that. Our model works. Or the shapes at least line up. We don't know if it works
1387:16 - yet. We haven't started training yet. But this is the output size. We've got the output. It's on
1387:22 - the CUDA device, of course. But we've got 32 samples with three numbers in each. Now these are going
1387:27 - to be as good as random, because we haven't trained our model yet. We've only initialized it here
1387:32 - with random weights. So we've got 32 or a batch worth of random predictions on 32 images.
1387:42 - So you see how the output shape here three corresponds to the output shape we set up here.
1387:47 - Output shape equals length class names, which is exactly the number of classes that we're dealing
1387:52 - with. But I think our number is a little bit different to what's in the CNN explainer 1616.
1387:59 - How did they end up with 1313? You know what? I think we got one of these numbers wrong,
1388:07 - kernel size, stride, padding. Let's have a look. Jump into here. If we wanted to truly replicate it,
1388:14 - is there any padding here? I actually don't think there's any padding here. So what if we go back
1388:20 - here and see if we can change this to zero and change this to zero? Zero. I'm not sure if this
1388:27 - will work, by the way. If it doesn't, it's not too bad, but we're just trying to line up the shapes
1388:31 - with the CNN explainer to truly replicate it. So the output of the COM Block 1 should be 30-30-10.
1388:38 - What are we working with at the moment? We've got 32-32-10. So let's see if removing the padding
1388:46 - from our convolutional layers lines our shape up with the CNN explainer. So I'm going to rerun
1388:51 - this, rerun our model. I've set the padding to zero on all of our padding hyper parameters.
1388:58 - Oh, and we get another error. We get another shape error. Of course we do,
1389:02 - because we've now got different shapes. Wow, do you see how often that these errors come up?
1389:10 - Trust me, I spend a lot of time troubleshooting these shape errors. So we now have to line up
1389:15 - these shapes. So we've got 13-13-10. Now does that equal 16-90? Let's try it out. 13-13-10.
1389:24 - 16-90. Beautiful. And do our shapes line up with the CNN explainer? So we've got 30-30-10.
1389:30 - Remember, these are in PyTorch. So color channels first, whereas this is color channels last. So
1389:36 - yeah, we've got the output of our first COM Block is lining up here. That's correct.
1389:41 - And then same with the second block. How good is that? We've officially replicated the CNN explainer
1389:46 - model. So we can take this value 13-13-10 and bring it back up here. 13-13-10. Remember,
1389:55 - hidden units is 10. So we're just going to multiply it by 13-13. You could calculate
1389:59 - these shapes by hand, but my trick is I like to let the error codes give me a hint of where to go.
1390:05 - And boom, there we go. We get it working again. Some shape troubleshooting on the fly. So now
1390:15 - we've done a single forward pass on the model. We can kind of verify that our data at least flows
1390:20 - through it. What's next? Well, I'd like to show you another little package that I like to use
1390:27 - to also have a look at the input and output shapes of my model. And that is called Torch Info. So
1390:33 - you might want to give this a shot before we go into the next video. But in the next video,
1390:39 - we're going to see how we can use Torch Info to print out a summary of our model. So we're
1390:44 - going to get something like this. So this is how beautifully easy Torch Info is to use. So
1390:51 - give that a shot, install it into Google CoLab and run it in a cell here. See if you can get
1390:57 - something similar to this output for our model zero. And I'll see you in the next video. We'll try
1391:03 - that together. In the last video, we checked our model by doing a forward pass on a single batch.
1391:13 - And we learned that our forward method so far looks like it's intact and that we don't get any
1391:18 - shape errors as our data moves through the model. But I'd like to introduce to you one of my
1391:24 - favorite packages for finding out information from a PyTorch model. And that is Torch Info.
1391:31 - So let's use Torch Info to get an idea of the shapes going through our model. So you know how
1391:40 - much I love doing things in a programmatic way? Well, that's what Torch Info does. Before,
1391:46 - we used print statements to find out the different shapes going through our model.
1391:50 - And I'm just going to comment these out in our forward method so that when we run this later on
1391:54 - during training, we don't get excessive printouts of all the shapes. So let's see what Torch Info
1392:00 - does. And in the last video, I issued a challenge to give it a go. It's quite straightforward of
1392:06 - how to use it. But let's see it together. This is the type of output we're looking for from our
1392:11 - tiny VGG model. And of course, you could get this type of output from almost any PyTorch model.
1392:16 - But we have to install it first. And as far as I know, Google CoLab doesn't come with Torch Info
1392:23 - by default. Now, you might as well try this in the future and see if it works. But yeah, I don't
1392:29 - get this module because my Google CoLab instance doesn't have an install. No problem with that.
1392:35 - Let's install Torch Info here. Install Torch Info and then we'll import it if it's available.
1392:45 - So we're going to try and import Torch Info. If it's already installed, we'll import it.
1392:51 - And then if it doesn't work, if that try block fails, we're going to run pip install Torch Info.
1392:58 - And then we will import Torch Info. And then we're going to run down here from Torch Info,
1393:06 - import summary. And then if this all works, we're going to get a summary of our model. We're going
1393:12 - to pass it in model zero. And we have to put in an input size here. Now that is an example of the
1393:19 - size of data that will flow through our model. So in our case, let's put in an input size of 1,
1393:25 - 3, 64, 64. So this is an example of putting in a batch of one image. You could potentially
1393:32 - put in 32 here if you wanted, but let's just put in a batch of a singular image. And of course,
1393:37 - we could change these values here if we wanted to, 24 to 24. But what you might notice is that if
1393:43 - it doesn't get the right input size, it produces an error. There we go. So just like we got before
1393:50 - when we printed out our input sizes manually, we get an error here. Because what Torch Info
1393:55 - behind the scenes is going to do is it's going to do a forward pass on whichever model you pass
1394:00 - it with an input size of whichever input size you give it. So let's put in the input size that
1394:06 - our model was built for. Wonderful. So what Torch Info gives us is, oh, excuse me, we didn't
1394:15 - comment out the printouts before. So just make sure we've commented out these printouts in the
1394:22 - forward method of our 20 VGG class. So I'm just going to run this, then we run that, run that,
1394:29 - just to make sure everything still works. We'll run Torch Info. There we go. So no printouts
1394:35 - from our model, but this is, look how beautiful this is. I love how this prints out. So we have
1394:40 - our tiny VGG class, and then we can see it's comprised of three sequential blocks. And then
1394:46 - inside those sequential blocks, we have different combinations of layers. We have some conv layers,
1394:52 - some relu layers, some max pool layers. And then the final layer is our classification layer
1394:57 - with a flatten and a linear layer. And we can see the shapes changing throughout our model.
1395:03 - As our data goes in and gets manipulated by the various layers. So are these in line with
1395:10 - the CNN explainer? So if we check this last one, we've already verified this before.
1395:17 - And we also get some other helpful information down here, which is total params. So you can see
1395:23 - that each of these layers has a different amount of parameters to learn. Now, recall that a parameter
1395:29 - is a value such as a weight or a bias term within each of our layers, which starts off as a random
1395:36 - number. And the whole goal of deep learning is to adjust those random numbers to better represent
1395:42 - our data. So in our case, we have just over 8000 total parameters. Now this is actually quite small.
1395:49 - In the future, you'll probably play around with models that have a million parameters or more.
1395:53 - And models now are starting to have many billions of parameters. And we also get some
1396:00 - information here, such as how much the model size would be. Now this would be very helpful,
1396:05 - depending on where we had to put our model. So what you'll notice is that as a model gets larger,
1396:10 - as more layers, it will have more parameters, more weights and bias terms that can be adjusted
1396:15 - to learn patterns and data. But its input size and its estimated total size would definitely get
1396:23 - bigger as well. So that's just something to keep in mind if you have size constraints in terms of
1396:27 - storage in your future applications. So ours is under a megabyte, which is quite small. But you
1396:34 - might find that some models in the future get up to 500 megabytes, maybe even over a gigabyte.
1396:39 - So just keep that in mind for going forward. And that's the crux of torch info, one of my
1396:44 - favorite packages, just gives you an idea of the input and output shapes of each of your layers.
1396:49 - So you can use torch info wherever you need. It should work with most of your PyTorch models.
1396:54 - Just be sure to pass it in the right input size. You can also use it to verify like we did before,
1397:00 - if the input and output shapes are correct. So check that out, big shout out to Tyler Yup,
1397:06 - and everyone who's created the torch info package. Now in the next video, let's move towards training
1397:13 - our tiny VGG model. We're going to have to create some training and test functions. If you want to
1397:19 - jump ahead, we've already done this. So I encourage you to go back to section 6.2 in the
1397:26 - functionalizing training and test loops. And we're going to build functions very similar to this,
1397:31 - but for our custom data set. So if you want to replicate these functions in this notebook,
1397:39 - give that a go. Otherwise, I'll see you in the next video and we'll do it together.
1397:43 - How'd you go? Did you give it a shot? Did you try replicating the train step and the test step
1397:53 - function? I hope you did. Otherwise, let's do that in this video, but this time we're going to do
1397:58 - it for our custom data sets. And what you'll find is not much, if anything, changes, because
1398:04 - we've created our train and test loop functions in such a way that they're generic. So we want
1398:10 - to create a train step function. And by generic, I mean they can be used with almost any model and
1398:16 - data loader. So train step is takes in a model and data loader and trains the model on the data
1398:26 - loader. And we also want to create another function called test step, which takes in
1398:33 - a model and a data loader and other things and evaluates the model on the data loader. And of course,
1398:42 - for the train step and for the test step, each of them respectively are going to take a training
1398:47 - data loader. I just might make this a third heading so that our outline looks nice, beautiful.
1398:54 - Section seven is turning out to be quite a big section. Of course, we want them to be
1398:58 - respectively taken their own data loader. So train takes in the train data loader, test takes in the
1399:04 - test data loader. Without any further ado, let's create the train step function. Now we've seen
1399:09 - this one in the computer vision section. So let's see what we can make here. So we need a train
1399:15 - step, which is going to take in a model, which will be a torch and then dot module. And we want
1399:21 - it also to take in a data loader, which will be a torch dot utils dot data dot data loader.
1399:29 - And then it's going to take in a loss function, which is going to be a torch and then
1399:34 - dot module as well. And then it's going to take in an optimizer, which is going to be torch
1399:41 - opt in dot optimizer. Wonderful. And then what do we do? What's the first thing that we do in
1399:49 - a training step? Well, we put the model in train mode. So let's go model dot train.
1399:58 - Then what shall we do next? Well, let's set up some evaluation metrics, one of them being loss
1400:04 - and one of them being accuracy. So set up train loss and train accuracy values. And we're going
1400:13 - to accumulate these per batch because we're working with batches. So we've got train loss
1400:18 - and train act equals zero, zero. Now we can loop through our data loader. So let's write loop through
1400:28 - data loader. And we'll loop through each of the batches in this because we've batchified our
1400:33 - data loader. So for batch x, y, in enumerate data loader, we want to send the data to the target
1400:42 - device. So we could even put that device parameter up here. Device equals device. We'll set that
1400:52 - to device by default. And then we can go x, y equals x dot two device. And y dot two device.
1401:05 - Beautiful. And now what do we do? Well, remember the pie torch, the unofficial pie torch optimization
1401:11 - song, we do the forward pass. So y pred equals model om x. And then number two is we calculate the
1401:22 - last. So calculate the loss. Let's go loss equals loss function. And we're going to pass it in
1401:32 - y pred y. We've done this a few times now. So that's why we're doing it a little bit faster.
1401:37 - So I hope you noticed that the things that we've covered before, I'm stepping up the pace a bit.
1401:42 - So it might be a bit of a challenge, but that's all right, you can handle it. And then, so that's
1401:47 - accumulating the loss. So we're starting from zero up here. And then each batch, we're doing a forward
1401:53 - pass, calculating the loss, and then adding it to the overall train loss. And so we're going to
1402:00 - optimize a zero grad. So zero, the gradients of the optimizer for each new batch. And then we're
1402:07 - going to perform back propagation. So loss backwards. And then five, what do we do? Optimize a step,
1402:16 - step, step. Wonderful. Look at that. Look at us coding a train loop in a minute or so.
1402:22 - Now, let's calculate the accuracy and accumulate it. Calculate the, you notice that we don't have
1402:31 - an accuracy function here. That's because accuracy is quite a straightforward metric to calculate.
1402:39 - So we'll first get the, the y pred class, because this is going to output model logits.
1402:46 - As we've seen before, the raw output of a model is logits. So to get the class, we're going to take
1402:54 - the arg max torch dot softmax. So we'll get the prediction probabilities of y pred, which is the
1403:02 - raw logits, what we've got up here, across dimension one, and then also across dimension one here.
1403:09 - Beautiful. So that should give us the labels. And then we can find out if this is wrong by
1403:15 - checking it later on. And then we're going to create the accuracy by taking the y pred class,
1403:21 - checking for a quality with the right labels. So this is going to give us how many of these
1403:28 - values equal true. And we want to take the sum of that, take the item of that, which is just a
1403:34 - single integer. And then we want to divide it by the length of y pred. So we're just getting the
1403:41 - total number that are right, and dividing it by the length of samples. So that's the formula for
1403:48 - accuracy. Now we can come down here outside of the batch loop, we know that because we've got this
1403:53 - helpful line drawn here. And we can go adjust metrics to get the average loss and accuracy
1404:03 - per batch. So we're going to set train loss is equal to train loss, divided by the length of
1404:10 - the data loader. So the number of batches in total. And the train accuracy is the train
1404:15 - act, divided by the length of the data loader as well. So that's going to give us the average
1404:21 - loss and average accuracy per epoch across all batches. So train act. Now that's a pretty good
1404:31 - looking function to me for a train step. Do you want to take on the test step? So pause the video,
1404:38 - give it a shot, and you'll get great inspiration from this notebook here. Otherwise, we're going
1404:44 - to do it together in three, two, one, let's do the test step. So create a test step function.
1404:53 - So we want to be able to call these functions in an epoch loop. And that way, instead of writing
1404:59 - out training and test code for multiple different models, we just write it out once, and we can
1405:03 - call those functions. So let's create def test step, we're going to do model, which is going to be
1405:11 - if I could type torch and then module. And then we're going to do data loader,
1405:17 - which is torch utils dot data, that data loader, capital L there. And then we're going to just
1405:26 - pass in a loss function here, because we don't need an optimizer for the test function. We're
1405:31 - not trying to optimize anything, we're just trying to evaluate how our model did on the training
1405:37 - dataset. And let's put in the device here, why not? That way we can change the device if we need
1405:42 - to. So put model in a val mode, because we're going to be evaluating or we're going to be testing.
1405:49 - Then we can set up test loss and test accuracy values. So test loss and test act. We're going
1406:00 - to make these zero, we're going to accumulate them per batch. But before we go through the batch,
1406:05 - let's turn on inference mode. So this is behind the scenes going to take care of a lot of pie torch
1406:12 - functionality that we don't need. That's very helpful during training, such as tracking gradients.
1406:16 - But during testing, we don't need that. So loop through data loader or data batches.
1406:23 - And we're going to go for batch x, y in enumerate data loader. You'll notice that above, we didn't
1406:33 - actually use this batch term here. And we probably won't use it here either. But I just like to go
1406:40 - through and have that there in case we wanted to use it anyway. So send data to the target device.
1406:48 - So we're going to go x, y equals x dot two device. And same with y dot two device. Beautiful. And
1406:59 - then what do we do for an evaluation step or a test step? Well, of course, we do the forward pass,
1407:05 - forward pass. And we're going to, let's call these test pred logits and get the raw outputs of our
1407:14 - model. And then we can calculate the loss on those raw outputs, calculate the loss. We get the loss
1407:21 - is equal to loss function on test pred logits versus y. And then we're going to accumulate the
1407:30 - loss. So test loss plus equals loss dot item. Remember, item just gets a single integer from
1407:39 - whatever term you call it on. And then we're going to calculate the accuracy. Now we can do this
1407:47 - exactly how we've done for the training data set or the training step. So test pred labels,
1407:53 - we're going to, you don't, I just want to highlight the fact that you actually don't need to take
1407:59 - the softmax here, you could just take the argmax directly from this. The reason why we take the
1408:04 - softmax. So you could do the same here, you could just directly take the argmax of the logits. The
1408:11 - reason why we get the softmax is just for completeness. So if you wanted the prediction probabilities,
1408:16 - you could use torch dot softmax on the prediction logits. But it's not 100% necessary to get the
1408:22 - same values. And you can test this out yourself. So try this with and without the softmax and
1408:27 - see if you get the same results. So we're going to go test accuracy. Plus equals, now we'll just
1408:34 - create our accuracy calculation on the fly test pred labels. We'll check for equality on the y,
1408:41 - then we'll get the sum of that, we'll get the item of that, and then we'll divide that by the
1408:46 - length of the test pred labels. Beautiful. So it's going to give us accuracy per batch. And so now
1408:53 - we want to adjust the metrics to get average loss and accuracy per batch. So test loss equals
1409:04 - test loss divided by length of the data loader. And then we're going to go test,
1409:11 - ac equals test, act divided by length of the data loader. And then finally, we're going to
1409:17 - return the test loss, not lost, and test accuracy. Look at us go. Now, in previous videos, that took
1409:28 - us, or in previous sections, that took us a fairly long time. But now we've done it in about 10
1409:33 - minutes or so. So give yourself a pat in the back for all the progress you've been making.
1409:38 - But now let's in the next video, we did this in the computer vision section as well. We created,
1409:44 - do we create a train function? Oh, no, we didn't. But we could. So let's create a function to
1409:53 - functionize this. We want to train our model. I think we did actually. Deaf train, we've done
1409:57 - so much. I'm not sure what we've done. Oh, okay. So looks like we might not have. But in the next
1410:05 - video, give yourself this challenge, create a function called train that combines these two
1410:11 - functions and loops through them both with an epoch range. So just like we've done here in the
1410:19 - previous notebook, can you functionize this? So just this step here. So you'll need to take in a
1410:26 - number of epochs, you'll need to take in a train data loader and a test data loader, a model, a
1410:30 - loss function, an optimizer, and maybe a device. And I think you should be pretty on your way to
1410:36 - all the steps we need for train. So give that a shot. But in the next video, we're going to create
1410:41 - a function that combines train step and test step to train a model. I'll see you there.
1410:51 - How'd you go? In the last video, I issued you the challenge to combine our train step function,
1410:56 - as well as our test step function together in their own function so that we could just call
1411:01 - one function that calls both of these and train a model and evaluate it, of course.
1411:05 - So let's now do that together. I hope you gave it a shot. That's what it's all about. So we're
1411:12 - going to create a train function. Now the role of this function is going to, as I said, combine
1411:18 - train step and test step. Now we're doing all of this on purpose, right, because we want to not
1411:25 - have to rewrite all of our code all the time. So we want to be functionalizing as many things as
1411:30 - possible, so that we can just import these later on, if we wanted to train more models and just
1411:35 - leverage the code that we've written before, as long as it works. So let's see if it does,
1411:41 - we're going to create a train function. I'm going to first import TQDM, TQDM.auto,
1411:48 - because I'd like to get a progress bar while our model is training. There's nothing quite like
1411:52 - watching a neural network train. So step number one is we need to create a train function that takes
1412:01 - in various model parameters, plus optimizer, plus data loaders, plus a loss function. A whole
1412:13 - bunch of different things. So let's create def train. And I'm going to pass in a model here,
1412:19 - which is going to be torch and then dot module. You'll notice that the inputs of this are going
1412:25 - to be quite similar to our train step and test step. I don't actually need that there.
1412:32 - So we also want a train data loader for the training data, torch dot utils dot data dot data
1412:39 - loader. And we also want a test data loader, which is going to be torch dot utils dot data
1412:47 - dot data loader. And then we want an optimizer. So the optimizer will only be used with our
1412:54 - training data set, but that's okay. We can take it as an input of the miser. And then we want a
1412:59 - loss function. This will generally be used for both our training and testing step. Because that's
1413:04 - what we're combining here. Now, since we're working with multi class classification,
1413:09 - I'm going to set our loss function to be a default of an n dot cross entropy loss.
1413:15 - Then I'm going to get epochs. I'm going to set five, we'll train for five epochs by default.
1413:21 - And then finally, I'm going to set the device equal to the device. So what do we get wrong here?
1413:30 - That's all right. We'll just keep coding. We'll ignore these little red lines. If they
1413:34 - stay around, we'll come back to them. So step number two, I'm going to create. This is a step
1413:39 - you might not have seen, but I'm going to create an empty results dictionary. Now, this is going
1413:44 - to help us track our results. Do you recall in a previous notebook, we outputted a model dictionary
1413:51 - for how a model went. So if we look at model one results, yeah, we got a dictionary like this.
1413:57 - So I'd like to create one of these on the fly, but keep track of the result every epoch. So what
1414:03 - was the loss on epoch number zero? What was the accuracy on epoch number three? So we'll show you
1414:09 - how I'll do that. We can use a dictionary and just update that while our model trains.
1414:14 - So results, I want to keep track of the train loss. So we're going to set that equal to an empty
1414:20 - list and just append to it. I also want to keep track of the train accuracy. We'll set that as
1414:25 - an empty list as well. I also want to keep track of the test loss. And I also want to keep track
1414:32 - of the test accuracy. Now, you'll notice over time that these, what you can track is actually
1414:38 - very flexible. And what your functions can do is also very flexible. So this is not the gold
1414:44 - standard of doing anything by any means. It's just one way that works. And you'll probably find in
1414:50 - the future that you need different functionality. And of course, you can code that out. So let's
1414:57 - now loop through our epochs. So for epoch in TQDM, let's create a range of our epochs above.
1415:06 - And then we can set the train loss. Have I missed a comma up here somewhere?
1415:09 - Type annotation not supported for that type of expression. Okay, that's all right. We'll just leave
1415:17 - that there. So we're going to go train loss and train act, recall that our train step function
1415:24 - that we created in the previous video, train step returns our train loss and train act. So as I
1415:30 - said, I want to keep track of these throughout our training. So I'm going to get them from train
1415:36 - step. Then for each epoch in our range of epochs, we're going to pass in our model and perform a
1415:43 - training step. So the data loader here is of course going to be the train data loader. The
1415:48 - loss function is just going to be the loss function that we pass into the train function.
1415:52 - And then the optimizer is going to be the optimizer. And then the device is going to be device.
1416:00 - Beautiful. Look at that. We just performed a training step in five lines of code.
1416:03 - So let's keep pushing forward. It's telling us we've got a whole bunch of different things here.
1416:08 - Epox is not defined. Maybe we just have to get rid of this. We can't have the type annotation here.
1416:14 - And that'll that'll stop. That'll stop Google Colab getting angry at us. If it does anymore,
1416:22 - I'm just going to ignore it for now. Epox. Anyway, we'll leave it at that. We'll find out if there's
1416:28 - an error later on. Test loss. You might be able to find it before I do. So test step. We're going
1416:33 - to pass in the model. We're going to pass in a data loader. Now this is going to be the test data
1416:39 - loader. Look at us go. Grading training and test step functions, loss function. And then we don't
1416:46 - need an optimizer. We're just going to pass in the device. And then behind the scenes,
1416:50 - both of these functions are going to train and test our model. How cool is that? So still within
1416:56 - the loop. This is important. Within the loop, we're going to have number four is we're going to
1417:02 - print out. Let's print out what's happening. Print out what's happening. We can go print.
1417:09 - And we'll do a fancy little print statement here. We'll get the epoch. And then we will get
1417:15 - the train loss, which will be equal to the train loss. We'll get that to, let's go
1417:20 - four decimal places. How about that? And then we'll get the train accuracy, which is going to be the
1417:26 - train act. We'll get that to four, maybe three decimal of four, just for just so it looks nice.
1417:34 - It looks aesthetic. And then we'll go test loss. We'll get that coming out here. And we'll pass
1417:39 - in the test loss. We'll get that to four decimal places as well. And then finally, we'll get the
1417:45 - test accuracy. So a fairly long print statement here. But that's all right. We'd like to see how
1417:52 - our model is doing while it's training. Beautiful. And so again, still within the epoch, we want to
1417:59 - update our results dictionary so that we can keep track of how our model performed over time.
1418:04 - So let's pass in results. We want to update the train loss. And so this is going to be this.
1418:11 - And then we can append our train loss value. So this is just going to expend the list in here
1418:21 - with the train loss value, every epoch. And then we'll do the same thing on the train accuracy,
1418:27 - append train act. And then we'll do the same thing again with test loss dot append test loss.
1418:41 - And then we will finally do the same thing with the test accuracy test accuracy. Now,
1418:51 - this is a pretty big function. But this is why we write the code now so that we can use it
1418:56 - multiple times later on. So return the field results at the end of the epoch. So outside the
1419:03 - epochs loop. So our loop, we're outside it now. Let's return results. Now, I've probably got an
1419:12 - error somewhere here and you might be able to spot it. Okay, train data loader. Where do we get
1419:16 - that invalid syntax? Maybe up here, we don't have a comma here. Was that the issue the whole time?
1419:23 - Wonderful. You might have seen that I'm completely missed that. But we now have a train function
1419:30 - to train our model. And the train function, of course, is going to call out our train step
1419:34 - function and our test step function. So what's left to do? Well, nothing less than train and
1419:42 - evaluate model zero. So our model is way back up here. How about in the next video, we leverage
1419:50 - our functions, namely just the train function, because it's going to call our train step function
1419:56 - and our test step function and train our model. So I'm going to encourage you to give that a go.
1420:01 - You're going to have to go back to the workflow. Maybe you'll maybe already know this.
1420:06 - So what have we done? We've got our data ready and we turned it into tenses using a combination
1420:11 - of these functions. We've built and picked a model while we've built a model, which is the
1420:16 - tiny VGG architecture. Have we created a loss function yet? I don't think we have or an optimizer.
1420:23 - I don't think we've done that yet. We've definitely built a training loop though.
1420:28 - We aren't using torch metrics. We're just using accuracy, but we could use this if we want.
1420:33 - We haven't improved through experimentation yet, but we're going to try this later on and
1420:37 - then save and reload the model. We've seen this before. So I think we're up to picking a loss
1420:43 - function and an optimizer. So give that a shot. In the next video, we're going to create a loss
1420:49 - function and an optimizer and then leverage the functions we've spent in the last two videos
1420:54 - creating to train our first model model zero on our own custom data set. This is super exciting.
1421:02 - I'll see you in the next video.
1421:06 - Who's ready to train and evaluate model zero? Put your hand up.
1421:09 - I definitely am. So let's do it together. We're going to start off section 7.7 and we're going
1421:17 - to put in train and evaluate model zero, our baseline model on our custom data set. Now,
1421:25 - if we refer back to the PyTorch workflow, I issued you the challenge in the last video to try and
1421:29 - create a loss function and an optimizer. I hope you gave that a go, but we've already built a
1421:34 - training loop. So we're going to leverage our training loop functions, namely train, train step
1421:40 - and test step. All we need to do now is instantiate a model, choose a loss function and an optimizer
1421:47 - and pass those values to our training function. So let's do that. All right, this is so exciting.
1421:54 - Let's set the random seeds. I'm going to set torch manual seed 42 and torch cuda manual seed 42.
1422:05 - Now remember, I just want to highlight something. I read an article the other day about not using
1422:09 - random seeds. The reason why we are using random seeds is for educational purposes. So to try and
1422:16 - get our numbers on my screen and your screen as close as possible, but in practice, you quite
1422:21 - often don't use random seeds all the time. The reason why is because you want your models performance
1422:27 - to be similar regardless of the random seed that you use. So just keep that in mind going forward.
1422:34 - We're using random seeds to just exemplify how we can get similar numbers on our page. But
1422:41 - ideally, no matter what the random seed was, our models would go in the same direction.
1422:46 - That's where we want our models to eventually go. But we're going to train for five epochs.
1422:53 - And now let's create a recreate an instance of tiny VGG. We can do so because we've created the
1423:00 - tiny VGG class. So tiny VGG, which is our model zero. We don't have to do this, but we're going
1423:07 - to do it any later. So we've got all the code in one place, tiny VGG. What is our input shape
1423:13 - going to be? That is the number of color channels of our target images. And because we're dealing
1423:21 - with color images, we have an input shape of three. Previously, we used an input shape of one to
1423:26 - deal with grayscale images. I'm going to set hidden units to 10 in line with the CNN explainer website.
1423:32 - And the output shape is going to be the number of classes in our training data set. And then,
1423:38 - of course, we're going to send the target model to the target device. So what do we do now?
1423:47 - Well, we set up a loss function and an optimizer, loss function, and optimizer.
1423:53 - So our loss function is going to be because we're dealing with multiclass classification,
1423:58 - and then cross entropy, if I could spell cross entropy loss. And then we're going to have an
1424:05 - optimizer. This time, how about we mix things up? How about we try the atom optimizer? Now,
1424:10 - of course, the optimizer is one of the hyper parameters that you can set for your model,
1424:14 - and a hyper parameter being a value that you can set yourself. So the parameters that we want to
1424:20 - optimize are our model zero parameters. And we're going to set a learning rate of 0.001. Now,
1424:29 - recall that you can tweet this learning rate, if you like, but I believe, did I just see that
1424:34 - the default learning rate of atom is 0.001? Yeah, there we go. So Adam's default learning rate is
1424:43 - one to the power of 10 to the negative three. And so that is a default learning rate for Adam.
1424:49 - And as I said, oftentimes, different variables in the pytorch library, such as optimizers,
1424:57 - have good default values that work across a wide range of problems. So we're just going to stick
1425:02 - with the default. If you want to, you can experiment with different values of this.
1425:07 - But now let's start the timer, because we want to time our models.
1425:13 - We're going to import from time it. We want to get the default timer class. And I'm going to
1425:20 - import that as timer, just so we don't have to type out default timer. So the start time is going
1425:26 - to be timer. This is going to just put a line in the sand of what the start time is at this
1425:32 - particular line of code. It's going to measure that. And then we're going to train model zero.
1425:38 - Now this is using, of course, our train function. So let's write model zero results, and then
1425:44 - they wrote model one, but we're not up to there yet. So let's go train model equals model zero.
1425:52 - And this is just the training function that we wrote in a previous video. And the train data
1425:58 - is going to be our train data loader. And we've got train data loader simple, because we're not
1426:03 - using data augmentation for model one. And then our test data loader is going to be our test data
1426:10 - loader simple. And then we're going to set our optimizer, which is equal to the optimizer we just
1426:15 - created. Friendly atom optimizer. And the loss function is going to be the loss function that
1426:21 - we just created, which is an n cross entropy loss. Finally, we can send in epochs is going to be
1426:28 - num epochs, which is what we set at the start of this video to five. And of course, we could train
1426:35 - our model for longer if we wanted to. But the whole idea of when you first start training a model
1426:39 - is to keep your experiments quick. So that's why we're only training for five, maybe later on you
1426:44 - train for 10, 20, tweak the learning rate, do a whole bunch of different things. But let's go
1426:50 - down here, let's end the timer, see how long our models took to train, and the timer and print out
1426:58 - how long it took. So in a previous section, we created a helper function for this.
1427:06 - We're just going to simplify it in this section. And we're just going to print out how long the
1427:10 - training time was. Total training time. Let's go n time minus start time. And then we're going to go
1427:19 - point, we'll take it to three decimal places, hey, seconds, you ready to train our first model,
1427:26 - our first convolutional neural network on our own custom data set on pizza, stake and sushi
1427:33 - images. Let's do it. You're ready? Three, two, one, no errors. Oh, there we go. Okay,
1427:43 - should this be trained data loader? Did you notice that? What is our trained data
1427:48 - taker's input? Oh, we're not getting a doc string. Oh, there we go. We want trained data
1427:55 - loader, data loader, and same with this, I believe. Let's try again. Beautiful. Oh, look at that
1428:03 - lovely progress bar. Okay, how's our model is training quite fast? Okay. All right, what do we
1428:10 - get? So we get an accuracy on the training data set of about 40%. And we get an accuracy on the
1428:17 - test data set of about 50%. Now, what's that telling us? It's telling us that about 50% of the time
1428:25 - our model is getting the prediction correct. But we've only got three classes. So even if our model
1428:32 - was guessing, it would get things right 33% of the time. So even if you just guessed pizza every
1428:40 - single time, because we only have three classes, if you guessed pizza every single time, you get
1428:46 - a baseline accuracy of 33%. So our model isn't doing too much better than our baseline accuracy.
1428:53 - Of course, we'd like this number to go higher, and maybe it would if it trained for longer.
1428:58 - So I'll let you experiment with that. But if you'd like to see some different methods of
1429:03 - improving a model, recall back in section number O two, we had an improving a model section,
1429:10 - improving a model. Here we go. So here's some things you might want to try.
1429:18 - We can improve a model by adding more layers. So if we come back to our tiny VGG architecture,
1429:25 - right up here, we're only using two convolutional blocks. Perhaps you wanted to add in a convolutional
1429:33 - block three. You can also add more hidden units. Right now we're using 10 hidden units. You might
1429:39 - want to double that and see what happens. Fitting for longer. This is what we just spoke about.
1429:44 - So right now we're only fitting for five epochs. So if you maybe wanted to try double that again,
1429:50 - and then even double that again, changing the activation functions. So maybe relu is not the
1429:57 - ideal activation function for our specific use case. Change the learning rate. We've spoken
1430:02 - about that before. So right now our learning rate is 0.001 for Adam, which is the default.
1430:08 - But perhaps there's a better learning rate out there. Change the loss function. This is probably not
1430:15 - in our case, not going to help too much because cross entropy loss is a pretty good loss for
1430:19 - multi class classification. But these are some things that you could try these first three,
1430:24 - especially. You could try quite quickly. You could try doubling the layers. You could try
1430:29 - adding more hidden units. And you could try fitting for longer. So I'd give that a shot.
1430:34 - But in the next video, we're going to take our model zero results, which is a dictionary or at
1430:42 - least it should be. And we're going to plot some loss curves. So this is a good way to inspect how
1430:49 - our model is training. Yes, we've got some values here. Let's plot these in the next video. I'll see you there.
1430:55 - In the last video, we trained our first convolutional neural network on custom data. So you should be
1431:06 - very proud of that. That is no small feat to take our own data set of whatever we want
1431:12 - and train apply to its model on it. However, we did find that it didn't perform as well as we'd
1431:17 - like it to. We also highlighted a few different things that we could try to do to improve it.
1431:22 - But now let's plot our models results using a loss curve. So I'm going to write another heading
1431:29 - down here. We'll go, I believe we're up to 7.8. So plot the loss curves of model zero. So what
1431:39 - is a loss curve? So I'm going to write down here, a loss curve is a way of tracking your models
1431:49 - progress over time. So if we just looked up Google and we looked up loss curves,
1431:56 - oh, there's a great guide by the way. I'm going to link this. But I'd rather if and doubt code it
1432:02 - out than just look at guides. Yeah, loss curves. So yeah, loss over time. So there's our loss value
1432:09 - on the left. And there's say steps, which is epochs or batches or something like that.
1432:15 - Then we've got a whole bunch of different loss curves over here. Essentially, what we want it
1432:19 - to do is go down over time. So that's the idea loss curve. Let's go back down here.
1432:28 - And a good guide for different loss curves can be seen here. We're not going to go through that
1432:37 - just yet. Let's focus on plotting our own models, loss curves, and we can inspect those.
1432:42 - Let's get the model keys. Get the model zero results keys. I'm going to type in model zero
1432:51 - results dot keys because it's a dictionary. Let's see if we can write some code to plot these
1432:59 - values here. So yeah, over time. So we have one value for train loss, train,
1433:06 - act, test loss, and test act for every epoch. And of course, these lists would be longer if we
1433:12 - train for more epochs. But let's just how about we create a function called def plot loss curves,
1433:18 - which will take in a results dictionary, which is of string and a list of floats. So this just
1433:26 - means that our results parameter here is taking in a dictionary that has a string as a key.
1433:33 - And it contains a list of floats. That's what this means here. So let's write a doc string
1433:42 - plots training curves of a results dictionary. Beautiful. And so we're in this section of our
1433:53 - workflow, which is kind of like a, we're kind of doing something similar to TensorBoard, what it
1433:58 - does. I'll let you look into that if you want to. Otherwise, we're going to see it later on.
1434:02 - But we're really evaluating our model here. Let's write some plotting code. We're going to use map plot
1434:08 - lib. So we want to get the lost values of the results dictionary. So this is training and test.
1434:19 - Let's set loss equal to results train loss. So this is going to be the loss on the training
1434:24 - data set. And then we'll create the test loss, which is going to be, well, index on the results
1434:30 - dictionary and get the test loss. Beautiful. Now we'll do the same and we'll get the accuracy.
1434:37 - Get the accuracy values of the results dictionary. So training and test.
1434:44 - Then we're going to go accuracy equals results. This will be the training accuracy train
1434:50 - act and accuracy. Oh, we'll call this test accuracy actually test accuracy equals results test act.
1435:00 - Now let's create a number of epochs. So we want to figure out how many epochs we did. We can do
1435:05 - that by just counting the length of this value here. So figure out how many epochs there were.
1435:13 - So we'll set epochs equal to a range because we want to plot it over time. Our models results
1435:18 - over time. That's that's the whole idea of a loss curve. So we'll just get the the length of
1435:26 - our results here. And we'll get the range. So now we can set up a plot.
1435:34 - Let's go PLT dot figure. And we'll set the fig size equal to something nice and big because
1435:41 - we're going to do four plots. We want one for maybe two plots, one for the loss, one for the accuracy.
1435:47 - And then we'll go plot the loss. PLT dot subplot. We're going to create one row, two columns,
1435:57 - and index number one. We want to put PLT dot plot. And here's where we're going to plot the
1436:03 - training loss. So we get that a label of train loss. And then we'll add another plot with epochs
1436:12 - and test loss. The label here is going to be test loss. And then we'll add a title, which will be
1436:20 - loss PLT. Let's put a label on the X, which will be epochs. So we know how many steps we've done.
1436:28 - This plot over here, loss curves, it uses steps. I'm going to use epochs. They mean almost the
1436:33 - same thing. It depends on what scale you'd like to see your loss curves. We'll get a legend as well
1436:41 - so that we are the labels appear. Now we're going to plot the accuracy. So PLT dot subplot.
1436:49 - Let's go one, two, and then index number two that this plot's going to be on PLT dot plot.
1436:55 - We're going to go epochs accuracy. And the label here is going to be train accuracy.
1437:04 - And then we'll get on the next plot, which is actually going to be on the same plot.
1437:08 - We'll put the test accuracy. That way we have the test accuracy and the training accuracy side
1437:12 - by side, test accuracy same with the train loss and train, sorry, test loss. And then we'll give
1437:20 - our plot a title. This plot is going to be accuracy. And then we're going to give it an
1437:25 - X label, which is going to be epochs as well. And then finally, we'll get the plot, but legend,
1437:31 - a lot of plotting code here. But let's see what this looks like. Hey, if we've done it all right,
1437:36 - we should be able to pass it in a dictionary just like this and see some nice plots like this.
1437:44 - Let's give it a go. And I'm going to call plot loss curves. And I'm going to pass in model 0 results.
1437:58 - All righty then. Okay. So that's not too bad. Now, why do I say that? Well, because we're
1438:06 - looking here for mainly trends, we haven't trained our model for too long. Quantitatively, we know
1438:12 - that our model hasn't performed at the way we'd like it to do. So we'd like the accuracy on both
1438:18 - the train and test data sets to be higher. And then of course, if the accuracy is going higher,
1438:23 - then the loss is going to come down. So the ideal trend for a loss curve is to go down from
1438:31 - the top left to the bottom right. In other words, the loss is going down over time. So that's,
1438:38 - the trend is all right here. So potentially, if we train for more epochs, which I'd encourage
1438:44 - you to give it a go, our model's loss might get lower. And the accuracy is also trending in the
1438:49 - right way. Our accuracy, we want it to go up over time. So if we train for more epochs, these curves
1438:56 - may continue to go on. Now, they may not, they, you never really know, right? You can guess these
1439:02 - things. But until you try it, you don't really know. So in the next video, we're going to have a
1439:08 - look at some different forms of loss curves. But before we do that, I'd encourage you to go through
1439:12 - this guide here, interpreting loss curves. So I feel like if you just search out loss curves,
1439:19 - you're going to find Google's guide, or you could just search interpreting loss curves.
1439:23 - Because as you'll see, there's many different ways that loss curves can be interpreted. But the ideal
1439:29 - trend is for the loss to go down over time, and metrics like accuracy to go up over time.
1439:38 - So in the next video, let's cover a few different forms of loss curves, such as the ideal loss
1439:43 - curve, what it looks like when your model's underfitting, and what it looks like when your
1439:47 - model's overfitting. And if you'd like to have a primer on those things, I'd read through this
1439:52 - guide here. Don't worry too much if you're not sure what's happening. We're going to cover a bit
1439:57 - more about loss curves in the next video. I'll see you there. In the last video, we looked at our
1440:05 - model's loss curves, and also the accuracy curves. And a loss curve is a way to evaluate a model's
1440:12 - performance over time, such as how long it was training for. And as you'll see, if you Google
1440:18 - some images of loss curves, you'll see many different types of loss curves. They come in all
1440:24 - different shapes and sizes. And there's many different ways to interpret loss curves. So
1440:29 - this is Google's testing and debugging and machine learning guide. So I'm going to set this as
1440:34 - actually curriculum for this section. So we're up to number eight. Let's have a look at what should
1440:41 - an ideal loss curve look like. So we'll just link that in there. Now, loss curve, I'll just
1440:54 - rewrite here, is a loss curve is, I'll just make some space. A loss curve is one of the most
1441:05 - helpful ways to troubleshoot a model. So the trend of a loss curve, you want it to go down over time,
1441:15 - and the trend typically of an evaluation metric, like accuracy, you want it to go up over time.
1441:20 - So let's go into the keynote, loss curves. So a way to evaluate your model's performance over time.
1441:28 - These are three of the main different forms of loss curve that you'll face. But again,
1441:34 - there's many different types as mentioned in here, interpreting loss curves. Sometimes you get it
1441:39 - going all over the place. Sometimes your loss will explode. Sometimes your metrics will be
1441:45 - contradictory. Sometimes your testing loss will be higher than your training loss. We'll have a
1441:50 - look at what that is. Sometimes your model gets stuck. In other words, the loss doesn't reduce.
1441:55 - Let's have a look at some loss curves here in the case of underfitting, overfitting, and just
1442:00 - right. So this is the Goldilocks zone. Underfitting is when your model's loss on the training and
1442:07 - test data sets could be lower. So in our case, if we go back to our loss curves, of course,
1442:13 - we want this to be lower, and we want our accuracy to be higher. So from our perspective,
1442:19 - it looks like our model is underfitting. And we would probably want to train it for longer,
1442:24 - say, 10, 20 epochs to see if this train continues. If it keeps going down, it may stop underfitting.
1442:31 - So underfitting is when your loss could be lower. Now, the inverse of underfitting is called
1442:39 - overfitting. And so two of the biggest problems in machine learning is trying to
1442:45 - underfitting. So in other words, make your loss lower and also reduce overfitting. These are
1442:50 - both active areas of research because you always want your model to perform better,
1442:55 - but you also want it to perform pretty much the same on the training set as it does the test set.
1443:01 - And so overfitting would be when your training loss is lower than your testing loss. And why
1443:08 - would this be overfitting? So it means overfitting because your model is essentially learning the
1443:14 - training data too well. And that means the loss goes down on the training data set,
1443:19 - which is typically a good thing. However, this learning is not reflected in the testing data set.
1443:27 - So your model is essentially memorizing patterns in the training data set that don't
1443:32 - generalize well to the test data set. So this is where we come to the just right curve is that we
1443:38 - want, ideally, our training loss to reduce as much as our test loss. And quite often, you'll find
1443:45 - that the loss is slightly lower on the training set than it is on the test set. And that's just
1443:51 - because the model is exposed to the training data, and it's never seen the test data before.
1443:56 - So it might be a little bit lower on the training data set than on the test data set.
1444:02 - So underfitting, the model's loss could be lower. Overfitting, the model is learning the training
1444:08 - data too well. Now, this would be equivalent to say you were studying for a final exam,
1444:13 - and you just memorize the course materials, the training set. And when it came time to the final
1444:19 - exam, because you don't even memorize the course materials, you couldn't adapt those skills to
1444:25 - questions you hadn't seen before. So the final exam would be the test set. So that's overfitting.
1444:31 - The train loss is lower than the test loss. And just right, ideally, you probably won't see
1444:37 - loss curves this exact smooth. I mean, they might be a little bit jumpy. Ideally, your training loss
1444:44 - and test loss go down at a similar rate. And of course, there's more combinations of these. If
1444:48 - you'd like to see them, check out the Google's loss curve guide that you can check that out there.
1444:53 - That's some extra curriculum. Now, you probably want to know how do you deal with underfitting
1444:58 - and overfitting? Let's look at a few ways. We'll start with overfitting.
1445:02 - So we want to reduce overfitting. In other words, we want our model to perform just as
1445:10 - well on the training data set as it does on the test data set. So one of the best ways to
1445:16 - reduce overfitting is to get more data. So this means that our training data set will be larger.
1445:21 - Our model will be exposed to more examples. And with us, in theory, it doesn't always work.
1445:28 - These all come with a caveat, right? They don't always work as with many things in machine learning.
1445:33 - So get more data, give your model more chance to learn patterns, generalizable patterns in a
1445:38 - data set. You can use data augmentation. So make your models training data set harder to learn.
1445:45 - So we've seen a few examples of data augmentation. You can get better data. So not only more data,
1445:50 - perhaps the data that you're using isn't that the quality isn't that good. So if you enhance the
1445:57 - quality of your data set, your model may be able to learn better, more generalizable patterns and
1446:02 - in turn reduce overfitting. Use transfer learning. So we're going to cover this in a later section
1446:08 - of the course. But transfer learning is taking one model that works, taking its patterns that it's
1446:15 - learned and applying it to your own data set. So for example, I'll just go into the Torch Vision
1446:21 - models library. Many of these models in here in Torch Vision, the models module, have already
1446:28 - been trained on a certain data set and such as ImageNet. And you can take the weights or the
1446:35 - patterns that these models have learned. And if they work well on an ImageNet data set, which is
1446:41 - millions of different images, you can adjust those patterns to your own problem. And oftentimes
1446:47 - that will help with overfitting. If you're still overfitting, you can try to simplify your model.
1446:52 - Usually this means taking away things like extra layers, taking away more hidden units. So say you
1446:58 - had 10 layers, you might reduce it to five layers. Why does this? What's the theory behind this?
1447:04 - Well, if you simplify your model and take away complexity from your model, you're kind of telling
1447:10 - your model, hey, use what you've got. And you're going to have to, because you've only got five
1447:15 - layers now, you're going to have to make sure that those five layers work really well, because
1447:20 - you've no longer got 10. And the same for hidden units. Say you started with 100 hidden units per
1447:25 - layer, you might reduce that to 50 and say, hey, you had 100 before. Now use those 50 and make your
1447:32 - patterns generalizable. Use learning rate decay. So the learning rate is how much your optimizer
1447:41 - updates your model's weight every step. So learning rate decay is to decay the learning rate
1447:52 - over time. So you might look this up, you can look this up, go high torch, learning rate,
1447:59 - scheduling. So what this means is you want to decrease your learning rate over time.
1448:05 - Now, I know I'm giving you a lot of different things here, but you've got this keynote as a
1448:09 - reference. So you can come across these over time. So learning rate scheduling. So we might look
1448:15 - into here, do we have schedule, scheduler, beautiful. So this is going to adjust the learning rate
1448:23 - over time. So for example, at the start of when a model is training, you might want a higher learning
1448:28 - rate. And then as the model starts to learn patterns more and more and more, you might want to reduce
1448:34 - that learning rate over time so that your model doesn't update its patterns too much
1448:39 - in later epochs. So that's the concept of learning rate scheduling. At the closer you get to convergence,
1448:46 - the lower you might want to set your learning rate, think of it like this. If you're reaching
1448:51 - for a coin at the back of a couch, can we get an image of that coin at back of couch?
1448:57 - Images. So if you're trying to reach a coin in the cushions here, so the closer you get to that coin,
1449:05 - at the beginning, you might take big steps. But then the closer you get to that coin, the smaller
1449:11 - the step you might take to pick that coin out. Because if you take a big step when you're really
1449:15 - close to the coin here, the coin might fall down the couch. The same thing with learning rate decay.
1449:22 - At the start of your model training, you might take bigger steps as your model works its way
1449:26 - down the loss curve. But then you get closer and closer to the ideal position on the loss curve.
1449:32 - You might start to lower and lower that learning rate until you get right very close to the end
1449:36 - and you can pick up the coin. Or in other words, your model can converge. And then finally, use
1449:43 - early stopping. So if we go into an image, is there early stopping here? Early stopping.
1449:50 - Loss curves early stopping. So what this means is that you stop. Yeah, there we go. So there's
1450:00 - heaps of different guides early stopping with PyTorch. Beautiful. So what this means is before
1450:04 - your testing error starts to go up, you keep track of your model's testing error. And then you stop
1450:11 - your model from training or you save the weight or you save the patterns where your model's loss
1450:16 - was the lowest. So then you could just set your model to train for an infinite amount of training
1450:21 - steps. And as soon as the testing error starts to increase for say 10 steps in a row, you go back
1450:27 - to this point here and go, I think that was where our model was the best. And the testing
1450:31 - error started to increase after that. So we're going to save that model there instead of the model
1450:36 - here. So that's the concept of early stopping. So that's dealing with overfitting. There are
1450:42 - other methods to deal with underfitting. So recall underfitting is when we have a loss that isn't as
1450:48 - low as we'd like it to be. Our model is not fitting the data very well. So it's underfitting.
1450:54 - So to reduce underfitting, you can add more layers slash units to your model. You're trying to
1450:59 - increase your model's ability to learn by adding more layers or units. You can again tweak the
1451:05 - learning rate. Perhaps your learning rate is too high to begin with and your model doesn't learn
1451:09 - very well. So you can adjust the learning rate again, just like we discussed with reaching for
1451:14 - that coin at the back of a couch. If your model is still underfitting, you can train for longer. So
1451:19 - that means giving your model more opportunities to look at the data. So more epochs, that just
1451:24 - means it's got looking at the training set over and over and over and over again and trying to
1451:29 - learn those patterns. However, you might find again, if you try to train for too long, your testing
1451:35 - error will start to go up. Your model might start overfitting if you train too long. So machine
1451:40 - learning is all about a balance between underfitting and overfitting. You want your model to fit quite
1451:45 - well. And so this is a great one. So you want your model to start fitting quite well. But then if you
1451:52 - try to reduce underfitting too much, you might start to overfit and then vice versa, right? If
1451:58 - you try to reduce overfitting too much, your model might underfit. So this is one of the
1452:03 - most fun dances in machine learning, the balance between overfitting and underfitting.
1452:08 - Finally, you might use transfer learning. So transfer learning helps with overfitting and
1452:13 - underfitting. Recall transfer learning is using a model's learned patterns from Ron problem and
1452:18 - adjusting them to your own. We're going to see this later on in the course. And then finally,
1452:23 - use less regularization. So regularization is holding your model back. So it's trying
1452:29 - to prevent overfitting. So if you do too much preventing of overfitting, in other words,
1452:34 - regularizing your model, you might end up underfitting. So if we go back, we have a look at the ideal
1452:40 - curves, underfitting. If you try to prevent underfitting too much, so increasing your model's
1452:47 - capability to learn, you might end up overfitting. And if you try to prevent overfitting too much,
1452:51 - you might end up underfitting. We are going for the just right section. And this is going to be a
1452:57 - balance between these two throughout your entire machine learning career. In fact, it's probably
1453:03 - the most prevalent area of research is trying to get models not to underfit, but also not to
1453:11 - overfit. So keep that in mind. A loss curve is a great way to evaluate your model's performance
1453:17 - over time. And a lot of what we do with the loss curves is try to work out whether our model is
1453:23 - underfitting or overfitting, and we're trying to get to this just right curve. We might not get
1453:28 - exactly there, but we want to keep trying getting as close as we can. So with that being said,
1453:34 - let's now build another model in the next video. And we're going to try a method to try and see if
1453:41 - we can use data augmentation to prevent our model from overfitting. Although that experiment
1453:46 - doesn't sound like the most ideal one we could do right now, because it looks like our model is
1453:50 - underfitting. So with your knowledge of what you've just learned in the previous video,
1453:54 - how to prevent underfitting, what would you do to increase this model's capability of learning
1454:01 - patterns in the training data set? Would you train it for longer? Would you add more layers?
1454:07 - Would you add more hidden units? Have a think and we'll start building another model in the next video.
1454:12 - Welcome back. In the last video, we covered the important concept of a loss curve and how it can
1454:23 - give us information about whether our model is underfitting. In other words, our model's loss
1454:28 - could be lower or whether it's overfitting. In other words, the training loss is lower than the test
1454:35 - loss or far lower than the validation loss. That's another thing to note here is that I put training
1454:41 - and test sets here. You could also do this with a validation data set and that the just right,
1454:46 - the Goldilocks zone, is when our training and test loss are quite similar over time.
1454:53 - Now, there was a fair bit of information in that last video, so I just wanted to highlight
1454:57 - that you can get this all in section 04, which is the notebook that we're working on. And then
1455:02 - if you come down over here, if we come to section 8, watch an ideal loss curve look like we've got
1455:08 - underfitting, overfitting, just right, how to deal with overfitting. We've got a few options here.
1455:14 - We've got how to deal with underfitting and then we've got a few options there. And then if we
1455:18 - wanted to look for more, how to deal with overfitting. You could find a bunch of resources here and then
1455:26 - how to deal with underfitting. You could find a bunch of resources here as well. So that is a
1455:35 - very fine line, very fine balance that you're going to experience throughout all of your
1455:39 - machine learning career. But it's time now to move on. We're going to move on to creating
1455:45 - another model, which is tiny VGG, with data augmentation this time. So if we go back to the slide,
1455:54 - data augmentation is one way of dealing with overfitting. Now, it's probably not the most
1455:59 - ideal experiment that we could take because our model zero, our baseline model, looks like it's
1456:04 - underfitting. But data augmentation, as we've seen before, is a way of manipulating images
1456:11 - to artificially increase the diversity of your training data set without collecting more data.
1456:18 - So we could take our photos of pizza, sushi, and steak and randomly rotate them 30 degrees
1456:24 - and increase diversity forces a model to learn or hopefully learn. Again, all of these come with
1456:29 - a caveat of not always being the silver bullet to learn more generalizable patterns. Now,
1456:36 - I should have spelled generalizable here rather than generalization, but similar thing.
1456:42 - Let's go here. Let's create to start off with, we'll just write down.
1456:48 - Now let's try another modeling experiment. So this is in line with our PyTorch workflow,
1456:55 - trying a model and trying another one and trying another one, so and so over again. This time,
1457:01 - using the same model as before, but with some slight data augmentation.
1457:10 - Oh, maybe we're not slight. That's probably not the best word. We'll just say with some data
1457:15 - augmentation. And if we come down here, we're going to write section 9.1. We need to first
1457:20 - create a transform with data augmentation. So we've seen what this looks like before.
1457:28 - We're going to use the trivial augment data augmentation, create training transform,
1457:34 - which is, as we saw in a previous video, what PyTorch the PyTorch team have recently used
1457:40 - to train their state-of-the-art computer vision models. So train transform trivial.
1457:46 - This is what I'm going to call my transform. And I'm just going to from Torch Vision import
1457:53 - transforms. We've done this before. We don't have to re-import it, but I'm going to do it anyway,
1457:58 - just to show you that we're re-importing or we're using transforms. And we're going to compose
1458:03 - a transform here. Recall that transforms help us manipulate our data. So we're going to transform
1458:09 - our images into size 64 by 64. Then we're going to set up a trivial augment transforms,
1458:15 - just like we did before, trivial augment wide. And we're going to set the number of magnitude
1458:24 - bins here to be 31, which is the default here, which means we'll randomly use some data augmentation
1458:31 - on each one of our images. And it will be applied at a magnitude of 0 to 31, also randomly selected.
1458:38 - So if we lower this to five, the upper bound of intensity of how much that data augmentation is
1458:44 - applied to a certain image will be less than if we set it to say 31. Now, our final transform
1458:51 - here is going to be too tensor because we want our images in tensor format for our model.
1458:57 - And then I'm going to create a test transform. I'm going to call this simple, which is just going
1459:03 - to be transforms dot compose. And all that it's going to have, oh, I should put a list here,
1459:09 - all that it's going to have, we'll just make some space over here, is going to be transforms.
1459:17 - All we want to do is resize the image size equals 64 64. Now we don't apply data augmentation
1459:27 - to the test data set, because we only just want to evaluate our models on the test data set.
1459:33 - Our models aren't going to be learning any generalizable patterns on the test data set,
1459:37 - which is why we focus our data augmentations on the training data set. And I've just readjusted
1459:43 - that. I don't want to do that. Beautiful. So we've got a transform ready. Now let's load some data
1459:51 - using those transforms. So we'll create train and test data sets and data loaders
1460:01 - with data augmentation. So we've done this before. You might want to try it out on your own. So
1460:12 - pause the video if you'd like to test it out. Create a data set and a data loader using these
1460:18 - transforms here. And recall that our data set is going to be creating a data set from pizza,
1460:25 - steak and sushi for the train and test folders. And that our data loader is going to be batchifying
1460:31 - our data set. So let's turn our image folders into data sets. Data sets, beautiful. And I'm going
1460:41 - to write here train data augmented just so we know that it's it's been augmented. We've got a few
1460:48 - of similar variable names throughout this notebook. So I just want to be as clear as possible. And
1460:52 - I'm going to use, I'll just re import torch vision data sets. We've seen this before, the image
1460:59 - folder. So rather than our use our own custom class, we're going to use the existing image folder
1461:05 - class that's within torch vision data sets. And we have to pass in here a root. So I'll just get
1461:12 - the doc string there, root, which is going to be equal to our trainer, which recall is the path
1461:19 - to our training directory. Got that saved. And then I'm going to pass in here, the transform is going
1461:28 - to be train transform trivial. So our training data is going to be augmented. Thanks to this
1461:35 - transform here, and transforms trivial augment wide. You know where you can find more about
1461:41 - trivial augment wide, of course, in the pie torch documentation, or just searching transforms
1461:47 - trivial augment wide. And did I spell this wrong? trivial. Oh, train train transform. I spelled
1461:59 - that wrong. Of course I did. So test data, let's create this as test data simple, equals data sets
1462:06 - dot image folder. And the root D is going to be here the test directory. And the transform is
1462:12 - just going to be what the test transform simple. Beautiful. So now let's turn these data sets
1462:24 - into data loaders. So turn our data sets into data loaders. We're going to import os,
1462:36 - I'm going to set the batch size here to equal to 32. The number of workers that are going to
1462:41 - load our data loaders, I'm going to set this to os dot CPU count. So there'll be one worker
1462:46 - per CPU on our machine. I'm going to set here the torch manual seed to 42, because we're going to
1462:55 - shuffle our training data. Train data loader, I'm going to call this augmented equals data loader.
1463:03 - Now I just want to I don't need to re import this, but I just want to show you again from
1463:08 - torch dot utils. You can never have enough practice right dot data. Let's import data loader.
1463:16 - So that's where we got the data loader class from. Now let's go train data augmented. We'll
1463:22 - pass in that as the data set. And I'll just put in here the parameter name for completeness.
1463:28 - That's our data set. And then we want to set the batch size, which is equal to batch size.
1463:33 - I'm going to set shuffle equal to true. And I'm going to set num workers equal to num workers.
1463:45 - Beautiful. And now let's do that again with the test data loader that this time test data
1463:52 - loader. I'm going to call this test data loader simple. We're not using any data
1463:56 - augmentation on the test data set, just turning our images, our test images into tenses.
1464:01 - The data set here is going to be test data simple. Going to pass in the batch size equal to batch
1464:08 - size. So both our data loaders will have a batch size of 32. Going to keep shuffle on false.
1464:14 - And num workers, I'm going to set to num workers. Look at us go. We've already got a data set
1464:26 - and a data loader. This time, our data loader is going to be augmented for the training data set.
1464:32 - And it's going to be nice and simple for the test data set. So this is really similar,
1464:36 - this data loader to the previous one we made. The only difference in this modeling experiment
1464:41 - is that we're going to be adding data augmentation, namely trivial augment wide.
1464:47 - So with that being said, we've got a data set, we've got a data loader. In the next video,
1464:52 - let's construct and train model one. In fact, you might want to give that a go. So you can use
1464:58 - our tiny VGG class to make model one. And then you can use our train function to train a new
1465:05 - tiny VGG instance with our training data loader augmented and our test data loader simple.
1465:13 - So give that a go and we'll do it together in the next video. I'll see you there.
1465:17 - Now that we've got our data sets and data loaders with data augmentation ready,
1465:26 - let's now create another model. So 9.3, we're going to construct and train model one.
1465:34 - And this time, I'm just going to write what we're going to doing, going to be doing sorry.
1465:40 - This time, we'll be using the same model architecture, but we're changing the data here.
1465:46 - Except this time, we've augmented the training data. So we'd like to see how this performs
1465:56 - compared to a model with no data augmentation. So that was our baseline up here. And that's what
1466:03 - you'll generally do with your experiments. You'll start as simple as possible and introduce
1466:08 - complexity when required. So create model one and send it to the target device, that is,
1466:14 - to the target device. And because of our helpful selves previously, we can create a manual seed
1466:21 - here, torch.manualseed. And we can create model one, leveraging the class that we created before.
1466:29 - So although we built tiny VGG from scratch in this video, in this section, sorry, in subsequent
1466:37 - coding sessions, because we've built it from scratch once and we know that it works, we can
1466:42 - just recreate it by calling the class and passing in different variables here. So let's get the
1466:48 - number of classes that we have in our train data augmented classes. And we're going to send it
1466:54 - to device. And then if we inspect model one, let's have a look. Wonderful. Now let's keep going.
1467:03 - We can also leverage our training function that we did. You might have tried this before.
1467:08 - So let's now train our model. She's going to put here. Wonderful. Now we've got a model and
1467:17 - data loaders. Let's create what do we have to do? We have to create a loss function and an optimizer
1467:24 - and call upon our train function that we created earlier to train and evaluate our model. Beautiful.
1467:37 - So I'm going to set the random seeds, torch dot manual seeds, and torch dot CUDA, because we're
1467:48 - going to be using CUDA. Let's set the manual seed here 42. I'm going to set the number of epochs.
1467:54 - We're going to keep many of the parameters the same. Set the number of epochs, num epochs equals
1468:01 - five. We could of course train this model for longer if we really wanted to by increasing the
1468:06 - number of epochs. But now let's set up the loss function. So loss FN equals NN cross entropy loss.
1468:16 - Don't forget this just came into mind. Loss function often as well in PyTorch is called
1468:21 - criterion. So the criterion you're trying to reduce. But I just like to call it loss function.
1468:28 - And then we're going to have optimizer. Let's use the same optimizer we use before torch dot
1468:34 - opt in dot atom. Recall SGD and atom are two of the most popular optimizers. So model one dot
1468:41 - parameters. Then the parameters we're going to optimize. We're going to set the learning rate to
1468:46 - zero zero one, which is the default for the atom optimizer in PyTorch. Then we're going to start
1468:54 - the timer. So from time it, let's import the default timer as timer. And we'll go start time
1469:02 - equals timer. And then let's go train model one. How can we do this? Well, we're going to get a
1469:12 - results dictionary as model one results. We're going to call upon our train function. Inside our
1469:17 - train function, we'll pass the model parameter as model one. For the train data loader parameter,
1469:23 - we're going to pass in train data loader augmented. So our augmented training data loader.
1469:29 - And for the test data loader, we can pass in here test data loader. Simple. Then we can write our
1469:39 - optimizer, which will be the atom optimizer. Our loss function is going to be an n cross entropy
1469:45 - loss, what we've created above. And then we can set the number of epochs is going to be equal to
1469:50 - num epochs. And then if we really wanted to, we could set the device equal to device, which will
1469:56 - be our target device. And now let's end the timer and print out how long it took.
1470:06 - Took n time equals timer. And we'll go print total training time for model one is going to be
1470:18 - n time minus start time. And oh, it would help if I could spell, we'll get that to three decimal
1470:28 - places. And that'll be seconds. So you're ready? We look how quickly we built a training pipeline
1470:35 - for model one. And look how big easily we created it. So go ask for coding all of that stuff up
1470:41 - before. Let's train our second model, our first model using data augmentation. You're ready? Three,
1470:50 - two, one, let's go. No errors. Beautiful. We're going nice and quick here.
1470:59 - So oh, about just over seven seconds. So what what GPU do I have currently?
1471:05 - Just keep this in mind that I'm using Google Colab Pro. So I get preference in terms of
1471:11 - allocating a faster GPU. Your model training time may be longer than what I've got, depending on the
1471:16 - GPU. It also may be faster, again, depending on the GPU. But we get about seven seconds, but it looks
1471:22 - like our model with data augmentation didn't perform as well as our model without data augmentation.
1471:29 - Hmm. So how long did our model before without data augmentation take the train? Oh, just over seven
1471:37 - seconds as well. But we got better results in terms of accuracy on the training and test data sets
1471:43 - for model zero. So maybe data augmentation doesn't help in our case. And we kind of hinted at that
1471:48 - because the loss here was already going down. We weren't really overfitting yet. So recall that data
1471:56 - augmentation is a way to help with overfitting generally. So maybe that wasn't the best step to
1472:03 - try and improve our model. But let's nonetheless keep evaluating our model. In the next video,
1472:09 - we're going to plot the loss curves of model one. So in fact, you might want to give that a go.
1472:14 - So we've got a function plot loss curves, and we've got some results in a dictionary format.
1472:20 - So try that out, plot the loss curves, and see what you see. Let's do it together in the next video.
1472:28 - I'll see you there.
1472:31 - In the last video, we did the really exciting thing of training our first model with data
1472:36 - augmentation. But we also saw that quantitatively, it looks like that it didn't give us much improvement.
1472:43 - So let's keep evaluating our model here. I'm going to make a section. Recall that one of my
1472:48 - favorite ways or one of the best ways, not just my favorite, to evaluate the performance of a
1472:52 - model over time is to plot the loss curves. So a loss curve helps you evaluate your model's performance
1473:04 - over time. And it will also give you a great visual representation or a visual way to see if
1473:10 - your model is underfitting or overfitting. So let's plot the loss curves of model one results and see
1473:18 - what happens. We're using this function we created before. And oh my goodness, is that going in the
1473:24 - right direction? It looks like our test loss is going up here. Now, is that where we want it to go?
1473:33 - Remember the ideal direction for a loss curve is to go down over time because loss is measuring
1473:38 - what? It's measuring how wrong our model is. And the accuracy curve looks like it's all over the
1473:44 - place as well. I mean, it's going up kind of, but maybe we don't have enough time to measure these
1473:49 - things. So an experiment that you could do is train both of our models model zero and model one
1473:56 - for more epochs and see if these loss curves flatten out. So I'll pose you the question,
1474:02 - is our model underfitting or overfitting right now or both? So if we want to have a look at the
1474:09 - loss curves, our just right is for the loss that is, this is not for accuracy, this is for loss over
1474:15 - time, we want it to go down. So for me, our model is underfitting because our loss could be lower,
1474:23 - but it also looks like it's overfitting as well. So it's not doing a very good job because our test
1474:28 - loss is far higher than our training loss. So if we go back to section four of the LearnPyTorch.io
1474:38 - book, what should an ideal loss curve look like? I'd like you to start thinking of some ways
1474:43 - that we could deal with overfitting of our model. So could we get more data? Could we simplify it?
1474:49 - Could we use transfer learning? We're going to see that later on, but you might want to jump
1474:53 - ahead and have a look. And if we're dealing with underfitting, what are some other things that we
1474:58 - could try with our model? Could we add some more layers, potentially another convolutional block?
1475:03 - Could we increase the number of hidden units per layer? So if we've got currently 10 hidden units
1475:08 - per layer, maybe you want to increase that to 64 or something like that? Could we train it for
1475:13 - longer? That's probably one of the easiest things to try with our current training functions. We
1475:17 - could train for 20 epochs. So have a go at this, reference this, try out some experiments with,
1475:24 - see if you can get these loss curves more towards the ideal shape. And in the next video, we're going
1475:30 - to keep pushing forward. We're going to compare our model results. So we've done two experiments.
1475:35 - Let's now see them side by side. We've looked at our model results individually,
1475:39 - and we know that they could be improved. But a good way to compare all of your experiments
1475:44 - is to compare your model's results side by side. So that's what we're going to do in the next video.
1475:49 - I'll see you there. Now that we've compared our models loss curves on their own individually,
1475:59 - how about we compare our model results to each other? So let's have a look at comparing our model
1476:05 - results. And so I'm going to write a little note here that after evaluating our modeling
1476:13 - experiments on their own, it's important to compare them to each other. And there's a few
1476:24 - different ways to do this. There's a few different ways to do this. Number one is hard coding.
1476:32 - So like we've done, we've written functions, we've written helper functions and whatnot,
1476:37 - and manually plotted things. So I'm just going to write in here, this is what we're doing.
1476:42 - Then, of course, there are tools to do this, such as PyTorch plus TensorBoard. So I'll link to this,
1476:48 - PyTorch TensorBoard. We're going to see this in a later section of the course. TensorBoard is a
1476:54 - great resource for tracking your experiments. If you'd like to jump forward and have a look at what
1476:59 - that is in the PyTorch documentation, I'd encourage you to do so. Then another one of my favorite
1477:05 - tools is weights and biases. So these are all going to involve some code as well, but they help out
1477:13 - with automatically tracking different experiments. So weights and biases is one of my favorite,
1477:20 - and you've got platform for experiments. That's what you'll be looking at. So if you run multiple
1477:25 - experiments, you can set up weights and biases pretty easy to track your different model hub
1477:30 - parameters. So PyTorch, there we go. Import weights and biases, start a new run on weights and biases.
1477:37 - You can save the learning rate value and whatnot, go through your data and just log everything there.
1477:43 - So this is not a course about different tools. We're going to focus on just pure PyTorch,
1477:48 - but I thought I'd leave these here anyway, because you're going to come across them
1477:51 - eventually, and MLflow is another one of my favorites as well. We have ML tracking,
1477:58 - projects, models, registry, all that sort of stuff. If you'd like in to look into
1478:03 - more ways to track your experiments, there are some extensions. But for now, we're going to stick
1478:08 - with hard coding. We're just going to do it as simple as possible to begin with. And if we wanted
1478:13 - to add other tools later on, we can sure do that. So let's create a data frame for each of our model
1478:20 - results. We can do this because our model results recall are in the form of dictionaries. So model
1478:26 - zero results. But you can see what we're doing now by hard coding this, it's quite cumbersome.
1478:33 - Can you imagine if we had say 10 models or even just five models, we'd have to really
1478:38 - write a fair bit of code here for all of our dictionaries and whatnot, whereas these tools
1478:45 - here help you to track everything automatically. So we've got a data frame here. Model zero results
1478:51 - over time. These are our number of epochs. We can notice that the training loss starts to go down.
1478:56 - The testing loss also starts to go down. And the accuracy on the training and test data set starts
1479:02 - to go up. Now, those are the trends that we're looking for. So an experiment you could try would
1479:06 - be to train this model zero for longer to see if it improved. But we're currently just interested
1479:12 - in comparing results. So let's set up a plot. I want to plot model zero results and model one
1479:18 - results on the same plot. So we'll need a plot for training loss. We'll need a plot for training
1479:24 - accuracy, test loss and test accuracy. And then we want two separate lines on each of them. One
1479:31 - for model zero and one for model one. And this particular pattern would be similar regardless if
1479:37 - we had 10 different experiments, or if we had 10 different metrics we wanted to compare,
1479:42 - you generally want to plot them all against each other to make them visual. And that's what tools
1479:47 - such as weights and biases, what TensorBoard, and what ML flow can help you to do. I'm just
1479:52 - going to get out of that, clean up our browser. So let's set up a plot here. I'm going to use
1479:59 - matplotlib. I'm going to put in a figure. I'm going to make it quite large because we want four
1480:04 - subplots, one for each of the metrics we want to compare across our different models. Now,
1480:10 - let's get number of epochs. So epochs is going to be length, or we'll turn it into a range, actually,
1480:19 - range of Len model zero DF. So that's going to give us five. Beautiful range between zero and five.
1480:29 - Now, let's create a plot for the train loss. We want to compare the train loss across model zero
1480:36 - and the train loss across model one. So we can go PLT dot subplot. Let's create a plot with two
1480:45 - rows and two columns. And this is going to be index number one will be the training loss.
1480:50 - We'll go PLT dot plot. I'm going to put in here epochs and then model zero DF. Inside here,
1480:57 - I'm going to put train loss for our first metric. And then I'm going to label it with model zero.
1481:04 - So we're comparing the train loss on each of our modeling experiments. Recall that model zero was
1481:12 - our baseline model. And that was tiny VGG without data augmentation. And then we tried out model one,
1481:19 - which was the same model. But all we did was we added a data augmentation transform to our training
1481:25 - data. So PLT will go x label. They both used the same test data set and PLT dot legend. Let's see
1481:35 - what this looks like. Wonderful. So there's our training loss across two different models.
1481:43 - So we notice that model zero is trending in the right way. Model one kind of exploded on epoch
1481:49 - number that would be zero, one, two, or one, depending how you're counting. Let's just say epoch number
1481:56 - two, because that's easier. The loss went up. But then it started to go back down. So again,
1482:00 - if we continued training these models, we might notice that the overall trend of the loss is
1482:05 - going down on the training data set, which is exactly what we'd like. So let's now plot,
1482:12 - we'll go the test loss. So I'm going to go test loss here. And then I'm going to change this.
1482:18 - I believe if I hold control, or command, maybe, nope, or option on my Mac keyboard,
1482:25 - yeah, so it might be a different key on Windows. But for me, I can press option and I can get a
1482:29 - multi cursor here. So I'm just going to come back in here. And that way I can backspace there
1482:35 - and just turn this into test loss. Wonderful. So I'm going to put this as test loss as the title.
1482:42 - And I need to change the index. So this will be index one, index two, index three, index four.
1482:49 - Let's see what this looks like. Do we get the test loss? Beautiful. That's what we get.
1482:55 - However, we noticed that model one is probably overfitting at this stage. So maybe the data
1483:00 - augmentation wasn't the best change to make to our model. Recall that even if you make a change
1483:05 - to your model, such as preventing overfitting or underfitting, it won't always guarantee that
1483:11 - the change takes your model's evaluation metrics in the right direction. Ideally, loss is going
1483:17 - from top left to bottom right over time. So looks like model zero is winning out here at the moment
1483:25 - on the loss front. So now let's plot the accuracy for both training and test. So I'm going to change
1483:32 - this to train. I'm going to put this as accuracy. And this is going to be index number three on the
1483:38 - plot. And do we save it as, yeah, just act? Wonderful. So I'm going to option click here on my Mac.
1483:48 - This is going to be train. And this is going to be accuracy here. And then I'll change this one to
1483:54 - accuracy. And then I'm going to change this to accuracy. And this is going to be plot number four,
1484:01 - two rows, two columns, index number four. And I'm going to option click here to have two cursors,
1484:07 - test, act. And then I'll change this to test, act. And I'm going to get rid of the legend here.
1484:15 - It takes a little bit to plot because we're doing four graphs in one hit. Wonderful. So that's
1484:20 - comparing our models. But do you see how we could potentially functionalize this to plot, however,
1484:26 - many model results that we have? But if we had say another five models, we did another five
1484:32 - experiments, which is actually not too many experiments on a problem, you might find that
1484:37 - sometimes you do over a dozen experiments for a single modeling problem, maybe even more.
1484:42 - These graphs can get pretty outlandish with all the little lines going through. So that's
1484:47 - again what tools like TensorBoard, weights and biases and MLflow will help with. But if we have
1484:54 - a look at the accuracy, it seems that both of our models are heading in the right direction.
1484:59 - We want to go from the bottom left up in the case of accuracy. But the test accuracy that's training,
1485:05 - oh, excuse me, is this not training accuracy? I messed up that. Did you catch that one?
1485:12 - So training accuracy, we're heading in the right direction, but it looks like model one is
1485:16 - yeah, still overfitting. So the results we're getting on the training data set
1485:20 - aren't coming over to the testing data set. And that's what we really want our models to shine
1485:26 - is on the test data set. So metrics on the training data set are good. But ideally,
1485:32 - we want our models to perform well on the test data set data it hasn't seen before.
1485:38 - So that's just something to keep in mind. Whenever you do a series of modeling experiments,
1485:42 - it's always good to not only evaluate them individually, evaluate them against each other.
1485:47 - So that way you can go back through your experiments, see what worked and what didn't.
1485:52 - If you were to ask me what I would do for both of these models, I would probably train them for
1485:56 - longer and maybe add some more hidden units to each of the layers and see where the results go from
1486:02 - there. So give that a shot. In the next video, let's see how we can use our trained models to
1486:08 - make a prediction on our own custom image of food. So yes, we used a custom data set of
1486:14 - pizza steak and sushi images. But what if we had our own, what if we finished this model training
1486:21 - and we decided, you know what, this is a good enough model. And then we deployed it to an app like
1486:25 - neutrify dot app, which is a food recognition app that I'm personally working on. Then we wanted to
1486:32 - upload an image and have it be classified by our pytorch model. So let's give that a shot, see how
1486:38 - we can use our trained model to predict on an image that's not in our training data and not in our
1486:44 - testing data. I'll see you in the next video. Welcome back. In the last video, we compared our
1486:54 - modeling experiments. Now we're going to move on to one of the most exciting parts of deep learning.
1487:00 - And that is making a prediction on a custom image. So although we've trained a model on custom data,
1487:14 - how do you make a prediction on a sample slash image in our case? That's not in either
1487:23 - the training or testing data set. So let's say you were building a food recognition app,
1487:30 - such as neutrify, take a photo of food and learn about it. You wanted to use computer vision to
1487:35 - essentially turn foods into QR codes. So I'll just show you the workflow here. If we were to upload
1487:41 - this image of my dad giving two thumbs up for a delicious pizza. And what does neutrify predicted
1487:48 - as pizza? Beautiful. So macaronutrients that you get some nutrition information and then the time
1487:54 - taken. So we could replicate a similar process to this using our trained PyTorch model, or be it.
1488:00 - It's not going to be too great of results or performance because we've seen that we could
1488:05 - improve our models, but based on the accuracy here and based on the loss and whatnot. But let's just
1488:11 - see what it's like, the workflow. So the first thing we're going to do is get a custom image.
1488:16 - Now we could upload one here, such as clicking the upload button in Google Colab, choosing an image
1488:23 - and then importing it like that. But I'm going to do so programmatically, as you've seen before.
1488:29 - So let's write some code in this video to download a custom image. I'm going to do so using requests
1488:36 - and like all good cooking shows, I've prepared a custom image for us. So custom image path. But
1488:43 - again, you could use this process that we're going to go through with any of your own images
1488:48 - of pizza, steak or sushi. And if you wanted to train your own model on another set of custom data,
1488:54 - the workflow will be quite similar. So I'm going to download a photo called pizza dad,
1489:00 - which is my dad, two big thumbs up. And so I'm going to download it from github. So this image is
1489:07 - on the course github. And let's write some code to download the image. If it doesn't already exist
1489:13 - in our Colab instance. So if you wanted to upload a single image, you could click with this button.
1489:20 - Just be aware that like all of our other data, it's going to disappear if Colab disconnects.
1489:25 - So that's why I like to write code. So we don't have to re upload it every time.
1489:28 - So if not custom image path is file, let's open a request here or open a file going to open up
1489:38 - the custom image path with right binary permissions as F short for file. And then when downloading,
1489:47 - this is because our image is stored on github. When downloading an image or when downloading
1489:54 - from github in general, you typically want the raw link need to use the raw file link.
1490:01 - So let's write a request here equals request dot get. So if we go to the pytorch deep learning
1490:08 - repo, then if we go into, I believe it might be extras, not in extras, it's going to be in images,
1490:15 - that would make a lot more sense. Wouldn't it Daniel? Let's get O for pizza dad.
1490:19 - So if we have a look, this is pytorch deep learning images, O for pizza dad. There's a big version
1490:26 - of the image there. And then if we click download, just going to give us the raw link. Yeah, there we
1490:32 - go. So that's the image. Hey dad, how you doing? Is that pizza delicious? It looks like it.
1490:36 - Let's see if our model can get this right. What do you think? Will it? So of course, we want
1490:43 - our model to predict pizza for this image because it's got a pizza in it. So custom image path,
1490:51 - we're going to download that. I've just put in the raw URL above. So notice the raw
1490:57 - github user content. That's from the course github. Then I'm going to go f dot right. So file,
1491:05 - write the request content. So the content from the request, in other words, the raw file from
1491:13 - github here. Similar workflow for if you were getting another image from somewhere else on
1491:18 - the internet and else if it is already downloaded, let's just not download it. So print f custom image
1491:26 - path already exists skipping download. And let's see if this works or run the code. So downloading
1491:36 - data o four pizza dad dot jpeg. And if we go into here, we refresh. There we go. Beautiful. So our
1491:46 - data or our custom image, sorry, is now in our data folder. So if we click on this, this is inside
1491:52 - Google CoLab now. Beautiful. We got a big nice big image there. And there's a nice big pizza there.
1492:01 - So we're going to be writing some code over the next few videos to do the exact same process as
1492:07 - what we've been doing to import our custom data set for our custom image. What do we still have to
1492:13 - do? We still have to turn it into tenses. And then we have to pass it through our model. So let's see
1492:18 - what that looks like over the next few videos. We are up to one of the most exciting parts of
1492:28 - building dev learning models. And that is predicting on custom data in our case, a custom image of
1492:35 - a photo of my dad eating pizza. So of course, we're training a computer vision model on here on
1492:40 - pizza steak and sushi. So hopefully the ideal result for our model to predict on this image
1492:45 - will be pizza. So let's keep going. Let's figure out how we can get our image, our custom image,
1492:53 - our singular image into Tensor form, loading in a custom image with pytorch, creating another
1492:59 - section here. So I'm just going to write down here, we have to make sure our custom image is in the
1493:06 - same format as the data our model was trained on. So namely, that was in Tensor form with data type
1493:18 - torch float 32. And then of shape 64 by 64 by three. So we might need to change the shape of our
1493:29 - image. And then we need to make sure that it's on the right device. Command MM, beautiful. So let's
1493:37 - see what this looks like. Hey, so if I'm going to import torch vision. Now the package you use to
1493:44 - load your data will depend on the domain you're in. So let's open up the torch vision documentation.
1493:51 - We can go to models. That's okay. So if we're working with text, you might want to look in
1493:56 - here for some input and output functions, so some loading functions, torch audio, same thing.
1494:02 - Torch vision is what we're working with. Let's click into torch vision. Now we want to look into
1494:07 - reading and writing images and videos because we want to read in an image, right? We've got a
1494:12 - custom image. We want to read it in. So this is part of your extracurricular, by the way, to go
1494:17 - through these for at least 10 minutes each. So spend an hour if you're going through torch vision.
1494:22 - You could do the same across these other ones. It will just really help you familiarize yourself
1494:26 - with all the functions of PyTorch domain libraries. So we want to look here's some options for video.
1494:33 - We're not working with video. Here's some options for images. Now what do we want to do? We want
1494:38 - to read in an image. So we've got a few things here. Decode image. Oh, I've skipped over one.
1494:44 - We can write a JPEG if we wanted to. We can encode a PNG. Let's jump into this one. Read image.
1494:51 - What does it do? Read the JPEG or PNG into a three-dimensional RGB or grayscale tensor.
1494:58 - That is what we want. And then optionally converts the image to the desired format.
1495:03 - The values of the output tensor are you int eight. Okay. Beautiful. So let's see what this looks like.
1495:10 - Okay. Mode. The read mode used optionally for converting the image. Let's see what we can do
1495:16 - with this. I'm going to copy this in. So I'll write this down. We can read an image into PyTorch using
1495:25 - and go with that. So let's see what this looks like in practice. Read in custom image. I can't
1495:34 - explain to you how much I love using deep learning models to predict on custom data. So custom image.
1495:41 - We're going to call it you int eight because as we read from the documentation here,
1495:46 - it reads it in you int eight format. So let's have a look at what that looks like rather than
1495:52 - just talking about it. Torch vision.io. Read image. What's our target image path?
1495:59 - Well, we've got custom image path up here. This is why I like to do things programmatically.
1496:04 - So if our collab notebook reset, we could just run this cell again,
1496:08 - get our custom image and then we've got it here. So custom image you int eight. Let's see what this
1496:14 - looks like. Oh, what did we get wrong? Unable to cast Python instance. Oh, does it need to be a
1496:23 - string expected a value type of string or what found POSIX path? So this the path needs to be a
1496:30 - string. Okay. If we have a look at our custom image path, what did we get wrong? Oh, we've got a
1496:38 - POSIX path. So let's convert this custom image path into a string and see what happens. Look at that.
1496:47 - That's how image in integer form. I wonder if this is plotable. Let's go PLT dot M show custom image
1496:55 - you int eight. Maybe we get a dimensionality problem here in valid shape. Okay. Let's
1497:00 - some permute it, permute, and we'll go one, two, zero. Is this going to plot? It's a fairly big image.
1497:11 - There we go. Two thumbs up. Look at us. So that is the power of torch vision.io. I owe stands for
1497:18 - input output. We were just able to read in our custom image. Now, how about we get some metadata
1497:24 - about this? Let's go. We'll print it up here, actually. I'll keep that there because that's
1497:29 - fun to plot it. Let's find the shape of our data, the data type. And yeah, we've got it in Tensor
1497:35 - format, but it's you int eight right now. So we might have to convert that to float 32. We want
1497:41 - to find out its shape. And we need to make sure that if we're predicting on a custom image,
1497:46 - the data that we're predicting on the custom image needs to be on the same device as our model.
1497:52 - So let's print out some info. Print. Let's go custom image Tensor. And this is going to be a new line.
1498:00 - And then we will go custom image you int eight. Wonderful. And then let's go custom image
1498:08 - shape. We will get the shape parameter custom image shape or attribute. Sorry. And then we also
1498:16 - want to know the data type custom image data type. But we have a kind of an inkling because the
1498:21 - documentation said it would be you int eight, you int eight, and we'll go D type. Let's have a look.
1498:30 - What do we have? So there's our image Tensor. And it's quite a big image. So custom image shape.
1498:36 - So what was our model trained on? Our model was trained on images of 64 by 64. So this image
1498:44 - encodes a lot more information than what our model was trained on. So we're going to have to
1498:49 - change that shape to pass it through our model. And then we've got an image data type here or
1498:56 - Tensor data type of torch you int eight. So maybe that's going to be some errors for us later on.
1499:01 - So if you want to go ahead and see if you can resize this Tensor to 64 64 using a torch transform
1499:07 - or torch vision transform, I'd encourage you to try that out. And if you know how to change a
1499:12 - torch tensor from you int eight to torch float 32, give that a shot as well. So let's try
1499:18 - make a prediction on our image in the next video. I'll see you there.
1499:26 - In the last video, we loaded in our own custom image and got two big thumbs up from my dad,
1499:31 - and we turned it into a tensor. So we've got a custom image tensor here. It's quite big though,
1499:36 - and we looked at a few things of what we have to do before we pass it through our model.
1499:40 - So we need to make sure it's in the data type torch float 32, shape 64, 64, 3, and on the right
1499:46 - device. So let's make another section here. We'll go 11.2 and we'll call it making a prediction on a
1499:56 - custom image with a pie torch model with a trained pie torch model. And albeit, our models aren't
1500:04 - quite the level we would like them at yet. I think it's important just to see what it's like to
1500:09 - make a prediction end to end on some custom data, because that's the fun part, right? So try to make
1500:17 - a prediction on an image. Now, I want to just highlight something about the importance of different
1500:22 - data types and shapes and whatnot and devices, three of the biggest errors in deep learning.
1500:28 - In let's see what happens if we try to predict on you int eight format. So we'll go model one
1500:36 - dot eval and with torch dot inference mode. Let's make a prediction. We'll pass it through our model
1500:44 - one. We could use model zero if we wanted to here. They're both performing pretty poorly anyway.
1500:50 - Let's send it to the device and see what happens. Oh, no. What did we get wrong here?
1500:56 - Runtime error input type. Ah, so we've got you int eight. So this is one of our first errors
1501:04 - that we talked about. We need to make sure that our custom data is of the same data type that
1501:10 - our model was originally trained on. So we've got torch CUDA float tensor. So we've got an issue
1501:17 - here. We've got a you into eight image data or image tensor trying to be predicted on by a model
1501:24 - with its data type of torch CUDA float tensor. So let's try fix this by loading the custom image
1501:33 - and convert to torch dot float 32. So one of the ways we can do this is we'll just recreate the
1501:42 - custom image tensor. And I'm going to use torch vision dot IO dot read image. We don't have to
1501:49 - fully reload our image, but I'm going to do it anyway for completeness and a little bit of practice.
1501:54 - And then I'm going to set the type here with the type method to torch float 32. And then
1502:01 - let's just see what happens. We'll go custom image. Let's see what this looks like. I wonder if our
1502:10 - model will work on this. Let's just try again, we'll bring this up, copy this down to make a
1502:17 - prediction and custom image dot two device. Our image is in torch float 32 now. Let's see what
1502:24 - happens. Oh, we get an issue. Oh my goodness, that's a big matrix. Now I have a feeling that
1502:32 - that might be because our image, our custom image is of a shape that's far too large. Custom image
1502:39 - dot shape. What do we get? Oh my gosh, 4000 and 3,024. And do you notice as well that our values
1502:47 - here are between zero and one, whereas our previous images, do we have an image? There we go. That
1502:54 - our model was trained on what between zero and one. So how could we get these values to be between
1502:59 - zero and one? Well, one of the ways to do so is by dividing by 255. Now, why would we divide by 255?
1503:09 - Well, because that's a standard image format is to store the image tensor values in values from
1503:17 - zero to 255 for red, green and blue color channels. So if we want to scale them, so this is what I
1503:24 - meant by zero to 255, if we wanted to scale these values to be between zero and one, we can divide
1503:31 - them by 255. Because that is the maximum value that they can be. So let's see what happens if we do
1503:38 - that. Okay, we get our image values between zero and one. Can we plot this image? So plt dot m
1503:47 - show, let's plot our custom image. We got a permute it. So it works nicely with mapplotlib.
1503:53 - What do we get here?
1504:00 - Beautiful. We get the same image, right? But it's still quite big. Look at that. We've got a pixel
1504:05 - height of or image height of almost 4000 pixels and a width of over 3000 pixels. So we need to do
1504:11 - some adjustments further on. So let's keep going. We've got custom image to device. We've got an
1504:17 - error here. So this is a shape error. So what can we do to transform our image shape? And you
1504:23 - might have already tried this. Well, let's create a transform pipeline to transform our image shape.
1504:29 - So create transform pipeline or composition to resize the image. Because remember, what are we
1504:37 - trying to do? We're trying to get our model to predict on the same type of data it was trained on.
1504:42 - So let's go custom image transform is transforms dot compose. And we're just going to, since our
1504:51 - image is already of a tensor, let's do transforms dot resize, and we'll set the size to the same shape
1504:59 - that our model was trained on, or the same size that is. So let's go from torch vision. We don't
1505:06 - have to rewrite this. It's already imported. But I just want to highlight that we're using the
1505:10 - transforms package. We'll run that. There we go. We've got a transform pipeline. Now let's see what
1505:18 - happens when we transform our target image, transform target image. What happens? Custom image
1505:25 - transformed. I love printing the inputs and outputs of our different pipelines here. So let's pass
1505:32 - our custom image that we've just imported. So custom image transform, our custom image is recall
1505:39 - of shape. Quite large. We're going to pass it through our transformation pipeline. And let's
1505:48 - print out the shapes. Let's go original shape. And then we'll go custom image dot shape. And then
1505:58 - we'll go print transformed shape is going to be custom image underscore transformed dot shape.
1506:11 - Let's see the transformation. Oh, would you look at that? How good we've gone from quite a large image
1506:18 - to a transformed image here. So it's going to be squished and squashed a little. So that's what
1506:24 - happens. Let's see what happens when we plot our transformed image. We've gone from 4000 pixels
1506:30 - on the height to 64. And we've gone from 3000 pixels on the height to 64. So this is what our
1506:36 - model is going to see. Let's go custom image transformed. And we're going to permute it to be 120.
1506:47 - Okay, so quite pixelated. Do you see how this might affect the accuracy of our model?
1506:52 - Because we've gone from custom image, is this going to, oh, yeah, we need to plot dot image.
1506:58 - So we've gone from this high definition image to an image that's of far lower quality here.
1507:06 - And I can kind of see myself that this is still a pizza, but I know that it's a pizza. So just
1507:11 - keep this in mind going forward is that another way that we could potentially improve our model's
1507:15 - performance if we increased the size of the training image data. So instead of 64 64, we might want
1507:23 - to upgrade our models capability to deal with images that are of 224 224. So if we have a look
1507:30 - at what this looks like 224 224. Wow, that looks a lot better than 64 64. So that's something that
1507:40 - you might want to try out later on. But we're going to stick in line with the CNN explainer model.
1507:47 - How about we try to make another prediction? So since we transformed our
1507:53 - image to be the same size as the data our model was trained on. So with torch inference mode,
1508:00 - let's go custom image pred equals model one on custom image underscore transformed.
1508:08 - Does it work now? Oh my goodness, still not working expected all tensors on the same device. Of course,
1508:15 - that's what we forgot here. Let's go to device. Or actually, let's leave that error there. And
1508:21 - we'll just copy this code down here. And let's put this custom image transform back on the right
1508:27 - device and see if we finally get a prediction to happen with our model. Oh, we still get an error.
1508:35 - Oh my goodness, what's going on here? Oh, we need to add a batch size to it. So I'm just gonna write
1508:42 - up here. This will error. No batch size. And this will error. Image not on right device. And then
1509:00 - let's try again, we need to add a batch size to our image. So if we look at custom image transformed
1509:08 - dot shape, recall that our images that passed through our model had a batch dimension. So this
1509:16 - is another place where we get shape mismatch issues is if our model, because what's going on
1509:22 - in neural network is a lot of tensor manipulation. If the dimensions don't line up, we want to perform
1509:28 - matrix multiplication and the rules. If we don't play to the rules, the matrix multiplication will
1509:33 - fail. So let's fix this by adding a batch dimension. So we can do this by going a custom image transformed.
1509:43 - Let's unsqueeze it on the first dimension and then check the shape. There we go. We add a single batch.
1509:50 - So that's what we want to do when we make a prediction on a single custom image. We want to pass it to
1509:54 - our model as an image or a batch of one sample. So let's finally see if this will work.
1510:03 - Let's just not comment what we'll do. This, or maybe we'll try anyway, this should work.
1510:11 - Added a batch size. So do you see the steps we've been through so far? And we're just going to
1510:17 - unsqueeze this. Unsqueeze on the zero dimension to add a batch size. Oh, it didn't error. Oh my
1510:26 - goodness. It didn't error. Have a look at that. Yes, that's what we want. We get a prediction
1510:32 - load it because the raw outputs of our model, we get a load it value for each of our custom classes.
1510:39 - So this could be pizza. This could be steak. And this could be sushi, depending on the order of
1510:44 - our classes. Let's just have a look. Class to IDX. Did we not get that? Class names.
1510:56 - Beautiful. So pizza steak sushi. We've still got a ways to go to convert this into that.
1511:01 - But I just want to highlight what we've done. So note, to make a prediction on a custom image,
1511:08 - we had to. And this is something you'll have to keep in mind for almost all of your custom data.
1511:16 - It needs to be formatted in the same way that your model was trained on. So we had to load the image
1511:22 - and turn it into a tensor. We had to make sure the image was the same data type as the model.
1511:35 - So that was torch float 32. And then we had to make sure the image was the same shape as the data
1511:43 - the model was trained on, which was 64, 64, three with a batch size. So that was one,
1511:54 - three, 64, 64. And excuse me, this should actually be the other way around. This should be color
1512:02 - channels first, because we're dealing with pie torch here. 64. And then finally, we had to make
1512:09 - sure the image was on the same device as our model. So they are three of the big ones that we've
1512:21 - talked about so much the same data type or data type mismatch will result in a bunch of issues.
1512:26 - Shape mismatch will result in a bunch of issues. And device mismatch will also result in a bunch
1512:33 - of issues. If you want these to be highlighted, they are in the learn pie torch.io resource. We have
1512:41 - putting things together. Where do we have it? Oh, yeah, no, it's in the main takeaway section,
1512:48 - sorry, predicting on your own custom data with a trained model as possible, as long as you format
1512:53 - the data into a similar format to what the model was trained on. So make sure you take care of the
1512:58 - three big pie torch and deep learning errors. Wrong data types, wrong data shapes, and wrong
1513:03 - devices, regardless of whether that's images or audio or text, these three will follow you around.
1513:10 - So just keep them in mind. But now we've got some code to predict on custom images, but it's kind
1513:17 - of all over the place. We've got about 10 coding cells here just to make a prediction on a custom
1513:22 - image. How about we functionize this and see if it works on our pizza dad image. I'll see you in the
1513:29 - next video. Welcome back. We're now well on our way to making custom predictions on our own custom
1513:38 - image data. Let's keep pushing forward. In the last video, we finished off getting some raw model
1513:44 - logits. So the raw outputs from our model. Now, let's see how we can convert these logits into
1513:50 - prediction labels. Let's write some code. So convert logits to prediction labels. Or let's go
1514:00 - convert logits. Let's first convert them to prediction probabilities. Probabilities.
1514:07 - So how do we do that? Let's go custom image pred probes equals torch dot softmax
1514:14 - to convert our custom image pred across the first dimension. So the first dimension of this tensor
1514:22 - will be the inner brackets, of course. So just this little section here. Let's see what these
1514:28 - look like. This will be prediction probabilities. Wonderful. So you'll notice that these are quite
1514:36 - spread out. Now, this is not ideal. Ideally, we'd like our model to assign a fairly large
1514:42 - prediction probability to the target class, the right target class that is. However, since our model
1514:49 - when we trained it isn't actually performing that all that well. The prediction probabilities
1514:53 - are quite spread out across all of the classes. But nonetheless, we're just highlighting what
1514:58 - it's like to predict on custom data. So now let's convert the prediction probabilities
1515:03 - to prediction labels. Now, you'll notice that we used softmax because why we are working with
1515:12 - multi class classification data. And so we can get the custom image pred labels, the integers,
1515:20 - by taking the argmax of the prediction probabilities, custom image pred probes across the first
1515:28 - dimension as well. So let's go custom image pred labels. Let's see what they look like.
1515:35 - Zero. So the index here with the highest value is index number zero. And you'll notice that it's
1515:42 - still on the coded device. So what would happen if we try to index on our class names with
1515:49 - the custom image pred labels? Or maybe that doesn't need to be a plural. Oh, there we go. We get pizza.
1516:00 - But you might also have to change this to the CPU later on. Otherwise, you might run into some
1516:06 - errors. So just be aware of that. So you notice how we just put it to the CPU. So we get pizza. We
1516:11 - got a correct prediction. But this is as good as guessing in my opinion, because these are kind
1516:16 - of spread out. Ideally, this value would be higher, maybe something like 0.8 or above for our pizza
1516:22 - dad image. But nonetheless, our model is getting two thumbs up even on this 64 by 64 image. But
1516:31 - that's a lot of code that we've written. Let's functionize it. So we can just pass in a file path
1516:37 - and get a custom prediction from it. So putting custom image prediction together.
1516:42 - Let's go building a function. So we want the ideal outcome is, let's plot our image as well.
1516:52 - Ideal outcome is a function where we plot or where we pass an image path to and have our model predict
1517:08 - on that image and plot the image plus the prediction. So this is our ideal outcome. And I think I'm
1517:17 - going to issue this as a challenge. So give that a go, put all of our code above together. And you'll
1517:24 - just have to import the image, you'll have to process it and whatnot. I know I said we were going
1517:27 - to build a function in this video, but we're going to say that to the next video. I'd like
1517:31 - you to give that a go. So start from way back up here, import the image via torture vision.io read
1517:39 - image, format it using what we've done, change the data type, change the shape, change the device,
1517:46 - and then plot the image with its prediction as the title. So give that a go and we'll do it
1517:54 - together in the next video. How'd you go? I just realized I had a typo in the previous cell,
1518:02 - but that's all right. Did you give it a shot? Did you put together the custom image prediction
1518:07 - in a function format? I'd love it if you did. But if not, that's okay. Let's keep going. Let's see
1518:13 - what that might look like. And there are many different ways that you could do this. But
1518:17 - here's one of the ways that I've thought of. So we want to function that's going to
1518:21 - pred and plot a target image. We wanted to take in a torch model. And so that's going to be ideally
1518:28 - a trained model. We wanted to also take in an image path, which will be of a string. It can
1518:33 - take in a class names list so that we can index it and get the prediction label in string format.
1518:41 - So let's put this as a list of strings. And by default, this can equal none. Just in case we
1518:46 - just wanted the prediction, it wants to take in a transform so that we can pass it in some form of
1518:52 - transform to transform the image. And then it's going to take in a device, which will be by default
1518:58 - the target device. So let's write a little doc string here, makes a prediction on a target image
1519:05 - with a trained model and plots the image and prediction. Beautiful. Now what do we have to do
1519:17 - first? Let's load in the image. Load in the image just like we did before with torch vision. So
1519:25 - target image equals torch vision.io dot read image. And we'll go string on the image path,
1519:34 - which will be the image path here. And we convert it to a string just in case it doesn't get passed
1519:40 - in as a string. And then let's change it into type torch float 32. Because we want to make sure that
1519:49 - our custom image or our custom data is in the same type as what we trained our model on. So now
1519:57 - let's divide the image pixel values by 255 to get them between zero or to get them between zero
1520:10 - one as a range. So we can just do this by target image equals target image divided by 255. And we
1520:17 - could also just do this in one step up here 255. But I've just put it out there just to let you know
1520:22 - that, hey, read image imports image data as between zero and 255. So our model prefers numbers
1520:30 - between zero and one. So let's just scale it there. Now we want to transform our data if necessary.
1520:37 - In our case, it is, but it won't always be. So we want this function to be pretty generic
1520:43 - predomplot image. So if the transform exists, let's set the target image to the transform,
1520:51 - or we'll pass it through the transform that is wonderful. And the transform we're going to get
1520:56 - from here. Now what's left to do? Well, let's make sure the model is on the target device.
1521:05 - It might be by default, but if we're passing in a device parameter, we may as well make sure the
1521:10 - model is there too. And now we can make a prediction. So let's turn on a vowel slash inference mode
1521:18 - and make a prediction with our model. So model, we call a vowel mode, and then with torch dot
1521:25 - inference mode, because we're making a prediction, we want to turn our model into inference mode,
1521:30 - or put it in inference mode context. Let's add an extra dimension to the image. Let's go target
1521:39 - image. We could do this step above, actually, but we're just going to do it here. From kind of
1521:43 - remembering things on the fly here of what we need to do, we're adding a, this is, let's write
1521:49 - this down, this is the batch dimension. e g our model will predict on batches of one x image.
1522:00 - So we're just unsqueezing it to add an extra dimension at the zero dimension space,
1522:05 - just like we did in a previous video. Now let's make a prediction
1522:09 - on the image with an extra dimension. Otherwise, if we don't have that extra dimension, we saw
1522:16 - that we get a shape issue. So right down here, target image pred. And remember, this is going
1522:21 - to be the raw model outputs, raw logit outputs. We're going to target image pred. And yeah,
1522:30 - I believe that's all we need for the prediction. Oh wait, there was one more thing, two device.
1522:35 - Me too. Also make sure the target image is on the right device. Beautiful. So fair
1522:44 - few steps here, but nothing we can't handle. All we're really doing is replicating what we've done
1522:49 - for batches of images. But we want to make sure that if someone passed any image to our
1522:55 - pred and plot image function, that we've got functionality in here to handle that image.
1523:00 - And do we get this? Oh, we want just target image to device. Did you catch that error?
1523:06 - So let's keep going. Now let's convert the logits. Our models raw logits. Let's convert those
1523:16 - to prediction probabilities. This is so exciting. We're getting so close to making a function
1523:22 - to predict on custom data. So we'll set this to target image pred probes, which is going to be
1523:27 - torch dot softmax. And we will pass in the target image pred here. We want to get the softmax of
1523:33 - the first dimension. Now let's convert our prediction probabilities, which is what we get in the line
1523:39 - above. We want to convert those to prediction labels. So let's get the target image pred labels
1523:49 - labels equals torch dot argmax. We want to get the argmax of, or in other words, the index,
1523:56 - which is the maximum value from the pred probes of the first dimension as well. Now what should we
1524:03 - return here? Well, we don't really need to return anything. We want to create a plot. So let's plot
1524:09 - the image alongside the prediction and prediction probability. Beautiful. So plot dot in show,
1524:21 - what are we going to pass in here? We're going to pass in here our target image. Now we have to
1524:27 - squeeze this, I believe, because we've added an extra dimension up here. So we'll squeeze it to
1524:33 - remove that batch size. And then we still have to permute it because map plot lib likes images
1524:40 - in the format color channels last one, two, zero. So remove batch dimension.
1524:50 - And rearrange shape to be hc hwc. That is color channels last. Now if the class names parameter
1524:59 - exists, so we've passed in a list of class names, this function is really just replicating
1525:05 - everything we've done in the past 10 cells, by the way. So right back up here, we're replicating
1525:11 - all of this stuff in one function. So pretty large function, but once we've written it,
1525:15 - we can pass in our images as much as we like. So if class names exist, let's set the title
1525:22 - to our showcase that class name. So the pred is going to be class names. Let's index on that
1525:29 - pred image, or target image pred label. And this is where we'll have to put it to the CPU,
1525:36 - because if we're using a title with map plot lib, map plot lib cannot handle things that are on
1525:42 - the GPU. This is why we have to put it to the CPU. And then I believe that should be enough for
1525:48 - that. Let's add a little line in here, so that we can have it. Oh, I've missed something.
1525:56 - An outside bracket there. Wonderful. Let's add the prediction probability, because that's always
1526:03 - fun to see. So we want target image pred probs. And we want to get the maximum pred problem from
1526:09 - that. And we'll also put that on the CPU. And I think we might get this three decimal places.
1526:16 - Now this is saying, oh, pred labels, we don't need that. We need just non plural, beautiful. Now,
1526:24 - if the class names doesn't exist, let's just set the title equal to f f string, we'll go pred,
1526:34 - target image pred label. Is Google Colab still telling me this is wrong?
1526:39 - Target image pred label. Oh, no, we've still got the same thing. It just hasn't caught up with me,
1526:45 - and I'm coding a bit fast here. And then we'll pass in the prob, which will be just the same as
1526:51 - above. I could even copy this in. Beautiful. And let's now set the title to the title. And we
1527:03 - and we will turn the axes off. PLT axes false. Fair bit of code there. But this is going to be a
1527:11 - super exciting moment. Let's see what this looks like. When we pass it in a target image and a
1527:16 - target model, some class names, and a transform. Are you ready? We've got our transform ready,
1527:23 - by the way, it's back up here. Custom image transform. It's just going to resize our image.
1527:29 - So let's see. Oh, this file was updated remotely or in another tab. Sometimes this happens, and
1527:36 - usually Google Colab sorts itself out, but that's all right. It doesn't affect our code for now.
1527:39 - Pred on our custom image. Are you ready? Save failed. Would you like to override? Yes, I would.
1527:47 - So you might see that in Google Colab. Usually it fixes itself. There we go. Save successfully.
1527:52 - Pred and plot image. I was going to say, Google Colab, don't fail me now. We're about to predict
1527:58 - on our own custom data. Using a model trained on our own custom data. Image part. Let's pass in
1528:07 - custom image path, which is going to be the path to our pizza dad image. Let's go class names,
1528:13 - equals class names, which is pizza, steak, and sushi. We'll pass in our transform to convert our
1528:19 - image to the right shape and size custom image transform. And then finally, the target device is
1528:28 - going to be device. Are you ready? Let's make a prediction on custom data. One of my favorite
1528:33 - things. One of the most fun things to do when building deep learning models. Three, two, one.
1528:38 - How did it go? Oh, no. What did we get wrong? CPU. Okay. Such a so close, but yet so far.
1528:50 - Has no attribute CPU. Oh, maybe we need to put this to CPU. That's where I got the square bracket
1528:57 - wrong. So that's what we needed to change. We needed to because this is going to be potentially
1529:03 - on the GPU. Tag image pred label. We need to put it on the CPU. We need to do that. Why?
1529:09 - Because this is going to be the title of our map plot lib plot. And map plot lib doesn't interface
1529:14 - too well with data on a GPU. Let's try it again. Three, two, one, running. Oh, look at that.
1529:25 - Prediction on a custom image. And it gets it right. Two thumbs up. I didn't plan this. Our model is
1529:30 - performing actually quite poorly. So this is as good as a guess to me. You might want to try this
1529:36 - on your own image. And in fact, if you do, please share it with me. I would love to see it. But
1529:41 - you could potentially try this with another model. See what happens? Steak. Okay, there we go. So
1529:47 - even though model one performs worse quantitatively, it performs better qualitatively. So that's the
1529:55 - power of a visualize, visualize, visualize. And if we use model zero, also, which isn't performing
1530:01 - too well, it gets it wrong with a prediction probability of 0.368, which isn't too high either.
1530:09 - So we've talked about a couple of different ways to improve our models. Now we've even
1530:13 - got a way to make predictions on our own custom images. So give that a shot. I'd love to see
1530:19 - your custom predictions, upload an image here if you want, or download it into Google Colab using
1530:25 - code that we've used before. But we've come a fairly long way. I feel like we've covered enough
1530:32 - for custom data sets. Let's summarize what we've covered in the next video. And I've got a bunch
1530:38 - of exercises and extra curriculum for you. So this is exciting stuff. I'll see you in the next video.
1530:47 - In the last video, we did the very exciting thing of making a prediction on our own custom
1530:52 - image, although it's quite pixelated. And although our models performance quantitatively didn't
1530:57 - turn out to be too good qualitatively, it happened to work out. But of course, there are a fair few
1531:03 - ways that we could improve our models performance. But the main takeaway here is that we had to do
1531:08 - a bunch of pre processing to make sure our custom image was in the same format as what our model
1531:16 - expected. And this is quite a lot of what I do behind the scenes for Nutrify. If you upload an
1531:21 - image here, it gets pre processed in a similar way to go through our image classification model
1531:27 - to output a label like this. So let's get out of this. To summarize, I've got a colorful slide here,
1531:34 - but we've already covered this predicting on custom data. These are three things to make sure of,
1531:40 - regardless of whether you're using images, text or audio, make sure your data is in the right
1531:46 - data type. In our case, it was torch float 32. Make sure your data is on the same device as the model.
1531:53 - So we had to put our custom image to the GPU, which was where our model also lived. And then we had
1531:59 - to make sure our data was in the correct shape. So the original shape was 64, 64, 3. Actually,
1532:05 - this should be reversed, because it was color channels first. But the same principle remains here.
1532:10 - We had to add a batch dimension and rearrange if we needed. So in our case, we used images of this
1532:17 - shape batches first color channels first height width. But depending on your problem will depend
1532:24 - on your shape, depending on the device you're using will depend on where your data and your
1532:29 - model lives. And depending on the data type you're using will depend on what you're using for torch
1532:34 - float 32 or something else. So let's summarize. If we go here main takeaways, you can read through
1532:43 - these, but some of the big ones are pie torch has many built in functions to deal with all kinds
1532:49 - of data from vision to text to audio to recommendation systems. So if we look at the pie torch docs,
1532:57 - you're going to become very familiar with these over time. We've got torch audio data,
1533:01 - torch text, torch vision is what we practiced with. And we've got a whole bunch of things here for
1533:06 - transforming and augmenting images, data sets, utilities, operators, and torch data is currently
1533:13 - in beta. But this is just something to be aware of later on. So it's a prototype library right now,
1533:19 - but by the time you watch this, it might be available. But it's another way of loading data.
1533:24 - So just be aware of this for later on. And if we come back to up here, if applied to watch built
1533:31 - in data loading functions, don't suit your requirements, you can write your own custom
1533:36 - data set classes by subclassing torch dot utils dot data dot data set. And we saw that way back
1533:42 - up here in option number two. Option two, here we go, loading image data with a custom data set,
1533:50 - wrote plenty of code to do that. And then a lot of machine learning is dealing with the
1533:56 - balance between overfitting and underfitting. We've got a whole section in the book here to
1534:00 - check out what an ideal loss curve should look like and how to deal with overfitting,
1534:04 - how to deal with underfitting. It's it is a fine line. So much of the research and machine
1534:09 - learning is actually dedicated towards this balance. And then three big things for being aware of
1534:16 - when you're predicting on your own custom data, wrong data types, wrong data shapes,
1534:21 - and wrong devices. This will follow you around, as I said, and we saw that in practice to get our
1534:27 - own custom image ready for a trained model. Now, we have some exercises here. If you'd like
1534:32 - the link to it, you can go to loan pytorch.io section number four exercises, and of course,
1534:38 - extra curriculum. A lot of the things I've mentioned throughout the course that would be a good
1534:41 - resource to check out contained in here. But the exercises, this is this is your time to shine,
1534:47 - your time to practice. Let's go back to this notebook, scroll right down to the bottom.
1534:52 - Look how much code we've written. Goodness me, exercises for all exercises and extra curriculum.
1535:02 - See here, turn that into markdown. Wonderful. And so if we go in here, you've got a couple of
1535:08 - resources. There's an exercise template notebook for number four, and example solutions for notebook
1535:15 - number four, which is what we're working on now. So of course, I'd encourage you to go through the
1535:21 - pytorch custom data sets exercises template first. Try to fill out all of the code here on your own.
1535:27 - So we've got some questions here. We've got some dummy code. We've got some comments.
1535:32 - So give that a go. Go through this. Use this book resource to reference. Use all the code
1535:38 - we've written. Use the documentation, whatever you want. But try to go through this on your own.
1535:43 - And then if you get stuck somewhere, you can look at an example solution that I created,
1535:47 - which is here, pytorch custom data sets exercise solutions. And just be aware that this is just
1535:53 - one way of doing things. It's not necessarily the best. It's just a way to reference what
1535:57 - you're writing to what I would do. And there's actually now live walkthroughs of the solutions,
1536:03 - errors and all on YouTube. So if you go to this video, which is going to mute. So this is me
1536:08 - live streaming the whole thing, writing a bunch of pytorch code. If you just keep going through all
1536:13 - of that, you'll see me writing all of the solutions, running into errors, trying different things,
1536:19 - et cetera, et cetera. But that's on YouTube. You can check that out on your own time. But I feel
1536:25 - like we've covered enough exercises. Oh, by the way, this is in the extras exercises tab
1536:32 - of the pytorch deep learning repo. So extras exercises and solutions that are contained in there.
1536:39 - Far out. We've covered a lot. Look at all that. So that has been pytorch custom data sets.
1536:46 - I will see you in the next section. Holy smokes. That was a lot of pytorch code.
1536:56 - But if you're still hungry for more, there is five more chapters available at learnpytorch.io,
1537:01 - which cover transfer learning, my favorite topic, pytorch model experiment tracking,
1537:06 - pytorch paper replicating, and pytorch model deployment. How do you get your model into the
1537:11 - hands of others? And if you'd like to learn in this video style, the videos for those chapters
1537:17 - are available at zero to mastery.io. But otherwise, happy machine learning. And I'll see you next time.