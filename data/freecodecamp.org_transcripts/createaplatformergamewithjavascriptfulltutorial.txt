00:00 - hey guys my name is frank i'm starting a
00:02 - series on how to program a tile-based
00:03 - platforming game called rabbit trap it
00:05 - will feature tile-based collision
00:06 - detection and response scrolling maps
00:09 - loading levels sprite animation and
00:11 - interactive game objects in this first
00:13 - part of the series i'll be talking about
00:15 - how to build a strong foundation for the
00:16 - game the concepts i'm going to explain
00:19 - are strongly rooted in object-oriented
00:20 - programming and can be used in any
00:22 - program to improve organization and
00:24 - modularity this might seem boring but if
00:26 - you use this approach it can save you
00:28 - hours of editing and frustration and
00:30 - leave you more time to focus on fun
00:31 - stuff like level design and graphics so
00:33 - be sure to watch this video
00:40 - in this video i'm going to talk about
00:42 - the model view controller approach to
00:44 - organizing a program and how the
00:45 - different components of this example
00:47 - work together in the main js file
00:50 - then i'm going to talk about how this
00:51 - structure increases maintainability and
00:53 - modularity as always feel free to use
00:56 - the comments section and be sure to
00:57 - check out the links to the source code
00:58 - and working example in the video
01:00 - description and if you learned something
01:02 - give this video a like
01:06 - so basically what i have here is just an
01:09 - example of a model view controller
01:11 - architecture where you separate out your
01:13 - game logic from your display logic and
01:16 - you also separate out your controller
01:18 - logic so i have my game logic stored in
01:20 - the game class the display logic in the
01:22 - display class and the controller logic
01:24 - in the controller class
01:26 - and each one of these handles its own
01:28 - business and it's totally separate from
01:30 - the other so i'm not going to run into
01:32 - any issues with having
01:34 - references to the game logic inside of
01:36 - the display i'm not going to have the
01:38 - controller logic referenced inside of
01:40 - the game i'm going to have all these
01:42 - different components interact with each
01:43 - other through their public methods
01:45 - inside of the main js file context
01:50 - and by the way each one of these classes
01:51 - is defined in its own individual file
01:54 - you don't need to have your own
01:55 - individual files but it makes it a lot
01:57 - easier to just
01:58 - use these different things in other
02:00 - applications if i choose to for example
02:02 - the engine i might want to use this
02:04 - fixed time step engine inside of another
02:07 - application at some point so it's nice
02:08 - to just store it in its own file but
02:10 - anyway what all this code does
02:13 - for this example is basically the game
02:16 - class controls color value
02:19 - right here that's the color
02:21 - variable from the game class basically
02:23 - it just increments the different red
02:26 - green and blue channels inside of a
02:27 - color value to change these different
02:30 - colors that you're seeing on the screen
02:32 - and then it will talk to the display
02:34 - class which governs things like the
02:36 - canvas and resizing the canvas when the
02:38 - screen resizes and rendering and the
02:41 - game will hand a color value to the
02:44 - display and the display will render it
02:46 - on every frame
02:48 - and the engine takes care of frames as
02:50 - for the controller i didn't really have
02:52 - anything cool to do with the controller
02:53 - for this example so all it does is take
02:55 - user input from the keyboard and tell
02:57 - the user which key
02:59 - he or she pressed so for example i just
03:01 - press the a key that's key 65.
03:04 - so
03:05 - basically what i'm trying to say is i
03:07 - want to keep things as organized as
03:09 - possible for this rabbit trap game and i
03:11 - want you guys to kind of think about
03:14 - organization of code before you start
03:16 - developing a game because if you just
03:18 - jump into things and try to mesh all
03:20 - this together in one big file with
03:22 - references going between different
03:25 - components
03:26 - it's going to get very messy very fast
03:28 - and here's an example of that that i
03:29 - want to show you so i define all my
03:31 - components i define my engine it's going
03:33 - to run at 30 frames per second
03:35 - and i'm handing in the render and update
03:37 - function down at the bottom of my
03:39 - main.js file i'm going to start my
03:41 - engine and that's going to execute the
03:43 - render and update function 30 times per
03:45 - second until i stop my game engine
03:49 - so the render and update functions i
03:51 - define up here and these are them right
03:54 - here so the update function is just
03:56 - going to tell the game
03:57 - to change that color value and that's
03:59 - what the update function of the game
04:00 - does just increments this color value in
04:02 - a random direction gradually to change
04:05 - the color
04:06 - now the render function is also going to
04:08 - be called on every frame of my game loop
04:11 - and inside i'm actually going to be
04:12 - communicating the game's color value
04:16 - to the display and i'm going to have the
04:18 - display object draw that color value to
04:21 - the on-screen canvas
04:23 - so here is a great example of why this
04:25 - is so good
04:26 - so i could just as easily write object
04:29 - literals to govern my display logic and
04:31 - my game logic and you've seen that if
04:33 - you've you've watched my other tutorials
04:35 - i'm kind of sloppy i just throw stuff
04:37 - together with object literals here i'm
04:39 - not doing that if i had written object
04:42 - literals i could put a reference to
04:43 - game.color directly inside of the
04:46 - display's render color function or
04:49 - better yet i probably wouldn't have even
04:51 - had a render color function i would just
04:52 - have a render method that handled
04:54 - rendering the entire thing the reason i
04:56 - have two here is because render color
04:58 - draws a color to a buffer canvas and
05:00 - then display.render
05:02 - renders that buffer canvas to the final
05:04 - on-screen canvas that you see so the old
05:07 - version of how i wrote my code
05:09 - or just the sloppy way that i write my
05:10 - code would just be to put two object
05:12 - literals on the
05:14 - main js file and one would be display
05:16 - one would be game and i would have a
05:18 - reference to game.color inside of my
05:20 - render function and display would just
05:23 - draw that color
05:24 - directly to the canvas
05:26 - now the reason this is bad is because
05:28 - say i want to change the name of my
05:30 - color variable to hue
05:33 - if i go ahead and i have a reference to
05:35 - game.color inside of my display
05:37 - and i change the variable color to hue
05:40 - inside of my game object now all of a
05:42 - sudden i'm editing my game
05:44 - class or my game object to change that
05:47 - value to hue
05:48 - and i have to go into my display object
05:51 - and change all the references to
05:52 - game.color to game.hue
05:55 - now that's a pain i don't want to have
05:57 - to do that and it's unnecessary so i
05:59 - don't see why i do it anyway
06:01 - with this method the mvc approach you
06:04 - don't actually have to
06:06 - have any internal references to any
06:08 - other components the display only has
06:11 - references to itself inside of itself
06:14 - the game only has references to things
06:16 - that it controls
06:18 - so how do they communicate they
06:20 - communicate just like this they
06:22 - communicate through public methods so
06:24 - display can only communicate with other
06:27 - objects like game and controller through
06:30 - public methods that it has so if i come
06:32 - into the display object here and i take
06:34 - a look at render color you can see that
06:36 - just takes a color value and inside of
06:38 - it it does exactly what i said it just
06:40 - changes the buffer's fill style to the
06:42 - specified color and draws that color to
06:45 - the buffer canvas and then here's the
06:47 - render function and all this is going to
06:49 - do is draw
06:50 - the buffer canvas to the final display
06:53 - canvas
06:54 - i'm not going to get too much into
06:55 - detail on that but you get what's going
06:57 - on here now i could have just as easily
07:01 - gone like this inside of this function
07:03 - and said
07:04 - game.color had i made these object
07:07 - literals instead of classes
07:09 - but that's actually really bad practice
07:11 - because like i said if i change
07:12 - something inside a game it might break
07:15 - my display
07:16 - object and prevent it from working so
07:18 - that's twice the editing that i'm going
07:19 - to have to do because i'm going to have
07:20 - to change all the values in display as
07:23 - well as all the values in game
07:26 - so this is just a much cleaner way of
07:27 - doing things
07:30 - so basically this is how you want your
07:31 - different components to interact and
07:34 - just take a look at this main js file
07:37 - it's really short everything is super
07:39 - clean i just have my two
07:41 - functions here render and update that i
07:43 - hand into my
07:44 - game engine
07:45 - and here i'm defining everything this is
07:48 - super clean i don't have huge object
07:50 - literals to take care of just sprawling
07:52 - out across my my screen here in my
07:54 - editor and to instantiate everything
07:57 - it's real simple i just add my event
07:58 - listeners for the screen resize and the
08:01 - the keyboard inputs and i just resize my
08:04 - screen initially so my canvas fits the
08:06 - screen when i start up and i start my
08:08 - engine and everything runs the way i
08:10 - expect it to
08:11 - so using the mvc approach or just
08:14 - separating out the different components
08:15 - of your game into logical groups is a
08:17 - really great way to keep your code
08:19 - maintainable and modular and i'm going
08:21 - to get into why in the next part of this
08:23 - video
08:27 - so now i want to talk about how this
08:28 - approach makes things more modular and
08:31 - more easy to maintain so
08:33 - obviously right off the bat it's a lot
08:35 - more organized you can see that clearly
08:37 - i have my different
08:38 - components reference here and
08:40 - instantiated here in one single line
08:43 - each rather than having big sprawling
08:45 - object literals defined and by
08:47 - separating these things out into their
08:49 - own classes i have the option of putting
08:51 - them into their own files which makes
08:53 - things even more organized because i
08:55 - could have all of these different
08:57 - classes
08:58 - right on top of each other in one big
09:00 - file
09:01 - or i could separate them like i did into
09:03 - their own files and now if i want to
09:05 - edit the game logic i only have to deal
09:08 - with
09:09 - 42 lines of code apparently instead of
09:11 - having to search through one big file so
09:13 - that's obviously one way that this
09:15 - technique lends itself to easy
09:17 - maintainability then there's the other
09:19 - thing i mentioned where you don't have
09:20 - internal references to one component
09:23 - inside of another component and like i
09:26 - said then
09:27 - it's a lot easier to just work with
09:30 - public methods
09:31 - and have your components communicate via
09:33 - public methods kind of like is happening
09:36 - right here in the render function
09:38 - display is interacting with game through
09:40 - a public method called render color
09:42 - rather than having an internal reference
09:44 - to game.color which would be a lot
09:47 - harder to maintain because if i change
09:48 - game.color in the game object i'm going
09:51 - to have to go through display and edit
09:52 - all of those references to game.color so
09:55 - this is another way it lends itself to
09:57 - maintainability now what about
09:59 - modularity
10:00 - okay well i've got a
10:02 - engine class down here which is
10:04 - basically a fixed time step engine
10:07 - now i can use this engine in any
10:09 - application that i want to and it's very
10:11 - easy for me to do that because this is a
10:13 - totally self-contained class that i
10:16 - store in its own file now i don't have
10:18 - to store it in its own file but by
10:19 - storing it in its own file i can very
10:21 - easily just
10:23 - reference that single file in another
10:25 - application and then all of a sudden bam
10:27 - i have a perfectly good game engine for
10:31 - a whole nother game and i didn't even
10:33 - have to write code for it i already had
10:35 - it on hand
10:36 - but if i were to have that game engine
10:38 - integrated into all my other components
10:41 - it would be a lot harder for me to
10:43 - extract the the engine components from
10:46 - say the game logic and that just isn't
10:49 - very modular the way i have it set up
10:51 - now is very very modular and it will
10:53 - save me a lot of time in the future when
10:55 - i need a game engine object so
10:58 - sometimes i write my code this way for
11:00 - most of my tutorials i just throw stuff
11:01 - together in one file because i want
11:04 - everything to be there for you guys to
11:05 - see
11:06 - up front i don't want to have to bring
11:08 - things in from other applications but
11:10 - this is how i would go about writing a
11:13 - more structured application and that's
11:14 - what i'm trying to do i'm trying to
11:16 - write this game rabbit trap and i just
11:18 - want it to be very structured and i want
11:20 - everything to go smoothly so using the
11:22 - mvc approach and separating my game
11:25 - logic from my display logic and my
11:27 - controller logic is just going to make
11:29 - everything go super smooth throughout
11:31 - this whole process so anyway i hope this
11:34 - has been a good explanation of how
11:37 - everything is going to be for this
11:38 - rabbit trap thing and i hope you guys
11:40 - are interested in what's going to come
11:41 - because i expect it to be a really cool
11:43 - game
11:44 - before i wrap things up i want to talk
11:46 - about my html for this
11:49 - example so i actually am going to do a
11:51 - whole bunch of parts in this series and
11:54 - rather than having to upload the sprite
11:57 - sheet for this example a thousand times
11:59 - to my github page or however many parts
12:01 - i have i don't want to upload this
12:02 - multiple times my github page because i
12:04 - don't want to waste memory space so i'm
12:07 - just going to use the same
12:09 - graphics i'm going to use the same html
12:11 - file in css file and i'm just going to
12:14 - write new javascript files as need be so
12:17 - that's going to keep the memory
12:19 - footprint on my github page a little bit
12:20 - smaller for this whole
12:22 - series that i'm doing so anyway the way
12:24 - i'm going about that is inside of my
12:27 - html i'm dynamically
12:30 - determining which
12:32 - javascript files to load based on a url
12:36 - variable specifying the part number so
12:38 - when i come into my
12:41 - actual html page here
12:44 - and i look at my url to the
12:46 - rabbittrap.html file at the end of it
12:49 - there is a question mark and a one which
12:52 - is the part number for this example now
12:54 - if i wanted to get to part two i would
12:56 - just come in and type two
12:58 - i haven't actually made typed or part
13:00 - two yet
13:01 - but
13:03 - that's how you would access part two so
13:06 - i'm accessing these different parts with
13:09 - a url variable that is just the part
13:13 - and i have a default to where if you
13:15 - don't specify anything
13:17 - it just brings you to part one so that's
13:21 - what i'm doing and this big chunk of
13:23 - code in the middle the middle of my html
13:26 - file is taking care of that for me so it
13:28 - just it defines all the sources i'm
13:30 - gonna use and that's just these files
13:33 - here it gets the
13:35 - url variable or that part number from my
13:37 - url that 01 after the question mark and
13:41 - then it goes ahead it checks to see if
13:43 - it's a viable part
13:45 - if there is no part specified it just
13:47 - sets it to part one and then it just
13:49 - loops through and adds a script tag for
13:51 - every single javascript file
13:54 - in the
13:56 - application so i'm always going to have
13:57 - controller display engine game main and
14:00 - manifesto is just my script for the
14:01 - video
14:02 - and i'm just going to add a new script
14:04 - for each one of those and i'm going to
14:06 - edit i'm going to parse together the
14:10 - url or the source attribute
14:12 - to match whichever part i'm in
14:15 - so hopefully that was a good explanation
14:16 - of how i'm actually getting these things
14:19 - in and if you had any questions about
14:21 - why my html was weird like this
14:23 - that's the reason i'm just trying to
14:25 - save memory space on my github page so
14:27 - being cheap but i kind of figured out
14:30 - this cool little script to just import
14:33 - uh javascript files based on what part
14:35 - i'm in so anyway that is an explanation
14:37 - of that
14:39 - this part is going to be on adding a
14:40 - player object to the screen and
14:42 - controlling him with the keyboard this
14:44 - is a vital component of any game so stay
14:46 - tuned to find out how it's done
14:52 - in this video i'm going to talk about
14:53 - the example program what it does and how
14:55 - the program has changed since part one
14:58 - then i'm going to show you the specific
14:59 - code that handles creating the player
15:01 - controlling him and drawing everything
15:03 - to the screen finally i'm going to show
15:05 - you my implementation of a fixed
15:06 - timestep game loop and how it works if
15:08 - you have any comments or questions post
15:10 - them and if at any point while you're
15:12 - watching this video you get the
15:13 - sensation that you're learning be sure
15:15 - to support this video with a like
15:18 - first thing i want to talk about is what
15:20 - this example actually does and how this
15:22 - program has changed since part one so
15:25 - all this example does is allow me to
15:28 - place a square which represents my
15:29 - player on the screen and use the
15:31 - keyboard to make him jump up and down i
15:33 - also added some stuff in for collision
15:36 - detection and to make it look nice so he
15:38 - changes color on every jump
15:41 - and he leaves a trail the reason he's
15:43 - leaving a trail is just because i'm
15:45 - filling the background i'm redrawing the
15:48 - background on every frame of animation
15:49 - with a
15:51 - a slightly transparent
15:53 - background so that's the reason i'm
15:54 - getting that trail if i was drawing just
15:56 - a plain opaque black ground or opaque i
15:59 - guess some people pronounce it that way
16:00 - if i was doing that you wouldn't be able
16:02 - to see that trail behind them but i
16:03 - thought that was pretty cool and it kind
16:05 - of helps you visualize the what's going
16:07 - on in every frame of animation because
16:09 - each one of those squares that you see
16:10 - trailing behind him
16:12 - is drawn on one frame of animation
16:16 - all right so now that you know what the
16:17 - program does
16:19 - let's talk about what has changed since
16:21 - part one so in part one i had to find my
16:24 - three different classes my controller my
16:26 - display and my game i also had my engine
16:29 - class and my main js file so all these
16:33 - are updated for part two that's why the
16:35 - file name has a o2 after it the ones
16:38 - from part one like engine i haven't
16:39 - changed since part one that has a part
16:42 - one
16:43 - so that's my naming convention that i'm
16:44 - using really the only thing that i
16:46 - changed majorly besides the code that
16:48 - went into making the example work was i
16:50 - took the event listeners
16:52 - out of the display
16:54 - and the controller classes so the key
16:57 - down up actual event handler function i
17:00 - hand into the event ad event listener
17:03 - method in my main
17:04 - js file i'm actually defining those
17:07 - inside of my main file now so this would
17:10 - be one that i moved out the key down up
17:12 - event listener and the resize event
17:15 - listener or actually event handlers
17:17 - that's what these are so if i come all
17:19 - the way down to the bottom of my main js
17:21 - file you can see that i'm adding these
17:23 - event listeners
17:26 - to the window object and i'm just
17:28 - handing in
17:29 - the
17:30 - methods that i define inside of my
17:32 - main.js file into these event listeners
17:35 - so that's one of the changes i made i
17:37 - decided to make that change because
17:39 - i didn't think that my
17:42 - event handling system was really
17:45 - something i wanted to put inside of my
17:47 - individual
17:48 - classes or my individual components and
17:50 - the reason for that is a lot of times
17:53 - inside of these i'm going to have to do
17:55 - interactions with
17:57 - multiple components of my game so for
17:58 - example the resize component actually
18:01 - needs to handle two different components
18:03 - and have them interact it needs the
18:05 - display component which handles drawing
18:07 - everything to the screen and all my
18:08 - graphics and it also takes information
18:10 - from the game component which has
18:13 - information about my
18:15 - world's height and width and my player
18:17 - location and stuff like that
18:19 - so
18:20 - that's just a little bit about the
18:22 - example program and what it does and a
18:24 - few things that have changed since the
18:26 - last part of this series
18:31 - all right so now i'm going to talk about
18:32 - how i define the world and the game
18:36 - object and this is basically going to
18:38 - define
18:39 - the world that my little player square
18:41 - can run around it and jump in and it's
18:43 - going to define the player itself that's
18:44 - going to be just the rectangle that
18:46 - defines the player as well as the color
18:49 - and it's going to handle some collision
18:50 - detection stuff as you can see i can't
18:52 - fall through the floor and i can't jump
18:54 - or walk through the walls so all of this
18:57 - is going to be handled inside of my game
18:59 - logic so i'm going to come into the game
19:02 - part 2 file
19:04 - and take a look at my game class
19:07 - but i'm going to keep it expanded so we
19:09 - could actually look at the code all
19:10 - right so the first thing i'm defining in
19:12 - here is a
19:13 - object literal called world so inside of
19:16 - my game class
19:18 - i'm going to have access to this world
19:20 - object and inside of this i'm just going
19:22 - to have my background color
19:24 - and by the way this is that transparent
19:26 - color so if i come in here and i just uh
19:29 - change this to something like
19:31 - zero zero zero zero zero zero that's
19:33 - gonna be the color for black if i come
19:35 - in there and save it and then refresh my
19:37 - screen now i'm no longer going to have
19:39 - that trailing
19:41 - graphic
19:42 - behind my player whenever he jumps
19:46 - but if i come back in here and change it
19:47 - back ctrl z a bunch of times get rid of
19:51 - that and that and save and come back
19:53 - here
19:55 - now all of a sudden i get my trailing
19:59 - graphics behind my player whenever he
20:00 - jumps in it looks like he has just a
20:02 - cool trail of fading graphics behind him
20:04 - so that's pretty cool and it's really
20:06 - really easy to implement all you got to
20:07 - do is draw this
20:10 - semi-transparent background color
20:12 - to erase your canvas on each frame of
20:16 - animation so anyway
20:17 - to get back to the world object i just
20:19 - want to make a side note of this and how
20:21 - i did that color trailing feature the
20:23 - world is just going to have everything
20:25 - to do with the world so friction and
20:26 - gravity are going to be defined here the
20:28 - player is going to be defined here later
20:30 - on i'm going to define other objects
20:32 - that are going to be in-game objects
20:34 - they're going to be defined here the
20:35 - world boundaries so the height and width
20:38 - of our level are going to be defined
20:40 - here if i were to change this let's say
20:42 - i want to make the height something like
20:44 - 200 and have a really tall screen if i
20:46 - do that and come here and refresh the
20:47 - screen now you can see that
20:50 - i have a really really tall game world
20:52 - and
20:53 - that looks kind of stupid so
20:56 - we're going to change it back
20:58 - save refresh and now i'm back to my
21:00 - normal size but basically the world
21:02 - object just holds everything to do
21:05 - with the game world including stuff like
21:07 - collision so this collide object
21:09 - function is just going to take an object
21:11 - parameter and for now that's just going
21:13 - to be handled inside of our game loop on
21:15 - every update and i'm going to pass clyde
21:17 - object the player object that we're
21:20 - defining i'm going to get to that class
21:21 - later and basically it's just going to
21:23 - test c is the object
21:25 - to the left of zero so that's going to
21:27 - be the far left of our screen and is he
21:31 - beyond the right side of the screen is
21:32 - he
21:34 - above the top of the screen is he below
21:36 - the bottom of the screen it's just going
21:37 - to set him to where he needs to be and
21:38 - handle collision with the boundaries of
21:40 - our rectangular world here
21:42 - so pretty simple stuff everything in
21:45 - this example is actually really basic
21:47 - take a look at the source code i have it
21:48 - linked in the description
21:50 - here i have the update function
21:53 - now this is actually going to update
21:54 - everything to do with our world so the
21:56 - player is going to have gravity added to
21:58 - his y velocity on every frame this
22:01 - function is going to be called on every
22:02 - frame of animation inside of the game
22:04 - loop
22:05 - the player has his own update function
22:08 - and if i come down to the player object
22:10 - down here we could take a look at it
22:12 - see what we got here update it just adds
22:14 - his x and y velocity to his current x
22:17 - and y position
22:20 - go back up see what else we got here
22:23 - so we're going to update the player
22:24 - we're going to add some gravity to his y
22:26 - velocity we're going to add friction or
22:29 - we're going to reduce his x and y
22:31 - velocities by the amount we defined in
22:34 - friction which is up here
22:36 - 0.09 it's just a simple pseudo-physics
22:39 - way to
22:40 - employ friction in your game then we
22:43 - have this dot clyde object this stop
22:45 - player and this is referring to
22:48 - the world object
22:50 - that we are talking about
22:52 - so that's a really simple world object
22:54 - it just governs everything to do with
22:56 - the world the dimensions the player the
22:58 - colors that you're seeing in there
23:01 - and also in our game class we have added
23:04 - or i have added rather uh the player and
23:07 - it's a simple class it's
23:10 - uh using dot syntax to kind of add this
23:14 - player class to the game class and
23:16 - that's kind of just a way to keep things
23:17 - organized and almost like name space in
23:20 - there it's not real name spacing but
23:23 - by doing this i'm not going to have a
23:27 - a global class called player
23:30 - instead i'm going to have to reference
23:32 - it with game dot
23:34 - player like that so if i have a bunch of
23:37 - classes that i'm throwing into an
23:38 - external context say your game is going
23:40 - to run on another website and it's going
23:43 - to be part of the global scope of that
23:44 - website you don't want your classes and
23:47 - stuff to be just floating around with
23:49 - all the other variable names and class
23:51 - names that other developers have defined
23:53 - so it's good to try to abstract out your
23:56 - own class names and variable names and
23:58 - do stuff like put them into anonymous
24:00 - functions just to keep your code
24:03 - separated from everybody else's code out
24:05 - there on different websites
24:08 - but anyway that's besides the point we
24:10 - define our player class here he has a
24:12 - color he has a height he has a width he
24:14 - has x and y velocities he has a value
24:17 - for jumping to determine whether or not
24:18 - he's jumping and he's in the air if he's
24:20 - standing on the ground we also have his
24:23 - x and y position and since i'm just
24:25 - being lazy and i'm not loading him in
24:28 - from a level map i'm just going to
24:29 - define his
24:31 - values all right at the start here when
24:33 - the player object is instantiate
24:36 - instantiated with the new operator
24:38 - so
24:40 - now i go into the prototype and i have a
24:42 - couple different functions that govern
24:44 - govern how he moves i have the jump
24:46 - function
24:47 - uh basically just says if he's not
24:48 - jumping
24:50 - then we're gonna change the color and
24:52 - we're gonna make him jump down here so
24:54 - pretty simple this is the code to get a
24:56 - random color
24:58 - and i'm not really gonna go into that
24:59 - but basically it just makes his color
25:01 - change every time he jumps every time i
25:03 - press the up arrow on my keyboard
25:06 - the jump function is called on the
25:07 - player and this code runs pretty simple
25:11 - same thing for the move left and move
25:13 - right functions these functions are
25:15 - going to be called in my main javascript
25:16 - file i'm going to take a look at that in
25:17 - a second and all it does is just add
25:20 - half a pixel to his x and y or x
25:24 - velocity depending on which button you
25:26 - press if i press left i'm going to
25:27 - subtract 0.5 pixels from his x velocity
25:30 - if i
25:31 - press right on my keyboard i'm going to
25:33 - add 0.5 pixels to his x velocity and
25:35 - then finally that update function that's
25:37 - just going to add his x and y velocity
25:39 - to his x and y locations in the canvas
25:43 - respectively so now let's let's take a
25:45 - look inside of the main js file and
25:49 - see where all of these are being
25:50 - employed which is going to be inside of
25:52 - the update function
25:54 - so the reason i have my
25:56 - update functions all over the place i
25:58 - have one for my player i have one for my
26:00 - world and i have one in my main
26:01 - javascript file is because
26:04 - i'm doing different things inside of all
26:06 - of them and i want to keep all of my
26:07 - objects as self-contained as possible so
26:10 - for instance
26:11 - uh the
26:12 - player object his update function is
26:14 - really simple
26:16 - it just handles stuff that has to do
26:18 - with the player my world's update
26:20 - function only handles stuff to do with
26:22 - the world so
26:24 - this.world.update is going to be this
26:27 - function right here the world's update
26:28 - function only has to do with things
26:30 - inside of the world
26:32 - the main javascripts file
26:34 - javascript file has an update function
26:36 - that handles
26:38 - the controller
26:40 - as well as the game so i'm mixing these
26:42 - two major components of my game's logic
26:46 - inside of this one method inside of my
26:49 - main.js file and that's kind of where i
26:50 - want everything to communicate i don't
26:52 - want to have those internal references
26:54 - pointing to other components inside of
26:56 - my game i want all of my code to be
26:59 - very self-contained and when i have it
27:02 - interact with other components inside of
27:04 - my code i want it to be in a safe
27:06 - context kind of like the main js file
27:08 - that's where i'm going to do most of my
27:09 - editing
27:10 - so anyway
27:11 - i'm getting information from the
27:13 - controller i'm just saying is the
27:14 - controller being pressed are these keys
27:17 - active on the keyboard and if so i'm
27:19 - going to execute a corresponding
27:21 - function function on my player object
27:25 - finally i'm going to call game.update
27:27 - and game.update is going to go ahead and
27:30 - call
27:31 - world.update world.update is going to
27:33 - call all this stuff
27:35 - and that's going to give me these nice
27:37 - cool physics and take care of all my
27:39 - numbers and player position and velocity
27:42 - and whether or not he's colliding and
27:43 - that's going to take care of all of the
27:45 - physics logic in my game it's also going
27:47 - to change the player color
27:51 - alright so now i just talked about what
27:54 - actually makes the game logic work and
27:56 - that is of course the game class itself
27:58 - stored in the game o2 file so now i have
28:01 - to talk about how i'm getting
28:03 - keyboard input and relaying that to the
28:06 - game class so it can actually take that
28:08 - input and do something with it so i just
28:10 - showed you inside the main
28:12 - file here that i'm i'm conveying the
28:15 - keyboard's input via the controller
28:17 - object to
28:19 - the game object and telling the game
28:21 - object to do something with the player's
28:22 - position like move left move right or
28:24 - jump
28:25 - and that's all going to happen depending
28:27 - on what the controller object is doing
28:29 - so let's take a look at the controller
28:31 - class and see how that works
28:34 - so the controller class just has three
28:37 - objects here a left right and up object
28:39 - and those objects are going to be
28:41 - controller dot button input classes so
28:44 - let's take a look at the button input
28:45 - class and see what it is it's really
28:47 - really simple all it is is an object
28:49 - that has two
28:50 - boolean values inside of it one called
28:53 - active and one called down now active is
28:56 - gonna hold the virtual state of our
28:58 - button
28:59 - so
29:00 - i'll get into that in a little bit
29:01 - because it has to do with jumping and
29:03 - down is going to refer to the physical
29:06 - state of our button on the keyboard so
29:07 - if i physically press the up key down
29:11 - down is going to be true and if i hold
29:13 - that key down it's going to remain true
29:16 - the active value however is going to
29:18 - depend more on my actual game's logic so
29:22 - just remember keep in mind that down
29:23 - refers to the physical state of the
29:25 - button on my keyboard and that's what
29:26 - that is going to track and active is
29:28 - just going to track
29:30 - uh what that value is of my button
29:33 - object inside of my game's code or my
29:35 - game logic
29:37 - so now that you know what the button
29:39 - input class is
29:41 - these three objects are going to be
29:44 - button inputs and this key down up event
29:47 - handler function is going to be called
29:49 - every time i press a key on my keyboard
29:52 - whether i press it down or it comes back
29:54 - up this is going to be called it's going
29:55 - to check to see what the event type is
29:57 - key down or key up so when i press a key
30:00 - down on the keyboard
30:01 - the type's going to be key down when i
30:03 - release that key it's going to be key up
30:06 - and depending on which one it is it's
30:07 - either going to be true or false and
30:10 - then i'm just going to use the get input
30:12 - method of my button input class
30:15 - and hand in that
30:17 - down value which is either going to be
30:18 - true or false
30:19 - and that's going to look like this it's
30:22 - just going to say if
30:24 - the
30:24 - key
30:25 - tracker or the
30:27 - button input object
30:29 - if that currently is down the state is
30:32 - currently down
30:33 - or if the state is not equal to whatever
30:36 - we're handing in then we're going to set
30:38 - active equal to whatever we're handing
30:39 - in and we're just going to set down
30:41 - equal to whatever we're handing in
30:42 - because that's going to be the physical
30:44 - state of the button
30:46 - pretty
30:47 - simple maybe not so simple take a look
30:49 - at the source code and fiddle around
30:50 - with it because that's really the best
30:52 - way to get an idea i'm just here running
30:54 - over everything i'm trying to get it
30:55 - done quick because this video seems like
30:57 - it's going to go long i don't want it to
30:59 - go too long but basically this is a
31:00 - controller class just takes keyboard
31:03 - input and i'm adding the event listener
31:06 - for the controller
31:08 - component inside not my engine but
31:10 - inside of my main javascript file at the
31:13 - bottom if i come all the way to the
31:15 - bottom you can see i'm adding the key
31:16 - down and key up listener to the key down
31:19 - up
31:20 - function which i'm defining also inside
31:22 - of my main file and that is just going
31:24 - to call the controller's key down up
31:27 - method and hand in the event.type and
31:30 - the
31:31 - code which we use to determine
31:36 - what the type is whether it's a down
31:38 - press or an up press
31:40 - and the key code is just going to
31:42 - determine which key on the keyboard i'm
31:43 - pressing so 37 38 and 39 are the left up
31:47 - and right arrow keys on the keyboard
31:50 - so basically this controller class just
31:52 - gets keyboard input and then we relay
31:55 - that input to
31:57 - the
31:59 - game component right here in the main js
32:02 - file
32:03 - inside of its update function which is
32:04 - called on every frame of animation
32:07 - managed by our engine which i'm going to
32:09 - talk about later on in this video so
32:11 - really simply just checks to see if the
32:14 - left right and up keys are active
32:16 - and then it goes ahead and it calls a
32:19 - player movement function so move left
32:21 - move right or jump so where the active
32:24 - value comes into play here is when the
32:26 - player is jumping so
32:28 - notice that i'm actually setting the
32:30 - virtual state of the controller dot up
32:32 - button input
32:34 - to false i'm changing the active value
32:36 - to false so that's going to give me the
32:39 - ability to press my key once and hold it
32:41 - down and not have my player jump again
32:43 - if i were to come in and comment this
32:45 - line of code out like this
32:48 - and just go
32:50 - like this comment this guy out save my
32:53 - file come over here to my browser
32:54 - refresh
32:56 - now i'm just going to jump up and down
32:58 - continuously
32:59 - now this might be desirable for some
33:01 - people for some games this might be what
33:03 - you want but for other games you're not
33:05 - going to want to keep on jumping just
33:06 - because you have the key pressed down so
33:09 - if that's something you want in your
33:11 - game
33:12 - not having the player jump up and down
33:14 - continuously as your button is pressed
33:16 - in
33:17 - this controller class
33:19 - right here
33:20 - and these
33:22 - button input objects here with this dual
33:26 - virtual and physical uh button state
33:29 - tracker
33:31 - objects here these boolean values
33:33 - this is going to allow you to prevent
33:35 - your player from just jumping up and
33:36 - down continuously and you're going to
33:38 - get functionality that looks like this
33:40 - instead you're just going to be able to
33:41 - jump one time and
33:43 - only jump when you press the key rather
33:45 - than jumping just continuously if you
33:48 - have the key held
33:50 - down all right so now that you know how
33:53 - to define the player object and the
33:55 - world
33:57 - object in our game class and you know
34:00 - how to get user input to actually
34:01 - control this guy and move them around
34:03 - the screen
34:04 - the only thing left is how to draw this
34:06 - guy so how we're drawing the player
34:09 - object and the world itself to this
34:11 - canvas element is with the display class
34:13 - so inside of the display class i just
34:15 - define a buffer and a context of my
34:17 - canvas so these are two uh 2d rendering
34:21 - contexts canvas rendering context
34:25 - context is the rendering context of the
34:27 - on-screen canvas that you see on screen
34:29 - buffer is just an off-screen canvas that
34:32 - is going to be sized perfectly to match
34:35 - our world height and width so if we come
34:37 - back into our game and scroll down here
34:40 - the buffer canvas is going to be sized
34:43 - at 72 pixels high and 128 pixels wide
34:46 - and that is actually going to happen all
34:48 - the way at the bottom of our main.js
34:50 - file and the reason for that is just so
34:52 - everything scales the way it should so
34:54 - i'm setting that up right here in the
34:56 - initialization portion of my main.js
34:58 - file
35:00 - so let's get back into display and talk
35:02 - a little bit more about it
35:03 - so i've added a couple different
35:05 - functions i have the fill function or
35:07 - method all it does is take a color and
35:09 - draw it to the buffer which remembers
35:11 - the off-screen canvas which is then
35:13 - drawn by the render function to our
35:16 - on-screen canvas it draws this
35:18 - off-screen buffer canvas to the
35:20 - on-screen
35:22 - display canvas that you actually see in
35:23 - the browser window
35:25 - so the fill method just fills the buffer
35:27 - with color
35:28 - render renders that buffer to the screen
35:30 - draw a rectangle just draws this
35:33 - rectangle here that's what i'm handing
35:35 - in in terms of x y width and height and
35:38 - color
35:39 - and it just draws that to the buffer as
35:40 - well i'm actually rounding down the x
35:43 - and y positions of the rectangle that
35:45 - i'm handing in this way it doesn't
35:47 - render it on a half pixel so let's see
35:50 - what happens when i take this code out
35:52 - first let's uh take a look at what this
35:54 - guy actually looks like moving around
35:55 - the screen
35:56 - so pretty smooth
35:58 - nothing weird going on
36:00 - all the edges look pretty straight if i
36:02 - come in here and i just put in
36:05 - x and y though let's take a look and see
36:07 - if anything changes
36:12 - as you can see
36:14 - it looks a little bit funky i mean it's
36:16 - hard to tell because
36:20 - i have this background let's actually go
36:21 - in here and change the background color
36:23 - of my game to something else here let's
36:25 - uh let's make it
36:27 - black instead
36:29 - zero zero zero zero zero zero that's
36:31 - going to give me black i'm gonna come in
36:32 - here refresh my screen
36:34 - take a look at the player character you
36:36 - see how his edges are kind of messed up
36:38 - they're kind of wavering a little bit
36:41 - kind of looks like he's just fading
36:43 - around instead of just sitting on the
36:45 - exact pixel he's meant to sit on well
36:47 - that is actually because he's sitting on
36:50 - half pixels from time to time and you
36:52 - can fix that by rounding down the values
36:54 - you pass into your draw method so we can
36:57 - go from this which looks a little bit
36:59 - funky
37:00 - to
37:00 - this
37:02 - which now looks really sharp and
37:05 - not so funky at all it's basis basically
37:07 - the best we can get
37:09 - on a
37:10 - html5 canvas so now let me set back my
37:13 - background color to the way it was
37:15 - before so we could have that nice
37:18 - fading effect that follows the character
37:20 - around refresh my screen
37:23 - and so that's
37:24 - what i'm going to use to draw my
37:26 - rectangle to the screen and round him to
37:28 - the nearest
37:29 - full pixel location with math.floor so
37:32 - he doesn't get that weird blur around
37:33 - the edges now let's take a look at the
37:36 - main.js file and that's where all of
37:37 - these are going to be called actually i
37:39 - think inside of
37:41 - actually no i'm wrong let's just take a
37:42 - look at the main js file and see where
37:44 - these guys are called
37:46 - i think it's going to be inside of the
37:47 - render function i haven't looked at this
37:49 - code in a little bit
37:50 - so we have display.fill
37:52 - and by the way the render function is
37:54 - going to be called by our game engine
37:56 - which is our game loop on every frame of
37:58 - the animation so 30 times every second
38:02 - so we call display.fill that's going to
38:05 - fill our background color with this nice
38:07 - dark gray here we're going to call
38:10 - drawrectangle and hand in the
38:12 - game.world.player which is a rectangle
38:14 - we're going to hand in all those values
38:16 - as well as the color value
38:20 - and finally we're going to call
38:23 - display.render and that's going to draw
38:24 - the buffer that we just filled with the
38:26 - background color and drew the rectangle
38:28 - to and we're going to draw that that
38:30 - buffer to the final display canvas now
38:33 - one more thing i want to talk about here
38:35 - because this is pretty simple stuff is
38:37 - the resize functionality so the resize
38:40 - functionality is going to take care of
38:42 - scaling my on-screen canvas it's also
38:45 - going to take care of keeping the aspect
38:47 - ratio of the game world which you
38:49 - remember has the height and width
38:51 - coordinates
38:52 - it's going to keep that aspect ratio
38:54 - from the game world
38:55 - and the buffer to the final display
38:58 - canvas so we get a nice square rectangle
39:01 - every time so
39:03 - what's important about that well if we
39:04 - come down here i told you that we're
39:07 - going to set our buffers
39:08 - canvas height and width to the game
39:10 - world height and width now if i were to
39:12 - change this and say height times 0.5
39:16 - obviously that would warp our game a
39:17 - little bit so let's take a look at that
39:19 - and what that looks like
39:22 - oh
39:23 - kind of cut off half the world but you
39:25 - can see that when i jump up the player
39:27 - is actually a lot taller than he is wide
39:30 - by about twice as much
39:32 - so
39:33 - let's set back that that back to normal
39:35 - and
39:36 - go ahead and take a look at the resize
39:38 - function
39:40 - which i'm adding to the window that
39:42 - handles all of that stuff so resize is
39:44 - right here it's going to call
39:46 - display.resize and it's going to hand in
39:49 - document.documentelement.clientwith and
39:51 - klein height it's going to subtract 32
39:53 - pixels from both of those to give us
39:55 - this nice 16 pixel margin on either side
39:58 - of our display canvas which i have to
39:59 - refresh so it goes back to the way it's
40:01 - supposed to be so that's what that's
40:03 - doing those 32 pixels then it's going to
40:06 - hand in an aspect ratio of our game
40:08 - world which is going to be just the
40:10 - height divided by the width of our game
40:12 - world so now let's take a look inside of
40:14 - the display
40:16 - object's resize method and see what it's
40:18 - actually doing
40:21 - so here i am inside of the resize method
40:24 - and as you can see it's not super
40:25 - complicated it's actually pretty simple
40:27 - it's basically just going to say if the
40:30 - height and width ratio that we handed in
40:34 - from
40:36 - document.documentelement.com with
40:37 - incline height minus 32 pixels to give
40:39 - us that nice 16 pixel margin on each
40:41 - side it's going to say if that ratio is
40:43 - greater than the height width ratio of
40:46 - the world object
40:48 - the game world
40:50 - then if that height with if the screen's
40:52 - height width ratio is greater than the
40:53 - height width ratio of the world then
40:55 - we're going to set the canvas's height
40:57 - to the width times the ratio and we're
40:59 - going to set the canvas's width to the
41:01 - width of the screen so right now we have
41:03 - a max width scenario
41:05 - otherwise we don't have a max width
41:07 - scenario we have a max height scenario
41:09 - and it's going to set the canvas's
41:10 - height to the max height and it's going
41:12 - to set the width to the
41:15 - height divided by the height with ratio
41:17 - so this code is basically going to allow
41:19 - me to do
41:20 - this if i come in here
41:22 - and i change the scale of my window
41:26 - as you can see it's always going to keep
41:27 - it centered right now i have a max
41:29 - height situation and i have a shorter
41:31 - width in my game world but the aspect
41:33 - ratio remains the same
41:35 - and
41:36 - here i'm going to go back down somewhere
41:38 - around here i'm going to change over
41:40 - from a max height situation to a max
41:42 - width situation
41:43 - and now you can see my display canvas
41:46 - gradually getting smaller in height
41:49 - so that's pretty cool that's the display
41:51 - function takes care of resizing the
41:54 - canvas and maintaining that nice aspect
41:57 - ratio so our game can scale nicely
41:59 - across many different devices
42:04 - alright so now i'm going to do a brief
42:06 - run through of my fixed time step game
42:10 - engine and this is the game engine class
42:13 - it's in the engine file i haven't
42:14 - changed it since part one of this series
42:17 - it's exactly the same as it was although
42:19 - i did add in this accumulated time
42:22 - variable definition because it wasn't in
42:24 - here
42:25 - it was actually being added later right
42:27 - here so i just fixed that but it's
42:29 - basically exactly the same
42:31 - so
42:32 - what a fixed time step game loop does
42:35 - is it causes your game to update and
42:37 - draw
42:39 - at a fixed rate as time passes and it
42:42 - does that by taking a time step value
42:44 - which in this case is going to be 1000
42:47 - divided by 30 if i come over to my main
42:49 - js where i actually instantiate this
42:51 - i am
42:54 - passing 1000 divided by 30 which is
42:56 - roughly 33.3
42:59 - repeating forever and that is going to
43:01 - be the number of milliseconds that i'm
43:03 - going to call render and update on so
43:05 - every 33.33 milliseconds i'm gonna call
43:08 - render and update
43:10 - and the render and update functions are
43:12 - just right here
43:13 - you've seen them throughout this video
43:14 - and they're basically just going to
43:16 - update my game logic
43:18 - and render the changed game state to the
43:21 - screen
43:23 - let's hop back inside of the engine and
43:25 - talk about this game loop some more
43:27 - alright so we've got
43:30 - our time step and that's going to be in
43:32 - this case about 33.33 milliseconds and
43:36 - so every 33.33 milliseconds i'm going to
43:38 - call the update and render function i
43:40 - passed in they're going to be stored
43:41 - right here
43:42 - and i'm going to keep track of how much
43:45 - time has passed in the accumulated time
43:48 - variable
43:49 - so every time
43:51 - 33.33 milliseconds passes hopefully our
43:54 - our game is updating close to that but
43:56 - anything that overflows is going to be
43:59 - stored in accumulated time so let's say
44:01 - 33.33 is our minimum time step and
44:03 - that's exactly what it is but let's say
44:05 - uh request animation frame which is what
44:08 - we're using to update our game logic
44:10 - fires at 40 milliseconds now we're gonna
44:13 - have about what is that
44:15 - seven six something about six
44:18 - milliseconds left over and we're going
44:20 - to store that in accumulated time and
44:22 - when accumulated time reaches our time
44:25 - step or 33.33
44:27 - we're going to update or call update one
44:29 - more time so basically we're storing all
44:32 - the time that passes in accumulated time
44:34 - and we're just taking bites out of that
44:37 - accumulated time we're taking 33
44:39 - millisecond bytes out of our accumulated
44:42 - time
44:43 - the time value is just going to be the
44:45 - last time our run function executes and
44:49 - this is just going to be the looping
44:51 - function this is going to be the
44:52 - function that loops over and over again
44:54 - a lot of game engines will call this
44:56 - cycle
44:57 - some call it loop i'm just calling my
44:59 - run because
45:00 - engines run so this is going to be one
45:03 - run of the game loop so inside of the
45:05 - run function
45:07 - we're adding the current time stamp
45:09 - that's handed to us by request animation
45:11 - frame we're
45:13 - subtracting the current time or the last
45:16 - time our game executed from the current
45:18 - time and we're adding that to
45:19 - accumulated time
45:20 - so let's say that our the last time our
45:23 - game executed was at 100 milliseconds
45:26 - and we're just now getting in a new call
45:29 - to the run function from request
45:31 - animation frame and it's going to happen
45:32 - at
45:33 - 140 milliseconds so we're going to have
45:36 - 140 milliseconds minus 100 milliseconds
45:39 - and 40 milliseconds is going to go into
45:41 - accumulated time
45:43 - so
45:44 - now we have 40 milliseconds in
45:46 - accumulated time we're just going to set
45:48 - the the new
45:49 - most recent time value to the current
45:52 - time value but just remember 40
45:53 - milliseconds in accumulated time here is
45:56 - where the fixed time step game loop
45:57 - really shines because this well actually
46:00 - this is just a safety i'm not going to
46:02 - talk about but but this is where it
46:03 - really shines the while
46:05 - loop
46:06 - so remember we have 40 milliseconds of
46:08 - accumulated time
46:10 - and we have our 33
46:12 - i'm going to round that down to 33 or 33
46:14 - milliseconds in our time step
46:17 - so 40 is greater than 33 so while 40 or
46:20 - our accumulated time is greater than our
46:22 - time step we are going to reduce our
46:25 - accumulated time by the time step we're
46:27 - going to call update
46:29 - and we're going to set this updated flag
46:31 - to true but don't worry about that too
46:32 - much
46:33 - so then we're going to loop again and
46:35 - see if that's true again and we
46:38 - subtracted 33 from 40 so that's going to
46:40 - give us
46:41 - 7
46:42 - and 7 is no longer greater than our time
46:44 - step so we're not going to update again
46:46 - but let's say that accumulated time was
46:48 - equal to 70.
46:51 - okay so now we have 70. 70 is greater
46:54 - than 33 so we're going to call update
46:57 - then we're going to try to loop again
46:58 - well 70 minus 33 what is that
47:02 - 47 is that accurate anyway 47 is still
47:06 - going to be greater whatever it is it's
47:07 - still going to be greater than 33 so
47:09 - we're going to update again so even if
47:11 - we didn't have another request animation
47:15 - frame event fire and we didn't update
47:17 - the screen again we're still going to be
47:19 - updating twice on the next time request
47:22 - animation frame fires and gives us a new
47:27 - run command or we're going to call run
47:28 - again so we're going to be keeping up
47:31 - with time no matter what happens so even
47:34 - if our game runs really slow and laggy
47:37 - it's still going to keep up with time
47:39 - and it's going to run at the same
47:42 - rate basically on any device regardless
47:45 - of how slow it is unless the device is
47:46 - so slow that it just can't handle the
47:49 - game and then it will crash but that's
47:50 - that's not something you really should
47:52 - worry about uh unless your game is
47:54 - crashing all devices but if your game is
47:56 - just crashing the you know computers
47:59 - from
48:00 - 1995 then you shouldn't worry about it
48:04 - but basically the fixed time step game
48:06 - loop just says
48:07 - if too much time has passed or if a
48:09 - certain amount of time has passed we're
48:11 - going to update our game at whatever
48:13 - rate we want it to update until we have
48:16 - caught up with however much time has
48:17 - passed and that's a really great
48:18 - functionality of fixed time step game
48:21 - loops and it's a great reason to add
48:22 - them in to any game that you're writing
48:25 - so now down here we have the updated
48:27 - flag basically we turn that flag on we
48:30 - set it to true anytime we do an update
48:32 - and then if it is true if we have
48:35 - updated then we're going to call the
48:36 - render function and that's just going to
48:38 - draw our game
48:39 - so
48:40 - why is this good well let's say
48:45 - accumulated time only has 20
48:46 - milliseconds in it but we need 33
48:49 - milliseconds to justify an update
48:51 - otherwise we'd be going
48:53 - faster than we want to update well if
48:55 - that's the case then this never fires we
48:58 - never update our game and if we don't
49:00 - update our game nothing has changed and
49:03 - anything we draw is just going to be a
49:05 - waste of cpu or gpu so we don't want to
49:09 - draw anything that hasn't been updated
49:10 - or changed so if no update has occurred
49:13 - update updated stays false
49:16 - and we don't draw
49:18 - and finally inside of the run function
49:20 - we just make another call to the
49:22 - handlerun method and the handlerun
49:24 - method is just down here it's just an
49:26 - arrow function that calls uh the
49:29 - engine.run method now the reason i'm
49:31 - using an arrow function is because
49:33 - if you've worked with event listeners or
49:35 - request animation frame before the this
49:37 - keyword inside of
49:40 - whatever function you hand into
49:42 - your event listener as your event
49:45 - handler or request animation frame as
49:47 - your response to a request animation
49:50 - frame event firing is going to point to
49:52 - the object that you request the frame or
49:54 - add an event listener to so in this case
49:56 - it's the window so i don't want this to
49:58 - refer to window
50:00 - i want this to refer to my actual engine
50:02 - object so by using this arrow function
50:05 - i can actually make this refer to my
50:08 - engine object rather than the window so
50:10 - that's the only reason i have that kind
50:12 - of set up as an arrow function there to
50:14 - make sure that this keyword is referring
50:16 - to engine instead of window otherwise i
50:19 - would have to have
50:21 - a reference to
50:22 - engine
50:23 - inside of the engine and that just is
50:25 - really
50:27 - it just seems really sloppy to me so i
50:29 - set up the arrow function and that's
50:30 - what that does
50:32 - and anyway i hope that was a good
50:34 - explanation of a fixed time step
50:36 - engine
50:37 - and
50:39 - probably wasn't the best i was kind of
50:40 - going through it really fast it's really
50:42 - cold in this room where i'm recording
50:43 - and i'm kind of i'm like freezing to
50:45 - death so
50:46 - don't hold it against me i should turn
50:48 - up the heat but
50:50 - you know just i'm doing what i'm doing
50:52 - here so hopefully that was a good enough
50:53 - explanation of a fixed time step game
50:56 - loop and if not definitely take a look
50:58 - at the source code i commented
51:00 - everything in here so you guys can get a
51:01 - better understanding of the code as you
51:04 - read through it line by line
51:06 - in this video i showed you how to lay
51:08 - the groundwork for any platforming game
51:10 - so far i've implemented keyboard input
51:12 - simple platforming physics scaling for
51:14 - multiple devices and a fixed timestep
51:16 - game loop to handle updating your game
51:18 - at a consistent rate no matter what
51:19 - device it's on which is perhaps the most
51:22 - important thing you could take away from
51:23 - this video
51:25 - i'm going to show you how to draw a
51:27 - tiled background from a one-dimensional
51:28 - tile map i'm going to talk about the
51:30 - example program and what i've added
51:32 - since part two then i'm going to talk
51:34 - about how to load the tilesheet image
51:35 - and store in a tilesheet class finally
51:38 - i'll show you the tile map in the game
51:40 - class and how it's drawn
51:43 - alrighty guys let's take a look at what
51:45 - has changed since part two if i come
51:47 - over here in the browser first i'm gonna
51:49 - real quick i'm gonna go ahead and i'm
51:51 - gonna pull up part two so you guys can
51:53 - see it
51:54 - and that is right here i'm gonna press
51:56 - enter load up part two
51:58 - and
51:59 - this is part two so as you can see i
52:01 - have some jumping physics i get keyboard
52:03 - input but there's no tile background and
52:05 - to make this game i'm definitely going
52:06 - to need a cool tile background so let's
52:08 - go over to part three and check out what
52:11 - we've done there
52:12 - alright so this is part three
52:14 - and as you can see it's a lot better i
52:17 - still have the same
52:18 - game physics where my character jumps
52:20 - around and moves around same fluid
52:22 - physics exact same physics code the only
52:25 - difference now is the world is a
52:26 - different size and i have a tile map
52:28 - inside of it
52:30 - also the color of the character
52:32 - is just a solid white and gray the
52:34 - reason i did that was to more closely
52:36 - resemble the player sprite we're gonna
52:38 - be using which is this little rabbit
52:40 - dude and
52:41 - basically that's it that's all the
52:42 - changes that have happened in part three
52:44 - since part two the files where the
52:46 - changes occurred are display game and
52:49 - main
52:50 - everything else i'm using uh the
52:52 - controller class from part two
52:55 - if i come into my directory here i'm
52:57 - gonna be using the controller class from
52:59 - part two
53:00 - and i'm gonna be using that file and i'm
53:02 - also gonna be using the engine class
53:04 - from part one
53:06 - but this is part three and these are the
53:08 - only three files that you need to worry
53:10 - about if you've already watched part one
53:11 - and two so anyway on to the rest of the
53:14 - video
53:17 - so the first thing we need to worry
53:18 - about for this application is how we're
53:20 - going to get our sprite sheet png image
53:23 - into our javascript so we can actually
53:25 - do something with it and have it render
53:27 - over here on the screen and show up on
53:30 - the background of our canvas element so
53:32 - first we need to define some sort of
53:35 - container for our sprite sheet image and
53:38 - its different
53:40 - variables
53:41 - and we do that inside of the display
53:42 - class so here's my display class it's
53:45 - one of the files that has changed since
53:46 - part two and inside of it
53:49 - i define a
53:51 - class called tilesheet i come down to
53:53 - the bottom here here's my tile sheet
53:55 - class it's just a really simple object
53:57 - it has an image inside of it
53:59 - this image object is going to store our
54:02 - tile sheet or our sprite sheet
54:04 - and then it records the tile size and
54:07 - i'm just going to hand in 16 because
54:08 - each one of our tiles is 16 by 16 pixels
54:11 - and the number of columns in our tile
54:13 - sheet so i think that's eight off top of
54:15 - my head but if we come over here and we
54:16 - actually count them
54:18 - we're gonna have
54:19 - one two three four five six seven eight
54:24 - different tiles kind of hard to tell but
54:26 - there's eight tiles or eight columns
54:28 - in this map
54:30 - eight tiles across or eight columns not
54:32 - just eight tiles in the map obviously
54:33 - there's more but
54:35 - so we have to define this tilesheet
54:38 - class and it's just going to have an
54:40 - image which is going to be our image
54:41 - it's going to have the tile size and
54:42 - it's going to have the number of columns
54:44 - in our tilesheet image
54:46 - now that we have this we can actually go
54:48 - about loading this png image into our
54:51 - javascript so we can do something with
54:52 - it where that happens is the main js
54:56 - file for part three so if i come down to
54:58 - the bottom of my file here
55:00 - you can see that
55:02 - i am
55:03 - setting the image
55:05 - of my tilesheet object in the display
55:07 - class i'm setting the source of that
55:08 - image to
55:10 - the rabbittrap.png and that's going to
55:12 - start loading the rabbittrap png image
55:15 - here
55:16 - into the
55:19 - tilesheet objects image
55:21 - and when it's done loading it's going to
55:23 - fire this
55:25 - event listener for loaded so it's going
55:28 - to say okay my image just loaded i have
55:30 - an event listener for that let's call
55:32 - this function the event handler function
55:34 - for a load event there i'm going to
55:36 - resize the screen
55:38 - that's just going to resize the browser
55:40 - window or not the browser window but
55:42 - resize our canvas to fit the browser
55:44 - window rather and it's going to call
55:46 - engine.start that's going to start our
55:47 - game loop off and then we're actually
55:49 - going to be able to use that graphic
55:50 - because if we start our engine before
55:53 - the graphic is fully loaded we're going
55:55 - to try to draw graphics that just aren't
55:57 - loaded yet and that's a problem so make
55:59 - sure that your graphic is fully loaded
56:01 - with an event listener for load before
56:03 - you actually start your engine
56:06 - also down here this extra parameter once
56:09 - colon true that just tells this event
56:12 - listener to only fire once and after
56:14 - it's done it just
56:16 - junks it
56:17 - sends it to the trash sends it to
56:19 - garbage collection we don't have to
56:21 - worry about removing this event listener
56:23 - from our tile sheet image because this
56:26 - parameter here just takes care of it
56:30 - all right so now that we've loaded our
56:32 - tile sheet image into our javascript we
56:34 - actually have to get these individual
56:36 - images out of this sprite sheet or tile
56:39 - sheet we have to draw them to different
56:42 - locations on the canvas to create
56:44 - something of a tiled map like you see
56:46 - here
56:47 - so how do we do that well it starts out
56:49 - in the game class and i have a
56:53 - map inside of my game class inside of
56:55 - the world
56:56 - and basically it's just a big long array
56:59 - of values that point to different
57:01 - locations in the tile sheet so the best
57:03 - way i can explain this to you is by just
57:05 - giving you an example and i'm gonna look
57:07 - down here in the bottom right of my
57:09 - numeric tile map at these three values 1
57:13 - 43 and 10. now these values correspond
57:16 - to locations inside of my tile sheet
57:18 - graphic
57:19 - and they also correspond to these
57:21 - locations on the map so this is the one
57:25 - tile this here is going to be the 43
57:27 - tile and this
57:29 - over here is going to be the 10 tile and
57:31 - as you can see you can kind of make that
57:33 - connection those three tiles are going
57:35 - to be in this bottom right hand corner
57:38 - of the map so now let's take a look at
57:41 - these tiles inside of the sprite sheet
57:43 - itself
57:44 - we're going to have one so that's going
57:46 - to be for this example it's going to be
57:47 - at position one in our map normally i
57:50 - start at zero i start counting at zero
57:52 - but for this example i'm gonna start
57:53 - counting at one so
57:56 - tile one is just going to be this corner
57:58 - tile and as you can see right here in
57:59 - the map
58:00 - it is that corner tile
58:03 - these two tiles are the same so
58:05 - tile one is just gonna be this one right
58:07 - here and if you think about it makes
58:09 - sense because this is the first tile
58:11 - index in the map so just go 1 2 3 4 5 6
58:15 - 7 8 9
58:17 - 10
58:18 - and remember this is tile 10
58:21 - we have our 10 tile right here
58:23 - and it's just a plain clear brown tile
58:26 - and if i come back to my map you can see
58:29 - that that is in fact valued at tile 10.
58:33 - so now you kind of understand or
58:34 - hopefully you understand the correlation
58:36 - between these values in a
58:38 - one-dimensional tile map
58:41 - and
58:42 - the images on screen
58:43 - as well as the locations of those images
58:48 - in the tile sheet image itself but just
58:51 - because we have the map doesn't mean
58:52 - we're actually drawing this stuff to the
58:54 - screen we actually have to write a
58:55 - function for that and that function is
58:57 - going to be inside of the display class
58:59 - and it's a function called draw map
59:02 - and it's just going to take the map
59:04 - which is just that array of values so
59:05 - it's just going to be this i'm going to
59:07 - hand in
59:08 - and the number of columns in the map and
59:10 - we have 12 columns on our map i define
59:12 - that here 12 columns if you count i
59:14 - actually have 1 2 3 4 all the way to 12
59:16 - columns inside of my map if you look at
59:19 - the screen you can count 12 tiles across
59:22 - so this draw map function is just going
59:24 - to take the map and it's going to take
59:25 - the columns and it's going to loop
59:27 - through every single value in the map
59:30 - so it's going to loop through every
59:31 - single number right here
59:34 - and it's going to get the value there i
59:37 - subtract 1 from it and that's going to
59:40 - if i don't subtract 1 this is what
59:42 - happens
59:44 - if i just add 0 let's take a look real
59:46 - quick and see what happens and i'll show
59:48 - you a really simple way to remedy this
59:50 - which i didn't use because i used the
59:52 - tile map editor to make this because i
59:53 - have really complex tiles here but this
59:56 - is what it looks like it's because all
59:57 - of my tile values are offset by one
60:01 - now i set it back to negative one the
60:02 - reason for that is
60:04 - in my tile map these are all one higher
60:08 - than they should be so this should
60:09 - actually be 17
60:11 - this should be 48 this should be 49
60:14 - this should be 31.
60:16 - they're all offset by one that's just
60:18 - because the tilemap editor i use which
60:20 - is tiled exports the comma separated
60:23 - values
60:24 - uh starting at one instead of zero i
60:27 - didn't feel like going through and
60:28 - changing all these so hopefully this
60:29 - doesn't throw you guys off too much
60:31 - don't worry about it when you make your
60:32 - maps just make sure you have the right
60:34 - value starting at index zero in your
60:36 - tile sheet so basically instead of this
60:38 - being one it would be zero and you start
60:41 - counting from zero
60:43 - but if you want to use a map editor like
60:46 - tiled and you don't mind just having
60:48 - that offset
60:49 - it's really simple all you have to do is
60:50 - subtract one from the tile value and
60:52 - you're good to go so anyway that aside
60:55 - let's get into how i'm actually placing
60:57 - those images from the source onto the
60:59 - buffer and then drawing it on the screen
61:01 - so i get the different values or i get
61:04 - the value of the specific tile in the
61:05 - map that i'm looping over
61:08 - i get the source
61:09 - x and y position that i'm going to cut
61:11 - it out of the tile sheet at
61:13 - and that's what this code right here
61:15 - does
61:16 - it just takes the number of columns in
61:18 - the tile sheet takes the value
61:20 - that gets the column and then you
61:22 - multiply by the tile size
61:25 - to get the actual position to cut out of
61:27 - inside of the tile sheet image
61:30 - oh didn't mean to do that
61:32 - but that's basically just getting the x
61:33 - position to start cutting out of uh
61:36 - come back in here then we have the y
61:38 - value that's going to get the y position
61:40 - to start cutting out of and then
61:42 - when you get the source you're going to
61:44 - hand in the source x and y which is just
61:46 - these two values here and the tile
61:49 - height
61:50 - and tile width which i just have one of
61:52 - it's tile size and it's 16 pixels so
61:54 - source x and source y
61:57 - are going to get me to the appropriate
61:58 - tile say i am at tile
62:01 - 8
62:02 - that's going to put me right here
62:04 - it would actually be a value of 7 but
62:05 - that's going to put me right here
62:07 - and then i'm going to cut 16 pixels wide
62:10 - and 16 pixels high so the y value would
62:13 - be 0 the x value would be
62:17 - 128 minus 16 to get me right here to the
62:20 - left side of this tile and then because
62:22 - 120 is the width of my map and it's just
62:25 - going to cut this tile out
62:27 - so pretty simple
62:29 - come back here display look the rest of
62:30 - this destination it kind of looks like
62:32 - the same kind of mathematical formula
62:35 - i'm just using the number of columns in
62:37 - my game world which you remember is 12
62:39 - so that's the number of columns in this
62:40 - map
62:41 - and
62:42 - i'm multiplying that by 16 as well
62:47 - now i guess i should be using the
62:49 - game.world
62:51 - dot tile size but i'm just using 16 for
62:54 - both so i guess it doesn't really matter
62:56 - and then finally you're going to use
62:58 - this information to cut the appropriate
63:00 - image out of your tilesheet image and
63:03 - draw it into your buffer which is then
63:06 - going to be drawn to the final on-screen
63:09 - canvas so you're just going to say
63:11 - i want to draw an image to my buffer
63:14 - from the tile sheet image
63:17 - and i'm going to cut the image out of
63:18 - the tile sheet out at source x and
63:20 - source y
63:22 - and
63:23 - tile size width and tile size height i'm
63:26 - going to draw it to the buffer at
63:27 - destination x destination y at the
63:31 - 16
63:32 - by 16 width and height
63:34 - so that's all that does and then if i
63:35 - come out here into my main js file and i
63:39 - come down to the or up rather to the
63:42 - render function you can see that i'm
63:44 - calling the
63:45 - display.drawmap function i'm handing in
63:47 - the game.world.map
63:49 - and thegame.world.coms into that
63:51 - function and that is how
63:55 - you draw all those tiles to the game
63:58 - screen
63:59 - i talked about how to load a sprite
64:01 - sheet image into your javascript how to
64:03 - create a tile map array and how to draw
64:05 - tiles from the sprite sheet to to
64:07 - display canvas if you're worried that
64:09 - there was a lot of code i didn't cover
64:11 - don't all you need to know is how these
64:13 - basic components work together in order
64:15 - to build them yourself chances are your
64:17 - application structure will be different
64:18 - from mine so don't focus too much on
64:20 - what i didn't show you and instead try
64:21 - to build the components i'm talking
64:23 - about into your own application
64:25 - this stuff really works and if you need
64:26 - the source code you can find it on my
64:28 - github page
64:30 - i'm going to show you the aspiring game
64:32 - programmer how to add pixel perfect
64:34 - professional quality tile-based
64:36 - collision detection and response to a
64:38 - platforming game i'm going to talk about
64:40 - what's changed since part three then i'm
64:42 - going to go over the three main
64:44 - components of my collision system
64:46 - there's the broad phase the routing
64:47 - function and finally the narrow phase
64:50 - let's take a look at what's changed
64:52 - since part three so this is part four it
64:54 - looks just like part three for the most
64:56 - part except now i have collision
64:59 - detection and response between my player
65:01 - character and the game world so as you
65:03 - can see i'm i'm moving smoothly across
65:05 - the tops of the tiles i'm jumping up
65:07 - along the sides of the tiles i'm not
65:09 - getting hung up on any of the edges
65:11 - anywhere i can jump through the bottoms
65:13 - of these platform tiles basically i have
65:15 - pixel perfect tile based collision
65:17 - detection and response and everything
65:20 - looks and works the way you would expect
65:22 - it to in a tile-based platforming game
65:24 - so now that you know what the example is
65:26 - all about let's take a look at what's
65:28 - changed in the code so the only two
65:30 - files that have changed since part three
65:32 - are the game file which holds the game
65:33 - class and the display file which holds
65:36 - the display class
65:37 - display had a minor change since part
65:39 - three if you remember part three i had
65:41 - an issue with the export values for my
65:44 - tile map because i used the tile map
65:46 - editor and all the values were offset by
65:49 - one so i just changed this function and
65:52 - i changed my tile map values to what
65:54 - they're supposed to be so i got rid of
65:56 - the offset as you see i have the comment
65:58 - no longer subtracting one take a look at
66:00 - part three so you can see what i'm
66:01 - talking about also in here in the draw
66:03 - player class i change math.
66:06 - floor to math.round in this line and
66:08 - this line here and the reason is because
66:11 - it just rounds my player to the
66:13 - appropriate
66:14 - spot that he's going to be drawn in more
66:16 - smoothly so those are two really minor
66:19 - changes in the display
66:20 - file inside the game file a lot has
66:23 - changed i've added
66:25 - the
66:26 - collider function i've added my
66:29 - collision map which is this guy right
66:31 - here a collision map is different than
66:32 - the graphical map for the tiles
66:34 - themselves that you see on the screen
66:36 - these are for the collision shapes
66:38 - uh down here i've amended my collide
66:41 - object function inside of the world
66:42 - class
66:43 - to do the broad phase collision
66:45 - detection and response that are
66:47 - these functions right here
66:50 - then i've also added the collider class
66:53 - the collider class takes care of the
66:54 - routing function as well as all of the
66:57 - narrow phase collision methods like
66:59 - collide platform bottom so cloud
67:01 - platform bottom would be called whenever
67:03 - you
67:04 - physically clyde you're the top of the
67:06 - player with the bottom of a platform so
67:08 - i'm jumping up and clyde platform bottom
67:10 - is firing every time my player hits his
67:12 - head on the bottom of that tile there
67:15 - so
67:16 - that's what that does then i've also
67:18 - added a bass class for the player object
67:21 - called object and that's nested inside a
67:24 - game.world
67:25 - the object is basically just a simple
67:28 - rectangle class
67:29 - and i'm going to talk about x-old and
67:31 - wild and why we need those
67:33 - later on in a different part in this
67:35 - video
67:36 - but basically the object class is just
67:39 - the superclass of the player class now
67:42 - basically the player is going to inherit
67:44 - all of these values from object and it's
67:46 - going to get all of these neat little
67:47 - helper functions to get the different
67:49 - sides of his
67:51 - rectangle
67:53 - so that's all that does and then down
67:54 - here you can see i'm actually extending
67:57 - the object class inside of the player
67:59 - constructor
68:00 - and
68:01 - down here i'm actually extending the
68:05 - player prototype off of the object
68:07 - prototype with object.sine
68:10 - so those are all the changes in part
68:11 - four stay tuned for the rest of the
68:13 - video
68:15 - there are three main components to this
68:17 - approach to tile based collision
68:18 - detection response and those are the
68:20 - broad phase the routing function and the
68:24 - narrow phase and they're all centered
68:25 - around having a collision map full of
68:28 - collision tile values each value
68:30 - represents a different shape or
68:32 - collision shape so for instance if i hop
68:35 - over here i can jump through the bottom
68:36 - of this tile but not fall through the
68:38 - top of this tile here i can cloud with
68:40 - the bottom i can collide with the
68:42 - right side and i can collide with the
68:43 - top of that as well this tile over here
68:46 - these two i can collide with the left
68:47 - side so all of these tile values
68:49 - correspond to
68:51 - collision shapes
68:53 - that have different sides
68:55 - so the broad phase
68:56 - gets what tile my player character is
68:59 - standing on it determines what the value
69:02 - of that tile is that my player character
69:03 - is standing on gets that value from the
69:06 - collision map
69:07 - it then hands that value as well as the
69:10 - player object into the routing function
69:14 - the routing function checks the value in
69:16 - a switch statement and it says okay well
69:18 - let's check for instance i'm standing on
69:20 - top of tile one here
69:22 - this is tile one so the routing function
69:24 - would say okay you're colliding with
69:26 - tile type one
69:27 - and for tile type one i'm going to call
69:30 - a certain set of narrow phase collision
69:33 - detection and response methods so the
69:35 - broad phase determines what the tile
69:37 - value is the routing function determines
69:39 - which narrow phase functions to call and
69:41 - the narrow phase does the final
69:43 - collision detection and response
69:46 - and that's how the system works so stay
69:48 - tuned and i'm going to go into the code
69:49 - that makes that stuff work in detail
69:53 - all right so now i want to talk about
69:55 - the broad phase collision method and
69:57 - that is going to be the collide object
69:59 - function which is located inside of the
70:01 - game.world class so i'm going to come
70:04 - down here and show you what this broad
70:05 - phase does
70:07 - the whole function all it does is first
70:09 - it checks for collision with the
70:10 - outsides of the world and that's going
70:12 - to be this right here that's from part
70:14 - three that's pretty simple stuff and
70:16 - then the other thing it does is it
70:18 - checks all of the different corners all
70:20 - four corners of our player character so
70:22 - i have these four
70:24 - chunks of code i have one here for the
70:26 - top left i have one for the top right
70:28 - one for the bottom left one for the
70:30 - bottom right and that's the end of the
70:31 - function
70:32 - so this is the entire broad phase just
70:34 - these four chunks
70:35 - and this chunk up here which does
70:37 - collision with the boundaries of the
70:38 - world so let's take a look at the first
70:40 - chunk that tests
70:42 - for broad phase collision with the
70:44 - collision map
70:45 - with the top left corner of our player
70:47 - character so
70:49 - what these are are
70:51 - a row and a column value inside of our
70:54 - collision map so top is going to be the
70:56 - row that the top side of our player is
70:57 - in and left is going to be the column
71:00 - that the left side of our player is in
71:02 - so this is going to be the top of our
71:03 - player this is going to be the left side
71:04 - of our player and this is going to be
71:06 - the row that the top is in
71:08 - now if i move the player over here this
71:11 - is going to be the row that he's in and
71:13 - if i check the left side this is going
71:14 - to be the column that he's in if i move
71:16 - him over here now the left side of the
71:18 - player is in this column
71:20 - so pretty simple the math that we use to
71:22 - get the row and column and convert it
71:24 - from the physical
71:26 - xy position of the player to the
71:29 - one-dimensional index
71:31 - or of a row or column value
71:34 - it's not really one-dimensional it's
71:35 - two-dimensional just simplified
71:37 - basically you just get the top of the
71:39 - object which is the y position at the
71:40 - top of the object you divide by tile
71:42 - size that gives you the row of the top
71:45 - and then you do the same thing for the
71:48 - column you just get the left side of the
71:50 - object which is right here you divide it
71:52 - by tile size that's going to give you
71:54 - the column value
71:56 - and then you're going to go ahead and
71:58 - convert those
72:00 - the row and the column
72:02 - into a
72:03 - index inside of our map array or
72:06 - collision map array and you just do that
72:08 - by multiplying the row by the number of
72:10 - columns
72:11 - inside of the collision map ours was 12
72:14 - and then you add the column that the
72:16 - player is standing in so that's the row
72:19 - of the side of the player multiplied by
72:21 - the number of columns in the collision
72:23 - map plus the column of the side of the
72:26 - player
72:28 - pretty simple
72:29 - and then you go ahead and you hand in
72:31 - that value as well as the
72:34 - uh row and column positions of the tile
72:39 - multiplied by tile size to give you the
72:41 - actual x and y position of the tile so
72:44 - for instance if i was going to get the
72:45 - top left of my player that would be
72:47 - right here he's inside of this tile the
72:50 - top and left values multiplied by the
72:52 - tile size is going to give you this
72:54 - position right here which is going to be
72:56 - the x and y position of the tile so
72:58 - we're going to hand all that information
73:00 - into the colliders
73:02 - collide method and that's going to be
73:04 - the routing function you're going to
73:05 - hand in the value you're going to hand
73:06 - in the object you're going to hand in
73:08 - the left side of the tile and you're
73:10 - going to hand in the top side of the
73:11 - tile
73:12 - you're also going to hand in the
73:14 - tile size
73:16 - and then you just go ahead and you do
73:17 - this for every corner of the player
73:20 - so we just did the top left
73:23 - down here we're going to do the top
73:24 - right
73:25 - then we do the bottom left
73:28 - bottom left there we go and we do the
73:31 - bottom right
73:32 - and we just do that for all four corners
73:34 - now you might be thinking well you're
73:36 - redefining some values
73:38 - that you're reusing so
73:40 - why not just define for instance
73:43 - here we go let me find a good example
73:44 - here
73:45 - right so this is checking the top right
73:47 - corner right this right here and this is
73:50 - checking the bottom right corner well
73:52 - i'm defining right two times but
73:55 - why would i do that well the reason i'm
73:57 - doing that is because
73:58 - here i'm defining right and i'm checking
74:00 - for collision if i have a collision and
74:02 - i respond to it my player character is
74:04 - going to move and right as i defined it
74:07 - here might not be the same anymore so
74:10 - down here when i'm getting the right
74:11 - side of the player again i'm not going
74:13 - to want to use this old
74:15 - value for right i'm going to want to get
74:17 - the right side of my player again
74:19 - because it might be different than it
74:20 - was when i checked collision with the
74:22 - top right
74:23 - so i check collision with the top right
74:25 - if there is in fact a collision up here
74:26 - it's going to move my player
74:28 - and then i check oh this is the top
74:30 - right i keep getting confused there but
74:33 - then when i check the bottom right
74:35 - if i moved that value is going to have
74:37 - to be redefined to get the appropriate
74:40 - new location of the player's right side
74:42 - after he
74:44 - had collision resolved with the top
74:45 - right corner
74:47 - so
74:48 - this is the broad phase it's not as
74:50 - complicated as you think it's really
74:52 - simple the math is really simple you're
74:54 - just getting a value out of an array
74:56 - based on a player's column
74:59 - and row or
75:01 - row and column rather and then you're
75:03 - handing all that information into the
75:05 - routing function we're going to take a
75:06 - look at the routing function in the next
75:08 - part of the video now let's take a look
75:11 - at the routing function so i'm going to
75:13 - come down here to the routing function
75:15 - and that is going to be in the
75:17 - game.world.collider class and it's going
75:19 - to be called collide so the collide
75:22 - function is my routing function and all
75:24 - it does is it takes the tile value the
75:26 - object and tiles x and y position as
75:29 - well as the tile size which is the
75:30 - tile's width and height
75:32 - and it takes all that from broad phase
75:34 - and it hands in the value of the tile
75:37 - into a big switch statement which then
75:40 - routes you and that's why i call it a
75:41 - routing function it routes you to the
75:43 - appropriate narrow phase collision
75:44 - methods and it also does some tweaking
75:47 - to the tiles so
75:48 - for instance
75:50 - case one if i move my player down here
75:52 - i'm actually gonna be standing on a one
75:54 - tile i know for a fact this here is a
75:56 - one tile
75:57 - and
75:58 - it's gonna call collide platform top and
76:01 - it's gonna hand in the object so that's
76:03 - gonna be my player character it's going
76:05 - to hand in tile y not tile x because we
76:08 - don't need it in this case we just need
76:09 - to know what the top of the tile is
76:12 - going to be
76:12 - now if i want this to be a little bit
76:15 - lower say i want to make a half tile i'm
76:17 - just going to hack this right now but
76:19 - i'm going to put in
76:21 - plus 8 and i know for a fact that 8 is
76:24 - half of my tile height so that's going
76:27 - to be
76:27 - didn't mean to do that
76:29 - that's going to be my change that i made
76:31 - i saved my file i'm going to refresh my
76:32 - screen
76:33 - now as you can see all the one tiles
76:35 - that i'm colliding with are going to
76:37 - have half height
76:39 - so this tile right here i'm now going to
76:42 - be colliding with a value that's a
76:44 - little bit lower
76:46 - interesting so i can take my narrow
76:48 - phase functions and i can tweak them a
76:50 - little bit inside of my routing function
76:52 - and that's going to give me the ability
76:54 - to create a whole bunch of different
76:55 - tile types
76:57 - however i want so all the different
76:59 - shapes are going to be defined basically
77:01 - inside of the routing function
77:03 - and all it really does is gets the tile
77:05 - value and links it to
77:07 - a certain set of narrow face functions
77:09 - let's take a look at
77:11 - let's see what i got here let's take a
77:13 - look at something a little more complex
77:17 - first i'm going to have to see what
77:18 - tiles are what because i can't think
77:20 - right off the top of my head what those
77:21 - values actually stand for but if i look
77:23 - at my map
77:24 - i'm going to come over here to a 13 tile
77:26 - and that looks to be
77:28 - at the left side of this t right here so
77:31 - 13 is going to be oh wait i forgot to
77:33 - refresh my screen let's refresh and get
77:35 - functionality back to normal so 13 is
77:38 - going to be this tile right here that
77:39 - i'm standing on now
77:41 - so let's take a look in the routing
77:42 - function at
77:45 - the
77:45 - 13 tile
77:48 - all right here we go it's going to call
77:50 - the methods
77:52 - collide platform top clyde platform left
77:55 - and collide platform bottom and the
77:57 - reason for that is because i'm going to
77:59 - collide with the
78:02 - left side
78:04 - of this tile cloud with the left side
78:06 - maybe if i can actually hit it with the
78:08 - left side i'm going to cloud with the
78:09 - bottom and i'm also going to collide
78:11 - with the top so those are the three
78:13 - sides that i'm going to be able to
78:14 - collide with if i happen to meet a
78:16 - tile with a value of 13.
78:18 - now the reason i have some of these
78:20 - functions nested inside of if statements
78:22 - is because i can only collide with one
78:24 - of those sides of a tile at a time
78:26 - so i can only collide with the top and
78:28 - if i do i can't possibly be climbing
78:29 - with the left or the bottom certainly
78:31 - not the bottom if i'm coming from the
78:32 - top how would i cut with the bottom so
78:35 - i use these if statements to early out
78:39 - of my routing function and not have to
78:41 - execute checks for these other two
78:44 - functions which is great because for any
78:45 - given tile we're only checking
78:47 - collisions on sides until we actually do
78:50 - collision and then we just exit out we
78:52 - don't have to check the rest of the
78:54 - collision so
78:56 - clyde platform top is going to be in
78:58 - this if statement
78:59 - if i collide with platform top then i'm
79:02 - no longer going to have to check for
79:05 - colliding with the left side or
79:07 - colliding with the bottom side of the
79:08 - tile
79:10 - now inside of my narrow phase
79:12 - my function returns true if i do in fact
79:14 - have a collision and it is resolved and
79:16 - returns false if no collision was
79:18 - detected and nothing was resolved and if
79:20 - that's the case if it's false it'll just
79:22 - jump down to this next
79:24 - narrow phase collision method call that
79:26 - if there's no collision there it will
79:27 - jump finally to the last method in the
79:30 - case
79:31 - and call that and if that doesn't return
79:34 - true then there is no collision and
79:36 - nothing gets resolved
79:38 - so that's the routing function pretty
79:39 - simple that's how it works uh in
79:41 - previous tutorials on how to do this
79:44 - systems tile based collision system i
79:45 - used an array
79:47 - and i used um
79:49 - objects object references to get these
79:52 - but actually it's much much faster to
79:54 - use a switch statement
79:56 - so that's why i made the switch to a
79:57 - switch statement pun intended there so
80:00 - anyway next step onto the narrow phase
80:04 - now let's look at the narrow phase and
80:07 - that is going to be
80:10 - farther down inside of the collider
80:12 - classes
80:14 - prototype so inside the cladder classes
80:16 - prototype i have four functions and
80:18 - those are collide platform bottom
80:20 - cloud platform left
80:22 - clyde platform right and cloud platform
80:25 - top and
80:27 - awesomely enough with these four
80:29 - functions we can do collision detection
80:31 - and response with all of the different
80:34 - tile types basically any tile that has
80:37 - four sides we can take these four
80:38 - functions and combine them
80:41 - to get all kinds of different
80:43 - combinations up to 15 combinations which
80:45 - is as many combinations as you can have
80:47 - with a
80:49 - four-sided tile
80:50 - so
80:52 - let's take a look at let's see here
80:55 - clyde platform top where i think i was
80:57 - on alright let's take a look at cloud
80:58 - platform top and see how this actually
81:00 - works so from the routing function
81:02 - you're going to get the object and
81:04 - you're going to get the top side of the
81:05 - tile so top side of the tile is just
81:08 - going to be whatever the top of the tile
81:10 - is that you're standing on so right now
81:11 - i'm standing on this tile i have my
81:13 - object i have the top of my tile and
81:17 - we're just going to run an if statement
81:19 - that checks to see if the bottom of our
81:21 - player character is greater than the
81:23 - tile top and if it is
81:25 - then we run this code but wait there's
81:28 - more there's an and in here so we've got
81:30 - to see what that is too we're also going
81:32 - to check to see if
81:34 - the bottom
81:36 - of the player from the last frame of
81:38 - animation is above the tile top now if
81:41 - you didn't include this it would still
81:43 - work but
81:45 - it would not work as smoothly as you see
81:48 - here so let's go ahead and comment this
81:50 - out and see what happens when we don't
81:52 - use the old position
81:54 - from the last frame of the player
81:56 - character i'm going to comment that out
81:58 - i'm going to save i'm going to come in
81:59 - here i'm going to refresh and now let's
82:02 - see what we get
82:04 - everything might work perfectly but oh
82:06 - wait how about that i just jumped right
82:07 - through that tile now the reason for
82:09 - that is
82:11 - the when i jump up the top left and top
82:14 - right corners of my player are going to
82:16 - enter into this tile space the broad
82:19 - phase is going to detect that it's going
82:20 - to hand the information to the the
82:22 - routing function and the routing
82:24 - function is going to call
82:25 - collide platform top
82:27 - now cloud platform top
82:30 - without
82:31 - doing this check on the last position
82:33 - that the bottom of the player was in the
82:35 - last frame of animation without that
82:37 - it's just going to check to see is the
82:39 - bottom of the player greater than the
82:41 - tile top and if it is
82:43 - set it to
82:44 - the
82:45 - top of the tile so that's what's
82:47 - happening
82:48 - when i enter into the tile it detects
82:49 - that the player was
82:51 - below the top of the tile and it just
82:53 - sets it right to the top so that's the
82:55 - functionality you're gonna get
82:57 - without this
83:00 - when you add this in basically what's
83:02 - happening is it's saying
83:05 - hang on let me refresh real quick
83:06 - basically it's saying
83:08 - okay
83:10 - the
83:11 - bottom of my player may be inside of
83:13 - this tile but if on the last frame it
83:17 - wasn't up here and therefore entering
83:20 - into this tile between frames so on
83:22 - frame one he's going to be here on frame
83:23 - two with the force of gravity he's going
83:25 - to be down here inside the tile he's
83:27 - going to be entering in through the top
83:29 - and collide platform top is going to
83:31 - detect that inside of this if statement
83:33 - because the bottom on the current frame
83:35 - is going to be below the tile top
83:37 - and the bottom on the last frame is
83:39 - going to be above the tile top
83:42 - so
83:43 - that's going to be true and then we're
83:45 - going to get the appropriate response
83:46 - that we expect and we're no longer going
83:48 - to jump through the bottom of the tile
83:51 - and get that kind of glitchy looking
83:54 - collision response
83:55 - so
83:56 - now let's take a look at what happens
83:58 - after we do that after we collide with
84:00 - the top of the tile so i'm going to
84:01 - cloud the top of my tile here
84:03 - this is going to be true the bottom on
84:05 - the current frame is going to be
84:06 - slightly below the bottom on the
84:08 - previous frame is going to be above
84:10 - and
84:12 - what i'm going to do is i'm going to set
84:13 - the bottom of the object i'm going to
84:15 - set this bottom of the object to the
84:17 - tile top and i'm going to subtract this
84:19 - little value here i'm going to get into
84:21 - why i subtract that value in a minute
84:22 - i'm going to take a look at another
84:24 - function because that better explains
84:26 - why i do that i'm going to set y
84:28 - velocity to zero this way gravity
84:30 - doesn't keep increasing
84:32 - and eventually pull me through the tile
84:34 - altogether i'm going to set jumping to
84:36 - false so i can jump again
84:38 - and i'm going to return true so i can
84:39 - tell the routing function not to do any
84:42 - more narrow phase collision calls
84:45 - so now let's take a look at this little
84:47 - value and see what it does but i'm going
84:50 - to do it in the context of the
84:52 - collide platform left function because
84:54 - that also has a similar problem cloud
84:57 - platform write and cloud platform bottom
84:59 - don't have this problem and it has to do
85:01 - with rounding so let's just comment this
85:04 - out and see what happens but first i'm
85:06 - going to show you the desired
85:08 - functionality so right now i'm colliding
85:10 - with the left side of these two tiles
85:12 - and it's calling collide platform left
85:14 - to do that collision resolution
85:16 - so as you can see i can jump up and down
85:18 - and it's as you would expect i'm jumping
85:20 - up and falling down nothing is broken
85:22 - yet so let me comment this out and break
85:24 - the code i'm not really breaking the
85:26 - code it's all going to work the same
85:28 - it's just not going to have the desired
85:29 - effect i'm going to refresh my screen
85:31 - and i'm going to come over here and i'm
85:33 - going to do this again now when i jump
85:35 - i land on top of the tile and the reason
85:38 - for that is because when i'm falling
85:40 - down i'm actually going to be in this
85:42 - tile space with the right side of my
85:44 - player
85:45 - so the right side of my player when i'm
85:47 - falling down into this tile space is
85:50 - actually going to be in this tile space
85:52 - just looking at it with a naked eye it
85:53 - looks like he's fully inside of this
85:56 - column but really his right side is just
85:58 - barely inside of this column over here
86:01 - so unless we subtract
86:03 - that .01 or some tiny number doesn't
86:07 - have to be 0.01 it could probably be 0.1
86:09 - or 0.001 if you prefer
86:12 - because we subtract that
86:14 - we are pushing the player character out
86:16 - of this tile into this column and he's
86:19 - no longer touching this after he enters
86:21 - or exits collision with the left side of
86:23 - this tile space so let's refresh
86:25 - and see what that
86:26 - good functionality looks like now i'm
86:29 - colliding with the left side of this con
86:31 - this tile right here it's pushing me out
86:33 - of collision and it's actually pushing
86:35 - me out of the tile space entirely by .01
86:39 - pixels so when i jump
86:42 - i am fully inside of this column as you
86:44 - would expect and i'm no longer going to
86:46 - be colliding with these tiles unless i
86:48 - press right on my keyboard and move the
86:51 - player into them
86:52 - so that's why i have to subtract that
86:54 - little value now before i stop talking
86:57 - about the narrow phase collision let me
86:59 - just talk a little bit about
87:01 - object.getold right and how we actually
87:03 - do that so
87:05 - basically all we're doing is on every
87:06 - frame we are saving the
87:09 - last frames player position and we're
87:12 - getting the new frames
87:14 - new player position so
87:17 - where that happens is
87:20 - inside of the player object we actually
87:22 - come out here and
87:23 - look so we can actually see the code a
87:25 - little bit the player class now extends
87:27 - the object class and inside of the
87:29 - object class we have this is the
87:32 - object class right here
87:34 - inside of this we have some information
87:36 - to describe a rectangle
87:38 - and
87:39 - we're also going to have the x old and y
87:42 - old values
87:44 - so keep that in mind we have a x and y
87:47 - location we have the x and y location
87:49 - from the previous frame of animation so
87:50 - if i come down here to the
87:52 - player class
87:54 - and i come down here to his update
87:55 - function this is where we're going to be
87:57 - keeping track of this
87:58 - x old and y old are going to be updated
88:01 - on every frame of animation to equal
88:04 - that frame's current x and y position
88:08 - and then we're going to update x and y
88:10 - to be
88:11 - as fresh as possible in the new frame so
88:14 - we're basically just keeping track of
88:15 - the player's old x and y position from
88:17 - the last frame and his current x and y
88:20 - position from the current frame and that
88:22 - allows us to calculate his angle of
88:24 - trajectory and we can see
88:27 - based on that trajectory if he was above
88:30 - a tile before he entered into it
88:33 - and that will give us the ability to
88:36 - get rid of that broken functionality
88:38 - that you saw where i would jump up and
88:40 - just
88:41 - almost teleport through this tile and
88:43 - sit on top of it so that's why we have
88:45 - to keep track of this this is also great
88:47 - for interpolation which is something
88:50 - really useful for smooth animation but
88:51 - i'm not going to talk about that in this
88:53 - video anyway that is the narrow phase
88:55 - it's really simple the functions are all
88:58 - really really simple if you just take a
88:59 - look at the source code i urge you to go
89:01 - to the link in the video description and
89:03 - check that out on my github page
89:06 - and that's it
89:07 - i'm going to show you how i added sprite
89:09 - animation to the game so you can take my
89:11 - example and use it to put sprite
89:12 - animation into your own programs i'm
89:14 - going to talk about what's new in part
89:16 - 5. then i'll give you a very simple and
89:18 - brief refresher on how sprite animation
89:20 - works when using a sprite sheet and
89:22 - finally we'll take an in-depth look at
89:23 - the animator class and how it works with
89:25 - the player's movement to render the
89:26 - appropriate animations
89:28 - alrighty so the first thing i want to
89:30 - take a look at in part 5 is the example
89:32 - program and as you can see in this
89:34 - example program i no longer am working
89:36 - with the little white and gray square
89:39 - now i am working with this animated
89:41 - rabbit and he looks a lot better it's
89:43 - starting to look a lot more like a game
89:45 - that you can actually play just minus
89:47 - power-ups and items and stuff like that
89:49 - so
89:50 - basically not much has changed other
89:52 - than i've added an animator class that
89:54 - does the sprite animation and i've also
89:56 - tweaked his physics for jumping and
89:58 - stuff like that a little bit but that's
89:59 - pretty pretty common sense stuff
90:02 - kind of know how to do that if you're
90:03 - already to this point in the tutorial
90:04 - series so i'm not going to worry about
90:06 - the specific changes i made for this
90:08 - video instead i'm just going to worry
90:09 - about showing you guys how the animator
90:12 - class works to get this guy animated on
90:14 - the screen if you do want to see what
90:16 - has actually changed in the code since
90:18 - part four take a look at the source code
90:20 - that i've linked in the video
90:21 - description at the top of each file that
90:23 - has changed and for part five it's just
90:25 - these three the game the display and the
90:27 - main files for each file that has
90:30 - changes in it i've added a bulleted list
90:32 - in the comments at the top of each file
90:33 - that outlines what exactly has changed
90:36 - specifically in the code so if you want
90:38 - to find out what's changed take a look
90:39 - at the source code and take a look at
90:41 - these comments but in this video i'm
90:43 - just gonna focus on the animator class
90:45 - and how to get this dude animated on the
90:47 - screen so stay tuned and i'll show you
90:49 - how it's done now let's take a brief
90:51 - look at how sprite animation actually
90:53 - works when you're using a sprite sheet
90:55 - so this here is my sprite sheet images
90:57 - the png has all my tile graphics and it
91:00 - has my sprite images in it now each
91:02 - sprite animation is just a compilation
91:06 - of these different
91:07 - unique images so each image can be
91:11 - considered just a square that you would
91:13 - cut out of this bigger image and then
91:15 - put on the screen in quick succession to
91:17 - give yourself an animation so for
91:18 - instance right now my player character
91:20 - isn't doing anything he's just sitting
91:22 - still this frame is literally being cut
91:25 - from
91:26 - this position right here if you notice
91:28 - this and this are exactly the same image
91:32 - so currently he is displaying this frame
91:34 - of animation if i were to move him to
91:37 - the left now he's going to stand still
91:39 - he's going to be displaying this frame
91:42 - right here
91:43 - when he's walking it's going to give me
91:45 - an animation so i'm going to be playing
91:46 - those frames over and over again in
91:48 - quick succession
91:49 - it's kind of hard to tell because he's
91:51 - walking so fast but he's basically
91:53 - playing when i walk to the right he's
91:55 - playing this set of frames right here
91:56 - he's stepping through these four frames
91:59 - right here and that's going to give me
92:01 - my animation so what's happening is
92:04 - on every frame that i draw to the screen
92:06 - i'm going to see which
92:09 - frame that my player characters
92:11 - class is determining that he should show
92:14 - based on his movement pattern
92:16 - it's going to take that frame it's going
92:17 - to go into this tile sheet image is
92:20 - going to cut that specific frame out of
92:23 - the tile sheet it is then going to take
92:25 - that frame and draw it to the player's
92:27 - location on this
92:30 - display canvas this canvas element that
92:32 - i have in the browser window and you're
92:34 - going to see whatever frame that is
92:36 - supposed to be displayed and that's
92:37 - going to give you animation so that's
92:40 - basically how it works basically you're
92:41 - just cutting different images out of a
92:44 - bigger sprite sheet image and you're
92:45 - displaying those smaller images
92:48 - at the player's unique location on the
92:50 - screen now we're going to take an
92:52 - in-depth look at what makes the code
92:54 - actually work or i guess we're just
92:55 - going to take an in-depth look at the
92:56 - code because the code makes the code
92:58 - work so here i'm going to start with the
93:00 - frame class now the frame class is just
93:02 - going to define a rectangular region
93:04 - that we are going to cut our sprite
93:06 - images out of the tile sheet width so it
93:08 - has an x value y value width and a
93:10 - height and that's just going to be the
93:11 - source rectangle that defines the
93:15 - individual image inside of our sprite
93:17 - sheet so i'm going to use one of those
93:18 - frame classes to define each rectangular
93:21 - region
93:22 - for each one of these individual images
93:25 - so that's what the frame class is going
93:26 - to be for and just bear with me as i
93:29 - explain all these different classes and
93:31 - you'll see how they fit together at the
93:33 - end of this part of the video
93:34 - so don't worry about the offset x and y
93:37 - positions just yet i'll tell you about
93:39 - those later just keep in mind it's just
93:41 - a rectangular region for the moment
93:43 - now we're going to look at the tile set
93:46 - class and this used to be the tile sheet
93:47 - class inside of the display file but i
93:50 - moved it over to the game file basically
93:52 - the functionality is exactly the same i
93:53 - just renamed it and its location is
93:55 - different basically just keeps track of
93:56 - the number of columns and tile size of
93:59 - our rabbit trap sprite sheet image
94:02 - and
94:03 - that's it
94:04 - where animation comes in here is with
94:06 - the frames array so now we just talked
94:08 - about the frames class which is down
94:10 - there the frames class is just a
94:12 - rectangular region with an offset
94:14 - position
94:15 - each one of these values inside of this
94:17 - frames array is just going to be one of
94:19 - the rectangular regions that corresponds
94:21 - to a specific graphic for our animation
94:24 - so for example this frame is where the
94:26 - idle left graphic is inside of our
94:28 - sprite sheet
94:29 - this frame is where the jump left
94:31 - graphic is inside of our sprite sheet
94:34 - this group of frames is going to be
94:37 - where all of the individual graphics are
94:39 - for the walk left animation down here we
94:41 - got the walk right animation so
94:43 - basically all i'm doing is defining each
94:46 - rectangular region for every one of my
94:50 - sprite animation components or basically
94:52 - these individual images
94:55 - so now you know where the individual
94:58 - frames are going to be defined inside of
95:00 - the tile set class now we're actually
95:02 - going to have to define
95:05 - what those animations are so the
95:06 - animation itself is going to be defined
95:08 - by the object that's using it so the
95:11 - animation for this rabbit or for the
95:13 - player is going to live inside of the
95:16 - player class so every unique animation
95:18 - the idle
95:20 - frames the walking left and right frames
95:23 - the jump frames
95:25 - those are all going to be stored inside
95:27 - of the player class
95:30 - inside of its prototype so i'm just
95:31 - scrolling up to that here we have the
95:34 - player prototype and inside of it we
95:37 - have an object called frame sets
95:39 - and inside of frame sets we have all the
95:42 - different
95:44 - animations
95:45 - for the player we have as idle left jump
95:47 - left move left and then the right words
95:50 - motions for those different animations
95:52 - so each one of these values corresponds
95:55 - to a frame inside of our tile sets
95:57 - frames array so for example idle left
96:01 - is going to
96:02 - have a value of 0 in it and 0 is going
96:05 - to be the frame index or the index
96:07 - inside of our frames array where
96:10 - the
96:11 - rectangular region is defined to cut the
96:13 - image out of the sprite sheet for the
96:15 - idle left animation and that's just
96:17 - going to be here so this is index 0
96:19 - inside of our frames array it's idle
96:21 - left and that's what we're going to use
96:24 - for the idle left animation of our
96:26 - player
96:27 - and that's why that value is going to be
96:29 - a zero
96:30 - so as you can see each one of these
96:32 - values just corresponds to a different
96:34 - frame inside of the frame's array and
96:37 - what a frame is it's just a rectangular
96:38 - region that we use to cut out our sprite
96:40 - sheet images from the sprite sheet
96:43 - so how do we actually animate these
96:46 - that's going to be our next class that
96:48 - we look at and that's going to be the
96:49 - animator class so i'm going to scroll up
96:51 - to the animator class and i'm going to
96:52 - take a look at what this guy does
96:55 - so
96:56 - here's the animator class it's a
97:00 - frame rate dependent animation class so
97:02 - what that means is
97:05 - the rate of frames that you see for each
97:07 - animation is going to be totally
97:09 - dependent on the game engine's frame
97:11 - rate so if you don't want that kind of
97:12 - functionality this probably isn't for
97:14 - you but if you're just going to run your
97:16 - game consistently at 30 frames per
97:17 - second across all devices this is
97:19 - probably what you want to do and for
97:21 - html5 games that's a pretty good bet so
97:23 - this will probably work for you so
97:26 - i define a couple different values in
97:28 - here i have count delay frame set frame
97:31 - set is going to be
97:33 - those different frame sets or those
97:35 - different animation arrays that i define
97:36 - inside the player so for example frame
97:39 - set could be
97:41 - i'm going to scroll down here it could
97:43 - be
97:44 - any one of
97:45 - these animations it could be idle left
97:48 - it could be this array right here it
97:49 - could be move left
97:51 - which is that array right there could be
97:53 - any one of those and basically it's just
97:55 - going to use that information and loop
97:57 - through it
97:58 - when it does my animation
98:01 - think i went too far here we go so the
98:04 - frame set is just going to be one of
98:05 - those arrays with those values and those
98:07 - values of course correspond to our
98:08 - different frames that we use to cut the
98:10 - animation image out of the sprite sheet
98:13 - frame index is just going to be where we
98:15 - are or where the play head is so to
98:17 - speak inside of that frame set array
98:20 - frame value is going to be the value
98:23 - of whatever
98:24 - index we're in inside of our frame set
98:26 - so for idle left remember that was value
98:29 - zero the value was zero
98:31 - so for that particular animation it
98:33 - would be at index zero inside the frame
98:36 - set and the value would also be zero for
98:38 - the idle left image
98:41 - and then we have mode mode right now for
98:44 - this example
98:45 - there are only two modes we have pause
98:47 - and we have loop
98:49 - now pause and loop are just going to be
98:51 - the two types of playback that we want
98:53 - our animations to do
98:55 - so
98:56 - pretty simply i'm going to just explain
98:58 - that as we go i'm going to come down to
99:00 - the loop function
99:03 - all it does is
99:05 - it just changes the playhead position
99:08 - every so many frames that pass in our
99:10 - game loop so count is going to increase
99:12 - one time on every cycle of our game loop
99:15 - until
99:16 - it reaches the delay that we specify so
99:18 - for the walking left and right
99:21 - animations i've i've defined a delay of
99:24 - five
99:24 - inside of the player class
99:26 - so every five frames of our game loops
99:29 - animation
99:30 - or cycle
99:32 - we are going to
99:33 - run the code inside of this while loop
99:37 - so count we're just going to decrease
99:39 - that by delay and that makes us wait
99:41 - again
99:42 - frame index this is where we set the
99:44 - frame index or the playhead inside of
99:46 - our animation basically this we're just
99:48 - going to say is the frame index
99:50 - currently less than the frameset.length
99:53 - so let's take a visual look at what's
99:55 - going on here
99:57 - inside of our rabbit trap png so let's
100:01 - say the frame set that we're going to
100:02 - use has values that correspond to the
100:05 - walking right animation which is going
100:06 - to be these four frames right here
100:10 - so
100:11 - frame index at zero is going to yield a
100:14 - frame value of this image right here at
100:18 - frame index of one i'm going to move
100:19 - over one it's going to be a value that
100:22 - corresponds to this image right here
100:24 - when i move it over again it's going to
100:25 - correspond to this image right here so
100:27 - basically what the code inside of the
100:28 - loop function is doing
100:30 - is it's just increasing my frame index
100:32 - by 1 until it reaches the end of the
100:35 - frame set
100:36 - and when it reaches the end of the frame
100:38 - set the next time it goes to increase
100:40 - instead it just sets it back to zero so
100:42 - inside of my
100:44 - loop function
100:47 - all that we're going to do is just say
100:50 - set the frame index equal to
100:53 - the frame index plus one if it's not yet
100:56 - past the end of our frame set length and
100:59 - if it is past the end of the frame set
101:01 - length just set it to zero to restart
101:03 - the animation loop over again
101:05 - then finally what we do is we get the
101:07 - frame value that's just going to be
101:10 - the value that corresponds to the
101:12 - specific rectangular region that we
101:15 - store in the tile sets frames array that
101:17 - corresponds to the image that we're
101:18 - going to be cutting out of the sprite
101:19 - sheet so the frame value is just going
101:22 - to be set to whatever our frame set
101:24 - array is and we're going to hand in the
101:26 - index of
101:28 - the the playhead so whatever frame index
101:30 - is that's going to give us the value
101:32 - inside of our frame set that we're
101:34 - currently at in the animations loop
101:36 - cycle
101:38 - all right so that was a mouthful and
101:40 - hopefully i'm explaining everything
101:41 - quite well i think the next place we
101:44 - want to go is probably the render
101:46 - function but first i want to just touch
101:48 - on uh this functionality here the change
101:51 - frame set function inside of the
101:52 - animator class and basically what this
101:55 - does is it just changes what frame set
101:57 - we're using so whenever i press left on
102:00 - the keyboard i'm going to call change
102:01 - frame set it's just going to change the
102:03 - frame set to the left animation which is
102:06 - that array inside of the player class
102:07 - that defines which frames to use for the
102:09 - left animation
102:10 - uh when i press right it's going to call
102:13 - change frame set i'm going to hand in
102:14 - the player's right
102:16 - movement animation if i jump to the left
102:18 - i'm going to call change frame set i'm
102:20 - going to hand in the left animation you
102:22 - kind of get what i'm saying here then
102:24 - the only other function in here
102:26 - is going to be the animate function it
102:27 - just checks to see which mode we're in
102:29 - loop or pause
102:30 - pause is gonna be for
102:33 - no animation so pause is gonna be called
102:35 - on the idle animation so idle right
102:38 - and idle left pause is gonna be the play
102:41 - method that we use for the walking
102:42 - animations we're going to be using the
102:44 - loop method because we want to keep
102:46 - animating that cycle of frames over and
102:48 - over and over again and basically this
102:50 - is just called on every frame and it
102:51 - just calls the corresponding method it's
102:54 - pretty simple
102:55 - so now that we know how we're animating
102:57 - our frames let's actually take a look at
102:59 - the render function which lives inside
103:01 - of the main file and we're going to take
103:03 - a look at how we actually use that frame
103:06 - information to cut our image out of the
103:08 - sprite sheet itself
103:10 - so
103:11 - the first thing we do we're actually
103:13 - going to have to jump to another section
103:14 - of code real quick because i'm using an
103:16 - assets manager to load my tileset image
103:18 - so real quick i'm just going to jump up
103:20 - here check out the assets manager class
103:23 - all it is is an image
103:26 - and i'm going to load in an image with
103:30 - our
103:31 - rabbittrap.png image inside of it so
103:33 - really all that we're doing here is just
103:36 - using the assets manager to load our
103:38 - tilesheet
103:40 - really simple so
103:41 - that's all that is don't worry about it
103:43 - too much you could write your own code
103:45 - you don't need an assets manager all you
103:47 - need is to load up the tilesheet image
103:49 - to use it for drawing from that tile
103:51 - sheet image
103:52 - so
103:54 - here we go
103:56 - here's where we get the frame value so
103:58 - frame we're going to get the the frame
104:00 - remember is just that rectangular region
104:02 - but we're going to get to it
104:05 - through all those classes i just talked
104:07 - about so the animation class is going to
104:10 - give us a pointer to
104:12 - a frame value which lives inside of the
104:15 - frames
104:17 - array inside of the tile set class and
104:19 - then the tileset class is going to be
104:21 - using the frame class to define its
104:22 - rectangular regions to cut images out of
104:25 - the tilesheet image
104:26 - so
104:28 - how we get the frame is we just
104:30 - get the frames array from our games tile
104:33 - set
104:35 - then we go ahead and we hand in the
104:37 - player's current frame value which is
104:39 - kept up to date on every cycle of our
104:41 - game loop inside of the update function
104:43 - we're going to be calling player dot
104:45 - update animation and that's going to
104:47 - update our frame value
104:49 - inside of the
104:50 - loop function most likely of our
104:52 - animator class
104:54 - so
104:55 - draw object is going to take all this
104:57 - information and put it together to give
104:59 - us the appropriate image that we need to
105:02 - see to make our animation work on the
105:04 - screen so
105:06 - what we're going to do is we're going to
105:07 - hand in our source tile sheet image
105:09 - then we're going to hand in the actual
105:12 - source frames x and y position to cut
105:14 - from
105:15 - then this is going to look a little
105:17 - complex but it's really not we're going
105:18 - to hand in the players x location and y
105:21 - location
105:22 - and we're just going to add basically an
105:24 - offset where we want the frame to show
105:27 - up and be drawn to the screen so
105:30 - right now the player's frame is slightly
105:32 - offset from the player's real location
105:35 - and the reason i want that to happen is
105:37 - so when i stand on the edge of a tile i
105:39 - actually fall through and if you look
105:41 - his ears on the the frame are actually
105:44 - kind of moving through the tile if i go
105:46 - over here this the image itself is
105:48 - actually overlapping the tile i don't
105:50 - want it to be pixel perfect like that i
105:52 - want it to be
105:53 - functional i want the player to have fun
105:55 - i don't care about pixel perfect
105:57 - collision as much as i do the player
105:59 - having fun so
106:01 - this code basically what it does is it
106:03 - just repositions the frame a little bit
106:05 - to center it on the player's position so
106:07 - we can more easily move him around the
106:09 - screen without that
106:11 - pixel perfect collision that makes his
106:12 - hitbox seem a lot larger than it needs
106:15 - to be
106:16 - so all this does it gets his exposition
106:19 - it adds
106:20 - the
106:21 - center
106:22 - or it gets the center of where i want to
106:24 - draw that frame on top of the player by
106:26 - just getting half of his width
106:28 - subtracting half of the frame source
106:30 - frames with and then it just adds the
106:32 - frames offset x position
106:34 - if i don't add that offset x position
106:37 - and remember i was talking about that
106:38 - for the frame class if i come back into
106:40 - the frame class all the way at the
106:42 - bottom here
106:43 - we define the offset x and offset y and
106:46 - then when we actually instantiate each
106:48 - frame we're going to add
106:49 - negative 2 which is the going
106:52 - offset y position
106:54 - for this player if i don't add negative
106:56 - two
106:58 - this is what happens i just set it to
107:00 - zero i saved i'm going to come back in
107:02 - here as you can see now that was the y
107:04 - offset he's now two pixels deep into the
107:07 - ground and that does not look quite
107:09 - right so that's why i have that offset
107:11 - position all it does is add a slight
107:13 - offset
107:14 - when i draw the frame to the screen to
107:17 - make him appear in the appropriate
107:18 - location
107:20 - so that's it that's all that does you
107:21 - don't need this stuff like i said i i'm
107:24 - using a
107:25 - frame based approach you could easily
107:26 - use a tile based approach where you have
107:29 - all your graphics inside of one big grid
107:31 - kind of like the tiles are instead of
107:33 - having them all close together and
107:34 - cutting them out specifically the reason
107:36 - i do this is because if i were to add
107:39 - let's say my my rabbit has a sword and
107:41 - the sword comes out to here
107:43 - now my sprite is going to be different
107:45 - and it's not necessarily going to fit
107:46 - uniformly into a box or into a grid row
107:49 - and column cell with all the other
107:51 - sprites so i do it this way because
107:53 - sprites change they change in size they
107:56 - vary in size depending on what animation
107:58 - you're doing so this is just much more
108:00 - flexible for me so
108:02 - now let's get back into the rendering
108:04 - function went off on a little rant there
108:08 - so
108:09 - basically all the draw object function
108:11 - does of the display class is just draw
108:14 - from the tile set
108:15 - from the frame's x and y position
108:18 - and it draws to the screen whatever
108:21 - frame is currently in the animation in
108:24 - the player's animation draws that frame
108:26 - to the screen at a slight offset
108:27 - position
108:29 - then we call display.render and that
108:31 - draws everything to the screen including
108:32 - the tiles and whatever frame of
108:35 - animation our player is in
108:37 - alright so now let me just quickly see
108:39 - if i actually missed anything here i
108:41 - think i went over everything how
108:43 - everything works let me take a look
108:45 - inside of the
108:48 - player class itself and actually see how
108:50 - we're doing the players animation how
108:53 - we're actually deciding which frames to
108:55 - display and which frame sets to use
108:57 - this is going to be done inside of the
108:59 - update animation function
109:01 - so update animate animation is going to
109:03 - be called on every cycle of our game
109:05 - loop and it's basically just going to
109:07 - check to see what direction the player
109:09 - is facing and it's going to choose an
109:11 - animation based on that so the very
109:13 - first if statement inside of update
109:14 - animation is going to be
109:17 - is the player moving up which means is
109:19 - the player jumping up so if i press up
109:21 - on the keyboard the player is going to
109:22 - move up and if you look closely you can
109:24 - see that the up animation or the up
109:27 - frame is played briefly while he's
109:29 - moving up while he's moving down it
109:30 - switches back to
109:32 - idle
109:33 - left
109:34 - so
109:35 - if he is moving up and if his direction
109:38 - which is determined just by which
109:40 - direction he's facing so when i press
109:42 - the left key his direction is going to
109:44 - be negative one when i press the right
109:46 - key direction is going to be positive
109:48 - one
109:49 - so
109:50 - if his direction is negative one so if
109:52 - he's facing left i'm going to change his
109:54 - animation frame set to jump left
109:58 - if that's not the case and he's facing
110:00 - the right i'm going to change his
110:01 - animation frame set while he's jumping
110:03 - to jump right i'm going to do that in
110:05 - the pause position
110:07 - now for these other ones basically is he
110:10 - moving to the left if he is
110:12 - and his velocity is a certain
110:15 - amount
110:16 - then we're going to
110:18 - play the
110:19 - move left animation if the velocity is
110:22 - not a certain amount or less than that
110:24 - basically if he's basically stopped and
110:26 - his velocity is very small we're going
110:28 - to play idle left instead now this is
110:30 - cool because
110:32 - what this functionality allows us to do
110:34 - is it allows us to have our player
110:36 - gradually stop walking even though we're
110:38 - not pressing the walk key anymore so if
110:40 - i were to come in here and change this
110:42 - code to
110:44 - let's say this is the left walking
110:45 - animation
110:47 - what is this move left let's change this
110:49 - to
110:53 - two negative two
110:55 - and i saved i'm going to come up here
110:57 - refresh my screen
110:58 - now let's see what happens for the walk
111:00 - animation
111:02 - because i have to be moving at
111:06 - 2
111:07 - a velocity of 2 to the left the move
111:10 - animation doesn't actually run unless i
111:11 - hit that
111:13 - 2 pixels of movement velocity per frame
111:16 - so what this allows me to do is it
111:18 - allows me to create an effect where i
111:21 - gradually walk to a stop instead of just
111:24 - halting to a stop really hard like that
111:26 - so a better
111:28 - a better kind of example would be if i
111:30 - used one instead and i refresh the
111:32 - screen up here
111:34 - let's see what that looks like
111:36 - now i start walking right away because i
111:38 - hit a velocity of one to the left really
111:40 - quick but as soon as i stop
111:43 - i go into the idle animation and that's
111:45 - not really good because it looks like
111:46 - i'm sliding too much or maybe you do
111:48 - prefer that and that's the great thing
111:49 - about this code you can just do whatever
111:51 - you want i kind of like it where i'm
111:53 - just gonna gradually stop walking until
111:55 - i'm completely stopped i don't prefer to
111:57 - just automatically stop and slide on my
111:59 - feet like that so what i've done is i've
112:01 - just set a very small value
112:05 - for the
112:07 - velocity check and if he is moving
112:09 - slower than negative 0.1 pixels to the
112:13 - left
112:14 - then
112:15 - he's going to idle and if not he's going
112:17 - to continue walking until he just comes
112:19 - that gradual stop like that
112:21 - so that's pretty cool so basically the
112:23 - update animation function is fired on
112:25 - every frame after you do collision
112:26 - detection with the player in the world
112:28 - and
112:29 - it just determines what way he's moving
112:31 - and depending on what direction he's
112:33 - moving it runs a certain animation
112:35 - now this is actually really important
112:37 - it's more important than you think not
112:39 - necessarily for the player because you
112:41 - can
112:42 - have fine control over the player but
112:44 - for non-player characters who move on
112:46 - their own
112:47 - you have to determine their animation
112:49 - based on how they're moving because you
112:51 - don't control them you can't say play
112:53 - the run animation when i press the run
112:55 - key because you're not pressing a key
112:57 - for a non-player character for those
112:59 - non-player characters you have to keep
113:01 - track of
113:02 - what direction they're moving how
113:04 - they're moving and based on that you
113:06 - have to set their animation so that's
113:09 - what this code does
113:11 - it just automates the process of setting
113:12 - the animation it doesn't rely on key
113:15 - presses or user input it just sets the
113:17 - animation depending on what direction
113:19 - he's moving
113:21 - before i go any further with this series
113:23 - i want to address something called
113:25 - tunneling it presents major problems for
113:27 - any physics engine and tile based
113:28 - engines are no exception
113:30 - tunneling is sure to affect you
113:31 - particularly if you are writing your own
113:33 - physics engine so stay tuned while i
113:35 - talk about how to overcome this pesky
113:36 - glitch
113:38 - alright so let's take a look at what
113:39 - tunneling actually looks like so this is
113:41 - the part five example program and i
113:44 - haven't changed any of the code since
113:45 - part five
113:47 - but i just want to show you this one
113:49 - glitch that happens underneath this
113:51 - t-shaped structure of tiles when i am
113:53 - running into this tile from the right so
113:56 - i'm pressing down on the left key and i
113:57 - jump i actually pass into the tile
114:00 - now i can actually jump down below the
114:02 - tiles and walk around because of the
114:03 - nature of my tile-based collision code
114:05 - but obviously you don't want that to
114:07 - happen
114:08 - this actually isn't a problem with the
114:10 - collision code itself this is just a
114:12 - problem with tunneling and it seems to
114:14 - happen just in this one scenario so in
114:17 - order to show you guys better what's
114:19 - actually happening first i'm going to
114:20 - explain what tunneling is just using my
114:22 - mouse pointer as an example and then i'm
114:24 - going to show you in slow motion when i
114:26 - slow this game down i'm going to show
114:28 - you what's actually happening with the
114:29 - player and why tunneling is happening in
114:31 - this particular instance
114:33 - so tunneling is when the object moves
114:36 - too far in one frame to actually collide
114:39 - with a collision shape so
114:41 - let's say that
114:42 - this tile is going to be my collision
114:44 - shape and the mouse pointer is going to
114:46 - be my object so this is frame one on
114:49 - frame one my object is right here where
114:51 - the mouse pointer is and on frame two
114:54 - i'm going to move my object a little bit
114:57 - to the left so this is frame one this is
114:59 - frame two my object has moved about 16
115:02 - pixels to the left now this is okay
115:05 - because i'm not moving more than one
115:06 - tile space
115:08 - i'm actually going to be over top of
115:10 - this tile space it's going to detect
115:11 - that i'm colliding with it and it's
115:12 - going to move the mouse out of the
115:15 - collision and put it back into an empty
115:17 - tile space that's how it should work
115:20 - tunneling happens when the mouse moves
115:24 - much farther than
115:26 - one tile space or 16 pixels in this case
115:28 - over the course of one frame so if this
115:30 - is frame one and i move in frame two all
115:34 - the way to here
115:35 - what's happening is i'm jumping right
115:37 - from here all the way to here and i'm
115:39 - never detecting a collision with that
115:41 - tile because i'm never landing in it so
115:44 - tunneling is basically just moving a
115:46 - player object or any object too quickly
115:48 - to detect collision with a stationary
115:51 - collision object
115:53 - so
115:54 - now that you kind of understand what
115:55 - tunneling is let me slow this down and
115:57 - show you
115:58 - in action what the tunneling looks like
116:01 - with the player character so i'm going
116:03 - to save my code i'm going to set the
116:05 - frame rate to one frame per second
116:06 - that's going to slow things down a lot
116:08 - and i'm going to refresh now as you can
116:10 - see things are really really slow
116:13 - so
116:15 - i'm going to run over here into the
116:16 - corner and it's going to take a while so
116:18 - just bear with me but i'm going to show
116:20 - you this glitch in as slow motion as i
116:23 - think it should be i don't want to go
116:25 - any slower than this or would take
116:26 - forever
116:27 - so here i am i'm standing next to the
116:29 - tile i'm going to press
116:30 - up and i'm just going to jump straight
116:32 - up
116:34 - so i jumped up and immediately this tile
116:37 - up here resolves collision and throws me
116:39 - right back down below it
116:41 - but if i jump up while i'm pressing the
116:43 - left key
116:44 - i jump up
116:46 - and i move slightly to the left
116:48 - now
116:49 - that's when the tunneling occurs so the
116:51 - tunneling isn't actually happening on
116:53 - this tile right here it's actually
116:57 - it's kind of a special case but i'll
116:58 - show you why so i'm going to run back
117:00 - out here and i'm just going to jump up
117:02 - the tunneling is actually happening when
117:03 - i jump because the player character is
117:05 - moving about 20 pixels upwards
117:08 - as soon as i start jumping and you'll be
117:10 - able to see that
117:12 - when i jump here in a moment
117:15 - so
117:16 - i could actually get this thing to
117:18 - comply it's just moving so slowly
117:20 - all right so i'm gonna jump and just
117:22 - take note of where this player actually
117:24 - moves to when i jump
117:26 - so
117:27 - this is the
117:29 - top of the player right here this would
117:31 - be 16 pixels from the ground right here
117:34 - when i press the jump key
117:36 - immediately my player is above that 16
117:39 - pixels his feet were about right here
117:42 - and he clearly moves more than 16 pixels
117:44 - which is our tile space so if he can
117:46 - potentially move
117:49 - past one full tile space without
117:51 - stopping in it he can tunnel because
117:53 - tunneling is basically when on frame one
117:55 - we're out of collision on frame two we
117:57 - jump over
117:59 - a collision object and never touch it
118:01 - so what's happening here is when he
118:03 - jumps
118:05 - imagine what happens if he were standing
118:06 - right here he's going to jump up
118:09 - on the first frame
118:12 - his the top of his hitbox is actually
118:15 - going to be over top of this tile and
118:17 - the bottom of his hitbox is going to be
118:18 - inside of this tile so what's happening
118:20 - is when he jumps and he's standing here
118:22 - he's going to jump up he's not even
118:24 - going to have a chance to clyde with
118:25 - this tile because the top two corners
118:27 - that i'm checking out on his hitbox are
118:29 - over top of this tile even
118:32 - the only reason collision happens on
118:33 - this tile is because his two bottom feet
118:36 - or his two bottom corners are inside of
118:39 - this tile
118:40 - and he can still technically move to the
118:43 - left while he's in this tile because
118:45 - collision is only going to happen in
118:47 - this tile with the bottom side of the
118:49 - tile and it does when i'm standing
118:51 - underneath this tile
118:53 - it does do collision but just on the
118:56 - bottom side i can still move to the left
118:58 - so when i jump up underneath this tile
119:00 - i'm going to jump i'm going to hit my
119:01 - head on the bottom and it's going to
119:03 - send me right back down again
119:05 - but remember i'm jumping 20 pixels high
119:08 - so
119:09 - what's going to happen is just my feet
119:11 - are going to collide with this
119:14 - when i jump i'm actually going to move
119:15 - up here then it's going to place me back
119:16 - down there and i can still move over to
119:18 - the left so when i jump up and press
119:20 - left
119:21 - i'm actually going to be up here and i'm
119:23 - going to fall back down into this tile
119:26 - on the wrong side of the collision
119:27 - boundary
119:29 - so that's what tunneling is and there's
119:30 - a really easy way to fix it if i come in
119:32 - here and i set this back to
119:34 - let's see
119:36 - 30 frames a second
119:38 - that ought to do let's see what that
119:40 - looks like
119:41 - 30 frames a second things are back to
119:43 - normal what i'm actually going to do is
119:45 - i'm going to come out here and i'm going
119:46 - to change the
119:48 - speed at which he jumps and that's
119:49 - actually going to fix everything
119:52 - so if i can find where that is oh it's
119:54 - actually in the game object here
119:57 - jump i'm actually setting jump whenever
120:00 - he jumps i call this function and it
120:01 - moves him 20 pixels up it sets his y
120:04 - velocity at negative 20 pixels so what
120:06 - i'm going to do is i'm going to set it
120:07 - to negative
120:08 - 15 pixels and that's going to prevent
120:10 - him from ever moving
120:14 - more than one tile space
120:16 - and actually i'm going to set this back
120:18 - to one frame so you guys can see that in
120:20 - action as well let's go back to one
120:22 - frame
120:23 - per second refresh and now we're going
120:26 - to zoom in and take a closer look at
120:28 - this guy jumping so
120:30 - this is what 16 pixels looks like when
120:33 - he jumps
120:34 - as you can see his bottom feet are no
120:36 - longer way up here on that first frame
120:39 - on that first frame they're down here so
120:41 - he'll still end up colliding with this
120:43 - tile right here so when i move back into
120:45 - collision and i'm going to speed things
120:47 - up for this
120:50 - set it back to 30 frames a second save
120:52 - come over here refresh my page and
120:55 - now tunneling can no longer happen
120:58 - so collision is going to happen as i
121:00 - expect it to so that is the problem
121:04 - and i guess i kind of showed you how to
121:05 - fix it in the first part but i'll go
121:07 - into more detail on how to fix it in the
121:09 - next part
121:10 - okay so we just looked at part five's
121:12 - example program where we had this glitch
121:15 - where actually i fixed it but very fresh
121:17 - we had this glitch
121:20 - i'm gonna leave that in actually so if
121:21 - you ever check out part five that glitch
121:23 - is gonna be left in there but now i
121:25 - wanna show you a better way to fix it
121:27 - and this is a sneak peek if you will at
121:29 - part six where i actually did fix this
121:31 - problem so here's the same exact tile
121:33 - structure same scenario in part six
121:36 - without the glitch now how i did this
121:39 - was i basically just clamped his
121:41 - movement velocity to
121:44 - never exceed 16 pixels or one tile space
121:48 - now if you just reduce the amount of
121:51 - velocity that he jumps at
121:52 - it can cause problems so for instance
121:54 - here i'm going to take a look at part
121:56 - five again here's part five i can jump
121:59 - up above this tile if i have a a y
122:01 - velocity of negative 20 pixels per frame
122:05 - when i jump so obviously if i reduce
122:07 - this to
122:08 - 15 and i save
122:11 - it's gonna it's going to eliminate the
122:13 - possibility of tunneling
122:15 - that's great but now i can't jump up on
122:17 - my platforms anymore so how do i fix
122:19 - this well the way to fix it is to go
122:21 - ahead and change your gravity and
122:24 - friction
122:26 - at least that's one way to fix it so i'm
122:28 - going to save that so it's back the way
122:29 - it was i'm going to come over here and
122:30 - i'm going to take a look at the code
122:33 - excuse me let's take a look at the code
122:35 - inside of part 6.
122:38 - so
122:39 - in part 6 i'm still using a velocity of
122:41 - negative 15 when i jump
122:43 - the only difference is now i'm clamping
122:46 - my movement velocity when i
122:49 - update the player's position
122:51 - so basically to do that i'm just saying
122:53 - if the absolute value of the player's x
122:56 - velocity or y velocity is greater than
122:59 - some max velocity and that's going to be
123:02 - 16 or 15 basically our tile size or
123:04 - maybe one less just to be safe
123:07 - if it's greater than that then we're
123:08 - going to set our velocity to
123:11 - the max velocity and actually this code
123:13 - is wrong because i don't want to change
123:16 - the sign
123:17 - of my velocity
123:19 - i just want to change the
123:21 - amount of my velocity so but you get the
123:24 - idea part 6 is still in development
123:26 - basically what you want to do is you
123:27 - want to clamp your movement speed
123:30 - and
123:33 - to get the same jump height
123:35 - with the different y velocity what you
123:37 - do is you just reduce
123:39 - gravity and friction so here is
123:43 - what a jump looks like in part five
123:45 - as you can see he jumps a lot faster
123:49 - it's kind of almost too quick so this is
123:51 - almost an improvement for visuals as
123:53 - well this is part six where i've kind of
123:55 - changed it up so he can
123:57 - have a clamped velocity and he just
123:59 - moves a little more smoothly if you look
124:01 - at it it's a little more smooth
124:04 - here's part five again
124:06 - jumps really far really fast it's a
124:08 - little bit
124:10 - too quick
124:11 - part six
124:13 - a little more smooth hopefully you can
124:14 - pick that up with my my video recorder
124:16 - here because sometimes it doesn't quite
124:18 - match the frame rate of the game when
124:20 - it's recording
124:21 - so
124:22 - basically what you want to do to fix
124:23 - tunneling is you want to clamp your jump
124:26 - speed
124:28 - so
124:28 - the amount of velocity that you apply to
124:31 - a jump and that's going to be where a
124:32 - lot of your velocity comes into play
124:34 - high velocities when you're jumping
124:35 - that's going to be a thing you wanna
124:37 - clamp it to
124:39 - an amount that's less than one tile
124:40 - space
124:41 - then in order to
124:43 - get the height of the jump that you want
124:45 - you're gonna have to reduce uh gravity
124:48 - and friction
124:50 - so for me i came in when i defined the
124:52 - world object
124:54 - what i do is i just have
124:56 - gravity and friction defined here so for
124:58 - example friction if i change the value
125:00 - of friction to say
125:02 - 0.9
125:03 - 0.99 that's going to be really low
125:06 - friction so if i come over here and
125:07 - refresh
125:09 - now i'm going to have really really low
125:10 - friction
125:12 - and as you can see i'm just moving
125:14 - really fast all over the place jump
125:16 - really far really fast because there's
125:17 - no friction
125:19 - so i don't want that but that's
125:20 - basically how you fix tunneling you just
125:22 - basically have to clamp your velocity to
125:24 - a certain speed and to get the jump
125:27 - height that you want you just
125:30 - mess with friction and gravity and
125:32 - that's gonna do it for tunneling
125:34 - i'm going to show you how to create
125:36 - level data files using json how to load
125:38 - level data and use it to populate the
125:40 - game world and finally how to trigger
125:42 - subsequent level loads by colliding with
125:43 - doors
125:45 - let's take a look at what has changed
125:47 - since part five and part five and a half
125:50 - so this is part six and everything is
125:52 - basically the same
125:53 - i did make quite a few changes but most
125:55 - of those changes pertain to loading
125:57 - different levels so when i jump up into
125:59 - this area here and walk off the side of
126:01 - the screen it's actually going to load a
126:03 - different level as you just saw so how
126:05 - how this is working is i have a little
126:07 - door hit region just off the right of
126:09 - the screen here and it's just a
126:10 - rectangular box and when the player
126:13 - character's center point hits that box
126:15 - it loads the level and places the player
126:17 - in
126:18 - whatever location he needs to be to
126:21 - start this level out when walking
126:22 - through that door from the other level
126:23 - so basically in part six i just have a
126:25 - couple different levels and i've defined
126:27 - a couple different types of doors
126:29 - they're all just rectangles you just saw
126:31 - two small rectangular doors this area on
126:34 - the bottom of this level is one big
126:37 - rectangular door so i can jump up
126:39 - through it at any point
126:41 - in this rectangle so this system works
126:43 - great for any size door doesn't just
126:45 - have to be one tile it can be any size
126:48 - rectangle that you define
126:50 - so that's basically part six so now that
126:52 - you know what the example program is
126:53 - about let's get into how this works
126:56 - before we get into the javascript code
126:58 - let's actually take a look at the
127:00 - different level files so this would be
127:03 - level zero zero or i call it zone zero
127:06 - zero so the file to load this level that
127:08 - you see on the screen is this file right
127:10 - here zone zero zero and basically it's
127:13 - just a couple of
127:15 - different json structures so i have a
127:17 - doors array and inside of that i just
127:20 - have the doors that are contained in
127:21 - this level so for this level level zero
127:24 - zero or zone zero zero i have one door
127:27 - just to the right of this tile the door
127:28 - would be right here off the level that
127:31 - you see on the screen
127:33 - and
127:34 - this json here defines an array of doors
127:36 - and this object inside of it will be
127:39 - that door object that resides right over
127:42 - here
127:43 - so that's my doors array down here i
127:46 - have some information about the maps
127:48 - each map has 12 columns and 9 rows i did
127:51 - not format this so you could actually
127:53 - see it in kind of a 2d
127:56 - row and column format i just have it in
127:58 - one big long array but if i were to line
128:01 - this up so each
128:03 - row had 12 columns in it you would see
128:05 - that the maps are 12 columns by 9 rows
128:08 - but this is my graphics map so these are
128:10 - all my graphics tile values this is my
128:12 - collision map so these are all the
128:13 - collision values for the tiles
128:16 - and then finally i have id and that's
128:18 - just going to be the level id so like i
128:20 - said this is zone zero zero so when i
128:23 - load zone zero zero this just tells my
128:26 - world object that
128:28 - it's
128:29 - zone id zero zero
128:32 - so
128:33 - now let's take a look at zone two and
128:35 - we'll just take a look at zone two's
128:37 - code really quick just so you get it in
128:39 - your head that this is what the the
128:41 - format is
128:42 - so here's my doors array zone two has
128:45 - two doors there's a door right here to
128:46 - go back into zone zero or actually it's
128:48 - zone one excuse me
128:50 - because i start labeling a zero but this
128:52 - is zone one and it leads back into zone
128:55 - zero zero there's a door right off the
128:56 - left side of the screen
128:58 - here and it goes into zone zero two with
129:02 - a door right over here on the far right
129:04 - side of the screen so inside of my doors
129:06 - array i have defined two door objects
129:10 - and then same as before i have my
129:12 - columns and rows and my two maps and the
129:15 - id that just indicates what zone this is
129:19 - so
129:20 - if you know how to write javascript you
129:21 - know how to write json for the most part
129:23 - it's really easy and it's a really great
129:26 - natural fit for
129:27 - writing information that you're going to
129:29 - load into your javascript game because
129:31 - it's so similar to javascript already
129:33 - and you have the built-in
129:35 - json.parse method to parse this
129:38 - information into usable javascript
129:40 - objects so now that you know how to
129:41 - write the level data let's get on to the
129:44 - next part of the video
129:45 - okay so now that we know how to define
129:48 - our level data we need to figure out a
129:49 - way to load it and the best way to load
129:51 - it is with
129:53 - xmlhttprequest so
129:54 - inside of my main.js file i have a class
129:57 - called assets manager and it basically
129:59 - just has a function called request json
130:01 - inside of it
130:02 - so in order to load my json file i'm
130:04 - going to call this request.json function
130:07 - i'm going to pass in the url of the file
130:09 - to load so basically i'm just if i want
130:11 - to load zone 0 0 i'm going to pass in
130:13 - the string
130:14 - zone00.json and i'm going to provide a
130:17 - callback function but i'll get to the
130:19 - callback function later so first thing
130:20 - i'm going to do is create an xml http
130:22 - request i'm going to give it an
130:25 - eventlistener for the load event
130:27 - and i'm going to have an event handler
130:29 - for when it loads which is just going to
130:30 - call my callback and hand in the parsed
130:34 - json
130:35 - string from my json file so
130:38 - i'm going to send off my request to the
130:40 - server it's going to process it it's
130:41 - going to hand me back the
130:43 - file content
130:44 - remember that file was
130:47 - zone00.json
130:48 - it's literally going to hand back
130:50 - this stuff in response text or just text
130:53 - format
130:55 - and i'm going to take that response text
130:57 - or the content my json file i'm going to
130:59 - use json.parse to turn it into a
131:01 - javascript object and i'm going to call
131:03 - the callback
131:04 - so that's the request json file that
131:07 - we're going to use to actually load our
131:09 - data so now let's take a look at where
131:10 - we first load up a level when we first
131:13 - start the game and that's going to
131:14 - happen all the way at the bottom of the
131:16 - main js file in the initial the
131:19 - initialization section
131:21 - so
131:22 - this is where we're using the request
131:24 - json file to load up our very first
131:26 - level so when i click refresh
131:29 - my code is gonna run in main.js
131:31 - and this
131:33 - right here is gonna be responsible for
131:34 - loading up zone zero zero which is on
131:37 - the screen right here so let's just take
131:38 - a look at what we're handing in
131:41 - calling assets manager dot request json
131:45 - zone prefix that's just gonna be the
131:47 - string zone for the first part of our
131:49 - url
131:51 - game.world.zone id
131:53 - when i first instantiate
131:56 - game it creates an object called world
131:59 - so game.world is a world object and that
132:02 - has a default value in it of
132:04 - 0 zero for world zero zero or zone zero
132:07 - zero so that's where we're going to get
132:09 - the zero zero from this is going to be
132:10 - zero zero and zone suffix is just gonna
132:13 - be
132:15 - dot json so i have the zone prefix of
132:18 - zone plus the game dot world dot zone id
132:22 - which is zero zero plus zone suffix
132:25 - which is going to be dot json
132:28 - so i'm going to hand in that url to
132:29 - request json it's going to send a
132:31 - request to the server when the server
132:33 - returns
132:35 - the json data inside of zone zero zero
132:38 - in text format i'm going to parse it
132:40 - into a js or a javascript object
132:43 - and then i'm going to hand that
132:46 - javascript object into my callback
132:49 - function which is just going to be
132:50 - defined here i defined it in arrow
132:52 - function format
132:53 - so
132:55 - this is my callback function and
132:56 - remember that i passed in json.parse
133:00 - request.responsetext so that's going to
133:02 - be the javascript object that i created
133:06 - from my
133:07 - zone file
133:09 - and i'm going to hand that into
133:11 - game.world.setup so let's go ahead and
133:13 - take a look real quick at
133:14 - game.world.setup
133:16 - and also where we
133:18 - create the very first
133:20 - default value for zone id so let me see
133:24 - if i can find where i'm at here i'm
133:26 - inside of the game file
133:29 - and this is the
133:32 - game.world.prototype so
133:34 - let's go up a little bit more
133:36 - game.world this is where we define
133:38 - game.world let me real quick just take a
133:40 - look at the default value for zone id
133:42 - so remember the default value for zone
133:45 - id we're going to use that right here
133:47 - when we're loading our first level
133:49 - so that's just going to be defined right
133:51 - here
133:52 - right now the default value is zero zero
133:54 - so when i refresh the page
133:56 - the first level it loads is zero zero if
133:58 - i change that to say zero one and save
134:01 - it
134:01 - and refresh the page keep an eye on the
134:03 - level map it's gonna load up world zero
134:06 - one if i change it again let's go world
134:08 - zero two save we're gonna load up and
134:11 - it's gonna immediately well it dropped
134:13 - us in world two but we fell down into
134:15 - world three so basically this sets our
134:17 - default level to load initially when we
134:20 - boot up the game
134:22 - so
134:23 - that's where we defined that but now
134:24 - we're going to take a look at
134:28 - game.world.setup where we actually put
134:30 - all the information from our zone file
134:33 - into our game.world object which we use
134:37 - on every frame of animation to do stuff
134:40 - with our game so
134:42 - down here is the
134:44 - setup function this is game.world.setup
134:47 - and it takes one parameter which is the
134:50 - zone which we just parsed into a
134:52 - javascript object from our
134:55 - zone00.json file
134:57 - so
134:58 - basically all we do is copy over all the
135:01 - values from our newly created zone
135:03 - object and we copy those values into our
135:06 - world object
135:08 - pretty simple
135:09 - the only one we don't copy directly is
135:11 - the doors array
135:13 - and the reason for that is because i
135:15 - want to use
135:16 - a door object that i defined i'll talk
135:18 - about that in the next part but we do
135:20 - loop through all the doors in the zone's
135:22 - doors array and we just create a new
135:25 - door from the doors that we loop through
135:28 - so inside of this
135:29 - zone file we have an array called doors
135:31 - every object inside we get and we
135:34 - convert this data
135:37 - into
135:39 - a
135:40 - game.door object so this class here
135:43 - we're just going to create a door object
135:45 - from the door data inside of our
135:48 - zone.doors array so whatever door we
135:51 - loop over in that doors array gonna be
135:53 - converted into a game.door class and
135:55 - that's what we're gonna use for our
135:57 - actual game
135:58 - logic and game physics when we collide
136:00 - with the doors and stuff
136:02 - now we finally know how we're setting up
136:05 - the very first initial level
136:07 - i'm getting out of breath here i'm
136:08 - talking so much but
136:10 - now we need to know one more thing and
136:12 - that's how to actually go ahead and load
136:15 - a level
136:16 - on the fly when we when we walk into a
136:19 - door so
136:22 - where we do that is inside of the update
136:25 - function for the game so on every cycle
136:27 - of our game engine
136:29 - on every game loop so to speak we're
136:31 - going to call this function from inside
136:33 - of main and this is the update function
136:35 - so the first thing we do is get some
136:37 - user input then we call game.update
136:39 - game.uptake
136:41 - takes care of moving the player takes
136:42 - care of all the world collision
136:44 - and inside of the game.update function
136:47 - is the world.update function so let's go
136:49 - ahead and take a look at
136:51 - world.update real quick
136:53 - already inside a world
136:55 - uh game.world.prototype so this is the
136:58 - game.world.update function which is
137:00 - called inside of the game.update
137:02 - function which we're calling right here
137:04 - so basically this function is going to
137:06 - call this function
137:09 - so
137:10 - first thing we do is update the player's
137:12 - position we collide the player with the
137:15 - world this refers to game.world
137:18 - so we're going to cloud the player with
137:19 - the world so all the tiles and then
137:21 - we're going to come down here and we're
137:23 - going to loop through all the doors in
137:25 - the world in the current region or zone
137:27 - of the world
137:28 - we're going to get each door
137:31 - and we're going to test for collision
137:32 - with the door and it's just basic
137:34 - rectangular collision i'll cover in the
137:36 - next part of the video basically if we
137:38 - do collide with the door so if the
137:40 - player actually collides with the door
137:44 - we're going to set
137:45 - this dot door or game.world.door
137:48 - equal to that door that we just collided
137:51 - with so
137:53 - normally this dot door is undefined
137:55 - so out here in our update function which
137:57 - is called on every frame
138:00 - we're going to
138:01 - test to see if game.world.door is not
138:04 - equal to undefined and the only time
138:06 - it's not equal to undefined is when for
138:08 - a split second we actually walk into it
138:12 - and
138:13 - then this if statement returns true and
138:15 - we go ahead and load the world that was
138:18 - specified by whatever door we collided
138:20 - with so let's just go through this real
138:22 - quick and see what happens the first
138:23 - thing that happens when i run into a
138:25 - door
138:26 - so if i run into a door the first thing
138:28 - that happens is i stop the engine
138:32 - i then make a request with request json
138:35 - to
138:36 - whatever zone that door
138:39 - brings you to so if i come up here into
138:41 - my zone00.json
138:44 - we're in zone zero zero
138:46 - the destination zone for this specific
138:48 - door located at an x of 192 which is
138:51 - about there and a y of 64 which is about
138:53 - there has a width and height of 16. so
138:55 - right off the right of the screen here
138:56 - is a box that's about 16 by 16 pixels
139:00 - and when i collide with it it's gonna
139:03 - load
139:05 - zone zero one and it's going to put the
139:06 - player at destination x of zero and
139:10 - negative one just means we're not going
139:12 - to use destination y so the player's y
139:14 - destination remains the same but i'll
139:15 - get into that in the next part
139:17 - um
139:18 - so basically we're gonna request
139:20 - the
139:21 - destination zone specified by that door
139:23 - so
139:24 - this door here that we're about to walk
139:26 - in right to the right of the player will
139:28 - tell us to go to world or zone zero one
139:31 - so when i walk into it
139:33 - this code loads up zone zero one
139:36 - pretty simple the same thing that we did
139:38 - for the initial level load we're just
139:40 - doing again right here even have the
139:42 - same arrow function with uh
139:45 - the zone parameter specified inside then
139:48 - inside of our callback after request
139:50 - json requests the level data the server
139:53 - gives it back to us in text format it
139:55 - parses that into a json object called
139:59 - zone and hands it back to us we're just
140:02 - going to call game.world.setup
140:04 - and it's going to get all the
140:06 - information out of the level file and
140:08 - put it on the screen basically
140:10 - so there is one difference this time
140:12 - however because now we're going to have
140:15 - to use some information from a specific
140:17 - door so let me go back inside the
140:20 - game.world.setup function real quick
140:23 - i'm going to scroll up to it
140:26 - right here game.world.setup
140:28 - and we check for the case that we are
140:32 - colliding with the door because remember
140:35 - when we
140:36 - enter into collision with the door we
140:37 - set the world's this dot door property
140:40 - equal to the door
140:42 - so when we call setup this dot door is
140:45 - actually going to be equal to whatever
140:47 - door we just collided with so if i come
140:49 - over here
140:50 - and collide with the door that's right
140:51 - over here
140:52 - it's going to be equal to that door that
140:54 - i just clouded with and it's basically
140:57 - it's just going to set the player's x
140:59 - and y center position to whatever the
141:02 - door's destination x and y values were
141:05 - that's it really simple everything else
141:07 - works the same as the initial level load
141:09 - the only difference is when you walk
141:10 - into a specific door
141:12 - you reposition the player according to
141:14 - that door's destination x and
141:15 - destination y so stay tuned for the next
141:18 - part where i'm going to talk about the
141:19 - door class specifically the collision
141:22 - and all that kind of good stuff
141:24 - now i want to take a look at what a door
141:27 - actually is so if i zoom in here i'm
141:29 - going to look at what a door is inside
141:31 - of my zone00.json
141:33 - file i've got an x position and a y
141:36 - position a width and a height so
141:37 - basically my door is just a rectangular
141:40 - region on the screen somewhere that the
141:42 - player object can collide with
141:44 - then i also have a destination zone
141:46 - that's going to be where the player is
141:48 - going to go what level i'm going to load
141:50 - if the player hits the door and i have a
141:52 - destination x and a
141:53 - destination y for the player as well so
141:56 - this is where i'm gonna put the player
141:58 - in the newly loaded zone when it loads
142:02 - if i have a negative one that just means
142:05 - destination y does not get used and the
142:07 - player's y position remains the same
142:09 - same thing for x if i have a negative
142:11 - one
142:12 - the destination x position isn't going
142:14 - to be used the player's x position is
142:16 - going to remain the same so we can see
142:18 - this functionality over here
142:21 - if i fall into this world
142:23 - i'm not being repositioned on the y-axis
142:28 - or on the x-axis rather because i don't
142:31 - need to be i just want to fall right
142:33 - through and naturally have my player end
142:35 - up where he has to be
142:37 - based on where he was in the previous
142:38 - level i don't want to jump through this
142:42 - floor door right here and end up at the
142:44 - very start of the door over here in the
142:46 - next level if i jump through over here
142:47 - like if i jump through right here i
142:49 - don't want to come out in this world
142:50 - right here because it just wouldn't look
142:52 - right
142:52 - so that's the only reason i have a
142:54 - negative one there but anyway let's look
142:56 - at the door class the game.world.door
142:59 - class and actually see what that looks
143:01 - like and the collision code that i'm
143:03 - using to have the player in the door
143:06 - actually collide so if i could find that
143:08 - wherever that is
143:10 - scroll scroll scroll
143:12 - hopefully i'll come across it soon
143:15 - ah this is it right here so it's a
143:16 - really simple object
143:19 - i'm gonna
143:20 - correct that small formatting error
143:22 - there
143:23 - really tiny object basically is the same
143:26 - exact thing as this right here it just
143:28 - has a prototype
143:32 - defined with the collide object function
143:34 - inside of it so
143:36 - this is the door class and i'm going to
143:38 - call object on it object all it is is
143:42 - a rectangle class that has some
143:44 - functions for helping me determine the
143:46 - sides
143:47 - of a rectangle so it has functions like
143:50 - get left get right get top get bottom
143:53 - just defining a rectangle here
143:55 - inheriting from the object class then
143:57 - i'm going to set the destination x y and
144:00 - zone to whatever those are from the door
144:02 - object that we hand in and that's just
144:04 - going to be whatever is defined inside
144:06 - of the zone file
144:09 - then inside of the prototype i have a
144:11 - function called collide object and
144:13 - that's just going to test to see
144:15 - if the object's center points
144:19 - are
144:19 - inside of the rectangular region of the
144:23 - door so
144:24 - this code right here just tests to see
144:26 - if the player is not colliding with the
144:28 - door if he's not then i'm going to
144:30 - return false and that means we didn't
144:31 - have a collision with the door if any of
144:33 - this is true
144:35 - or actually if any of this is false
144:38 - then we know that we have collided with
144:40 - the door and in that case we're going to
144:42 - return true so where do we actually use
144:44 - this that's going to be inside of the
144:47 - world.update function so if i come down
144:50 - here to worlds
144:52 - world.update
144:56 - right here there we go
144:59 - okay so inside of world.update i have
145:01 - all the doors defined inside of my
145:03 - world.doors array i'm going to loop
145:05 - through
145:06 - every door in that array
145:08 - i'm going to get each individual door
145:10 - i'm gonna test to see if the door is
145:12 - colliding with the player object and if
145:15 - it is
145:16 - i'm just gonna set the world's door
145:18 - property equal to that door and then
145:21 - just like in the last part we're going
145:23 - to go into the
145:25 - update function for our main game loop
145:28 - game loop and inside of that we're going
145:30 - to have an if statement that just checks
145:32 - to see is game.world.door defined and
145:34 - the only time it's defined is right
145:37 - after we collide with the door so we're
145:39 - going to stop the engine we're going to
145:40 - load the level defined by the door by
145:43 - the door's destination zone more
145:44 - specifically we're going to set up that
145:46 - zone in game.world.setup and we're going
145:48 - to restart our engine now inside of
145:51 - setup
145:52 - i know i'm recapping stuff that i just
145:54 - talked about but inside a setup we have
145:56 - this is the inside of the setup function
145:58 - we have an if statement that just checks
146:00 - to see is this door or game.world.door
146:04 - defined is it not undefined if it's
146:06 - defined and we have a door in there
146:08 - we're going to set the player's x and y
146:11 - coordinates equal to whatever those were
146:13 - defined
146:15 - as by the door object and if it's not
146:18 - equal to negative one then we know we
146:19 - can set it up if it is equal to negative
146:21 - one we just leave it alone so that's
146:23 - like in this case here where i'm not
146:25 - changing the player's x position
146:28 - so for both of these doors this door up
146:31 - here and this door down here for each
146:33 - level respectively
146:35 - the destination x position for that door
146:38 - is going to be set to negative 1 because
146:40 - i only want to change the player
146:42 - character's y position
146:45 - this way i don't have him jump through
146:46 - here and start out over here on this
146:48 - door
146:50 - so that's basically it that's how i
146:52 - define my door objects and
146:55 - that's how to load levels with doors
146:58 - i'm going to show you how i define the
147:00 - carrot and grass objects in the level
147:01 - data file their respective classes and
147:04 - the basic collision detection used to
147:05 - collide with the carat objects
147:07 - the first thing i'm going to talk about
147:09 - is what this example program is all
147:11 - about and where the carrot and grass
147:14 - objects are defined because since the
147:15 - last installment of this series i have
147:18 - since added carrot objects and grass
147:21 - objects you can see that i'm running
147:22 - into the carrot objects and when i
147:24 - collide with their hitbox i collect a
147:26 - carrot i have a carrot counter at the
147:28 - top left of the screen and then down
147:30 - here i have some grass
147:31 - objects and all the grass objects are
147:33 - are just
147:35 - objects with an x and y position and
147:37 - they have an animator inside of them
147:39 - they extend the animator class and it
147:41 - just updates the image on every frame of
147:44 - the grass to give the impression that
147:45 - the grass is actually swaying back and
147:47 - forth so
147:48 - just some basic objects i've added and
147:50 - if i come over here and take a look at
147:52 - the zone file
147:54 - you can see that
147:56 - this is my level data file and i have an
147:58 - array for carrots i have an array for
147:59 - grass and basically they're just little
148:02 - arrays inside of here that define an x
148:05 - tile position and a y tile position so
148:07 - if i come over here to my map and i
148:10 - refresh this carrot is going to be at
148:13 - position
148:14 - 1 comma 2. so the x tile is going to
148:18 - start at 0 and go to 1 because this
148:20 - right here is 1 2. so x tile of 1 y tile
148:23 - of 2 so if i count from zero i get zero
148:26 - one on my x tile axis and for the y tile
148:29 - axis i have zero one two so i know that
148:33 - from this map i wanna carry it at
148:34 - position one two and that's that carrot
148:38 - same thing for the grass my first grass
148:40 - tile is at x position two y position
148:43 - seven
148:44 - and that's going to be this grass object
148:47 - right here
148:48 - so pretty simple so when i load my level
148:50 - up i'm gonna actually have to loop
148:52 - through these arrays here get the x and
148:55 - y tile positions from them and then
148:57 - create an object
148:59 - from that x and y tile position and if i
149:02 - am looping through the carrots array
149:03 - i'll create a carrot object if i'm
149:05 - looping through the grass array i'll
149:06 - create a grass object so let's go in and
149:09 - check out the setup function of the
149:12 - game.world object
149:14 - the setup function just runs i come over
149:16 - here and refresh my screen the setup
149:18 - function runs right after the level data
149:20 - is loaded so right after i load this
149:22 - level data and i get access to it with
149:25 - json.parse
149:26 - i then call the setup function i pass in
149:30 - the json object that i just parsed after
149:32 - i loaded that level data from json and i
149:35 - go ahead and i set up all of the game
149:39 - objects
149:40 - and the graphics and collision map and
149:42 - everything for this level
149:44 - and then i'm going to go ahead and i'm
149:45 - going to loop through the zones carrots
149:48 - array and the zones grass array and
149:52 - basically those are literally just going
149:54 - to be
149:55 - these two arrays right here
149:57 - so i'm going to loop through them and
149:58 - i'm going to create a new carrot and a
150:00 - new grass object for every instance of
150:02 - one of those little
150:04 - x and y tile arrays that i come across
150:06 - inside of the zone file so what that
150:09 - looks like is i'm just going to use a
150:11 - for loop i'm going to go ahead and i'm
150:12 - going to loop through all the carrot
150:14 - objects inside of my zone's carrots
150:16 - array which is just the little tiny x
150:19 - and y tile arrays
150:20 - i'm going to create a carrot
150:24 - object or not an object but a variable
150:26 - to store that x and y position from the
150:28 - zone.carrots array and then i'm going to
150:31 - store a new game.carrot
150:34 - inside of
150:35 - my
150:37 - game's actual carrots array that i'm
150:39 - going to use on every frame of animation
150:42 - inside of my game cycles for my game
150:44 - loop so what i'm going to do is i'm
150:46 - going to feed it in x position in pixels
150:48 - not in tile space so i'm going to take
150:51 - the x tile position of the carrot which
150:53 - is located at position 0 inside of that
150:55 - array that we loaded from the
150:57 - level data and i'm going to multiply it
150:59 - by the tileset.tile height which is 16
151:02 - pixels plus 5 is just going to give me
151:04 - an offset so if i were to
151:06 - come out here and make this plus 0
151:10 - and save
151:11 - i come over here what's going to happen
151:12 - is i'm no longer going to i'm not going
151:14 - to have an offset of 5 pixels anymore so
151:16 - you can see they're kind of offset to
151:18 - the left by 5.
151:19 - if i come back in here and i undo that
151:23 - the z control z
151:25 - save come back over here and refresh now
151:28 - all my carrots are in the right position
151:30 - pretty much
151:32 - i do the same thing with the grass
151:34 - basically i just loop through all the
151:35 - grass in the level data file and i
151:37 - create a new instance a new grass object
151:40 - and i just position it based on the x
151:43 - and y tile values stored in my level
151:45 - data so that's it next i'm going to take
151:47 - a look at the actual classes that we use
151:50 - to make the grass and carrot objects
151:53 - now we're going to take a look at the
151:55 - grass and the carrot classes
151:57 - respectively so first i'm going to start
151:59 - out with the grass class and all it is
152:02 - is really simply an animator object it
152:04 - inherits from animator this way i can
152:06 - animate the frames
152:08 - and it also has an x and y position if
152:11 - you look at a grass object which is just
152:13 - this right down here obviously all it
152:14 - does is sit in a location so that's
152:17 - going to be my x and y position and it
152:19 - is animated so it's going to have to
152:21 - inherit from the animator now the
152:22 - animator class is the same class that i
152:24 - use to animate the rabbit it can be
152:26 - reused for all different kinds of game
152:28 - objects to give them an animation so
152:31 - really simply the grass class just has
152:33 - an animation and a position and the
152:35 - carrot class kind of does too but it
152:38 - also has a lot more so let's go up and
152:40 - take a look at the carat class
152:42 - and see what makes it move and how we
152:45 - collide with it with the player object
152:47 - so here's the carrot class and it
152:50 - inherits from the object class the
152:52 - game.object class as well as the
152:54 - animator class so the animator class
152:56 - just gives it the animation
152:57 - the object class is what's going to give
152:59 - it its x and y position as well as its
153:02 - width and its height and in addition to
153:04 - those things it also gets the collide
153:06 - object function which is going to
153:09 - be responsible for allowing us to
153:11 - collide with a carrot and actually
153:13 - collect it so
153:16 - that's important to note
153:17 - then some cool features about the carrot
153:19 - we have the base x y and position x y
153:23 - values so base x and base y are just
153:26 - referring to
153:28 - the
153:29 - center position that the carrot is
153:30 - rotating around or making that figure
153:32 - eight around so that's going to be the
153:34 - base x and base y position the carat
153:36 - does still have an
153:39 - x and y position that's going to be
153:40 - where it's actually drawn to the base x
153:43 - and base y are going to be just the
153:44 - point that it rotates around
153:47 - position x and position y are going to
153:49 - be
153:50 - vectors that the caret is placed
153:55 - by the amount of the vector on whichever
153:58 - axis away from the base x so to explain
154:00 - that a little more clearly
154:02 - if base x is in the center position x
154:05 - and position y are going to be distances
154:07 - away from the base on their respective
154:10 - axes and that's what's going to
154:13 - determine how far from the base the
154:15 - carrot is
154:16 - and we're going to i'll show you how i'm
154:19 - using position x and position y in a
154:20 - second
154:21 - just going to move down here but i set a
154:23 - random value up here
154:25 - and
154:27 - that basically just
154:29 - makes all the carrots kind of have a
154:31 - different um path because otherwise if i
154:34 - just set this up to be
154:36 - let's see
154:38 - zero
154:39 - all the carrots would have the same
154:42 - rotation pattern they'd all be
154:43 - synchronized basically so if you look
154:45 - now you can see very clearly that
154:47 - they're all synchronized and that's kind
154:49 - of a bad look so
154:50 - just go back to how it was before
154:54 - save and now you can see that they all
154:57 - kind of move independently and it's a
154:59 - lot less jarring to look at because
155:01 - before it was almost like there was a
155:02 - big
155:03 - just
155:04 - solid image of carrots with the
155:06 - transparent background just moving back
155:08 - and forth on the screen that's not what
155:09 - we want to go for we want to have
155:11 - independent movement we want to have
155:13 - things looking like everything is random
155:16 - so also speaking about that up here the
155:19 - frame index
155:21 - if you notice all the carrots on screen
155:24 - are not sharing the same uh
155:27 - animation sequence well they they're
155:30 - they're sharing the same frames
155:31 - obviously but
155:33 - if you look at two you can see that
155:35 - they're animating at different rates
155:37 - i just have to find two that are going
155:39 - at offset values here
155:41 - these two this one and this one they
155:44 - display the
155:46 - opposite frame from one another so when
155:48 - this one is on frame zero this one's on
155:50 - frame one when this one's on frame one
155:52 - this one's on frame zero that keeps
155:53 - things looking fresh so
155:55 - if i come up here and change this to
155:58 - just be
156:00 - zero
156:03 - it's going to reduce the
156:05 - randomization and we're just gonna have
156:08 - everything animating the same exact way
156:10 - almost like it's updating from the same
156:12 - exact animation object so that's not
156:14 - what we want either we want things to
156:17 - randomly update their animation not
156:19 - randomly but look like they have their
156:21 - own unique animation even though they're
156:23 - displaying the same frame so to do that
156:25 - all i'm doing is i'm starting off the
156:27 - animation at
156:29 - a
156:30 - randomized frame index
156:33 - alright so now let's take a look at what
156:35 - actually makes these things rotate
156:36 - around the base x and base y position
156:39 - inside of the game.carrot.prototype
156:43 - which is going to be the prototype for
156:44 - our charact class i have a function
156:47 - called update position and that's oh
156:49 - that's the only function for this class
156:51 - and this is going to be called on every
156:53 - frame of animation we're going to talk
156:54 - about this in the next part
156:56 - but
156:58 - all it does is it updates the position x
157:00 - and position y value
157:02 - and
157:04 - sets the actual x and actual y value of
157:06 - the carat object which we're going to
157:08 - use to draw it to the screen so
157:11 - excuse me position x and position y what
157:13 - it does
157:15 - is it's just a distance from the base so
157:17 - you can think of it as a vector distance
157:19 - from the base
157:21 - so
157:22 - oh actually well that is true but
157:24 - when i'm updating these
157:27 - it kind of controls the speed of the
157:29 - animation so if i were to make this five
157:32 - and this
157:33 - nine and save we're gonna see the
157:35 - carrots move a lot more quickly so when
157:38 - i press refresh up here
157:40 - now they're really moving like those
157:42 - guys are jumping around quite a bit
157:44 - there so that controls the speed at
157:48 - which things move because on every frame
157:50 - of the animation i'm adding uh 0.5 or
157:52 - 0.9 to these and that's going to make
157:56 - the thing move a lot more quickly
157:57 - obviously
157:58 - so let's get back to how things were
158:01 - save come down here and look at how we
158:03 - actually use these
158:05 - so
158:07 - math.cosine and math.sine are what's
158:09 - going to give us that circular motion
158:11 - and we just plug in position x and
158:13 - position y into cosine and sine
158:16 - and over here we have a multiplier of
158:18 - two
158:19 - that's going to control the distance
158:22 - that the carrot sways on the x-axis so
158:25 - if i come over here and refresh to get
158:26 - things back to normal
158:28 - you can see that it sways a little bit
158:30 - further from side to side than it does
158:33 - from up to from top to bottom there
158:36 - so the reason for that is because of
158:38 - this two
158:40 - if i were to make this a 10
158:43 - and save that
158:44 - the carrots are going to sway a lot more
158:46 - from side to side than they do right now
158:48 - so now you can see they're really
158:50 - swaying from side to side but that looks
158:52 - kind of ridiculous so we don't want that
158:54 - but basically what's happening here is
158:56 - we're just increasing we're incrementing
158:58 - up position x and position y
159:00 - uh math.cosine and math.sine
159:03 - give us a nice uh
159:06 - rounded or circular
159:09 - kind of effect there and then the
159:12 - multiplier is just going to be how big
159:14 - is that distance vector from the base
159:17 - position
159:19 - i guess it's actually a scalar because
159:21 - it's only one single value but together
159:23 - they make a vector so
159:25 - let's just put that back to two
159:28 - so on every frame i'm going to call
159:30 - update position and this code is going
159:32 - to run and it's going to make the carrot
159:34 - move back and forth
159:35 - now if i refresh
159:39 - everything's back to normal so next i'm
159:40 - going to talk about how we actually do
159:42 - the collision between the carrot and the
159:44 - player
159:45 - to do the collision detection between
159:47 - the player object and the carat object
159:49 - we need a function that basically just
159:51 - does collision detection between two
159:52 - square hitboxes so where that function
159:55 - is is inside of game.object so i'm going
159:58 - to scroll up to game.object
160:02 - and we're going to take a look at the
160:03 - function that we used to do that hit
160:05 - detection so here's the
160:07 - game.object.prototype
160:09 - that's just the prototype for our game
160:10 - the object class and we have collide
160:13 - object
160:14 - and what collide object does is it just
160:16 - tests for square collision detection
160:18 - between two rectangular objects so
160:22 - this object is going to collide with the
160:24 - parameter object that i hand in
160:26 - so basically i'll be able to hand in two
160:28 - objects
160:29 - and
160:31 - determine whether or not their hitboxes
160:33 - are overlapping so
160:35 - just wanted to show you this function
160:37 - and
160:38 - now you'll kind of know where the
160:40 - collision detection function is coming
160:41 - from
160:42 - where i'm actually utilizing all this is
160:45 - going to be inside of
160:46 - game.worlds
160:48 - update function so i'm going to come all
160:50 - the way down to the bottom
160:52 - all the way down past the player object
160:55 - pass the tile set object to the world
160:58 - object inside of the
161:01 - not the setup function
161:03 - but the update function so here we are
161:05 - inside of the update function and here
161:08 - we are going to call all of this code on
161:11 - every frame of our game's animation
161:14 - and we start up we uh we update the
161:18 - player's position we collide the player
161:20 - with the game world to get the tile
161:22 - collision going and then we're going to
161:23 - start colliding with carrots so we have
161:26 - a carrots array that's going to hold all
161:27 - of our carrot objects that we created
161:29 - inside of game.setup or game.world.setup
161:32 - rather we're going to loop through all
161:34 - of those carat objects so just these
161:36 - guys here and we are going to update the
161:39 - carrots position we're going to animate
161:41 - the carrot
161:42 - and then we're going to say is the
161:44 - carrot colliding with the player with
161:46 - the clad object function
161:48 - if that function returns true we're
161:50 - going to splice that specific carrot out
161:53 - of the carrots array
161:55 - and we're going to just remove it
161:58 - completely and we're going to add one
162:00 - two carat count and it's as simple as
162:02 - that we're just going to test for
162:04 - collision between the player and the
162:05 - carrot
162:06 - if collision occurs we're going to just
162:08 - remove the carrot carrot object is
162:10 - totally gone it will be garbage
162:11 - collected later on assuming that i
162:13 - removed all references to it and i think
162:15 - i have so then what's gonna happen is
162:18 - i'm going to increase carrot count by
162:20 - one
162:22 - and carrot count is what we're using to
162:24 - update this p element's inner html right
162:27 - here so where does that happen that
162:29 - happens inside of the main js file
162:32 - if i come down to the render function i
162:34 - have a p element it's referenced with
162:36 - the p variable
162:37 - and
162:38 - i just set its inner html to equal
162:40 - carrots plus
162:42 - game.world.carrotcount on every frame
162:45 - and that's it
162:46 - so i hope you guys learned something i
162:47 - hope you enjoyed the video and i'll see
162:49 - you guys next time