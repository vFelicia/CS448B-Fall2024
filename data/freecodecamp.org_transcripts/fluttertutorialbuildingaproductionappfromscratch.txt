00:00 - hello everybody my name is tatus petra
00:02 - and i run the amateur coder channel
00:04 - where our goal is to explain things so
00:06 - simply that even amateurs can understand
00:07 - it
00:08 - and that's my goal for today's video as
00:10 - well to be able to explain how to build
00:12 - a complete production ready app from
00:14 - scratch as simply as i can
00:16 - so the topics we're going to cover today
00:18 - are planning which in my opinion doesn't
00:20 - get covered enough and i think it's one
00:21 - of the most important parts of building
00:23 - any software
00:24 - some other steps you take before you
00:26 - start building an app
00:28 - building an actual app then there's
00:30 - three types of testing that we're going
00:31 - to cover
00:32 - and finally maintainability
00:34 - and hopefully by the end of this video
00:36 - you'll be able to be confident about the
00:37 - apps that you're releasing to all the
00:39 - app stores i'd like to thank free
00:40 - codecamp for giving me this opportunity
00:43 - and i think all my links will be in the
00:45 - description if you want to check them
00:46 - out
00:47 - and let's get into the video
00:49 - okay so today the app we're building is
00:51 - going to be a very simple to-do app
00:53 - now the code for this app isn't going to
00:55 - be too complex but we're going to focus
00:56 - on the process and make sure we go
00:58 - through all the steps necessary to be
00:59 - confident about launching our
01:01 - application
01:02 - and to start with that is planning i
01:05 - think planning is the most overlooked
01:06 - topic when it comes to creating any type
01:08 - of software especially creating an app
01:11 - we're going to focus on two main parts
01:13 - of planning today one of them is
01:15 - requirements
01:19 - and then design
01:22 - so what are requirements it basically
01:24 - breaks down the big requirement of build
01:26 - a to-do app into smaller sections that
01:28 - are more achievable and that you can
01:29 - test at the end
01:31 - so we're gonna have requirements like
01:32 - the following we're gonna have
01:35 - create
01:37 - account
01:38 - be able to login
01:41 - be able to sign up
01:43 - only display
01:44 - not finished to do's
01:47 - keep the list
01:50 - synced up with firebase
01:53 - and lastly if no to-do's say that
01:55 - there's no unfinished dues be able to
01:57 - add a to-do and check off to do's
01:59 - now for each of the topics we're going
02:00 - to get in today there's whole
02:02 - methodologies about how to do them and
02:04 - just like for example requirements
02:06 - there's ways to actually structure the
02:07 - sentences in a way
02:09 - using words like shao and must
02:12 - but today we're going to keep it simple
02:14 - if you're interested in any of these
02:15 - make sure to do more research we just
02:17 - can't cover it within like a couple
02:19 - hours
02:20 - so we got eight requirements for this
02:22 - app now let's get into the design a
02:23 - little bit
02:24 - so with design i like to use adobe xd
02:28 - and there's other options like that you
02:30 - can use but for this one we're just
02:31 - gonna do some very basic
02:35 - drops
02:37 - so we'll have the
02:39 - login screen and then we'll have a
02:42 - logged in screen so here we're going to
02:43 - have a field for
02:44 - the email
02:46 - the password
02:47 - and then a login button and then a
02:50 - register button
02:53 - nothing too complicated
02:55 - then once inside we'll have an app bar
02:58 - with a
03:00 - sign out and then
03:02 - add to do
03:06 - and then down here
03:08 - just a list of to-do's you want to kind
03:10 - of get gain a vision for how the app's
03:12 - going to work and make sure
03:14 - all the parts are thought out for
03:15 - example if we didn't think about the
03:16 - sign up button at the top and we wanted
03:18 - to put something else at the top it gets
03:20 - a little clearer up there you just want
03:21 - to think about it
03:22 - now the design doesn't only include how
03:24 - the app looks
03:26 - there's also the architectural design of
03:28 - it
03:30 - so for this app it's pretty simple we're
03:32 - going to have
03:33 - we're going to have the main
03:35 - which will
03:36 - check for authentication
03:40 - and this is not a widget this is just a
03:41 - check then if the authentication data
03:44 - hasn't been received
03:46 - we're going to show a loading screen
03:48 - if there's an error we're going to show
03:50 - an error screen
03:52 - if there's no user logged in we're going
03:53 - to take them to the login screen
03:56 - and then finally if they are logged in
03:57 - we're going to take them to the home
03:58 - screen
04:00 - now inside these two
04:04 - inside the login screen will have a
04:08 - username widget
04:10 - a password widget
04:15 - and then two buttons
04:17 - then on the home screen we're going to
04:18 - have a
04:20 - sign out button
04:22 - and add to do widget
04:24 - and then a list of the to-do's
04:31 - so this is pretty much the way to treat
04:33 - there is software like jaw.io that you
04:35 - can use but
04:37 - this works for us
04:39 - so that's all the planning we're going
04:40 - to do for this specific app but a more
04:42 - complex app should have
04:44 - days or even weeks of planning in my
04:47 - opinion
04:48 - the things you need to think about are
04:50 - object oriented principles and stuff
04:52 - like that you can look up the
04:54 - principles called solid and
04:57 - grasp those will help you
05:00 - separate the widgets out and keep your
05:02 - architecture clean
05:04 - all right and next is to create some
05:05 - sort of version control and some way to
05:07 - be organized
05:08 - i think almost everybody uses github
05:10 - nowadays so make sure you create a
05:12 - github project and
05:14 - create some tickets and issues in there
05:16 - that you want to work on things like
05:18 - that
05:19 - and then finally we can start on the
05:21 - code so
05:22 - so i'll go do that right now i'll set up
05:23 - a new flutter project and a new firebase
05:26 - project and connect to it
05:28 - okay so we got our firebase project with
05:30 - the email and password sign-in method
05:32 - enabled we're able to run our app once
05:34 - to make sure it works
05:35 - so then i imported these three packages
05:37 - so we could use everything we need with
05:38 - firebase and then also lint along with
05:42 - analysis options.yaml so we can have a
05:45 - static analysis tool
05:47 - that
05:48 - tells us where we can improve our app
05:50 - performance so here you see problems
05:52 - with const
05:54 - we can add that before
05:58 - and now our app will technically be a
05:59 - little bit faster
06:01 - now we got a little bit more preparation
06:02 - before we're ready to start i'm going to
06:04 - set up our folder structure folder
06:06 - structure is very important to make sure
06:07 - you have everything organized
06:09 - and you can access it real quickly so
06:12 - this is the one i use but every project
06:14 - should be a little bit different
06:16 - depending on what it needs
06:18 - so i have a screens folder
06:21 - a models folder
06:23 - a services folder
06:26 - and a global widgets folder
06:29 - or we'll just call it widgets
06:32 - so models are like bits of data that go
06:34 - together for us we're going to use a to
06:36 - do model
06:37 - which will basically consist of data
06:39 - that is included within every to-do
06:42 - then we have screens we're going to have
06:43 - the login screen on the home screen
06:45 - services we're going to have two
06:46 - services authentication and the database
06:49 - service
06:51 - and then we have global widgets
06:53 - we're only going to have one in there
06:54 - called the to do card
06:56 - which basically will make all our
06:57 - to-do's look the same
07:00 - so now we're ready to start not yet
07:02 - there's still some more decisions to
07:03 - make
07:04 - now the final decisions you should think
07:06 - about before starting your app whether
07:08 - you want to do tdd which is test driven
07:10 - development this is actually a really
07:12 - great way to write apps but
07:14 - i personally don't like it too much
07:16 - because i find a little bit boring i
07:17 - like to write a little bit of code and
07:19 - then write the test for it right after
07:21 - then there's
07:23 - the state management decisions for us
07:25 - we're not going to use any state
07:26 - management solutions other than set
07:28 - state because it's such a simple app but
07:30 - state management is a huge topic and
07:32 - will definitely clean up your app
07:33 - architecture a lot so definitely take a
07:35 - look at the top three our provider get x
07:37 - and block
07:39 - so you could take a look at look at each
07:40 - of those and see which one you prefer
07:42 - and now finally i think we're ready to
07:44 - get started
07:45 - so one thing to keep in mind when you're
07:46 - building an app keep things simple and
07:48 - keep them iterative
07:50 - so that means do one small part at a
07:52 - time make sure you check all of it
07:54 - everything works and test it all those
07:55 - things
07:57 - so the first part we're going to start
07:58 - with is getting our connection to
08:00 - firebase working
08:02 - so this part's actually pretty simple
08:04 - there's a new firebase.flutter.dev
08:06 - website that
08:08 - kind of helps you out
08:10 - and this is the initialization code that
08:12 - we're just going to copy
08:14 - and
08:15 - paste right in here
08:21 - so
08:21 - the code in here runs the app
08:24 - you first initialize the app
08:26 - and return a future builder
08:29 - which depends on that initialization
08:32 - so this future builder pretty much
08:35 - takes in the future and builds depending
08:37 - on what state that future is in
08:39 - so if the future has an error we're
08:41 - going to return
08:44 - a scaffold with
08:47 - a center
08:49 - child
08:52 - text error
08:56 - very simple and then you see the blue
08:57 - that's our linter popping up saying we
08:59 - need to fix that
09:03 - then if our connection is done that
09:04 - means it was successful
09:06 - and you can go to your app
09:08 - we're not going to touch that yet
09:10 - and then the last case is it's still
09:12 - loading that if it doesn't have an error
09:14 - and it's not done yet then you know
09:17 - the only option left is it's loading
09:19 - we're going to return the same thing
09:21 - except we're going to say loading
09:23 - now the most important part if the
09:25 - connection is done and secure we're
09:27 - ready to move on to our app
09:29 - also one thing to keep in mind we're
09:31 - going to go through this code a little
09:32 - bit fast because
09:33 - there's a good amount of code in there
09:35 - but we want to mainly focus on the
09:37 - testing aspect of it
09:38 - but i still want to go through the code
09:40 - a little bit so you kind of get like a
09:41 - thought process of how
09:43 - you think through building an app
09:46 - so we have our firebase connected
09:49 - now there's another precondition we need
09:51 - to check whether the user is
09:52 - authenticated or not
09:54 - so we're going to do it inside
09:56 - a root widget
09:58 - which is going to be stateful
10:01 - so you can put this in another file but
10:04 - for simplicity i just put it in here
10:07 - and this is going to send us to our root
10:09 - so root is going to decide where the
10:11 - next page is
10:13 - so now inside our widget we're going to
10:14 - create our firebase auth instance
10:20 - firebase auth
10:22 - i'll call it auth and then
10:25 - firebase.instance
10:29 - and then while we're here might as well
10:30 - create a
10:32 - firestore one
10:35 - firebase firestore
10:39 - so then we get into the actual return
10:40 - type
10:42 - i like to use a stream builder for the
10:43 - authentication because anytime anything
10:46 - changes with your authentication state
10:47 - it'll be updated because it's being
10:50 - streamed
10:52 - so the way we do this is we need to give
10:53 - it a stream
10:55 - and our stream is actually not defined
10:57 - here
10:58 - so we're going to have an auth stream
11:01 - so remember i told you there was going
11:02 - to be two services that we have one for
11:04 - connecting to the database which is
11:06 - firestore and then one for the
11:07 - authentication
11:09 - so let's do the authentication part
11:14 - we'll have a file called auth.dart and
11:17 - here
11:18 - we'll have a class called auth
11:24 - we're going to pass in a firebase
11:28 - auth instance
11:33 - and does create a constructor for it
11:36 - and we're going to have three functions
11:37 - in here one is going to be a stream
11:40 - of
11:40 - type user which is a type return from
11:44 - firebase
11:46 - now we're going to get that from auth
11:48 - off state changes
11:49 - so any time the state changes will get
11:52 - returned a user and all the data for it
11:55 - so just like that
12:00 - then we'll have three other functions
12:07 - one's going to be called create account
12:13 - where we're going to need to pass an
12:15 - email
12:16 - and a password
12:20 - anything that's related to future i
12:21 - always make sure to wrap in a try and
12:23 - catch
12:24 - because if anything goes wrong then it
12:26 - gets caught here
12:28 - here we're not going to actually do
12:28 - anything we're going to re-throw it back
12:30 - but if you want to create any actions
12:32 - based off of a problem occurring like
12:35 - maybe a snack bar you want to make sure
12:36 - you return
12:38 - whatever you want to return
12:40 - then inside this try catch we're going
12:42 - to have
12:44 - create user with email and password
12:47 - really simple passing the email
12:49 - password
12:54 - and we're actually going to do
12:55 - email.trim
12:57 - just in case they put a space after it
13:01 - then if that's successful
13:03 - we're going to return
13:06 - success
13:08 - and now the reason i made a return a
13:09 - string is because we're going to also do
13:12 - an on
13:13 - firebase auth exception
13:16 - now we're going to catch that as well
13:20 - and return
13:22 - a dot message for that
13:24 - so basically
13:26 - if there's an exception from firebase
13:27 - auth
13:28 - it catches it in this variable e and
13:30 - it'll return a message for you basically
13:32 - why it failed
13:34 - then we can return that from this
13:35 - function give a little snack bar or
13:37 - something telling them
13:38 - that it failed
13:40 - and why
13:41 - so we have two more functions one for
13:43 - signing in and one for signing out
13:46 - i don't think we need to go through that
13:47 - they're going to be pretty much the same
13:59 - all right so that's it that's our three
14:00 - functions that's all we're going to need
14:01 - for the authentication
14:03 - notice how clean this code is all we're
14:05 - going to have to do is call this create
14:07 - account function and everything is going
14:09 - to be handled for us
14:11 - so now in the main we finally have
14:14 - our auth
14:16 - class
14:18 - and remember we need to pass in
14:21 - a parameter called auth
14:23 - and then the string that we're looking
14:25 - for is for the user stream
14:29 - this error as we'll see is because it's
14:30 - not a named
14:32 - parameter and you just do that by adding
14:34 - in brackets
14:36 - to make sure it's named i like to make
14:38 - sure everything is named for myself
14:41 - so we have our stream defined now
14:45 - the builder
14:47 - notice everything's filled out for us we
14:48 - have our context and
14:50 - a snapshot of our current user
14:52 - if our snapshot
14:55 - connection state is equal to connection
14:58 - dot
15:00 - dot active
15:01 - which means our authentication stream is
15:04 - active basically
15:06 - otherwise you want to return another
15:07 - loading state just like that
15:11 - now if it is active we have a couple
15:13 - more conditions to check
15:16 - so snapshot.data
15:20 - and we can look for the uid
15:23 - if the uid is no then we know there's
15:26 - nobody logged in
15:28 - otherwise uid is not null we'll know
15:31 - there's someone logged in
15:32 - so these two screens are going to be
15:34 - real simple so i'll make those real
15:35 - quick and be right back
15:38 - all right so both of those are done
15:39 - they're both very simple
15:41 - the login screen has two text form
15:43 - fields and two raised bonds that don't
15:45 - do anything just now
15:47 - and the home screen just has an app bar
15:53 - so here
15:55 - if the snow return
15:57 - login
15:59 - with an authentication
16:02 - of auth
16:05 - and a firestore of firestore
16:09 - now we're doing a lot of passing
16:10 - authentication and firestore everywhere
16:13 - this is why i think you should use some
16:15 - sort of state management because you
16:16 - only need to pass those around
16:17 - everywhere but
16:19 - it's not too bad for us
16:22 - then over here we're going to return the
16:24 - home screen
16:27 - and we're going to need an auth of
16:29 - auth again
16:31 - and firestore of firestore
16:35 - now within the to-do widget
16:37 - we have the two functions for signing in
16:39 - and create an account
16:41 - all we do here is call those functions
16:42 - we created so this will return a success
16:45 - or the error message if you remember
16:48 - we're gonna need to do auth and sign in
16:51 - the user
16:53 - with
16:53 - email
16:56 - from the email controller
17:02 - and password
17:05 - from the
17:07 - password controller
17:11 - dot text
17:13 - then we can check if the
17:16 - return value is equal to success
17:22 - then we can clear those controllers
17:25 - otherwise let's display a
17:27 - snack bar
17:28 - with the return value because remember
17:30 - we'll return the error
17:34 - okay
17:37 - copy paste that
17:39 - and add it here obviously it'd be nice
17:41 - to have another function like this but i
17:43 - think since it's such a small piece of
17:44 - code it's okay and we only do it twice
17:46 - so
17:47 - not too bad
17:50 - long screen should be done
17:52 - and i think we can run the app at this
17:54 - point and see if it works or not
17:56 - and of course things can't work on the
17:58 - first try like that
18:00 - but it's actually pretty simple we never
18:02 - wrapped it in a material app or anything
18:05 - so make sure this future builder is
18:07 - wrapped
18:10 - in a material app
18:14 - and then this should be the home
18:16 - and we might as well add some theme
18:19 - and make it dark theme because you know
18:21 - we're programmers that's
18:22 - that's kind of what we stick to
18:24 - and there we go
18:26 - let's see if it's working so we create a
18:28 - username
18:30 - let's just type anything
18:31 - signed in
18:32 - password is invalid and the user does
18:34 - not have a password or the user doesn't
18:36 - have a password okay
18:38 - so let's try
18:41 - taught us
18:42 - gmail.com
18:44 - password one two three four five six
18:47 - sign in
18:48 - there is no user record correspondence
18:50 - identifier user may have been deleted
18:52 - okay then let's create an account first
18:55 - we created an account and there we go
18:57 - we're back in the home screen
19:01 - now last part before we start testing
19:03 - is let's actually create do something
19:05 - when we try to sign out
19:07 - here we need an auth again
19:10 - we have our authentication pass to this
19:14 - and we can just do sign out
19:16 - easy
19:17 - and now hopefully we click it and we'll
19:19 - go back to the main screen
19:22 - now we're able to type in our email
19:23 - again
19:26 - and this time we're able
19:28 - we're not able to create an account just
19:30 - email our address is already in use but
19:32 - we're able to sign in
19:34 - there we go that's our full complete
19:36 - login process now after this stage is
19:39 - where the testing begins
19:41 - so the nice thing about test driven
19:42 - development or tdd is that at this point
19:45 - you're pretty much done you know your
19:46 - app is fully tested
19:48 - and that everything works
19:50 - but for us we don't have that yet so
19:54 - we're gonna add some unit tests
19:57 - so what unit tests are they basically
19:59 - test
19:59 - the unit per se so
20:02 - a unit is just a function pretty much
20:05 - and the only things that really make
20:07 - sense to test in this application are
20:08 - these functions that we have
20:10 - create account sign in and sign out you
20:13 - also want to make be careful about not
20:15 - writing useless tests you don't need to
20:18 - write a test for every little simple
20:19 - thing you do
20:21 - in fact there's probably an argument
20:23 - that these don't really need to be
20:24 - tested since
20:25 - firebase already tests this for you
20:28 - and you're not really
20:30 - you're not really testing much but just
20:32 - for demonstration we're going to go
20:33 - through it so the reason i wanted to go
20:35 - over is because these tests could be a
20:37 - little bit more complicated given that
20:39 - they need mocks in them
20:42 - so we're going to need to add some more
20:43 - dependencies in here
20:45 - we're going to add more keto and then
20:48 - we're also going to add flutter
20:51 - driver
20:52 - and test
20:54 - but those are for
20:55 - the integration test
20:57 - for this one we only need mokito and
20:59 - flutter test
21:00 - so each of your tests needs a main
21:03 - and then inside your again you can have
21:05 - a setup
21:06 - and a teardown
21:09 - so what these are the setup runs before
21:13 - every single test and the teardown runs
21:15 - after every single test then checking
21:17 - back to this class what was the one
21:18 - thing i said we're going to need this
21:19 - firebase auth in order to do anything we
21:21 - need this authentication
21:23 - but for us we're going to be mocking it
21:24 - so it's not calling the actual
21:26 - database
21:28 - so like i said the thing we need to mock
21:30 - is the
21:31 - authentication class
21:33 - so we will create a mock auth class
21:36 - the way you mark it is you need to
21:38 - extend that class with with a mock
21:42 - you'll see we have a library imported
21:44 - the mokito library
21:46 - and then it implements our firebase auth
21:49 - class
21:51 - so basically this says we're mocking our
21:54 - firebase auth class and this is the
21:56 - class that will contain all the mocks
21:59 - so once we have our class defined
22:01 - we can create an instance of it
22:04 - and now we will be able to use this for
22:06 - all our tests
22:09 - so our first test
22:11 - we're going to call
22:14 - emit
22:14 - occurs
22:16 - so we're going to test that this off
22:18 - state changes actually emits and we get
22:20 - a user from it
22:22 - we do that
22:23 - by overriding the function up here
22:26 - so auth state changes you just type it
22:29 - out i'll send you this whole thing
22:32 - and what we'll need to use
22:34 - is a
22:37 - string dot from iterable
22:40 - now inside here we're going to iterate
22:42 - over
22:43 - the type of objects that you use
22:45 - so you saw this should return our user
22:48 - so we're going to do is create a mock
22:50 - user as well so we'll have mock user
22:53 - extends mock implements
22:58 - user
23:00 - then here we can return a mock
23:03 - user
23:04 - so before we get to the actual test case
23:06 - i want to change this name to mock
23:07 - firebase auth
23:11 - just to make sure we're all clear
23:13 - that this is the firebase authentication
23:17 - our our class is actually called mock as
23:19 - well so we're not mocking this class
23:20 - we're mocking the firebase auth that
23:22 - we're passing in
23:24 - so now we can create our instance of our
23:26 - auth class as well
23:28 - and remember we have to pass in an
23:30 - authentication
23:32 - and that authentication would be mock
23:34 - firebase auth
23:36 - so there now we have our auth class that
23:38 - we can use for all our tests
23:41 - so here we want to call expect later
23:44 - which is for
23:46 - anything with futures
23:49 - and we're expecting the auth user class
23:51 - to return
23:53 - a stream
23:55 - which we can check by emits
23:58 - and order
24:00 - and inside here we'll have the mock
24:02 - user
24:05 - so there we go
24:06 - now if we run it well you'll actually
24:08 - see a problem
24:12 - there
24:14 - so we were expecting an emit of the type
24:18 - mock user
24:19 - instead we got an instance of generated
24:22 - stream of just user
24:27 - so what happened here
24:29 - well in flutter if you have two
24:30 - instances of an object
24:33 - let's say you do this simple
24:36 - check if you do mock user
24:38 - is equal to
24:40 - mock
24:41 - user even though they are exactly the
24:43 - same this will always return false this
24:46 - is because
24:47 - a separate instance of a mock user is
24:49 - not equal to a different instance
24:51 - there are packages like equatable and
24:54 - other ones i'm pretty sure that actually
24:56 - check the properties within i tell you
24:58 - whether they're equal or not but since
25:00 - we're not using that we have another
25:01 - option
25:02 - you can create a variable
25:04 - for mock user
25:06 - and then use the same instance within
25:09 - this iterable
25:11 - and this emit check
25:14 - so now if we save
25:17 - and run
25:18 - everything passes
25:22 - great so we got the mission there
25:24 - now go back to this function
25:26 - and we need to check this first part
25:28 - whether create an account works
25:30 - so you can copy paste that
25:32 - and check create
25:36 - account
25:37 - so here the difference is we want to
25:38 - mock an actual
25:40 - call to database so we want to mock this
25:42 - create user with email and password
25:44 - we're not trying to override it like we
25:45 - did here we're trying to
25:48 - catch it and then return something of
25:50 - our own instead of the database
25:52 - so you you will need to do when and then
25:54 - inside
25:56 - basically do when the mock mock firebase
25:58 - auth dot
26:00 - create user with email and password gets
26:02 - called
26:03 - with the fields we'll say
26:05 - tardis gmail.com
26:09 - and password
26:11 - one two three four five six
26:14 - so when that happens
26:17 - then answer
26:18 - and we put in whatever value we wanted
26:20 - to answer with
26:22 - so actually in this case
26:24 - we don't really care where it answers it
26:26 - will just return success no matter what
26:28 - the answer is
26:30 - unless it throws an exception that's the
26:31 - only way it doesn't return a success
26:34 - and it will throw an exception if this
26:36 - wasn't
26:37 - successful basically
26:40 - so
26:41 - we mark it we don't really care what the
26:43 - return is
26:44 - and then we can do an expect
26:47 - where we await
26:50 - our
26:51 - auth class
26:54 - create account
26:57 - and we want if we don't pass anything
26:59 - that means
27:00 - these aren't going to get called to the
27:02 - specific fields that we mentioned here
27:04 - so want to make sure we pass
27:06 - the email of tatus gmail.com
27:11 - and password of
27:13 - one two three four five six now since it
27:16 - gets called with those exact fields
27:18 - it'll return with a
27:20 - success
27:22 - okay
27:24 - let's try to run it
27:26 - perfect
27:27 - it works
27:29 - now we could check the same thing except
27:32 - for this firebase auth exception make
27:33 - sure the exceptions actually work
27:36 - create account exception
27:39 - so when this function gets called
27:41 - instead of turning null let's actually
27:44 - throw
27:45 - a firebase auth exception and you can
27:47 - put your own message like
27:50 - you screwed up
27:52 - now we can actually copy this message
27:55 - and that should be our return for that
27:57 - function
27:58 - now we can run all three actually to
28:00 - check
28:01 - all the past perfect
28:05 - now i'm going to copy paste these
28:08 - and we'll do for
28:11 - sign in
28:13 - i will do sign in with email password
28:15 - pass those in
28:18 - sign in
28:20 - that should run
28:24 - sign in exception
28:28 - you do sign in with email password
28:31 - sign in function gets called perfect
28:34 - now we should be able to run those
28:40 - that one runs
28:43 - this one runs
28:45 - and then we could do the same thing with
28:47 - sign out
28:49 - these don't need any calls
28:53 - let's check how this function works so
28:54 - success if it's no
28:56 - and same thing with exception
29:00 - very easy sign out
29:03 - and there we go now we can run all of
29:05 - these tests
29:08 - and we have one two three four five six
29:10 - seven eight tests that i'll pass
29:13 - let's say firebase gets updated or
29:15 - something and the sign out function
29:17 - works differently our tests will not
29:18 - pass anymore and now we have full
29:20 - coverage for all of our authentication
29:22 - functions
29:23 - and let's say firebase updates they no
29:25 - longer throw a firebase auth exception
29:27 - they throw something else
29:28 - then one of our tests is going to fail
29:30 - when we run it
29:32 - because we only catch a firebase auth
29:34 - exception
29:35 - we don't catch the other ones
29:37 - so our code is more safe and you'll be
29:38 - able to catch problems with anything you
29:40 - interface with and you'll know that it's
29:42 - not your app that's actually broken into
29:44 - something else so that's it now there's
29:46 - another type of testing called widget
29:48 - testing
29:49 - would you basically test your ui
29:52 - the thing is we don't really have
29:54 - anything that's driven with the ui here
29:57 - we just have a sign in screen that
29:59 - is based off of the firebase
30:01 - database it's not really
30:03 - ui changes right
30:05 - so we'll come back to that and the
30:07 - integration tests after we do the to-do
30:09 - lists
30:10 - so for this next part we're just going
30:11 - to go through the database interfaces
30:13 - because the rest is just making ui to
30:15 - work with it and i don't think that
30:17 - brings too much value for you guys
30:21 - so we're gonna need a to do model
30:24 - and here we're gonna have a
30:26 - to do model class
30:28 - with a to do id
30:33 - the content of the to do
30:36 - and then whether it's finished or not
30:39 - then we're also going to give it a
30:41 - name constructor from
30:44 - document
30:46 - snapshot
30:50 - going to want to pass in a document
30:51 - snapshot for it then in here just simply
30:55 - set the to-do id
30:57 - equals document snapshot dot
31:01 - id
31:02 - content equals
31:05 - document snapshot.data
31:12 - content
31:14 - as string
31:15 - and then same thing for the done
31:19 - except as boolean
31:22 - okay
31:24 - so now our database class
31:26 - we're gonna need to pass in firebase
31:29 - firestore
31:30 - and the constructor for that and then
31:32 - we're going to have
31:33 - a stream of the list of to-do's that we
31:35 - have
31:37 - so stream of list of to-do
31:40 - model
31:43 - i'm going to call that function stream
31:45 - to do's
31:47 - and all we need is the uid of the user
31:50 - so the way our database is going to work
31:52 - we're going to have a collection called
31:53 - to do's
31:55 - then have a document with the uid
31:59 - and then within that uid we're gonna
32:00 - have the to do for that specific
32:04 - user and then we're gonna have the to-do
32:06 - id
32:08 - content
32:09 - and
32:10 - done
32:13 - so that's what our database is going to
32:14 - look like
32:16 - very simple
32:18 - and easy to use
32:20 - so for the stream
32:22 - we want to again try catch as always
32:26 - and we will try to return
32:28 - firestore
32:29 - that collection
32:31 - remember to do's collection
32:34 - that document
32:36 - of
32:37 - the uid we passed in
32:40 - and then that collection of to do's
32:47 - and we only want to get the ones
32:51 - where the done field
32:52 - is equal
32:54 - to false
32:57 - and then we want the snapshots of that
32:59 - so that returns a stream but we want a
33:01 - stream of lists of to-do models
33:04 - so we gotta map it to such a list
33:07 - these snapshots will return a query for
33:10 - us
33:12 - and then
33:13 - i like to space it out even more
33:19 - we will have a list of to do models that
33:22 - we want to return
33:27 - at the end we got to make sure to return
33:29 - that
33:30 - and then here we're going to have a for
33:31 - loop for
33:35 - each document
33:38 - in
33:41 - query dot docs
33:44 - so all the documents that that query
33:45 - returns we're going to iterate through
33:46 - every single one
33:48 - and then
33:50 - append to the list we have
33:54 - with a to-do model
33:57 - from document snapshot
33:58 - and a pass in that document
34:03 - okay that was a mouthful but
34:06 - it's not as bad as it looks
34:09 - so we return a query
34:11 - and then we go through every document of
34:12 - that query add it to this list then
34:14 - return that list
34:16 - through a stream
34:19 - that's pretty much it
34:20 - so then we have two more functions
34:22 - i'm just i'm just going to go over them
34:24 - with you there's not too much to them
34:26 - this one's to add a to-do if you
34:28 - remember we need the id and
34:30 - what the content of it is
34:32 - so we'll find the collection name to
34:34 - do's go to that specific uid go to the
34:36 - collection call to do's again and add a
34:39 - document with the content and the done
34:41 - field is false
34:43 - then we want to update that to do
34:45 - so we'll have the uid and then the to-do
34:48 - id so we're able to get to the specific
34:51 - to do item
34:54 - and we just update the done to true so
34:56 - i'll go ahead and make the ui and use
34:58 - this and then i'll be right back
35:00 - okay so here we have the home screen
35:03 - we have
35:04 - list app we can call it
35:07 - amateur
35:09 - coder
35:11 - to do instead
35:13 - nice
35:15 - so i have our sign at the top we have a
35:17 - text saying add to do here
35:20 - a text form field
35:22 - an icon button which calls our add to do
35:24 - function that we created
35:27 - and then a list of your to-do's inside
35:29 - of a stream builder which takes in the
35:31 - stream to-do's that we created
35:34 - and then similar to when we log in we
35:36 - have a snapshot if it's active
35:39 - and our data is empty means we don't
35:42 - have any to use want to return you don't
35:44 - have any unfinished to do's
35:47 - and if we do
35:49 - we have a list built listview builder
35:51 - which returns
35:52 - a list of to do cards
35:54 - and to do cards are just
35:57 - a card with an expanded text and a
36:00 - checkbox next to it
36:02 - and if we click on the check inside
36:03 - check box it will update our to do to be
36:06 - checked
36:08 - so let's see if it works for the fun of
36:11 - it go
36:12 - eat a hot dog
36:14 - we can add that
36:16 - go get a hot dog perfect
36:19 - if we refresh here
36:22 - showed up uid and then to do and here we
36:25 - go
36:26 - and the cool thing is
36:29 - if we update here
36:31 - you'll see it update right there right
36:32 - away
36:34 - and same thing we got a check box we
36:36 - click it it's gone from here that's
36:38 - turned to true
36:39 - and you're good to go
36:40 - if you want to implement another screen
36:43 - saying
36:44 - to do is that we're finished you can
36:46 - take this code and do it it's in the
36:47 - description
36:50 - but now to test it so remember the fact
36:53 - that i told you about there's no need to
36:54 - have useless tests
36:57 - all these things in firestore are
36:58 - already tested so writing tests for
37:00 - these doesn't give us much value
37:02 - actually
37:05 - so we're going to skip the unit test for
37:06 - this if you want to do it
37:08 - it's very similar to the way we did the
37:10 - authentication tests
37:13 - so you can try that on your own so thing
37:15 - with flutter is there's two more
37:17 - different types of tests there's widget
37:18 - tests and then there's integration tests
37:22 - now what widget tests are is they test
37:24 - how your ui reacts
37:26 - if you click or touch something so
37:28 - basically it's ui tests
37:30 - the thing about our app that we created
37:32 - is there's nothing driven by the actual
37:34 - ui
37:35 - everything is streamed so when you click
37:37 - this button you're not doing anything
37:39 - within the page
37:40 - you're actually just sending it to
37:41 - firestore
37:42 - and then unrelatedly the stream builder
37:45 - updates
37:46 - once the firestore
37:48 - data comes in
37:51 - so there's nothing really to widget test
37:53 - here but i still wanted to show you how
37:55 - widget tests work and i have a to do app
37:57 - that doesn't use a database so let's
37:59 - look into that okay so this is the to do
38:01 - app it looks pretty similar right except
38:04 - there's one big difference we have a
38:06 - controller
38:07 - and this list isn't being streamed from
38:09 - firebase or anything it's just a static
38:11 - list that we're holding in the app
38:14 - as well the database isn't actually a
38:16 - database it's just a future
38:19 - that returns
38:20 - from database and true
38:22 - so if we look at the app you can add
38:24 - things like
38:26 - hello
38:27 - add it
38:28 - and then load to do from database you
38:30 - load it in from database and it's
38:31 - checked
38:32 - but if we reload it
38:34 - it's all gone
38:35 - anyways this means it's ui driven now
38:38 - this button when we click it actually
38:40 - does something within our app before
38:43 - the button click sends it to the server
38:45 - and then comes back right
38:49 - so here we have some widget tests we're
38:50 - just going to go over them because
38:52 - i think widget tests have a lot of
38:53 - material online i think
38:55 - integration and unit tests are the ones
38:57 - that are a little bit less covered and
38:58 - if you want more information about
39:00 - widget test
39:01 - unit test and integration test i have
39:04 - videos more dedicated to that topic on
39:06 - my channel so make sure to check those
39:08 - out
39:10 - but we're gonna read through this simple
39:12 - widget test that i have so this test is
39:14 - called add a to do and remove it
39:17 - and you'll see
39:19 - we have this tester.pump widget
39:21 - so this pump widget basically means
39:24 - in its ram or in its memory it brings
39:27 - that widget
39:28 - up in the background
39:30 - like we don't need to we don't need to
39:31 - be running this and this test will work
39:33 - some background it launches this widget
39:36 - we wrap it in a material app because
39:38 - you need a material app to launch
39:40 - anything
39:41 - or at least use the scaffold
39:44 - then we launch our home screen
39:47 - then we have these
39:48 - add field and add button
39:50 - they have a value key on them
39:52 - so if you go back to our home screen
39:55 - you can add things called
39:58 - keys to the buttons and form fields and
40:01 - that makes it a lot easier to find them
40:04 - with our widget test
40:07 - you can also do
40:11 - find
40:12 - by type
40:15 - by type what type of widget it is by
40:17 - tooltip things like that there's more
40:20 - than
40:21 - more than just that way to find stuff
40:24 - and also we'll have find dot text get
40:27 - groceries
40:28 - so this basically looks through
40:30 - everything in the widget tree and see if
40:32 - there's a text called get groceries
40:36 - so now for the actual widget tests
40:40 - we use the widget tester
40:42 - the same one we use to pump the home
40:44 - widget
40:45 - so we bring the widget basically onto
40:46 - the screen
40:48 - we enter the text get groceries into the
40:50 - ad field we tap the add button
40:54 - and then we call this pump function
40:56 - which rebuilds
40:58 - just basically like set state does
41:02 - and then we can expect
41:05 - find a get groceries
41:09 - so message finder
41:12 - basically tries to find a text called
41:15 - get groceries
41:16 - now we tell it that it should only find
41:18 - one of them
41:20 - so we can run this now
41:22 - and it passes
41:24 - let's say we do finds nothing
41:28 - it doesn't find any widgets
41:31 - so basically we add a text field and
41:33 - we're expecting it not to show up
41:35 - we have a problem right there
41:37 - said it actually did find that
41:39 - so that's all we're going to cover for
41:40 - widget tests
41:41 - there's a lot more
41:43 - documentation on the flutter docs you
41:44 - can watch come to my channel check out
41:46 - the videos if you need some more help
41:48 - but it's not too complex
41:51 - the most complex one in my opinion is
41:53 - the integration testing okay so we
41:55 - covered unit tests which go over the
41:57 - function then we cover the widget test
41:59 - which goes over a whole widget and now
42:01 - the last one is integration test
42:03 - and that goes over the app as a whole
42:06 - but to do that you need to run the app
42:08 - there's no way you can really test the
42:09 - app as a whole
42:11 - without running it
42:13 - if you remember we added this flutter
42:14 - driver so this flutter driver is the one
42:17 - that pretty much does the
42:19 - driving of the integration tests
42:22 - so we're going to do is add another
42:24 - folder called test
42:26 - underscore
42:28 - driver
42:30 - and here we're going to need two files
42:32 - we're going to need a app dot dart
42:35 - and we're going to need a
42:37 - app underscore test.dart
42:40 - inside the app dot dot we're just going
42:42 - to copy the flutter documentation
42:45 - and this basically runs the main of our
42:47 - app
42:49 - call the main function of the app or
42:51 - call run app with any widget you are
42:52 - interested in testing
42:54 - so then for the actual app test we're
42:56 - going to go to the documentation again
42:57 - and copy the
42:59 - the code that they have
43:01 - okay now let's read through this so this
43:03 - imports the flutter driver api
43:05 - all good
43:06 - we have all the finders that we have
43:09 - just like we checked in the
43:11 - widget test except
43:13 - there's a by value key so
43:15 - it's a little different syntax but
43:17 - similar idea
43:19 - then in the setup we want to connect to
43:21 - the flutter driver and then close it
43:23 - whenever we tear down
43:25 - and then they have two tests here we can
43:27 - remove these tests
43:29 - we don't need them
43:31 - our first test will be
43:34 - create
43:35 - account
43:37 - we're actually gonna have three tests
43:38 - total so we could just
43:41 - put them in here already
43:43 - we'll have a create account we'll have a
43:45 - login
43:46 - and then we'll have
43:48 - add a to do
43:51 - so notice we're doing
43:53 - creating the account that means it has
43:55 - to call the firebase server right
43:59 - and that's perfectly fine with
44:00 - integration tests you can do that it
44:02 - actually builds the whole app with the
44:04 - firebase connected to it and you can
44:05 - actually run the
44:06 - tests but i would recommend doing this
44:09 - not on the production server and have a
44:12 - different firebase project that you
44:14 - connect when you do testing
44:16 - so what i'm going to do right now is i'm
44:17 - going to go through the whole app and
44:18 - add a bunch of these value keys
44:21 - because we need to use them
44:23 - so on the login we have the
44:26 - value
44:27 - key
44:29 - called username
44:31 - and we can make a constant and i'll be
44:33 - back when i do this with every widget
44:35 - that we're going to need to use
44:57 - okay so these are all the objects that
44:59 - we're going to be using in our
45:00 - integration test we have the username
45:02 - password sign in create account
45:04 - sign out button add field add button
45:08 - so now in the create account
45:11 - first
45:12 - i want to check
45:14 - if there is a sign out button present
45:17 - because this builds the app and launches
45:19 - it if our authentication is already
45:21 - there we're going to be already logged
45:22 - in this test is going to fail because
45:25 - we're already logged in with an account
45:28 - so there's this function i made called
45:29 - is present basically it looks for the
45:32 - value key and it waits for a certain
45:34 - timeout that we pass in which one second
45:37 - if it doesn't find it within one second
45:39 - it'll throw an exception we return false
45:41 - if it does find it within one second
45:44 - it will continue and we will say that it
45:46 - is present
45:47 - so pretty simple
45:50 - so we check
45:52 - if our sign out
45:55 - button is present
45:57 - then we want to await driver which is
46:00 - what drives the actual test
46:04 - and we want to tap
46:06 - on the sign out button
46:12 - so
46:13 - we'll check if it's there if it is sign
46:15 - out
46:18 - once that's done
46:20 - we're going to await
46:23 - driver like i said this thing basically
46:25 - does everything for you within the app
46:27 - you want to first tap on the username
46:29 - field
46:33 - just like you would use the app you got
46:34 - to tap there first in order to type
46:36 - right
46:40 - now i can copy it and
46:42 - enter
46:43 - text
46:45 - and here we'll enter let's say tatus1
46:48 - gmail.com
46:52 - taught us that gmail is already taken so
46:53 - we get an error in this case obviously
46:57 - i don't know if this create an account
46:59 - test is worth making since this is
47:01 - testing whether firebase works or not
47:04 - but
47:04 - we're just doing it for demonstration
47:06 - purposes
47:08 - hopefully you will learn something
47:11 - so then let's tap the password field
47:13 - enter the password very secure one two
47:16 - three four five six
47:17 - and then we finally
47:20 - tap the create
47:24 - account
47:25 - button
47:29 - so that should have done the test for us
47:32 - now what do we do next
47:34 - we just wait
47:37 - for
47:38 - find
47:41 - the text
47:42 - called your
47:44 - to-dos if you remember on the home
47:46 - screen
47:47 - there was added to do and then there was
47:49 - your to-do so we find the text we know
47:50 - this worked and now this integration
47:52 - test is done and we can run it
47:55 - so the way you run the test is you do
47:57 - flutter
47:58 - drive
48:00 - target
48:01 - and you put the test driver app.dart
48:03 - that we made over here as the target
48:07 - so this will enable the flutter driver
48:09 - extension then run your app
48:11 - and then run your tests
48:14 - so if we click it let's see what happens
48:17 - so i was in the wrong directory but then
48:19 - i got to the right one and here's us
48:20 - running the flutter driver
48:23 - and then there's multiple devices found
48:26 - i have an iphone connected an ipad and
48:28 - then this is the iphone 11 pro so we
48:30 - want two
48:32 - so there we go it's done and now it's
48:34 - launching it'll start off logged in i
48:36 - think
48:38 - it's logged in logged out you saw that
48:40 - got pressed
48:41 - and everything worked
48:44 - all your tests passed and now if we
48:46 - check firebase taught us one gmail.com
48:51 - so there we go
48:52 - that's how integration tests work
48:56 - now let's quickly add these last two
49:01 - we'll pretty much copy this one
49:04 - if it's present sign out
49:06 - if it's not enter the password and then
49:07 - instead of create account button
49:09 - let's do sign in button
49:12 - then add a to do
49:13 - we want to check if it is signed in
49:16 - already just because we don't want to do
49:18 - be doing to-do's while we're in the
49:20 - login screen
49:22 - if it is
49:23 - tap the add field
49:25 - which is this part
49:27 - enter the text
49:31 - make a video for free code camp
49:34 - then tap the add button
49:37 - and then let's
49:38 - wait
49:40 - for
49:42 - the text
49:46 - make a video for free code camp to show
49:48 - up
49:49 - also you can add your own timeout in
49:51 - here if you want
49:53 - let's stay say three seconds
49:57 - make that constant again
49:59 - and now let's remove this tata suana
50:01 - gmail
50:03 - so get that problem again
50:05 - and we can run our
50:08 - integration test again
50:14 - it's running you see logged in logged
50:16 - out log back in and created us to do for
50:18 - make a video for free code camp
50:22 - nice that was pretty cool
50:24 - i wish you could slow it down a bit
50:26 - so there we go we have created a pretty
50:28 - robust to-do list app
50:30 - uh it has unit tests it has integration
50:32 - tests it doesn't have any widget test
50:34 - but if there was anything ui driven
50:36 - would have definitely done it there's
50:38 - also one more type of testing called
50:39 - functional testing
50:41 - this is pretty manual so i didn't really
50:44 - go over that but
50:46 - you also want to make sure you play
50:47 - around with your app by yourself make
50:48 - sure the ui looks good like for example
50:51 - all our tests would have still passed if
50:53 - this to do screen right here if this to
50:56 - do was
50:57 - off the screen it would have still
50:58 - worked because it's technically within
51:00 - the widget so you want to make sure
51:02 - everything looks good as well
51:04 - and the animations behave as as you want
51:06 - things like that
51:09 - now the last point i wanted to go over
51:10 - was maintainability
51:12 - things you should keep in mind as you
51:13 - work on this project because i'm sure
51:15 - you made a to-do app
51:17 - there's a lot of updates i want to push
51:18 - to this right to make it even better
51:21 - so one thing one great thing for
51:23 - maintainability is to set up a ci cd
51:25 - pipeline
51:26 - ci cd stands for continuous integration
51:29 - and continuous deployment or delivery i
51:31 - don't know i've seen both basically this
51:33 - gives you the ability to set up a
51:34 - pipeline where you push your changes to
51:36 - the master
51:38 - and then it runs a test for you it
51:40 - builds the code it checks everything and
51:42 - deploys the app store all automatically
51:45 - i think it's very useful and
51:47 - makes it more reliable that like your
51:48 - release will happen the same exact way
51:50 - every time
51:51 - i have a video about this on my channel
51:53 - if you want to check it out
51:55 - it's for code magic with flutter it
51:57 - seems to be the go to ci cd platform for
51:59 - flutter another big thing is to make
52:01 - sure you keep up with your tests as you
52:03 - go because i know
52:04 - even if you do it at the beginning it's
52:06 - hard to always keep up with them but
52:08 - they will definitely save you time in
52:09 - the future when you have updates make
52:11 - sure you break it down in github keep it
52:12 - organized make sure you
52:14 - break it down into simple tests because
52:16 - you want to make sure you incrementally
52:18 - change and everything works
52:20 - incrementally this way you can track
52:22 - where things go wrong and make sure they
52:24 - don't go wrong i guess in the first
52:25 - place
52:26 - and then as you keep building up to it
52:28 - if you keep your architecture principles
52:31 - in check and keep your testing up to
52:33 - date you will be a lot more confident
52:35 - about your app and you'll be
52:37 - able to release the app store with less
52:39 - bugs and people will enjoy the user
52:41 - experience a lot more
52:42 - and as you go forward i'd make sure you
52:44 - go through the whole process we went
52:45 - through today for every change make sure
52:47 - you check the requirements go through
52:48 - the design
52:49 - the widget tree planning all that stuff
52:52 - it might be a little bit tedious but for
52:54 - smaller changes it won't shouldn't be
52:56 - that bad and it'll definitely make your
52:58 - process a lot more smoother so that's
53:01 - been it for me once again i'd like to
53:02 - thank free code camp for giving me this
53:04 - opportunity
53:05 - if you want any more in-depth details
53:07 - about any of the topics we covered make
53:09 - sure to come to my channel i have videos
53:11 - on almost all these i think this code
53:13 - will be in the description and i'll also
53:15 - add the code for the widget testing as
53:17 - well
53:18 - and that's it for me thank you for
53:19 - watching