00:03 - so the primary purpose of this video
00:05 - series is gonna be for analyzing not
00:07 - just algorithms but also primarily
00:10 - pieces that are can be utilized not just
00:11 - a computer science but also for
00:12 - interviews and we're gonna be starting
00:14 - up with something called the Big O so
00:15 - really quickly and we're gonna be doing
00:17 - this all in the Jupiter notebook
00:19 - primarily because it's not that
00:20 - difficult enough that we have to use
00:22 - pycharm and it's also a little bit
00:24 - cleaner looking so why analyze
00:26 - algorithms in the first place so an
00:27 - algorithm don't get nervous but the word
00:28 - is just a procedure or formula for
00:30 - solving a problem some of them are so
00:32 - useful that we've given them names like
00:35 - merge sort or bubble sort etc and then
00:38 - one of the important things were going
00:38 - to come across you're gonna see very
00:40 - quickly is how can we compare the
00:41 - algorithms you know which is better and
00:43 - by better it's gonna be relative term to
00:45 - the task at hand but typically there's
00:47 - gonna be two avenues for analyzing if an
00:50 - algorithm is better than another and
00:51 - that's going to be either by speed time
00:53 - of completion and that's gonna go into
00:56 - its scalability and also memory its size
00:59 - allotment and its requirements and so
01:01 - forth
01:02 - so really quick let's jump in so in this
01:05 - first segment of code I said it magic
01:06 - about this function this is just
01:08 - defining a function called sum of 1 it's
01:10 - taking one argument n so then we have
01:12 - final sum equals zero so we have an
01:14 - object final sum and we're giving a
01:15 - assignment of zero and it says for X and
01:17 - range n plus 1 so we have a for loop
01:19 - here range is gonna be whatever we
01:21 - define it for in terms of the hands I'm
01:23 - plus 1 equals final sum equals front of
01:25 - sum plus X and then we're returning the
01:27 - final sum so I'm just going to shift
01:31 - enter so that it actually loads into the
01:33 - jupiter notebook and then i have here
01:35 - some one and calling five is the
01:36 - argument and you'll see that it prints
01:38 - out 15 so what this did was with a with
01:42 - the object having the argument of 5 and
01:44 - the formula essentially the algorithm
01:47 - for this was for x and range so for each
01:49 - number in range and plus one and was 5
01:52 - so in 6 you have to remember for range
01:54 - we started zero so we had to add that
01:56 - one of wanted to really get 5 actual
01:58 - numbers so cos 0 is not gonna have any
02:00 - implication for addition and the final
02:03 - sum was starting with 0 so if we did 5
02:06 - times 4 we're gonna have 9 at 9 plus 3
02:08 - is 12 12 plus 2 is 14 14 plus 1 is 15 so
02:14 - of course we got the answer to be 15
02:16 - that's appropriate so let's see what
02:18 - this is all going towards anyway so
02:20 - again this is a function that we've
02:22 - created defining a sum of 1 and we got a
02:24 - result of 15 when N equals 5 we're gonna
02:28 - go down here now for this point and
02:29 - let's assume that you gave me this
02:31 - function you called it some two also
02:33 - taking only one argument of N and you
02:37 - instead of doing a for loop you're just
02:39 - returning n times n plus 1/2 and let's
02:43 - see what we get I'm going to shift into
02:45 - through that as well and same argument
02:47 - of 5 and we also get 15 same as that
02:51 - function if you actually did this math
02:53 - by hand of course
02:54 - PEMDAS is gonna hold place so
02:56 - parentheses are always gonna be first so
02:58 - you would have had 5 plus 1 which is
03:00 - going to be 6 6 times 5 is 30 30 divided
03:04 - by 2 is going to be 15 so what's the
03:07 - point of this essentially we got the
03:09 - same answer with two very different
03:11 - functions
03:12 - that's essentially that's that's the
03:14 - point of this so this is my function I
03:15 - created and this is the one that you
03:17 - created both getting the same result so
03:20 - function one is someone's gonna complain
03:23 - about that I and a few so function of
03:28 - someone it's using a for loop to iterate
03:31 - iteratively add across our range of plus
03:34 - one so here's our for loop and we're
03:36 - just iterating over the range that was
03:38 - dictated by the input n and it's adding
03:41 - across that range
03:42 - number two is simply just taking
03:44 - advantage of a formula it's a formula
03:46 - basis solve a problem
03:47 - both of these are technically algorithms
03:49 - because remember the algorithm is a
03:51 - procedure or a formula for solving a
03:52 - problem so we're solving a problem and
03:54 - here we're suffering a problem this is
03:56 - just more formula based and this is an
03:57 - iterative four loop that we're running
04:00 - so now the question is gonna come how do
04:02 - we compare them how do we determine
04:04 - whose function is better mine or yours
04:06 - and that's gonna become relative to what
04:08 - it is you're trying to determine defines
04:10 - is better so we have to objectively be
04:12 - able to compare them and the two places
04:15 - the two avenues I mentioned before that
04:16 - we can do the for is memory which is
04:19 - space allocation within the computer or
04:20 - the time to run how much time is it
04:22 - going to take to actually run that
04:23 - software so we're going to use built-in
04:25 - magic magic commands in the note the
04:28 - jupiter notebook
04:29 - times I might call ipython that's the
04:30 - old connotations back then it was just
04:32 - pi thana now it's multiple languages so
04:35 - they call it Jupiter notebook so first
04:37 - of this this is a magic command using
04:39 - the % side time it and I'm saying I want
04:42 - you to time it for the sum of one
04:43 - function with an N of 100 so I'm gonna
04:46 - shift unto that and right now what it's
04:48 - doing it's doing that for loop so there
04:50 - we go we got a hundred thousand loops
04:51 - best-of-three three point seven four
04:53 - microseconds per loop and then I'm gonna
04:55 - do with these same magic time at some
04:58 - two with a hunter as the input and then
05:00 - did you do oh it's doing the computation
05:02 - now it's like a second there depending
05:04 - on your computer it's going to determine
05:05 - if it happens faster or slower so for
05:10 - the same n of 100 which we know that
05:12 - they're going to give me the same answer
05:13 - and you can ignore this for right now
05:16 - it's just talking about caching that's
05:19 - the 344 but now this is nanoseconds so
05:23 - and I put down here just for those human
05:25 - I know micro which is up top here is ten
05:27 - to the minus six
05:28 - nano is ten to the minus nine so that
05:30 - means nano is a smaller number by a
05:32 - factor of three and so this is faster so
05:36 - in the two different functions we had
05:38 - function of some one a function of some
05:40 - two for the same n my algorithm your
05:43 - algorithm your algorithm was a function
05:46 - was much much faster
05:48 - you are nanoseconds that was a
05:49 - microseconds for time of completion but
05:52 - now that's not necessarily the end-all
05:53 - be-all because that's the time of
05:55 - completion of my computer your computer
05:57 - the time of completion might be faster
05:59 - or slower now of course granted we're
06:01 - talking micro in nanoseconds that
06:04 - difference can get very large when we
06:07 - have much larger inputs to deal with and
06:10 - some systems will be faster and slower
06:12 - but at the end of the day regardless for
06:13 - loops row is going to be slower and
06:15 - that's why we try to avoid them and
06:17 - especially machine learning artificial
06:18 - intelligence so now that we have that I
06:22 - have your smallest numbers obviously
06:24 - faster we know that so we can't rely on
06:26 - just time to run because again all
06:28 - computers to different hardware is going
06:29 - to be different some are faster than
06:30 - others
06:30 - we want this to be Hardware independent
06:33 - and that's one of the big takeaways
06:35 - because there's you know hardware is
06:36 - constantly changing so how can we
06:37 - objectively determine if one function is
06:39 - faster or slower or rather is better
06:42 - or worse than another function if we
06:43 - can't use the time parameter per se
06:46 - because of the objective nature of
06:49 - different computers well that's where
06:52 - the Big O comes in so the Big O is a way
06:55 - that we can objectively compare the
06:56 - efficiency of those two algorithms so
06:59 - we're gonna compare the number of
06:59 - assignments of each algorithm you know
07:02 - there's some key phrases you know that
07:03 - we're gonna run through and this is what
07:04 - I want you to be cognizant of so we're
07:06 - gonna compare the number of assignments
07:07 - a feed that each algorithm makes or has
07:10 - to undergo so for the original some one
07:13 - function it's I'm gonna read this and
07:15 - I'll go back up to it and show you what
07:16 - I mean
07:16 - the original some one functional created
07:18 - assignment n plus one x we can see this
07:21 - from the range based function this means
07:23 - it will assign the final some variable n
07:24 - plus one x we can then set for that
07:26 - problem of n size in this case just a
07:27 - number n this function will take 1 plus
07:29 - n steps and this one's going to become
07:31 - meaningless so going back up to function
07:34 - number one or some one what it's saying
07:38 - here is that the allocation that this is
07:42 - going to that this is gonna require in
07:43 - terms of an assignment it's only in a
07:45 - the assignment is this so if my n is 1
07:48 - it's gonna have two assignments it's
07:49 - gonna have the assignment of 1 and then
07:51 - the assignment of 0 cuz again we're
07:53 - dealing with the indexing of 0 and its
07:54 - arranging if my n is 3 then we're gonna
07:57 - have 4 it's going to be the assignments
07:58 - gonna be still be n plus 1 because
08:02 - whatever the N is gonna be it's gonna be
08:03 - linear as the point so we're gonna be
08:05 - looking at here but there's only one
08:06 - assignment that's necessarily going on
08:08 - within this and a final first assignment
08:10 - is 0 and then that assignments gonna
08:12 - keep changing based on an order of a n
08:13 - the N notation allows us to compare the
08:16 - solutions and algorithms relative to the
08:18 - size of the problem so since some 110
08:21 - and some one of 100,000 we take very
08:24 - different times to run but using the
08:26 - same algorithm we can also note that n
08:28 - grows very large the plus one doesn't
08:30 - have much effect that's almost referring
08:31 - before some of these constant number is
08:33 - essentially when you start to get to
08:34 - numbers like infinity or if you're
08:35 - familiar with calculus may get some
08:37 - limits that constants the constant
08:41 - numbers just drop off they no longer
08:42 - have a real effect on me on the ultimate
08:44 - coding and you'll see that in just a
08:45 - minute so how can we how can we still
08:48 - quantify this how can we still compare
08:49 - the functions and that's where Big O
08:51 - notation comes in it's describing how
08:53 - quickly the
08:54 - run-time will grow relative to the input
08:56 - as the input gets arbitrarily large and
09:00 - again this is how we're gonna measure
09:01 - one algorithm over another or even one
09:05 - you know different coding aspects like
09:07 - using numpy in an instance where it so
09:09 - it can be a heck of a lot faster than if
09:10 - we were using a built-in list sequence
09:12 - and in python using data frames instead
09:15 - also utilizing pandas so it's a Big O
09:19 - what I want you to upon your head is how
09:20 - well can it scale as the data increases
09:23 - because Big O has a lot to do with
09:24 - scaling that scaling can either be in
09:26 - time or it can be in memory so we're
09:29 - comparing how quickly the run time is
09:31 - going to grow not the exact run times
09:33 - since those are going to depend on the
09:36 - hardware so at least this way I can know
09:38 - it doesn't matter the system if I have
09:39 - two different algorithms I can tell you
09:41 - that one algorithm is going to have some
09:45 - element of time and this other algorithm
09:47 - is going to have a comparatively
09:48 - different relative amount of time
09:50 - regardless of the hardware one's going
09:52 - to be faster than the other if I can see
09:54 - the code and I do the Big O notation so
09:58 - as the end gets arbitrarily large we're
10:00 - only worried about the terms that will
10:01 - grow the fastest design gets large so
10:03 - essentially if you're looking at an
10:04 - algorithm and if you're trying to which
10:06 - we're gonna get down to just a second
10:07 - you trying to determine which element in
10:09 - that code is the driving factor which
10:12 - one's still which one's going to
10:13 - actually impose the limiting behavior on
10:16 - the execution of that code well that's
10:19 - going to be your Big O and everything
10:20 - else is essentially going to drop off
10:21 - and in math that's this this idea is
10:25 - called asymptotic analysis which is just
10:28 - describing limiting behavior so it's
10:30 - kind of looking at a whole picture so
10:31 - we're gonna get to this guy in a second
10:33 - so asymptotic analysis is looking at
10:35 - this return here and pretty much saying
10:37 - who's the limiting factor in here who's
10:39 - gonna limit what my n is going to be
10:43 - able to do which one of these guys is
10:45 - going to mess with scaling the most or
10:47 - of the most impact or the least impact
10:48 - on scaling and then you can go from
10:50 - there
10:50 - so again which part of the algorithm has
10:52 - the greatest effect on the final answer
10:53 - which part of the algo is the real
10:55 - bottleneck which is the limiting factor
10:57 - that's for the syntax someone can be
11:00 - said to be this is the notation here so
11:02 - they say this is a big all and since run
11:04 - time grows linear with input size
11:06 - so let's go back up to summit one so
11:09 - what we're saying is second this was big
11:11 - oh if I was to do it in that notation it
11:16 - was essentially just this but again the
11:19 - Big O that's that was going to be the
11:21 - objective nature of pick on rotation for
11:24 - this linear event but the one as n gets
11:26 - larger and larger and larger this number
11:28 - one falls off so when n is 1 or 5 or 10
11:32 - you'll see an impact of the 1 but even
11:35 - just getting to a hundred and then a
11:36 - thousand this one becomes meaningless so
11:39 - we end up with a Big O notation N and
11:42 - again this is not supposed to make a lot
11:44 - of sense you just yet it will as we get
11:45 - further down when you can see the stuff
11:47 - in a graphical analysis so I wanted to
11:50 - bring this idea again of describing
11:51 - lipid behavior from an asymptotic
11:53 - analysis standpoint so here it is
11:55 - created a function called Big O with one
11:57 - argument hand and this is simply us
11:59 - returning 45 times n cubed plus 20 times
12:03 - n squared plus 19 and if I call Big O
12:07 - with an N of one I'm just gonna get 84
12:11 - if you wanted to do that math you
12:12 - absolutely can just don't forget you
12:13 - have to do operations so the it's one
12:15 - cube times 45 and then 1 squared times
12:18 - 20 and then plus the 19 and they add it
12:20 - all together so if we just did one of
12:24 - the variable we're gonna get 84 so what
12:26 - happens if I do just two we oughta make
12:29 - the joke made it 4-2 459 so what I want
12:31 - you to see is just looking at these two
12:33 - here all we do is change n by a factor
12:36 - of 1 correct and yet our result
12:38 - substantially change but you the point
12:40 - is that this 19 it had an effect here
12:43 - even if from a percentage standpoint
12:45 - when n is 1 19 had an effect but when n
12:47 - is just 2
12:48 - the 19 is pretty much becoming
12:50 - meaningless so this would not contribute
12:53 - to our computational intensive time
12:55 - because it's not really having any kind
12:57 - of an overall effect it's not limiting
12:59 - how we're progressing in terms of
13:00 - scaling so what happens if we go to a
13:03 - Big O of 10
13:05 - so now we're up to 47,000 so now looking
13:08 - back at our RPC I'm gonna get to the
13:10 - second going just from 1 to 2 to 10 the
13:13 - 19 we already know is pretty much out of
13:16 - the picture 19 is not going to make a
13:17 - big difference here in terms of
13:19 - computational intensive requirements so
13:22 - then the questions had to come down
13:23 - which one of these is it I'll tell you
13:25 - right now but can you ignore the
13:26 - constants never look at constant numbers
13:28 - so we're really focusing on is n cubed
13:30 - and then squared and then we're pretty
13:32 - much saying which one of these is going
13:33 - to be the bottleneck which one of these
13:35 - is the limiting factor for this
13:37 - particular function well it can be seen
13:40 - that the 19 is at how much weight
13:41 - anymore we came to that conclusion
13:42 - already the 20 and squared in this case
13:45 - is 2,000 so out of 47,000 if we took out
13:48 - 2,000 we're not that far off you don't
13:50 - forget 45,000 if we go to the 19 so
13:52 - again
13:52 - 45,000 or 47,000 is not that big of a
13:55 - difference so we can pretty much
13:56 - conclude that the N squared it's not
13:58 - gonna be the living factor within this
13:59 - particular function so then we have the
14:01 - again the constant 45 don't care about
14:02 - per se but the N cubed I do and with our
14:05 - hand of 10 it's gonna be 45,000 so
14:08 - 45,000 and forty seven thousand have
14:11 - much more of a percentage-based impact
14:13 - on its outcome of the performance of the
14:15 - calculation of that particular function
14:17 - so in this function this entire piece
14:20 - here you would say this is essentially
14:24 - going to be you're controlling Big O
14:25 - this is what's going to determine your
14:26 - scalability this is what's gonna
14:28 - determine eight let me factor this is
14:29 - what's going to determine who's gonna
14:30 - have the biggest bang for your buck
14:31 - within your function and which is gonna
14:33 - require the most computational time in
14:36 - your system so this part of the Algol I
14:39 - realize a lot to do the fun answer as
14:40 - the data scales it's not going to be the
14:42 - 45 again here we have it's not me the 45
14:45 - but it's gonna be the end cubed so this
14:47 - algorithm has an order of n cubed so
14:51 - it's a Big O whoops-a-daisy let me put
14:55 - this in here so this is gonna be a Big O
14:57 - and then we'll just keep it this way
15:05 - that's what that would be the order for
15:07 - this particular function now what I have
15:10 - here this is just a big ole complexity
15:13 - chart we have horrible bad fair good and
15:15 - excellent so what this is showing that
15:18 - these are different elements and then we
15:19 - have the operations so if your function
15:22 - has a Big O of 1 or a big old log of n
15:25 - which is still going to be quite linear
15:27 - you can see that our performance here as
15:30 - n grows and is getting bigger bigger
15:32 - bigger bigger bigger bigger and this is
15:35 - the the operations the amount of
15:37 - operation to the be performed you can
15:39 - see that we're in the excellent range
15:41 - here excellent and good range for those
15:43 - particular big O's but then once we
15:45 - start to get to this is over the
15:47 - function of n which is very much like
15:49 - our our original function that we did
15:53 - somewhat 1 you can see we're in a fair
15:55 - from a performance standpoint as n grows
15:57 - so too does the time but the complexity
16:00 - of the nature that is not is not obscene
16:02 - and then we start to get bad once we get
16:04 - to Big O and log in and then we're
16:07 - getting into the horrible territory when
16:09 - n is squared 2 to the exponent of n over
16:13 - here you would have n cubed n cubed is
16:15 - even worse than 2 to the N in terms of
16:19 - operational performance this is
16:24 - something you can memorize I have two
16:25 - different charts here you can look at
16:26 - how you can go through so for the big oh
16:28 - I dig of one that's called a constant
16:31 - which is exactly what we'd have is it's
16:33 - going to be whatever if it's a you know
16:35 - Big O is 10 then it's gonna be 10 that's
16:37 - gonna be the constant number log of n
16:39 - logarithmic and linear we saw that log
16:41 - of N and the constant and the O and
16:45 - linear they're pretty fair in terms of
16:47 - after your elements grows your and grows
16:49 - your operational computation intensive
16:51 - doesn't grow substantially that it's
16:54 - still it's still considered a valid
16:56 - function of valid formula you're going
16:58 - to be using and then we go and log n log
17:01 - linear we're getting in today what was
17:03 - that fair no bad so we left fair weren't
17:06 - bad territory already just because of
17:08 - the amount of computational intensive
17:10 - that is putting on the system regardless
17:12 - of your system and then we have N
17:14 - squared + to the third
17:16 - then we have to n in terms of quad cubic
17:18 - exponential so this is just things you
17:20 - can start to memorize anymore you're
17:21 - going to be doing is this is what we're
17:22 - looking at when we're determining our
17:25 - function where does it fall in terms of
17:27 - the pit go this is a more broken down
17:29 - version of the Big O showing our one
17:32 - like a blog and logout and so and so
17:34 - forth going in this to what their actual
17:35 - from functional name is gonna be called
17:39 - if you were ever describing it what I
17:43 - have here this code I'm not gonna go
17:44 - through per se I'm just using this from
17:46 - demonstration purpose but we're
17:49 - importing log importing numpy importing
17:51 - matplotlib i'm gonna have map table in
17:52 - lime which you're gonna see in a moment
17:54 - setting up run ten comparison so what
17:56 - we're doing this we're using numpy to
17:58 - create a line space one two ten and then
18:00 - we're giving a different labels constant
18:02 - log linear a log linear quadratic cubic
18:03 - exponential and then what we're telling
18:06 - it to do here is the actual calculations
18:08 - each one of these calculations is
18:09 - corresponding to its particular label so
18:12 - therefore this could have been done even
18:13 - like a dictionary if you're going to do
18:14 - key values and then we're just setting
18:16 - up our figure size and we're going to be
18:18 - plotting it and then this is do to do
18:21 - this is how we're actually gonna go
18:22 - through the calculation piece what i'm
18:24 - gonna do is go through that and here we
18:29 - go
18:30 - so what this is just another graph
18:31 - version showing you that the n increases
18:34 - with the relative runtime on a
18:36 - particular system so in this case this
18:37 - is my system and it's giving you a color
18:40 - code below that were constant log linear
18:42 - log linear quadratic cubic exponential
18:45 - so again you can see we're in good
18:47 - better worse and then just asinine
18:49 - territory so even with the N of four you
18:52 - can see the relative runtime performance
18:54 - are here but we're in constant and log
18:58 - so we have constant log at for our
19:00 - relative runtime as you know you could
19:02 - say it's like one in change and now once
19:04 - we start to get up to linear log linear
19:06 - even with the vent of four we're still
19:08 - under ten for relative runtime so it's
19:10 - not it's not crazies because it can be
19:12 - somewhat grouped together but now we're
19:14 - launching out of it out of the territory
19:16 - R with quad cubic exponential we're just
19:20 - weaving with the end of four we're
19:22 - hitting relative run time substantially
19:24 - and look with a head of four we're
19:26 - looking to go off overall to
19:27 - one time here before a cubic and we're
19:29 - out of the ballpark and when what did we
19:32 - find four cubic was that's exactly what
19:34 - did you do this big o-notation was for
19:38 - this particular it was cubic run so it's
19:41 - bigger was cubic so in terms of its
19:43 - relative performance you could see with
19:45 - a small n now with an N of 1 and n of 2
19:48 - we saw a substantial change then ahead
19:50 - of and of 10 it just skyrocketed so
19:53 - we're here with a nun of 10 you can see
19:54 - how the relative run time if we ever
19:56 - even get up to the cubic it just rises
19:59 - at exponential the rises at a cubic rate
20:04 - so clearly we want to choose algorithms
20:07 - to stay away from any exponential quad
20:09 - or cubic behavior in terms of
20:11 - computational intensive typically
20:13 - mathematics and you're gonna see us when
20:14 - we're doing machine learning and AI and
20:16 - we're gonna use we're gonna use we will
20:20 - do exponential quadratic cubic
20:21 - behaviorists but we don't want to be
20:23 - doing them on large scale so if we're
20:25 - gonna be doing them we want our ends to
20:26 - be relatively smaller so if we keep our
20:29 - hands small we can keep our relative
20:30 - runtime in a manageable fashion but
20:33 - again this is exactly why if you're
20:37 - running certain neural networks on
20:39 - particular models on different pcs why
20:41 - you can have runtimes ekko hours days
20:44 - and two weeks depending on your system
20:45 - and why things like the GPU and it's
20:48 - parallelism why it has such a massive
20:50 - impact on decrease the amount of time
20:52 - that we can run with ml ai and DL and
20:56 - even some you're gonna see soon coming
20:58 - out which is the Nvidia Volta well it's
20:59 - already out one of the biggest pieces of
21:02 - that is its its ability with tensors and
21:04 - when you have a GPU that is primarily
21:07 - focus on tensor mathematics and
21:09 - manipulation you're gonna find that the
21:10 - scaling of that is going to be
21:12 - astronomical and the speed of that's
21:14 - gonna be high qualify so we currently
21:15 - have even we say the Titan X pain
21:17 - running up with Pascal so that's gonna
21:21 - be it for today again this was beginning
21:23 - of algorithms and we start with a Big O
21:24 - notation so and this this information
21:28 - that we're doing now is not just for
21:29 - like say for a computer science and it's
21:31 - not just for your knowledge all of this
21:35 - is even if you start going to interviews
21:37 - for computer science you're going to be
21:39 - dealing with functions or formulas that
21:41 - are going to be looking where are they
21:42 - falling in this are they computationally
21:44 - intensive from a memory standpoint or
21:47 - from a time standpoint how could you
21:49 - make them better what could happen that
21:51 - could make them worse and how can you
21:53 - make them functional in terms of what
21:54 - they're doing because again you can code
21:56 - and incredible piece of code but if it
21:59 - if it can't be run on you know 70% of
22:03 - systems in the world then what good was
22:05 - the code so you have to keep these
22:07 - things somewhat logical
22:12 - big-oh examples first for a Big O of one
22:15 - a constant numbers so we have here
22:17 - creating a function function is constant
22:19 - we're gonna put a values of the argument
22:20 - all we're doing is printing in this case
22:22 - the first item in a list of values that
22:24 - admit us our first item because we're
22:25 - indexing at 0 it's gonna be our first
22:27 - item so we're printing out values
22:28 - whatever we're going to run through
22:29 - values of the argument and printing out
22:31 - the index of one so we're calling that
22:33 - function here function constant one two
22:35 - and three so out of this list that was
22:37 - we're passing through our function of
22:38 - function constant give me the index
22:41 - position of 0 and sure enough it gives
22:43 - me one because that's appropriate now
22:45 - the point of this is that it doesn't
22:47 - matter how large my values list becomes
22:49 - this values list I could have made this
22:52 - four and I'm still gonna get one because
22:59 - doesn't matter if this was infinity
23:01 - digits long I'm only grabbing the first
23:04 - index position which is always going to
23:05 - be one and it's also in the first spot
23:08 - so this algorithm is only gonna grab the
23:10 - intercept 0 in that list no matter how
23:11 - many times I run out I'm gonna have me
23:12 - this list is so this is a constant this
23:15 - is a Big O of 1 in constants as you
23:17 - remember from the chart from yesterday
23:19 - have one of the lowest computation
23:22 - intensive impacts on a computer system
23:26 - in terms of performance so scalability
23:29 - this is nothing this is easy as balls
23:31 - you can scale this as much as you want
23:32 - we're only grabbing the first index
23:34 - position so now we're going to move on
23:36 - to
23:37 - oh and Big O of n which of course is
23:40 - going to be linear it's not a constants
23:41 - linear so linear is slightly above in
23:44 - terms of we're still in good performance
23:46 - on a Big O performance chart so
23:49 - regardless of n we still can get fair
23:52 - computational intensive out of the
23:54 - system so here were defining a function
23:56 - and we're going to put a list through
23:58 - there
23:58 - so we have four Val and list so that's
24:01 - going to be for our values in the list
24:02 - we want to print the values so it
24:04 - doesn't matter what our list is gonna be
24:06 - it's simply going to print this you know
24:07 - what I'm gonna do
24:10 - let me do this so you guys can see the
24:13 - outputs as we run it so I don't want you
24:15 - feel like your brain is cheating
24:20 - so you're going to pass the list of 1 2
24:22 - & 3 through my functionalist Dodd
24:24 - defined function and all it should do is
24:26 - print out each one of these values
24:28 - within the list so we're going to shift
24:31 - through there so of course it prints out
24:32 - 1 2 & 3 so if every values gonna print
24:35 - no less each time the list gets larger
24:37 - though what's gonna happen to our what
24:40 - it's also gonna get larger it's not
24:41 - gonna be a constant it's gonna be linear
24:43 - so if right now if it's 3 it's gonna
24:45 - print out 3
24:46 - conversely if it was larger it would
24:51 - print out a larger list so our list
24:53 - growth does have an impact on the
24:55 - computational intensive of our system
24:57 - and it has a has a a competition ance of
25:00 - risk up so you'd say Big O to the N as a
25:03 - linear growth rate so as our list grows
25:05 - with this particular function as our
25:08 - list grows so too does the computational
25:10 - not to the point that it's disasters
25:13 - though because again computers can do a
25:14 - hell of a lot of math but again the
25:17 - point is it has to do the whole list
25:18 - whatever I do pass through here so
25:20 - that's why Oh and linear is going to be
25:24 - a little bit more computationally
25:25 - intensive than Oh 1 constant so what do
25:30 - we have every valuable print the list
25:31 - each time so larger list gets the bigger
25:33 - the Big O yet that's exactly what is
25:34 - covered so now we're gonna go to
25:36 - quadratics this is gonna be Oh with n is
25:39 - square it so we're gonna create a
25:40 - quadratic Big O function so in this case
25:43 - we're gonna do that just by doing a for
25:45 - loop in a for loop so we're gonna do a
25:47 - functional quad we're gonna have a list
25:48 - and what we want to do is print a pair
25:51 - so for item 1 in list and then for item
25:54 - 2 unless print item 1 print item 2
25:56 - nothing crazy will make our list just
26:00 - for fun we'll make it a little bit
26:02 - bigger want this to be neat and then
26:07 - we're just gonna call our function and
26:08 - function quad and then put our list
26:09 - through our list that we produce of 1 2
26:10 - 3 4 5 6 so what this is gonna do it's
26:12 - gonna go for item number 1 in the list
26:15 - and then it's gonna print one it's gonna
26:16 - print - it's gonna print 3 it's gonna be
26:18 - so it's going to be 1 1 1 2 1 3 1 4 it's
26:20 - gonna do this for each item in the list
26:21 - as it goes through most one and list two
26:23 - so sure enough we have 1 1 1 2 1 3 1 4 2
26:26 - 1 2 2 2 3 we're never dropping anything
26:29 - off 3 1 3 2 so it's creating a
26:31 - ere's list all the way through this but
26:33 - the point of the matter is that this is
26:35 - going to be one iteration for the
26:37 - computer system number one let's stick
26:40 - this is take one one element within our
26:43 - list so for the first element it has to
26:45 - do this run and then it has to do this
26:47 - run so it has to do n times n for each
26:50 - element that's in our list but this
26:54 - doesn't matter how big this is doesn't
26:55 - matter if this is one number or one
26:57 - element doesn't matter if it's a million
26:59 - elements infinity elements the point is
27:01 - it's always gonna have to do n times n
27:03 - such that we're gonna our ends squared
27:05 - that's going to result in this that's
27:07 - that's exactly we're getting from we're
27:08 - gonna have a quadratic representation of
27:10 - this on the graph which is we saw from
27:12 - from last week bring that up when we get
27:19 - into quadratic again we can see that our
27:21 - from our as the elements grow very quick
27:24 - let's say you know we're at 0 and then 1
27:26 - and then 2 is there elements grows or n
27:28 - grows the operations are gonna be in
27:30 - this case exponential that's where n
27:33 - squared it's because we have two loops
27:39 - one less than side the other as we said
27:41 - for list of n items we also perform n
27:44 - operations for every item in the list
27:45 - that means a total will perform of and
27:47 - times and assignments or N squared so if
27:49 - we have three assignments let me show
27:52 - you so if we only have here we have 6 so
27:55 - we should have 36 so if you counted this
27:58 - down 1 2 1 2
28:00 - whoops you should have 36 so let's keep
28:03 - this a little shorter so it's easier to
28:04 - see so if we have three elements we
28:06 - should have 9 1 2 3 4 5 6 7 8 9 so
28:12 - that's our n times N or N squared
28:15 - whatever our n is going to be N squared
28:17 - in terms of the computational intensive
28:19 - for that particular system how many
28:21 - operations are we actually performing or
28:23 - performing this and operations for n
28:26 - operations in a loop of loops it says
28:30 - you can see how very dangerous this can
28:31 - be for lower very large inputs this is
28:32 - why Big O so important to be aware of
28:34 - when you're creating software
28:36 - hence the input of 3 gives us 9 outputs
28:38 - that's what I just showed above we have
28:40 - 9 outputs for an
28:42 - three calculating scale of bigos so
28:47 - insignificant terms drop out of the Big
28:49 - O notation and this is exactly what we
28:51 - saw yesterday when we did nope
28:56 - here we go in terms of these are called
28:59 - insignificant terms the 45 the 20 the 19
29:02 - but they're always going to go in a
29:03 - backwards order meaning that the lowest
29:05 - term is gonna be the 19 and then it's
29:07 - gonna be our square that's gonna be our
29:08 - cube in the terms of the constant that
29:10 - stands before them so as you saw just
29:12 - going from a big off one to Big O of 2
29:14 - or 19 start to become very insignificant
29:16 - and then from a Big O of 2 to 10 not
29:19 - only do our 19 become insignificant but
29:21 - so too did our 20 and our 45 what came
29:24 - significant though was the cubic even
29:28 - our square started to show that it was
29:29 - not it was falling off rather quickly so
29:32 - as the N increased that N squared is
29:36 - going to become smaller and smaller
29:38 - compared to what the cube is going to
29:40 - contribute to the ultimate outcome of
29:42 - your answer so when it comes to the Big
29:45 - O notation we only care about the most
29:47 - significant terms remember is the input
29:49 - grows larger only the fastest-growing
29:51 - term will matter this is again like
29:53 - taking the limits toward infinity if
29:55 - you're familiar with calculus so that's
29:57 - that's we always want to focus on what
29:58 - is the most significant term and that's
30:01 - what we were heading on here out of this
30:03 - whole function this is the most
30:06 - significant term because as n grows this
30:10 - is going to contribute the largest to
30:11 - the overall answer in proportionate to
30:14 - the other values that would reside
30:16 - within that function so here we're
30:20 - creating a new function to find print
30:21 - once and it's gonna print all the items
30:23 - once so for the values are for Val and
30:26 - let's print about printing list
30:27 - print once and there's gonna call our
30:29 - list what list is this well it's gonna
30:31 - go by our last list that we ran in the
30:34 - Jupiter note books was gonna do list 1 2
30:35 - & 3 so if you wanted to see that you
30:38 - could also run it it's gonna print the
30:41 - list 1 2 & 3 so we can see how the
30:44 - growth is linear for this particular
30:45 - input so this is just going to be since
30:47 - it's a linear growth it's gonna be Big O
30:49 - to the head
30:49 - and you would say yeah it makes sense
30:51 - right for every value in the list if
30:53 - there's three we're only running this
30:55 - end times event is one and we're going
30:59 - through this once if n is two we're
31:00 - going through it twice if n is three
31:02 - we're going through it three times so
31:03 - it's a linear growth rate for the
31:05 - function that we're dealing with her
31:06 - being in regards to pick out here were
31:08 - defining print three we have our list
31:10 - but now what we're doing is we're
31:11 - printing it three times so for each
31:13 - value that's in our list we're doing it
31:15 - three times for each particular n so for
31:19 - our list it goes through print if I in a
31:21 - list it's going to be one print value
31:23 - list two three one two three one two
31:26 - three it's just printing this three
31:28 - times because again that's that we have
31:29 - three different for loops within our
31:31 - function there so again this is gonna
31:33 - run three times for each of the hens
31:34 - this becomes an order of three times and
31:36 - now notice it's still linear it doesn't
31:39 - automatically becomes n cube that would
31:41 - make any sense because each of these are
31:43 - going to be run in a sequential fashion
31:45 - so it's just gonna be three n but it's
31:46 - still linear the important thing here is
31:50 - this three times infinity is not really
31:54 - different than infinity so we can drop
31:55 - the insignificant constants and that's
31:58 - why this three n you'd be technically
32:00 - correct to say this is a Big O of three
32:02 - to the N as n grows you're our
32:05 - computational test is going to be three
32:07 - times that n however as n becomes
32:09 - infinity 3 becomes inconsequential
32:11 - because it's an insignificant constant
32:13 - so should it be a Big O of n so this is
32:15 - no different than this would be in terms
32:17 - of it's a Big O notation where would you
32:20 - say this it was gonna run faster than
32:22 - this
32:23 - absolutely but we're talking very small
32:25 - lists right now when we get to very very
32:27 - large lists those times this should
32:30 - still always be longer than this but it
32:33 - becomes inconsequential in terms of the
32:34 - difference
32:38 - and here we have a new function we're
32:40 - defining a cop it's gonna have take a
32:41 - list as an argument so now we're doing
32:43 - three different things and you can
32:45 - ignore this right now let's disco dance
32:46 - weirdo so we're printing the list of the
32:48 - first position that's what we're doing
32:50 - first and then we're creating a new
32:51 - variable called the midpoint we're gonna
32:53 - take the length of that list and divided
32:54 - by two and then we're taking a for loop
32:57 - for the values in the list from the
32:58 - beginning to the midpoint print that
33:02 - value and then for X in range 10 so
33:04 - we're going to go to 0 want to do 4
33:05 - minus X 999 print the number so I'm
33:08 - gonna shift enter through that so it can
33:13 - actually create its part auto-saving oh
33:24 - Jesus Chris I never called I'm like why
33:26 - is it white running I never called my
33:29 - actual function that we created so here
33:30 - I have my list I have 1 2 3 4 5 6 7 8 9
33:33 - 10 and then I'm calling the function we
33:35 - just wrote up above and I'm passing
33:37 - through this variable so now we have 1 1
33:41 - 2 3 4 5 and then we have the word number
33:44 - printed 10 times so what is the Big O of
33:48 - this particular function so if we're
33:51 - looking through this again you might
33:52 - recall this from yesterday all we're
33:53 - doing here is taking our list that we
33:55 - have here I'm pulling out the first
33:56 - indexed position that's going to be a
33:58 - constant of 1 always right it's our Big
34:00 - O of 1 that's a constant so we have here
34:02 - this first function is gonna print a Big
34:04 - O of 1 is going to be a constant nothing
34:06 - special there this is just creating a
34:09 - variable midpoint we're taking a length
34:11 - the first dividing by 2 and then we're
34:13 - using that in this piece here so what
34:16 - we're doing is what we're doing is
34:17 - printing the first half of the list so
34:19 - we're from the beginning of the list to
34:20 - the midpoint print those values so if a
34:24 - list of 1 to do so the midpoint you're
34:26 - going to tell me is going to be 5 so go
34:29 - from the beginning because it's 10
34:30 - divided by 2 is 5 and then go from the
34:33 - beginning of the list to the midpoint
34:35 - it's gonna print 1 through 5 that's what
34:39 - going to do for this point so for this
34:41 - one this is going to be
34:43 - that's we have here it's why doing half
34:46 - the list so it's Big O and divided by
34:48 - two
34:49 - because it over my N is here my n was
34:52 - ten so the big oz n divided by 2 is 5
34:55 - because we're gonna have an output of
34:56 - five different elements and then for the
34:59 - last one for X and range 10 so we have a
35:01 - constant here right doesn't matter what
35:04 - this is constant orderings printing your
35:05 - numbers this is going to be o to the 10
35:08 - a Big O of 10 or a Big O constant so
35:10 - what we have here we have a one constant
35:12 - we have oh and over two and then we have
35:14 - Big O town which is also a constant if
35:16 - we were to compare all three of those
35:18 - since we're doing down here we've got 1
35:20 - plus n over 2 plus 10 what did we say
35:22 - though about constants constants are
35:24 - gonna fall out as the end gets larger
35:26 - and larger and larger as we're scaling
35:28 - up you're gonna see how the number one
35:30 - in the number 10 are gonna quickly mean
35:31 - absolutely nothing to our overall answer
35:33 - for computational intensive on a Big O
35:35 - and even the divided by 2 is going to
35:38 - begin to have no effect either so what
35:39 - we're going to be ending up with is a
35:41 - Big O of n this is also going to become
35:43 - a linear growth rate based on the N
35:48 - because the constants of they do have a
35:50 - mathematical impact early on that impact
35:53 - falls off dramatically as we scale up so
35:58 - another piece that we're going to speak
36:00 - about when we get to Big O is an entire
36:02 - Big O notation in computational
36:05 - intensives and algorithms is worst case
36:07 - versus best case there's no point in
36:09 - really concerned computing a best case
36:12 - other than knowing what your best case
36:14 - could possibly be but we usually it's
36:16 - best to do your Big O notation in a
36:17 - worst case scenario so that's why we
36:20 - usually consider what the worst possible
36:21 - case of an algorithm because then you
36:23 - know what your worst case scenario is
36:24 - gonna be and you're gonna work up from
36:26 - there but an interview setting it's
36:28 - important to keep in mind that there is
36:29 - a worst-case in the best-case scenario
36:30 - and they can have very completely
36:32 - different Big O times they should have
36:34 - very complete different Big O times so
36:36 - we're gonna do here is we're gonna
36:36 - create a best-case scenario first off so
36:39 - I'm going to create a function and they
36:41 - call it match or it's gonna take a list
36:42 - and it's gonna take a match so we're
36:44 - having two different arguments so I'm
36:45 - gonna pass through this function and
36:46 - then for item in the list for item if
36:49 - item equals match return true otherwise
36:52 - we're gonna return false from and follow
36:54 - the loop so I'm
36:55 - have a list we already have a list
37:00 - produce I have LST here I'm just gonna
37:01 - run the cell to see what our list is so
37:03 - it gives me the output our list is one
37:05 - through ten all right sweet and then
37:07 - what I'm doing here is I'm calling the
37:08 - function is created matcher
37:09 - and I'm saying for the first argument
37:11 - its list that's what I'm putting through
37:12 - ears list and I'm putting in number one
37:14 - so a match of one so what it's going to
37:16 - do it's going to say for item in list
37:17 - for number one two three four five six
37:19 - seven eight nine ten
37:20 - if item if this equals the match and the
37:24 - match here that was our argument here's
37:26 - match here's my argument if any one of
37:28 - these equals this it's going to return
37:31 - true otherwise return false so it
37:33 - doesn't say it says if any item
37:35 - essentially so we're doing in that list
37:36 - so what do you think we're gonna get for
37:38 - this one here well we're gonna run it
37:40 - we're gonna get true sure enough within
37:42 - this list there is a match for the
37:44 - number one now the reason that this is
37:46 - the best case scenario is because where
37:48 - is the number one that we're trying to
37:50 - match it's in the bits in the index
37:51 - position of zero it's at the very very
37:53 - first of our list so a computer is gonna
37:55 - go sequentially when it's dealing with a
37:57 - list or you know when we gets a
37:58 - different kind of algorithms you can see
38:00 - you know you could say what could split
38:01 - it we can do higher lower and go from
38:02 - there and just break it down half and
38:04 - half and half and half but in this
38:06 - particular example our list what we're
38:08 - matching is very the first element so
38:10 - the list goes is number one yep true
38:13 - that's our bet so that the time to
38:16 - compute that is very very low now in
38:19 - terms of a false we're just going to go
38:20 - to make sure it's working so we have our
38:22 - list we're passing a twenty there is no
38:24 - number twenty within our list so we're
38:26 - going to get a false now this is
38:28 - essentially technically a worst case
38:29 - scenario because in order to find out if
38:32 - this was true or false in order to make
38:34 - this part of the code to determine if we
38:36 - were going to fall down into the true or
38:38 - if we were going to jump out of the loop
38:39 - and return false the computer had to go
38:41 - under had to go number one and then I
38:42 - had to go two three four had to
38:44 - sequentially go down this list to find
38:46 - that there's no number twenty so in the
38:48 - first run match our first one we only
38:50 - had to go through an element of one to
38:52 - find the true and match her list twenty
38:54 - we had to go through ten different
38:55 - elements to find out that it's false so
38:57 - technically this is a worst case
38:59 - scenario because we have to go through
39:00 - our entire data set to find out that
39:02 - there's no match so that's a worst case
39:04 - because again the entire list must be
39:06 - searched and I'll
39:07 - at the an worst case becomes linear this
39:09 - is a big off one the constant because
39:11 - again once I was gonna be in the first
39:13 - net sex position within this particular
39:14 - list lastly we're just going to talk on
39:18 - space complexity so not only do we talk
39:20 - about how obviously the huge time
39:22 - complaints time complexity with Big O
39:25 - notation and functions and algorithms
39:27 - but there's also a space complexity it's
39:30 - also concerned with how much memory
39:31 - space and algorithm uses if you've ever
39:32 - tried to do data work with al AI m LD L
39:36 - on images on image net or in any
39:39 - particular kind of cago piece if you
39:40 - have a crappy GPU it's going to come out
39:42 - and say memory error because you're
39:44 - you're trying to allocate the algorithm
39:46 - is trying to allocate a certain amount
39:48 - of memory to the problem which it does
39:49 - not exist so it's telling you I can't
39:51 - run this crap is you need more memory
39:52 - than what a connection what you have so
39:55 - this notation of space complexity is the
39:57 - same but instead of checking the time of
39:58 - the operations were checking the size
40:00 - and allocation of memory so in this
40:02 - quick example is creating a function
40:03 - called memory and we're putting it N
40:05 - equals 10 so then if we look at the code
40:08 - it says for X and range and AG am was 10
40:11 - we're gonna print memory so we're gonna
40:13 - print the word the string memory then we
40:15 - call memory 10 I was gonna be our
40:18 - arguments actually take that out because
40:24 - we assigned 10 to our argument and we
40:29 - ran the code so of course very complex
40:31 - code right it's gonna print the word
40:32 - memory 10 times but if you're looking at
40:35 - this loop what we have here is this
40:38 - first piece is a time complexity because
40:40 - if n is 3 then it's gonna run through
40:43 - this three times if n is infinity it's
40:45 - going to run through this infinity times
40:46 - this is a time complexity so this is o
40:49 - to the N because as n grows so to all
40:52 - the time this is a linear growth right
40:53 - here it's only one element it's only one
40:55 - operation to run through to me to make
40:57 - that sufficient now for print memory
41:00 - this is gonna become a space complexity
41:02 - and we have a Big O of 1 for space
41:04 - complexity because memory is a constant
41:06 - meaning that it's not printing it's not
41:09 - creating 10 versions of this it's
41:11 - creating at once and in terms of space
41:13 - complexity so spring are one consonants
41:15 - running at 10 times but the point is
41:17 - this is the lowest computational
41:19 - intensive that we can deal
41:20 - because it doesn't matter if I made this
41:22 - as a hundred and ran it not going to
41:25 - move me through that for you but it's
41:28 - not going to have any kind of effects
41:29 - effect on the Big O in regards to space
41:31 - complexity but will have effective time
41:33 - complexity so we have o to the end for
41:39 - the time complexity which we already
41:40 - came to that conclusion the space
41:42 - complexity and memory doesn't need to
41:44 - store ten versions of memory it only
41:46 - needs to store one string that's going
41:47 - to be the constant so again in terms of
41:50 - you said which one of these is more
41:51 - efficient you would say the constant is
41:53 - more efficient than the time complexity
41:54 - so in this particular code if you were
41:56 - dealing with a larger piece of code and
41:58 - you had time complexities and space
41:59 - complexities and if you had a space
42:01 - complexity if they go to the one at time
42:02 - complexity a Big O to the N if you had
42:04 - to manipulate some aspect of the code or
42:06 - to store something you rather do from a
42:07 - space complexity standpoint because a
42:09 - computational intensive of that from the
42:11 - Big O of a constant is much lower in
42:13 - terms of scalability and in terms of
42:16 - limits then the time complexity of Big O
42:18 - n because this even though it's still
42:20 - linear this is going to grow at a much
42:22 - much faster growth rate in terms of
42:25 - computational intensive than the space
42:26 - complexity of a constant one now again I
42:31 - don't expect all of this to sit within
42:33 - the first time that we're doing this but
42:34 - that's why you have videos you can go
42:36 - back and do this again and again and
42:37 - we're just going to have more and more
42:38 - examples and the whole point of this
42:39 - again was for algorithms for also
42:42 - playing with Jupiter notebook more so
42:43 - for algorithms and then even doing with
42:45 - interviews because it's beginning to ml
42:46 - and DL and AI a lot of those algorithm
42:49 - based and even if you're doing something
42:50 - with an umpire pandas with cycad or risk
42:52 - you learn it's important that you
42:53 - understand what that algorithm is doing
42:55 - just from a complexity standpoint so as
42:57 - you grow and trying to scale things and
42:58 - if you're hitting limits or walls you'll
43:00 - know what those limits are walls are
43:01 - caused from
43:06 - so in Python with our 8 sequences there
43:08 - are three different types of rays you
43:09 - can have a lists array a tuple and a
43:10 - string now these are all different three
43:12 - types of arrays you can see that the
43:14 - list is going to be identified by the
43:17 - brackets tuple parenthesis with a
43:19 - comment between them and then a string
43:20 - is identified in between parentheses
43:23 - with the quotations what makes all three
43:27 - of these unique in terms of Ranieri
43:28 - sequences all three of these can be
43:30 - manipulated by indexing they all support
43:33 - different index and parameters so to
43:35 - quickly understand some of the basic
43:36 - theory before we get into even the
43:38 - question the interview question to
43:39 - understand how arrays work when you
43:41 - understand low-level computer
43:43 - architecture so what I have here is a
43:45 - members I assume this is like your RAM
43:47 - or random accessible memory within the
43:50 - computer and each one of these numbers
43:51 - 21 44 21 45 46 etc are like address
43:55 - locations now memory is stored in bits
43:58 - but eight bits is a byte so we go by
43:59 - bytes when we're looking at this data
44:00 - and then there's a memory address for
44:02 - each byte so in this one byte here 21:44
44:07 - it actually has eight bits within it
44:09 - that's how well that's how we're
44:11 - visualizing this now what's interesting
44:13 - about at least with the arrays is that
44:15 - they're stored and retrieved in Big O
44:17 - one it's a constant time so it does not
44:19 - matter if you're at the beginning of a
44:21 - right middle of a right at the end of
44:22 - the rape you're indexing its position
44:24 - anywhere along this memory sequence the
44:26 - the Big O at the time is going to be
44:28 - constant regardless of where you're
44:29 - doing it and against its theoretical but
44:31 - it's also pretty much in practice so the
44:33 - idea is no matter how much you have
44:34 - stored in memory if you're using
44:36 - indexing you can recall it the same at a
44:38 - time regardless of if you're using a
44:40 - list tuple or string and also regardless
44:43 - of its index position so if you have a
44:45 - book that's in all on one string if
44:47 - you're indexing the very beginning of it
44:49 - or the very end of it it's going to be
44:52 - able at the same kind of a recall time
44:53 - because of its memory address location
44:55 - python is represented in unicode
44:57 - characters with 16 bits and again if
44:59 - there's 8 bits in a byte then 16 bits
45:00 - gonna be 2 bytes so in 2146 2147 if we
45:04 - had the string sample it would show me
45:06 - an index of 0 in that string is going to
45:09 - have the element s for sample and it's
45:11 - going to take up 2 bytes within this
45:13 - memory so you guys to address 2146 2147
45:16 - so if i index 0 or if i index 3
45:20 - the Python is gonna know exactly where
45:22 - into memory what address to go to
45:23 - actually recall that element that exact
45:26 - that resides within that list tuple or
45:29 - string so we have sample of six
45:31 - characters it's gonna be 12 bytes
45:33 - because again it's 16 bytes for 2 bits
45:34 - 16 bits or 2 bytes are um we haven't a
45:38 - right here of 6 characters 1 2 3 4 5 6
45:41 - index and 0 to 5 each character is going
45:44 - each card is going to take up a cell so
45:46 - this cell s is actually being composed
45:48 - of two different bytes and then index
45:53 - describes the location of course 0 1 2 3
45:54 - 4 5 is describing our location of our
45:57 - string tuple or list and this is just
46:02 - for knowledge we're gonna be using when
46:04 - we use when did the work that we do is
46:05 - going to be higher level abstraction
46:06 - this is considered low level abstraction
46:09 - the very lowest level you can get into
46:10 - in terms of arrays so quickly talking
46:15 - about lists and references so looking at
46:19 - this image here assuming we create a
46:21 - list and we named it primes and it's
46:24 - storing the prime numbers 2 3 5 we
46:26 - created this list and it's storing it
46:27 - within these index locations here within
46:30 - memory so now you know that index of 0 1
46:32 - 2 3 is actually going to correspond to a
46:34 - physical address within the memory in
46:36 - the computer these are the reference
46:38 - points that it's going to have now
46:40 - assume we create a new list say we have
46:42 - like a you know temp list and we wanted
46:46 - to reference a portion of the list like
46:48 - if you were splicing a list the point is
46:51 - it's not going to create a brand new
46:54 - list all it does is it takes a temporary
46:56 - list that you created here and it just
46:59 - changes the index assignment of that
47:01 - list to reflect where those elements are
47:04 - within memory so down here we have if
47:07 - you want to change it index assignment
47:08 - to a new templates that we did temp
47:09 - index of 2 is 0 1 2 so that's this
47:12 - location here of 13 right now it's
47:14 - pointing to 13 within the previous list
47:16 - of primes all it's doing is referencing
47:18 - Prime's index of 5 which is at 13 it
47:21 - says indexing that temp 2 is indexing at
47:23 - 13
47:24 - it's just referencing that particular
47:26 - element within stored memory if we want
47:30 - to change it to 15
47:31 - the original list is not going to change
47:34 - all that's going to happen
47:35 - is right here this - right now it's
47:38 - referencing 13 this two will then point
47:41 - over here in reference number 15 it's
47:43 - not going to actually change it's not
47:45 - going to append or amend this list with
47:48 - that exist within primes it's just gonna
47:50 - change its pointer and that takes us to
47:52 - a topic called pointers and in regards
47:54 - to memory and I very crucial at the low
47:57 - level aspect of understanding computer
47:59 - science and how things are stored in
48:00 - memory and recalled and referenced but
48:03 - the important thing here is that the
48:04 - original list is not changed to 3 5 7 11
48:07 - 13 17 19 that's not changed if I change
48:09 - this temp index to 215 it just comes
48:12 - over here and references a different
48:15 - location in memory that's storing the 15
48:18 - it does not mess with the original list
48:20 - so we have here the take away this new
48:22 - list create a shallow copy meaning
48:23 - you're only changing or creating your
48:24 - pointers you're not duplicating objects
48:26 - in memory and much of what we're doing
48:28 - is manipulating references and calls not
48:30 - the object itself we're just we're
48:32 - manipulating the reference and the
48:34 - calling of the elements not we're not
48:36 - actually changing the physical object
48:37 - that's resides within memory a quick
48:40 - little exercise here or importing sis
48:43 - it's a module within Python creating N
48:45 - equals 10 data is an object that we're
48:48 - creating with just an empty list and
48:49 - then for our I in range and again n is
48:52 - written out 10 so it's going to be 4 1 4
48:54 - 2 4 3 4 5 and it's gonna go through this
48:56 - a it's a variable that we just saying
48:58 - give me the length of the data at that
48:59 - point data again right now is an empty
49:01 - list so at the first point it's going to
49:02 - say 0 B equals Cystic get sizeof get
49:06 - sizeof is a method that resides in the
49:07 - system module and we're saying give me
49:10 - the size of data and then I'm printing
49:12 - on the bottom here we have a string it
49:14 - says length now this it looks like a
49:16 - dictionary right it looks almost like a
49:17 - key value pair that we have here but
49:19 - what this is is this is string
49:20 - formatting and what I'm going to be
49:22 - doing is if you see this and then look
49:26 - at this so what this is saying here is
49:29 - at index 0 of format so dot format index
49:33 - of 0 is going to be a
49:35 - and a is gonna reference this data so
49:40 - it's saying I want you to put life : and
49:43 - then I want you to give me the value of
49:46 - a and I want you to only take three
49:49 - integer places that's that's all that's
49:53 - messing with right there and then size
49:54 - and bytes index of one which is going to
49:57 - be the value of B B is generated here
50:01 - and we're saying give me B and take that
50:04 - for integer places now you'll notice you
50:07 - can also do left and right alignment so
50:09 - if we're calling for three integer
50:11 - places and we only have one number
50:12 - you're gonna have two and one a left of
50:16 - it because it's gonna automatically
50:17 - default to right alignment but that's
50:20 - what this dot format method is it's take
50:22 - I'm saying dot format format a into this
50:25 - position zero and format B into this
50:28 - position here when I print my string out
50:30 - so data dot append and again this is
50:33 - just saying with my empty list here
50:35 - appendant with the number n so right now
50:37 - it's empty we're gonna fill it up so I
50:39 - will run the cell even though I already
50:41 - have a ring run down below and I just
50:45 - want quickly go through what this means
50:46 - so a length of zero because the original
50:49 - data is gonna be zero that the length of
50:51 - data starts off as zero Python
50:53 - automatically reserves 64 bytes in
50:57 - memory even though the length of the
50:59 - list has not changed yet and I'm gonna
51:01 - bring this down so we can see this image
51:03 - down here when it goes to length of one
51:06 - the size and bytes does go up to 96 but
51:08 - then with the length of two the size is
51:11 - still 96 three we're still 96 four we're
51:14 - still 96 once we get to five elements
51:16 - within our list now we go up to 128 five
51:19 - python is increasing and then it runs at
51:20 - 128 1 2 3 4 instances before it runs up
51:23 - to 92 what is this doing the point of
51:26 - this is that Python we don't have to we
51:27 - don't have to dictate the size of the
51:29 - array before we create it in Python it's
51:32 - gonna grab a little bit more memory than
51:33 - what its gonna need and it's gonna fill
51:35 - up that memory and when it gets to the
51:37 - point of where it's it's can't fill up
51:39 - anymore it's going to create a new sized
51:42 - array it's gonna copy over the previous
51:44 - array and then it's gonna
51:46 - almost almost double what it's doing
51:47 - depends on your bite size so down here
51:50 - if you have this array that has four
51:51 - elements one two three and four so four
51:54 - if our length of zero one two three
51:56 - we're good but then once we start to get
51:58 - to four five six it's gonna have to jump
52:00 - down to a new size array so that's what
52:02 - we're showing here with B so B is an
52:03 - empty array and it's gonna take the
52:06 - elements of a because B is bigger than a
52:08 - it's gonna take all the elements of a
52:10 - and it's gonna point them to B so here's
52:13 - our elements here's our elements first a
52:16 - is referencing now B is also referencing
52:19 - and then a is gonna become garbage B
52:22 - what was B is going to hold those
52:24 - elements and it has more spaces here now
52:26 - to take on more elements more pending of
52:28 - that particular array and you can see
52:32 - it's just changing assignment to a
52:33 - because this became a garbage array
52:34 - which we get into another time but the
52:37 - point is you could see you could even
52:38 - make this whatever the heck you want and
52:41 - you can just see that it's gonna it's
52:43 - gonna create a new sides and it's gonna
52:45 - hold it as long as it can and then it's
52:47 - going to move that array into a larger
52:50 - array of memory so that it can hold
52:52 - those put but it's not point four point
52:54 - it will hold it for a certain number of
52:55 - time and as the length increases then it
52:58 - will jump to the appropriate size of
52:59 - memory of course until you get a memory
53:01 - error all right guys that's it for today
53:04 - on the arrays sequencing again we have
53:07 - lists tuples and strings they all
53:08 - support indexing that's one of the main
53:10 - takeaways there there we just did some
53:11 - low-level pieces of memory called data
53:14 - storing for arrays and just showing you
53:17 - how exactly those things are stored and
53:20 - how we can jump through how Python can
53:23 - increase its memory size of arrays if
53:25 - necessary
53:29 - any of you questions for me are things
53:30 - that you should pretty much kind of sort
53:32 - of have memorized one for the point of
53:34 - recall - to memorizing code does have a
53:36 - huge impact in terms of if you have to
53:38 - utilize code later on you could has
53:39 - recalled of course but also you can use
53:41 - parts of code when you're building new
53:44 - new pieces so this is just for dynamic
53:46 - arrays interview questions and we're
53:47 - gonna have a couple of and your
53:48 - questions for a raise as we go through
53:50 - this work so the problem you're given
53:52 - we're given two different strings we
53:53 - want to see if they are anagrams so an
53:56 - anagram is just when two strings or you
53:58 - know two words or a sentence if both of
54:01 - them can be written using exactly the
54:03 - same letters no repeats in terms of you
54:07 - can't have one that has seven a is one
54:08 - that has a days but they don't have the
54:09 - same letters throughout the entire
54:11 - sentence phrase or word all you have to
54:13 - do is rearrange the letters get a
54:15 - different phrase or word so for example
54:16 - public relations is an anagram because I
54:20 - can take all of the letters of public
54:21 - relations and I can create crap built on
54:24 - lies isn't that ironic you know Public
54:27 - Relation crap anyway so without having
54:29 - to increase or decrease in amount of
54:31 - letters the spaces don't matter so it's
54:33 - just about the letters Clint Eastwood
54:35 - those letters can be a rearrange to make
54:37 - Old West action so we want to build the
54:40 - software we want to create a function
54:42 - rather that will take in a string and
54:47 - two strings as arguments and compare
54:49 - them to see are they anagrams we want to
54:51 - ignore spaces and capitalization and
54:53 - that's pretty easy to do so again D
54:56 - space geo is an anagram for God ignoring
54:59 - the capitalization ignoring the space
55:00 - here so we're gonna do two different
55:03 - solutions for this the first one we're
55:04 - gonna do in Jupiter notebooks and the
55:06 - next we're going to do in pycharm so for
55:09 - the first one here we're creating and
55:11 - I'll explain you why we're doing two
55:13 - we're creating the function anagram and
55:16 - we're taking in two arguments s1 and s2
55:18 - and the first one we want to do is we
55:21 - want to tell Python whatever string we
55:23 - give it for s1 and whatever string would
55:25 - go for s2 first and foremost get rid of
55:28 - the spaces so s 1 equals s 1 dot replace
55:31 - so this is a method that exists within
55:32 - Python we want to replace spaces there's
55:35 - a space here I'll show you I'm going to
55:36 - take it away and
55:37 - back replace spaces with no spaces and
55:41 - lower-case everything and we want to do
55:43 - the same thing for the second string as
55:45 - two equals s to not replace tickle your
55:47 - spaces get rid of your spaces and
55:48 - lowercase everything wonderful that
55:51 - we're doing is we're going to return a
55:52 - boolean for a sorted match sorted
55:55 - essentially putting them you know
55:56 - alphabetical order or numerical order so
55:57 - if they if the letters in 1s one can
56:01 - also be used to make something else in s
56:03 - 2 then they would have the same letters
56:05 - so if they're sorted they should be
56:06 - equal so returns sorted s1 equals sorted
56:10 - s2 it's either gonna be true or false so
56:12 - we run at first we have we're gonna call
56:14 - our function anagram that we made above
56:16 - and taking our two arguments first dog
56:18 - and then God and we run it and sure
56:20 - enough it's gonna tell us true and that
56:22 - is correct
56:23 - same thing for clint eastwood old action
56:25 - I'm gonna run it true and then we get a
56:28 - false here for anagram AABB why they
56:30 - have the same number of letters
56:32 - absolutely 2 & 2 but you can't make BB
56:35 - from a a or vice-versa
56:36 - conversely if we made this a capital T
56:39 - it would still give me a true because we
56:41 - are lower casing our letters if I added
56:46 - one more letter I do get a false because
56:48 - now it's saying you can make old-west
56:50 - action from clint eastwood but now you
56:52 - have au here so we have a letter that's
56:54 - left over that old-west action did not
56:56 - use so it does not an anagram of that
56:58 - example now we can make a back to an
56:59 - anagram this is not an optimal solution
57:03 - for an interview because you're using a
57:05 - Python module we're using dot replace
57:07 - here and I don't say it's cheating but
57:10 - if your interview was in if it was in
57:11 - Java or JavaScript if it was in a
57:13 - different language
57:13 - SEPA plus you're not going to be using
57:15 - Python modules and so you want to be
57:18 - able to also do this anagram solution we
57:21 - using accounts and dictionaries and
57:22 - that's exactly what we're going to be
57:24 - doing in PyCharm here so I'm gonna run
57:27 - through the code and then we'll actually
57:28 - run it you'll be able to see what it's
57:30 - doing so we're defining anagram to again
57:33 - same two arguments s1 and s2 and we're
57:35 - doing the same thing in the beginning
57:36 - we're taking this one and we're doing s1
57:38 - dot replace we want to get rid of the
57:39 - spaces and replace it with no spaces and
57:42 - also lowercase everything same thing for
57:44 - s 2 s 2 dot replace get rid of the
57:47 - spaces no spaces lowercase everything
57:50 - then we want to do is we want to check
57:51 - if we have the same number of letters in
57:53 - each of the strings if we have the same
57:56 - number of letters that's a start if we
57:58 - do not have the same number of letters
58:00 - then we know off that that we do not
58:02 - have an anagram so if the length of s 1
58:04 - does not equal the length of s 2 return
58:07 - false and that's exactly what we want to
58:10 - be able to do because again if it was
58:12 - going to be true if they did not equal
58:15 - each other which true then that means
58:17 - one string has a thirteen no one has 16
58:19 - it can't be autographs so if they do not
58:22 - equal each other return false then we
58:23 - can keep rolling through so count
58:25 - frequency of each letter count we're
58:27 - just having as an empty dictionary and
58:28 - Lotus our brackets there so we have an
58:30 - empty dictionary for count and now we're
58:32 - saying we're gonna create a for loop for
58:34 - letter in s1 and I'm gonna actually do
58:36 - debug this so it makes more sense for
58:38 - you for a letter in string one for every
58:40 - letter in the first string if letter in
58:42 - count counts gonna start off as zero but
58:45 - if the letter is already in the
58:46 - dictionary then I want you to add a 1 to
58:49 - that count for that so if it's gonna be
58:51 - like a key value so if the first letter
58:53 - and kleenex what is C we're gonna start
58:55 - out with a zero so then I want to make
58:56 - it C equal one else count is this gonna
58:59 - equal one if it's not already within the
59:02 - dictionary that would created here of is
59:04 - it which is empty at this point and then
59:06 - we're gonna do the reverse for the
59:07 - second string the reverse meaning we're
59:10 - going to subtract it so we did here was
59:11 - to change the plus over before to a
59:14 - subtraction now we want to subtract one
59:16 - so we want to count all the letters up
59:18 - and then bring them on back down and
59:20 - then at the end here we're just saying
59:22 - for K and count if count K does not
59:25 - equal zero return false because every
59:27 - letter should equal zero after we count
59:29 - up and then count down and then lastly
59:31 - if all of this is met to do for this
59:35 - function you can see how we're doing our
59:36 - indenting we can return true and then I
59:39 - just have here x equals anagram to Clint
59:41 - Eastwood Old West action you can see I
59:43 - capitalized West at capitalize CM a but
59:45 - we already know from the previous
59:46 - example that these are anagrams and
59:48 - we're gonna print X and see if we get a
59:50 - true or false so what I'm going to do is
59:53 - I'm going to come up here debug it and
59:55 - we're
59:55 - going to run are a debug yes for anagram
60:00 - and I don't care about that console for
60:04 - now so bring this down a little bit all
60:08 - right sweet all right so I'm gonna come
60:10 - to the first line we're gonna f8 through
60:11 - this so again you can see where from
60:13 - line 1 to line 32 because when we're
60:15 - debugging it doesn't go through a
60:16 - function until the function gets called
60:18 - so here in the variable X we're calling
60:21 - the function a degree 2 and we're giving
60:23 - it two arguments s1 and s2 clinics would
60:25 - an old ways action so now we can
60:27 - actually run through our our function
60:29 - and you can see here it put into memory
60:31 - s1 Clint Eastwood it's a memory s2
60:34 - old-west action and you can see we
60:35 - maintain the capitalization so far
60:37 - because we didn't do anything with the
60:38 - code f8 so now we can be within the
60:40 - function because we have our arguments
60:42 - s1 equals s1 not replace so it should if
60:45 - you look at if you're looking at s1
60:47 - watch us one as IFFA through this you're
60:49 - ready set go so you can see that it got
60:53 - rid of the capitalized see the capital e
60:55 - and it got rid of this space and it
60:57 - should do the same thing now for s2 and
60:59 - go old-west action great so now we have
61:02 - two strings in a both lowercase and no
61:03 - spaces within them now we want to check
61:05 - if we have the same number of letters so
61:07 - let's see what happens we're gonna f8
61:09 - through this and it jumped from if
61:11 - length is not equal return false and
61:12 - then orden then go down to count so this
61:14 - went through this did not meet the
61:16 - requirements so it jumped down to the
61:18 - next piece because they do equal each
61:20 - other so count equals an empty
61:23 - dictionary
61:24 - so let's FA through that and sure enough
61:25 - in memory it creates an empty dictionary
61:27 - how lovely and now we're gonna go
61:30 - through our actual bring this up a
61:32 - little bit so it's you can see it better
61:34 - now we're gonna go through our actual s1
61:36 - which was Clint Eastwood no capitals and
61:38 - no spaces so I'm gonna f8 and you can
61:41 - see it gives me Freight off the bat a
61:42 - letter C and we're gonna f8 through here
61:45 - it gave me the letter C
61:47 - so it's an if letter in count which it
61:50 - was not because C was not in count count
61:52 - was empty so letter C was in count nope
61:55 - so it's gonna jump down to else count
61:57 - equals 1 so watch what's gonna happen
61:58 - here to count once ifá through the next
62:01 - line of code for count letter equals 1
62:03 - BAM now we're creating the dictionary
62:05 - the key C a value of 1 now if I come
62:08 - across
62:09 - anymore sees that see is going to turn
62:11 - into two because it's going to say if
62:12 - letter in count yeah season count letter
62:15 - equals one plus one at that point it
62:17 - would be two so now it's going to go
62:19 - through each letter so first see then
62:20 - we're going to see L so we're gonna f8
62:22 - through this and sure enough it tells
62:23 - you over here letter is now out if
62:26 - letters in count L is not in count
62:29 - because we can see an account we only
62:30 - have C so then it's gonna jump to the
62:32 - else which is the count letter equals
62:34 - one and we're gonna have an our
62:35 - dictionary up above L and one so I'm
62:38 - just going to go through this i n t a s
62:50 - now we already had a t so when it got to
62:54 - east e AST it did not create a new key
62:57 - value it changed t to number two because
63:00 - now we had two instances
63:08 - drag this over a little bit how do I do
63:12 - I can do pop pop pop but up now it's
63:20 - active better to write you saw fraps
63:24 - give me soft raps
63:34 - Oh didi ah I didn't want to go into s2
63:37 - yet so it was Clint Eastwood and it
63:42 - didn't do Altos action yet so we got to
63:44 - Clint Eastwood and that's what it did
63:47 - East wood Clint Eastwood pas TW oh-oh-oh
63:55 - is - its Y and then D alright and now it
63:59 - just brought in the letter O and that's
64:00 - the beginning of our second string so
64:02 - all we did so far was in this in this
64:04 - for loop in our counter just empty
64:06 - dictionary we now have a filled
64:08 - dictionary with a key value for all the
64:10 - letters in Clint Eastwood now in this
64:12 - second for loop here it's going to do
64:13 - the opposite now it's gonna go through
64:15 - Old West and it's gonna say is there an
64:17 - O if the letter isn't count is o in
64:21 - count well yeah we have two O's and
64:23 - count from before so it's gonna go minus
64:26 - one if it didn't exist then it would do
64:28 - a one so the idea is all of these should
64:31 - be 0 by the time we're done with going
64:34 - through Old West action we can see
64:36 - there's two T's and O blue section we
64:37 - have two T's in Clint Eastwood's so it
64:39 - should go down so I'm just going to
64:41 - again start FA ting through this and you
64:43 - can see up here if you watch up here as
64:46 - i f8f aid through all this you're gonna
64:48 - see all these numbers to go down one by
64:50 - one until they all get to zero and it's
64:53 - not that they're all going through zero
64:54 - that the variable on line 12 is also
64:57 - changing each time we go through the
64:58 - loop now they all came through on zero
65:01 - we went through all the letters and s2
65:03 - and we can see that they're all zero but
65:07 - that doesn't mean anything here for the
65:08 - code because now it's going to do for K
65:10 - and count k4 see if K count is not equal
65:15 - zero return false so we know that all of
65:17 - our all of our Kaizen count are going to
65:20 - equal zero zero zero zero zero which
65:23 - means it's going to jump out of this
65:24 - loop and return true so it's just going
65:28 - to go through n te a and it's going to
65:30 - go through every letter within our count
65:33 - and you see here in memory X is true FA
65:37 - through it print X and we can see I'll
65:41 - bring it up for you you can see in our
65:47 - console it printed out true so now we
65:51 - know that it is an anagram now I know
65:54 - that seemed a little normally when
65:57 - you're doing this you're not going to be
65:58 - debugged debugging through it but I
66:00 - wanted to only get rid of that so you
66:01 - can see the line better I should change
66:02 - that highlighting I wanted to show you
66:04 - the code and debug through it so you can
66:06 - see again what's happening in memory
66:08 - when we're creating an empty dictionary
66:10 - adding two with the count base of a key
66:13 - value and then deleting from that count
66:16 - so this way no matter what language you
66:17 - were doing this in you could do the same
66:18 - kind of a same kind of a process to
66:21 - check if something was an anagram or not
66:24 - also good exercise with for loops
66:27 - indentation the replace method and
66:30 - lowercase always good practice
66:36 - we have another coating example we're
66:38 - gonna go through and essentially utterly
66:39 - memorize so that we have more tools
66:41 - within our toolbox so today for a rare
66:44 - pair sarey pair some excuse me so we're
66:47 - gonna be dealing with so again for raise
66:48 - you could have lists tuples of
66:49 - dictionaries those are all different
66:51 - arrays we're gonna be utilizing but this
66:52 - is gonna be a rate pair of sums so given
66:54 - an integer array so say we have an array
66:56 - of 1 3 2 2 which you can see down here
66:58 - that we've already defined in pairs some
67:00 - given an array in the teacher array 1 3
67:03 - 2 2 I'll put all the unique pairs the
67:06 - pairs of these of these integers that
67:07 - can sum up to a specific value of K so
67:10 - that can sum up to a specific specific
67:12 - value of 4 so our input we're gonna make
67:14 - a function called pair some we're gonna
67:15 - pass through argument wants is going to
67:17 - be the array and then argument 2 which
67:18 - is going to be the value of K or some
67:20 - kind of specific sum that we want these
67:21 - to see if we have any pairs that add up
67:23 - to so in this case if we ran this if we
67:26 - have our function improperly it should
67:27 - return two different pairs 1 3 and 2 2
67:30 - because 1 3 else adds up to 4 2 2 adds
67:33 - up to 4 and 1 3 and 2 to our integer
67:37 - pairs that were within the array that
67:39 - we're passing through so let's get
67:41 - coding first off we need to define our
67:44 - function and like I said we're passing
67:47 - through it an array and a value of K
67:48 - that's gonna be our first piece there
67:50 - now before we even get into anything we
67:52 - want to make sure we have some way to
67:53 - troubleshoot this so we don't get errors
67:54 - what if our array only had one value in
67:58 - it 1 integer one element well then
67:59 - that's gonna be a really crappy array
68:01 - and we don't want to go any further so
68:03 - first off the bat we can say if the
68:04 - length of the array that we're gonna be
68:07 - passing is less than 2 well what do we
68:09 - want it to do if it's less than 2 he'll
68:12 - just return let's do a print function
68:14 - and say too small so we know so that's
68:20 - how we can take care of that if the
68:22 - length of the array is gonna be too tiny
68:23 - to begin with
68:24 - now something I want to do because I
68:25 - already know how I'm going to code this
68:27 - we want to have a way almost like
68:29 - counters we want to have a way of
68:31 - counting exactly keeping track of what
68:33 - we see in terms of our array pairs and
68:37 - also outputs of our different array
68:40 - pairs so we're just going to create two
68:41 - different empty variables that are gonna
68:43 - sit in memory and they're gonna get
68:44 - filled as we go through in this case a 4
68:47 - so we want to go through it we want to
68:49 - use a for-loop to go through each of the
68:50 - elements within our array and somehow
68:52 - compare it to our target to see if it's
68:54 - gonna be a match
68:55 - so for each target and number we're
68:58 - gonna get a nut we're gonna get an
68:59 - output and that output might be a good
69:02 - that number target might be a very good
69:04 - match for our number of for our specific
69:07 - value in this case which is K so with
69:10 - that being said let's just run through
69:11 - it'll make sense more sense to as we go
69:12 - through and then as we debug it of
69:13 - course so for the number in the array
69:16 - that we're gonna be going through what
69:18 - we want to do it for each number in the
69:20 - array well I want to compare it to
69:23 - another variable I'm gonna create called
69:24 - target target is going to equal K minus
69:27 - the number that we're gonna be going
69:29 - through in the for loop so for a number
69:31 - in array target equals K minus number so
69:34 - what does this mean if we if I if we go
69:38 - through the beginning of the array it's
69:39 - gonna first go through the number 1 and
69:40 - K is always gonna be 4 in this example
69:42 - so 4 minus the numb for minus 1 is going
69:45 - to be 3 so in this case when the target
69:48 - variables created in memory it's going
69:50 - to fit that with the number 3 when it
69:52 - does that in in memory so what do we
69:54 - want to do with that if that's gonna be
69:56 - the case well if the target is not seen
69:59 - I want to somehow take that that target
70:01 - that I get in this case it's gonna be 4
70:02 - minus 1 which could be 3 if that target
70:04 - is not seen what do I want to do so if
70:08 - the target that work that we're
70:09 - computing is not in seen and seen as the
70:12 - variable that we have created above
70:13 - we're gonna want to take that scene and
70:15 - add the number to it so again the number
70:19 - is gonna be this portion here we want to
70:21 - add the number that we just computed
70:23 - that target with and this will make
70:25 - sense because we're doing in pairs so
70:27 - this is 4 minus 1 and we're gonna get a
70:30 - target of 3 so we care about the 3 and
70:32 - we care about the 1 because we already
70:34 - know now that that's gonna be a pair
70:35 - that's gonna equal up to our ultimate
70:37 - value of K so now as we're starting to
70:41 - adjudicate this list we're saying
70:42 - alright if it's if the target is not in
70:43 - the scene add it to seeing what else and
70:45 - what are we doing Python way since we
70:47 - want to put an else statement and to say
70:48 - you know if it is in the scene what do I
70:50 - want it to do well if I know that the if
70:52 - the if the number that were utilizing to
70:55 - create the target is already in scene
70:57 - well then I know I have a combination
70:58 - now of target and scene I'm sorry target
71:01 - and number that are going to combine
71:05 - together as a pair to make the value of
71:07 - K why the hell's that mean meaning in
71:10 - this example we'll do 4 and 1 again so 4
71:14 - minus 1 equals 3 so now going through
71:18 - this next line here if target if 3 is
71:21 - not in scene well scene is empty at this
71:23 - point and the number and the number 1 so
71:26 - then we're should we should get out the
71:27 - number 1 to pop up here but then what's
71:30 - gonna happen is the next time I go
71:31 - through I go through this piece here
71:34 - it's gonna say the next loop it's gonna
71:36 - say for num and array well it's gonna be
71:38 - then 4 and then 3 the reason the next
71:40 - number in there right target equals 4
71:43 - minus 3
71:43 - target's now gonna equal 1 if target not
71:46 - in scene well we just know in the last
71:48 - for loop we have a number 1 in here so
71:49 - it is seen so what do I want it to do
71:52 - well so now I have a combination of 1
71:54 - and 3 I'm sorry this is gonna be 3 at
71:57 - that point so I'm gonna have a 1 in
71:58 - scene and I'm gonna have a 3 in num so
72:01 - what do I want to create that pair that
72:03 - 1 3 pair that's gonna equal 4 so what
72:05 - I'm going to do within our else loop we
72:07 - want to we want to now start to
72:08 - adjudicate our output and this is how
72:11 - we're gonna sever go do so we're gonna
72:12 - take our output or empty variable output
72:14 - and we want to add to it
72:15 - we want to add we want to add the
72:17 - minimum of what well of number or the
72:22 - target
72:22 - so in this say so the first one is 4
72:24 - minus 1 and it was gonna be 3 and that
72:28 - was and then the next time we had 4
72:30 - minus 3 is gonna be 1 so we want the
72:32 - minimum of that number target
72:33 - combination so the minimum the second
72:36 - time it runs through when you this will
72:37 - make more sense to go through the
72:38 - minimum when we do this it's going to be
72:40 - this will be 3 and this will be 1 so the
72:43 - minimum between 3 & 1 is 1 so it's gonna
72:45 - it should print a 1 first and then I'm
72:47 - going to then whoops-a-daisy then we
72:49 - want to do the maximum of the same thing
72:51 - of that same combination
72:54 - get rid of that another way so now what
72:56 - I wanted to do is say begun again
72:57 - between one and three now can be the
72:59 - maximum of that number see if our cool
73:01 - our parentheses match up yes yes and
73:04 - we're in the add method wonderful so
73:06 - again as we as we go through this in the
73:09 - debugger it'll be a lot cleaner for you
73:12 - and then as we're going through this I
73:14 - want to do one more piece in this for
73:16 - loop which is then we want to give an
73:19 - output right so I'm just gonna put just
73:21 - for the sake of cleanliness have a new
73:24 - line and to that we're gonna join I want
73:26 - to join something this will make sense
73:28 - to you again as we go through the
73:29 - debugger I want to map and the map I
73:31 - want to create a string and I want that
73:34 - list to be from the output that we
73:36 - created which again is going to be this
73:38 - right now is just an empty set but it's
73:39 - I want it to print out that output and
73:41 - that's what we're adjudicating here in
73:43 - this else statement so as I go through
73:45 - so I check my parentheses good good good
73:49 - sweet all right so now in order to make
73:52 - any of this even do anything
73:53 - after we printed out a tuple answer
73:55 - we're gonna see if we have the right
73:56 - answer we're gonna first have to call
73:58 - this function and into place first off
74:01 - so how do we do that
74:03 - well I'm just going to put pass through
74:06 - call our function pass through the the
74:08 - function here pair sum so we're calling
74:10 - the function we created I need a first
74:12 - put an array and we said we were doing
74:14 - what do we say we're doing 1 3 2 & 2
74:16 - that's our array and then I have to also
74:19 - give it a K value in this case you're
74:21 - doing 4 so let us
74:25 - pop it in and run the debug we're doing
74:30 - pair some says we're gonna run here and
74:32 - I can do a console but we don't even do
74:34 - this right now but it's gonna keep
74:35 - popping up I believe so start off in the
74:38 - beginning that's that fade through there
74:39 - so first off again remember for
74:41 - functions whenever you're running
74:42 - through a function in the debug or even
74:44 - in Python code it's not gonna run the
74:46 - function until you call it so that's why
74:48 - it jumps from line 13 where I started
74:49 - all the way down to line 31 because now
74:51 - it's calling the function pair some and
74:53 - it's checking do you have two arguments
74:55 - otherwise we'd get an argument error
74:56 - it's say you know you're trying to pass
74:57 - two and once three or or vice versa so
75:00 - pair some we're giving two arguments we
75:02 - could see in our function wants two
75:03 - arguments so we're gonna get to the next
75:04 - line so in memory we have an array which
75:06 - is a list and it's one three two two and
75:08 - then we have our K which is equal to
75:10 - four so now we are good we can start to
75:12 - run through the code so if the length of
75:13 - the array is less than two it's not our
75:15 - array has four elements in it if the
75:17 - index is zero to three so that's going
75:19 - to be a false so it's as false it's not
75:21 - gonna finish that loop it's gonna jump
75:23 - out of the loop and go to the next line
75:24 - of executable code which in this case
75:26 - now we're at scene so scene is gonna be
75:28 - a variable it's an empty variable just
75:30 - gonna create set so in memory we're
75:31 - gonna see the variable seen created and
75:34 - it's gonna have an empty set
75:35 - same thing for output nothing special
75:37 - there so we can see in memory what we're
75:38 - creating down the computer now first for
75:41 - loop for the number in the array so for
75:43 - the first number in the array that's
75:44 - number one so it's gonna say give me an
75:46 - uncle's one target equals K minus 9
75:48 - minus num so that means target is
75:51 - another variable we've created and it's
75:52 - going to equal four minus one which is
75:54 - going to give you three so now it's
75:56 - going to save targets gonna equal three
75:57 - now this is where I want you to pay
75:59 - attention so if the target is not in
76:01 - scene so we can look at seeing right now
76:03 - scene is an empty set up top here if the
76:06 - target is not in the scene will target
76:07 - it's three it's not in scene I want you
76:09 - to add the number and the number right
76:11 - now in memory is 1 so since 3 is not up
76:14 - in here add the number
76:17 - we're gonna have faith through there and
76:19 - sure enough in seen now we have a one
76:21 - and now we can go to the next number in
76:23 - the array because we're still within
76:24 - this loop here so for a number in array
76:26 - so now the number is three in the the
76:29 - next number in the array which is
76:30 - correct
76:30 - now we're gonna have target equals K
76:32 - minus num or four minus three so now our
76:34 - target is gonna change with the memory
76:36 - and sure enough it did now watch what
76:38 - happens here
76:38 - if target not in seen target is one is
76:41 - target not in seen that would be false
76:43 - it isn't soon so we're not gonna add it
76:46 - we don't want to add it 1-1 again it's
76:47 - not gonna make any sense we already have
76:48 - one within the scene so that means this
76:50 - is gonna be false and it's gonna jump to
76:52 - the next executable line of code so it
76:54 - better go down to line 27 sure enough it
76:57 - does because now we're in our else
76:58 - statement because that if statement was
77:00 - false so it's got to go to the next X
77:01 - could have a line of code we have to
77:02 - keep going until we hit it true so now
77:05 - this is going to be this else statement
77:06 - is simply adjudicating the output set
77:09 - that we have appear at empty set so
77:10 - we're saying an output I want you to add
77:12 - I want you to add the minimum of the
77:15 - number or the target or right now the
77:17 - number is 3 and the target is 1 so the
77:20 - lowest of that the minimum is going to
77:21 - be 1 so the first element here and this
77:25 - tube is going to be 1 and then for the
77:27 - second element and once you give me the
77:28 - maximum that is of the number or the
77:29 - target number is three targets one
77:31 - maximum is three so now this tuple had
77:34 - better print out a 1 and a 3 if we coded
77:37 - properly so I'm gonna f8 through there
77:39 - so now in our output sure enough we have
77:41 - a 1 and a 3 good so within this
77:44 - dictionary now we have a 1 3 2 bowl
77:46 - sweet I like it now we still have more
77:49 - numbers in the array to go through so
77:51 - now we're gonna FA through there and the
77:52 - number is gonna change to 2 so now we're
77:54 - gonna have 4 minus 2 it's gonna equal to
77:56 - now if target not in seen target is - it
77:59 - is not in scene so it had better go to
78:00 - the next line 24 and add it and sure
78:02 - enough it does wonderful so now we have
78:04 - 1 comma 2 within the scene the next
78:07 - number that's in our array is the number
78:09 - 2 again so that's going to stay too
78:12 - like all good math targets gonna stay -
78:14 - if target not in scene will target is -
78:18 - right now and it isn't a scene so this
78:19 - is gonna be false so we have better jump
78:21 - to our else statement and sure enough we
78:23 - do same thing now output right now
78:26 - output has a 1 comma 3 tuple and we want
78:29 - to add to it the minimum of the number
78:30 - target well the minimum for a number
78:32 - target and memory right now is a 2 and
78:34 - the maximum of our number target in
78:36 - memory right now is also 2 so we have
78:38 - better get a 2 to show up in memory and
78:41 - sure enough we get a 2 - and we can kind
78:43 - of see our code is working because 1 3
78:45 - is 4 - 2 is 4 so this and it should be
78:47 - right I mean it makes sense we're doing
78:49 - the math right here in this for loop so
78:51 - now we run through all the numbers in
78:52 - our array so when I f8 through this for
78:54 - loop here it's gonna leave and sure
78:56 - enough it did it left the for loop why
78:58 - because there were no more numbers in
78:59 - the array we were done next I could
79:02 - executable line of code outside the for
79:04 - loop is this print statement and that's
79:06 - what we have print is equaling 1 in new
79:07 - line and we want to join and by that
79:09 - join I'm gonna map we're gonna create a
79:11 - string of our list of outputs so right
79:13 - now we have two outputs and that new
79:15 - lines just gonna mean that's gonna take
79:16 - 1 3 and on a new line I'll put 2 2 again
79:19 - if I did this properly so I'm gonna f8
79:22 - through there everything's out of memory
79:23 - and I just want to see if it actually
79:26 - did it right hey there we go awesome so
79:28 - I'm in the console now so this was the
79:31 - let me bring this up and let me go down
79:33 - here so we can see it so this is the
79:35 - printing out at the end and here in the
79:37 - console we print it out I wanted a new
79:40 - line and I wanted to join and then map
79:43 - creating a string of the list so we have
79:45 - a tuple of 1 3 and a tuple of 2 2 and it
79:49 - got those from the output
79:51 - do-do-do-do-do from the output variable
79:54 - who created right now it's empty
79:55 - memories done because the code is done
79:56 - but you saw the output was growing every
80:00 - time we got through this else statement
80:02 - within the code that output was growing
80:04 - so this is a good opportunity you can
80:06 - look up join method you can look up the
80:08 - map method if you need to play with this
80:11 - change your pair sums get to and add
80:15 - another number and see what happens is
80:17 - you run through your code try to break
80:18 - it and then debug through it and see
80:20 - where it's going wrong and maybe what
80:23 - other tests you might need to put into
80:24 - the code
80:25 - to make it executable I highly recommend
80:28 - memorizing this this aspect of code
80:32 - again as another aspect of the array job
80:36 - interview questions for algorithms for
80:39 - array algorithms not I mean done a race
80:42 - Pacific boat that we're using it for
80:44 - this example
80:48 - this one is primarily just called the
80:49 - largest sum or we're gonna take an array
80:52 - that has positive and negative integers
80:54 - and find the maximum sum of that array
80:56 - so first off we're simply just gonna
81:00 - create will call largest nothing to odd
81:04 - nothing too crazy there we're gonna pass
81:05 - an array through it so first off we want
81:09 - to make sure that the array is even in
81:11 - appropriate length in order to to create
81:14 - a sudden so we're just gonna have if the
81:16 - length of our array equals zero well
81:20 - what do we want it to do we can return
81:23 - to small nothing fancy there so it's
81:30 - putting in a check into the code early
81:32 - on if the array is gonna be if the
81:33 - actual element counts gonna be equal to
81:35 - zero there's no point running this code
81:36 - and we don't want to crash it so we're
81:37 - gonna tell it to print none so first off
81:39 - we're gonna set the first element that
81:41 - was within the first index position
81:43 - within our array we're gonna set it to
81:45 - something that will just we'll name it a
81:47 - variable with max sum and that's going
81:51 - to equal we want another variable and
81:55 - this is going to equal the first element
81:58 - within our right now we're creating two
82:00 - different variables maximum sum and
82:01 - current sum are both equal in the
82:03 - argument I'm sorry the array the first
82:05 - element of the index position 0 the
82:07 - reason that you're gonna see in a second
82:09 - why we want two different Maxim's and
82:10 - current sums as we do the calculations
82:13 - so we're going to create a simple for
82:15 - loop for enum and alright and what we
82:19 - want to do is we want to make sure we
82:20 - can go from we already accounted for the
82:22 - first index position of array 0 in line
82:25 - number 10 so now we want to go from the
82:27 - next index position which an index
82:28 - position of 1 the second number in the
82:30 - array and go all the way to the end so
82:32 - that's just going to be starting at 1
82:33 - and then the column four going to the
82:35 - end then we can close it off so in our
82:38 - for loop we want to count for each
82:39 - number but again we don't need we don't
82:42 - have to account for the first index
82:44 - position because we already did here in
82:45 - this line so now we can start from the
82:47 - second in this position and go to the
82:48 - end of the array in this counting
82:50 - essentially what we're doing now what
82:52 - we're going to do is we're going to
82:53 - compare the current sum which as you can
82:55 - see is set to the first element in the
82:57 - array
82:58 - of indecision zero we want to we want to
83:00 - compare the current sum to the maximum
83:02 - of a Newsome compared to the number that
83:04 - we have so what does that mean so we're
83:06 - gonna redefine the current sum here
83:08 - we're gonna say current sum is gonna
83:10 - equal the maximum well the maximum of
83:12 - what won't either
83:14 - the current sum oops-a-daisy plus that
83:18 - number that we're going to be
83:19 - calculating so this is going to this is
83:24 - do I have what I want to put oh yes but
83:27 - I'm or or the number so if we want to
83:31 - calculus ining what current sum is going
83:35 - to mean let me get this out of the way
83:36 - here just for a second so this is like a
83:38 - current sum tracker if you will this
83:41 - particular line so what we're saying
83:42 - here is we want to redefine the current
83:44 - sum to equal whatever is the maximum is
83:46 - the current sum the maximum plus the
83:49 - number so if it was I would say 2 and
83:51 - then now the number is 3 so is it the
83:53 - maximum 5 or is it the number 5
83:56 - I'm sorry 3 that's gonna be the maximum
83:57 - whichever is the maximum we want to add
83:59 - that to current some stupid and then
84:04 - that we also want to create compare the
84:07 - maximum sum to that current sum so we're
84:10 - gonna have we have a current sum tracker
84:11 - so now we'll have a max sub tracker so
84:16 - that's is simply going to equal the
84:18 - maximum of the current and we're gonna
84:20 - we're gonna of course debug all through
84:22 - this our current sum or the max sum so
84:31 - you get out of there I don't I don't
84:33 - want those greens in place so we're
84:35 - tracking the current sum which is simply
84:37 - whatever number that we're iterating
84:38 - through in this for loop we're adding it
84:40 - to the previous current sum and then
84:43 - we're or the number we're gonna compare
84:45 - the maximum which is gonna be greater
84:46 - that number or the current sum plus the
84:48 - number and then we're also gonna be
84:50 - tracking the maximum sum which is the
84:51 - maximum of the current sum which we just
84:53 - computed a new current sum or the
84:56 - maximum which we already have starting
84:58 - at our first index position of zero so
85:01 - this is just creating a like we said are
85:03 - running sum essentially a maximum sell
85:06 - largest continuous sum of the numbers
85:08 - largest continuous sum so of course when
85:11 - this is all said and done
85:12 - we need to return something right so
85:14 - let's come out of that for a loop and
85:16 - let's just return max sum that's what
85:20 - we're after so now in order to even call
85:23 - this and run it so we can't bug it we're
85:25 - gonna call our defined function we call
85:29 - it largest and in that largest we're
85:34 - gonna call the function that we are now
85:35 - we're gonna put our brackets to create a
85:37 - list so we're gonna put up I want to
85:39 - start with a naught a 1 so when we
85:43 - debugging it makes sense in terms of the
85:45 - coding negative 52 crazy negative 12 3
85:56 - 21
85:57 - the negative 19 all right so we have our
86:01 - array that we're gonna pass through so
86:04 - first off let's let me run this do I
86:06 - have largest sum even here yet now
86:08 - somebody's come across here and let me
86:11 - run largest continuous sum and we're
86:14 - gonna get 38 so at least we don't have
86:16 - any errors yep let me get this out of
86:17 - the way so we can see everything one
86:18 - shot whoops excuse me
86:21 - awesome so now we're gonna go to plug
86:23 - this and we're gonna see exactly what's
86:25 - happening within within the code so
86:27 - we're gonna run our debug and this is
86:30 - largest continuum sum all right so of
86:33 - corresponds we're starting our debugger
86:35 - on our defined function but as the FAQ
86:37 - that it's gonna jump right down to the
86:38 - next executable code because we don't
86:39 - execute functions so until they're
86:41 - called so now we're calling it within
86:42 - this print function we're calling the
86:44 - largest function so we have our array so
86:46 - we assumed that in memory which it did
86:48 - its gonna place that array within memory
86:50 - so there we have our array as a class
86:51 - list so first line if the length of
86:53 - array equals zero well that's false so
86:55 - we know it's gonna it's not going to
86:56 - return print too small it's gonna jump
86:57 - out of that client it's gonna jump out
86:58 - of that if loop because we it's greater
87:01 - than zero so that's false so we want to
87:03 - go two lines at only true so next max
87:04 - sum equals current sum equals argument
87:06 - is zero so it's gonna be true so it's
87:07 - going to create in memory it should
87:08 - create the array of it should create
87:11 - Maxima khals current sum equals seven
87:13 - because that's the first element within
87:15 - our array of Indic position zero so
87:17 - we're gonna fade so sure enough we have
87:18 - maximum is seven current sum is 7 so now
87:20 - we have two new variables that exist
87:21 - within computer memory now next line for
87:24 - a number in
87:25 - the array that we created starting at
87:27 - index position one going all the way to
87:29 - the end so and if someone's already
87:31 - counted for in their previous line ten
87:33 - so now we're gonna be starting in this
87:35 - example the array of restarting for
87:36 - number one all the way to the end
87:38 - we're gonna go number by number so first
87:40 - off it puts in memory a number of one so
87:43 - we want to say current sum let's let's
87:44 - this was our current sum tracker so
87:46 - current sum right now is seven so we
87:48 - want to equal the maximum of seven plus
87:50 - one or one
87:52 - well clearly that's going to be seven
87:54 - I'm sorry eight excuse me
87:56 - so you can see up here current sum now
87:59 - change to eight so that was appropriate
88:01 - now we're gonna work with the maxim
88:03 - tracker but it's good the codes gonna
88:04 - take the maximum of you the current sum
88:06 - which right now is eight or the maximum
88:08 - sum which is seven so it's gonna take
88:09 - eight it's gonna redefine Maksim to now
88:11 - be eight so if you see up here fade
88:14 - maximum Sun chart turned to eight so max
88:17 - M is always going to come after current
88:18 - sum because we're taking the maximum of
88:20 - this continuous value so now the next
88:22 - index position of two is actually the
88:25 - number two so we're gonna fade through
88:26 - this so sure enough our number number
88:29 - two changed now we're going to do
88:31 - current sum is going to equal maximum
88:32 - maximum of what well the maximum with
88:34 - the current sum which is eight plus two
88:36 - of ten or two so that's going to turn
88:38 - the current sum to ten and then the
88:40 - maximum is all the maximum of what will
88:42 - the current summer with Maxim well the
88:44 - current sum is ten the max is eight so
88:46 - what's called your trends to ten and
88:47 - they keep doing some way to get a
88:48 - negative one so current sum is the
88:50 - maximum of the current sum plus the
88:52 - number so that's gonna be ten plus a
88:54 - negative 1 or negative 1 well 10 plus
88:56 - negative 1 is gonna be 9 so it's gonna
88:58 - create it to 9 so here we have the
88:59 - maximum something this is why we did
89:01 - that Maxim counter because now look what
89:02 - happens so far into this code we've
89:04 - always seen the current sum being
89:05 - greater than the maximum now we're
89:06 - seeing the opposite of that so now the
89:08 - maximum sum equals but whatever is the
89:10 - maximum the current sum or the maximum
89:11 - well it's currently the maximum sum we
89:13 - want the largest continuous running sum
89:15 - of the array so it's not going to change
89:17 - the maximum to 9 it's going to keep it
89:19 - at 10 as we go through the next number
89:20 - which is now going to be 3 so now we're
89:22 - gonna have fade through that so now the
89:24 - current sum is 12 and Max is 10 so you
89:26 - know what's gonna happen it's going to
89:27 - turn the max to 12 and we're gonna go
89:28 - through this I like the negative numbers
89:30 - because it really brings it home here we
89:32 - got negative 12 let's run through
89:33 - current some calculations and our
89:35 - current sum is 14 because we did 26 plus
89:38 - negative
89:39 - 12 and that was obviously going to be
89:42 - less than the number of negative 12 even
89:45 - though it was going to be 14 so the
89:47 - current son became 14 but the maximum is
89:49 - now looking at what's greater than Maxim
89:50 - with the current sum and clearly it's
89:52 - the maximum sum so it's going to take 26
89:54 - I'm just going to completely ignore that
89:56 - 14 and it's going to go the next line of
89:58 - code which is gonna be 3 so now as 26 is
90:01 - gonna eventually gonna come up into uh
90:02 - Oh No see that yep so we still 26
90:05 - because current sum is only 17 we wanted
90:07 - the largest continuous running sum so
90:12 - now we currently is now finally greater
90:14 - than the maximum so now the maximum sum
90:17 - is gonna update so they were going on
90:19 - with Maxima 38 so I'm just gonna finish
90:22 - running through this and I got to run to
90:23 - HP the last one return the max um and it
90:27 - sure did we'd have another consult of 38
90:30 - so this is not just a simple addition
90:32 - this is we wanted to go through and find
90:34 - the maximum the largest running
90:36 - continuous sum that we could find within
90:39 - the array so nothing too fancy nothing
90:42 - necessarily new here in the code the
90:45 - only thing we've done a little
90:46 - differently than previous as we both
90:47 - started off with both variables being
90:50 - tied to the same input and then being
90:52 - adjudicated later differently depending
90:54 - on the running sums and the the the the
90:57 - some trackers we were using if their
90:58 - current sum or the maximum sum just
91:02 - start to put these into memory so you
91:03 - have your your interview algorithms at
91:07 - call whenever you need them and the
91:09 - largest benefit of all of this is that
91:11 - when you are working on different
91:13 - projects you can always say well I I
91:15 - need to do X and I can pull that from
91:18 - this array or I can pull this from this
91:20 - server how the hell do I go from
91:21 - beginning to end how do I go reverse oh
91:22 - I can take this from this array that
91:24 - I've memorized so that's the importance
91:26 - of memorizing fundamental pieces early
91:27 - on so then you always have them at your
91:30 - disposal
91:35 - yeah the array it's gonna be given a
91:36 - string of words we want to reverse all
91:38 - the words and we want to do this first
91:39 - we can show just using Python built-in
91:42 - methods how we can utilize that but then
91:44 - I'll say I you can code it from by hand
91:46 - from scratch without using built-in
91:48 - function so if you were doing this in a
91:49 - different language you could pretty much
91:51 - do the same thing so if we're starting
91:52 - with a string this is the best how can
91:54 - we finish with the string beste is this
91:56 - and you'll notice we also did preserve
91:59 - the spaces in between the words and we
92:02 - can also insert something else instead
92:05 - of the spaces should we want to
92:06 - utilizing the join method so first off
92:10 - let's just start to call we'll call it
92:12 - reverse and we're gonna pass a string
92:15 - we'll just call it s for this purpose so
92:18 - we're gonna pass a string as the
92:21 - argument through our to our function
92:23 - that we're creating and what if I I
92:24 - could have simply I could just simply
92:26 - say and I'll explain what all this means
92:29 - I'm gonna return and I'm gonna put a
92:31 - dash in here just so you can see what
92:33 - that's gonna make what is gonna make the
92:36 - code do so then you can understand
92:38 - reversed and we're gonna have to split
92:43 - our particular string that we have so
92:46 - let me just explain to you exactly what
92:48 - I have in here we're gonna kind of and
92:51 - remember it so just like in mathematics
92:53 - or PEMDAS parentheses always take
92:55 - priority and we work from the inside out
92:57 - so starting with our first set of
92:59 - parentheses and they're highlighted here
93:01 - in green so s dot split so what is that
93:04 - actually doing so s is our argument that
93:07 - we're putting through a function reverse
93:09 - that we defined and we're splitting it
93:11 - we're applying this split method on it
93:12 - so what does that do I wanted to quickly
93:15 - show exactly I may bring up I think I'll
93:22 - bring this one up for now so let me copy
93:24 - what we have here and I just want to
93:26 - show you something so what if we did and
93:32 - I'm going to show you like a backhanded
93:33 - way in a sense of doing this if I wanted
93:36 - to if I wanted this to make it as
93:38 - simplified as possible so what what I'm
93:41 - essentially doing when we do this to
93:42 - make sure we're tabbing is appropriate
93:43 - I'm saying take the the argument s that
93:47 - and I want you to create that new
93:49 - variety a split so what does that do so
93:54 - all we're doing is we're taking our
93:55 - argument here we're playing the split
93:56 - method me it's going to split that that
93:58 - string up so what if we passed will pass
94:01 - this copy we're essentially going to be
94:07 - calling our method that we have there
94:10 - reverse and I'm putting in that string
94:14 - that I just copied from before this is
94:15 - the best so right now my return is it's
94:19 - calling for the s-splits so we've we've
94:21 - covered that so we could take this part
94:23 - out right and then we have the reversed
94:27 - function here that's being utilized now
94:29 - there is also a reverse in Python that's
94:32 - reverse and there's a reversed and one's
94:34 - gonna be on the string and one's gonna
94:35 - be on an object so all I'm gonna do
94:37 - again to keep with this method of
94:38 - simplicity I'm gonna get rid of all this
94:40 - for just a hot second so we've taken our
94:44 - argument s which is a string we're
94:46 - saying take that string and now here and
94:48 - split it into pieces and then with those
94:50 - pieces we have a new s now which is a
94:52 - split version of that string meaning
94:54 - it's just segment so we have the string
94:56 - this is the best so it's gonna take this
94:59 - and it's going to take this and it's
95:00 - gonna take it down it's gonna take paths
95:01 - it's gonna separate them it's gonna
95:03 - split them up and then I just want you
95:07 - to reverse it I'm gonna put the reverse
95:09 - method the dot reverse method on that
95:10 - string and then I want you to return to
95:13 - me well s right that's what we're doing
95:15 - so I'm calling down this print function
95:17 - here I'm calling the reverse and let's
95:19 - actually run it and then make sure we
95:21 - can debug it to make sure it makes sense
95:23 - to us
95:23 - so beste is this so first off notice it
95:26 - returns a list the letters are not
95:29 - reverse the words are reversed the
95:31 - elements of each of the words are
95:33 - reversed and they're separated here by
95:35 - commas because it is a list so we don't
95:37 - have anything representing the spaces
95:38 - except the space here there's a space
95:40 - here and there's a space here so let's
95:43 - do let me go through this
95:50 - so first off it's gonna create the
95:52 - variable essence but this is the best so
95:55 - it's taking a string that I'm giving
95:57 - that I'm assigning into this function
95:58 - reverse that we just defined I'm gonna
96:01 - have a through it as split so you can
96:03 - see really quick with the S dot split
96:05 - what did was it took that string that we
96:07 - had this is the best and it broken up
96:08 - into it now it's a list C class list
96:10 - this is the best so it just broke it up
96:12 - into four different elements 0 1 2 3
96:15 - instead of our list and now we're gonna
96:17 - take that new string s or that variable
96:20 - s we want to apply the reverse method to
96:22 - it so fa through that and now you can
96:24 - see up here beste is this and then we're
96:26 - just returning what s is now that's it
96:30 - so that's exactly what we saw down here
96:33 - in the console so we know we're working
96:35 - so what is this is kind of doing all of
96:39 - that with one modification this is doing
96:42 - all of that that one line of code that
96:45 - I'm going to show you next is doing all
96:46 - of this plus one more thing so we have
96:48 - our s we're splitting it we're reversing
96:50 - and I notice this is not reversed this
96:52 - is reversed because that's going to be
96:54 - on an object and then we have the dot
96:56 - join method so the dot join method and
96:59 - then we there's two point two parts
97:01 - excuse me to the join method so this
97:05 - whatever we have in between the
97:07 - quotations here we're telling Python to
97:09 - join the sequence that we're creating in
97:11 - this case via - we can make it whatever
97:15 - we want I'll show you how we could do
97:16 - that in two different ways in a second
97:17 - calling the join method is just going to
97:19 - return a sequence that's joined by the
97:21 - separator so we're telling Python here's
97:23 - the separator that I want to use and
97:26 - what I want you to do with that
97:27 - separator I want you to join what you
97:29 - reversed after you split it into a list
97:32 - all right so with that said let's be
97:35 - consistent let's take this and I'll
97:38 - bring you over here so of course this is
97:44 - under assumption traversal so I'm going
97:46 - to run it let's see we got beste is this
97:48 - so we reversed it appropriately we don't
97:50 - have we no longer have spaces now we
97:52 - have our separator is the - so to show
97:55 - you let me make it a dollar sign we'll
97:58 - run it again so now best I'll assign the
98:01 - dollar sign is dollar sign this
98:03 - so all I did was with the dot joy mat
98:05 - that we're giving the separator how we
98:07 - want it to be separated and then we
98:08 - wanted to join it and if you want spaces
98:10 - then put it in your separator and now
98:12 - you'll have spaces surrounding the
98:14 - dollar sign and the dot joint method
98:16 - after we reversed it after we split it
98:18 - up into a new list so this is one quick
98:21 - way you could reverse a string utilizing
98:23 - Python built-ins another simple way I
98:27 - can think to do it let's I'm actually
98:29 - going to do I'm going to keep this piece
98:31 - doo doo doo doo another way a simple way
98:34 - you could have done it is simply just
98:35 - almost doing well not almost doing
98:38 - actually doing indexing through it so if
98:41 - I'm just gonna I'm gonna go back to
98:42 - return and I want to keep it let's do a
98:45 - star this time let's do a space on it so
98:47 - I wanna call my join method and what I
98:50 - want to do with this join method I'm
98:52 - gonna say we're gonna skip the reverse
98:54 - directly and I just still want to split
98:56 - it alright so we still want to split but
99:00 - now in addition I'm actually gonna call
99:01 - my list and I'm gonna say start in the
99:03 - beginning going all the way to the end
99:05 - and then reverse that burrow so let's
99:09 - run it now send reversal beste is this
99:11 - so I have my string it's split it or
99:16 - rather if we go inside now for
99:17 - parentheses we did split it first and
99:20 - then we reversed it via end using
99:21 - indexing from the beginning to the end
99:23 - then reverse that order and join it up
99:26 - with the star with the space on each
99:28 - side so there's two ways we could
99:29 - quickly do it utilizing Python built-ins
99:33 - now for like I said we'll get rid of
99:36 - this will keep our reverse the string
99:39 - and we'll keep our print statement that
99:41 - we're going to use with the actual
99:42 - string element that we're going to do
99:43 - let's do another one one that would be
99:46 - more appropriate for an interview
99:47 - because it's not use it not utilizing
99:49 - Python built-ins so first off what we're
99:52 - gonna do we're going to just we care
99:57 - about the length of our string all right
99:59 - so we're just photos we're gonna first
100:01 - call off our length and we're gonna say
100:03 - that's gonna be the length of s alright
100:06 - nothing too crazy there and what I'm
100:08 - gonna do is we're gonna have an index
100:10 - track or I need something to tracked us
100:12 - with and what does that mean when we do
100:15 - this first and then I'll make sense
100:17 - - and again yes well we'll debug as we
100:19 - go through this this is gonna be my
100:22 - index tracker that I have here so uh
100:25 - that didn't mean to do that
100:27 - and the reason I have that it's called
100:30 - what I'm gonna say is wile hi is less
100:36 - than the length so what are we saying
100:38 - here I mean we have the length as a
100:42 - variable create up hit the length of the
100:43 - string so we know this string is going
100:45 - to be one two three four five six seven
100:47 - eight nine 10 11 12 13 14 15 16 16
100:50 - different elements we have to include
100:51 - the spaces because whitespace is
100:54 - included in Python when it counts so we
100:56 - have the length with it's the length of
100:57 - the string and we're saying while I is
100:59 - less than the length the length of the
101:00 - string probably could have gotten where
101:02 - two lengths and wrote the length s here
101:03 - and we already have I is starting at
101:05 - zero because that's gonna be our index
101:06 - counter what do I want to do while the
101:08 - eye is less right now zero is less than
101:10 - the string absolutely what do I want to
101:12 - do with that well we're gonna jump right
101:15 - into an if loop as well and what I'm
101:17 - doing here is I'm saying if string at
101:19 - that position so right now I'm at zero
101:22 - position right because I is equal to
101:24 - zero so I'm saying in the indexed of 0
101:26 - of my string which is going to be here
101:28 - that the t in this case if the
101:31 - interposition of string is not in spaces
101:32 - meaning we don't have any spaces in
101:36 - place right now right now python is
101:38 - gonna be saying to me what the hell does
101:39 - spaces mean and that's we're gonna come
101:41 - up top here and we're going to tell
101:43 - python what we want to call spaces and
101:46 - space is is simply going to be
101:49 - whoops-a-daisy excuse me a space so what
101:54 - I'm doing is I'm putting it as a list
101:56 - because this is all going to be broken
101:57 - down the list and we're index I'm using
101:58 - indexing so if the index is not in
102:01 - spaces meaning it's not a space the
102:03 - element is actually a letter what I want
102:06 - to do if the element is a letter because
102:08 - if we're not in a space here's a space
102:11 - if I'm not in a space that the first
102:12 - one's not going to be in a space you're
102:13 - gonna see we do this when we debug it in
102:15 - memory it's gonna pull that T out if
102:18 - index of zero goes starting at zero not
102:21 - in space as well it's non spaces that's
102:22 - gonna be true so what do I want to do if
102:24 - it's true well I want to create some
102:27 - kind of a another variable worth
102:30 - going to maintain that letter so we're
102:34 - gonna call it word start and will it
102:36 - just make it equal to I so that we know
102:39 - where the word is starting for this
102:40 - index that's all it's doing this is just
102:42 - let me note that a word is starting and
102:44 - it's going to equalize so word start in
102:45 - this case well then equal zero when I do
102:48 - this this first piece so I know that
102:50 - zero is going to have the start of a
102:53 - letter now I still want to stay within
102:55 - this this while and if loop because what
102:58 - I'm gonna say next is while and it can
103:00 - this will make more sense to you well we
103:01 - debug it if if you're not getting yeah
103:03 - while the length and I like I like dupes
103:10 - I like doing some loop within a loop in
103:14 - a sense while I is less than the length
103:16 - and we're gonna see that that's pretty
103:17 - clear at this point and the index at I
103:20 - is not in spaces what I want to do so
103:25 - while I is less than length and we're at
103:27 - that position not in spaces that's toda
103:29 - been true at this potion here right well
103:32 - it's sure and I want to add a 1 to the I
103:34 - until we hit a space that's what I want
103:35 - to be doing so we're just gonna simply
103:37 - do I equals plus equals 1 I plus equals
103:41 - 1 so that's again equals I equals I plus
103:43 - 1 we just want to increase that I
103:45 - counter until we hit a space because I
103:47 - haven't hit a space when I first start
103:49 - this index of the string that we're
103:51 - passing to the definition and well that
103:54 - what I want to do if if I am actually
103:56 - doing that I want to add that letter to
103:58 - another variable that I don't yet have
104:01 - so what I'm gonna do is I'm gonna come
104:03 - up to the top again and we're going to
104:05 - create a new variable just um we'll call
104:07 - it words that's what we're doing right
104:08 - we'll make an empty list so now what I
104:11 - can do is we can say within this while
104:14 - loop outside of the while loop mean if
104:18 - once we get past that know that piece of
104:19 - the code because this is going to be
104:21 - independent of that I want to append I
104:23 - want to take my words empty last list
104:26 - and I want to append it what do I want
104:27 - to pend it with well clearly for my
104:30 - string I want to take words start and
104:32 - that's what we have up here that's going
104:34 - to be our I at that moment so we're just
104:36 - recording that variable word start from
104:38 - the beginning to I and I is going to be
104:42 - adjudicated right up above here
104:44 - so it these two pieces of code here this
104:47 - line 20 and line 23 are going to run
104:50 - both of them will execute with the same
104:54 - eye and then what I just want you to sit
105:01 - in again this will make more sense when
105:02 - we debug it we're adding the word that
105:04 - we collected or the letter that we
105:05 - collected in that while loop into a
105:08 - space so if we collect at a letter in
105:11 - here so while little is a non spaces so
105:13 - this would have been so far as we run
105:14 - through this we've so far we have the
105:15 - letter T so if if index of zero of the S
105:20 - is non space that's true its T word
105:22 - start equals I word start is down below
105:26 - here so equals I so that's the equaling
105:28 - zero at that moment which is actually
105:30 - going to be the S word start we're
105:32 - calling the index here of zero to the I
105:37 - which is going to be then at that point
105:39 - one and that's going to give me the
105:40 - letter T so I'm taking the letter T and
105:42 - I'm going to pend that into words and
105:44 - that's going to be up in here so what
105:47 - else do we need to do well number of
105:51 - things one we have to then add that and
105:53 - that's what we're going to do right now
105:54 - let me go into the if loop here so why
106:00 - am i doing that
106:01 - because if I'm going to get a space Y
106:04 - lies less in length if s is not in
106:06 - spaces if this becomes a false meaning I
106:09 - have a space BAM I want to come down and
106:12 - I want to increase my I so I can go to
106:13 - the next element that's within my string
106:16 - ergo the argument that I'm passing
106:17 - through the function that we are
106:19 - defining and when all is said and done
106:22 - what do we need to do we need to return
106:24 - something
106:25 - so let's and I want this lined up with
106:27 - my while so I'm going to return what are
106:30 - we returning I'm gonna put a space there
106:32 - because I just want to put a space in
106:34 - between my join method that we're going
106:36 - to be using so it's a little cleaner and
106:38 - what we reversed because we collected
106:42 - our word list our words variable here is
106:45 - going to contain the breakdown of this
106:48 - is the best this is a lot of work just
106:50 - to break this down so that it's in a
106:51 - complete same thing this is the best and
106:53 - you're going to see that and then at the
106:55 - end here we're going to call the
106:56 - reversed on an object
106:58 - and we have our object is s that's what
107:01 - I call to correct yes s so that's all we
107:04 - did there so nothing crazy so let us
107:08 - debug well first off let me run it so
107:13 - this is sentence reversal so now we have
107:19 - this is the best and if I didn't want
107:23 - those spaces and the letters we can do
107:27 - that but you'll notice here not only did
107:29 - we reverse the letters River I'm sorry
107:31 - the words we reverse the letters as well
107:33 - so let's debug and go through this and
107:35 - see what's what I want to see if I can
107:38 - open it up so we can get everything yeah
107:39 - it's gonna be enough let's go like that
107:46 - so we can see the whole shebang all
107:48 - right run
107:49 - I want to debug this and this is sent a
107:52 - traversal all right we're gonna see
107:58 - everything on the screen all right let's
108:01 - go
108:02 - I fade through it so like all code it's
108:04 - gonna not gonna do the function I'm
108:05 - gonna go down to our print statement
108:07 - works we're calling the function we
108:08 - define and putting in the string this is
108:09 - the best now first thing the length
108:12 - length of s it's gonna give me a 16 and
108:14 - again if you count the letters you have
108:15 - to also count the spaces and then we
108:17 - have spaces this is empty list nothing
108:20 - special to it with this with a space in
108:21 - between words is also going to be an
108:24 - empty list and then we have I equals 0
108:26 - so it's gonna create I equals 0 so Y is
108:28 - less than the length old length we could
108:29 - see is 16 up top here and the length the
108:33 - I right now is 0 so that's true so we go
108:36 - to the next line within the loop if si
108:38 - not in spaces so I is 0 index of 0 is T
108:44 - it's not in spaces because spaces is an
108:47 - empty space so that's true so it's gonna
108:49 - go the next part of the loop word start
108:51 - equals eyes so now it's going to create
108:53 - a new variable in memory called word
108:56 - start it's going to equal I and this
108:58 - point I is 0 next line while I or 0 is
109:02 - less than 16 in this case which is true
109:04 - and remember and loop both have to be
109:07 - true NS I which is 0 which is T not in
109:10 - space is true so
109:11 - true and true then it absolutely will
109:13 - execute this next line in here I equals
109:16 - I plus one so now I is going to go from
109:19 - zero which will start out now to one and
109:21 - then we're gonna go to the two ah I
109:27 - messed up my spacing did I no thought I
109:31 - messed up my space in there for out
109:32 - second so let me I want to start that
109:39 - over for you guys
109:42 - no I don't want to do that I wanted to
109:44 - bug let's get it in there let's get it
109:52 - in place I want to show you exactly
109:53 - where I went ahead of myself so let me
109:57 - go to where we got so Y is less than
109:59 - length and si not in spaces I equals I
110:02 - plus one so we did that we got the one
110:05 - and we can see that we have nothing in
110:07 - place yet now while I equals less than
110:09 - two so it's still doing work start still
110:10 - zero while I is less than like NS is not
110:14 - in spaces we want to keep adding to the
110:16 - I so what you're gonna notice here is
110:19 - what you don't see it happening in
110:21 - memory except for the updating of the I
110:22 - we're going through this first word here
110:25 - because we haven't gotten two spaces
110:26 - once we get a false here it's going to
110:28 - stay in this loop here this while loop
110:29 - but once we get a false then we're gonna
110:31 - jump down below and we're gonna append
110:33 - so right now in memory we have an index
110:36 - of zero and one which is T and H so
110:40 - we're gonna have faith through there now
110:42 - we have an index of three here so 0 1 2
110:46 - 3 so sf8 now we're at index of 4 acid an
110:52 - index of 4 is a space 0 1 2 3 4 so now i
110:57 - is a space so while I is less than
110:59 - length well that's true 4 is less than
111:01 - 16 and the index of that position for
111:05 - not in spaces will not in space as a
111:07 - space that's a false so it should jump
111:09 - me out of the suit and put me into words
111:10 - down below there we go so now what's
111:12 - gonna happen we're in words that append
111:15 - words was an empty list you can see it
111:16 - here in memory and empty list words dot
111:18 - append we're appending from our string s
111:20 - words start words start 0 to RI or
111:24 - what is my IRA now for so it's going to
111:28 - take index of 0 T 2 4 1 0 1 2 3 4 so
111:34 - when I FA through this it should pop the
111:36 - word at this there goes this into the
111:38 - words empty list because we rant we hit
111:41 - a space so that jumped out that first
111:43 - word so I equals now we still want to
111:46 - increase our I 1 more to get out of that
111:47 - space because though is gonna be stuck
111:49 - in number 4 so now I equals 5 so now
111:51 - what's in 5 it's the letter I so I'm
111:54 - gonna go through words start is now
111:56 - gonna be 5 it's gonna equal I that's
111:58 - fine 5 is less than 16 5 is less than 16
112:02 - that's what we have here well 5 is less
112:03 - than 16 and the index position s 5 is
112:06 - not in spaces well we know in Nick's
112:08 - position 5 in the S is I so that's true
112:11 - so what's gonna f 8 so we're gonna go to
112:13 - 6 for the I and that should be the same
112:15 - true here for success 6 is good now 7 is
112:20 - a space so it should jump me out of this
112:22 - while loop again and go down and append
112:24 - the word is to my word list the empty
112:28 - list that I had here same thing now now
112:33 - it's just gonna be for the we increased
112:34 - our I to 8 so that we can get to the T
112:36 - in the word the so 8 is T 9 is H 10 is e
112:42 - 11 s a space word append this is the you
112:47 - can see now in the words variable we now
112:50 - we have the the and again we're gonna go
112:52 - F 8 again same thing while eyes lesson
112:54 - length is 12 absolutely is not in spaces
112:58 - nope nope word starts going to be on 12
113:01 - which is excellent that's going to be
113:02 - the B and the word best so we're gonna
113:05 - be going 13 14 15 so we get to 16 so now
113:11 - there's no space after this so it's not
113:12 - gonna jump me um out of the loop because
113:15 - of the spaces while I is less than
113:17 - length look what happens now when I get
113:20 - before execute this code we have a next
113:21 - video we're just sitting on it
113:22 - I is 16 length is 16 this now loop
113:25 - becomes false it's why I loop now
113:27 - becomes a false so we're gonna skip this
113:28 - and we're gonna go down to words append
113:30 - so now when I execute this words append
113:32 - now we'll get the word best up in our
113:34 - variable top here and there we go we got
113:36 - best I equals
113:38 - plus one it'll execute it now it's 17
113:41 - while I is less than leg 17 is greater
113:43 - than 16 this whole loop now becomes a
113:47 - false I'm not going to get past this
113:48 - first line so I got to jump down into my
113:50 - return and what am I saying here return
113:53 - with no spaces join these because you'll
113:55 - see we have spaces already in our words
113:57 - list join no space join this reversed s
114:02 - the string will print it out and I can
114:07 - go to my console where did my console go
114:12 - that was rude and we're printing out
114:18 - letter for letter of exactly how we how
114:20 - we did that and you'll notice the
114:21 - difference we got the letters this time
114:23 - and not the words from before is we
114:25 - reversing the entire string and if you
114:27 - recall in memory that the string was not
114:29 - it wasn't split into its constituents
114:32 - whereas in the code we did before we
114:34 - were calling the split function to break
114:37 - up those pieces if we utilize the split
114:40 - function in this we would have gotten
114:41 - the same outcome in regards to the words
114:44 - going backwards so just really quick
114:48 - another way I want to show without even
114:52 - having to use the join method if I did
114:57 - reverse this let me just quickly say
115:02 - this is the one that I would memorize I
115:05 - mean the other ones you got the
115:06 - functions you got the the built-in
115:08 - functions in Python and that's cool but
115:11 - this is the one that I would pretty much
115:12 - memorize and work with not only is it I
115:15 - utilize another language as long as you
115:17 - have loops of course but it makes the
115:19 - most sense in terms of going element by
115:21 - element creating taking that string as
115:24 - an argument and breaking it down element
115:27 - by element and creating counts and
115:29 - indexing counts and then building and
115:30 - rebuilding that list and then doing what
115:32 - you want to do with it and having a
115:34 - number of different loops within loops
115:36 - and different conditional statements
115:37 - where we using the end a boolean end
115:39 - statement to get a true and a true
115:41 - otherwise we're going to jump down to
115:43 - the pen so this is this is a really good
115:44 - exercise but I just want to show one
115:48 - more semi piece if I simply just had
115:51 - do to do to do we could return and if I
115:55 - return ass because that's what you can't
115:58 - see it now but let me get rid of this
115:59 - I'm sorry that's what we're calling so
116:01 - if I took my ass and I split it just
116:04 - like I showed and then we simply could
116:06 - ask Oh beginning to back I gotta go to
116:18 - test now because that's where I am I
116:28 - want to quickly show that what you could
116:31 - do is not only you sit there and say we
116:35 - didn't reverse anything the point I
116:36 - wanted to make with this was inside the
116:37 - pit print function since now this is a
116:41 - string that I have I can call the
116:43 - reverse instead of not reverse for the D
116:46 - but just reverse on it so I can run it
116:49 - and then I'm gonna get my split on the
116:51 - list grant M ILO so it's actually going
116:53 - to take my string it's going to reverse
116:55 - it I'm just gonna reverse a string that
116:58 - it returns after it goes to this reverse
116:59 - function that we have I should probably
117:01 - call this something else so it's not
117:02 - confusing let's just call it Rev so I'm
117:10 - calling my function that we have hello I
117:13 - am grant so the functions gonna take
117:15 - that string hello I am grant it's gonna
117:17 - split it so we're going to have one list
117:20 - with each of the elements and its own
117:22 - forward and then we just did beginning
117:24 - to end minus one so I think I showed you
117:26 - guys that one earlier on I just I really
117:28 - like this one personally because I like
117:30 - the idea of the indexing because when we
117:31 - get into data science and machine
117:33 - learning we really utilize a lot of this
117:35 - indexing when we're messing with data
117:37 - bases and so forth
117:42 - two arrays were swimming no duplicates
117:44 - within those arrays is one array a
117:47 - rotation of another if it is we're going
117:49 - to return true or false so they have to
117:51 - be the same size and the elements same
117:54 - size and elements but they're going to
117:55 - start at a different index location this
117:58 - is gonna be a big goal of man it's gonna
117:59 - be linear now we're gonna go through
118:01 - each array two times but it's Oh times
118:02 - two and again the two is not going to
118:04 - count because constants are going to be
118:05 - nothing as you get infinite infinitely
118:06 - large we want to select an index
118:09 - position in list one get its value and
118:12 - we're going to find the same element and
118:13 - list two and see where it is in that
118:15 - index and then from there we're gonna go
118:17 - index position index position because
118:18 - again they should be in the same same
118:21 - size same elements and starting the same
118:23 - it says start index in different
118:24 - locations so as if if I get to index
118:29 - position 0 of list 1 is the number two
118:31 - and number two is index position 4 and
118:35 - list 2 then when I go to in x position 5
118:38 - in list 2 and 1 in list 1 it should be
118:41 - the same next number so have fun with
118:44 - that
118:45 - let's run forward so we're just going to
118:48 - call it rotation and just like I said
118:50 - we're passing one list and two lists
118:54 - those are gonna be our arguments for the
118:56 - for the for the defined function and
118:58 - then we're going to do a quick edge
119:00 - check here if they're not the same
119:02 - length then they're certainly cannot be
119:04 - a rotation of each other right so simply
119:06 - if the length of list 1 we do want to
119:11 - close that off does not equal the length
119:16 - of list 2 so what we're doing here again
119:20 - is saying if it doesn't equal to list 2
119:21 - then what we want to do if the lengths
119:23 - are different and even rotation the
119:25 - lengths have to be exactly the same the
119:27 - elements have to be the same just a
119:28 - different index location well we just
119:31 - simply want to return false so we have
119:35 - an edge check in place now we want to do
119:38 - is you want to in memory you want to
119:40 - create the first element of list 1 we
119:42 - want to store that into into memory so
119:45 - we're just going to simply say that
119:46 - we're gonna call it the K and that's
119:48 - going to be a 1 and how do we call the
119:49 - position just 0 ok that's okay it's a
119:52 - list so we can just index to it in X
119:54 - position 0
119:56 - so we have our first variable and the
119:58 - second one we're going to call heat
119:59 - index we're going to create a counter
120:01 - and we're going to initialize it to zero
120:06 - now this is going to be what we're going
120:08 - to be counting as we're looking through
120:10 - the second list to see what the net
120:12 - number what that value is in that index
120:15 - position should nobody want to iterate
120:18 - through lists to trying to find this key
120:20 - starting at index zero because remember
120:22 - when I pass the list 1 I'm already gonna
120:24 - have in memory key the first element of
120:27 - list 1 so now I want to pass through
120:28 - lists to and say hey we're in your list
120:31 - or what an index position do you have
120:33 - this value whatever this value is here
120:35 - so I wanted to do that point to do our
120:37 - good old for loops also for eye and
120:44 - we're simply gonna do the length of list
120:47 - 2 so now we can iterate through list
120:53 - here trying to find this case that what
120:55 - we want to do is you have our for loop
120:57 - for I and range or doing the range
120:59 - because of course we want to go for the
121:00 - full length of the list and we're doing
121:02 - index positioning so we wanted to start
121:04 - at 0 because length of the list which is
121:07 - count the elements so if list too
121:13 - because we're doing two right and we
121:15 - want to see if the index position of two
121:17 - so if the index position that I is
121:19 - currently at an index number two if it
121:21 - equals the key well what I want to do
121:25 - so if list two has the same value that
121:27 - we've sorted in the key well I want to
121:30 - create an increase and a key index I
121:37 - want to change the the key key counter I
121:40 - wanted to make that index sorry so what
121:46 - this is going to mean is that as we go
121:48 - through this let's say I is at two
121:50 - so for two in range because there will
121:52 - be more than two numbers if list I at if
121:55 - the element that's at position number
121:57 - two and let's say it's five equals the
122:00 - key let's say the first element list of
122:02 - almost five so let's say they equal each
122:03 - other and I want the key index to now be
122:06 - five but what the key index
122:08 - I'm sorry too cuz I was gonna be to want
122:10 - the key index to be - so then what that
122:11 - would tell me is is that for list 1 this
122:15 - element the element of this location the
122:17 - value of this location
122:18 - equals the value at list to index
122:21 - location at index of whatever was at
122:24 - that point of index of index of 2 and
122:28 - yes we're going to debug this of course
122:30 - as we go as we go through now once we
122:34 - have that piece in place next thing I'm
122:36 - gonna want to do is I'm going to want to
122:37 - break out of this code so but because I
122:43 - want to force it to the next line so
122:45 - once I once I find the index in list -
122:49 - that is equatable to the appropriate
122:53 - index of list 1 I then want to break out
122:55 - of the code we only need to do this we
122:59 - don't have to do this once and we won't
123:00 - this is because we want to jump out of
123:01 - the loop that's how what let's how
123:03 - you're forced to jump out of the loop so
123:09 - now we're gonna say if our key index
123:10 - equals 0 which we don't want it to write
123:16 - this would be true if we didn't find the
123:18 - key endless - so that's the only time
123:21 - that this would be true is again if we
123:24 - did not find the key in list - so we're
123:33 - gonna return false because it means that
123:35 - we're we don't we can't even do a
123:36 - rotation because it doesn't have it's
123:38 - missing one of the key values this is
123:40 - missing the same value so now we're just
123:43 - going to now we want to go through list
123:45 - 1 and we're going to iterate through the
123:47 - list 1 but we want to iterate through
123:51 - we're gonna iterate through list 1 I
123:53 - mean want to iterate through this one
123:55 - until we find that element of list -
123:57 - that matches so again this will make
123:59 - more sense as well primarily as we'd be
124:01 - bucket of course that's the best way to
124:03 - learn anything so we're just going to do
124:05 - the right range of length of list 1
124:11 - I'm too far and again this will make
124:14 - more sense so if if list 1 index 0
124:17 - equals the value of 1 and we find a one
124:21 - and list two it index 4 than the canned
124:23 - X at that point it's going to be for
124:25 - this appear is going to be 4 so the
124:27 - value of index position 0 list 1 it
124:30 - might be 4 but the key the 4 in list 2
124:34 - is not showing up until index position 4
124:36 - so this again this will make more sense
124:38 - when we when we debug everything so now
124:43 - what I want to do is I want to create
124:43 - another variable we're gonna name it T
124:46 - and what I want to do is this is just
124:48 - going to create the as you know we'll
124:50 - call it the new index for list 2 so
124:56 - we'll say L to index that's what we're
125:01 - gonna call this one now what we're gonna
125:03 - take is we're gonna save our key index
125:05 - and we're gonna add it to X and this
125:12 - would be good exercise for modulus as
125:13 - well we want to take a modulo length of
125:16 - list 1 and this is going to become the
125:19 - index now for list 2
125:20 - what we're doing is we're gonna reassign
125:23 - the index for list 2 and this is where
125:26 - you're gonna see the comparison so f
125:30 - list 1 position of X alright so if the
125:35 - index position X does not equal
125:41 - plus two and this is where we're going
125:44 - to change its index l2 index so we're
125:47 - getting the value we're getting the
125:52 - value that we've created here and we're
125:54 - checking that index of what we're saying
125:56 - is if if the list 1 if the value at that
126:00 - index position does not match the value
126:02 - at this index position then of course
126:05 - our good old-fashioned we want to return
126:11 - rerun Jesus Christmas we'll want to
126:15 - return false all right
126:17 - but otherwise we want to return true if
126:23 - this first line of code here is going to
126:25 - hold is going to hold right so why do I
126:31 - have
126:39 - oh we got a call in that loop right I
126:41 - wanted to break inside that loop okay
126:43 - what I was looking at just now is why I
126:45 - had I had a read up here telling me if
126:46 - there was an error and my break was on
126:50 - the outside of the loop but I want this
126:51 - break to be inside this loop so that
126:53 - once I actually do satisfy this I want
126:56 - to break out of it break out at that for
126:57 - loop and jump into the next if loop and
126:59 - it's all so let's actually run this
127:02 - through and let's see if it works and
127:04 - then we can debug it so we're gonna call
127:08 - we're gonna call our function my
127:10 - goodness
127:11 - I can't do this so early in the morning
127:13 - we're gonna call our function that we
127:15 - created now we can we're passing to list
127:17 - so we're gonna do brackets so we'll put
127:20 - this one in order and I guess we'll go
127:25 - up to 7 and we'll do a comma we're gonna
127:27 - do another list now this next list has
127:29 - it has the same seven elements right but
127:33 - and the the order has to be the same but
127:35 - the starting point the indexing point
127:37 - will be different so we'll do it as
127:40 - seven and then we went to one two three
127:42 - so that's one two three four five six
127:44 - seven so we have this is a rotation so
127:46 - this should return a true but like I
127:49 - said we're going to go into bug it and
127:50 - then we'll go through that so I'm
127:52 - already in a red rotation I'm gonna run
127:55 - it through and we get a false and we
128:02 - shouldn't I just said we should get a
128:04 - true didn't I so why is statistically
128:12 - something almost same order so let's go
128:15 - through the color my getting the wrong
128:16 - answer then I think they they will
128:19 - return so it's quite a jump it at us
128:20 - it's gonna go here we'll create those
128:21 - two variables for high and range so this
128:24 - would be starting at zero if this equals
128:26 - key key index one can tax I break if
128:34 - this is a false I watch this huh let me
128:41 - try it now true yep so I was breaking
128:45 - out of this loop too early my mistake so
128:49 - now we got it true so now we can
128:50 - actually debug this
128:52 - I'm going to hit their array of rotation
128:58 - let's load our piece into memory alright
129:02 - actually we'll keep it on the debug for
129:03 - now I'm just gonna bring this down a
129:05 - little bit so we have our two pieces in
129:07 - memory we have our list one in our list
129:09 - two and their proper values and you guys
129:13 - don't need all of that so we can just do
129:16 - this see a little bit more if length of
129:20 - this one does not equal length to return
129:21 - false it does equal the same length so
129:23 - it's going to jump down to the next
129:24 - aspect of code which is we're gonna
129:26 - create a key list 1 index 0 and memory
129:28 - and that's actually gave us the values
129:30 - so if we look at list 1 the first index
129:32 - position value is 1 that's why it's a
129:34 - one key index equals 0 that's just the
129:36 - variable key index where you going 0 now
129:38 - for I in range this is the length of
129:41 - list 2 so it's going to iterate through
129:44 - list 2 so the first hit the eye is going
129:48 - to be 0 because that's what we're
129:49 - starting
129:49 - if list 2 eyes so if the index position
129:54 - I so if I look at list to the first
129:57 - indexed value is gonna be number 4 in
129:59 - index position 0 if it equals the key
130:02 - you already know the key equals 1 then
130:05 - we can then we'll jump down a mobile
130:07 - break and we'll go down otherwise the
130:09 - key index is going to equal I so let's
130:11 - watch this go through so if Liz to I
130:14 - equals key it did not equal key because
130:15 - 4 does not equal 1 right now the key is
130:17 - 1 and and the first element this index
130:22 - position unless too was a for some we're
130:25 - going to go check it again now it's
130:26 - going to change up to index position 1
130:28 - well list to an acquisition 1 is a 5 and
130:30 - we're looking for one so we're gonna
130:32 - have Fate it's going to go through it
130:33 - again and now it's gonna change to I
130:34 - equals 2 key and still 1 because that's
130:36 - what we created and in a position to is
130:39 - a 6 so it's not gonna be satisfied it's
130:42 - gonna be false and now it's 3 and if
130:44 - it's in 3 is a 7 it's still not a ones
130:47 - we're gonna have faith through that now
130:48 - it's a 4 0 1 2 3 4 and now at index
130:53 - position for of list to the number 1
130:56 - equals the key index of 1 and list 1 so
131:00 - now that they match it should take us
131:01 - out of this loop it should go to key
131:03 - index equals I so it should change the
131:05 - in Dixon out of four good which it did
131:07 - appropriately ups up here now the key
131:08 - index is for now we can break out of
131:11 - this loop because we're done finding the
131:13 - matching sequence if key index equals
131:15 - zero so key index it started zero but
131:17 - we've changed it this is what it is in
131:19 - memory now it's four this is almost like
131:21 - it to another kind of another edge check
131:23 - if you will and we're simply gonna kind
131:26 - of skip over that because that's going
131:27 - to be false because it's not a index is
131:28 - now for now what we're gonna do is we're
131:31 - gonna this is what we're gonna go over
131:32 - at least one changing the index of list
131:34 - to constantly upping it by one to see
131:37 - where it is that we're going to be
131:38 - within that list and I'm gonna when I'm
131:41 - done with this I'm gonna do a little
131:42 - lesson on modulo because it may not make
131:43 - sense to some people so for X and ranged
131:46 - length of list so X is going to be zero
131:48 - because we're starting at position zero
131:50 - when it for the range l2 index equals
131:53 - four so how do we get that well the key
131:55 - index right now is 4 plus X X is 0 4
131:58 - plus 0 is 4 for module the length of
132:00 - list 1 is 7 so we can go 1 2 3 4 5 6 7
132:03 - so for module 7 is 4 if you don't
132:07 - understand that I'll do a quick video
132:08 - showing how that comes about in just a
132:11 - moment
132:11 - if list 1 X does not equal the list of
132:16 - l2 index and right now it does not the
132:18 - index position of 0 is 1 and the list 2
132:22 - and at position of 4 0 1 2 3 4 is 1 and
132:27 - 1 so it does so if they don't match
132:29 - return false but they do match so now
132:34 - it's going to go to the next one X is
132:35 - going to be 1l indexes of an a have to
132:37 - go up to 5 so now it's checking the the
132:39 - values at index position 1 which is 2
132:42 - and list 2 index position which is now
132:45 - this a 5 which is a 2 so you see how
132:48 - it's going element 4 element now so I'm
132:50 - just going to go through that that
132:51 - matches so it's going to go to 2 and 6
132:53 - so now we're at 3 and 3 and they
132:57 - actually do equal each other so this is
132:59 - going to be false so it's going to jump
133:00 - back into loop now we're at 3 & 6 so
133:05 - we're at 4 0 1 2 3 so when I went 4 for
133:10 - X and a position of 6 so 0 1 2 3 4 5 6
133:16 - and we're going to be matching up the
133:19 - the we didn't even do it it's not for
133:20 - insects it's got to be three and seven
133:22 - yeah I didn't I didn't go through it yet
133:23 - so it goes to an index of zero because
133:26 - again zero to six is one to seven but
133:28 - we're doing a range so now we're
133:30 - matching up through index position three
133:32 - of list 1 and X position 0 list 2 so 0 1
133:36 - 2 3 so that's 4 & 4 so which is it to
133:39 - jump into the list so it's going to do
133:41 - this until we extinguish the range of
133:44 - the list and that should be it for the
133:47 - range because when I get up to 6 so once
133:49 - we jump out of the range and we're going
133:50 - to return true because we've we found
133:52 - that these al these two lists they have
133:55 - the same length they are composed of the
133:57 - same elements and the elements are in
133:59 - the same order the only difference being
134:00 - the starting index position so and of
134:05 - course if we have a do that then in the
134:06 - consoles is going to show us the true
134:10 - that we have so if people didn't get
134:14 - this the module before if you're sitting
134:15 - there saying how the heck and for module
134:16 - 7 equal 4 it doesn't make sense some
134:18 - people maybe even thought on might even
134:19 - three or whatnot let me quickly just
134:22 - show why that is what it is so I'm just
134:29 - gonna quickly open up this program here
134:33 - when they throw on the tablet and move
134:37 - this so it's most people you can
134:47 - actually even make this closer to 3
134:52 - that's excellent
134:55 - do a nice bright green for this so if I
134:59 - did 12 modulo 5 most people are going to
135:04 - tell me why no 5 can go into the 12 it's
135:07 - it's the way that we wait you is
135:09 - supposed to be doing this is 5 times 0 5
135:13 - times 1 5 times 2 5 times 3 and we're
135:17 - gonna get 0 5 10 15 and you see that it
135:21 - fits in here so it's going to be we have
135:22 - we have a 2 in that spot so then and
135:25 - then how do we get to this level if
135:27 - you're a 10 well it's 12 minus 10 it's
135:29 - going to equal 2 so that's why it's
135:32 - equaling
135:32 - - so with that being said what we had we
135:36 - had four and seven that this is where it
135:39 - gets different because four and seven
135:40 - where we're used to the bigger number
135:41 - being first but now with four modulo 7
135:46 - what we're saying is for four goes into
135:49 - seven four zero times
135:51 - so four times zero so so how many times
135:53 - does four go into seven well 7 times
135:56 - zero is zero
135:58 - seven times one equals seven so we can't
136:01 - use we have we have to use the zero this
136:04 - is my point because seven is already
136:05 - larger than four so for taking that zero
136:09 - 4 minus 0 equals 4 so that's my form
136:13 - modulo that is for module seven is going
136:16 - to be four if we go to five let me do
136:22 - this I'll keep it if we went to five
136:32 - modulo 7 and say what is that equal to
136:34 - well again we're at 7 times zero is zero
136:37 - seven times one is seven so we're still
136:40 - in this middle point here so we have to
136:42 - select 0 5 minus 0 is 5 so 5 modules 7
136:46 - to be 5 we get to 6 so it'll be the same
136:48 - thing when you get to 7 and this will
136:51 - make more sense to you now oh my
136:55 - goodness so 7 modulo 7 everyone knows is
137:02 - going to be 0 we have no remainder left
137:03 - over but why well 7 times 0 is 0 7 times
137:07 - 1 is 7 so we can select this and then
137:11 - we're doing 7 minus 7 equals 0 and
137:14 - that's how we're getting that number so
137:16 - modulo czar always easy whenever we're
137:21 - whenever it's you know it's somebody
137:23 - who's gonna be doing that who is gonna
137:26 - be doing the remainder when the top
137:27 - number when your numerators larger than
137:29 - the denominator it's fairly simple to do
137:31 - but it becomes as people got confused
137:33 - when the numerator becomes smaller than
137:35 - the denominator so you have to actually
137:37 - understand how you're how you're doing
137:38 - the math so and that's exactly why in in
137:42 - our example
137:44 - if I'm gonna do this that's why in our
137:46 - example that was pretty cool for modulo
137:50 - 7 and because this was at that point 4
137:53 - plus 0 and so this was our our key index
137:56 - value plus the X at that moment and it
137:58 - was modulo of the length of list 1 and
138:02 - this was seven because we had seven
138:05 - elements within the list one
138:06 - so for modulo 7 again was going to
138:09 - that's why I was going to equal 4
138:10 - because we were going to end up getting
138:11 - 4 minus 0 so I just wanted to quickly
138:14 - explain that because I could see people
138:16 - coming up with a question saying how the
138:17 - heck did you get that
138:21 - we want to return the common elements as
138:23 - an array between two sorted arrays of
138:25 - integers
138:25 - hey sending reduce things not going to
138:27 - matter I'm an example the common
138:29 - elements let me just quickly do this I'm
138:32 - still on softwraps
138:34 - it's ending in the order entered a
138:37 - standing order example the common
138:38 - elements between 1 3 4 6 7 9 and 1 2 4 5
138:41 - 7 5 9 and 10 are 1 4 & 9 so if we want
138:43 - to just take to a different race and
138:45 - tell me which two elements are the same
138:47 - between them so let's first off name it
138:53 - up but what are we going to take through
138:54 - this we're going to take like I said 2
138:56 - different arrays so we'll just name them
138:57 - a and B for this argument so now we want
139:00 - to create pointers that are going to
139:02 - point each index and compare the values
139:04 - so we want to have a pointer that's
139:07 - going to you know point look at this
139:08 - index 0 and index 0 and X 1 and X 1 we
139:11 - want to find the common elements that
139:13 - are going to exist between so we're
139:14 - going to use pointers first off to then
139:15 - append into a list so I'm just going to
139:19 - create pointer 1 and what do we think
139:21 - we're going to do we're going to set
139:22 - that counter to 0 all right so this is
139:24 - pointing at index is 0 for a fro it's
139:28 - gonna be for a essentially and that's
139:29 - how we're going to tie it together and
139:31 - pointer to what do you think is going to
139:34 - be at da right the same for big nothing
139:36 - special there so recording two different
139:38 - pointers we're going to tie those two a
139:39 - and B later to dictate a index position
139:43 - and like I said I do want to have an
139:46 - empty list cuz we're going to be
139:47 - appending this let's just keep it proper
139:55 - context so we're gonna do a while loop
139:57 - we want to go through the length of the
140:00 - list essentially and check the
140:02 - corresponding index position to know if
140:06 - the index value is the same and we want
140:07 - to add that element to the result if
140:09 - it's not the same that's how we're gonna
140:10 - get the the end product so
140:13 - while p1 which was the end of which is
140:16 - one of the variables we created while p1
140:18 - is less length and length of a that's
140:20 - what we're comparing it to and I love
140:24 - using an ellipse p2 is less than what do
140:28 - you think the length of B so while and
140:33 - it's a bit both of these conditions that
140:36 - the point I want to make is both of
140:37 - these conditions have to be true in
140:39 - order to get to the next line of code so
140:43 - if while we're going through the loop if
140:46 - a so what does this say so while we're
140:50 - going to the loop if the index location
140:54 - of a is what equal to the index location
141:00 - of being so if the value at that next
141:05 - location is the same if the index value
141:08 - is the same then we want to add the
141:10 - element to the result so how do we add
141:12 - an element to the result well the
141:13 - results up here is the variable that we
141:16 - created which is an empty list so we're
141:18 - just going to good old-fashioned result
141:20 - append and what are we appending we want
141:24 - to append the value at that point
141:29 - whatever p1 is going to equal for that
141:30 - index location of a since since they're
141:34 - equal it does not matter which one
141:36 - you're gonna add from this could have
141:37 - been be p2 it doesn't matter the point
141:39 - is if because it's there the same if
141:42 - you're appending your empty list result
141:45 - we're only doing so when these two equal
141:47 - so whether you did a p1 or b p2 it's the
141:49 - same value that's that's all that's
141:51 - that's that's gonna mean and now what do
141:53 - we do whenever we want to move to the
141:56 - next index location we're gonna have to
141:58 - simply change our count right so now we
142:05 - can actually move through the iteration
142:06 - appropriately now we want to do we have
142:10 - to cover for other ups look at that I
142:11 - forgot a call we have to now account for
142:16 - other instances so what if P 1 because
142:21 - we have if they're equal to each other
142:22 - what if it's a greater than
142:27 - what if it's greater or if the values
142:30 - give if the index at a element is larger
142:32 - than the one that's at the B element we
142:34 - want to move point we want to move our
142:37 - pointer in bei only so how are we gonna
142:42 - move our pointer nothing crazy
142:44 - where it's gonna say P to cuz again that
142:47 - was our pointer we want to move it up by
142:48 - one we're only moving the pointer in
142:50 - point B since the a element is larger
142:52 - all right that's gonna cover if that's
142:55 - the case but we need one more condition
142:56 - right we're gonna use an else the only
142:59 - other possibility is that the value at
143:01 - ap one is smaller than the value of B p2
143:04 - so all we're gonna do in that case is
143:08 - increment P one we're gonna increment
143:12 - our pointer RP one pointer so that it
143:17 - can then still stay within this while
143:18 - loop because that's what we're doing and
143:21 - what do we want to return at the end of
143:22 - all of this we want to return our result
143:24 - that we have here to see what it's
143:26 - actually going to put within that list
143:28 - so let's actually run this bad boy and
143:32 - see how we're doing
143:33 - common elements and oops-a-daisy look at
143:36 - that otherwise we can see what are we
143:38 - passing through or passing through two
143:40 - arrays right so let's do 1 3 4 6 7 9
143:48 - then we have to do a second or right
143:50 - because we're taking 2 so we'll do 1 2 4
143:54 - 5 9 and that will say 10 so we have 1 2
144:00 - 3 4 5 6 1 2 3 4 5 6 we have 6 minutes
144:04 - they don't have to be the same
144:10 - do-do-do-do-do-do
144:11 - all right so let's run this bad boy
144:16 - common elements
144:23 - yep so it comes out it tells me you can
144:30 - see that 149 let's quickly look before
144:32 - we start to debug it make sure we're
144:34 - good so let's check Athena positions are
144:43 - correct we're checking common elements
144:48 - so they both have a 1 that's true
144:51 - they both do not have a 3 they both have
144:55 - a 4 they both have a 9 so 1 4 9
145:06 - excellent
145:07 - so again but this was the common
145:09 - elements of A to B so you'll notice it
145:11 - didn't put a 10 where you would think
145:14 - you know I didn't but it's not a common
145:16 - element so it is checking good to be
145:18 - against the a as well so let's debug
145:21 - this let me hop up here let's run our
145:24 - debug bring this down just for we have a
145:29 - little more space so it's going to put
145:31 - into memory are a and B arrays that we
145:34 - have so this is just our two variables
145:36 - p1 and p2 is just gonna put those in
145:38 - memory we have encounter at 0 nothing
145:39 - special there the results the same thing
145:42 - results with a variable to an empty list
145:43 - now we're gonna do our first of all P is
145:46 - less than the length of a call the
145:47 - length of a as well as at 6 1 2 3 4 5 6
145:50 - it is to the right now P I p1 and p2 are
145:53 - both 0 so it's definitely less than like
145:54 - they and p2 is also less than like BAE
145:56 - so what's gonna run through though that
145:58 - while loop and it says if a p1 equals b
146:02 - p2 result append a with p1 so they did 1
146:12 - & 1 are the same index position so p1
146:15 - was 0 the index position pichação is B 0
146:17 - a 0
146:19 - well a 0 is 1 and B 0 is 1 so they add
146:23 - each other so we're appending our
146:24 - results up here we're adding that value
146:26 - which is appending with the value of a2
146:29 - p1 it could have been B it doesn't make
146:31 - a difference again because they're equal
146:32 - to each other but now we want to move
146:33 - our counter from Indic resistance 0 to
146:35 - end of position one and same
146:36 - thank you both lists so our peas are
146:39 - gonna change now we're going to go
146:41 - through our list again and do they equal
146:44 - well now we have a three and a two they
146:45 - do not equal so it's going to go to our
146:47 - else--if it's the a is the value larger
146:49 - it is larger because in a it's three and
146:51 - then B it's two so what is it gonna do
146:54 - we're gonna go down to our else P we're
146:58 - gonna we have to increase our iterator
147:03 - so now we're running for the loop yet
147:05 - again now we're finding our we edit it
147:10 - ended for it appended for trying to see
147:13 - if we can see a list better because now
147:15 - an index position too
147:16 - we have a for an index position too we
147:20 - have a four involve list so they are
147:21 - equal to each other so we're going to
147:24 - increase the iteration of both our
147:26 - pointers we're gonna go through our list
147:28 - again and we're gonna find that it is
147:29 - not the next position is not sure now
147:31 - we're at a pi/3 and a p2 of four for our
147:34 - positioning so three and then four is
147:37 - because they're not going to equal each
147:38 - other so we're increasing our counters
147:43 - now to now match each other now they're
147:45 - back to four and four because we went
147:46 - through our else loop you're gonna see
147:51 - that third part of the loop come into
147:53 - play when we get to the number ten going
147:55 - through the same thing five four results
147:58 - they did equal they both equal nine
148:00 - position one was that five so that's
148:02 - zero one two three four five we had a
148:05 - nine and that's position for zero one
148:07 - two three four and B two so it did they
148:10 - did match up they were equal so it is
148:12 - going to append it now we're at six and
148:15 - six that's going to be a nine of ten so
148:19 - it's gonna return the result because
148:20 - we're outside of our while loop we no
148:22 - longer have our piece and if I bring our
148:25 - console up we have one for nine so took
148:28 - us out of the loop simply because when
148:29 - we got to the PS the piston is six we
148:32 - have one tooth will zero one two three
148:34 - four five so when the p1 and p2 the
148:36 - pointers became six that's outside of a
148:38 - range it's outside the array it's it's
148:40 - not permissible so it's going to take us
148:42 - completely out of the loop and then hit
148:43 - to the return the next executable code
148:44 - which is the return result all right
148:47 - this is a pretty simple exercise guys
148:50 - run through a play with it see what else
148:51 - you want to do change up the numbers
148:53 - mirror this is all about finding the
148:55 - common elements so do it with different
148:57 - sequence of numbers and do it in
148:59 - different orders and you'll see
149:00 - different aspects of the code as you
149:01 - debug it
149:05 - so the question write a function that's
149:07 - going to take three arguments three and
149:11 - in those three arguments one of them one
149:13 - of the arguments can be multiples but at
149:16 - least three first one of the arguments
149:17 - gonna be bombs what we have here we're
149:19 - gonna list the bomb locations this will
149:21 - be very similar to those who know the
149:23 - game minesweeper we're gonna take rows
149:25 - and columns so this is what it's going
149:27 - to look like minesweeper here we have to
149:31 - bomb locations this is going to be a row
149:33 - and a column row in a column is that
149:35 - that and then we have our matrix if you
149:41 - will a 3 by 4 matrix so we have our two
149:44 - bomb locations and our three by four
149:46 - matrix now the bomb at row index 0 first
149:51 - bomb this one this one give you its own
149:55 - location it's a 0 0 so row 0 column 0
149:58 - bomb at row index 0 column index 1 is
150:02 - the second bomb that's right here three
150:04 - rows three columns that's what this
150:06 - translates to and just so we can you
150:11 - know me I'm a visual guy let me just
150:14 - bring out the tablet real quick to give
150:16 - you an idea of what it is we're talking
150:18 - about so we just had zero our first bomb
150:24 - was zero zero and our second bomb is
150:27 - zero one so if we have this
150:37 - I'll do that and this is where our other
150:46 - parameters came in so we had our bomb
150:48 - locations right so that it's gonna be
150:53 - those two arrays and then we had 3 by 4
150:56 - so that's rows columns shell that means
151:00 - that we are rocking out in terms of the
151:04 - this is going to be the columns so we're
151:07 - 0 1 2 3 and we also correspondingly have
151:14 - our rows 0 1 2 so we can see we're
151:18 - indexing so we have 1 2 3 rows and we
151:20 - have 4 columns now just like we did with
151:23 - some of our other previous Python
151:24 - exercises we're creating a matrix if
151:27 - we're creating like a grid I want you to
151:28 - think of so the first bomb location and
151:31 - we're gonna identify bombs by negative 1
151:35 - when we're doing this code that's how
151:37 - we're numerically gonna modify them so 0
151:39 - 0 is row 0 column 0 so there's gonna be
151:41 - a bomb and row 0 column 1 there's gonna
151:45 - be another bomb so those are our two
151:46 - bomb locations you can change my however
151:49 - you want you know maybe for this
151:50 - exercise we'll do let's do this instead
151:53 - so then when we're doing part of our
151:56 - loop it will make more sense to you so
151:58 - I'm actually going to adjudicate this
152:02 - and instead we're gonna make our second
152:05 - bomb
152:05 - it's row 1 column 2 that's going to be
152:08 - our second bomb location so we're gonna
152:11 - have a bomb and a bomb and then we also
152:13 - have to numerically represent these
152:16 - other spaces here all right they're
152:19 - either gonna be a numerical value that's
152:23 - going to represent that it has a bomb
152:24 - how many bombs at us how many cells away
152:26 - so example this one has one bomb one
152:29 - cell away it has nothing else here if I
152:31 - had a matrix if I had a 3 by 3 1 2 3 4 5
152:37 - 6 7 3 by 3 & 9 square matrix and if I'm
152:40 - here in this cell here this number one I
152:42 - only have one bomb one cell away over
152:46 - here I would have I have two bombs at
152:48 - this moment I have this guy he
152:50 - because I'm looking at this 3 by 3
152:54 - matrix if you will to see adjacent cells
152:56 - so I got a bomb here and I got a bomb
152:58 - here so this would be a number two so
153:02 - this will be actually be fun to do so
153:04 - I'm actually going to change that to 1
153:06 - comma 2 when we get back into the code
153:11 - so like I said we're going to come back
153:13 - in and I said we're going to do Row 1
153:15 - column 2 for this example this is
153:18 - actually we're gonna run through our our
153:21 - example so this would not be accurate
153:22 - then that's gonna end up being here
153:29 - whoops that will not be accurate so
153:36 - we're actually gonna take this out for
153:37 - now so we're still going to return to 3
153:41 - by 4 array that's appropriate because we
153:44 - that's how we defined it here so this
153:46 - make a little more space and let's start
153:49 - this bad boy I'm gonna move the tablet
153:51 - for now but we will be coming back to it
153:54 - momentarily because there's some good
153:56 - examples that we can utilize it for them
153:58 - so first we're going to write out
154:02 - exactly how we defined our function and
154:04 - I said we're taking 3 arguments right so
154:08 - we're gonna be taking bombs that's gonna
154:11 - be our are that the first augment that
154:13 - were putting through then we're also
154:15 - calling and our number of rows and we're
154:18 - calling in you guessed it number of
154:20 - columns I'm gonna close off that
154:23 - function so we have at least three
154:24 - arguments but in the bomb argument we
154:26 - can have more than one row column
154:30 - combination so first we want to create a
154:32 - proportionately sized array filled with
154:34 - just zeros so we know we have in our
154:38 - example we want a three by four array
154:40 - and we want to be filled with zeros
154:42 - first off so we're just gonna call it
154:43 - field that's gonna be our variable that
154:46 - we're gonna create and it's gonna be a
154:48 - list so and we're gonna do 0 because
154:51 - that's what we want to fill it in for
154:53 - for I hope so Daisy 0 for I in what and
154:58 - range of
155:01 - one of the arguments that we have our
155:04 - number of columns right and then for
155:06 - those we want to put a zero for every I
155:08 - number college right now columns is four
155:09 - so we want to have zero zero and all the
155:12 - columns but then we also have to do that
155:14 - accordingly for it's only one bracket at
155:21 - that point for what for J in range
155:26 - realize what we're gonna do now here
155:28 - number of rows we have to have this set
155:30 - number the rows otherwise we're not
155:34 - going to be able to do more than one row
155:36 - just do the four columns that won't stop
155:37 - at that point so this is just saying
155:39 - we're putting a zero we're taking the
155:41 - range of the number of columns and we
155:42 - know we already know we're gonna have
155:43 - four four number of columns when I take
155:46 - that range of zero one two three and we
155:47 - want to put a zero in any of those
155:49 - categories and then for J and range a
155:52 - number of rows number of rows is three
155:54 - so that's going to be zero one two we
155:56 - also want to put a zero in so we're just
155:58 - doing this is a two different for loops
156:00 - and one line of code if you want to see
156:04 - what that's gonna look like we could
156:07 - even just and for argument's sake we're
156:12 - going to get this guy already ready so
156:19 - we're gonna have minesweeper we have our
156:20 - function I forgotten a mistake and then
156:25 - within that function we're putting in a
156:27 - list and then the first we're doing a
156:28 - list of list in the beginning so I said
156:30 - we were gonna do a zero zero for our
156:32 - first bomb correct and then in our
156:34 - second bomb we are doing one comma two
156:36 - for row column closing off that closing
156:40 - off the first argument comma and we said
156:42 - we want a 3 by 4 matrix all right so
156:45 - let's run this and see what we get so
156:48 - now perfect so we have this is our it's
156:53 - not as a list of lists here if you want
156:55 - to print it more like an umpire way
156:56 - that's a different story but we do have
156:58 - a three by four three column three rows
157:00 - rather one two three with four columns
157:04 - and they're all filled with zeros so we
157:06 - kind of go all right sweet we're on the
157:08 - right path here
157:09 - all right so I'm going to take that out
157:11 - just for now because we don't need that
157:12 - in our code so now we want to we want a
157:16 - for loop to take our BOM arguments and
157:17 - add them to the array that we just
157:18 - created so just created that array of
157:20 - zeros we want to get our BOM locations
157:22 - from the arguments that we have into
157:25 - those locations and we're gonna do that
157:26 - with a for loop so for bombs like
157:29 - jumpstart we're gonna do it as bomb
157:31 - location because that will make more
157:32 - sense when we debug everything and bombs
157:35 - so for bomb location and bombs what
157:38 - we're gonna have to say what bomb
157:39 - location is gonna mean right well we
157:41 - know that it's going to be the 0 0 0 and
157:44 - the 1 2 that we have so it's a row
157:45 - column right so what we're saying is BOM
157:48 - row this is kind of the orientation that
157:54 - we have our our raisin at the moment so
158:01 - we have our BOM row and our BOM column
158:04 - and what is that equal the bomb location
158:07 - so now right we're starting to get the
158:10 - for the format in place to what we
158:11 - needed now we want to update the field
158:13 - to show that the that this cell is a
158:15 - bomb right so how are we going to do
158:17 - that very simply we're gonna call field
158:19 - and what are we going to do in field
158:21 - we're gonna change some of its positions
158:24 - and we're gonna do that simply by BOM
158:28 - row that's gonna be our first index
158:31 - position and then you guessed it BOM
158:34 - column and what do we want it to be and
158:37 - we said we're gonna make it negative 1
158:38 - negative 1 is gonna be a location of a
158:40 - bomb within this three by four array
158:46 - that we created so just so you could see
158:48 - it let's go back to field we're gonna
158:51 - print the fields so now we have our BOM
158:54 - locations we said they were at 0 0 1 2
158:58 - so row 0 column 0 that's correct
159:01 - and row 1 column 2 0 1 2 that's correct
159:06 - so now we have negative ones where we
159:09 - wanted our bombs within our array all
159:12 - right so let's get rid of this all right
159:14 - so we're making good progress at this
159:16 - point now we want a way to select we
159:19 - need a way to select all the surrounding
159:20 - cells and I'm going to do this
159:22 - in a particular way with the idea of
159:24 - debugging in mind because if I wasn't
159:25 - debugging I would do this slightly
159:27 - differently but I want to do it this way
159:29 - because I want you to be able to see
159:30 - exactly what it is that I'm going to be
159:33 - messing with so we're gonna call this
159:35 - first one row range and what is row
159:39 - range going to equal well it's going to
159:41 - be the range of the bomb row minus one
159:45 - and you're going to see why we're doing
159:46 - this in a second bomb row and then we're
159:51 - gonna add plus two now this was so we
159:53 - could have a distance of three of the
159:56 - matrix that we were doing if you recall
159:58 - on this picture here when we were doing
160:01 - our imaginary matrix we wanted we want
160:04 - to take whatever location our row range
160:06 - is that at that moment we want to create
160:08 - a whatever row barbed or whatever so
160:12 - were at that point we want to be able to
160:13 - do a for loop that's going to go through
160:15 - the rows and the columns to check the
160:17 - numerical value of that cell and this is
160:21 - how we're gonna do it in a way where we
160:22 - can easily debug it so we're gonna do
160:24 - the same thing for column range and
160:28 - that's that's going to simply just be
160:30 - the range of what column same thing
160:34 - minus one plus two so that I'm looking
160:45 - at them like why is addison's I like
160:47 - that space as image of my numbers just
160:49 - makes it for me visually easier to read
160:51 - so now we have always selected our
160:53 - surrounding cells the surrounding cells
160:55 - from the position that we're currently
160:56 - at at that moment in time so now we're
160:58 - gonna do a for loop in the for loop so
161:00 - now we're already in our primary for
161:02 - bomb location and bombs loop and within
161:04 - that loop we are going to now for I in
161:08 - what well we want to first go through
161:10 - bro range right we're gonna go through
161:12 - our rows first and I'm just again for
161:15 - the sake of debugging
161:17 - Kurenai equals eyes so we can see it I
161:20 - just want to create a variable so that
161:21 - we can see this now another loop inside
161:23 - of a loop J is going to be tied to the
161:27 - column range and same thing I want to be
161:32 - able to see what that current J is going
161:34 - to be
161:35 - sorry just so we can see it as we're
161:39 - debugging that's the only reason I have
161:41 - those in now what we're doing is as we
161:45 - do this for loop so it's going to be for
161:48 - I and I so for row zero then we're gonna
161:52 - have to iterate the four for the columns
161:54 - zero zero zero one zero two zero three
161:57 - and then after we exit this column here
162:00 - then it's going to go back to the
162:02 - original for loop and do Row one and
162:05 - then inside that Row one iteration we're
162:07 - going to do column 0 so 1 0 1 1 1 2 1 3
162:10 - so we're iterating over the cells in a
162:13 - top-to-bottom right-to-left fashion and
162:16 - then well what the hell are we gonna do
162:19 - in those cells and again this when we
162:21 - debug it or I'm I'm gonna write this out
162:23 - on the tab because it'll make more sense
162:24 - for you what we want to do is we have I
162:28 - alright so first we're looking at I and
162:30 - we're also gonna be looking at Jane so
162:33 - what do I want to know I want to know if
162:35 - I is less than the number of rows not
162:42 - only that but I also want to know if I
162:45 - is greater than or equal to what 0 in
162:48 - this case it's gonna make more sense now
162:51 - as we debug everything so now this just
162:53 - says I when it does this if loop if I is
162:57 - greater than or equal to 0 and it's less
162:59 - than the number of rows so we have our
163:01 - first conditional statement there and
163:03 - it's gonna get really fun we have to do
163:06 - the same thing for who well for the
163:08 - columns and the columns are represented
163:10 - by J and then they have to be less than
163:13 - the number of columns so this is all
163:18 - we're I'm gonna have to do yeah that's
163:20 - gonna be fine I close it off go away and
163:26 - 0 do-do-do-do-do do-do-do-do-do
163:33 - James Lawson no columns are just making
163:36 - sure everything where I needed to be and
163:38 - if you're not if you have to follow the
163:40 - numbers and num columns is where it's up
163:42 - here in our arguments so now what are we
163:46 - doing in that if loop if we find that
163:47 - condition
163:48 - it's not just we're not just stopping
163:50 - there so we have if and end I actually
163:54 - didn't want to close that off just yet
163:55 - why I'm adding another end so what we're
163:59 - gonna be doing is we're gonna be finding
164:00 - if we're in the proper row column
164:02 - location and we want to make sure
164:04 - there's no bomb in there at that moment
164:05 - right so how are we gonna do that well
164:08 - we already know in our field where the
164:10 - bombs are so we want to make sure that
164:12 - the being the the field is not that the
164:18 - IJ that we're currently iterating
164:19 - through we want to make sure that it is
164:20 - not equal to a bomb that's where our
164:24 - negative ones gonna come into play
164:26 - so we're going to need a true and a true
164:28 - and a true in order to execute for the
164:31 - next loop and what are we gonna do if we
164:34 - did find this condition well we want to
164:37 - update that cell in the field and again
164:40 - we're at the IJ cell is what we're
164:42 - trying to do and we want a plus or minus
164:44 - one we want to up that index that's
164:46 - exact to do I'm missing yeah that's
164:53 - pretty now we just want to update that
164:56 - particular cell of the field and then
164:58 - when we're all said and done we want to
165:01 - return our field that we created make
165:07 - this a little tighter here so what we
165:10 - just did with that with that particular
165:11 - code we're gonna iterate through the row
165:13 - columns and we're saying if the row is
165:17 - greater than 0 so let's say I'm in here
165:20 - it's greater than or equal to 0 so that
165:22 - would be true and column is greater than
165:26 - 0 and less than the row calls which I'm
165:28 - the number of columns which is true
165:30 - because it's 0 and it's greater than 0
165:32 - greater than equal to 0 and it's less
165:34 - than 4 so we have a true and a true and
165:39 - the field I J which is 0 0 does not have
165:42 - a negative 1 this does have a negative 1
165:44 - so this would be a false and we jump out
165:46 - of that loop and go back into our for
165:47 - loop until we got to a true so this
165:50 - should become a true and then with this
165:53 - being a true would also say there's no
165:55 - bomb in here this cell the row is
165:57 - greater than 0 it's less than 3 the
165:59 - column is greater than 0 and it's less
166:01 - than 4
166:02 - we don't have a bomb in it the field I J
166:05 - which is field zero one does not have a
166:09 - negative one so then what we're going to
166:10 - do is we're telling it in this field
166:11 - update it's a plus one so that would
166:13 - simply then take this and make this a
166:16 - one which would tell the player at that
166:20 - point that they're from this cell
166:22 - there's one cell around here in this
166:26 - tube two by three matrix that has a bomb
166:29 - and of course it's right here and then
166:31 - as we go through the code and we get to
166:33 - here and here this wouldn't reality
166:36 - become a three because there's three
166:38 - bombs within this cellular matrix and
166:40 - again it's cellular matrix just to
166:43 - separate it would be here and
166:45 - theoretically would be up here but we
166:47 - don't have any cells up here so this
166:50 - particular cell has a bomb here we have
166:52 - a bomb here I'm sorry I thought this was
166:54 - also a negative one so I'll make it that
166:56 - way so then we would have three and this
166:57 - number telling us that three of its six
167:00 - cells have a bomb all right if you're
167:05 - not confused yet good let's debug
167:07 - alright so it looks like it's gonna run
167:10 - let me see what I get first off if I run
167:12 - it let's move my output is negative 1 2
167:16 - 1 1 1 2 negative 1 would be here that's
167:21 - why that's 2 because I have a one on one
167:23 - all right
167:25 - and then you have an adjacent bomb yes
167:27 - you do my third row 1 2 & 3 should all
167:31 - be ones they're all ones cuz there's a
167:33 - bomb all right cool so it's it looks it
167:35 - looks like it's appropriate so let's do
167:39 - our favorite thing let's run this debug
167:42 - I'm gonna f8 we're going to hit our
167:45 - print function and go back into our
167:47 - function and we have here our bomb class
167:50 - list which was just our input let me
167:54 - bring this down our field this is where
167:57 - we did the 0 for I and range for the
167:59 - number of columns and japheth and I'm
168:00 - arrangers creating our matrix filled
168:02 - with zeros so it did that appropriately
168:08 - now that's annoying I wanted to see that
168:11 - I wanted to bring just so you can see it
168:16 - here so we have our zero zero matrix
168:18 - there now for bomb location and bombs so
168:21 - we're gonna go bomb locations right now
168:23 - it's a list and we're at zero zero where
168:24 - did it get that zero zero up for bomb
168:26 - location it got it from our first
168:27 - argument our first argument here is
168:29 - bombs and we have to within that
168:30 - argument now we're just breaking down
168:32 - the bomb location that zero zero
168:34 - breaking it down into a bomb row and a
168:36 - bomb column so we're gonna get bomb row
168:38 - and bomb column do we have a zero zero
168:40 - that's appropriate now the field we want
168:42 - to update the field we want to tell our
168:43 - field hey we know where there's a bomb
168:44 - is a zero zero bomb right now our field
168:47 - as you can see up top here is simply
168:50 - just all zeros so we're gonna update it
168:54 - with a negative one meaning what again
168:57 - we're telling our field now where
169:00 - there's a bomb make it a negative one
169:01 - and you're gonna say well it didn't do
169:02 - it for one - well no because we haven't
169:03 - gone through that bomb location yet
169:05 - we're still going through the code for a
169:10 - bomb location and bomb that's true
169:11 - that's true that's true we're still
169:13 - within this four loop when we jump out
169:14 - of the for loop then it'll go and look
169:16 - for another bomb location so now we're
169:18 - just going to create a row range and I
169:20 - just want to quickly say before I even
169:21 - go through this I have for I in range
169:23 - this row range could be taken out and
169:25 - you could put this code in there and
169:27 - it's the same thing I pulled it out of
169:29 - that for loop cuz I want to actually see
169:31 - the varial produce in memory so that I
169:33 - have something I can visually track as
169:34 - I'm running the code so row range is
169:37 - simply the range from the bomb row
169:38 - negative 1 to the Brahma row plus 2 so
169:40 - we have a row range range negative 1 2
169:42 - and then we have our column range
169:44 - negative 1 2 totally that's appropriate
169:47 - cuz we're 0 0 at this point 0 minus 1 is
169:49 - negative 1 and 0 plus 2 is 2 for both of
169:52 - our row and our columns now I'm just
169:55 - gonna quickly jump over here for a
169:56 - second to show you what this is gonna be
169:57 - so we just did a range what are we going
169:59 - out negative 1/2 so that's appropriate
170:01 - so we're negative 1/2 I just want to run
170:02 - this show you what the outputs gonna be
170:05 - may bring this over so you can see the
170:07 - output actually no I can keep it like
170:09 - this and I can I didn't mean to do that
170:13 - let me bring it up to a float window so
170:16 - we have a 0 and a 1 why well because
170:19 - we're only printing out the eye for the
170:21 - ranges thereof
170:22 - one two two we're only getting two
170:24 - values within that so what happens if we
170:26 - make this a three for I in range zero
170:31 - one two three we're still getting a one
170:33 - two we made this a zero and that's not
170:42 - proper so I had to make this bigger
170:44 - because we were getting the wrong answer
170:45 - so if we were zero we'd go back where we
170:48 - were
170:48 - one day what was it originally I mean
170:51 - move you for a second negative 1 to
170:53 - negative 1/2 so if we run this we should
170:56 - get a negative 1 because okay perfect so
170:58 - we have a negative 1 and then we're
170:59 - going to numbers index is 0 and X is 1
171:02 - so it's negative 1 0 1 that's for the
171:04 - ion range of 1 2 if we increase this to
171:07 - say 5 we're gonna get the negative 1
171:09 - it's still going to count up to 4 which
171:11 - is going to be 5 numbers of the range 1
171:12 - 2 3 4 5 and conversely if we did it to
171:16 - negative 3 then we would have 3 to 1 so
171:19 - this is why we're not having a problem
171:20 - with calling cells that are outside of
171:24 - our actual matrix because right it's not
171:26 - gonna these negative numbers are gonna
171:28 - just simply equate to less than 0 so
171:31 - it's not going to be an issue all right
171:33 - so back to the code
171:34 - so I'm fading through for I in range and
171:38 - I just want to show you what that I is
171:41 - that's why I have that current I equals
171:42 - and current I that current I and the
171:44 - real range is negative 1 Y it will roll
171:46 - range the first I is gonna be negative 1
171:49 - that's appropriate for a J what you
171:51 - think we're gonna get you should get the
171:52 - same negative 1 so we've negative 1
171:54 - negative 1 so now as we go through this
171:56 - piece of code here this is exactly what
171:59 - gonna be looking at we're gonna have
172:00 - negative 1 I'm gonna do it one time on
172:01 - here and then you can do it for the
172:04 - future times if you like so let's clear
172:09 - this out let's whatever that's fine so
172:17 - we had negative 1 negative 1 corrects ya
172:20 - negative 1 negative 1 so if we're rockin
172:25 - ah
172:29 - OC days so we have I is negative 1
172:33 - and J is negative one all right so this
172:36 - is our row and our column piece that
172:40 - we're playing with so when if you if you
172:42 - follow this with a code what are we
172:43 - saying we're saying if if zero is less
172:48 - than or equal to negative 1 and negative
172:52 - 1 is less than the number of rows which
172:55 - was 3 well that's true is negative 1
172:58 - greater than equal to no so this is a
172:59 - false so right there that codes going to
173:02 - cut out so we can see what's going to
173:04 - happen is we're gonna run right down
173:05 - into the J and if when we try to run
173:08 - through this loop here it's not going to
173:09 - go so I'm going to f8 through there and
173:11 - we're gonna go back up why don't we go
173:13 - to I because we're still in the first
173:14 - row we still have 3 more values in the
173:16 - range to go through so now G is going to
173:18 - turn into 0 why again because we were
173:22 - negative 1 to 2 so it's gonna go 0 and
173:23 - then after that a guarantee it's gonna
173:24 - go 1 and then it will then will go to
173:26 - the next row so now we are negative 1 0
173:30 - let's see what's going to happen so if
173:32 - we're hanging out here at negative 1 0
173:36 - so let's do it a little just for fun all
173:39 - right so now we have an I is negative 1
173:42 - and J is 0 so is negative 1 greater than
173:48 - or equal to Z no I'm still at a false
173:50 - now it doesn't even matter what J is in
173:52 - either of these examples yet and our for
173:54 - loop we're still getting a false so
173:56 - we're not able to proceed within our
173:57 - code so I'm gonna be pulled out of that
173:59 - loop now go back into J and now J is
174:01 - gonna be a 1 so now I'm negative 1 1
174:03 - this is the last cell of the first row
174:06 - so now we're negative 1 1 and you should
174:09 - know the answer to this I'm not even
174:10 - gonna change the damn color cuz now if
174:12 - I'm I neg ative 1 and J 1 we did not
174:16 - matter what J is yet because we have not
174:18 - even gotten a true statement yet on our
174:20 - I because our I was in this case it was
174:26 - 3 the number of rows so we have not even
174:29 - gotten a true on this you know we're
174:30 - gonna true or I has to at least be 0 we
174:32 - haven't even gotten a 0 I so let's see
174:35 - what's gonna happen and it should go I
174:37 - fade through this back up to 4 i in row
174:40 - but jumped here and I thought there were
174:42 - no more in the range for column range I
174:44 - went to the I range which is appropriate
174:47 - so we're going to FA through there and
174:49 - the current is going to change the zero
174:50 - that's appropriate because we'll go
174:51 - negative one zero then one and that's
174:53 - gonna be our two values starting from
174:54 - the negative one so now we're at zero we
174:57 - have to f8 to change our column that's
174:59 - gonna be negative one
175:00 - all right so appropriate so now what's
175:02 - going to happen and you probably might
175:04 - have guessed it now we're 0 1 so we're
175:09 - going to let's clear this layer so now
175:17 - we have our I is 0 RJ is what Noah yeah
175:24 - zero negative 1 I was going to say I
175:26 - think that's wrong negative 1 so now our
175:30 - I and this is just how we're going
175:31 - through the code so now we're at 0 has
175:34 - to be greater than or equal to zero and
175:37 - has to be less than 3 so I have a true
175:39 - but then I have end negative 1 greater
175:45 - than equal to 0 I'm at a false right
175:46 - there so I'm already jumping out of that
175:48 - code
175:48 - so until J gets to a 0 I can't even go
175:53 - any further right so what you're going
175:55 - to see it should it better jump out of
175:57 - this good ah now we're talking now we
176:00 - have an I of 0 and a j of 0 so let's see
176:03 - what we get within this code all right
176:09 - so now we have an i of 0 we have a J of
176:14 - 0 so we have 0 is greater than or equal
176:16 - to 0 that's a true and it's less than 3
176:19 - sweet so we have a true and 0 is greater
176:24 - than or equal to 0 that's a true and
176:26 - it's less than 4 I have 2 truths but I'm
176:29 - not done I also have another end and the
176:34 - field for I J which is 0 0
176:39 - that's my row column right cannot equal
176:43 - negative 1 meaning it cannot have a bomb
176:45 - there well let's look at our field at 0
176:47 - 0 do we have a bomb so if we go to 0 0
176:55 - do we have a bomb row 0 first row column
176:59 - 0 negative 1 son of a
177:01 - we got a bomb so what just happened to
177:03 - our code but you should have somewhat
177:06 - presumed which is now we have a false so
177:11 - true and true and false equals false
177:15 - so we're jumping out of that code we're
177:17 - not able to come back into that code so
177:18 - now we've got to jump out f8 now we're
177:22 - gonna be at zero one and just for before
177:24 - we even get there let's quickly look at
177:26 - our field and look at zero one row 0
177:31 - column one it's a zero so we do not have
177:34 - a bomb in that location right awesome so
177:38 - let's see what this should do for the
177:39 - math so we have a zero one alright bring
177:43 - this like this let's clear out the level
177:50 - all right so now we have AI is 0 and J
177:55 - equals 1 I'm just I'm anal retentive I'm
177:58 - going to make sure it's right all right
177:59 - good so we write 0 and 1 so we saw up a
178:02 - form that we have
178:04 - I'm sorry 0 is greater than or equal to
178:07 - 0 that's true and it's less than 3 so I
178:10 - have a true for my first and 1 is
178:14 - greater than or equal to 0 that's true
178:15 - when it's less than 4 sweet and the
178:22 - field at 0 1 does not equal a bomb I got
178:31 - a true so now I got true true true so
178:34 - that all looks like boobs so then we can
178:36 - go to the next line of code and the next
178:38 - line of code that we're gonna have is
178:39 - gonna say we're gonna take our field at
178:42 - where do you think location 0 1 that's
178:46 - my I am I J and I want to do plus equals
178:51 - 1 so what's gonna happen now my row of
178:54 - rows I'm gonna have a bomb and then this
178:57 - should be a 1 right now it's a 0 but it
178:59 - should update to a 1 and then it should
179:01 - go all the way back and then run that
179:03 - code again so let's see how we're doing
179:07 - f8
179:09 - now good we got to line 30 that's our
179:11 - field IJ equals and then you can I'm
179:14 - gonna see if I can make it like this so
179:16 - we can watch here we have negative one
179:19 - this zero should turn to one on the next
179:20 - execution and the bastard jumped on us
179:25 - negative 1 1 there we go so we have our
179:28 - 1 so now we know that in this cell the
179:30 - representation represented cell of row 0
179:32 - column 1 that if you if you if you were
179:35 - to click this cell this I was exposed
179:36 - it's gonna say number 1 telling us that
179:38 - one of the adjacent cells
179:41 - we're not calculate above obviously go
179:43 - to row 0 has a bomb all right so that
179:46 - was successful now I'm not going to keep
179:49 - going through this for each location I
179:51 - just wanted to do that for observation
179:55 - for your ownself but now that you're
179:56 - gonna see we went through range negative
179:58 - 1 0 1 for column as we're done so now
180:02 - it's got to go to row number 2 which is
180:03 - index of 1 so when I FA through there
180:05 - it's gonna change now now it's gonna
180:07 - start going through this row we're going
180:14 - through that row at this point now so
180:17 - let's go and start going through 1
180:21 - negative 1 1 negative 1 1 0 up so far we
180:24 - can see based on that we're getting
180:26 - executing codes that we were able to
180:28 - adjudicate and we got another one in our
180:29 - list so I'm just gonna go through all of
180:31 - this now you can see bomb location it
180:33 - went through all the rest of the arrays
180:34 - bomb location is now gonna change
180:37 - because we ran through the 3 by 4 matrix
180:40 - for this location now we're going
180:43 - through the matrix for this second bomb
180:44 - location same exact thing we're gonna
180:48 - run through this for loop come on baby 1
180:53 - 3 2 3 2 1 2 2 2 2 take us out of a loop
181:00 - there's no more bomb location so for
181:02 - bomb location and bombs we're done so
181:04 - now we're gonna jump out of that final
181:05 - loop and be to return fields and if I f8
181:09 - through that
181:14 - we're gonna come out and we're gonna be
181:17 - given weight bring this up there we go
181:23 - so now we can see where we put our bomb
181:25 - locations in these are the negative ones
181:27 - and then the two the one the one the one
181:29 - the two the one the one the one 101 all
181:32 - those ones and twos were controlled by
181:34 - this for loop with what we were doing is
181:37 - in the whole point of the loop again we
181:39 - were trying to find where the bomb
181:40 - locations were so that if I expose this
181:42 - cell I know that I have two bombs that
181:46 - are nearby so if I brought this out I
181:48 - was trying to make this as visual as
181:50 - possible for you guys let me do this let
181:54 - me bring you up clear layer whatever
182:01 - I'll draw the I'll draw the matrix in
182:03 - this so we did a three
182:23 - all right so we have this and of course
182:25 - I'm not gonna draw up but you know we
182:27 - have our rows and I'll just do this I'll
182:30 - do row 0 Row 1 Row 2 column 0 column 1
182:38 - column 2 column 3 it's nice and bright
182:48 - so now what I want to do is let me get
182:50 - rid of this guy we are a negative 1 to 1
182:55 - 1 negative 1 to 1 1 we are one second I
183:14 - bring this where's my pen 1 2 negative 1
183:20 - 1 going backwards all right so this is
183:25 - what our matrix ended up filling out
183:26 - remember we start with all zeros and
183:28 - then after we started with all zeros
183:30 - then we put in our bombs with the
183:33 - negative 1 that was a simple just
183:36 - rearranging within our list of
183:38 - substituting new values from from our
183:41 - argument so now we had these guys in
183:43 - place and then we did our for loop and
183:45 - when the for loop was going through
183:47 - again we went 0
183:51 - it started at 0 and then 0 0 0 1 0 2 0 3
183:56 - and then it went Row 1 0 1 1 1 2 1 3 so
184:03 - that's how it was going through the
184:03 - cells and when it's going through the
184:05 - cells what it was doing was it was
184:07 - trying to find those and and then if we
184:09 - had all three combinations appropriate
184:11 - so in this particular one here remember
184:14 - it starting was started as a 0 and the
184:16 - first time we went through it we turns
184:18 - it into 1 because we got to a point
184:20 - where row 0 was greater than equal to 0
184:23 - in his lesson 3 and column 1 was greater
184:28 - than equal to 0 and it was less than 4
184:29 - we had true and true and there was no
184:32 - negative 1 in this in this in the cell
184:34 - that was true also
184:35 - so we upped it to
184:36 - it would change to a number one but that
184:38 - one happened when we went through this
184:41 - row we went through bro 1 and when we
184:43 - got to when we got to examining this
184:47 - particular cell cuz they're gonna win
184:49 - it's gonna iterate through the loops yet
184:50 - again this was going to end up getting
184:53 - changed to 2 simply because now it had
184:56 - this number right here is represented by
184:59 - this cell this cell this cell this cell
185:03 - in this cell so this particular cell in
185:06 - its neighbors it has two bombs this
185:10 - salad oil is one bomb and its neighbors
185:12 - who's doing pretty much for doing
185:14 - depending on the cell size cells 3x3
185:18 - because if this did not have one I'd be
185:20 - checking here here here here here and
185:23 - here here here and here but that's what
185:25 - the iteration on our for loop was doing
185:27 - and you may sit there and say how the
185:29 - hell I did have a student once asked me
185:32 - this how did ah let's make a little
185:35 - different how did if this was originally
185:40 - zero and we got to one like they
185:43 - understood that part they understand how
185:44 - we got to one but then when we got to
185:46 - this room we came and we got to this
185:48 - number here we got to this cell here how
185:51 - the hell did the code note it back to
185:53 - essentially space zero one and change it
185:57 - from a 1 to a 2 how denoted it well you
186:01 - have to remember when we first did this
186:03 - when we first did the first row zero row
186:05 - one row two
186:06 - this was not yet here it was only after
186:09 - we finished all 12 cells that then we
186:12 - went back up to the original for loop
186:14 - for bomb location and then bomb location
186:17 - then changed this cell to a negative one
186:20 - and then it goes again zero zero zero
186:23 - one zero two zero three and when it got
186:27 - to this location here when it was doing
186:30 - its check it found that it did have a
186:32 - bomb location it was gonna it did have
186:34 - an end and end and an end and an end and
186:36 - an end and it was oh it judicata self up
186:39 - to it - that's all that happened there
186:41 - if that it's not not clear to you let me
186:43 - know but that's how we got it
186:45 - essentially when we ran through this
186:46 - loop the first time then we came back up
186:49 - to bomb location in bomb
186:50 - and then it put in this second location
186:53 - of the second bomb then it went back
186:55 - through this four loop yet again to
186:58 - adjudicate what it was a one into now a
187:00 - two based on this parameter of the code
187:02 - here so pretty pretty involved granted
187:06 - I'll give you that but an excellent
187:08 - excellent excellent exercise not just in
187:11 - Python and for loops and nested loops
187:13 - and nested loops within nested loops but
187:16 - even in how you can do like I think this
187:19 - is a really fun piece of code here this
187:21 - this particular line right here I
187:23 - thought that was really good it's a
187:24 - great way to make it visual I think this
187:26 - was a great let me get rid of this guy I
187:28 - think this was a great piece here I like
187:30 - how he got to use one word argument
187:32 - bombs but we were able to pass a number
187:35 - of different a list of lists for that
187:38 - one argument so even though we have
187:40 - three arguments so it's taking one two
187:41 - three four different parameters if you
187:43 - would pretty cool then if you didn't put
187:46 - this as a list of lists then you should
187:49 - get an error yeah perfect so we're gonna
187:55 - get an error so that was good
187:57 - glad to see that that works that would
188:01 - be for you that's for you
188:04 - oh that's why I have to if I did this we
188:07 - should get a different error yep see it
188:11 - takes three positional organs but we
188:13 - gave four that's because we as far as we
188:15 - know we gave it one two three and four
188:17 - so we want to encapsulate this entire
188:20 - list of lists as one argument so then
188:23 - when we run it we'll get the appropriate
188:25 - output
188:30 - given an array what is the most
188:32 - frequently occurring element within that
188:34 - array so this is gonna be done in linear
188:37 - time so a Big O of n essentially what
188:40 - it's gonna do is create a empty
188:41 - dictionary to keep track of the
188:43 - occurrences and then we're gonna return
188:44 - the element with the largest maximum
188:46 - count so nothing nothing too monstrous
188:49 - today so we'll call it most frequent and
188:54 - what are we passing we're gonna pass
188:55 - through a list into this function of
188:58 - course we want to create our count my
189:00 - set that's going to be an empty
189:01 - dictionary all right so the empty
189:03 - dictionary we want to key value for the
189:05 - count and we're gonna set our max count
189:09 - we'll set it to zero for right now we're
189:11 - just initializing max count that's gonna
189:13 - keep track of the number of times each
189:14 - item has occurred and then we're gonna
189:17 - have a maximum item which as of right
189:19 - now it's gonna equal none because we
189:23 - don't have any the max item is just
189:24 - another variable it's gonna keep track
189:26 - as a counter in real time for the most
189:28 - frequently occurring item that we have
189:29 - this our thus far so for I and list was
189:35 - going to iterate through the list that
189:36 - we're given in the argument for the most
189:38 - function if the I is not an account well
189:42 - what we want to do if the i sorry before
189:50 - i not in count we we want to index we
189:54 - want an index item that has not been
189:55 - saved yet that's what that is for i've
189:57 - nine count it's not in count count right
189:58 - now is empty so it was not an account we
190:00 - want to do something with we want to
190:01 - index it we want to put that element and
190:04 - count and that element is gonna be i at
190:07 - that moment right we want to give it a
190:09 - count of one so we want to actually load
190:11 - whatever the element is if we if this if
190:13 - this list has an element two and if
190:15 - there's no two and count yet then we
190:17 - want to add two to this empty dictionary
190:19 - dictionary called count else
190:26 - jump down we're gonna throw our else in
190:29 - this means we have to see we also have
190:32 - numbers that we've seen before so if
190:33 - we've seen the number before what we
190:37 - want to do with count well we want to
190:39 - add to it right so now we have a way
190:42 - that we've seen the number before we can
190:44 - add one to its value in the dictionary
190:45 - key but what if not whatever but rather
190:50 - we also have to we're also going to have
190:54 - to make sure we have max count max item
190:56 - so now we have to go through our max
190:57 - count and max item and see if they need
190:59 - to be adjudicated as we go along so the
191:04 - so make sense if count of I is greater
191:08 - than maximum count this is comparing the
191:13 - value of the elements in the dictionary
191:15 - to the maximum count so whatever value
191:17 - in the dictionary we've built in this
191:19 - loop we're comparing it to the max count
191:21 - for that particular I all right nothin
191:25 - monumental there so if the max count of
191:29 - I is greater than max countable we want
191:31 - to update max count because it should be
191:35 - the maximum count right so we want it to
191:38 - be the count to that I so that it
191:40 - updates the maximum count we want the
191:42 - maximum counts reflect the maximum count
191:44 - for that particular key in the
191:46 - dictionary and then of course we also
191:48 - want to update if if it is so it's a new
191:53 - king of the max location so if max count
191:55 - is updated then that max item is also
191:59 - going to take the cake for right now so
192:03 - all of this is doing is just updating
192:06 - these two variables here as we go along
192:08 - iterating through our list and then
192:11 - simple is sweet we want to return what
192:17 - let the max
192:20 - whole point of this to get the maximum
192:21 - item right give it an array what is the
192:23 - most frequently occurring element we
192:25 - want to return the max item so no errors
192:28 - showing up yet
192:29 - we have call our gonna call our why are
192:41 - you oh my goodness I really should have
192:49 - my coffee fresh in then we're gonna open
192:55 - and close and I'm also going to open and
192:56 - close the function out just so we're
192:58 - consistent and now within this we're
193:00 - gonna be passing a list I'm going to put
193:01 - that list in so let's say we did on
193:05 - three three another three two one oh one
193:09 - one so we can tell that our we should
193:11 - get a 1 as our output but I wanted to
193:14 - have the 1 after the 3 because I don't
193:16 - want it to be numerically validated and
193:18 - you could also you should be able to do
193:20 - negative numbers in this as well so
193:29 - let's see we're gonna rock here so we
193:31 - have a 1 alright so that word alright so
193:33 - we can debug through this I'm just going
193:36 - to argument sake I'm gonna increase it
193:38 - to 3 and run it again and see if we get
193:43 - 3 okay cool so just close that out get
193:49 - rid of a 3 so we can keep it a 1 because
193:51 - I like the idea that it's value wise is
193:53 - less than a 3 and it's after 2 3 so make
193:55 - sure that we're actually iterating
193:57 - proper properly so let's debug through
194:00 - this bad boy not gonna need you we're
194:04 - gonna go down to our print get our list
194:06 - now we have our list in memory count as
194:08 - an empty dictionary in memory max counts
194:10 - a variable set to zero and dictionary
194:12 - max item is to none now we're gonna
194:15 - interact through the list so I is gonna
194:17 - be 1 because that's our first element in
194:19 - the list if I is not in count count
194:21 - right now is empty so it's not an
194:22 - account so that's gonna be true so we
194:24 - want to increase that to 1 so now it's
194:26 - gonna say 1 : 1 because
194:28 - the dictionary so now we have one we
194:30 - have one occurrence of the number one so
194:32 - far in our count we're going down if
194:34 - count is greater than max count with max
194:36 - count of zero so that's true so it's
194:38 - good should update the maximum count to
194:40 - one and the max item we're going to
194:42 - update to whatever is at that moment I
194:43 - write now is 1 so now we have our king
194:46 - of the hill is max item is 1 now we're
194:49 - gonna go through the next number so it
194:50 - should be 3 so when we go through 3 it's
194:52 - gonna add it to the list
194:53 - max counts greater than max count nope
194:55 - it's 1 so 3 as occurrence of one one has
194:58 - an occurrence of 1 so there was no
194:59 - update to have to be done now our I
195:02 - enlist now we're going to know we have
195:03 - the number 3 again so count was in there
195:07 - so now we're gonna hit the else loop so
195:08 - count just increase it by one so this
195:10 - three one should become three two when I
195:11 - go through this line excellent if count
195:14 - is greater than max count max count is
195:16 - one count of I right now is two so this
195:18 - max count I have max item here should
195:21 - change to three and the max count should
195:23 - change to two two and three excellent
195:27 - all we do is update the max count to do
195:29 - count of I in the max item to BI and
195:32 - we're just going to keep going through
195:33 - this we have three again now we have
195:35 - three threes so the max count was
195:37 - updated max item was already three now
195:40 - we are number two but number two which
195:43 - was it was never seen before so it
195:45 - created the key value of two one but it
195:48 - did not the max count at the right now
195:50 - is 3 so 1 is less than 3 so it didn't
195:52 - have to go through this code down below
195:54 - and we're just gonna keep going we're
195:56 - gonna get our ones now we have four ones
195:58 - so now max item right now is set to
196:00 - three max count is 4 because I won as
196:02 - the 4 so max count 3 should change to 1
196:05 - right now excellent so now that we're
196:07 - going through this let's see so we went
196:09 - through the whole for loop now we're
196:10 - just gonna return the max item and that
196:13 - would have been Z number one which we
196:18 - have over go to floating mode you just
196:21 - do that automatically which we have is
196:23 - the number one if we wanted to make
196:25 - these the negatives not going to make a
196:28 - difference because it's checking the
196:29 - occurrence of each particular element
196:31 - it's not checking the numerical value of
196:33 - it so you can see we have negative one
196:34 - as the return so
196:36 - a another quick function just to show us
196:40 - how we can utilize
196:42 - for loops iterations if loop else loop
196:44 - and just some creative some variables
196:47 - inside that will create a counter so
196:50 - you'll notice a lot of what we doing in
196:51 - a lot of our rate problems with creating
196:52 - counters or creating pointers to iterate
196:55 - through through arrays or couldn't
196:56 - counters in dictionary style so we have
196:58 - a key value count to go through this
197:01 - equally enough to find the least
197:02 - occurring element at a very similar
197:04 - fashion which we've done before so we
197:06 - have most frequently occurring element
197:07 - and we've done least as well
197:12 - and this one's going to be based on
197:13 - strings and I remember strings are gonna
197:15 - be different than arrays arrays are
197:17 - easily mutable strings are immutable
197:19 - characters so or rather elements so we
197:22 - have to do things a little bit
197:23 - differently so this question
197:25 - given a string or all the characters
197:27 - unique so we should give a true or false
197:29 - return first I'm going to show you how
197:32 - you could use this if you're just using
197:33 - by Python built-in structures and then
197:36 - I'll show you how we could create our
197:37 - own lookup function first off we're
197:40 - gonna define what unique is gonna be and
197:43 - what are we passing through nothing more
197:44 - than a string could even write string if
197:48 - you want um first thing I'm gonna do I'm
197:56 - gonna replace spaces so let me let me
197:59 - first show you what I'm gonna be passing
198:01 - through all right so when we're very
198:03 - done with it we're done with the whole
198:04 - thing I'm gonna be passing through the
198:08 - following string a space B space cdef so
198:17 - we're gonna be passing again if all the
198:19 - count of all the characters are unique
198:21 - but I had these spaces in here because I
198:23 - don't like when people just do like you
198:24 - know a abbc it's just it's not it's not
198:27 - reflective of what you do in real world
198:30 - real world they're gonna have spaces
198:31 - you're gonna have capital she's gonna
198:32 - blow up cases and it's a good idea to
198:34 - understand replace methods lower case
198:37 - methods and and so on and you're gonna
198:39 - see me use it a lot and a lot of the
198:42 - algorithms that we use so I just want to
198:45 - get rid of any spaces that are in there
198:46 - so to do that we're just gonna reassign
198:49 - what string is gonna mean and I'm just
198:52 - gonna tell it I want to replace it so
198:54 - we're gonna dart that replace method
198:55 - what I want to do well I want to tell it
198:57 - right now there might be spaces and I
199:00 - want to replace it with no spaces all
199:03 - right so that's what we're doing there
199:05 - we're just gonna fix that up so string
199:07 - is a little bit cleaner
199:07 - now I'm we're gonna the easiest way to
199:10 - do this using Python built-in structures
199:12 - with a set and remember set is an
199:15 - unordered collection of unique elements
199:18 - so it's giving us unique elements it's
199:20 - just not going to be ordered we don't
199:22 - care about order so therefore if we can
199:25 - create both of
199:26 - can create our string that is going to
199:28 - be in a set then it's very easy to see
199:31 - if comparing the length of but if it's
199:33 - going to be unique or not so all we have
199:36 - to do at this point is do a return what
199:38 - a returning I want to return the length
199:40 - of set string whoops-a-daisy so we're
199:48 - creating a set of the string and I want
199:50 - to know is it equal to the length of the
199:59 - string am i on unique I'm on unique let
200:10 - me drop this down to a floating window
200:14 - so it tells me true
200:16 - so remember whenever we're doing
200:18 - anything with with parentheses always
200:21 - work from the inside out so this is
200:24 - going to be dis operations gonna be done
200:25 - first it's gonna create a set of our
200:27 - string which the string is the input
200:30 - again remember the string we took we
200:31 - took out the spaces so I just do this
200:34 - let's debug it as we go through it nope
200:38 - I wanted to run debug yep I'm not gonna
200:45 - need anything else that's fine so it's
200:47 - gonna put our unique string into memory
200:49 - and we can see we still have our spaces
200:51 - or held intact I'm gonna get to this
200:53 - next link as we execute line number nine
200:55 - it's going to replace the spaces so you
200:57 - can see in memory now we no longer have
201:00 - spaces on our string so now we're taking
201:02 - take a set of this string this has
201:03 - already ordered it doesn't make a
201:04 - difference but asset is unordered so
201:07 - take a set from our string which is
201:09 - going to G it be exactly this only
201:10 - unique elements so we'll do repeats in
201:13 - just a second and then does that equal
201:15 - the length of the string well the length
201:17 - of the string is one two three four five
201:19 - six and how many unique elements are
201:21 - there going to be in this asset of the
201:22 - string is going to be six so it does the
201:24 - length of 6 equals six doesn't link
201:27 - that's to equal say yes it does it's
201:29 - true so it's gonna return true so we'll
201:31 - finish this to bugging in this so you
201:32 - can see that was gonna be a so let's um
201:34 - let's mess a fit let's put a non unique
201:37 - element in
201:38 - so now I get a false why and I say
201:44 - because the the B is redundant that's
201:46 - true but let's see what's going on in
201:47 - the code so we have our string Sharif
201:49 - going to take out the spaces so now if
201:52 - you wanted to see a length of the string
201:56 - is what 1 2 3 4 5 6 7 so that's equaling
202:01 - 7 right now the length of a set of that
202:06 - string remember set is an unordered
202:08 - collection of unique elements only well
202:10 - this was 7 for the length of the string
202:12 - how many unique elements do we have 1 2
202:14 - we're skipping that second because it's
202:15 - not unique 3 4 5 6 so does 6 equal 7
202:19 - false so that's it's a nice quick way
202:22 - you can use built-in Python structures
202:30 - for that operation now we're gonna do
202:33 - the same exact problem find the unique
202:35 - elements but without using Python
202:38 - built-in give me that without using
202:41 - Python built-in functions so the way
202:44 - we're gonna do this is the same thing in
202:45 - terms of defi unique we're gonna pass
202:48 - what's called s4 now it's easier to type
202:51 - we're gonna define the function unique
202:53 - it's gonna pass a string through it and
202:55 - just like before I want to replace the
203:00 - spaces with no spaces because again the
203:04 - inputs are gonna be I want to make this
203:06 - a little bit more real life I know what
203:08 - we're gonna do is we're gonna take our
203:09 - characters we're gonna make a variable
203:11 - characters characters within the element
203:14 - and we're gonna put them into a set now
203:18 - we need to iterate over this string to
203:20 - see what we're going to add in to
203:23 - remember we only want to add unique
203:25 - elements into this set and again yes it
203:28 - will be unordered so for letter NS
203:33 - subsidising we're gonna iterate through
203:36 - that string that we're putting through
203:37 - so again just so we have a mental idea
203:40 - of what we're doing
203:44 - and the string that I said will pass
203:47 - what did we do before we did a space B
203:52 - space C the EF so we'll pass our string
203:59 - which right now we know has all unique
204:02 - elements so it'd better be it better be
204:03 - true in terms of the return so for
204:06 - letter in s we're gonna do now that if
204:08 - if the letter in characters if it's
204:10 - going to return false or if it's going
204:12 - to return true so four letters in s is
204:15 - that is that in characters because
204:18 - remember characters is a set at this
204:20 - point and if it's not and we want to do
204:23 - something with that
204:24 - so if letter in characters right now
204:31 - it's an empty set nothing to we want to
204:34 - return false because if this is going
204:37 - through let's say we have this B being
204:39 - well as it goes through the code we're
204:41 - gonna do an append in a moment or added
204:42 - to the set imagine there was an A and
204:44 - there was a B when it gets to this
204:46 - second B if the letter is in characters
204:48 - B is well that's true then we wanted to
204:50 - return false because then it's not a
204:52 - unique pair of elements so we want to do
204:55 - that if it's not if there is nothing in
204:57 - characters that if that particular
204:59 - letter or element is not in our
205:01 - character set yet what we want to do
205:04 - well we want to add and what are we
205:08 - adding we're the letter because that's
205:10 - what we're iterating through it could
205:11 - have been I or you know a soar and
205:13 - whatever you wanted to put in to
205:16 - identify your iterator that's what you
205:17 - would have done there so characters not
205:19 - add letter so now if it does not exist
205:21 - within characters set we're going to be
205:22 - adding it and then when we're done with
205:24 - that loop when we're done with the
205:25 - iteration we're going to return true
205:28 - because if we did hit a repeat letter we
205:31 - are already are gonna be stopping here
205:33 - returning false if we do not hit me
205:35 - repeat letters then we will return true
205:37 - so let me see unique I got a false oh
205:46 - because I put a baby haha so we return
205:50 - to false if I take out that B
205:53 - we run it again I should get a true good
205:57 - let's take them out of sequential order
206:00 - you know alphabetical order rather let's
206:03 - do lkj re w so we know that this these
206:08 - are all unique characters so we got it
206:11 - true and if I replicate one of them I'll
206:15 - put a J over here and we should get a
206:18 - false awesome so let's just quickly run
206:21 - through a debug on this so we can say
206:26 - we're a thorough I fade through it and
206:28 - gets out of the way for a second so you
206:30 - can see in memory we put our string into
206:33 - memory we're gonna replace out the
206:34 - spaces so we just have a set string
206:36 - characters equals up empty set and so
206:38 - we're gonna have right now memory so for
206:39 - letter in s s is our string above up
206:42 - here for letter and character so we're
206:44 - gonna FA through so it's gonna take the
206:45 - first letter which is i if letter is in
206:48 - characters right now characters is empty
206:50 - return false but that was false so we're
206:53 - gonna skip that and jump down in the
206:54 - next piece otherwise characters dot add
206:56 - letters all right now letters I so we're
206:57 - gonna add what characters dial I so when
207:00 - I go through this it should add I
207:01 - wonderful and then it's gonna go through
207:04 - L if lettering characters is not in
207:06 - characters so we're gonna jump down to
207:07 - our else statement which is characters
207:09 - add so we're just adding these
207:10 - individual elements and let's get to a J
207:13 - and would go with the J and you will
207:16 - notice that or am I here I want to get
207:23 - to that second J so you can just see how
207:26 - up dammit I missed it
207:35 - there's J I remember again a set is an
207:38 - unordered pair so this we're running at
207:40 - this time it's a different order than it
207:41 - was before what are we now we're on e so
207:46 - the next letter is gonna be J so now
207:49 - we're on J but look at our character set
207:51 - we already have a J right here
207:52 - so if letter is in character set well
207:54 - that's gonna be true it is in character
207:55 - set already we're looking at J right now
207:57 - is it through this iteration and it
207:59 - isn't the character set so what are we
208:00 - going to do if this is true we're going
208:02 - to go the next part of that if loop
208:03 - which is going to be return false so
208:05 - return false is now going to be executed
208:08 - and sure enough in our output will be
208:12 - given a false because it is false and if
208:17 - we took that out did it end and then
208:26 - going through it same thing we're gonna
208:28 - have it replace it out it's just gonna
208:29 - run through the characters for each
208:30 - individual letter and it's never gonna
208:32 - find it's gonna always find that every
208:36 - letter is unique every element is unique
208:38 - it does not find it within the character
208:41 - set that we created so we'll end up
208:43 - returning true at the very end of it all
208:50 - non repeat elements so we're taking a
208:52 - string or gonna return characters that
208:54 - never repeat if there's multiple unique
208:57 - it's gonna return only the first unique
208:59 - and then after this is done I'm going to
209:00 - show you how you can return every single
209:03 - element that is not repeating this has
209:05 - huge implications in security so for
209:09 - those of you who are like well how am I
209:10 - ever gonna need this so what is it
209:12 - not only is this great practice for
209:14 - Python and for algorithm learning for
209:16 - interviews but this is also very
209:18 - applicable to data security so let's
209:22 - jump in and not to mention this is also
209:24 - linear time solution so what so we're
209:28 - gonna do a non-repeating that's we're
209:30 - gonna name our function today and all
209:32 - we're passing through that is a string
209:34 - now from the last video remember the
209:35 - first thing I'm gonna do with any string
209:37 - that I'm messing with is we're going to
209:39 - replace what spaces with no spaces and
209:44 - on top of that I want to make this all
209:47 - lowercase just otherwise if I didn't
209:51 - have it lowercase a capital A and a
209:52 - lowercase a are different elements so if
209:56 - I you would say you sit there and say oh
209:57 - my god it it didn't gave me back an a a
210:00 - big and a little a and you say those are
210:02 - not unique those are the same but
210:03 - they're not the same they are unique
210:04 - they have very different binary codes so
210:07 - they are unique so we're just gonna make
210:08 - everything lowercase for simplicity sake
210:10 - now how are we gonna even do this one
210:13 - we're gonna create a dictionary and
210:15 - again the dictionaries are our hash
210:16 - tables putting our language they're all
210:18 - gonna track the key value pair for each
210:21 - character in the string so we're just
210:23 - creating a count you know it's not very
210:25 - different from a lot of the stuff that
210:25 - we've done just done it a little bit of
210:27 - different way so we're gonna create a
210:29 - character count and again that was just
210:31 - gonna be at this point in empty
210:32 - dictionary all right now for character
210:35 - in s or for C NS we'll keep it nice and
210:39 - simple what do we want to do if the
210:42 - remember that you guys have seen this
210:43 - whole time if the character is in the
210:45 - character count then we can add 1 to it
210:48 - if it's not then we want to add 1 so
210:51 - what does that mean okay well we did for
210:53 - character in us if character is in
210:57 - character count if it's in character
211:01 - count then I want to take character cow
211:03 - and I want to add one to it for that
211:05 - particular element oh so I need to do I
211:08 - am say I almost made a boo-boo
211:10 - this is for that see only for that
211:12 - letter see I want to add for that that
211:14 - particular interval iment that we're
211:17 - using at that moment which in this case
211:18 - is C for character in C if C is in
211:20 - character count if it is then we want to
211:22 - for that particular C we want to add +1
211:24 - for that value and then of course we
211:28 - always have the well what if it ain't so
211:30 - then we're gonna have to do our else
211:32 - so if character is not in character
211:34 - count that what do I want to do I just
211:35 - want to simply take character count and
211:37 - for again for that particular say don't
211:40 - forget that part and we want to add it
211:42 - there we want to give it its first value
211:43 - of 1 now we're going to iterate again
211:46 - and then we're gonna we're going to do a
211:48 - second iteration to return the
211:50 - characters with only one count
211:52 - meaning the unique characters so how are
211:55 - we going to do that well still within
211:57 - this function or we're gonna back out
211:59 - cuz it's a whole separate for loop if
212:01 - you will for C NS so same thing there if
212:07 - character count for that particular C
212:10 - because again we're iterating so we're
212:11 - going one by one equals one if it equals
212:15 - one that means it's unique right so we
212:17 - want to return C come on otherwise if
212:23 - I'm gonna back out of this I'm gonna
212:24 - return none come on and stop that I want
212:31 - to return none otherwise if if if none
212:37 - of them are gonna equal one which means
212:38 - that there if there are no repeating
212:39 - elements within that particular string
212:42 - then damn it I wanted to tell me so so
212:46 - let's do this we named this non
212:49 - repeating there we go it's a string so
212:51 - I'm gonna put quotes inside that
212:52 - function string and we're gonna do I
212:56 - Apple eight peels now I did this on
213:01 - purpose so let's run it run non repeat
213:09 - again let's make this a floater
213:12 - and we go we got a floater and it
213:15 - returned I so is I the only one it's not
213:19 - repeated I is not repeated a is repeated
213:21 - Pease obviously repeated L repeated he
213:23 - is repeated there's no the unique so
213:25 - that is appropriate now
213:28 - just for argument's sake what if I did I
213:30 - want to prove a point if I do this and
213:34 - if I take this out later it will give me
213:39 - all of them see now first let's give me
213:40 - a capital I it's only returning the
213:42 - first one though but it would have also
213:43 - the reason for that is as it goes to
213:46 - this loop and it creates it counts for
213:47 - the dictionary when it goes through this
213:49 - and it gets to the letter I because
213:50 - that's the first one that that's that
213:52 - it's coming across if the character
213:54 - count equals one that one does so it's
213:56 - going to return C and it's gonna
213:57 - completely take me out of the loop at
213:59 - that point it's gonna stop going on but
214:01 - you're gonna see later how we would have
214:05 - to we would get multiple returns four
214:11 - unique elements and I'm gonna take the
214:12 - lower out just to show you what it's
214:14 - doing
214:14 - so let us um we'll debug it real quick
214:19 - you know I think the next one the
214:21 - debugging is gonna be a little bit more
214:22 - appropriate so let's let's debug it I
214:25 - don't need this
214:27 - so let's f8 our way through we're gonna
214:29 - put our string into memory I Apple a
214:31 - peels I start replace nothing new there
214:33 - it's going to lower case and it's gonna
214:35 - remove all the spaces character counts
214:37 - an empty dictionary so now for C in s so
214:43 - its first one's gonna be I foresee and
214:45 - character count character count is going
214:46 - to equal C it's not right now this C is
214:48 - I so I is not in the character count so
214:51 - it's gonna go down to my else else make
214:52 - it one so now we're gonna have an i and
214:54 - a comma 1 or colon one I'm sorry because
214:56 - its dictionary it's not a tuple so now
214:59 - for C and s now we're gonna go to a and
215:01 - its gonna do the same thing you're not
215:02 - in there so we're gonna go to the Alice
215:03 - we're gonna go to an a we're gonna go to
215:06 - P so the first time it's seeing P now
215:08 - we're going to pee again so again we're
215:09 - at the second P in the word Apple for
215:12 - character in character count it is right
215:14 - now P is right here and has a count of
215:16 - one so all I want to do is go to the
215:18 - next line of code because that was true
215:19 - character count of the index C at that
215:22 - moment which is P equals whatever P is
215:25 - right now 1 plus
215:26 - so it's going to change that to two so
215:28 - now this is how we're getting non-unique
215:30 - elements and as we go through this whole
215:32 - loop wait till we get to the L we have
215:38 - our L so next is going to be s s is not
215:41 - in there so it's going to add a
215:42 - character kind of s one excellent now
215:45 - we're going to jump into this for loop
215:46 - you're going to see that it's going to
215:47 - try to find a for C NS but all the seeds
215:48 - are done so we jump it up for loop now
215:50 - we're down below for C NS if character
215:52 - count equals one so we're going to FA
215:54 - through if character count equals one
215:56 - well the first C and s is I I equals one
216:01 - yeah that's going to give me a true it's
216:03 - going to go the next line of code
216:04 - returns C it's going to return that I
216:07 - and as far as the code is concerned it's
216:12 - done but we know that that is not true
216:16 - so there we go we have our I because we
216:19 - know that there could have been other
216:20 - letters that repeated and if it wasn't
216:23 - the first letter that was the unique
216:24 - element then if carrot when it got
216:26 - through this line here line 21 it would
216:28 - have went it would've went for 222 when
216:32 - we executed 22 would have skipped this
216:33 - and it would have returned not at that
216:35 - moment I'm sorry now I'm lying it
216:37 - wouldn't back to the for loop and it
216:38 - would have done the second C which at
216:40 - that point would have been the a and it
216:42 - would have been looking for them for the
216:44 - first time that character count equaled
216:46 - one character count being that
216:48 - dictionary we created for the key value
216:49 - pairs so what would we do to this get
216:53 - rid of that for a moment what would we
216:55 - do to this if we wanted to make this
216:58 - account for all of the non repeats well
217:04 - to do that we're gonna sit within the
217:06 - code that we've already started I'm just
217:07 - gonna bring some of this together so we
217:09 - a little bit more space on the screen so
217:12 - what would we need to change if we
217:15 - wanted to return not only the first
217:16 - element but any at all a total of the
217:19 - unique elements well let's go line by
217:21 - line so we can obviously keep this we
217:23 - can clearly keep this there's no change
217:25 - in their character counseling we have
217:26 - two dictionary we're still gonna be able
217:28 - to keep our first for loop let's
217:31 - actually do this
217:33 - so a little bit of separation visually
217:35 - we can still keep our first for loop
217:37 - there's no reason we have to make any
217:39 - change in that we're still creating a
217:40 - dictionary with the characters and the
217:42 - count for that but now it's going to get
217:44 - a little bit different so what we're
217:46 - going to do is we're actually going to
217:48 - get rid of this second for loop and what
217:52 - are we going to do instead well we're
217:53 - gonna create a list so to do that we
217:57 - want our final answer and it's gonna be
218:00 - at this point an empty list all right
218:02 - actually let's rename this let's call it
218:08 - all uniques so we're gonna make a list
218:12 - of all the unique elements that exist
218:14 - within the string that we're putting
218:19 - through so we have an empty list we want
218:22 - to sort our dictionary now so that the
218:24 - values control the order of the keys and
218:29 - we're gonna do this in an ascending
218:30 - fashion so a nice little quick way to do
218:33 - this is we're gonna create a variable Y
218:35 - you know just so we have something to
218:37 - plug this object orientation into we're
218:40 - gonna take a sorted so we have sorted
218:43 - and what are we sorting well our
218:44 - character count that we have from above
218:46 - and we're sorting it by the items that
218:50 - are within side of it now by doing this
218:53 - what we are that's not right that's
218:56 - better
218:56 - I'll lab them because I do want to add
218:59 - one more piece to this
219:00 - so we're sorting we're taking our
219:02 - dictionary that we've created and we're
219:04 - sorting it based off of the items that
219:05 - are within that that's going to put this
219:07 - in an a sending meaning that the lowest
219:10 - count to the highest count of the
219:12 - elements so we're already it's it's a
219:14 - it's sorting it for us now with
219:16 - something else we're going to be doing
219:17 - is we're going to add a key lambda key
219:24 - equals lambda and I'm gonna say at this
219:25 - point X and I'll get to this in just a
219:27 - second X 1 and of course
219:35 - so oh wait no I don't want to do an
219:38 - order versa now I wanted to show you
219:39 - that port later because right now I want
219:41 - a sending right yeah well we'll do a
219:43 - sending so lambda is it's something we
219:46 - haven't covered before and I'll cover it
219:48 - in another time but lambda is a way of
219:52 - almost like doing this whole defining of
219:54 - a function piece it's a function of
219:55 - itself and it's going to carry out
219:57 - whatever that function is that we're
219:59 - that we're specifying at that particular
220:02 - moment so all we're doing is we're
220:05 - saying we want the key to be that second
220:09 - position because the first position is
220:10 - the key the second position is the value
220:12 - we're looking for this x1 that we're
220:14 - going to be executing and so then then
220:17 - what we're going to do is we're going to
220:18 - compare the index 1 position of each
220:20 - tuple because again we have a list and
220:22 - if we have a key and a value that's
220:24 - going to be separated by a comma in a
220:26 - list not the dictionary where does it
220:27 - semicolon and then so then we have a
220:29 - tuple then it's exactly what we're going
220:31 - to have so if we did this just further
220:38 - so you can see it let's print Y so you
220:50 - can see now that we have Y is now it
220:53 - started out as an empty list and now
220:55 - it's it took exactly what we're going to
220:57 - have done here so based on this you can
220:58 - see that our we have two unique elements
221:00 - we have I and we have s which is true we
221:02 - have two unique elements last time we
221:04 - only returned the high because that
221:05 - alphabetically became first that came
221:06 - first in our sentence rather on our
221:08 - string but now this time we should be
221:10 - getting an i and an S because they both
221:11 - have a key value of 1 the lowest values
221:13 - so what it did was it sorted it took our
221:15 - character count or dictionary it's a
221:17 - character count by the items and then
221:18 - it's sorted that and it's sorted it well
221:21 - how we need to tell it we wanted to do
221:22 - by lambda we want to sort it by the not
221:24 - the first part but the second part which
221:27 - is this is 0 and this is 1 that's where
221:29 - this is coming into place so we want to
221:30 - take our entire list X take our entire
221:33 - list and we want to take that second
221:35 - index position as our as our key of how
221:39 - we're going to do the sorting and then I
221:41 - just want to print this to show you
221:42 - exactly what that I is going to look
221:44 - like an accord
221:46 - this nun here is just referring to the
221:48 - fact that we didn't print out our
221:49 - function because we did not finish it
221:51 - yet so we don't need this in the end so
221:54 - I'll take it out for now I just wanted
221:56 - to show you that so now what am I going
221:58 - to do so we have Y we have our tuples
222:02 - instead of a list so we're just going to
222:03 - do four items in Y right we want to
222:07 - iterate through this now what we want to
222:08 - do we want to compare the index position
222:09 - of each tuple so how do I do that well
222:12 - I'm just going to say if the item and I
222:14 - care about that position the second
222:15 - position if it equals that sequence it's
222:24 - getting that : then what I want to do we
222:27 - named it all unique we're going to
222:33 - append it with what the item and then of
222:40 - course we always have to give our good
222:41 - old we want to return all uniques I
222:48 - gotta put an S I didn't put the s there
222:50 - I apologize
222:50 - alright so now they're all the same so
222:52 - yeah when you're high like that get all
222:53 - three it shows me well those variables
222:55 - show up so I know they match
222:57 - all right sweets bring this down to spit
222:58 - so we see everything so what I did was
223:00 - we created another for loop iterating
223:02 - through it and we're saying for each
223:04 - item in Y and again this is how we
223:07 - separated them out if item in the that's
223:09 - the second position equals the same Y of
223:12 - the one position for the value aspect of
223:16 - that tuple then we want to append it
223:18 - into all uniques so let us actually now
223:22 - I'm sorry let's run first because we do
223:24 - actually have a print statement below
223:26 - and it gave me I and s and just for
223:31 - argument's sake I do want to show you if
223:33 - we take this out and if I make this a
223:36 - lowercase a and then we should get more
223:40 - because there's no other ease in there
223:42 - right yeah so yeah see that's what
223:44 - that's what I want to show you so now we
223:45 - have I got rid of the lowercase so now
223:47 - we have one unique upper I
223:49 - one unique lower a one unique upper a
223:51 - one unique upper P one unique lower s
223:55 - now it's kind of being a smartass
223:57 - because we both know that those are not
223:58 - unique elements hence the lower method
224:02 - that we're applying here so that we only
224:03 - get the real ones that are resulted only
224:06 - one time so let us do bug get out of
224:11 - here so I'm gonna run my debug on the
224:16 - non repeats excuse me and I'm gonna f8
224:20 - so it's gonna put I Apple eight peels
224:22 - into our string for the argument in the
224:25 - function and all we're doing here is
224:27 - replacing all of these spaces with no
224:29 - space and lower casing the entire string
224:31 - character counts empty dictionary
224:32 - nothing new there we already saw this
224:34 - loop before it's going to be the same
224:36 - exact function so let's go through this
224:41 - come on baby s awesome so now all
224:48 - uniques is an empty list so we have that
224:50 - in memory and then dude Richard y equals
224:55 - the sort of the character count by the
224:56 - items and how we doing that we're using
224:57 - a lambda which is the function of the
224:59 - self and we're telling exactly what let
225:01 - me get so as you can see that what we're
225:03 - left with we're left with exactly what
225:05 - we printed for Y before that same kind
225:07 - of a class list it's got with tuples so
225:10 - you can still think of it like a key
225:11 - value but it's not it's more of a in X
225:14 - position 0 index position 1 within each
225:16 - individual tuple that comprises the list
225:19 - so for item in Y well it's going to tell
225:21 - me what is item in Y well the first item
225:23 - is i1 so for item 1 while item is right
225:28 - here this is 0 this is 1 if it equals y
225:31 - of the first index position that second
225:34 - is position then all uniques dot append
225:39 - item so now you can see that was true
225:42 - and true so in all uniques are empty
225:44 - lists we appended it with the i1 because
225:46 - it equaled 1 now we're going to go f8
225:49 - second item is now s1 so we should also
225:52 - add that s1 so it's going to go to the
225:55 - next well why'd you freeze on me so now
226:02 - we have a and now a happens twice within
226:05 - the string so it does not equal that one
226:07 - position so it's not going to go to the
226:09 - lines
226:09 - 23 of the all unique so we're not
226:10 - appending our all uniques list same
226:13 - thing we have a 2 we have a 4 we have a
226:15 - 4 did not work be in the sense that we
226:18 - we didn't no longer hit a 1 in that
226:20 - second index position so we're returning
226:22 - all uniques non-repetitive
226:24 - so in our console we should be left with
226:28 - FA through that last list the only two
226:32 - elements that were non repeats
226:34 - throughout the entire string and the
226:36 - count which we know is going to be 1 in
226:38 - this case so I feel that this one is
226:40 - much more productive that this this
226:43 - particular code simply because of the
226:45 - fact that we were able to return all
226:48 - uniques all non repetitive x' within
226:51 - that string and that non repetitive is
226:54 - life ii based on the lowest lowest key
226:55 - value and again this has huge
226:57 - implications in data security and
227:01 - encryption so with that said guys have
227:04 - an excellent day and I will see you all
227:05 - at the next video