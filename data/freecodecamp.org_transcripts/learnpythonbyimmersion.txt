00:00 - welcome to the python by immersion
00:02 - tutorial here at pycon 2018
00:04 - uh thanks to everyone for coming i
00:07 - have been doing this tutorial in various
00:09 - formats in various places for almost a
00:12 - decade this is actually my 11th time
00:14 - teaching some kind of tutorial at pycon
00:18 - taught computer science at university
00:19 - for a while so i've got a fair amount of
00:20 - teaching experience
00:23 - in sort of scattered areas so
00:26 - hopefully this will work if it doesn't i
00:28 - certainly want to hear
00:29 - feedback on the survey link or just in
00:31 - person because it helps the tutorial get
00:34 - better
00:36 - so
00:38 - you're going to be drinking from a fire
00:40 - hose
00:41 - so i'm going to show you about 1100
00:43 - lines of code in under three hours and
00:46 - talk about a fairer number of them
00:48 - especially early on somewhat slowly and
00:50 - then we'll get faster
00:52 - don't please try not to get discouraged
00:54 - if you don't understand everything i go
00:56 - over i think you'll understand most of
00:57 - it but some stuff you won't and that's
00:59 - okay
01:00 - definitely do not try to memorize what
01:02 - i'm showing you right so the the title
01:04 - of the tutorial python by immersion uh
01:06 - is like learning a language by immersion
01:08 - right you don't start with well here's
01:11 - the grammar and hear the tenses of the
01:12 - verbs and hear the those kinds of things
01:15 - instead it's just like you just start
01:16 - listening and you start absorbing your
01:18 - brain starts absorbing in ways you don't
01:20 - even understand um and and that's my
01:23 - goal here so i'm going to show you a
01:24 - broad overview of the language
01:27 - and my hope is
01:29 - three weeks from now when you find
01:31 - yourself needing to do a particular
01:33 - thing in python you'll go
01:35 - you'll be able to say with some level of
01:37 - confidence but you're not sure why oh
01:39 - yeah i'm pretty sure i can do that in
01:40 - python pretty easily even if you don't
01:42 - remember what i showed you today
01:44 - somewhere in your brain will be the
01:46 - knowledge that you have a sense for what
01:47 - python's about and you have a sense for
01:49 - the kinds of stuff you can go looking
01:50 - for
01:50 - okay
01:52 - i'm going to start the la the first 20
01:55 - minutes about
01:56 - fairly slow and a little bit pedantic
01:58 - trying to explain certain things about
02:00 - python that are very different from many
02:02 - other programming languages especially a
02:04 - number of the ones that you are coming
02:05 - from
02:06 - and that all has to do with objects and
02:08 - names and variables
02:10 - um
02:13 - yeah so uh and the rhythm is that i will
02:17 - talk for a bit and then show you some
02:19 - code and then i'll give you time to work
02:20 - on some exercises during which time i'll
02:22 - wander around and if i answer questions
02:24 - when i'm wandering around i'll probably
02:25 - just answer them one-on-one and then
02:26 - summarize them at the end when i uh come
02:29 - back up here and we'll go through the
02:31 - same exercises you just did a little bit
02:32 - quicker and adding the explanations
02:34 - especially where people had questions
02:36 - feel free to stop me with questions
02:38 - raise your hand sometimes i'll say ask
02:40 - me later or i'll get to it later
02:42 - sometimes i'll answer it right then
02:44 - okay any questions before we get going
02:48 - okay
02:50 - so here's the uh form of this tutorial
02:52 - that
02:53 - this this is what most of us gonna be
02:55 - like i'm gonna
02:56 - show you lines of code and talk about
02:58 - what's going on
03:00 - first of all i'll tell you what version
03:01 - i happen to be running
03:02 - uh and then i'm going to talk about how
03:04 - objects get created in python and this
03:06 - would be kind of slow but it's really
03:08 - important to understand to get the right
03:09 - mental model of how this works
03:13 - so i'm going to talk about this line for
03:14 - about two minutes
03:16 - i'm going to type the number one and hit
03:18 - enter so this is the read eval print
03:19 - loop
03:20 - you can tell that by the three a little
03:22 - greater than signs of the chevron there
03:24 - at the read eval print loop when you
03:26 - type an expression python
03:29 - parses it
03:30 - compiles it into bytecode not into
03:32 - machine code but into bytecode it then
03:34 - executes it and if it's got a value if
03:36 - that expression has a value other than
03:38 - none it will display that value on
03:40 - standard output so it'll print the value
03:42 - of the expression
03:43 - okay
03:44 - so
03:47 - there it just did it it evaluated the
03:49 - the character which is the digit one
03:52 - and it figured out that that's an
03:53 - integer literal it's called because you
03:55 - literally are typing the integer into
03:57 - the prompt there and you can put all
03:58 - these lines in code too the only
04:00 - difference between
04:01 - the the read eval print loop the repl
04:03 - and uh what you what happens when you
04:06 - run your code is it doesn't
04:07 - automatically print out all the
04:08 - expressions the read eval print loop
04:10 - prints the one if you write a script or
04:12 - code it's not going to print the one
04:13 - unless you use the print function
04:17 - but what actually happens when i
04:19 - type the 3.14 in this example by the way
04:22 - the for numbers on the far right those
04:24 - are just line numbers to keep me on
04:25 - track and i can go back quickly
04:28 - so when python sees a literal like this
04:30 - this one's a floating point literal it
04:31 - creates
04:32 - an object
04:34 - which represents
04:36 - the literal so let's go back to the one
04:38 - there and just do that one because
04:40 - that's what i'm used to talking about so
04:41 - when i type the one and hit enter python
04:44 - goes off and it creates an object in
04:46 - memory uh an integer on most of your
04:48 - machines takes about 64 bits of memory
04:52 - about eight bytes the object that python
04:54 - creates is more like 30 or 40 bytes big
04:57 - it's huge by in computer terms relative
05:00 - to the amount of memory that's actually
05:01 - stored in the integer so you got this
05:02 - big object that has all sorts of
05:04 - information in it of which the one is a
05:06 - small piece the other stuff is what type
05:09 - it is what its super classes are what is
05:11 - documentation there's a whole bunch of
05:12 - stuff in there how many names are bound
05:14 - to it etc okay so every time you do that
05:17 - so this is in contrast to the way you're
05:19 - used to thinking about variables in
05:22 - python and any language most people
05:24 - think of variables as a box
05:26 - within memory location in memory and if
05:29 - i assign a variable the number three i
05:33 - write over the bits that are in that box
05:34 - with new bits and i get the three in
05:36 - there and if i
05:39 - say
05:40 - that variable equals 17 then i erase
05:42 - those bits and write over it with 17.
05:44 - that's not what's happening in python in
05:46 - python if i say i equals 1
05:48 - it creates an object and makes i refer
05:50 - to it if i say i equal 17 it creates a
05:52 - different object and makes i refer to
05:53 - that instead and i'll repeat that a few
05:55 - times in the next section as well but
05:57 - let's just look at how you create stuff
05:58 - in python so i can create integer
06:00 - literals floating point literals string
06:03 - literals with single quotes or double
06:05 - quotes
06:06 - round brackets or parentheses around a
06:09 - list of literals or a list of anything a
06:11 - sequence of anything gives me a tuple
06:14 - sometimes pronounced tuple
06:16 - and it's a an immutable
06:19 - list is the way a good way to think
06:20 - about it if you put square brackets
06:22 - instead of round brackets it's almost
06:24 - the same except it's mutable so one you
06:26 - can change easily one you can never
06:28 - change once you've created a tuple you
06:29 - can't pull things out you can't change
06:31 - elements in it a list you can change it
06:33 - all you want
06:34 - and there's some reasons for why there
06:36 - are both that aren't that important that
06:38 - i'm not going to really mention
06:40 - hang on a second
06:51 - oh sorry wrong code
06:53 - okay
06:55 - uh
06:56 - great all that work and now
07:00 - hold on a second here
07:09 - okay so when you create objects in
07:11 - python
07:13 - they have a single value
07:15 - a single type
07:17 - they have attributes they have one or
07:19 - more base classes if you understand what
07:21 - classes are it's not going to slow you
07:22 - down much today
07:24 - it has every object has a single id
07:26 - and every object has a name usually
07:30 - almost all objects have a name and many
07:32 - times objects have more than one name
07:34 - those names live in different name
07:35 - spaces so i might have two names in my
07:37 - current namespace and i'll explain what
07:38 - namespaces are soon you might have
07:41 - more than one name in the same namespace
07:42 - much more often you'll have names in
07:44 - different name spaces like you might
07:45 - import a module and then access an
07:48 - attribute of it
07:49 - and you might have names in multiple
07:50 - places
07:52 - so let's uh
07:54 - sorry
07:56 - i'll get the hang of this soon
07:59 - okay so let's
08:00 - explore this a little bit
08:02 - so what's going to happen here is about
08:04 - one of about 10 times i'm going to slow
08:06 - down and just say it the same way python
08:08 - sees the one
08:09 - it creates an object
08:11 - it sends that object it then looks up
08:13 - the name type and finds another object
08:15 - what happens to be a function a callable
08:17 - type is a class or function but it's
08:19 - callable like a function is
08:21 - it then takes that object and sends it
08:23 - off to that other object and
08:25 - executes it because it's got the round
08:27 - brackets it does a call it executes that
08:29 - function that function does something
08:31 - with it and returns a new object which
08:34 - is
08:36 - the class int the class of which one is
08:39 - an instance
08:41 - is its own object so classes are objects
08:44 - in python everything in python's an
08:45 - object uh and then it tries to represent
08:47 - that class well instead of you know
08:49 - right showing you the c code that
08:50 - implemented or the python code that
08:51 - implemented it it says well it's a class
08:53 - and it's got its name in it because it
08:55 - it's got it's trying to show you what it
08:56 - is but it's hard to show what it is
08:58 - because you can't type this back into
08:59 - the prompt and get the class in
09:02 - okay 3.14 type float
09:06 - uh
09:06 - there's string for a string str the type
09:10 - of that tuple is tuple
09:13 - there's the list objects have attributes
09:15 - so
09:17 - this looks up the name true finds an
09:18 - object and then tries to access dunder
09:21 - dock so this is a double underscore dock
09:24 - double underscore which we say instead
09:27 - of saying double underscore true double
09:28 - underscore we say our start doc we say
09:31 - dunderdock so if you hear me say
09:33 - dunderdock it means double underscore on
09:34 - both sides and those are attributes in
09:36 - python that are sort of behind the
09:37 - scenes you're welcome to use them
09:40 - but they're sort of more implementation
09:42 - side than user side
09:44 - and you can see that
09:46 - that has an attribute which is this long
09:48 - string that explains how doc works
09:51 - here's a string object and we ask access
09:54 - its upper attribute and we get back
09:56 - built in method upper blah blah blah so
09:59 - it's a method methods are like functions
10:02 - but instead of calling them with a
10:03 - parameters or arguments you call them on
10:06 - an object and pass extra arguments so a
10:08 - method is always a call made on or to an
10:11 - object so this method when you call it
10:15 - operates on that
10:17 - okay and when i say operates doesn't
10:18 - mean it actually necessarily changes it
10:20 - it might just return a new one or a
10:21 - different version or how big it is
10:23 - right
10:24 - so
10:25 - here i'm going to check is that string
10:27 - is the is this attribute
10:30 - of this object
10:31 - callable
10:33 - yes it is so i can call it like a
10:35 - function
10:36 - so i will call it like a function here i
10:37 - just access the attribute now i'm going
10:39 - to call it like a function
10:41 - and it's like i'm asking the spam object
10:44 - give me an uppercase version of yourself
10:46 - and so it returns a new object
10:48 - which is an uppercase string spam
10:51 - okay
10:53 - objects have base classes the inspect
10:55 - module is a good way to look at them
10:57 - so
10:59 - spam is an instance of string which is a
11:01 - subclass of object
11:04 - true
11:06 - is of type bool which is a subclass of
11:08 - in which is a subclass of object
11:11 - so if you're familiar with classes
11:12 - everything in python the superclass of
11:15 - all the objects in python is the type
11:18 - object which just has a few rudimentary
11:20 - things that it can do
11:22 - every object in python has an id
11:24 - the id of the object that gets created
11:26 - when python sees the three and
11:29 - creates that integer object that
11:31 - represents the three
11:33 - with some long number the only thing
11:35 - you're guaranteed is that number's
11:36 - unique across uh between like every
11:38 - object has unique id other than that you
11:40 - don't need to worry about what that
11:41 - means
11:42 - and so
11:43 - here
11:44 - in c python which is the version the
11:46 - implementation of python most people run
11:48 - it's written in c that's why it's called
11:49 - c python um it's actually a memory
11:51 - address which is kind of interesting
11:54 - but that's not guaranteed to always be
11:55 - true and it's not true in all
11:57 - implementations of python
11:59 - uh here's uh
12:01 - the other way to create objects so
12:03 - so far all i've done is
12:05 - is directly created objects with
12:07 - literals or called functions to get them
12:09 - back in general you usually call other
12:11 - objects to create objects or get access
12:13 - to objects so abs is a built-in function
12:16 - it is callable
12:18 - if i pass it this object
12:22 - i'm going to get back a different object
12:23 - in this case
12:25 - all right
12:27 - int is a built-in type 3 was an instance
12:30 - of int
12:32 - it's actually callable
12:34 - and
12:35 - every class is callable because when you
12:36 - instantiate a class you do it like a
12:38 - function call
12:39 - in this case it kind of functions uh it
12:42 - sort of feels like a function that when
12:44 - you call it converts whatever you pass
12:46 - it to an end
12:48 - like that
12:51 - okay
12:52 - so
12:53 - let's talk about names
12:56 - more carefully
12:57 - uh i just restarted my python to clear
12:59 - my namespace which makes things a little
13:01 - easier
13:02 - so there's built-ins
13:04 - which is a name that shows up in my
13:06 - namespace in this the way i'm running
13:08 - python here let me create a little
13:10 - function here that you don't need to
13:11 - worry about how that works
13:13 - uh
13:14 - when i say a equals 300 i'm going to add
13:17 - this name to my current namespace
13:20 - and i'm going to take that object that
13:22 - got created when the 300 was interpreted
13:25 - and make a a reference to it
13:27 - so
13:28 - if you want to say a is a variable
13:31 - and it holds the value 300
13:34 - it's it's
13:35 - mathematically that's good language in
13:37 - terms of computer programming it's a
13:39 - little bit misleading especially if you
13:41 - don't have the right mental model for
13:42 - how it works
13:44 - um and and even if you've only ever
13:46 - learned python you just people talk
13:49 - about variables this way they talk about
13:50 - the box into which you put values so i
13:53 - prefer
13:54 - at least when i'm teaching to use
13:56 - the language that's standard in the
13:58 - python documentation which is
14:00 - the name a is bound to the object 300.
14:03 - so this is a name binding and the name
14:05 - lives in a namespace okay once you've
14:08 - bound the name a to the 300
14:10 - then you can see in my namespace i
14:13 - didn't have anything before now i have a
14:14 - name a there's a representation of the
14:18 - the objects
14:19 - what it looks like and here's where it
14:21 - actually lives in memory it's id
14:24 - so
14:25 - now i can type a and hit enter and
14:27 - python says oh that looks like a string
14:30 - but it doesn't have the quotes around it
14:32 - but it's a valid identifier it starts
14:33 - with a letter uppercase or lowercase it
14:36 - has some number of letters uppercase or
14:38 - lowercase or maybe an underscore in it
14:41 - with no breaks that therefore that looks
14:43 - like an identifier i'm going to assume
14:44 - it's a name i'm going to look it up and
14:46 - try to find it
14:47 - if it does
14:48 - it gets the object back and tries to
14:50 - show it to you
14:51 - that's why you get the 300.
14:53 - okay this i'm not going to go this slow
14:55 - the whole time don't worry but thinking
14:57 - about it this way is really important so
14:58 - that's why i'm taking the time now
15:01 - right
15:02 - so uh
15:07 - i actually had a mistake here
15:09 - that i didn't notice
15:12 - which is i forgot to do this
15:15 - so i've restarted the interpreter
15:18 - the namespace was cleared
15:20 - if i type a now
15:21 - it's going to go look in the namespace
15:23 - because it looks like an identifier it's
15:24 - not going to find it
15:27 - really i thought i restarted the
15:28 - interpreter
15:33 - there we go
15:35 - now if i type a
15:36 - and hit enter
15:38 - i get a name error okay
15:40 - so
15:41 - uh if you type a name
15:43 - and it's not in the namespace it can't
15:45 - find it then it gives you an error well
15:47 - but how did it find abs and true well
15:49 - that's different
15:50 - those are sort of built-ins that are
15:52 - hiding behind the namespace um so this
15:54 - is there you get name error
15:56 - and when you see errors like this
15:58 - read them
15:59 - the first 10 of you like this is kind of
16:01 - complicated what does this all mean but
16:02 - once you get in the habit of reading
16:04 - errors they actually come in really
16:05 - handy sometimes often
16:07 - you'll find that if you read the error
16:09 - after reading 10 or 20 of them you get
16:10 - to the point where oh actually that does
16:11 - give me a clue to what i did wrong so in
16:13 - this case traceback
16:15 - if this were a
16:17 - function calling a function calling a
16:18 - function you'd have that whole call
16:20 - stack in the traceback in here it's a
16:21 - single line because i'm running at the
16:23 - interactive prompt the rebel
16:25 - and it's saying it's it and it was
16:27 - running this file well it's not a file
16:28 - it's the repel so it calls the file
16:29 - console it's at line one well obviously
16:32 - there was only one line
16:34 - and it wasn't in a module because i was
16:36 - just running at the rebel but then it
16:38 - gives the error so name error is the
16:40 - name of the exception
16:42 - it's this is a common name it's a common
16:44 - it's usually
16:45 - up a case lowercase camel case and its
16:47 - name error something error something
16:48 - here and then it tells you exactly what
16:50 - it was name a is not defined
16:52 - okay so a little diversion there about
16:54 - reading names
16:56 - okay so let's go back and do we got the
16:57 - a
16:58 - and there's the 300.
17:00 - okay so i've got that i can access it
17:03 - and what if i hit say type a equals 400.
17:07 - so what's going to happen is python
17:09 - sees the 400
17:11 - goes off and creates an integer object
17:13 - representing the integer 400 it then
17:17 - says okay i'm going to add this to the
17:18 - namespace well actually it's already in
17:20 - the namespace so it's just going to
17:21 - change the value so namespaces in python
17:23 - are like dictionaries dictionaries are
17:25 - mappings from keys to values and it's a
17:26 - common data structure in python that
17:28 - we'll explore later key value pairs so
17:31 - the key is a
17:32 - the value is 400. in a dictionary you
17:34 - have to name the dictionary use square
17:36 - brackets put a quote around the a close
17:38 - quotes square bracket
17:39 - uh names it sure does all that for you
17:41 - is another way to think about it it's
17:42 - like a dictionary that it doesn't you
17:45 - just type the the characters right away
17:47 - and it assumes you mean a key in that
17:48 - namespace dictionary okay so here it's
17:50 - just going to change the value that's
17:51 - already in the dictionary for the name a
17:54 - in the namespace
17:55 - right so we can see that namespace
17:58 - change the a is still there but
17:59 - different
18:00 - value different location
18:03 - so what this does is it looks up the
18:07 - name a gets back an object and then adds
18:09 - a new name to the namespace b which
18:11 - refers to that same object okay
18:15 - so it's not copying the value from a to
18:18 - b to b
18:19 - in the
18:20 - traditional variable computer science or
18:23 - computer programming sense it's just
18:24 - putting two names in the name space that
18:26 - point to the same object
18:28 - okay
18:30 - and if i look at b it says 400
18:33 - a's 400
18:34 - and you can see that they are at the
18:35 - same address so these are actually the
18:37 - same 400 because they're it's one object
18:40 - that represents the 400 two names the
18:42 - other way to think about names as being
18:44 - bound to objects is to think about
18:46 - post-its right so
18:49 - if i have a post-it and i write stuart
18:51 - on it put it right there
18:53 - that's a name for me a stuart if i write
18:55 - dad and put it on a post-it stick it on
18:58 - me or in some name space at home
19:01 - with my kids that name is the name for
19:03 - me
19:04 - right in a different name space someone
19:06 - else's
19:07 - family
19:09 - when you put the name
19:10 - uh mom on you you're gonna you know if
19:12 - you're a mother then your kids will
19:14 - understand that name but in our family
19:16 - it's like a different name space mom
19:18 - means a different thing it's bound to a
19:19 - different object okay
19:22 - um so think of postus on an a on an
19:25 - object and you can have multiple ones
19:27 - just like we have an a and a b here
19:29 - c equals 400
19:31 - oh okay so interesting now we have a and
19:34 - b
19:35 - they all have the same value these two
19:37 - actually are at the same address so we
19:38 - know those the same object
19:40 - this one's at a different address that's
19:43 - up to python whether or not it creates
19:45 - the integers at the same address are
19:46 - different and they're uh it actually
19:48 - pre-allocates some sometimes it'll it'll
19:50 - reuse an object sometimes it won't in
19:52 - the case of integers and strings it can
19:53 - reuse them because they're immutable you
19:55 - can't change the value of one it's
19:56 - always one
19:59 - so
20:01 - this is getting sort of uh so i'm going
20:04 - slow to explain names and namespaces and
20:06 - objects
20:07 - i'm also showing you some of these
20:08 - behind the scene details like where the
20:10 - memory is because just because that
20:11 - helps you understand what's going on at
20:12 - that level right so if you want to
20:14 - program well in python it helps to know
20:17 - a little bit about what's going on
20:19 - uh underneath the hood or behind the
20:21 - curtain
20:22 - uh if you want to know how to drive a
20:24 - car really well it helps to know a
20:25 - little bit about the engine works uh if
20:27 - you want to ride a bike earlier etc so
20:29 - so knowing that the next layer down a
20:31 - little bit of it is helpful i think so
20:34 - ida is one is the way you can get these
20:36 - addresses
20:38 - is
20:40 - is the way you check in python if two
20:43 - i'm going to say it wrong if two objects
20:45 - are the same well if two objects are the
20:47 - same they are the same object so what it
20:49 - really is checking is if the name a is
20:51 - bound to the same object as the name b
20:54 - are those two names
20:56 - the names for the same object that's
20:59 - what is means
21:00 - uh it does not mean really really equal
21:03 - right some languages you've got equal
21:05 - double equal triple equal
21:07 - that's not what it means and there are
21:09 - some uh edge cases where you'll actually
21:10 - get in trouble if you assume that is is
21:12 - the same as equal
21:13 - yes question
21:19 - uh yep i wonder if i do that next no i
21:21 - don't
21:23 - well now it's going to fail let me show
21:25 - you
21:30 - oh sorry it's gone uh the answer is yes
21:32 - it would it would uh
21:36 - sorry
21:39 - so asb
21:40 - was true it's now false because i went
21:42 - on and moved backwards
21:44 - and if you said a to c you would get the
21:47 - answer false
21:49 - so here i'm going to change
21:51 - the
21:53 - i'm going to change a to be abc
21:55 - you can talk like that remember what
21:56 - we're actually doing is we're creating a
21:58 - new object representing the string abc
22:00 - and binding a
22:02 - that was looking at the
22:04 - 400 on binding it to now refer to the
22:07 - string abc so i'm rebinding the name
22:10 - right so now if i look b is still 400
22:13 - show names shows me i've got a is bound
22:16 - to that b is bound to that c is bound to
22:19 - that these are two different objects
22:21 - usually you don't need to worry about
22:22 - this but when you do need to worry about
22:23 - it you really need to understand it and
22:25 - it really matters a lot in rare cases
22:27 - well
22:28 - relatively rare
22:30 - in some some of you are doing uh pandas
22:32 - for example um there are cases where
22:34 - whether or not the objects are the same
22:36 - object or if they're just equal makes a
22:38 - big difference in terms of performance
22:39 - sometimes you just want to use the same
22:41 - one again because to reallocate
22:44 - a data frame with millions of rows is
22:46 - going to be inefficient
22:49 - okay
22:50 - we're almost past the slow boring name
22:52 - stuff here uh
22:54 - del a
22:57 - what do you think that does
23:00 - it takes the post-it off and throws it
23:03 - away
23:04 - it doesn't take all the post-its off
23:06 - just the one that was the a it doesn't
23:08 - do anything with the object
23:10 - the object is not deleted when you
23:12 - call dell a
23:14 - right
23:16 - when is an object deleted well when all
23:18 - the names when all the post-its have
23:20 - been pulled off the object and there's
23:22 - no more references to it then there's no
23:24 - way you can it can be reached from any
23:25 - line of code then python goes and cleans
23:28 - it up and that's called garbage
23:29 - collection
23:30 - and that's very convenient for
23:32 - programmers to not worry have to worry
23:33 - about that
23:35 - and and uh in languages where you do
23:37 - have to worry about that
23:38 - uh memory leaks are always a problem
23:40 - unless you're very careful
23:42 - or there's a strong language support for
23:43 - it
23:44 - so now we've just got b and c left a is
23:47 - gone
23:48 - delby
23:50 - del c now it's empty nothing in the name
23:52 - space
23:54 - uh just
23:55 - i said uh there are cases where knowing
23:58 - when you mean equality and when you mean
23:59 - is basically the only time you want to
24:01 - use is
24:02 - in common practice is in a function when
24:04 - you're checking to see if a non-default
24:06 - parameter was passed or argument was
24:08 - passed and i'll show you that later and
24:10 - so you'll often see at the beginning of
24:11 - function if arg1 is none well that's the
24:14 - right thing to do otherwise you almost
24:15 - always want to use equality instead of
24:17 - is and here's
24:21 - proof
24:23 - okay
24:24 - that's interesting so i said i equal 10
24:27 - j equal 10 turns out that when python
24:30 - saw this 10
24:33 - it didn't go create a new object it went
24:35 - and found the one that already existed
24:37 - that represents the integer 10.
24:39 - and so you can see here i'm going to the
24:42 - comma here means please evaluate these
24:44 - both these expressions is actually an
24:46 - implied tuple um i'm saying are they
24:48 - equal are they the same name are they
24:51 - are they two names for the same object
24:52 - yes and yes
24:54 - and you can see they're at the same
24:55 - address
24:56 - however oh in here i equal j equals 500
24:59 - this is python syntax that says please
25:01 - bind both these names to that object at
25:04 - the same time or right after each other
25:06 - so it's actually here you're guaranteed
25:08 - that whatever
25:09 - j was bound to i is going to get bound
25:11 - to the same object
25:13 - and you can see that they're equal and
25:14 - they're the same object
25:16 - yeah
25:21 - but this one
25:24 - does not
25:25 - so in this case if i
25:27 - create a file if i say to python i want
25:30 - to use the integer 500 it goes and
25:32 - creates a new one
25:33 - and you say it again it goes and creates
25:34 - a different new one in a different
25:36 - location and so these are equal but they
25:39 - are not two names for the same object
25:41 - there are two names for two different
25:42 - objects and why it does it this way it's
25:44 - for efficiency reasons uh integers from
25:47 - about minus five to plus 256 are
25:49 - commonly used and so pre-allocating them
25:51 - saves um memory um whereas other
25:53 - integers aren't used that often so it
25:55 - doesn't pre-allocate them so that's
25:56 - behind the scenes what's going on the
25:58 - lesson here is use equals almost always
26:00 - when you want check for equality use is
26:02 - extremely rarely
26:05 - okay
26:08 - so import math
26:11 - what it does
26:13 - is it uh
26:15 - asks python to go find the library named
26:17 - math
26:18 - pull it into memory
26:20 - so that it can actually execute parts of
26:22 - it and then puts the name math in the
26:24 - current namespace so it bound the name
26:26 - math to that module now i can access the
26:28 - attribute of that object
26:30 - like math is not his name referring to
26:32 - an object it has an attribute called nan
26:35 - and if i get that back
26:37 - it shows me as nan uh some of you
26:39 - familiar with this it's not a number
26:40 - it's a representation of something
26:41 - that's not a number
26:42 - uh its type is float
26:48 - so here's a counter example that's kind
26:50 - of weird in this case
26:53 - they are the same object but they are
26:54 - not equal to each other
26:56 - right and that's just the weirdness of
26:58 - nan and it's useful to have that
27:01 - behavior so the nan object is not equal
27:03 - to itself but it's it is the same object
27:06 - okay
27:07 - just driving home the point here use
27:09 - equal equal
27:12 - okay
27:13 - so
27:15 - now i'm going to let you do some
27:16 - exercises
27:18 - uh i this section i can't remember
27:20 - exactly how long is i'll bring it up and
27:21 - see for myself um so i'll give you a few
27:24 - minutes to do the exercises when you do
27:25 - the exercises i encourage you to
27:28 - i've tried to make them easy to type so
27:29 - a lot of times i use short names and
27:31 - short stuff
27:32 - whenever possible i encourage you not
27:34 - just to type them and hit enter i
27:36 - encourage you to type it and then think
27:37 - about what's going to happen here right
27:39 - okay it says i you know for example it
27:42 - says uh
27:45 - okay
27:47 - like here when you when you type this
27:49 - into the interactive prompt type i
27:50 - before you enter figure out what's going
27:52 - to happen what is going to happen when
27:54 - you hit
27:54 - enter on this
27:57 - okay and if you can't figure that's okay
27:59 - go ahead and do it but but try to figure
28:01 - out ahead of time
28:03 - and i will wander around and answer
28:04 - questions and then we'll move on usually
28:06 - when about half the class has done the
28:08 - exercises i make them long enough and
28:10 - hard enough near the end that i try to
28:12 - keep everybody happily doing exercises
28:14 - but when you're about halfway through
28:16 - you've gotten as much as you really need
28:17 - to know to move on
28:19 - any questions
28:21 - okay
28:36 - so if you haven't gotten the exercises
28:38 - yet there second of the bottom line here
28:41 - http
28:44 - immersion
28:46 - uh
28:47 - or
28:48 - or it was you was emailed out to you
28:50 - about three hours ago as well um
28:52 - if you you'll bring up a dropbox screen
28:54 - that un shows three files you can
28:56 - download one of them or just click
28:57 - download and download the whole zip
29:46 - down
30:21 - you
30:41 - so
30:59 - um
31:23 - um
32:10 - yes
32:35 - um
32:44 - but you can't use locals when i use dirt
32:46 - the other form which is to pass it an
32:47 - object
32:54 - uh stop at the end of the exercises
32:56 - is that clear
32:57 - it's like uh
33:00 - let me just
33:09 - so when you get to the numbers
33:11 - we haven't talked with numbers you did a
33:12 - little bit with lists
33:22 - okay
33:26 - okay so
33:27 - how many people are done
33:29 - uh lots of people like you when you're
33:31 - half done and what happened you're done
33:32 - that's when i was in general i mean uh
33:35 - don't feel bad if you're not finishing
33:37 - especially when else this is normal like
33:38 - different people are here with different
33:40 - levels
33:41 - i usually will move on before everyone's
33:43 - finished at all
33:45 - learn what you can and you can go
33:47 - through some of the stuff again later
33:48 - watch the video again later et cetera
33:51 - okay so now i'm going to go through the
33:52 - exercises which means even those of you
33:55 - who didn't finish you're going to see me
33:56 - doing them uh and show you what uh new
33:59 - things there are to learn and answer
34:00 - questions you might have as you're going
34:03 - thank you
34:05 - so i'm gonna now go through the
34:07 - exercises uh that you just did and those
34:09 - of you who uh didn't finish you won't
34:11 - have to worry about not finishing
34:12 - because you're gonna see what i'm doing
34:14 - so
34:15 - i
34:16 - name error how many predicted that
34:18 - correctly
34:20 - that's pretty good more than half didn't
34:22 - and that's normal you know i'm making
34:23 - you think i'm i'm going to intentionally
34:25 - frustrate you a little bit to make you
34:27 - think and hope that doesn't go overboard
34:30 - because thinking about what the computer
34:32 - is going to do is is a really effective
34:34 - way especially when you're diagnosing a
34:36 - problem just look at the code and say
34:37 - okay what's python going to do in this
34:39 - situation it's a really effective way to
34:40 - find bugs and figure out why something's
34:42 - not doing what you think it should be
34:44 - doing because python can't read your
34:45 - mind
34:47 - so
34:48 - and you can see there is no i in the
34:50 - name space once i bound i to the object
34:53 - integer one then when i type i i don't
34:56 - get a name error i get the value back
34:58 - and you can see that the i got added to
35:00 - the namespace it's an ins
35:03 - now j and i are two names that are bound
35:06 - to the same object
35:08 - uh and and i i know that not because of
35:11 - the value but because j equals i it's
35:13 - going to bind j to the same object that
35:15 - eyes bound to
35:17 - so
35:19 - that's not
35:20 - implementation specific that's
35:21 - guaranteed by python and so they are
35:23 - going to be the same two names for the
35:25 - same object
35:27 - so this is a list we create here with
35:29 - two names
35:33 - and they those two names the object is
35:36 - the same so it looks the same
35:39 - you can see the m and the n names that
35:41 - got put into the namespace you didn't do
35:43 - either restart like i did so you'll
35:44 - probably have i in there as well and
35:46 - maybe some other names
35:48 - this is the syntax in python to
35:51 - access
35:52 - element at index one
35:54 - python lists and tuples start at index
35:57 - zero so the first element is called zero
35:59 - and that's not just to be frustrating
36:02 - that's because it actually reduces bugs
36:03 - um there's some interesting papers from
36:05 - many decades ago talking about
36:07 - zero-based indexing is better than one
36:08 - based indexing it makes a lot of
36:10 - calculations easier once you get used to
36:11 - it
36:13 - so what this does
36:14 - this is actually not a name assignment
36:17 - right so earlier i said
36:19 - you know m equals in the list
36:22 - that's assigning or binding the name n
36:24 - the name m and the name n to an object
36:27 - in this case this is actually a request
36:30 - to the object that m refers to to change
36:33 - index element one to be that object
36:35 - instead and i'm saying the request is
36:38 - like message passing the old metaphor
36:40 - for object-oriented programming with
36:41 - methods right so that's
36:43 - so this so this object tries to change
36:45 - itself the m object the object m refers
36:47 - to try to tries to change itself and say
36:49 - oh let me go find index one the second
36:51 - element and whatever was there get rid
36:53 - of it and put a b in its place oh sorry
36:55 - and whatever it was referring to at
36:57 - element one make it refer to something
36:59 - else instead right you know i'm sort of
37:01 - switching between the talking about
37:03 - variables colloquially and the way
37:05 - python's doing it
37:06 - and so now you look at m and you've got
37:08 - one b and three
37:10 - so
37:12 - if i ask
37:13 - if i asked the object
37:15 - that m is bound to to change l index one
37:19 - to b
37:20 - will n
37:21 - the name n
37:22 - the object it refers to will it also
37:24 - show up as changed the answer is yes
37:26 - because it's the same object
37:28 - so we asked the object we didn't ask the
37:30 - m or the n the object doesn't even know
37:32 - its name
37:33 - it just knows it's a list
37:34 - okay
37:37 - all right any questions on all that
37:40 - all right we're gonna go a little bit
37:41 - faster a little bit a little faster now
37:44 - okay so
37:46 - let's just explore numbers a little bit
37:49 - oh okay one minus yeah that doesn't
37:50 - really make one sense minus one means
37:52 - negative one so minus you can either
37:54 - subtract or say something is negative
37:56 - uh here's you get here's how you get a
37:57 - syntax error and it shows you the line
38:00 - that failed and it shows you where in
38:02 - the line it failed that's what that
38:03 - little hat or carrot means it says at
38:05 - that character is when i couldn't figure
38:06 - out what you meant
38:10 - that's reassuring actually that i can't
38:12 - assign to a literal i can't make the
38:14 - literal one have a different value it's
38:16 - always going to mean an integer one in
38:17 - python
38:19 - okay
38:20 - there's equality there's inequality the
38:22 - not equal
38:23 - used to have
38:24 - the other one less than greater than is
38:26 - a not equal that i think got removed in
38:28 - python three
38:29 - so it's always this one instead
38:31 - is one less than two yes
38:33 - is one less than or equal to one yes
38:36 - it's equal to one so it is less than or
38:38 - equal to one
38:39 - is one greater than two no
38:43 - we can do math that's pretty good one
38:46 - slash two in python three gives you 0.5
38:49 - that was a big change for python 2 fixed
38:51 - one of the problems with uh
38:52 - design problems from python
38:55 - that was
38:56 - figured out to be a design problem long
38:57 - after the fact
39:00 - this is floor division which basically
39:03 - does an integer divide
39:05 - rounds down okay this is a modular
39:07 - modulo operator or otherwise known as
39:10 - clock arithmetic right if it's uh how
39:12 - many times does three go into nine three
39:14 - and how many are left are well zero it
39:16 - divides evenly so there's the zero
39:18 - whereas if you divide that way you get
39:20 - one left over it's the remainder
39:23 - uh
39:24 - sorry double click there int
39:26 - is callable
39:28 - i can pass two to the int callable and
39:32 - get back
39:34 - the same thing
39:35 - if it takes a it'll take a float
39:38 - it'll take a float that's not equal to
39:40 - an integer and it'll truncate it
39:43 - it won't round it
39:47 - it'll convert from strings
39:49 - but
39:50 - it draws the line somewhere and says uh
39:52 - sorry that was a float you want me to
39:54 - convert that string that's a float to an
39:55 - end it's not a string int it's a string
39:57 - float and it stops there because you
40:00 - wouldn't want to do that one by mistake
40:02 - okay
40:03 - this error is kind of interesting value
40:04 - error so we've seen name error and
40:07 - syntax error well now we have value
40:08 - error invalid literal
40:11 - which is the string literal for int
40:13 - which is what we call with base 10.
40:16 - so it's
40:17 - maybe there's a clue there that you can
40:18 - actually use other bases
40:21 - and of course it's not going to
40:22 - magically figure out that you speak
40:24 - english and want to turn that into a
40:25 - number so
40:27 - it's trying it's pretty strict in terms
40:29 - of and narrow in terms of how it
40:30 - interprets it
40:32 - okay uh
40:34 - float two will convert from
40:36 - it to float they'll convert from strings
40:39 - including floating point numbers
40:42 - this will give us another error zero
40:44 - division error
40:46 - at what line
40:49 - can we add types that are different
40:51 - types
40:52 - sometimes floats and it's you can
40:56 - all right a equals one
40:58 - yep
41:00 - yeah we've seen that
41:02 - a plus one
41:04 - so look up the name hey in the namespace
41:08 - find the object it
41:09 - refers to or is bound to which is
41:11 - represented like that
41:13 - go find or create another object which
41:16 - represents the integer one
41:18 - add those two numbers together to create
41:20 - a new object which is going to be an
41:22 - integer 2
41:24 - and display it
41:26 - right so now what is a
41:28 - what is a bound to
41:32 - yeah it's still one i didn't change it
41:34 - right
41:36 - and now i can bind so
41:39 - it showed me the two and then it stopped
41:41 - using it didn't have a name
41:42 - anymore so if i want to give it a name i
41:44 - put the
41:45 - name binding in front that assignment
41:50 - here it is going to change what a is
41:52 - bound to right
41:54 - it's not going to change what's in the
41:56 - box a because that's not the way python
41:58 - does it but it's going to
41:59 - look up the one
42:00 - uh
42:02 - create another one add them together
42:04 - create a two and then bind a
42:06 - two so in this line it looked up a is
42:08 - one and now binds it to two
42:10 - okay so it's a change in that name space
42:13 - a plus equal one is lets us do that or
42:16 - something very similar to that all in
42:18 - one line and we get a3
42:21 - this operator is actually its own it's
42:22 - just it's not just syntactic sugar
42:27 - for this this actually tries to ask this
42:30 - object to change itself in place but
42:33 - integers can't change their value lists
42:35 - can by change their contents or what
42:38 - they refer to if it can't change itself
42:40 - then it falls back and does that so
42:42 - that's a little bit behind the scenes or
42:43 - a little bit more depth of what actually
42:45 - is going on
42:46 - uh this you'll see you may be familiar
42:48 - with from c plus plus doesn't exist in
42:50 - python that's a conscious choice
42:54 - okay
42:55 - these are pretty straightforward i think
42:56 - oh okay let's do some math so
42:58 - sine pi 2
43:02 - name error there is no sign name
43:05 - available to us in python we didn't put
43:07 - it in the namespace and it's not part of
43:08 - the built-ins there are about 50
43:10 - built-ins that you get for free that
43:12 - don't show up when you do a dur but they
43:14 - are accessible
43:15 - sign is not one of them
43:18 - right so
43:19 - it's not in this sort of hidden name
43:21 - space and it's not the ones i've created
43:23 - import math as i showed you before we'll
43:26 - add math as the name to the current
43:27 - namespace
43:29 - and
43:29 - make it a bind it to the math module
43:32 - which has a whole bunch of attributes
43:33 - including sine and pi
43:36 - so
43:37 - will this work now
43:40 - is the name sign defined in my namespace
43:43 - no only the name math got defined in a
43:45 - namespace
43:47 - right so there's the math that got added
43:49 - if i look at the attributes of that
43:51 - object
43:53 - there are lots of them
43:54 - including somewhere over there
43:56 - sign
43:58 - and wherever pi is there it is
44:01 - right
44:02 - so i can type this and it will work
44:05 - right and again what's going on here
44:08 - python looks up this object asks that
44:12 - object for this name and gets back the
44:14 - attribute which is a floating point
44:16 - object representing pi
44:18 - it goes and creates a floating point
44:20 - number representing two it does the
44:22 - division takes that object sends it off
44:24 - to whatever to look up here
44:27 - you get the idea
44:28 - right so we get the number
44:30 - you can do from math import sign by
44:33 - whatever you want
44:35 - and what that will do is it will go find
44:37 - this module which already was imported
44:38 - so it doesn't re-import it from the disk
44:40 - it just says oh i've already got i
44:41 - already know about that one
44:43 - because i did an import of it earlier
44:46 - and i'll go look inside it for those two
44:47 - objects and instead of putting math in
44:50 - the name space it puts sine and pi into
44:52 - the name space
44:54 - right so sine refers to math.sine
44:57 - now and pi refers to math.pi now i can
45:00 - just say sine pi over 2 and it works
45:02 - in general this syntax is uh not
45:06 - recommended when you're writing code
45:07 - that's going to live for a long time and
45:09 - lots of people are maintaining
45:10 - because it doesn't take very much effort
45:12 - to write that
45:14 - over that
45:16 - and then it's very clear to the reader
45:18 - exactly this is very clear to the reader
45:20 - what's going on oh you're talking about
45:21 - the sign from the math module not the
45:23 - sign from the numpy module something
45:24 - like that
45:30 - has to load the whole yes
45:33 - uh
45:34 - does
45:35 - this take a performance hit because it
45:37 - has to load the whole module
45:41 - uh no so when you load a module it loads
45:43 - the whole module
45:44 - unless the in a few cases the module is
45:46 - smart and will sort of auto load certain
45:48 - pieces but something like the math it
45:50 - just loads it in because it's fast to
45:51 - get it in um so it's pretty rare that
45:54 - you have really large complicated
45:56 - modules that
45:57 - incrementally load and when they do
45:59 - that's usually hidden from you
46:03 - help in is a built-in function you can
46:06 - pass it an object
46:07 - not a name it's python looks up
46:10 - this
46:11 - looks up this gets an object passes off
46:13 - to help and based on that object help
46:15 - says oh i'm going to tell you about that
46:17 - object
46:19 - and so
46:19 - [Music]
46:21 - if that's true how did help know to use
46:23 - the word math and the word sign well
46:25 - it's because the object itself
46:28 - knows its own name i told you objects
46:30 - don't know their names in a few cases
46:31 - they do modules classes
46:34 - functions when they are created
46:36 - the name is stuck in there or reference
46:38 - the name stuck in there so that the
46:40 - documentation works again more
46:43 - implementation detail than you need
46:44 - maybe but some of you so when i when i
46:46 - sort of do those little digressions like
46:47 - that if you don't get it don't worry
46:48 - about it we'll just keep going
46:50 - okay
46:51 - your turn to do a few exercises with
46:53 - numbers
47:51 - you
48:33 - you
49:34 - uh
50:39 - you
51:07 - you
51:49 - what do you think
52:11 - um
52:42 - come on
53:18 - okay
53:20 - let's uh move along so a number of you
53:23 - that you noticed in this set of
53:24 - exercises a couple things one is
53:27 - i introduced new things in the exercises
53:29 - and that was intentional
53:30 - all right i i
53:32 - i'm not going to do what knuth did and
53:34 - offer you
53:35 - double a dollar you know the first
53:37 - person who finds a bug i'll give you a
53:39 - dollar the second person i'll give you
53:40 - two four
53:41 - but i'm almost positive there are no
53:43 - errors left in the exercises um
53:45 - they're all intentional so when you get
53:47 - an error it's because i wanted you to
53:48 - get the error and look at it and think
53:49 - about it when you see an r in front of a
53:51 - string i want you to think what is that
53:52 - can i figure out what it is just by
53:53 - looking at the code and then i'll
53:55 - explain it in the exercises
53:57 - so so uh
53:59 - so yes get a little bit frustrated
54:01 - enough to make you think harder but if
54:03 - it really bugs you in you know if you're
54:05 - gonna hate me for it well tell me
54:06 - afterwards and i'll clean it up because
54:07 - i don't want to be too frustrating
54:13 - camera what else i think that was the
54:14 - only thing i noticed in terms of the
54:16 - questions that were coming around but
54:18 - let's uh look at these so create an
54:20 - integer add
54:22 - yep so we can do equals
54:26 - 1 plus 2 less than 3. so is this going
54:29 - to say is 3 less than 3 or is 1 plus 2
54:31 - less than 3 well the answer is going to
54:33 - do 1 plus 2 less than 3. there's a
54:35 - notion of operator precedence the python
54:37 - documentation documentation sells you
54:39 - what comes first which is binds
54:42 - more tightly than others
54:43 - i'm not going to explain all that now
54:45 - you can look it up or you can put
54:46 - parentheses around stuff when it's not
54:47 - clear if it's not clear to you good
54:49 - chance it won't be clear to other people
54:50 - so it doesn't hurt too much to put in
54:52 - extra parentheses it makes your code a
54:54 - little bit unreadable for a little bit
54:56 - less readable for people who already
54:57 - know it once you get to know it
54:59 - so you should try to learn some of them
55:00 - but don't worry about learning all of
55:01 - them
55:04 - this is one things i didn't tell you
55:05 - about but you can in python you can say
55:07 - is one less than two and two less than
55:09 - three all in one line all in one
55:10 - expression which is kind of convenient
55:13 - is two less than one and one less than
55:15 - three well no because two is not less
55:16 - than one uh all the boolean operators
55:20 - like and and or in python are short
55:22 - circuit meanings it won't evaluate them
55:24 - all it'll evaluate till it knows the
55:26 - answer's
55:27 - false and it'll stop unless it's an or
55:29 - then it keeps going
55:31 - um
55:32 - 3
55:33 - star star 3 means 3 raised to the third
55:36 - power
55:39 - round 1.0 and 1 is going to round
55:42 - up
55:43 - or down depending on if it's
55:45 - 50.
55:46 - one person noticed that round of 2.50
55:49 - goes to two instead of three that's
55:52 - because uh computers don't store
55:54 - floating point numbers the way we look
55:56 - at them it's they store them with base
55:58 - two using a ieee
56:01 - 754 i think or 854 is the standard
56:04 - that's the standard that all computer
56:06 - hardware uses so it's predictable what
56:08 - it's going to use um but it can't store
56:11 - arbitrary precision so there are some
56:12 - rounding errors that will happen that's
56:14 - one of the reasons why people talk about
56:16 - dusty decks these algorithms were
56:19 - written back when people wrote using
56:20 - card decks and
56:22 - once the experts math experts who do
56:25 - numerical analysis figure out how to
56:27 - write that algorithm so it doesn't drift
56:29 - one way or the other with these little
56:30 - tiny rounding errors then they don't
56:32 - want to touch it because to get that
56:33 - provably right is really hard
56:35 - so when you import python libraries
56:38 - especially from scipy you're
56:39 - occasionally importing fortran
56:41 - code for
56:42 - example stuff that's been around a long
56:44 - time and is tested and true
56:46 - it's easier to upgrade the compilers
56:49 - for modern architectures than it is to
56:51 - rewrite code
56:52 - cheaper easier safer
56:54 - okay so uh
57:01 - around that so here you notice that
57:04 - here's an example where i have round
57:05 - takes an argument well actually now i
57:07 - can give it two so python has this great
57:09 - feature which is optional arguments
57:12 - round you have to pass it at least one
57:13 - argument but you can pass it a second
57:16 - argument
57:17 - and in this case if you look at the
57:19 - documentation for round it'll tell you
57:20 - what that second argument does and it
57:22 - basically says how many decimal points
57:24 - after the decimal
57:26 - but what if you put in a negative number
57:28 - you'd think that might give you an error
57:29 - but someone thought well yeah it's
57:30 - obviously an error you if you but
57:32 - there's a nice feature we could add
57:34 - which is
57:35 - how far to move the decimal point the
57:37 - other direction
57:38 - so you can round that way as well and
57:40 - there are a bunch of sort of
57:42 - easter egg-ish kind of features in
57:43 - python like that where once you know
57:45 - they're like oh that's really handy um
57:48 - okay
57:49 - advanced exercises again all of the
57:51 - exercises are start easy and get harder
57:53 - so by the time you get to the end of
57:55 - them hopefully you're thinking really
57:56 - hard and most of you won't get that far
58:00 - but here type callable
58:04 - help callable okay this tells you a
58:05 - little bit more about what the callable
58:07 - function does
58:11 - yeah yeah
58:14 - all pretty straightforward here i don't
58:16 - think there's much i want to talk about
58:18 - because there's more interesting stuff
58:19 - we'll keep going to
58:21 - uh here's here's where i i said okay
58:24 - end with base 10 so what about that also
58:27 - base 10 but i can do this
58:30 - so a second argument to int is the base
58:33 - so c in base 16 hexadecimal is 12 in
58:37 - decimal
58:40 - any questions
58:43 - okay
58:45 - yep
58:48 - so the help callable uh he noticed that
58:51 - the
58:54 - second argument was slash
58:57 - so that means no more required arguments
59:00 - after that
59:01 - and that's a fairly new feature in
59:03 - python that shows up with that slash
59:04 - that's a documentation it's not actually
59:06 - a
59:07 - um
59:08 - it's not the name of the second argument
59:10 - because you can't have a the name of an
59:12 - argument if you name it you can actually
59:14 - pass names i'll show you that later uh
59:16 - has to be a valid identifier anyway
59:19 - okay so strings
59:21 - here's a string
59:23 - same string
59:25 - right so you can use single quotes or
59:26 - double quotes whichever you prefer
59:29 - some people prefer double quotes because
59:31 - they're more like c some people prefer
59:33 - single quotes because they're slightly
59:34 - easier to type and they are python's
59:36 - canonical representation you see that
59:38 - you here we entered a string literal
59:40 - when it shows us a string literally it
59:42 - will use single quotes
59:43 - when it can
59:45 - well what i mean when it can well
59:48 - okay
59:49 - i want to put a single quote in that
59:50 - string how do i do it i can't do it that
59:52 - way because it gets to the
59:54 - there defines the string and then it
59:55 - sees this s all by itself and then a
59:57 - dangling
59:58 - unmatched single quote at the end
60:00 - um so i could either put a backslash in
60:02 - front of it which escapes it's called
60:04 - escapes the quote
60:06 - right so python when it sees the quote
60:08 - it says ah you're starting a string
60:11 - and it remembers that and then it starts
60:12 - adding characters to the string so t is
60:14 - the first character the string not the
60:16 - quote
60:17 - when it gets to a backslash it says oh
60:19 - whatever comes next i'm not going to do
60:21 - what i usually do which in this case is
60:23 - end the string instead i'm going to
60:25 - actually
60:26 - add that character
60:27 - to the string
60:29 - and then it keeps going when it gets to
60:30 - this one which is not escaped with the
60:32 - backslash it says okay that's the end of
60:33 - the string because i was looking for i
60:36 - got a quote and this is the second one
60:37 - therefore
60:38 - it is the two ends of the string
60:40 - okay so you can do that notice what
60:42 - python does it gives it back to you in
60:45 - the way it its best effort at
60:47 - representing the string it puts double
60:49 - quotes around it in a single quote in
60:50 - the middle which is a lot easier to read
60:52 - so that's one of the reasons why
60:54 - you can use double or single as it makes
60:56 - it easier to write
60:57 - things
60:58 - with quotes inside them like this
61:01 - like this
61:02 - how about two lines no
61:04 - it doesn't work
61:06 - but that does so if you use triple
61:08 - quotes single apostrophe or quote marks
61:11 - you can have multiple lines
61:13 - uh newline characters in the strings you
61:15 - hit enter
61:16 - and this is whether you're in in python
61:18 - code or at the interactive prompt uh now
61:21 - in python code if you're doing it inside
61:22 - a function and it's indented then all
61:24 - those spaces that are indenting it are
61:26 - going to be part of the string
61:30 - okay here i want to put
61:32 - triple quote
61:33 - around triple quotes so i want a single
61:35 - quote there and a pair of double quotes
61:37 - there it doesn't know what to do right
61:39 - so it's got the four quotes in a row and
61:40 - it got confused it's one of those ed's
61:42 - cases where in theory
61:44 - the people who maintain python and are
61:45 - extend improving it could go make that
61:48 - work but is it worth it there's other
61:49 - ways to do it so it just gives you an
61:51 - error and keeps the language
61:53 - faster and
61:55 - easier to maintain being less code this
61:57 - will work
61:59 - here's the other way to put new lines in
62:00 - of course up here we put a new line in
62:02 - by hitting enter on the space there
62:05 - that's because at the interactive prompt
62:07 - it always puts in a space as part of
62:09 - interacting with you typing
62:14 - in
62:16 - is an operator in python operators
62:18 - aren't just pluses and minuses and
62:20 - slashes they're words sometimes too like
62:22 - the in operator
62:23 - so is the string el
62:26 - in the string hello so is it a substring
62:30 - not in
62:32 - is also an operator those of you who are
62:34 - familiar with other programming
62:35 - languages you might find it funny that
62:36 - this not isn't over here it's because
62:39 - not in two words is a single operator
62:42 - which means the opposite of n
62:43 - you can also say not el in hello it
62:46 - would work but the not in is easier to
62:48 - read and there's lots of things in
62:49 - python that are done to make it easier
62:51 - to read make it much more like you're
62:52 - reading
62:54 - like you would be speaking
62:57 - all right
62:58 - so a string
63:00 - is stored in python as a sequence of
63:03 - characters
63:05 - a single character in python is stored
63:07 - as a string of one
63:10 - right so there's not a separate
63:11 - character and string type like there is
63:13 - in some languages a character is a
63:15 - string of length one
63:18 - a character the string you can access
63:20 - elements of it so here we use the square
63:21 - brackets to access
63:23 - the element at index zero that's the way
63:25 - i would say it which is going to be the
63:27 - h
63:28 - and we get back
63:29 - a single character i.e a string of
63:32 - length one so it's the same type so this
63:35 - single character string and this
63:37 - multiple character string they're the
63:38 - same type of type str
63:40 - uh are those characters stored as bytes
63:44 - or two bytes or four bytes
63:46 - the answer is it's none of your business
63:48 - you shouldn't have to care
63:50 - right in python
63:52 - this string representation is a is an
63:54 - abstraction of whatever was on the disk
63:57 - or whatever came in over the network
64:00 - um it's an abstraction that's trying to
64:02 - represent at a high level closer to
64:03 - where we think about things it's a
64:04 - string of characters right and if those
64:06 - characters are klingon or korean or
64:09 - french characters whatever it doesn't
64:11 - matter python knows how to handle those
64:13 - when you put stuff on the disk then you
64:15 - need to worry about it when you read
64:16 - stuff off the disk you need to worry
64:17 - about it
64:19 - and i'll show you some of that later
64:22 - okay
64:23 - let's bind snt to the same object
64:28 - there they are
64:29 - i can look at them so here you notice if
64:32 - i evaluate you've seen this before just
64:33 - a reminder when i say s comma t python
64:36 - says oh you must mean a tuple
64:38 - and so it interprets that as a tuple and
64:41 - returns you a tuple that's why it's
64:43 - putting the parentheses around it it's
64:45 - handy for
64:46 - uh to be able to do that though in
64:47 - several cases
64:49 - so
64:50 - this is going to
64:52 - look at the ello and look at the j
64:55 - create two string objects from those
64:57 - literals concatenate them which is
64:59 - allowed in python when you use a plus on
65:01 - string types it
65:03 - puts them together and return a new
65:05 - string object jello and bind s to that
65:12 - what's t
65:14 - that's right
65:18 - okay
65:19 - what's this gonna do
65:26 - are you going to change jello back to
65:27 - hello
65:30 - strings are immutable that's right
65:32 - strings and tuples are immutable in
65:33 - certain individual floats are immutable
65:35 - it means they cannot be changed
65:38 - and the way it shows up here is string
65:40 - object does not support item assignment
65:42 - so someone out there said it
65:44 - answer the question correctly
65:46 - good for being correct just keep
65:47 - answering incorrectly just don't be
65:49 - afraid of answering the wrong answer
65:50 - we're here to learn stuff yes
66:03 - right so why
66:04 - why was it that before when i had two
66:07 - lists m and two names
66:09 - and one list i had a list object where i
66:11 - said m equals n equals list
66:13 - and i then used m sub square uh subrag
66:17 - sorry m sub 0 m square bracket 0
66:20 - equals and i changed that's because
66:22 - lists are immutable and the equal
66:26 - in
66:27 - m square bracket 0 is a request to the
66:29 - list for it to change itself in this
66:31 - case
66:32 - i didn't use the any square brackets so
66:34 - here it's actually this is a request to
66:36 - python to change the binding of s to
66:39 - point to the object that gets created by
66:40 - the right hand side
66:43 - okay
66:44 - so yes good good catch that those
66:46 - seem to be behaving differently and they
66:48 - sort of did and they sort of didn't
66:49 - uh so partly it's because
66:51 - uh
66:52 - partly it's because the list example
66:55 - earlier we had s we had m sub zero
66:58 - so i tried to do that here and i can't
67:01 - so that's why
67:02 - that's why i had to do it that way
67:03 - instead
67:04 - okay
67:07 - but i don't like the fact that i have to
67:09 - go back
67:10 - so i'm going to make a note to fix that
67:16 - okay
67:21 - all right so s is still jello didn't
67:23 - change
67:27 - okay
67:29 - hmm
67:31 - what's the b oh
67:34 - in the exercise the strings oh someone
67:36 - was working ahead they were noticing the
67:37 - r in front of a quote you were working
67:38 - ahead i think okay uh so what's the b
67:42 - mean the b means bytes
67:44 - so in python there is a bytes
67:47 - type
67:48 - which is really great
67:51 - but it's actually a little bit confusing
67:54 - and uh this is the first time i'm trying
67:57 - the next treatment here so be sure to
67:59 - write down notes if you can think of
68:00 - ways to make it better um but what this
68:02 - does is the the string type is an
68:05 - abstraction
68:06 - of characters the bytes type
68:08 - is bytes it's like one byte right
68:12 - but you notice i didn't have to put in
68:14 - the
68:15 - integer numbers that represent these
68:17 - characters it assumed i meant ascii and
68:19 - it translated the h into the number for
68:21 - me and the e into the number for me
68:23 - and if i look at the type it's a class
68:25 - it's type b
68:26 - class
68:27 - bytes it's the type bytes um s1 is hello
68:32 - b1 is b hello
68:34 - are these equal
68:36 - who thinks they're equal raise your hand
68:38 - who thinks they're not equal raise your
68:40 - hand oh fairview fair number you know
68:42 - that they're not equal right so why
68:44 - aren't they equal it's because
68:46 - by making them not equal it helps you
68:48 - prevent it helps prevent you from
68:50 - writing bugs so character encoding was
68:52 - one of the things that was well
68:53 - supported in python 2 but the way it was
68:56 - supported made it confusing and it made
68:58 - errors lag
69:00 - it did the friendly thing which then you
69:02 - would regret it later
69:04 - python 3 you regret it right up front it
69:06 - tells you right up front no you can't do
69:08 - that so you can't compare
69:09 - and that makes total sense right if
69:11 - there are bytes on the disk i've got a
69:13 - if i've got you know
69:15 - a byte which is you know
69:17 - 220 followed by a byte which is 13
69:20 - follow which byte which is seven and i
69:22 - compare that to
69:24 - three characters well they're not the
69:25 - same one is integers and one is
69:27 - characters the fact that we use integers
69:29 - are numbers to represent characters
69:31 - that's the confusing part or the part we
69:32 - have to make sure we think carefully
69:34 - about the difference
69:36 - so what if we want to take those bytes
69:40 - the numbers that are in here
69:42 - and turn them back into string
69:44 - characters
69:45 - into characters in a string this is how
69:48 - i do it i decode right so we take
69:50 - characters we encode them in bytes on a
69:52 - disk in a file or over the wire like a
69:55 - network protocol
69:56 - so if i decode them
69:58 - then i can compare it to the string so
69:59 - if i take those
70:01 - that what looks like a string is
70:03 - actually bytes and decoded into a string
70:05 - then it actually is the string hello and
70:06 - it's equal to the string hello
70:08 - okay
70:10 - i'm going to keep going here
70:12 - uh what if i take s1 and call n code on
70:15 - it well s1 is a string
70:18 - when i call the encode method it's going
70:20 - to return me an encoded version of that
70:23 - string encoded in bytes
70:26 - and
70:27 - it works
70:29 - now why did it work
70:30 - partly because
70:32 - uh it encoded it with a default encoding
70:35 - which is utf-8
70:37 - and utf-8 encoding for hello is the same
70:40 - as the uh
70:41 - is the same as the bytes uh ascii hello
70:44 - sort of is basically where i'm going
70:45 - with that um
70:47 - so as long as you work with ascii
70:49 - uh which is seven bit
70:51 - then
70:52 - utf-8 is identical as soon as you go
70:54 - past those first 127 characters then
70:58 - utf-8 you start to get different numbers
71:00 - of bytes per character sometimes and how
71:03 - many it depends on the character anyway
71:06 - your turn to do some exercises
71:08 - and i'll wander around
71:33 - yeah one more comment uh so
71:36 - so i said that the the way i'm doing the
71:38 - bytes and the encoding and decoding i
71:41 - put a lot of that in the exercises so
71:42 - when you get about half done the
71:43 - exercises i'll stop us and go through it
71:46 - together i probably should have moved
71:47 - some of that around
72:05 - my mother
72:09 - um
72:26 - uh
73:00 - uh
73:45 - you
74:13 - you
76:01 - okay so
76:03 - i think uh
76:05 - close to i think most uh more than half
76:07 - of you have gotten about a third of the
76:08 - way through and i'm going to
76:10 - change the structure here and i'm going
76:11 - to do the second most of this is i'm not
76:14 - going to let you finish the exercise i'm
76:15 - going to go through them slowly
76:17 - and i
76:18 - i
76:20 - i had planned to shift that section
76:22 - around and forgot to do it so to have
76:23 - more of it in the lecture and lessen the
76:25 - exercises so let's look at this
76:28 - so
76:29 - if you put an r in front of the string
76:31 - it doesn't do much to that string
76:34 - it just seems like it's a different way
76:36 - to do the same thing
76:38 - but here look what happened so r spam is
76:41 - spam r spam with the backslash n it puts
76:43 - a double backslash in
76:45 - right
76:46 - and
76:47 - the r stands for raw i think which seems
76:49 - kind of a funny name but basically it
76:50 - means don't do any special processing on
76:53 - the stream i.e don't
76:55 - interpret backslashes as an escape
76:57 - character so when it sees a backslash it
76:59 - puts it in and then it displays it to
77:01 - you with a double backslash without the
77:02 - r because this is what you would have to
77:04 - type back in without the r
77:06 - to get the same string as you type with
77:08 - the r and a single backslash
77:10 - okay
77:11 - uh and again the exercise here was
77:14 - trying to get you to figure that on your
77:15 - own and if you don't that's fine it just
77:17 - helped you to
77:18 - work your tiny gray cells as poirot
77:21 - would say
77:22 - um
77:23 - the uh and you can see those those are
77:25 - the same string right so if you put the
77:27 - no no these are on
77:29 - right why are these not the same because
77:30 - this one has a backslash character and
77:32 - an n character and this one has a new
77:36 - line character
77:37 - which is what backslash n gets
77:38 - interpreted as in a regular string
77:41 - and you can see the length is different
77:42 - right so one's got one more string than
77:44 - the other one one more character in it
77:45 - than the other
77:47 - okay
77:54 - so yeah i'm going to skip that one
77:57 - so you can multiply strings which is
77:59 - basically concatenate multiple copies of
78:01 - it
78:02 - you we saw you concatenate strings
78:04 - before but you can't
78:06 - concatenate strings to other things at
78:08 - least not those but you can turn it into
78:10 - a string and then you concatenate them
78:14 - okay
78:15 - oh that's kind of cool if you have two
78:17 - string literals next to each other
78:18 - python assumes you want to concatenate
78:20 - them so it'll do that as part of parsing
78:25 - all right there's a dollar sign
78:28 - there's unicode code point 24.
78:32 - oh it looks like a dollar sign
78:34 - there's a unicode named camera exactly
78:37 - the right term for that but unicode is
78:39 - the standard
78:41 - is the standard we use for encoding
78:43 - characters
78:45 - but the unicode standard is not um
78:50 - i have a pet peeve
78:52 - what is that file encoded in well it's
78:53 - encoded as unicode no unicode is not a
78:57 - an encoding unicode is a standard that
78:59 - includes things about encoding so if
79:01 - someone ever says to you it's a file
79:03 - encoded in unicode you say okay which
79:05 - one unicode utf-8 utf-16
79:09 - some other character encoding
79:11 - so this is the there's a there's a
79:14 - a table table hundreds thousands tens of
79:16 - thousands i think of characters and they
79:18 - each have a name and this is the unicode
79:20 - name for dollar sign and you can use the
79:23 - backslash capital n to actually enter a
79:25 - character that way if you want
79:27 - and you can see that these are all the
79:28 - same character
79:29 - okay
79:33 - interesting not really helpful it
79:35 - happens to be that those three are also
79:37 - stored in the same object
79:38 - strings are immutable so it can do that
79:41 - if it wants to but not every python
79:42 - implementation will do that
79:44 - um okay just think about equal
79:47 - so let's uh do a few things with that
79:49 - dollar so if we encode that
79:53 - looks like it's the same except the b in
79:55 - front so when you encode it turns it
79:57 - into a bytes
79:59 - object
80:02 - and they are different as you saw
80:04 - earlier with um
80:06 - was it hello
80:08 - the string hello and if you look at the
80:10 - you see the types are different
80:12 - one string and one's bites
80:17 - it's a single byte long
80:20 - let's encode it
80:21 - and take its first
80:24 - element
80:25 - i didn't say character on purpose
80:28 - because it's not a character bites don't
80:29 - store characters they store bytes
80:32 - what's first
80:38 - it's an it's so that's interesting if
80:40 - you take a bytes type
80:44 - like uh where was it
80:47 - first so dollar encode you turn that
80:50 - into bytes
80:51 - well hello for example the bytes type
80:53 - hello the bytes object hello it looks
80:55 - like h-e-l-l-o it's not it's actually
80:59 - whatever the number is it's it's a list
81:01 - of integers but it's sort of intended to
81:03 - be used for encoding characters right so
81:05 - it's kind of interesting that when you
81:07 - take uh
81:08 - the bytes type let me have a better
81:10 - example of that hang on a second
81:17 - okay
81:19 - right like if we say
81:21 - b hello
81:24 - v hello
81:25 - sub zero
81:29 - that's kind of weird isn't it so what's
81:31 - weird is and this is the trick to uh if
81:33 - you're new to character encoding and you
81:36 - think you i encourage you to just
81:37 - remember that when you see a b
81:40 - it's lying to you it's letting you enter
81:42 - the characters because it's convenient
81:43 - but it's not storing them as characters
81:45 - as storing them as bytes and i'm bytes
81:48 - meaning lower level down on the disk
81:50 - okay
81:51 - okay so if we look at the types of these
81:53 - things we got you know string bytes and
81:55 - int if we look at the
81:57 - the dollar string the encoded version
82:00 - and axis in the first element of it
82:02 - if i take that
82:03 - 1036
82:06 - and call the chr function on it it will
82:08 - give me back so chr and ord let you map
82:11 - from ascii values to ascii characters
82:16 - uh
82:17 - i can turn it into binary
82:20 - a string representation of it okay let's
82:22 - take the pound sign and do something
82:23 - like that so there's the pound sign
82:25 - character uh some of you might not be
82:27 - able to display it that way it depends
82:28 - on what version of python what outbreak
82:30 - system what shell
82:31 - so whether or not your shell actually
82:33 - can
82:34 - display
82:35 - characters beyond ascii defense if i try
82:38 - to turn that into a string
82:43 - well yeah what would turn it into a
82:44 - string b isn't this a string already the
82:46 - answer is yes it's a string it's a type
82:48 - string
82:49 - if i do a wrapper of it well repper all
82:52 - that's going to do is show you what you
82:53 - would have to attach here's a string of
82:56 - five characters the middle three
82:58 - characters from the
83:00 - uh quote to the pound and the quote
83:02 - that's what you would have to type to
83:03 - get it back in if your interpreter
83:05 - interact your prompt can let you type in
83:07 - those characters
83:09 - i can turn that into an ascii
83:12 - and i get xa3 using a certain encoding
83:16 - okay
83:17 - okay let's look at encoding a little bit
83:19 - more and then we'll move on
83:20 - so
83:22 - in code we saw earlier encoding utf-8
83:27 - break is at what time
83:29 - i think it's three
83:34 - someone look it up for me please i think
83:35 - it's three but yeah i'd like to know a
83:37 - few minutes before thank you for that
83:39 - reminder um so
83:41 - if i encode the pound sign using utf-8
83:43 - it actually gives me two characters
83:47 - uh sorry two bytes
83:49 - two values right so if you take the
83:51 - pound sign and code it with utf-8 which
83:53 - is by far the most popular encoding on
83:55 - the web
83:56 - has been for almost a decade not quite
83:59 - uh you get two characters or two bytes
84:01 - to represent that
84:02 - oh
84:04 - sorry for being giving all this detail
84:06 - about
84:07 - encoding you need to know about it
84:08 - otherwise you get into trouble and
84:09 - you'll just like if you know
84:11 - what you get into then it's not so bad
84:14 - what time's the break anyone find out
84:16 - yet
84:22 - okay thanks
84:23 - so we think it's three o'clock
84:26 - uh so utf-8 is the defaulting coding i
84:28 - can pass it or just give it no argument
84:30 - it'll assume that
84:32 - it's two
84:34 - bytes long
84:36 - those are the values of it right so you
84:38 - notice if i take
84:41 - that and try to enumerate over i get the
84:43 - integers out
84:44 - when i call a list it just says whatever
84:46 - it is iterate over it and give me the
84:48 - elements individually so that's why i
84:49 - get the list back with those two
84:52 - and i can get
84:55 - the first one the 194 and look at it as
84:57 - bytes and the second one look at his
84:59 - bytes and here is where you'll see
85:02 - in uh basically if these if
85:05 - this is a one
85:08 - this is just for your information if the
85:10 - first bit is a one
85:12 - then it's the start of a multiple
85:14 - character utf-8 character
85:17 - multiple byte utf-8 character if it's a
85:19 - zero it's not and so in this case uh so
85:22 - with utf-8 when basically running along
85:24 - you say all these
85:26 - bytes that are less than 127
85:30 - and you're or 127 or less and they all
85:33 - start with a zero as the highest bit
85:35 - most significant bit and when so i'm
85:37 - reading utf-800 let's just ask you to
85:40 - ask you ask you ask i get to one where
85:42 - oh it starts with the one then i read
85:43 - the byte figure out okay is this one
85:45 - it's going to be one more character two
85:47 - more character or three more characters
85:48 - it reads those in and turns it into a
85:50 - unicode
85:51 - behind the scenes it's stored something
85:53 - like that
85:58 - okay what else here
86:01 - interesting so if i you encode that with
86:03 - windows 1252 which is
86:06 - was the most popular encoding on windows
86:08 - i'm not sure if it still is depends on
86:10 - how you measure it it's a single
86:11 - character
86:14 - if i encode it as iso 859-1 which was a
86:18 - popular html encoding it's the same as
86:20 - windows 52. how about the euro sign
86:24 - the euro sign in windows 1252 is
86:27 - that byte
86:28 - in utf-8 it's those three bytes
86:32 - in iso 859-1 it's
86:34 - not
86:35 - possible
86:37 - so this is why if you're doing stuff you
86:38 - sometimes need to worry about encodings
86:40 - and how to do things always use uti
86:43 - always remember that characters are
86:45 - encoded at a higher level obstruction
86:48 - when you go to bytes or come back from
86:49 - bytes you have to worry you have to know
86:51 - what you're encoding from or to
86:54 - can't do it that way
86:56 - i can use the ignore on the encoding and
86:57 - it'll basically drop the ones that can't
86:59 - convert
87:00 - or i can replace them say replace them
87:02 - replace the characters accounting code
87:04 - with a question mark instead some
87:05 - interesting features
87:07 - okay
87:09 - string functions and methods
87:11 - any questions about all that encoding
87:13 - stuff i think i
87:14 - that was the first time i've presented
87:15 - this material i think i've got a lot of
87:17 - changes to make to make it a little bit
87:18 - simpler a little bit easier
87:20 - more feedback would be welcome yes
87:28 - what was the first character it wasn't
87:30 - it was two bytes
87:33 - what was the first byte oh you could
87:35 - convert it and find out i don't know
87:37 - what the actual number was
87:39 - i let python worry about that
87:41 - what's that
87:44 - there you go
87:48 - and and and you
87:49 - and you can't you i there's no one
87:52 - answer for it because that first
87:53 - character changes that's sorry that
87:55 - first byte changes depending on where in
87:57 - the unicode code space in utf-8 it's
87:59 - trying to get to
88:02 - so encoded in that first byte i think
88:04 - you can have i'm not utf-8 expert i
88:07 - think in that first byte of a utf-8 more
88:09 - than one character
88:11 - character representation like a 2 byte
88:13 - three byte or four byte utf-8 i'm pretty
88:15 - sure that first byte actually
88:17 - some of the low order bits can change
88:18 - too i could be wrong on that though
88:21 - okay yes
88:24 - [Music]
88:40 - yeah
88:43 - it is confusing here the here's the
88:44 - summary
88:45 - uh
88:46 - when python's running
88:48 - and you have it's doing things with
88:50 - strings
88:51 - like you're saying is this uppercase
88:53 - does this string end with an s
88:55 - you're dealing with characters and the
88:57 - characters are
88:59 - can be anything
89:00 - uh
89:02 - hindi arabic
89:05 - korean
89:06 - english
89:08 - english with an accent imported from you
89:10 - know whatever all sorts of stuff
89:12 - when
89:13 - you want to
89:15 - store that on the disk you have to
89:17 - choose an encoding to use
89:19 - you can't just say well use the
89:21 - use the one that everyone uses because
89:23 - everyone doesn't use the same one
89:24 - there's some stuff that's encoded as
89:26 - ascii and only has 127 characters
89:28 - there's some stuff that's coded as
89:30 - windows 1252 and has 256 characters well
89:33 - not quite there's some stuff that's
89:35 - encoded as iso 859-1
89:37 - and overlaps with tundra soft due to a
89:39 - lot it's almost the same but there's
89:40 - some that are different
89:41 - and then there's stuff that neither of
89:43 - those can encode at all like the euro so
89:45 - you have to choose an encoding
89:47 - the short answer is always use utf-8 and
89:49 - you'll be happy as long as it's
89:50 - supported all the way downstream
89:51 - including the database
89:54 - how many characters can be encoded in
89:56 - utf-8
89:57 - uh was many
89:59 - 256 to the fourth power almost
90:02 - plus
90:03 - right because i think four byte
90:05 - characters are the largest in utf-8 and
90:07 - except for the first few bits any of
90:09 - them can be used to encode that so
90:10 - unicode has tens of thousands i think
90:12 - it's in the 50 000 range maybe more i
90:14 - don't keep up
90:18 - the difference between binary and
90:21 - right so the bits i'm just saying i use
90:23 - the word bits to mean on the disk
90:25 - there's bits on and off so it's actually
90:26 - the the number that's represented in
90:28 - binary the bytes type
90:31 - is
90:32 - the way a convenient
90:35 - way to store a list
90:37 - of integers in a compact format that's
90:40 - almost always used to convert between
90:43 - encodings
90:45 - between encoding characters and
90:46 - unencoded characters
90:48 - that's all it is and that's why it looks
90:50 - funny is when you look at it it'll often
90:52 - show you characters even though it's
90:53 - actually storing a list of integers
90:59 - okay string functions and methods
91:02 - uh i think uh so the break is at three
91:04 - then i'll get through at least some of
91:06 - this maybe all of it and then you can
91:08 - either take your break early or late or
91:10 - whatever choose when you work on the
91:11 - exercises we'll see
91:14 - length four min what does it mean to
91:16 - take the minimum of a string well min is
91:18 - going to iterate over
91:19 - this object when you iterate over a
91:21 - string you get four strings each of
91:23 - length one and it's going to show me the
91:25 - smallest character
91:26 - uh in terms of the earliest in the
91:29 - in the way it's encoded is historically
91:31 - how it was
91:32 - max works sorted always returns a list
91:36 - does that string start with an s does it
91:38 - start with an s and a p
91:40 - does it end with an m
91:42 - give me an uppercase version give me a
91:44 - lowercase version
91:45 - take the white space off the front and
91:47 - the back new line tab space
91:51 - vertical form feed
91:52 - all those things just rip them off
91:55 - actually no just take them off the right
91:56 - side
91:57 - oh no actually just take them off the
91:58 - left side
92:00 - okay take off now this one's confusing
92:04 - you might think this is dropping the csv
92:07 - the dot csv from the end of a string but
92:08 - it's not this is actually
92:11 - dropping
92:14 - the dot or c or an s or a v
92:17 - from the right side
92:19 - which doesn't look any different there
92:21 - but here
92:23 - it does a
92:28 - and here certainly does
92:29 - right so this one's a gotcha that some
92:32 - people get confused about so
92:34 - uh r strip and strip and l-strip take
92:38 - a string and it looks for any character
92:40 - in that string and rips it off okay
92:43 - split is a method on string that returns
92:47 - a list of strings split on any white
92:50 - space by default
92:52 - if you give it an argument then it's not
92:54 - going to take the default of any white
92:56 - space it's going to use exactly what you
92:57 - give it so here it's going to look for
92:59 - the 2
93:00 - character string
93:02 - comma space comma space
93:04 - and there it's the end of the string so
93:05 - it doesn't matter
93:10 - whoa look at all those
93:12 - methods i did a dir of str or maybe a
93:15 - deer of the string what would i do i do
93:17 - the the class itself or the type itself
93:19 - there's lots of methods on there let's
93:20 - just look at what they are
93:23 - well that's a little bit easier to read
93:24 - but there's lots of them
93:27 - if i look at the string or the type
93:29 - they're the same which is mildly
93:31 - interesting for those of you who know
93:32 - what's going on behind the scenes a
93:33 - little bit or have more programming
93:35 - experience
93:36 - uh index says please find that string in
93:40 - the larger string so look for that
93:42 - string pa in the string spam and it
93:44 - finds it at character offset
93:49 - one zero one so there's the one and two
93:51 - or this is index is just like
93:54 - oh no index
93:56 - will raise a value error if it can't
93:58 - find what you're looking for find is
94:00 - just like index except it has different
94:02 - behavior
94:03 - when you when it can't find the string
94:10 - these are all fairly straightforward oh
94:12 - i can replace the e with a three
94:14 - all e's with three or just one e
94:18 - with three
94:20 - and that's it so
94:22 - start the break now come back at about 3
94:25 - 15 3 18.
94:27 - you can work on the exercises now or
94:28 - later
94:29 - if you want to break snack coffee you
94:32 - probably want to go out now instead of
94:33 - later
94:34 - shorter lines spread it out
95:22 - so before i formally start how many of
95:25 - you have finished the exercise
95:36 - and i won't walk through that shows
95:42 - okay welcome back from the break um
95:45 - some of you had time to work through
95:46 - some of the exercises i'll go through
95:47 - them now and show you
95:49 - what you missed or the ones you didn't
95:51 - get to uh before i do that had some
95:53 - couple comments uh helpful comments on
95:57 - the utf-8 and encoding
95:59 - those pieces
96:01 - and a blog post was it joel on software
96:04 - a very good old blog post on
96:06 - understanding encoding there's a bunch
96:07 - of good ones out there that explain
96:08 - encoding again it's it's i don't know if
96:11 - you need to know the depth i put in here
96:12 - i'll probably simplify for next time but
96:14 - understand at least about encoding the
96:16 - two levels of abstraction that you can't
96:17 - mix them easily and when you do you have
96:19 - to be explicit on what you want to do so
96:22 - if someone gives you a file and you just
96:24 - open it and read it without
96:26 - asking them what encoding is that file
96:29 - then someone's made a mistake like you
96:31 - need to know what encoding a file is if
96:33 - you want to safely get the characters
96:35 - out of it
96:36 - and simply for a like a stream of data
96:38 - it's usually not as
96:41 - important to ask because it's usually
96:43 - encoded in headers between like a
96:45 - browser and a server it's already that
96:47 - negotiation happened for you but if it's
96:48 - just a file on a thumb drive or email to
96:50 - you find out what the encoding is
96:54 - okay so exercises here so sorted spam
96:59 - again supposed to think about what's
97:01 - this going to do well sorted is a
97:02 - function that takes any iterable
97:05 - string is a kind of iterable a list is
97:07 - kind of iterable a tuple is an interval
97:08 - a dict is an interval there's lots of
97:10 - other file handled
97:12 - and then it pulls out all those elements
97:14 - which for a string are going to be the
97:15 - individual characters representative
97:17 - strings
97:18 - and puts them in in sorted order
97:21 - let me get rid of my little
97:24 - sidebar there
97:26 - uh you can pass an optional character
97:29 - optional argument reverse equals true
97:30 - puts me in the reverse order
97:33 - reversed is a built-in function that
97:35 - takes an iterable and returns a reversed
97:38 - object at a particular address so
97:42 - many
97:43 - uh over time python has
97:47 - is gent is is
97:50 - slowly and steadily marching towards
97:51 - more and more lazy evaluation so don't
97:54 - uh evaluate until you have to
97:56 - generators do this a lot of functions do
97:58 - this um the views on
98:00 - dictionaries et cetera so in this case
98:03 - the reversed object won't give you them
98:05 - in reversed order until you ask for them
98:07 - individually and that in many cases can
98:09 - be more efficient because it's not
98:11 - putting stuff in the member you might
98:12 - never want anyway
98:14 - well in this case it's all memory anyway
98:16 - but uh if you want to iterate some over
98:18 - something to see what's actually in it
98:20 - like a reversed iterator you want to do
98:22 - the iteration the easy way is just pass
98:23 - it off to the list built in it will
98:25 - iterate over it for you and return the
98:27 - list okay
98:30 - upper is upper
98:33 - title
98:34 - is title see the pattern there there's a
98:36 - bunch of them there where the is is the
98:37 - predicate function or predicate method
98:39 - it's called because it answers yes no
98:40 - question
98:42 - and title returns a title case version
98:44 - of the string
98:46 - and you can see what title case does
98:48 - with spaces
98:50 - swap case
98:52 - right so here we've done what's called
98:53 - method chaining we called a method so
98:56 - this object this method was called on it
98:58 - a new string object
99:00 - was returned which was spam eggs in
99:02 - uppercase and then the swap case method
99:05 - was was called on that object to swap
99:08 - the case so method chaining is becoming
99:10 - more popular especially in some
99:12 - libraries
99:13 - in python
99:15 - is that string substring is pa a
99:18 - substring of the spam string
99:21 - is the exclamation point in that string
99:25 - okay
99:26 - will he nearly find ill
99:28 - ah it said in index one right there
99:32 - find the first one that starts after six
99:35 - that should be that one
99:37 - there we go offset seven
99:41 - anyone get through far enough it's not
99:43 - going to work for me because i didn't
99:44 - define s anyone figure out what s dot
99:47 - index 0 s index space does
99:50 - oh this didn't work because s is defined
99:53 - but it's not assigned
99:56 - oh so in years s was defined thank you
99:58 - that's helpful where's mine it was not
100:00 - because i'd reset my interpreter
100:05 - right so if we set s to hello world as
100:07 - an example
100:09 - which i think i did next
100:12 - and then go back and do it well then
100:14 - we see i mean basically what's going on
100:16 - here is that
100:18 - s dot
100:19 - index says look for the o but starting
100:22 - at the character
100:24 - starting at this character position
100:25 - where this character position is
100:26 - whatever s dot index space returns so
100:28 - it's going to start looking at space
100:30 - to find the o so it's going to get the o
100:31 - there
100:32 - okay
100:36 - uh
100:37 - yeah and then you can see
100:40 - yeah
100:41 - build it up and see okay
100:42 - uh
100:44 - count the spaces in string
100:46 - how do i check for more spaces of
100:47 - non-spaces in a string think about how
100:49 - to solve that
100:54 - you know that they say about regular
100:55 - expressions
100:56 - if you have a problem that you solve
100:58 - with regular expressions now you have
100:59 - two problems
101:01 - just because they're so like for simple
101:03 - stuff they're great as soon as it's so
101:05 - easy to go over this line that's hard to
101:07 - see it's in this visible line and
101:08 - suddenly like why did i write regular
101:12 - so yeah they're great but keep them
101:14 - small
101:15 - regular expression would work you could
101:16 - do an s count of spaces you could do
101:18 - replacement spaces and count what's left
101:20 - there's a bunch of ways to do it i'm not
101:21 - gonna actually go through it yeah oh no
101:23 - that was a
101:25 - not a question okay
101:28 - questions before you move on
101:30 - so let me do a check uh how many of you
101:33 - think i've been going too fast raise
101:35 - your hand
101:37 - how many of you think i've been going
101:38 - too slow raise your hand
101:40 - so at least within the bounds of
101:42 - people's courage to stick their hand up
101:44 - alone uh i'm i'm hitting the right
101:46 - stride good
101:47 - um
101:49 - and and other feedback welcome in the uh
101:51 - there's a little comment box in the
101:53 - survey i think you can type as much as
101:54 - you want i'd like to hear it i was
101:56 - tightened with someone over lunch who
101:58 - said yeah these you know surveys are a
102:00 - great way to get feedback but sometimes
102:01 - it's kind of you know
102:02 - it's kind of passionate not very polite
102:05 - feedback if you're so frustrated that
102:07 - you can only give me feedback online in
102:09 - politely i'd still like to hear that
102:11 - because that's really important feedback
102:12 - for me to know
102:14 - and i have in teaching over the years
102:15 - sometimes gone too far on the frustrate
102:17 - users to help them think make them think
102:19 - i have gone i've gone across that line
102:21 - sometimes so
102:22 - feel free to tell me i'd like to know so
102:25 - print and string formatting
102:29 - no difference when you're in the rebel
102:31 - in
102:32 - a script or code you're running if you
102:34 - just put a three it's never going to
102:35 - print out you have to actually call the
102:37 - print function
102:38 - right i can call it with multiple
102:40 - arguments by default it separates the
102:42 - arguments with a space
102:48 - here you can see
102:50 - print three four it printed and then
102:52 - there's a new line that got printed just
102:54 - like the repple printed a new line after
102:56 - it so by default there's a new excuse me
102:58 - new line you can put a backslash n to
103:00 - add another one
103:05 - you can do this in python 3.
103:08 - most people are moving towards the dot
103:10 - format operator or f strings uh so
103:15 - the way this works and you still see it
103:16 - it's um it's basically this percent that
103:19 - i showed you earlier as a mod operator
103:21 - like a remainder um
103:23 - is saying
103:24 - is basically saying please look in the
103:26 - string for percent d and interpolate is
103:29 - the official term for that number into
103:31 - that string so you get three good
103:32 - reasons um however this is much more
103:35 - common
103:36 - in newer versions of python since two
103:39 - six or two seven i think
103:41 - um and so what happens here is it looks
103:43 - for curly braces and then matches the
103:45 - argument to the curly brace
103:48 - that's in the string
103:49 - okay
103:50 - uh so there's the format built in method
103:53 - you can call it with no arguments and
103:55 - there's nothing to interpolate not a
103:56 - problem
103:57 - you can call it with an argument that
103:59 - doesn't get interpreted because this
104:00 - string didn't have it
104:02 - but if you say i want to interpolate
104:04 - something and there isn't an argument to
104:06 - interpolate then it tells you there's a
104:07 - problem and there are good use cases for
104:09 - why it would allow these other ones
104:10 - because you don't i mean here we're
104:12 - playing with toy strings where we know
104:13 - the string we know the argument ahead of
104:14 - time often in your program you have
104:16 - multiple cases and some runs or once
104:18 - sometimes through the loop you might
104:19 - have values there other times you
104:21 - wouldn't and you could simplify code by
104:23 - having these
104:25 - at least in some cases more relaxed
104:27 - interpretation such as this one where
104:30 - you have an argument but nowhere to put
104:31 - it
104:35 - uh yeah that's no different so hi class
104:41 - uh i can use numbered arguments if i
104:43 - want
104:44 - i used to have to use them now you
104:45 - they're optional
104:47 - and that's advantageous if you want to
104:49 - change the order which again in this toy
104:52 - example it's more confusing than helpful
104:54 - but in real world examples it would
104:55 - sometimes be more helpful than confusing
104:57 - you can also repeat them that way
105:00 - so they're a good good uses cases good
105:02 - times it's good to have the ability to
105:04 - use numbered arguments
105:06 - uh and then you can see like the colon d
105:08 - here now again
105:10 - reminder i'm not expecting you to
105:12 - memorize all this stuff just let it wash
105:14 - over you and absorb as much as you can
105:16 - okay
105:17 - so so you're aware of all the things you
105:19 - can do just like strings there's tons of
105:21 - things you can do with string
105:22 - i would say
105:24 - i think this is good advice
105:26 - if when you're trying to figure out how
105:28 - to do something in python and you know i
105:30 - could do that with an index and a this
105:32 - and a loop think is this something that
105:34 - lots of people have done before and
105:35 - wanted to do before and if the answer is
105:37 - yes there's probably already a way to do
105:39 - it that doesn't involve you writing five
105:40 - lines of code there's probably a method
105:42 - or a built-in function and if stack
105:44 - overflow doesn't give it to you just
105:46 - keep looking because it's almost always
105:48 - there
105:48 - standard library same thing
105:51 - the standard library in python is huge
105:53 - people say it's batteries included
105:56 - and for probably the first six seven
105:58 - years of me programming quarter of my
106:00 - time in python i kept kind of every few
106:03 - months like oh that's in the standard
106:04 - library why did i write write that code
106:07 - six months ago um because there's just
106:08 - lots of stuff hiding in there that you
106:10 - know i and i'm the type that reads
106:12 - manuals up front like oh let's just read
106:13 - through the standard library manually
106:14 - skim it to see what's there and then i'd
106:16 - forget stuff
106:17 - okay back to string formats uh so colon
106:20 - d is the way so you put a colon
106:23 - after the missing argument here so so
106:25 - again here the the argument is just the
106:27 - implied first one because it's the first
106:29 - in the string here um and then colon d
106:31 - is a modifier that says here's how i
106:33 - want you to format that argument so i
106:35 - want to format it
106:36 - as a decimal a string a number or a
106:39 - number 10 characters white right
106:41 - justified
106:42 - or
106:45 - same thing but
106:46 - put the negative all the way at the left
106:48 - side or
106:50 - explicitly right justify it
106:52 - put underscores in front of it left
106:55 - slide to the left of it put it in the
106:56 - center
106:57 - lots of stuff
106:59 - what's that yeah you can do that too
107:06 - and i have some
107:08 - duplicates here
107:15 - i don't know what that one does equal
107:17 - plus 5d what's the five
107:20 - it's only showing i think it says no no
107:22 - oh show
107:24 - yeah i can't remember there's actually a
107:26 - good online resource called pi
107:29 - pi format i think uh dot info or
107:31 - something like that that just shows you
107:32 - lots and lots of examples um it's a
107:34 - really complicated
107:35 - like there's lots of features i don't
107:37 - know nearly all of them
107:38 - you can also
107:40 - put names in like this and then give
107:42 - argument names like that to match them
107:47 - right
107:49 - so and in most recent versions of python
107:52 - you can use an f string where it will
107:54 - look in the current namespace for gree
107:57 - and who so if i have these names in the
107:58 - current namespace when the string
108:00 - executes then it will find them and put
108:02 - them in
108:03 - and that's uh these f strings are
108:05 - like
108:07 - way almost always far more readable than
108:09 - the dot format version because you can
108:11 - see the placeholder
108:13 - okay your turn to uh spend a few minutes
108:16 - looking at exercises
108:59 - you
109:41 - you
110:14 - so
111:19 - you
112:04 - okay i'm going to move us along here
112:07 - and i'll go through these exercises
112:10 - so you notice you can take
112:12 - that print takes defau
112:14 - optional arguments like what to separate
112:17 - in what to use as the separator between
112:20 - its argument its other arguments other
112:21 - than space or what to use as a
112:24 - ending
112:25 - string instead of the new line character
112:28 - if you want to have nothing as the end
112:30 - character you might think that end equal
112:33 - and then give it an empty string would
112:35 - work but it won't sorry that n equals
112:36 - none would work but it won't you have to
112:38 - give it an empty string and that's
112:39 - because the end equal none that's the
112:42 - way almost all functions when they're
112:44 - written they take uh they say well this
112:46 - is a character that you you you have to
112:48 - you can supply what you want to end with
112:50 - or if you give us nothing
112:52 - then we'll use a new line and sending n
112:54 - equals none is like not giving it
112:56 - there's no way for the called function
112:57 - to actually tell if you explicitly
113:00 - called it with none or just left the
113:01 - argument off
113:02 - so that's a little gotcha that shows up
113:04 - in other places as well once you realize
113:07 - that's the way functions are implemented
113:09 - you won't it won't trip you up as much
113:12 - uh
113:13 - nothing new there there we duplicated
113:16 - the three or the four switch them around
113:20 - right so here you can see that seven is
113:23 - the width and point two is how many
113:26 - decimal places
113:27 - and those mean different things for
113:29 - different items like the s if you say
113:31 - it's a string
113:32 - then the
113:33 - dot means how whether or not to truncate
113:36 - and how closely or how tight
113:39 - b
113:40 - is binary
113:45 - you can sort of play around hex
113:47 - hexadecimal octal
113:49 - percent so it does the math for you and
113:52 - puts in the percent sign
113:55 - here it's
113:56 - print for me one third five wide two
113:58 - after the decimal point and it's a
114:00 - percent
114:02 - so here notice that we have a curly
114:04 - brace pair and inside it there's a curly
114:07 - brace pair exactly where you would
114:08 - expect to see how many digits after
114:10 - and so there you can see
114:12 - how that works
114:14 - uh obviously if you know up front what
114:15 - they are stick them in the string but if
114:17 - this is a variable that changes with
114:18 - various runs or configuration or
114:20 - whatever that's when it makes sense to
114:21 - use it
114:23 - and you can even do
114:25 - something like that where date time
114:27 - objects
114:28 - the date time object has its own format
114:33 - specification so when format method runs
114:36 - it acts the objects it actually goes and
114:38 - talks the object to say well do you have
114:40 - a dunder format method and if so it uses
114:42 - it to figure out how to do it so you can
114:43 - write your own in theory
114:49 - sis.version info is an example of a
114:52 - named tuple in python so it's uh
114:56 - it's like a list
114:58 - it's like a couple of elements that you
115:00 - can access by index or by name and so
115:03 - for example here i can say pass cis as
115:06 - the argument
115:08 - and then i put dot version info as the
115:10 - part of that argument i want
115:15 - so uh yes so then it's going to show me
115:17 - sysdot version info
115:19 - or i can pass
115:21 - uh in this case i use the format in this
115:23 - case i'm using the fstring so it's going
115:24 - to look for sys.version info
115:27 - and just take
115:30 - uh
115:30 - oh it's gonna put the whole thing same
115:32 - thing in there
115:37 - 308 i think that's a little confusing
115:40 - let me make a note
115:44 - uh and notice in in the f strings you
115:47 - can put inside these curler braces i
115:49 - mean here i've got you know take that
115:51 - piece out and multiply it by three and
115:52 - add five and we'll play that you can put
115:54 - almost any python expression in here
115:57 - which is not true for the dot format
115:58 - method the dot format method there's not
116:00 - quite as much
116:01 - python you could play there there's a
116:03 - few restrictions but not too many
116:05 - so um and that can wait i mean
116:07 - like in my opinion that's starting to
116:09 - get pretty ugly and hard to read so when
116:11 - do you put stuff inside the curly braces
116:13 - when you put it in a format whatever's
116:15 - going to be readable easiest to read by
116:17 - yourself or someone else six months ago
116:18 - is the way i answered some of my
116:20 - questions
116:21 - think about readability
116:23 - okay questions on format printing
116:27 - okay tuples and lists there's a list
116:30 - there's a tuple
116:32 - you can pass any iterable to a list and
116:34 - it'll create one for you
116:38 - you can pass you can access
116:40 - you can ask a list to
116:42 - change its element at index one so it's
116:45 - going to instead of referring to the b
116:47 - it's gonna or two it's gonna refer to
116:48 - the b
116:49 - so it can change itself they are mutable
116:53 - i could take uh any iterable and pass it
116:56 - to the tuple built-in name that callable
116:59 - and it will create a tuple from it
117:02 - and
117:03 - if i try to change
117:05 - the contents of a tuple though i'm going
117:07 - to get an error does not support item
117:09 - assignment
117:11 - but you create the mixed of course
117:13 - there's no restriction that tuples all
117:14 - be the same type
117:16 - the only place you start you see that
117:19 - all the things in a data structure need
117:21 - to be the same type are things like
117:22 - little string they all have to be
117:23 - strings
117:25 - and then you see in other libraries like
117:26 - numpy where columns have to be all the
117:28 - same type if you want to be fast
117:32 - okay
117:33 - so
117:34 - can i concatenate lists the answer is
117:37 - yes then you see what happened i got a
117:39 - new list those two lists stuck together
117:42 - sort of
117:44 - of course the original list didn't
117:45 - change
117:46 - i didn't use plus equal here i just used
117:48 - plus
117:49 - right earlier i used a plus equal which
117:50 - says please modify the list extend it
117:54 - can i
117:57 - so here i added a list to a list here
117:59 - i'm adding a tuple to
118:01 - an int
118:03 - and it says you can only concatenate
118:05 - tuple to tuple okay so let's try
118:07 - concatenate the tuple
118:12 - read the error what happened
118:18 - so right here not int
118:20 - it's seeing an int there why well
118:21 - because round brackets in python are
118:23 - used both to create tuples
118:26 - to call functions
118:27 - and to
118:28 - uh enforce precedence in mathematical
118:30 - expressions or make them more readable
118:32 - or both
118:33 - so the 4 is being interpreted as
118:36 - not a tuple with the single element but
118:39 - as
118:40 - the number 4.
118:43 - well there's a
118:44 - that works
118:48 - okay that worked for creating a tuple
118:52 - no it didn't look good so t equals four
118:54 - that actually said t is now an inch so
118:56 - that's not working and it doesn't matter
118:58 - how many parentheses you put on it's not
118:59 - going to help um but you can oh see how
119:02 - about here here if i put abc is going to
119:04 - give me a tuple here i did tuple four
119:06 - and it gave me an int here i give double
119:08 - abc and gives me a tuple of three
119:09 - characters so if it can iterate over
119:11 - what you pass it it will do so and put
119:12 - those elements in the list in the tuple
119:15 - sorry um if you need to create a tuple
119:17 - with a single element you can do it that
119:19 - way
119:20 - and you can see that it works so
119:22 - occasionally you'll see that on output
119:23 - as well like here and that's what's
119:24 - going on there so it's sort of this
119:26 - collision between the multiple uses of
119:28 - parentheses we have this edge case that
119:29 - we have to handle so a comma trailing is
119:32 - allowed uh is required and in fact a
119:34 - trailing comma is allowed in lists and
119:37 - tuples and dictionaries and that's quite
119:38 - handy when you have a list or
119:41 - and you split it across multiple lines
119:42 - you'll often see a comma f between them
119:44 - like you'll have element number one
119:46 - comma element two comma and the last
119:48 - element comma and then the closing
119:49 - square bracket
119:51 - and that people once you get used to it
119:52 - it's more readable it's easier to edit a
119:54 - bunch of reasons why people do it that
119:56 - way
120:04 - oops
120:05 - got an error there
120:07 - i have a
120:08 - typo here
120:15 - let's do that
120:17 - and that was it line 433
120:21 - is that the second typo is that two
120:22 - dollars now
120:28 - okay so now if i take
120:30 - the tuple t which is a b c i can add the
120:34 - tuple four and i get a b c four as a new
120:36 - tuple
120:40 - right so you can do the math as in
120:42 - concatenate multiple versions of itself
120:45 - there's another way to create an empty
120:47 - tuple
120:49 - a list vcdf length 4 minimum maximum
120:54 - sorted
120:55 - reversed
120:56 - list reversed
120:58 - i think you've seen all this in the
120:59 - exercises before why does this feel like
121:01 - repetition
121:05 - i think i have another error is that
121:06 - eight dollars no four dollars now
121:11 - there you go just reinforcing thank you
121:13 - so uh m dot insert zero a what that does
121:16 - is it's going to insert
121:17 - a into the list m
121:20 - before index zero
121:23 - okay
121:29 - what's that going to do
121:36 - someone said at the end
121:37 - so let me read this one again
121:39 - insert a before index zero
121:43 - so let's insert
121:45 - e before index minus one
121:49 - what is index minus 1 on a list
121:52 - that's index minus 1. so if i insert e
121:54 - before
121:56 - the index of f i'm going to get it
121:59 - e before f
122:00 - okay
122:01 - so
122:03 - if you someone asked me earlier about
122:06 - how do you read slices and where is it
122:07 - going to put it well if you think i
122:08 - always think of before in cases where
122:10 - it's
122:11 - i think in most cases maybe all cases
122:13 - where it's ambiguous think about it as
122:15 - before the index you're giving is you
122:16 - wanted to put it in before that put it
122:18 - in before that
122:19 - and then it makes sense and we'll see
122:21 - some other examples that later
122:23 - m.remove e
122:25 - this is one that sometimes people get
122:27 - confused and think it's going to if you
122:28 - pass it a number it's going to
122:30 - remove an index it's not it's going to
122:32 - look for that element so mr move looks
122:34 - through the list finding one that's
122:36 - equal to e and removes it from the list
122:39 - now you notice it didn't return anything
122:41 - so it doesn't pull it out of the list
122:42 - and give you a copy it just asks the
122:44 - list to remove that element from the
122:46 - list
122:48 - um actually what i couldn't remember
122:51 - oh so m.pop will pop the last item and
122:54 - return it
122:57 - hang on
123:01 - uh and what i couldn't remember earlier
123:02 - but i'm sure i'm remembering right but
123:04 - someone feel free to
123:06 - prove me wrong is that if you had two
123:08 - e's in the list it finds the first one
123:10 - to remove it it doesn't go looking
123:11 - through the whole list it says just
123:12 - remove the first element that matches
123:14 - that that is equal to that
123:17 - all right so pop does return an element
123:19 - and remove the last one so let's uh bind
123:22 - i to the one and j to two
123:26 - okay
123:30 - so i don't need the parentheses here i'm
123:31 - doing uh this is
123:33 - uh
123:34 - sometimes called tuple assignment or
123:36 - unpacking basically if the right side is
123:38 - an iterable and the left side is
123:40 - multiple names like an implied tuple
123:43 - that can be entered over it'll do
123:44 - multiple name assignments at the same
123:45 - time
123:47 - sorry about that
123:52 - all right so there's a tuple of three
123:55 - there's another tuple of three
123:58 - are they equal
123:59 - what does it mean for two tuples to be
124:01 - equal
124:02 - the answer is
124:04 - it's that they have this they have
124:07 - the same contents meaning that each of
124:09 - their elements are equal so when you say
124:11 - our two lists equal our two strings
124:13 - equal our two tuples equal python goes
124:15 - through looking at each element and if
124:16 - it gets to the end and they were all
124:17 - equal then the tuple is considered to be
124:19 - equal the two tuples are considered to
124:21 - be equal
124:23 - how many threes are in there you saw
124:25 - this before with strings
124:27 - right so a bunch of these the same
124:29 - now this looks kind of weird
124:31 - but it's really nice
124:33 - left side
124:35 - right side is
124:37 - four elements left side is three but the
124:39 - star says put extras in there so what's
124:41 - gonna happen is n3 will be three and
124:43 - four will be four and rest will be
124:46 - all the rest of them it doesn't remember
124:48 - the type on the right side like this is
124:49 - a list over here it's just looking at
124:50 - this as an iterable iterates over it
124:52 - doesn't know that it's a list it just
124:53 - puts them all into a list it turns out
124:58 - right
125:00 - so
125:01 - n3 was assigned three and four four rest
125:03 - was designed four five six and then be
125:05 - because i use commas between them here
125:07 - it shows it to me as a tuple but it's
125:09 - actually it's doing the three name
125:10 - assignments is the part that matters
125:12 - if i put it in the middle here
125:15 - works
125:16 - cool
125:17 - you can't it can't be ambiguous so it
125:20 - doesn't always it doesn't read your mind
125:22 - so your turn now to do exercises for
125:25 - tuples
127:39 - you
128:21 - you
130:10 - okay
130:13 - once again i'm going to
130:14 - stop those of you who haven't quite
130:16 - finished and go through it
130:18 - as a group here
130:20 - there's another one that exercises
130:22 - pretty long
130:23 - so
130:25 - lists
130:31 - right so you can see here that if you're
130:33 - going to use the plus equal operator on
130:35 - a list
130:36 - the object
130:37 - has to be an iterable such as another
130:39 - list
130:41 - also implies it doesn't have to be
130:42 - another list it could be any iterable
130:47 - all right sure enough
130:51 - append appends an element to a list
130:56 - and append
130:58 - appends an element to a list
131:00 - it takes only one argument okay so let's
131:02 - append an element to a list
131:04 - and we have a list that contains as its
131:06 - last element a list
131:08 - of three strings okay
131:11 - let's uh
131:13 - delete that one so before you saw em
131:15 - remove here i'm saying do a del of m
131:17 - minus one this is not a namespace
131:19 - operation it's a request to the list
131:21 - object that m is bound to to remove its
131:24 - last element so
131:26 - and this last element is the list efg so
131:29 - i remove that
131:30 - and now it stops at d and if i use
131:32 - extend instead and give it an iterable
131:35 - like a list
131:37 - then i get the efg added each of those
131:40 - okay
131:46 - that comment i forgot to take out i
131:48 - think yeah it's bam
131:50 - we have five in m right so similar
131:54 - that's just too long
132:04 - right so in here just like in in a
132:06 - string here it's just looking to see if
132:08 - it's in there
132:11 - and you can see that in and not in not
132:13 - in as a single operator or not the
132:15 - expression of within operator either
132:17 - works
132:18 - well how about that one five six i see
132:20 - five six in that list
132:23 - oh no i don't do i
132:27 - but now i do
132:29 - so
132:30 - is that object in that
132:33 - object so that list now contains five
132:35 - six before it contains five and it can
132:37 - say six but as in as separate objects
132:44 - that's interesting
132:46 - m is one two three four five six seven
132:47 - all the way up to g with some weird mix
132:50 - of integers and strings
132:51 - uh n is three characters
132:53 - one two and four three elements and one
132:56 - two and four so
132:57 - python lets me compare those two objects
133:00 - and it will go through them and say is 1
133:02 - less than 1
133:04 - yes is
133:06 - sorry m less than n is 1 less than 1 yes
133:09 - 2 less than 2 yes 3 less than 4 yes and
133:11 - then it runs off the end of this list
133:14 - and it's done so it says sure true so
133:16 - you're allowed to compare
133:18 - lists of unequal length in any interval
133:20 - other intervals of unequal length that's
133:22 - not a problem
133:26 - so these are just
133:33 - doing lots of unpacking on the right to
133:35 - assign to bind multiple names here
133:37 - multiple assignments
133:38 - do you notice any iterable
133:40 - works on the right side as long as it's
133:42 - the right length
133:50 - so all these are unsurprising
134:00 - there's a split like we saw before gives
134:02 - us a list
134:03 - join is the reverse so
134:06 - if you call split on a string it returns
134:08 - a list if you call
134:10 - join on a string it returns
134:13 - uh and pass it a list if you pass a list
134:15 - to join on string it returns a string
134:18 - just a little bit sure in the middle
134:22 - this one
134:23 - line 520 yeah
134:29 - show up where
134:31 - this line
134:34 - igk i j k l m n o p
134:40 - ah so this did the assignment this is
134:43 - showing the values
134:46 - p is right there
135:01 - i think it is
135:08 - anybody else in the problem
135:15 - yep
135:18 - so what happens here is python
135:20 - looks at this iterable one two three
135:23 - four five six seven eight objects
135:26 - and it looks left side one two three
135:28 - four five six
135:30 - and says okay i can do the last two and
135:33 - the first three and all the extras i
135:35 - will stick into there
135:36 - yep
135:38 - you're the only one that asked some of
135:39 - the other people were thinking they were
135:41 - under it too
135:42 - probably
135:44 - oops what happened here
135:52 - so
135:53 - here i join on space i can join on
135:56 - something like a column space i can join
135:57 - an empty string just to concatenate
135:59 - strings together you'll often see
136:01 - that as a pattern because joining
136:03 - concatenating to strings one at a time
136:04 - is slow if you're doing big strings well
136:06 - computer's a lot faster now so it
136:07 - doesn't usually matter occasionally it
136:09 - does
136:11 - okay there's a list
136:13 - m dot sort called the sort method on the
136:16 - list m
136:17 - and it will sort in place
136:20 - and it doesn't return anything
136:22 - or more precisely it returns none than
136:24 - none object
136:25 - reverse
136:27 - similar
136:29 - okay let's start over again
136:31 - i could do sort
136:33 - ask it to sort itself in reverse order
136:35 - yeah that works too
136:37 - i can ask
136:38 - uh it to sort itself and reverse itself
136:43 - why will this fail
136:50 - so remember how method chaining works
136:52 - is that
136:55 - this
136:56 - will create a list
136:58 - that looks the same as that one
137:01 - this
137:03 - will ask that list to sort put itself
137:05 - into sorted order
137:07 - and it will return nothing
137:10 - and then python will try to look up the
137:12 - name reverse on the none object and it
137:14 - can't find it so i'm going to get a name
137:16 - error
137:17 - or an attribute error
137:19 - on the none type object the none object
137:21 - which is a type num type
137:29 - no no some it depends so some methods
137:32 - don't return anything some do so in this
137:34 - case sort and reverse uh i have a
137:37 - specific
137:38 - reason they have there is a specific
137:40 - reason for that
137:43 - all right and i don't actually say it
137:45 - but but it's it's because there are
137:46 - built-in functions
137:48 - sorted and reversed
137:50 - and built in and methods on list
137:53 - sort and reverse without the d on the
137:55 - end uh and by not by returning none it
137:59 - makes it even more clear that if you've
138:00 - done the if you use the wrong one by
138:02 - mistake
138:15 - uh so
138:16 - we could say m equal list
138:19 - m.sort
138:20 - m.reverse that would work fine
138:26 - well sort returns none
138:29 - yep
138:30 - okay
138:33 - uh and here's the sorted function
138:36 - well it's not though i called it as a
138:38 - method there's no sorted method there is
138:39 - a sorted function
138:42 - okay
138:43 - so sort and reverse are methods on list
138:45 - or and possibly other objects sorted is
138:48 - a built-in function that takes any
138:49 - iterable and returns a list of those
138:52 - elements in sorted order
138:55 - okay
138:57 - any questions
139:00 - all right let's do some stuff with slice
139:03 - sequence
139:04 - yes
139:08 - does what
139:11 - so the method reverse
139:13 - is a request to the list to reverse its
139:16 - contents and it returns none
139:20 - it's a requested list to reverse itself
139:22 - and the list method does do that
139:25 - in theory you can write your own reverse
139:27 - on some other
139:28 - object that doesn't but
139:31 - reversed is a function that takes any
139:33 - iterable
139:34 - and returns a list
139:39 - remembering that exact difference
139:42 - it's okay if you forget that but in
139:43 - general you got to remember these little
139:44 - details that's part of what keeps you
139:46 - happy when you're programming
139:49 - okay so there's a list
139:52 - access element zero
139:55 - number three
139:58 - the last element
140:00 - second to last element
140:03 - okay so what's this one going to do
140:05 - this is going to return this one returns
140:08 - an element an element in element l this
140:09 - one is a slice and it returns a sub list
140:14 - and the sub list is going to be a list
140:16 - of elements that start at index 0 and
140:18 - stop before they get to index 1.
140:21 - so what will this return
140:26 - some people said march and that's not
140:28 - quite right
140:29 - it's going to return a list of all the
140:31 - elements starting at zero and ending
140:33 - before one
140:35 - so it's not going to return march it's
140:37 - going to return
140:38 - march
140:40 - right it's going to return a sub list
140:43 - okay and that's a
140:45 - tricky thing uh this one will start at
140:48 - zero and stop before two so it will
140:50 - return march and april in a list
140:52 - a slice
140:55 - this one will return the whole list
140:59 - start at zero stop before you get to the
141:02 - minus one element it will return the
141:04 - whole list except for july
141:07 - okay
141:09 - this one will start at zero and stop
141:11 - before it gets to element 100.
141:13 - who thinks it'll give an error raise
141:15 - your hand
141:16 - who thinks it'll give the whole list
141:18 - raise your hand
141:19 - yeah
141:20 - it'll actually work
141:22 - so it's completely reasonable to think
141:23 - it might give you an error many
141:26 - languages would in python it's like well
141:28 - again as long as you think the reason
141:29 - i'm using this stop before you get to is
141:31 - that way of thinking about it
141:33 - uh makes it at least a little bit more
141:35 - comfortable that this would not return
141:37 - an error okay it's a language choice
141:38 - when they design it that this works and
141:40 - that actually does come in handy
141:42 - sometimes
141:46 - this returns a list
141:48 - starting
141:50 - as early as you can and stopping as late
141:52 - as you can because we've left off the
141:53 - start and stop so it returns the whole
141:56 - thing and those are three ways to do the
141:58 - same thing
141:59 - okay so all three of those basically
142:02 - make a new list all of these are making
142:04 - a list this is a new list new list new
142:06 - list new list and these in this case all
142:09 - three times there month two was bound to
142:11 - a new list where the elements and their
142:13 - order was the same as the old list but
142:15 - it's a copy of the list
142:17 - okay so the difference is the list
142:19 - stores the ordering of the objects the
142:21 - objects are shared between them
142:24 - but those are all immutable objects
142:25 - they're strings so you can safely change
142:27 - one and the others won't be changed
142:29 - okay
142:31 - there's a tuple
142:37 - and there's a
142:38 - copy of the tuple
142:41 - oh no that's not right
142:44 - i think i'm wrong
142:45 - i think i have a i think i just learned
142:47 - something other check here
142:54 - oh no i'm right okay yeah so if you use
142:56 - uh
142:57 - so so all of these using start with that
143:00 - tuple if you use square brack cone it
143:02 - returns a sub
143:04 - a slice of the tuple and it is a tuple
143:07 - type
143:08 - because it's a request to that object so
143:10 - it returns the same type
143:13 - and you can do it but you can't do
143:16 - copy there's no copy attribute you can't
143:17 - do there's no copy method on top of but
143:19 - there's a list some objects have a dot
143:20 - copy some don't
143:23 - uh
143:24 - in general
143:25 - when you are writing this to remind me
143:27 - to tell you this in general when you're
143:29 - writing a function
143:30 - try not to think okay
143:33 - i'm going to get an argument which is a
143:34 - list and i need to do some things with
143:36 - this list instead think more generally
143:38 - if you can instead write the function as
143:40 - okay i've got this list and i want to do
143:41 - something with it let me write a
143:42 - function but let me write the function
143:44 - so that takes any iterable and works on
143:46 - it and don't assume that it's a list
143:49 - assume that it could be a list or a
143:50 - tuple or a string or an open file handle
143:53 - or open network handle or anything that
143:55 - can be iterated over a generator a
143:58 - generator expression uh then your code
144:01 - will be more reusable
144:04 - uh you'll you'll find you're using it
144:05 - for things you didn't intended for down
144:07 - the road which is really nice
144:09 - okay let's get back to that list there's
144:12 - months two which is a copy they are the
144:14 - same
144:16 - they are the same what they're equal
144:18 - those two lists are equal when you
144:20 - compare them they are equal
144:23 - are they the same
144:24 - two names for the same list
144:27 - no because remember i create a new list
144:29 - when i use the square brackets so
144:30 - they're different
144:32 - list objects that happen to share the
144:34 - same
144:35 - uh
144:36 - contents
144:38 - if i ask month 0 to delete its 0th
144:42 - element the element beginning march it
144:44 - will do so
144:45 - and we can see that march got dropped
144:48 - but months 2 which is a different list
144:50 - march is still there
144:56 - if i take months which was april may
144:58 - june july and add
145:00 - months
145:01 - uh i'd concatenate these two lists
145:03 - together and rebind months then i get
145:06 - more april may june july so it just it
145:08 - created a new list which was same as
145:10 - this list plus one in front of it as a
145:12 - new list
145:13 - i said that twice
145:15 - uh okay can i do this again or is this
145:17 - going to say
145:18 - doesn't support item assignment no i can
145:20 - do this because it's a list lists are
145:21 - mutable
145:23 - there we go so we fixed march
145:26 - i can append an elemented list
145:31 - i can change that element
145:35 - like this
145:37 - meaning i can add a new object as the
145:40 - last element in the list in place of the
145:42 - object that was there
145:44 - right i didn't change the string
145:46 - lowercase august to be a different
145:47 - string like there's still there was a
145:49 - string lowercase august and it got
145:51 - thrown away
145:52 - and i put a new one in its place
145:56 - dell months 2 is going to return what no
145:58 - it's going to do what to list the list
146:00 - will then be
146:01 - march
146:02 - april june july august
146:09 - okay what's this
146:12 - it's a list of lists we saw a hint of
146:14 - that when we had the 567 i think in
146:16 - there
146:17 - so it's a list with two elements each of
146:19 - which is a list of three elements
146:24 - and if i access the zeroth list i get
146:27 - the list abc
146:30 - the list one two three
146:32 - if i access this list and then access
146:35 - its zeroth element i get the one back
146:38 - okay so you can use lists of lists to do
146:41 - a two-dimensional or multi-dimensional
146:43 - array of course if you're doing anything
146:45 - that's big or you want to be fast you
146:46 - would use numpy or pandas or something
146:47 - like that instead
146:49 - but occasionally you would do that
146:52 - and any questions before you take your
146:55 - turn at the exercises
146:58 - okay go ahead
147:15 - you
148:31 - yes
149:04 - i would
149:08 - is
149:22 - is
150:21 - so
150:32 - okay i'm gonna
150:33 - continue here the first part of this
150:35 - exercise is the
150:36 - that's the most interesting stuff i
150:38 - think
150:42 - all right
150:43 - so
150:46 - remember what
150:48 - so we have a list zero one two
150:50 - m sub one
150:52 - equals is there is we're basically
150:54 - asking the list to change this
150:57 - link or the the in here that refers to
151:00 - the object one and change it to instead
151:02 - refer to that the 1020. so this 1020 a
151:05 - list 1020 is gonna replace the one
151:08 - i hope
151:08 - i did okay
151:10 - that hopefully makes sense
151:12 - uh let's put it back to zero one two and
151:14 - now what we're saying is uh let's
151:16 - replace
151:18 - what well this is saying so if we just
151:20 - pull this out if we just access this
151:22 - we're gonna get the sub list that starts
151:24 - at element or index one starts at x1 and
151:27 - stops before it gets to index 2.
151:30 - well the element that the part of the
151:31 - list which stops starts at index 1
151:34 - and stops before index 2
151:36 - is
151:37 - just the single element in there and
151:38 - here we're saying replace that sub list
151:41 - with instead this
151:43 - sub list 10 20. so we actually take the
151:46 - 10 and 20 and stick them in as two new
151:47 - elements in that list
151:50 - okay um and uh one person was asking me
151:53 - why wouldn't it be
151:54 - something else this is the way that
151:55 - python interprets it you just got to get
151:57 - used to that there's not really a wrong
151:58 - or white way to think about it python
152:00 - chose one way
152:02 - and so hopefully the way i've been
152:04 - describing the start and stop before uh
152:07 - will help you at least get get the
152:08 - bounds right which is the most important
152:10 - part
152:12 - what's that
152:16 - it's it's that's right here it's saying
152:18 - change that element to that sub list
152:20 - here it's saying please change that
152:22 - sublist to a different sub list
152:25 - yep now this isn't like unpacking though
152:28 - right if we added an extra value in the
152:31 - second and the 10 20 if we added like 30
152:33 - or like 10 up to 100 it would just
152:36 - replace the two values and then with
152:38 - however many values are in that other
152:40 - list that's right this is not like the
152:42 - unpacking earlier and in fact
152:44 - it it couldn't be in this this example
152:47 - shows that it's not because it sing it's
152:48 - a sublist of one element and we're
152:51 - replacing with a sub list of two
152:52 - elements so if you replaced it with a
152:53 - sub list of a thousand elements it would
152:54 - just slide them all over and stick those
152:56 - elements in as opposed to stick me in
152:58 - one object
153:05 - i'll skip that and these ranges i'm not
153:08 - going to cover
153:10 - uh but basically
153:11 - the same thing you can do with uh slices
153:14 - which are what these actually objects
153:16 - that get created as with that syntax are
153:19 - and range have very similar
153:21 - syntax and you can play around with
153:23 - those they're kind of complicated make
153:25 - you think hard
153:26 - maybe do some unexpected things but you
153:28 - can see you basically are saying okay
153:30 - range 101 for example we're saying start
153:33 - by default at zero and go because range
153:35 - you can have multiple arguments as well
153:37 - which i don't show you here oh yes i do
153:38 - right there right so start at zero stop
153:41 - before you get to 101 and create a list
153:45 - from uh and that that that's a range
153:47 - object and then you can access elements
153:49 - of the range object saying start at
153:51 - uh the last
153:53 - item and then count by minus 10 to get
153:56 - there as in 10 index over and stop
153:59 - before you get to element at index 1.
154:01 - that language almost all i think always
154:03 - saying it that way always will give you
154:05 - the right answer
154:11 - this argument the one
154:15 - so the first uh the slice has three up
154:19 - to three numbers uh and always a colon
154:22 - so the number before says start at start
154:24 - with the element at that index
154:27 - the second one says stop before you get
154:29 - to the element at that index
154:32 - and the last says instead of increasing
154:34 - by one increase or in this case decrease
154:36 - by a different amount
154:38 - this step exactly
154:42 - okay yep that works true okay
154:46 - so
154:47 - range
154:49 - is an object that you can iterate over
154:51 - it'll go from zero up to seven inclusive
154:53 - stop before you get to eight
154:54 - uh this is a list comprehension it has
154:56 - square brackets same syntax as a list
154:58 - but inside it's not individual elements
155:01 - it's sort of like a for loop which we
155:03 - haven't seen yet in this tutorial
155:05 - and basically you get to choose the name
155:07 - e
155:09 - and then there's a four
155:10 - ex set of names here
155:12 - in and then an expression that gets
155:14 - evaluated so e for e and range eight
155:17 - that's just going to give you
155:19 - gonna iterate over that whole range and
155:20 - give you a list of those elements
155:22 - you could do this with a for loop it's a
155:24 - little bit longer the big advantage to
155:27 - list comprehensions is they are uh
155:30 - they are a
155:31 - declaration of what you want
155:33 - as opposed to a declaration of how to
155:35 - make what you want
155:37 - right so it's a slightly higher level of
155:38 - abstractions i want to have a list
155:40 - that's that that's more like a
155:41 - mathematical expression saying this is
155:43 - what i want you know you know if you did
155:45 - create with a loop you'd have to create
155:46 - a for loop and say well i want you to
155:47 - loop over and add these things well then
155:49 - you're telling it how to do it
155:52 - you can put
155:53 - uh any expression on the left here so
155:55 - you too sorry i said you choose that
155:56 - name that's not true you choose this
155:57 - name
155:58 - this is the name that you control the
156:00 - second one so e4e in range it's just
156:02 - after the four is where you choose
156:04 - whatever name you want or multiple names
156:06 - if you're entering over something that
156:08 - can do tuple and unpacking
156:10 - or unpacking um so here i'm going to
156:13 - take the
156:14 - each of those 0 through 7 inclusive and
156:17 - multiply it by 2 and i should get back
156:18 - the list 0 to 4 up to 14
156:23 - okay
156:24 - or i can add
156:26 - i can also add an if clause afterwards
156:29 - if and then after the if comes any
156:31 - expression could be quite a long
156:33 - complicated one so only give me the even
156:35 - ones
156:39 - uh and the expression doesn't have to be
156:41 - i mean it's any arbitrary expression so
156:43 - here the expression is an f string
156:45 - all the way to that quote so it's going
156:46 - to return me that string
156:49 - evaluated
156:51 - eight times
156:53 - with
156:54 - each time through the e being zero then
156:56 - one then two all the way up to seven so
156:57 - i should give back a list of eight
156:59 - strings
157:01 - that are like that
157:04 - uh and you can buy them too you can buy
157:06 - them if you want right so here's the
157:07 - long expression for that if that and we
157:09 - get some other so
157:12 - i said like you look back here that's
157:14 - pretty easy to read this one not so much
157:17 - if i saw that in code you were asking me
157:20 - to review i'd say just make a for loop
157:21 - it's easy to read
157:23 - and that's my general advice is use list
157:26 - comprehension sparingly make sure they
157:28 - have no side effects like don't put
157:29 - print statements inside or something
157:31 - like that
157:32 - and
157:33 - usually avoid nested ones you can
157:34 - actually nest you can have a list
157:36 - comprehension that says e for e and this
157:38 - for x you can have them
157:40 - nested multiple times but they get
157:41 - pretty hard to read after a while
157:43 - question
157:50 - this one i would say for e in range 8
157:53 - colon
157:54 - well first i would have to create a list
157:56 - create an empty list before the for loop
157:58 - create the for loop and then for each
158:00 - element in the for loop if e percent two
158:04 - equals zero if it's an even number then
158:06 - i would append this element to the to
158:07 - the for the uh to the list
158:10 - what is
158:17 - so this is an f string
158:19 - f
158:20 - quote quote that's an f string which
158:22 - means it's an expression like a format
158:24 - string that's in that is evaluated and
158:27 - it looks for the e in the current name
158:29 - space which we created by say naming it
158:32 - by by using the name e in the form
158:37 - great questions
158:44 - uh so here
158:49 - here's the name that's going to have
158:51 - each time through a different value i
158:53 - don't use it at all in the expression
158:56 - right it's all kind of silly i think i
158:59 - would use uh
159:00 - easier ways to do that but but i'm just
159:01 - pointing out here's here's exactly how
159:03 - what's going on help you understand it
159:05 - hopefully
159:06 - here's some months in alphabetical order
159:08 - a comes before f comes before m well
159:10 - okay these are months these are tuples
159:12 - which include a month a month number and
159:14 - a number of days non-leap years
159:17 - okay
159:21 - if i call sorted on them it returns me a
159:23 - sorted list which is the same one
159:24 - because remember when you compare tuples
159:26 - it compares april to february then it
159:29 - compares four to two then it compares to
159:31 - 320 well never got that far because the
159:32 - a and the f and the f and the m
159:35 - it made the comparison right there it
159:36 - stopped right there and figure out what
159:38 - to what order put them in
159:39 - i can reverse the sorted
159:42 - okay
159:42 - uh element two is going to give me the
159:45 - tuple march 331.
159:48 - so here's a function
159:50 - we haven't seen a function yet in this
159:52 - tutorial but i think most of you
159:53 - probably see them before
159:54 - all right but the way it works is that
159:56 - the def starts a block you give the name
159:59 - of the function
160:00 - you give any argument you want
160:03 - and then you have the body of the
160:05 - function which is all the indented stuff
160:07 - possibly indented further and then it
160:09 - ends with the first non-indented
160:12 - line
160:13 - or when you're in the ripple like we are
160:15 - the redevel print loop
160:16 - you have to have a blank line so this
160:18 - blank line is optional in code you're
160:20 - writing in a file it's required in the
160:22 - reply because otherwise it doesn't know
160:23 - what you whether you're done or not
160:25 - right
160:26 - so get index is just going to return
160:30 - uh
160:30 - whatever you pass it
160:32 - element number one
160:34 - so if i call index
160:37 - 612.
160:38 - i don't like that name
160:44 - so this will return
160:47 - february 228
160:49 - right
160:50 - zero one two it's asking for one
160:55 - so get index one is going to return
161:00 - element at index one of months sub two
161:03 - well month sub two is march 331
161:06 - index element one is going to be
161:09 - three
161:11 - right and i realized i just made it all
161:13 - to myself month is a bad name here
161:15 - because it's anything it doesn't have to
161:17 - be a month
161:18 - um
161:19 - let's import the operator module
161:21 - and use this item getter
161:23 - operator item getter
161:26 - built in sorry the function in there so
161:29 - if
161:30 - item getter is a function that you pass
161:33 - it an argument and it returns a function
161:39 - who here finds that kind of hard to
161:40 - think about a function that returns a
161:42 - function
161:43 - come on come on be honest yeah it is
161:45 - hard to think about um when i started
161:47 - using python that was one of the things
161:49 - that for me was hard to think about it
161:50 - took me a while to get used to it and
161:52 - decorators were like
161:54 - because they're functions that return
161:56 - functions or callables that return
161:57 - functions um
161:59 - most of them are well
162:01 - yes most of them are um unless it's a
162:04 - decorating a class then it's a
162:05 - functioning class anyway
162:07 - the point is this is kind of hard to
162:08 - think about but
162:09 - it's just a simple way to write a
162:10 - function right
162:11 - like this is one way to write a function
162:13 - that returns whatever you pass it it
162:15 - accesses index element one and returns
162:17 - that part of it
162:18 - this is another way to create the same
162:21 - function object no an equivalent
162:22 - function object
162:24 - right and the way i give it a name here
162:26 - is i do a def get index the way i give
162:28 - it a name here is i just say equal or
162:29 - whatever that thing is whatever that
162:31 - object is that gets returned which i
162:32 - know is a function object because that's
162:34 - the documentation item getter says give
162:36 - it the name and get it x1
162:38 - and then it just works same way okay
162:41 - this is a a common thing you'll see in
162:43 - python is
162:45 - functions returning functions functions
162:47 - that take functions as callbacks have
162:49 - you seen that before in python
162:51 - give me an example
162:54 - oh no sorry i i that was a trick
162:56 - question and it was the trick was on me
162:58 - sorted is one but we've seen sorted only
163:00 - with reverse equal true which is not a
163:02 - function you can call sort with a key
163:03 - function and a comp function so that's
163:05 - actually sort and sorted or another one
163:07 - that can take a callback function so
163:09 - sorry about that trick on me
163:13 - so if i call get index 1 of months sub 1
163:17 - i'm going to get
163:19 - 2 right there's month sub 1 that object
163:23 - i pass it to get in x1 it's going to
163:25 - return me index 1 of that object
163:28 - there we go
163:31 - get so
163:32 - do i need to give it a name in order to
163:34 - call it no i can just take that
163:37 - and stick it right in place of that so i
163:38 - take so so again it's kind of
163:40 - complicated what's going on here is
163:42 - python looks up this module name which
163:44 - was imported so it's in my namespace it
163:46 - accesses the object that's got the name
163:48 - item getter which is a function i call
163:50 - it with the integer object one it
163:52 - returns to me a function and i call that
163:55 - function passing it that thing and it
163:57 - gives me back something
163:59 - okay
164:00 - so that works just as well
164:02 - so there's the foreshadowing to what i
164:06 - was trying to get you to say here is a
164:08 - function
164:09 - sorted
164:11 - that takes a function
164:13 - as an argument
164:16 - and what it does is
164:17 - this is one of the ways uh one of
164:19 - there's several ways in python to take
164:20 - some existing code
164:22 - uh which either was by design or by
164:25 - accident uh somebody wants to
164:28 - let me rephrase that sorted was designed
164:30 - so that you could change its behavior
164:31 - without having to go in and change the
164:33 - sorted module or the sorted function in
164:35 - a module in python you don't have to
164:36 - edit the sorted
164:38 - function
164:39 - you can just change its behavior by
164:41 - giving it a key function so what sort
164:44 - does is it takes the two things coming
164:46 - in
164:47 - and
164:48 - i don't know if this is exactly what it
164:49 - does but you know what say oh how long
164:51 - are they okay well let me start marching
164:52 - through them let me compare the first
164:53 - two and see which one's smaller
164:55 - but it actually doesn't do that what it
164:57 - does is it says okay let me compare the
164:59 - first two to see which one's smaller but
165:00 - only if they didn't pass me a key
165:02 - function if they passed me a key
165:03 - function then i'm going to take those
165:04 - two objects call the key function on
165:07 - both of them and get something else back
165:09 - and i'm going to pair i'm going to
165:10 - compare those two objects to see which
165:12 - one is smaller
165:14 - okay that's what's going on here so if
165:18 - and then so what what sort is going to
165:20 - do with this key callback function is
165:23 - it's going to call this
165:24 - function
165:26 - on
165:28 - those objects like the march 331
165:31 - and then what it gets back which is the
165:33 - three is what it's going to do to do its
165:34 - comparison and sort
165:36 - the original
165:37 - list
165:38 - right so this is going to sort by month
165:40 - name oh sorry month number so now
165:42 - february comes before march comes before
165:43 - april
165:44 - and of course we don't need to use the
165:46 - git index we can use the on
165:47 - operator.item getter
165:49 - so
165:50 - sorted months key equals operator i'm
165:52 - getter one that's code
165:54 - that you might see
165:57 - that kind of code exists a lot in a lot
165:59 - of python code and now
166:01 - even better than before hopefully you
166:03 - know how to read it and what it's doing
166:05 - okay
166:07 - and if you want to sort on something
166:08 - else well
166:10 - you could do uh
166:12 - actually this we could sort on first
166:14 - item getter01 actually returns uh
166:27 - i had a note to fix this and i didn't
166:29 - uh this is yeah let's skip that because
166:31 - it's kind of confusing let's just
166:32 - imagine i'm not going to type it for you
166:34 - but if you change item getter 1 here to
166:35 - item carrier 2 and it would sort by the
166:38 - number of days instead
166:41 - and let's skip those two
166:44 - and we'll skip that one as well
166:46 - okay
166:47 - sorry about that so your turn to do some
166:49 - exercises oh question first instead of
166:53 - using operators
167:02 - no you could use a lambda
167:04 - using operator.itemgater i would use
167:06 - because it's built-in library people
167:08 - know what it is if they're familiar with
167:09 - it they understand it right away they
167:10 - don't have to parse my lambda and i'm
167:12 - not going to get my lambda wrong because
167:14 - i won't be using it
167:15 - right
167:17 - what's that
167:20 - yep yep they have limits you can't do as
167:22 - much as with others but yeah i would i
167:24 - would yes a lambda function would work
167:26 - fine in that case i would recommend use
167:28 - the built-in because it's well known and
167:29 - someone else already got it right
167:32 - that's all okay other questions
167:35 - okay go ahead and take some time working
167:37 - on the exercises
168:01 - you
169:48 - yes
170:35 - okay
170:37 - let's look at the exercises here
170:40 - splits pretty easy
170:42 - m for m just to simple this
170:43 - comprehension
170:46 - so here
170:47 - i'm using a nested four 4n in range 3 4m
170:50 - in genmar split so i get this more
170:53 - complicated thing
170:56 - you know i suggest avoid them but be
170:58 - aware you can do that if you want to
170:59 - enumerate's a kind of cool
171:01 - it's a very useful function especially
171:03 - in python in languages where you always
171:05 - have to remember the index to iterate
171:07 - through things
171:08 - this is why would you have enumerate in
171:10 - python usually you iterate over
171:11 - iterables without remembering the index
171:13 - because python does it for you but
171:14 - sometimes you actually want to know well
171:16 - how far am i am i at index 50 when i do
171:18 - this
171:19 - um and enumerates the easy way to do
171:21 - that basically enumerate
171:24 - as you can see
171:25 - it takes an iterable
171:27 - consumes it and
171:29 - it returns in turn pairs
171:33 - an iterable of pairs where the pair is
171:36 - 0a
171:37 - 1b 2c okay
171:40 - and you can of course
171:41 - change what happens like once you've got
171:43 - that end in the c you can change it
171:45 - there and by the way this parenthesis
171:46 - here is these parentheses there are
171:48 - optional but
171:49 - i think it's a little bit easier to read
171:51 - zip is another cool function which uh
171:54 - very much like a
171:56 - zipper but not quite a zipper
171:58 - right
171:59 - interleaves the zip function doesn't
172:01 - interleave it does pairs
172:03 - that's the way it works um and so zip
172:06 - you can take
172:08 - a zip pass it two arguments and it will
172:11 - pair up the jan the one the fab the two
172:13 - the more the three if you pass the three
172:14 - arguments it'll give you triples et
172:15 - cetera and then
172:17 - zip
172:18 - returns an object which is iterable so
172:20 - we hand it off to list so actually we
172:21 - can see it
172:23 - what it looks like and there we get that
172:24 - list
172:28 - so
172:30 - what do you think will python give us an
172:32 - error in this case
172:33 - we've got three on the left and four on
172:36 - the right the second argument to zip and
172:37 - the answer is no zip will happily stop
172:39 - when it exhausts the first of its
172:42 - arguments as an iterable sort of like
172:44 - the m100 it just that's fine i'll stop
172:47 - before i get to 100. um if you wanted to
172:49 - stop there's an itertools.zip
172:51 - longest
172:52 - in the inner tools module um
172:56 - i don't remember that may not be the
172:58 - right name but it will stop when it gets
173:00 - to
173:01 - one of them
173:06 - and then only one two three
173:07 - same
173:08 - the lowest stop the shortest one
173:10 - um and and again that is can be i've
173:12 - used that lot it's convenient when for
173:15 - example
173:16 - i don't really care
173:17 - uh like i have several of them and i
173:19 - don't i don't even i want to maybe add
173:21 - an index to one of them and i don't know
173:23 - how many i'm going to have i'll just put
173:24 - in place of the last of the one i want
173:26 - the index to be i'll do a range from
173:28 - zero to accent
173:30 - it'll only evaluate as many as it needs
173:32 - and it'll stop when it's done
173:33 - so that'd be an example of where it's
173:34 - handy to have that functionality
173:39 - so there's another way to create that
173:40 - list that was created earlier right is
173:42 - you could take there's the zip of three
173:44 - elements
173:46 - and you can see i'm combining the split
173:47 - stuff like that of course here's another
173:49 - way to do it oh and here i put in look
173:51 - at that there's the range 100 just like
173:52 - i said
173:53 - and it stops when it gets the shortest
173:55 - one
173:57 - and there's a something i want you to
173:59 - try solve
174:00 - and another one
174:01 - and this one we talked about a little
174:03 - bit about
174:07 - i'm going to skip most of these
174:09 - five minutes right can we end at 4 40.
174:12 - all right so dictionaries and cents i'm
174:13 - not going to quite get through the rest
174:14 - of it which is
174:15 - typical i usually i put in more content
174:17 - to make sure you can go look at it
174:19 - afterwards dictionaries are a really
174:22 - important helpful data type in python
174:25 - a list is
174:27 - actually a mapping is one way to think
174:29 - about like remember math venn diagram
174:31 - venn diagram dots in it the arrows that
174:34 - map from a to b
174:36 - that's what i mean by mapping uh in a
174:38 - list maps from
174:39 - integer zero to the first element
174:41 - integer one to the second element
174:44 - element at index one integer two
174:47 - et cetera
174:48 - and so here's an example of
174:51 - right so if i take jan feb mar well
174:53 - that's i want i'd really like jan to be
174:55 - index element one so i put a none in
174:58 - front of it
175:00 - or i could use that in python three or
175:02 - five or greater using that that uh
175:04 - syntax now i've got
175:08 - zero one two three which is convenient
175:11 - for me because one
175:13 - two three are the month numbers as i
175:14 - think about them all right so now i can
175:17 - map it i can say well give me uh take an
175:19 - in to turn it into a month
175:21 - and i get back jan is one
175:24 - number two is jan sorry number one is
175:25 - jan number two is that
175:28 - a dictionary is a one-to-one mapping
175:30 - from anything almost it's got to be
175:32 - hashable i'm not going to cover that
175:34 - today
175:35 - to any other thing so
175:37 - instead of
175:39 - assuming the index value or the key
175:41 - value of 0 1 2 3 et cetera here i have
175:44 - to explicitly state it and i can use
175:46 - integers if i want so here i'm saying
175:48 - map one to jan two to fab three tomorrow
175:51 - and then i can just say into month one
175:53 - two three and it works so dictionary is
175:55 - uh more powerful in terms of the more
175:57 - things you can do with it it's also much
175:59 - uh
176:00 - it's very fast for uh for searching and
176:03 - finding things in it
176:06 - um
176:09 - okay i could do that too instead of
176:11 - explicitly doing the mapping i can do
176:14 - a dictionary comprehension i think is
176:16 - what it's called so i sort of looks like
176:18 - a list comprehension but it kind of
176:20 - looks like a dictionary with a curly
176:21 - brace and a colon with the key
176:24 - and the value and these are variables
176:26 - that are iterated over
176:28 - the change through that iteration so
176:30 - that's another way to do it
176:33 - and then i can just access it right
176:34 - month to int so here i'm doing month to
176:36 - instead of into month right and so i've
176:38 - got january is month one etc
176:42 - april is four
176:43 - no it's not there
176:45 - okay let's add it
176:46 - so this is how you access elements of a
176:48 - dictionary use the square brackets just
176:50 - like a list and you pass it the key
176:53 - which doesn't have to just be an int it
176:54 - has to be whatever key you've defined
176:56 - the dictionary to have
177:00 - and you can see it now has an april over
177:02 - there on the end
177:08 - in for dictionaries is asking the
177:11 - question is this key in the dictionary
177:13 - is there a key value pair in the
177:14 - dictionary with this key
177:18 - here's how you would delete an element
177:19 - from the dictionary you give it the key
177:21 - and it'll delete that
177:23 - you can't ever have two
177:25 - uh
177:26 - duplicate keys
177:28 - so you don't have to worry about how to
177:29 - figure out which one to remove there's
177:30 - only going to ever be one key feb in the
177:32 - dictionary that's one of the constraints
177:35 - just like months you can't have two
177:37 - elements at index one there's only one
177:40 - element there
177:41 - okay
177:42 - is february in there not anymore
177:44 - okay
177:46 - uh
177:47 - do a couple
177:49 - things here
177:51 - how to use dictionaries dictionaries are
177:53 - one of the data structures in python
177:55 - that if you haven't had them in
177:56 - languages you've used before
177:58 - you will find yourself not reaching for
178:00 - them until you get to know them and then
178:02 - you'll find yourself reaching for them
178:03 - all the time
178:04 - so for example if you want to know how
178:06 - many letters there are in
178:09 - what are the letters in mississippi here
178:11 - would be a way to do it
178:15 - so what i'm done letters is going to be
178:18 - a dictionary with
178:20 - key m
178:21 - we'll have one
178:24 - what's that
178:26 - no
178:27 - no i i'm looking for what letters are in
178:29 - mississippi
178:30 - right so
178:32 - so
178:33 - s is going to be set to one four times
178:37 - no we're not counting letters we're just
178:38 - saying what are the letters in
178:39 - mississippi okay
178:41 - uh or i can just look at the keys and i
178:43 - get back this data structure that i can
178:45 - iterate over that shows me those are the
178:46 - letters
178:49 - here's another way to do the same thing
178:51 - using addictive comprehension
178:53 - there is a
178:55 - collections module
178:57 - in the standard library that has a
179:00 - default dict you can pass it a function
179:04 - and it will
179:06 - add elements to a dictionary
179:09 - on the fly
179:11 - so
179:12 - earlier with a regular dictionary this
179:14 - would give me a key error with a default
179:16 - dict it doesn't
179:18 - it gives me
179:19 - a zero because it says oh i can't find
179:21 - it so i'll call this function to figure
179:22 - out what to put in its place added the
179:24 - key value pair and now it's in there so
179:26 - this one i could do what you were
179:28 - getting at which is let's count them
179:31 - right
179:33 - and i get the letter count
179:39 - right
179:40 - so it added letters as needed and
179:42 - incremented them so the first time it
179:44 - saw the m it stuck in well that's a bad
179:46 - example first time it's because i
179:48 - already did it up here first time i saw
179:50 - the i it stuck it in as zero and then
179:52 - incremented it made it one next time it
179:54 - pulled it out as it won increment it to
179:57 - two put it back in etc
180:00 - and then you can look at how many of the
180:02 - letters are in there
180:04 - there's also a collections counter that
180:05 - will do this for you
180:07 - and a bunch of other things and if you
180:09 - only care about the keys like we did in
180:10 - the first example well there's a simpler
180:13 - way to do it there's a set built-in type
180:16 - and you can also create sets with a set
180:18 - literal like that looks kind of like a
180:19 - dictionary with curly braces but has no
180:21 - colons because you only care about the
180:22 - keys
180:23 - and then you can do various operations
180:25 - mississippi hero you're all familiar
180:27 - with the ascent of boyne it's in my
180:28 - backyard so one of the two rivers that
180:30 - runs through winnipeg
180:33 - here's another way to do the same thing
180:34 - but set operations are pretty handy at
180:36 - line 687
180:39 - and lots of set operations okay
180:43 - so i can put almost anything in a
180:45 - dictionary key but not quite everything
180:48 - and
180:50 - i won't be able to explain why but but
180:51 - it's basically because they have to be
180:53 - hashable because if they weren't i'm
180:54 - about to explain why uh then if you when
180:57 - you change the key you can change the
180:59 - contents of a list then when it goes to
181:01 - hash it look it up fast it would find it
181:03 - in the wrong place or not find it
181:04 - because it would look in the wrong place
181:06 - okay
181:08 - so
181:09 - what i did not get to show you
181:13 - was an example with dictionaries which
181:15 - is kind of cool
181:16 - blocks and for loops
181:18 - iterators and generators and a little
181:20 - bit about imports calling functions etc
181:22 - so we got through a fair chunk of this
181:24 - tutorial and i hope it was helpful
181:27 - um please please please please fill out
181:30 - the
181:31 - evaluation forms
181:33 - give me feedback afterwards i'm happy
181:35 - with for that as well
181:37 - and
181:37 - hope you enjoy using python
181:43 - [Applause]
181:56 - functionality