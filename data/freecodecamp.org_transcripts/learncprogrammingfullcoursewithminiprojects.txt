00:00 - this comprehensive C course will take
00:02 - you from the basics of C programming to
00:04 - advanced concepts all while integrating
00:07 - exciting mini projects to solidify your
00:09 - learning this course offers a structured
00:12 - path through essential topics such as
00:14 - syntax object oriented programming data
00:16 - structures and more ABA teaches this
00:19 - course and he will help you understand C
00:21 - both theoretically and also gain
00:24 - practical experience in applying your
00:25 - knowledge to real world scenarios hey
00:28 - there free Corum ABA here join me in
00:30 - Walking you through everything you need
00:32 - to get a setup with cop let's have a
00:34 - quick walk through the course contents
00:35 - to let you know what to install for you
00:37 - we'll start with installing the visual
00:38 - studio program required to develop cop
00:40 - applications you'll learn about data
00:42 - types including integers strings and
00:44 - many more and how to manipulate them
00:46 - inside your code next we'll dive into
00:48 - control flow you'll discover how to use
00:50 - conditional statements and Loops to
00:51 - control the flow of your program's
00:53 - execution strings are essential in many
00:55 - applications you'll Master powerful
00:57 - string functions in C allowing you to
00:59 - manipulate and transform Text
01:01 - effortlessly data structures are crucial
01:03 - for organizing and managing data from
01:05 - arrays to collections you'll explore
01:07 - various data structures in C and learn
01:09 - how to use them effectively functions
01:11 - are the backbone of any program you'll
01:13 - uncover the power of functions in C
01:15 - including how to create and call them to
01:17 - organize your code no program is immune
01:19 - to errors you'll learn how to handle
01:21 - exceptions gracefully in C ensuring that
01:23 - your applications remain robust and
01:25 - reliable debugging is a crucial skill
01:27 - for any developer you'll discover how to
01:29 - use visual Studio's powerful debugging
01:31 - tools to identify and fix bugs in your C
01:34 - code efficiently finally we'll delve
01:36 - into objectoriented programming you'll
01:38 - learn the principles of object-oriented
01:40 - programming how to use classes objects
01:42 - inheritance and polymorphism to create
01:44 - modular and maintainable code by the end
01:46 - of this course you'll have a solid
01:48 - understanding of C programming and be
01:50 - well equipped to tackle a wide range of
01:52 - software development challenges thanks
01:54 - for tuning in let's get
01:56 - started so in order to start developing
01:58 - with C we need to install install the
02:00 - latest version of visual studio in this
02:01 - case it's currently 2022 so let's head
02:04 - over Google and type in Visual Studio
02:06 - 2022 download we will be presented with
02:08 - two links we have this one and this one
02:11 - we want to use a second one which says
02:12 - download visual studio tools so if you
02:14 - press on that and now we present it with
02:16 - the download area we have three
02:18 - additions Community professional
02:20 - Enterprise Community is free for
02:22 - students open source contributors and
02:24 - individuals which is exactly what we
02:25 - need for the content of this course we
02:27 - have the professional Enterprise Edition
02:29 - which paed for and only used by bigger
02:31 - companies or smaller teams so let's go
02:33 - ahead and press free download the
02:35 - download will start straight
02:37 - away after the download is complete
02:39 - let's start the installer so double
02:41 - click on the executable and press yes to
02:43 - allow it for admin permissions it'll pop
02:45 - up like this Visual Studio installer
02:47 - before you get started we need to set up
02:48 - a few things you can configure your
02:50 - installation you can read the privacy
02:52 - policy in the software terms if you'd
02:53 - like or you can just press continue so
02:55 - it's getting the visual studio installed
02:58 - already so so when you get to this
03:00 - section everything here is all the
03:01 - different packages and tools you can
03:03 - install within Visual Studio 2022 the
03:06 - main one that we're concerned within the
03:07 - content to this cause is the neck
03:09 - desktop environment so you can go ahead
03:11 - and press this one it will then tell you
03:13 - in the bottom right hand corner the
03:14 - total space required is 6.52 GB please
03:18 - make sure you have enough storage space
03:20 - available for this and then you can go
03:21 - ahead and press install if you want to
03:23 - check out other packages you can have a
03:24 - scroll through and read any other
03:26 - packages you may need and may want to
03:28 - install like I said the the only one
03:30 - required for this course is the net
03:31 - desktop environment you can also deal
03:34 - with noj development python development
03:36 - web
03:36 - development if you need to deal with
03:38 - individual components like specific
03:40 - versions you can access it here if you
03:42 - need some more languages installed you
03:44 - can access it here this should
03:45 - automatically select your default
03:47 - language for you that's based on your
03:48 - systems language and if you want it to
03:51 - you can also change the installation
03:52 - location in case you want to install it
03:54 - on a different drive or you just want it
03:56 - in a different folder so now that we
03:58 - selected the neck desktop environment
03:59 - ment we can go ahead and press the
04:01 - installation button we do have two
04:03 - options down here we have it install
04:05 - while downloading and it download all
04:06 - then install if you have a reasonably
04:09 - fast computer you can stick with the
04:10 - install while downloading and it will do
04:12 - the installation and the downloading at
04:14 - the same time if you have a slow
04:16 - computer it's preferred that you use
04:17 - this option to download it first and
04:19 - then install it just means that it won't
04:21 - slow down your computer too much so you
04:23 - can go for this one and press install
04:26 - now the installation will begin so now
04:28 - that visual studi finish installing it
04:30 - will say done installing Visual Studio
04:32 - has been successfully installed we
04:34 - recommend rebooting soon to clean up any
04:36 - remaining files so this just means
04:37 - restart on your computer just so it has
04:39 - a chance to clean up any files that were
04:40 - kept during the installation process so
04:43 - we can just press okay if you have any
04:45 - other versions of Visual Studio
04:47 - installed they'll also show up down here
04:49 - now that Visual Studio Community 2022 is
04:51 - installed we can just press
04:55 - launch so now it'll prompt you to sign
04:57 - into Visual Studio we should definitely
04:59 - sign in but just for now I'm going to
05:00 - skip but feel free to create an account
05:02 - or sign in if you already have one
05:04 - existing we can skip this and then we
05:06 - get to choose your theme I personally
05:08 - prefer the Dark theme but you can go
05:09 - with blue blue extra contrast or the
05:11 - light mode so let's select dark and hit
05:13 - start Visual Studio it will do a first
05:16 - time
05:17 - setup and it's already done and we're
05:19 - already inside Visual Studio 2022 so
05:22 - that's it for the visual studio
05:25 - installation so now that we got Visual
05:27 - Studio 2022 installed let's let's see
05:29 - how to create your first project so once
05:31 - you've opened Visual Studio 2022 you'll
05:33 - see this window popping up you can clone
05:35 - a repository from things like GI Hub in
05:37 - as you devops or open a project that you
05:39 - already have or open a folder which may
05:42 - have projects inside or you can create
05:43 - one from scratch if you don't want to do
05:45 - any of these options you can just open
05:47 - the visual studio program just on its
05:49 - own by clicking continue without code so
05:51 - let's go down the create a project path
05:53 - so click on create a new project and
05:54 - we'll get a list of all these different
05:56 - projects inside our system to be able to
05:58 - use the ones we going to be focusing on
06:00 - on this course is going to be C in the
06:02 - languages dropdown box and the platform
06:04 - is going to be windows and the project
06:06 - type is going to be console and they
06:09 - have one that uses net core which is for
06:11 - Linux Mac and windows and one that uses
06:12 - the Net Framework which is Windows so we
06:15 - want to go for this one so press on this
06:17 - one and then press
06:18 - next here we have our project name our
06:21 - location and our console app so we can
06:23 - start with the project name and say my
06:26 - first
06:27 - project as you can see it start copying
06:30 - over to the solution name as well and it
06:31 - tells you where the project will be
06:33 - created into so I'll be creating a
06:34 - folder called my first project which is
06:37 - the solution name plus my first project
06:39 - which is the project name inside that
06:41 - folder if we change the solution name
06:43 - you'll see update you can see here now
06:45 - we have multiple T's because we appended
06:47 - the solution name the solution name is
06:49 - almost like a folder that holds lots of
06:51 - projects inside so to begin with we'll
06:53 - have one solution that has one project
06:56 - inside and then later on in the course
06:57 - if you feel like you want to add more
06:59 - project projects to it you can just add
07:00 - more to this solution so let's get
07:02 - started and press
07:08 - create so now we've created our very
07:10 - first project and just to explain what's
07:12 - here we have a static main void which is
07:15 - the main entry point to our program if
07:17 - you do a lowercase M then the system is
07:19 - not going to recognize this main
07:21 - function because the down NET Framework
07:23 - requires this function to be found in
07:24 - order to run a c console app and you can
07:27 - see here in the errors the program does
07:29 - not contain a static main function and
07:32 - you can see it's capital M and C
07:34 - programming language is K sensitive so
07:36 - make sure to include it so now you
07:38 - understand how to use Visual Studio 2022
07:40 - to create a project and also know where
07:41 - the main entry point is in C let's get
07:44 - started with Hello World example to kick
07:46 - off this
07:48 - course so as we know our main entry
07:50 - point to our application is the static
07:52 - void main if we go inside here and press
07:54 - enter then we can actually start writing
07:56 - some code inside here just a quick note
07:59 - before we
08:00 - continue static void main is inside the
08:03 - class program and the class program is
08:06 - inside the namespace hello world and the
08:08 - reason why you can tell this is because
08:10 - of the curly braces the curly braces of
08:12 - hello world begins here and ends here
08:15 - and Within These curly braces we have a
08:17 - class program and also within the class
08:19 - program we have the styo
08:22 - men so just between these curly braces
08:25 - we want to type console. right line open
08:29 - the brackets and we can type in some
08:31 - speech marks and we can simply Type
08:33 - Hello
08:34 - World there you go so as you can see now
08:37 - system has actually been highlighted so
08:40 - if we just delete this
08:42 - line you can see now system has been gr
08:44 - out and the reason why is it says it's
08:46 - unnecessary because it hasn't been
08:50 - used so if you undo it then this comes
08:55 - up because I showed you before that
08:57 - console right line is actually within
08:59 - the system Library what happens if we
09:01 - delete
09:02 - it if we delete it then it doesn't know
09:05 - where console exists from and because
09:07 - that just said system we can actually
09:09 - just use system. console. right line and
09:12 - then open the brackets and type in hello
09:14 - world and now this works again and the
09:17 - reason why this works it's because we
09:19 - don't have to Define that we're using
09:21 - system we could just use it straight in
09:24 - here if you have multiple lines like
09:27 - this then you don't want to be using
09:28 - syst right at the start ideally you want
09:31 - to have the reference to it at the top
09:32 - of the screen and then use it
09:35 - throughout so now that we've included
09:37 - back in the project you can see that now
09:39 - these have turned gray and it says that
09:41 - it can be simplified if we press the
09:43 - light bulb and we can say simplify
09:45 - member and it doesn't really matter
09:47 - because we can just delete the rest now
09:50 - so now that we've WR hello world let's
09:51 - press F5 which is a shortcut to the
09:53 - start
09:55 - button as you can see well you couldn't
09:58 - really see because the program closed
09:59 - too quickly and the reason for that is
10:02 - printed hello world to the console and
10:04 - then it didn't do anything else CU
10:05 - there's nothing else for it to do so the
10:07 - console simply
10:08 - closed we can use another command called
10:12 - console read Line open the brackets and
10:14 - close the brackets and have a semicolon
10:16 - at the end all this does is it waits
10:18 - here until the user inputs something
10:21 - reads the next line of characters from
10:22 - the standard input
10:25 - stream so although the program will
10:27 - actually be reading stuff we you just
10:29 - want this line to stop the application
10:31 - from closing so now if you press F5 and
10:33 - run the program you can see it actually
10:35 - says hello world and it's just waiting
10:37 - here
10:38 - flushing and this flashing means it just
10:41 - started this console read line so it
10:42 - doesn't matter what we type into here it
10:44 - just waits for us to press enter and as
10:46 - soon as we press enter this line
10:48 - executes and the program finishes
10:50 - congratulations you just wrote your
10:52 - first C program welcome to the amazing
10:55 - journey of
10:56 - programming so let's look at how to make
10:59 - variables in our C codee let's start
11:01 - every code with a console read line and
11:04 - then we can hit F5 just to make sure our
11:06 - console doesn't
11:07 - close so let's begin with an integer so
11:11 - integers are whole numbers so we can
11:13 - just say int age equals
11:15 - 23 so what we've actually done here is
11:18 - we've said we want an INT we want to
11:20 - call it age already made it equal to
11:24 - 23 this is called initializing and
11:27 - declaring in the same line line so what
11:30 - you could do alternatively is you can
11:31 - end the semicolon here and it just says
11:33 - int Edge and then on the next line you
11:36 - can write ede equals 23 so this is
11:39 - declaring it in the first line and then
11:40 - give it an initial value in the second
11:42 - line if they're right underneath each
11:44 - other like this case then you may as
11:46 - well just make it together because then
11:48 - you have less lines of code the reason
11:49 - why it says it's a green under line it's
11:51 - because there the unnecessary assignment
11:53 - because we're not actually using age so
11:55 - let's just print ede to the console if
11:57 - we make some new lines and we can type
11:59 - in console. right line and then press
12:01 - tab to finish it we can write Edge and
12:04 - if we run our code using F5 we can see
12:07 - that 23 gets print out to the
12:09 - screen so now that we've worked on the
12:11 - Edge Let's explore all data types so
12:14 - let's define a long variable so let's
12:15 - start with the type long followed by
12:18 - space and then the variable name that we
12:19 - want and let's add equals and type in a
12:22 - very big
12:23 - number so now if we hover over it it
12:25 - says it's a system int32 and int32 2 is
12:29 - actually an integer but we're telling it
12:31 - it's a long which makes no sense we have
12:34 - an in 64 here but when we hover over the
12:36 - number it comes up as
12:38 - n32 and the reason for that is when C
12:41 - sees that you just have a number typed
12:43 - in like this it will always assume that
12:45 - it is an integer to tell the compiler
12:48 - that you indeed want this to be
12:49 - processed as a long number then you can
12:51 - put a capital l right at the end now if
12:54 - we hover over it it says
12:56 - N64 and this says in 64 so so now we've
12:59 - got it working and we've got the long
13:01 - there so now we can take another console
13:03 - right line and just print this out to
13:04 - the screen and just a helpful tip if you
13:06 - type in CW and press tab twice then you
13:09 - get the console right line it's very
13:11 - easy to write your code and then you can
13:13 - type in big Follow by a tab and it'll
13:15 - come up straight away so as you can see
13:17 - they're both being printed to the
13:18 - console
13:19 - now so now that we've made positive
13:21 - numbers we can also make these negative
13:24 - by simply just putting a negative sign
13:26 - behind them there we go and just to show
13:29 - you how big these numbers are what we
13:31 - can do we can type in int. max value and
13:34 - then make another one using contr D and
13:36 - type an int. Min
13:38 - value so you can see integers can be
13:41 - positive 2.1 billion or negative - 2.1
13:46 - billion and if we do the same for
13:52 - long you can see that long is a very
13:55 - very big number because instead of being
13:56 - an INT 32 it's an int64 which takes up a
13:59 - lot more memory so now we've covered
14:02 - whole numbers let's have a look at
14:04 - decimals so we can have a double
14:07 - negative for example and we can say it's
14:09 - minus
14:10 - 55.2 and in this case when you just have
14:13 - a number typed in like this and it's got
14:15 - a decimal point in it it will always
14:17 - register it as a double but just to make
14:20 - sure just as we're doing with the long
14:22 - you can actually just put a capital D at
14:24 - the
14:25 - end now if we print this out to the
14:27 - screen and also print out how big these
14:30 - numbers can
14:31 - be max value and Min value and print
14:36 - this out so we get our minus 55.2 and
14:39 - you can see that these numbers can be
14:40 - very big e + 308 means it's this number
14:45 - times by 10 to the^ of 308 which is a
14:48 - very big number and we also have that as
14:51 - a negative so we have float let's call
14:53 - this precision and make equal
14:57 - 5.1 and then put a semic call at the end
15:00 - now we've got a problem here this is
15:01 - trying to register as a double but we
15:03 - don't want to register double we want to
15:05 - register as a float and this is the same
15:07 - issue we have the long so when you type
15:09 - any number that has a decimal point in
15:11 - it the C compiler will always register
15:13 - as a double the same way when you type
15:15 - in a whole number it'll always register
15:17 - as an INT so in this case we need to put
15:20 - a capital f at the end and it'll process
15:22 - this as a
15:24 - Flo so now we can print this
15:27 - out and then let's just print out the
15:29 - max values and the Min values just to
15:33 - show you what that looks
15:34 - like so as you can see here we have our
15:36 - number printed out and again we have
15:38 - quite a big number 3.4 * 10 to the^ of
15:42 - 38 so again it's a big number and we
15:44 - have that positive and negative so quite
15:46 - a big range of
15:48 - numbers and the last one we're going to
15:50 - cover is decimal for things like money
15:53 - and currency
15:55 - 14.99 and again in this case it's trying
15:58 - to assign a double into a decimal so in
16:01 - order to denote what a decimal is you
16:03 - can put a capital M right at the
16:05 - end and for one last time let's print
16:08 - out the
16:09 - money and the decimal. max value contrl
16:13 - D and then we'll do Min
16:17 - value and you can see here that this is
16:19 - a really big number as well and it's
16:21 - even bigger than the
16:23 - long so we have our number printed and
16:25 - the Max and the minimum values so now
16:27 - that we've understood that how to
16:29 - declare a variable I have an extra
16:31 - little tip for you so if we had three
16:33 - variables int X and int Y and in in Z
16:38 - and let's say you're always going to
16:39 - declare them together like this you can
16:41 - actually miss out and do X comma y comma
16:44 - Z and that will do exactly the same
16:47 - thing there you go and that's really
16:50 - neat and it's a lot better let's say for
16:52 - example you had these variables but you
16:55 - actually had them set to something like
16:56 - equals 10 = 20 = 30 this is still
17:02 - practical but it might look a little
17:04 - uglier so you can actually type them in
17:06 - straight into here and if you comment
17:09 - these out again then it still works you
17:12 - can even put these onto new lines like
17:13 - this just so it looks a bit neater just
17:16 - prevent you from typing the additional
17:18 - int each time if they're all going to be
17:20 - the same variable type so that's it for
17:22 - the numbers inside our code so let's
17:24 - just have a quick recap so in order to
17:27 - Define a variable you want use the data
17:29 - type in this case an integer followed by
17:32 - the variable name and then you can
17:33 - either add a semicolon at that point or
17:36 - you can add a equals to give it a value
17:38 - this is just called declaring a value
17:40 - and this is called initializing a value
17:43 - if you want to decide you want to change
17:44 - the variable further down your program
17:47 - for example age equals 50 here then this
17:50 - is fine and this is now called an
17:53 - assignment it's called initialization
17:56 - because as soon as you make it you give
17:57 - it a value value and then in later on in
18:00 - the code if you give it another value
18:02 - this is called simply assigning a value
18:04 - this is just called assigning it a
18:08 - value so now that we can store numbers
18:10 - in C let's see how we can store
18:12 - characters and letters so as you know
18:15 - from the introduction we have a string
18:16 - variable so let's call that name and
18:19 - make it equal to
18:20 - Aba please note that when you're
18:22 - defining a string and giving it a value
18:25 - that this value needs to be in speech
18:28 - mark if you put it in quotation marks it
18:30 - will not accept this because that's the
18:32 - notation to declare a Char which we'll
18:35 - get on to next so on the next line we
18:37 - can do a Char letter equals and we can't
18:40 - have something like this because the
18:42 - Char will only accept One Singular
18:44 - character so we have to wrap it around
18:46 - the quotation mark once you've wrapped
18:49 - it around the quotation mark then it
18:50 - will accept it so let's print these two
18:52 - to the screen so CW tab tab and we can
18:56 - just print these to the screen and if we
18:58 - just run the code you can see that we've
19:00 - got the values entered in
19:03 - here we can start to write
19:05 - stuff your name
19:08 - is and then we can output this and we
19:11 - can also put it on one
19:13 - line if we do a console right and a
19:16 - console right then maybe we can take the
19:18 - callon off and just have it space and we
19:20 - can say your name is ABBA and we've seen
19:22 - that additional a because that's the
19:24 - right line for the letter so we can
19:26 - space it out with an empty conso right
19:28 - line and they'll add a gap between them
19:30 - both there we
19:32 - go so now we know how to declare a
19:34 - string variable and give it a value and
19:36 - we can declare a Char variable and also
19:38 - give it a value just a quick recap when
19:41 - you're declaring and initializing string
19:43 - variables you need to put the value in
19:45 - speech marks but when you're declaring
19:47 - and initializing a Char you don't have
19:49 - to put it in speech marks you put them
19:50 - in apostrophes whenever you see
19:52 - apostrophes that that can only ever
19:53 - refer to One Singular character when you
19:55 - see a speech mark it could be one or
19:57 - more characters also things can be empty
20:01 - this just means the string is empty this
20:03 - is also a valid character it just means
20:05 - that we're storing a string but it has
20:07 - no value with a Char that's not exactly
20:09 - the same you can't store an empty
20:11 - character literal it has to be given
20:13 - something Charles get defaulted at back
20:15 - sl0 which is just a default character
20:18 - but don't worry about that too much now
20:20 - we'll go into Escape characters which is
20:21 - the back SL later on in the course for
20:23 - now just knowe that whenever you declare
20:25 - a string variable we need to put it in
20:27 - the speech marks and when we're
20:28 - declaring a Char variable we need the
20:30 - quotation
20:32 - mark So now that we know how to define
20:34 - numbers in C and to also Define strings
20:37 - and characters then let's look at how to
20:39 - convert between them both so let's take
20:41 - some similar code from our first video
20:43 - and we can Define it age the number the
20:45 - negative the Precision and the money and
20:47 - we give it the same values from the
20:49 - first video we simply just print them
20:51 - out to the console here and if we just
20:53 - run we can see them all but this doesn't
20:55 - help us cuz we're just statically typing
20:57 - in the numbers what if these were
20:58 - actually processed as string and we want
21:00 - to convert them into an INT so just
21:02 - above each of the variables we're going
21:04 - to make another variable so we can say a
21:06 - string text age equals
21:08 - -23 and then for the age what we're
21:11 - going to use is this function called
21:12 - convert to in32 and we can put in the
21:16 - string inside the brackets and what this
21:18 - is now saying is we're taking our string
21:21 - text Edge which is equal to -23 and
21:24 - we're passing it into this function
21:25 - convert to in32 and the reason why in32
21:29 - is because an INT is by definition an
21:31 - in32 which is a 32bit signed integer so
21:35 - what we want to do here is convert for
21:37 - our text age into an int32 and store it
21:41 - back into our int and hopefully we
21:43 - should see the same value when we hit
21:46 - run 23 so now that's actually went from
21:49 - a string variable and then went into our
21:52 - integer and we've printed out as an
21:54 - integer and it's no longer a string
21:56 - variable now we can do the same for the
21:58 - other ones so we can have a string text
22:01 - big number and make it equal to this
22:04 - value just in the quotation
22:07 - marks now we're typing this value in the
22:09 - quotation marks we don't need to put the
22:11 - L at the end the L is just to tell the
22:13 - compiler that we want to use N64 if we
22:15 - take the L away then it's going to think
22:17 - it wants in32 this is not re applicable
22:20 - when it comes to text because we're
22:21 - going to explicitly stay on the next
22:23 - line we want to convert to N64 so the
22:26 - compiler already knows that it's in 64
22:28 - and we don't need to put an L at the end
22:30 - now let's make sure this works and there
22:32 - we go so what we should end up with is
22:35 - the console should look exactly the same
22:37 - as how we had it at the start of the
22:38 - video but actually what we're doing is
22:40 - converting it from a string into the
22:42 - applicable value
22:44 - string text negative = -
22:49 - 55.2 and then in here we can do convert
22:53 - to double add the text negative inside
22:56 - here and let's just run it to check and
22:59 - we still have the same value so it's
23:01 - going well okay a string text
23:07 - Precision make it equal to
23:10 - this and then instead of this we can
23:13 - have a convert to and in this case it's
23:16 - actually going to be a single and the
23:18 - reason why it's a single when you hover
23:20 - of a float the definition for a float is
23:22 - indeed a single so we can add that in
23:25 - text precision and we're just going to
23:27 - do the last one just check it all
23:28 - together text money equals
23:33 - 14.99 and then instead of this we can
23:35 - have a
23:36 - convert and let's have a look at this a
23:38 - decimal is indeed a decimal so we can
23:40 - say two decimal and then add the text
23:43 - money
23:43 - in perfect now if you run the line of
23:46 - code we can see that all of these values
23:48 - are exactly as we had them now they're
23:50 - being represented by their official
23:52 - descriptions Based On A String
23:54 - conversion as I mentioned before in the
23:56 - error video the problem you'll have with
23:58 - this is if this value actually has a
24:00 - character inside you will get a runtime
24:03 - error this can be fixed in the future
24:05 - when we look at how to resolve these
24:07 - errors and we can have exception
24:09 - handling and use functions like trass so
24:12 - we can try and avoid these exceptions
24:14 - occurring because when these exceptions
24:16 - occur the rest of our code does not run
24:18 - and it becomes fatal at this
24:20 - point but for now don't worry about this
24:22 - too much just get used to the notation
24:25 - and how these things
24:26 - work so this video we're going to focus
24:29 - on the booing data type so we can make a
24:31 - Boolean data type by saying Bo value
24:34 - equals
24:36 - true this Boolean value is literally
24:38 - just a true or false value we can store
24:41 - anything in here and maybe something
24:42 - like bull is male and we can just say it
24:45 - true and later on our code booleans are
24:47 - used to make decisions we'll cover this
24:50 - in the next section of this course but
24:52 - boings are mainly used for making
24:54 - decisions if one thing is equal to
24:56 - another thing then we can take another
24:58 - path or if something is true or
24:59 - something is false then we can do
25:01 - another path for example if you make an
25:03 - output to the user you could check if
25:05 - this value is true and if the value is
25:07 - true then you can address the user as a
25:09 - male and if the value is false then you
25:11 - can address the user as a female these
25:13 - are the kind of things that booleans can
25:15 - help us with and just like any variable
25:17 - if you want to assign it later on you
25:18 - can just assign it again and if we print
25:20 - these out to the
25:24 - screen just like that you'll just see
25:26 - the value is true and the values false
25:28 - appear on the screen as of right now in
25:30 - the course there's not a whole lot to do
25:32 - with booing just understand that they
25:33 - can hold a true or false
25:36 - value so now that we know how to define
25:38 - different variables and how to convert
25:40 - between them let's see how we can
25:42 - perform operations on different data
25:44 - types let's say we could have an INT age
25:47 - equals 23 and then what we can do to
25:49 - that age is we can say Age ++ and what
25:53 - this age will do is it will actually
25:54 - just increment age by one and if we do
25:57 - age minus minus it will decrement it by
25:59 - one so if we just print it out after and
26:01 - after this as well what we'll notice is
26:03 - there'll be no change CU it'll go
26:05 - forward one and then back one there we
26:07 - go went from 23 plus plus to 24 and then
26:10 - minus minus to
26:12 - 23 that's one of the important operators
26:15 - that you'll see a lot especially during
26:17 - the next section of this course so
26:19 - another way to be able to add one to a
26:21 - variable or anything to a variable we
26:23 - can replace this with age equals age + 1
26:28 - and what we're seeing here we want age
26:30 - to have the value of itself added to one
26:34 - which will give us the same result is
26:35 - doing h++ another way of writing this is
26:38 - a quick shorthand is you can say age
26:41 - plus equals 1 these three things are
26:44 - doing exactly the same thing when you do
26:46 - an age Plus+ you can only increment by
26:49 - one and only one these two options give
26:52 - you the flexibility of having something
26:54 - like 10 these two are doing exactly the
26:56 - same age equals age + 10 and this is
27:00 - going to read exactly the same thing
27:01 - it's is when you use plus equals it will
27:04 - take the value of the current variable
27:06 - and add it to 10 which exactly what this
27:08 - line does to make it a lot shorter you
27:10 - can use age plus equals and then just
27:12 - put the value at the end just in case
27:14 - you forget to mention age twice so now
27:16 - if we just get rid of these two lines of
27:18 - code and we can just have a look and see
27:20 - if this runs so now the value should be
27:22 - 33 perfect and now as we said we're
27:25 - going to cover plus minus times and
27:28 - divide so just as you did with plus
27:31 - equals you can actually do a minus
27:32 - equals as well which will give us 13 and
27:35 - you can do a times equals which should
27:37 - give us
27:39 - 230 now if we try to do divide equals
27:42 - we're going to run into an
27:43 - issue it says
27:46 - 2 23 / 10 is
27:50 - 2.3 and when you take 2.3 and make it
27:53 - into an integer it's just going to
27:55 - truncate the3 and leave you with two
27:58 - with integers if you add two integers or
28:00 - take away two integers or times them
28:02 - you'll always end up with an integer if
28:05 - you divide two integers you don't know
28:07 - what you'll end with for example if you
28:09 - make this into 20 then you'll always end
28:11 - up with two but that's not always the
28:13 - case as you just saw 23 / 10 is 2.3 so
28:17 - if you're ever going to do any division
28:19 - it's best to actually make this a double
28:22 - cuz now that we do the division we
28:23 - actually get 2.3 which is technically
28:25 - the right value so you can add minus
28:28 - times and divide any variables that you
28:30 - want these are just demonstrated in int
28:32 - and double but you can do this the Flor
28:34 - the decimal Etc so let's have a look and
28:36 - see what the plus and the minus
28:37 - operators do when you've got a string
28:39 - variable so we can have a string name
28:41 - equals
28:43 - abber and then we can say the name plus
28:48 - equals is
28:51 - programming and then we can just print
28:53 - out name to the screen and see what
28:54 - happens so there you go you've actually
28:56 - just joined two strings together they're
28:58 - completely separate from each other and
28:59 - we've made them string
29:03 - together so if we try to do a minus
29:05 - equals you can't really remove from a
29:07 - string because a string is just text
29:09 - it'll be very difficult for the compiler
29:11 - and for the C language to be able to
29:13 - determine what's currently in the string
29:15 - and whether you can remove it or not
29:17 - this is not something that's built into
29:18 - the language this is not something
29:20 - that's built into the language so let's
29:22 - remove that and we can have the same
29:23 - thing with the
29:26 - TR now the problem with the Char is if
29:29 - we add a to B then let's see what
29:31 - happens to the
29:36 - output what it will try and do is
29:38 - actually get the uni code values for
29:40 - both of these items and try and add them
29:43 - together as integer
29:45 - variables so when you add a and b it
29:48 - will take the unic code value and you
29:49 - will actually get a capital A with a
29:51 - squiggle at the top and if we open
29:53 - character map you can see that this
29:54 - squiggle at the top is right here here
29:57 - which is unic codee 61 and 61 actually
30:00 - means 97 because it's 6 * by 16 + the 1
30:05 - and b means it's 6 * 16 which is 96 +
30:08 - the 2 so you have 97 and 98 and if you
30:12 - add them two values together you'll get
30:14 - the hex code which is C3 just for this
30:17 - character so what you're doing is you're
30:18 - kind of adding them both together and
30:20 - you're producing weird results so unless
30:23 - you really want to do this then you
30:24 - should be worried about adding two
30:26 - characters together
30:28 - one more thing to note about when you're
30:29 - doing Plus+ let's bring another int
30:32 - variable we just say int I equal Z then
30:35 - we can do i++ and then if we print out I
30:38 - the value should be one which is fine
30:41 - what if we did
30:44 - i++ but we did Plus+ I so the value is
30:47 - still going to be one but what happens
30:49 - if we put this i+ plus straight into
30:52 - these brackets let's try and run it and
30:54 - you'll still get the value is zero
30:57 - that's strange because we've said I ++
31:00 - and what happens when you do Plus+ at
31:01 - the front it will actually execute this
31:04 - and return the value of I and then do
31:07 - the Plus+ so if you actually print the
31:09 - value of I after you'll realize that now
31:12 - it becomes one after if you have had a
31:15 - situation where you need to increment
31:17 - first and then use the value you can use
31:19 - plus plus I now if you run it you should
31:22 - see the value is one twice the
31:24 - difference is that as the plus pluses
31:26 - before the VAR aable name it tells the
31:28 - compiler please do this action first and
31:31 - then return back the I if you don't want
31:33 - that behavior then use
31:37 - i++ finding the remainder between the
31:39 - division of two integer variables can be
31:41 - very handy when you're determining
31:43 - whether a number is even or odd let's
31:45 - look at an example let's have it in
31:48 - first Nome design the value of 10 and in
31:51 - second n and give it the value of three
31:53 - now if we just printed the screen first
31:55 - n divided by second n what do you think
31:57 - you'll get so the value of this in the
31:59 - calculator would be 3.3 reoccurring so
32:02 - we'd actually just get three because
32:04 - it's truncating it because of the
32:08 - integer so now what happens if we need
32:10 - the remainder between both of these you
32:12 - could actually work this out by seeing
32:14 - how many times three would be divided by
32:16 - 10 as close as possible and you'll see
32:19 - is the value is three and then 3 * 3 is
32:22 - 9 which will give you one left over for
32:24 - the 10 but that's a bit too long in our
32:27 - code so we have something called a
32:28 - modulus operator so we can actually
32:31 - change this divide for a percentage sign
32:34 - and what this will outut is it will only
32:35 - give us the remainder so let's say 10 /
32:39 - 3 is
32:42 - 3.3 as we've just said but the remainder
32:45 - is different remainder is exactly how
32:46 - you learned it at
32:48 - school 10 / 3 is actually three
32:52 - remainder 1 because 3 * 3 is 9 and then
32:56 - you have one left over to get to 10 so
32:59 - that'll be 3 * 3 which is equal to 9 and
33:02 - then one left over to get to 10 so now
33:05 - let's run our code and see if we do
33:07 - actually get one there we go so the best
33:10 - way to determine if a value is actually
33:13 - odd or even is to divide it by two so we
33:16 - can say 10 modulus 2 and if the value is
33:21 - zero then that means the value for first
33:23 - num is actually even if the value is one
33:27 - one then it's odd let's see how this
33:29 - works out if we had 10 modulus 2 then
33:32 - the value is zero because 10 can be
33:34 - divisible by two perfectly let's say we
33:37 - had 11 modulus 2 the closest multiple to
33:41 - 11 is 10 which is five and then we have
33:44 - one left over so you just have the
33:47 - remainder is equal to one and if we just
33:50 - keep going up in the chain we'll realize
33:51 - that it's the same pattern every single
33:54 - time you go up a value the value just
33:56 - toggles
33:59 - so when we print this out to the console
34:01 - and the value is actually zero that
34:03 - means the number is even and if we make
34:06 - the number odd on purpose and then rerun
34:08 - the code you can see that it's a number
34:10 - one now which means this value is now
34:12 - odd so let's look at a couple of
34:14 - examples and see if you can figure out
34:15 - the answer if we do a th000 modulus 90
34:20 - what do you think the value will be and
34:22 - let's write a couple more if we do 100
34:24 - modulus 90 and maybe something like like
34:27 - 71 modulus 10 so have a think about this
34:30 - in your head and see if you can figure
34:32 - out the answers pause the video and see
34:34 - if you were
34:35 - correct let's take a look at the
34:38 - answers so we can see we have 10 10 and
34:41 - 1 so the closest multiple to 1,000 from
34:44 - 90 is
34:45 - 990 so we have 10 left over to get to
34:49 - 1,000 and the same goes here the closest
34:51 - multiple of 100 to 90 is just indeed 90
34:55 - so we only have 10 to get from 90 to 100
34:58 - and in this case the closest multiple of
35:00 - 71 to 10 is 70 and we have one to get up
35:04 - to 71 therefore these two answers are
35:06 - indeed
35:08 - correct so now that we know how to
35:10 - really Define a variable by specifying
35:12 - that type followed by the name and given
35:14 - it a value let's see how we can do a
35:16 - very easy way of defining a variable so
35:19 - normally we would type in Edge but we
35:21 - can use this VAR keyword and what this
35:24 - means is the compiler will figure out
35:25 - what type it needs to be based on the
35:27 - value we initialize it with so if we
35:30 - just make a variable called age then
35:32 - it's not going to like it because you
35:33 - need to give it a value this doesn't
35:35 - give the compiler enough information to
35:37 - figure out what this variable is going
35:39 - to be just because it says age this is
35:41 - just text to the compiler this does not
35:43 - mean anything so if you make it equal to
35:45 - 23 then the compiler can see that this
35:48 - is indeed int 32 because it knows that
35:51 - so now if you hover over VAR it says
35:54 - in32 now let's try and do this for the
35:57 - big
35:58 - number our big number equals
36:02 - 90,000 and what will happen now is
36:05 - because it's defined as in32 it's going
36:07 - to say this is in32 as well and this is
36:10 - the same issue we had we'll move first
36:11 - def finding the long variable in the
36:13 - first video we need to explicitly give
36:15 - it an L just so this knows that it's N64
36:18 - and now the VAR has updated to an in
36:21 - 64 instead of rewriting each one we can
36:24 - just change each to V and inspect what
36:26 - happens double double and now we have a
36:30 - float single single and finally the
36:34 - decimal we have a decimal and we have a
36:36 - decimal and the same thing goes for a
36:38 - string we can say V name equals ABA and
36:42 - we can have a v letter equals a there we
36:45 - go and they'll both register as there
36:47 - pickable data types as a string and as a
36:50 - CH and if we just print this out to the
36:53 - screen to make sure everything's working
36:54 - fine and run the code you can see that
36:57 - everything is exactly how we'd expect so
37:00 - just a quick recap you don't have to do
37:02 - this at the end of the day this will be
37:03 - exactly the same as writing this because
37:06 - when our code gets compiled down it
37:07 - doesn't matter what these things are cuz
37:09 - the compiler will deal with it however
37:11 - way it wants to this is just for us to
37:13 - read it in some cases if the value is
37:15 - very obvious like as we know an age
37:18 - cannot really be a point 23.1 years old
37:21 - no one says that in real life when you
37:23 - get asked your age so we can just assume
37:25 - that this value is going to be an
37:27 - integer and that's fine because that's
37:29 - an easy number that's an easy example
37:32 - but if we say we want a negative or a
37:34 - big number then it doesn't really tell
37:36 - us what we're meant to be like this big
37:38 - number could be somewhere up to 2.1
37:40 - billion which is what an integer
37:42 - supports but in this case if it's going
37:44 - to be a big number and we specified the
37:46 - L then we're going to need a really big
37:48 - number bigger than 2.1 billion so in my
37:51 - honest opinion it would be very
37:52 - beneficial to only use VAR if it's very
37:55 - obvious what the variable is going to be
37:57 - and what it's been assigned to using VAR
37:59 - too much might hurt the readability of
38:01 - your code in the future because you have
38:04 - to inspect each variable individually to
38:06 - read what the type is going to be if
38:08 - you're scrolling through your code and
38:09 - you can see that this is along very
38:11 - quickly and you don't have to hover over
38:13 - it then it can improve your read time
38:15 - this is really important as readability
38:17 - of code will make more sense when it
38:18 - comes to Big projects when you have 20
38:20 - 30 lines just like this project then it
38:22 - makes almost no difference cuz it only
38:24 - takes a couple of seconds when you have
38:26 - big functions and big software when you
38:28 - work at a job then it's going to be very
38:31 - difficult to be able to find your way
38:32 - around and to understand what's going on
38:34 - especially if you're new to the code
38:37 - something very simple like this where
38:38 - you know you're defining a name it's
38:40 - very obvious and V will be accepted fine
38:43 - because you can tell that this is always
38:44 - going to be a string there's no other
38:46 - data type in C gets specified by a
38:49 - speech mark whereas when you're defining
38:51 - numbers it can be very very hard to
38:53 - understand what different data types
38:55 - that people are using throughout the
38:57 - code especially when these numbers are
38:59 - not statically typed in they might be
39:01 - inputs from the console from the user
39:03 - from a different function from anywhere
39:05 - so having good variable names along with
39:08 - their explicit types will be very handy
39:10 - to understand code in the
39:13 - future so now that you've understood how
39:15 - to make a variable let's look at a
39:17 - concept called constants so we defined a
39:19 - variable called vat and we set it to 20
39:22 - just to represent the 20% vat in the UK
39:25 - now later on in the program we can
39:27 - actually change it to anything we want
39:29 - and that's because it's a variable
39:30 - variables can change in certain
39:32 - circumstances like vat you might not
39:34 - want to change it and you want to
39:35 - disable the ability to change it to out
39:37 - the code if it's done accidentally let's
39:39 - say for example you're making a banking
39:41 - application and you want to fix the vat
39:43 - and you don't want anyone else to change
39:45 - it you can add this keyword called const
39:48 - right before the Declaration and now
39:49 - when you go to reassign it you'll get an
39:51 - error message and it says at the left
39:53 - hand side of the assignment so anything
39:55 - before the equal sign has to be a
39:57 - variable property or indexer and in this
39:59 - case if you hover over vat it states
40:02 - that it's a local constant local because
40:04 - there's no access modifier before it and
40:06 - constant because we specified the cons
40:08 - keyword so now if we try and run the
40:10 - code we'll actually get a compile error
40:12 - because the vat cannot be changed so if
40:15 - we remove that and then we just print
40:17 - out to the console using CW tab tab and
40:19 - then we can put V8 in the brackets and
40:21 - press F5 and now we can see our 20 being
40:25 - printed
40:27 - so let's try and calculate some values
40:29 - using this code if you have an in
40:32 - Balance make it equal to 1,000 and let's
40:35 - say we wanted to calculate the vat based
40:37 - off this then you'd have to do a little
40:39 - bit of a complicated calculation you
40:41 - have to take the balance and because the
40:42 - V is a percentage we need to convert it
40:45 - from decimal to percentage so if we do
40:47 - times and then open the parentheses we
40:49 - can insert
40:51 - vat divided by 800 and just to make sure
40:55 - that this gets processed as double we
40:57 - want to write 100 D cuz right now it's
40:59 - in 32 and if we leave this as an integer
41:01 - division then we'll lose any decimal
41:03 - places and decimal places are very
41:05 - important when it comes to percentages
41:07 - so we put a 100 D at the end now you can
41:09 - see it says double so it'll actually
41:11 - calculate as if it was a decimal number
41:13 - so now if we print that to the screen so
41:15 - we can see here that 20% of the balance
41:18 - is indeed 200 instead of having to do
41:21 - this calculation each time what we can
41:23 - actually do is make another const this
41:26 - I'm making it a double cuz we're not
41:27 - sure what the output of this division
41:29 - will be and we don't want to truncate it
41:31 - so we want it as a double and we can say
41:33 - percent
41:34 - vat and what we can do here when we
41:36 - assign the value just because it's a
41:38 - constant it means that we can't change
41:40 - the value but that also means we can
41:42 - read it as many times as we want so we
41:44 - can say the percentage V is actually the
41:47 - current V that we've got specified here
41:50 - ided
41:52 - 100d this will give us the vat from a
41:55 - number form into a decimal form so now
41:58 - when we do this calculation if we
42:00 - duplicate this line using contrl D we
42:02 - can remove these entire brackets and
42:03 - literally replace it with percentage vat
42:06 - and you should see we get the same
42:07 - values
42:09 - perfect this can be very helpful in the
42:11 - future if you have things like version
42:13 - numbers in your code you can have
42:15 - version 1.0 and then if you ever specify
42:18 - this version later on in your code you
42:20 - can just change it once up here and it
42:22 - will change the rest this can be very
42:24 - helpful you'll avoid a lot of typ and
42:26 - you won't have to redeclare this value
42:28 - several times if you had three different
42:30 - occasions where you displaying the
42:32 - version number in your code then it's
42:33 - going to be problematic once you update
42:35 - the version number and you have to
42:36 - change every single occurrence and you
42:38 - might miss them so inserting it once and
42:40 - only having to change it once is the
42:42 - preferred option just to note with
42:44 - constants when you compile your code all
42:46 - the constants will actually do is do a
42:49 - find and replace so it will take this
42:50 - vat and find all references of vat and
42:54 - just drop the 20 in there
42:57 - so this is more of a feature for
42:58 - maintaining your code from a user and
43:00 - programmer's perspective rather than
43:02 - anything to do with the compiler because
43:04 - when it compiles it just removes all the
43:06 - constant anywhere and then you're left
43:07 - over with the literal values that we've
43:09 - gave it nonetheless this is still
43:11 - something very handy to learn and to use
43:13 - throughout your
43:15 - code first you want to Define a variable
43:17 - to hold your name so we can just say
43:20 - string name equals abber perfect so
43:23 - that's the first one achieved says
43:25 - Define a VAR able to hold your phone
43:27 - number so at first this could be quite
43:29 - easy we could say int number equals and
43:32 - then we can start to type our number in
43:34 - here so now that's our number completed
43:36 - let's move on to holding your age and we
43:38 - can just have an INT age equals
43:41 - 23 print variables line by line to the
43:44 - screen so we can use CW tab tab and type
43:46 - in name and then we can use contrl D to
43:49 - copy and paste the line then we can do
43:51 - number crl D again and then we can use
43:53 - Edge now if we run the code let's see
43:55 - what
43:57 - happens here we've actually hit a slight
44:00 - problem it says 1 2 3 4 for the number
44:03 - but I'm pretty sure that I started off
44:04 - with zero this is a problem with storing
44:07 - your number as an integer as a number
44:09 - zeros at the front don't really matter
44:11 - if we had 100 zeros here then it's not
44:14 - going to change the actual value the
44:16 - only time zeros matter is if it's
44:18 - throughout the number or towards the end
44:21 - that actually changes the number but if
44:23 - we have lots of zeros at the start then
44:24 - it doesn't change anything
44:26 - so what you actually want to do in order
44:28 - to store a number is you want to store
44:29 - it as a
44:31 - string therefore when you run the code
44:33 - it will actually return the zero that we
44:35 - typed in so now that we've accomplished
44:37 - all of these let's see how we can Define
44:39 - the variables using the VAR keyword so
44:41 - if we hover over these you can see that
44:43 - it's picking up that it's a string and a
44:45 - string here and finally this is an
44:48 - integer so what we can do very simply is
44:51 - just change these to VAR and then let's
44:52 - hover over the variables and just see if
44:55 - the tool tip reads the the correct data
44:56 - type string string and integer and if
45:00 - you run the code you should see no
45:05 - difference so in this exercise I want
45:07 - you to create and initialize two integer
45:10 - variables make a variable to work out
45:12 - the remainder output the remainder to
45:14 - the screen and then change the first
45:16 - integer variable to another number
45:18 - recalculate the remainder and output the
45:20 - new remainer to the screen so let's take
45:22 - this step by step so first we need to
45:25 - create an ize two ins let's say int num
45:28 - 1 equals to 10 int num 2 equals to two
45:33 - make a variable to work out the
45:34 - remainder so we can have an INT
45:36 - remainder equals to and if you remember
45:39 - how to do the remainder it uses the
45:41 - modulus symbol which is the percentage
45:43 - sign so we can say num one percentage
45:46 - num
45:48 - two now it says output remainder to the
45:50 - screen so we can use CW tabtab add
45:53 - remainder in and hit run and just for
45:56 - now we can see that the remainder is
45:58 - indeed zero if the remainder is zero
46:01 - then that means 10 is even because 10
46:03 - modulous 2 gives us zero and if it's
46:06 - zero then that means it's even if the
46:08 - remainder was one then it would mean
46:11 - it's odd so if we try 11 remainder two
46:13 - we get one so 11 is indeed an odd number
46:17 - so let's change this back to 10 and then
46:19 - it says change the first inter variable
46:21 - to another number so just after here we
46:23 - could say num one equal 11 and then
46:27 - recalculate the remainder so we
46:29 - essentially just need to do this section
46:31 - again and we don't need to write into
46:33 - before these two variables cuz int is
46:35 - only used when you're declaring it this
46:37 - is reassigning the
46:39 - variable so we reassign variable num one
46:42 - to 11 and then we reassign the remainder
46:45 - to the calculation again and now we can
46:47 - use the exact same line of code above to
46:50 - print out the remainder to the screen
46:52 - now you can see that it's 0o and one
46:54 - it's zero because 10 is even and it's
46:56 - one because 11 is
46:59 - odd so far throughout the course we've
47:02 - been using console right line to Output
47:04 - stuff to the screen for example I can
47:06 - output hello my name is Aba and we can
47:08 - see it in the console the issue is so
47:11 - far we haven't really wrot any code to
47:13 - be able to read in values from the
47:14 - console so let's explore that option
47:17 - right now so in the console Library we
47:19 - have a console right line but what you
47:21 - don't realize is we can also use this
47:23 - console right line to ask the user a
47:25 - question and to let the user type
47:27 - something in so let's use CW tab tab and
47:31 - say enter your
47:33 - name with a colon and then end the
47:36 - quotation
47:37 - marks and then in order to return a
47:40 - value from the console into your program
47:42 - we need to use console. readline and if
47:45 - you hover over readline let's have a
47:47 - read at description reads the next line
47:49 - of characters from the standard input
47:51 - stream perfect this is exactly what we
47:53 - want to do right now it's to use at the
47:56 - end of our code just to stop the console
47:58 - from closing so we can actually see the
48:00 - output so if we just run this right now
48:02 - we actually get the opportunity to type
48:04 - but when we press enter our program
48:06 - closes this is because in this case
48:08 - we're simply using readline just to wait
48:11 - until the user has pressed enter so so
48:13 - our program doesn't close but what you
48:15 - don't actually see is this is returning
48:18 - as a string which means that anything
48:20 - that we type into here and when we press
48:22 - enter it actually gets a return back to
48:24 - the code but we not doing anything with
48:26 - it because we don't care at this point
48:29 - so now let's actually do something that
48:31 - will make us care about the user's input
48:33 - so we can make a new string variable and
48:35 - assign it to console readline and it
48:37 - should give us the ability to store
48:39 - Whatever Gets entered inside the console
48:42 - so we can just do string name and we can
48:45 - end the semicolon here and if you wanted
48:47 - to on the next line you could do name
48:49 - equals console.
48:51 - readline or if you wanted to have it all
48:54 - in one line then you can get rid of the
48:55 - semicolon and bring it up like this this
48:58 - is the preferred method as both lines
49:00 - were on top of each other and it wasn't
49:01 - really necessary to split them here
49:03 - we're doing a declaration of string name
49:06 - and an initialization and giving it the
49:08 - value of console. readline and this is
49:10 - whatever value the user is going to type
49:12 - in let's run our code and see what
49:15 - happens enter your name abber now when I
49:18 - press enter it's successfully stored
49:20 - abber inside this string name variable
49:23 - and now it's waiting at this line the
49:25 - console read line just right here so
49:27 - when I press enter the program closes so
49:30 - now that we've made a variable and not
49:32 - done anything with it let's print out to
49:34 - the screen to make sure that something's
49:35 - actually worked so if we use CW tab tab
49:38 - and we type in name in the brackets and
49:40 - we can run this code again and let's see
49:42 - what happens as soon as I type in Abba
49:44 - and press enter then this second abber
49:47 - is actually the variable printing out to
49:48 - the screen so here it says enter your
49:51 - name with a colon and normally when you
49:53 - see the colon it sometimes lets you type
49:55 - on the same line so if youd prefer the
49:57 - user to type on the same line then we
49:59 - actually have another function for that
50:01 - instead of using right line we can just
50:04 - use right and the difference between
50:06 - right line and right is the right line
50:09 - will actually have a Terminator at the
50:11 - end of the line to tell the console that
50:13 - he wants to push everything after it
50:15 - onto the next line whereas console.
50:17 - right will just print it out to the
50:19 - screen and not worry about any new lines
50:22 - let's try run it now and now we can type
50:25 - in
50:25 - and as you can see it's a little close
50:27 - to the colon so we can fix that in a
50:29 - second so you press enter you can see
50:31 - now that abber comes up on the second
50:33 - line so if we just put a space after the
50:35 - callon just to give it a bit of room now
50:38 - if we type in abber you can see that
50:39 - there's a bit of a gap and it's quite
50:41 - nicer to look at now if we press enter
50:44 - you can see that Abra has been stored
50:46 - successfully so what we can do now is
50:49 - maybe ask for your age so we can have a
50:52 - console.
50:53 - right enter your age age call on space
50:57 - and then do a string age equals console.
51:00 - readline and then we can have a age
51:03 - output as well and let's see how that
51:05 - works so we can say abber then say 23
51:08 - and press enter and now we have abber
51:10 - stored within the name variable and have
51:13 - 23 stored within the age variable so
51:15 - let's try and output a string that's a
51:17 - bit more meaningful to the user let's
51:19 - clean this console up and see what we
51:21 - can do so we don't need to Output their
51:24 - result back to the console because they
51:26 - literally just type that in and we don't
51:28 - want to have this line because we just
51:29 - use that as an example so if we run the
51:31 - code right now it'll look better but it
51:34 - does look a lot more structured enter
51:36 - your name and then enter your age so now
51:39 - when you press enter the program will
51:40 - just close so let's try and output these
51:42 - two variables in a formatted fashion so
51:45 - as you now know we can use console.
51:47 - write to print a lot of stuff on one
51:49 - line so we can use console. write and we
51:52 - can say your name is and then add a
51:55 - space and finish that line there and
51:58 - then duplicate it down we can write name
52:02 - duplicate that down and say space and
52:05 - your age is duplicate that one down and
52:09 - then we can type in age and let's see
52:11 - what happens now abber
52:14 - 23 there we go so we actually have the
52:17 - name output and the age output all on
52:20 - one line if we all change these to right
52:23 - lines then they're going to be on
52:24 - separate lines and it's not going to
52:25 - look very nice so I'm just going to
52:27 - introduce you to a notation called
52:29 - string concatenation this is the notion
52:32 - of being able to concatenate two
52:33 - different strings which just means to
52:35 - add one string onto another as you can
52:38 - see this is taken up four lines of
52:39 - chorde and it's getting a bit ugly the
52:41 - better and easier way to do this is by
52:44 - containing it all within one line so we
52:46 - can have a console right line and we can
52:49 - take the first section your name is keep
52:52 - the space at the end we can end the
52:53 - speech marks and put a plus
52:55 - and then we can say name so now we've
52:57 - just added these two together if we just
52:59 - comment out the rest of them and run the
53:02 - code and you can see that they should be
53:04 - on one line there you go so we can say
53:07 - your name is ABBA and let's just keep
53:09 - changing the plus symbol so we can say
53:12 - and your age is another space and the
53:15 - speech marks and plus the age now we've
53:18 - got all of this contained within one
53:21 - line and it looks a lot better enter
53:23 - your name abber and into your age 23 and
53:26 - now you can see exactly the same output
53:28 - but reduced to one
53:32 - line as you can see these three lines
53:34 - are all stuck to each other so if you
53:36 - wanted to add a blank line between these
53:38 - two you can just put an MC console right
53:41 - line just in here and what this will do
53:43 - is simply just print the right line
53:45 - character to the screen which will force
53:47 - the console to make it on the next line
53:50 - just like so here's the console right
53:52 - line from the empty line that we just
53:53 - wrote and this is the console right line
53:55 - to Output the
53:56 - values so now that you've understood how
53:59 - to read values in from the console let's
54:01 - try and convert some values as I showed
54:03 - you how to do it earlier on in the
54:04 - course you can actually convert these
54:06 - strings into integers ideally you want
54:08 - to store variables in their data types
54:10 - as we covered before ages should not be
54:12 - stored as strings they should be stored
54:14 - as integers but if you try and change
54:16 - this to an INT then you're going to have
54:18 - an issue console read line will return
54:21 - back a string so therefore it can't
54:23 - implicitly convert from a string to an
54:26 - integer so we need to do this in two
54:28 - steps we can rename this to age input
54:32 - and then on the line underneath it we
54:34 - can say int age equals convert to int 32
54:39 - and then add age input in these
54:42 - brackets there we go and now when we
54:44 - actually print the line of code nothing
54:47 - should actually
54:49 - change your name is abber and your age
54:51 - is 23 but now what's actually changed is
54:54 - we're storing the the variables in the
54:56 - correct format this is the ideal method
54:58 - because in the next section when we
54:59 - cover if statements you'll realize why
55:01 - this is very important if you wanted to
55:04 - minimize the amount of steps you need to
55:06 - convert this then you can actually move
55:08 - the console read line and get rid of the
55:10 - string input variable and we can just
55:12 - paste it straight into the bracket of
55:14 - the converter in 32 and you can get rid
55:17 - of the string input variable and
55:19 - everything will work the same AB 23 and
55:22 - now it's working exactly the same if
55:24 - this is many steps for you or if this
55:26 - looks too complicated then just please
55:28 - revert it back just to keep it the same
55:30 - way for the time
55:32 - being so now we've learned how to read
55:35 - in values from the console and output
55:36 - them back to the screen now let's see
55:38 - how we can use if statements to divert
55:40 - our code into multiple paths so in the
55:43 - previous section I told you that it is
55:45 - very crucial for our code to have this
55:47 - int Edge and the reason why is age is
55:50 - meant to be stored as a number and not
55:52 - as a string so we read it in first as a
55:54 - string and and then convert it to an
55:56 - integer using this function and store it
55:58 - into our age variable this is the reason
56:01 - why so our condition goes as follows we
56:04 - write the word if and between the
56:06 - brackets this needs to be evaluated to
56:08 - either a true or false value and then we
56:10 - can have the curly braces to tell us
56:12 - what to do if this becomes true so in
56:15 - this case you want to just check if our
56:16 - age input is greater than or equal to 18
56:19 - let's say this was an entrance to a
56:21 - place that only allowed overes to enter
56:23 - so we can do a input which references
56:26 - the age input variable and we can use
56:29 - the operators equals greater than
56:32 - greater than or equal to less than or
56:34 - less than or equal to or not equal to so
56:36 - these are all the different options that
56:38 - we have we can say if the age input is
56:40 - equal to
56:42 - 18 perfect so now that we've read in the
56:45 - age input we can check if it's 18 let's
56:48 - just process a message in here says you
56:50 - are 18 and let's have a look and see if
56:53 - this works
56:56 - AB 18 now I press enter it says you are
57:00 - 18 but this is the problem with storing
57:02 - everything as a string and then trying
57:04 - to use it as if it was a number if I
57:07 - type in 18 followed by a space as you
57:10 - can see there's a blank Spacey now and
57:11 - press enter you can see that it doesn't
57:13 - come up and the reason why is it's
57:15 - processing it like this with a space at
57:17 - the end in order to avoid situations
57:20 - like this this is why we would convert
57:22 - it to a number and the reason why we're
57:24 - using equals to here is we can't use
57:26 - greater than or equal to because strings
57:28 - can't be greater than or equal to
57:30 - another string they can only ever be
57:32 - equal to or not equal to string is just
57:35 - text so if something equals to something
57:38 - then it's fine the only way that we can
57:40 - use these different operators is if we
57:42 - actually interact with our integer
57:44 - variable now let's see how we can use
57:46 - this so we can say age equals equals 18
57:49 - and now you can see we actually
57:50 - reference it as a number now let's run
57:52 - the code if I do 18 Follow by space it
57:56 - still works and the reason why is it
57:59 - actually dismisses that space when it's
58:01 - converting to the integer so now age is
58:03 - stored as an integer and we can actually
58:05 - manipulate this a bit better so instead
58:07 - of saying you are 18 we can say you are
58:10 - 18 or Alo and now instead of doing equal
58:12 - to we can have greater than if we have
58:15 - greater than then we're actually
58:16 - dismissing the number 18 because if the
58:19 - age is greater than 18 so this will read
58:21 - like this and 18 is not greater than 18
58:25 - so this will return back false what we
58:27 - actually want to use is greater than or
58:29 - equal to if the age that we've inputed
58:32 - is greater than or equal to 18 then you
58:34 - are 18 hence the equal to or greater
58:38 - than if you're older so now let's try
58:40 - and run this abber 23 perfect you are 18
58:45 - or older let's change so let's change
58:47 - some other if statements to add some
58:49 - additional conditions so we can say else
58:52 - if and the only reason why it would come
58:54 - into this bracket if this condition
58:57 - returns false it will move down the next
59:00 - condition in the else chain if this was
59:02 - wrote as a separate if statement then
59:04 - this would run completely independently
59:06 - from this one if you're going to have
59:08 - chained if statements you need to make
59:10 - sure that you chain them correctly in
59:12 - this case I want to check if it ages
59:14 - between 18 and 25 and then move on to a
59:18 - different age bracket and these two
59:20 - things are grouped together so we should
59:22 - have this as an else if because with an
59:24 - age bracket you can only be part of one
59:26 - age bracket and not multiple so we can
59:29 - say if age is greater than or equal to
59:31 - 25 and we can copy this and we can say
59:34 - you are 25 or older now let's see what
59:36 - happens enter your name abber and let's
59:39 - just say that I am
59:40 - 35 it says you're 18 or older but I told
59:44 - it the program I was 35 now the problem
59:46 - we're facing is any value that's over 18
59:49 - will always enter inside here and it
59:51 - will skip over this one completely this
59:53 - is not the behavior it that we want so
59:56 - what we can do in our if statements is
59:57 - we can use the double pipe which
59:59 - represents or or the double Ampersand
60:01 - which represents and and we can change
60:04 - some conditions in here to make sure
60:06 - that you implement some sort of range so
60:08 - we can actually have a range between 18
60:11 - and 25 so we can say if the age is
60:14 - greater than or equal to 18 and the age
60:18 - is less than or equal to 25 and we can
60:21 - tweak this message you are between 18
60:25 - and
60:27 - 25 and let's just run that for now and
60:29 - see what happens ABA 25 now it says 18
60:34 - and
60:35 - 25 so now that we've got between 18 and
60:38 - 25 here we can tweak this to be greater
60:41 - than or equal to
60:44 - 26 if you're 25 will'll enter this
60:47 - condition and if you're 26 or older into
60:50 - this condition so let's test that now if
60:52 - we enter
60:53 - 35 now it says you're 26 or older that's
60:57 - perfect because now that we've
60:58 - implemented range checking it gives us
61:00 - the ability differentiate between
61:02 - different age groups more precisely
61:04 - let's Show an example of how to use the
61:06 - all so if we just have a block comment
61:08 - around all of this we can write an if
61:10 - statement in here and we can say if the
61:13 - edge is smaller than zero or the edge is
61:16 - bigger than 150 then we can output to
61:19 - the screen inv valid Edge and what this
61:23 - is saying is if we're less than zero and
61:26 - notice that this is less than zero so
61:28 - this value will actually start at minus
61:30 - one and this value start at 150 is minus
61:34 - one or less or over 150 then this will
61:38 - happen notice why it's an r one of these
61:41 - need to be true in order for this to be
61:43 - true when you've got an and both sides
61:47 - need to be true in order for this
61:49 - condition to evaluate is true so let's
61:51 - try our code we can say and we put
61:53 - minus one one and now it says invalid
61:56 - age which is perfect because this is our
61:58 - range checking and we can try again with
62:02 - 151 as it's just outside the range it
62:05 - will say invalid age and if we have an
62:08 - else on here we can print valid
62:12 - Edge notice there is no condition in
62:14 - here if you have an open else like this
62:17 - it means If This Were to return false it
62:20 - will always do this regardless of any
62:22 - condition in this case is it's perfectly
62:25 - reasonable to do this because we know
62:27 - that any values that are underneath zero
62:29 - or over 150 is invalid and anything
62:33 - between 0 and 150 is indeed valid what
62:37 - you can do instead is actually move
62:40 - these if statements inside here so
62:42 - instead of just printing out valid age
62:45 - we can actually check the age as
62:47 - well so let's run this now and we can
62:49 - say Aba minus one and it will only print
62:52 - out invalid age and then move on because
62:55 - once it reads this line of codee it will
62:57 - actually skip over the lse and finish up
62:59 - down here and now if you enter a real
63:03 - value you are between 18 and 25 so let's
63:06 - follow the path it got to here and
63:09 - realize that the range track was
63:10 - actually correct so it jumped out of
63:12 - this curly brace and went to the else
63:14 - because this had returned false we jump
63:16 - into this else and now we start checking
63:18 - if age is between 18 and 25 which it was
63:22 - because our age variable is 23 then it
63:24 - outputed this to the
63:27 - screen now if we do the same thing but
63:29 - have 35 instead then it follows the
63:32 - exact same path except towards here this
63:34 - will return back false and then it will
63:36 - check the next condition if age is over
63:39 - 26 then we'll return
63:42 - this so now let's just make a quick
63:44 - multiplication program using if
63:46 - statement to see if you can get the
63:47 - answer correct so let's just comment
63:49 - everything
63:51 - out and we'll start the next section
63:53 - underneath
63:56 - so let's make a console. write and ask
63:58 - the user to enter the first
64:01 - number and then we can say int number a
64:05 - equals convert to int32 and the value
64:09 - that we want to convert is a console.
64:11 - readline which is whatever the users
64:13 - entered from the console again if you're
64:16 - unfamiliar with this format you can just
64:18 - type it in manually number a input
64:21 - equals console readline and then we can
64:23 - put the number input in here now if you
64:25 - use shift and highlight these lines and
64:26 - press contrl D we can duplicate this
64:28 - entire section and we can say enter the
64:31 - second number change a to B change a to
64:35 - B and then finally change a to B perfect
64:38 - so now we've got into the first number
64:40 - and enter the second number and we can
64:42 - say our
64:44 - answer equal to number a multip by
64:48 - number
64:49 - B and then we can have a console. right
64:54 - value of you can add to it number A plus
64:58 - an X Plus number B and then finally plus
65:03 - a callon for the user to type in and
65:05 - then we can say string answer input
65:07 - equals console. readline and then
65:11 - int actual answer equals convert to in
65:16 - 32 and then we can have the input in
65:18 - here so now that we've got one number
65:21 - from the console the second number from
65:23 - the console we're just making a variable
65:25 - that will multiply them together and
65:27 - store inside answer and then we're just
65:29 - going to ask the user what's the value
65:31 - of number a times my number B and they
65:34 - can input that we store it as a string
65:36 - and then convert it to an integer and
65:38 - store the answer into actual answer so
65:41 - now just after the section we can write
65:42 - an if statement that says if the answer
65:45 - equals to the actual answer then we can
65:48 - say Well
65:50 - done and else and the reason why we
65:53 - don't need a condition this else because
65:55 - with equals to the only opposite thing
65:57 - you can have is if it's not equal to so
66:00 - if you really wanted to you could also
66:02 - right if answer is not equal to actual
66:04 - answer then in here you can say close
66:08 - but it was wrong you don't actually need
66:12 - this this is just for learning purposes
66:14 - because this will return back false if
66:16 - they're not equal to each other so this
66:18 - statement is just a given if they're not
66:20 - equal to each other then we can just
66:21 - assume that they're not equal to each
66:23 - other so so we don't need this
66:24 - additional statement if this condition
66:27 - evaluates to being false then that means
66:29 - they're not equal to each other we don't
66:31 - need this additional check to check if
66:33 - they're not equal to each other because
66:35 - that's a given if this returns back
66:37 - false so we can just leave this as an
66:39 - else let's try run the
66:42 - code 10 10 value of 10 * 10 100 now it
66:47 - says well done and let's just try that
66:49 - again and we can enter a different value
66:51 - 90 Clause but it was wrong
66:54 - so let's just have a quick
66:56 - recap so in the previous section we
66:59 - talked about how to input from the
67:00 - console and we generated this line of
67:02 - code which will output your name and
67:04 - your age in one line to the console and
67:07 - then we looked at how we can use these
67:08 - different operators in our if statements
67:10 - and we did some range checking to check
67:12 - if the age was between 18 and 25 and it
67:15 - would output something to the screen and
67:18 - if it was over 26 you'd get a different
67:20 - output to the screen and then we took
67:22 - that a little bit further and started
67:24 - using the r operator if the age is
67:26 - smaller than zero or it's greater than
67:29 - 150 then it must be invalid and if this
67:32 - condition returns false it must be
67:34 - between 0 and 150 so we can come into
67:37 - this L's bracket and inside here we can
67:39 - do our range checkin from the previous
67:41 - bit of code we can check the ranges
67:44 - between 180 and 25 and print a value or
67:47 - if it's over 26 we can print another
67:49 - value and you can keep changing these if
67:51 - you want you can have 26 to 40 and 40 to
67:54 - 60 etc etc that's up to
67:57 - you so this is just a quick little
67:59 - program to simulate multiplication
68:02 - program we can enter the first number
68:04 - using console. right and then we start
68:06 - it as a string and we put that string
68:08 - into the convert in 32 function to give
68:11 - us back an integer variable and we do
68:13 - exactly the same thing for the second
68:15 - number and then we make a variable to
68:18 - store both numbers multiplied by each
68:20 - other we ask the user what is the value
68:22 - of number a Times by number B and we
68:25 - give them an opportunity to type in a
68:26 - value we read that value in convert it
68:29 - to an integer store it as an into actual
68:32 - answer and then in our if statement we
68:34 - say if the answer is equal to the actual
68:36 - answer then we print well done to the
68:40 - screen double equals are used for
68:42 - equality and single equals are used for
68:44 - assignment don't get them mixed up we
68:47 - don't need an else condition in here
68:49 - because if this returns true then this
68:51 - will execute if this is indeed false
68:54 - that they're not equal to each other
68:55 - then we always want to do this section
68:57 - and we don't need to put an additional
68:59 - if statement inside here if you wanted
69:01 - to but it's not necessary you can have
69:03 - else if answer is not equal to actual
69:07 - answer but this is just extra code and
69:09 - it hurts the readability and it should
69:12 - be
69:14 - avoided if statements are one of the
69:16 - methods we can decide different paths in
69:17 - our code the next method we can use is
69:20 - called switch statements so let's write
69:21 - a little program so we can demonstrate
69:23 - this
69:24 - so we can just have a console. right
69:26 - enter a date of the week and we can have
69:29 - in date equals convert to in32 and we
69:32 - can place our console.
69:34 - readline inside the brackets so we take
69:36 - whatever the user typed into the console
69:39 - and then place it inside here and inside
69:41 - here we're going to convert whatever
69:42 - they've typed in to an integer 32 and
69:45 - star it into our D variable so if we
69:47 - just print this out to the screen to
69:48 - make sure it's working fine if we just
69:51 - type in seven we can see that seven is
69:52 - returned so it's all working
69:54 - so normally what we do is type if D
69:57 - equals equals 1 and then we can add the
69:59 - curly braces and use CW tab tab and we
70:02 - can print out Monday now if you run the
70:04 - code and try use number one then Monday
70:06 - works and that's fine and then let's do
70:09 - another lse if and we can say day equals
70:11 - equals 2 and then we can print
70:14 - Tuesday perfect so if we try that
70:16 - now there we go so now we have the
70:18 - ability to print out Monday and choose
70:20 - it to the console depending what day the
70:22 - week the user enters
70:24 - but since we're going to have seven
70:25 - different paths because we got seven
70:27 - days of the week then sometimes it might
70:29 - be better and cleaner to use a switch
70:31 - statement so let's have a look at the
70:32 - syntax so we can type in switch and then
70:35 - inside the brackets it's what variable
70:36 - we want to have a switch on so in this
70:39 - case we want to be using the day
70:40 - variable so we can add day in the
70:41 - brackets this is not a condition in the
70:43 - brackets this is just telling us what
70:45 - variable we're going to be using for the
70:47 - switch statement so let's open the curly
70:49 - braces after and inside here instead of
70:51 - having paths like this we're going to
70:53 - use cases so this can be translated to
70:56 - in the case of number one we can do this
70:59 - in the case of number two we can do this
71:02 - so let's try and see how it works we can
71:04 - type in case followed by number one and
71:06 - then add a call on and then we can type
71:08 - out our Monday in here and then we need
71:11 - to follow each case off by finishing the
71:14 - section off with a break this break is
71:16 - very essential and you'll get a syntax
71:18 - error if you don't put it in so now if
71:20 - we do case two and we do exactly the
71:22 - same thing there we go and if I dismiss
71:25 - the break then you'll realize that it
71:27 - says it cannot fall out so we have to
71:29 - use a break just the compiler knows that
71:31 - we want to break here the reason why
71:33 - this break is placed inside here is
71:35 - because what we can do is we can say
71:38 - case two and then add another one in
71:41 - here called case three and what this now
71:43 - reads is if we enter two it says Tuesday
71:47 - and if we enter three It also says
71:49 - choose it so what you can do is you can
71:52 - actually chain so this would be
71:53 - equivalent to writing if D equals 2 or D
71:57 - equal equals 3 now this is exact
72:00 - translation these two are exactly the
72:02 - same as of right now we have D equals
72:04 - equals 1 which is our case 1 and then
72:07 - equals 2 or equals 3 is right here if we
72:11 - go into the case 2 path it will fall in
72:12 - the case 3 so we're saying for this
72:14 - break is we want to end this section
72:17 - here so now if we just revert this back
72:18 - and continue the
72:20 - chain I'll just skip this part just so
72:22 - it's a little bit quick
72:26 - there we go so now that we've got all
72:27 - seven days of the week let's just see if
72:29 - it works let's try six and we have sat
72:31 - it so now we're kind of missing
72:33 - something from here the only thing we're
72:35 - missing is having our external else just
72:38 - in case the user types something invalid
72:40 - so normally we would write something
72:41 - like this enter value between 1 and 7
72:46 - just to make sure that the user knows
72:47 - what they're
72:48 - doing now we don't seem to have anything
72:51 - inside here that gives us the
72:52 - opportunity to it in invalid so we have
72:54 - this keyword called default and it works
72:57 - exactly the same as the case except what
72:59 - this will do is this is basically the
73:01 - word that replaces else so we can
73:03 - literally take this line of code and
73:05 - place it again over here and add
73:07 - ourselves a break this is exactly the
73:09 - same as doing our L statement inside
73:11 - here if none of these cases match this
73:14 - variable then it'll go into the default
73:16 - and continue as normal so if we type in
73:18 - zero we should see the message twice
73:20 - because it's executing for the if
73:21 - statement and executing down here and
73:24 - let's do eight and you see the message
73:26 - again so now that the case statement is
73:28 - fully working let's just comment out the
73:29 - if statement and make sure that it's
73:31 - still works one Monday let's just try
73:34 - another one and we can do seven for
73:36 - Sunday so just a quick recap case
73:39 - statements are used by using the keyword
73:40 - switch followed by the variable in
73:42 - question and then if you want to check
73:44 - if this variable number is equal to
73:46 - something you put that something
73:47 - straight after the word case followed by
73:50 - a colon and then you can insert multiple
73:52 - lines of code inside here and make sure
73:54 - you end that line with a break if you
73:56 - want to chair in multiple like Dayal 2
73:59 - or Dayal 3 then you can add the case
74:01 - above right here so the case of zero or
74:05 - the case of two it will do this little
74:07 - section so it'll print out choose there
74:09 - if the user enters zero or the user
74:11 - enters two of course in this case we
74:13 - don't actually want that after you
74:15 - filled out all of the code make sure you
74:17 - add something called the default the
74:19 - default is equivalent to an lse keyword
74:21 - in our if statement just to catch all
74:22 - the Val use in case the users type
74:25 - something incorrect and you want to let
74:26 - them know what they should be typing
74:30 - instead so now that we explored
74:32 - different paths in our code using IF
74:33 - statements and switch statements let's
74:35 - have a look at how we can iterate
74:36 - through our code an iteration in code is
74:39 - just the ability to be able to Loop and
74:41 - do a certain task so let's say we wanted
74:43 - to print high to the console several
74:46 - times then we just have to copy and
74:47 - paste it down and this will be five
74:49 - separate lines that do exactly the same
74:51 - thing this will essentially achieve what
74:54 - we want the problem is you just have
74:56 - exactly the same code copy and pasted so
74:59 - what we can do if we just block comment
75:01 - this line for the time being we can
75:02 - write something called a for Loop a for
75:05 - Loop gives us the ability to Loop a
75:07 - certain amount of times depending on the
75:08 - parameters that we give it so this is
75:10 - the syntax you can type for open the
75:13 - bracket and we have to use a variable so
75:15 - we can declare a new variable straight
75:17 - into these brackets we can say in I
75:19 - equals z and then have a semicolon and
75:22 - there's three different sections of this
75:24 - the first one is the variable decoration
75:26 - and initialization and the second one is
75:28 - the condition so in this case we want to
75:30 - do this task five times so you want to
75:33 - say I is less than five then we end that
75:35 - semicolon there and now for the third
75:37 - task every time this fall Loop goes
75:39 - around we want to increase I by one
75:42 - because we want to go in steps of one so
75:44 - we can do
75:45 - i++ alternative if you don't like using
75:48 - Plus+ you can say I = I + 1 or to make
75:52 - that quicker you can could say i+ equals
75:54 - 1 I personally just prefer using Plus+
75:57 - and you'll see that everywhere else
75:59 - there is certain cases where you would
76:01 - actually you want to change this to a
76:02 - different value like i+ equal 2 and
76:04 - we'll show you that in a second so this
76:06 - for Loop now says we want to go from
76:08 - ials Z and once this condition returns
76:11 - back false when I is equal to 5 or
76:14 - greater then we want to stop this for
76:16 - Loop every time this forp goes around so
76:18 - when it hits this curly brace and comes
76:20 - back around we want to do this action
76:22 - and in this this case it's I ++ so if we
76:25 - just use console right line and print
76:27 - out the value I we can see what happens
76:29 - when the follow
76:31 - runs you can see that the value of I is
76:34 - increasing one each time and after the
76:36 - fifth time is increased the value is
76:39 - actually five so now this statement is
76:41 - false because the value of I is equal to
76:44 - five so therefore this is now false and
76:46 - the fall Loop is ended so now that we've
76:49 - verified that you can repeat it five
76:51 - times using this code we no longer want
76:53 - to print I we want to print our high so
76:55 - let's paste that inside the bracket and
76:57 - run the code now you can see that these
76:59 - two values will be exactly the same as
77:02 - printing it out to the console just like
77:03 - this but now we have a lot less code so
77:07 - let's have a look at another example we
77:08 - can say 4 in I equal 0 and we can say I
77:12 - is less than or equal to 10 and then we
77:16 - can do i+ equal 2 and then if we just
77:19 - print I to the console so what this is
77:21 - now saying is I want to go from zero all
77:24 - the way till 10 and I want to go up two
77:27 - times each time so what this will be
77:29 - achieving is printing out all of the
77:31 - even numbers between 0 and
77:33 - 10 let's try and run
77:36 - it now we can see we have all the even
77:38 - numbers printed out between 0 and 10
77:41 - because we're going up in
77:42 - twos if we start this at one for example
77:45 - and still keep every parameter exactly
77:47 - the same then we'll be getting all of
77:49 - the even numbers between 1 and 10 11 is
77:52 - missing because our condition stops at
77:54 - less than or equal to 10 what you can
77:56 - also do with for Loops is you can let
77:57 - the user determine what this value is
78:00 - going to be let's test that so if we
78:03 - block comment this section out what we
78:05 - can do is we can append this little
78:06 - section so we can have a console. right
78:09 - how many times do you want to say hi can
78:13 - have a callon followed by speech marks
78:15 - and then we can say int Loop counter
78:18 - equals convert to n32 and we can have
78:21 - console read line inside the brackets
78:24 - how many times you want to say hi the
78:26 - user types in the value we take the
78:28 - console read line as a string convert it
78:30 - to an integer and St inside loop
78:33 - counter so now what needs to change
78:35 - inside here the five is what determines
78:38 - how many times that we're going to Loop
78:40 - so in this case we actually want to just
78:41 - Loop by whatever the user types in the
78:43 - counter let's just type five and make
78:46 - sure it works and if we just type one it
78:50 - works if we type zero however however it
78:53 - will just skip over the for Loop and the
78:56 - reason for that is if you're going from
78:58 - zero to I is less than zero then this is
79:00 - immediately going to be false so then
79:02 - the for Loop is just going to get
79:04 - skipped immediately there is nothing to
79:06 - do if the user is typed in zero which is
79:08 - perfectly reasonable and you can type in
79:10 - a really big number like a 100 and it
79:12 - will output them all to the
79:15 - screen if the user types in zero then
79:18 - nothing's going to come up so you always
79:19 - want to be able to let the user know if
79:21 - there's something wrong so we can say if
79:23 - the loop counter equals equals to zero
79:26 - or maybe we can change this to less than
79:28 - or equal to cuz it could type in minus
79:30 - numbers as well we could just say conso
79:33 - right line using CW tab tab sorry please
79:37 - enter a value above
79:39 - zero and then if this condition has
79:42 - returned back false then inside our else
79:44 - statement we don't need to give it an
79:46 - else if because if it's less than or
79:48 - equal to zero then we want to process
79:50 - the other values because it has to be
79:53 - greater or equal to
79:55 - one so when this is false this section
79:59 - has to be greater than or equal to one
80:01 - so we can just place our for Loop inside
80:03 - here and that's fine and let's try to
80:05 - run the code now and if we type in zero
80:07 - please enter a value of zero and if we
80:09 - just try any negative values we'll get
80:11 - the same message if you want to print
80:13 - additional code in here you can
80:15 - literally do anything you want you can
80:17 - even ask the user what they want to
80:18 - print up here and then you can replace
80:20 - this with a message for example we can
80:22 - have a string
80:24 - message and we can just change this to
80:26 - hello world and this could be something
80:28 - that you read in from the console so we
80:30 - can say message and we can put that in
80:32 - here and if we print that there we
80:35 - go so we can just say console.
80:39 - right what do you want to repeat and
80:43 - then we can read this
80:45 - in and actually it might be easier if we
80:48 - change this Loop counter to Second so if
80:51 - we highlight the section and hold alt
80:53 - and press down arrow twice we can move
80:54 - it down and say and how many times do
80:58 - you want to repeat it there we go so now
81:03 - what we can do is we can use this
81:05 - message inside here and then Loop
81:07 - depending on how many times the users
81:09 - typed in whatever so we can type in
81:11 - hello world get this exact value and we
81:13 - can say 10 times there we go so now this
81:16 - entire program is fully customized by
81:18 - the user's
81:20 - input so let's just have a quick recap
81:22 - so we started off this code by printing
81:25 - the console right line five times to the
81:26 - screen we wrote Our simple far Loop that
81:29 - went from in equal Zer to I is less than
81:32 - 5 and we did I ++ because we want to
81:35 - count up in ones you can place the high
81:37 - inside here and it'll printed it five
81:39 - times for us so now we've made our code
81:41 - from five lines down to just three lines
81:44 - for the for Loop and then we allowed the
81:46 - user to type in how many times that they
81:48 - want to repeat it and we change the
81:50 - condition from I is less than five to I
81:52 - is less than whatever the user has typed
81:54 - in installed within the loop counter and
81:57 - then we hit a problem where if we
81:59 - entered zero anything less than zero the
82:01 - F would just not run and it might look
82:03 - like some things went wrong so we added
82:05 - a little if statement in here to make
82:07 - sure that the user has entered a value
82:09 - above zero and if they haven't we can
82:11 - let them know we don't need another if
82:13 - statement in here because if this has
82:15 - returned back false we can assume that
82:17 - the value is something that we can work
82:19 - with we later tailored the program so we
82:22 - can change this message that was fixed
82:24 - to high to something that the user can
82:26 - type in
82:28 - manually so now that we know how to use
82:31 - for Loops let's have a look at while
82:32 - Loops for loops and while Loops still
82:35 - iterate through code but they're used in
82:37 - slightly different contexts for Loops
82:39 - are used mainly when you know how many
82:41 - times you can iterate through as in this
82:43 - example we're going to printer the
82:45 - console exactly 10 times but in a y Loop
82:48 - you might print until a condition is
82:50 - true for example if you asking the user
82:52 - to type a number and they kept typing in
82:55 - something else you don't know how many
82:57 - times it's going to take the user to
82:59 - type in correctly so in that case you
83:01 - would use a y Loop if you executing a
83:04 - certain amount of code and you're only
83:05 - doing it a fixed amount of times then
83:07 - it's always best to use a for Loop so
83:10 - first let's try and convert this simple
83:12 - for Loop that just prints I to the
83:13 - console 10
83:15 - times just like so from zero all the way
83:18 - till 9 so let's comment out this for
83:20 - Loop and have a look at this Syntax for
83:23 - the while loop so we can type the world
83:25 - while and then in here we have our
83:27 - condition and then we can open our curly
83:29 - braces and while this condition returns
83:32 - back true it will always go inside the
83:34 - curly braces and when this condition
83:36 - returns back false then we'll exit the
83:38 - while loop so let's try and mimic
83:41 - exactly what we're doing inside here
83:43 - there's three sections of the for Loop
83:46 - we Define the variable that we're going
83:47 - to use for the for Loop counter and we
83:49 - give it an initial value we give it the
83:52 - stop dring condition and we give it how
83:54 - many times the value needs to go up
83:56 - every time the fall Loop iterates in the
83:58 - while loop situation we only have the
84:00 - condition available so let's take our
84:02 - condition and paste it straight into
84:04 - here and now we need to store our
84:06 - variable so just because it's a while
84:08 - loop when we can't store it inside here
84:10 - we have to do it outside the Y Loop so
84:12 - let's make it in I and we'll make it
84:14 - equal to zero so we've got our variable
84:17 - we've got our condition now we need to
84:19 - set I ++ so inside the Y Loop we can say
84:23 - i++ and then now we've achieved this
84:25 - entire line and successfully converted
84:28 - it let's try and put the console right
84:30 - line in and see what
84:32 - happens and let's run the
84:34 - code so it's going from 1 all the way
84:37 - till 10 and the reason why it's gone
84:39 - from 1 till 10 not from 0 to 10 is
84:42 - because the i++ is at the start let's
84:44 - move it down online using alt and down
84:46 - arrow key to move it down and let's run
84:49 - it again and you can see it goes from 0
84:50 - to 99 and if we just block comment this
84:54 - out and undo the for
84:57 - Loop you can see that they're doing
84:59 - exactly the same thing so let's bring
85:01 - the W loop
85:03 - back and as you can see what we have is
85:07 - we've defined our I variable made it
85:09 - equals to zero while the I variable is
85:12 - less than the value of 10 we print the I
85:15 - to the console and increment I by one
85:17 - and we keep looping this until this
85:20 - statement returns back false and then
85:22 - exit the Y Loop and jump underneath the
85:24 - curly braces and hit the console read
85:26 - line and this is the output that we've
85:28 - got so now I've just copied the code
85:30 - from the if statement video and let's
85:32 - make this code a little bit better so
85:34 - let's comment out our while loop and our
85:36 - for Loop that was just used for
85:37 - explanation purposes and this is the
85:39 - code that you saw earlier on in the C we
85:42 - read in the first number start as a
85:43 - string use that string to convert to an
85:46 - integer star number a and Then star
85:48 - number B and these two blocks are
85:50 - exactly the same except you have have
85:52 - enter first number and enter second
85:54 - number and we store number a and store
85:56 - number B then we store the value of them
85:58 - both multiplied inside our int answer
86:02 - variable then we ask the user what's the
86:04 - value of both answers times together
86:07 - give them a chance to input their value
86:09 - convert it to an integer and then we
86:11 - check the value and print well done of
86:13 - close but it was wrong now if we run
86:15 - this code again and we type in 10 and 10
86:19 - and we know the values of 100 but let's
86:21 - just type in 90 now this is kind of a
86:23 - problematic user case we've asked the
86:26 - user to type in a value and they've got
86:28 - it wrong and then when they press enter
86:30 - the program just closes there's no
86:32 - opportunity to Loop or try this again so
86:35 - what we can do is add a y Loop in here
86:37 - and we can say while the answer is
86:39 - incorrect we can keep asking the user to
86:41 - keep on guessing so instead of reading
86:44 - the input here let's turn this little
86:45 - section into a question what's the value
86:50 - of number a * number B and instead of
86:52 - allowing an input here let's just put a
86:54 - question mark and then let's add a
86:57 - console right line just to give a little
86:58 - bit of a gap and then in order to do our
87:01 - while loop we actually want to create a
87:03 - bolean variable just to track if the
87:05 - answer has been correct or
87:07 - not this is the section that we want to
87:10 - loop around in the while loop we want to
87:12 - read in the user's answer check it
87:14 - output a message and then give them the
87:16 - opportunity to read in another value so
87:18 - they can guess again while the answer is
87:21 - not not equal to the actual answer then
87:24 - we can loop around our code so we have
87:27 - to modify a few things here so we can't
87:29 - just take this code and place it inside
87:31 - the problem with doing this is the
87:33 - variables that we want to check answer
87:35 - is outside of this y Loop but actual
87:38 - answer is inside and the reason why
87:40 - there's a red line here says it does not
87:42 - exist in the current context because
87:44 - we're trying to check a variable that
87:45 - hasn't been defined yet so what we can
87:47 - do is take the decoration for the actual
87:50 - answer and place it outside here and
87:51 - make make it equal to zero and instead
87:54 - of redeclaring it inside the while loop
87:55 - we can take this in and get rid of it so
87:58 - we set the actual answers to zero set
88:00 - the answer to the multiplication while
88:02 - the answer is not equal to the actual
88:04 - answer then we want to loop around so we
88:07 - don't actually need another check in
88:08 - here this while loop will keep on
88:11 - repeating if the answer is incorrect so
88:13 - we don't need a path for correct and
88:15 - incorrect if this while loop still
88:17 - continues then the answer will always be
88:19 - incorrect so what we can do to double
88:21 - check is we can say if the answer does
88:24 - not equal the actual answer then we can
88:27 - place this message inside here and get
88:29 - rid of this
88:31 - branch and then after the while loop has
88:34 - continued we can say Well done so let's
88:37 - just read through the code while the
88:39 - answer is not equal to the actual answer
88:42 - and when this while loop first enters
88:43 - it's going to be true because you're
88:45 - going to have 10 * 10 which is 100 and
88:48 - the value of answer is zero so this will
88:50 - return back true cuz these two values
88:52 - are not equal to each other then we're
88:54 - going to ask the user to enter the value
88:56 - then we're going to read into the actual
88:58 - answer check if they're not equal to
89:00 - each other and then we output a message
89:02 - because we're asking a question here we
89:04 - want to ask another one using a console
89:06 - right Line enter your answer call on
89:11 - here we go so let's have a look and see
89:13 - how this
89:14 - works 100 100 what's the value of 100 *
89:18 - 100 and let's just get it wrong on
89:20 - purpose 90 call is wrong and now we get
89:23 - to answer again and we can keep
89:25 - answering this as many times as we want
89:27 - until we reach the correct answer which
89:30 - in this case is 10,000 and we've got the
89:32 - answer well done so to make the console
89:35 - look a little bit better cuz this is all
89:37 - in one block we can separate these with
89:39 - console right lines maybe after this
89:41 - line we can print out a new line and
89:43 - then after each guess we can print out
89:45 - another new line so after each guess
89:47 - we'll be down here we can just print out
89:49 - a blank console right line and just
89:51 - after after you ask them to enter the
89:53 - second number we can print another one
89:54 - here and let's just see how that looks
89:56 - 10 10 now it looks a lot better because
89:59 - you ask the user to input the numbers
90:01 - then you ask them the question and then
90:03 - you get the answer and then it keeps
90:05 - looping around like
90:06 - this so there's a little gap between
90:08 - each one so you can efficiently read it
90:10 - instead of it all being closed off
90:12 - together and now if you answer it
90:13 - correctly 100 now it says well done and
90:16 - when we press enter again the program
90:18 - now closes so that was using a while
90:20 - loop and now we have something else
90:22 - called a do while and a do while is very
90:25 - close to a while except that the while
90:28 - will only happen if this condition
90:30 - returns back true and a do while will
90:32 - always happen once and it'll check the
90:35 - condition at the end so let's have a
90:37 - look and see how this works so we write
90:38 - the word do and then we have the curly
90:40 - braces and then after it we have our
90:42 - while condition and let's just copy the
90:45 - condition from the old while loop and we
90:47 - can say answer is not equal to actual
90:49 - answer so as you can see with a while
90:52 - loop it will always check the condition
90:53 - first and then it opens the curly braces
90:56 - in the do there is no condition it will
90:59 - always do everything inside the curly
91:01 - braces once and then it will check this
91:03 - while condition if this condition is
91:06 - still true then it'll loop around and
91:08 - check it every time but it will only
91:10 - check it at the end while Loops will
91:12 - check the condition as the first thing
91:13 - it does and then check it every
91:15 - iteration so let's move our Corde down
91:18 - into here and let's just comment out our
91:21 - while loop just to see how this works
91:24 - and if we run it again to make sure it's
91:25 - working fine 10 10 90 90 50 and then
91:30 - finally 100 and it says well done so you
91:33 - could be thinking what are the
91:34 - differences between a while loop and a
91:36 - do while in certain cases you want the
91:38 - while loop to make sure this condition
91:40 - is true before even continuing in this
91:43 - specific case we always want the user to
91:46 - answer the question it doesn't matter if
91:48 - it executes once because actually that's
91:50 - the behavior that we want
91:52 - we've asked the user a question right
91:54 - here so we want to always be looping at
91:56 - least one time the while loop user case
92:00 - doesn't quite apply here because we
92:02 - don't necessarily have to check if
92:03 - they've answered correctly if they
92:05 - haven't even inputed a value yet we
92:08 - always want to be able to give them the
92:09 - option to do it once and then we check
92:12 - their answer at the end they could get
92:13 - it on the first answer 10 10 100 and
92:17 - it'll still be fine the same is true
92:19 - with a while loop but it'll B easier and
92:22 - it makes more sense to read your code
92:24 - when you have a while loop you can see
92:26 - that this bit of code depends on a
92:28 - condition whereas in a due while the
92:31 - first iteration does not depend on
92:33 - anything but the second and third and so
92:35 - forth depend on the condition so
92:38 - depending on your user case and what
92:40 - situation you want to use it you should
92:42 - either pick a while loop which will only
92:44 - occur through a condition or pick a do
92:46 - while that will occur once or multiple
92:49 - times after the first condition has
92:51 - passed
92:54 - so when you have if statements that are
92:56 - pretty basic you can actually make them
92:58 - quite easy to read through the
93:00 - conditional operator also known as the
93:02 - Turner operator so let's see how this
93:04 - works let's say we have an INT ede and
93:06 - we set it to a minus value and we know
93:09 - that this value can never be someone's
93:11 - age because it's negative but let's say
93:13 - that we have a situation where you ask
93:15 - the use it for their age and they've
93:16 - accidentally typed in -10 and we know
93:19 - that that value is not actually true so
93:21 - we could write something like this age
93:24 - is greater than or equal to zero then we
93:26 - can print out
93:27 - valid and then in the lse we can take
93:31 - this console right line and we can print
93:33 - out invalid so that means if we run our
93:35 - code now you can see that it says
93:38 - invalid and if we change it to positive
93:40 - 10 now it says valid so this seems a
93:43 - little bit long we are just checking one
93:46 - condition printing a value and printing
93:49 - another value if that condition returns
93:51 - back false so our conditional operator
93:53 - works like this we have a condition
93:56 - followed by question mark then the value
93:59 - if it returns true then the value if it
94:01 - returns false let's see how you can
94:03 - rewrite this if statement into one
94:05 - simple line so let's take this in
94:08 - steps these two values are both strings
94:11 - that we've typed in so let's make a
94:14 - string and we can call it result and
94:16 - let's make it equal to our Turner
94:19 - operator so the first step is to get the
94:21 - condition and the condition in this case
94:23 - if the age is greater than equal to zero
94:26 - we can follow that by a question mark
94:29 - and then if this returns back true we
94:31 - want the string to say valid and we can
94:34 - have a call on and if it returns back
94:36 - false then we want the string to say
94:38 - invalid and we can add a semicolon and
94:41 - then straight after it we can just have
94:43 - a console right line that just says
94:45 - result as you can see now that we get it
94:47 - twice we can verify one comes from the
94:49 - if statement and one comes from from the
94:51 - turny operator and now if we make this a
94:53 - positive 10 then you can see it both
94:55 - says valid so if we comment out the if
94:58 - statement and just see this running on
95:00 - its own just to double check there we go
95:03 - and because this is just returning back
95:04 - a string we can actually just take all
95:07 - of this code in the conditional operator
95:09 - and paste it straight into the console
95:11 - right line so you run the line of code
95:12 - now we get exactly the same thing if
95:15 - this hurts the readability of your code
95:18 - then it's best to just store it and then
95:19 - use it after if you can read this code
95:21 - and it's better for you in the long run
95:24 - later on you might want to dismiss this
95:26 - variable and do it straight inside the
95:27 - brackets just to save a variable and
95:30 - then print it out to the screen straight
95:32 - away it'll be better for memory if you
95:34 - just print it out straight away but if
95:36 - you're not familiar with this notation
95:38 - yet and you want to get used to it then
95:39 - that's fine as well so a quick recap we
95:42 - had an if statement with a condition and
95:44 - if this returned back true we printed
95:46 - valid and if it return back false we
95:48 - print invalid and this is pretty simple
95:50 - the only difference between these two
95:52 - paths is this string literal that we've
95:54 - typed into here so we can pull the
95:56 - string values out and place them in our
95:59 - conditional operator we can say string
96:01 - result is equal to if the age is greater
96:04 - than or equal to zero then we store
96:07 - valid inside result and if it's not
96:09 - greater than equal to zero then we can
96:11 - start inv valid straighten our string
96:14 - after we've start this value we can
96:15 - print results straight to the screen
96:17 - which will either give us valid or
96:20 - invalid
96:23 - when you're dividing two numbers you
96:24 - might get an ugly output just like
96:27 - this the user sometimes doesn't want to
96:29 - see such long decimal places and maybe
96:32 - you just want to prevent it to
96:34 - 81.3 in order to do this we need to use
96:37 - a format pattern so the language
96:39 - understands what we're trying to achieve
96:40 - so if we make another console right line
96:42 - what we can do is use string. format and
96:45 - inside the brackets we can give it a
96:47 - format and then the object that we want
96:48 - to format so in this case the object in
96:50 - the second parameter is our value so
96:53 - let's open some speech marks go to the
96:56 - next parameter using the comma and just
96:58 - type in our value and then inside the
97:01 - speech marks we want to type in the
97:02 - pattern if you type in curly brace as
97:04 - zero then zero represents the first
97:07 - value in this list we can do a space
97:10 - followed by curly braces one and then
97:12 - add another comma and we can add a
97:14 - thousand and what this means is value
97:17 - will get placed where zero is and 1,000
97:19 - will get Place one is
97:21 - so let's run this and you see the exact
97:24 - same thing's happened plus a SP and now
97:27 - we have the Thousand which follows this
97:29 - part exactly if this is confusing don't
97:32 - worry too much about it I have the next
97:33 - section all about string functions so
97:36 - let's get rid of the one followed by the
97:38 - thousand and run it again and we should
97:40 - see the output being exactly the same
97:42 - there we go so now let's see how we can
97:45 - make this better in terms of decimal
97:46 - places so just after the zero and the
97:49 - zero represents the first value value we
97:51 - can add a callon and this callon will
97:54 - tell us what format we want the value to
97:56 - be displayed as we can type in
97:59 - 0. and what this means is all the
98:01 - numbers before the decimal place will
98:03 - get displayed and only two numbers after
98:06 - the decimal place will get displayed so
98:08 - let's try run this now and you can see
98:09 - that the code output is a lot cleaner
98:12 - one thing to note though by default this
98:13 - will round it up 0.37 becomes
98:17 - 0.4 not to worry though cuz this is what
98:20 - the user will see on the screen and it
98:21 - won't affect the actual value of the
98:23 - variable if we print out value straight
98:26 - after you'll see that the difference
98:28 - hasn't been changed it's still 0.3 in
98:31 - the original variable so that's one
98:33 - method of doing it what we can do now is
98:35 - just use contr D and copy it down and we
98:38 - can use different formats to show you
98:39 - what it looks like if we remove the 0
98:43 - and then one of the zeros and leave it
98:45 - like this and it grains one decimal
98:47 - place each time you'll see what the
98:49 - output looks like we just have the 81
98:52 - which essentially makes it into an
98:54 - integer because it's a whole number then
98:56 - we have
98:57 - 81.0 and the reason why it's 0 Z is cuz
99:00 - 0.3 will round down as it's under
99:03 - 0.5 the 03 is going to round down as
99:06 - it's under 05 so it'll round down to
99:09 - zero and then finally we have the
99:13 - 81.4 and just like before this will
99:15 - round down
99:16 - to4 and just like before this will round
99:19 - down to 0.4
99:21 - this will round down to
99:23 - 04 let's say you wanted to get rid of
99:25 - trailing zeros because you don't want
99:27 - them then you can actually change this
99:29 - zero to a hashtag once you onun the
99:31 - hashtag then it will trim off any
99:33 - trailing zeros so what this means is it
99:36 - will try and put it in this format but
99:38 - if this format happens to be a zero then
99:40 - it will just keep it like this and if
99:42 - you just have 81 dot then it'll also get
99:45 - rid of the dot for you so then you just
99:46 - left with
99:47 - 81 it's really up to you as the
99:50 - programmer what you want want to display
99:51 - depending on what context I'm just
99:53 - giving you the options that you have
99:55 - available so let's say we want to work
99:57 - with money now and we have a 10d divided
100:00 - by 3D and what that value would be is
100:03 - somewhere between 3333 and this will be
100:05 - reoccurring cuz it's exactly 1/3 the
100:08 - reason why I've got D's in here is
100:10 - because these are registering as doubles
100:12 - if you type the value in normally it'll
100:14 - get registers an in32 and the problem
100:17 - with in32 is when you do this division
100:20 - it will process the division is an
100:21 - integer and then store it as a double
100:24 - the issue with that is in this case and
100:26 - in this case both values will get truned
100:29 - let me demonstrate if I remove the D
100:31 - from both sides and down in here it will
100:33 - see what the difference is and let's
100:35 - print out money and then's see what's
100:38 - happened in the first case this isn't
100:40 - actually an issue because we have a
100:42 - decimal place here which means this will
100:44 - be a double so an integer divided by
100:46 - double will give us a double but we just
100:48 - place the D here just so we don't forget
100:50 - and and it makes the compiler's job a
100:52 - lot easier cuz it doesn't have to
100:53 - convert it from an integer to a double
100:56 - and in this case we have an INT that's
100:58 - divided by an INT so we'll get 3.3
101:01 - reoccurring but because it's processing
101:03 - as an integer then we just get three
101:05 - being displayed and this is not the
101:07 - intended result so let's just replace
101:09 - these back to D's and we'll see what we
101:10 - get now which is a 3.3 perfect so let's
101:14 - say that we want to display this as
101:16 - actual currency because you never see it
101:18 - displayed like this it's always to two
101:20 - decimal places just as follows so we can
101:23 - follow the same approach as
101:25 - above we can do string.
101:28 - format 0 call on 0.00 and the curly
101:32 - brace and then common money cuz that's
101:33 - the variable in reference and now if we
101:35 - run that let's see what happens
101:38 - 3.33 that's perfect and now what we can
101:41 - do in here because this is the pattern
101:43 - we can actually type in anything before
101:45 - after this and it won't affect the
101:47 - pattern just like so we've added some
101:49 - Extra Spaces in here so if we get rid of
101:51 - these spaces we can actually just place
101:53 - a pound sign in front of it and then
101:56 - let's see what happens when we run it
101:58 - perfect so now we actually have some
102:00 - money and we can say in here £10
102:05 - /3 equals
102:07 - this and now our output looks a little
102:09 - bit better because we have some
102:11 - formatting now the issue is when we
102:13 - start getting into negatives let's see
102:15 - what happens so we can say -10 /3 equals
102:21 - something and when we run we'll see that
102:23 - the format is actually incorrect
102:26 - now you never see the negative symbol
102:29 - after the pound symbol it's always this
102:31 - way around in this case what we're doing
102:34 - is we're telling the compiler hey we
102:36 - only want to see two decimal places but
102:39 - always keep in this format the pound
102:41 - sign followed by the value and the value
102:44 - of money is -3 so it'll Place -3 inside
102:47 - here and then add the pound sign before
102:50 - it but we don't don't exactly want that
102:52 - so we can add something called a culture
102:54 - info but we can also give it some other
102:56 - formatting some other way so let's
102:58 - explore some other
103:00 - options if you use money to string then
103:03 - what we're actually doing here is using
103:05 - the double variable and converting it to
103:07 - a string and we get passed back a string
103:10 - representative of this value and that's
103:13 - fine and when we run the code you'll see
103:15 - no difference between these two at this
103:17 - point they're both being converted to
103:19 - Strings but what we can do in this case
103:22 - is when we open these brackets it tells
103:23 - us there one of four what does this mean
103:26 - exactly so in our two string function we
103:28 - have four ways that we can call this
103:30 - function the first way you give nothing
103:32 - in the
103:35 - brackets and if we press the down arrow
103:38 - the second way is to give it a format
103:40 - provider the Third Way is just a string
103:42 - format and the fourth way is both a
103:45 - format and a provider so we'll use all
103:47 - of these in a second but let's explore
103:49 - the easiest one if you add a string in
103:51 - there which gives us the third overload
103:53 - string format and we can just type in a
103:55 - Capital C let's just see what
103:58 - happens perfect so now we have the best
104:01 - format displayed to us and the reason
104:03 - why this works is the C program will
104:06 - recognize that the format of C is
104:08 - telling us that we want to display
104:10 - currency so then it's going to your
104:12 - local machine and figuring out where you
104:14 - are based on your date and time just
104:16 - down here when you have adjust date and
104:18 - time it will figure it out based on this
104:21 - we have UTC time and we have the date
104:23 - and time listed up here based on that
104:26 - information it can figure out that we
104:27 - are indeed in the UK and we want to
104:29 - display a pound sign and because the
104:31 - program knows that it's - 3.33 it'll put
104:34 - the pound sign in the right location so
104:37 - now that we've explored C let's have a
104:39 - look at the other ones that are
104:40 - available so if we use contrl D and copy
104:42 - this down three times we can use C 0 C1
104:46 - and C2 and now if you run this again
104:48 - you'll see what the output gets you
104:51 - c will get your currency in its most
104:53 - native form which is what we're used to
104:55 - using in the UK C zero will only return
104:58 - you back with the whole number C1 will
105:00 - give you one decimal place and C2 mimics
105:03 - C on its own as they're displaying the
105:05 - same values now this is where it gets
105:08 - interesting if you want to display a
105:10 - different currencies then you're going
105:11 - to have to use this thing called a
105:13 - culture info which will be able to
105:14 - retrieve back different currency formats
105:17 - based on a certain country code that you
105:19 - give the function
105:21 - so let's have a look and see how that
105:23 - works if we scroll to the top we can add
105:25 - a new library called system.
105:27 - globalization inside globalization we
105:29 - have a culture info so let's see how we
105:32 - can tailor these to make it look a lot
105:34 - better if you're worried about different
105:36 - currencies so we use CW tab tab and we
105:39 - do the same thing money. two string we
105:42 - add our C and this is where our format
105:44 - provider fits in so we can start typing
105:47 - culture info it should come up like this
105:50 - press enter and inside this is a class
105:53 - that's why it went green if we press dot
105:56 - then we get the current culture the
105:58 - current culture will decide based on the
106:00 - machine that the program is running on
106:02 - if this program is running on a cloud
106:04 - computer and the cloud computer is
106:06 - stored in Europe then it might display
106:08 - euros and if it's stored in America then
106:10 - it'll display dollars so you want to
106:12 - avoid using current culture if you're
106:14 - going to scale your program worldwide in
106:17 - the case of this example I'm going to
106:19 - leave it because as you you can see when
106:20 - I run it it will display the same thing
106:22 - as the other ones because this one will
106:25 - also recognize that my current culture
106:27 - is UK and I'm also telling it to use the
106:30 - current culture so in both of these
106:31 - cases it's figured out that my current
106:33 - culture is indeed the UK and it started
106:36 - using the pound sign but let's say we
106:38 - want to give it a different culture then
106:40 - what we can do if we duplicate this line
106:42 - using contr D and remove this section
106:45 - just after the dot we can actually say
106:48 - create specific culture and inside the
106:51 - parentheses we can actually add a string
106:53 - and it says here a predefined culture
106:55 - name or the name of an existing culture
106:57 - info object the name is not case
106:59 - sensitive so in the case of the UK you
107:02 - have English GB and now we need another
107:05 - bracket at the end and then if we use
107:07 - controll D to copy this down we can
107:10 - change GB to us let's run this again and
107:13 - see what
107:16 - happens these two don't actually output
107:18 - anything different because we're just
107:20 - doing the normal culture and then we're
107:22 - telling it to find the GB culture which
107:24 - is exactly the same thing for me so we
107:26 - get these two values exactly the same
107:28 - and apparently it's picking up that in
107:30 - the US you have brackets around your
107:32 - negative values which I can't personally
107:34 - validate but this is how it's showing up
107:37 - so let's try some other cultures and see
107:39 - what happens so we can try Au for
107:43 - Australian then you can see that they
107:45 - actually use a negative followed by the
107:47 - pound sign and then the value so even
107:49 - though they're both in dollars one's US
107:51 - Dollars and one Australian dollars and
107:54 - apparently the US uses brackets for the
107:56 - negative values but Australians use the
107:58 - negative value like we do so let's just
108:01 - have a quick recap so we can display the
108:04 - value just like this but we'll have a
108:05 - problem with multiple decimal places we
108:08 - can use these former options to give us
108:10 - zero decimal places one or two decimal
108:13 - places and then when we use this format
108:16 - the problem with it was when you display
108:18 - negative numbers you get a nasty form
108:20 - format where the negative value actually
108:22 - comes after the pound sign which is not
108:24 - correct and you don't want to Output
108:26 - that to your users instead you should
108:28 - use the C format to tell the compiler
108:30 - that you want to process this as a
108:32 - currency currency processing is better
108:34 - because the software will understand
108:36 - that the value you're trying to
108:37 - represent depends on a certain strict
108:39 - format just as follows you don't want
108:41 - the negative to be here instead of
108:44 - before it because that doesn't look very
108:45 - nice to the end user alternatively you
108:48 - could use this CI info if you're going
108:50 - to scale your program scaling your
108:53 - program means that it's going to live on
108:54 - servers and this culture in for
108:57 - especially the current culture depends
108:59 - on where the program is being run on
109:01 - because it depends on the system time
109:03 - different servers will have different
109:05 - dat times set because they'll be in
109:07 - different countries so you want to be
109:09 - careful and if you want to display in a
109:10 - certain currency you can create a
109:12 - culture specification and pass the
109:15 - country code inside the brackets and
109:17 - then you'll get the correct output and
109:18 - it doesn't matter where your program
109:20 - lives if you always want to generate in
109:23 - pound symbols then you always use create
109:26 - specific culture and always specify
109:29 - NGB upon doing so you'll always get the
109:31 - pound sign and it doesn't matter where
109:33 - your program
109:36 - lives so throughout this course you've
109:38 - seen this notation a lot print out value
109:41 - using console right to give the user an
109:43 - opportunity to write on the same line
109:45 - reading their value as a string and
109:47 - store it in a variable and then use that
109:49 - variable able to convert it to an
109:51 - integer 32 and we're passing the string
109:53 - input inside here and then we convert it
109:56 - to an integer if we run the code you can
109:58 - see that this actually works perfectly
110:00 - assuming you actually enter a real
110:02 - number like 10 we press enter and it
110:05 - works and it outputs back to the screen
110:07 - using this console right line and if you
110:09 - press this restart button we can start
110:11 - the program again and let's say we
110:12 - accidentally type a character like L and
110:15 - we press enter and we've get a format
110:17 - exception now this is problematic
110:20 - because our program will now close if we
110:22 - press continue it doesn't even hit this
110:24 - line or this as soon as it hits the
110:26 - exception in here our program just
110:28 - closes if we use debug start with our
110:30 - debugging and now we're actually running
110:32 - the program outside of visual studio so
110:34 - we won't get that pop up when the error
110:36 - happens let's see what happens if we
110:38 - type this in now we can say 10p and
110:40 - press enter and now we get that the
110:42 - program stopped working you've probably
110:44 - seen this pop up a lot throughout
110:46 - Windows and different versions of
110:47 - Windows because when a program has a
110:49 - fair little error or an exception you
110:52 - see this popup appear and the only thing
110:54 - you can do is either debug or close it
110:56 - normally the debug option isn't
110:58 - available but because this is a c
111:00 - program and it's made through Visual
111:01 - Studio and the visual studio is being
111:03 - installed on the system then it gives us
111:05 - the option but really all we can do here
111:08 - is just terminate the program it doesn't
111:10 - matter what happened because we can't
111:12 - recover this if we press close then it's
111:14 - literally just going to close down it's
111:16 - going to tell us the exception and then
111:18 - press any key to continue and it's as
111:20 - you press any key then the program just
111:21 - closes so this is very fatal for our
111:24 - code since if we had some precious data
111:26 - stored in here or anywhere else in the
111:28 - program it is now lost before we can do
111:31 - anything this is problematic and we want
111:33 - to avoid this the best way to do this is
111:36 - to use something called trass right here
111:39 - the program is assuming that your string
111:41 - input is a perfect input and then you're
111:44 - immediately converting it to an integer
111:46 - now like I said what if this had 10 H in
111:49 - it the program is going to cause an
111:51 - exception and then the program is going
111:52 - to close so let's see what we can do
111:54 - with this trip pass function so the
111:57 - notation is int.
111:59 - trass the first parameter is a string s
112:02 - string s is a string containing a number
112:05 - to convert so what this
112:12 - tripassure equivalent a return value
112:15 - indicates whether the conversion
112:17 - succeeded okay perfect so we'll get into
112:19 - that in a second so our string s is a
112:22 - string containing our number to convert
112:24 - and in this case we want to be using the
112:26 - num input so we copy and paste that down
112:29 - and then we add a comma because we have
112:31 - more than one parameter now we have an
112:33 - out int result when this method returns
112:38 - result which is our integer contains the
112:40 - 32bit sign integer equivalent of the
112:43 - number contained in S and S in this case
112:45 - is our first parameter which is num
112:47 - input if the conversion succeeded
112:50 - then we get the value inside our result
112:52 - or zero if the conversion failed the
112:55 - conversion fails if the parameter s is
112:57 - null or string empty is not of the
113:00 - correct format or it represents a number
113:02 - that's less or more than the maximum
113:04 - value that the integer can stall this
113:07 - paramet is p uninitialized any value
113:09 - originally supplies in result will be
113:11 - overwritten let's dive in to see what
113:13 - this means because it's an out in result
113:17 - what this means is we can actually
113:18 - process a variable inside here like in
113:20 - Num so we can say out num and what this
113:23 - will do is when this line executes it
113:26 - will try and convert num input and place
113:28 - the value inside num so we don't need to
113:31 - run this convert anymore we can just
113:32 - specify that num is equal to zero so
113:36 - we've read in the string that contains
113:38 - our 10 H and we have our num that
113:41 - contains zero let's just remove this
113:43 - console right
113:44 - line so now we have our variable set up
113:47 - let's see what happens if we do a conso
113:50 - right line and just print num after this
113:52 - let's see what happens to the code so if
113:54 - we type in 10 H and press enter the
113:57 - value of num is zero but what you notice
113:59 - now the program hasn't caused because
114:02 - it's tried to pass it instead of just
114:05 - passing it automatically and then cause
114:07 - an exception so the reason why Try pass
114:10 - is called try pass is first it tries and
114:13 - then if it succeeds this will contain
114:15 - the value and if it doesn't succeed this
114:17 - will contain zero to know if the number
114:20 - has actually been converted we actually
114:22 - have to use the bull return value so
114:25 - what this means is because it returns us
114:27 - back a bull we can store it inside a
114:29 - bull and we can give it the name of
114:31 - success bull success equals into. trass
114:34 - we try and pass the num input and we
114:37 - place the value inside num the reason
114:39 - why having this bu success is very very
114:42 - essential let's say for example the user
114:45 - actually enters zero so technically as
114:48 - of this point num zero is actually
114:51 - correct because we've got zero and we
114:53 - initialize it to zero but of course
114:55 - after the trass runs this is still going
114:57 - to be zero now we don't know if the
115:00 - value zero is because this has succeeded
115:03 - or the value is zero because we
115:05 - initialized it to zero let me
115:07 - demonstrate if I type in a zero here is
115:11 - this zero being converted because this
115:13 - was successful or is it presenting me
115:16 - zero because this has been initialized
115:18 - to zero and the only way we can know is
115:21 - because our trip pass will return us
115:23 - back with true if s was converted
115:26 - successfully otherwise false we can
115:29 - actually write an if statement in here
115:31 - if success open the curly braces and we
115:34 - can start to type something in here so
115:36 - we can take our console right line and
115:38 - place it up here using alt and up Arrow
115:41 - key and then in the L's we can say
115:44 - failed to
115:47 - convert so now we have a mini setup here
115:51 - if it's been successful we print out the
115:53 - number if it hasn't been successful then
115:55 - it'll go into this path and it'll print
115:57 - fail to convert let's have a look and
116:00 - see how this works now if I press zero
116:03 - and I see Zero that means it's followed
116:05 - down the success path and this zero
116:08 - actually means it's converted my input
116:10 - instead of just the value that it's
116:11 - being initialized by if you run the code
116:14 - again and type in 10 hit then we
116:17 - actually see it says fail to convert
116:20 - and why that happened is we have 10 H
116:22 - appear and then this will return back
116:24 - false when it tries to convert num input
116:28 - and then after it hits this line since
116:30 - success will be false it will Dodge this
116:32 - path going into this path and output
116:35 - fail to convert what you can do if you
116:37 - really wanted to is you could wrap this
116:39 - around in a while loop so let's see what
116:41 - we can do so we can specify a bu's
116:45 - success and make that equal to true and
116:47 - then we can add a while loop with
116:49 - success in there and then open the curly
116:51 - braces and put all of this code inside
116:54 - here now we're going to have some errors
116:56 - because we got success twice but what we
116:58 - can do which will be a lot easier is we
117:01 - can place this straight inside our
117:04 - bracket and the reason why is because
117:06 - this returns us back at Boolean so we
117:08 - don't need to store it and then use it
117:11 - another thing we can do is instead of
117:13 - having Inn and then num right here you
117:16 - can actually make this a declaration as
117:18 - well so if we just remove this value we
117:21 - can write out Inn and this will do
117:24 - exactly the same thing it just uses less
117:27 - variables while our success is true we
117:30 - come into here and run this code if we
117:32 - fail to convert then we still want it to
117:35 - be true so we can loop around if we've
117:38 - converted it and the value is successful
117:40 - then we can actually make our success at
117:43 - this point false cuz that will stop the
117:46 - W loop from going around let's run the
117:48 - code we can type typ in 10 H 10 a 10 a
117:53 - etc etc and as soon as we type in a real
117:55 - number then it'll print out and the
117:57 - while loop will cancel and now right
117:59 - here we're set on the console readline
118:02 - now if we press enter the program will
118:03 - close so let's have a
118:06 - recap we use in. TR pass so we can try
118:10 - and pass a value before the program
118:12 - assumes that the value is in the correct
118:13 - format we give it a string variable and
118:16 - it returns us back with a fresh new
118:18 - integer called called num or whatever
118:20 - you want to call it inside here we can
118:22 - place this straight inside the condition
118:23 - of an if statement because this function
118:26 - returns us back with a true or false
118:27 - value otherwise known as a bull if this
118:30 - has been successful we stop the while
118:32 - loop and print the value out to the
118:34 - screen and if it hasn't been successful
118:37 - then we print fail to convert and
118:39 - because our success is still true it
118:41 - will L back around to the start of the
118:43 - while loop and ask the user to input
118:46 - another value to try and convert this
118:49 - Loop will only exit if it's indeed being
118:51 - successful and the only way it can exit
118:54 - is by having the success being equal to
118:56 - false and the only way that can happen
118:59 - is by having a successful
119:01 - conversion the use of trip pass in every
119:04 - program is very essential because if you
119:06 - have a fatal exception then your program
119:08 - will close and you will lose all the
119:10 - data the problem with that is you might
119:12 - lose anything that you haven't processed
119:14 - yet at that given point in your program
119:16 - so you want to try and use trass because
119:18 - you'll avoid any potential exceptions
119:21 - and you can let the user know if the
119:22 - conversion has been successful or not
119:24 - and write yourself the same while loop
119:26 - just like this so you can tell the user
119:28 - hey you input it incorrectly but this is
119:31 - how to do it right and make sure that
119:33 - your program doesn't execute incorrectly
119:36 - and make sure your program doesn't just
119:37 - close unexpectedly and then an error
119:40 - will be
119:42 - caused in this exercise I want you to
119:44 - print out some sort of times table and
119:47 - what I mean by this is you want to ask
119:48 - the user us to input a number for the
119:50 - table and then write a for Loop to print
119:53 - out the x * table X is dependent on the
119:56 - value that entered if they enter 10 in
119:58 - here then this will be the 10 times
120:00 - table let's get started so we can have
120:04 - our normal console.
120:05 - write enter a
120:08 - number and then use our int number
120:11 - equals to convert to in32 and we can say
120:15 - console. readline because we want to
120:16 - read whatever the user types in then we
120:19 - have a four into I equal 0 I is less
120:22 - than 10 we're only going to print up to
120:25 - the 10 times table so 1 * Something 2 *
120:28 - something all the way up to 10 times the
120:30 - value that they
120:32 - entered immediately we acknowledge an
120:34 - error here when you do your 10times
120:36 - table for example you do 1 * 10 2 * 10
120:40 - and so on and so forth the issue here is
120:43 - we're going from 0 to 10 but because
120:46 - it's less than 10 we're actually going
120:47 - from 0 to 9 so let changes to one and
120:50 - then less than or equal to 10 in both
120:53 - cases we were actually looping the same
120:55 - amount of times the issue is this was
120:58 - starting on one and the other one was
121:00 - starting on zero and the first one was
121:02 - finishing on nine and this one's
121:04 - finishing on 10 and we want them to go
121:06 - from 1 till 10 instead of from 0 till 9
121:10 - even though that's the same amount of
121:11 - iterations it gives us different
121:14 - values so in here we can just have a
121:16 - console right line and this is how it's
121:18 - going to work work we're going to have
121:20 - our first number times by our second
121:22 - number and that's going to be equal to
121:24 - something so our first number is our
121:27 - value of I cuz that will say 1 time
121:29 - something 2 * something and so forth our
121:33 - second number is whatever the user has
121:35 - typed into the calculation which will be
121:38 - number and our third number is going to
121:40 - be the actual result of the calculation
121:43 - which are these two times together so we
121:45 - can have I star number and that should
121:48 - be it
121:49 - let's run it and give it a
121:51 - shot we can do our 10 times table and if
121:54 - we press enter you can see that it's
121:56 - fully working this will be our I
121:58 - variable going down the side the second
122:01 - number is what the user typed in and the
122:04 - third number is this multiplied by this
122:06 - gives you the output let's run it again
122:09 - with a bigger number and it seems to
122:11 - handle okay and because this is an
122:14 - integer you'll expect to work okay up
122:16 - until around 2.1 billion which is a big
122:19 - number for some times tables anyway so
122:21 - just a quick recap we Loop through from
122:24 - 1 till 10 instead of from 0 to 9 because
122:27 - we made sure that when we do our
122:29 - multiplications we don't want to start
122:31 - the value at 0 * something we want to
122:33 - start the first one at 1 time something
122:35 - and we don't want to end at N9 we want
122:37 - to end at 10 so using one and less than
122:39 - or equal to 10 will get us the values
122:42 - that go from 1 till 10 and that will
122:44 - make our output look a lot more concise
122:47 - we're using conditional format in here
122:49 - adding the zero and curly braces and
122:51 - then the one and then the two and in
122:53 - order to insert the values in it's a
122:55 - comma delimited list after the speech
122:57 - marks the first one goes in the right
122:59 - order zero is I one is number two is I
123:04 - times the number running that code we
123:06 - will get this output there you
123:11 - go so in this exercise I want you to
123:13 - have a look and see if you can make the
123:15 - Fizz bu game Fizz bu game is one of the
123:18 - most popular interview questions you'll
123:19 - come
123:20 - across and the way to do this is to
123:23 - create a for loop from one to something
123:25 - in this case I'm just going to use 15
123:27 - and inside the followup you want to
123:28 - decide if the number is divisible by
123:30 - three and five then you want to print FS
123:32 - buuz if it's divisible by three then
123:35 - it's Fizz five it's buzz and if it
123:37 - doesn't fall into any of them categories
123:39 - then you want to simply just print the
123:41 - number out to the screen let's get
123:43 - started so we can have a four and
123:45 - because we know how many we want to do
123:47 - we want to do in I
123:49 - less than 15 I
123:52 - ++ and then inside here we need to use
123:55 - the modulus operator which is the
123:57 - percentage sign so if you remember from
123:59 - the tutorial in order to figure out if a
124:01 - number is odd or even you could do the
124:03 - number modul is two and if that value is
124:06 - one then it must mean it's odd and if
124:09 - that value is zero it must mean it's
124:11 - even but what we can also differentiate
124:14 - from here is if 10 modulus 2 equals 0
124:17 - then that means that 10 is divisible by
124:20 - two but also it is even and if it's even
124:24 - that means it's divisible by two if it's
124:26 - not divisible by two that means it's not
124:28 - even and therefore it's odd so in this
124:32 - case if we try to divide three and five
124:34 - we can have the same calculation but we
124:37 - can work it out differently so 10
124:39 - modulus 3 actually gives us a value of
124:41 - one because it's three remainder one so
124:44 - if this value is anything other than
124:46 - zero then we know that these two were
124:48 - not div divisible by each other 9
124:50 - percentage 3 equals 0 which means it's
124:53 - divisible by it so in our if statement
124:55 - we can say if I which is the number that
124:58 - we're currently up to
125:00 - percentage 3 equals equals to zero and
125:04 - because we want to check for five as
125:06 - well we want to say and I percentage 5
125:09 - equals equals to zero and that means
125:11 - they're both divisible by each other so
125:14 - we can do a console right line and we
125:15 - can say fiz buzz and then in else if
125:19 - we're going to check if it's three and
125:21 - we can repurpose this exact condition
125:23 - because this just checks if it's
125:25 - divisible by three and then we can print
125:28 - Fizz and then if we copy this exact
125:30 - structure down and change this to a five
125:32 - to check if it's divisible by five then
125:34 - we can print out buzz and in the worst
125:37 - case scenario where none of them get
125:39 - applied then we can simply print I to
125:41 - the screen and actually there's no point
125:43 - in starting at zero because normally
125:46 - these start at one so we'll just do one
125:48 - and we can make it 15 by making it less
125:50 - than or equal to so instead of before it
125:53 - was actually going from 0 to 14 now it's
125:55 - going from 1 to 15 and they will tell
125:58 - you this in the interview they might say
126:00 - counting from 1 to 100 print out all of
126:03 - the Fizz buzzers so let's run the code
126:05 - and see what's going
126:07 - on 1 2 fizz fizz is actually three so
126:11 - three is divisible by three then you
126:13 - have four and then five is divisible by
126:16 - five you get buzz and six goes into
126:19 - three so you get Fizz nine you get Fizz
126:21 - because it's divisible by three then 10
126:24 - / by 5 gives you buzz 11 12 goes into
126:28 - three so you've got Fizz and finally
126:30 - when you hit 15 it goes into three and
126:33 - goes into five so we get Fizz buzz and
126:36 - the way to increase this to 100 is by
126:37 - simply changing this to 100 if you need
126:40 - to and you can scroll through the entire
126:42 - input and you can see all the history if
126:44 - you wanted to make this slightly
126:46 - efficient what you could actually do is
126:48 - store the booing values for these
126:49 - calculations before you can store the
126:52 - values for these calculations before so
126:54 - we can say
126:56 - Bo 3 div equals false and bull 5 div
127:01 - equals false and what we can do at the
127:04 - start of each of the for Loop is we can
127:05 - say three div equals this value and five
127:09 - div also equals this
127:12 - value and then every time we find a
127:15 - calculation for three or calculation for
127:18 - five we can replace it with either three
127:20 - div or five div so let's change this one
127:23 - here and this one here and our five here
127:28 - and here and because these are values
127:31 - now we want to actually store them as
127:33 - true or falses so we don't need to check
127:35 - if they're equal to zero so we can just
127:37 - remove them so we can say if three div
127:40 - and five div are both true and they'll
127:42 - only be true if these two are both zero
127:45 - now if we run the code and just make it
127:47 - 15 again just just we have a Shor output
127:50 - you can see that our code is exactly the
127:51 - same the reason why this is more
127:54 - efficient is we're only doing this
127:55 - calculation twice whereas before we were
127:58 - doing it twice for three and twice for
128:00 - five now we're doing it once storing it
128:04 - and then making use of it this is a lot
128:06 - more memory efficient than having to
128:07 - calculate it every single time it
128:09 - computes a lot faster and it's better
128:11 - for readability if the rules of the game
128:14 - happen to change and this was divisible
128:15 - by four or six then you could just
128:18 - change it very easily whereas in the
128:20 - previous example you would have to
128:21 - change it in every single
128:24 - case in C when you're constructing
128:27 - strings that have backslashes you're
128:30 - going to need to use double backslash
128:32 - and the reason for this is the first
128:34 - backslash is an indication that it's
128:36 - actually going to be an escape character
128:38 - you're going to put an escape character
128:40 - in and then put the character that you
128:42 - want to display and the reason for that
128:44 - is they've chose backslash as the
128:46 - designated character so so you can use
128:49 - backs slash and then a backs slash to
128:51 - show one backslash only and what this
128:54 - means is it will use the first backs
128:56 - slash as a reference so it knows that
128:58 - it's going to process the next character
129:01 - as an escape character I want these
129:03 - Escape characters are you can have
129:05 - things like T for tab n for new line and
129:09 - you can even use speech marks because if
129:12 - you outputting some dialogue and you
129:14 - wanted to say something like this he
129:17 - said
129:19 - and then you added your own quote in
129:22 - there if you want to put something in
129:24 - quotes then you can't because the speech
129:26 - mark dictates that this is the end of
129:28 - the string literal that's why it's
129:30 - gotting it off like this and then now
129:32 - it's not recognizing that something is
129:34 - just wrote here and what it's actually
129:36 - doing is you've got two strings
129:38 - specified one that says he said space
129:41 - and one that's just empty and then you
129:43 - just have this something that's just in
129:45 - the middle of course we actually want to
129:47 - insert the speech marks within another
129:50 - pair of speech marks this is where the
129:52 - backslash comes in so you can insert a
129:54 - backslash before here and this is now
129:57 - acceptable and the same thing with the
129:59 - normal backslash because the backslash
130:02 - character is also going to be the Escape
130:04 - character then you need a double
130:06 - backslash so then that equals to a
130:08 - single backslash when you print it out
130:11 - let's Show an example so we have C colon
130:14 - SL slash which will return us back a
130:16 - single slash but visually right now it's
130:19 - a double slash but when it gets
130:21 - processed or outputed to the screen
130:23 - you'll see that it's a single slash so
130:25 - this common example is when you're
130:27 - constructing a path together and you
130:29 - want to use backs slashes to denote the
130:31 - different directories so let's output
130:34 - this to the screen and see what
130:36 - happens and as you can see we have a
130:38 - single backslash because of the Escape
130:40 - character we don't see both of them and
130:43 - if we print the Spree out to the screen
130:45 - just to show you that as well then we
130:47 - can see that there's only the speech
130:48 - marks around the something and we don't
130:51 - have the backslash you can tell when an
130:53 - escape character is being used because
130:55 - it goes a slight hint of yellow instead
130:58 - of the normal color for a string so now
131:00 - that we've worked out that this is how
131:02 - this works let's see a way that we can
131:05 - undo this to make it easier for us so
131:08 - you've used the dollar sign for string
131:09 - interpolation and you've used the plus
131:11 - just to concatenate two variables
131:14 - together and just as a quick example it
131:16 - looked something like this your name is
131:19 - and then the name variable and using the
131:22 - plus you would say your name is followed
131:25 - by a space and the quotation marks and
131:27 - do plus name that's fine and now we have
131:30 - another one so similar to how we placed
131:32 - a dollar sign before the speech marks we
131:35 - have a Verbatim identifier and what this
131:38 - means because it says verbatim it just
131:40 - means whatever you see is whatever
131:42 - happens so let's try and Define this
131:44 - path a slightly different way but still
131:46 - containing the exact same information
131:49 - that you see when you print out to the
131:51 - screen so let's have a look we can
131:54 - reassign the path value and just before
131:57 - the speech marks we can put it at symbol
132:00 - and this at symbol means it will
132:02 - actually negate all of the Escape
132:04 - characters it will process a single
132:06 - backslash as a single backslash let's
132:10 - take this line of code and place inside
132:12 - here now what you see is that tint of
132:15 - yellow is no longer there so if we print
132:17 - this past to the screen let's see what
132:20 - happens we actually get the double
132:22 - backslash because it's ignoring all the
132:24 - Escape characters which means if we take
132:26 - them all out this actually looks exactly
132:29 - how we want and you don't have to worry
132:31 - about the Escape
132:33 - characters there you
132:37 - go these two are identical even though
132:40 - one is being displayed using Escape
132:41 - characters and ones using the verbatim
132:44 - identifier please note that if you're
132:46 - going to use the back slash n for
132:48 - example and I'll just demonstrate at the
132:50 - end of this new line test and if we run
132:53 - that code again you'll see that it's
132:54 - printed the path on one line the back
132:57 - sln has made it go on to the next line
133:00 - and now it's printing new line test on a
133:02 - dedicated line that's fine the problem
133:06 - is if you use a back sln or a back SLT
133:09 - or any of these Escape characters during
133:12 - the at symbol then it's going to process
133:14 - it as literal characters which means you
133:16 - can't mix a back n with an at symbol AS
133:20 - this is just taking the text verbatim so
133:23 - if we try to run the code now you'll see
133:25 - the back sln will actually appear in the
133:27 - code if you wanted to do this then maybe
133:30 - you could remove the back slash n and
133:32 - add a plus at the end and then make
133:34 - another string that just has a back sln
133:37 - and then this string will not be
133:39 - processed as a Verbatim string because
133:41 - we don't have the at symbol right before
133:44 - it so then we can have the exact same
133:46 - thing here just to show you
133:49 - this so now these two are identical
133:52 - again just as shown here and as shown
133:56 - here the difference being that we can't
133:59 - specify a back sln in the same string we
134:01 - actually have to concatenate them
134:03 - together because of the verbatim
134:05 - identifier so let's have a look at
134:07 - speech
134:09 - marks so if we have a string name and we
134:12 - can make this equal to hello and then
134:15 - someone and we said before that we have
134:18 - to use the backslash so we can activate
134:20 - the Escape characters and that will work
134:22 - and if we just print that to the screen
134:24 - to make sure then we get hello someone
134:26 - in the speech marks if we add the
134:28 - verbatim identify at the start then we
134:31 - see we've got an error it's trying to
134:33 - process it
134:34 - differently this is a little Quirk with
134:37 - the verbatim identifier if you want to
134:39 - insert a speech marks you actually want
134:41 - a double speech mark on either side the
134:44 - double speech marks will get processed
134:46 - as a single speech mark because it's
134:48 - within a speech mark the verbatim
134:51 - identifier needs to know that you're
134:53 - specifying a speech mark and this acts
134:55 - as a same reason why you have a
134:57 - backslash here it's slightly quirky
134:59 - doing it this way but it still works as
135:01 - per you
135:02 - expect and when you're specifying
135:05 - something like name and we can say hello
135:08 - someone so let's print name to the
135:09 - screen and make sure it works in this
135:12 - case we don't actually need to specify
135:13 - any sort of Escape character because the
135:16 - quotation mark is a separate character
135:18 - to the speech mark and it doesn't
135:20 - interrupt anything by placing a
135:22 - quotation mark inside the string just
135:24 - represents that as its own character
135:26 - let's run that and make sure it works
135:28 - there you go so just as a quick recap
135:32 - Escape characters are very essential
135:34 - because we can use things like back SLT
135:36 - to give us a tab character in our
135:38 - console output this can be very helpful
135:40 - cuz you can almost mimic the use of
135:42 - columns inside our console output you'll
135:45 - notice that back sln is used quite a lot
135:48 - in the console output so you can
135:49 - separate lines without having to use
135:51 - multiple console right
135:53 - lines if you have a single backslash you
135:56 - can't have it on its own if the string
135:58 - is not a Verbatim string you have to
136:01 - pair it with another character otherwise
136:03 - you will get a syntax error if you want
136:05 - to use the verbatim string then you can
136:07 - put an at symbol before the string
136:09 - definition and then it will ignore all
136:11 - of the Escape characters for example
136:14 - using back sln within these speech marks
136:16 - will mean that the back SL n will
136:18 - literally be printed to the screen and
136:20 - you won't get the new line functionality
136:22 - that back sln provides when you want to
136:24 - print speech marks of the screen using
136:27 - the verbatim identifier you have to use
136:29 - a double speech marks in order for it to
136:31 - show up and as you can see it slightly
136:33 - goes yellow and that's the similar
136:35 - notation as using Escape character when
136:37 - you don't have an verbatim string if
136:40 - you're using other characters that are
136:41 - similar to a speech mark like a
136:43 - quotation mark because this doesn't
136:45 - interrupt the syntax of the language
136:48 - then this is fine because a character
136:50 - can just be inside a string and to the
136:52 - compiler this is just a character even
136:54 - though they are very similar the
136:56 - quotation mark doesn't affect the speech
137:01 - mark the most common approach for
137:03 - outputting values to the console is by
137:05 - having this format you type something in
137:08 - as a static string and then you add a
137:10 - variable to it but when you're doing
137:12 - long sentences this format can get messy
137:15 - quite quickly so this will just output
137:17 - both of these on separate lines the name
137:20 - followed by the name variable and the
137:22 - age followed by the age variable I just
137:25 - have a console right line to split up
137:27 - these two sections just so you can see
137:28 - it visually in the console so if we run
137:31 - this code you can see that both the
137:33 - outputs are exactly the same and the
137:36 - reason why is we can use this back sln
137:39 - what this back sln is doing is inserting
137:41 - a new line character just where my
137:43 - cursor is here which is forcing The Edge
137:46 - to jump onto the next line the reason
137:48 - why this is a slightly different shade
137:50 - to the age text is because it's an
137:52 - Escape character back sln means new line
137:56 - we'll explain this in a further video in
137:58 - this section so don't worry about that
138:00 - just know that it means that it produces
138:02 - a new line so as you can see since we're
138:04 - adding the name followed by the name and
138:06 - then the age followed by the ede then
138:08 - it's getting a bit long and a little bit
138:10 - tedious it's not too bad in this case
138:13 - because we're not really printing out a
138:14 - sentence we're just going straight to
138:16 - another line but let's see what this is
138:18 - going to look like if we start dealing
138:20 - with multiple pits of data your name is
138:24 - followed by the name and then we can add
138:27 - a comma and your age is and then add the
138:31 - age and as you can see while we're
138:33 - structuring a sentence then it gets a
138:35 - little bit long we have to remember to
138:38 - put in the spaces otherwise our code is
138:40 - going to look funky when we print out to
138:42 - the screen and the reason for that is
138:45 - there's no spaces between the name and
138:47 - the age variables so let's put them back
138:49 - in and make sure the output looks all
138:53 - right now that the output looks like
138:55 - this let's explore composite formatting
138:57 - and what this means is we can get rid of
138:59 - all of these plus symbols and replace it
139:01 - with curly braces so let's actually
139:04 - output this string again but just output
139:06 - it completely static your name is
139:09 - abber and your age is
139:12 - 23 and now if we've run this you'll see
139:15 - that both outputs are identical this is
139:18 - because I know the values for the string
139:19 - variables up here and I can input it
139:22 - straight into here so now that we know
139:24 - what our sentence is going to be we
139:26 - don't need to add any pluses what we do
139:28 - need to do is remove our variables so in
139:31 - the case of this sentence our name
139:33 - variable is here and our age variable is
139:35 - here so we can replace this with this
139:38 - curly brace notation we can have curly
139:41 - BRAC and then we want to start this
139:43 - value at zero throughout the string you
139:46 - want to have these values starting from
139:49 - zero and going up incrementally from
139:52 - left to right so our next variable would
139:54 - be our 23 and we can store it like this
139:59 - now that it's got your name zero and
140:01 - your age one let's see what happens when
140:03 - you output it then we just get this and
140:05 - this is very confusing that's because
140:08 - we're not done yet so now that we've got
140:10 - our string typed in we can actually
140:12 - place a comma in here and now it lets us
140:15 - put any object in and any object could
140:18 - be a string an in a double or any data
140:20 - type so we want to insert the values
140:23 - inside here going from left to right so
140:26 - our name is first and then we do a comma
140:29 - and we type in Age and what this now
140:31 - says is the name will get replaced by
140:33 - the curly brace zero and the age will
140:36 - get replaced by the curly brace one so
140:39 - now if we run the code let's see what
140:41 - happens and now you'll see that the
140:42 - output is exactly the same and now look
140:45 - at the difference between these two
140:47 - lines you'll see that these multiple
140:49 - amount of pluses are not confusing and
140:52 - let's say you forget this one then
140:54 - you're going to get a syntax error and
140:55 - it's a bit frustrating to keep on typing
140:58 - when you're trying to join things
140:59 - together now we can clearly see that
141:01 - this flaw is like a sentence and this
141:03 - space here looks very unnatural but this
141:06 - space here looks like it's part of the
141:08 - sentence which makes our code a bit more
141:11 - complete and the same goes if you want
141:13 - to print something like this and let's
141:15 - convert this one so if we copy this line
141:18 - down into here and we just remove the
141:20 - spaces then it can look something like
141:24 - this name followed by the name we don't
141:27 - actually need this space here because
141:28 - we're going to be going into a brake
141:30 - line we can replace our name with curly
141:32 - braces zero and our age with curly
141:35 - braces one and then straight after we
141:38 - can type name and age and if we output
141:41 - this we'll see it's exactly the same
141:43 - there we go so just a quick recap print
141:47 - ing strings and any other variables to
141:49 - the screen has been normally achieved by
141:51 - doing a string followed by a plus and
141:54 - then adding another variable to it
141:56 - adding more than one can be a little bit
141:58 - complicated and hard to track of all the
142:01 - spaces that you're going to put in and
142:02 - you might accidentally miss one of them
142:05 - like this one here or this one here are
142:07 - very crucial to the output if you miss
142:09 - this one then it's going to say is
142:11 - followed by the name all together with
142:14 - no space we then introduce composite
142:16 - format in which lets us use this
142:18 - notation of curly brace Z and curly
142:21 - brace one to give us the ability to
142:23 - store some variables outside of the
142:26 - string and then insert them in
142:29 - dynamically we took both of these
142:31 - examples and made them down here using
142:34 - composite
142:36 - forming so let's explore a new method of
142:39 - concatenation that makes this look a lot
142:41 - better the reason why this is an issue
142:43 - is you have spaces in here and sometimes
142:45 - you might forget these spaces and it
142:47 - could mess up your program this string
142:49 - here looks very unnatural because you're
142:51 - forcing the space but when you run it
142:54 - you'll see that it is actually what you
142:55 - expect the spaces are complete and it
142:58 - makes perfect sense but when you're
143:00 - writing it it kind of looks a little bit
143:02 - stupid because you're forcing the space
143:05 - and then adding a plus and then the name
143:07 - and then another plus and then another
143:09 - static string and this just get a little
143:11 - bit long to type it's fine when you have
143:13 - a smaller sentence like this but when
143:15 - the program starts to grow it could be a
143:17 - little bit problematic and you'll have a
143:19 - lot of syntax errors when you forget to
143:21 - type in all the pluses locally this can
143:23 - be fixed let's duplicate this line down
143:26 - and let's see what we can do so we have
143:28 - this thing called string interpolation
143:30 - and it uses a dollar sign as a reference
143:33 - we can place the dollar sign before the
143:35 - quotation marks and then what you can do
143:38 - is you can actually keep this as one big
143:40 - sentence so let's remove all of the
143:43 - values and have it like this so now of
143:46 - course this actually doesn't print our
143:47 - variables because we've just replaced it
143:49 - with text so if we just run this then
143:51 - it's completely messed up because now
143:53 - we're not using our variables and this
143:56 - can be easily fixed because we've used
143:58 - our dollar sign now we can actually wrap
144:00 - our variables in this curly brace and
144:03 - now you can see it's went white if I
144:05 - double click on it you can see that it's
144:06 - referencing the
144:08 - variable wrapping the variables in the
144:10 - curly brace means that they can actually
144:12 - be processed variables even though they
144:14 - are still within the speech marks please
144:16 - do not remove the dollar sign because
144:18 - now this will be interpreted as string
144:20 - text as you can see here putting a
144:23 - dollar sign at the start will make into
144:25 - string interpolation and then we get the
144:27 - ability to have our brackets this can
144:30 - make string concatenation very easy to
144:32 - do because you don't have to worry about
144:34 - all the pluses and adding them together
144:37 - and don't have to worry about the spaces
144:38 - as well this looks more like a natural
144:41 - sentence and what you can do for
144:43 - practice is you can actually just type
144:44 - out the sentence your name is AB
144:47 - your age is 23 and then from there you
144:51 - can actually just break down the
144:52 - variables and know that you'll need one
144:54 - here so you can replace that with name
144:57 - and then you'll know you'll need one
144:58 - here so you can replace that one with
144:59 - age and then you can place the dollar
145:02 - sign right at the end and then there you
145:04 - go you have your solution this method
145:06 - means that it's a lot cleaner to read
145:09 - easier to maintain and make changes in
145:11 - the future and that's the whole point of
145:13 - programming if your code base is very
145:15 - difficult to go around and understand
145:17 - what's going on and potentially make
145:19 - changes in the future then you've
145:20 - already made a bad step and you don't
145:22 - want to get into these nasty habits it's
145:25 - fine if you're just going to have
145:26 - something like this where it's not
145:27 - really complicated at all a string plus
145:30 - another string that's quite simple and
145:32 - that's fine you don't have to go the
145:34 - extra effort to put in the dollar sign
145:36 - and wrap it around in the curly braces
145:38 - even though I personally still would
145:40 - because in my personal opinion this
145:42 - looks a lot
145:44 - better than having it like that you can
145:47 - see that it's a lot neater it takes up
145:49 - less code and you can see visually that
145:51 - you're using a specific variable and you
145:54 - don't have to worry too much about the
145:55 - spaces because this looks like a real
145:59 - sentence explore another method of
146:01 - string concatenation which is the idea
146:03 - of taking strings or objects and add
146:06 - them together to form a sentence of
146:07 - sorts we can say your name is followed
146:10 - by a space and then add the name
146:13 - followed by a space add your ages and
146:15 - then add the actual age variable
146:17 - and we can also write the exact same
146:19 - line using string interpolation or
146:21 - composite formatting just like this and
146:24 - like this we can specify the dollar
146:27 - symbol and put our variable in the
146:29 - bracket which is shown here and here and
146:32 - for the composite formatting we can take
146:34 - the content where our variable would go
146:36 - and replace it with incremental numbers
146:39 - 0 and one wrapped around in a curly
146:41 - brace and then specify in the correct
146:43 - order zero takes a value of name and one
146:46 - one takes a value of age if we run this
146:49 - code you'll see that the outputs are
146:51 - identical so let's explore this other
146:54 - method we have a string test for example
146:57 - and then inside the string Library we
146:59 - have this function called concat and it
147:01 - can taking any amount of parameters that
147:03 - we want to give it so we could say your
147:07 - name is space and the quotation marks
147:10 - and then we can add a comma and then we
147:12 - can say we want to add the name and then
147:14 - another comma and we want to add and
147:16 - your
147:17 - ages and the speech marks add a comma
147:20 - add the age variable and that's it and
147:23 - we could just use CW tab tab and type in
147:25 - test and let's run it and see what
147:28 - happens and now as you can see we get
147:30 - the exact same output and because this
147:32 - just returns us back with a string we
147:34 - can also just take this entire line and
147:37 - paste it straight into the console right
147:38 - line you don't necessarily have to store
147:40 - it but you can if you want to and there
147:42 - you go all methods produce the same
147:44 - output another way you can use this
147:46 - concap function is by giving it an array
147:49 - we haven't covered arrays so far so I'm
147:51 - just going to show you this for
147:52 - demonstration purposes don't worry about
147:54 - understanding it so just a quick
147:56 - explanation arrays are just ways of
147:58 - storing multiple of the same data type
148:00 - so if we have these three names inside
148:03 - our names we can actually use the
148:05 - console to print them all out so we can
148:08 - say string. concat and then we can
148:10 - concut the names together which will
148:12 - just add all of these three together now
148:14 - the problem is when you've run it you'll
148:16 - see this stuck together so what you
148:18 - could do is just add a space between
148:20 - them and as you can see this is getting
148:22 - a little bit tedious
148:23 - now there's other methods that we can
148:26 - use to concat some arrays together and
148:28 - I'll show you that in the next section
148:29 - but for now don't worry about it this is
148:31 - concentrating on the string concat
148:33 - function and we'll just demonstrate that
148:35 - again so if we run the line of code we
148:37 - can see that they're all the same so now
148:39 - that you have four different methods of
148:41 - printing out exactly the same
148:42 - information you might be asking yourself
148:45 - what's the best method I personally
148:47 - prefer to use the string interpolation
148:49 - because with this one you can easily
148:51 - miss the spaces and you could produce a
148:53 - bad output and it might be stuck
148:55 - together it's fine when you can see the
148:57 - lines right in front of you and you can
148:59 - easily identify the spaces but when
149:01 - you're adding about 10 variables
149:03 - together then it could be a problem the
149:05 - reason why I like string interpolation
149:07 - using the dollar signs and the variables
149:09 - in the curly braces is that you don't
149:11 - have to rely on missing out spaces
149:13 - because it actually forms a sentence and
149:15 - you just replace the use with your
149:17 - variable composite formatting which is
149:19 - this one is very efficient and very nice
149:21 - to look at because it allows you to
149:24 - specify the sentence and then plug in
149:26 - the variables after the only problem
149:28 - with this is if you were to change this
149:29 - value in the future or to change a
149:31 - sentence you have to make sure that the
149:33 - numbers add up just like in the first
149:35 - example if you only have a short
149:37 - sentence then this isn't really an issue
149:39 - since you can see it all visually and
149:41 - you also got to realize that these need
149:42 - to be in the right order because if you
149:44 - put Age first then it's going to put age
149:46 - in this one and name in the second one
149:48 - and that's going to be problematic cuz
149:50 - it now mess up the sentence using string
149:53 - interpolation you don't actually have to
149:54 - worry about anything because if you
149:56 - wanted to change this to say your age is
149:59 - then you simply just do this and that's
150:01 - very easy to do because in this case
150:03 - you'd say your age is and then you'd
150:05 - have to change a string and then now
150:07 - that this is zero we need to change this
150:10 - from being age and this one to be name
150:13 - whereas in the first example you could
150:14 - just easily change the value in the
150:16 - curly braces instead of changing this
150:18 - reference and the end reference cona is
150:21 - not widely used just because you have
150:23 - all of these methods available where you
150:25 - can easily add stuff together but there
150:27 - could be user cases later on down the
150:29 - line where users just so it's a bit more
150:31 - obvious and it helps the readability of
150:33 - your code and maintain within a big
150:35 - project or just on your personal
150:37 - projects when you're looking back at
150:39 - your previous
150:41 - code when you create and initialize a
150:44 - string variable you might want to give
150:45 - it the value of an empty quotes and this
150:47 - will just default the value to
150:49 - essentially nothing you're giving it a
150:51 - value but at the same time the value
150:52 - doesn't actually contain any sort of
150:54 - characters if we print this out to the
150:56 - screen then you won't really see
150:57 - anything this video is going to focus on
150:59 - string.empty and string.empty will
151:02 - actually just represent these quotation
151:03 - marks string. empty will represent these
151:06 - speech marks so what we can do is we can
151:08 - type in string using a DOT and then we
151:11 - can type in empty just like that we've
151:13 - initialized our string name to a value
151:16 - of empty
151:17 - now this isn't necessarily used when
151:19 - you're declaring and initializing it
151:21 - because this is almost identical to just
151:23 - defining a string on its own main reason
151:25 - why this is used let's say we actually
151:27 - ask the user to input their name so we
151:29 - can say a console. write enter your name
151:32 - and then we can take this string
151:33 - variable move it down use an alt and
151:36 - then arrow keys and remove this and
151:38 - let's initialize it to a
151:40 - console.readline to read in the value
151:42 - from the
151:43 - console and now what we can do is using
151:45 - our is string interpolation method that
151:48 - we just learned we can print to the user
151:50 - your name is and then the name in The
151:51 - Curly braces now let's just see what
151:54 - happens so let's actually type our name
151:56 - in Abba and it says your name is ABBA
151:59 - but what if the user just types in
152:00 - nothing and just presses enter Then it
152:02 - still says your name is blank now let's
152:04 - see what we can do here we don't
152:06 - necessarily want to say your name is
152:08 - blank we want to check what this value
152:09 - is so we can say if the name is not
152:12 - equal to empty quotation marks then we
152:14 - can output your name is and then then
152:17 - else we can say name is empty and then
152:20 - if we run it now and press enter it says
152:22 - name is empty so we can use string.
152:25 - empty instead of these quotation
152:28 - marks this looks a lot better when
152:29 - you're trying to compare it AB your name
152:32 - is Aba and then when we press enter it
152:34 - says name is empty this just helps to
152:37 - keep your code a lot tidier just so you
152:39 - don't have to write the two quotes if
152:41 - you accidentally put a space in there
152:43 - now your if statement is incorrect if
152:45 - you always use string. empty then it
152:47 - just helps you to make sure that your
152:49 - code is going to be maintainable and
152:50 - readable in the future reading
152:53 - string.empty gives you a better
152:54 - representation of what's going on
152:56 - instead of two open
152:59 - quotes if there is a situation where you
153:02 - want to check if one string equals
153:03 - another string then you can do the
153:06 - following if message equals equals
153:09 - compare then we can print out same and
153:12 - then else we can print out
153:15 - different and as we can see here they
153:17 - both have a capital H and they both say
153:19 - hello so they should be identical let's
153:22 - run the code and find out so they say
153:24 - same which is exactly what we'd expect
153:27 - so we have another method of being able
153:29 - to do this so even though we can apply
153:31 - equals equals to two strings it's
153:33 - normally better practice to use do
153:35 - equals and then place the other string
153:37 - inside the brackets so you're saying if
153:39 - message equals compare now if you run
153:42 - the code you'll see that it's the same
153:44 - output in certain circumstances where
153:47 - you want to ask what the user has
153:48 - entered enter your name and then we can
153:52 - use a string name equals console.
153:54 - readline we can say if the name does not
153:58 - equal to empty strings then from there
154:01 - what we can do is type in your name is
154:05 - plus
154:06 - name and then we get some output
154:09 - your name is abber but since we're
154:11 - checking if it's not equal to that that
154:13 - means they've entered something in let's
154:15 - see if there's another way that we can
154:16 - actually write this so if we just
154:18 - duplicate it and comment it out so we
154:20 - got it for reference so what we want to
154:22 - do is we're checking if name is not
154:24 - equal to empty quotes so we can say name
154:28 - do
154:29 - equals empty quotes but what this is
154:31 - telling us if the name equals empty
154:33 - quotes then we should do this so then
154:35 - what we can do when we learn about the
154:37 - if statements is we can use the not
154:39 - operator and we can say if the name not
154:42 - equals to empty quotes then we proceed
154:44 - with this line L we can just
154:48 - say invalid name
154:51 - input let's run that and see what
154:53 - happens to type in AB then it passes
154:55 - fine and if we type in nothing then we
154:57 - get an invalid name input the reason why
155:00 - equals equals and the do equals function
155:02 - are different is because lower level
155:05 - using equals equals will actually
155:07 - compare the reference in the memory and
155:09 - the reference in the memory is what's
155:11 - used up when you actually create these
155:13 - variables so what this is doing is it's
155:16 - comparing the value that's actually
155:17 - stored in memory to the other one that's
155:19 - stored in memory now the problem is when
155:22 - it comes to something like arrays where
155:24 - you actually have the same value but
155:26 - they're slightly different let me
155:27 - demonstrate so I'm just going to use
155:29 - this code because we haven't covered
155:31 - arrays yet so I'm just showing you an
155:32 - example if we have a chart array that
155:35 - literally says hello and then we can use
155:37 - this line of code to join them together
155:40 - but this is actually an object instead
155:42 - of a string but if you see what we can
155:44 - do in the if statement we can say save
155:46 - the message which is equal to hello we
155:49 - can use message. equals and we got the
155:51 - new compare and this is actually an
155:53 - object so now we're comparing a string
155:56 - with an object and generically speaking
155:58 - an object can hold any sort of value
156:01 - because all of these variables that are
156:03 - strings ins double Etc they're all
156:05 - derived from something called an object
156:07 - which is just a very generic way of
156:09 - storing information so since these two
156:11 - data types are little bit different they
156:13 - still evaluate to the same thing what
156:16 - the equals function is doing is actually
156:18 - checking the literal values of the
156:20 - variables instead of checking the values
156:22 - that are held inside the memory address
156:24 - location and the difference here is even
156:26 - though we have a character array that is
156:28 - giving us the values hello and our
156:31 - string is also given us the value of
156:33 - hello if we run this line of core that
156:35 - uses do equals then you'll actually see
156:38 - that the second same actually represents
156:40 - the bottom if statement so what that's
156:42 - doing is it's actually giving us back
156:45 - the comparison saying that it's true and
156:47 - it is indeed true because hello is
156:49 - literally equal to hello but if you were
156:52 - to use the double
156:54 - equals then what you'll realize when you
156:56 - run the code is now it will say it's
156:58 - different because what it's doing now is
157:01 - it's taking a string object and
157:03 - comparing it to an object and they are
157:06 - not different because of their memory
157:08 - and that's what the equals equals is
157:10 - comparing it's not only comparing the
157:12 - value it's comparing the memory address
157:14 - location and that's going to going be
157:16 - vastly confusing because you don't want
157:18 - to hit these situations so it's always
157:20 - best to use the equals function because
157:22 - the equals function is concerned about
157:24 - the values rather than where they are in
157:27 - your memory I hope that made sense and
157:29 - it wasn't just confusing but basically
157:31 - when you use equals equals it checks the
157:34 - values that are actually wrot in your
157:35 - computer's memory instead of the value
157:38 - itself it will do both it will check the
157:40 - memory and check the value whereas when
157:43 - you use do equals it is only concerned
157:45 - about about the values and that's all
157:47 - that matters when we're doing an if
157:48 - statement like this we're checking if
157:50 - they're both the same so it shouldn't
157:52 - really matter how and where they are
157:54 - stored the only thing that matters is
157:56 - the values contained within the variable
157:58 - we're only caring about the values and
158:00 - not where they're
158:03 - stored so when we have a string variable
158:05 - defined in C we have it like this and
158:08 - when we print it out to the console we
158:10 - get the entire string being
158:12 - displayed but what if you want to return
158:14 - the first element back not the rest then
158:16 - what are your options so in the later
158:18 - video in the course we covered the
158:20 - substring function and technically you
158:22 - could go from the first character till
158:24 - the second character and you will just
158:26 - get C back so that's index zero till
158:28 - index one and you'll get the C back now
158:31 - the problem with that is that's an extra
158:32 - function call or something that should
158:34 - be quite simple and it is a message is a
158:36 - string and strings tend to be an array
158:39 - of characters which is similar to this
158:42 - we haven't learned about arrays so far
158:44 - and we'll cover that in the next section
158:46 - but what an array essentially is is it
158:47 - lets you store multiple of that data
158:49 - type so we could have a chart array that
158:52 - holds exactly the same value and each
158:54 - position will hold each one of these
158:56 - characters and the reason why I'm
158:58 - mentioning this is because with strings
159:00 - you can use the square bracket notation
159:02 - so if you add some square brackets at
159:03 - the end it says here it returns back a
159:05 - Char and it takes in an index gets the
159:09 - CH object at the specified position in
159:11 - the current string object so if we use
159:13 - message zero you can see that returns
159:15 - back with a ch ch right here gets the CH
159:18 - object so we can call this on a string
159:21 - and it can return us back with a
159:23 - character because like I said with the
159:25 - array of characters that's essentially
159:27 - what a string is each one of these is
159:29 - just its own independent character and a
159:32 - string lets you pair them all together
159:34 - so if we print this out then we should
159:36 - get C because it's zero based so if we
159:38 - copy this down and use
159:40 - one 2 and three then what should we get
159:44 - we get C
159:46 - then we get actually nothing technically
159:49 - because it's a space character and then
159:51 - the third character which is the fourth
159:53 - in the list because it's zerob based is
159:55 - going to be our I so let's just print
159:57 - this out to the screen and see what
159:58 - happens there we go so even though we
160:00 - don't see it visually there's actually a
160:02 - space character right there and that's
160:04 - the third character in The List which is
160:06 - right here so of course we don't tend to
160:09 - know how long the string is unless we
160:11 - can see it visually and if you were to
160:13 - reference one of these values and the
160:15 - string is not actually that long then
160:17 - you have a problem let's demonstrate if
160:19 - we have the string just called C and
160:21 - let's comment out the rest then that's
160:24 - only two characters so only zero and one
160:26 - will be applicable these two will return
160:29 - back something let's have a look and see
160:31 - what happens so the first character and
160:33 - the second character will run fine and
160:35 - let's put a console read line in there
160:37 - just to break it up so the other code
160:39 - doesn't run yet if we run the code we
160:41 - get our C and that's the max length of
160:44 - our string so so far it's zero and one
160:47 - now if we press enter let's see what
160:49 - happens we get an index out of range
160:52 - exception index was outside the bounds
160:54 - of the array and the reason for that is
160:56 - we only have two characters inside our
160:58 - message and we're trying to display the
161:00 - third and the fourth this is problematic
161:03 - because we literally don't have any of
161:04 - them characters to
161:06 - display so what we can do instead is
161:08 - actually write ourselves a little Loop
161:10 - to go through the entire string and
161:12 - return us back all of these character
161:13 - positions instead of us just get ing how
161:15 - long the string is so if we return this
161:17 - string back to normal and then just
161:19 - after this little section we can write a
161:21 - for Loop in I equals 0 and I is less
161:24 - than message and then we have access to
161:27 - dot length this gets the number of
161:29 - characters in the current string so we
161:31 - don't have to worry about the maximum
161:32 - length in the square brackets we can
161:34 - always rely on do length because we
161:37 - don't have to keep track of it and the
161:39 - language can know that for us and give
161:40 - us the
161:42 - value in this case we're going from zero
161:44 - to whatever the length is these
161:45 - characters are and then in here we can
161:48 - actually just console right line and we
161:50 - can do the same notation we did here
161:52 - we're say we want to print the message
161:54 - but not only the message we want to
161:56 - print the index and the index is going
161:58 - to be I in this case because we start at
162:01 - zero since it's zero based and then
162:03 - we're going to the last character so
162:05 - let's print this and see what
162:07 - happens so now we get C Is Awesome from
162:10 - here down to the bottom c is awesome
162:13 - print on every single line and that's a
162:15 - little bit annoying to read so what we
162:17 - could do is just change this to a
162:18 - console right and maybe we can just
162:20 - comment this section out just so we can
162:22 - see this
162:25 - properly there we go so we get c is
162:27 - awesome and because it's a console right
162:29 - it's right in them all next to each
162:31 - other and they're being printed out one
162:32 - by one let's add a cool little effect
162:35 - that can demonstrate you for now so
162:37 - inside the system. threading Library we
162:39 - have this sleep function so what we can
162:42 - do is we can add another using command
162:44 - system do threading we already have
162:47 - threading do tasks in there but the
162:49 - function that we need is inside the
162:50 - threading Library so there's two ways we
162:53 - can write this we can actually write
162:54 - everything by hand like this do sleep or
162:58 - you could just remove the system do
163:00 - threading because we've added it at the
163:02 - Top If you don't want to add it at the
163:03 - top that's not really a problem you can
163:05 - just include it straight into here
163:07 - adding it at the top will include it
163:09 - within the entire project but if you're
163:10 - only going to use it once or twice then
163:12 - sometimes it's better to just include it
163:14 - straight into here because it'll make
163:15 - your overall program size a lot smaller
163:18 - so let's just keep it in so we can make
163:20 - our code a bit more readable so we have
163:22 - thread. sleep and what this will do is
163:25 - it will suspend the current thread for a
163:26 - specified number of milliseconds there's
163:29 - a th000 milliseconds in 1 second so what
163:32 - we can do in here and we're trying to
163:33 - mimic a typewriter effect so we can say
163:36 - something like 200 which will be roughly
163:38 - a quarter of a second so if we've run
163:40 - the code now let's see what happens so
163:42 - we get this cool effect where after it
163:44 - prints out each of the characters
163:45 - characters it will print out the next
163:47 - character only after it's been asleep
163:49 - for a quarter of a second and that looks
163:51 - kind of cool if you wanted to speed it
163:52 - up you could just decrease this number
163:55 - there you
163:55 - go of course if you make it too low then
163:58 - it might be too fast for you to actually
163:59 - acknowledge what's happening and if you
164:02 - also make it too slow then it's just
164:04 - going to take too long to turn off and
164:06 - at that point you can use control+ C on
164:08 - your keyboard or use the stop button at
164:10 - the top to terminate the program okay so
164:12 - let's have a look at another thing that
164:14 - we can do with this so maybe we can make
164:15 - this 100 for now in the previous videos
164:18 - we've used a function called contains
164:21 - and let's say we're just checking if it
164:23 - Con turns C and we know it does because
164:25 - we can see it visually let's run the
164:27 - code and we see we have true being
164:30 - printed and the reason why true is
164:32 - actually on the same line as c is
164:34 - awesome is because we're using console.
164:36 - right here so it's actually not made a
164:38 - new line character just after the E so
164:41 - when it's printing true it prints it
164:43 - straight after that so what we can do do
164:45 - to fix that is just place a new line
164:47 - character in here using console.
164:48 - readline and we can just drop this a
164:50 - little bit lower to 50 there we go so we
164:53 - have true and what we can do with this
164:56 - is we can actually make our own little
164:57 - version of the contains function let's
165:00 - demonstrate so if we make this exact for
165:02 - loop again in I equals z i is less than
165:05 - the message. length and i++ so first
165:09 - let's kind of understand what's going on
165:10 - with this function returns a value
165:12 - indicating whether a specified substring
165:14 - occurs with in this string and what that
165:16 - means is it will return a Boolean for us
165:18 - if C is inside our message then this
165:20 - will return back true and we know this
165:22 - is true because we just outputed to the
165:24 - screen and we can see this visually so
165:26 - what we need to do is we need to Loop
165:28 - through our message and try and figure
165:30 - out if we can find C inside our message
165:33 - and then we can give back a value of
165:35 - true so maybe we can do a bu contains
165:38 - equal false and the reason why we
165:40 - initial it to false and the reason why
165:41 - we initialize it to false is because we
165:43 - want to set it up telling that we
165:45 - haven't found it and then inside the for
165:47 - Loop if we find it then we can set it to
165:51 - True let's have a look so after the for
165:53 - Loop we can print contains of the screen
165:55 - and then inside the for Loop what we can
165:57 - do as we've seen here it returns back
166:00 - every single character so you'll get
166:02 - back C sharp then the space then I then
166:05 - s and so on and so forth and what we
166:08 - want to do is we want to go through each
166:09 - of the characters and then just ask if
166:12 - the variable is equal to C if C is equal
166:15 - to C then we can assign this to true and
166:18 - then go through if hashtag is equal to C
166:20 - if space is equal to C and so on and so
166:22 - forth so we can write a if statement
166:24 - here that says message square bracket I
166:27 - is equal to equal to apostrophe C and
166:31 - the reason why it's an apostrophe is
166:32 - because this is a character and this
166:34 - also returns us back with a character so
166:36 - we need to compare them both like that
166:39 - if we use a string in here then it might
166:40 - complain that we're trying to convert
166:42 - between a chart and a string and it
166:44 - won't let let you do the equals equals
166:46 - operator between two different variables
166:49 - maybe what we can do instead is to
166:50 - follow the approach that we used before
166:52 - and use the equals function and place
166:54 - our C inside here so if the character
166:56 - that we're currently up to inside the
166:58 - for Loop is equal to our C which is what
167:01 - we want to search for then we can set
167:03 - our contains variable equal to true we
167:06 - don't need to write an lse statement in
167:08 - here to set our contains to false
167:11 - because we've already gave it a value at
167:12 - the start if we didn't have this value
167:14 - then it'll be beneficial to do this but
167:17 - since we have it then we can remove this
167:19 - other path and we don't exactly need it
167:21 - so let's have a look and see if this
167:24 - works perfect it says true maybe we can
167:27 - change this character to something like
167:28 - air make sure this
167:30 - works which it does as well so perfect
167:33 - so now we've made our own mini little
167:35 - contains function inside here and we can
167:37 - also use the C library one but the
167:40 - purpose of this exercise was just to
167:41 - show you how we can iterate through a
167:43 - string variable and and then decide what
167:45 - each of the characters can be equal to
167:48 - and then we can decide if they're equal
167:49 - to another one and then let the user
167:51 - know that we found a match for their
167:53 - search
167:56 - term so far in the course we've covered
167:58 - the equals function and the contains
168:00 - function when you're searching through
168:02 - strings or trying to find values let's
168:04 - have a look at a method that makes sure
168:06 - a string is valid before we can process
168:08 - information on it so in this quick
168:10 - example we have a name output we're
168:12 - reading the value into a string name and
168:14 - then we simp complet output it to the
168:16 - screen if we run the code and just press
168:18 - enter then it says your name is blank
168:20 - and we don't really want that because we
168:22 - want to check if your name is equal to
168:24 - something before we continue so let's
168:26 - look at some methods so we have if the
168:29 - name is not equal to nothing and then
168:31 - let's just print zero to the screen and
168:34 - that's one of the methods and we can say
168:37 - if name is not equals two quotation
168:41 - marks then let's print out number one so
168:44 - what what this is doing is checking if
168:46 - the name is not equal to empty quotes
168:48 - and then this is doing exactly the same
168:50 - thing except we're using the equals
168:52 - method and let's just run the code and
168:55 - press enter and you can see the zero or
168:57 - the one doesn't appear because it's
168:59 - detecting that it contains nothing so if
169:01 - we type in a real value we can see Zero
169:03 - and one coming up so these are both
169:06 - valid ways of checking if the string is
169:08 - not empty so let's look at a third one
169:11 - and this one is actually very important
169:12 - for reasons I'll explain in a second so
169:15 - inside our string Library we have is
169:17 - null or empty so we place our name
169:20 - inside here and let's see what this says
169:22 - now indicates whether the specified
169:25 - string is null or it's an empty string
169:28 - so this can be very effective so what
169:30 - this reads now is if the string is null
169:33 - or empty then we print a value but we
169:36 - want it to be not null or empty because
169:38 - it wants to have some contents so if we
169:41 - type a value in again you'll see now we
169:43 - get all three numbers and what them
169:45 - three numbers mean is that it's past all
169:47 - of these checks and each of these checks
169:49 - just ensures that the value has got
169:51 - something inside and that's fine but it
169:54 - can be slightly problematic for this
169:56 - reason using this method and this method
169:59 - are fine in some cases except as it says
170:02 - here it checks if the string is null and
170:05 - null means it doesn't have a value but
170:07 - it just has nothing instead of something
170:10 - let me demonstrate if we assign the
170:12 - value of empty quotation marks this
170:15 - actually has a value but the contents is
170:17 - empty but it's still a string as it
170:20 - comes up in here if we assign this the
170:22 - value of null then it's just a keyw that
170:24 - we can use to denote that this literally
170:26 - has no contents it's not that it has an
170:29 - empty string CU an empty string is still
170:32 - actually a string whereas a null it just
170:34 - means the variable is blank now this is
170:37 - where the issue arises if we try and
170:39 - call a method on something that's null
170:42 - Watch What
170:43 - Happens we actually get an exception and
170:45 - our program just crashes you can't run
170:48 - any code on something if that variable
170:50 - is actually defined as
170:52 - null it doesn't mind if you check the
170:55 - value of it but if you try and run a
170:57 - function then you've got a problem so if
170:59 - we comment this line out this ensures
171:02 - everything it ensures it's null or it's
171:05 - empty and this is the belt and braces
171:07 - option because if it's null we don't
171:09 - actually get an exception when we try
171:11 - and run this code as follows
171:15 - we get the zero showing up because our
171:17 - variable has something that's not speech
171:19 - marks and it's actually null so we want
171:22 - to avoid this option as well and also
171:24 - avoid this option in case our string is
171:27 - actually genuinely
171:28 - null using is null or empty we'll check
171:32 - both for the value of null which it is
171:34 - right now and if it's got empty quotes
171:37 - EG the value is empty so if we just run
171:40 - this again and have these two paths
171:42 - commented out we can see that two is not
171:44 - appearing if we change this back to our
171:47 - console readline and we try and do it
171:50 - then we get our number two because it's
171:52 - validated that this string variable is
171:55 - got something inside it and the variable
171:57 - is not actually no this is a very good
172:00 - way of being able to make sure that your
172:02 - program doesn't get exceptions as with
172:04 - calling these equals if you want to call
172:07 - equals then call it inside here you can
172:10 - check if that variable equals something
172:13 - by simply placing that if statement in
172:15 - inside here after you validated if the
172:17 - name variable actually has some contents
172:21 - if it's null or it's empty running
172:23 - equals on it will just break the code
172:25 - further and you don't need to check if
172:27 - it's equal to Something in here maybe
172:29 - you were checking if the value is equal
172:31 - to abber or something along them lines
172:33 - and now if we run it again we actually
172:36 - get the output correct it's best to Nest
172:39 - them like this because if you run this
172:41 - function on something that's null it's
172:43 - actually really safe but as you saw
172:46 - previously if you run a function on
172:47 - something that's null then you're going
172:49 - to get a null reference exception and
172:51 - your program will close down and break
172:54 - you want to avoid exceptions at all cost
172:56 - so nesting it inside it is null Remy
172:59 - check will be perfect for your code it
173:01 - improves the stab ability of your
173:03 - program to ensure that exceptions don't
173:07 - happen so in this exercise I want you to
173:09 - ask the user to input any message and
173:11 - then I want you to print the message in
173:13 - Order character by character and then
173:15 - also print it in reverse character by
173:17 - character let's get started so we could
173:20 - just have a console right line but let's
173:22 - change it to a right and just say enter
173:24 - your message callon and then speech
173:26 - marks and then just have a string
173:28 - message
173:30 - equals console. readline perfect so in
173:34 - order to be able to Loop through the
173:36 - string message we need to have a for
173:37 - Loop if you remember from our previous
173:39 - videos we can have this string variable
173:42 - followed by a square bracket and then
173:44 - and then we can have an index inside and
173:46 - that will print us back any sort of
173:47 - index based on that position so if we
173:51 - just have this is a test then it's prob
173:54 - print as the T because that's the first
173:56 - index and so on and so forth so what we
173:59 - can do with this information is take
174:01 - what we can do with the string index and
174:03 - then also use the property which is
174:05 - length and then use these two values to
174:08 - be able to process this is a test so we
174:11 - have the first character square bracket
174:13 - 0 and the last character is at length 14
174:16 - so our message variable now contains 14
174:19 - characters obviously When I close the
174:21 - program then that value is lost and I
174:22 - have to re-enter it but because of that
174:24 - exact reason we would always use do
174:26 - length because we never know how long
174:28 - the user's input is going to be so we
174:30 - can have a for Loop so we can say 4 into
174:33 - I equal 0 I is less than and we can use
174:36 - the message. length here and then we can
174:38 - say I
174:39 - ++ so you want to start at zero because
174:42 - our first index position is inde Z and
174:45 - we want to go from the index zero all
174:47 - the way to the length now in that
174:49 - example I just printed out 14 for the
174:51 - length but you got to realize is there
174:54 - might be 14 positions but there's only
174:56 - 13 indexes so it's not actually 13 index
175:00 - it's just up to 13 when you start at
175:02 - zero going from 0 to 13 gives you 14
175:06 - positions so when we're saying 0 is less
175:09 - than the message length then that will
175:11 - actually take us from 0 to 13 instead of
175:13 - 0 to 14 if we made this greater than or
175:16 - equal to and change this to a one for
175:18 - example then that's going to go from 1
175:20 - to 14 and first we're going to miss out
175:23 - the first character and we're actually
175:25 - going to go one over the message length
175:27 - so you always want to start from zero if
175:29 - we're going through the entire string so
175:31 - this will go from 0 to 13 and then here
175:34 - we can just have a console right line
175:36 - and just print message square bracket I
175:39 - and then just for the time being we can
175:40 - comment out these lines just so it
175:42 - doesn't saturate the output so let's run
175:43 - this Cod code and see what
175:45 - happens this is a test and then we get
175:48 - them all on separate lines maybe we can
175:51 - just use a console. right instead so we
175:53 - get each character on the same line
175:55 - instead of a new line character being
175:56 - outputed at the end of each of the lines
175:59 - so we can say this is a test again and
176:01 - there we go we get this as a test
176:03 - outputed as well so now that we've
176:05 - printed that in order let's see how we
176:06 - can print it in reverse so just a quick
176:09 - little tip throughout this C I've been
176:11 - quite hard on you I've made you WR the
176:13 - for Loop out exactly the way it should
176:15 - be but all done manually this is so you
176:18 - can get used to the syntax and after a
176:20 - while once you understand exactly what
176:22 - to do then what you can do is when you
176:24 - type in the four you can see that it
176:26 - says there's a for snippet tab twice to
176:28 - insert the for snippet and we can do
176:30 - that now and it actually gives you a
176:32 - little bit of an output you can see
176:34 - these sections that have been
176:35 - highlighted the reason they're
176:36 - highlighted is once you're done with one
176:38 - section you can actually press Tab and
176:40 - it'll jump to the next one so now my
176:42 - cursor is jumped on the length and we
176:44 - can type in message. length if I press
176:47 - tab again then it'll just keep cycling
176:49 - through them until we're done and we can
176:51 - press Escape upon pressing escape then
176:53 - it gets out of the little message and
176:55 - there we go we've now just defined a
176:58 - really quick for Loop please only use
177:00 - this once you're comfortable writing for
177:02 - loops and don't use them immediately
177:04 - because you might get stuck on what to
177:06 - do and how to do it so it's best to
177:08 - always write the for Loop syntax out
177:09 - from scratch so you can get used to the
177:11 - three different sections so this is
177:13 - actually a for Loop that goes forwards
177:15 - it's going from 0 to 13 but what we
177:18 - actually want to do now is go from 13 to
177:21 - 0er so let's actually change this for
177:23 - Loop completely and we can do our little
177:25 - shortcut again so if we do four and then
177:28 - we don't actually want to start on the
177:29 - value is zero we want to start on
177:32 - message. length and then you want to
177:34 - minus one and just as we said here we
177:37 - never actually want to get to the length
177:39 - because we want to go from 0 to 13 so if
177:41 - we want to go backwards we want to go
177:43 - from 13 to zero and the only way that we
177:46 - can get this 13 is by getting the 14
177:49 - value which is message. length and
177:51 - simply minusing one so now that we've
177:53 - got our first variable which is in I
177:55 - equal message length minus one which
177:57 - will give us the 13 we want to go from I
178:00 - and instead of less than it's going to
178:03 - be greater than or equal to and then we
178:05 - actually want to change it to a zero
178:07 - because we actually want to stop at zero
178:08 - in this case and then we don't want to
178:10 - use I ++ because if we start at 13 we
178:14 - want to go down in one instead of up in
178:16 - one then we can simply just do minus
178:19 - minus we can take this exact line and
178:21 - print it out to the
178:23 - screen and if we just print something
178:25 - small in between like a hyphen just to
178:28 - separate the two outputs and let's see
178:30 - what
178:31 - happens test there we go so we have test
178:35 - and then t s e and t is now in Reverse
178:39 - but now you might be wondering if we had
178:42 - a shortcut for the four what what's this
178:44 - for with an additional R Cordes n it for
178:46 - a reverse for Loop so if you tap tab
178:49 - twice you can see that we have exactly
178:51 - the same format in I equals something
178:54 - minus one which we have right here and
178:56 - then we have I is greater than or equal
178:58 - to zero as is we have here and then we
179:01 - have IUS minus just like here so we can
179:04 - literally just change this into message
179:06 - do length and then these two now are
179:09 - exactly the same so just copying this
179:12 - down we'll get us exactly what we need
179:14 - but obviously we just wrote this I just
179:15 - wanted to show you the shortcut so let's
179:18 - try it with a longer string this is a
179:20 - test there you go and if you wanted to
179:22 - you could just print these on separate
179:23 - lines so you can just change this into a
179:25 - right line for
179:27 - example and have it like that it doesn't
179:29 - really matter the rest is up to you but
179:31 - the task is just so you can print it one
179:33 - way and then print it the other way I
179:35 - realized that what you can also do is
179:38 - just simply print a console right line
179:40 - and have message in there and just get
179:42 - rid of this completely and the output
179:44 - will still look exactly the same there
179:47 - you go and the reason why I told you to
179:49 - write the for Loop is not because it'll
179:51 - be easier if you do this it's more for
179:53 - your Educational Learning purposes
179:55 - having more practice to how to iterate a
179:57 - string variable is very helpful for the
180:00 - future and you can understand it fully
180:02 - if you just print out to the screen then
180:04 - you're not learning anything extra
180:05 - you're just applying what you already
180:07 - know so let's just have a quick recap we
180:09 - ask the user to enter the message we STW
180:11 - it into a string variable and then Iden
180:13 - demonstrated that you could use the
180:14 - square brackets to Output the first
180:16 - index then you can output the length of
180:18 - the entire variable using a follow you
180:20 - can go from zero to message length which
180:23 - will give us from indexes zero up until
180:25 - 13 in this case and then we can go
180:27 - through i++ incremen in one and then we
180:30 - can have a console right which will just
180:32 - print out message index I for the index
180:35 - that we're currently up to and then we
180:36 - break it off with a console right line
180:38 - just in the middle because these are
180:40 - printing on the same line so we need to
180:42 - insert a new line character at the end
180:44 - after we've done that what we can do now
180:46 - is print it in reverse and now we can do
180:48 - exactly the same thing except from 0 to
180:51 - 13 we go from 13 to zero so we start at
180:54 - the message length minus one because the
180:56 - length was 14 and now we minus one to
180:58 - get to 13 and we're going from I is
181:00 - greater than or equal to zero because
181:02 - that's the value that we want to stop at
181:04 - and then we can do I minus minus if we
181:06 - were to take out this equals operator
181:09 - let's see what happens test and now
181:12 - we're actually missing the last
181:13 - character because what we've done is
181:15 - we've actually went from 13 to 1 instead
181:18 - of 13 to 0o so let's put that back in
181:21 - and make sure it works and then we have
181:23 - t set for test and then we're outputting
181:26 - the exact same thing in both for Loops
181:29 - because we're simply just printing the
181:30 - character that we're currently up to and
181:32 - because this for Loop starts at zero and
181:34 - this for Loop starts at the length minus
181:36 - one then they outputting the same values
181:39 - or what it appears to be the same values
181:41 - it's just starting at different indexes
181:45 - in this exercise we're going to be
181:47 - building some sort of a password
181:48 - validator this can be present in
181:50 - something like a register form where you
181:52 - ask the user to enter their password and
181:54 - then enter it again to make sure that
181:56 - they've entered it correctly so you want
181:57 - to ask user to enter their password in
181:59 - twice and store them both check if they
182:01 - both contain something if they do we can
182:03 - print out password match if they don't
182:05 - passwords do not match and if they both
182:07 - contain nothing then you want to Output
182:09 - please enter a password so let's get
182:11 - started first we can have have a console
182:14 - console right we can have enter
182:18 - password string password equals console.
182:23 - readline and then we can just copy these
182:25 - two lines down using contrl D and then
182:28 - we can have a password C for password
182:30 - confirmation and we can say enter
182:32 - password again and let's just print
182:34 - these out to the screen just to make
182:35 - sure we know what's going on just like
182:37 - so so we can have abber and then abber
182:40 - again so now we have both AB stored and
182:42 - that's fine
182:44 - so let's see what we can do now we need
182:46 - to check if they both contain something
182:48 - so what are the different ways that we
182:49 - can do this so we can have if password
182:52 - do equals and then we can make it equals
182:54 - to string. empty and because we want to
182:56 - check if it's not empty then we can
182:58 - simply place the not operator right at
183:00 - the start and then we can join them with
183:02 - another one not password. equals and
183:05 - then exactly the same thing string.
183:08 - empty but in this case we don't want to
183:10 - use password we want to use password C
183:13 - there we go so if we've came into here
183:15 - then that means they must have entered
183:17 - something so let's just quickly do our
183:19 - exit path which is if they're empty
183:21 - please enter a password so we can say
183:23 - else and we don't need a condition here
183:26 - because if this were to fail then it has
183:28 - to mean that their passwords empty so we
183:30 - can have a console. right line and we
183:32 - can just do please enter a
183:35 - password and let's just test if this
183:37 - path works first and we just press enter
183:40 - twice and we get please enter a password
183:43 - and maybe if we typee something in for
183:44 - both and then we get nothing because
183:46 - it's actually came to here now perfect
183:49 - so if we come through and we can say
183:51 - password equals equals password C or we
183:54 - could use the equals function and we can
183:56 - say password. equals and then password C
184:00 - and if they both equal to each other
184:02 - then we can print out passwords
184:05 - match there we go and if that were to
184:09 - fail then we can print out passwords do
184:12 - not match
184:14 - here we go let's run that let's find out
184:17 - ABA and ABA and we get passwords match
184:20 - and if we try ABA and ab two is and then
184:23 - we get passwords do not match so what
184:25 - are some other ways that we can do this
184:27 - you can structure this completely
184:29 - differently right now we're doing both
184:31 - checks in one single if statement and we
184:33 - can actually split this up into two and
184:35 - then provide a different error message
184:37 - so right now this ISS please enter a
184:39 - password you might have entered the
184:41 - second one but not have entered the
184:43 - first one or vice versa but it doesn't
184:45 - matter because you have to enter both of
184:47 - them in order to pass this validation
184:49 - check so what you could do instead is
184:51 - actually put another if statement inside
184:54 - and paste this one inside here and then
184:57 - just keep these as two separate if
184:59 - statements and then you can actually
185:01 - provide different error messages so
185:03 - let's Nest this in one deeper so we can
185:06 - say if the password is not equal to
185:09 - empty and if this returns back true then
185:11 - this variable has something inside it
185:13 - and then once we go inside these curly
185:15 - braces we get another check and if the
185:17 - password C is not equal to nothing then
185:20 - that means if we've came in here then we
185:22 - pass both of these validation checks and
185:24 - both of them contain something and then
185:26 - we can proceed to check the variables so
185:28 - what you can do in the first L statement
185:30 - is you can say please enter a password
185:33 - but on the second one so just after this
185:34 - curly brace we can have another L
185:37 - statement or we can say please enter a
185:41 - password confirmation
185:44 - so I know that was a bit quick so let's
185:45 - just have a quick recap so we can have
185:47 - one if statement that processes the
185:49 - first password that you type in and if
185:51 - this is empty then it says please enter
185:53 - a password and if it's not empty then
185:55 - it'll go inside this curly brace hit the
185:58 - first line and check if the password
186:00 - confirmation is not empty if it is empty
186:03 - then it'll say please enter a password
186:05 - confirmation if both of these return
186:07 - back true then it will go inside the
186:09 - success path in which it will actually
186:11 - check if password is equal to the
186:13 - password confirmation and we can say the
186:15 - passwords match or if they don't equal
186:17 - to each other we can say the passwords
186:19 - do not match let's run that and see what
186:21 - we get so if we type something in for
186:23 - the second one but not the first one so
186:26 - for the first one we just press enter
186:27 - and then let's type something in for the
186:29 - second one and it says please enter a
186:31 - password and then if we run that and do
186:33 - the complete opposite type in p and then
186:36 - press enter for the second one then it
186:38 - says please enter a password
186:39 - confirmation so you can see immediately
186:41 - what we can do is provide a different
186:43 - error message for different situations
186:45 - if you include these both in one line
186:48 - then you can only give out more of a
186:49 - generic error message this is similar
186:51 - for when you go to login and when you
186:53 - get your password or email wrong it
186:55 - doesn't say which one you've got wrong
186:57 - it just says them generically which one
186:59 - you've got wrong it says invalid
187:01 - credentials or invalid username or email
187:04 - it will say them generically like
187:05 - invalid username or password but it
187:07 - won't tell you which one it is because
187:09 - hackers can exploit this and you don't
187:11 - want to be doing this but in the case of
187:13 - a password confirmation and this is just
187:15 - for a register form then it's not
187:17 - exactly the worst thing to do this
187:19 - because sometimes what you'll see is the
187:20 - text boxes might go red to indicate that
187:22 - they're both not equal to each other and
187:24 - this is fine on registration but it's
187:26 - not fine on the login what we can also
187:28 - do in here once we've checked if they're
187:30 - both not equal to something we can
187:32 - actually just validate how long the
187:33 - string needs to be we can have if
187:36 - password. length and let's say you had a
187:38 - restriction and it can only be over six
187:41 - characters and we can say six
187:43 - and password
187:45 - c.length is greater than or equal to 6
187:48 - and once it passes all three of these
187:50 - checks then we can check if they're
187:52 - equal to each other if they got
187:54 - something inside and if they've got
187:56 - something inside and if they've got both
187:59 - the length is greater than or equal to
188:01 - six then we can check it so we can have
188:04 - something like password and then
188:06 - password and then this returns back with
188:08 - password matched if we have something
188:10 - like abber then it's actually returns
188:12 - back nothing
188:13 - because we don't have an else for this
188:15 - specific bracket so we can say else
188:19 - conso right line please enter six or
188:23 - more
188:25 - characters so if we type in Alit twice
188:28 - then you can see we get this message now
188:30 - please enter six some more characters so
188:32 - right now we have a validation for the
188:34 - first password and the second password
188:37 - and for the length and if all these
188:39 - checks go by then you can process the
188:41 - actual passwords that they they've
188:43 - entered and check if they're equal to
188:44 - each other you can technically do all of
188:46 - these checks in one line it'll just be a
188:49 - pretty long line but what that means is
188:51 - you can't have three separate error
188:53 - messages like this if you have it
188:55 - processed in one line the only error
188:57 - message that you can give is very
188:58 - generic there's no one generic message
189:00 - that can fit for password empty and the
189:03 - confirmation password empty and for the
189:05 - length so maybe what you could do is
189:07 - chain the both of them to be check if
189:09 - they're not empty so then you can
189:11 - process a message with something like
189:13 - please enter a password and then you can
189:15 - have another check for the password
189:16 - length just to let them know that they
189:18 - need to enter six or more characters but
189:20 - in these off into two separate checks is
189:23 - going to be very helpful because it'll
189:24 - let the user know something a bit better
189:26 - than a generic error message so in the
189:29 - previous examples throughout the course
189:30 - we've actually talked about using the
189:32 - two lower function and I said in
189:34 - majority of cases where you want
189:36 - actually compare two different things
189:37 - you want to actually use the two lower
189:39 - function or the two upper function and
189:41 - you can achieve this by having two lower
189:44 - just here and then also two lower just
189:47 - here now the problem with comparing if
189:49 - they're both equal to each other but
189:51 - checking the lowercase values is this is
189:53 - indeed a password if you're checking if
189:55 - the user has inputed any capitals lower
189:58 - case symbols Etc then there's no point
190:00 - in applying a too low function because
190:02 - that will just ruin their actual
190:04 - password and reduce the security so in
190:06 - certain cases you don't always want to
190:08 - use two lower and two upper for
190:10 - comparison you want to just check the
190:12 - value straight up and the same thing is
190:14 - when you're doing a login you don't want
190:16 - to be checking their values lowercase
190:18 - because that's their login these are
190:20 - some of the specific situations where
190:22 - you don't want to be using the tow
190:23 - function if the data that you're
190:25 - processing is pretty sensitive and will
190:27 - be messed up if you use the toow
190:29 - function that you should always avoid it
190:31 - passwords fit this perfectly and
190:33 - usernames as well if someone's added
190:35 - some capitals inside the username then
190:37 - you don't want to ruin that by doing
190:38 - lower case or upper
190:41 - case if you're your username is spelled
190:43 - like this and you try and log on like
190:45 - this then they are not equal to each
190:47 - other because this will probably be two
190:49 - different accounts you can have an
190:51 - account with a capital B and have
190:53 - account with a lowercase b so you don't
190:55 - be lower casing the input and then doing
190:56 - a comparison because what you might
190:58 - actually retrieve is a different account
191:00 - than you're looking
191:02 - for so now that we talked about stuff
191:04 - theoretically let's see how we can do
191:06 - things practically so as you heard in
191:08 - the last video arrays are a way that we
191:10 - can store multiple variables of the same
191:12 - data type in one little group so if we
191:15 - had something like Nome 1 = 5 in n 2 =
191:19 - 10 in N 3 = 15 and we had a similar case
191:23 - in one of the exercises like this where
191:25 - we had to work out if a triangle was
191:27 - actually a triangle so we asked user to
191:29 - input three different angles and then we
191:31 - stalled them all and then we added them
191:33 - up after and it looked something like
191:35 - this in total equals num 1 plus num 2
191:39 - and then finally plus num 3 and then we
191:42 - had some sort of if statement after to
191:44 - check if the
191:45 - total was equal to
191:48 - 180 and then we did something in the
191:50 - curly braces just output that it's valid
191:52 - and then else output it's
191:54 - invalid you can see how this gets a
191:56 - little tedious we have to create a new
191:58 - variable every single time we want some
192:00 - more data to be stored and in this case
192:02 - we just simply want another number that
192:04 - we can store but we have to just keep a
192:06 - pending one to it in that case we could
192:09 - have angle one angle two and angle three
192:11 - but how about if you have something that
192:13 - just called angles for now let's just
192:15 - talk about how arrays work and how we
192:17 - can use them and then after I've went
192:19 - through this example about arrays and
192:20 - taught you what to do with it then I
192:22 - will go get the code from the exercise
192:24 - from the triangle video and actually
192:26 - transform it into using an array so you
192:28 - can see what the difference is and how
192:29 - the new code will look like so let's get
192:32 - rid of this little section so now that
192:34 - we've got three integer variables let's
192:36 - see how we can do this another way so
192:38 - the Syntax for arrays you first type in
192:40 - the data type that you want just like
192:43 - before and then you add on a square
192:44 - bracket and a closed square bracket
192:46 - there's nothing that needs to be inside
192:48 - as of right now then you press space and
192:50 - type in the variable name as per always
192:53 - and then we can make that equal to new
192:55 - in 3 so what this side of the equal sign
192:58 - means is we want a new instance of an
193:00 - integer array and we want to have three
193:02 - positions since we have three variables
193:05 - here that we want to store we need to
193:06 - have three positions to stall them so
193:09 - this line in total says that we want to
193:10 - integer array we want to call it numbers
193:13 - and we want to instantiate our new
193:14 - integer array with three positions
193:17 - instantiate is just the term that we use
193:19 - when you turn something into a new class
193:22 - at this point if we don't use new then
193:25 - we're going to get compiler error
193:27 - because it's unsure what this is trying
193:28 - to tell you it's trying to St an integer
193:31 - inside integer array and that makes no
193:33 - sense so it won't recognize the square
193:35 - brackets in this case because it has no
193:37 - idea what it's trying to do and this
193:38 - syntax is completely incorrect so the
193:40 - compiler doesn't know what error message
193:42 - to give you so we can have a new int and
193:45 - what we can do now is by using the
193:47 - square bracket reference we can actually
193:49 - specify these three variables inside our
193:51 - numbers array so now we have access to
193:54 - numbers 0 = 5 and then if we use
193:58 - controll D to copy this down twice we
194:00 - change this to one and two and then
194:03 - print 10 here and 15 here so now this is
194:06 - exactly the same as this we have three
194:09 - integer variables defined separately as
194:11 - 5 10 15
194:13 - and now that we've created an array of
194:14 - numbers we can specify all three of
194:17 - these values inside our numbers array so
194:19 - instead of having three individual
194:21 - variables now we just have one that
194:23 - holds everything like a group and just
194:25 - to show you how this works if we have a
194:27 - console right line we can say n one
194:29 - space num two space num three and if we
194:34 - use control D to duplicate that down
194:36 - then what we can have instead of these
194:38 - num ones is simply just place these
194:40 - values
194:40 - inside changes to one and changes to two
194:44 - and what you should notice is these two
194:46 - lines are going to print the exact same
194:49 - values there we go so in this example
194:52 - we've took our sloppy code that will
194:54 - roll us around appending one to this
194:56 - number creating a new array and then
194:58 - printing it out so let's say we want to
195:00 - actually use these to read in values
195:02 - from the console what can we do and
195:04 - you'd use these exactly the same as how
195:06 - you use variables up here this is just
195:09 - an integer variable at a specific
195:10 - position held inside a group so we could
195:13 - simply have a console right line delete
195:16 - the right and just say enter a
195:18 - number and then instead of starting five
195:21 - we can say convert to in32 and then we
195:23 - can have a console.
195:26 - readline and that will read in from the
195:28 - console convert it to an integer 32 and
195:31 - then store it into the first position of
195:33 - our numbers array now if we just copy
195:36 - this down
195:37 - twice and we can get rid of these two
195:39 - lines cuz this is just staring it
195:41 - statically and add one and two to here
195:44 - so now what we're saying is enter a
195:46 - number St into 0o 1 and two and let's
195:49 - see what happens now so now we get asked
195:52 - the numbers 10 20 and 30 and you can see
195:54 - that they've been stored here of course
195:57 - these haven't changed because this is
195:58 - still referencing our static variables
196:00 - up here so what you can see in this
196:02 - example is now that we've made an array
196:04 - we can specify each of the values very
196:07 - easily inside here and if so we wanted
196:09 - to have a number four instead of to
196:12 - duplicate it and rename it and change
196:14 - the value for example we can just simply
196:16 - turn this into four duplicate this
196:19 - little section and then just change it
196:21 - to a three one thing to note in C and
196:25 - many other languages almost every single
196:27 - index will start at zero in the last
196:30 - section we covered the string functions
196:32 - and they also started at zero when
196:34 - you're dealing with strings and their
196:36 - positions when you have a for Loop of
196:38 - the string then you always want to use
196:40 - index zero as the first position
196:43 - the same is true here we have four
196:45 - positions which means it goes from zero
196:48 - all the way till three it never goes
196:50 - from 1 to 4 or from 0 to 4 these are bad
196:53 - values it always goes from 0 to
196:56 - 3 you might be thinking this looks
197:00 - really good but when we go to print it
197:02 - we're going to have to copy and paste
197:03 - this little section add another one and
197:05 - rename this to three this gets a little
197:07 - bit tedious if we just trying to print
197:09 - them all to the screen so let's see how
197:11 - we can fix that we can use a four Loop
197:13 - for this so we can have four in I equals
197:16 - z i is less than and then we can have
197:19 - numbers do length and if you notice from
197:22 - iterating through a string variable the
197:24 - syntax is exactly the same we have a do
197:27 - length property on the arrays as well as
197:29 - we do with a string
197:31 - variable so in order to print out this
197:33 - line what we can do is print one of them
197:36 - every time we go around the for Loop
197:38 - instead of using a console right line we
197:40 - can just use a console right
197:43 - so we can have console.
197:45 - right and then what we can simply do in
197:47 - here is we can say numbers square
197:50 - bracket I and then we can have a space
197:53 - right after it just to M make what
197:56 - happens here we have the number printed
197:57 - out and then a space after it number
197:59 - printed out a space after it and so on
198:02 - and so forth so let's see what happens
198:04 - now if we run the code 10 20 30 40 there
198:10 - you go so you can see that these two
198:11 - lines are exactly same and now what
198:13 - happens is let's just comment these two
198:15 - lines out and if we were to change this
198:17 - to five and we can duplicate the
198:20 - section changes to a four and then now
198:23 - we have five variables started and we
198:25 - don't need to touch this for Loop
198:26 - because the numbers do length will get
198:28 - updated anyway so we can have 1 2 3 4
198:31 - five and you can see all five variables
198:34 - have been printed automatically what
198:36 - also is quite tedious here is we're
198:37 - having to add another one to this just
198:39 - so we can ask the user how many times
198:41 - that they want to enter a number again
198:44 - this is quite tedious but we also have a
198:46 - fix for that because we know how many
198:48 - times we want to ask the user to enter a
198:50 - number then we can use a for Loop to
198:52 - iterate through and ask the user as you
198:55 - can see every single line here is
198:57 - exactly the same except for the index
198:59 - position that we're dealing with and the
199:01 - same is true for this for Loop this line
199:04 - will always be the same as we're
199:06 - printing out here and the only thing
199:07 - that changes between this section and
199:10 - this section is the fact that this says
199:12 - one and this says zero so we can
199:14 - translate this into a for Loop to make
199:17 - it
199:18 - Dynamic and we can do exactly the same
199:20 - thing above here so let's actually copy
199:23 - and paste this for
199:25 - Loop because we want to do exactly the
199:27 - same
199:29 - approach we want to go through all the
199:31 - positions inside our numbers array and
199:33 - then we can actually ask the user to
199:35 - enter a number in so let's block comment
199:37 - out this massive section and then we can
199:40 - take one of them and place it inside the
199:42 - follow Loop so now we're asking the user
199:44 - enter a number and then we're storing
199:46 - inside index zero and of course if we
199:48 - keep using index zero then it's just
199:50 - going to override the first one and
199:51 - we're not going to store any data so we
199:53 - can change that to an i let's see what
199:55 - happens when we run it now 1 2 3 4 5 and
199:59 - then we get the five numbers being
200:01 - printed this is awesome because what
200:03 - we've got now is five output commands
200:06 - coming straight to the console just from
200:07 - a for Loop the for Loop is responsible
200:10 - for printing them all out to the screen
200:12 - reading in the value convert it to an
200:14 - integer and then store it inside our
200:15 - array and then we have a separate for
200:17 - Loop to print it out to the screen
200:19 - what's really really powerful about
200:21 - these two for Loops that we've built is
200:23 - if we want to have 10 numbers now we
200:25 - simply just change this to 10 and then
200:27 - just rerun the code as you can see we
200:29 - now have 10 numbers there you go so what
200:32 - we've just done if we move this code
200:34 - down a lot now just so we can have it
200:36 - close
200:37 - by we've made our entire program that
200:40 - was actually pretty lengthy in into just
200:42 - a couple of lines and two for Loops one
200:45 - for Loop is responsible for looping x
200:47 - amount of times x depends on whatever
200:49 - that number is and then we go through
200:51 - and ask the user to enter a number read
200:54 - in from the console convert it to an
200:56 - integer 32 and start within the array
200:59 - after this for Loop has finished running
201:01 - then we have all the numbers stored
201:03 - inside our array and then we can go
201:05 - through and print them all out to the
201:06 - console another way we can print this
201:09 - out to the screen is by actually using a
201:11 - for each so we can say int num and then
201:14 - we want to be a number inside our
201:16 - numbers so for each of the integers
201:19 - inside the number we want to create a
201:21 - new local variable called num and then
201:23 - we can use it in here and if we take
201:25 - this line and copy it down everything's
201:27 - exactly the same except we don't need to
201:29 - specify the main array numbers now and
201:31 - we don't need to specify the square
201:33 - brackets we can just change this
201:35 - completely and replace it with n and if
201:37 - we just make this number smaller so we
201:39 - don't have to Output a lot of
201:40 - values
201:42 - 1 two and three and you can see that
201:44 - they're exactly the same there's no line
201:46 - between them because I don't have a
201:47 - console right line so let's quickly add
201:49 - that
201:51 - in and there we go 1 2 3 and you can see
201:54 - they're outputting the exact same
201:58 - values the reason why I needed a console
202:01 - right line is because these four Loops
202:02 - are using console. right the problem
202:04 - with console. right is even after
202:06 - finishing writing all of the lines it
202:08 - doesn't continue to the next line it
202:10 - stays there so if I don't break up the
202:13 - two outputs with the console right line
202:15 - then all six outputs from the console
202:17 - right and the other console right will
202:19 - all go on one line this is just for
202:21 - demonstration purpose anyway either one
202:23 - of these Solutions are fine more people
202:26 - tend to use this one the problem with
202:28 - these two options is you can't always
202:29 - use them
202:31 - interchangeably this one will always go
202:33 - through every single position it will
202:36 - always go from zero and it will always
202:37 - go to the length the problem with this
202:40 - for Loop is you can't choose how many
202:42 - times you want to iterate through before
202:44 - you stop there might be a very specific
202:46 - case where you have a big array of data
202:48 - but you only want to select the specific
202:50 - range if an example where you had a
202:52 - th000 array positions so from 0 to 999
202:56 - and let's say you wanted to request and
202:58 - run a for loop from 500 to 600 so you
203:01 - would literally type in 500 in here and
203:04 - then 600 inside here and this would be
203:07 - fine as long as your array has that many
203:09 - positions but with the four each Loop
203:11 - Loop if you run for each loop on a
203:13 - thousand length array then it's going to
203:15 - go through every single position in some
203:18 - cases you might not want that and you
203:19 - only want to go through specific cases
203:22 - so if you know you're going to go
203:23 - through every single case then you can
203:25 - use the for each but if you know you're
203:27 - going to go through a certain amount of
203:28 - cases then it's always best to use the
203:30 - fall Loop okay so we covered quite a lot
203:32 - in this video so let's just have a recap
203:35 - so initially we started off saying we
203:37 - have our num one num two and num three
203:39 - then we had our static variables St
203:41 - inside there and then we created our
203:43 - integer array which is now down here and
203:46 - just to make it a little bit easier to
203:48 - store multiple variables because if you
203:50 - wanted five variables you'd now have to
203:52 - duplicate that and change that to number
203:53 - five and this will get very tedious if
203:55 - we had something like 10 like before
203:58 - this is very long and you don't need be
204:00 - specifying number 10 in your code
204:02 - because this also hurts the readability
204:04 - of it using arrays can solve this
204:06 - problem quite a lot you can easily
204:08 - specify array using this notation int
204:12 - square brackets followed by the name and
204:14 - you make that equal to a new int three
204:17 - the three can be any number that you
204:19 - want as long as it's a whole number cuz
204:21 - this tells us how many positions that
204:22 - we've got we then outputed lots of
204:24 - values to the console and read them into
204:26 - our Ray but we had the same problem as
204:29 - we did above where we just had to keep
204:31 - duplicating the sections so what we did
204:33 - to prevent that is by writing a little
204:35 - for Loop that went through every single
204:37 - position in numbers array I puted
204:39 - something to the screen readed in the
204:41 - value converted it and stored it into
204:43 - the array and then after all that was
204:45 - done we can use a for Loop or a for each
204:48 - Loop and print that back to the screen
204:50 - now that we finished the base cont of
204:51 - this video and because I said at the
204:53 - start that I was going to take the
204:54 - triangle exercise and convert that into
204:56 - an array so let's do that now so now
204:59 - I've copy and paste a solution from the
205:01 - triangle exercise straight into this
205:03 - project I've just block commented
205:05 - everything above just so it doesn't
205:06 - interfere with our code so let's just
205:08 - run this code to familiarize us with
205:10 - what's going on so if we enter 60 60 and
205:14 - 60 then it says valid and if You' run it
205:17 - again and enter something else that
205:19 - doesn't equal to 180 then we get invalid
205:22 - so let's see how we can make this code a
205:24 - lot better by the use of arrays so as we
205:26 - said before we don't want to be using
205:28 - this angle one angle two and angle three
205:31 - let's make a int square bracket angles
205:35 - equal new int and then in this case we
205:37 - have three angles and what you could do
205:40 - as well is you could say con int angle
205:43 - count equals
205:44 - 3 and then you can simply use that
205:46 - inside here so later on in the code if
205:49 - we wanted to specify this to a different
205:51 - value we can just change that later
205:53 - on so now that we've got the three
205:55 - angles we can get rid of these three
205:57 - lines and write ourselves a little for
206:00 - Loop so I goes from zero all the way to
206:03 - angles. length and then every single
206:06 - time we go around in the for Loop we
206:08 - want to
206:10 - say console right enter angle one and
206:15 - then we can say angles square bracket
206:19 - and not zero in this case cuz we don't
206:21 - to be specifying index as it will go
206:23 - from 0o to 1 to two we want to be using
206:26 - I I because we're inside a for Loop
206:29 - that's already going through all the
206:30 - indexes forers and make that equal to
206:33 - convert to in32 and then a console.
206:37 - readline now we've got all the values
206:39 - stored inside here let's do deal with
206:41 - this problem so if we just comment out
206:44 - the total for the time being let's run
206:45 - the
206:50 - code oh we have one more error down here
206:52 - sorry let's run the code again and we
206:55 - can say enter angle one and we can type
206:57 - the values in but as you can see we've
207:00 - got angle one for each of the times what
207:03 - we can do in here is use our I index to
207:05 - print out the value so we can turn this
207:07 - into interpolation and then wrap the one
207:10 - inside curly braces and we can simply
207:12 - change this one to an i and let's see
207:15 - what happens now so we have enter angle
207:17 - zero and then one and then two and this
207:20 - is fine but humans don't like reading
207:23 - zero they like reading 1 two and three
207:25 - so what we can simply do is say I + one
207:28 - and because we're using I and then
207:30 - adding one to it it's not going to
207:31 - affect the variable inside the for Loop
207:33 - so there's no problems by doing this
207:35 - this is simply just for the output
207:37 - purposes so now we can have 1 2 and
207:40 - three just show up like that perfect so
207:44 - what we can do now that we have all the
207:45 - angles stored now we need to replace
207:48 - this line by writing a for Loop that can
207:50 - add up all the values for us so we can
207:52 - have for each in angle inside our angles
207:57 - and we can just say int angle sum plus
208:01 - equals
208:03 - angle the problem with this is we can't
208:06 - specify a new variable inside here and
208:09 - then use it outside an if statement so
208:11 - what do we do in this case you want to
208:13 - take angle sum and initialize it outside
208:16 - the for Loop and then give it a value of
208:18 - zero and then inside the follow we can
208:21 - remove the int and we can say angle sum
208:24 - plus equals the whatever angle that
208:26 - we're currently up to so if we had three
208:29 - values that's going to say 0 + 60 and
208:32 - then take that value and add another 60
208:34 - and then take that value and add another
208:36 - 60 so it'll keep a running total for us
208:38 - and if we just print out angle Su to the
208:40 - screen let's see see what happens 10 20
208:43 - 30 and now we have 60 and that's the
208:46 - correct calculation if you add them
208:48 - three together so now that we have a
208:50 - running total for angle sum then we're
208:52 - pretty much done if we get rid of this
208:54 - line of code which is our previous total
208:57 - and we actually bring back our if
208:59 - statement there you go there's no error
209:01 - now and all this is doing is checking if
209:03 - the angle sum is equal to 180 and then
209:06 - print valid and invalid so we can have
209:08 - 60 60 60 and it prints out valid and
209:11 - let's just comment out our
209:13 - output and then we can have 60 60 59 and
209:17 - then it prints out inv volid which is
209:18 - exact same behavior that we saw at the
209:20 - start so let's remove the extra code in
209:23 - here and keep it like this there you go
209:27 - so now we've got our solution just like
209:29 - this and it's a lot better because if
209:31 - triangles were to transform in the
209:32 - future and we wanted more than three
209:34 - sides then we can easily update this
209:36 - value because now that we're using
209:37 - arrays or we're using a for Loop to
209:39 - enter out the values what we can do we
209:42 - don't actually need to store it what I
209:44 - mean by that is we can actually just get
209:45 - rid of this array completely let me
209:49 - demonstrate we can take this angle sum
209:52 - and place it underneath here we can keep
209:54 - the count so we can use that in the for
209:56 - Loop so we going from 0 to three because
209:58 - that's our angle count and then we can
210:01 - get rid of all this and let's see what
210:03 - we can do now so we have an angle count
210:07 - equals 3 so we go from 0 to three which
210:10 - will'll just do as we said before from 0
210:12 - to two because it's less than the angle
210:14 - count and let's just print this to the
210:16 - screen see what happens so the output
210:18 - still exactly the same but what's
210:20 - happening is these values are not being
210:22 - stored they're just being shown to the
210:24 - screen and then not done anything there
210:26 - is no equal sign here to assign it into
210:29 - anything so what we can do is we can say
210:31 - angle sum plus equals the value straight
210:34 - away and now if we try it 60 60 60 then
210:38 - we get valid the main differences
210:40 - between the these two situations is in
210:43 - the first one we used an array to store
210:45 - all the different values and then we
210:47 - added the total but if we're not going
210:50 - to use these values after then what's
210:52 - the point in storing them we can just
210:54 - use a for Loop to ask the user how many
210:56 - times they want to input the values and
210:58 - then just add them every single time
211:00 - that they add the calculation in and at
211:02 - the end we could just simply use a
211:04 - conditional operator to be able to print
211:06 - at the screen whether it's valid or not
211:08 - but let me just undo that solution so I
211:09 - can show you the array solution and we
211:11 - can have a quick recap that was just an
211:13 - extra little tip just in case you wanted
211:15 - to know what different ways you could
211:17 - use to make this work there we go so
211:19 - let's just have a quick recap here so we
211:21 - have a Conant which all we'll do is let
211:24 - us specify three inside here and then we
211:26 - can use it here this isn't entirely
211:28 - necessary but it does clean up your code
211:30 - a little bit because it gives this
211:32 - number three a bit of a meaning it says
211:34 - the amount of angles is our angle count
211:37 - having a three left over like this is
211:39 - what we call a magic number they're
211:41 - quite bad because it hurts the
211:42 - readability of your code people want to
211:44 - know what the three actually means so if
211:47 - you bring in an angle count then you can
211:49 - actually read we want a set of angles
211:51 - and this is the amount that we need and
211:53 - that's denoted by angle count it adds
211:56 - text to a variable it gives you a way of
211:59 - making sure that the text equivalent of
212:01 - a variable is present so someone can
212:04 - just read it after we've created our
212:06 - integer we can actually make a for Loop
212:08 - that goes from zero to the length and
212:10 - then we ask the US it to enter the angle
212:12 - and in the previous example we had enter
212:15 - angle one 2 and three so now we can
212:17 - mimic that by using I but because I
212:20 - starts at zero we want to use plus one
212:22 - every time we loop around the for Loop
212:24 - we ask the user to enter the number read
212:26 - it in through console read line convert
212:28 - using convert 2 and 32 and then store
212:31 - into the array after this for Loop is
212:33 - finished we have all three values stored
212:35 - in the angles array and then we have an
212:37 - In Sum to count up all the values that
212:39 - we need and and then we use the fall
212:41 - Loop to go through every single integer
212:43 - value inside and make a running total
212:46 - and store it inside angle sum once angle
212:48 - sum has the total count then what we can
212:50 - do is use console right line along with
212:53 - the conditional operator to print
212:55 - whether it's valid or invalid to the
212:59 - screen in this video we're going to look
213:01 - at how we can use the built-in array
213:03 - functions to be able to sort an array so
213:05 - if you have an INT array called numbers
213:08 - and then using the previous notation
213:09 - that we looked at we can actually
213:11 - specify any numbers that we want using a
213:13 - common delimited list so if we just have
213:16 - nine numbers inside here then we've
213:18 - actually defined an integer array and
213:20 - then the compiler can count the amount
213:21 - of items that are inside here and give
213:23 - it the length but we don't have to worry
213:25 - about that ourselves so if we use a for
213:27 - each and we can just print
213:30 - Inn inside numbers we can do a console
213:34 - right line on the new local variable
213:36 - called num if print it out we can see
213:38 - all of the values and maybe we can
213:40 - actually just use a console
213:43 - right followed by a space just to give
213:46 - them all on the same line there we go so
213:49 - as you saw before if you had a string
213:51 - called test and we wanted to do
213:53 - something to it for example if you
213:55 - wanted to use the replace function if
213:57 - you want to remove all spaces with an
213:59 - empty string then if we check the
214:00 - replace tool tip we can see that it
214:02 - returns a new string most of the string
214:04 - functions will return you back the new
214:06 - string after doing something with it but
214:09 - in this case if we type type in Array
214:11 - followed by do sort and we can place our
214:14 - array straight in the bracket what
214:16 - you'll realize is if you hover over sort
214:18 - it will sort the elements in the entire
214:20 - array but it will indeed return back a
214:22 - void and void just means it returns back
214:25 - nothing so in this case what it's doing
214:28 - is you're actually affecting the numbers
214:30 - array straight away and you don't have
214:32 - to do numbers equals array. sort numbers
214:35 - for example if we were doing the test
214:37 - replace we would have to do this
214:39 - otherwise this would just be returning
214:41 - back a string but we wouldn't be using
214:43 - it the same is not true for the arrays
214:46 - when you run the array functions they
214:48 - tend to return back void and you don't
214:50 - have to do anything other than give it
214:52 - the array that you wanted to sort so now
214:55 - if you run this code you should just see
214:56 - the same output since they already
214:58 - sorted anywhere so let's change some of
215:00 - these numbers
215:02 - up and just see what happens
215:05 - now there we go 0255 6 7
215:09 - 899 and that's it sorted just like that
215:12 - there isn't a whole lot to this sorting
215:14 - function but what you should note is you
215:16 - can use this new array syntax to Define
215:18 - how many items that you want in there
215:20 - instead of having to change the amount
215:22 - of positions that you have using the
215:23 - square brackets you can just denote any
215:26 - number of items that you want inside the
215:28 - compiler will count them for you and
215:30 - press the length straight into the
215:31 - brackets for you so you don't have to
215:33 - worry about it using the array. sort
215:35 - function all you have to do is give it
215:37 - the parameter of the array that you want
215:39 - to sort and it will affect the array
215:41 - straight away and you don't have to
215:42 - restore it and then we're just using a
215:44 - simple for each Loop to print them out
215:46 - to the
215:48 - screen in this video I want to discuss
215:51 - the array reverse function so if you
215:53 - hide an INT numbers equal new int and if
215:56 - you just had lots of numbers in here
215:59 - defined just up to five then we can add
216:01 - a semicolon and again using this array
216:04 - function we can see array. reverse and
216:06 - pass our array
216:09 - inside and then we can just use a for H
216:12 - our item inside our
216:14 - numbers and simply just print them out
216:16 - using a console. write and we can use
216:18 - string interpolation I just put a space
216:20 - at the end there we go and if you run
216:22 - the code then you can see our numbers
216:25 - have just been reversed there isn't a
216:27 - lot to this video I just wanted to show
216:28 - you about the different functions that
216:30 - you have available for arrays these can
216:32 - come in handy when you have something
216:33 - like a list return from a database for
216:35 - example and it's ordered in a certain
216:37 - way let's say you're returning back a
216:39 - list of lots of people who ordered back
216:41 - alphabetically and it's going from a to
216:43 - zed and let's say you have some sort of
216:45 - user interface that allows you to flip
216:47 - the order instead of having to request
216:49 - the database to get the data back in the
216:51 - opposite order you can use this array
216:53 - function to just reverse the list the
216:55 - same thing goes if you're trying to
216:56 - order by lowest price or highest price
216:58 - you can use this to show the different
216:59 - values in different orders that's where
217:01 - this array function comes in handy when
217:03 - you have different situations like the
217:05 - names or the price by ascending or
217:07 - descending where you can just flip the
217:09 - data and instead of having to request it
217:11 - back from the database again flipping it
217:13 - locally is a lot easier than going back
217:15 - to the database as that uses more data
217:18 - and more computational power on the back
217:19 - end and then return it to the front end
217:22 - it's always best to be able to use these
217:23 - functions instead of having to use
217:25 - external things to be able to return
217:27 - back the same data using it locally like
217:30 - this will give us a performance
217:31 - Advantage because it's done directly on
217:33 - the data instead of having to request
217:35 - everything again if you wanted to do
217:37 - this manually let's have a look and see
217:39 - what your options are you can have your
217:41 - integer array just defined like this
217:43 - with a dynamic list and then we can have
217:45 - a sorted array using the same length as
217:48 - the current array what you can do
217:50 - instead of using reverse we can actually
217:52 - just comment these lines out you can
217:55 - bring back a normal for Loop but if we
217:56 - use two RS it gives us a reverse Vol so
217:59 - the length is going to be our numbers do
218:01 - length and the rest of the paramet is
218:03 - exactly the same we want to go from the
218:05 - last minus one all the way till zero and
218:08 - we want to decrement in one and we can
218:10 - say our sorted number I is equal to
218:14 - numbers I but all this will do right now
218:17 - is just give us back the same value
218:18 - stored so what we need to do in a case
218:21 - like this is make another variable
218:22 - something like X and we can store that
218:24 - into zero and what we can say is X is
218:27 - assigned the value of whatever this
218:29 - numbers is because this is going
218:31 - backwards but we want this one to go
218:33 - forwards CU we want it to be reversed
218:35 - and we can say x++ and see what happens
218:38 - when we run it
218:39 - now so so nothing's going to come up
218:41 - because we don't have any output so
218:42 - let's use a for
218:44 - each we can have V
218:47 - number inside our sorted numbers and we
218:50 - can just take this and place it in here
218:52 - and just print out the item and we can
218:54 - use
218:56 - num and there you go it's been flipped
218:59 - the exact same value is just the other
219:01 - way so this is obviously a little bit
219:03 - more complicated because you have to use
219:05 - an additional variable use a backwards
219:07 - for Loop and then incom your own
219:09 - separate variable and as well as
219:11 - completely make a whole new array of
219:13 - course you should only do this if you
219:14 - need it as two separate arrays if not
219:16 - you can always just affect the one that
219:18 - you're up to right
219:20 - now because I said before that arrays
219:23 - are actually static data and they're
219:24 - going to be fixed size then there's no
219:27 - way to remove or add an item but you can
219:29 - clear what you have already so let's
219:31 - have a look array do clear set a range
219:35 - of elements in an array to the default
219:37 - value of each element type so the first
219:39 - parameter takes our array so let's use
219:41 - numbers and we want to start off at the
219:43 - index that we want to clear from and
219:45 - let's just say zero and because we want
219:47 - to clear the entire array let's go all
219:49 - the way to numbers. length and now let's
219:52 - just produce a for each of our item
219:54 - inside numbers and then just have a
219:56 - console right string interpolation which
220:00 - just prints out the item followed by
220:01 - space and now let's run the code and see
220:03 - what happens so we have lots of zeros in
220:06 - the console and this is to be expected
220:08 - because as we've talked about before for
220:10 - the default value for an integer is
220:12 - indeed zero so all this is doing when it
220:15 - says it's clearing it's just actually
220:17 - assigning all of the positions the value
220:19 - of zero and we can mimic this quite
220:21 - easily through a for Loop so if we
220:24 - comment this out and write ourselves a
220:26 - for Loop in I equals z and we want to go
220:28 - to numbers. length and then simply
220:31 - inside we just want to say numbers
220:33 - square braet I equals to Z what you can
220:36 - also write is the word default this will
220:39 - pick up the default value for the data
220:41 - type that you specified you can type in
220:43 - zero or you can type in default it's up
220:46 - to you but I think in this case if
220:48 - you're trying to reset it back to
220:49 - default then you don't have to worry
220:51 - about remembering it or any typos you
220:53 - can just use the keyword default so if
220:56 - we run this code now let's see what
220:57 - happens so effectively we've mimicked
221:00 - what this function is doing but let's
221:02 - have a look and see what other
221:03 - parameters we have access to so if we
221:06 - comment this out and drop the value then
221:08 - you can still see we only have one
221:10 - Constructor normally you'd see the open
221:12 - down arrows on the left hand side to say
221:14 - one of two in this case we only have
221:16 - access to one Constructor it will only
221:18 - give us a range of elements we want to
221:20 - remove but really we just want to clear
221:23 - it does say here in the tool tip the
221:25 - array whose elements need to be cleared
221:28 - and because it is a clear and not a
221:29 - remove you got to remember when using
221:31 - this function it doesn't actually remove
221:33 - any of the positions it just resets the
221:35 - values inside the array so what we can
221:37 - do in this case is we can say numbers
221:40 - comma 5 comma 5 and what that will do is
221:44 - the first parameter is where you want to
221:46 - start so if you want to start at the
221:48 - fifth position and then we want to count
221:50 - five forward and because we have 10
221:53 - numbers then this should return back
221:54 - okay let's comment out this for Loops it
221:57 - doesn't take an effect and let's run the
221:59 - code and see what happens now so now we
222:01 - took the position five which is actually
222:03 - the sixth number because it's zero base
222:05 - and said we want to remove five forward
222:08 - so itself and then P more forward and
222:11 - there we go we have five numbers being
222:13 - removed so instead of removing all of
222:15 - the different values we can actually
222:17 - clear a certain amount that we want and
222:19 - to mimic this in a for Loop we can do
222:21 - the following we can start it at five
222:24 - and we want to go to 10 and let's run
222:27 - the code and you can see the output is
222:29 - exactly the same when doing in a for
222:32 - Loop you need to actually calculate what
222:34 - this is going to be so we need to take
222:36 - both the numbers the fifth index and the
222:38 - five length which is 5 + 5 and then we
222:41 - get 10 and we don't make this less than
222:43 - or equal to 10 because we have 10
222:46 - numbers so actually want to go from
222:48 - position five to position 9 which will
222:50 - equate to less than 10 we actually want
222:52 - to go from position five all the way to
222:54 - position 9 which actually covers five
222:57 - numbers 5 6 7 8 9 even though it feels
223:02 - like the difference between the two
223:03 - numbers is only four because 9 - 5 is
223:06 - four but we actually have five numbers
223:08 - between that 1 2 3 4 5 there we go so
223:13 - when we print the values from 5 to less
223:15 - than 10 we're going from 5 to 9 which is
223:18 - exactly what this is doing this is the
223:20 - index that you start at and this is how
223:22 - many numbers you want to count forward
223:25 - so let's just have a quick recap of this
223:26 - function we defined our numbers array
223:29 - using array. clear it doesn't actually
223:32 - clear the values it just gives us access
223:34 - to removing them back to their default
223:36 - values it doesn't actually clear the
223:38 - array it just resets the the values back
223:40 - to their default type we can have
223:42 - numbers parameter which will equal to
223:44 - our array and we want to say we want to
223:47 - go from index0 all the way to numbers.
223:50 - length which will be every single value
223:52 - inside the array and all that will do is
223:54 - go through the array and set them all to
223:56 - their default value which is similar to
223:59 - what this for Loop is doing and before
224:01 - we had inti equals z and I is less than
224:04 - numbers. length and that will go through
224:06 - every single position you can
224:07 - technically use zero instead of default
224:10 - but that would mean you have to remember
224:11 - the default value of every single data
224:13 - type it's easier to just write the
224:15 - default keyword and it doesn't promote
224:17 - any typos using the default keyword is
224:20 - by far the easiest and the most safest
224:22 - option if you're going to have this
224:23 - situation so making every numbers index
224:26 - equal to default in this case because
224:28 - we're using integers it's going to
224:30 - assign the value of zero and then after
224:32 - this voles run with I is zero and I is
224:35 - less than numbers. length it's going to
224:37 - make all of these positions equal to
224:39 - zero which is in essence what this
224:41 - function is here for because arrays
224:43 - can't be added or change in terms of the
224:45 - values that they have after they've been
224:47 - created you can only really modify
224:49 - what's already there or you can reset
224:51 - them all back to zero using this
224:53 - notation from zero to numbers length you
224:56 - can get rid of all the values and make
224:58 - them all zero using five to five means
225:00 - it'll start index 5 which is the sixth
225:03 - position and then go five numbers
225:05 - forward so it will delete these and
225:07 - reset them back to zero you can mimic is
225:09 - and a follow Loop just like this start
225:12 - in I at five and then go to less than 10
225:15 - and the reason why it's less than 10 is
225:17 - 5 + 5 gives you the 10th index but
225:19 - because it's I is less than 10 you
225:21 - actually want to go to the ninth index
225:24 - because from 5 to 9 that's actually
225:26 - covering five different numbers and then
225:28 - we can go through and assign the default
225:30 - value and then when we print it out
225:32 - you'll see that all of these numbers
225:34 - have turned into zeros just like
225:38 - so searching through arrays are very
225:41 - helpful when you try to find some data
225:43 - inside your array and you want to return
225:45 - back the position to maybe do something
225:47 - else with it so let's have a look at
225:48 - this example so we have a numbers array
225:51 - and let's say we want to search number
225:52 - 199 and find the index of it so first
225:56 - let's ask the user what the number they
225:58 - want to search enter number to search
226:01 - then we can have in search is equal to
226:04 - convert to in32 and we're converting the
226:07 - console. readline
226:10 - and then let's have a look at the
226:11 - function so inside the array Library we
226:13 - have an index of searches for the
226:16 - specified object and Returns the index
226:18 - of the first occurrence in a
226:19 - one-dimensional array this is very
226:21 - important as it says the first
226:23 - occurrence which means if there was
226:25 - another 199 at the end it's only going
226:28 - to return you back this one and then
226:30 - stop immediately and not give you the
226:32 - value of this one so let's have a look
226:34 - in the parameters and see what it takes
226:36 - it takes our array and then a value so
226:39 - our array is called numbers and the
226:41 - value you want to search by is our
226:42 - variable called search if you hover over
226:44 - the index function again it says that it
226:47 - returns back an integer zerob based
226:49 - index of the first occurrence of the
226:51 - value in the entire Ray if it was found
226:54 - otherwise the value is going to be minus
226:56 - one so we can say in position is equal
226:58 - to this and because it says if it's
227:01 - going to be found then it's going to
227:03 - have the value of a zero index and if
227:05 - it's not going to be found it's going to
227:07 - have the value of minus1 so we can say
227:09 - if the position is greater than minus1
227:12 - because if it's greater than minus1 that
227:14 - means the value is zero onwards we can
227:18 - also write this by saying if the
227:19 - position is greater than or equal to
227:21 - zero it's just up to you they both mean
227:24 - the same thing and then we can say in
227:26 - here number
227:29 - search has been found at position
227:34 - position there we go so let's run the
227:36 - code and let's do a perfect situation so
227:39 - we can can say 50 and you can see it
227:41 - says number 50 has been found at
227:43 - position three and that's the fourth
227:45 - index since it's zero based and what you
227:48 - could do if you wanted to is actually
227:49 - add one to this just so it looks like a
227:51 - bit more of a readable number because
227:54 - four is going to be the fourth number 1
227:57 - 2 3 4 and let's try find a number that
228:00 - hasn't came up like 60 it's going to
228:03 - return us back with nothing this is
228:05 - really bad because it looks like the
228:06 - search has failed which it has but you
228:08 - need to Output message to let the user
228:10 - know so have conso right line and say
228:13 - number search has not been
228:16 - found let's type that again 60 number 60
228:20 - has not been found so let's see what we
228:22 - can do to be able to write this function
228:24 - ourselves if we just block comment this
228:26 - for the time being we can actually use
228:29 - in
228:31 - position equals to minus1 and the reason
228:34 - why I make it equal to minus1 because
228:36 - when we read the tool tipe of this index
228:38 - function it said if it's not not going
228:39 - to be found it's set to minus1 so why
228:41 - don't we set it to minus1 first and then
228:43 - we can try and find it so in I equals 0
228:46 - and we want to go to numbers. length and
228:50 - inside here we want to scan each of the
228:52 - positions so we can say numbers square
228:54 - braet I and if that is equal to our
228:57 - search then we can set the position
228:59 - equal to I if the number we're up to is
229:02 - equal to what the user has typed in then
229:04 - we want to set our position to the index
229:06 - we're currently up to and we don't need
229:08 - to have an else because we've already
229:09 - set it to minus one and after the for
229:12 - Loop we can actually take this if
229:14 - statement and put it back down here
229:16 - because the code's going to be the same
229:18 - if the position is greater than minus
229:20 - one which in this case is our default
229:22 - value so in essence if this value has
229:24 - changed then this should always pass EG
229:28 - we've found the number so let's run the
229:30 - code and let's type a number in 30 now
229:34 - it's found at position five now if we
229:36 - try 60 again number 60 has is not being
229:40 - found there we go so this function is
229:43 - exactly doing something similar to this
229:46 - it's going through every single position
229:48 - finding the variable and if they match
229:50 - assigning the index and then after just
229:53 - returning back to position back to the
229:55 - console so let's comment our example and
229:57 - let's see what other variants of the
229:59 - function we can use and let's comment
230:00 - back the first one so using this line we
230:04 - can duplicate it and just comment it so
230:07 - we have some other parameters inside
230:09 - here if we add a comma we can actually
230:11 - give it a start Index this is the
230:13 - starting index of the search and let's
230:15 - say you only want to search from the
230:17 - second number onwards then you can just
230:20 - type in the number two so now if you've
230:21 - run the code and type in 90 it's going
230:24 - to say 90 is not found cuz 90 is the
230:26 - first one and let's try a value like 50
230:29 - now it says the number 50 is being found
230:31 - at position four because now it's
230:33 - included in the range from two onwards
230:36 - because this is two onwards it'll be
230:38 - position two until the the end of the
230:39 - array if you wanted a very specific
230:41 - range then you can actually give it
230:43 - another value so we can say we want to
230:45 - go from zero and then we only want to go
230:48 - to forward so if you run that now and
230:50 - type in 22 it says it's not being found
230:53 - cuz we' started here and we said 1 2 so
230:57 - now it's only searching between 90 and
230:59 - 199 and if you wanted to include the
231:02 - middle ones you could say you want to
231:03 - start a position one and go to forward
231:06 - so now you get these two numbers and so
231:08 - on and so forth
231:09 - so now if we try number 90 you'll see
231:12 - it's not being found because 90 is not
231:14 - one of these two the reason why you'd
231:16 - use different ones like this if I revert
231:18 - back the first
231:20 - one this will go from two till the end
231:23 - this will go specific range and this
231:25 - will go through everything the reason
231:27 - why these exist is if you have a very
231:29 - very big array let's say it's a th000
231:31 - indexes then you don't want to search
231:34 - everything unless you really need to
231:36 - let's say for example you had a names
231:37 - array and it was sorted off
231:39 - alphabetically and the person's name
231:41 - that you wanted to search began with an
231:42 - a there is no point in running the
231:44 - search all the way from a to zed if you
231:46 - know it begins with a and let's say for
231:49 - example you found the first index of the
231:52 - user that has a name B so you have now
231:55 - the indexes from the start of the array
231:57 - up until the last array position that
232:01 - has the value of someone's name
232:02 - beginning with a so now you have the two
232:05 - indexes of every single a name inside
232:08 - this array if this was a this was B and
232:11 - this was C and this was D and you had
232:13 - these two positions then you should only
232:15 - be searching all of the a names instead
232:18 - of searching the entire array and the
232:20 - reason for that is you'll be searching
232:21 - lots more data for no apparent reason
232:24 - and it's going to take an extra long
232:25 - time for searching something that you're
232:27 - never going to find if you're searching
232:29 - for a name that begins with a there is
232:31 - no point in searching for anything a BCD
232:33 - and so on and so forth that's where
232:35 - you'd use the very specific range you
232:38 - can say you want to go from zero all the
232:40 - way up to the first B name so then
232:41 - you're only searching the a names this
232:44 - is just one example and there is a lot
232:46 - more every situation is very unique so
232:49 - use the parameters that you want and
232:51 - always use the ones that can get you the
232:54 - best performance the least amount of
232:56 - things that you can search is the best
232:58 - way forward if you don't know what
233:00 - you're going to be searching then you
233:01 - should always use the top one which will
233:03 - just search everything if you know where
233:05 - the value is going to be or roughly
233:07 - going to be the then you can use this
233:09 - one or this one to give you a better
233:12 - range and it's a bit more focused
233:14 - instead of searching for everything so a
233:16 - quick recap of this index function what
233:18 - it will do is it will return you back to
233:20 - position if it's found it the position
233:22 - will be zero based just as arrays are if
233:25 - it hasn't found the position then it's
233:27 - going to return this variable with minus
233:29 - one so therefore after you've run the
233:31 - code you can check if the value is
233:33 - greater than minus one which will be
233:35 - from zero onwards if the value position
233:38 - is z onwards then you know that that
233:40 - number has been found and you can use
233:42 - the position variable to Output that to
233:44 - the screen if the value position is
233:46 - minus one it means the array index
233:49 - function has returned back negative and
233:51 - the value position is now minus one so
233:53 - you can output to the user that it has
233:55 - not been found just in my little
233:57 - explanation down below you can see that
233:59 - we can mimic this function by setting
234:01 - the value of position to minus one using
234:04 - a for Loop that goes from zero to
234:06 - numbers length and if you wanted to as
234:08 - well you could use these inside here if
234:11 - you wanted to mimic this this goes from
234:14 - two till the end so you can say I equal
234:16 - 2 and you still want to go to the length
234:19 - this one goes from one and then to ahead
234:21 - so you can actually put I equal 1 and
234:24 - then because it's two ahead from one
234:26 - instead of numbers. length it will just
234:28 - be I is less than three because 1 + 2
234:32 - gives you the three so in order to do
234:34 - this manually you can Lube through the
234:36 - elements that you want check if the
234:38 - number you're up to to based off the
234:39 - index position of I is equal to the
234:42 - search variable that the user typed in
234:44 - up here and if you find a match then you
234:46 - can assign the position to the value of
234:48 - I after the for Loop is run you can
234:51 - check the same if statement as we
234:52 - discussed above these are copy and past
234:55 - it down below just to give you an
234:56 - example in this little
235:00 - section all these arrays have static
235:02 - data which means that when you
235:04 - initialize them with a certain length
235:05 - you can't increase that length or
235:07 - decrease the length you can only modify
235:09 - the data inside it and you can't delete
235:11 - any rows if you create an array of size
235:14 - five and you only store three people in
235:16 - then now you have two positions that are
235:19 - being unused and that's unnecessary
235:21 - amount of data stored in your memory if
235:23 - you're not going to be using it up in
235:25 - certain situations like when you're
235:27 - making a game for example Tic Tac Toe
235:30 - then you know you're always going to
235:31 - need a 3X3 grid so a 2d array will be
235:35 - perfect in this situation cuz you know
235:37 - the exact width and height height of
235:39 - your array so you can do this perfectly
235:42 - whereas lists are quite Dynamic if you
235:44 - don't know how many people are going to
235:45 - be within a system for example if you're
235:48 - signing up some sort of register for a
235:51 - class or for a school or something of
235:52 - the sort and you don't know how many
235:54 - people are going to be in that class
235:56 - then you can use something called a list
235:58 - a list a dynamic cuz what you do when
236:00 - you initialize it you just say that you
236:02 - simply want a list and you can add items
236:05 - and you can remove items and you can
236:07 - also modify them if you wanted to expand
236:10 - the size of an array it's slightly
236:12 - complicated but it's not impossible so
236:14 - if you had int numbers equals new int
236:17 - and let's make that length four and
236:19 - let's say we had a numbers array that we
236:21 - wanted to increase to length
236:23 - five we could have new numbers change
236:26 - that position five and then what we're
236:28 - going to have to do is from position
236:30 - zero all the way to three which is our
236:33 - fourth length from the numbers array
236:35 - we're going to have to copy that into 0
236:38 - to 3 of the new numbers array so now
236:40 - they have the extra data plus the last
236:43 - one which will give us our four so
236:45 - that'll be five length 0 to three gives
236:47 - us our four numbers and then we have one
236:50 - empty one so we've just made a new array
236:52 - and then copied all the data from
236:54 - numbers into new numbers now of course
236:56 - this is not really practical that if you
236:57 - want to reduce the size or increase the
236:59 - size you're going to have to do this
237:01 - each time of course you don't want to do
237:03 - this you just want to use something
237:04 - called a list so let's stick with an
237:06 - example and see what we can do so you
237:08 - make this and
237:09 - three and let's just put three numbers
237:12 - inside here if you remember from the
237:13 - array video we can also declare it like
237:15 - this we can say number 0 equal 1 and
237:19 - then one and then two and change these
237:21 - values these two are doing exactly the
237:23 - same thing I'm initializing it with 1 2
237:26 - and 3 and also just saying that all the
237:28 - positions in here are equal to 1 2 and 3
237:31 - so we don't need this twice but I was
237:32 - just showing you as a quick recap so
237:34 - we're declaring array we're calling it
237:36 - numbers and we're giving it a length of
237:38 - three and initializing it to 1 2 and 3
237:41 - now let's see the syntax to define a
237:43 - list you start off with the word list
237:46 - and then you have a left and a right
237:47 - arrow which makes a little section
237:49 - inside the section you actually want to
237:50 - State the data type that you want so if
237:52 - we're copying the numbers array we can
237:54 - have an INT inside here and that's it
237:57 - for the Declaration of the data type and
237:59 - then we can say new numbers or List
238:01 - numbers equals to new and then there you
238:05 - go it gets Auto filled for you but let's
238:07 - just type it in we have list open the
238:10 - arrow in in the middle and then close it
238:13 - so now it's the same on both sides but
238:16 - because this is a new we need to add a
238:17 - Constructor so we can open the curly
238:19 - braces and the first Constructor says
238:21 - initialize a new instance of the list
238:23 - class that is empty and has the default
238:25 - initial capacity press the down arrow we
238:28 - can give it a capacity of the number of
238:30 - elements that the new list can initially
238:31 - store so we can start it off with five
238:34 - length or three length or whatever it
238:36 - doesn't actually matter it just means
238:38 - that we actually have three positions
238:39 - available immediately if we place three
238:42 - in the
238:43 - brackets and the last one we can
238:45 - actually give it entire collection so
238:47 - let's say if we loaded a list of numbers
238:49 - from a database or a list of something
238:52 - from database and we can actually insert
238:54 - it straight into this list by putting a
238:56 - list inside these brackets of course
238:59 - right now we don't have a list that
239:00 - we're going to assign it with so let's
239:02 - just leave this empty and close the
239:03 - brackets and add a semicolon so we could
239:06 - say list numbers do add and then we can
239:09 - add one and then duplicate this down and
239:11 - add two and add three so now these two
239:14 - have exactly the same contents instead
239:16 - of doing this you can have the same
239:18 - notation like this so you can have the
239:20 - codyy braces in
239:22 - here and we can put in one 2 and three
239:25 - now that's doing exactly the same thing
239:27 - and you see I can just keep adding more
239:29 - numbers in here and the list simply
239:31 - doesn't care but as soon as I add one
239:33 - more into here then I'm going to get a
239:35 - syntax error because it complains that
239:37 - the length is not equal to to the
239:38 - numbers that we
239:39 - have because the list are really Dynamic
239:42 - it doesn't matter how many you put in
239:43 - here because it can just go on forever
239:45 - of course until you run out of memory so
239:47 - let's have a little working example just
239:49 - to see how this
239:51 - works so we can have a for Loop and we
239:53 - can go from 0 to 10 or maybe 0 to 3 just
239:56 - so we don't have to enter as many values
239:58 - we can have a console right that kind of
240:00 - just says enter a number and then let's
240:02 - read that in and we can say in n equals
240:05 - convert to in 32 and we can place a
240:08 - console. readline inside
240:11 - here and then after we've got the
240:13 - console read line we've got an inome
240:15 - that's being converted from the console
240:17 - input inside our integer num and from
240:20 - there we can take our list numbers do
240:22 - add and we can add the num inside there
240:25 - or if you want to reduce a variable you
240:26 - can just take this line and place it
240:28 - straight into here now if you get rid of
240:31 - that when this fall Loop runs will have
240:33 - three iterations let's run the code and
240:35 - find out 1 2 3 so now we've ented three
240:39 - numbers and now they've been stored in
240:41 - the list so let's create a follow loop
240:43 - after and we can go from zero all the
240:45 - way to list numbers do length but of
240:48 - course when we're using list we don't
240:51 - have a length anymore when we're using
240:53 - arrays we have length because arrays
240:56 - have a fixed length whereas lists have a
240:58 - count of the items inside it so instead
241:01 - of length we simply use count and then
241:04 - inside here we could just do what we
241:06 - normally do and say list number numbers
241:08 - square braet I and let's run that and we
241:11 - should see the numbers printed back out
241:13 - in the exact same order 1 2 and 3 and
241:16 - the same principle goes if you use a for
241:18 - each Loop we can say V item inside list
241:20 - numbers and that's all you need to do
241:22 - and you can just print item to the
241:24 - screen now we should see the same output
241:26 - twice let's have a look at other values
241:28 - that we have inside here so we type in
241:30 - list numbers Dot and let's have a look
241:33 - at the functions inside so we can add
241:35 - which you just used above we can convert
241:37 - it to an array we can remove a specific
241:39 - position and we can clear it completely
241:42 - they have other ones in here like binary
241:44 - searches we can check if it contains a
241:46 - certain element this is going to be very
241:47 - handy when we do our
241:49 - remove we can convert them all to a
241:51 - different type we have a copy to we
241:54 - check if a value exists
241:56 - inside we have a find finding all of
241:59 - them the difference between these two is
242:01 - the find will return back the first one
242:04 - whereas find all will retrieve all the
242:05 - elements that match it finding the index
242:08 - of a specific match finding the last
242:10 - index iterating through them all you can
242:13 - insert a specific position whereas the
242:15 - ad will just insert at the end of the
242:17 - list adds an object to the end of the
242:20 - list inserts an element to the list at a
242:23 - specified index and then you have remove
242:26 - which gives you the first occurrence so
242:28 - you can type the number straight into
242:30 - there so you can ask the user what
242:32 - number do you want to delete and if they
242:34 - type zero it will delete the first zero
242:36 - in the list and you can can remove all
242:38 - so if you want to remove every single
242:40 - zero inside the list you can do that as
242:42 - well or you can remove a specific
242:44 - position this is the most used function
242:47 - because what you can
242:48 - do and what you can do is use the find
242:51 - index search for an element that matches
242:53 - a condition and then returns zerob based
242:55 - index the first occurrence so if you
242:58 - want to delete the number zero from the
243:00 - list you could use find index and that
243:02 - returns you back with an INT and then
243:04 - you can use the remove at and then pass
243:07 - that index straight into there you can
243:09 - also sort it so it goes up in number
243:11 - order we did this with the array. sort
243:13 - function as well and if you wanted to
243:15 - you can also reverse the entire list
243:17 - this can be very helpful as we did with
243:19 - the array functions if you just wanted
243:21 - to reverse them all in case someone had
243:23 - something like a filter when you're
243:25 - doing from Price high to low and low to
243:27 - high the difference between them two
243:29 - lists is simply the list flipped so
243:31 - let's run a remove just inside here and
243:33 - let's see what happens so we can say
243:35 - remove that and let's say position zero
243:38 - so we type in 1 2 and three you'll see
243:41 - that 1 2 3 gets printed out and then
243:44 - I'll hit this remove at and it will
243:46 - delete the first index and in this case
243:48 - the first index is going to be our
243:49 - number one so now this has became our
243:52 - first index and this is our second index
243:54 - and it's got rid of the number
243:57 - one so let's move on to a different data
244:00 - structure called dictionaries
244:02 - dictionaries are generic collections
244:03 - that store key value pairs in no
244:05 - particular order they take in a t key
244:08 - key and a t value and these just mean
244:10 - the key and the value can be any data
244:12 - type that you want dictionaries come
244:14 - under the system. collections. generic
244:16 - namespace and if you don't include this
244:18 - line at the top then you'll have to type
244:20 - in system. collections. generic space
244:23 - dictionary every single time you want a
244:25 - specify dictionary putting the name
244:27 - space at the top will include it within
244:29 - the project and you can use dictionaries
244:30 - freely so one thing to know is the keys
244:33 - must be unique and they cannot either be
244:34 - null values can be null or duplicate cuz
244:37 - they're the value values depending on
244:38 - the key as long as the keys aren't the
244:40 - same then the values can be similar so
244:42 - let's have a look and see what we can do
244:44 - we can type in dictionary and you can
244:47 - see it has the arrows either side and
244:49 - you can see here it says T key and T
244:51 - value and what T key and T value is is
244:54 - it gives us the flexibility to add any
244:56 - data types that we want we can add in
244:58 - two strings in here for example or we
245:00 - can do anything that we please so in
245:02 - this example I just want to start a list
245:04 - of names and I want to give them a
245:06 - unique identifier and this unique
245:08 - identifier will just give them a number
245:10 - that their profile is up against it's
245:12 - the same way whenever you make an
245:14 - account with any sort of website when
245:16 - your data gets stored in the database
245:18 - you have a unique ID for your account
245:20 - and this is the same thing that I'm
245:22 - trying to replicate here we have a
245:24 - unique ID and with that unique ID comes
245:26 - a name so we can say equals new
245:29 - dictionary just like we do with the list
245:32 - we can end the brackets and end the
245:34 - semicolon there and now we've created
245:36 - our dictionary and the exact same
245:38 - principle we can use with the list we
245:40 - can simply type in the name of the
245:42 - variable of the dictionary and type in
245:45 - add and then we have access to int key
245:47 - and string value and this parameter is
245:50 - going to change if this now becomes a
245:52 - string as I'll show you
245:54 - now and if we reopen the bracket you'll
245:57 - see this has turned into a string key so
246:00 - that will change depending on the data
246:01 - types that you specified so let's say we
246:03 - want to add one and we want to add
246:06 - ourselves then we can dup at this down
246:09 - and add in two and three and we can say
246:12 - test and test and now if you run the
246:14 - code you'll see that we have no errors
246:16 - and nothing's going to show up I'm just
246:18 - demonstrate that it compiles okay and
246:20 - the same thing with the list we can also
246:23 - simplifies the initialization process
246:25 - and it looks something like this so
246:28 - because this is a key value pair we can
246:30 - no longer just type it in one line they
246:32 - need to be in a little block so when we
246:34 - wrap these around the curly brace we can
246:36 - have the key on the left left and the
246:38 - value on the right and one of these is
246:40 - called a key value pair key value pair
246:45 - and we will use these in the for each
246:46 - Loop in a second when we print out all
246:48 - the values to the console so let me just
246:50 - demonstrate something about what I said
246:52 - at the start I said that all keys must
246:54 - be unique and there's a reason why I
246:56 - said that if we duplicate the first
246:58 - entry therefore giving us the same key
247:01 - as one and we try run it and let's see
247:03 - what happens we get something called a
247:05 - runtime error this runtime error happens
247:08 - when we run the program and it's got
247:10 - nothing to do with compile time or our
247:12 - logic an item with the same key has
247:14 - already been added so we need to watch
247:16 - out if we do this because our program is
247:18 - going to compile but it's not going to
247:19 - work at runtime and let me demonstrate
247:21 - another fact if we make this number four
247:24 - and our values are exactly the same once
247:26 - we run this it will still work fine
247:29 - values can be the same but the keys
247:31 - cannot be the same the keys have to be
247:33 - unique so just like with our lists and
247:35 - our arrays we can use a for each or for
247:38 - Loop to access this directly so we can
247:40 - say 4 in I equal 0 and we want to go
247:43 - names. count and the same reason it to
247:46 - do count for a dictionary as it is for a
247:48 - list but it's not for an array
247:50 - dictionaries don't have fixed length and
247:52 - neither do lists they are very Dynamic
247:54 - and basically are a list list can only
247:57 - store one different data type whereas
247:59 - dictionaries give you a key and a value
248:01 - so as we said above we have a key value
248:03 - pair so let's try and print this and see
248:05 - what happens have a console right line
248:07 - we can say names square bracket I and
248:10 - that will give us back the position the
248:12 - issue with this is it will just give us
248:13 - back the string and let's just see what
248:15 - happens if we print
248:17 - this then we get an exception because no
248:20 - key was given and the problem with this
248:22 - situation is we can't use this like a
248:24 - list Geto sets the value associated with
248:27 - a specified key what this means is when
248:29 - we give our square bracket I inside here
248:32 - this is actually not talking about the
248:33 - index this is actually trying to do a
248:35 - search on these keys
248:38 - so if you actually change this to one
248:40 - then we should get ABA return back this
248:42 - is not actually doing an index Lo up
248:44 - it's doing a key lookup and the reason
248:47 - for that is what we're going to have to
248:48 - do instead is say names do element at
248:51 - and then what we can do inside there is
248:53 - place our index so this element art will
248:56 - return us back with the key value pair
248:58 - as I said above here so how this
249:01 - variable works is we can do key value
249:03 - pair and then we need to specify this
249:05 - variable the same way we've got it up
249:07 - here so we have an INT inside a string
249:10 - and then we can say a pair and make that
249:12 - equal to the function called element at
249:15 - as that returns us back with a key value
249:17 - pair in string and of course if you
249:20 - wanted to make this a lot smaller you
249:21 - could just simply use VAR but let's keep
249:23 - it as key value pair just so you can
249:25 - understand what's going on and the
249:27 - reason why we need to get the key value
249:28 - pair is if we want to retrieve the
249:30 - integer and we want to retrieve the
249:32 - string and now we can use pair. key and
249:35 - pair. value and because these are both
249:38 - integer and this one is a string it
249:40 - matches our pair exactly so we can take
249:43 - these values and go to our console right
249:45 - line and we can say something like this
249:47 - use string nipulation and say pair. key
249:49 - and then maybe add a hyphen and then say
249:52 - pair do value and then just remove these
249:54 - two lines and let's try and run it now
249:58 - there we go so we get all the values and
249:59 - it doesn't matter what this key is it
250:01 - can be something random it doesn't
250:03 - really make a difference like I said
250:05 - this doesn't have to be in a specific
250:07 - order
250:08 - so let's keep it as 1 2 3 there we go so
250:11 - you can see using a for each Loop to
250:12 - print this is a little bit more
250:14 - complicated let's have a look and see
250:16 - what it takes when you use a for each
250:18 - Loop for each VAR item inside our
250:23 - names and as you can see here our item
250:25 - is automatically a key value pair of int
250:28 - and string and again what you can do is
250:31 - type this straight into here just so you
250:33 - can get used to the notation and there
250:35 - you go it's still a key value pair and
250:38 - then now what we can do is we can take
250:40 - this exact line and paste into here and
250:42 - instead of pair we have item and this
250:45 - should return us back the exact same
250:47 - values and if we just separate with a
250:48 - console right line there we go okay so
250:51 - now that we've understood this let's
250:53 - take a look at an example let's comment
250:55 - this out and let's create another
250:57 - dictionary so we can say dictionary and
250:59 - then we can have a string of
251:01 - string and we can call this teachers
251:04 - equals new dictionary string of string
251:06 - again and we can add our curly brace
251:08 - just so we can add our Valu straight to
251:10 - here so as you said before we need to
251:11 - open curly brace and close curly brace
251:14 - and then we can say the math teacher is
251:15 - called abber and then we can add another
251:18 - one and we say the science teacher is
251:21 - called test there we go so we've
251:22 - initialized our teachers and we said
251:24 - that the value that we want to give it
251:26 - is a unique identifier which is going to
251:28 - be our string assigned to the subject
251:31 - and this is going to be the teacher that
251:32 - is assigned to this subject so what we
251:34 - can do inside here is we can have a
251:36 - console right line and we can do
251:38 - something like this so remember when I
251:40 - was saying in the for Loop we can't
251:41 - actually use the square bracket notation
251:43 - like this because this is inferring to a
251:45 - key rather than a position so we had to
251:48 - use element at just to find out the key
251:50 - value pair and then to print out to the
251:52 - console so because the square brackets
251:54 - is an actual sech let's try and make use
251:57 - of that now so we know that there's a
251:58 - math class available so we can type math
252:00 - in here and what does should return us
252:02 - back is abber there we go so what that's
252:04 - doing is it's searching through our
252:06 - dictionary find ing this element inside
252:08 - here and then return us back with the
252:10 - value for that key get all sets the
252:13 - value associated with the specified key
252:15 - the problem with using this approach is
252:17 - it says here if the specified key is not
252:19 - found a operation throws a key not found
252:22 - exception let's just say for instance I
252:23 - mistyped the math and now we're just
252:25 - going to get a runtime error and it's
252:27 - going to be a horrible exception and our
252:29 - code is obviously going to break this is
252:31 - similar to what we do when we have int.
252:33 - trass we don't just trass it immediately
252:36 - and convert it it without actually
252:38 - checking if it's a valid value so
252:40 - instead of doing this line what we can
252:42 - do is we can check if that key exists
252:45 - first before we then use it so we can
252:48 - say if
252:49 - teachers do try and get the value which
252:52 - is a similar to what we have with trass
252:55 - and then the first parameter is the key
252:57 - that we want which is going to be our
252:59 - math and then out here is going to be
253:02 - the variable that we want to Output out
253:04 - so we can say out
253:06 - teacher and then open the curly braces
253:09 - and then inside here we can print out
253:11 - the teacher so we try to get the value
253:13 - for Math and if we found that key inside
253:15 - these then we return back the value
253:17 - inside our teacher the same way works
253:20 - for our
253:24 - tripassure if it successfully passed it
253:27 - and if it hasn't we can say cons output
253:30 - math teacher not found so let's try and
253:34 - run that now you see we get return back
253:36 - abber and if if you actually drop the
253:37 - lower case then it says the math teacher
253:40 - is not
253:41 - found alternatively what we can do
253:43 - inside here let's assume that this is
253:45 - correct we can take this value and place
253:48 - it straight inside the square brackets
253:50 - and do this again this is kind of
253:52 - redundant because we've told it to get
253:54 - the value for key place inside teacher
253:56 - and then we're just going back to the
253:57 - dictionary to get the value twice so
254:00 - make sure if you have an output variable
254:02 - that you actually use it inside here you
254:03 - can see that you're not using it when it
254:05 - goes a slightly dark color like this so
254:07 - just like in the last examples when we
254:09 - were placing values inside our list we
254:11 - can also do that in dictionaries we can
254:14 - say teachers square bracket math and
254:16 - then we can make that equal to something
254:18 - so if the math teacher were to change
254:20 - and now the teacher's called Joel then
254:22 - we can run this line and print out to
254:24 - the screen let's just take that for each
254:25 - Loop and tailor it to the new dictionary
254:28 - and see what happens when we run it so
254:30 - let's just change this into our V to
254:31 - make it simple and then we can have
254:33 - teachers inside here there we go so now
254:35 - let's just run this and see it now it
254:37 - says abber is the first value the abber
254:40 - is coming from console right line here
254:42 - that says teacher this is one line
254:44 - before we change it and we change the
254:46 - value of the math teacher to jaw on the
254:49 - next line and there we go it's committed
254:51 - the change and just like in the last
254:53 - video as well when we try to delete
254:54 - something from the list let's see what
254:56 - we can do to delete it from here so we
254:58 - can have teachers do remove and you can
255:00 - see that it says key in there and again
255:03 - if we add the key in like this then it's
255:04 - going to work just fine there go we just
255:07 - have science we don't have math anymore
255:09 - but if I drop the lowercase then it's
255:11 - going to cause us back with an error but
255:13 - in this case instead of it thrown an
255:14 - exception like it did when we were
255:16 - trying to do up here and up here as well
255:19 - the problem with using the remove is you
255:21 - just simply won't remove it but what it
255:23 - will do is it'll give you back a
255:25 - building if you remember from the last
255:27 - video we actually had a look at a
255:29 - section where in the list it gave you
255:31 - back a booing whether the remove
255:32 - function worked or not alternatively
255:34 - what you could do instead of using the
255:36 - remove function is to check if the item
255:39 - exists in the first place we can say
255:41 - contains key and we can place math
255:43 - inside here and if it does contain it
255:45 - then we can run the same line of code
255:47 - and we can say remove and then use math
255:50 - just to make sure that this is has been
255:52 - actually removed and then in the else we
255:54 - can say math not found retrieving values
255:58 - back should be retrieved using try get
256:00 - just so you don't cause an exception if
256:02 - this is not found we can simply do an
256:04 - update by placing the value of the key
256:06 - inside this square brackets and then
256:08 - simply just assigning it to something
256:10 - else this assignment will change the
256:12 - value of the key which is inside the
256:14 - teacher dictionary and if you wanted to
256:17 - remove something it's best to use the
256:18 - contains key just to check if it
256:20 - contains it first and then you can do
256:22 - the remove and then if it doesn't
256:23 - contain it you can tell the user that
256:25 - math has not been found and then finally
256:28 - we can just print it out like
256:30 - this so in this exercise I want you to
256:33 - create two lists with the integer data
256:35 - type one for even and one for odd and
256:37 - then we're going to Loop through from
256:38 - zero all the way till 20 and if the
256:40 - number is even add it to the even and if
256:43 - the number is odd add it to the odd list
256:45 - and at the end print out all the values
256:47 - for even and for odd I know you can just
256:49 - print these out inside the for Loop we
256:51 - don't have to have dedicated lists but
256:53 - this is just for list practice and I
256:55 - want to talk about different ways that
256:56 - we can do this solution so let's start
256:58 - we can have a list of int and we can say
257:01 - odd new list int and we don't know the
257:05 - size so we're just going to leave the
257:06 - gap empty and if we duplicate this down
257:09 - we can simply just change this to even
257:11 - now the reason why we're doing lists
257:13 - we're going from 0 to 20 of course this
257:15 - 20 value could be anything it could be a
257:17 - million it could be 100 but we don't
257:19 - know and the point is lists have counts
257:23 - whereas arrays have length if we set the
257:25 - array length to something like a
257:26 - thousand we know probably be able to
257:28 - contain all the numbers inside there but
257:30 - that's going to be a lot of positions
257:31 - that we don't exactly need because
257:33 - arrays are not really dynamic because
257:35 - they're static then it's it's best to
257:37 - use list in this case because we don't
257:39 - know how many numbers are going to be
257:40 - odd or are going to be even between this
257:43 - range if we knew the exact number of
257:45 - positions that we needed in a given
257:47 - solution then array would be better
257:49 - since you don't want it to be dynamic if
257:51 - it doesn't need to be so let's start you
257:53 - can have a for Loop that goes from 0o to
257:55 - 20 if you want to include the 20 as well
257:58 - we can just place an equals the best way
258:00 - to determine if a number is odd or even
258:02 - is to use the modulus operator so we can
258:04 - say I percentage 2al equal 0 and what
258:07 - this will do is it'll tell us if I is
258:09 - divisible by two if the value is equal
258:11 - to zero if you have two modulus 2 then
258:15 - the remainder is going to be zero if you
258:17 - have three modulus 2 it's going to be 1
258:20 - * by 2 which gets you to two and then to
258:23 - go from two to three you actually have
258:25 - one so if you insert an odd number and
258:28 - do a modulus 2 you're going to get a one
258:31 - returned if you do an odd number and you
258:33 - do modulus 2 then you're going to get
258:34 - one returned if you do an even number
258:36 - modulus 2 then you're going to get zero
258:39 - returned so what we can do in here is we
258:41 - can say even do add and then we can
258:43 - simply add I and then in the else we can
258:46 - also simply just do odd do add and then
258:49 - have I because the values of the
258:51 - remainder can only be Zer or one we
258:53 - don't need to have an lse if in here
258:55 - doing this is a little bit redundant
258:57 - although it's still technically correct
258:59 - the values can only either be zero or
259:01 - one so if you run this calculation and
259:03 - the value is zero if you run this
259:05 - calculation and the value zero the only
259:07 - other value can possibly be is one so
259:10 - therefore we don't need additional
259:11 - condition so therefore we don't need
259:13 - this additional condition and we can
259:14 - simply get rid of it if I modulus 2 is
259:17 - equal to0 then we add the number to even
259:20 - and else we add it to odd normally when
259:22 - you have situations like this we can use
259:25 - the conditional operator where we have
259:26 - the question mark followed by the colon
259:29 - but in this case we're actually doing
259:30 - two different assignments we're either
259:32 - assigning into the even or assigning
259:34 - into the odd so there's no room for the
259:36 - conditional operator so at this point we
259:38 - should have all the even and odd values
259:40 - from zero all the way to 20 inside our
259:43 - two lists so then we can now just print
259:45 - both the list out so we can say printing
259:49 - even numbers and then we can have a for
259:51 - each Loop that goes v item inside our
259:53 - even and then we can do a console Right
259:56 - add some inst string interpolation and
259:58 - then we can say item followed by space
260:01 - then we can print environment. new line
260:03 - just to give it some space and we can
260:05 - say printing odd numbers
260:07 - here we go and then we can just take
260:08 - this exact for Loop and copy it down
260:11 - instead of saying in even we want to do
260:13 - in odd and this exactly the same since
260:15 - the variable name is exactly the same
260:17 - let's try run the
260:19 - code there we go it's got zero all the
260:22 - way till 20 and you can see it goes up
260:24 - in twos hence all even numbers and we
260:26 - also get these going up in twos except
260:28 - it starts from one and this covers all
260:30 - of the odd numbers and if we change this
260:32 - number up to something like 50 then the
260:34 - list will just grow and they Cod just
260:35 - still work okay you can see that all of
260:38 - these numbers are still consistently
260:39 - even so now that our task is actually
260:41 - complete let's just have a little recap
260:43 - so the reason why we're using lists and
260:45 - we're not using arrays is for this exact
260:47 - nature if we have 0 to 10 then we can
260:51 - almost work out how many even numbers
260:53 - and how many odd numbers we can have we
260:55 - can manually count we have zero and then
260:58 - 2 4 6 8 and 10 and then for odd we have
261:01 - 1 3 5 7 and 9 so we know how many
261:05 - numbers exist within here but what if we
261:08 - just change that number to 50 then now
261:10 - we have a lot more odd and a lot more
261:12 - even it's impractical to type these
261:14 - numbers in and then to Simply count them
261:16 - in your head and then make an array
261:18 - length based on that position that's a
261:19 - bad solution because not all cases
261:22 - you're going to have the flexibility of
261:24 - Simply typing in the numbers like this
261:25 - and Counting them yourself these numbers
261:27 - could be something that typed in by a
261:29 - user or something loaded for something
261:31 - external like a text file you need to
261:33 - understand that these values can be
261:35 - generated from anywhere and if you just
261:37 - type them in then it provides an
261:38 - unrealistic expectation of how to write
261:40 - some programs so what you have to bear
261:42 - in mind in situations like this is you
261:45 - simply don't know how many even and how
261:47 - many odd numbers will be appearing
261:49 - during this range so you want to use a
261:51 - list so it as dynamic as possible we
261:53 - have two lists in this case one to store
261:56 - all the odd numbers and one to St all
261:57 - the even numbers we don't initialize
261:59 - them with any sort of capacity we just
262:01 - keep it empty for the exact reason we
262:03 - don't use an array we Loop through from
262:05 - zero to anything we don't even have to
262:07 - Lo from zero we can also just start this
262:09 - at 100 and go all the way to th000 it
262:12 - really doesn't matter what our number
262:14 - ranges the only thing that matters is
262:16 - that we have a list that is going to be
262:18 - dynamic and then we can calculate
262:20 - whether the number is odd or even and
262:23 - add it to the right list how this works
262:25 - is we use I which is the number we're
262:27 - currently up to and we calculate the
262:29 - modulus of it to check the remainder if
262:31 - the remainder is zero then it must be
262:33 - even as it's divisible by two and if
262:35 - it's anything else than Z zero which you
262:36 - can only ever be one in this case when
262:38 - using modulus 2 then we add it to the
262:41 - odd list after this followup has run now
262:43 - our odd and even lists have all the
262:45 - values that they should have and we
262:47 - simply just write these two blocks are
262:49 - exactly the same just print the even
262:51 - numbers and print them out print the odd
262:53 - numbers and simply print them out to the
262:55 - screen and that's it and if you run the
262:57 - code it might get a little bit crazy in
262:58 - here but as you can see these will
263:00 - actually work if you pick any random
263:02 - numbers you can see that they're all
263:04 - divisible by two and this same thing
263:06 - goes for odd you can see that they're
263:08 - not divisible to cuz they're all
263:11 - odd so in this exercise we're going to
263:14 - cover a little task I like this call
263:15 - this task an array of multiples so we
263:17 - want to Define initialize two integers
263:20 - and num into length so in the case of
263:22 - this example we have a number seven and
263:24 - the length of five so what this will do
263:26 - is it will essentially give you the
263:28 - seven times table but only the first
263:30 - five numbers 7 14 21 28 and 35 we take
263:35 - the first number which is Nome which
263:37 - will give us the multiples and we take
263:39 - the second number which is the length
263:41 - and that gives us the size of the array
263:43 - so we create the integer array with the
263:44 - size of length Loop through the array
263:46 - and insert the loop count Times by
263:49 - because this is 1 * 7 2 * 7 and so on so
263:52 - forth until we reach the length and we
263:54 - place into the array and then finally we
263:56 - paint the array just to give us these
263:58 - values out to the console all right so
263:59 - let's get started we can have it into
264:01 - norm and make it equal to seven and we
264:04 - have it into length and make that one
264:06 - equal to 5 now the defined initializer
264:08 - two integers let's create the int array
264:10 - with the size length int array result
264:13 - equals new int and we want size length
264:16 - after that we want to create our for
264:17 - Loop now this is the tricky part if we
264:19 - try go from zero all the way to result.
264:22 - length then let's see what happens so we
264:25 - want to start result I you want to make
264:27 - that equal to number which is our array
264:29 - of multiples Times by the value that
264:31 - we're currently up to now let's print
264:33 - our array using for each Loop to see the
264:35 - value so we can say a v item inside our
264:38 - result then we can have a console right
264:40 - that just prints one of them at a time
264:42 - so we can say item followed by spits now
264:45 - let's see what happens when we run
264:47 - it so we get 0 14 21 and 28 and as you
264:51 - can see these are the first four numbers
264:53 - so we're close what we're nearly there
264:56 - because our array starts at zero and it
264:58 - goes to the length which in this case is
265:00 - going to be 0o to less than five which
265:03 - will cover the positions of 0 to four
265:07 - with these positions it's going to do 0
265:09 - * 7 1 * 7 and then get to 4 * 7 and not
265:13 - actually get to the fifth because we're
265:15 - starting from zero so alternatively what
265:18 - we can do or what you think you can do
265:20 - is change it to a one and changes to
265:22 - equal to so now what it's doing is it's
265:25 - going from one all the way to five which
265:27 - is still covering the same amount of
265:29 - positions it's just one index forward so
265:31 - now if we try to run the code then we
265:33 - get a runtime exception and the reason
265:35 - for for that is it's trying to access
265:37 - position number five if we hover over I
265:40 - we have five and if we hover over the
265:43 - result we actually have some of the
265:45 - right values except it's trying to get
265:47 - to the fifth position and it's not
265:49 - working the reason why the zero index is
265:51 - actually zero is simply because that's
265:54 - the same value as the default value
265:56 - because our for Loop started at in I
265:58 - it's actually only starting from here
265:59 - and going down so this calculation is
266:01 - actually correct but it needs to be back
266:03 - one we need to start the multiplication
266:06 - on IAL 0 but our for Loop needs to start
266:09 - on IAL 1 so we can get all the way
266:12 - through so we have two ways of doing
266:15 - this we could say IUS one so even though
266:18 - it goes from 1 to 5 it's still assigning
266:20 - into the array using 0 to 4 so if we run
266:23 - that we can see that that will give us
266:25 - the desired result alternatively what we
266:27 - can actually do instead of doing IUS one
266:30 - inside here we can define a variable
266:32 - called counter and make it equal to zero
266:35 - we can change this this to counter and
266:37 - we don't need to change the
266:38 - multiplication because that's already
266:39 - going from one to the length which is 1
266:41 - to 5 in this case after the follow is
266:44 - run we need to remember to increment
266:46 - counter so there we go we have the
266:48 - desired effect another hack if you're
266:50 - interested if you have two variables
266:52 - that you want to increment inside a for
266:54 - Loop you can see that we already have I
266:56 - ++ in here which will increment it by
266:58 - one and we want to increment counter by
267:00 - one as well every single time it loops
267:03 - around what you can actually do is
267:05 - remove this and you know how these are
267:07 - broken up by semicolons that indicates
267:09 - that the section has ended the first
267:11 - section is for declaration the second is
267:13 - for the range and the third is so you
267:15 - can increment the variable or decrement
267:17 - it when you trying to increment two
267:18 - variables inside a for Loop instead of
267:20 - placing a semicolon here and type in the
267:23 - next one you can actually place a comma
267:25 - and do counter Plus+ what that will tell
267:27 - the for Loop is every single time you go
267:30 - through you want to do a series of these
267:32 - actions and because we have i++ and
267:34 - counter Plus+ then that's going to work
267:37 - exactly the same way it just prevents us
267:39 - having counter Plus+ down here and we
267:41 - can move it inside the for Loop just so
267:43 - it doesn't for us and it looks a lot
267:45 - cleaner cuz you can clearly see that
267:47 - every single time we loop around this
267:49 - for loop we're going to increment these
267:50 - two variables there we go so let's try
267:54 - to put some different values in here
267:55 - maybe make this 10 and we can have 10 on
267:57 - both which should give us the first 10
267:59 - numbers there we go from 10 all the way
268:01 - to 100 let's have a little recap so
268:04 - we're essentially just making an array
268:06 - that will give us back all the multiples
268:07 - so it's like a mini times table but the
268:10 - fact that we're doing it dynamically
268:11 - using our array is quite important what
268:14 - you can do if you wanted to is to extend
268:16 - this program you can ask the user to
268:18 - type these into the console and then
268:19 - convert them and use them right now
268:22 - we're just statically typing them in and
268:23 - that's not really an issue since the
268:25 - main focus was doing this for Loop if
268:27 - you wanted to you could ask the user and
268:29 - you can type these values in so you
268:31 - don't have to change them every single
268:32 - time you compile so now we've got the
268:34 - number and the length let's make our
268:35 - inter the rare call result and
268:36 - initialize it to the length we set up
268:39 - this counter so we simply didn't have to
268:40 - do I minus one here so it looks a little
268:43 - bit more intuitive we start the follow
268:45 - from one and go to the length so we can
268:48 - access 1 to five and the reason why we
268:50 - want to do 1 to five so when we do our
268:52 - multiplication it doesn't start at zero
268:55 - these two are going through the exact
268:56 - same amount of indexes 1 to five is five
268:59 - numbers and 0 to four is also five
269:01 - numbers so when we do our multiplication
269:03 - we want to start from one since the
269:05 - timetable normally starts at one and we
269:06 - go to the length the reason why we're
269:08 - using the counter is so we don't have to
269:10 - do IUS one in here and it breaks up the
269:12 - logic a little bit and it looks nicer
269:14 - with our counter we start our counter at
269:16 - zero and instead of incrementing down
269:18 - here we use this fancy comma and we can
269:21 - say we want to increment I and counter
269:23 - every time the for Loop goes around so
269:25 - we don't need to include the counter
269:26 - increment inside the for Loop and this
269:28 - one line is pretty simple we say result
269:31 - the index of counter which will start at
269:33 - zero which is the start of the array
269:35 - since it's zero base and we say that's
269:37 - equal to the number and the number is
269:38 - going to be a fixed number since this is
269:40 - the multiple and we say number times by
269:43 - I and in this case it goes from one all
269:45 - the way to the lth so we get essentially
269:47 - the times table and at the end we just
269:49 - use a simple for each Loop that will go
269:51 - through all the items inside the result
269:53 - array and just print them out to the
269:54 - screen with a comma after each other
269:56 - using console. WR just so they're all on
269:58 - one line this is the start of the
270:01 - function section functions can also be
270:03 - called method they are used
270:05 - interchangeable
270:06 - in the introduction we discussed dry
270:08 - which means don't repeat yourself and
270:10 - the whole point of dry is so you don't
270:12 - have multiple sections of code that do
270:14 - basically the same thing you want to
270:16 - wrap it around in a function functions
270:18 - are used to improve the readability of
270:20 - your code and the reusability of the
270:22 - code as well having multiple section
270:25 - code that are basically exactly the same
270:27 - can be more prone to errors if you wrap
270:29 - them round and place in One Singular
270:31 - function you can make sure that the
270:33 - error prone and then wherever you use it
270:35 - it will be error prone as well if you
270:37 - have to copy and paste and tweak some
270:39 - code then you're actually exaggerating
270:41 - the amount of errors that could occur
270:43 - and plus it makes your code look a lot
270:45 - cleaner and the structure a lot better
270:47 - since you can name the functions so
270:48 - let's take a little example we have a
270:51 - static void main straight into here this
270:54 - is a function or a method and these are
270:56 - the parameters for the function The NET
270:59 - Framework expects every C program to
271:02 - have a main function with a capital m
271:04 - and it needs to be a static and avoid
271:07 - the parameters don't exactly matter we
271:08 - can also remove them and it won't be a
271:10 - problem the only thing that matters is
271:12 - this needs to be called main if we drop
271:15 - the lowercase on it and try and run the
271:17 - code then we're going to get a build
271:19 - error program does not contain a static
271:22 - main method suitable for an entry point
271:25 - so if you change this back to M and run
271:26 - it again and then it works fine so
271:29 - that's one thing to note about The NET
271:31 - Framework is you need to include the
271:33 - main function otherwise the program
271:35 - won't run and it won't even compile so
271:37 - let's take a look at how we can use this
271:40 - we can have something like a console
271:41 - right line and we can say welcome to my
271:44 - program this is a line that we're
271:46 - probably only going to use once but
271:48 - let's say this is welcome in someone's
271:49 - name welcome AB let's say you had this
271:52 - in your software in many different
271:53 - places you don't want to be recalling
271:55 - this or retyping out this message in
271:58 - case you type it wrong the fifth time
271:59 - and you get a error of course this won't
272:01 - be a syntax or a runtime error it'll
272:04 - just simply be a logic eror because it's
272:06 - a typo so in order to make sure this
272:08 - typo never occurs we can actually make
272:10 - another function so outside of these
272:12 - curly braces and just still within the
272:14 - class we want to create a new function
272:16 - so we want to follow this exact same
272:18 - approach we can say static then viid and
272:22 - we can call it welcome message and we
272:24 - don't need to give it any parameters cuz
272:25 - we're not really going to give it any
272:27 - values just for now now that we've made
272:29 - that we have no syntax errors and we can
272:31 - run it like this except of course
272:33 - there's no body so let's place our
272:34 - console right line within here now if
272:36 - you run the codee nothing is going to
272:38 - happen and the reason for that is the
272:40 - code will still execute in the main we
272:43 - haven't called this function inside the
272:45 - main we've defined it and called it
272:47 - welcome message and we've gave it the
272:49 - contents but we haven't actually made
272:50 - use of it and you can see that when it's
272:52 - highlighted in a darker color that means
272:55 - it's not being used as it says here
272:57 - private member welcome message is on use
273:00 - so now we can simply type in here
273:02 - welcome message followed by an Open
273:04 - Bracket and then a close bracket to
273:06 - denote the parameters that we're going
273:07 - to give it and of course in this case
273:09 - there is no parameters and then we close
273:11 - the brackets and add a semicolon now if
273:13 - you run the code you can see it says
273:15 - welcome abber so just to go over some of
273:17 - these words that we're using static
273:19 - means that we can access it anywhere and
273:22 - everywhere what I mean by that is we
273:24 - don't have the keyword new just before
273:27 - this we don't need to make a new
273:28 - instance of the program class in order
273:31 - to access this so what that means is
273:33 - when we make future programs we're going
273:35 - to have some functions inside our class
273:37 - inside the class you can actually denote
273:40 - if a function is going to be static or
273:42 - it's not going to be static you don't
273:44 - have to specify is it static but this
273:46 - won't let you call it from here because
273:48 - it's unaware where this function is
273:49 - coming from an object reference is
273:51 - required for the non-static field method
273:53 - or property because this is static you
273:56 - need to reference something else from a
273:58 - static nature all static means is you
274:00 - don't have to create a new instance of
274:02 - this thing in order to use it we'll see
274:04 - different examples in the future where
274:06 - you have to create an instance in order
274:08 - to use something so let me just show you
274:10 - quickly if we have a test and I say
274:12 - static void
274:15 - something and we can just print out
274:17 - nothing to the screen and let's try and
274:19 - use this so because this class is
274:21 - outside of the program we have to use
274:24 - the notation test Dot and then it should
274:28 - be available within here and the reason
274:30 - why it's not is because you need to
274:31 - insert this public word just before it
274:33 - and public means everything has access
274:35 - access to it and static means you don't
274:37 - need to create an instance now if I type
274:39 - in the dot again you can see we can now
274:40 - see
274:42 - something and the reason why we can see
274:44 - something is because this is a static
274:46 - now if I remove the static word then you
274:48 - see that we'll get a compile error
274:50 - because it doesn't know where this is
274:52 - now if you don't use static you need to
274:54 - do this you need to say test test equals
274:57 - new test so you make it instance of the
275:00 - class and then inside test then we get
275:02 - the something so that's the difference
275:04 - between static and not static
275:08 - essentially it's accessible from
275:09 - everywhere but if you don't want to be
275:11 - accessible from everywhere then you can
275:13 - just simply remove the static word and
275:15 - the user will have to create a new
275:17 - instance before they can use it so this
275:19 - is what it's like without
275:21 - static and this is what it's like with
275:23 - sty don't worry if you don't understand
275:26 - this too much this was just a quick
275:27 - overview but I have a dedicated video
275:29 - later on in the course so don't worry
275:31 - too much about it so now that we've made
275:33 - a function and we've called it
275:34 - successfully in the main and it's
275:36 - printed out to the
275:39 - console so when we're declaring
275:41 - functions we want to specify what return
275:43 - type we're going to have we have a
275:45 - static void Main in here if you hover
275:47 - over main it says void which means at
275:49 - the end of this function it doesn't
275:51 - return anything hence it's void if you
275:53 - have a look at something like an inter.
275:55 - trass and we open the brackets you can
275:57 - see that it takes in a string and it
275:59 - takes in an integer out parameter it
276:02 - also returns us back with the booing so
276:04 - we can have something like 1 2 3 out in
276:07 - result and then it doesn't actually
276:08 - complain about anything but what we can
276:10 - do is also just store this into to a bu
276:13 - success and then print it out to the
276:17 - screen there we go so it says it was
276:19 - successfully true if we remove this or
276:22 - whether we keep it in or not trip pass
276:24 - function doesn't actually complain but
276:26 - the main point here is it defines back a
276:28 - bu that means at the end of this
276:30 - function it will always return you back
276:32 - with a bull and it's up to you if you
276:33 - want to make use of it and you can
276:35 - alternatively you can place this
276:37 - straight inside the console right line
276:39 - and get the value printed straight to
276:41 - the screen or you could wrap this around
276:43 - inside an if statement like we've done
276:44 - in the past Etc and make use of it that
276:47 - way and have the result being printed
276:48 - out inside here the point is you have
276:50 - functions that return something and
276:52 - functions that don't if you remember
276:54 - that we had the array. copy for example
276:57 - you'll see that they have void here
276:59 - because they just apply a function to
277:01 - something but they don't actually give
277:02 - you something back this is the
277:04 - difference of having something like this
277:06 - a string test that says hello and then
277:09 - you can do test. replace and then you
277:12 - can return you back with the string and
277:14 - it says here it returns a new string
277:16 - whereas when we had a string builder for
277:19 - example and we did string builder.
277:22 - replace you can see that alloy does say
277:24 - it replaces a new string Builder you can
277:27 - type anything inside here and it will
277:29 - still affect the current string Builder
277:31 - it won't have to do SB equals s SP
277:33 - replace as you would need to do here
277:35 - because this returns you back with a new
277:37 - string and if you wanted to replace test
277:39 - you would literally have to say test
277:41 - equals test. replace with something like
277:44 - a string Builder all the array functions
277:47 - you don't actually have to do any of
277:49 - that so you can say array. empty and
277:51 - it'll just return the empty array and
277:53 - the ones that we used before are things
277:54 - like equals and that will give you back
277:56 - a Bool because that's determining
277:58 - whether it's equal or not but if you're
278:00 - doing functions like sort for example
278:03 - and doing things like reverse it just
278:05 - simply applies the data but it doesn't
278:07 - return you back with anything so you can
278:09 - literally just call it inside here put
278:11 - your array in the brackets and it'll use
278:13 - it happily now depending on your user
278:15 - case you need to define whether or not
278:17 - you need to use a return type or not for
278:21 - now let's just cover void which means it
278:23 - won't do anything so let's just Define a
278:25 - function static void create and print an
278:28 - array open the brackets close the
278:30 - brackets and we can have it int numbers
278:33 - make it equal to new int with a l three
278:35 - and let's just have 0 1 and two inside
278:38 - here as the initializer let's just do a
278:41 - for each VAR item inside numbers and
278:44 - then just do a console right string
278:46 - interpolation and just have item Follow
278:49 - by space and now that it's dark gray
278:51 - because we haven't called the function
278:53 - so let's make use of it at the top of
278:54 - our code and let's run it now you can
278:57 - see we get 012 printed to the screen and
278:59 - if we make this into a five and simply
279:02 - just add more values in here and then we
279:04 - run the code you'll see that now it all
279:06 - update but because this doesn't return
279:07 - us back on anything and we don't
279:09 - actually use the integer array outside
279:11 - of these curly braces it's not actually
279:13 - available up here numbers won't be
279:15 - accessible inside here because it's
279:17 - simply not within the scope numbers is
279:21 - only available within this curly brace
279:23 - and this curly brace which means when
279:25 - this function finishes numbers has now
279:27 - been deleted from memory so you can't
279:29 - access it after this line void doesn't
279:31 - do anything it simply just does the
279:34 - contents of the function and as soon as
279:36 - it reaches the bottom that's all that
279:37 - happens you can have another function
279:39 - defined that can return a value like I
279:42 - said with in. trass for example at the
279:44 - end of the function you'll see a word
279:46 - that says something like this it will
279:48 - have return and then return back
279:50 - something followed by a semicolon and
279:52 - that will dictate that as soon as that
279:54 - function is done it's going to give you
279:56 - something back now we're going to cover
279:58 - that in the next video but for now we're
280:00 - only going to cover void functions so we
280:02 - can have something more obvious like a
280:04 - static void welcome
280:05 - message and simply just do a console
280:08 - right line welcome to my program and we
280:11 - don't need to return anything here
280:12 - because all this function will do is
280:14 - simply print out a welcome to the screen
280:17 - and we can use that just before the
280:18 - print array so we can say welcome
280:20 - message Open Bracket close bracket and
280:23 - then a semicolon and hit F5 to run and
280:26 - there we go as you can see our main is
280:28 - really tidy now it gives us function
280:30 - names that tells us exactly what's going
280:32 - on we're creating and printing an array
280:34 - and then then welcoming the user to the
280:36 - console and then having a console read
280:37 - line at the end there isn't an awful lot
280:40 - of void functions all you need to know
280:42 - is that when you create a function you
280:43 - need to give it a return type it returns
280:45 - back a certain data type or it simply
280:47 - just doesn't and depending on what you
280:49 - want to do and what you want to achieve
280:51 - with that function really depends on if
280:53 - you want to return a data type or not in
280:55 - the case of these since they're just
280:57 - doing something and then moving on you
280:59 - don't actually need to return anything
281:00 - by it with in. tripath you want to make
281:02 - the function is executed successfully so
281:05 - when you use in. tripos you can see that
281:07 - returns back a bull and the bull
281:09 - determines whether the conversion has
281:11 - been successful and based on that return
281:13 - value you can determine the next steps
281:15 - of your program if all your function
281:16 - needs to do is provide some sort of
281:18 - functionality and then quit then that's
281:21 - fine and avoid is fine but if you need
281:23 - to provide some functionality and then
281:25 - also return a value then you'll need to
281:27 - specify the data type in here which
281:29 - we'll cover in the next
281:32 - video so far we've covered a void
281:35 - functions but we haven't covered return
281:37 - types void functions are where the
281:38 - function just does something but doesn't
281:40 - actually return anything hence the name
281:42 - void let's start with an example if you
281:45 - have a static void print
281:48 - introduction might want to just return
281:50 - back your name after you've printed this
281:52 - line it's going to print it to the
281:53 - console and that's all it's going to
281:55 - do there we go let's say there's a
281:58 - situation where you actually want to use
281:59 - this inside your code you can actually
282:01 - set the console's title by typing in
282:03 - console. title and type in your name
282:05 - inside the quotation marks or you can
282:06 - type in anything inside here if you run
282:08 - that you'll see Abra is in the title of
282:10 - the console right now and that looks
282:11 - pretty cool what you got to realize is
282:14 - now we have two references to the same
282:15 - value now at this point we can actually
282:18 - do something better we can type in
282:20 - static string name equals abber and then
282:23 - instead of using abber in here we can
282:25 - say name and instead of using abber in
282:27 - here we can also say name and they're
282:29 - both using this variable and if you run
282:30 - the code now you see that the same
282:32 - output will happen you have ABA twice
282:34 - both both in the title and both in the
282:35 - console output now the problem with this
282:37 - approach is you're actually making use
282:38 - of a global variable which we do not
282:40 - like in code in situation like this you
282:42 - shouldn't need to make a global variable
282:44 - because there are ways around it so
282:46 - instead of having this which has a print
282:48 - introduction and we've got the name used
282:49 - in there but the name is coming from
282:51 - here maybe we can use this somewhere
282:53 - else so let's say we make another
282:54 - function called Static and instead of
282:57 - void we want to actually return back a
282:58 - string so we can say string and then we
283:01 - can say my
283:03 - name or something like return name or
283:06 - anything you want just make sure you
283:08 - give it a meaningful name so it dictates
283:10 - what the function is trying to do so
283:11 - this is to return the name and the
283:13 - reason why there's a red underline is it
283:15 - says not all called P return a value
283:18 - since we need to use our keyword return
283:21 - now that we add some empty codes and the
283:22 - return it's going to execute fine and
283:24 - the compil error is gone so obviously we
283:26 - don't want to just return nothing we
283:27 - actually want to take this arber and
283:29 - return in here so let's get rid of our
283:31 - Global variable and let's see what we're
283:33 - going to break so we're going to break
283:35 - these two references to the name
283:36 - variable and simply inside here we can
283:39 - actually just call return name and then
283:42 - here as well we can call return name and
283:44 - what this will do is inside here it will
283:47 - execute this function and then return
283:49 - the value in here if this is too many
283:52 - steps for you you can have a string name
283:54 - equals return name and then simply use
283:56 - the name inside the brackets these two
283:59 - lines are doing exactly the same thing
284:01 - except this is using a variable CU we're
284:03 - starring it first and then we're using
284:05 - it whereas if you place it straight
284:06 - inside the brackets that's just going to
284:08 - store it and use it immediately and
284:10 - there's no additional variable but don't
284:11 - worry too much if you're going to do
284:13 - this notation because an extra variable
284:15 - in this case doesn't really matter
284:17 - because as soon as this function is
284:18 - executed the variable used to run this
284:20 - function gets deleted since it's inside
284:23 - the scope of these two curly braces so
284:25 - now if we run the code you'll see that
284:27 - again we have abber and abber but now
284:29 - what we've done is actually controled
284:30 - everything throughout here so if you
284:32 - want name where to change or maybe this
284:34 - changes in different circumstance based
284:36 - on the user that's logged in then you
284:38 - can simply have the same thing now
284:40 - printed in two different locations in
284:42 - the title and in the console output and
284:45 - it's actually coming from one function
284:47 - so we can have a return name and we can
284:49 - make a static in now can say return age
284:52 - and then we can have simply return 23
284:55 - and that's our name and our age being
284:57 - returned I change us back to abber and
284:59 - then instead of the print introduction
285:01 - maybe we actually want to print a little
285:02 - bit more than the name then maybe in the
285:05 - title what we can do is have string
285:07 - interpolation wrap the return name and
285:10 - maybe put a hyphen in there and then we
285:11 - can say return age so if run the code
285:14 - now you can see we have ABA hyphen 23 so
285:18 - maybe that's the title of our console
285:20 - but then in the introduction we can use
285:22 - a bit more than that so we can have int
285:24 - age equals return age and then in the
285:26 - console output we can have something
285:28 - like this hello my name is name and my
285:32 - age is age and then after we've compiled
285:35 - that together we can place the output
285:37 - inside here there we go so we're using
285:40 - the name and the age inside the console
285:42 - title and then we have this function
285:44 - that runs to get us back the name and
285:46 - the age and then we're using it using
285:48 - string interpolation of course these
285:50 - four lines can be all squished into one
285:53 - you can simply take this dollar sign let
285:55 - me duplicate this
285:57 - line you can take this and paste it
286:00 - straight into here and while you have
286:01 - name we can have our return name and
286:03 - while you have age you can have return
286:05 - age and that will actually rule out all
286:08 - of these lines and you can wrap it all
286:10 - into one there you
286:13 - go and if age were to change like I said
286:15 - before you can simply type this number
286:17 - in change it and you can see in both
286:19 - cases in the title and in the console
286:21 - output it has officially changed
286:23 - functions can be very helpful to reduce
286:25 - repetition in code let's show you an
286:27 - example if you had three sections where
286:30 - you said enter a
286:32 - number and you had int n one equals
286:35 - convert to in32 and then we add a
286:38 - console.
286:40 - readline and then you had this section
286:42 - and you wanted to do num
286:44 - two and you had this section again and
286:46 - you actually wanted to do num three now
286:48 - at this point even though these three
286:50 - are actually identical you want to be
286:52 - using array in this case so you could
286:54 - have int numbers equals new int Square
286:58 - braet 3 and then here we could say
287:00 - numers
287:01 - zero numbers one numbers two and then we
287:05 - don't need the ins because it's already
287:07 - been defined and then we have them like
287:09 - this but because again all of these
287:11 - three sections are exactly identical we
287:13 - can actually run a for Loop that goes
287:15 - from numbers do length and then we can
287:17 - place one of these straight inside here
287:20 - and then change this to I and now we've
287:22 - achieved exactly the same thing but
287:23 - we're not actually done yet so if you
287:25 - run the code and we do 1 2 3 now we
287:28 - stored all three numbers so we have
287:29 - enter a number and then we have the
287:31 - console read line and maybe we can
287:33 - actually make these two lines a little
287:34 - bit shorter so let's make a function
287:37 - static and because we essentially want
287:39 - to return an integer we can say static
287:41 - int read number from
287:44 - console and then if we take these two
287:47 - lines place them inside here and because
287:49 - we need to return back an integer this
287:51 - is the value that we're going to be
287:52 - returning so instead of assigning this
287:54 - position to something we'll actually
287:56 - just immediately return at this point so
287:58 - instead of doing this line now and
288:01 - instead of doing all of this we can
288:02 - simply make this into one line of code
288:05 - read number from console so every time
288:07 - this will execute it will jump into here
288:09 - print out the value enter a number the
288:12 - user will type it in it will read it in
288:14 - convert it to an integer 32 and this
288:16 - will return back the integer that the
288:18 - user typed in and then that will return
288:19 - it back to the console and essentially
288:21 - replace this so if the user is typed in
288:23 - five then it essentially replace this
288:25 - with five store it loop around and if
288:27 - replaced in 10 the next time and then
288:29 - you replace this with 10 essentially and
288:31 - then that gets started inside and so on
288:32 - and so forth until until all the
288:34 - positions have been complete Let's test
288:36 - that 1 2 3 and it still works okay of
288:40 - course I'm not actually printing the
288:41 - values out to the screen so if you
288:42 - wanted to see that quickly for each can
288:45 - have our item inside our numbers and
288:48 - then do a console right with some string
288:50 - interpolation item followed by a space
288:53 - let's run that one two and three and
288:55 - there we go we get one two and three of
288:57 - course you can make these functions and
288:58 - they can return any bits of data that
289:00 - you want you can even have something
289:02 - like an INT array and we can say create
289:05 - random array and then we can create an
289:06 - array call numbers make that equal to
289:09 - new in square braet 3 and we can
289:12 - actually give it the values of 0 1 and
289:14 - two and then just at the end here we can
289:16 - actually just return numbers and then
289:18 - just in here we can have an INT array
289:20 - and we can call that new numbers since
289:22 - we have numbers above just above here
289:24 - and then we can make that equal to
289:25 - create random array and because this
289:28 - returns us back with an integer array
289:30 - there's no compile arrays inside here
289:32 - and we can have a for each follows the
289:34 - exact same approach as the one above new
289:36 - numbers console right line into a
289:39 - console right and then have item
289:41 - followed by a space now if we print
289:44 - these both out you can see that the zero
289:46 - one and two actually comes from the new
289:48 - one it's just we have two console right
289:50 - right next to each other so there's no
289:51 - new line separating them so if we just
289:53 - add a console right line here one two
289:56 - and three and there you go 1 2 and three
289:58 - comes from the three inputs we just
290:00 - typed in and 0 1 and two actually come
290:03 - from the function we've just created of
290:05 - course if you don't like this notation
290:07 - then what you can do is you make it a
290:08 - lot easier you don't even need to make a
290:11 - new variable you can actually just
290:12 - return the integer just like this so if
290:15 - we place
290:16 - this straight inside here actually just
290:20 - make it on one line just so it looks a
290:21 - bit neater then there you go we have our
290:23 - entire function reduced in one line the
290:26 - goal of functions is to make them do as
290:28 - little as possible if your function has
290:30 - two different things it's doing or more
290:32 - then you should break that out into into
290:34 - another function for example if you had
290:35 - a function that did two distinct
290:37 - operations one was a conversion and one
290:39 - was a calculation then you want to split
290:41 - out into two the first function should
290:43 - be the conversion and the second
290:44 - function should be the calculation and
290:46 - the reason why they're separate is
290:48 - because if you want to reuse them as a
290:50 - pair then you won't be able to reuse
290:52 - each of the pairs if you wanted to have
290:54 - a calculation on its own then you can't
290:56 - do that if both functions do the same
290:58 - thing for example you could have a
291:01 - static and it just could be something
291:03 - let's just call it VI and it could just
291:05 - be test for example and if you had the
291:07 - conversion here and then if you had the
291:09 - calculation in here then you need to
291:11 - split this up into two different
291:12 - functions you want have static void
291:16 - conversion and static void calulation if
291:19 - you wanted to use conversion or
291:21 - calculation separately you can't because
291:23 - now it's in this pair together so if you
291:24 - wanted to use them separately you simply
291:26 - can't it's best to keep functions on the
291:28 - RW anywhere just so they have a single
291:30 - purpose so you can give them a name cuz
291:32 - as you can see here we can't can't give
291:34 - this an appropriate name because it's
291:35 - doing more than one task this is doing
291:37 - the conversion this is doing the
291:38 - calculation and this is doing multiple
291:40 - things this could be doing something if
291:43 - you have to think too hard about the
291:44 - function title then you might be doing
291:46 - too much within each of functions these
291:48 - are very easy to be able to decide what
291:50 - they do cuz this one converts and this
291:52 - one's going to calculate reading number
291:54 - from console if this was reading the
291:56 - number from the console and doing
291:58 - something else then it's going to be a
292:00 - bit of a problem because now you've got
292:01 - a bigger name you don't want to be doing
292:03 - reading number from console and and
292:05 - something else cuz then your function
292:07 - name gets also too big and you got
292:09 - multiple dependencies so best thing to
292:11 - do is to call them accordingly and keep
292:13 - them as short as possible so let's say
292:15 - we wanted to make a function that added
292:16 - two values we can have a static int call
292:18 - it add and then we can return 5 + 5 now
292:22 - this function is a little bit redundant
292:24 - although it will actually work so if we
292:26 - go back to our main and we do a console
292:28 - right line and actually print the value
292:30 - of
292:31 - ADD and we go through our function then
292:33 - we see we get the value of 10 which is
292:35 - indeed 5 +
292:37 - 5 but since this 5 + 5 won't change it's
292:41 - always going to be 5 + 5 this is where
292:43 - parameters will come in which we'll
292:44 - cover in the next videos parameters are
292:46 - a way of being able to give the function
292:48 - value so these two can be actually
292:50 - changed there's no point in having an
292:52 - add function if the only ability you can
292:54 - do is add 5 + 5 because you may as well
292:56 - just return 10 at this point so I
292:58 - covered a lot in this video and there's
293:00 - lots of different functions that do
293:01 - different things of course there is
293:03 - quite a lot of lines we're up to 87 this
293:05 - is probably the biggest project that
293:06 - we've wrote so far and even though this
293:08 - is not really a project it's just a
293:10 - bunch of functions that do little things
293:12 - that are made for demonstrations so
293:14 - let's have a recap so first here we're
293:16 - setting the title as a result of return
293:18 - name and return age we can actually take
293:21 - this and develop this further if you
293:23 - want to we could actually say return
293:25 - name age pair and if you wanted to
293:28 - collapse that inside one function then
293:30 - that could be really easy you could say
293:32 - static string
293:34 - return name age pair and then you can
293:37 - have return and literally the exact same
293:39 - line above you can have return name
293:41 - followed by a hyphen and then you can
293:43 - have a return age and then end the line
293:46 - like that so that just concatenates the
293:48 - two values that are returned from these
293:49 - two functions but the point is you keep
293:51 - them all separate if you were to type in
293:53 - very statically inside here AB 25 then
293:56 - obviously like I've talked about above
293:58 - then you're going to have duplication of
294:00 - data and of course we're going to use
294:01 - this name inside something like here and
294:04 - as you can see this name age pair is
294:06 - actually not applicable when it comes
294:07 - back to this format so it's always best
294:09 - to keep these two separately so if you
294:12 - bring it back and we can actually keep
294:13 - it like this now instead of having this
294:15 - code we can actually say return name age
294:18 - PA now will give us the same value at
294:20 - the top of the code it will have ABA
294:22 - hyphen
294:23 - 25 so that's that bit in our print
294:26 - introduction If We Hold control and we
294:28 - actually press on this function it will
294:30 - actually jump us right down and then if
294:32 - we press the back arrow top left we can
294:34 - go back to it there we go and then click
294:36 - forward so in this function we can break
294:38 - down all of the return values into
294:40 - string variables we have a string name
294:42 - equals return name an inage equals
294:44 - return age then we have a string input
294:46 - that concatenates them both together
294:48 - hello my name is name and my age is age
294:51 - and then we print out to the screen or
294:52 - if you wanted to we could wrap all four
294:54 - of these lines straight up into one we
294:57 - don't need to assign these into
294:58 - variables although it does help the
295:00 - readability if you keep them separate
295:02 - but I prefer to keep it like this since
295:04 - I'm used to this notation we can place
295:06 - return name straight into there which
295:07 - will get rid of our name variable and
295:09 - the same thing with age which will get
295:11 - rid of these two variables and of course
295:13 - we're actually storing the string value
295:15 - before we printing it so we could just
295:17 - take all of this and place it straight
295:19 - instead of here scrolling back to the
295:23 - top this little section was
295:25 - demonstrating how we can use integer
295:27 - arrays to read in all the values from
295:29 - the console but wrap it around in a
295:31 - function so before in here you would
295:33 - would have something like a console
295:34 - right line you'd print out the value to
295:36 - the screen that would say something like
295:37 - a ter number and then you have on the
295:39 - next line a convert to in32 and then
295:43 - after you converted in 32 you'll
295:45 - actually start it straight to numbers
295:46 - but because this is going to be the same
295:48 - thing for inster all the numbers you can
295:50 - actually wrap this around in a function
295:52 - so if we hold control again and go to
295:54 - this you'll see that them two lines are
295:55 - very simply placed in here console right
295:58 - Line enter a new number and then convert
296:00 - in 32 based on the console read line and
296:03 - then we're simply just returning that
296:04 - back ready to be stored in the index of
296:07 - the numbers array and then straight
296:08 - after that we're just printing out all
296:10 - the values to make sure it's worked and
296:12 - that all succeeded fine here I was just
296:14 - demonstrating that you can have
296:15 - different return values and it can
296:16 - literally be anything so as you can see
296:18 - here if you hover over create random
296:20 - array it's inside the program class it's
296:22 - called create random array and it
296:24 - returns back an integer array so that's
296:26 - what we're sign into and if we hold
296:28 - control and click on this again you can
296:30 - see that all this simply does is returns
296:32 - us back back a three length array with 0
296:35 - 1 and two as the array positions and
296:38 - then if we scroll back up when we
296:40 - execute this for each Loop then we're
296:41 - simply going to get 0 1 and two just
296:45 - like that since it's a console right and
296:46 - it'll be on the same line with a space
296:49 - after each
296:51 - other this demonstration was slightly
296:54 - theoretical I was saying in one given
296:56 - situation a function should only do one
296:58 - task if your function converts and does
297:00 - a calculation at the same time then
297:02 - these are actually two different things
297:04 - you should split them so you use the
297:06 - conversion in this step and you use the
297:08 - calculation in this step if you wanted
297:10 - to convert something or calculate
297:11 - something in the future then you can
297:13 - only do it now because we've separated
297:16 - them whereas before if you have them
297:17 - both inside here then you simply can't
297:19 - do one operation because you wrapped it
297:22 - around in one section the same is true
297:24 - when I was discussing this earlier on if
297:27 - we kept this name pair is the only way
297:28 - to access the age in the name then it's
297:30 - going to mess up when we use it in here
297:32 - and then we're going to have a
297:33 - duplication of data but because we
297:35 - separated the name and we separated the
297:37 - age we can use it in this function and
297:39 - we can use it in this function and it
297:41 - doesn't interrupt anything this simply
297:43 - Returns the name this simply Returns the
297:45 - age and these two functions make use of
297:47 - them if we had something else underneath
297:50 - there were another function that
297:51 - depended on the name of the ede then
297:53 - again we can simply use them if it was
297:55 - restricted to this function then it's
297:57 - going to be a problem using it in this
297:59 - function or any future ones and finally
298:03 - just to finish off add function and all
298:05 - it simply does is return 5 + 5 and I was
298:08 - saying as of right now even though it
298:10 - returns back a value it's kind of
298:11 - pointless CU you may as well just return
298:13 - back 10 since it's doing the same thing
298:15 - the reason why included this function is
298:17 - that we can set it up and start planting
298:19 - the seeds to understand why functions
298:21 - exist and how to make use of parameters
298:23 - what a parameter is is it lets you put
298:25 - things Within These brackets so you can
298:27 - give this function some data so if you
298:29 - have an in. trass for example these
298:32 - things that we place ins inside the
298:33 - brackets are actually the parameters so
298:35 - we have a string s and out in something
298:38 - and that's how the parameters work on
298:39 - our Tri pass function and just to show
298:42 - you this is how it's actually wrote It's
298:44 - a Bo and then it's called trip pass and
298:47 - it takes in a string s and out in
298:51 - result then we can make this static and
298:54 - I know it's give us an error because we
298:56 - don't have the control path if we just
298:58 - use result and assign it to zero and
298:59 - then return back true you can see that
299:02 - the compil error is now gone on and as
299:03 - you can see here it says bull trip pass
299:05 - string s out in result and if we
299:08 - actually try and use the trip pass in
299:09 - here and press the brackets you can see
299:12 - that these parameters are exactly
299:13 - identical to parameters that were inside
299:16 - of the tripar coming from the integer
299:18 - Library so in the future we're going to
299:20 - study how we can use parameters to pass
299:22 - data inside our function but just for
299:25 - now know that this function is
299:26 - essentially pointless because it's only
299:28 - going to return back 10 and this
299:30 - function will gain the functionality it
299:32 - needs on when we start adding parameters
299:34 - this should essentially be add five + 5
299:37 - except this is kind of a pointless
299:39 - function because we already know the
299:40 - value is going to be 10 but again this
299:43 - is just helping you understand why
299:44 - parameters are very essential to
299:48 - functions we've covered how to create a
299:50 - viid function and a function that
299:52 - returns a data type but now we want to
299:54 - create a function that gives it some
299:55 - sort of data you may not realize it but
299:57 - all these functions that you normally
299:58 - use like console right line you're
300:00 - actually inserting data consistently
300:03 - into all of these functions if you hover
300:04 - over console right line you see his void
300:07 - console right line and right now there's
300:09 - an open bracket and there's a close
300:10 - bracket if we delete this bracket and
300:12 - reopen it you see there's 19 different
300:13 - ways you can call this function and as
300:15 - soon as you start to type a string you
300:17 - can see we have a string format and an
300:19 - object if you need to and if you type in
300:20 - another string you can see it says
300:22 - string value this string value is
300:24 - actually a parameter If We Hold control
300:26 - and press on right line you can see all
300:28 - of the different functions right here
300:30 - this is the most basic version that just
300:32 - inserts a right line character to the
300:33 - console and then these are all the
300:35 - different parameters that you can give
300:36 - the value of course you can't double
300:39 - click and view the source code because
300:40 - this is hidden inside Microsoft's
300:42 - libraries the values that are placed
300:45 - inside these parentheses are actually
300:46 - called the parameters this is known as
300:49 - functional overloading which we'll cover
300:51 - later on in the course basically that
300:53 - means you can have the same name
300:54 - function but give it different
300:56 - parameters and you'll see why this is
300:57 - helpful later on down the line so let's
300:59 - close this tab in the top right hand
301:00 - corner and let's bring back out code so
301:03 - now that we've passed hello into this
301:04 - function that's was actually given this
301:06 - a string value parameter and that hello
301:08 - is going to get passed straight into the
301:10 - console right line so then when we run
301:12 - the code it's going to print it to the
301:13 - console so let's create our own function
301:15 - with our own parameters so if we take
301:17 - the function I had last time it was
301:19 - static int add Open Bracket close
301:21 - bracket and it simply returned 5 + 5
301:24 - which we all know is going to be 10 so
301:26 - if we place add inside these brackets
301:28 - and we run the code we should get 10
301:30 - return back there we go so of course the
301:32 - this is a little bit pointless since
301:34 - it's always going to be adding 5 + 5
301:36 - there is no way we can change this
301:38 - without the use of parameters so in here
301:40 - we can actually just do what we do when
301:42 - we normally declare a variable we say
301:44 - the data type int and then the variable
301:46 - name and then if you want to add
301:48 - multiple parameters you can simply add a
301:49 - comma so now we can say int a and int B
301:53 - and you can see now we've got a syntax
301:54 - error because it expects us to have both
301:56 - of these values inside if you hover over
301:58 - it there is no argument given that
302:00 - corresponds to the required formal
302:01 - parameter a and then if we insert a by
302:04 - having five for example and if we hover
302:06 - over it it complains about not having B
302:09 - so we can do comma and then do five
302:11 - again so just this on its own is not
302:13 - actually going to do anything we're
302:14 - actually giving the add function the
302:16 - values of five and five and place them
302:18 - inside a and inside B variables these
302:21 - are now known as local variables and
302:23 - they only exist in memory between these
302:25 - two curly braces as soon as this
302:27 - function is done these are deleted from
302:29 - memory and you can no longer access in a
302:31 - and int B you can't just do something
302:33 - like a inside here and think that this
302:35 - can be used up here these are in two
302:37 - completely different Scopes this is one
302:39 - function and this is another function
302:41 - and they're completely separate from
302:43 - each other when you type in five and
302:44 - five it goes in order so int a is the
302:47 - first one so five gets placed into here
302:49 - and this five gets placed in a b so now
302:52 - that we need to make use of them we can
302:53 - simply change this to a and change this
302:56 - one to B now if we run the Corde we
302:58 - should still get 10 but now our function
303:00 - Works a bit better we can give it a set
303:02 - of d
303:03 - so if we actually just put zeros instead
303:05 - of here then we should get 100 returned
303:07 - perfect so now that we've figured out
303:09 - how to do this let's have a look at
303:10 - different ways that we can make use of
303:12 - this function so let's say we had a
303:14 - situation where we did console right
303:16 - enter a
303:18 - number and we add int nor equals convert
303:22 - to
303:23 - in32 and then converting the console do
303:26 - read
303:27 - line and let's wrap this inside a
303:30 - function so before what I was doing is
303:32 - simply just returning back in int it was
303:34 - static int read
303:37 - int and then we took these two lines and
303:40 - place it straight inside here and remove
303:42 - the fact that we have an integer and
303:43 - simply just change this to a return and
303:45 - what this now will say is let's output
303:47 - enter a number to the console let the
303:49 - user type it in inside the console read
303:52 - line and then read it in convert it to
303:54 - an integer and then give it back to
303:55 - whatever calls it so now we can get rid
303:57 - of this and get rid of this convert and
303:59 - simply just type in read in inside here
304:02 - and after the line let's just print it
304:04 - out to make sure it's worked okay enter
304:06 - a number 10 press enter and we have 10
304:09 - again and that's fine except if we want
304:11 - to use this in another case for example
304:13 - if you have num one maybe we don't
304:15 - actually want to enter a number maybe
304:17 - this time it's going to be enter an
304:18 - angle or something of this sort so what
304:21 - we can do if we undo that we can
304:23 - actually introduce a string message and
304:25 - what this will do now is actually
304:27 - specify the message that we put in here
304:29 - maybe there's a situation where we
304:31 - always want to enter something so maybe
304:33 - we can just replace this and put a
304:34 - string interpolation and wrap this
304:36 - number around in the curly brace and
304:38 - replace it to message so then in here we
304:40 - can say enter a and then we can pass the
304:44 - string variable which will get placed in
304:46 - here so if this is a number then we can
304:48 - type a number and maybe this is
304:49 - something like an
304:51 - angle and then here we can type an angle
304:54 - so we have 10 enter a number and then
304:56 - there you go it says enter an angle then
304:58 - we can have 100 and that's working as
305:00 - well alternatively if you want to
305:02 - specify the entire message then you can
305:04 - remove these and keep it like this and
305:07 - then in both of these situations we can
305:08 - say enter a number and copy that down
305:11 - like this and make sure you put the
305:13 - colum at the end followed by the space
305:15 - there we go enter a number 10 enter an
305:18 - angle 20 maybe the situation where this
305:21 - text actually changed and you just want
305:23 - it to be angle and if you run that again
305:25 - then you'll see that these are
305:26 - completely different now one says enter
305:28 - a number and one says angle but this
305:30 - gives us a lot of flexibility in what we
305:32 - pass in if we keep it as enter a and
305:35 - then let the user decide on what this
305:36 - section is then you rule out any
305:38 - opportunity to be able to do that option
305:40 - if you wanted to to prevent the colon in
305:42 - the space always being at the end you
305:44 - can actually just add that in manually
305:46 - if we bring back the string
305:47 - interpolation we can say colon followed
305:49 - by space so you don't have to remember
305:51 - to always put that in there we go so
305:53 - that's doing the exact same thing and
305:54 - we're actually just reducing the amount
305:56 - of repetition because we have to
305:58 - remember to put a call on Follow by
306:00 - space inside here we might just forget
306:02 - it and then when you leave it like this
306:04 - then the chord is going to look ugly
306:05 - because it looks like this and it's all
306:07 - stuck together so let's make use of
306:09 - these two functions and let's see if we
306:10 - can write a really basic calculator we
306:13 - can say int first num equals read int
306:16 - and we can say enter first number and
306:19 - then duplicate that down change first to
306:21 - second and then change this also to
306:23 - Second and then inside a console right
306:25 - line we can actually have the add
306:27 - function and we can type in first number
306:29 - and then we can type in second number
306:31 - and if you don't want to call the
306:32 - function inside here you could actually
306:33 - just make another int and we can say int
306:35 - result equals add and just bring this
306:38 - line over to here and then in the
306:39 - console right line you can just print
306:41 - the
306:42 - result there we go so we read in both
306:44 - the values execute the add function and
306:47 - then return it back to the user using a
306:49 - console right line so these are the
306:51 - other ones and then here they are so if
306:53 - we do 50 and we do 50 again and you see
306:55 - that I've messed up because we have
306:56 - double colums now so although our
306:58 - calculator did indeed work let's just go
307:00 - and correct that so we can take these
307:02 - off now because we added it inside
307:06 - here 50 and 25 we should get 75 perfect
307:10 - so now we've made a little basic
307:12 - calculator by simply making use these
307:14 - functions and if we just expand this
307:16 - just to show you what it would have
307:17 - looked like so we go in from this and we
307:21 - place our message inside to here and
307:24 - then we have our convert line just like
307:27 - this and then if we duplicate that down
307:29 - we can change this to second number and
307:31 - then to second number
307:33 - and then as for the result we can say
307:35 - first n plus second
307:38 - n there we go you can see the code is
307:40 - drastically longer and is a bit
307:41 - meaningless to have duplica code this is
307:44 - literally the exact same line in both of
307:47 - these sections except for the fact that
307:48 - this ISS first and this ISS second and
307:51 - we're starring in first and we're
307:52 - starring in second so let's undo that
307:54 - and get back to our more efficient code
307:56 - there we go you can see that these three
307:58 - lines are considerably shorter and
308:00 - easier to read this is telling us we
308:02 - read integer here is the value and we
308:04 - want to return it inside our first Nome
308:06 - and so on and so forth let's have a look
308:08 - at another example where we can make use
308:09 - of this so we can have a string called
308:11 - name and we can read this in from the
308:13 - console console.
308:16 - readline but we need to Output a message
308:18 - so we can have another console right and
308:21 - we can say enter your
308:23 - name and then we can have this twice and
308:27 - we can do enter your age and then have
308:29 - an INT
308:30 - age but of course we don't want to be
308:32 - using this approach and putting a
308:34 - console right line inside here with a
308:36 - convert in 32 because although this is
308:38 - actually technically correct now we're
308:40 - UND doing the point Val function so
308:42 - let's change this into our readint and
308:44 - then as for our message well we have the
308:46 - message right here and again we don't
308:47 - need the space colons let's remove that
308:49 - and then as for the name we can actually
308:51 - do this differently so this is actually
308:53 - going to do a string variable so what we
308:55 - want to do instead of having read in we
308:57 - can have another function called read
308:59 - string another string message parameter
309:02 - and then do exactly the same thing have
309:04 - a console right and we can place string
309:07 - interpolation and place a message inside
309:09 - here followed by callon space and then
309:11 - we can just simply return the console.
309:14 - readline there we go and instead of
309:16 - doing all of this we can actually just
309:18 - put our read string inside here and then
309:21 - place our ENT your name inside here just
309:24 - without the call on Space because we
309:25 - don't need that so now we' reduce this
309:28 - section to two lines as well so now what
309:30 - we can do is have a string details and
309:32 - make that equal to a function that we're
309:34 - going to use now we can say user details
309:36 - if we want to give it the name and give
309:37 - it the age and that will give us back a
309:40 - string that we can print to the console
309:42 - so we can say details so let's go ahead
309:44 - and make use of this function so we can
309:46 - have a static and it's going to return
309:48 - as back a string CU we're placing it
309:49 - inside the string and then it's going to
309:51 - be user details and then our name is a
309:54 - string our age is an INT and then inside
309:57 - here we just want to concatenate them
309:59 - two values together so we can say hello
310:01 - my name is name and my age is age and
310:07 - because that's returning us back with a
310:09 - string we can make use of it inside
310:10 - string details or we can place this
310:13 - straight inside the console right line
310:15 - let's leave it as a function call assign
310:17 - into string details and then print out
310:19 - to the screen let's just skip over these
310:22 - sections enter your name AB enter your
310:24 - age 23 and then there you go hello my
310:26 - name is abber and my age is
310:29 - 23 so this is how we can make use of
310:31 - parameters and inside our functions so
310:33 - we can actually give it some sort of
310:34 - data that's meaningful if you didn't use
310:36 - parameters then what you're going to
310:37 - have to face is for example we showed
310:39 - you with this integer if you don't use
310:41 - parameters then you're going to have
310:42 - situations like I showed you before with
310:44 - this integer function it returns back an
310:47 - integer but it only gave us the value of
310:49 - 5 + 5 I mean technically you don't need
310:51 - to return anything you can actually just
310:53 - keep this avoid and just wrap this
310:54 - around in console right line the only
310:56 - issue with this approach is you don't
310:58 - have any option other than to print out
311:00 - to the screen or if you didn't want to
311:02 - print out to the screen and he simply
311:03 - just wanted to return the calculation
311:05 - and then store it inside another
311:06 - variable this doesn't give you the
311:08 - flexibility of that so we change this
311:10 - into an INT and instead of returning it
311:12 - back to the console we just return back
311:14 - the pure value and then if the user
311:16 - decides that they want to print this out
311:17 - to the screen that's fine like here
311:20 - we've made a decision that we want to
311:21 - print out let's just say we had a
311:23 - variable that said in calculation then
311:25 - we place that inside but we actually
311:27 - never wanted to print it maybe we kept
311:29 - it like this and then use Cal for some
311:31 - something else down below or maybe that
311:33 - was something like storing inside a
311:35 - database not everything will be printed
311:37 - out to the screen for the user to see
311:39 - the best thing to do is return the
311:40 - values in their purus form because you
311:42 - never know what the developer or the
311:44 - user is going to make use of that data
311:45 - later on down the line keeping it it's
311:47 - purus form is the best way possible for
311:49 - example in this case we're actually
311:51 - reading back the integer and then print
311:52 - it out to the screen but in this exact
311:55 - case which is the best case scenario
311:56 - that I just showed you we're actually
311:58 - making use of first n and second n but
312:00 - first n and second n and never actually
312:02 - print it to the screen it's always just
312:04 - used for the calculation if we use
312:06 - console right line to print out first n
312:08 - and second n then we're not going to be
312:10 - able to use it inside our calculation
312:12 - and therefore our very basic calculator
312:14 - is now being rendered pointless so read
312:16 - in and add all return back values that
312:19 - we can use in their purest form and that
312:21 - is the whole goal of
312:24 - parameters so now that we covered
312:26 - parameters that are always going to be
312:27 - required let's have a look at another
312:29 - concept called optional parameters so we
312:32 - had a static int add and we had int a
312:34 - and int B for example and then we simply
312:37 - just returned a plus b like we used in
312:39 - the previous examples if we have an INT
312:41 - result and we want to call that function
312:44 - and we give it the value five and five
312:46 - and then print out to the screen
312:47 - everything runs okay because we've added
312:49 - in exactly what we expect let's say we
312:52 - don't actually have this additional five
312:53 - of course this doesn't make any sense
312:55 - cuz we meant to be adding two numbers
312:57 - but just humor me for a minute then what
312:59 - this will do is says there's no argument
313:01 - given that corresponds to the parameter
313:03 - B now of course this is a problem
313:04 - because it's a red underline which means
313:06 - if we try and run the code we're going
313:07 - to get an issue let's say you creating
313:10 - some sort of system that if you entered
313:12 - both values it uses both values but if
313:15 - you only entered one it automatically
313:17 - set the second value to something else
313:20 - and we can achieve this Behavior using
313:22 - optional parameters so an optional
313:24 - parameter doesn't exactly mean quite
313:26 - optional it kind of just means that it's
313:28 - going to be optional but you can also
313:30 - give it a default value this will always
313:32 - add two numbers A and B even if we make
313:36 - a or b optional it's going to still need
313:38 - two numbers to add in order for the
313:40 - function to run so in order to make a
313:42 - parameter optional let's just say we
313:44 - want to make B optional we can type in
313:46 - equals straight after it and actually
313:48 - give it a value so as you can see our
313:50 - syntax error is now gone and if we run
313:52 - the code we should get
313:54 - 55 and the reason why this works is a is
313:57 - now five if you hover over here we can
313:59 - see a is five and then the square
314:02 - brackets around the int B actually
314:04 - denotes that it's optional and it says
314:06 - int b equals 50 cuz we have that here so
314:09 - it's actually using this as 50 and if we
314:12 - don't specify the second parameter then
314:14 - it's practically just doing this which
314:16 - is completely fine so the reason why I
314:18 - said it's not quite optional is because
314:20 - you still need to give it a value of
314:22 - course in here you can use the default
314:23 - keyword in the case of an integer the
314:26 - default value is actually zero so if you
314:28 - just run that code now it's going to say
314:29 - 5 + 0 which is just 5
314:33 - so it can be optional but you still need
314:34 - to give it some sort of value of course
314:36 - if you're doing a calculator and you're
314:38 - adding two values if you only specify
314:40 - the first one then adding zero to it is
314:43 - simply not going to change it so zero or
314:45 - default is going to be the best user
314:47 - case when you're dealing with default
314:49 - values with integers so another way you
314:51 - can actually specify this is by
314:52 - inserting this thing called an attribute
314:54 - if we remove this equal zero and just
314:56 - before the end we can type in Open
314:58 - Bracket close bracket and type in
315:00 - optional with a capital O and then
315:03 - you're going to get a red underline if
315:05 - you hover over it it says we need to
315:07 - include this extra Library which will
315:09 - import it at the top of our code as you
315:11 - can see here now that this is available
315:13 - it says indicates that a parameter is
315:15 - optional and what this will do by
315:17 - default is it'll give you the basic
315:19 - value for this number so what I mean by
315:22 - that is we can type in here just to show
315:24 - you this b equals and then B and this
315:26 - will just give you the default value
315:28 - based on the data type and as we just
315:30 - said a minute ago that value is actually
315:32 - going to be zero there you go B is zero
315:35 - so all it's doing is saying 5 + 0 =
315:39 - 5 so that's another way of doing it or
315:41 - you could just leave it as I said before
315:43 - you can say in b equals default or in b
315:46 - equals z it's completely up to you I
315:48 - prefer using the default keyword so you
315:50 - don't have to keep remembering which
315:52 - different data types have the default
315:53 - values in the integer case it's zero but
315:56 - I just like leaving the default and we
315:58 - can get rid of this line now let's have
315:59 - a look at different situations where
316:01 - this be helpful if you had a function
316:03 - called print name and we had a string
316:05 - name in here and then we can simply just
316:08 - say console right line my name is and
316:11 - then name this is quite easy to use so
316:14 - we can say print name and then place
316:16 - arber inside the brackets and then run
316:18 - the code and we get abber printed to the
316:20 - screen and that's fine but let's say if
316:22 - we had someone else's name in there as
316:25 - Joe for example then we get Joe to the
316:26 - screen and let's just say as the
316:28 - developer you only want to default this
316:30 - to abber if you you don't actually
316:32 - insert anything so now if you don't
316:33 - insert anything of course we're going to
316:35 - get a compil error because we need a
316:36 - parameter but if we assume what we did
316:39 - here and just follow the same approach
316:41 - if we use default then it's going to
316:42 - give us nothing because the default
316:45 - value for a string is just empty quot
316:47 - which is just nothing but instead of
316:49 - default we can actually specify value so
316:52 - we can say if no one types their name
316:54 - inside the bracket then use
316:57 - abber there we go so you can have this
317:00 - optional parameter that defaults to
317:02 - something and if someone types in jaw or
317:04 - whatever inside the print name function
317:06 - then the default optional parameter is
317:07 - not going to be used since this will be
317:09 - overridden if you have a parameter
317:11 - placed inside here so now the abber is
317:13 - going to get overridden by the jaw
317:15 - because this is actually the parameter
317:17 - that's being used in the
317:19 - function so you've looked at functions
317:21 - with normal parameters optional
317:23 - parameters and now let's take a look at
317:24 - name parameters so let's say you had a
317:26 - situation where you had string name ABA
317:29 - in age equal 23 and string address
317:32 - equals one something Road and then you
317:35 - had a function that would simply print
317:37 - these details out to the console so
317:39 - start void print details there string
317:42 - name inage String
317:45 - address so you have three console right
317:47 - lines that just print out a name value
317:49 - pair just like
317:51 - this and then when you go to call this
317:53 - function what you're going to have to do
317:55 - is specify the name then the age then
317:57 - the address in that specific order as
318:00 - per the parameter show if we try and run
318:02 - the code now we should get the desired
318:05 - output perfect let's say for example you
318:07 - wanted to rearrange the parameters and
318:09 - put Age first you'll see we have a
318:11 - compiler error now because age and name
318:13 - are in the wrong order string name
318:15 - should be first and int age should be
318:17 - second we can still achieve this by
318:19 - using something called name parameters
318:21 - we don't have to stick to this order if
318:22 - we tell the compiler which parameter
318:24 - we're directly talking about so we can
318:27 - say age callon because our parameter is
318:29 - now called age as you can see it's been
318:31 - being highlighted and then after the
318:32 - call on it's the variables that we're
318:34 - talking about so it just happens to be
318:36 - that age is the same value as the edge
318:39 - so maybe we can change this to age input
318:42 - and place input at the end of these so
318:44 - then we can have age equals age input
318:46 - and name parameter equals the name input
318:49 - and the address parameter equals the
318:50 - address input now we can have it like
318:53 - this and to make it look even better you
318:55 - can actually add new lines in here just
318:57 - to break it off like this and this is a
318:59 - similar pattern that you'll see in
319:00 - normal production code putting a space
319:02 - here can separate them out a little bit
319:04 - and there we go it doesn't matter which
319:06 - order that we put these in right now we
319:07 - can even put address first and it'll
319:10 - still work okay and if we run it you
319:12 - should still get exactly the same output
319:14 - it's just specified in a different way
319:16 - so let's just have a little recap to
319:18 - make use of name parameters you don't
319:19 - need to do anything to the original
319:20 - function you just write it exactly the
319:22 - way you're used to doing you specify the
319:24 - parameters in the order that you think
319:26 - is sensible and when you go to call it
319:28 - you can simply just type in the
319:29 - parameter's name first followed by colon
319:32 - and then the variable name that you want
319:33 - to address once you've done that then
319:35 - you can use name parameters you can go
319:37 - back to using the normal function by
319:39 - just getting rid of the name followed by
319:40 - the colon and just replacing all of the
319:42 - parameters using the correct order and
319:44 - the original variables instead of the
319:46 - new notation having Name colon followed
319:49 - by name
319:51 - input so far we've covered functions
319:53 - with no parameters normal parameters
319:56 - optional parameters named parameters and
319:58 - let's look at a concept called out
320:00 - parameters let's demonstrate a quick
320:01 - example so if we call a function called
320:03 - test and we pass in a value and let's
320:05 - just make this work so we can have an
320:07 - INT Norm equals 0 and then we have a
320:09 - test function so we can say static void
320:12 - test and we can say in Num and inside
320:16 - here let's make num the value of five
320:18 - now in this example if we print out num
320:20 - to the screen what do you think is going
320:21 - to happen is num going to take the value
320:23 - of five or is it going to keep the value
320:26 - zero I'll give you a second to think and
320:27 - let's run the
320:29 - code so let's run it and see what
320:33 - happens and if you guess five you're
320:36 - indeed Incorrect and if you guess zero
320:38 - you are correct and the reason why it's
320:40 - not five is because when you pass a num
320:43 - inside this parameter it just becomes a
320:45 - parameter and therefore it becomes a
320:47 - local variable even though these two
320:50 - variables are actually called exactly
320:52 - the same thing you'll see that when I
320:54 - highlight it it only highlights this one
320:56 - and doesn't highlight this one and the
320:58 - same is true for this it highlights
321:00 - these three references but not the ones
321:02 - down here the gome variable is only
321:03 - accessible in each other scope this one
321:06 - is available through here and here and
321:08 - this one is available through here and
321:10 - here therefore if we use this assignment
321:13 - then it's actually doing nothing if we
321:15 - print out gnome inside here num equals
321:19 - num and then we print that we can see
321:22 - that it is assigned the value five but
321:24 - because it doesn't do anything at the
321:25 - end of this function then it simply
321:27 - doesn't get returned back or anything
321:28 - happens to it so let's see how we can
321:30 - make make this in to five when it gets
321:32 - printed out here so the options that we
321:35 - have is we can actually make this vo an
321:37 - integer and we can say nor equals 5 and
321:39 - then we can return num or alternatively
321:42 - we could simply just return five and not
321:44 - do both of these lines so if we run that
321:46 - now then we still get zero and the
321:49 - reason why we get zero is the test
321:51 - function is being called and it returns
321:53 - back an integer but we're simply not
321:55 - doing anything with it so we can say num
321:57 - equals the return value of this function
322:00 - which will be five and now if we run it
322:01 - we should see our five perfect now this
322:05 - is a little bit cumbersome and let's say
322:06 - you wanted to return a value and return
322:08 - back another value at the same time then
322:10 - what are your options so let me show you
322:12 - a quick example when you're using int.
322:14 - tripod we have a string s an out in
322:18 - result and a bull so what this function
322:20 - is effectively doing is return you back
322:23 - a true or false value to dictate whether
322:25 - or not the conversion has been
322:27 - successful and it's also returned you an
322:29 - out into result and what what this means
322:31 - is you can actually specify integer
322:33 - variable straight inside the brackets so
322:35 - in essence this function has gave you
322:37 - back two values it's gave you back
322:40 - something from the integer parameter and
322:41 - it's also returned back a Boolean
322:43 - variable so let's convert this to code
322:45 - and see what the third option is of
322:47 - trying to return back five over to this
322:50 - so if we just comment out this line and
322:52 - as you saw in the trip pass you simply
322:54 - just need to put the word out just
322:56 - before
322:57 - here out in Num
323:01 - now we don't actually need to return
323:02 - anything in this specific example
323:04 - because we want to just change a num
323:06 - variable using the out parameter but if
323:09 - we wanted to return something separate
323:10 - to the num like a booing like the tri
323:12 - pass did then we have that option so we
323:14 - can return back true but just before we
323:17 - return back true as there's a red
323:18 - underline here it will say that the out
323:20 - parameter gome must be assigned so we
323:23 - need to give num a
323:24 - value we give it the value five because
323:27 - what we're actually doing here even if
323:29 - we double click on this we'll still
323:30 - still get none being selected here cuz
323:33 - the scope is still exactly the same now
323:35 - except what's happening is when this
323:37 - variable gets returned it actually gets
323:39 - put into the variable that it was
323:40 - initially called with so let's fix these
323:42 - compiler errors first so the reason why
323:44 - it's complaining is because we need to
323:46 - give it the out keyword so when we're
323:48 - specifying in Tri pass our first
323:50 - parameter is a string so if the user
323:51 - types in 1 2 3 we put in the first
323:53 - parameter and then we'd say out in
323:56 - result or something along them lines you
323:58 - have an out and then you say you want to
324:00 - make a new integer and you want to call
324:02 - a result see in our case we don't need
324:04 - to put int just like in here because
324:06 - we've already created our num so the
324:08 - only keyword we need is out to follow by
324:10 - space and now of course we're trying to
324:12 - assign this back into an integer which
324:15 - we don't need anymore because this is a
324:16 - booing so we can say bu
324:19 - success equals test out n so we print
324:22 - out
324:24 - Success Print them both the screen now
324:26 - we should have five and true the true
324:28 - comes from the return true and the five
324:30 - comes the num equals 5 so what's
324:33 - actually happening here is we're
324:34 - creating our new integer we're passing
324:36 - it into this function we're also telling
324:38 - you it's going to be an out parameter so
324:40 - this function can still output things to
324:42 - our number variable and then when it
324:44 - gets placed inside here we assign Nome
324:46 - equal to five and then just because we
324:48 - have a bull we have to return true or we
324:50 - can return false of course we can just
324:53 - take this out completely take away the
324:55 - return true and just keep this as
324:57 - test of course in both scenarios these
325:00 - aren actually do anything they're just
325:01 - complete random values it's just made
325:03 - for demonstration so bu is returned back
325:06 - true or false doesn't actually mean
325:07 - anything I was just demonstrating that
325:09 - you can have two return values from one
325:11 - function there we go we get five when we
325:13 - run it just like this so now I've
325:15 - completed this little example let's have
325:17 - a look at how it's used in the real
325:18 - world so before we continue let's see if
325:20 - we can rewrite the tripal function in
325:23 - our code so it's going to be a static
325:25 - returns back a we have a triy pass our
325:27 - first parameter is a string s and our
325:29 - second parameter is out out into result
325:32 - and inside there we can just do result
325:35 - equals to zero and then we can return
325:37 - back true of course we actually need to
325:38 - do conversions inside here if you want
325:40 - this function to work but I'm just
325:42 - showing you for demonstration purpose if
325:44 - we uncomment this line out and have a
325:45 - look at the parameters again you'll see
325:47 - that now they line up perfectly string s
325:50 - out in result and it returns back a Bo
325:52 - which we have exactly the same here
325:54 - there you go bu in. trass string s out
325:57 - in result so that's how this function
325:59 - has been declared of course they're
326:01 - doing something inside the body that can
326:03 - take in the string convert it to an
326:04 - integer place it inside result and then
326:07 - return whether or not the function has
326:08 - been executed successfully so now that
326:11 - we understand how to make an example and
326:13 - how to make the trip pass function
326:14 - ourselves and to give you the
326:16 - Declaration let's have a look at a real
326:17 - world example so if we had a list of
326:20 - string and we had our shopping list that
326:22 - was used from the examples we can have
326:24 - list string and let's just create our
326:27 - own initializer just with coffee and
326:28 - milk
326:29 - inside there we go so now that we've
326:31 - created that we've got our shopping list
326:33 - if you wanted to find something inside
326:35 - the shopping list we have the function
326:36 - index of and what that will do as it
326:38 - says here searches for the specified
326:40 - object and Returns the zero based index
326:43 - of the first occurrence so if we were to
326:45 - search for coffee then we should get
326:47 - return back zero so let's try and run
326:50 - this and put it in the console right
326:51 - line and see what the value is there we
326:53 - go we get zero since it's the first item
326:56 - and if we place milk inside here we
326:57 - should get back one there we go
327:01 - so let's try and rewrite this function
327:03 - into our own code so all this will do is
327:05 - loop around all of the positions until
327:07 - it finds it and it'll find the first one
327:10 - and it'll return us back the index so in
327:12 - this case there's no out parameters but
327:14 - there is a return value so we can also
327:16 - include an out parameter and then
327:19 - instead of assigning the value of minus
327:21 - one we can actually assign the value of
327:22 - true or false to dictate whether or not
327:25 - that we found it so let's write the code
327:26 - normally in here and then let's wrap it
327:28 - around in a function so we can say int
327:30 - index equals minus one because we want
327:32 - it to start a value that we know is
327:34 - incorrect since the lists are from zero
327:36 - onwards the value is only ever minus one
327:39 - then that means it's not in the list
327:41 - then we can then create a for Loop
327:43 - entire equal Z shopping list do count
327:46 - cuz we want to go through every single
327:47 - item inside the shopping list and inside
327:50 - here we want to do a lowercase
327:51 - comparison so we can do if the shopping
327:53 - list square bracket I do to
327:56 - lower do equals and then we want to make
327:59 - that equal to just something that we're
328:01 - going to type in statically so we can
328:03 - just say copy we can make this into a
328:06 - parameter after but this is just for
328:07 - demonstration purposes so we have a
328:09 - bracket and if we found that match then
328:11 - we can say index equals to I cuz the
328:14 - index of the position that we want to
328:15 - find must be up to I cuz that's the one
328:17 - that we've made a match with and we
328:19 - don't need an else inside here we don't
328:22 - need to set an else inside here to make
328:24 - it equal to minus one because if it
328:25 - simply doesn't find it then the index
328:27 - variable won't change its value so it
328:29 - will always stay minus one if it doesn't
328:31 - find anything so after the follow Loop
328:33 - is run let's just print index out to the
328:36 - screen there we go we have zero and if
328:39 - we change this over to milk run it again
328:41 - then we actually have one placed inside
328:44 - here perfect so now what our function is
328:46 - doing is giving us the values of the
328:49 - index if it finds it now if you type in
328:51 - something else if you just add another
328:52 - can let's see what happens then we get
328:55 - minus one and minus one means that it's
328:57 - incorrect and it hasn't found it and
329:00 - what we we can do inside here we can say
329:02 - if the index is greater than minus one
329:05 - then we can say found or else we can say
329:08 - not found so let's run the code now and
329:10 - see if we get a visual representation
329:12 - not found and if we changes back to milk
329:15 - run it again then we get found perfect
329:19 - so as you can see here we're actually
329:20 - checking if the value is greater than
329:22 - minus one but it'd be easier if you had
329:24 - a variable called found and is actually
329:26 - a booing variable so we can make a Bo
329:28 - found and make that equal to and if
329:30 - statement condition so we can say
329:32 - something like index is greater than
329:34 - minus1 which is exactly what we had here
329:37 - a second ago and because this is a
329:39 - condition it's either going to return
329:40 - back true or false and it's going to
329:42 - place the value inside found and then
329:44 - we're going to use found inside here
329:46 - this is easier logic to understand if
329:49 - this is true then it's found if this is
329:51 - not true then it's not found true true
329:54 - false false it's quite really
329:56 - straightforward and very easy and clear
329:58 - you have an index and you have whether
330:00 - not it's being found so let's try and
330:02 - wrap this around inside a function so
330:04 - just as the trip pass does it returns us
330:06 - back with a Bool which in this case will
330:08 - be our found and it also gives us back
330:10 - an integer result but in this case it's
330:12 - going to be our index so let's see what
330:15 - we can do to write this so we can have a
330:16 - static we want to return back the Bo and
330:19 - we can say find in list we need to give
330:23 - it the item we're going to find so we're
330:25 - going to need a string s we need a
330:27 - string s for the item that we're going
330:28 - to find we need to give it the list as
330:30 - well and then finally we need our out
330:32 - int
330:34 - index there we go so let's comment out
330:37 - this code
330:39 - here and let's copy this down into our
330:42 - function and see what we need to do so
330:44 - index has the value of minus one we
330:46 - don't need the integer variable
330:48 - declaration here because we've already
330:49 - declared it inside the parameter so
330:51 - after declaring inside here we give it
330:53 - the value ofus one minus one indicates
330:56 - it hasn't been found since the index are
330:58 - zero based so instead of shopping list
331:00 - we now just have list and list here as
331:03 - well and then instead of having it being
331:06 - equal to milk we actually want to use
331:07 - our s variable and to make it better we
331:10 - can convert it to lower case just so we
331:11 - have lowercase conversions on both sides
331:13 - of the equals if we find a match between
331:16 - the list that we've passed in and the S
331:18 - variable which is our surge term that
331:19 - we've passed in then we assign I to the
331:22 - value of index and then it's still got a
331:24 - red underline because we haven't
331:26 - returned back
331:27 - bu so right now we actually want to
331:29 - return back the found variable so we
331:31 - have two options here we can return back
331:32 - found or we can simply take this and
331:35 - return it back in here we don't need to
331:37 - run this code to see if it's found or
331:38 - not and then store it and then return it
331:40 - after since we're not doing anything
331:42 - else with it we could just return it
331:43 - like this this makes the code
331:44 - considerably shorter because this will
331:46 - just return back a true or false if the
331:49 - index is greater than minus one then it
331:50 - will turn back true if the index is less
331:52 - than minus1 then it will turn back false
331:55 - so let's see how we can use this
331:56 - function inside our code now so we
331:58 - wanted to search for milk so let's just
332:00 - copy and paste this line and let's see
332:01 - if we can get the same output as the
332:03 - shopping list index of so now our
332:05 - function is called finding list you have
332:08 - a bracket and then our string s is going
332:09 - to be our milk our list is our shopping
332:12 - list and our out in
332:15 - index so this is going to return us back
332:18 - with a booing so we can print that
332:19 - booing to the screen and then if we just
332:21 - duplicate that down and we can print
332:23 - index to the screen and maybe using a
332:25 - console right line and just place a
332:27 - space right at the
332:29 - start so we print out whether it's
332:31 - successfully converted or not and we get
332:33 - the value back from
332:35 - it let's run the
332:38 - code so we get true plus the value of
332:41 - one so that means it's found it and it's
332:43 - found it at one index and the previous
332:45 - line before it which just run the normal
332:47 - index of function also return back one
332:50 - so they're both the same let's just get
332:51 - rid of that
332:55 - space so if you change these both to
332:58 - coffee then hopefully we should see the
333:01 - same result but with index zero there we
333:03 - go this zero comes from the index
333:05 - function this true is from our function
333:07 - telling us has been successful and this
333:09 - zero is the index so we can actually
333:11 - take this and put this straight into an
333:13 - if
333:14 - statement so just like we had down here
333:16 - with the found and not found we can say
333:18 - if and then this function call and then
333:21 - we can say found and then the item what
333:24 - we passed in so in this case it's going
333:25 - to be coffee found coffee found coffee
333:29 - at index index and if it hasn't been
333:32 - found then we can just print not
333:35 - found and this is getting an error
333:37 - because we have two indexes up here so
333:39 - let's comment out this line and let's
333:41 - try running out found coffee index zero
333:44 - and you can see these two are the same
333:46 - again one comes from here and one comes
333:48 - from that index we change these both to
333:50 - milk now milk milk and milk then run the
333:55 - code and you see F milk index one if you
333:58 - wanted to just before you pass in here
334:00 - you can ask the
334:02 - user enter an item to
334:06 - search start inside string search equals
334:10 - console.
334:12 - readline and then instead of passing mil
334:14 - in here we can just pass in Search and
334:16 - then instead of passing milk in here we
334:18 - can also use the search variable so now
334:20 - if we try run it again we can type in
334:21 - milk and then we go file milk index one
334:24 - and then coffee found coffee index zero
334:26 - and just to give this a test let's just
334:28 - try and find m not
334:31 - found
334:33 - perfect so let's have a little recap
334:35 - based on this function so initially we
334:37 - tried to assign the value of zero and
334:39 - then print out a normal function and
334:41 - inside test we just had a simple num
334:44 - equals 5 and what this was doing inside
334:46 - is just locally assigning it but not
334:48 - actually return anything and then we
334:50 - said we could assign it and then return
334:51 - it back and that was another option of
334:53 - being able to assign the value to five
334:55 - and then we useed the out parameter
334:57 - which allowed you to pass in an integer
334:58 - when you assign in here it will pass it
335:00 - back into the original call and place it
335:02 - in this variable here so when we print
335:05 - out on the next line it says it's equal
335:06 - to 5 we wrote our own little shopping
335:09 - list for the list of strings and then we
335:11 - called the shopping list function index
335:13 - of and then we actually created our own
335:15 - index of function and made it into a
335:18 - function so just a little recap what's
335:20 - going on here we have a string s which
335:22 - is our search term the list full of the
335:24 - items in the index that we're going to
335:26 - pass back to the user as well as
335:27 - returning back a bu to indicate whether
335:29 - we found found it or not we set the
335:32 - index to minus one so then that
335:33 - completes our logic at the bottom minus
335:36 - one means it hasn't been found since the
335:38 - list is all zero based if this value is
335:41 - greater than minus1 then that means that
335:44 - we found it inside the list since the
335:46 - list is zero Bas and if it's not that
335:48 - and this returns back false then we
335:50 - mustn't have found it because this line
335:52 - would have executed so we Loop through
335:54 - the list we do a lowercase comparison on
335:57 - both sides of the equation on the list
335:58 - item and on the sege term if they both
336:01 - match we run the index and stall the I
336:04 - variable inside the index and then we
336:06 - return whether index is greater than
336:07 - minus one so after we've turned this
336:09 - back from the end of the function we can
336:11 - see once we run it inside the console
336:12 - right Line This is just going to return
336:14 - us back with a true or false value as
336:16 - well as creating our new integer
336:18 - variable called index so on the next
336:20 - line we can use index and print out of
336:22 - the screen this line should return true
336:23 - or false since it's a Boolean return and
336:26 - this variable will either give us minus
336:28 - one or something above minus1 but in
336:30 - this case when we actually make use of
336:31 - the function we can ask a user to enter
336:33 - something get them to type it in and
336:36 - pass that into the function but more
336:37 - importantly when this function returns
336:40 - if it's true we output it's been found
336:42 - and if it's false we output not found
336:45 - and we only make use of this integer
336:47 - variable should this return back true
336:49 - there is no point in printing minus one
336:52 - to this screen because that's what
336:53 - you're going to get if it's not
336:55 - found it's going to look something like
336:57 - this which is kind of redundant because
336:59 - the user doesn't care about this so we
337:01 - don't need to include it when we're
337:02 - printing not found but we should include
337:04 - it when we're printing out the found of
337:06 - course this is just a random example and
337:07 - you might not need to print it out to
337:09 - the screen or you might just do
337:10 - something else inside here you might be
337:12 - searching for something and then you
337:14 - might want to edit it or do something
337:15 - else with it and then you can make use
337:17 - of that index if you wanted to ask the
337:19 - user to search for an item and then tell
337:21 - them what they want to replace it with
337:23 - then you can also do that just as we've
337:25 - covered in the last
337:28 - examples so after after we've covered
337:30 - out parameters and normal parameters
337:32 - let's have a look at a concept called
337:33 - passing by reference so we created
337:35 - interm equals 10 and let's call it
337:37 - assign and we passed it straight into
337:39 - here and we can have a static void
337:43 - assign in
337:45 - N if we say Nome equals 20 if we use a
337:48 - console right line up here then Nome is
337:50 - still going to be 10 because we're not
337:53 - returning it and we're not really
337:54 - affecting it now other ways we can do
337:57 - this is by changing this into an INT and
337:59 - then we can say return 20 and then we
338:02 - don't really need this anymore so we
338:04 - could just say
338:05 - num num equals a sign and then we'll get
338:08 - 20 assign back in there we go or we can
338:11 - actually make this an out into num and
338:14 - then we can say num equals to
338:17 - 20 and then inside here we can say out
338:20 - num we don't need to return back in
338:22 - anymore so we can make this Vol and you
338:24 - see the value 20 so there are different
338:26 - ways that we can assign a variable
338:28 - straight from here so let's let's have a
338:29 - look at another method so instead of
338:31 - having out we can actually use a new
338:33 - keyw called ref and the reason why it's
338:35 - ref it means it's passing it by
338:37 - reference so when you pass a value in
338:38 - through a parameter normally you're
338:40 - actually passing by value and what that
338:42 - means is you're copying this value that
338:44 - gets passed inside the brackets into
338:47 - here and it's making a whole new
338:48 - variable what I mean by that is this
338:51 - might have memory dress location one and
338:53 - then when this variable gets created it
338:55 - has memory dress location 2 for example
338:57 - and then it's used within here and then
338:59 - two is now deleted because you've got
339:01 - rid of the variable because of this
339:02 - function but one is still alive since in
339:05 - the main function when you pass by
339:06 - reference what you're doing is you're
339:08 - saying give me the memory address
339:10 - location of the variable inside the
339:11 - brackets and give it into this function
339:14 - rather than copying the value so if this
339:15 - has memory just location one and you
339:17 - pass it into here then it's also going
339:19 - to have one so what this actually means
339:21 - is if we put this ref keyword just
339:23 - before the in just like we do with the
339:25 - out and we can place it here as well
339:27 - we're now saying we want to pass this by
339:29 - by reference so when this 10 gets passed
339:31 - in here we actually have a link if you
339:34 - will to this gome is now linked to this
339:36 - gome which means if we simply do n
339:39 - equals 20 and run the code then we're
339:41 - going to see 20 the main differences
339:43 - between reference and using the out
339:45 - keyword is when you're using out within
339:47 - a function you actually need to make use
339:50 - of the value if I don't include anything
339:52 - within here then I'm going to get
339:53 - exception and it says the out parameter
339:55 - num must be assigned so when using the
339:58 - out keyword num has to be assigned when
340:01 - using the ref keyword you don't have to
340:03 - make any assignment because we're just
340:05 - passing a reference in with the out
340:07 - keyword you literally tell the function
340:09 - I want to Output this value but if you
340:11 - haven't gave it a value to Output then
340:13 - of course it's going to be an error so
340:14 - we can assign in the reference if we
340:16 - really want to but you don't have to and
340:18 - it's not required so there are the two
340:20 - main differences between passing by
340:22 - reference and passing by value and also
340:24 - using the out parameter passing by
340:26 - reference is technically quicker because
340:28 - of efficiency when you don't pass it by
340:30 - reference you pass it by value which
340:32 - means it'll essentially place that 10
340:34 - inside these
340:35 - brackets instead of passing the variable
340:38 - in it actually just passes the value and
340:40 - then it makes a whole new variable down
340:42 - here when you pass it in by reference
340:44 - you're essentially actually giving it a
340:46 - link to this memory address location
340:48 - from inside this function which means
340:50 - that you don't actually have another
340:52 - local variable inside here because this
340:54 - one is affecting this one directly you
340:57 - can do this with any amount of
340:58 - references you want by simply just
341:00 - changing them and adding another one in
341:02 - like that for example and then we can
341:04 - have a string name and then we can pass
341:07 - our ref name inside here and inside here
341:10 - we can say name equals hour and this
341:13 - doesn't like it if it's unassigned so we
341:15 - just give it empty quotes or we can sign
341:17 - it another name it doesn't really matter
341:19 - it's just a demonstration and if you run
341:21 - that but let's just print out the name
341:23 - as well to the
341:24 - screen there we go we get Abra assigned
341:27 - into
341:28 - there and same thing with this variable
341:30 - is we're actually just passing in the
341:32 - variable as a reference rather than as a
341:34 - value it doesn't matter what the value
341:36 - is going to be CU it's just given this
341:38 - variable inside this function so we're
341:40 - actually saying name equals we'll
341:42 - basically just assign it back into the
341:44 - original variable so let's just have a
341:45 - look at another example so we can have
341:47 - some sort of like change name function
341:49 - and we can give it the name variable as
341:51 - a reference and then we can give it the
341:53 - new name that we're going to pass in in
341:54 - a second so if we make a new function
341:56 - static void change name you're going to
341:58 - need a ref string name and a string new
342:01 - name and we can simply say in here name
342:04 - equals new
342:05 - name perfect so let's give this a shot
342:08 - so if we just comment out this little
342:10 - section and we can say console right
342:14 - enter your new name then we have a
342:16 - string new name equals console.
342:20 - readline and then just up here as we've
342:22 - done before we could just declare the
342:23 - name as being Joe and then we enter the
342:26 - new name call this function and then
342:28 - after we can say
342:30 - your new name is and then we can pass in
342:33 - name perfect let's run
342:35 - that so at this point the name is
342:37 - actually Joe cuz we've made it appear
342:39 - and then we'll enter a new name so we
342:40 - can type in abber now it says your new
342:43 - name is abber perfect so all this
342:45 - function is doing I know it's pretty
342:47 - pointless right now cuz it's just doing
342:48 - one line but all it's doing is assigning
342:51 - the reference to the variable that we
342:52 - pass in so what we can do now is make
342:54 - sure that we can actually assign this
342:56 - variable in and we can also pass in a
342:58 - Boolean variable so what we should do
343:00 - now is actually make sure that we can do
343:02 - the assignment properly cuz you don't
343:03 - want to assign it if the value is empty
343:05 - and then return back a booing type just
343:08 - to indicate whether or not it's being
343:09 - assigned so what we can do in here is
343:11 - just on the change name we can wrap this
343:13 - around an if statement and if this
343:15 - returns back true then your name has
343:17 - been changed and if not we can say
343:20 - console right Line new name cannot be
343:22 - empty or
343:24 - no in order to be able to do this check
343:27 - as we've used before we could say if new
343:30 - name and then just around that we can
343:32 - say string do is n or empty and wrap
343:34 - that inside the brackets and we want to
343:36 - say if it's not n or empty then we want
343:38 - to do our
343:40 - assignment after we've done our
343:42 - assignment we can return back true
343:43 - inside here and then just outside we can
343:46 - return back false notice how in this
343:48 - little bit of code we actually don't
343:49 - have an else we don't need to write else
343:52 - inside here and place return false
343:55 - inside here because if this returns back
343:57 - true then it's going to execute this one
343:59 - line return back true and since it's a
344:02 - return it's going to jump to the end of
344:03 - the function so we don't need the else
344:05 - in there because the only way that this
344:07 - line will ever execute is if we actually
344:09 - had this function returning back false
344:12 - so if this returns back true it's going
344:13 - to hit this line hit the return jump to
344:16 - the end if this returns back false it's
344:18 - going to skip over the if statement and
344:19 - then just return back false to the user
344:21 - perfect so now we've got no compile
344:22 - errors let's give it a run so we want to
344:25 - change your name to nothing if we just
344:27 - press enter then we can see it says says
344:29 - new name cannot be empty or no and if we
344:31 - type something in then we get our name
344:33 - changed so just to round up this video
344:35 - let's talk about the main differences
344:37 - between the ref parameter and the out
344:38 - parameter when you sign in by reference
344:40 - you actually have to make the variable
344:42 - before you pass it in for example you
344:44 - can't just write ref string in here and
344:46 - that actually works whereas you can't
344:48 - actually do that with the end let me
344:50 - demonstrate so if you had the in. trass
344:53 - and that has an out parameter you can
344:55 - actually type out in index inside here
344:58 - you don't actually have to make the int
345:00 - index inside here and then specify it
345:03 - outside you could just initialize and
345:05 - declare the variable straight inside the
345:07 - brackets whereas because you're passing
345:09 - a reference with the string you actually
345:11 - need to make the string first and then
345:12 - pass it in so that's a big difference
345:14 - between the out and the ref when you
345:16 - make use of it actually inside the
345:18 - function if you're using a reference
345:20 - then you never have to assign it or at
345:22 - least it's not required you could have a
345:24 - series of if statements inside this body
345:26 - and then you might determine that you
345:27 - might not need to assign it which is
345:29 - exactly what we've got here the only way
345:31 - we assign name is if this returns back
345:33 - true if it doesn't return back true then
345:35 - we simply don't assign it and move to
345:37 - here this is a problem if the out
345:39 - variable if we change it to an out then
345:41 - we're going to get a compiler error
345:43 - because it doesn't return back a value
345:45 - so we'd have to write something like
345:46 - this at the top name equals something
345:48 - and then potentially sign it here and
345:50 - then return back false so with reference
345:52 - you don't have to worry about the fact
345:54 - that you might not assign in every
345:55 - single path of your code and finally the
345:58 - main difference is the fact that out
345:59 - parameters are still used by value and
346:02 - this is by reference reference will be
346:04 - slightly quicker since you'll get the
346:05 - memory just location being passed in
346:07 - instead of the values so you won't have
346:09 - two copies of the same
346:12 - variable the focus of this task is to
346:15 - create a function that calculates the
346:16 - area of a triangle so we're going to ask
346:18 - the user for width and height install
346:20 - them both create a function to calculate
346:21 - the area the function is going to
346:23 - calculate it using width times by height
346:26 - taking that calculation and dividing the
346:28 - value by two call it in the main and
346:29 - print out the area of the triangle to
346:31 - the screen so let's start with entering
346:33 - the width and the height so we can say
346:35 - enter width
346:36 - callon and have int width equals convert
346:40 - to int
346:42 - 32 console do read line and if you copy
346:46 - these
346:47 - down change width to height and change
346:50 - width here to height and just before we
346:52 - continue because we did copy and paste
346:54 - down then this is quite bad and we
346:56 - should use a function here so in both of
346:58 - the cases we're going to output
346:59 - something to the console and then read
347:00 - it in and convert it back as an integer
347:02 - so we it says static int because we
347:04 - return back an integer so we can store
347:06 - it we can say read int and we want a
347:09 - string message so we can pass in this
347:11 - value inside
347:12 - here so we take these two lines and
347:15 - place inside here instead of enter
347:18 - height we're now going to have message
347:19 - instead of int height we're just going
347:21 - to have a return value and then we're
347:23 - ret return in the conversion from the
347:24 - console read line and now we can use it
347:26 - inside here read in and inside inside
347:28 - the brackets you want to put the string
347:30 - output which is going to be enter height
347:32 - if you paste that inside here and then
347:34 - do the same thing for the previous
347:36 - section and change height to width and
347:38 - now get rid of these so we just have
347:40 - these two lines perfect so let's just
347:42 - print these out to the screen on
347:44 - separate lines just to make sure it's
347:47 - working see the width of 10 and height
347:50 - of 15 we get 10 and 15 Perfect Since
347:52 - that's working okay we can now create a
347:54 - function that can calculate the area
347:56 - forward so we can get static int Cal
347:59 - area and we can have int width and in
348:05 - height and then taking this formula we
348:07 - can simply just do return bracket width
348:10 - times by height / two as you can see
348:13 - this is literally exactly the same as
348:15 - what we've got here it's crucial to
348:17 - include the brackets because we want to
348:19 - do this calculation first take the value
348:21 - of that and divide it by two if this is
348:23 - too many steps you can actually break it
348:25 - down we can say in calculation is equal
348:28 - to to the width times by the height and
348:30 - then we can simply return calculation /
348:33 - two back to the function it's slightly
348:35 - grayed out because we haven't use it but
348:37 - that's not a problem we're going to use
348:38 - it now I personally just to prefer is to
348:40 - keep that inside here and just have the
348:42 - brackets since a bit more obvious to me
348:44 - what's going on but it's up to you as
348:46 - the programmer either way it makes no
348:48 - difference it's just more for the
348:49 - programmer's convenience so now we need
348:51 - to call the function above so we can say
348:53 - in result equals calc area and then pass
348:56 - in the width and pass in the height and
348:58 - then we can have console right line that
348:59 - just says the area is and then result
349:02 - and then let's run it so you have 10 and
349:05 - 15 and there we go we get the area is
349:07 - 75 perfect if you didn't want to call
349:10 - the function inside here and St it
349:11 - inside a variable you could just output
349:13 - this straight to the screen by placing
349:15 - the function calls straight in the cly
349:16 - braces and if you run that again just to
349:18 - make sure 105 and we get 75 again
349:22 - perfect so just a quick little recap we
349:24 - have the console right plus the convert
349:26 - inside this function which will let us
349:28 - return is back an integer and we can
349:30 - pass in the message straight in the
349:31 - variable to make this a little bit
349:32 - quicker and a bit easier you can
349:34 - actually just change this one word
349:35 - inside here so you could actually say
349:38 - enter message call on space and then
349:41 - just inside here you can say height and
349:43 - just inside this one you can say width
349:45 - just to reduce on code because in this
349:47 - specific case the only thing that
349:49 - changes between them two string
349:50 - variables was the fact that one was
349:52 - width and one was
349:53 - height there we go you can see it's
349:55 - exactly the same now so after we read in
349:58 - these two variables we pass it into the
350:00 - function and all the function will do is
350:02 - take width and height times them both
350:04 - together take that value and divide it
350:06 - by two and return it back to the user
350:08 - and then we can call it straight in here
350:09 - the area is calc area and pass in width
350:11 - and
350:15 - height in this task we're going to
350:16 - create a function that will return us
350:18 - back with the sum of numbers inside an
350:20 - integer array so first step is to create
350:23 - an initialize an array of numbers create
350:25 - the function with the int return type
350:26 - and it also takes a int array as a
350:28 - parameter the function should return a
350:30 - total of all the numbers inside the
350:32 - interray call in the main output the
350:35 - total and just for extra bonus points
350:37 - inside the function instead of using a
350:39 - for Loop immediately you can check if
350:41 - the array length is greater than zero
350:43 - and then return minus one if it's empty
350:45 - and then check that inside the main and
350:47 - then output a specific message and also
350:49 - see if you can think of any other
350:51 - implementations you can use instead of
350:53 - having to do return minus one how else
350:55 - can you make this function whether that
350:56 - means you have to change the parameters
350:58 - of return type or anything like that
351:00 - just have a think about the situation
351:01 - and see what other options you can make
351:03 - of course the output at the end is still
351:04 - going to be the same but it's the way
351:06 - you do it and the problem solving skills
351:08 - that I'm trying to get you to get used
351:09 - to let's get started so let's create
351:11 - initialize an array of numbers so you
351:13 - have int numbers equals new int and
351:16 - let's just allocate them manually 1 2 3
351:18 - 4 5 and add a semicolon there we go now
351:21 - let's create the function sum of
351:24 - numbers and we want it to return integer
351:26 - back with the total then we want to take
351:28 - an in Array called
351:30 - numbers and then inside here we need to
351:32 - actually return back an INT so we can
351:34 - create an in total make that equal to
351:36 - zero and at the end we can return total
351:39 - and then during the middle we're going
351:40 - to have to write our for Loop so we can
351:42 - go through the integer array and count
351:43 - through everything so we can use a for
351:45 - each V item inside our numbers and just
351:48 - inside here we can say total plus equals
351:51 - item perfect so if we can call in here
351:54 - we can have a console right line and we
351:56 - can just say sum of numbers and pass our
351:58 - numbers array in the parameters so we're
352:00 - just going to Output it to the screen
352:01 - just for the time
352:02 - being so sum of values from zero all the
352:05 - way till 5 is 15
352:08 - perfect so now that we've done that
352:10 - we've created a function that Returns
352:11 - the total numbers call it in the main
352:13 - output the total so we can just say the
352:15 - total the total is and then wrap this
352:19 - around in the C
352:20 - brace there we go the total is
352:23 - 15 now with the extra points we can
352:25 - check the ray length and return minus
352:27 - one if if the array is empty so let's
352:30 - see what we can do in here before we
352:31 - even end up going inside anything to do
352:33 - with the total we can wrap this around
352:35 - in if statement that says if the numbers
352:37 - do length is greater than zero then we
352:39 - can proceed with this little section so
352:41 - if we highlight all of this hold alt and
352:43 - press upar key then because it's one
352:45 - back just press tab ones and just press
352:47 - the delete key here and let's get rid of
352:48 - the empty Line This is going to return
352:50 - us back with an error because not all
352:52 - code path return a value if this returns
352:55 - back true then we'll eventually hit a
352:57 - return but if this return Z false then
352:59 - we not do anything inside here so let's
353:01 - have a look at our requirements return
353:03 - minus one if the array is empty this
353:06 - dictates whether the rray is empty so if
353:08 - this returns back false then it's going
353:09 - to come into here and we can say return
353:11 - minus one so we've got this function
353:14 - call in here we don't want to print the
353:16 - total right now because we want to make
353:18 - sure that this total is actually greater
353:20 - than zero because we don't want to make
353:22 - a sum of the numbers if the array is
353:24 - empty so if you run this right now going
353:27 - to get the total is 15 and if we get rid
353:29 - of all these variables and just have the
353:31 - length of five but not give it any value
353:33 - so all the values are going to be zero
353:35 - then if we still run that then the total
353:37 - is going to be zero but that's still an
353:38 - acceptable value because that's actually
353:40 - got values
353:41 - inside but if you said the array length
353:44 - is zero then the total is minus one of
353:46 - course we don't want the user to see
353:48 - minus one so we want to bring this back
353:51 - and instead of calling the function
353:52 - immediately down here let's call it here
353:55 - we can say int result is equal to this
353:58 - and then we can say if the result is
354:00 - greater than minus one then we can
354:02 - output the total and again press into
354:04 - this line hold alt and press Arrow
354:06 - key and then we can place the result
354:08 - inside here and the L's to this will be
354:11 - canot add up and empty aray there we go
354:15 - so now if you run it we should still see
354:17 - 15 but if we get rid of this and put it
354:19 - back to
354:20 - zero there we go we cannot add an empty
354:24 - array so we bring that back perfect so
354:27 - now if we check this we've got check in
354:28 - the main output the message and then now
354:31 - we've got this little solution do we
354:33 - need to return minus one how else can we
354:35 - make this so right now we're going to
354:37 - have to return back minus one cuz that's
354:39 - the only way that we can tell the user
354:41 - whether or not it's been successful if
354:43 - the ray is empty we return minus one and
354:46 - if the ray is not empty then we return
354:47 - something greater than minus one which
354:49 - will be something above zero or Zer
354:51 - itself but as long as it's greater than
354:53 - minus one that's how we know it's
354:54 - complete but we don't actually want to
354:56 - do this we want to be ideally returning
354:59 - back a Boolean so let's duplicate this
355:01 - function and show you both
355:03 - implementations let's change this into
355:06 - a and then because we're still going to
355:08 - need to reference the total we're going
355:09 - to have an out in total so we need to
355:12 - change up a few things inside here
355:14 - instead of this return minus one we can
355:16 - do return false to indicate that it
355:18 - hasn't been successful instead of
355:20 - returning back total we can actually
355:21 - just return back true now we haven't
355:23 - done everything yet we don't need to
355:25 - redeclare in total inside because we
355:27 - already declared it inside here so we
355:29 - could just initialize total to equal to
355:31 - zero but the problem here is if we make
355:34 - total equal to zero just within this
355:36 - path then it's still going to complain
355:37 - that total must be assigned so we can
355:39 - take this and just assign it right at
355:41 - the start of the function just like that
355:44 - there we go so we make total equal to
355:46 - zero that gets rid of the compil errors
355:48 - and gives it a value the reason why we
355:50 - have to give it a value is because this
355:51 - out in parameter doesn't like it if you
355:54 - don't assign the value that is a
355:55 - requirement for using the out parameter
355:57 - so make total equal to zero check the
355:59 - numbers length If This Were to return
356:01 - back false then we return false to
356:03 - indicate that we can't do anything if
356:06 - this returns back true it will go
356:07 - through and count all of the items place
356:10 - inside total and then return back true
356:13 - so let's have a look and see what else
356:14 - we can write this little section of code
356:16 - so instead of having to call inside here
356:18 - and use it within there then we can
356:20 - actually do this another way the reason
356:22 - why we actually calling this straight
356:23 - inside here is because we can't place
356:25 - this straight into here since it returns
356:27 - returns us back with an integer and now
356:29 - that is actually fine if that returns
356:31 - back with integer cuz as you can see
356:32 - there's no problems here the issue
356:34 - arises is when we have our result
356:36 - variable we can use it inside the
356:37 - bracket and down here there's no point
356:39 - in calling this twice to get the same
356:41 - value although this would still
356:43 - technically work but this is not really
356:45 - efficient since you calling the function
356:46 - twice it's best to call it
356:49 - once store the value and then make use
356:51 - of it twice when we use our out
356:54 - parameter you'll see that this gets a
356:55 - bit easier so straight inside the if
356:57 - statement we can say sum of numbers and
356:59 - then we can pass in our numbers and then
357:01 - space out into total and what that'll do
357:04 - now is because this returns us back with
357:06 - the bull we don't need any additional
357:08 - conditions like we have one here cuz
357:09 - this will turn us back with a true or
357:11 - false true if it succeeds false if it
357:14 - doesn't so we don't need to say if it's
357:16 - greater than minus one because we don't
357:17 - actually care about the value of the
357:19 - total right now we just care if this
357:20 - returns back with true or false so
357:23 - inside here we can take this same output
357:24 - message and instead of having result
357:26 - here we can have total
357:28 - and then we can take this exact L
357:30 - statement and place it here and let's
357:32 - see what happens now the total is 15 and
357:35 - the total is 15 so they're both return
357:37 - back the same values let's add something
357:39 - else on here just to make sure it works
357:41 - there we go so you can see that both
357:43 - these Solutions look very identical but
357:45 - one is considerably different we have to
357:47 - make a variable outside use inside here
357:50 - and use inside here whereas in this
357:52 - function we can actually just call the
357:53 - function straight inside that will
357:55 - process our new out into total and then
357:58 - we can simply use total inside here and
358:00 - we don't have to require another
358:01 - additional variable just outside here as
358:04 - this one will and you can see that the
358:06 - functions is a little bit better because
358:08 - we're returning true and returning false
358:10 - to indicate whether or not it's been
358:11 - successful whereas in this solution we
358:13 - have to return back an arbitrary value
358:15 - and then check that in the console the
358:18 - reason with returning minus one is kind
358:20 - of a problem is what if these numbers
358:22 - are actually all negative then this
358:24 - value is going to be very bad this can
358:27 - only read work if all of these values
358:29 - are positive if you had negatives for
358:32 - all of these and we tried running the
358:34 - code there you go this is a major issue
358:37 - cannot add up an empty array well it's
358:39 - not the fact that it is empty it's the
358:41 - fact that these values are smaller than
358:43 - minus one so you don't actually want to
358:45 - be going with something like this
358:46 - approach where you're comparing the
358:48 - value because you don't know what
358:50 - numbers are going to be typed into here
358:51 - if the user were type in positive or
358:53 - negative you want to provide a solution
358:55 - just like this one that works for either
358:57 - positive or negative you don't want to
358:59 - restrict that by checking if it's
359:01 - greater than minus one will only works
359:03 - if all of these are positive values all
359:05 - this is an index for the array since
359:07 - arrays start at zero and go upwards you
359:09 - can't have a negative -1 array position
359:11 - but in terms of numbers that are
359:13 - randomly typed inside of a ray you
359:14 - should always be wary of using this
359:16 - option because if some of them are
359:18 - negative then this could return back
359:20 - false so let's just have a quick recap
359:23 - so we have an integer array we have our
359:25 - values initialized down here and then
359:27 - the first solution we call the function
359:29 - pass in the numbers array get our result
359:31 - back check if it's greater than minus
359:33 - one then that means it's been successful
359:35 - so we print it out and else we tell it
359:37 - it's an empty array now second option we
359:40 - actually call the function because it
359:41 - returns back a booly in this case so we
359:43 - can place it straight inside the if
359:44 - statement and then we can pass in the
359:46 - numbers array and then we have it out in
359:48 - total which will give us the total and
359:50 - in this case we don't need to check the
359:51 - value because this returns us back with
359:53 - the true or false and in this case true
359:55 - determines whether it's been successful
359:57 - and false it doesn't if it returns back
359:59 - true then it has some values inside the
360:01 - numbers array that we can actually add
360:03 - up and if it returns back false then
360:04 - that means the array is empty so let's
360:07 - have a look at the implementations so
360:09 - without the out parameters this is the
360:10 - first solution up
360:12 - here we get the numbers length check if
360:14 - it's greater than zero if it's not we
360:16 - return minus one make a new variable
360:18 - called total make equal to zero and we
360:20 - run a for each Loop of our item inside
360:22 - the numbers and we just say total plus
360:25 - equals item add them all up in the for
360:27 - Loop and simply return the total and
360:29 - then in the out solution we have a total
360:32 - equals zero which just initializes this
360:34 - variable otherwise we'll get a compile
360:35 - error then we can say if the numbers is
360:37 - greater than zero then we can say if
360:39 - numbers. length is greater than zero
360:41 - then we can do the for Loop and return
360:43 - back true and if this turn back false
360:45 - then we can say false inside here and
360:47 - then when we use it straight in the
360:49 - brackets we have access to it straight
360:50 - away since it uses a Boolean variable
360:53 - and then our value will be placed inside
360:54 - our out into total parameter which is
360:57 - used down here for the output to the
360:59 - screen and again if this returns back
361:01 - false then it will say cannot add up an
361:03 - empty array and then we hit the console
361:04 - read line and way at the end there we go
361:07 - that covers everything inside
361:09 - here exceptions are used to prevent your
361:11 - code from crashing and then the program
361:13 - closes down let's have a look at a very
361:16 - very common example let's have a console
361:18 - right and we can say enter a number and
361:21 - then we can use int Norm equals convert
361:24 - to int 32 and then we can have a
361:26 - console. readline inside here and let's
361:29 - just print out number to the screen now
361:31 - if we assume everything goes well and we
361:33 - actually enter an integer like 15 and we
361:35 - press enter then we simply get 15
361:38 - returned and as we saw in the past when
361:40 - we covered the trass function if you
361:42 - enter anything else that's not exactly a
361:44 - number then you get again exception
361:47 - exception unhandled unhandled means that
361:49 - we haven't wrote anything specific that
361:51 - will handle this exception so it's
361:53 - causing the program to close it's a
361:55 - system. format exception it says the
361:58 - input string was not in a correct format
362:00 - so this is a format exception because
362:01 - we've entered in a very weird set of
362:04 - characters that can't be converted over
362:05 - to an integer so now our program is
362:08 - forced to crash and now rest of our code
362:10 - is going to be deleted now because it
362:11 - won't be able to run so if you had any
362:14 - important data that was stored just
362:15 - before this point then it is now lost
362:17 - this is very crucial because if you have
362:19 - a system that rides to a database or it
362:21 - stores some very important information
362:23 - that someone's typed in you want to
362:24 - handle the exceptions so if something
362:26 - were to arise it doesn't actually close
362:28 - the program down and they lose all of
362:30 - their data I'm sure you've had it in the
362:31 - past where you've tried to do something
362:33 - and the program comes up in Windows and
362:35 - it says this program had to stop
362:37 - responding when that normally comes up
362:39 - it means that Something's Happened
362:40 - that's so fatal that the program cannot
362:42 - continue it has to crash down and in
362:44 - most cases this is what's called an
362:46 - exception so if we run this code again
362:48 - let's have a look and see what else we
362:49 - can do to make this code break so of
362:51 - course as you heard before a num integer
362:54 - can only survive up to about 2 billion
362:56 - numbers so if we enter a number bigger
362:58 - than that let's see what happens then we
363:00 - get an overflow exception value is
363:03 - either too large or too small for an
363:05 - in32 of course this number is very big
363:08 - and only a long would handle something
363:10 - like this an integer definitely won't so
363:12 - these are the kind of exceptions where
363:14 - you'd have to handle it yourself
363:16 - manually otherwise your program is going
363:17 - to crash coming up next we're going to
363:19 - go through the ways that we can handle
363:21 - these and make sure programs don't come
363:23 - to a halt exactly like these
363:26 - examples
363:28 - I want to explore a technique called TR
363:30 - catch this is very similar to when we
363:32 - use the int. trass what this essentially
363:35 - does is it tries to do something and it
363:38 - lets you know if something went wrong
363:40 - this is exactly the same when we're
363:41 - dealing with exceptions except when
363:43 - we're doing a try catch what the catch
363:46 - means is catching the exceptions that
363:47 - happen and therefore it is now a handled
363:50 - exception instead of unhandled exception
363:52 - so before we try and fix how this works
363:55 - let's just explore the syntax so we can
363:57 - type in try followed by curly brace and
363:59 - just after this curly brace we can say
364:01 - catch then we're going to put something
364:03 - inside the brackets and then we have an
364:05 - opens brackets if you wanted a quick
364:08 - shortcut to this just like we've done
364:09 - the for Loop and we double tap tab we
364:12 - can actually delete this so you can type
364:13 - in try and press tab twice and then you
364:15 - get try the Open brackets you get the
364:17 - exception and then we get throw so let's
364:20 - get rid of this and what we can do right
364:22 - now is we can actually place the Corde
364:24 - that we want inside here inside this Tri
364:26 - bit
364:28 - because we're telling the compiler that
364:29 - we want to try to do the things inside
364:31 - here and then we want to catch these
364:33 - things so inside these brackets what you
364:35 - want to actually do is decide what thing
364:38 - that you want to catch if you type in
364:40 - exception this will catch every single
364:43 - exception now the problem with that is
364:45 - you'll actually face some difficulties
364:47 - when you're trying to Output very very
364:49 - specific messages so as we've said
364:51 - before when you type in a value too
364:53 - large you get an overflow exception but
364:55 - when you type a value that can't be
364:57 - converted like a square bracket then you
364:59 - get an input format exception so first
365:02 - what you actually want to do is run this
365:04 - code outside the try and let's run it
365:06 - now and let's get them bad values so we
365:09 - had the square brackets and we can get
365:11 - this and let's copy it down and place
365:13 - inside a comment just like this and then
365:15 - let's rerun
365:17 - it and if you type a number too big take
365:21 - this stop the program and put it inside
365:24 - here so now that you know what the
365:25 - exceptions are called we can actually
365:26 - write write these inside the code so we
365:28 - have a form exception and an overflow
365:30 - exception but before we get into these
365:32 - specific exceptions let's just catch
365:35 - everything this is just a catch all and
365:37 - then see how this
365:39 - works so as we've put it back inside
365:42 - here let's see what actually happens so
365:44 - we can just put a console right on here
365:46 - and say something has went
365:49 - wrong the reason why something has went
365:52 - wrong is because this is a catch all any
365:54 - exception appears during this code it
365:57 - will always come into here regardless of
366:00 - what the exception is whether it's a
366:01 - format or an overflow it doesn't matter
366:04 - it will always come into here so it's
366:05 - going to be something because this is
366:07 - not specific at all so let's run the
366:10 - code enter very big number something has
366:13 - went wrong but if you notice how the
366:15 - program doesn't actually clash it's
366:16 - still very much alive and we can test
366:19 - this by putting a simple message here at
366:20 - the end that says goodbye and we run it
366:23 - again enter a big number and there you
366:25 - go we get the message as goodbye
366:27 - so it successfully skipped over this
366:29 - section without actually causing an
366:31 - exception that breaks the program so
366:33 - even though we've entered something very
366:35 - fatle because we've handled it then
366:37 - there's no
366:38 - problems so if we now type the other one
366:40 - where we have the square brackets then
366:42 - you'll see we'll also get something has
366:43 - went
366:44 - wrong so if you wanted to catch a very
366:47 - specific exception what we can do is say
366:49 - catch open the brackets and we can say
366:52 - format exception just like it says above
366:54 - here and then place the curry braces and
366:57 - what you can do now is you can actually
366:58 - chain these and these go from top to
367:01 - bottom when an exception occurs up here
367:04 - it will match this one if it doesn't
367:05 - match it will match this one and you
367:08 - want to put the catch all right at the
367:09 - end so if it doesn't match any of the
367:11 - ones above it it will always match the
367:13 - last one so you can have a generic
367:15 - message inside here but you can have a
367:17 - very specific message inside here
367:19 - because it's a format exception you can
367:21 - say please only enter numbers so now if
367:24 - we run the code and if we type in square
367:25 - brackets it'll say please only enter
367:28 - numbers there we go so this is a very
367:30 - specific example and if we copy and
367:32 - paste this down again and then we can
367:34 - say overl
367:35 - exception and we can say please enter a
367:39 - number less than 2
367:43 - billion if you enter a very big number
367:45 - again please enter a number that's less
367:48 - than 2 billion
367:50 - perfect so this will get checked like if
367:52 - statements it will start on the first
367:54 - one and go down the list imagine this is
367:56 - a if and then we have an lse if and then
367:58 - lse if as well if you place this one
368:00 - right at the start then you're actually
368:03 - going to get compile errors and you
368:05 - can't actually have the catch all right
368:07 - at the start so even if you wanted to
368:09 - the compiler literally doesn't let you
368:11 - and anyway you don't really want to be
368:13 - doing that because then you'll be ruling
368:14 - out these two and it's kind of pointless
368:16 - writing this code if it's never going to
368:18 - get used anyway so now when we run the
368:20 - Corde you can see even if we type in a
368:21 - bad value our program will still run and
368:24 - everything works okay so now what we can
368:26 - do is actually make this into a real
368:28 - life
368:29 - situation so if we actually type in 10.2
368:32 - that it says please only enter numbers
368:34 - then we're going to have an issue here
368:35 - because if we try and print the value
368:37 - down here then it's going to cause a
368:39 - problem let's try and print out num and
368:41 - you can see that num does not exist now
368:43 - we have an issue of scope int is only
368:45 - declared within here and here so if you
368:47 - wanted to print out the value of gome
368:49 - we'd have to print it out up here so now
368:51 - let's run it again and if we enter 20 20
368:53 - comes up if we've entered 15.5 then
368:56 - actually skips over this console right
368:58 - line because the exception occurs right
369:00 - here and then it'll jump into one of
369:02 - these paths so in order to store the
369:04 - value of num you can either move num
369:06 - outside here and make it equal to zero
369:08 - and then assign num inside here and then
369:11 - you can take this console right line and
369:13 - actually put it right after the triy
369:14 - pass but I don't really suggest this
369:16 - option so if you said 15.5 then you're
369:19 - just going to get zero returned but we
369:21 - don't really care about the zero because
369:23 - we're not going to get the value
369:24 - converted so why do we need to print the
369:26 - zero and the answer is we don't so what
369:29 - we should do is keep it all inside here
369:34 - again and then what we should do instead
369:36 - is wrap this around in a while loop so
369:39 - this will try to do the code this
369:41 - section will catch them all and then we
369:43 - simply have a good buy at the end but
369:45 - let's just make sure that this actually
369:46 - runs because if we type in
369:49 - 15.5 then the user still hasn't entered
369:51 - the number but our program is closed so
369:54 - we want to loop around until the user
369:56 - has success successfully enter a correct
369:58 - number so we can say bull looping equals
370:01 - true and we can have while the chord is
370:04 - looping then we can have the curly
370:05 - braces let's place our entire Tri cut
370:08 - inside here if we highlight it all hold
370:11 - alt and press the op power key and then
370:13 - tab it once and then get rid of this
370:14 - empty line so now we'll keep looping
370:17 - around here until this is going to be a
370:19 - different value so because the while
370:21 - loop will only keep looping until this
370:23 - is true and the moment when it's false
370:25 - is when it will cancel while loop so as
370:27 - I said before it when we run this code
370:30 - and then just at this specific line if
370:32 - the exception occurs it will actually
370:33 - skip this line and jumped below here so
370:36 - if it ski this line then what we can
370:38 - actually do is we know if it reaches
370:40 - this line then the conversion is been
370:42 - successful so we can print out to the
370:44 - screen and we can say looping equals
370:46 - false and we don't need to place looping
370:49 - is equal to True inside all of these
370:51 - three paths because if we don't assign
370:53 - it to true then it's still going to be
370:55 - the value false no matter how many times
370:57 - you loop around so let's try and run
370:59 - that
371:01 - now enter a number 15.5 enter a number
371:05 - 15 and we can keep doing this forever as
371:08 - it's a while loop and as soon as we
371:10 - enter a valid character 20 and now it
371:12 - says goodbye because we hit the end of
371:14 - the
371:15 - program so that's it for this video but
371:17 - let's just have a little recap so we've
371:20 - determined when we run our code just
371:22 - these two lines that in both situations
371:24 - we can have a format exception and it
371:26 - all overflow exception we can use these
371:28 - to catch them specific exceptions and
371:30 - then have a catch all at the end the
371:32 - reason why you want to catch multiple is
371:34 - you can have a very specific message
371:36 - overflow dictates we have a number
371:38 - that's too big or too small to fit
371:40 - inside of an integer it can be less than
371:42 - -2 billion or can be greater than 2
371:45 - billion and that's how you get the
371:46 - Overflow exception we get him a format
371:49 - exception if you entered something
371:50 - that's literally not a number or
371:52 - something that has decimal places and
371:54 - then I'll catch all can be if anything
371:55 - else goes wrong we can output a generic
371:57 - message but in 99% of the cases you'll
372:00 - either enter a number too big or too
372:02 - small or it's in the wrong format and
372:04 - this exception is just so it catches
372:06 - everything else should anything else
372:08 - happen so at this point even though our
372:10 - program doesn't actually close and
372:11 - there's no exceptions the user hasn't
372:13 - had a chance to enter the number again
372:15 - so we use this inside a while loop and
372:17 - we can say while looping is true when we
372:19 - hit a conversion that's successful we
372:21 - say looping is equal to false and once
372:23 - it hits this line the Y Loop will then
372:25 - exit and then we'll get our good goodbye
372:26 - message and we wrap the entire TR catch
372:29 - inside the W Loop just so this keeps on
372:31 - looping until the user has typed in a
372:33 - successful value as demonstrated
372:37 - above we can type all this and 15.2 15
372:41 - Point 15 and then finally says 15 and
372:45 - then
372:47 - goodbye so I want to explore different
372:49 - ways you can output messages inside this
372:51 - catch block when you have a catch
372:53 - exception this is actually a parameter
372:55 - that we're passing in this parameter can
372:57 - actually have a variable as well
372:59 - normally when you specify parameters in
373:01 - a function form you say int and then
373:06 - something whereas right now we're kind
373:08 - of defining the data type which is our
373:10 - exception in the same case as in in here
373:13 - but we're actually not giving it a name
373:14 - so it looks something like this of
373:15 - course when we do this inside a function
373:17 - we're going to get a syntax error but
373:19 - for a catch we're not going to get any
373:21 - errors at all and the reason is because
373:22 - we can catch without having to use a
373:24 - local variable so we actually add a
373:26 - local variable make you call it e for
373:29 - exception then we actually have lots of
373:31 - options inside here Type e then we have
373:33 - lots of data and the stack Trace is very
373:35 - helpful when you debuging but we'll
373:37 - cover that at a later date the thing I
373:38 - want to focus on right now is the
373:40 - message so we can use this and print out
373:42 - to the screen so we can say error callon
373:46 - and then type in E message and let's run
373:49 - that now if you enter something invalid
373:52 - input string was not in a correct format
373:55 - if you enter big number then value is
373:58 - either too large or too small for an
373:59 - in32 as you can see these error messages
374:02 - are pretty descriptive and normal users
374:04 - should be able to read this and
374:06 - understand it of course if you want this
374:07 - error message to be more specific then
374:09 - you can add some more catches inside
374:11 - here and we can have format
374:14 - exception this will be if you type in
374:16 - something other than number but if you
374:17 - do exactly the same thing in here then
374:20 - it's kind of redundant because you're
374:21 - just outputting exactly the same value
374:23 - if we try to put the square brackets
374:25 - again then we're going to get this this
374:26 - string which is actually outputed from
374:28 - this line but even if we include the
374:30 - catch all exception you get exactly the
374:32 - same error message outputed from here
374:35 - the moral of the story is you should
374:37 - always have a catch all right at the end
374:39 - of your chain but if the only thing
374:41 - you're going to do inside here is simply
374:43 - output this message to the screen then
374:45 - you don't need any multiple catches what
374:47 - you should do is catch multiple
374:49 - exceptions that you know are going to
374:50 - get fired in your code and then you want
374:52 - to handle them and then have a catch all
374:54 - at the bottom that will display the
374:55 - message generically instead of
374:57 - displaying the message right here you
374:59 - can actually have a more specific
375:00 - message like we covered in the last
375:01 - video so this could be please only enter
375:05 - numbers and we don't actually need the
375:07 - message in this case because we know
375:09 - what exception we're going to catch
375:10 - because we've specified format exception
375:13 - another little tip if you hover over the
375:15 - function call it says here format
375:17 - exception and overfall exception which
375:19 - is the two that we handled in the
375:20 - previous video this is very easy and
375:23 - understandable if you can just read the
375:24 - values from here into see what
375:26 - exceptions can get raised and the same
375:28 - thing here you get an IO exception for
375:30 - the console right line the console right
375:32 - can also give back an IO exception as
375:34 - well generally speaking these console
375:36 - functions almost never return back
375:38 - exceptions I don't think I've ever hit a
375:41 - situation where this exception has been
375:42 - returned unless you do something
375:44 - ridiculous and maybe you type in way too
375:46 - many values that the console right line
375:48 - can handle let's try an example and we
375:51 - can do something like this if you enter
375:52 - a very big number that can't be
375:54 - specified inside an integer then console
375:56 - right line has so many overloads that it
375:58 - actually processes it as a long right
376:00 - now so you almost can't break this
376:02 - unless something fundamental to your
376:04 - computer actually happens so you have
376:06 - exception e and with exception e you can
376:09 - actually take this local variable and
376:10 - print out the message this is the
376:12 - preferred pattern because instead of
376:14 - outputting here something went wrong
376:16 - just very generically you can actually
376:18 - give them the error message that comes
376:19 - back from the exception the reason why
376:21 - this is helpful is because if it doesn't
376:23 - hit any of these exceptions and it just
376:25 - happens to fall into the catch all at
376:27 - least the user has an idea of what the
376:29 - error message is going to be the
376:31 - preferred option is to try get to a
376:32 - point where you never have to reach the
376:34 - catch all and try chain as many catches
376:36 - as you can in order to handle as many
376:39 - exceptions based on the code that you're
376:40 - writing which can be found if you hover
376:42 - over the function and read the
376:44 - exceptions once you've covered as many
376:46 - options as you can throughout the
376:47 - catches then you almost never have to
376:49 - worry about the code entering this
376:51 - section because we've covered both the
376:53 - exceptions in format and overflow and we
376:55 - can do overflow right now please enter a
376:58 - value under 2
377:00 - billion then that means we've actually
377:02 - covered all of the catches that are to
377:04 - do with converting in integer 32 covered
377:07 - format and covered overflow so when we
377:09 - run this code the only two things that
377:11 - can possibly go wrong are these two
377:12 - functions the format exception overflow
377:15 - exception and we won't ever hit the
377:17 - catch all in this case but if anything
377:19 - goes wrong at least we have a belt and
377:21 - Brace option to catch it and we can tell
377:23 - the user what happened and because it's
377:25 - e. message then the value is going to be
377:27 - quite descriptive so the user can read
377:28 - it without any
377:31 - problems so in this task we want to be
377:34 - able to convert a string to an in
377:36 - successfully without any errors
377:37 - occurring and without any exceptions
377:39 - that could break our code so in steps we
377:41 - want to create an INT and try and
377:43 - convert any string from the console to
377:45 - an integer notice the error that appears
377:47 - when you try to do that write a try
377:49 - catch Handler around it to successfully
377:51 - operate that and output the message to
377:52 - the screen and you won't need to change
377:55 - the console out print and convert in 32
377:58 - to be able to make this work so you
377:59 - don't want to change the current code
378:01 - you just want to add the Trion Handler
378:03 - around it so why is this a bad situation
378:05 - how can we know if it's been converted
378:08 - this is just a question that you should
378:09 - keep at the back of your head and we'll
378:10 - answer this shortly and then finally we
378:13 - want to create a custom trip pass
378:14 - function find the real trip pass
378:16 - function and copy the return Titan
378:18 - parameters and see if you can mimic Its
378:20 - Behavior read the tool tip it gives you
378:22 - to give you ideas on what to do so let's
378:24 - take these in steps first first we can
378:26 - have a console right and say enter a
378:28 - number and then int num equals convert
378:31 - to in 32 and then we need a console read
378:35 - line and then if you run the
378:38 - code if we try and just convert some
378:41 - square brackets then we get a format
378:44 - exception so that's the exception that
378:46 - we're going to be handling right now so
378:48 - we can take this code and we can wrap it
378:50 - around in a
378:51 - try use alt and up Arrow key and then
378:55 - just have to do a c and then we want to
378:56 - do a format exception and then space e
378:59 - to give it a variable and then we do e.
379:01 - message out to the screen and now let's
379:03 - run the code square brackets input
379:06 - string was not in a correct format so we
379:08 - get our message and our exception has
379:09 - been successfully handled and our
379:11 - program hasn't crutched but the problem
379:13 - is is has got to this console read line
379:15 - and the user hasn't had a chance to
379:17 - actually enter a number so what we can
379:18 - do in here to ensure the user always has
379:21 - access to writing a number is we can say
379:23 - something like this bu success equals
379:26 - false and then just after here we can
379:28 - say success equals the
379:30 - true and just down here we can say
379:33 - console right line success question mark
379:36 - yay and then call on or
379:40 - no so if it convert it 15 we should get
379:43 - a yay and if we convert it and it fails
379:45 - then we should get an o no along with
379:47 - the message of course what you can also
379:50 - do is wrap this entire section inside a
379:52 - y Loop what we've already covered that
379:53 - inside the tutorial and that means we
379:55 - keep repeating this until this is set to
379:58 - true and therefore exit the while loop
380:00 - and then will the users finally typed in
380:01 - a number so let's go back so we've
380:03 - noticed an error and we've wrot a tri
380:05 - catch handle around it now we want to
380:06 - catch the error and output the error
380:08 - message with through done and then we
380:09 - haven't changed the current code which
380:11 - was these two lines we've added a the
380:13 - booing and set it to True here just so
380:15 - we can have a bit of an output message
380:16 - before so why is this a bad situation
380:18 - how can we know if it's being converted
380:20 - so this code is a bad situation because
380:22 - we just have these two lines outputed
380:25 - and then now that you've added our
380:26 - booing to tell the user whether it's
380:27 - been successful or not is actually
380:29 - making it a bit more meaningful the
380:30 - problem is even if we print or no then
380:33 - the user doesn't really have a chance to
380:34 - enter it again so like I said before you
380:36 - could loop around and use a while loop
380:37 - to make sure that this situation can go
380:40 - from something that gets handled into a
380:42 - situation where the user can actually
380:43 - type it in there's no point hand on
380:45 - exception and realizing there's error if
380:47 - you don't give the user a chance to
380:49 - enter another value if they enter out 15
380:51 - Follow by full stop when they only meant
380:53 - to type 15 then you need to give them
380:55 - another chance to type in that 15 value
380:58 - otherwise the program is simply just
380:59 - going to end and nothing's going to
381:01 - happen for example 15 DOT it says oh no
381:05 - or you can have another message that
381:06 - says something went wrong or you can
381:08 - have more specific message about the
381:10 - conversion and then once you press enter
381:11 - the program simply closes this is not an
381:13 - interaction that you want you want the
381:15 - user to be able to reselect another
381:17 - value so that's why it's a bad situation
381:19 - because you know it's been converted or
381:21 - not use now Bill success but the problem
381:23 - is we don't have any sort of looping so
381:26 - let's have a look so now let's comment
381:28 - out this and let's see how we can make
381:29 - our custom trip pass so we type in in.
381:32 - trass you can see they have a Bo inpass
381:35 - string s and out in result so let's try
381:38 - and copy that and make our own custom
381:39 - function so we say static Bull and then
381:42 - it's trass and then we have a string
381:45 - input and out end
381:49 - result perfect so now we can get rid of
381:51 - this line just so we use it for
381:53 - reference and let's use it straight in
381:54 - here and then we can write the
381:55 - implementation in a second so we can say
381:57 - if try pass the thing that we want to
382:00 - pass is actually a console read line and
382:03 - then we just say out into
382:06 - result and the console read line is
382:08 - going to be answered to this question
382:10 - which is enter a number we place it
382:12 - straight inside here and then we say out
382:13 - in result so if this has been successful
382:16 - we can print out yay again and else if
382:19 - it's not successful we can print out or
382:20 - not of course you can do other things
382:22 - inside here or you can even print out
382:24 - the value straight from here so we can
382:26 - say yay plus a space and then result
382:29 - just so we can get that back to the user
382:30 - and then oh know if something goes wrong
382:32 - of course this is just so we can test
382:33 - things and see how they work so this
382:35 - trass function it will take in a string
382:38 - input and it will try and give us back
382:40 - the result so in order to be able to
382:42 - make this successful function what we
382:43 - need to do is essentially do the
382:45 - conversion ourself which will be this
382:47 - convert in 32 so first we need to assign
382:50 - this out int so we can say result equals
382:53 - minus1 so now that we've used that we
382:54 - actually need to have return type as
382:56 - well but let's worry about that in a
382:57 - second so essentially what we actually
382:59 - want to do is say that the result is
383:02 - equal to convert to in32 and then we
383:04 - want to convert the input store it
383:06 - inside the result and if this goes
383:08 - successful then we want to return true
383:10 - and if it doesn't go successful then we
383:12 - want to return false but of course we
383:14 - need to be able to do these things
383:15 - separately so like we said with the try
383:18 - you only wrap around the section of
383:19 - which is going to be problematic so in
383:22 - this case as we've done here we've
383:23 - wrapped the convert in 32 inside the try
383:26 - so we're going to need to do that down
383:27 - here as well so we can open the try
383:29 - right here and place these two lines
383:32 - inside and then have a catch have a
383:35 - little think about what sort of catch do
383:37 - we need the whole point in this function
383:39 - is to Simply convert value and return
383:41 - back whether it's been successful or not
383:43 - there is no messages here we just need
383:46 - has it been successful yes or no and
383:49 - because we only need to know if it's a
383:50 - yes or a no then we can just have a
383:52 - generic exception and we don't need the
383:54 - E variable because we're not going to
383:56 - access the message we're going to keep
383:57 - it as an exception and instead of
383:59 - returning false down here we actually
384:00 - want to do this straight inside the
384:02 - catch so now the code reads like this we
384:05 - set the result to minus one and the
384:06 - reason why we do that is because if we
384:08 - don't then we're going to get a compiler
384:10 - error and it says that not all paths
384:12 - were going to assign result
384:13 - alternatively we can also assign result
384:15 - straight inside here just so we have an
384:17 - assignment in both paths or you could
384:19 - just leave it outside at the top so we
384:21 - assign result to minus one and then we
384:23 - place our problematic code straight
384:24 - inside here we try and convert the
384:26 - result and if this line returns back
384:28 - successful then it's going to execute
384:30 - the second line and return back true if
384:32 - this line returns back an exception it's
384:34 - going to miss this line completely and
384:36 - jump straight into the exception and
384:38 - then return us back with false so let's
384:40 - actually try this and see what happens
384:42 - 15 DOT or no and then 15 yay 15 so the
384:48 - reason why we don't care about the
384:49 - exception in here we can add in
384:51 - different values as we've used before
384:53 - with format exception overflow exception
384:55 - but as we saw with triy pass it simply
384:57 - just returns us back with the bull the
384:59 - bull simply tells us if it's been
385:01 - successful or not so we could stack
385:03 - these multiple times we can say catch
385:05 - and then we have the format exception
385:07 - and then we can place a return false in
385:09 - there and then we have another catch for
385:11 - the Overflow exception and we can place
385:13 - another return false in there but as you
385:15 - can see we're just returning false
385:16 - inside here so now that we've changed
385:18 - these it's kind of pointless each of
385:20 - them return back false and because we're
385:22 - not doing anything very specific we
385:24 - don't actually need to change them all
385:25 - together we don't care about the message
385:28 - we don't care the exception we only care
385:30 - about the fact that something has went
385:32 - wrong and if something has went wrong
385:34 - then we turn back false if everything
385:36 - goes okay then we return back true and
385:38 - that's all this Tri pass function is
385:40 - going to need to do it simply converts
385:42 - it or it doesn't convert it using an
385:44 - input and outputting a
385:46 - result so if you run it weet type in a
385:49 - real number we get a number back and
385:51 - then 15 DOT zero then we get all no
385:54 - because it can't come it there we go
385:56 - we've met all our requirements for this
385:59 - program let's have a look at how we can
386:01 - do debugging using visual studio to step
386:04 - through our code manually so this is the
386:06 - example I used last time int age equal
386:08 - 35 and ideally in this case you'd want
386:11 - something like 30 plus to be printed
386:13 - instead of 18 plus even though 18 plus
386:15 - is still technically true we'd still
386:17 - like 30 to be printed in this case
386:19 - because this says if it's over 18 do 18
386:22 - if it's over 30 do 30 plus so in order
386:24 - to start the debugging process you
386:26 - shouldn't run the code first if you run
386:28 - the code first it's going to execute so
386:31 - fast that you won't get a chance to
386:32 - actually put any code in and try and
386:34 - debug it there we go we've already hit
386:36 - the console read line and it's executed
386:38 - for a split second so the best thing to
386:41 - do just to the left of the line numbers
386:44 - you want to press in the Gap and that
386:46 - will create a red dot and it'll tell you
386:48 - that this is a debugging Red Dot just in
386:50 - this little tool tip debugging do
386:52 - program. Min debuging program
386:55 - main so it tells us we're in the program
386:57 - class and we're going inside the main
386:59 - you can also address the debug menu up
387:01 - here and it says we can have a toggle
387:03 - break point we can add new one we can
387:05 - delete them all or we can actually
387:06 - disable deleting them will just simply
387:09 - get rid of them as you can see here if I
387:11 - set a couple more and press disable then
387:14 - it's going to hide them so whenever we
387:16 - run our code it doesn't actually apply
387:18 - the debugging but it doesn't delete them
387:20 - and then we can enable them and then we
387:21 - can also delete them all and it gives
387:23 - you a little prompt because if you do
387:25 - doing this inside a big project and you
387:26 - just spent a lot of time going through
387:28 - and debugging certain functions then you
387:30 - don't want to be able to delete them all
387:32 - without any confirmation so let's delete
387:33 - them all and put it back on line 13
387:35 - which is our int Edge so let's run the
387:38 - code and see what happens so as you can
387:40 - see it minimizes our console for us and
387:42 - nothing's actually been printed yet
387:43 - because we're only up to this line and
387:45 - then we can use these buttons up here
387:47 - step into goes inside a function step
387:51 - over goes over the line so it will go
387:53 - from this line to this line step out is
387:56 - used after you've stepped in if you
387:58 - stepped into a function and then you
387:59 - don't want to see the rest of the
388:01 - function executing you can step out to
388:03 - jump back out of it which I'll
388:04 - demonstrate later on in this video so
388:06 - now that we've hit this line you can
388:08 - actually see what's going on so we have
388:09 - in age equals z because when this line
388:12 - is highlighted it means this line hasn't
388:14 - executed just yet so we can press this
388:17 - or we can press F10 on our keyboard if I
388:20 - press F10 you can now see in age has the
388:23 - value of 35 and what you can actually do
388:25 - is double click on it and just change
388:26 - the value to 30 for example now if you
388:28 - highlight you can see the value is 30 so
388:30 - you need to double click change the
388:32 - value to something and then simply press
388:34 - enter if you change the value but leave
388:36 - the box like this then it won't change
388:38 - the value so you have to remember to
388:39 - press enter so now I've made the age 40
388:42 - but let's just change it back to 35 to
388:43 - keep it the same and then now what we
388:45 - can do we can explore what's going on
388:47 - here if age is greater than 18 then
388:51 - we're going to check if this condition
388:52 - is true or false so in order to check if
388:54 - this returns back true or false you can
388:56 - actually hover over the operator and it
388:58 - says here AG is greater than 18 is equal
389:00 - to true and if we hover over this one it
389:03 - says age is greater than 30 is equal to
389:05 - True notice what we actually did there
389:07 - we essentially ran this condition
389:09 - through the debugger without actually
389:11 - reaching this line we're only up to line
389:13 - 15 as of right now but we've managed to
389:15 - execute this and give us back a function
389:18 - so as you can see age greater than 30 is
389:20 - true and age greater than 18 is true and
389:23 - because this is L if chain it only cares
389:26 - about the first one that turns back true
389:28 - and because this one has turned back
389:29 - true then if you press F10 again you'll
389:32 - see that now it's went inside this curly
389:33 - brace which will print out the console
389:35 - right line if I press F10 again you can
389:38 - see we're now waiting on here if I use
389:40 - alt tab I can get back to the console
389:42 - you see that 18 plus has now been
389:44 - printed now that we're waiting here we
389:46 - actually press F10 one more time and
389:48 - then it jump straight to this read line
389:50 - of course because this is L if chain as
389:52 - soon as one of these become true and it
389:54 - jumps over the lse if because of course
389:56 - this is a chain the first one it hits
389:59 - that's true it skips over the rest if we
390:01 - didn't want this to be a chain then we
390:03 - could keep them as both independent if
390:05 - statements if age is greater than 18 and
390:08 - if age is greater than 30 and don't use
390:10 - the lse keyword but in this case because
390:12 - you do want to Output a different
390:13 - message for every single age range you
390:15 - do want to place the L's word in there
390:17 - and now that we've hit this line we can
390:19 - press F10 and then now we jump back in
390:22 - the console and now we're wear in right
390:23 - here and just a little tip when it comes
390:26 - to debugging if at any point you just
390:28 - want to exit the debugging you can
390:29 - either press continue or just press F5
390:32 - and the program will run for example if
390:35 - we investigate this variable and we can
390:37 - see the value is 35 and then now we're
390:40 - happy with the rest of the code we can
390:41 - just press F5 and our code will run as
390:44 - normal we'll get the out print and we'll
390:46 - get a read line waiting here so we know
390:49 - our problem here is both conditions
390:51 - return back true so just like in the
390:52 - last video we actually changed this
390:54 - condition
390:55 - so to make sure that it only goes
390:56 - between this range but let's not repeat
390:58 - ourselves let's have a look at a
390:59 - different example so we can have string
391:01 - name equals Abu and then int age and
391:05 - then age equal 23 which I'll demonstrate
391:07 - why I've done it like this in a second
391:09 - and then let's have a function just so I
391:10 - can show you how to step in so we can
391:13 - have a static string print details
391:15 - string name in
391:17 - Edge and here actually we want to just
391:20 - return back a void because we just want
391:22 - to print out to the screen and we can
391:23 - say name space edge and maybe just put a
391:27 - dash between them and let's run that
391:28 - code now we can see ABA
391:31 - -23 of course making that function
391:33 - wasn't the point I actually want to show
391:35 - you what's going on so if we just print
391:37 - this a couple of times just so we can
391:38 - show you the step out and step in so you
391:40 - run the code now we can see our string
391:42 - name if we go over that you can see it's
391:45 - called abber and then now that it's
391:47 - stepped over this line cuz there's
391:48 - nothing really to execute here it's just
391:50 - creating back a variable so you can see
391:52 - that age is zero cuz that's the default
391:53 - value for an integ
391:55 - and when we skip over that now it's got
391:56 - the value of 23 so one line creates the
391:59 - integer with the default value equal to
392:01 - zero and then the next line will make it
392:03 - equal to 23 and then we're passing on
392:05 - the variables here and if you wanted to
392:07 - investigate it you could simply just
392:08 - hover over them like this so you can see
392:10 - what the values contain and then now
392:12 - that we've hit this function if we press
392:14 - F10 then it's just going to skip over it
392:17 - but what we actually want to do is be
392:19 - able to go inside the function so this
392:21 - is where our step in goes step over
392:24 - doesn't doesn't care if it's a function
392:25 - or a normal line it'll just step over it
392:27 - regardless so we want to in here we want
392:30 - to use step into or we can press f11
392:33 - once you press for f11 you can see that
392:35 - now it's jumped from print details up
392:37 - here to print details down here and then
392:39 - now look if I step through it's going to
392:41 - actually execute these one by one so
392:44 - right now it hasn't executed anything so
392:45 - I step over this once using F10 you'll
392:48 - see it now appears and then the same
392:49 - thing with this one and this one and now
392:51 - that I've executed three we should see
392:53 - three in the console perfect so now what
392:56 - I want to demonstrate is let's say we're
392:57 - happy with the rest of this function and
392:59 - then now we want to just step out so I
393:01 - press this button and you can see it
393:03 - jumps back up to print details f11 to go
393:06 - in and then shift f11 to go out so now
393:09 - that we're back in here the only thing
393:11 - we can do really from this point is
393:12 - either press F5 to stop debugging or
393:15 - press F10 to jump to this line and at
393:17 - this point we've already hit the last
393:18 - line now code so we don't really need to
393:20 - use F10 anymore cuz with nothing to step
393:22 - over so we can just press F5 let our
393:25 - program finish and there we go so let's
393:27 - have a look at another example can have
393:29 - a string message equals read from
393:31 - console then we can pass this in enter
393:34 - anything and then we can have a console
393:36 - right line and we can just print the
393:37 - message and then let's create this
393:39 - function so because it's a return value
393:41 - and store inside a string we're going to
393:43 - need a static string read from console
393:47 - and then this is one string parameter so
393:49 - we have a string
393:53 - message
393:55 - and then we can just do a console
393:57 - right and then print the message to the
393:59 - screen and then we just want to return
394:01 - the console. readline there we go and
394:05 - again let's put a breakpoint here and we
394:07 - can remove this one so it doesn't always
394:09 - have to be the first line if we're
394:11 - perfectly happy with this amount of code
394:13 - then we can simply take that off and it
394:15 - will stop when it gets after this
394:18 - line now if you look at the console
394:20 - you'll see all of this is executed that
394:22 - function is executed four times to print
394:24 - the name name and age of the screen and
394:25 - now we're waiting here so we have our
394:27 - read from console and now we can step
394:29 - into using f11 and you can see that if
394:32 - you hover over string message has enter
394:34 - anything which is our parameter that we
394:36 - specified up here and then there you go
394:38 - and then that will print into the screen
394:40 - so you tap back in you'll see it says
394:41 - enter anything and then just at the read
394:43 - line we need to actually enter it
394:45 - now
394:47 - something and then press enter and then
394:49 - just right here it's going to return it
394:51 - back so if we use F10 it jumps back in
394:54 - here
394:54 - and then actually we need to execute
394:56 - this line so F10 again and then if you
394:58 - hover over a message you see it says
395:00 - something which is exactly what we typed
395:02 - in the console here and then we just
395:04 - print it back to the screen there you go
395:07 - and now we just at the console read line
395:08 - and we can press F5 to finish up there
395:11 - we go so debugging is mainly used by
395:13 - pressing this button on the side so
395:15 - debugging is used by pressing on the
395:17 - empty Gap just to the left of the line
395:19 - number and it will create a red dot once
395:21 - you create a red dot it'll highlight
395:23 - this for you once you've clicked done it
395:24 - it should show up a red dot you can also
395:26 - disable or delete all the break points
395:28 - from the debug window at the top of the
395:29 - screen when you run the code it will
395:31 - stop here and then you can either use F9
395:34 - as a shortcut as well click into the
395:35 - line that you want to debug and press F9
395:37 - please note there is specific cases
395:39 - where if you try and press this one
395:41 - right here it's not going to let you if
395:43 - the line doesn't really do anything for
395:45 - example this is creating an integer
395:47 - there's no real action that's happening
395:49 - here that you should or want to debug
395:52 - this is an assignment this is an
395:53 - assignment this is a function call and
395:55 - so on and so forth and this is also a
395:57 - function call when it comes to just
395:59 - declaring variables then a compiler does
396:01 - not let you put in a breakpoint because
396:04 - there's nothing really to investigate
396:06 - when you're just creating a variable so
396:08 - don't get thrown off or think
396:09 - something's wrong if you click on the
396:10 - empty line and nothing appears so that's
396:12 - it for debugging but let's just have a
396:14 - little recap we can use F10 to step over
396:18 - f11 to step into functions shift f11 to
396:21 - step out or you can use the buttons that
396:23 - appear at the top of the screen when you
396:25 - run the code just right
396:28 - here hover over variables and you get
396:30 - their values as I showed you in the if
396:32 - statements if you hover over the
396:34 - operator inside the if statement it will
396:36 - actually tell you what the condition is
396:38 - and whether it's true or false so me say
396:39 - if1 equals equals to 1 and let's just
396:42 - print out true to the screen just so I
396:44 - can demonstrate
396:46 - this if a hover r that equals equals it
396:48 - says 1 equals equals 1 is
396:53 - true
396:54 - so that's how you check if a condition
396:56 - is going to be true or false when you're
396:58 - debugging you can check the parameter
397:00 - values by simply hovering over it and
397:02 - the tool tip should include the
397:05 - value just like so and if you wanted to
397:08 - step into this function you can use step
397:10 - into and then use step over which is F10
397:14 - just here and then you can actually
397:16 - investigate these values as well or you
397:18 - can look at the parameters and once
397:19 - you're done with the function you can do
397:20 - shift f11 or you can use step out and
397:24 - then you can skip over this and the same
397:26 - thing with this you can have a look at
397:27 - the string variable once it gets
397:29 - returned something in
397:31 - here and now it says something in here
397:33 - and string message and then we can print
397:35 - out to the screen Etc so you can have a
397:37 - little bit of Freedom with what you can
397:39 - do in terms of debugging play around to
397:41 - debuging in the past exercises that
397:43 - we've made together and then what you
397:45 - can actually do is gain experience in
397:47 - debugging so it comes to more
397:48 - complicated projects you can also apply
397:50 - that learning there and make sure that
397:52 - your code is error free
397:56 - so we covered how to debug by pressing
397:58 - the white space just to the left of the
398:00 - line number if we run the
398:03 - code the program will stop where our
398:05 - breakpoint is and it won't execute the
398:07 - line that we're up to we have to step
398:09 - over it so we've actually use this
398:10 - before to analyze our functions and see
398:13 - what values are inside things so we have
398:15 - these extra windows called the local and
398:17 - the auto so let's take a look at them
398:19 - and see what they're about so again if
398:21 - you don't have this layout you can use
398:23 - window reset layout and it should be in
398:25 - the left panel not the right one this
398:27 - time so we've got watch which we'll
398:29 - explore later and we're going to have
398:31 - locals and Autos so the autos because
398:34 - we're up to the age then it shows us the
398:36 - age has value zero and then that
398:39 - prevents us from hovering over it and if
398:41 - we step over it you'll see that now it's
398:42 - got age 23 and now name has appeared the
398:46 - auto tab will try and figure out what
398:48 - functions and what parameters you need
398:50 - to be displayed down here based on the
398:53 - section of cord that you up to so my
398:55 - guess is because we're up to this
398:56 - function and it takes in a name and age
398:59 - then we're getting name and age
399:00 - appearing before when we were on this
399:02 - line it was only showing back the age
399:04 - and because that section only used the
399:06 - age we only got age here but if you
399:09 - press locals you can see all the
399:10 - variables that are local to this main
399:12 - function are actually showing up we have
399:14 - a parameter called ARs and technically
399:16 - this is a parameter and it's a string a
399:18 - ray type but it's currently unused but
399:20 - it's still a parameter so you can see it
399:22 - down here and then in order we have have
399:24 - the name variable down here then we've
399:26 - got the age and then we've got the
399:27 - message which is currently said to know
399:29 - because we haven't created this in
399:31 - memory yet but as you can see this
399:33 - changes depending on the scope of our
399:34 - variables so now that we're about to hit
399:36 - this function let's use the step into
399:39 - and you'll see that the locals have now
399:41 - changed we've got rid of name age
399:43 - argument and string message and it's
399:45 - replaced with name and age because
399:47 - remember what I saying about the scope
399:48 - of the variables parameters inside a
399:50 - function are always going to be local to
399:52 - that function around the curly braces
399:54 - that they're surrounded by name and age
399:57 - is only within here so when it's trying
399:58 - to shows the local variables it's only
400:01 - local to what's inside these curly
400:02 - braces which in this case is name and
400:04 - ede so now if we step over
400:07 - this and then if we step into this read
400:10 - from console you'll see that just before
400:12 - we step into this function that these
400:13 - have all came back cuz again the scope
400:15 - has changed back to this function which
400:18 - is our main function which has all these
400:20 - variables inside so our read from
400:22 - console will only have our Str message
400:24 - so hopefully when we press f11 or press
400:27 - the step into button at the top we
400:28 - should only see the message variable
400:30 - inside here there we go we get enter
400:33 - anything cuz that's what was passed in
400:35 - over here and then as soon as we return
400:38 - back to
400:40 - that let we type something in and then
400:43 - we get all of the values again and you
400:45 - can see that system. console. reine had
400:47 - returned hello which is this line and
400:50 - then if we press F10 again you'll see
400:51 - that even though we've got it back here
400:53 - our message is about to be assigned once
400:55 - we step over this there you go it says
400:57 - hello and as you can see this changes in
401:00 - real time so as soon as we step over
401:02 - lines hello got placed straight into
401:04 - there this helps us tremendously because
401:06 - we don't have to keep hovering over
401:07 - variables like this to keep checking
401:09 - over their values you can simply use
401:11 - this menu and it will always update
401:13 - because whenever you change Scopes
401:15 - between functions that will
401:16 - automatically update as you just saw in
401:18 - them examples there we go and then when
401:20 - the program ends obviously this window
401:22 - is going to close down so that's a very
401:23 - help helpful method have being able to
401:25 - debug without having to hover over
401:27 - anything in the next video we're going
401:28 - to cover how to watch variables and this
401:30 - can be very handy when you're looking
401:32 - for specific
401:36 - errors another really good debuging
401:38 - technique is the watch window let's
401:40 - press a break point just of left of line
401:42 - 13 and let's run the code and let's see
401:44 - what this is about so we covered that we
401:46 - have the locals window and we have the
401:48 - auto window that will automatically give
401:50 - us the variabl that we're currently in
401:52 - the scope of but let's forget about that
401:54 - right now let's have a look at the watch
401:55 - window it says here add an item to watch
401:59 - so there's a couple ways that we can do
402:00 - this you can actually double click on a
402:02 - variable and right click or you can just
402:04 - highlight it like this and then right
402:06 - click and it says here add watch and you
402:08 - can press it it says name value null
402:11 - because we haven't created it yet so the
402:12 - default value is null as of right now
402:14 - cuz it's not actually assigned anything
402:16 - so you press F10 and step over it you'll
402:18 - see that immediately changes to abber
402:20 - without was having to do anything except
402:22 - simply press F10 which is the shortcut
402:24 - for our step over button right at the
402:26 - top of the screen this prevents us from
402:28 - having to hold over the variables to get
402:30 - the little tool tip so we can see the
402:32 - value the power of this is we can watch
402:34 - variables and we don't have to worry
402:36 - about showing in the locals or the auto
402:38 - because it's always there and if you
402:39 - have lots of variables like this then
402:41 - you're only concerned about the one that
402:43 - you're watching locals and aluto will
402:45 - always change depending on the scope
402:47 - that you currently at whereas watch will
402:49 - only do what you want it to do so
402:51 - because we don't put age inside there
402:53 - then it's simply won't come up just
402:54 - because it likes it if we check the
402:56 - locals we have agent there and the Autos
402:59 - we have agent there as well but we don't
403:00 - have it in the watch so what else you
403:03 - could do is actually just type straight
403:04 - into here age
403:07 - 23 if you really wanted to you can
403:09 - actually also type in conditions age
403:11 - equals equals 23 it returns back true so
403:14 - if you had an if statement that you
403:15 - wanted to track then you could do that
403:17 - as well so let's have a
403:20 - look so it a statement that said if age
403:23 - is greater than than 18 then we can just
403:25 - print out 18 plus to the screen so let's
403:27 - run the code now and see what happens so
403:29 - as you know we have this condition right
403:31 - here so if you actually highlight this
403:32 - and drag and drop it you can see that
403:34 - the cursor changes and you can drop it
403:36 - inside here let's click on the AG equals
403:38 - equal 23 and click delete so of course
403:41 - we can't really render this function
403:43 - right now because we haven't even
403:44 - created the integer variable so let's
403:46 - run over the integer variable and as you
403:48 - can see here it says AG is zero which is
403:51 - the default value for integer and that
403:53 - is is indeed zero right now and then age
403:55 - is greater than 18 is false but as soon
403:57 - as I step over this line and it makes
403:59 - age the value of 23 you'll see that
404:01 - these two immediately change you know
404:03 - they change because the values have went
404:05 - red red means that the values have just
404:07 - changed in the last button that you
404:08 - pressed whether that means he stepped
404:10 - into over or stepped out it doesn't
404:12 - matter red always dictates that the
404:14 - value is just changed so now it's
404:16 - telling us that age is greater than 18
404:18 - is returned back true so when I step
404:20 - over this line because this is returned
404:22 - back true I should render 18 plus let's
404:25 - have a look F10 F10 and there we go
404:28 - we've reached the middle which means
404:29 - that's going to get printed out
404:31 - now so moving on to another example we
404:34 - can have print details if we go into
404:36 - this function and let's say we only
404:38 - concerned about the name then we can
404:39 - print out the name down here but as you
404:41 - can see we already have it twice so
404:43 - that's just going to update depending on
404:44 - the parameter name and even if you
404:46 - wanted to show something like this you
404:48 - can drag this down here and it actually
404:50 - shows you the output this is very handy
404:52 - so you can see the output because
404:54 - sometimes when you have it like this it
404:55 - doesn't look very clear you can also
404:58 - hover over it right there and you can
404:59 - see the value placed here but again it's
405:02 - very handy to have it here so you don't
405:04 - have to keep hovering over the tool tape
405:06 - just to see the values and from here you
405:08 - can actually change the values so we can
405:10 - just say Harry is now the value for the
405:12 - name and Harry is going to be age 35 so
405:16 - when we press F5 and let the program run
405:18 - naturally you'll see that Harry is age
405:20 - 35 now and that's all done through the
405:22 - watch list down here here and it doesn't
405:24 - even matter because we have full control
405:26 - over the watch list variables and we can
405:28 - change their contents to see how our
405:30 - code acts in different situations so
405:33 - please use this watch list as much as
405:34 - you can and don't forget that once you
405:36 - can double click on variables and add it
405:38 - to the watch just from here you can also
405:41 - say quick watch and what that'll let you
405:43 - do is it'll give you the value and then
405:45 - if you want to add it you can press add
405:47 - watch here or you can just keep pressing
405:49 - re-evaluate once you've skipped over
405:51 - some lines so let's say we skipped over
405:53 - it now and then go back onto it and
405:56 - because it has a shortcut shift F9 we
405:58 - can just quickly press it like this and
406:00 - it says abber inside here and we can
406:02 - change the expression maybe do something
406:04 - like age and then click re evalue it and
406:06 - it changes the value to zero and then we
406:09 - can even change this to like 50 for
406:10 - example as you can see down here it's
406:12 - changed to 50 as well so you can drag
406:15 - and drop it into here or you can double
406:17 - click and press add watch it's up to you
406:19 - please make use of this watch variable
406:21 - and don't rely too much on the autos and
406:23 - the local just so you can keep your own
406:24 - variables inside here and you can have
406:26 - complicated outputs like these you can
406:28 - check conditions you can check console
406:30 - outputs as well as just checking normal
406:32 - variables so using the watch window you
406:35 - have lots of different opportunities to
406:37 - keep track of your
406:40 - code so we've got another debugging task
406:42 - let's try and run the code and see what
406:45 - happens we're going to get printed over
406:47 - 18 so our value is AG equals 35 and
406:50 - we're already getting over 18 printed to
406:52 - the screen so if we place a Brak line
406:54 - inside here and actually run the code we
406:56 - can see what's going on we can add them
406:58 - inside the watch just like this we can
407:01 - add in all the conditions
407:03 - inside just like
407:05 - this perfect so we can actually see here
407:08 - that because our age is over 35 it's
407:11 - saying greater than 18 is true greater
407:13 - than 30 is true but greater than 50
407:14 - isn't true and we can easily see that
407:17 - except because this is an if and an else
407:19 - if chain as soon as the first one is
407:21 - true it's going to enter that one you
407:23 - press press F10 then we get over 18 and
407:25 - then as soon as it finishes that path it
407:27 - actually skips all the way to the end
407:30 - the problem with this is we only want it
407:31 - to print over 30 since it's over 30 so
407:34 - we have to introduce ranges inside here
407:36 - and we can say age is less than 30 and
407:39 - then you can have ages greater than 30
407:41 - here and then you can also insert an end
407:43 - and say AG is less than 50 and there we
407:46 - go and now it says over
407:49 - 30 and if we change this to 55 then we
407:52 - should get over 50
407:54 - and then finally if we change this to
407:55 - something like 23 then we should also
407:58 - get over 18 perfect so what was going on
408:01 - here is because we had if and else if
408:03 - chains then you're only going to get one
408:05 - of them printed and because a value over
408:07 - 18 satisfied both the first path and the
408:10 - second path then it's only going to
408:11 - print the first path if we actually undo
408:13 - our changes all the way till the start
408:16 - and then we actually flip the order of
408:17 - this if we put our this one first and
408:20 - delete the El's and change it to lse if
408:23 - inside here so now we have a new chain
408:25 - except the first one in the chain is
408:27 - actually if age is greater than 30 now
408:29 - if you're on the code you'll see that
408:31 - the first one actually says over 30 and
408:33 - it says over 30 and it doesn't say over
408:35 - 18 anymore but simply because this is
408:38 - the first one in the list as soon as it
408:40 - hits the first one as I'll demonstrate
408:41 - now it will go inside this bracket hit
408:44 - this curly brace and then jump straight
408:45 - to the
408:46 - end you should always order them from
408:49 - smallest to biggest because that will
408:51 - probably make the most logical sense
408:53 - when you're reviewing your code and in
408:55 - doing so you can actually have a more
408:57 - formatted code but you need to watch out
408:59 - that the ranges need to make sense if
409:01 - you have something like this then you
409:03 - need to restrict this one because it's
409:04 - going to be blocking the second one and
409:06 - you don't want to make these all ifs
409:08 - because then you get multiple outputs
409:10 - now we should get 18 and 30 being
409:12 - printed to the screen this is not
409:14 - something you want so make sure that you
409:16 - place your ranges inside here by adding
409:18 - an and and then placing the other end of
409:20 - it which will be 30 and then this one
409:22 - will continue from it so so just to sum
409:23 - up what you need to do is make sure that
409:25 - you use Els and make sure that you have
409:28 - ranges just so when one exits it's going
409:31 - to check the other one and the other one
409:33 - you don't want the first condition to
409:34 - beat the second one if that's for the
409:36 - right path age 35 goes into this path or
409:40 - at least we want it to but it's been
409:42 - restricted by the fact that age is
409:43 - greater than 18 when we had it like
409:46 - this this is restricting everything over
409:49 - 18 to go inside this path if this was
409:51 - even like 65 we should only fall into
409:54 - this one and we run the code then we're
409:56 - still going to get over 18 which is
409:58 - still technically true it is still over
409:59 - 18 but we have different outputs for
410:02 - this sort of age range make sure that
410:03 - you use lfs and you keep in an
410:05 - appropriate range and keep them in the
410:07 - order of the if statements going from
410:09 - lowest to highest or whatever makes
410:11 - sense in that situation that you're
410:12 - using
410:13 - it this is a start of objectoriented
410:16 - programming let's start with a concept
410:17 - called structures structures allow us to
410:20 - store different data types inside one
410:22 - data type so it's almost like a group of
410:24 - data types we can demonstrate this if
410:26 - you wanted to stall something like a
410:28 - person you would normally have something
410:29 - like a string name equals ABA and in age
410:32 - equal 23 so in here we have a string
410:35 - name that represents the name and in age
410:38 - which represents their age and you can
410:39 - see that because these are two different
410:41 - data types you can't wrap them around
410:43 - inside an array you can't have a string
410:45 - array called person and then say we want
410:47 - to have two different values although
410:49 - this will still compile we can't store
410:51 - both these data types inside array
410:53 - unless you make the ede and store it as
410:55 - a string which will be 23 inside the
410:58 - quotation marks and then you'll have to
411:00 - worry about converting it later on in
411:01 - your program so this is not really ideal
411:04 - so we have something called a structure
411:06 - so just outside here we can say struct
411:09 - which stands for structure and then we
411:11 - can have our name straight after so we
411:13 - can say person in the next time we just
411:15 - open the curly braces and let's see what
411:16 - we've just created so now in order to
411:18 - make an instance of this we can actually
411:20 - use that like a data type between say
411:22 - person person there we go so now we've
411:24 - created our person variable now you see
411:26 - we've got our own data type before we're
411:28 - just using string and ins and arrays and
411:30 - things like that but now we actually
411:32 - have a new person so because our person
411:34 - is made up of a name and an age let's
411:37 - place that in here string name and then
411:40 - inage of course you don't want to give
411:41 - them default values because like all
411:44 - variables you don't know what the value
411:45 - is going to be to begin with so now what
411:48 - we can do person Dot and we don't
411:51 - actually have access to using these
411:52 - values yet so what we're going to have
411:53 - to do there is a concept called access
411:55 - modifiers which we'll cover on later on
411:58 - in this course but just for now what
412:00 - this means is you either have private or
412:02 - public and they're the main two words
412:04 - there's other words that you can have
412:05 - but they're the main two for now if you
412:07 - have it private it means you can't
412:08 - access it down here through person. name
412:11 - and but as soon as you make this
412:13 - public then now it becomes
412:17 - accessible there we go we can make that
412:19 - equal to something and if we take off
412:22 - public
412:24 - then you see we don't have access to it
412:26 - it's inaccessible due to its protection
412:28 - level because the protection level is
412:30 - private which means that you can only
412:32 - access name Within These two curly
412:33 - braces the second you make it public it
412:35 - means that anyone outside of the
412:37 - structure EG down here can also have
412:39 - access to name so if we do that to our
412:41 - public on int age and string name then
412:44 - we actually can access both now we can
412:46 - say person. Ag and it comes up like this
412:49 - the purple cube is a function and the
412:51 - blue is Fields you you can actually
412:53 - filter them out by pressing them down
412:54 - here show only methods and show only
412:57 - Fields so we can do age equals 23 and I
413:00 - can actually just place abber inside
413:02 - here now that this data is essentially
413:04 - the same as this the benefit that we
413:06 - have now is when we print to the screen
413:08 - we can say person. name and then hyphen
413:11 - person. Ag and if you run that
413:15 - now you we Abid
413:17 - 23 if we actually copy and paste this
413:20 - lined out and just remove person dot
413:22 - just so we're using these two variables
413:23 - at the top of here and we in the code
413:26 - you should see exactly the same values
413:27 - coming up there we go but now what's
413:30 - really handy about this situation is we
413:32 - have two data types that are wrapped
413:34 - inside of one data type instead of
413:36 - having a name and age we have a person
413:39 - because what gets really easy now is if
413:40 - you wanted to add something else inside
413:42 - here like for example birth month which
413:45 - for me is five so in here you'd have to
413:47 - make another one birth month equals 5
413:50 - and then all we have to do inside our
413:52 - person is just say person. birthmonth
413:54 - and we could just assign it right here
413:56 - instead of having to create a whole new
413:58 - variable we add it up here and then we
414:00 - can use it down here and then we can add
414:01 - that into here person. birthmonth
414:05 - and we can add this to this one and then
414:08 - get rid of birth month and as you can
414:10 - see it's exactly the
414:12 - same so we've taken these data types and
414:14 - placed it inside our structure so then
414:16 - we can just reference it by the person
414:19 - this becomes very very handy for this
414:21 - exact reason that I'm going to show show
414:22 - you now let's say you wanted to read
414:24 - this data R from the user so you have
414:26 - static and then you're a bit stuck on
414:28 - what data type you want to return if you
414:30 - forget about the birth month then we
414:32 - have a name and age as a very basic
414:34 - person but our return type only lets us
414:36 - have one type so that's going to be a
414:38 - problem now so you could do a string
414:39 - return that will give us back the name
414:41 - and then we can say return person and
414:45 - inside the brackets what you can
414:46 - actually do is do out in Edge so you can
414:48 - have two output variables an out Edge
414:51 - and then a return string since hiide
414:53 - here we could
414:55 - say enter your name and then string name
414:59 - equals console do read
415:01 - line if we copy and paste this down and
415:04 - then we can say enter your age and then
415:06 - we can say int age equals convert to and
415:09 - 32 and then put the console read line
415:12 - inside there there we go now that we've
415:14 - got that we don't actually need inage
415:16 - because we've already got output
415:17 - parameter so we just need to be Edge and
415:20 - then after we've retrieved them two
415:21 - values we can return name there we go so
415:25 - let's actually try that up here so we
415:28 - can say new name is equal to return
415:32 - person and then out in new ede and you
415:35 - can take this exact line paste it down
415:38 - here get rid of the birth month and then
415:40 - we can use new age in here and new name
415:42 - inside here so let's run that now ask us
415:46 - what is your name ABA what is your age
415:48 - 23 and then we got ABA 23 which is the
415:50 - same as what we've got before but you
415:52 - see that this situation is prettyy messy
415:54 - we have to return a string variable and
415:56 - also use an output in order to be able
415:58 - to give back two values alternatively
416:00 - what we could do is actually just return
416:02 - back void and then we can say string
416:04 - name and then inage but we're going to
416:07 - have to use references inside here and
416:10 - then have string new name equals nothing
416:13 - and then new inage equals 0o so we have
416:17 - string new name equals nothing and then
416:19 - into New Age also equal to nothing and
416:21 - then inside our function instead of
416:23 - having out parameters we can actually
416:25 - use a reference and we can say a new
416:27 - name and then ref New Age and what that
416:29 - will do is we can just return it like
416:31 - this because it's void instead of
416:33 - declaring a new string name we can
416:35 - actually just assign it to the reference
416:36 - that just passed and because it's a void
416:38 - parameter now and for the return type we
416:40 - don't actually need to return anything
416:42 - so we can actually assign these by
416:43 - reference enter your name ABA and 23 so
416:47 - as you can see it still works fine but
416:49 - let's say we wanted to add another birth
416:50 - month so we' have to take the birth
416:52 - month variable new birth month make it
416:55 - equal to zero and then add yet another
416:58 - parameter ref new birth month and then
417:02 - we need a new birth month inside
417:04 - here ref int birth month and then we
417:09 - need another one from here enter your
417:12 - birth
417:12 - month and then we'd start it inside
417:15 - birth month and then finally we can also
417:18 - return it up
417:20 - here as new birth month
417:23 - there we go AB 23 and then five so we
417:26 - get them values being returned so in
417:28 - order to keep adding different
417:29 - properties to your code you have to make
417:30 - a new parameter a new reference variable
417:33 - and then append the parameters inside
417:35 - the function now the problem that is
417:37 - even though you can have an infinite
417:38 - amount of parameters then this gets very
417:40 - tedious very quickly and you don't want
417:42 - this so let's have a look at how we can
417:44 - make this function exactly the same way
417:46 - just using our new structure you can see
417:50 - that instead of having to pass all of
417:51 - these different things in or return back
417:53 - a certain value we can actually just
417:55 - return back a complete person so all of
417:58 - this can be squished pretty quietly so
418:01 - actually let's just comment all of this
418:04 - out and let's comment out this function
418:06 - and let's have another
418:08 - rewrite so now that everything's gone we
418:10 - only want to be returning and dealing
418:12 - with the person so we can say static and
418:15 - instead of void we actually want to say
418:17 - we want to give the user back a person
418:19 - return person and we don't need any
418:21 - parameters in in this case this is only
418:24 - passed in because it's a reference so we
418:26 - can assign these values back to the
418:28 - original variables but because we're
418:30 - going to be returning a person then we
418:31 - don't need to do that so we can
418:33 - essentially take this code and put it in
418:35 - here and we can say string name now we
418:38 - have an in here and then also an in here
418:41 - there we go so now that we've
418:43 - constructed all our variables that we
418:45 - need for the person what we can do is we
418:47 - can make a new person person person and
418:50 - then person. name equals name
418:53 - and then duplicate this down we say a
418:54 - person. ag is equal to age and finally
418:58 - the birth month is equal to the birth
419:00 - month and then now that we've
419:02 - constructed our person we still got a
419:04 - red underline because we haven't
419:05 - returned anything yet and after all of
419:07 - that we can say return
419:09 - person there we
419:11 - go and now simply in here we could just
419:14 - say person person equals return person
419:19 - there we go and then we can take this
419:22 - console right line here and place it
419:24 - straight underneath since it uses the
419:25 - same properties now let's try and run it
419:28 - AB
419:30 - 235 there you go so now instead of
419:32 - having to make a whole new variable all
419:35 - you have to do is simply just add
419:36 - another one down here so we can just say
419:38 - number this could be your favorite
419:40 - number or anything and we can add it
419:42 - onto
419:45 - here person.
419:47 - number and then here we can paste this
419:50 - down we can say enter your number and
419:53 - then it will be number in here we can
419:56 - paste it down here and change it to
419:58 - number and there we go that's all we
420:00 - need to change and this code doesn't
420:02 - change cuz it's simply calling back the
420:04 - function and we're doing all the hard
420:05 - work inside here so now if you run this
420:08 - enter your name abber 23 5 and finally
420:13 - four and there you go we get the values
420:14 - being
420:16 - returned so this looks a little bit
420:18 - tedious we have to assign each one
420:20 - individually every single time we do it
420:22 - so we can actually use something called
420:24 - a Constructor in order to achieve this
420:26 - result we make the person we set them
420:28 - and then we return it it' be easier if
420:30 - we could have the Constructor that we
420:32 - can assign straight inside here and then
420:34 - just return it immediately instead of
420:35 - having to do all of these lines and then
420:37 - reference each one individually so let's
420:40 - have a look and see what we can do
420:42 - inside here we can have a new function
420:44 - that'll just be called whatever the
420:46 - structure is called then you open the
420:47 - brackets close the brackets for now and
420:49 - this is called a Constructor in order to
420:51 - be able to use it down here we need to
420:53 - make it public in order for someone else
420:55 - to access it so this says that it needs
420:57 - explicit parameters in order to be able
420:59 - to compile it says that it needs to
421:02 - assign name age birth month and number
421:04 - so let's see how we can do that as we've
421:06 - used Constructors in the past for
421:09 - example when we had things like the
421:11 - string Builder we had s SP equals new
421:13 - string Builder and when you make a new
421:15 - something that means you're making a new
421:17 - Constructor so all of these sixes are
421:20 - the parameters that go inside of this
421:22 - but each one of these is a separate
421:23 - Constructor if we control click this we
421:25 - should be able to see them all there we
421:27 - go you see that the class is called
421:29 - string Builder and this is called string
421:31 - Builder and these two names match
421:33 - exactly so to make a string Builder you
421:35 - can give it any one of these as long as
421:37 - your parameters match one of these six
421:40 - you can give it nothing or you can give
421:42 - it some other values and that's the same
421:44 - is true with our current
421:46 - person so what we need to do in this
421:48 - case is we don't have multiple ways that
421:51 - we can constru this in the case of our
421:53 - person we have to provide all of these
421:55 - details otherwise the compiler is not
421:57 - going to like it so we can have a string
421:59 - name int age int birth month and int
422:03 - number now we got our parameters set up
422:05 - we actually need to make use of them in
422:07 - here so because we have name and name
422:11 - and they're exactly the same string by
422:13 - string then in here we can't say name
422:15 - equals name in terms of global and local
422:18 - variables this is global within the
422:20 - structure as it's within these two curly
422:22 - braces and all of these variables are
422:24 - only Within These two curly braces local
422:27 - variables always take presidence over
422:29 - the main one if I double click on this
422:31 - you'll see that all three are
422:33 - referencing this Constructor if I double
422:35 - click on this you'll see that both name
422:37 - references on line 20 down here is all
422:40 - referencing this one in the parameter
422:42 - and not the one up top we want it to be
422:45 - assigned into here so you have two
422:46 - options in this case you could
422:48 - capitalize all of these so then you
422:50 - don't run into this issue and then
422:52 - instead of name equals name it's capital
422:54 - N equals name and that fixes it
422:56 - alternatively if you want it to be a
422:58 - lower case then what you can simply do
423:00 - is you can place this
423:02 - dot if you use this it goes back to the
423:04 - current scope and the current scope of
423:06 - name is going to be this which is within
423:09 - the
423:10 - structure when you use this it doesn't
423:12 - reference the local variables it
423:14 - references the global variables appear
423:16 - so when I double click on this now
423:17 - you'll see that that gets highlighted so
423:19 - we can say this. ede equals ede this.
423:22 - birth month equals birth month and
423:24 - finally this. number equals number so
423:27 - we're just getting all the parameters
423:29 - from here and putting them into these
423:31 - values this might look a little bit
423:33 - redundant but I'll show you why this is
423:34 - a lot
423:35 - cleaner so back in our return person
423:37 - function we have the variable and then
423:40 - we assign them all manually but look how
423:42 - easy this now has became if I comment
423:44 - out this return we can say a return
423:46 - person so now we can reference person
423:48 - with a capital P this time cuz I want to
423:50 - reference the structure directly so
423:52 - after the person we can open the
423:53 - brackets and then start to type in so
423:55 - our first one is name age and the birth
423:57 - month name comma age comma birth month
424:01 - comma and then number comma and then
424:02 - this is not going to like it because we
424:04 - also need to place new
424:09 - inside as I said before when you making
424:11 - a string Builder you have a new keyword
424:14 - and this new means that you want to
424:15 - create a new instance of this you could
424:18 - think of this structure as a template
424:20 - this is the template for something and
424:22 - until you start using that something
424:24 - it's actually not going to do anything
424:26 - so we have to make a new instance of it
424:28 - because it's not already available so we
424:30 - need to make it available through our
424:31 - data type so when we say we want a new
424:33 - person that gives us access to the
424:35 - Constructor if I remove that you'll see
424:37 - we've got one of two now we can create
424:39 - an empty person and that will just make
424:41 - us assign all the values individually
424:43 - but we don't want that we want to use
424:44 - the second path and if you drop the
424:46 - arrow you'll be able to see the
424:47 - different parameters which is the ones
424:49 - we just typed in name age birth month
424:52 - and then number and now that we've
424:54 - returned back this we actually don't
424:55 - even need to do any of these lines right
424:58 - here we can actually just return it
425:00 - exactly like this so now if you run it
425:01 - again you should see exactly the same
425:03 - output 23 5 and four perfect so let's
425:07 - just have a little recap so normally
425:09 - when we're creating variables we use
425:11 - common variables that we've used in the
425:12 - past string in double Flo bull Etc but
425:16 - with the use of structures we can create
425:18 - our own group of variables and then we
425:20 - can use them VAR Ables inside functions
425:23 - and inside our code to make things a lot
425:25 - cleaner and a lot easier so inside
425:27 - person we actually stall four different
425:29 - variables and they can be an infinite
425:31 - amount of variables should you will and
425:33 - you can easily remove them and then
425:35 - remove them from the parameters and from
425:37 - the assignment and then that's it if we
425:39 - use this without our structure then
425:40 - we're going to have to declare every
425:42 - single variable separately and I know
425:44 - this is the same as doing it up here
425:46 - it's actually a little bit more work cuz
425:47 - you need to create a new parameter and
425:49 - create all the the instances inside here
425:51 - and assign the values now the benefit of
425:54 - doing it within a structure is that when
425:56 - you go to do a function look how easy
425:58 - this line is before you'd have to have
426:01 - name age birth month all as references
426:03 - or have them as out parameters and it
426:05 - gets a little bit long and a bit sloppy
426:07 - you only to include the month in here
426:08 - we' have to have another int number and
426:12 - you can see that the parameters are
426:13 - growing if you wanted to store a user
426:15 - from a registration form you might have
426:17 - name address phone number country and
426:19 - the list goes on it can be a very long
426:21 - form and you therefore you'll have a lot
426:23 - of parameters so it's very easy to wrap
426:25 - it around inside a structure and then
426:27 - simply reference it like that and you'll
426:28 - need zero parameters because everything
426:31 - is contained within the data type and
426:33 - then inside here we can ask for the
426:34 - users's details individually store them
426:36 - as their integers and string variables
426:39 - and then instead of using this notation
426:40 - we can now use our fancy Constructor
426:43 - where we can pass it in in this exact
426:44 - order right here name age birth month
426:47 - and then the number perfect and then we
426:50 - can use inside here we can call each of
426:52 - these positions separately and
426:53 - concatenate them
426:56 - together so now that we covered
426:58 - structures known by struct as the
427:00 - keyword let's have a look at classes and
427:02 - how to define them syntactically so we
427:04 - can make a struct called person and we
427:06 - can give them a string name and inage
427:09 - and to make them accessible we'll make
427:10 - them
427:11 - public and we can say public person
427:14 - string name and int age and that means
427:17 - we can assign these values using the
427:19 - Constructor so we can say this.name
427:21 - equals equal name and this. age equals
427:24 - age perfect so let's get rid of our
427:27 - compiler error since we're assigning
427:28 - both the values and then down here we
427:30 - can use it we can say person person
427:32 - equals new person and then have abber
427:35 - and then 23 in the brackets and we can
427:38 - print to the screen person. name and
427:40 - then if use controll D to duplicate that
427:42 - down and we can do age and if we run
427:45 - that right now we should see abber and
427:47 - 23 being printed to the
427:50 - console perfect so as we talked about
427:52 - introduction syntactically the struct
427:54 - and the classes are very similar so
427:56 - let's comment this out so we don't get
427:58 - any compile errors and let's see how
428:00 - this is going to work so of course we're
428:01 - going to get error on this line but once
428:03 - we make our class the error should
428:04 - disappear from here so instead of struct
428:07 - person we're simply just going to have
428:09 - class person exactly the same and
428:12 - because these are fields we can also
428:14 - copy these down so we can have public
428:16 - string name and public int
428:18 - age and then we can have public person
428:22 - and then string name in age this do name
428:25 - equals name and this. age equals age so
428:28 - as you can see this is exactly the same
428:30 - as this except for the fact we have
428:32 - structure and we have class inside here
428:35 - now you see how compile error is gone
428:36 - and if you've run the code we should see
428:38 - exactly the same
428:40 - output there we go now the main
428:42 - difference about classes and about
428:43 - structures is that you don't actually
428:45 - have to give these a default value
428:47 - inside the
428:48 - Constructor if we just comment this one
428:50 - out for a second
428:53 - and if we bring the structure back and
428:55 - we actually remove the parameters from
428:57 - here then we're actually going to get
428:58 - compile errors and it says that the name
429:00 - and age must be assigned before it's
429:03 - returned and stroks cannot have
429:05 - parameterless Constructors now that's a
429:07 - bit of a problem in certain cases you
429:09 - might want to create an instance of
429:11 - something but not actually derive any
429:12 - values so you could actually make these
429:14 - into default values you can have string
429:17 - name equals nothing and int age equals
429:19 - zero and therefore once we place in
429:21 - inside here then there's no problems if
429:23 - you run the code then you will get the
429:25 - output this will be nothing this will be
429:27 - zero and you'll get errors and you won't
429:30 - get any compile errors doing this way
429:31 - but the point is you have to include
429:33 - them and you don't have a
429:35 - choice so if you just comment this back
429:37 - out now what you'll notice about the
429:39 - class
429:40 - person is even if we get rid of it then
429:43 - it still lets us have it of course we
429:45 - can't actually give it parameters since
429:46 - we don't have a Constructor that lets us
429:48 - have parameters but what you can do as
429:50 - well is you can overload this and
429:52 - actually include it as well so you can
429:54 - have another set that literally lets you
429:56 - define both of
429:58 - them and then you can even have another
430:00 - overload that lets you just include the
430:02 - name without the edge and then also
430:05 - another one that lets you include the
430:06 - int Edge without the name or you include
430:09 - both the details so in these cases what
430:12 - you can do is you can store the values
430:13 - up here as the fields let them use a
430:16 - default Constructor or only give it the
430:18 - name or the age or you can actually give
430:20 - it both so when we come down into here
430:23 - we actually now have four different
430:25 - Constructors we can make an empty person
430:27 - we can make it with an edge with the
430:29 - name or with
430:31 - both and what you can do in here is you
430:33 - can say this.name is equal to nothing
430:36 - and then here you can say this. AG is
430:38 - equal to minus one just to default it to
430:40 - a value that's incorrect so after we've
430:42 - got this let's have a look at the
430:44 - different ways so we can give it a
430:45 - person which gives us an empty value so
430:47 - if you run that now we get blank and
430:50 - zero and if we just give it the name
430:52 - which is Aba then we should get ABA in
430:54 - minus one yep and then if we just give
430:57 - it the age you should get nothing in 23
431:00 - and if you actually give them both then
431:02 - you should get both printed out to the
431:03 - screen and there we go so now we have
431:07 - four different ways that we can create
431:08 - our person with our structure we're only
431:11 - really limited to one since all of these
431:13 - values need to be assigned as the
431:15 - structure is created structures are
431:17 - meant to be used as an extension to a
431:19 - data type rather than almost like a mini
431:21 - management system when we make a class
431:24 - we have so many options of different
431:25 - ways that we can do this inside here and
431:27 - later on in the course we're going to
431:29 - show you how to include functions inside
431:31 - here and then eventually do other
431:33 - Advanced Techniques with classes that
431:35 - aren't directly available structures if
431:38 - you have a basic example where you want
431:39 - to extend something to use inside a
431:42 - function or a data type like starring
431:44 - name and age instead of having to do two
431:47 - return types inside a function then a
431:48 - struct is perfect the second you want to
431:50 - do more complicated things or make it a
431:53 - bit more specific and flexible then
431:55 - classes are the way forward you'll see
431:56 - it very often in games where they have
431:58 - struct position you'll see in video
432:00 - games where they have something like a
432:02 - struct position and they might have int
432:04 - X int Y and int Zed and that's for their
432:06 - 3D position or they might even just have
432:08 - an X and Y or you could have something
432:10 - simple like a rectangle and you can give
432:13 - it a width and a length so now when you
432:16 - use that inside the code you're going to
432:18 - have different flexibilities of the
432:20 - amount with data types that you can
432:21 - store and then when you return that back
432:23 - from a function that will be okay as
432:25 - well since you can use this as a data
432:27 - type so if you want something simple and
432:29 - straightforward then go for the struct
432:31 - the second you want something a bit more
432:33 - complicated and a bit flexible then you
432:35 - probably want a class we go into more
432:37 - different situations inside this cause
432:38 - so you understand in which cases to use
432:40 - what and in most cases you'll notice
432:42 - that the class is more replicable so if
432:44 - you wanted to you could ask the user to
432:45 - enter these details in and then you can
432:47 - pass them inside the Constructor so we
432:49 - could say a console right line
432:51 - changes to a right enter your
432:54 - name String name console. readline and
432:59 - then copy and paste this down change
433:00 - this into a int age and then wrap this
433:03 - around inside a convert in32 instead of
433:06 - enter your name it'll be n your H and
433:08 - then since these are grayed out it means
433:09 - we haven't used them so we can change
433:11 - abber to your name and then change 23 to
433:13 - H perfect so now if you run the code now
433:17 - enter your name ABA enter your age 23
433:20 - then we get AB number 23 printed out to
433:22 - the screen so just a quick recap
433:25 - Constructors are basically defined the
433:26 - same way you have public followed by the
433:29 - class or the structure name and then the
433:30 - parameters inside the brackets and then
433:32 - you can assign it after without
433:34 - structure you have to declare all of the
433:36 - variables inside the parameter and
433:38 - assign them all down here otherwise you
433:40 - won't be able to run your code with
433:42 - classes we have the flexibility of just
433:44 - including one default function which
433:46 - will just be our Constructor and even if
433:48 - it does nothing this is still acceptable
433:51 - and then we broke it down to multiple
433:52 - sections where you might have situations
433:54 - where you only want their name or their
433:56 - age or you might even collect both to
433:58 - store it if you collect the name then
434:00 - we'll initialize age to minus one just
434:02 - so you know that this is a bad value and
434:04 - if you declare only the age then we'll
434:06 - initialize a to nothing just so you know
434:09 - that it's an empty value and if you
434:10 - accept both then we simply assign both
434:13 - and down here we have access to it we
434:16 - can even make this a little bit better
434:17 - by checking these values so we can say
434:20 - if string is not null or mty of person.
434:24 - name and we can put a not inside here
434:27 - then we can print out
434:30 - this and then the same thing for age we
434:32 - can say if person. AG we can say greater
434:36 - than minus one since we set minus one as
434:38 - the bad value and then we can move this
434:40 - line up and let's try run it now so
434:42 - these two if statements are
434:44 - fundamentally separate from each other
434:46 - one is checking the name and one is
434:47 - checking the age so let's try and
434:49 - manually type these in and see what
434:51 - happens so enter your name let's make
434:54 - this blank and only include the age and
434:56 - let's see if this runs okay so you had
434:58 - no name in the age of 23 then you see we
435:01 - only get printed 23 because it'll skip
435:03 - over this line as you can see if we put
435:06 - a break point in now and just refresh
435:07 - the code we get empty name plus 23 and
435:11 - when we press F10 over this line it
435:13 - jumps the next one because if we hover
435:15 - over this you'll see that it should
435:17 - return us back with false there we go we
435:19 - get strings null or empty is is false so
435:21 - that'll skip over that and because the
435:23 - age is 23 then this line is going to
435:25 - execute let's run it again and do the
435:27 - opposite we could say name is Aba and
435:30 - then age is minus one and then we get
435:32 - ABA printed be not the
435:34 - age there we go so if you wanted to fix
435:37 - these in and type them manually so we
435:39 - can say
435:40 - 23 there we go we get 23 and if we only
435:43 - include the
435:45 - name
435:47 - ABA then we only get ABA printed out and
435:49 - if we include both both of
435:52 - them then we get them both printed out
435:56 - perfect so now that we've created our
435:58 - class we've gave it some fields and
436:00 - we've made our Constructor that lets us
436:02 - initialize it let's see how we can print
436:03 - the details out to the console so we can
436:05 - have a CW tab tab a console right line
436:08 - and then we can say string interpolation
436:11 - name callon space and then we can have
436:13 - our curly braces and we can say person.
436:16 - name we can access these fields using
436:18 - the dot operator and then we can say
436:20 - back/ again for the new line and then
436:22 - say age and the same thing person. AG
436:25 - let's try run that and see what we've
436:27 - got so now we've outputed name and age
436:30 - out to the screen let's see how we can
436:31 - do this inside a function if you wanted
436:33 - to place this in different part of your
436:34 - code then you're going to have to copy
436:36 - and paste this and as we know this is
436:38 - bad for our code because it's j a
436:39 - duplication we want to be able to wrap
436:41 - this inside a function somewhere so
436:43 - let's see what we can do we can have a
436:44 - static string so you can return us back
436:47 - with this that we can output straight to
436:48 - the console and we can say return
436:51 - details and for our parameter we can
436:53 - have something like string name and int
436:56 - age because that's what our class is
436:57 - made up of and inside here we can simply
437:00 - take this put it inside here and put a
437:03 - return before it and then get rid of the
437:05 - person dot since we have an aim and age
437:07 - variables as local to the function so
437:10 - now instead of this line we can
437:11 - duplicate this down take out the
437:13 - contents and we can say return details
437:16 - and then we can place person. name and
437:18 - person. AG inside here let's r on the
437:21 - code so we get exactly the same output
437:24 - but the problem with this function is
437:26 - we're having to type out the parameters
437:28 - manually we have them here and we're
437:30 - going to have to type them again in here
437:32 - and again for the parameters this is a
437:34 - bit of a problem because we've just made
437:35 - our class but we haven't really used it
437:37 - when we're passing it in so instead of
437:39 - having string name and int age we can
437:41 - actually duplicate this method and just
437:42 - comment it out just so you can see it
437:44 - for reference and instead of doing this
437:46 - you can actually just pass in an entire
437:48 - person so now we have access to person
437:51 - and we can bring this back and we can
437:52 - say person. name and we can also say
437:55 - person. Ag and the reason why this
437:57 - method is preferred is if you actually
437:59 - have something else public int number
438:02 - and then you added another one inside
438:03 - here int number and then you said this
438:05 - do number equals number the parameters
438:08 - won't have to change inside the function
438:11 - all you have to do is simply pass in the
438:13 - person and then now we actually have
438:15 - access to doing person. number inside
438:18 - here should we need to if you passing
438:20 - them all all in one by one like this
438:22 - then you have to append into number on
438:24 - the end and then add it straight to here
438:26 - and then also add it inside here as you
438:28 - have like this it's easy to pass the
438:30 - class in because all of these properties
438:32 - above are just simply used throughout
438:34 - the function so now if we just bring
438:35 - this
438:39 - back and let's have a run and see if we
438:42 - get the same
438:43 - output which we do name ABA age 23
438:46 - perfect so now that we've thought of two
438:49 - functions how to do this we we can
438:50 - manually type in the strings and the
438:52 - integer and any other parameters that we
438:54 - need or we can actually pass in the
438:55 - person the problem with these two
438:57 - approaches is the whole point of having
438:59 - classes and structures of the like is so
439:01 - we can wrap around lots of functionality
439:03 - inside it if you want to send this to
439:05 - another developer for them to use in
439:06 - their project or maybe this is a file
439:08 - that is shared within the projects then
439:10 - you don't want them to include a
439:11 - separate function that is simply outside
439:13 - of the class we want to include the
439:15 - functions inside the class so of course
439:18 - as you know these are functions so
439:20 - inside side here we can also make
439:22 - functions so let's do it so we can have
439:24 - public and we want a string return
439:27 - details and then we don't need to pass
439:29 - anything in the the values that we're
439:32 - going to be returning are these two
439:33 - right here which is technically local to
439:35 - our class so therefore we're not going
439:37 - to have any parameters I'll explain that
439:40 - further in a second so we can take this
439:42 - exact line paste it straight into here
439:44 - and get rid of the person Dot and get
439:46 - rid of the person dot on this side so
439:48 - then we have the name variable and the
439:49 - age variable
439:51 - if you double click on them you see it
439:52 - references these variables and the same
439:54 - thing for age the reason why we don't
439:56 - have parameters is when you call this
439:58 - function as I'll show you in a second
440:00 - you call it directly on the person so
440:02 - the person that you're trying to print
440:04 - has already got these contents inside of
440:05 - them so let's have a look we can
440:07 - duplicate this down and instead of
440:09 - calling return details and passing the
440:11 - person you actually do it the other way
440:13 - around you say the person object dot
440:16 - return details so now we're calling
440:18 - return details inside our person person
440:20 - an
440:21 - object now let's run the code you see
440:24 - the output is exactly the same except
440:26 - now this functionality is a lot better
440:28 - our return details is wrapped inside our
440:30 - class which is the preferred way now we
440:33 - can actually get rid of these inside
440:35 - here and then we shouldn't really use
440:37 - this notation even though is technically
440:39 - correct but you want to wrap all your
440:40 - functionality inside here and just bear
440:43 - in mind that scope is also applicable
440:44 - here return details is within this class
440:47 - which means if you try to run this
440:49 - function inside the main then it's not
440:51 - going to node exist this return details
440:53 - function was able to be used inside here
440:56 - because this was in the scope of the
440:57 - class program which is this curly brace
441:00 - and this curly brace but this return
441:02 - details is only within the scope of this
441:04 - class which means you can't just
441:06 - suddenly use it inside the main so
441:08 - please bear that in mind when you
441:09 - producing these classes and you're
441:10 - trying to understand where everything
441:12 - goes every function that you place
441:14 - inside here is accessible through the
441:16 - dot notation after the object once
441:18 - you've created the class soose person
441:20 - equals new person and then after we type
441:22 - person dot then we'll get a list of all
441:24 - the functions the same way if you have
441:26 - something else just like this and then
441:30 - if you do person Dot and then you see
441:32 - that something has appeared there so all
441:34 - the functions that you create up inside
441:36 - in this class for every person that you
441:38 - make it'll be accessible through the dot
441:40 - notation so just to round up this video
441:42 - you should always make your functions
441:44 - inside your class having them inside the
441:46 - class is the whole point of making a big
441:48 - class and have lots of functionality
441:50 - side if you keep the function that does
441:52 - exactly the same thing outside of the
441:54 - class then if you were to share this
441:56 - file or come back to it in the future
441:58 - then you're not going to understand why
441:59 - you've done this and it's outside the
442:01 - class keeping everything wrapped inside
442:03 - the class is the best way forward in
442:05 - most case
442:07 - scenarios so now we have our class
442:09 - person it's got a name and age a
442:11 - Constructor and a function to return
442:13 - back the details and we can simply use
442:15 - it like this and return back the details
442:17 - like this but so far we've covered how
442:19 - to make classes Constructors Etc and
442:22 - assign the values but the values are
442:24 - only getting assigned throughout the
442:26 - Constructor but what if a different part
442:28 - of our program the user want to change
442:30 - their name update their age Etc then
442:32 - what options do we have so you know we
442:34 - can access our Fields using person. name
442:37 - and then you can simply type equals and
442:39 - then type in another name and we can say
442:41 - person. AG equals 25 now we've changed
442:44 - these properties if we use the console
442:46 - right line and return details you'll see
442:48 - that the values have indeed changed
442:51 - as you can see there it's changed the
442:52 - Harry in
442:54 - 25 this is okay except for the fact that
442:57 - this shouldn't really be possible we
442:58 - should try and restrict this directly by
443:01 - the use of gets and sets so for now
443:03 - we're going to cover fields and how to
443:05 - restrict certain values and later on in
443:07 - the course we're going to go through
443:08 - what properties are so before alter
443:10 - properties got invented we had to use
443:13 - gets and Setters gets and sets are
443:15 - essentially functions that will prevent
443:17 - this from happening so the reason why we
443:20 - can do this is simply because this
443:22 - public word is placed right here if we
443:25 - change it to private it means that name
443:27 - is still accessible within here and here
443:30 - which is only the limit of the class but
443:32 - as you can see it's not applicable here
443:35 - this is why you need the public Getters
443:37 - and Setters so I'll explain that what
443:39 - that means now so we prevent these from
443:41 - accessing outside the class by making
443:44 - them private so this functionality no
443:46 - longer works so what you have to do
443:48 - instead is for every field that you have
443:50 - you need to create a getto and a set a
443:52 - function so in order to set a value we
443:55 - can have public and because we're
443:57 - setting it we don't need to return
443:58 - anything so it'll be void and we can say
444:00 - set name and then we pass in string name
444:04 - and then we simply just say this. name
444:06 - equals name so when someone calls set
444:09 - name and pass in the name like this we
444:11 - just overwrite it so let's see how that
444:13 - looks so if we comment these two lines
444:15 - out we can simply say person do set name
444:18 - and then we can say Harry so this line
444:21 - is directly replaced by this line and
444:23 - now if you run this we'll see that Harry
444:25 - should be changed there you go abber is
444:28 - changed to Harry this is really powerful
444:31 - because what we can do now is restrict
444:33 - the access inside here and make sure
444:35 - that the value contain something genuine
444:37 - we can say if string is null or empty
444:41 - and then pass the name inside there if
444:44 - the string isn't null or empty then we
444:46 - assign it and if it is null or empty
444:49 - then what we can do inside here is we
444:51 - can say else this do name equals nothing
444:54 - and we can keep it blank or we can use
444:56 - string. empty just to make sure that we
444:58 - know that the name has been blanked out
445:00 - if they've entered something invalid if
445:02 - they've entered something that's valid
445:04 - we assign it if it's invalid then we
445:06 - don't assign it and we just initialize
445:08 - it back to nothing and because our
445:09 - options are endless with this we can
445:11 - actually make this into something else
445:13 - we can simply just say invalid name so
445:15 - then what happens is if we try and
445:17 - change this to nothing and we run the
445:19 - code
445:21 - we can see that we get invalid name
445:22 - being printed to the screen and that's a
445:24 - lot better than if we had string.empty
445:27 - because if you had strings are empty
445:30 - then it would kind of say nothing then
445:31 - it looks like something's went wrong if
445:33 - you have something like invalid then
445:35 - that gives you a bit of a bar message so
445:38 - we can have invalid name there so using
445:40 - our Setter Let's us change our name from
445:42 - down here without directly exposing the
445:44 - public if he expose the public then
445:46 - everyone who uses classes can simply
445:49 - change the name to whatever they want
445:51 - having it private and only changing the
445:53 - name within the set name function is
445:55 - very preferable because you can restrict
445:57 - the access and what people can set the
445:59 - values to if they try to set it to
446:01 - something that's not valid then we set
446:03 - it to invalid name whereas before when
446:06 - we did this and if we make this public
446:10 - again we can simply set this to
446:12 - something bad like null null is a very
446:14 - bad value but it still lets us have it
446:17 - and the reason why it's very bad is if
446:19 - you you try to do something like this
446:21 - person do equals and just some empty
446:24 - brackets now even if I just leave this
446:26 - empty the fact that you try call equals
446:29 - onside person. name is going to be a bit
446:32 - of a
446:33 - problem so we can say person object the
446:36 - name property inside it and we're
446:38 - checking if it equals to abber for
446:39 - example but because we've just set it to
446:41 - null let's see what
446:43 - happens you see that we actually get an
446:45 - exception it's a null reference
446:47 - exception because if you hover over name
446:49 - you see that returns back null nulls are
446:51 - very bad in this case whereas if we
446:53 - actually bring our function back and we
446:56 - make this into a private and then if we
446:58 - try and take this value our null value
447:01 - and place it straight inside our set
447:03 - name if you uncomment it get rid of the
447:06 - quotation marks and if you actually try
447:08 - and assign it to null let's see what
447:10 - happens then we're going to get invalid
447:12 - name and this prevents us from breaking
447:14 - our code if a function like equals were
447:17 - to be called on any of our properties
447:18 - inside of name so now that we've done it
447:20 - for our name we can also do it for our
447:22 - age but before we do that we can also
447:25 - call a function called get name return
447:28 - details gives you back these details in
447:30 - a very specific fashion but what if you
447:32 - wanted to do something like this your
447:35 - name is and then you wanted to do
447:37 - person. name but of course you can't do
447:39 - that because name is no longer public so
447:42 - you can't reference it directly so we've
447:44 - got a set name and then now we need to
447:46 - do a get name so we can have public and
447:49 - because name is a string the return type
447:52 - is going to be string and we can say get
447:54 - name and this function is very simple it
447:56 - just returns back name and that's it
447:59 - there's no parameters because all it
448:01 - does is return back a value and in this
448:03 - case it's just returning back name so
448:06 - instead of using person. name in here we
448:08 - can say person. getet name open close
448:11 - the brackets to indicate it's a function
448:12 - but there's no parameters now you see
448:14 - that we have no compile errors so now if
448:16 - you run that you'll see that it says
448:18 - your name is invalid name so let's
448:21 - actually give it a
448:22 - value and we can say hurry again run the
448:25 - code there you go your name is hurry so
448:28 - let officially change it and now let's
448:30 - work on the
448:31 - edge so just following the exact same
448:33 - approach we can have a public void set
448:37 - age int age and instead of just doing
448:41 - this. age equals age let's try set some
448:43 - boundaries on this we can wrap this
448:46 - inside an if statement so as for the
448:48 - condition we want to valid Val if the
448:50 - age is successful so we want to do if
448:52 - age is greater than or equal to zero and
448:54 - age is less than or equal to 150 so this
448:57 - means if the age is less than zero or
448:59 - greater than 150 then this is going to
449:01 - return back false and then it's not
449:03 - going to assign the value and we can
449:05 - simply assign it to minus one minus one
449:08 - is just so we know it's a bad value so
449:09 - now that we've created our set age we
449:11 - can actually make our get age so we want
449:13 - to return back an INT because that's
449:16 - going to be the data type PR age so we
449:18 - do public int get age we don't need any
449:20 - parameters cuz as like the name we're
449:23 - just simply returning something so we
449:25 - can say return age so now that you've
449:27 - made the set age and the get age let's
449:29 - actually use it in our code so we've
449:31 - made our set name and let's say person
449:34 - do set age and we have 25 inside here
449:37 - just like above and then now that we've
449:39 - set the age let's appin this sentence we
449:41 - can say and your age is and then person.
449:45 - getage perfect so let's run the code and
449:47 - see what happens there we go we have 25
449:50 - and Harry being
449:52 - changed so another little tip when we
449:55 - doing this code our get age is one line
449:58 - and I'll set age as a couple of lines
450:00 - but fundamentally only assigning age so
450:02 - what we can do is we can make these into
450:04 - the tertiary operator so as we can see
450:06 - here this is the condition if this
450:09 - returns back true then we assign age our
450:11 - local parameter and if this returns back
450:13 - false we assign minus one so we can
450:16 - actually make this into this. AG equals
450:19 - if you remember remember the format of
450:20 - our conditional operator use condition
450:22 - true and then condition false so this is
450:25 - our condition that is leading our if
450:28 - statement and if this returns back true
450:30 - then we do question mark and put age in
450:32 - there and then call on if it returns
450:34 - back false then it's simply minus one
450:36 - there we go so this has actually been
450:38 - entirely replaced by this one simple
450:41 - line and we can do the same thing for
450:43 - our string so we can say this.name is
450:46 - equal to string that is null or empty
450:48 - pass the name name inside there and if
450:50 - that is true then we assign it to name
450:53 - and if that is false we say invalid name
450:55 - let's comment this one out and let's see
450:57 - if all code runs okay
450:59 - still hurry 25 hurry 25 and now let's
451:03 - try our bad values so we can try to set
451:05 - the age to 200 and the value to nothing
451:08 - and let's see what happens we get
451:10 - invalid name minus one and there you
451:13 - go perfect so that's working okay let's
451:15 - undo them values and you can see that
451:18 - this has been shorten completely another
451:20 - top tip for functions like this you can
451:22 - actually use something called Arrow
451:23 - functions and if you've done any
451:25 - JavaScript this might be quite familiar
451:27 - so we can have our get ede and instead
451:29 - of open the curly braces at this point
451:32 - we can actually place this Arrow inside
451:34 - so if we comment out this one with arrow
451:36 - functions you can only return back one
451:39 - simple line so because this is only one
451:41 - line we can have return age but our
451:44 - functions don't like the keyword return
451:46 - any variable that you put straight
451:48 - inside here is automatically applied
451:50 - that it's a return type so we literally
451:52 - just put age get age returns us back
451:55 - with age if this is confusing then stick
451:58 - to this approach but this can might tidy
452:00 - up your code because instead of having
452:02 - all of this and all the curly braces for
452:04 - one simple line you can use Arrow
452:07 - function so if you actually copy and
452:09 - paste but first comment out all of these
452:11 - functions you can see how small the code
452:14 - can actually get there we go and then
452:16 - let's actually have a public void set
452:20 - age let's put our R function in and then
452:22 - we can take this one line and paste it
452:24 - straight into here so you can see that
452:26 - these two lines are now being replaced
452:28 - by all of
452:29 - this and of course we need our int age
452:32 - inside here there we
452:35 - go so now we can do the same thing with
452:37 - our set name we can take
452:40 - this we can have public vo set name
452:44 - String name and then have our Arrow
452:46 - function and then simply paste that in
452:48 - you can see that this will get a little
452:49 - bit long now but it's still ideal I've
452:52 - got the code zoomed in but if you put
452:54 - that to 100% you'll see that this code
452:56 - is actually pretty small it's just I've
452:58 - zoomed in just so you can see the code a
453:00 - lot
453:01 - clearer and then finally for public
453:05 - string and we can get name and then we
453:07 - simply just do arrow and then name and
453:10 - you can see that with all this other
453:11 - code commented we just relying on these
453:13 - functions as we just created and you'll
453:15 - see there's no console errors or
453:17 - anything else so if you try and run it
453:19 - you'll see that everything is going okay
453:21 - of course if you don't like this
453:23 - notation and you don't have to include
453:24 - it you can stick with the curly braces I
453:27 - don't use Arrow functions a lot in
453:28 - practice because there isn't many
453:30 - situations where you'd actually use them
453:32 - and even if you do some people might not
453:34 - like them or there might be certain
453:36 - guidelines that you might be following
453:37 - inside a
453:38 - company what I do suggest you stick with
453:41 - is the tertiary operator these are a lot
453:44 - good and a lot better to use since it
453:46 - reduces the cord drastically if we
453:48 - actually remove
453:49 - this and I'll paste it back in just so
453:52 - you can see it for reference inside the
453:53 - resources but you can see that these
453:55 - four functions are now reduced to on one
453:58 - page you can see that they're all got
453:59 - one lines and they're pretty short so
454:02 - let me undo that just so you can see the
454:03 - original code and have it for
454:05 - reference so there's a lot covered
454:07 - inside this video so let's just have a
454:09 - little recap before we finish up so just
454:12 - to start at the beginning when we
454:14 - initialize our person with their name
454:16 - and their age we don't actually have any
454:18 - other opportunities to change their
454:19 - value which is where this comes in you
454:22 - can actually just say a person. name and
454:24 - assign any sort of value you can put
454:26 - anything inside there and it will assign
454:28 - it directly unconditionally the problems
454:30 - of doing this is someone might expose it
454:32 - to null by accident and some wearing
454:34 - your code if you're using something like
454:36 - equals this will actually prevent an
454:38 - exception of course you can wrap this
454:40 - inside a TR catch but this is
454:41 - unnecessary because we can prevent this
454:43 - in the first place it's always best to
454:45 - prevent an exception than to put
454:47 - additional code in like a TR catch in
454:49 - order to catch something that you can
454:50 - prevent in the first place prevention is
454:52 - definitely better than the Cure in this
454:54 - case so having something like a person.
454:57 - name being exposed it's not so much for
454:59 - the integer because integers will always
455:02 - have number values whereas strings they
455:04 - can be initialized to null there is no
455:06 - such thing as null in our age that our
455:09 - default value for an integer is zero so
455:12 - we don't really have the same issue we
455:13 - started introducing the name function
455:15 - and the age function these are used so
455:17 - we can control what Val values get
455:19 - assigned to our local variables and we
455:21 - also have our get functions get name and
455:23 - get age so let's explore how these are
455:25 - made inside our Cass and expand on that
455:28 - and see how they work so first we need
455:30 - to make sure that our variables are
455:32 - actually private they're private so we
455:34 - can't access them just like this if I
455:36 - copy and paste this line above you'll
455:37 - see we're going to get a compile error
455:39 - and this error is because we can't
455:41 - actually use it because as it says here
455:43 - it's inaccessible due to its protection
455:46 - level and the protection level comes
455:48 - from the fact that this is indeed
455:50 - private it's private so it's only
455:52 - accessible within class person so every
455:55 - reference to name can be used inside
455:56 - here just not outside so the only way to
455:59 - be able to change the name now you've
456:00 - made it private is by enforcing this
456:03 - function the good thing about this
456:04 - function is we can check if the value is
456:06 - invalid and then we can star it if it's
456:09 - valid and then change it to something
456:10 - else if it's invalid and then we can
456:12 - wrap this if statement around in a
456:14 - conditional Operator just to make it a
456:16 - little bit shorter and in order to
456:18 - retrieve an name because now that it
456:19 - made it public we can neither set or
456:22 - retrieve it so we have our get name
456:24 - function that simply just returns it
456:26 - back to the screen nothing special here
456:28 - and the same thing for our set age we
456:30 - can check if the age is between 0 and
456:32 - 150 and assign it and if it's not assign
456:34 - it to minus one and then again wrap it
456:37 - around in our conditional operator and
456:39 - then for our get age we can just return
456:40 - age I demonstrated our functions inside
456:43 - here you can take all of these on line
456:45 - functions and actually add them all in
456:47 - one line without the need of cly Braes
456:49 - if you want to return back in age then
456:51 - you simply just type in age just like
456:53 - you can see here and here when you do
456:56 - assignment you want to specify this.name
456:58 - equals but when you're doing returns you
457:00 - just need to type in the variable that
457:01 - you need of course this looks a little
457:03 - bit cleaner and a bit shorter but not
457:06 - Everyone likes this notation so it's
457:07 - completely up to the developer or the
457:09 - environment that you're working in and
457:11 - finally we just have our return details
457:13 - and then we can make use of them just
457:15 - like this by using person which is the
457:17 - name of our local variable for new
457:19 - instance followed by a DOT and then set
457:21 - name set age and then get name and then
457:24 - get
457:27 - age so now that we're dealing with
457:29 - classes it's important you focus on the
457:31 - scope we have a person person here
457:33 - that's defined within the main which
457:35 - means it's only Within These two curly
457:37 - braces so if we had a static void and a
457:39 - function that did something inside here
457:42 - we can't access person inside here if we
457:44 - take out the comment and we try it the
457:46 - only reference we have is accessing the
457:49 - class directly not this local variable
457:52 - if you want to access local variable
457:54 - from inside this function then you'd
457:56 - simply have to pass it in like this and
457:58 - then it'll finally become available as
458:00 - you can see now there's two and it says
458:02 - as a parameter and the same goes for
458:04 - this class above just because we have
458:07 - name and age up here it doesn't
458:09 - necessarily mean that we can magically
458:10 - use name down here if we have something
458:13 - like a static int defined right here
458:16 - then we can use this integer inside
458:18 - these function functions as it says
458:20 - there it's available we can sign that to
458:22 - 10 and it's also down here available and
458:24 - we can sign that one to 20 and you'll
458:26 - see we have no compil errors but if we
458:28 - take this and put it inside our return
458:30 - details function then you're going to
458:31 - get an exception because X is not
458:33 - available within that scope and the
458:35 - functional scope matters inside here as
458:37 - well if you have a string test inside
458:40 - here we can just access it in another
458:42 - function for example the Constructor we
458:45 - can't just print out test as a screen
458:48 - the handy or classes if you want
458:49 - variables to be available throughout the
458:51 - class then you put them at the top we
458:53 - can have that private string test and
458:56 - there you go you see that the compil
458:57 - error is now gone and we can give that
458:59 - initial value and then you can use that
459:01 - to print to the screen Etc and just to
459:04 - note when you have a variable that's
459:06 - called exactly the same thing we have a
459:09 - private string test up here and we can
459:11 - say hello and then we also have a string
459:13 - test down here so let me demonstrate
459:16 - what happens when two variables are the
459:17 - same so let's let's move this into our
459:20 - Constructor so if we run this as it is
459:22 - we test equals hello and then we print
459:24 - out test and then run the
459:26 - code there you go we get hello printed
459:29 - and just ignore this this is from the
459:31 - return details function as we've got in
459:33 - the main down here return details so
459:37 - we've made our new Constructor and then
459:39 - assigned it the value with abber and 23
459:41 - and then we can get hello printed to the
459:43 - screen but let's say we actually made a
459:44 - string test inside here and we said hi
459:47 - instead of hello then which one you
459:48 - think get use the global one or the
459:51 - local one let's run it and find out it's
459:54 - actually the local one the compiler will
459:56 - always prioritize the local variables
459:58 - over the global variables and this is
460:00 - the reason why you need to type this dot
460:03 - because when you use name it's always
460:05 - going to reference the parameter when
460:06 - it's name on its own use console right
460:09 - line and say name and then if we do
460:11 - after this line and another console
460:12 - right line and we say this. name then
460:14 - these are completely different this one
460:16 - is the parameter and this one is talking
460:18 - about the variables from the class and
460:20 - these are known as our
460:22 - Fields local variables take presidence
460:24 - over our Fields as long as they're
460:26 - called the same thing as you can see now
460:29 - it says it's assigned but the value is
460:30 - never used if you take the string test
460:32 - out then you can see it's now being
460:36 - used there you go hello gets printed out
460:39 - to the screen and there you go the green
460:41 - line has went because we're using it
460:43 - down here scope is very important when
460:45 - you're designing these classes and just
460:47 - to note that the variables that are
460:49 - available inside here are not going to
460:52 - be necessarily available inside here
460:54 - unless you make them public and even
460:56 - when you make them public that doesn't
460:58 - necessarily mean that this is still
461:00 - available magically over here name will
461:03 - only be available through an instance of
461:06 - the person class so if we do person.
461:08 - name now we can see that that's
461:10 - available as our field so that's why
461:13 - that makes it
461:14 - public if we try and make this private
461:16 - again just to return that value back
461:20 - and we scroll down you'll see now we get
461:22 - a compile error because it's
461:23 - inaccessible because it's outside the
461:25 - scope because it's now a private
461:30 - variable so we've covered what it means
461:32 - to have a public or a private field if
461:35 - you have a private field then you're
461:36 - going to have to use Setters and gets in
461:38 - order to work with this field if you
461:40 - make it directly public then you won't
461:42 - need any Setters and gets because the
461:44 - user can just type iname after their
461:47 - public instance
461:48 - so you can have person followed by the
461:50 - dot and right now you can't see name
461:52 - inside here and the blue slittle icon is
461:55 - no longer there the reason why it's not
461:57 - there is cuz there's no public Fields if
462:00 - we then change this to
462:02 - public remove the dot and readit you'll
462:04 - see that our blue square is now back
462:07 - because our field is now accessible and
462:09 - we can assign that to anything that we
462:11 - want the whole point of making this
462:12 - private is your only restricted access
462:15 - so you know what you're doing and the
462:17 - reason why I say that that is if they
462:19 - enter something that's invalid then we
462:21 - want to specify something like invalid
462:23 - if we give them Public Access then we're
462:25 - not going to know and we won't be able
462:26 - to validate what they've entered so in
462:29 - order to do it through a Setter we can
462:31 - make it private create our set function
462:33 - with a return type it's going to take in
462:35 - a string parameter and this string has
462:37 - to be the same data type as the
462:39 - parameter you're talking about call it
462:41 - name or whatever you want it to be and
462:43 - because these two are called exactly the
462:45 - same thing we have to use this dot so
462:47 - we're referencing this name instead of
462:49 - this name in the parameters and here
462:50 - we're just using a conditional operator
462:52 - and we're saying if the string is not
462:54 - null or empty hence the exclamation
462:56 - point then we assign it to name name
462:59 - gets put in this. name and if this were
463:01 - to return back false then we place
463:03 - invalid name straight into this. name
463:06 - and for the get we simply just return a
463:08 - string since that's a data type for name
463:10 - and then just return it back and it's
463:12 - that simple and the same thing for age
463:14 - we validate the age range set it and if
463:17 - it's outside this range we can set it to
463:18 - minus one so as you can see this is a
463:20 - bit long we have our private variables
463:23 - and then we have two functions one for
463:25 - set one for get and the same thing for
463:28 - age so these are called fields and gets
463:31 - and Setters so I'm going to introduce a
463:33 - notion called properties and properties
463:35 - make it easier to do this exact notation
463:38 - so let's now see how properties created
463:40 - since these fields are private we need
463:42 - to make something that's actually public
463:44 - so we can do something like this we can
463:46 - say public string
463:48 - and we can say name with a capital N so
463:51 - now you can see that name and name are
463:53 - not actually clashing and we can assign
463:55 - that in here should we want to and you
463:57 - see we don't need this dot anymore
463:59 - because this is now different it's a
464:02 - capital N so this one always references
464:04 - this and this references this so we need
464:07 - to add something else onto here so if
464:10 - you create them
464:11 - both now you can see we can do age
464:13 - equals age and there'll be no problems
464:15 - with this so now that we've made our two
464:18 - new Fields so now we have our two new
464:20 - public variables which are known as our
464:22 - Fields let's see how we can turn them
464:24 - into properties so if you remove the
464:26 - semicolon you can actually add in some
464:28 - curly braces so inside here we need a
464:31 - getter and Setter just like we had down
464:34 - there but we have a quick Ann notation
464:36 - for it instead of making two distinct
464:38 - functions you can actually create a
464:40 - little section inside these curly BRAC
464:42 - to get and set the name so you got to
464:44 - think of this as a middleman the same
464:46 - way this is a middleman
464:48 - we call this function and this function
464:51 - will affect the name and this is going
464:53 - to be the same principle we make use of
464:55 - name with a capital N but it will
464:57 - actually be affecting the lowercase n
464:59 - variable these are going to be our new
465:01 - middle mans and they will directly
465:03 - replace the gets and sets here so what
465:05 - we can do in here is we can say get
465:08 - press enter go on the next line and make
465:10 - some cly braces and then we can also
465:12 - have a set so this is like our mini get
465:15 - and mini set function just like we've
465:17 - got here by as you can see it's a lot
465:18 - shorter we don't need to give it a
465:20 - distinct name or set the public or
465:22 - anything else we just give it a simple
465:25 - set and get so if you have a look at the
465:27 - compile error it says not all call Path
465:30 - return of value because as it says here
465:32 - this get function is actually a mini
465:34 - function built into this property
465:37 - person. name which is our name with a
465:39 - capital N and then it's do get and this
465:41 - returns back a string so if we actually
465:43 - just type in return this then it gets
465:45 - rid of the compiler error but of course
465:47 - we don't want to return nothing we
465:48 - actually want to return name because
465:50 - remember what I said string name and
465:52 - intage up here is our private field they
465:55 - actually start the data the public
465:57 - string name and the public in age is the
465:59 - middleman that coordinates all of the
466:01 - gets and sets to do with the private
466:03 - variables so for the set just for now we
466:05 - can say name equals and then what do we
466:08 - give it the value of so if we hover over
466:11 - set it doesn't actually give you any
466:13 - indication of what it's going to be so
466:15 - let's have a look if we press control
466:17 - space then we don't also get the list of
466:19 - everything that we can add inside here
466:21 - now it's very difficult to understand
466:23 - what to assign this to when we have set
466:26 - name we've gave it a string name
466:28 - parameter so we can use name down here
466:30 - so what's our parameter in this case
466:31 - well the function itself doesn't
466:33 - actually tell us but I'm telling you
466:34 - right now that the parameter is actually
466:36 - just called value and this is a very
466:38 - default parameter that you'll see
466:40 - everywhere when you doing gets and sets
466:42 - inside a property you don't have to
466:44 - specify value or anything it just gets
466:47 - simply assigned in just like here where
466:49 - we have string name this will be a
466:52 - string value so it will look something
466:53 - like this behind the scenes but of
466:55 - course you can't actually type this in
466:57 - cuz remember these properties are trying
466:59 - to give you a short hand on how to do
467:01 - gets and Setters so you just got to
467:03 - remember that when you trying to set you
467:04 - get the property inserted as value so
467:07 - you can startall that into name so
467:09 - that's it the name is actually sorted
467:11 - now so before we do the same thing for
467:13 - age let's see how we can use this inside
467:15 - the code so we scroll down to our main
467:18 - we have a person person and then we have
467:19 - a console right line that prints the
467:21 - details so we can actually do person Dot
467:24 - and you can see now that it's slightly
467:26 - different if you ignore the age since
467:28 - that's returned back as a field since we
467:30 - haven't done that yet you'll see that
467:32 - name now has a little Cog next to it
467:34 - show only properties this is a new icon
467:37 - that we haven't saw yet so this is our
467:39 - new icon it says it's going to return us
467:41 - back with the string and we can actually
467:43 - execute a get and execute a set straight
467:45 - on this name then we can say name equals
467:48 - Harry and we don't get any compiler
467:49 - errors whatsoever this lets us do it
467:52 - completely so now if we do another
467:54 - console right line and we say person do
467:56 - return details and let's run that and
467:58 - you should see that the name gets
468:01 - changed there we go ABA gets changed to
468:04 - hurry perfect so after we've got person.
468:07 - name let's see how we can also get the
468:10 - value so we can just say string
468:12 - interpolation your name is and then we
468:15 - do person and followed by a DOT and as
468:18 - you can see the exact same list that we
468:20 - got given over here is given right here
468:22 - as well name also says get and set and
468:25 - it returns back a property which is a
468:27 - string type so we can open like this and
468:30 - you'll notice that we don't have the
468:31 - parentheses after it and the reason for
468:33 - that is because the brackets indicate
468:35 - that you're calling a function but a
468:37 - property is just a property it's almost
468:39 - like a variable so you're not actually
468:41 - needing to put any brackets after it
468:43 - because there's no function to call so
468:45 - as you can see this is exactly the same
468:47 - as this
468:48 - in this case we're actually setting the
468:50 - value and in this case we're actually
468:52 - getting the value so let's comment this
468:54 - line out and let's see what
468:56 - happens your name is Harry so that's
468:59 - worked okay so now let's do the same
469:01 - thing for
469:02 - age remove the semicolon add the curly
469:05 - brace we can say get and then return age
469:09 - and then simply do set and then do age
469:12 - equals value there we go so now we got
469:15 - that set up if we return back down here
469:17 - and we see person dot so as you can see
469:19 - now the age is being removed as being a
469:21 - field as we saw in the blue icon it's
469:24 - now being turned into a spanner which
469:26 - means it's a property as shown here show
469:28 - only properties so now you can see it
469:30 - returns back an integer and we've got a
469:32 - get in a set so we can set that to 25
469:35 - for example and then we can append onto
469:37 - here and your AG is person. AG you see
469:40 - that it's a couple a just as this one is
469:42 - a capital N and now we have get and set
469:44 - available and again we don't need the
469:46 - brackets inside here since this is a
469:48 - property not a function now let's run it
469:51 - we should see Harry 25 there you go your
469:53 - name is Harry and your age is
469:56 - 25 perfect so as you can see now is
470:00 - instead of having our set name and get
470:01 - name which are these two functions we
470:04 - actually have them contained within a
470:06 - property we call this property and it
470:09 - affects these variables but as you can
470:11 - see just as these functions below were a
470:13 - middleman we've now moved the middleman
470:16 - into these properties so as these are
470:18 - only one line you're probably thinking
470:21 - there's probably a better way of doing
470:22 - this and it's a lot quicker for syntax
470:24 - and you're right there is so let's
470:26 - explore that so I said before about
470:28 - Arrow functions when you're doing
470:30 - something like this get name you can
470:32 - have public string get name and then you
470:35 - can simply do Arrow name and this is a
470:37 - very common string function get name
470:39 - that just returns back a value and you
470:41 - can make that into an arrow function by
470:43 - literally just putting back name so we
470:45 - can actually do the same thing but for
470:46 - our properties
470:48 - so these both contain one line so we can
470:50 - actually minimize this and if we just
470:52 - block comment this
470:54 - out we can say public string name and
470:58 - then we can have get and then the same
471:00 - thing with the arrow function when we're
471:02 - doing Arrow function down here you would
471:04 - simply won't use the return keyword you
471:06 - would just type in the variable you want
471:07 - to return so we can say get arrow and
471:10 - then simply low case name and then add a
471:12 - semicolon just so you know that that
471:14 - section is ended and then straight after
471:16 - we can have set
471:18 - and then arrow and then name equals
471:20 - value just like that so as you can see
471:23 - these contents are exactly the same
471:25 - we've actually return them back in a
471:26 - short space and of course here as we got
471:29 - a compile error it just expects a semic
471:31 - callon to be right at the end here there
471:33 - you go and now we do the same thing for
471:34 - our
471:37 - age we can do public int age get Arrow
471:42 - age and set Arrow age equals
471:45 - value perfect so now you can see that
471:48 - this has been drastically reduced if I
471:50 - cut this just underneath you'll see that
471:52 - almost all of these lines are just
471:54 - replaced in a two and you'll see that
471:55 - our functionality will still work
471:57 - exactly the same if we just run the code
471:59 - Harry and 25 is being reassigned over
472:02 - our default variables perfect of course
472:05 - now if you want to add some more
472:06 - functionality inside here for example in
472:08 - our set name we had a little check that
472:11 - makes sure that it's a valid name before
472:13 - we assign it so we actually take
472:16 - this and paste it over here then you see
472:19 - the lines grown quite a lot so what's PR
472:22 - to do is if you're going to have any
472:23 - data inside here that does a little bit
472:26 - of logic then it's best to keep the
472:27 - curly braces since you can have a bigger
472:30 - output and it looks a bit more sensible
472:32 - if you just simply getting and you're
472:34 - setting the variables then you can leave
472:35 - this notation so let's undo this and
472:38 - bring back the original ones in this
472:43 - case there we go and then we can take
472:45 - that line and in the set we can actually
472:47 - replace it here so as you can see this
472:49 - is a little bit grayed out so let's put
472:51 - the semicon at the end and let's see why
472:53 - this is grayed out name can be
472:55 - simplified so what we're doing now is
472:57 - name and all of these variables are
472:59 - actually looking at the private variable
473:02 - whereas if you actually look down here
473:03 - and we uncomment this you'll see that
473:06 - set name if we double click on this one
473:08 - this is the only reference to it which
473:11 - is our private variable appear and the
473:13 - reason why this doesn't need to be used
473:15 - in this case is because our parameter is
473:18 - now called
473:21 - value so it's saying the name is equal
473:24 - to checking if the value is null or
473:26 - empty assigning the value into name if
473:29 - not and then if it is empty then we
473:31 - assign invalid straight into name in the
473:34 - case of our set name our name was our
473:37 - parameter the same goes here if we
473:39 - change this to Value we can change these
473:41 - two for Value as you can see now this
473:43 - dot is actually grayed out and it can be
473:45 - simplified to just simply name and the
473:47 - same principle applies above so let's
473:50 - comment these back out and scroll back
473:51 - to the top so now that we've assigned
473:54 - name there we go we've got our check
473:56 - inside there and you can also leave this
473:58 - on one line if you want you can even
474:00 - drop the curly brace in just so it looks
474:02 - like this instead of having it all on
474:04 - one line so you could do this and this
474:07 - would be applicable as well but the
474:09 - second you start to put it all on one
474:11 - line then it gets a little bit messy
474:13 - quickly so if you leave the outer
474:15 - bracket just like that then you can can
474:17 - be pretty short since you don't need
474:18 - more curly braces so now that we've done
474:21 - that for the name let's do it for the
474:23 - age as well so we had this. age we check
474:25 - the range and we assign the relevant
474:27 - values so let's take that paste it over
474:31 - this we don't need this dot anymore and
474:34 - age in this case is actually going to be
474:35 - the value gets passed
474:37 - in so replace all the ages with value
474:41 - there we go so if the value passes the
474:43 - range check we put the value inside age
474:46 - or not we can put minus one Inside Edge
474:49 - and again we can have the same thing we
474:51 - can use our arrows inside here there we
474:53 - go so now we've got our code drastically
474:57 - reduced so we went from these big
474:59 - functions that have to be defined with
475:01 - specific names over to our properties
475:04 - and they went from really small to just
475:05 - a little bit bigger but now they have
475:08 - advanced connections just to make sure
475:10 - that the variables are okay before you
475:12 - assign it in so now that we've got our
475:13 - properties let's have a look so inside
475:15 - our Constructor we we don't also need to
475:18 - use our local variables which is our
475:20 - private ones directly we should actually
475:23 - get rid of this now and we should always
475:25 - do everything through our properties
475:27 - name equals name and because this is a
475:29 - capital and this is a lower case we
475:31 - don't need this dot in
475:33 - there there we
475:35 - go so what you should do in the return
475:38 - details function is also use the capital
475:40 - n and the capital age so when you hover
475:42 - over these you're actually referring to
475:44 - the property because like I said before
475:47 - these are the middleman to communicate
475:48 - with the private variables you shouldn't
475:51 - need to access the private variables
475:52 - directly you should use the middleman as
475:54 - much as possible so now that we've done
475:57 - that I have one last thing to introduce
475:59 - so if we actually abandon all of this
476:00 - code just to keep it for reference we
476:02 - have something called an auto property
476:05 - and you briefly saw it when we saw it
476:07 - down here so if we actually just bring
476:09 - them back for a
476:11 - second and if you hover over a name down
476:13 - here it says string name get and set in
476:16 - the Cur C brace but you see how the get
476:18 - and set is empty it just has two values
476:21 - inside there and it just ends a curly
476:22 - brace with no actual logic you see in
476:25 - our get we're saying age and our set
476:28 - we're saying age equals this so when
476:30 - we're doing Auto properties what you can
476:32 - do is you can actually make these public
476:37 - again change these to a capital N
476:39 - changes to a capital A and just straight
476:42 - after it you can say Get Set just like
476:46 - that
476:48 - and what that will do is although
476:49 - they're actually made public what it's
476:51 - doing behind the scenes is actually
476:53 - doing this for you it actually has a
476:56 - private and a public for you behind the
476:59 - scenes this is just a Shand these are
477:01 - what's called a auto property what it
477:04 - does is it makes an anonymous property
477:05 - behind the scenes as I'll show you in
477:07 - Microsoft documentation right now as it
477:10 - says here in CP 3 or later Auto
477:12 - implemented properties make property
477:14 - declaration more concise when no
477:16 - addition logic is required and what that
477:19 - means is no additional logic all of
477:22 - these are additional logic if you just
477:25 - simply assigning a value and reading it
477:27 - back just like here then this is no need
477:30 - to write get name and set name if all
477:32 - you're doing is getting and setting it
477:34 - if you're getting and setting it but
477:35 - there is a certain amount of logic as we
477:37 - have here we essentially have a
477:39 - conditional operator that's making a
477:41 - subconscious decision about what to
477:43 - assign the name to but if you just
477:45 - simply assigning something like this
477:46 - then an auto property is perfect they
477:49 - also enable client code to create
477:51 - objects when you declare a property as
477:53 - shown in the following example the
477:54 - compiler creates a private Anonymous
477:57 - backing field that can only be accessed
477:58 - through the properties get and
478:01 - Setters as you can see here just like in
478:03 - our example we have public int something
478:06 - and then get and set and then they have
478:09 - a public in something with the get and
478:10 - set as well and they can use it just
478:12 - here to access it
478:14 - directly and because they're simply just
478:16 - assigned and getting the values and
478:18 - there isn't any additional logic then
478:20 - this is the best way to do it and you
478:22 - get as it says here an anonymous private
478:25 - backing field so this would be the same
478:27 - thing as doing this private string name
478:31 - and private int AG so once you do that
478:34 - and you make this into the get and set
478:36 - properties which are these two right
478:41 - here this and this line together make a
478:44 - property what the auto implement the
478:47 - property does is actually combine this
478:49 - line and this line together and make the
478:51 - private one behind the scenes so the
478:53 - programmer doesn't see it but it will be
478:55 - applicable when the program runs in the
478:56 - compiler and then you only get publicly
478:59 - exposed with this parameter which will
479:01 - be our name property so it will actually
479:04 - make the private for you if you just
479:06 - keep it like we had it a second
479:08 - ago just like this so if you leave it
479:11 - like this it will actually create the
479:13 - private variable behind the scenes as it
479:15 - says here it's Anonymous backing field
479:17 - and it can only be accessed through name
479:20 - and age and as you can see none of our
479:22 - code has actually changed all of these
479:25 - still function okay and if we run the
479:26 - code we should still get Harry and
479:29 - 25 so just to sum this video up since
479:31 - there was a lot covered the bottom line
479:33 - is if you're going to have any sort of
479:36 - values that require any logic then you
479:38 - should use normal properties if you're
479:40 - simply just going to assign and get the
479:42 - value and it doesn't matter and you have
479:44 - no control over it then you can use the
479:46 - auto implemented properties since that
479:48 - will do the same thing with less code
479:50 - using the gets and Setters is the old
479:52 - way of doing this and you should always
479:54 - use the properties going forward Getters
479:56 - and Setters are very helpful to know
479:58 - just so you understand what they are and
479:59 - why they exist but you should not that
480:02 - properties are the best way forward
480:04 - properties give you access to doing the
480:05 - same logic as it says inside here if you
480:08 - do an auto-implemented properties then
480:10 - you're not allowed to use the logic
480:12 - inside the set or the get so if you
480:14 - don't want to do any logic then don't
480:16 - use the AL implemented properties only
480:18 - use the normal properties to make a get
480:20 - and Setter you just do set name get the
480:22 - parameter and assign the local variable
480:25 - and the get just returns it getting back
480:27 - a property you want to capitalize your
480:29 - private variable if you had private
480:31 - string name with a lowercase n you want
480:33 - public string name with a capital N you
480:36 - get the name and then you can set the
480:37 - name with some sort of conditional
480:39 - operator or any if statement or anything
480:41 - inside here and the same thing goes with
480:43 - the age you can have a public int age
480:45 - with a capital a and a private end age
480:47 - with a lowas here you can get the age
480:49 - and then set the age with a conditional
480:51 - operator again or any other code if you
480:54 - don't require any logic like these two
480:56 - lines indicate then you can simply just
480:58 - use the auto properties as demonstrated
481:00 - above here and they can be used quite
481:02 - easily throughout the Constructor and
481:04 - our functions and even outside the
481:06 - function when the user is trying to call
481:09 - them but one thing that we haven't been
481:11 - able to solve and you may not have
481:13 - noticed this as a nuisance the problem
481:15 - is when you trying to return details
481:17 - about something we're having to call
481:18 - this function every single time if we
481:21 - have an INT age for example and made
481:22 - that equal to 23 and we did consle right
481:25 - line and simply placed age inside the
481:26 - brackets we don't have to do anything
481:28 - like this because it simply just prints
481:30 - the value out if we run the code you'll
481:33 - see that it simply just says 23 this
481:36 - should be pretty simple for our person
481:38 - as well but it's not we need to call
481:40 - return details every single time we want
481:42 - to print the properties and if we don't
481:44 - do this the only way to do it is is by
481:46 - making some string interpolation and we
481:48 - can say person.
481:51 - name and then also include person. AG
481:54 - Etc and then that can print out to the
481:56 - screen just like
481:58 - that of course it doesn't have the same
482:00 - format in but we can also just take this
482:03 - place it straight inside here add our
482:05 - person dot before them person Dot and
482:08 - there you go then you get exactly the
482:10 - same output as call and return details
482:12 - but of course you don't want to do this
482:14 - every time and you certainly don't want
482:15 - to have to type type in return details
482:17 - function every single time as well you
482:19 - want to keep it as just person now of
482:21 - course this is not going to work
482:23 - straight out the box let's try run that
482:24 - and see what happens so we get string
482:27 - override. person and what's going on
482:29 - here is it's saying namespace is string
482:31 - override and then it's a class person so
482:33 - it's just printing out this person
482:35 - object but it's not really doing
482:36 - anything because we haven't really told
482:38 - it to do something so what we can do
482:40 - here is we can actually override the two
482:42 - string method so let me explain so let
482:44 - me set up a couple of examples just to
482:47 - show you what's going to happen at the
482:48 - end so right now we call return details
482:50 - to return these details what we can also
482:52 - do is say do two string and then we can
482:55 - also do these three options return the
482:58 - details convert it to a string or just
483:00 - print the person straight to the console
483:02 - at the end of this little section we're
483:04 - going to make all three of these print
483:05 - out the same values so let's have a look
483:07 - now two string and printing out normally
483:11 - these two lines right here are actually
483:13 - doing exactly the same thing behind the
483:15 - scenes when you place anything inside
483:17 - these brackets inside a console right
483:18 - line it will try and convert it to a
483:20 - string anywhere so whether you put to a
483:22 - string or you leave it as person the
483:24 - console right line function will still
483:26 - accept it so let just comment out the
483:28 - age for the time being in order to make
483:30 - the two string function work as well as
483:32 - just ping person inside the brackets we
483:34 - need to make a special function which is
483:36 - an override function so let's have a
483:38 - look so just underneath our return
483:40 - details still within the scope of the
483:42 - class would say public and then override
483:45 - after we press tab we can follow it by a
483:47 - space and we can see the functions that
483:49 - we can override so in this video we're
483:51 - actually going to cover two string and
483:52 - equals get hash code will actually serve
483:55 - as a default hash function if I show you
483:57 - the documentation it says here a hash
483:59 - code is numeric value that is used to
484:01 - insert an identify an object in a hash
484:04 - based collection this is normally used
484:06 - when you doing hash functions as it says
484:08 - here and for the time being we're not
484:10 - actually going to be using this right
484:11 - now so the two we can do are two string
484:14 - and equals but as you can see our two
484:16 - string is available right now we'll
484:18 - cover equals as an extension in a minute
484:20 - so let's double click on our two string
484:22 - and we get this little template placed
484:24 - in if you don't want the template then
484:26 - it's just an override it returns back a
484:28 - string since it's converting to string
484:30 - it needs to be this exact notation if
484:32 - you drop the T then it's got nothing to
484:34 - override now you go be a compil error
484:37 - cuz there's nothing to override itself
484:40 - so play two string the capitals there's
484:42 - no parameters passed in and then we're
484:43 - going to be returning something so the
484:46 - thing that we're going to be returning
484:47 - is exactly the same as our return
484:48 - details function we actually have two
484:50 - options here we could say return and
484:52 - then return details so what that will do
484:55 - is it will go to this function it will
484:57 - call this function grab that and
484:59 - essentially place inside here and then
485:01 - return it back to the console in the
485:03 - ideal world we don't actually need this
485:04 - return details function so we could
485:06 - comment it out but I'm going to leave it
485:08 - in just so the demonstration doesn't
485:09 - break down here so we can take this and
485:12 - place it straight inside here now we
485:14 - have two functions that essentially do
485:15 - the same thing thing but the advantage
485:17 - is this function is something that needs
485:19 - to be called explicitly do return
485:21 - details whereas this function the two
485:24 - string override actually just gets
485:26 - called naturally without having to add
485:28 - any extensions so if you run the code
485:30 - now you'll see that now the all equal
485:32 - exactly the same value we get three
485:34 - sections that have this maybe we can
485:37 - place back SLT instead just so we can
485:39 - have them all in the same
485:41 - line there we go so you can see all
485:44 - three are exactly the same so what we
485:46 - can do now is if we comment this option
485:49 - and we comment out this function we
485:51 - don't have to include two string if we
485:52 - don't want to we can also comment this
485:54 - one out and we can keep it just as
485:56 - person so as we do when we declare the
485:58 - integer we say inage equals 23 and then
486:00 - we simply print out and this is exactly
486:03 - the notation that we want it should
486:05 - really be this simple there you go one
486:07 - line creates the person and one line
486:09 - with just a variable name goes inside
486:12 - the brackets to print them out the same
486:13 - thing here person person age and age and
486:17 - let's run that code now and there you go
486:19 - you get the person printed and the age
486:20 - printed exactly and straightforward as
486:23 - you may think it should be so now that
486:25 - we've done that let's explore what the
486:26 - equals function needs to be done let's
486:29 - make another person we can say person
486:30 - test equals new person and we can have
486:33 - hurry age
486:34 - 23 now we don't need to print them out
486:36 - in this example we just need to
486:38 - demonstrate this equals function so if
486:40 - you remember with strings we can have a
486:41 - string called Abba for example and we
486:43 - can say do equals straight after it we
486:45 - can say if ABA is equal to Harry then we
486:48 - can do something inside here what I'm
486:50 - trying to demonstrate is once you've got
486:52 - an object you can place do equals and
486:54 - then you can compare it like that so you
486:56 - can also do that with our classes so we
486:58 - can say person do equals and then equals
487:01 - to test and in here we could just say
487:04 - same let's try and make these as same as
487:06 - possible and see what happens so let's
487:08 - keep the name exactly the same just like
487:11 - that and let's copy the 25 down just
487:13 - like that so now these two are
487:15 - instantiated exactly the same way let's
487:17 - see what happens when we've run the
487:19 - equals then we don't get anything
487:21 - printed which means they're not the same
487:23 - so because this doesn't automatically
487:25 - tell us that these two are exactly the
487:26 - same we can override that and provide
487:28 - our own functionality just like we did
487:30 - with the operate overload we override
487:33 - equals we get passed in an object and we
487:35 - need to check something inside it so
487:37 - let's see what we can do inside here so
487:39 - in order to check if something is equal
487:41 - to another thing what can we do so we
487:43 - have a name and an age if this one is
487:46 - the same as this and this is the same as
487:48 - this then two people are exactly the
487:50 - same so let's try that out and see what
487:52 - happens so we can say name which is the
487:55 - property inside the class that we're
487:56 - currently inside and then we can use
487:59 - equals because this is just a string
488:00 - parameter and then we can say that
488:02 - equals to
488:04 - objectname but you can see we've got a
488:06 - little problem here this object is very
488:09 - generic it's just an object every class
488:12 - that you create is derived by an object
488:15 - what that means is every class or
488:17 - integer or double at the end of the day
488:19 - is also just known as an object through
488:21 - inheritance which we'll discuss further
488:23 - on this course but just know that
488:25 - everything inside C is always an object
488:27 - somewhere down the line so what that
488:29 - means is we have to convert it from an
488:31 - object to our custom class which is
488:33 - person in this case so we can use this
488:36 - thing called casting so we can say
488:38 - person person which is just Define a new
488:41 - variable and we can make that
488:42 - immediately equal to object as person
488:46 - so what we've done here is we've said
488:48 - our object which is this parameter is
488:51 - currently an object right now we want to
488:53 - cast it as a person which is kind of
488:55 - like converting into a person and then
488:57 - placing the values inside here so now if
488:59 - we get rid of this comment and instead
489:01 - of using object we actually have a new
489:03 - local variable called person so then
489:05 - here we can say personname there we go
489:08 - now we have access to the person
489:09 - property since we've converted this
489:11 - object into a person and of course we
489:13 - know that we have name and age available
489:16 - so if the name is equal to the person.
489:19 - name and the age is equal to the person.
489:24 - age then we must have a match and of
489:27 - course you want to keep using the
489:28 - properties we're going to use a capital
489:29 - A and there we go so we run the
489:31 - conversion on one line and then we check
489:33 - if they're equal to each other now in
489:35 - this specific case you can actually pass
489:37 - anything inside here so let's try it we
489:40 - can pass five into idea and as you can
489:42 - see there's no compile error cuz like I
489:44 - said five is just an integer which is an
489:46 - object at the endend of the day if you
489:48 - make it a double that works as well
489:50 - there is literally no compile errors and
489:52 - even if you put M to make it into a
489:54 - decimal again there's no compile errors
489:56 - because they're all objects at the end
489:57 - of the day so let's pass Tes in there
489:59 - what you will have to know is if you do
490:01 - accident pass in a double for example
490:03 - like this you're going to hit an error
490:05 - here which will be a runtime error it
490:07 - will try and convert it as soon as it
490:08 - hits this line and obviously you can't
490:10 - convert a double into our person so what
490:13 - you could do just to wrap it around you
490:15 - could say
490:16 - if the object is a person then we can
490:19 - proceed with a conversion just like this
490:22 - and then what you can do for safety is
490:24 - just outside of this you can actually
490:26 - just return back false just so the user
490:28 - knows that this isn't equal to each
490:30 - other so if the object is a person then
490:33 - we convert it as a person is is used for
490:36 - checking and as is used for converting
490:39 - is this object a person and if it is
490:42 - then we try and convert it and then
490:44 - return back if they're equal to each
490:45 - other and if we accidentally pass
490:47 - something in that's not a person then we
490:49 - just return back false so let's just
490:51 - demonstrate this
490:52 - first not the same so let's just save
490:55 - five inside here it says not the same so
490:59 - let's actually go into this place a
491:01 - break point and let's run it
491:02 - again hover over object then we get
491:06 - five if we place this straight inside
491:09 - the watch you can see object is person
491:11 - is returning back false so it's skipping
491:13 - this entire function and going into
491:15 - return false and then it's returning
491:17 - back false so we get not
491:19 - same let's stop the program change this
491:21 - over to test and rerun it using F5 and
491:24 - now we can see object is person is
491:27 - actually set to true so now if we put
491:29 - the object inside here you can see that
491:32 - generically it's an object right here it
491:35 - says object so what we can do now is we
491:37 - can place person and down here as well
491:40 - you see that person doesn't exist but if
491:41 - you just give it a second it we change
491:43 - this to just the p
491:47 - there we go so obviously the person
491:48 - doesn't exist cuz we're only up to this
491:49 - line we press F10 and F10 again so now
491:53 - it's create a the variable and F10 wants
491:55 - to skip over it and now you can see the
491:57 - object has went from type object to type
492:00 - string. override. person string
492:02 - overwrite is the name of our namespace
492:04 - and do person with a capital P is the
492:07 - name of our class now you can see that
492:08 - the object and the values are exactly
492:10 - the same 25 ab and 25 AB as you can see
492:14 - right here so now both of them are
492:16 - exactly equal to each other so when we
492:18 - check this name here is Aba name here is
492:22 - Aba age 25 and age is 25 so this must
492:26 - return back true and we can check that
492:28 - by highlighting everything dragging and
492:30 - dropping it down here and we can see it
492:31 - says true there so when it returns back
492:33 - to our code it's going to go and print
492:35 - their
492:37 - same perfect there you go so that's it
492:40 - for this video but let's just have a
492:41 - recap before we wrap up so before this
492:43 - video we'd always print the details out
492:45 - like this person. return details but
492:47 - obviously we don't have that function
492:48 - anymore so let's just bring it back
492:50 - quickly there we go so we use return
492:52 - details and this is just a bit long have
492:55 - to do this every single time if you want
492:57 - to print the details of the test object
492:59 - as well you have to test Dot and then
493:01 - return details again it'd be so much
493:02 - easier if we could simply just use it
493:04 - like this as you would do with a normal
493:06 - variable like an integer double A String
493:08 - Etc and now it's made possible by using
493:11 - our public override string two string
493:13 - function it will contain exactly the
493:15 - same contents as our previous function
493:17 - except we won't have to go through an
493:19 - additional function just to print out
493:20 - the details we can override the two
493:22 - string and then we can call it straight
493:24 - in the console like this and finally
493:26 - when you're doing equals inside an
493:28 - object you can actually build in some
493:30 - custom functionality we can convert the
493:32 - person using object as person but first
493:35 - before doing the conversion you want to
493:37 - check if the object is indeed a person
493:39 - type before doing the conversion this
493:42 - will give you a runtime error on this
493:44 - line so let me just demonstr that before
493:46 - we continue so if I comment out this one
493:48 - and actually just change this into
493:51 - 5D and then let's press into the code
493:54 - right
493:55 - here it's going to hit this line if I
493:57 - press F10 then it's going to try and
493:59 - convert it but you're going to get back
494:00 - null and then if you run the code again
494:03 - then you're get an exception thrown here
494:05 - you're going to get a runtime exception
494:06 - because it's a null reference we're
494:08 - trying to run the equals function on
494:10 - something that is null which is right
494:12 - here null reference exception so you
494:14 - shouldn't do this you you should also
494:16 - make sure that these are correct values
494:18 - before doing it this is a form of error
494:20 - checking if you don't do this then
494:22 - you're going to have to wrap this inside
494:24 - a tri catch and it will look something
494:26 - like this and the cord will be
494:27 - considerably longer you can place these
494:29 - two
494:30 - lines inside here and then place your
494:33 - cat inside here etc etc and you can
494:36 - return false inside here but as you can
494:38 - see the Cod is a bit more complicated
494:40 - now and there's no reason for this extra
494:42 - complication if you can prevent it with
494:44 - an if statement so undo
494:46 - that so what's best in this case is to
494:49 - say if the object is of type person then
494:52 - we can run the conversion if you run the
494:54 - conversion and it's not of type person
494:56 - then as you can see it's going to return
494:57 - back null for the person and then when
494:59 - you run this line it's actually going to
495:01 - return you back a null reference
495:02 - exception at this point but anyway the
495:04 - whole point of this equals is to check
495:06 - if two objects are going to be equal to
495:08 - each other so we keep this back to test
495:10 - because this is a custom classes you
495:12 - can't just simply do person equals
495:14 - equals time test and assume that that
495:16 - will just work these aren't buil-in
495:18 - functionalities for custom classes we
495:20 - covered operate overloading where you
495:22 - can actually overload what you do with
495:23 - the equal sign but we didn't cover the
495:25 - dot equals which is what we're doing
495:27 - today in this video as well as the two
495:30 - string this is a different kind of
495:32 - overriding because in the other one when
495:33 - we're doing operator overloading that's
495:35 - specifically an operator that you're
495:37 - just changing the parameters of whereas
495:39 - this one is a strict override of a
495:41 - function equals and the functions two
495:43 - string this will make it easier to print
495:45 - your custom classes out to the screen as
495:47 - well as comparing them just like this
495:49 - person. equals putting test inside the
495:51 - bracket is a lot easier and quicker and
495:53 - you can build in your own custom
495:55 - functionality if you only had the age in
495:57 - there then you can compare the age maybe
495:59 - have a lot more properties and you can
496:01 - always just chain them inside a big if
496:03 - statement that's fine as well but the
496:04 - point is you have full control over how
496:06 - you compare your custom classes maybe
496:09 - you had a list of names inside a
496:11 - dictionary for example and you wanted to
496:13 - add a new name or a new age or a new
496:15 - user to this dictionary but first before
496:18 - you add a new user to the dictionary you
496:20 - want to check if the user already exists
496:22 - so maybe you could have a system where
496:24 - it uses the equals function and it Loops
496:26 - through all of the dictionary items and
496:27 - it checks if all the values are not
496:29 - equal to this one if you didn't build in
496:31 - this functionality so you could do the
496:33 - do equals function then you won't be
496:35 - able to determine if this one is equal
496:37 - to this one and now with your equals
496:39 - function overrided you can now have the
496:42 - functionality to do so thank you for
496:44 - watching this C course I hope you found
496:46 - it helpful in your journey to becoming a
496:48 - proficient C developer if you have any
496:50 - questions or need further clarification
496:52 - on any topic we have covered please
496:53 - don't hesitate to leave a comment below
496:55 - and I will do my best to assist you for
496:57 - those of you who want to dive deeper
496:58 - into C consider checking out my udemy
497:00 - cause you'll find more comprehensive
497:02 - lessons and Hands-On exercises to
497:03 - enhance your skills remember practice
497:05 - makes perfect keep coding and exploring
497:08 - and I wish you all the best on your
497:09 - programming Journey