00:00 - hello everybody and welcome to the free
00:01 - code camp blockchain and solidity
00:04 - beginner to expert full course python
00:07 - edition we're going to go through
00:09 - everything you need to know for
00:10 - developing on a blockchain using
00:12 - solidity and engaging in the future of
00:14 - finance we're going to cover topics that
00:15 - will teach you all the skills you need
00:17 - to become a smart contract expert that
00:19 - you can take with you no matter which
00:21 - blockchain you're developing on
00:23 - blockchain engineers are in extreme
00:24 - demand and they're building billion
00:26 - dollar applications almost every day at
00:28 - this point at the time of filming
00:30 - protocols like ave yearn.finance and
00:33 - synthetics have billions of dollars of
00:35 - locked value in them allowing people to
00:37 - engage in decentralized finance or defy
00:40 - this allows people to make censorship
00:42 - resistant moves and so much more some of
00:45 - these protocols with billions of dollars
00:46 - are even less than a year old so whether
00:49 - or not you're brand new to this space or
00:50 - you've been in here a while hi my name
00:52 - is patrick collins and i live in the
00:54 - smart contract world i'll be taking you
00:56 - through your journey to becoming a
00:58 - blockchain and smart contract expert a
01:00 - little bit of background on myself i'm
01:02 - an engineer and developer advocate on
01:04 - the chain link protocol and i also have
01:06 - my own blockchain infrastructure company
01:08 - called alphachain where i run different
01:11 - nodes and different infrastructure for
01:12 - blockchains including one of the main
01:14 - technologies we're going to be talking
01:15 - about today which is ethereum i love
01:18 - being a pioneer in the smart contract
01:20 - ecosystem and i love taking new users
01:23 - like yourself along to the journey with
01:25 - us and we are going to teach you to
01:27 - become a smart contract expert building
01:30 - blockchain and solidity applications is
01:32 - building a world of more trust and
01:35 - accountability it means building a
01:37 - financially free future and we get to be
01:39 - the ones that will go down in the
01:40 - history books as the pioneers of this
01:42 - space additionally blockchain and smart
01:45 - contract engineering skills are some of
01:46 - the most sought after in the world with
01:48 - an average salary of a solidity
01:50 - developer being between 150 and 175 000
01:55 - in this video we're going to teach you
01:56 - how to become one of these developers
01:59 - and go out into the world and
02:00 - participate in the world of smart
02:02 - contracts in the world of blockchain
02:04 - this course is ideally for engineers who
02:06 - know a little bit of python programming
02:08 - and you can have any level of smart
02:09 - contract engineering whether you're a
02:12 - complete beginner to blockchains and you
02:13 - don't even know what one is or you're an
02:15 - advanced solidity engineer and you're
02:17 - looking to learn more this is the
02:18 - perfect place for you having a little
02:20 - bit of experience in other
02:22 - object-oriented programming language
02:23 - like javascript as well will be helpful
02:25 - here too and if you're brand new to
02:27 - coding in general that's all right
02:28 - because we're going to take you step by
02:30 - step through everything if you do want a
02:32 - little bit more in-depth python coding
02:34 - video there is a fantastic free code
02:36 - camp video in the description if you do
02:38 - prefer javascript we will also be
02:40 - releasing a javascript edition of this
02:42 - video as well but everything that you
02:44 - learn here will be applicable there and
02:46 - if you watch both you'll learn even more
02:48 - you can find the entire itinerary for
02:51 - this entire course along with all of the
02:53 - code associated with everything that we
02:55 - do and additionally discussions and
02:57 - support and everything else in this
02:59 - smart contract kit
03:00 - full blockchain solidity course pi
03:03 - github repository it has a table of
03:04 - contents and then the entire itinerary
03:07 - of everything that we're going to go
03:08 - over in this course and like i said with
03:10 - helpful tips resources for getting
03:12 - support and resources for getting help
03:14 - now for your convenience every single
03:16 - piece of code that we're going to go
03:17 - over in this video has a github
03:19 - repository associated with it so be sure
03:22 - to grab the link in the description grab
03:24 - that github repository and look through
03:26 - all the different repos that we're going
03:27 - to give you if you ever get lost or need
03:29 - to refer to some code or want to copy
03:31 - paste some code all of it will be there
03:33 - for you it'll also be a great place to
03:35 - reference in the future when you're
03:36 - working on some project and you want to
03:38 - remember how to do something so be sure
03:40 - to start and refer back to it as you
03:42 - watch this video so let's talk a little
03:44 - bit about some best practices for
03:46 - watching this video this space moves
03:48 - really quickly so if we show you some
03:50 - documentation it might be a good idea
03:52 - for you to open that documentation up as
03:54 - well read through it as we do so you can
03:56 - stay up to speed now we've packed a ton
03:59 - of information in this video and studies
04:01 - have shown if you try to digest a
04:03 - massive amount of information in a short
04:05 - period of time your retention isn't as
04:07 - good so it's highly recommended that
04:10 - every 25 minutes to half an hour you
04:12 - take a five minute break and then every
04:14 - two hours maybe you take an additional
04:16 - 30 minute or an hour long break you can
04:18 - pause bookmark areas and come back later
04:20 - and learn at your own speed there are
04:22 - timestamps in the description that will
04:24 - help you come back to where you left off
04:26 - and you don't even have to go in order
04:28 - if you want to bounce around from topic
04:30 - to topic you're absolutely free to do so
04:32 - we're also going to get really technical
04:34 - with the fundamentals of blockchain and
04:36 - if you want to just jump right into
04:37 - solidity you can jump down the
04:38 - timestamps below and get right into it
04:42 - and if you're watching this on youtube
04:43 - you can adjust the speed that i talk and
04:45 - then i give this presentation so if i'm
04:48 - talking way too quickly for you you can
04:49 - slow it down or if i'm talking too
04:52 - slowly for you you can have me speed up
04:54 - so be sure to set me at the pace that
04:56 - you like best you are highly encouraged
04:58 - to pause come back and ask questions the
05:01 - blockchain in smart contract world is a
05:03 - very collaborative community so if you
05:06 - have questions some of the best places
05:07 - that you can go going to stack overflow
05:10 - and tagging your question with the
05:12 - specific technologies that you're
05:13 - working on make an issue on the github
05:15 - repo that we're working with go to stack
05:18 - exchange eth and make a question there
05:20 - as well jump into the discord of the
05:22 - technology that you're working with or
05:24 - even on github discussions if those are
05:26 - there learning to become a blockchain
05:28 - and solidity engineer is actually a lot
05:30 - more than just learning solidity
05:31 - becoming comfortable with all the tools
05:33 - in the space is going to be just as
05:35 - essential as becoming familiar with
05:37 - solidity itself and continuing the
05:39 - conversation on maybe twitter or reddit
05:42 - or any of these other channels and maybe
05:44 - even showing your stuff in the next
05:45 - ethereum or chainlink hackathon are
05:47 - going to be majorly beneficial to
05:49 - increasing your skill as an engineer
05:51 - now before we get actually coding a lot
05:53 - of people want to understand what is
05:55 - actually happening with all this
05:57 - blockchain stuff what is blockchain what
06:00 - is a smart contract how did this all get
06:02 - started and understanding these core
06:04 - fundamentals will actually shape the way
06:06 - you code and architect your smart
06:08 - contract applications so learning these
06:11 - is really really critical
06:12 - however if you're already familiar with
06:14 - blockchain and you just want to jump
06:16 - into the solidity feel free to grab a
06:18 - timestamp from the description and jump
06:20 - to that section
06:25 - now since you're here though you've
06:26 - probably heard of bitcoin before bitcoin
06:30 - was one of the first protocols to use
06:32 - this revolutionary technology called
06:34 - blockchain the bitcoin whitepaper was
06:37 - released by the pseudo-anonymous satoshi
06:39 - nakamoto and it outlined how bitcoin
06:42 - could be used to make peer-to-peer
06:43 - transactions in a decentralized network
06:46 - this network is powered by cryptography
06:49 - and allows people to engage in
06:51 - censorship resistant finance in a
06:54 - decentralized manner due to some of the
06:56 - features of bitcoin a lot of people took
06:58 - it to be as a superior store of value
07:00 - over another asset like let's say gold
07:03 - and that's why it's commonly referred to
07:05 - as digital gold similar to gold there is
07:08 - a scarce and set amount of it on the
07:10 - planet and people use it to buy and sell
07:13 - similar to other assets you can read
07:15 - more about the original vision in the
07:17 - white paper and there's a link to it in
07:18 - the description
07:20 - now this was a fantastic breakthrough
07:22 - and in a little bit we're actually going
07:23 - to look through how blockchains can
07:25 - actually work and how all of this is
07:27 - possible but some people took this and
07:29 - saw this technology and thought that
07:31 - they could do even more a few years
07:33 - later a man named metallic buterin
07:36 - released a white paper describing a new
07:38 - protocol called ethereum which used this
07:41 - same blockchain infrastructure but
07:44 - with an additional feature and in 2015
07:47 - they released this project called
07:49 - ethereum him and a number of other
07:51 - co-founders took this blockchain
07:52 - technology and applied it in ways that
07:55 - people can make entirely decentralized
07:57 - applications decentralize organizations
08:00 - and build smart contracts and engage in
08:03 - agreements without a third-party
08:05 - intermediary or centralized governing
08:07 - force their idea was to take the same
08:10 - pieces that made bitcoin great and add
08:12 - smart contracts to it and in fact this
08:15 - technically wasn't even a new idea back
08:18 - in 1994 a man named nick zabo proposed a
08:22 - technology called smart contracts a
08:24 - smart contract is a self-executing set
08:27 - of instructions that is executed without
08:30 - a third party intermediary they come to
08:32 - life on a blockchain and these smart
08:35 - contracts are really going to be the
08:37 - core thing that we're going to be
08:39 - working with and we're going to be
08:40 - developing smart contracts are similar
08:42 - to regular traditional contracts that
08:44 - people make between each other but
08:46 - instead of writing these contracts down
08:48 - on pen and paper or typing that on the
08:49 - computer it's entirely written in code
08:53 - the terms of the agreement are written
08:55 - in code and automatically executed by
08:58 - the decentralized blockchain network
09:00 - instead of being written pen and paper
09:02 - and executed by the two parties or three
09:04 - parties or however many parties involved
09:06 - this is one of the main differentiators
09:08 - between the ethereum protocol and the
09:10 - bitcoin protocol now technically bitcoin
09:13 - does also have smart contracts however
09:15 - they're not touring complete meaning
09:17 - that they don't have the full range of
09:19 - capabilities as a turing complete
09:21 - application like ethereum this is
09:23 - actually an intentional move by the
09:25 - bitcoin developers they view the bitcoin
09:27 - network as an asset whereas ethereum and
09:30 - the ethereum and developers viewed that
09:32 - acid as an asset and also a utility for
09:35 - people to build these smart contracts
09:37 - now these smart contracts are
09:38 - revolutionary technologies and we're
09:40 - going to talk a little bit more about
09:41 - what their advantage is in a little bit
09:43 - but they actually come with a fatal flaw
09:46 - with what's known as the oracle problem
09:48 - these blockchains are deterministic
09:50 - systems and we'll learn why they're
09:51 - deterministic very soon and this
09:53 - determinism means that they're a walled
09:55 - garden meaning that everything that
09:57 - happens in these smart contracts and on
09:58 - this blockchain happens in this little
10:01 - box now of course if you want these
10:03 - smart contracts to actually be these
10:04 - digital superior agreements then they
10:06 - need some way to interact with the real
10:08 - world and get real data and external
10:11 - outside the blockchain computation this
10:13 - is where oracles come into play oracles
10:15 - are devices that bring data into a
10:18 - blockchain or
10:19 - execute some type of external
10:21 - computation so great so oracles are the
10:23 - solution now blockchains can talk to the
10:25 - real world right
10:27 - well not quite our blockchains and smart
10:29 - contracts are these decentralized
10:30 - applications and in order for them to
10:33 - stay decentralized that means they would
10:35 - also need to get their data and external
10:37 - computation from a decentralized manner
10:39 - as well your on-chain logic will be
10:41 - decentralized on the blockchain but
10:43 - you'll also need your off-chain data and
10:45 - external computation decentralized as
10:47 - well combining these on-chain logic
10:49 - settlement layers and these off-chain
10:51 - data and external computation
10:53 - builds what's called hybrid smart
10:55 - contracts and a large majority of d5
10:57 - applications in the largest applications
10:59 - today are these hybrid smart contracts
11:01 - this is where the protocol chain link
11:02 - comes into play chain link is a
11:04 - decentralized modular oracle network
11:07 - that allows you to bring data into your
11:09 - smart contracts and do external
11:11 - computation and it's these hybrid smart
11:13 - contracts that can have this on-chain
11:15 - settlement and interact with the real
11:17 - world in some meaningful way chain link
11:19 - is an incredibly powerful oracle network
11:21 - because it allows us to get data get
11:23 - randomness do some type of upkeep or
11:25 - really customize our smart contracts in
11:28 - any way we want and elevate them to do
11:30 - anything that we want them to do now
11:32 - throughout the course when we're talking
11:34 - about smart contracts oftentimes we are
11:36 - also talking about hybrid smart
11:38 - contracts smart contracts is used a
11:40 - little bit interchangeably with hybrid
11:41 - smart contracts but just know that when
11:43 - we say hybrid smart contract we're
11:45 - talking specifically about smart
11:46 - contracts with an off chain component
11:49 - now throughout this video you'll hear
11:50 - people say smart contract you'll hear
11:52 - people say decentralized protocol
11:55 - decentralized application or dap and
11:58 - they kind of all are a little bit
12:00 - interchangeable a decentralized
12:02 - application is usually a combination of
12:04 - several smart contracts
12:06 - and when we start coding some solidity
12:08 - you'll see what a singular smart
12:10 - contract or singular contract looks like
12:12 - smart contracts are going to be what we
12:14 - code write and deploy for the majority
12:17 - of this video and learning some of these
12:19 - fundamental concepts will allow us to be
12:21 - better smart contract and better
12:22 - solidity developers now since its
12:25 - inception the ethereum protocol has
12:27 - given rise to many new paradigms and
12:29 - industries including d5 nfts
12:33 - dows or decentralized autonomous
12:35 - organizations
12:36 - layer twos and so much more
12:39 - and a couple of other protocols have
12:40 - taken this ethereum vision and gone in a
12:42 - different direction with it like polygon
12:45 - polka dot or avalanche if we learn the
12:48 - core basics of smart contract
12:49 - development on the ethereum platform all
12:52 - these skills translate to these other
12:54 - chains as well so don't worry about
12:56 - learning a specific tool or chain
12:57 - because most of them work together
12:59 - pretty seamlessly
13:01 - now there are a few exceptions to this
13:03 - rule and there are some smart contract
13:05 - platforms aka blockchains that don't use
13:08 - solidity however learning the
13:10 - fundamental skills here will still
13:12 - translate to every single other
13:14 - blockchain
13:15 - and ethereum is by far the most popular
13:19 - and most used smart contract blockchain
13:21 - or smart contract protocol you'll also
13:23 - hear those words used a little
13:25 - interchangeably as well sometimes i'll
13:27 - say blockchain or sometimes i'll say
13:29 - smart contract platform smart contract
13:31 - protocol and the like similarly chain
13:34 - link is the most popular and powerful
13:36 - decentralized oracle network and is
13:37 - going to be the one that we're going to
13:38 - focus on here chain link is also
13:40 - blockchain and smart contract platform
13:42 - agnostic meaning it'll work on ethereum
13:45 - avalanche polygon polka or really any
13:48 - blockchain or smart contract platform
13:50 - out there
13:51 - even in this introduction we've already
13:53 - learned a lot so let's do a quick
13:54 - summary of what we've talked about
13:56 - bitcoin was the first application to
13:58 - take the blockchain technology into the
14:00 - limelight and into a meaningful way
14:02 - bitcoin is a sort of digital gold able
14:05 - to make transactions between users as
14:07 - almost a sort of currency ethereum takes
14:09 - this blockchain technology one step
14:11 - further but you can also build smart
14:14 - contract or decentralized applications
14:16 - decentralized autonomous organizations
14:18 - and more because you can code with smart
14:21 - contracts these smart contracts can then
14:24 - access external data and external
14:25 - computation outside the blockchain using
14:28 - what's called oracles chain link is the
14:30 - most powerful decentralized oracle
14:32 - network and allows us to build these
14:34 - hybrid smart contracts which is a
14:35 - combination of decentralized on-chain
14:38 - logic settlement layer and any
14:40 - decentralized external off-chain data or
14:43 - computation hybrid smart contracts and
14:45 - smart contracts are often used
14:46 - interchangeably now you're probably
14:48 - asking yourself a lot of questions right
14:49 - now like what makes bitcoin so
14:51 - interesting what makes it like a digital
14:53 - gold and how are these smart contracts
14:55 - going to add any value to the real world
14:57 - and that's what we're going to go into
14:58 - now so before we get into the
15:00 - nitty-gritty of how these blockchains
15:02 - and how these smart contracts actually
15:04 - work from a low level let's go
15:06 - high level and talk about some of the
15:08 - features and massive advantages that
15:11 - blockchains and smart contracts have
15:12 - over our traditional environments the
15:15 - first feature that these have is they
15:16 - are decentralized and you'll hear this
15:19 - term used a lot because it has a massive
15:22 - benefit blockchains are decentralized
15:25 - meaning there's no centralized source
15:27 - that controls the blockchain the
15:29 - individuals that make up blockchain are
15:32 - known as node operators and they are the
15:34 - independent individuals running the
15:36 - software that connects the whole
15:38 - blockchain together it's all these
15:40 - different independent individuals that
15:42 - make the blockchain and blockchain like
15:44 - networks decentralized we'll dive deeper
15:47 - into that concept later great example of
15:50 - why this is so fundamentally
15:52 - groundbreaking is if we go back to what
15:54 - happened recently even with robinhood
15:56 - and gamestop gamestop shares were no
15:59 - longer allowed to be bought because a
16:01 - centralized entity didn't want them to
16:04 - be bought anymore so they
16:06 - flipped a switch and nobody could buy
16:08 - that stock anymore essentially having a
16:10 - single entity controlling the entire
16:13 - financial market the fact that a single
16:15 - entity has the power to make these
16:17 - choices for us is a travesty and
16:20 - blockchain is here to solve that there's
16:22 - a narrative here called the bankless
16:24 - narrative where users can actually live
16:26 - in a world where they don't have a bank
16:28 - banks while good in their own right have
16:31 - a history of doing some shady things
16:33 - they also have the power to potentially
16:35 - freeze your funds not letting you
16:37 - withdraw or move or do anything because
16:39 - they are a centralized entity that again
16:41 - can
16:42 - flip a switch and control how you
16:44 - interact with your life every day being
16:47 - free of these centralized entities have
16:49 - this much power and this much control
16:51 - over your life has widespread positive
16:54 - ramifications transparency and
16:56 - flexibility
16:58 - everything that's done on a blockchain
17:00 - and all the rules that are made can be
17:02 - seen by everyone there's no backdoor
17:05 - deals there's no shady happenings
17:07 - everything that happens on chain you can
17:10 - see this means that there's no special
17:12 - information that a few have
17:14 - everyone has to play by the same rules
17:16 - and everyone can see exactly what those
17:19 - rules are
17:20 - now additionally this doesn't mean that
17:23 - everything you do is tracked the
17:24 - blockchain is pseudo-anonymous so you
17:27 - can create different accounts and you
17:28 - can interact with it in many different
17:30 - ways this leads me to my freedom point
17:33 - but i'll get there in a second speed and
17:35 - efficiency have you ever tried to make a
17:37 - withdrawal from the bank and it took
17:39 - three to five days
17:41 - all the bank is doing is adding and
17:43 - subtracting numbers
17:44 - basic first grade math
17:47 - so why does it take so long because
17:49 - blockchains are verified by a
17:51 - decentralized collective the settlement
17:53 - or withdrawal period in this case is
17:56 - substantially faster and depending on
17:58 - the blockchain that you're using it can
17:59 - be from
18:00 - 10 minutes all the way down to just a
18:03 - couple of seconds in the stock trading
18:05 - or hedge fund world it can actually take
18:06 - up to a week for your buy or sell of a
18:10 - stock to go through security and
18:12 - immutability blockchains are immutable
18:15 - which means they can't be changed and
18:17 - because of this it means that they can't
18:19 - be tampered with or corrupted in any way
18:22 - shape or form this allows us to have
18:24 - massive security on our data on our
18:27 - transactions and anything of the like if
18:29 - your computer goes down and your backup
18:31 - computers go down
18:34 - in the regular world your data is gone
18:36 - if all your data is on those two
18:37 - computers you're out of luck on a
18:39 - blockchain if several nodes go down it
18:42 - doesn't matter because as long as one
18:45 - node and the entire system is running
18:47 - the data is safe and secure there are
18:50 - thousands or hundreds of thousands of
18:52 - nodes running these blockchain softwares
18:54 - meaning that everything that happens
18:56 - happens and is immutable and won't
18:58 - change
18:59 - hacking the blockchain is nearly
19:02 - impossible and substantially harder than
19:05 - hacking a centralized entity and this is
19:07 - also much more secure in the asset sense
19:09 - as well instead of having gold in a
19:11 - vault or contract written on a piece of
19:13 - paper or on your computer you have a
19:16 - asset that is
19:18 - locked on the blockchain forever and all
19:20 - you need to do to access it is have a
19:22 - private key or mnemonic
19:25 - which is essentially a password so you
19:28 - don't have to lug your gold around or
19:30 - lug your contracts around with you it is
19:32 - always on the blockchain smart contracts
19:35 - in particular remove a massive conflict
19:38 - of interest in the traditional world
19:40 - when we engage with users or individuals
19:43 - they don't always have our best
19:45 - interests at heart
19:46 - a lot of them are usually self-motivated
19:49 - in some sense and there's nothing wrong
19:51 - with that that's how a lot of people are
19:52 - however when we make an agreement with
19:54 - them this agreement can have a massive
19:57 - conflict of interest with the user who's
19:59 - supposed to execute that agreement
20:01 - let's take insurance for example if i
20:03 - pay an insurance provider 100 a month
20:05 - i'm paying them a hundred dollars and in
20:07 - the event that i get hit by a bus we've
20:09 - made an agreement or a contract that
20:12 - they're going to pay my medical bills or
20:14 - bail me out however they have this
20:17 - massive conflict of interest insurance
20:19 - companies aren't in the business of
20:20 - giving out money they're in the business
20:23 - of making money so even though they've
20:25 - signed this agreement when this event
20:28 - occurs they still don't want to pay this
20:31 - money out to me and if they can find a
20:33 - loophole in the contract they will
20:35 - because that is what they are motivated
20:37 - to do so they sign this agreement but
20:40 - it's not in their best interest to do so
20:42 - so they have this massive conflict of
20:44 - interest and this is native in all of
20:46 - the agreements that we make today they
20:48 - are the ones who decides whether or not
20:50 - they're going to execute their agreement
20:52 - giving execution power to the party that
20:54 - doesn't want to execute something has
20:57 - often led to frustration now the
20:59 - follow-up is you can always sue them and
21:01 - go through this process but now you're
21:03 - wasting all this time going through this
21:05 - long process to get something that you
21:07 - should have originally gotten in the
21:09 - first place
21:10 - this leads me to one of the biggest
21:12 - value adds to smart contracts smart
21:14 - contracts allow us to engage in
21:16 - trustless and trust minimized agreements
21:20 - we currently live in a world of
21:22 - brand-based agreements
21:24 - if i engage in some agreement and i
21:26 - don't like the service that i'm provided
21:28 - my alternative to this is to waltz down
21:31 - the street to another brand to another
21:34 - service who's going to make the exact
21:36 - same set of promises to me and then i
21:38 - have to trust them that they're going to
21:41 - execute faithfully smart contracts allow
21:43 - us to move from this brand based
21:46 - agreements to
21:48 - math-based agreements these math-based
21:50 - agreements we don't even have to trust
21:53 - that they're going to do the right thing
21:54 - hence the name trustless one plus one is
21:58 - always going to equal two in a math
22:00 - world whatever the code determines is
22:02 - the input output that's exactly what's
22:05 - gonna happen every single time
22:08 - now for me these really all add up to
22:10 - two major pieces
22:12 - freedom
22:13 - and trustless all these pieces allow us
22:16 - to live in a world that's more
22:17 - accountable more trusting more friendly
22:21 - and
22:21 - just better it allows us to work in an
22:24 - environment and a universe where things
22:25 - just
22:26 - work
22:27 - it allows us to do the freedom to engage
22:30 - with other people how we wish because
22:32 - there's no centralized controlling body
22:35 - influencing every action that we make
22:37 - all the rules are the same and nobody's
22:40 - getting special treatment
22:42 - this brings out this new world of
22:43 - economic opportunity as well and as our
22:46 - lives become more and more digital we're
22:48 - constantly being bombarded with
22:50 - centralized services that want us to use
22:52 - their interface so they can profit on
22:55 - how we interact and force us or push us
22:58 - to making the decisions that they're
23:00 - motivated for us to make smart contracts
23:03 - decentralized applications and
23:05 - blockchain
23:06 - allows us to be free of these repressors
23:10 - and live in an environment that's truly
23:13 - free and trustless
23:15 - so with all that high level being said
23:18 - let's do a quick summary of what we just
23:20 - learned blockchains are decentralized
23:24 - meaning that they are not controlled by
23:25 - a single centralized entity it is run by
23:28 - a network of independent users
23:32 - transparency blockchains are transparent
23:35 - everything that happens on a blockchain
23:37 - everybody else can see and everybody
23:40 - else can work with and see that
23:41 - everyone's playing by the same rules
23:44 - blockchains are quick and efficient
23:46 - especially when it comes to monetary
23:47 - policy settlement on blockchains are
23:50 - fast and easy immutability and security
23:53 - blockchains can't be changed or tampered
23:56 - with or corrupted and are incredibly
23:59 - incredibly secure smart contracts remove
24:02 - the massive conflict of interest
24:04 - traditional agreements have smart
24:06 - contracts allow us to move away from
24:08 - political brand-based agreements to
24:10 - secure
24:12 - math-based agreements smart contracts
24:14 - allow us to engage in trustless and
24:16 - trust minimized agreements
24:18 - smart contracts are a set of
24:20 - instructions which when placed on a
24:22 - blockchain are self-executing pieces of
24:24 - code not run by any centralized
24:27 - intermediary in addition smart contracts
24:29 - are typically paired with some type of
24:31 - oracle to get some information about the
24:33 - real world when smart contracts are
24:34 - paired with an oracle they're called
24:36 - hybrid smart contracts chain link is a
24:38 - secure decentralized modular oracle
24:41 - network used to bring data into your
24:43 - smart contracts and also make some type
24:45 - of external computation i also briefly
24:47 - want to mention dao's or decentralized
24:49 - autonomous organizations you'll hear
24:51 - this referred to a lot as well
24:53 - decentralized autonomous organizations
24:55 - are organizations that live online and
24:58 - live in these smart contracts they're
25:00 - similar to a regular organization in the
25:02 - traditional world however they have
25:04 - people who maybe hold governance tokens
25:05 - to make voting decisions or they do all
25:07 - their governance on chain
25:10 - on this decentralized settlement layer
25:12 - giving us the freedom to engage with
25:14 - each other as we please
25:16 - so now that we've taken our first dive
25:18 - into blockchains and smart contracts and
25:20 - at least from a high level understood
25:22 - why they're so advantageous let's jump
25:24 - in let's get an ethereum wallet and
25:27 - let's make our first transaction on a
25:31 - live blockchain are you ready now let's
25:34 - jump into ethereum we're going to make
25:36 - our first interaction with the ethereum
25:38 - blockchain and once we do this
25:40 - interaction once we make this
25:41 - transaction
25:42 - then we're going to go back and look at
25:44 - what actually happened what were the
25:46 - technical implications that allowed this
25:47 - transaction to go through so in order
25:50 - for us to interact with the blockchain
25:52 - the first thing that we're going to need
25:53 - is an ethereum wallet
25:56 - so i'm going to go ahead and go to
25:58 - metamask because it's one of the most
25:59 - popular wallets and one of the easiest
26:02 - to use we're going to go ahead and
26:03 - download it
26:05 - i'm using the brave browser but it works
26:07 - for chrome firefox or really any other
26:09 - browsers
26:10 - and it's just going to be a little
26:12 - extension in the top right hand
26:14 - of your browser
26:16 - this way we can really easily see at any
26:18 - time what we have in our wallet
26:21 - this will store all of our ethereum
26:23 - based currencies
26:25 - so i'm going to go ahead and install
26:26 - metamask for brave
26:28 - add to brave
26:30 - add extension
26:32 - and now we can go ahead and get started
26:34 - with working with brave this is the
26:37 - first step you absolutely need to take
26:38 - when starting your journey and one of
26:40 - the easiest steps to take so we're going
26:42 - to go ahead and get started
26:44 - and we're going to create a brand new
26:46 - wallet so we're going to go ahead and
26:47 - hit create wallet
26:48 - if you already have a wallet you can
26:51 - actually import it via i have a seed
26:53 - phrase and we'll talk about the seed
26:55 - phrase or secret phrase in a little bit
26:57 - so let's go ahead and create a new
26:58 - wallet
26:59 - and sure we'll agree to help out
27:01 - metamask now we will create our password
27:04 - make sure that this is really secure
27:06 - for the purpose of this demo my
27:08 - passwords are just gonna be password but
27:10 - please don't have that be a password now
27:11 - when i'm doing my testing when i'm doing
27:13 - my coding i actually use a separate
27:15 - account from the account that i actually
27:16 - have real money in however if you want
27:19 - to use this account and actually put
27:20 - real ethereum and put real money into it
27:23 - you absolutely 100
27:25 - need to back this up so we're gonna go
27:27 - ahead and click reveal secret words i'm
27:30 - showing you guys here because
27:32 - uh this is just a demo and i don't
27:34 - really care however if you show this
27:36 - secret phrase to anybody else they will
27:39 - have access to
27:40 - all funds
27:42 - so everything that we're gonna do in
27:43 - this tutorial we're gonna use fake money
27:45 - we're gonna use not real money so it
27:47 - doesn't matter however if you're going
27:49 - to actually put money in here you
27:50 - absolutely need to have this written
27:52 - down because if you lose access to this
27:54 - and or your private keys which we'll
27:56 - talk about in a little bit you will lose
27:57 - access to your wallet and you will lose
28:00 - access to all your funds
28:01 - so they give some tips like store this
28:03 - phrase and a password manager like one
28:05 - password write this phrase down on a
28:07 - piece of paper put it in a secure
28:09 - location memorize it whatever you want
28:11 - to do just make sure you have this
28:13 - backed up somewhere
28:14 - i'm just going to go ahead and hit
28:15 - download this for now and i'm going to
28:17 - save it on my computer it's not best
28:19 - practice to save to your computer it is
28:21 - much better to use a password manager or
28:23 - write it down on a piece of paper or
28:24 - something
28:25 - but again because we're just demoing
28:26 - here
28:27 - i'm going to show you it here and we're
28:29 - not going to put any real funds into
28:30 - this
28:31 - so we're going to go ahead and hit next
28:33 - and we're it's going to ask us to
28:36 - make sure we and it's going to ask us to
28:38 - verify that we actually have it written
28:39 - down
28:43 - and we're gonna go ahead and hit confirm
28:45 - and great and it gives us a couple other
28:47 - tips remember definitely take these tips
28:49 - very seriously especially if you're
28:51 - gonna use this for real money like i
28:52 - said for this demo we're just gonna use
28:54 - test money so it's not as big of a deal
28:56 - but if you put real money in you
28:58 - absolutely need to back up this seed
29:00 - phrase or secret phrase or we're going
29:02 - to refer to it as our mnemonic phrase
29:05 - awesome now we can see the user
29:07 - interface of this wallet
29:09 - and depending on your browser if you
29:10 - actually go ahead and look in your
29:12 - extensions you can pin it to your
29:14 - browser and you can even just click it
29:16 - and get the same interface here let's
29:18 - take some inventory of what is actually
29:20 - going on in here and what we actually
29:22 - have our mnemonic phrase that secret
29:25 - phrase that we got
29:26 - has given us access to a new account and
29:30 - here's the address of our account we can
29:32 - use a tool like etherscan to view
29:34 - different addresses and what's been
29:36 - going on with them so if we look at this
29:39 - address that we just created on
29:40 - etherscan we can see that no
29:42 - transactions have happened it's empty it
29:44 - has zero ether in it it has zero dollars
29:47 - worth of value in it and this address
29:49 - here
29:49 - is our unique address this address
29:52 - represents
29:53 - exclusively this single account that we
29:56 - just created we'll talk a little bit
29:58 - more about etherscan in a bit as it's a
30:00 - tool that we're going to use more and
30:01 - more now we can even click this
30:04 - circle here and we can even create more
30:07 - accounts and give it a different account
30:09 - name
30:10 - we'll call it account 2.
30:12 - this one has a different address so if
30:15 - we go ahead go back to etherscan and
30:17 - look this up this one has a different
30:19 - address here
30:20 - so we can have multiple addresses in
30:22 - here and now if i click this i have two
30:24 - accounts account one
30:26 - and account two
30:28 - the mnemonic that we've been given
30:30 - gives us access to create multiple
30:33 - accounts with that same mnemonic so
30:35 - having that mnemonic will give us access
30:37 - to every single account that's ever
30:39 - created with that mnemonic this is why
30:41 - securing your mnemonic is so crucial
30:43 - especially if you create multiple
30:45 - different accounts
30:46 - now each account
30:48 - has a unique identifier with them as
30:51 - well so so this right here is the public
30:54 - address when we copy this this is the
30:56 - public address of that account
30:58 - however there's also a private key to
31:01 - work with this account a secret key
31:03 - and we can go ahead and view it by
31:05 - clicking these three dots go to account
31:06 - details and export private key
31:10 - put our password in and confirm
31:12 - so this is going to be our private key
31:14 - so this is a single
31:16 - password associated with this account if
31:19 - you give somebody else access to this
31:21 - private key they will have access to my
31:23 - account too they won't have access to my
31:26 - account one because the private key of
31:28 - account two is only associated with
31:29 - account two the mnemonic however is
31:32 - associated with all accounts and this is
31:34 - why when people say store your private
31:36 - keys in a safe place or store your keys
31:38 - in a safe face they're usually referring
31:40 - to both your mnemonic and your private
31:42 - keys
31:43 - if you lose your private key you lose
31:45 - access to this account if you lose your
31:47 - mnemonic you lose access to all your
31:49 - accounts so long story short back up
31:52 - your mnemonic since it has access to
31:54 - everything and back up your private keys
31:56 - too but just keep in mind they only have
31:58 - access to the individual accounts and
32:00 - great those are some of the main
32:01 - security pieces here
32:02 - now what else is going on in metamask is
32:04 - we can see this section here that says
32:06 - ethereum mainnet if we click it we
32:08 - actually see a bunch of other networks
32:10 - in here
32:11 - so when you buy eth and when you work
32:13 - with eth you're working on the ethereum
32:15 - mainnet when you interact with smart
32:16 - contracts or d5 or any things that we're
32:19 - going to talk about later on mainnet
32:21 - with real value you're going to be
32:23 - working on the mainnet
32:25 - however since we're engineers oftentimes
32:28 - we're going to want to test our
32:29 - applications or do some type of
32:31 - integration tests or just make sure our
32:33 - code actually works
32:35 - so there's also what's called test nets
32:38 - these are networks that resemble
32:40 - ethereum and work exactly the same way
32:43 - as ethereum does
32:44 - however they're not with real money and
32:47 - it's just for testing your applications
32:49 - so we can even go to ether scan and look
32:51 - up
32:52 - brinkp ether scan
32:54 - we can see the rink be test on explorer
32:57 - we look up at our address and it's the
32:59 - exact same
33:00 - information here
33:02 - nothing has gone on on rink b and this
33:04 - is totally different so when we make a
33:06 - transaction these are all different
33:08 - networks and it says test network it's
33:10 - made to be made without real money later
33:13 - on we're actually going to show you how
33:14 - to work with other evm compatible chains
33:17 - don't worry about what evm compatible
33:19 - means for now but we can work with
33:21 - avalanche polygon and other applications
33:24 - through this networks interface as well
33:26 - so remember a testnet blockchain is a
33:28 - blockchain where the currency doesn't
33:30 - have any real value but it resembles and
33:32 - acts exactly like the ethereum mainnet
33:34 - so we can test our applications
33:36 - so we can test and practice our
33:37 - applications
33:39 - in fact what we're going to do right now
33:41 - is make our first transaction on the
33:43 - rink b test net and this will simulate
33:45 - exactly what it's like to make a
33:47 - transaction on the ethereum mainnet so
33:49 - we're going to go to this application
33:50 - called the rink b faucet this is where
33:53 - we're going to make our first
33:54 - transaction ring b is going to be one of
33:57 - two test nets that we're actually going
33:59 - to work with the other test net that
34:01 - we're going to work with is going to be
34:02 - coven it's important to know how to
34:04 - switch between test nets and evm
34:07 - compatible chains which is why we're
34:09 - going to be working with both for now
34:10 - we're just going to be working with rink
34:12 - b
34:12 - a faucet is a tested application that
34:15 - gives us free test ethereum hence why it
34:18 - has no value because anybody can get it
34:19 - for free from one of these faucets so to
34:21 - get tested ethereum with this
34:23 - application we actually have to post a
34:25 - tweet or a facebook post
34:28 - with this tweet so i'm actually going to
34:31 - i'm going to sign in real quick
34:33 - and now that i'm signed in i can post
34:35 - this tweet requesting faucet funds into
34:39 - and this is where i'm going to put my
34:41 - address
34:42 - on the rinkby ethereum test network i'm
34:45 - going to go ahead and tweet that out
34:47 - now that i have this
34:49 - we're gonna copy link to tweet
34:51 - and we're gonna place it in here and
34:54 - we're gonna hit give me ether and we're
34:56 - gonna say 18.75 ether for three days and
34:59 - it said funding request accepted for
35:02 - patrick alpha c
35:03 - into this
35:05 - and what we can do then
35:07 - is if we take this address again
35:10 - we go over to rink b ether scan
35:16 - we now see that the balance is 18.75
35:20 - and we can even see that
35:22 - in our wallet on the ringbeat network we
35:24 - have 18.75 eth but again if we look at
35:27 - mainnet we have nothing there if we look
35:30 - at robson we have nothing there if we
35:32 - look at rink b we have 18.75 right so
35:34 - these are very different networks and
35:36 - we've just made our first transaction
35:39 - we've been given
35:40 - 18.75 eth and if we refresh this page we
35:44 - also see that this is our first
35:46 - transaction that was made
35:48 - some account sent us 18.75 ether
35:52 - from
35:53 - this account to us and we can actually
35:56 - even look at the details of this
35:57 - transaction
35:59 - etherscan is what's known as a block
36:01 - explorer block explorers are
36:03 - applications that allow us to see
36:05 - details of things that happen on a
36:07 - blockchain easily we can see the
36:08 - transaction details of this transaction
36:11 - here and whenever we work with smart
36:13 - contracts we will also see them in a
36:15 - transaction similar to what we're seeing
36:16 - right here and again we'll talk about
36:18 - that soon now we can see a number of
36:20 - information here we see a unique
36:22 - transaction hash this hash or this
36:25 - unique identifier uniquely identifies
36:28 - this transaction
36:29 - as the key of what this transaction is
36:32 - we see that it was a successful
36:33 - transaction this is the block number
36:36 - which we'll talk about in a little bit
36:38 - we see it was from this unique account
36:41 - which looks like they did a ton of
36:43 - transactions because this is the faucet
36:44 - account
36:45 - to our account that we created
36:47 - value was 18.75 ether
36:50 - and then we have these transaction fees
36:53 - gas price gas limit and gas used now gas
36:56 - refers to the fee paid to node operators
36:59 - for successfully including a transaction
37:02 - in a blockchain
37:03 - now exactly how this works is actually
37:05 - going to change pretty soon but the
37:07 - concept is basically anytime you want to
37:09 - change the state of blockchain whether
37:11 - this is sending some ethereum or making
37:14 - any type of transaction
37:16 - you actually have to pay a little bit of
37:18 - ethereum or a little bit of that native
37:20 - blockchain token to actually execute
37:23 - that transaction whenever we do
37:25 - something on the blockchain
37:27 - it costs gas and if we do something that
37:30 - would take a lot of energy for the
37:31 - blockchain to do it will cost more gas
37:34 - so if i send a single transaction that's
37:36 - going to cost 21 000 gas however if i
37:39 - were to do if i were to send a
37:41 - transaction that called the smart
37:42 - contract function and did a whole bunch
37:44 - of other stuff it would cost more gas so
37:47 - we see here when we got sent
37:49 - 18.75 eth whoever sent us that eth also
37:53 - paid the blockchain miners or the
37:56 - blockchain validators a little bit of
37:58 - ethereum to include our transaction now
38:00 - we actually get to pick how much of a
38:02 - fee we want to send with our
38:03 - transactions so let's look at another
38:06 - example so
38:07 - in our accounts in metamask let's even
38:10 - expand the view here
38:12 - we have two different accounts we have
38:14 - account one and account two account one
38:16 - has 18.75 account two has zero
38:20 - we can actually send money from account
38:22 - one to account two and again remember
38:24 - this is all fake money so so we're gonna
38:26 - go ahead and hit transfer between my
38:28 - accounts so we're gonna send money to
38:30 - account two
38:32 - and here's where we can see some
38:33 - transaction details and we see the asset
38:36 - that we're going to send which we only
38:38 - have ethereum in this wallet so we're
38:40 - only going to send ethereum later on
38:41 - we'll learn how to get different assets
38:43 - into this wallet we're going to choose
38:44 - an amount i'm just going to choose to
38:46 - send one and then we have these pieces
38:49 - here
38:50 - associated with the transaction fee so
38:52 - we have a gas price in guay and a gas
38:55 - limit so when we send a transaction we
38:57 - can choose a gas limit we can say hey if
39:00 - this transaction is going to spend more
39:02 - gas than
39:03 - 21 000 gas we're not going to do it
39:07 - we also get to set a gas price in guay
39:11 - but here's the quick example of guay
39:13 - versus ethereum
39:14 - [Music]
39:17 - one ether is
39:20 - this many gray
39:21 - and one gray is this much ether because
39:24 - if we just said hey could you send me
39:26 - .00001
39:29 - that would be
39:30 - kind of really obnoxious so we just just
39:32 - say send me one way or send me one way
39:35 - so i know we've been throwing this gas
39:37 - term around for a little bit but here is
39:39 - it basically simplified gas is going to
39:41 - be the measurement of how much
39:43 - computation something uses the gas price
39:46 - is going to be how much it costs per
39:48 - unit of gas a gas limit is going to be
39:51 - the maximum amount of gas that can be
39:53 - used in transaction so for example if we
39:56 - make a transaction that uses 21 000 gas
40:01 - and each one gas is one way
40:05 - in price that means we're going to pay
40:07 - 21 000 way
40:09 - in transaction fee
40:11 - so back in our transaction we have we're
40:13 - saying the gas price
40:15 - is going to be one way so the
40:17 - transaction fee is going to be the gas
40:19 - that we use which will be up to this gas
40:21 - amount
40:22 - times the gas price so it'll be 21 000
40:26 - way will be the transaction fee so then
40:28 - the question is well why would we ever
40:30 - bump it up why would we want to pay more
40:33 - gas price why do i even have the option
40:35 - to pay more well and this comes down to
40:38 - block space we'll talk about this a
40:40 - little bit more when we get into how the
40:41 - blockchain actually works but the
40:43 - blockchain can only
40:45 - process so many transactions at a time
40:47 - and nodes and blockchain nodes can only
40:49 - process so many at a time so when i make
40:52 - a transaction a node has to decide why
40:55 - they want to include my transaction into
40:57 - the block and if there are a ton of
40:59 - people
41:00 - looking to make these transactions then
41:02 - the nodes are going to be highly
41:04 - incentivized to pick the transactions
41:07 - that are going to give them a high price
41:09 - that are going to give them a lot of
41:10 - money for including that transaction
41:13 - so this is what's called eath gas
41:15 - station and it is a a gas estimator of
41:19 - the blockchain it currently says that if
41:21 - you want to get your
41:23 - transaction in right away it's going to
41:25 - cost you 31 way to do so if you want to
41:28 - get it in less than five minutes it's
41:29 - going to take you maybe about 21 gway
41:32 - so the gas prices of ethereum fluctuate
41:35 - with how much people use it and the gas
41:37 - prices of all these blockchains
41:38 - fluctuate with how much people use it
41:41 - so this is an important concept so
41:43 - typically when you're setting your gas
41:45 - price in a transaction you can take a
41:47 - look-see at you know gas station and say
41:49 - okay if i want mine to go in right away
41:51 - i'm going to do asap if i want to go in
41:53 - fast maybe i'll do you know this fast
41:55 - amount standard i'll do this standard
41:57 - amount but it all depends on how many
42:00 - people are looking to work with this
42:01 - blockchain at the same time and and as
42:03 - you can see it fluctuates pretty quickly
42:05 - right it just went all the way up to 46
42:06 - so maybe more people are using the
42:08 - blockchain now this is obviously for the
42:10 - eth main net and on the test net there's
42:12 - not going to be that same competition
42:13 - but we can still change it anyway so if
42:15 - i go ahead and do 100 for the gas price
42:18 - and i hit next and i hit confirm if i go
42:20 - to activity
42:22 - i now have
42:23 - this transaction
42:25 - in my
42:27 - metamask but i can go ahead and view
42:29 - this on etherscan as well
42:31 - and we can see this is what it looks
42:33 - like when it's still processing this
42:34 - transaction and now we can see that it's
42:36 - passed and now if we look at the gas
42:38 - price we see it's a hundred gray and
42:41 - this is what we set it as when we were
42:42 - working with it before so gas prices 100
42:45 - way here versus our first original
42:47 - transaction was just one way
42:50 - now if we look at our metamask we can
42:52 - see that
42:53 - the funds have indeed been
42:55 - subtracted from this account and they
42:57 - have been added to this account now
42:59 - there's one eighth in this account
43:01 - awesome and you can see the activity
43:02 - there's one ethan here so again the
43:04 - reason that these gas prices exist is
43:06 - because nodes can only put so many
43:09 - transactions into a block so they're
43:11 - highly incentivized to input the
43:13 - transactions that are going to give them
43:15 - a higher fee so in times when a lot of
43:18 - people are looking to use a blockchain
43:19 - prices will get very high and when very
43:21 - few people are using a blockchain prices
43:23 - will be very low this ether scan tool is
43:26 - incredibly incredibly powerful and we'll
43:28 - be using it more and more as time goes
43:30 - on now here's something that's
43:31 - incredibly exciting with just this
43:32 - little bit of information you now know
43:34 - how to interact with blockchains and
43:36 - interact with the ethereum protocol so
43:38 - if you don't want to learn how to code
43:40 - anything you can go and you can start
43:42 - interacting with ethereum and interact
43:44 - with protocols with just this much
43:46 - information however i know most of you
43:48 - guys are here to learn how to code so
43:49 - let's look under the hood of ethereum
43:51 - and what is actually going on with these
43:53 - transactions
43:54 - and with these gas and with these
43:55 - blockchains and what's really going on
43:58 - let's learn all the fundamentals of a
44:00 - blockchain now if you want to just go
44:01 - ahead and jump into the coding go ahead
44:03 - and grab a timestamp from the
44:05 - description however learning exactly how
44:08 - the blockchain works is going to make
44:09 - you an incredibly powerful developer so
44:11 - let's take a look at that first so we're
44:13 - going to be going through this
44:13 - blockchain demo on this site right here
44:15 - now the creator of the site has a
44:17 - fantastic video and a fantastic
44:19 - walkthrough blockchain 101 it is right
44:21 - on their site so if you're looking for
44:23 - another explanation definitely check out
44:25 - his video it is absolutely fantastic but
44:27 - the first thing that we really need to
44:28 - do in order to understand blockchain in
44:30 - order to find really anything and
44:31 - everything that's going on here we first
44:33 - really need to understand this shot 256
44:35 - hash or hashing just kind of in general
44:38 - let's first understand what a hash is a
44:40 - hash is a unique fixed length string
44:43 - meant to identify any piece of data they
44:46 - are created by putting some piece of
44:48 - data into a hash function
44:50 - in this example
44:52 - the hashing algorithm used is sha256 now
44:55 - ethereum actually uses this this right
44:57 - here for its hashing algorithm which
44:59 - isn't quite um sha256 but is in kind of
45:02 - this shaw family but it's it's really
45:05 - just another way to hash things and uh
45:07 - the specific hash algorithm doesn't
45:09 - matter uh so much so uh this example
45:12 - uses sha-256 but you can imagine it's
45:14 - the same as the ethereum hash they're
45:15 - just gonna you know result in a
45:17 - different hash
45:18 - so what's going to happen in this
45:20 - application here is whatever
45:22 - data or whatever information we put into
45:25 - this data section here as you can see
45:27 - below this hash
45:29 - changes
45:30 - so what's happening is this data is
45:33 - running through the sha 256 hash
45:36 - algorithm and it's outputting this
45:38 - unique hash so this
45:41 - hash is a unique fixed length string
45:44 - that's going to identify like a blank
45:46 - data piece here right so if i put in you
45:47 - know my name like you know patrick
45:49 - collins
45:50 - this is the hash that's going to
45:52 - represent patrick collins right and you
45:54 - can see
45:55 - even when i put you know tons and tons
45:58 - of data in here the length of the string
46:02 - doesn't change
46:03 - right
46:04 - so it's always going to be the same
46:06 - amount we can put
46:07 - almost any amount of data in here there
46:09 - is an upper limit on the max size of the
46:12 - data but for all intents and purposes we
46:14 - can pretty much put any length in here
46:17 - and you'll see too that you know every
46:18 - time i type in patrick collins
46:20 - this hash is always going to be this
46:22 - 7e5b right i'm going to delete i'm going
46:24 - to do
46:24 - patrick collins again
46:26 - you know seven e5b it's always this this
46:29 - unique hash is always going to be
46:31 - unique right it's always gonna be this
46:32 - fixed length string here so now we can
46:35 - take this idea right of putting this
46:36 - data in here and we can move on to
46:38 - uh this concept of a block so with this
46:41 - block concept we're going to take the
46:43 - exact same thing with this hash this
46:44 - this data section right but instead of
46:46 - having everything just being this this
46:48 - singular data area right here we're
46:50 - going to split this data up into block
46:53 - nuns and data so all so what we're going
46:55 - to do is we're actually going to hash
46:57 - all three of these to get to get this
46:59 - hash right we're going to put all three
47:00 - of these we're going to say all three of
47:01 - these are combined uh together we're
47:04 - going to put every all three of them
47:05 - into this hashing algorithm uh to figure
47:07 - it out so if i type a bunch of stuff
47:09 - here
47:10 - we can see that block one
47:12 - with nuns you know this nonce and this
47:15 - data we're gonna get this hash and as
47:17 - you can see actually
47:18 - the screen turns red this block turned
47:21 - red now
47:23 - what happens when i hit this mine button
47:25 - when i hit this mine button it's
47:27 - actually going to take some time it's
47:28 - going to think for a little bit and we
47:30 - can see that the nuns here actually
47:32 - changed right the nuns is different from
47:34 - what it was before and
47:36 - this hash now starts with four zeros
47:40 - okay and then it the the back turned
47:41 - green when we're talking about mining
47:43 - we're talking about miners solving some
47:45 - type of very difficult problem that
47:47 - takes a lot of time to do now in this
47:49 - example here the problem that the miners
47:53 - had to solve was they had to find a nuns
47:56 - or or a value in this nun section that
47:58 - when hashed with at block number one
48:00 - with this data
48:02 - it would start with four zeros
48:04 - so the problem here the miners had to
48:06 - solve was to start with four zeros and
48:07 - the only way for them to really do that
48:10 - is kind of this brute force you know
48:12 - trying stuff so they tried one okay one
48:13 - didn't work okay two nope two didn't
48:15 - work three no four or five six okay five
48:18 - well that started with one zero but it's
48:19 - not four and they have to keep trying
48:22 - all these numbers until they uh get to
48:24 - this one where you know let's hit mine
48:26 - again
48:29 - where it has four zeros at the top at
48:31 - the start
48:32 - now
48:33 - this specific problem changes blockchain
48:35 - to blockchain right ethereum has a
48:37 - different problem for miners to solve um
48:39 - bitcoin has different problems for minor
48:41 - itself but this concept is going to be
48:42 - the same
48:43 - so they have to take
48:45 - one block is going to be this
48:47 - uh this concept is going to be all this
48:49 - data it's going to be the block number
48:52 - and it's going to be this nunce right
48:54 - and so this nunce is the solution um is
48:57 - is going to be the the number that they
48:58 - use to get like the solution to the
49:00 - problem right so if i go to one
49:03 - here you know when i do this again
49:06 - i'm gonna hit mine
49:08 - and the nuns has changed right it went
49:09 - from one to
49:11 - thirty three thousand one hundred and
49:12 - twenty eight because this is the nuns
49:13 - that allowed this hash to start with
49:16 - four zeros and so that's what's
49:17 - happening
49:18 - when uh blockchain miners are mining
49:21 - they're going through this process this
49:22 - very computationally intensive process
49:25 - of trying to find a nuns that fulfills
49:27 - whatever the problem is so that's really
49:29 - it actually so that's a block and that's
49:31 - really what's happening when miners are
49:33 - mining they're just looking there's
49:34 - trial and error brute force trying to
49:36 - find this nut so so now that we know
49:39 - what a block is let's go to the next
49:40 - step and figure out okay well what's a
49:42 - block chain so here we have an example
49:45 - of what a block chain is going to look
49:47 - like right we have a combination you
49:50 - know we have back here in the block
49:51 - section we have one what one block looks
49:53 - like now here we have multiple different
49:56 - blocks right each one of these
49:57 - represents a different block but we have
49:59 - an additional column here or we have
50:01 - additional uh variable here so like
50:04 - before you know we have block nuns and
50:06 - data
50:07 - right we have block nun's data but we
50:09 - also have this thing called previous
50:11 - right and so this is actually pointing
50:13 - to the previous hash of the last block
50:17 - so for example if we go to the the last
50:19 - block in this blockchain it says
50:20 - previous is 008 and if we look at the
50:23 - hash of block number four it's zero zero
50:25 - zero zero eight e eight and then we look
50:27 - at its previous it's uh four zeros b9 we
50:31 - have four zeros b9 and so on all the way
50:33 - back to our first block which has
50:35 - previous of just all zeros right and so
50:38 - the block with the previous of all zeros
50:41 - is going to be known as the genesis
50:43 - block so you've probably heard that
50:44 - before the genesis block it's the first
50:45 - block in the blockchain where the
50:47 - previous hash points to a hash that
50:50 - doesn't actually exist now as you can
50:52 - imagine kind of the same as how this
50:53 - block worked how the block nuns and data
50:56 - all go through the hashing algorithm in
50:58 - the blockchain the block nuns data and
51:01 - previous hash all go through this
51:03 - hashing algorithm to figure out you know
51:05 - what the hash is okay so if we go to
51:07 - over here you know for example if i type
51:09 - in you know patrick
51:10 - obviously this is now no longer valid
51:12 - right because this nuns uh combined with
51:15 - the block the data and the previous hash
51:17 - aren't gonna solve you know our problem
51:19 - of having four zeros at the start right
51:21 - so i'm going to go and fix that and and
51:23 - that's that's kind of an easy way to see
51:24 - it being broken but
51:26 - but let's take a look if i break
51:29 - this block right here what happens if i
51:31 - if i break the data in here if i do like
51:33 - trick in here you can see that both of
51:36 - these
51:37 - are now red both of these are now
51:39 - invalid right because the block hashed
51:42 - with the nuns hash with the new data
51:44 - which is my name patrick has worked
51:46 - hashed with the previous block
51:48 - is now a brand new hash right and this
51:51 - block
51:52 - is still pointing to this previous hash
51:55 - right here right it's pointing to this
51:56 - previous block and now it is wrong and
51:59 - it is messed up and now um and now it's
52:02 - nuns with this previous hash is also
52:05 - wrong
52:05 - right and this is where when we talk
52:07 - about uh blockchains being immutable
52:09 - this is exactly how it's immutable right
52:12 - because if i go back and i change
52:14 - anything you know if i've just
52:16 - typed a right here the entire blockchain
52:18 - is now invalidated because none of these
52:21 - are going to have
52:23 - nunses that solve this equation anymore
52:25 - so this is why blockchains are immutable
52:27 - is because anytime you change one thing
52:30 - you ruin the rest of the blockchain okay
52:33 - so however though you know if if an a
52:34 - was here originally we can go ahead and
52:36 - mine these
52:38 - we can mine all these but as you can see
52:39 - you know this is going to start getting
52:41 - very
52:42 - computationally expensive
52:43 - because i have to go redo basically the
52:46 - entire blockchain
52:47 - and the farther and farther down the
52:49 - line you get the harder and harder it
52:50 - becomes to you know rehash and redo all
52:53 - these different blockchains here now
52:54 - this makes a lot of sense right so we
52:55 - have this blockchain it's really hard to
52:57 - change something in the past but if we
52:58 - do we can just go ahead and remind it
53:00 - now if i'm the one who controls the
53:02 - blockchain right if i'm the one who
53:03 - controls this you know and i want to
53:04 - change something in the past well okay
53:06 - great all i got to do is change this
53:08 - data here and then you know mine each
53:10 - one of these and you know obviously it's
53:11 - going to be very computationally
53:13 - expensive but it's something that i can
53:14 - do right if i'm the one who owns the
53:16 - blockchain
53:18 - now here's where the decentralized
53:21 - nature or the distributed nature really
53:23 - uh makes it incredibly powerful so we're
53:26 - gonna go to the distributed tab here
53:28 - which i also refer to as the
53:29 - decentralized tab here
53:31 - it's going to show us what a blockchain
53:33 - looks like
53:34 - in a decentralized manner so we have
53:36 - this exact same initial setup here we
53:38 - have distributed blockchain we have you
53:40 - know our first block chain which is kind
53:42 - of exactly as the one from here but we
53:43 - also have
53:45 - more than one so we have peer a peer b
53:48 - and peer c and when people are talking
53:49 - about peer to peer appear to be your
53:51 - transactions they're really talking uh
53:52 - this is kind of that concept that
53:54 - they're talking about right so we have a
53:55 - number of different peers who are
53:57 - running this blockchain technology
53:59 - they're all weighted equally right each
54:01 - one of these peers or each one of these
54:03 - nodes each one of these entities running
54:05 - a blockchain
54:07 - has the exact same power as anybody else
54:10 - right so the way that we can tell very
54:13 - easily which blockchain is correct or
54:15 - which ones are correct are by looking at
54:18 - this end
54:19 - hash here right or by looking at where
54:21 - we are
54:22 - in the blockchain because again remember
54:24 - because again remember this this hash
54:26 - that this this in this last block here
54:29 - is going to encompass
54:31 - all of the blocks from before right
54:34 - because this last hash is going to have
54:35 - the previous hash here which includes
54:37 - the previous hash here which this hash
54:39 - includes the previous hash here in which
54:41 - so this last hash is encompasses
54:43 - everything in here right and we can look
54:46 - we can look at the hash of pure c which
54:48 - is four zeros and then e4b we can look
54:50 - at the latest hash of peer b which is
54:53 - four zeros e4b
54:54 - and then pure a which is for zeros e4b
54:57 - so all of these peers all of these nodes
55:00 - all of these decentralized you know
55:02 - these independent
55:04 - all these independent users running this
55:06 - blockchain software they're all matched
55:08 - up it's very easy for their nodes to
55:10 - look at each other and say hey great we
55:12 - are all matched up
55:13 - now
55:14 - what let's say that a decides that you
55:17 - know something happened on the
55:18 - blockchain that they didn't like and
55:19 - they wanted to go back and change
55:21 - something right so let's say they change
55:23 - here you know obviously
55:25 - the rest of their blockchain is
55:26 - invalidated and they have to spend a lot
55:28 - of computational power to catch up to
55:29 - speed so let's go ahead and humor it
55:31 - let's say that they they did they ended
55:33 - up catching up
55:35 - uh they ended up catching up you know
55:36 - they ended up mining everything
55:38 - and now they have a valid blockchain
55:40 - right it solves the equation awesome
55:43 - however
55:44 - in block number three
55:46 - there's something new
55:47 - right this is here and it shouldn't have
55:49 - been here this is something that pier a
55:51 - put in by themselves
55:53 - all that happens now
55:55 - is we look at all the blockchains that
55:58 - are running the software and we're
55:59 - looking at all the hashes at hash at
56:02 - block number five so pier a has this new
56:05 - hash now 009 bc
56:08 - but peer b has a different hash 0 e4b
56:12 - right so who's right is it is it pier a
56:14 - with their new stuff or is it peer b
56:16 - well that's where the decentralizator
56:19 - comes in because then we can look at
56:20 - pier c and pierce c
56:22 - also has e4b so
56:24 - pure b and pure c both say hey pure a
56:27 - you're wrong
56:28 - get out right and peer a will stop being
56:31 - able to participate in the mining
56:32 - rewards because they have essentially
56:34 - forked uh the blockchain and started
56:36 - their own little blockchain right with
56:38 - their own history because they're the
56:40 - only ones with this this piece of data
56:43 - in block three whereas peer b
56:46 - and peer c have nothing in there so that
56:48 - really shows why uh in these blockchain
56:50 - worlds in this decentralized world there
56:52 - really is no central identity you know
56:53 - pier a you know might have been
56:55 - maliciously motivated to change you know
56:57 - this block number three however
56:59 - democracy rules right the majority rules
57:01 - in the blockchain peer b and pc both say
57:04 - hey you know that's cute and all pure a
57:06 - but
57:07 - you're wrong right that that's not right
57:08 - now it might be a little abstract that
57:10 - you just look at data and you know us
57:12 - typing kind of random stuff in here and
57:13 - think okay yeah that's that's data right
57:15 - that makes sense you know just kind of
57:17 - random strings in here doesn't really do
57:19 - anything for us so if we actually go
57:21 - over to the token section here this is
57:23 - where everything really starts to make a
57:25 - lot of sense so we have the exact same
57:27 - setup here with peer a peer b peer c
57:30 - except the difference is instead of
57:33 - having kind of this this data section we
57:35 - have this
57:36 - tx this transaction section right and
57:38 - this represents all the transactions
57:41 - that are happening in this block right
57:43 - so we're we're sending 25 dollars from
57:45 - darcy to bingle or to bingley uh force
57:48 - uh four dollars and 27 cents here uh
57:51 - 1922 right and it's the exact same thing
57:54 - so this all these transactions are going
57:56 - to get hashed in the exact same way uh
57:59 - that the data is going to get hashed and
58:01 - and this is why it's so powerful because
58:02 - again you know if i want to be malicious
58:04 - right if uh if i want to say hey i
58:07 - really wanted to give jane
58:08 - a lot more money from elizabeth so i'm
58:10 - pure a and i go back and i change it to
58:12 - 100 well now
58:13 - you know not only do i does my whole
58:15 - blockchain
58:16 - get invalidated because that was so far
58:18 - so long ago but i'm not going to match
58:21 - any of these other chains right and so
58:23 - my blockchain is going to be excluded
58:25 - from the overall blockchain so and let's
58:27 - let's go ahead and fix this and it's the
58:29 - same thing if down here if i become
58:31 - malicious and i want to send you know i
58:34 - want
58:34 - uh miss audrey to have less money maybe
58:37 - i want to send a dollar and i go ahead
58:39 - and mind it the same thing here
58:41 - this hash now this 2a1 is not going to
58:45 - match
58:46 - peer b's
58:48 - pre-b's hash of bba and it's not going
58:50 - to match pc's hash of bba as well so the
58:53 - two of them are going to say hey this
58:55 - your blockchain isn't valid it's not
58:57 - matching the majority you know you're
58:59 - out right
59:01 - so that's really how these blockchains
59:03 - work at a low level and it all goes back
59:06 - to this this understanding this hash
59:08 - idea and using it in this very
59:10 - sophisticated manner uh to kind of
59:12 - cryptographically prove
59:13 - um you know where where stuff lies now
59:16 - the way the blockchain works is that
59:17 - instead of random stuff put in this data
59:19 - section it's actually going to be
59:21 - solidity code in here to finding ways to
59:23 - interact with different blocks and
59:24 - different protocols that are on chain or
59:27 - as we've said before different smart
59:29 - contracts
59:31 - now the next question that you might be
59:33 - asking is okay well
59:34 - how do i know how can i be sure that i'm
59:38 - the one
59:39 - uh you know let's say this is let's say
59:40 - i'm darcy right how can i be sure that i
59:42 - was that darcy was the one to actually
59:44 - send this money here how do we know that
59:46 - darcy sent 25
59:48 - to
59:49 - bingley well this is where we get into
59:52 - uh private keys and public keys and
59:54 - that's what we're going to go into now
59:55 - let's just do a quick recap of what
59:58 - we've learned in this section so far
59:59 - right we've learned that
60:01 - ethereum actually runs on this ketchup
60:03 - 256 but you know we used shot to v6 for
60:06 - this demo it doesn't really matter we're
60:08 - just talking about hashing algorithms so
60:11 - again a hash is a unique fixed length
60:14 - string meant to identify any piece of
60:17 - datum a hash algorithm or a hash
60:19 - function is a function or algorithm that
60:22 - computes any type of data into a unique
60:25 - hash
60:26 - mining is the process of finding the
60:28 - solution to the blockchain problem in
60:31 - our example the problem was to find a
60:33 - hash that starts with four zeros
60:35 - whenever a node mines a block they get
60:38 - paid a little bit of that gas we were
60:39 - talking about earlier for doing
60:41 - something a block in a blockchain is
60:43 - basically a combination of a block nonce
60:45 - transaction and previous hash to create
60:48 - this unique hash for this block and
60:50 - again depending on the blockchain
60:52 - implementation this might have a couple
60:54 - other fields or might have different
60:55 - fields but this is essentially what's
60:57 - going on blockchains are decentralized
60:59 - and distributed because
61:00 - many independent users are going to run
61:02 - this blockchain software and they will
61:04 - check and they will compare against each
61:05 - other to see which blockchains are
61:07 - acting honestly and which ones are
61:09 - acting maliciously in the blockchain
61:11 - world majority rules the nuns here is
61:14 - the answer used or the number used to
61:17 - get this hash now nuns is kind of an
61:19 - overloaded term it's actually used for a
61:21 - number of different reasons in this case
61:23 - we're using it to solve this problem of
61:25 - getting you know four or five zeroes at
61:27 - the stop of the hash however in ethereum
61:29 - it'll also be often used as the number
61:31 - of transactions from a given address so
61:34 - now we're going to talk a little bit
61:35 - about signing these transactions and
61:37 - private keys and some other cryptography
61:39 - pieces right because in this blockchain
61:41 - demo here we can see we hover these
61:43 - these fantastic transactions right all
61:45 - these things went through but how do we
61:46 - know that it was darcy who was the one
61:49 - to send 25
61:51 - to bingley right how do we know that
61:53 - actually happened and this is where
61:55 - all those pieces that we just learned
61:57 - about uh in our our test net in our
62:00 - metamask account are really going to
62:01 - start to to come to life here a little
62:03 - bit here so here we have an example of
62:06 - public and private keys okay at the top
62:09 - we have this private key right that was
62:11 - that was randomly generated a private
62:13 - key is is you know as it kind of states
62:15 - is a key that you really want to keep
62:17 - secret because you're going to be using
62:18 - this
62:19 - as kind of your secret password for all
62:22 - your transactions right i can really
62:23 - pick you know any
62:25 - any any private key anything that i want
62:28 - and with it uh
62:30 - this algorithm they're going to use an
62:32 - algorithm you know for ethereum in
62:33 - bitcoin they both use this elliptic
62:35 - curve digital signature algorithm it's a
62:38 - variant of just a digital signature
62:40 - algorithm and it's going to create this
62:42 - this public key right i'm really not
62:43 - going to go at all into kind of this
62:45 - digital signature algorithm but just
62:47 - know it does use some of these some of
62:49 - the hash
62:51 - knowledge that we just learned combined
62:52 - with some other pieces
62:54 - to kind of get this this public here so
62:56 - i'm not going to go too deep into it but
62:57 - we have this private key that we create
63:00 - and we get this public key now this
63:01 - public key we want everybody to have
63:04 - access to right this is yeah whole world
63:06 - can see this this private key we really
63:08 - want it to be uh private we don't want
63:10 - people to see this we're going to use
63:12 - this private key as like a password to
63:14 - quote unquote digitally signed
63:17 - transactions and then people can verify
63:20 - them with this public key so let's let's
63:22 - see what this actually looks like let's
63:23 - pick a random key a more secure key
63:25 - right because the longer it is the more
63:27 - secure it's going to be
63:29 - and if we go to signatures now
63:31 - right
63:32 - let's say we have this
63:34 - this message that we want right we'll
63:35 - say hi world right we want this to be
63:38 - the message what's going to happen
63:40 - is this private key that we've created
63:42 - we can use to sign this data right
63:44 - remember how in the blockchain demo you
63:46 - know we were kind of we were hashing
63:48 - stuff right we were we're using this uh
63:50 - shay256 hash to to get this hash well
63:53 - we're doing something similar but
63:54 - instead of hashing we're we're using
63:56 - this digital signature algorithm to
63:58 - create this message signature
64:00 - now what's really powerful about how
64:02 - this uh this algorithm works is that you
64:05 - can create this message signature with
64:08 - your private key but somebody else can't
64:10 - derive your private key from the message
64:13 - signature and that's what makes this
64:15 - really really powerful however if we go
64:17 - to verify using this public key right
64:20 - and so this is the
64:21 - this is that o four zero three this is
64:23 - that same public key using this using
64:26 - this public key
64:27 - anybody can verify let's go ahead and
64:29 - sign again anybody can verify
64:32 - that the signature
64:34 - is yours right so you have a public a
64:37 - private key
64:38 - just for you so you can sign things and
64:40 - a public key that anybody can verify
64:42 - something right so anybody can verify
64:44 - this and let's say somebody tries to
64:46 - fake a transaction from you they say hey
64:49 - you know this is this is this is their
64:51 - transaction
64:53 - all they have to do is verify
64:54 - that this
64:56 - signature against your public key and
64:59 - very easily this whole thing turns red
65:01 - because
65:02 - it isn't verified right the the
65:04 - algorithm says hey
65:05 - that's wrong so we can go ahead and take
65:07 - that into transactions in this exact
65:10 - same way so if i want to send money
65:12 - you know if i want to send
65:14 - 400
65:15 - from you know my address to another
65:18 - address using my private key i can sign
65:21 - that transaction
65:23 - and anybody else in the world can then
65:25 - verify this transaction right and this
65:27 - is why when people say
65:29 - hide your keys you know protect your
65:30 - keys this is what we're talking about
65:32 - in our accounts here
65:34 - right if we go to
65:36 - uh settings and again the only reason
65:38 - that i'm showing you guys
65:40 - my mnemonic in my private key is because
65:42 - this is a
65:43 - uh this is a dumpster account i'm gonna
65:44 - throw this away at the end of this video
65:46 - or i'm just not gonna put any real money
65:47 - in it
65:48 - um
65:49 - but
65:52 - when we look at our our metamask here we
65:55 - have this mnemonic phrase which allows
65:57 - us to
65:59 - easily get these different private keys
66:01 - right so
66:02 - demonic phrase combined uh with you know
66:06 - whatever account number will get us a
66:07 - private key so demonic phrase combined
66:09 - with one we're going to get this private
66:11 - key and this is when we look at account
66:13 - details export private key
66:18 - password confirm this is going to be the
66:21 - private key that we're going to use to
66:23 - sign our transactions right this if
66:25 - anybody else gets access to this private
66:27 - key they then can sign transactions for
66:30 - us and they can send transactions for us
66:32 - and that's why we want to keep these
66:33 - private
66:34 - so it works the exact same way right so
66:36 - this is why it's so important to hide
66:38 - your private keys and hide your
66:40 - mnemonics now
66:41 - your ethereum address is actually
66:44 - a piece
66:48 - is actually a piece of your public key
66:50 - now to get our address in ethereum all
66:53 - we have to do is take this public key
66:54 - that we've created with our private key
66:57 - hash it using that same ethereum hashing
66:59 - algorithm and then take the last 20
67:00 - bytes and that's how we'll actually
67:02 - derive to our um to our address here now
67:05 - knowing the exact methodology of how to
67:08 - get the address doesn't really matter
67:10 - because it could change blockchain to
67:11 - blockchain and could even change an too
67:13 - but just know that that is essentially
67:15 - how kind of these addresses are derived
67:17 - right there's some derivative of the
67:19 - public key right because the public key
67:21 - is public and you know using the public
67:24 - key in kind of any public way is is
67:25 - totally fine
67:27 - but not the private key so that is how
67:29 - we sign our transactions note though
67:31 - this isn't how we send the transaction
67:33 - so so this is just going to sign it
67:34 - create a transaction for us to send
67:36 - we'll learn later on how to send these
67:38 - transactions
67:40 - so that was a lot of information there
67:41 - too let's do a quick recap your public
67:44 - key is derived by using a digital
67:46 - signature algorithm on your private key
67:49 - right and you want to keep your private
67:50 - key private at all times because you're
67:52 - going to use your private key to sign
67:55 - transactions
67:56 - signing transactions with your private
67:58 - key you are the only one who can
67:59 - actually do this because you can't get
68:02 - the private key from a message signature
68:04 - however using your public key you can
68:08 - anybody can very easily verify that a
68:10 - signature that's signed by you is in
68:12 - fact signed by you in our metamask our
68:14 - private keys are located in this account
68:17 - details section you just hit
68:19 - show private keys and type in your
68:21 - password and you'll get your private key
68:23 - here
68:24 - a quick note here is often times when
68:26 - using your private key somewhere they
68:28 - want it in hexadecimal form so if we're
68:30 - going to use our private key
68:32 - for something like brownie which we'll
68:34 - go into later we need to actually append
68:36 - in a 0x to the front but we'll get into
68:38 - that later
68:39 - and the address
68:41 - of your account is derived from this so
68:44 - if you think about it your private key
68:46 - creates your public key which then can
68:48 - create your address and there's a little
68:50 - barrier
68:52 - or a big barrier here
68:54 - because your private key you want to
68:55 - keep private and your public key and
68:57 - your address can all be public
68:58 - information awesome so now that we know
69:00 - all the cryptography pieces and all the
69:02 - little nitty gritties of how the
69:03 - blockchain actually works and how our
69:05 - signatures work and how everything
69:06 - sticks together let's talk a little bit
69:08 - about how this works in actuality and
69:11 - what's really going on now for a lot of
69:13 - this each different blockchain has
69:15 - slightly different algorithms and
69:16 - slightly different metrics and criteria
69:19 - for doing a lot of the stuff so when
69:21 - we're talking about these specific
69:23 - implementations keep in mind the exact
69:25 - algorithm might be a little bit
69:26 - different but the concepts are all still
69:28 - going to be exactly the same hashing and
69:31 - hash function is going to be the same no
69:32 - matter where you look a decentralized
69:34 - blockchain is going to be the same no
69:36 - matter where you look how it's actually
69:38 - implemented is going to be a little bit
69:40 - different now traditionally when you run
69:42 - an application you know be it a website
69:44 - or something that connects to some
69:46 - server you are interacting with a
69:48 - centralized entity and unlike how we saw
69:51 - with the blockchain with multiple
69:52 - different peers it's going to be run by
69:55 - a single centralized group now it still
69:57 - could be run on many different servers
69:59 - but all those servers are still going to
70:00 - be controlled by the same centralized
70:03 - group blockchains as we saw run on a
70:06 - network of different independent nodes
70:09 - when we saw peer a peer b peer c those
70:11 - were different examples of different
70:13 - independent users running the blockchain
70:16 - technology on their own node now when i
70:18 - use the term node i'm usually referring
70:20 - to a single instance of a decentralized
70:22 - system so when i say a single node when
70:24 - i'm talking about a blockchain i'm
70:26 - talking about one of those peer a's peer
70:28 - b's pcs running that blockchain software
70:30 - i'm talking about one server running
70:32 - this technology and again it's this
70:35 - network it's this combination of these
70:36 - nodes interacting with each other that
70:38 - creates this entire blockchain what
70:40 - makes this so potent too is that anybody
70:42 - can join the network and that's why
70:44 - there's decentralized the barrier to
70:46 - entry is a little bit of hardware
70:47 - requirements you're getting the correct
70:49 - materials to run the software and then
70:51 - you running the software anybody can
70:53 - join these networks and participate and
70:54 - that's what makes it truly decentralized
70:57 - in fact you can go to github right now
70:59 - and run your own ethereum node in a few
71:01 - seconds now in the traditional world
71:03 - applications are run by centralized
71:05 - entities and if that entity goes down or
71:08 - is maliciously bribed or decides that
71:10 - they want to shut off they just can't
71:13 - because they're the ones that control
71:15 - everything blockchains by contrast don't
71:17 - have this problem if one node or one
71:20 - entity that runs several nodes goes down
71:22 - since there are so many other
71:24 - independent nodes running that it
71:26 - doesn't matter the blockchain and the
71:28 - system will persist so long as there is
71:30 - at least one node always running and
71:33 - luckily for us most of the most popular
71:35 - chains like bitcoin and ethereum have
71:37 - thousands and thousands of nodes and as
71:39 - we showed in our demo if one node acts
71:41 - maliciously all the other nodes will
71:45 - ignore that node and kick that out or
71:47 - even punish it in some systems because
71:49 - they can easily check everybody else's
71:51 - node and see okay this one is out of
71:54 - sync with the majority and yes majority
71:56 - rules when it comes to the blockchain
71:57 - each blockchain keeps a full list of
71:59 - every transaction and interaction that's
72:02 - happened on that blockchain and we saw
72:04 - if a node tries to act maliciously
72:06 - then all their hashes are going to be
72:07 - way out of whack and they're not going
72:08 - to match everybody else this gives
72:10 - blockchains this incredibly potent
72:12 - immutability trait where nothing can be
72:15 - changed or corrupted so in essence we
72:17 - can think of a blockchain as a
72:18 - decentralized database and with ethereum
72:21 - it has an extra additional feature where
72:23 - it also can do computation in a
72:26 - decentralized manner now let's talk
72:27 - consensus proof of work and proof of
72:30 - stake because you've probably heard
72:31 - these before and they're really
72:33 - important to how these blockchains
72:35 - actually work we went through that
72:36 - blockchain example and we did that
72:38 - mining feature this is what's known as
72:40 - proof of work proof of work and proof of
72:43 - stake fall under this umbrella of
72:45 - consensus and consensus is a really
72:48 - important topic when it comes to
72:49 - blockchains consensus is defined as the
72:51 - mechanism used to reach an agreement on
72:54 - the state or a single value on the
72:56 - blockchain especially in a decentralized
72:58 - system i briefly alluded to this
73:00 - consensus mechanism in our blockchain
73:02 - example when i said if one changes
73:04 - something and the other two
73:06 - don't then majority will rule and kick
73:08 - that one out this is part of that
73:10 - consensus mechanism now very roughly a
73:13 - consensus protocol in a blockchain or
73:14 - decentralized system can be broken down
73:16 - into two pieces a chain selection
73:18 - algorithm and a civil resistance
73:20 - mechanism that mining piece that we were
73:22 - doing or or the proof of work algorithm
73:25 - is what's known as a civil resistance
73:27 - mechanism and this is what ethereum and
73:29 - bitcoin currently use please note that
73:32 - depending on when you're watching this
73:34 - if eth2 is out then it's no longer proof
73:36 - of work now proof of work is known as a
73:38 - civil resistance mechanism because it
73:39 - defines a way to figure out who is the
73:41 - block author which node is going to be
73:44 - the node who did the work to find that
73:46 - mine and be the author of that block so
73:48 - all the other nodes can verify that it's
73:50 - accurate civil resistance is a
73:52 - blockchain's ability to defend against
73:54 - users creating a large number of
73:56 - pseudo-anonymous identities to gain a
73:58 - disproportionately advantageous
74:00 - influence over said system
74:03 - and in layman's terms it's basically a
74:04 - way for a blockchain to defend against
74:06 - somebody making a bunch of fake
74:07 - blockchains so that they can get more
74:09 - and more rewards now there are two types
74:11 - of the civil resistance mechanisms that
74:12 - we're going to talk about here namely
74:14 - proof of work and proof of stake let's
74:17 - talk about proof of work a little bit
74:18 - more in depth first in proof of work
74:20 - this is silver resistant because a
74:22 - single node has to go through a very
74:24 - computationally expensive
74:26 - process called mining which we
74:28 - demonstrated earlier to figure out the
74:30 - answer to the blockchain's riddle of
74:31 - finding that correct nonsore or whatever
74:33 - the blockchain system has in place in
74:35 - proof of work this works because
74:36 - no matter how many pseudo-anonymous
74:38 - accounts you make each one still has to
74:41 - undergo this very computationally
74:42 - expensive activity of finding the answer
74:45 - to the proof-of-work problem or the
74:47 - proof-of-work riddle which again in our
74:49 - demonstration it was finding a nunce
74:51 - with that first four zeros but again
74:53 - each blockchain might change the riddle
74:55 - work or change the problem to be a
74:56 - little bit different in fact some of
74:58 - these blockchains make this riddle
74:59 - intentionally hard or intentionally easy
75:02 - to change what's called the block time
75:04 - the block time is how long it takes
75:05 - between blocks being published and it's
75:07 - proportional to how hard these
75:09 - algorithms are so these problems
75:11 - actually can change depending on how
75:13 - long they want the block tone to be if
75:15 - the system wants the block time to be
75:17 - very very long they just make the
75:19 - problem very very hard if they want to
75:21 - be very short to make the problem a lot
75:23 - easier we'll talk about civil attacks in
75:25 - a little bit and how they can affect the
75:26 - system but with proof of work it's a
75:28 - verifiable way to figure out who the
75:30 - block author is and be civil resistant
75:33 - now you need to combine this with a
75:34 - chain selection rule create this
75:36 - consensus now there are some consensus
75:38 - protocols that have more features but
75:40 - very very roughly these are the two
75:41 - pieces that we're going to look at the
75:43 - second piece is going to be a chain
75:45 - selection rule
75:46 - how do we know which blockchain is
75:48 - actually the real blockchain and the
75:50 - true blockchain now on bitcoin and
75:51 - ethereum they both use a form of
75:53 - consensus called nakamoto consensus and
75:56 - this is a combination of proof of work
75:58 - and longest chain rule the decentralized
76:00 - network decides that whichever
76:02 - blockchain has the longest chain or the
76:04 - most number of blocks on it is going to
76:06 - be the chain that they use this makes a
76:08 - lot of sense because every additional
76:10 - block that a chain is behind it's going
76:12 - to take more and more computation for it
76:14 - to come up
76:16 - that's why when we saw in our
76:17 - transaction we actually saw
76:18 - confirmations the number of
76:20 - confirmations is the number of
76:22 - additional blocks added on after our
76:25 - transaction went through in a block so
76:27 - if we see confirmations is two it means
76:29 - that the block that our transaction was
76:31 - in has two blocks ahead of it in the
76:33 - longest chain now i do want to point out
76:35 - that a lot of people use proof of work
76:37 - as a consensus protocol and i do want to
76:39 - say that this is a little bit inaccurate
76:42 - but sometimes people use it
76:43 - interchangeably proof of work is a piece
76:46 - of the overall consensus protocol which
76:48 - in bitcoin and ethereum one's current
76:50 - case is nakamoto consensus nakamoto
76:53 - consensus is a combination of proof of
76:56 - work and its longest chain rule both
76:58 - equally and very very important now
77:01 - proof of work also tells us where these
77:03 - transaction fees and these block rewards
77:05 - go to remember how when we made this
77:07 - transaction we had to talk about gas and
77:10 - a transaction fee so who's getting paid
77:12 - who is getting this transaction and this
77:14 - transaction fee is going to the miners
77:16 - or the validators in a proof of work
77:18 - network they're called miners and in the
77:20 - proof of stake network they're called
77:23 - validators there are a little bit
77:24 - different and we'll get into that when
77:26 - we talk about proof of stake in this
77:27 - proof of work system all these nodes are
77:29 - competing against each other to find the
77:32 - answer to the blockchain riddle remember
77:34 - in our example it was to find a hash
77:36 - that has four zeros at the start and
77:38 - again depending on the blockchain
77:40 - implementation that riddle is going to
77:41 - be a little bit different but all the
77:43 - nodes are trying as many as possible to
77:46 - try to get this answer first why because
77:49 - the first node to figure out the answer
77:51 - to the blockchain rule is going to get
77:52 - that transaction fee they're going to
77:54 - get paid from that now when a node gets
77:56 - paid they actually get paid in two
77:57 - different ways one is going to be with a
77:59 - transaction fee and another piece is
78:01 - going to be the block reward remember
78:03 - how we talked about alternating the gas
78:05 - price or the way on our transaction well
78:07 - that's the transaction fee that we're
78:09 - going to pay to these blockchain nodes
78:11 - for including our transaction the block
78:13 - reward is given to these nodes from the
78:15 - protocol from the blockchain itself
78:18 - you've probably heard of the bitcoin
78:19 - having before the having is referring to
78:22 - this block reward getting cut in half
78:25 - and it's supposed to be cut in half
78:26 - roughly every four years this block
78:29 - reward increases the circulating amount
78:31 - of whatever cryptocurrency that is being
78:33 - rewarded for example on ethereum the
78:35 - block reward is giving out ethereum and
78:37 - on bitcoin the block reward is giving
78:38 - out bitcoin so these nodes are competing
78:40 - against each other to be the first one
78:42 - to find this transaction to be the first
78:44 - one to find the answer to this problem
78:46 - so that they can be the ones to win both
78:48 - this block reward and your transaction
78:51 - fee some blockchains like bitcoin for
78:53 - example have a set time when they are no
78:56 - longer going to give out block rewards
78:57 - and the miners or the nodes are only
78:59 - going to get paid from transaction fees
79:02 - now this gas fee again is paid by
79:04 - whoever initialized the transaction when
79:07 - we got our funds from the faucet there
79:09 - was some server and somebody else was
79:11 - paying the transaction fee for us
79:13 - however when we sent ether from one
79:15 - account to another our first account
79:18 - actually paid some transaction fee to
79:20 - send that ether in proof of stake
79:22 - there's also a gas fee but it's paid out
79:24 - to validators instead of miners and
79:27 - we'll talk about that in a little bit
79:28 - now let's talk about two types of
79:29 - attacks that can happen in these
79:31 - blockchain worlds let's talk about the
79:32 - first one being the sybil attack the
79:34 - simple attack is when a user creates a
79:36 - whole bunch of pseudo-anonymous accounts
79:38 - to try to influence a network now
79:41 - obviously on bitcoin and ethereum this
79:43 - is really really difficult because the
79:45 - user needs to do all this work in proof
79:47 - of work or have a ton of collateral in
79:49 - proof of stake which again we'll talk
79:50 - about in a bit the other more prevalent
79:52 - attack is what's known as a 51 percent
79:55 - attack now as we saw as part of our
79:56 - consensus protocol these blockchains are
79:59 - going to agree that the longest chain is
80:01 - the one that they're going to go with so
80:03 - long as it matches up with 51 percent of
80:05 - the rest of the network
80:07 - this means that if you have the longest
80:09 - chain and you have more than 51 percent
80:11 - of the rest of the network you can do
80:13 - what's called a fork in the network and
80:15 - bring the network onto your now longest
80:17 - chain now sybil attacks obviously are
80:19 - when a single node or a single entity
80:21 - tries to affect the decentrality of the
80:23 - network by pretending to be multiple
80:25 - different people although they're just
80:27 - the same person or entity and like i
80:29 - said it's really difficult to do in
80:30 - proof of work and proof of stake so you
80:32 - can see now that blockchains are very
80:33 - democratic whichever blockchain has the
80:36 - most buy-in and is the longest is the
80:38 - blockchain that the whole system is
80:40 - going to corroborate when nodes produce
80:42 - a new block and add to the longest chain
80:44 - the other nodes will follow this longest
80:46 - chain that the rest of the network is
80:47 - agreeing with add those blocks to their
80:49 - chain and follow up so very small
80:51 - reorganizations are actually pretty
80:53 - common when a blockchain picks a block
80:55 - from a different longest chain puts it
80:57 - on and then has to
80:58 - swap it out for another block and
81:00 - continue with a different blockchain
81:02 - however if a group of nodes had enough
81:04 - nodes or enough power they could
81:05 - essentially be 51 of the network and
81:08 - influence the network in whatever
81:10 - direction that they wanted this is
81:12 - what's known as a 51 attack and it's
81:14 - happened on blockchains like ethereum
81:16 - classic which is not ethereum this is
81:18 - why the bigger a blockchain is the more
81:20 - decentralized and the more secure it
81:22 - becomes so after you watch this video
81:24 - and you become a blockchain engineering
81:26 - expert i definitely recommend you run a
81:27 - note as well because you are going to
81:29 - increase the security of the network as
81:31 - a whole by running a node so proof of
81:33 - work is fantastic because it allows us
81:35 - to very easily protect against these
81:37 - civil attacks and keep our blockchains
81:39 - decentralized and secure
81:41 - however it has some drawbacks as well
81:43 - proof of work costs a lot of electricity
81:45 - because every single node is running as
81:47 - fast as they can to win this race to get
81:49 - the rewards this leads to obviously an
81:52 - environmental impact now since proof of
81:54 - work and nakamoto consensus a lot of
81:56 - other protocols have taken this idea and
81:58 - gone in a different direction with a
81:59 - different civil resistance protocol a
82:01 - lot of them with the intention to be a
82:03 - lot more environmentally friendly and
82:05 - the most popular one right now is proof
82:07 - of stake there are some chains that are
82:09 - already using this proof-of-stake
82:10 - protocol and that are live and thriving
82:13 - some of them are like avalanche solana
82:15 - polygon polkadot and terra and
82:17 - additionally ethereum has decided to
82:20 - upgrade to eth2 which will have this of
82:23 - stake algorithm as well it'll also have
82:25 - some other features which we'll talk
82:27 - about in a bit now as a quick aside all
82:29 - the tools that we're going to learn here
82:30 - are still going to work in eth2 so
82:33 - depending on when you watch this
82:34 - everything here is still valid so let's
82:36 - talk about proof of stake now again this
82:38 - is a different civil resistance
82:39 - mechanism instead of solving this
82:41 - difficult problem proof of stake nodes
82:43 - put up some collateral that they're
82:45 - going to behave honestly aka they stake
82:48 - in the example of ethereum 2 nodes put
82:51 - up some ethereum as a stake that they're
82:53 - going to behave honestly in the network
82:55 - if they misbehave to the network they
82:57 - are going to be slashed or removed some
82:59 - of their stake
83:00 - obviously this is a very good civil
83:02 - resistance mechanism because if you try
83:04 - to create a whole bunch of anonymous
83:05 - accounts
83:06 - then each one of those accounts you have
83:08 - to put up some stake and if you
83:10 - misbehave you're going to run the risk
83:11 - of losing all the money that you put up
83:13 - as collateral in this system miners are
83:16 - actually called validators because
83:18 - they're no longer binding anything
83:20 - they're actually just validating other
83:21 - nodes now unlike proof of work which
83:23 - every node is racing to be the first one
83:25 - to find the block in proof of stake
83:27 - nodes are actually randomly chosen to
83:29 - propose the new block and then the rest
83:31 - of the validators will validate if that
83:34 - node has proposed the block honestly as
83:36 - we saw with our cryptography lesson it's
83:38 - usually very easy for other nodes to
83:40 - verify if a proposal or a transaction is
83:43 - honest now randomness is a really
83:45 - important topic when we're talking about
83:47 - blockchains because keep in mind these
83:49 - blockchains are deterministic systems
83:51 - they're walled gardens from the rest of
83:52 - the world and as you know a determinic
83:55 - system by definition can't have random
83:58 - numbers so how do we choose the random
84:00 - validators in the system well it changes
84:02 - from blockchain to blockchain and
84:04 - actually choosing the node will change
84:06 - blocks you to blockchain but in eth2
84:08 - they're using what's called randow at
84:10 - least for the original implementation
84:11 - this is a decentralized autonomous
84:13 - organization that collectively chooses
84:15 - the random number and collectively
84:17 - chooses which node is going to run next
84:19 - we aren't going to dive too deep into
84:20 - this because there's a good chance that
84:22 - this might change in the future but we
84:24 - will go into randomness solutions in
84:25 - blockchain later on in this course now
84:27 - proof of stake obviously has some pros
84:29 - and cons as well pros are that again it
84:30 - is a great civil resistance mechanism
84:33 - and a great way to figure out who the
84:34 - author of a block should be the other
84:36 - pros are that it's way less
84:38 - computationally expensive to figure out
84:40 - the new block because instead of every
84:42 - single node on the network trying to do
84:44 - this only one node needs to do this and
84:47 - then the rest of the nodes just need to
84:48 - validate it the cons are that it's
84:50 - usually considered a slightly less
84:52 - decentralized network due to the upfront
84:54 - staking costs it costs to participate
84:56 - now this gets into a little bit of a
84:57 - philosophical battle on how
84:59 - decentralized is decentralized enough
85:01 - and i think that's up to the community
85:03 - to decide and as we progress i think
85:05 - we'll learn more and more about how
85:06 - decentralized is decentralized enough
85:08 - the general consensus amongst blockchain
85:10 - engineers though is that proof of stake
85:12 - is very very decentralized and very
85:14 - secure this massive environmental impact
85:17 - improvement is one of the two main
85:18 - reasons why eath is shifting to eth2 it
85:21 - reduces the environmental impact by up
85:23 - to 99 percent now these are the main
85:25 - pieces of proof of work and proof of
85:27 - stake but i did want to talk about
85:28 - another concept that's really important
85:30 - in these ecosystems and that is
85:32 - scalability when we were talking about
85:34 - gas prices we were saying that the gas
85:36 - prices can get really high if a lot of
85:38 - people want to send a transaction
85:40 - because a block only has so much block
85:42 - space and the nodes can only add so many
85:44 - nodes so when a lot of people want to
85:46 - use a blockchain the gas price
85:49 - skyrockets
85:50 - this is not very scalable because if we
85:53 - want to add more and more people to
85:54 - these blockchains it's going to cost
85:56 - more and more to use the blockchains
85:58 - because more people are going to want to
86:00 - get into these blocks this means that
86:01 - there's kind of a ceiling to how many
86:02 - people can use the system because of the
86:04 - financial constraints that will get
86:06 - imposed as gas prices keep rising
86:08 - ethereum 2 is not only attacking the
86:10 - environmental impact of proof of work by
86:12 - switching to proof of stake but they are
86:14 - also implementing this new methodology
86:16 - called sharding and sharding is a
86:18 - solution to this scalability problem a
86:21 - sharded blockchain really just means
86:23 - that it's going to be a blockchain of
86:25 - blockchains there is a main chain that's
86:27 - going to coordinate everything amongst
86:29 - several chains that hook into this main
86:32 - chain this means that there's more
86:34 - chains for people to make transactions
86:36 - on effectively increasing the amount of
86:38 - block space that there is sharding can
86:40 - greatly increase the number of
86:42 - transactions on a blockchain layer 1.
86:44 - now there's another term that might be
86:46 - the first time you heard it a layer 1.
86:48 - we're going to talk about layer ones and
86:50 - layer twos in terms of scalability
86:51 - really quickly as well a layer one
86:54 - refers to any base layer blockchain
86:56 - implementation bitcoin's a layer one
86:58 - ethereum's a layer one avalanche is a
87:01 - layer one these are the base layer block
87:03 - chain solutions a layer two is any
87:06 - application that is added on top of a
87:09 - layer one added on top of a block chain
87:11 - some examples of layer twos are going to
87:13 - be chain link arbitrarily or optimism
87:16 - arbitrary and optimism are very
87:18 - interesting because they are layer twos
87:19 - that also look to solve this scalability
87:22 - issue arbitrary and optimism are what's
87:24 - known as roll-ups and they
87:26 - roll up their transactions into a layer
87:29 - one like ethereum we're not going to go
87:30 - too deep into rollups and how they
87:32 - actually work but all you really need to
87:34 - know is that a rollup is kind of like a
87:37 - sharded chain they derive their security
87:39 - from the base layer from the layer one
87:41 - like ethereum and they bulk send their
87:43 - transactions onto the layer one they
87:45 - solve some of the scalability issues by
87:46 - being another blockchain that people can
87:48 - make transactions on still on kind of
87:50 - this base ethereum layer
87:53 - now they're different from side chains
87:55 - because side chains derive their
87:56 - security from their own protocols roll
87:59 - ups derive their security from the base
88:01 - layers so arbitrary optimism for example
88:03 - is going to be just about as secure as
88:05 - ethereum there's some fantastic guys in
88:07 - there that go a little bit deeper into
88:08 - rollups and i've left a link in the
88:10 - description for you all right so we just
88:12 - talked about a lot of stuff so let's do
88:15 - a quick recap before moving on ethereum
88:17 - and bitcoin are currently both
88:18 - proof-of-work blockchains that follow
88:21 - nakamoto consensus however ethereum is
88:23 - moving to ethereum two which will be a
88:25 - proof-of-stake sharded blockchain civil
88:27 - attacks are prevented due to protocols
88:29 - like proof of work and proof of stake 51
88:32 - attacks grow increasingly harder with
88:34 - the size of blockchain so you should run
88:36 - a node consensus is the mechanism that
88:39 - allows a blockchain to agree upon what
88:41 - the state of the blockchain is sharding
88:43 - and rollups are solutions to scalability
88:46 - issues on layer ones
88:48 - a layer one is any base blockchain
88:50 - implementation like bitcoin or ethereum
88:52 - a blockchain scalability problem is that
88:54 - there's not always enough block space
88:56 - for the amount of transactions that want
88:57 - to get in them this leads to very high
89:00 - gas prices and again gas prices are how
89:02 - much it costs to interact with a
89:04 - blockchain
89:05 - so we've learned a ton in this video so
89:08 - far
89:08 - everything that you went over is going
89:10 - to make you 10 times better as a
89:13 - developer because yes being a good
89:15 - developer means you understand the code
89:17 - at a very technical level
89:18 - but if you can understand the overall
89:20 - architecture as well you can make the
89:22 - informed decisions about how to
89:24 - architect your design or how to build
89:26 - your software in however you want to do
89:28 - so so with all that being said it's
89:30 - finally time to jump into some solidity
89:32 - and jump into some code so let's do this
89:38 - now again
89:39 - in the description of this video there
89:41 - is a link to this github repository
89:43 - that's going to be the home base for all
89:46 - the code that we work with in this
89:48 - tutorial we scroll down to this main
89:50 - section this readme there's a table of
89:52 - contents in here
89:54 - we can go to lesson one simple storage
89:57 - and we'll have links helpful tips the
89:59 - itinerary of what we're going to learn
90:01 - and everything else that you need to
90:02 - work with here all the code that we're
90:04 - going to be working with is located in
90:07 - this simple storage link that we can go
90:09 - ahead and click it's in its own
90:11 - different repository we can go ahead and
90:13 - click the file to see all the code that
90:16 - we're going to be working with so let's
90:17 - jump into it additionally back in our
90:20 - full blockchain solidity course right at
90:22 - the top
90:23 - there's this resources for this course
90:25 - section if you have questions engaging
90:28 - in github discussions stack exchange
90:30 - ethereum and stack overflow are going to
90:33 - be great places to get help and get
90:35 - support i highly recommend making a
90:37 - stack overflow
90:39 - stack exchange ethereum
90:42 - and a github account so you can
90:44 - participate and engage with the
90:46 - community
90:49 - welcome to the remix ide or the remix
90:52 - integrated development environment this
90:55 - is going to be where we're starting to
90:57 - teach you how to work with solidity and
90:58 - work with smart contracts and deploy to
91:00 - blockchains we're going to use remix to
91:02 - get us up to speed as it has a lot of
91:04 - nice features that allow us to really
91:06 - see and interact with blockchains and
91:07 - really see what's going on but
91:09 - eventually we're actually going to move
91:10 - off of remix to another platform
91:13 - but all the solidity that we're going to
91:14 - learn here obviously is going to apply
91:16 - everywhere as well when you come to
91:17 - remix there's a whole lot of different
91:19 - plugins like solidity learn eth soul
91:21 - hint linter and a whole bunch of other
91:23 - plugins as well i'm going to go ahead
91:25 - and start by clicking the solidity
91:26 - plugin but we're not going to use any of
91:28 - these plugins for now but later on you
91:30 - can kind of go back and learn a little
91:32 - bit more about what these plugins do so
91:33 - let's start perusing let's start coding
91:36 - some things on the left hand side over
91:38 - here is where we're going to interact
91:40 - with everything so let's go ahead and
91:42 - click the files up here now you can
91:44 - always go back and peruse this a little
91:46 - bit more and in fact i highly encourage
91:48 - you to because that's how you're going
91:49 - to learn the most the quickest but for
91:51 - us we're actually just going to go ahead
91:52 - and start with our own brand new file
91:55 - we're going to create a little
91:56 - application that can store information
91:58 - on the blockchain for us and this is our
92:00 - first project that we're going to do in
92:02 - solidity so we're actually going to
92:04 - create a new file
92:05 - and we're going to call it
92:08 - simple
92:09 - storage dot soul all solidity has an
92:11 - extension of dot soul at the end stands
92:14 - for solidity now let's take inventory of
92:16 - what we're going to be working with here
92:18 - this is the solidity compiler tab
92:20 - it compiles all the solidity code down
92:23 - to machine understandable code or
92:25 - machine language here there's a whole
92:27 - bunch of different parameters we can
92:28 - choose when working with sliding we
92:30 - choose the compiler version we can
92:32 - choose the language which we're only
92:34 - going to be working with solidity the
92:35 - evm version don't worry about this for
92:38 - now so let's code our first solidity
92:41 - contract here
92:42 - now we are going to use something a
92:44 - little bit special here when we actually
92:46 - deploy these we're going to use a
92:48 - javascript virtual machine
92:50 - so we're going to use a virtual machine
92:52 - that's going to simulate actually
92:54 - deploying to a test net or a real
92:56 - network we're not actually going to
92:58 - deploy on a real network we will
93:01 - in a little bit but just to get started
93:03 - we're going to work with a javascript vm
93:05 - which is kind of a fake environment for
93:07 - now okay
93:08 - testing locally and understanding how to
93:10 - test locally will make your
93:12 - coding experience a lot faster as you
93:15 - saw when we sent some transactions some
93:17 - of them actually took some a lot of time
93:19 - to actually deploy we don't want to have
93:21 - to spend that much time waiting around
93:23 - for our tests to actually finish so
93:25 - we're going to use a javascript vm to
93:27 - kind of dummy it for now but let's just
93:29 - start coding and go from there
93:31 - so the first thing that you're going to
93:33 - need in any solidity program is the
93:36 - solidity version so that's always going
93:38 - to be at the top of your solidity code
93:41 - it's defined by doing pragma solidity
93:44 - and the version
93:45 - we're going to be using some version
93:47 - between
93:50 - 0.6.0
93:53 - and 0.9.0
93:56 - so we're saying we want to use anything
93:58 - between 0.6
94:00 - and 0.9 and and as a force of habit i
94:02 - just automatically hit command s
94:04 - whenever i write anything so that's why
94:06 - you saw some of this pop up here we can
94:08 - hitting command s or control s depending
94:10 - on if your windows or not we'll hit this
94:12 - compile button and we'll compile
94:14 - everything for us
94:15 - now if we want a specific version of
94:17 - solidity we can also do 0.6.0
94:20 - and if i go ahead and hit command s or
94:22 - compile
94:27 - our compiler will automatically convert
94:29 - to 0.6.0
94:31 - however if i try to do 0.8.0 with my
94:34 - solidity at 0.6.0 it's going to give us
94:36 - an error it's going to say the source
94:38 - file requires a different compiler
94:39 - version
94:40 - we're using 0.8.0 and this is 0.6.0 so
94:45 - we're going to go ahead and hit compile
94:46 - and it's going to automatically move
94:47 - down to 0.6.0
94:49 - we can also
94:51 - do carrot 0.6.0
94:53 - and this will allow us to work with
94:55 - really any version of 0.6
94:58 - it'll work all the way up to 0.7 where
95:01 - if we hit command s or control s there
95:03 - it'll give us an error so this only
95:05 - works with any version below 0.7 and
95:08 - above 0.6 we're going to be using
95:11 - version
95:12 - 0.6.6 however in future contracts that
95:14 - we work with we're actually going to
95:15 - work with different versions of solidity
95:18 - the reason we're going to be changing
95:19 - versions throughout this course is that
95:21 - solidity is a constantly updating
95:22 - language being good at switching between
95:25 - versions is going to make you an
95:26 - incredibly powerful smart contract
95:28 - engineer the next thing that we're going
95:30 - to do is we're going to define our
95:31 - contract
95:33 - so contract is a keyword in solidity
95:36 - which stands for our smart contract that
95:38 - we're going to create you can think of a
95:39 - contract similar to a class in java or
95:42 - any other object-oriented programming
95:44 - language so we're going to give our
95:45 - contract a name here we're going to call
95:47 - it simple storage
95:52 - and we're going to add this little curly
95:53 - bracket to say this
95:55 - is the contents of our contract simple
95:57 - storage
95:58 - and i went ahead and hit command s and
96:00 - we can see it is compiling successfully
96:03 - you could hypothetically deploy this
96:04 - right now and this would be a valid
96:06 - contract so great job for making it this
96:08 - far now in solidity there are many
96:10 - different types that we can work with
96:12 - let's go into some of the types of
96:13 - solidity we can have integers aka whole
96:17 - numbers they can be uint as in an
96:20 - unsigned integer meaning they're not
96:22 - positive or negative we can also have an
96:24 - int
96:25 - and we would define a variable by doing
96:28 - you in 256 favorite number
96:32 - equals 5.
96:34 - so we have
96:35 - an unsigned integer you went 256 means
96:38 - this is an integer of size 256 bits
96:43 - so we can have this be upped this number
96:45 - be up to 256. you can also do uint
96:48 - favorite number equals 5 but if you want
96:51 - to be a little bit more precise a lot of
96:53 - protocols and a lot of smart contracts
96:54 - will do the whole name like you and 256.
96:58 - we can also have
96:59 - booleans booleans are true false so we
97:02 - can have boolean
97:04 - favorite bool
97:07 - equals
97:08 - true so this favorite bool would be true
97:11 - it could also be
97:12 - false
97:14 - we can have strings
97:16 - string
97:18 - favorite
97:20 - string
97:21 - equals
97:24 - string
97:25 - a string is a string of text here right
97:28 - it's going to be some word or phrase or
97:30 - really any of these keystrokes here
97:32 - similar to the unsigned integer we can
97:34 - have an int
97:36 - 256
97:38 - favorite
97:39 - int
97:40 - equals negative 5
97:42 - so it could be positive or negative we
97:44 - can have an address
97:47 - which is going to be some type of
97:50 - ethereum address
97:52 - so we could do address
97:54 - favorite address
97:57 - equals
97:59 - and then we can even copy right from our
98:00 - metamask
98:02 - and just paste it right in here
98:05 - this is going to be a valid address here
98:07 - you'll also notice that we end all of
98:10 - our statements with a semicolon
98:12 - we can have a bytes object
98:14 - size 32 bits
98:16 - favorite bytes
98:18 - for our example
98:19 - we're just going to use the word cat
98:21 - because cat is a string which can be
98:24 - converted down into a bytes object by 32
98:27 - means that there's 32 bytes in this
98:29 - variable favored bytes we can also do
98:31 - bytes 2 bytes 3 bytes 5 etc with the
98:35 - maximum size of bytes 32
98:37 - for example we can't do bytes 64. we're
98:41 - going to be talking about some other
98:42 - variables as well like arrays and
98:43 - mappings but let's just stick here for
98:45 - now if you want to learn more about the
98:47 - different types and the different
98:48 - variables that you can use head over to
98:50 - the solidity documentation and there's a
98:52 - link in the github and the description
98:54 - to show you this section for now for our
98:57 - simple storage let's say we only want to
98:59 - store numbers we don't want to store
99:00 - anything else
99:02 - so we're just going to go ahead and
99:03 - delete everything and just have uint256
99:06 - favorite number
99:07 - at the top now in solidity if i do this
99:11 - favorite number actually does get
99:13 - initialized even though i didn't have it
99:15 - initialized to 5. if i leave it blank it
99:18 - gets initialized to the null value in
99:20 - this case it would be initialized to 0.
99:23 - so for now let's just not initialize it
99:25 - to anything that way it'll get
99:26 - automatically initialized to zero this
99:29 - means that when we deploy this contract
99:30 - as of right now favorite number will
99:33 - start off as zero if you get confused
99:36 - you can also make a comment on this you
99:38 - could say
99:39 - this will get initialized to zero
99:43 - this double slash here is the way to
99:45 - make comments in solidity and it won't
99:48 - get executed as code so we can write
99:50 - whatever we want as long as it's
99:52 - preceded by two backslashes
99:55 - now let's go ahead and create our first
99:58 - function
99:58 - functions or methods are self-contained
100:01 - modules that will execute some task for
100:04 - us and in solidity it's the exact same
100:06 - thing they're defined
100:08 - by the keyword function
100:10 - let's make a function called store
100:13 - that will change the value of this
100:16 - favorite number here
100:18 - so we're going to call store and we're
100:20 - going to allow it to be past a variable
100:22 - so we're going to allow it to be passed
100:24 - a variable of type unsigned integer 256
100:28 - and we're going to call it underscore
100:30 - fave
100:31 - or it
100:34 - number we're going to make this a public
100:37 - function which we'll get to in a minute
100:39 - and all we're going to do
100:41 - is we're going to set
100:42 - favorite number
100:44 - equals to whatever variable we passed in
100:47 - favorite number so this in its simplest
100:50 - form is how you can define a function
100:53 - now just to visualize what we're working
100:54 - on so far let's go ahead and deploy this
100:57 - contract so we can actually start to
100:59 - interact with it so if we hit this
101:01 - button this will bring us to the deploy
101:03 - tab and will allow us to deploy our
101:05 - smart contract here
101:07 - using our javascript vm it's given us a
101:10 - fake account with some ethereum in it it
101:12 - has 100 ethereum in it to start and same
101:15 - as before anytime we want to interact
101:17 - with the blockchain we have to pay a
101:19 - little bit of gas even in our fake
101:21 - virtual machine here and we want to
101:22 - simulate that so you'll see it has some
101:24 - of the same parameters here as making a
101:27 - transaction like gas limit for example
101:29 - when we deploy a contract it's going to
101:32 - cost a little bit of ethereum or a
101:33 - little bit of gas to do so
101:35 - so let's go ahead and hit this deploy
101:37 - button and see what happens so once we
101:40 - deployed with this virtual machine a few
101:42 - things happened
101:44 - we have
101:45 - remix kicking out this section down here
101:47 - saying great job you've deployed
101:48 - something and if we scroll down it says
101:51 - transactionsrecorded1 we can look at all
101:53 - the transactions we've recorded
101:55 - and we can see it says deployed
101:57 - contracts and we have a contract here
102:00 - that we've deployed now let's zoom out
102:02 - just a hair here so we can see
102:03 - everything a little bit better in this
102:05 - simple storage contract we see this big
102:07 - store button because there's one public
102:09 - function that we can actually interact
102:11 - with so we can add
102:13 - this number here and we'll hit store and
102:15 - you'll see again we have a completed
102:17 - transaction
102:18 - and if we look at our contract
102:20 - we'll have paid a little bit more gas
102:22 - right we'll have paid a little bit more
102:24 - to interact with this function because
102:25 - again anytime we want to make a state
102:28 - change in the blockchain we have to pay
102:30 - a little bit of gas the reason metamask
102:32 - isn't popping up is because we're kind
102:34 - of doing it in this simulated
102:35 - environment so this is great however it
102:38 - looks like we can't actually see
102:40 - what our favorite number is we can't
102:42 - actually look at it so how do we
102:44 - actually make sure that we can view this
102:46 - favorite number well let's add another
102:49 - parameter to this as well
102:51 - if we add public
102:53 - to our favorite
102:54 - number we recompile by hitting command s
102:58 - or hit the compile button
103:00 - we delete this contract and we redeploy
103:03 - and scroll down
103:05 - now we'll see two buttons pop up
103:08 - this blue button to show us favorite
103:10 - number which again is initialized to
103:12 - zero
103:13 - and we have the store function
103:15 - so let's talk a little bit about why
103:17 - this public variable allowed us to see
103:19 - this new button this new favorite number
103:21 - button this public keyword defines the
103:25 - visibility of the variable or the
103:27 - function there are currently four
103:28 - different types of what's called
103:30 - visibility in solidity there's external
103:33 - public
103:34 - internal and private we're mostly going
103:37 - to be working with public for now but
103:40 - it's important to know how the rest of
103:41 - these work public functions can be
103:43 - called by anybody including variables
103:47 - so oddly enough variables are a function
103:50 - call to just look at them and return
103:53 - whatever that variable is an external
103:55 - function means it can't be called
103:58 - by the same contract it has to be called
104:01 - by an external contract so if in this
104:03 - contract
104:05 - i had this be external
104:07 - i couldn't call
104:09 - the store function
104:11 - i couldn't call the store function
104:12 - inside this function
104:14 - because the function is external it
104:16 - means somebody outside of the contract
104:18 - has to call this function internal
104:20 - functions however can only be called by
104:23 - other functions inside of this contract
104:26 - or in its derived contract
104:28 - and then private is the most restrictive
104:30 - as private functions and state variables
104:33 - are only visible for the contract they
104:34 - are defined in and not derived contracts
104:37 - now the reason that we didn't see
104:39 - favorite numbers show up in our original
104:41 - contract deployment is that if we don't
104:43 - give a state variable a visibility it
104:46 - will automatically get set to internal
104:49 - so if we want other people to be able to
104:51 - read it we have to change it to public
104:54 - now let's see how this interaction
104:55 - actually works
104:56 - if we hit the favorite number button
104:58 - right now we'll get this call thing that
105:00 - shows up and it'll show us right here
105:02 - that
105:03 - the value of
105:05 - favorite number is zero
105:07 - now this function however is set so that
105:10 - whatever value we pass it is going to
105:12 - change the favorite number to whatever
105:14 - we pass it as so if we pass one two
105:16 - three hit store
105:18 - that transaction goes through
105:20 - and then hit favorite number we can see
105:23 - the value is now one two three
105:25 - now i will also be using transactions
105:27 - and smart contract interactions and
105:29 - function calls a little bit
105:31 - interchangeably that's because on a
105:33 - blockchain whenever you call a function
105:35 - or whenever you make some state change
105:37 - to the blockchain you're actually also
105:39 - making a transaction that's what makes
105:42 - this whole thing so powerful and again
105:44 - that's why making a function call or
105:46 - deploying a contract costs a little bit
105:48 - of gas now the reason we can access this
105:51 - favorite number variable inside this
105:53 - function
105:54 - is because favorite number has this
105:56 - global or contract scope so even if we
105:59 - made union 256 tests equals 4 or
106:03 - equals equals 4 we wouldn't be able to
106:06 - use this variable outside of this
106:07 - function
106:09 - right because it's self-contained it's
106:10 - self-contained inside this bracket
106:13 - and
106:14 - if i were to make another function
106:18 - store two perhaps
106:20 - public
106:26 - 2 doesn't know that this test variable
106:28 - exists
106:29 - functions only know about the variables
106:31 - that are in the same scope as them so
106:33 - favorite number is in this global scope
106:35 - because the only bracket that's above
106:37 - them is simple storage and test is in
106:39 - this store scope because it has two
106:41 - brackets above it it has it's inside of
106:43 - the store function and inside of this
106:45 - contract simple storage
106:47 - store two isn't inside of this store
106:50 - function or this store scope so it can't
106:53 - access this test variable
106:56 - so let's go ahead and make this back to
106:57 - public
106:59 - and we'll compile again i'm hitting
107:00 - command s to compile but you can go
107:02 - ahead and click the button if you like
107:03 - and let's get rid of this now as you saw
107:05 - when we deploy this
107:07 - there's this button here that we can
107:08 - click called favorite number we can also
107:11 - make a function called
107:13 - retrieve and make it a public function
107:16 - that is of type view
107:19 - and returns
107:20 - uint256
107:23 - and all this is going to do
107:24 - is return
107:27 - favorite number so we're going to talk
107:29 - about views and returns here
107:32 - so i'm going to go ahead and compile
107:34 - i'm going to go ahead and delete delete
107:36 - this contract i'm gonna go ahead and
107:38 - deploy it now
107:40 - and we can see
107:41 - now we have
107:43 - two functions or two blue buttons here
107:45 - we have retrieve and we have favorite
107:47 - number
107:48 - if i change favorite number by calling
107:50 - the store function favorite number and
107:53 - retrieve will both now say it's one two
107:55 - three
107:57 - so then the question might be well why
107:59 - is this one orange and these two are
108:01 - blue
108:03 - and the key relies in this view function
108:06 - or this view keyword there's two special
108:08 - keywords that define functions that you
108:10 - actually don't have to make a
108:12 - transaction on
108:13 - and those keywords are view
108:15 - and pure
108:17 - a view function
108:18 - means that we want to read some state
108:20 - off the blockchain so we're just reading
108:22 - off the blockchain if we're reading off
108:24 - the blockchain and we're not actually
108:26 - making a state change then we don't need
108:28 - to make a transaction
108:29 - these blue buttons are blue because they
108:32 - are view functions public variables also
108:35 - have view functions that's why both of
108:37 - these are blue
108:39 - this technically is a view function and
108:41 - when i click it i get to view and i get
108:43 - to read the state off the blockchain
108:46 - retrieve is the same way we could have
108:49 - this without a return but it wouldn't do
108:51 - anything pure functions are functions
108:53 - that purely do some type of math we'd
108:56 - have you in 256 favorite number public
108:59 - pure and just have favorite number plus
109:01 - favorite number
109:02 - so we're doing some type of math here
109:05 - but we're not actually saving state
109:07 - anywhere
109:08 - we're going to do this math but we're
109:10 - not going to save this favorite number
109:12 - anywhere we're not going to save
109:13 - anything deploy this now this pure
109:16 - function
109:18 - we would have this retrieve function one
109:20 - two three it's blue as well because it's
109:24 - again not going to change the state of
109:26 - the blockchain so view functions and
109:28 - pure functions are both can have this
109:29 - blue color
109:32 - now the reason that nothing shows up at
109:34 - the bottom is because we didn't return
109:36 - anything
109:37 - all we're doing is we're saying add
109:39 - these two numbers together and that's it
109:42 - in order for this function to give us
109:44 - something back we need to have it return
109:46 - something so if we go back
109:51 - to this retrieve
109:54 - to this retrieve function we have to
109:56 - define what we're going to return when
109:58 - we're defining this function so we're
110:00 - going to say this is a public function
110:01 - it's a view function because we're going
110:03 - to read some state and it's going to
110:05 - return a unit 256.
110:08 - so favorite number is of u 256 so that's
110:11 - what we're going to return
110:12 - our public variable favorite name is
110:15 - also a view function that returns a
110:16 - un256
110:18 - for now let's just remove that so we can
110:20 - work with this retrieve function
110:22 - so let's go ahead and deploy
110:24 - so now we see we don't have this
110:25 - favorite number button anymore because
110:27 - it is no longer a public function
110:30 - because again it gets initialized to
110:32 - internal so we can't actually view it
110:34 - now keep in mind later on we're going to
110:36 - talk about how everything on chain you
110:38 - actually can see
110:39 - and we'll talk about that a little bit
110:41 - later though so retrieve is going to do
110:43 - 0
110:44 - we can call store
110:46 - and now retrieve is going to be 1 2 3.
110:48 - now this application is great so far it
110:50 - allows a single person to store a
110:52 - favorite number and then go ahead and
110:54 - retrieve it
110:55 - later which is fantastic but what if we
110:57 - want a list of people or a group of
111:00 - people
111:01 - and store their favorite numbers or what
111:03 - if we want to associate a favorite
111:05 - number with a single person well what
111:07 - can we actually do now we have a whole
111:09 - number of different choices but the one
111:10 - that we're going to talk about is using
111:12 - a struct structs are ways to define new
111:15 - types and solidity they're almost like
111:17 - creating new objects as well
111:20 - so we can create a struct
111:22 - called type people
111:24 - and allow it to start storing a favorite
111:27 - number associated with a certain people
111:29 - so inside of our struct we can have
111:32 - different types as well
111:33 - so we have a uin256
111:36 - favorite number
111:37 - and we could also have a string
111:40 - name
111:41 - now we have a new type of type people
111:44 - that has a favorite number and a name
111:47 - inside of it now what we could do
111:49 - with destruct is we could say
111:53 - people
111:54 - public
111:56 - person
111:57 - equals
111:59 - equals people
112:01 - and then inside we add the variables so
112:04 - we could say
112:06 - favorite number
112:07 - favorite number is
112:09 - 2
112:11 - and name
112:12 - is
112:14 - patrick
112:16 - and of course the semicolon at the end
112:19 - and again i'm hitting command s to save
112:21 - but you can also go ahead and compile
112:24 - in the compile tab
112:25 - so let's go ahead and delete this
112:27 - contract and see what this looks like
112:28 - now
112:30 - so now we've deployed this new contract
112:32 - and we have this person struct which at
112:35 - the zero index
112:37 - is the favorite number and the variable
112:39 - stored in the first index is going to be
112:42 - the name storing variables and solidity
112:44 - always works in this numeric index
112:46 - fashion in fact in contract simple
112:49 - storage uint 256 favorite number is at
112:52 - index 0. if we were to add another
112:55 - object here like
112:56 - boolean favorite bool
112:59 - this would be at index one
113:01 - if we were to add bool
113:03 - favorite
113:04 - bool2 this would be at index
113:07 - two zero
113:09 - one
113:10 - two
113:11 - and it works the same in structs this is
113:13 - at index zero inside the struct this is
113:15 - at index one inside the struct
113:18 - so we can see the variables associated
113:20 - with this person we're gonna go ahead
113:21 - and delete this for now because
113:23 - instead of just creating one person we
113:25 - actually want to create a whole list of
113:27 - people so how do we create a list of
113:29 - people let's delete that contract
113:31 - and what we can do is we can make what's
113:33 - called an array an array is a way of
113:36 - storing a list or a group of some object
113:40 - so as you're starting to see the way the
113:41 - syntax works for defining any type of
113:44 - variable is going to be the type of the
113:46 - variable
113:48 - the visibility of the variable like
113:50 - public or if you don't declare it it
113:51 - gets initialized to internal
113:55 - and then the name of the variable
113:57 - it works the same with arrays so we'll
113:59 - make a people array the people array
114:02 - is the type
114:05 - we'll make it public
114:06 - and we'll call it people
114:09 - now if we deploy this contract
114:11 - we go and see we now have a people array
114:15 - but if we click this button
114:17 - you'll see that
114:18 - nothing shows up
114:19 - the reason is because it's an empty
114:21 - array to start with right we don't have
114:23 - anything inside of it
114:25 - now this type of array that we've
114:26 - created is what's known as a dynamic
114:28 - array it's a dynamic array because it
114:31 - can change its size right now it's a
114:33 - size 0 and if we added something to it
114:35 - it's of size one you can also create
114:38 - arrays of a fixed size so if i were to
114:40 - do people one public people this array
114:44 - could only have a maximum of one person
114:47 - inside of it
114:48 - so we're going to work with a dynamic
114:49 - array though because we want to add an
114:52 - arbitrary number of people into here so
114:54 - let's go ahead and create a new function
114:55 - called add person where we can add a
114:57 - person to this array
114:59 - so we'll do function
115:01 - add person
115:04 - string
115:06 - memory name i'll talk about this memory
115:08 - keyword in a minute
115:10 - uin256
115:12 - favorite
115:13 - number
115:18 - and then we'll make this a
115:20 - public function
115:25 - and inside we'll do we'll add this
115:27 - person to our array the way to add a
115:29 - person to your arrays is using the push
115:33 - method
115:34 - so we're going to push
115:36 - a new people or a new person
115:39 - and we're going to give it
115:40 - those variables again
115:42 - so we're going to give it so we're going
115:43 - to give it favorite number
115:46 - is this variable that we passed in here
115:49 - oops this needs a bracket
115:52 - and then we're going to give
115:55 - the name
115:57 - going to be this underscore name
116:00 - and then end bracket
116:03 - oops
116:05 - zoom out again here just so i can see
116:07 - stuff
116:09 - this needs a semicolon
116:11 - and perfect
116:13 - now in that last clip we saw this little
116:15 - red box pop up whenever a little red box
116:17 - like this pops up after you compile it
116:19 - means you have a compile error this
116:22 - means that there's something wrong with
116:23 - your solidity code or your salinity
116:25 - syntax and it won't compile and deploy
116:27 - properly red is going to be this compile
116:29 - error now we're going to see a bunch of
116:31 - yellow warnings in the future if you get
116:34 - a little yellow pop-up these are okay to
116:36 - ignore but they usually have some
116:38 - helpful tips about something that might
116:40 - be going wrong in your code so to
116:41 - summarize if it's red if it's red it's
116:44 - broken if it's yellow you might want to
116:46 - check it out but it could be okay so we
116:47 - can see we have our new function add
116:49 - person
116:50 - where we pass a string memory name and a
116:53 - unit 256 favorite number and then we
116:56 - create
116:57 - this people person
116:59 - this people object here and then we push
117:01 - it
117:02 - onto our people array
117:04 - and i'm going to show you another way we
117:06 - can actually create a people person
117:08 - is just by passing
117:10 - favorite number and name
117:13 - and getting rid of this other bracket by
117:16 - passing favorite number and name
117:18 - because we know
117:19 - that
117:20 - the zeroth index of people is favorite
117:21 - number and the first index of people is
117:24 - name so we can also create a new person
117:26 - by adding it like this now let's talk
117:28 - about this memory keyword here now in
117:30 - solidity there's more or less two ways
117:33 - to store information you can store it in
117:35 - memory
117:36 - or in storage
117:38 - when you store an object in memory it
117:41 - actually means that it'll only be stored
117:43 - during execution of the function or of
117:46 - the contract call
117:47 - if we hold it in storage
117:50 - that means that that data will persist
117:52 - even after the function executes a
117:54 - string in solidity is actually
117:56 - technically not a value type a string is
117:59 - actually an array of bytes a variable of
118:01 - type string is actually a special type
118:03 - of array that we can append text to so
118:07 - because it's technically an object we
118:08 - have to decide where we want to store in
118:10 - memory or in storage and since we only
118:13 - need this name during the execution we
118:15 - can have it be string memory name and
118:17 - then when we create this new people
118:18 - object we will create a new copy of this
118:22 - name variable into storage memory means
118:24 - that after execution delete this
118:26 - variable and storage means keep it
118:28 - forever if this is a little bit
118:30 - confusing for you just know that for now
118:32 - when you use a parameter that's going to
118:34 - be a string for one of your functions
118:36 - you need to call it string memory so
118:38 - let's go ahead and deploy this contract
118:40 - and see what happens now
118:42 - now we have this new function add person
118:46 - and since we are making a state change
118:48 - here we can see that this indeed
118:50 - is a orange button instead of being a
118:53 - blue button so we can add in here a
118:55 - string name we'll add
118:57 - patrick and we'll say his favorite
118:59 - number is 2.
119:01 - again right now if we look at people
119:03 - we see people 0 there's nothing in here
119:05 - if we retrieve there's nothing in here
119:07 - so we're going to add person patrick and
119:10 - now if we hit people of 0 we can see
119:13 - that the person at the zerowith index in
119:15 - this people array
119:16 - is going to be
119:18 - string patrick
119:19 - if we try at one there's nothing in here
119:22 - let's add another person
119:24 - we'll add
119:25 - becca and her favorite number will be
119:27 - 24.
119:28 - let's add her now if we hit one we see
119:31 - favorite number 24 string name is becca
119:34 - and retrieve is so showing up blank
119:36 - because we haven't touched favorite
119:38 - number awesome this is great we can just
119:41 - keep adding people
119:43 - however there is kind of an issue here
119:45 - what if i'm looking for a person what if
119:47 - i'm looking to find
119:48 - becca and find her favorite number in
119:50 - this array
119:52 - what if i know her name but i don't know
119:53 - her favorite number is there an easy way
119:55 - for me to find that favorite number
119:56 - without having to triage the entire
119:59 - array there's another data structure
120:00 - called a mapping so let's create this
120:03 - new data structure
120:04 - so this data structure is going to be of
120:06 - type
120:07 - mapping a mapping takes some type of key
120:09 - and spits out whatever variable it's
120:10 - mapped to so in this case if we're
120:13 - saying we want to use the name becca to
120:15 - find her favorite number we would say
120:17 - the string becca
120:20 - is going to be mapped
120:21 - to the uint 256 favorite number and
120:25 - similar to
120:26 - all the other variable declarations the
120:29 - first part is going to be the typing so
120:31 - this is going to be a type mapping of
120:34 - string
120:35 - mapped to un256
120:37 - we're going to give this public
120:38 - visibility and we'll call it
120:40 - name
120:41 - to favorite number and without adding
120:44 - any other functions that work with it if
120:46 - we deploy this we can see we have this
120:49 - blue button because we're not making a
120:50 - state change name to favorite number and
120:53 - if we type in becca in here
120:56 - obviously nothing's going to happen
120:58 - because we haven't added this
121:00 - mapping in yet
121:01 - so in our ad person down here let's even
121:04 - have this ad person also add to the
121:07 - mapping so we can do name
121:09 - to favorite number
121:13 - and then the key is going to be this
121:15 - name so of becca we're going to say
121:17 - we're going to map the name becca
121:20 - to
121:21 - the favorite number
121:23 - now we're going to go ahead and compile
121:25 - again i'm hitting command s
121:27 - deploy
121:28 - we can scroll down here
121:30 - if we look up backhand here
121:32 - we're going to get nothing
121:34 - however
121:35 - if we add
121:37 - becca
121:40 - and her favorite number being 24
121:44 - this add person is going to add it both
121:46 - to the array
121:47 - and to this mapping now if we look up
121:50 - name to favorite number we see that
121:52 - becca returns 24. now one other thing i
121:54 - want to show you guys just because
121:56 - compilers are going to yell you if you
121:58 - don't have them is typically at the top
122:00 - of these contracts you want to add an
122:02 - spx license identifier basically
122:05 - solidity and the ethereum community
122:07 - found out that
122:08 - trust in a smart contract can be better
122:09 - established if source code is available
122:12 - and
122:12 - in terms of legality and copyright it
122:15 - just makes life a lot easier if you add
122:17 - that license identifier right at the top
122:19 - of your solidity we're going to use the
122:21 - mit license identifier because it's the
122:24 - most open license out there it means hey
122:26 - anybody can use this code and we don't
122:28 - care so you'll see a majority of
122:30 - salinity contracts have this spx license
122:32 - identifier mit at the top and compilers
122:36 - will yell you a lot less awesome we now
122:38 - have a contract that we've decided that
122:40 - we liked it's got mappings it enables us
122:43 - to actually store people and their
122:44 - favorite numbers this is fantastic we've
122:46 - done all of our testing in this
122:48 - javascript vm and we've decided you know
122:51 - what we want to deploy this to an actual
122:53 - test net or an actual mainnet how do we
122:56 - actually deploy this so that other
122:58 - people can interact with this contract
123:00 - we are again going to use rink b because
123:02 - that's what we use to make our first
123:03 - transaction
123:04 - now again you will need some type of
123:07 - test ethereum in your test and wallet so
123:10 - again if you get lost
123:12 - you can always just google rink b
123:15 - faucet
123:16 - or ring b test net faucet
123:18 - and find a faucet or a better
123:20 - alternative would be to come to the link
123:22 - token contracts in the chain link
123:24 - documentation at
123:26 - docs.chain.link and
123:28 - scroll down or just look up rink b this
123:31 - linked token contracts page has the most
123:33 - up-to-date faucets for any test net that
123:36 - it supports so for example we get a test
123:39 - and eth faucet right here which also
123:41 - just happens to be that exact faucet
123:43 - that we used earlier the only thing you
123:45 - need to change
123:46 - in remix is we need to change from
123:49 - javascript vm to injected web3
123:53 - and metamask will actually pop up and
123:54 - say hey would you like to connect to
123:57 - this application
123:58 - anytime you're working with a web3
124:00 - application or a web application that
124:02 - wants to access your funds or work with
124:04 - your metamask metamask will pop up and
124:07 - ask for authorization first this is
124:09 - really good so that we know which
124:10 - applications we're actually connected to
124:13 - so we're going to go ahead and say next
124:15 - connect and we can see here
124:17 - that we've even connected here and that
124:20 - our account on the main network
124:22 - has zero eth
124:24 - and remix even tells us hey you're on
124:26 - the main network so let's go ahead and
124:28 - switch
124:30 - to the rink b network
124:31 - and we can now see
124:33 - we're on the rink b network and we have
124:35 - 17.74 eth on this ring b test network
124:39 - injected web 3 means we're taking our
124:42 - meta mask and injecting it into the
124:45 - source code of the browser here and
124:48 - that's the difference between injected
124:49 - web 3 and javascript vm web web3
124:51 - provider is if we want to use our own
124:53 - blockchain node or our own web3 provider
124:57 - when we do injected web3 we're saying
124:58 - our web3 provider is our metamask which
125:01 - will work perfectly for what we're
125:02 - trying to do so since we already have
125:04 - some tests on ethereum let's go ahead
125:06 - and deploy this and see what this would
125:07 - actually look like if we deployed to a
125:09 - mainnet the process is going to be
125:11 - exactly the same right the only
125:13 - difference was we would be on the main
125:15 - net instead of rank b so let's go ahead
125:17 - hit deploy we'll uncheck publish
125:18 - published ipfs
125:20 - hit deploy metamask will pop up asking
125:22 - if we want to do this transaction
125:24 - because remember
125:25 - we are deploying a contract we are
125:28 - changing the state of the blockchain so
125:30 - we have to pay a little bit of gas fee
125:31 - for it so we're going to go ahead and
125:33 - hit confirm
125:35 - and we get
125:36 - a link to ring the ether scan similar
125:39 - exactly as we saw before when we made a
125:41 - transaction the difference here
125:44 - is that instead of sending ethereum to
125:46 - somebody we're actually making a
125:48 - transaction on the blockchain to create
125:50 - a contract after a short while it will
125:52 - show up here on etherscan with a success
125:55 - the number of block confirmations which
125:57 - again is the number of blocks appended
126:00 - to the block that included our
126:01 - transaction
126:02 - we see from which is our account here
126:05 - and we see two is this new contract that
126:07 - we just created and we can even click it
126:09 - and we see
126:10 - that
126:11 - there's this unique transaction hash
126:13 - that created a new smart contract and
126:16 - same as working with the vm we have all
126:18 - the exact same functions in here and you
126:20 - can see if i hit retrieve
126:22 - these three functions since they're not
126:24 - making a state change you can just click
126:26 - them and no transactions will be made
126:29 - however what do you think is going to
126:30 - happen if i hit store
126:34 - if you guessed metamask will pop up you
126:35 - guess correctly
126:36 - again we see the familiar pieces here we
126:38 - have a gas price gas limit
126:41 - go ahead and hit confirm
126:43 - we get another transaction here and once
126:46 - this transaction goes through
126:48 - we should be able to call our retrieve
126:49 - function and see a new number
126:52 - if we call it now
126:53 - nothing shows up because our original
126:55 - transaction hasn't succeeded but i bet
126:58 - if we look at it now
127:01 - okay it's still indexing but it looks
127:02 - like it's been included if we hit it now
127:05 - we do indeed see this value here
127:07 - and we can do the same thing with adding
127:09 - a person we'll add becca we'll say her
127:12 - favorite number is 24.
127:14 - metamask will pop up we'll go ahead and
127:16 - confirm the transaction and if i look up
127:19 - becca and the name to favorite string
127:21 - right now it's going to show nothing
127:23 - because our transaction hasn't gone
127:24 - through yet
127:26 - but if we wait a little bit i should
127:28 - probably spell her name right we do see
127:30 - 24.
127:31 - and if we look at the zeroth index we
127:33 - also see becca's been added here as well
127:35 - now all the solidity code that we wrote
127:37 - and when we interacted with this
127:38 - blockchain here
127:40 - all this solidity was compiled down to
127:42 - the evm also known as the ethereum
127:45 - virtual machine
127:46 - a lot of the blockchains out there today
127:48 - are what's called evm compatible
127:51 - and that means that all this solidity
127:53 - and all these functions that we're
127:54 - creating
127:56 - can still compile down to evm and
127:58 - deployed on their blockchain you'll find
128:00 - out a little later when we look to work
128:02 - on a non-ethereum based chain that we
128:04 - can still deploy our solidity smart
128:06 - contracts to these other chains as well
128:08 - but that's a term you'll hear more and
128:10 - more the ethereum virtual machine or ebm
128:13 - now take a break give yourself a high
128:15 - five because you just deployed your
128:17 - first smart contract and you learned the
128:19 - basics the fundamentals of solidity so
128:22 - huge congratulations on how far you've
128:24 - gotten now in our second projects we're
128:26 - going to take the fundamentals a step
128:27 - further and start going into the more of
128:29 - the intricacies of solidity but just as
128:32 - a quick recap the first thing you always
128:34 - got to do in your smart contracts is
128:36 - name the solidity version
128:38 - then you'll have to name your contract a
128:40 - contract in solidity is like a class and
128:42 - defines all the functions and parameters
128:44 - of your contract
128:46 - there's many different types in solidity
128:48 - like unsigned integer 256 boolean and
128:51 - bytes
128:52 - we can create structs in solidity we can
128:55 - create arrays in solidity we can create
128:57 - mappings in solidity we can create
128:59 - functions in solidity
129:01 - view functions don't make a state change
129:03 - memory and storage are two different
129:05 - ways to initialize where a variable is
129:08 - going to be saved
129:09 - all the solidity code that we're working
129:10 - with gets compiled down to the ethereum
129:12 - virtual machine and last but not least
129:14 - congratulations on taking your first
129:16 - step in learning solidity let's move on
129:18 - to the next project
129:22 - all the code tips and links that we're
129:25 - going to be working with can be found in
129:27 - our course repository
129:28 - we can scroll down to lesson two
129:31 - storage factory
129:33 - click it here and we can see all the
129:36 - code we're going to be working with good
129:37 - luck all right so we've done it we've
129:39 - got our first contract out of the way
129:41 - we're understanding some of the basics
129:43 - of solidity now let's move onward let's
129:46 - get a little bit more advanced with what
129:48 - we're going to do
129:49 - with our smart contracts and let's build
129:51 - what's called the factory pattern of
129:53 - smart contracts so we have our simple
129:56 - storage contract here which is great it
129:58 - allows us to store
130:00 - numbers and store favorite numbers
130:02 - associated with different people and
130:04 - this is great what if though i want to
130:06 - have a lot of these simple storage
130:08 - contracts deployed i want to give people
130:10 - the ability to generate and deploy their
130:13 - own lists based off of this contract
130:16 - this is where the factory pattern comes
130:18 - into play so let's go ahead and create a
130:21 - new contract so in this contracts folder
130:24 - i'm going to do new file
130:27 - we're going to call this
130:29 - storage
130:30 - factory
130:31 - dot sol
130:33 - and now we'll have a storage factory.sol
130:37 - now the way that we're going to do this
130:38 - is that you need simple storage and
130:40 - storage factory in the same folder
130:43 - i have both of them in this contracts
130:45 - folder but if you have them outside or
130:47 - in a different folder that's okay just
130:49 - make sure wherever they are they're in
130:51 - the exact same folder so let's figure
130:53 - out how to get a contract to actually
130:55 - deploy another contract we're going to
130:58 - add those basic pieces that we added in
131:00 - that simple storage.sol we'll add the
131:02 - spdx
131:05 - license
131:07 - identifier
131:08 - which will be mit
131:11 - we'll choose our solidity version which
131:13 - will be pragma
131:16 - solidity
131:17 - and we'll say anything in the six range
131:21 - and then we'll create our contract we'll
131:24 - say contract
131:26 - storage
131:27 - factory
131:28 - and we'll create our brackets here and
131:31 - i'm going to do command s or compile
131:33 - whatever you want to do things are
131:35 - looking good here great so how can this
131:38 - contract
131:39 - deploy a simple storage contract well
131:42 - the first thing that we're going to need
131:43 - to do is actually import this simple
131:46 - storage into our storage factory
131:48 - contract
131:49 - we need to import it so that
131:51 - our storage factory contract knows
131:54 - what a simple storage contract even
131:56 - looks like
131:57 - the way that we can import it is by
131:59 - doing the command import and then the
132:01 - file path that the simple storage is
132:03 - located so the file path for this is
132:05 - going to be at dot slash
132:08 - simple
132:09 - storage dot soul
132:12 - this means that simple storage is in the
132:14 - exact same directory as storage factory
132:17 - doing this line is equivalent to copying
132:20 - everything in this contract bit
132:22 - coming over to storage factory and
132:25 - pasting it above
132:28 - you can even save and compile and have
132:30 - two contracts in the same file now
132:32 - what's interesting about having two
132:34 - contracts in the same file is that when
132:36 - you go to deploy
132:37 - you'll actually have a choice of which
132:39 - one you want to deploy and it's the same
132:41 - thing if i do that import statement so
132:44 - if i delete all this
132:46 - and i go back to import dot slash
132:49 - simple storage dot sol in our deploy tab
132:52 - still
132:53 - you'll see that we still have our choice
132:56 - of which contract we actually want to
132:57 - deploy
132:59 - so this is how we actually import a
133:01 - contract or import any type of file that
133:03 - we want so that our contract knows what
133:07 - that contract looks like and can do so
133:09 - if we want this contract to then be able
133:11 - to deploy a simple storage contract
133:14 - we're of course going to have to create
133:15 - a function that can do that
133:18 - so we'll do function
133:20 - we'll call it create
133:22 - simple
133:23 - storage contract
133:25 - we'll make this a public function
133:28 - we'll do our little open and close
133:29 - bracket in here the way we can generate
133:32 - a contract of simple storage type is by
133:35 - using a new keyword so let's create a
133:37 - simple storage variable
133:38 - we'll say a variable of type
133:41 - simple storage contract we'll name this
133:44 - variable
133:45 - simple storage
133:47 - with a lowercase s
133:49 - equals
133:50 - new
133:52 - simple
133:54 - storage
133:58 - what this line is saying is we're saying
134:00 - we're going to create an object
134:02 - of type simple storage contract
134:05 - we're going to name it simple storage
134:07 - with a lowercase s
134:09 - and we're going to say this is going to
134:10 - be a new simple storage contract and
134:13 - we're saying this simple storage
134:14 - contract takes no input parameters of
134:17 - course if we deploy this contract as is
134:20 - by going to our deploy tab
134:22 - choosing the storage factory
134:25 - staying on a javascript vm
134:28 - deploying
134:29 - scrolling down
134:31 - we have this function that doesn't
134:33 - return anything
134:35 - so we're creating new contracts but we
134:37 - can't really read where those contracts
134:39 - are being created we'd have to look on a
134:41 - block explorer like etherscan or
134:43 - something
134:44 - so let's make a way for us to keep track
134:47 - of all the different simple storage
134:48 - contracts that we deploy
134:50 - let's put them in a list or in an array
134:54 - so what we can do
134:55 - is we can say
134:57 - simple storage
135:00 - array
135:01 - of visibility public and we'll call it
135:05 - simple storage
135:07 - array
135:10 - we'll initialize this symbol storage
135:12 - array
135:13 - and every time we deploy we create one
135:16 - of these new simple storage contracts
135:18 - we'll add it to our simple storage array
135:21 - so we'll do simple storage array dot
135:24 - push
135:25 - and we'll push
135:26 - this simple storage variable
135:30 - so again i'm compiling or hitting
135:32 - command s
135:34 - delete that most recent contract
135:37 - we'll choose the storage factory and not
135:39 - the simple storage
135:41 - and we'll hit deploy
135:44 - now if we scroll down to our storage
135:46 - factory
135:47 - we have this blue button which stands
135:49 - for our simple storage array
135:51 - if we try to see what's at index 0 we
135:54 - get an error of course because we
135:56 - haven't added anything to it yet
135:58 - if i click this create simple storage
136:01 - contract
136:02 - orange button here
136:04 - now i've created a transaction that's
136:06 - going to create a new simple storage
136:08 - contract and push it onto our simple
136:11 - storage array
136:13 - now if i try to access the zerowith
136:15 - index or the first index of this array
136:18 - i'm going to get this address here
136:21 - this is the address that this simple
136:23 - storage contract was deployed to so
136:26 - we've successfully deployed
136:28 - a contract
136:29 - to the blockchain from another contract
136:32 - and this of course is really exciting
136:34 - now we can actually do more than just
136:36 - deploy the contracts we can actually
136:38 - deploy contracts from another contract
136:40 - and then call those functions as well
136:43 - so let's create a new function where we
136:45 - call
136:46 - this store
136:49 - function and we'll also create a
136:51 - function where we call the retrieve
136:52 - function from our storage factory so
136:55 - we'll do function
136:57 - storage factory store
136:59 - we're going to shorthand it by saying sf
137:01 - store we'll have it take unit 256
137:05 - simple
137:08 - storage
137:11 - index
137:12 - and a uint256
137:14 - underscore simple
137:17 - storage
137:19 - number
137:20 - we'll make this a public variable as
137:22 - well in our little brackets here
137:24 - and the reason i'm choosing a simple
137:26 - storage index is because we're going to
137:28 - choose which simple storage contract in
137:31 - our list that we want to interact with
137:33 - and then we're also going to pass a
137:35 - simple storage number
137:37 - to call
137:39 - on the store function which of course we
137:41 - need to pass a favorite number to any
137:43 - time that you interact with a contract
137:45 - you need two things
137:47 - you need the address of the contract you
137:49 - want to interact with and you also need
137:52 - the abi for us we figured out that
137:56 - we're going to push and get this address
137:58 - from this simple storage array
138:01 - we can get the abi or the application
138:03 - binary interface from this import
138:06 - we'll explain the application binary
138:08 - interface a little bit more later
138:11 - for now just know that in order for us
138:13 - to interact with this simple storage
138:15 - contract we can just do
138:18 - simple storage
138:21 - and then
138:23 - we'll pass this simple storage the
138:26 - address of that simple storage
138:28 - contract
138:29 - to get the address of that simple
138:30 - storage contract
138:32 - we'll say
138:33 - grab the address
138:36 - inside the simple storage array
138:39 - at index simple storage index this will
138:42 - return that contract that we want to
138:44 - interact with
138:45 - so we could even say
138:49 - simple storage
138:52 - simple
138:54 - storage
138:55 - equals simple storage
138:57 - at that address in the array
139:01 - once we get this contract we can then
139:03 - call
139:04 - any and all of its functions
139:06 - so we could call
139:08 - simple storage
139:10 - dot store
139:14 - this simple storage number
139:16 - now if we compile this
139:18 - we go to our deploy tab deploy the
139:20 - factory
139:22 - hit deploy
139:24 - open this up we can see we have a couple
139:26 - different functions here we of course
139:28 - have our create simple storage function
139:30 - which creates the contract and adds it
139:31 - to our array
139:33 - we now have this sf store
139:35 - which stores
139:37 - a number
139:38 - to one of those contracts on this array
139:42 - and then we have
139:43 - a lens
139:45 - into that simple storage contract
139:47 - so if i create a simple storage contract
139:50 - i can now store
139:53 - on that zerowith contract on that first
139:56 - contract any number that i want like 55.
140:00 - of course i can't really see that 55
140:03 - because we didn't add a retrieve
140:05 - functionality we didn't add a way to
140:08 - actually listen or read or retrieve that
140:10 - favor number that we got
140:12 - so let's add that now so
140:14 - we'll create a new function
140:17 - called
140:18 - sfget and this will take a uint 256
140:23 - simple storage
140:24 - index
140:26 - and as a parameter and we'll choose one
140:30 - of these contracts on this array and
140:33 - return
140:36 - its favorite number
140:37 - calling the retrieve function on that
140:39 - contract
140:42 - so since we're just going to be reading
140:44 - state
140:45 - this can be a public
140:47 - view function
140:48 - that will return
140:50 - a uint256
140:54 - to do this
140:55 - we need to access that contract once
140:57 - again
140:58 - so we'll say simple
141:00 - storage
141:02 - simple storage
141:04 - equals
141:05 - simple storage
141:09 - at that address
141:11 - of
141:12 - simple
141:15 - storage array
141:17 - at index
141:18 - underscore simple
141:21 - storage index
141:25 - and we can return
141:27 - return
141:30 - simple storage
141:33 - dot
141:35 - we call this retrieve function
141:39 - i'm just going to copy paste it so i
141:41 - don't spell it wrong
141:42 - simple storage we'll put the semicolon
141:45 - here too
141:46 - and here
141:49 - now if we compile this go to our deploy
141:52 - tab delete the most recent
141:56 - choose the storage factory and hit
141:58 - deploy
142:00 - we can see we now has have an sfget
142:03 - function
142:05 - so let's go ahead
142:06 - create a simple storage contract we'll
142:08 - store a function on the zeroth contract
142:12 - we'll store 55 as its favorite number
142:15 - and we'll hit that
142:16 - and then for s of get we'll see if we
142:19 - can get
142:21 - the favorite number of the zero with
142:23 - contract
142:24 - and we do indeed get 55.
142:26 - awesome we can actually even refactor
142:29 - this code to be a little bit simpler
142:30 - here
142:31 - we don't need to save
142:34 - this simple storage contract is a
142:36 - variable here we can actually just call
142:38 - retrieve
142:40 - on this whole section here
142:42 - paste retrieve at the end
142:44 - and just
142:46 - return
142:47 - like this
142:50 - the same goes for our sf store
142:54 - we can delete saving it as a variable
142:57 - we can copy this dot store
143:00 - paste it at the end here
143:02 - and delete this as well
143:06 - now we'll compile
143:10 - delete the most recent
143:11 - we'll deploy the storage factory
143:16 - and if we go into it create a simple
143:19 - storage
143:23 - store the number 55
143:26 - see what's at the zeroth index and we do
143:29 - indeed see 55.
143:31 - so
143:32 - this is really cool this is a way for us
143:34 - to actually deploy contracts and
143:36 - interact with contracts from another
143:39 - contract now to deploy a contract we do
143:41 - need all the functionality of that
143:43 - contract
143:44 - imported however to interact with the
143:46 - contract we don't need all of the
143:49 - functionality we'll learn about
143:50 - interfaces in the next lesson which will
143:53 - allow us to actually interact with the
143:54 - contract without having all the
143:57 - functions defined and now i'm going to
143:59 - show you something really cool now i'm
144:01 - going to show you something really cool
144:03 - simple storage has got a lot of really
144:05 - cool functions and maybe i want all
144:07 - these functions inside my storage
144:10 - factory i want my storage factory to be
144:12 - able to create simple storage contracts
144:15 - and i want it to be a simple storage
144:17 - contract itself
144:19 - well what i can do
144:21 - is my storage factory can actually
144:23 - inherit
144:24 - all the functions of simple storage
144:27 - without me having to copy paste all
144:30 - these functions and all these variables
144:32 - over to storage factory what i can do
144:35 - is i can do solidity's version of
144:36 - inheritance
144:38 - i can say contract storage factory
144:41 - is of type
144:44 - simple storage or is of contract simple
144:47 - storage
144:48 - and just by doing this line right here
144:51 - my storage factory contract now will
144:53 - have all of the functions and variables
144:56 - of simple storage so it'll have
144:59 - a store function a retrieve function an
145:03 - add person function
145:05 - a people array a name to favorite number
145:07 - mapping it'll have everything because i
145:10 - will inherit it with this is syntax
145:14 - so if i go to my deploy tab now
145:16 - [Music]
145:17 - let's look at what our last storage
145:19 - factory was
145:21 - all we did to change this was add is
145:23 - simple storage and we can see just the
145:26 - four functions that we originally added
145:28 - if i delete this now
145:34 - if i save and compile the storage
145:36 - factory let's go ahead and deploy
145:39 - storage factory
145:41 - if we open this up now
145:43 - we can see
145:44 - not only do we have all the functions
145:47 - originally defined in our storage
145:49 - factory but we additionally have all the
145:51 - functions from our simple storage and
145:54 - awesome you've completed the second
145:55 - lesson we've learned about some
145:57 - incredibly powerful tools here we've
145:59 - learned how to import entire chunks of
146:02 - code from other files into our files
146:05 - we've learned how to do inheritance
146:07 - we've learned how to deploy contracts
146:09 - from our contract
146:12 - and then we've learned how to interact
146:14 - with different contracts from outside of
146:17 - our contract well done now is a great
146:19 - time to take a breath take a breather
146:21 - and review what you've learned
146:26 - the github repository associated with
146:28 - this course also has all the code for
146:30 - this lesson so let's jump into it so
146:33 - we're back in remix now and we're going
146:34 - to go to contracts and same as before
146:36 - we're going to create a new file we're
146:39 - going to call this fundme.sol
146:41 - now same as last time we're actually
146:43 - going to add this spdx license
146:45 - identifier mit right at the top and then
146:47 - we're going to choose our solidity
146:49 - version
146:51 - so we're going to go pragma solidity
146:55 - and for this we're just going to do
146:57 - greater than equals to
146:58 - 0.6.6
147:00 - and less than 0.9.0
147:04 - and great
147:06 - this should look pretty familiar
147:08 - now we're going to do contract fund me
147:12 - and we're going to start working so what
147:14 - again do we want this contract to do we
147:17 - want this contract to be able to accept
147:19 - some type of payment so let's create a
147:22 - new function that can accept payment
147:25 - we'll call it fund
147:27 - so we'll do function
147:29 - fund
147:31 - public and we'll add a new keyword in
147:33 - here called payable when we define a
147:35 - function as payable we're saying hey
147:38 - this function can be used to pay for
147:40 - things when you call a function
147:42 - every single function call has an
147:44 - associated
147:45 - value with it whenever you make a
147:47 - transaction you can always append a
147:50 - value
147:51 - this value
147:52 - is how much whey or gray or fini or
147:55 - ether you're going to send with your
147:57 - function call or your transaction
147:59 - as we mentioned before
148:01 - whey way and ether are just different
148:04 - ways to talk about how much ether you're
148:06 - going to send
148:07 - so if we look at a way to ethereum
148:10 - converter one each is
148:13 - this much way
148:15 - one way is the smallest denomination of
148:19 - ether you can't break up ethereum into
148:21 - anything smaller than one way this is
148:24 - why when you're talking about how much
148:25 - something costs everything always
148:27 - defaults to whey or the smallest unit of
148:30 - measure in ethereum so again for us to
148:33 - test we're going to stick with the
148:34 - javascript vm for now if we hit deploy
148:37 - we get a new contract and this button is
148:39 - now red it's red because it is a payable
148:43 - function so now if i hit this fun button
148:45 - [Music]
148:46 - i can add
148:48 - a value associated with it so what do we
148:50 - want to do with this funding what do we
148:52 - want to do when people send us something
148:54 - well let's keep track of who sent us
148:56 - some funding so what we can do is we can
148:59 - create a new mapping between addresses
149:02 - and value
149:03 - so let's do a mapping
149:06 - of address
149:09 - to
149:10 - uin256 which will represent the value
149:13 - we'll make this a public mapping
149:15 - and we'll call it
149:16 - address to amount
149:19 - funded
149:20 - now in this fun function let's keep
149:22 - track of all the people who sent us
149:24 - money or all the addresses that sent us
149:26 - some value
149:28 - to do this we can use some keywords that
149:31 - go along with every transaction so we'll
149:33 - say address
149:35 - to amount funded
149:38 - of message.sender
149:43 - equals
149:44 - or
149:45 - plus equals
149:47 - message.value message.sender and
149:50 - message.value are keywords in every
149:53 - contract call and every transaction
149:55 - message.sender is the sender of the
149:58 - function call and message.value is how
150:01 - much they sent
150:03 - so whenever we call fund now somebody
150:05 - can send some value because it's payable
150:08 - and we're going to save everything in
150:10 - this address to amount funded mapping
150:13 - so if we deploy this now
150:14 - in our javascript vm
150:16 - we now have again a new view function
150:18 - called address to amount funded and we
150:20 - can even hit the drop down to see the
150:22 - full name
150:23 - now if i hit fund nothing's going to
150:25 - happen right because my address is going
150:28 - to be sending zero
150:30 - in order for me to send something i have
150:32 - to add some value along with my
150:34 - transaction
150:35 - so let's send for example one way
150:38 - which is going to be equal to
150:40 - 1
150:41 - 1 2 3 4 5 6 7 8 9 this much way so
150:46 - before i hit fund here if i copy this
150:48 - fake account which is up here
150:51 - and i put it in this address to amount
150:53 - funded
150:54 - it's going to return zero
150:57 - but now if i add
151:00 - 1 1 2 3 4 5 6 7 8 9 in here
151:05 - and we go ahead and hit fund now we've
151:07 - now just called this fun function with a
151:09 - value of one gray associated with it
151:13 - so if i call
151:15 - this address to amount funded now with
151:17 - the same address i can now see
151:19 - how much we've funded this smart
151:21 - contract and we can even add more gray
151:25 - we'll add
151:27 - we'll add 11gway for example we'll call
151:29 - fund and if we call this now we can see
151:32 - that even more has been added when we
151:34 - send our funds to a contract this
151:36 - actually means that this contract
151:38 - wherever this is deployed now is the
151:40 - owner of this
151:42 - amount of ether
151:44 - so this is fantastic we now have a way
151:46 - to fund our smart contracts now here's
151:48 - the thing
151:50 - in this smart contract in this funding
151:51 - that we're doing we want to create a
151:54 - minimum value for people to be able to
151:56 - fund our endeavors which whatever they
151:58 - may be we want to set some minimum value
152:00 - here
152:01 - and ether is great but for whatever
152:03 - reason we want to work in usd or maybe
152:06 - we want to work in some other token so
152:08 - how are we going to get the conversion
152:09 - rate from that currency to a currency
152:11 - that we can use in this smart contract
152:14 - well the first thing that we're going to
152:15 - need to do to set this value is we're
152:17 - going to need to know
152:19 - what the eth
152:21 - to usd
152:22 - conversion rate is
152:24 - because if i want to
152:26 - accept ethereum as the token but i want
152:29 - it in its usd currency well then i'm
152:31 - going to need to know what that
152:32 - conversion rate is so how are we going
152:34 - to get this data into our smart contract
152:37 - where are we going to get this data from
152:39 - now remember how we talked about
152:40 - blockchains being deterministic systems
152:42 - and and oracles being the bridge between
152:44 - blockchains and the real world well this
152:46 - is exactly where oracle's come in when
152:49 - we're talking about these systems you
152:50 - know these blockchains they can't
152:52 - connect to real-world events they can't
152:53 - connect to external systems they can't
152:55 - do external computation they're
152:57 - intentionally these deterministic
152:59 - systems these walled gardens so in order
153:02 - for us to make this connection we need a
153:04 - blockchain oracle we need some type of
153:07 - network here now just to get a little
153:09 - bit more technical for you if we look at
153:12 - a blockchain a blockchain can easily say
153:15 - one plus one
153:16 - equals two and every other node can
153:18 - easily verify this
153:20 - however a blockchain can't easily say
153:23 - okay let's all grab the same random
153:25 - number because each node is going to get
153:27 - a different random number they also
153:29 - can't say hey let's make an api call
153:32 - because if one node calls the api at a
153:35 - different time another node calls it or
153:37 - specifically an http get there could
153:40 - potentially get very very different
153:43 - results
153:44 - and if another node tries to replay
153:46 - these transactions by calling these apis
153:48 - again
153:49 - maybe 10 years in the future there's a
153:51 - good chance that that api is going to be
153:53 - depreciated
153:55 - and they could be hacked they could be
153:56 - malicious et cetera et cetera
153:59 - the other reason that blockchains
154:01 - intentionally can't make api calls is
154:03 - because then they would be making
154:05 - assumptions about the real world and
154:07 - layer ones typically don't want to have
154:09 - an opinion on any political or
154:11 - geopolitical issue whereas an oracle
154:13 - network on the other hand can make those
154:14 - assumptions the other main thing we need
154:16 - to talk about here is centralized
154:18 - oracles being main points of failures if
154:20 - you or i say hey i'm just going to be
154:22 - the oracle i'm going to be the one to
154:24 - put this data on chain we now have this
154:26 - massive centralized point of failure
154:29 - we've done all this work to make our
154:31 - decentralized computation decentralized
154:33 - and on chain but we ruin all the
154:35 - decentrality by having a single point of
154:37 - failure remember one of the whole
154:39 - purposes of blockchain is so that not a
154:41 - single entity can flip a switch and
154:43 - restrict our freedom to interact with a
154:46 - centralized oracle a single entity can
154:48 - flip a switch and restrict our freedom
154:51 - to interact with each other we also need
154:53 - to get data from many different
154:54 - decentralized sources or do any type of
154:57 - computation in a decentralized manner
155:01 - this is where chain link really shines
155:03 - chain link is a modular decentralized
155:06 - oracle infrastructure and oracle network
155:08 - that allows us to get data and do
155:10 - external computation in a highly civil
155:13 - resistant decentralized manner it can be
155:16 - as customizable as you want as you can
155:18 - run with one node or many nodes or do as
155:20 - many nodes as you like
155:23 - now currently one of the most popular
155:25 - features of chain link is their data
155:27 - feeds or their price feeds we can even
155:29 - go check them out
155:31 - over at data
155:34 - dot chain dot link
155:37 - we can see a number of different price
155:39 - feeds and the networks that are
155:41 - providing the prices for these specific
155:43 - pricing powers
155:44 - we can see here by looking at the ui
155:46 - there is a whole number of decentralized
155:49 - different oracles returning data for
155:51 - different price feeds this one for
155:53 - example is fusd and it's also exactly
155:56 - the price view that we're looking for
155:57 - having a decentralized network bring
156:00 - this data on chain and have it as a
156:02 - reference point of definitive truth
156:04 - allows users to all collaborate and use
156:07 - this common good and it will be cheaper
156:10 - more secure more efficient than anybody
156:12 - even running their own centralized
156:14 - oracle so these price feeds are
156:16 - incredibly powerful additionally they're
156:18 - being used by some of the top protocols
156:21 - in the defy system right now
156:23 - like synthetics which at the time of
156:25 - recording is securing around 2 billion
156:28 - sushi swap for leveraging trades set
156:31 - protocol commodity money ave for
156:33 - understanding the price of an underlying
156:36 - collateral now this is an example of an
156:38 - out of the box decentralized solution
156:40 - that's already been packaged in the
156:42 - decentralized manner for you to consume
156:44 - and for you to use this makes going to
156:46 - production a thousand times easier than
156:49 - building everything yourself
156:50 - however if you want to make api calls
156:53 - and build your own decentralized network
156:55 - you absolutely can with the chainlink
156:57 - api calls
156:59 - we're not going to go into that here
157:00 - because using the chainlink price feeds
157:02 - chainlink vrf keeper network and all
157:04 - these other pre-box decentralized
157:06 - services are going to make going live
157:08 - and going mainnet a lot easier you can
157:10 - always make a chain link http get call
157:12 - as well we're not going to go over this
157:14 - though because putting this into
157:16 - production is a little bit trickier and
157:17 - working with chainlink vrx if you ever
157:19 - want to try them out by themselves you
157:21 - can always head over to docs.chain.link
157:24 - and head over to get the latest price
157:26 - feed there's usually a remix button
157:28 - actually that we can click and it will
157:30 - kick us out to a remix edition with all
157:33 - the code already ready to go for us if
157:35 - we just hit this just right here this
157:37 - will include all of our code which we'll
157:38 - go into in a second
157:40 - but let's go ahead and compile it
157:42 - we're going to deploy it
157:44 - to a real network here
157:46 - this one looks like it's actually for
157:49 - covin so we're going to go ahead and
157:50 - switch to coven looks like i don't have
157:52 - any covent ethereum so we're going to
157:54 - grab
157:55 - a covent faucet we can usually find
157:57 - different faucets in the chain link
157:59 - documentation
158:00 - let's look up kovin here
158:03 - there is a coven faucet here
158:05 - it looks like in order for us to get
158:06 - some covent ethereum here we have to log
158:08 - in with github then we can add our
158:10 - address in here and get the ethereum in
158:12 - the interest of time i'm going to skip
158:13 - ahead for me doing that
158:16 - great it looks like i've got some covent
158:18 - test that now being able to switch
158:20 - between test nets is going to make you a
158:22 - lot more effective as an engineer as
158:24 - well because you're going to be able to
158:25 - understand how each network actually
158:26 - works so now we've compiled this
158:29 - let's deploy this
158:33 - again metamask is going to pop up
158:36 - and let's go ahead and click to get the
158:38 - latest price and we can see that this
158:40 - function does indeed return the latest
158:42 - price of ethereum
158:44 - now you might be asking
158:45 - why does this number look so big
158:47 - well remember how we talked about whey
158:49 - and gray and ether
158:51 - well the reason that those exist is
158:53 - because decimals don't work in solidity
158:55 - so we actually have to return a value
158:57 - that's multiplied by 10 to some number
159:00 - so this value is actually 2614
159:03 - times
159:05 - 10
159:06 - raised to the eighth now the next
159:07 - question you might ask is well why did
159:09 - we work with this on a test net why
159:11 - can't we do this on a local network and
159:13 - the answer to this is because there is a
159:14 - network of nodes looking at this test
159:17 - net and delivering data onto this test
159:19 - stem when you spin up a local network or
159:21 - do a simulated vm there are no nodes
159:24 - actually doing that we'll learn later
159:26 - how to actually mock these interactions
159:28 - and mock a chain link node returning
159:30 - data onto our blockchain but for now
159:32 - let's head back over to the contract
159:33 - that we're working on so we can learn
159:35 - how to implement this in any contract
159:38 - that we ever want to another contract
159:40 - called in this case called price feed
159:43 - has a function called latest round data
159:45 - which returns a lot of data it returns a
159:48 - round id which defines how many times
159:51 - this price feed has been updated it
159:53 - returns a price which is the actual
159:55 - conversion rate between the two assets
159:58 - it returns a started at which defines
160:00 - when this was last updated
160:02 - it returns a time stamp and it returns
160:05 - an answer in round don't worry about
160:07 - answered in round for now if you want to
160:09 - dive a little bit deeper into what these
160:11 - rounds mean and what answered in round
160:13 - means you can definitely check out the
160:14 - chain link documentation and some of the
160:16 - faqs to learn more now how do we
160:18 - implement this data feed into our fundme
160:21 - application well the first thing we're
160:22 - actually going to need to do is we're
160:24 - going to need to import the chain link
160:26 - code
160:26 - so we're going to do import
160:28 - at chain link
160:30 - contracts
160:33 - source
160:34 - v 0.6
160:37 - interfaces
160:39 - slash aggregator
160:42 - v3
160:44 - interface
160:45 - dot soul
160:48 - now let's talk about what this is
160:50 - actually doing
160:51 - oops looks like i spelt aggregator v3
160:53 - interface wrong
160:55 - all right great now it's actually
160:56 - compiling
160:57 - so let's talk about what imports
160:59 - actually do
161:00 - as we know an import will take whatever
161:03 - code you're importing and stick it at
161:05 - the top of your project so when we
161:07 - import from at chainlink contracts we're
161:10 - actually importing from the at chainlink
161:12 - contracts npm package
161:14 - we can look up at chain links contracts
161:19 - in npm
161:22 - and we can see and read more about this
161:24 - repository
161:27 - this links us back to the github which
161:29 - will tell us a little bit more about
161:30 - what's really going on if we follow that
161:32 - import path that we got from the
161:34 - documentation we'll end up on this file
161:36 - in front of me now we have what's called
161:38 - an interface you can see these contracts
161:41 - don't start with the contract keyword
161:43 - but they start with the interface
161:45 - keyword they have the exact same pragma
161:47 - solidity at the top but the main
161:49 - difference is that you can see that
161:51 - their functions aren't completed they
161:54 - just have the function name
161:56 - and its return type
161:58 - now just to be a little bit more
161:59 - explicit here i'm actually going to go
162:01 - ahead and delete this import statement
162:03 - on the top and replace it with that
162:05 - interface code from github just to show
162:07 - you exactly what's going on however if
162:09 - you've already typed that at import
162:10 - syntax feel free to leave it in there
162:12 - and just remember that it's going to be
162:14 - the exact same as me copy pasting the
162:17 - interface code in our code here solidity
162:19 - doesn't natively understand how to
162:22 - interact with another contract we have
162:24 - to tell solidity what functions can be
162:27 - called on another contract this is where
162:30 - interfaces are actually going to come in
162:32 - similar to structs what we can do with
162:33 - interfaces to find a new type so if we
162:36 - copy all this code
162:39 - from this section and place it at the
162:41 - top of our code here
162:43 - above where we're declaring a contract
162:46 - we can actually then
162:47 - interact with contracts that have these
162:50 - functions
162:51 - if we go ahead and even compile this we
162:53 - can see this does indeed compile
162:55 - correctly remember how we said before we
162:57 - talked a little bit about abis well
163:00 - interfaces actually compile down to
163:02 - what's called the abi or the application
163:04 - binary interface the application binary
163:07 - interface
163:08 - tells solidity what functions can be
163:11 - called on another contract
163:17 - we need solidity to know what functions
163:19 - it can use and what functions it can
163:21 - call other contracts with and if that
163:23 - was a little bit confusing just know any
163:26 - time you're going to interact with
163:28 - another contract in solidity or smart
163:30 - contract programming in general you're
163:32 - going to need that contracts abi we'll
163:34 - go into what these apis look like a
163:36 - little bit later anyways to simplify it
163:38 - interface compiles down to an api we
163:41 - always need an api to interact with the
163:42 - contract so how do we actually work with
163:44 - this contract here to interact with an
163:46 - interface contract it's going to work
163:48 - the exact same way is interacting with a
163:50 - struct or a variable let's define a new
163:52 - function called getversion and we're
163:55 - going to call this version function on
163:58 - this other contract
164:00 - so we'll start out doing function
164:03 - get version
164:05 - public
164:06 - remember it needs to be a view since
164:08 - we're just going to be reading this
164:10 - state and even in the interface it even
164:14 - defines it as a view returns
164:17 - so we'll even grab
164:19 - this whole bit right here
164:22 - view returns unit 256. now the exact
164:25 - same way we define variables and structs
164:28 - we define working with other contracts
164:30 - and interfaces so the first thing is we
164:33 - name the type which in this case is
164:35 - aggregator v3 interface
164:37 - then we'd name the visibility but since
164:40 - again we're inside of this contract
164:42 - we're going to skip it then let's give
164:44 - it a name
164:45 - we'll call it
164:46 - price feed since this aggregator v3
164:48 - interface is going to be giving us a
164:50 - price fee then we can do equals and this
164:53 - is where we're going to initialize the
164:54 - contract so how do we actually choose
164:56 - where to interact with this contract
164:58 - well we just type aggregator v3
165:01 - interface and then we put in here the
165:03 - address of where this contract is
165:05 - located in order to find
165:07 - where this fusd price feed contract is
165:10 - located on the rink b chain we can look
165:13 - at the ethereum price feeds chain link
165:15 - documentation
165:16 - it has a ton of different price feeds
165:19 - and even more not price related data
165:23 - let's scroll down to rink b
165:26 - because again
165:27 - on each different chain
165:29 - the contract address that has all this
165:31 - price feed information is going to be
165:33 - different
165:34 - let's scroll down and find fusd which is
165:37 - right here
165:39 - and we'll copy it
165:41 - and we'll paste it into here
165:44 - now what is this line saying
165:46 - it's saying that we have a contract that
165:49 - has
165:50 - these functions defined in the interface
165:53 - located at this address if that's true
165:56 - then we should be able to call
165:58 - price feed
165:59 - dot
166:00 - version
166:05 - and we should be able to return it
166:07 - whoops looks like we forgot to add
166:10 - those here
166:11 - and we need a semicolon here
166:13 - i hit ctrl s or command s compiled it
166:16 - looks like we're compiling successfully
166:18 - and we do need to deploy this on a test
166:21 - n
166:22 - remember this address here is located on
166:26 - an actual test tent it's located on an
166:28 - actual network it's not going to be
166:30 - located on our simulated chain here so
166:32 - we do need to deploy this to injected
166:34 - web 3. we do need to deploy our contract
166:37 - to rink b because the rink b chain has
166:39 - this address
166:41 - we'll learn later on how we actually can
166:43 - work with a simulated chain and work
166:45 - with these price feeds but that's much
166:47 - later in this course so let's go ahead
166:49 - and save
166:51 - we'll deploy
166:52 - make sure we're on injected web 3.
166:55 - now we can go ahead and hit deploy
166:57 - metamask is going to pop up per usual
167:00 - confirm
167:01 - we're going to get a transaction link to
167:04 - etherscan showing us our contract
167:08 - and once it actually is confirmed we can
167:10 - see we have our contract right here now
167:12 - we have our familiar functions with one
167:15 - additional function
167:16 - we have our fund button which is red
167:18 - because it's payable we have our address
167:21 - to amount funded mapping which is blue
167:23 - because it's a view
167:24 - and we also have this get version button
167:27 - that's also blue if we go ahead and
167:29 - click it we can see that the version of
167:32 - our aggregator v3 interface is version
167:34 - 3. this is the third version of the
167:37 - aggregator interfaces hence the name
167:40 - aggregator v3 interface so we just made
167:43 - a contract call to another contract from
167:46 - our contract using an interface this is
167:49 - why interfaces are so powerful because
167:52 - they're a minimalistic view into another
167:54 - contract so this is great we have a get
167:56 - version function but this still isn't
167:59 - the function that we want we want to
168:00 - call the get price function which if we
168:04 - look at our interface we can see there's
168:06 - a latest round data function that
168:08 - returns
168:09 - an answer this is the function that
168:11 - we're going to want to call on this
168:13 - contract so let's go ahead and make a
168:15 - function that calls that instead
168:17 - so we're going to do
168:19 - function
168:20 - get price
168:22 - public
168:23 - view
168:24 - returns
168:26 - uint 256.
168:29 - uh oh
168:30 - this latest round data function though
168:32 - returns
168:33 - five variables so how do we actually
168:35 - work with that well let's find out to
168:38 - work with this contract we're gonna do
168:39 - the exact same thing
168:41 - we're gonna do aggregator v3 interface
168:43 - because this is the type of the contract
168:46 - price feed
168:47 - equals
168:50 - aggregator v3 interface
168:52 - we'll do this same address in here
168:54 - because this is the fusd address
168:57 - then we'll do price feed
169:00 - dot
169:01 - latest round data
169:04 - now since this is going to return
169:06 - five different values
169:08 - we can actually have our contract also
169:11 - return these five different values
169:14 - we can copy paste like this
169:16 - and literally do
169:18 - this
169:19 - these five values equal price feed that
169:21 - latest round data
169:23 - and you can see
169:24 - that even compiles correctly let's
169:26 - adjust the formatting a little bit here
169:28 - so it looks a little bit nicer a tuple
169:30 - is a list of objects of potentially
169:32 - different types this is the syntax for
169:34 - getting a tuple we can define several
169:36 - variables inside one of these tuples
169:38 - although our compiler is going to give
169:40 - us some warnings it's saying unused
169:42 - local variable because we're not
169:43 - actually using these for anything we'll
169:45 - come back to this
169:47 - now we can go ahead and do return
169:49 - and we can pick one of these variables
169:51 - that we want to return answer is going
169:53 - to be the price so we're going to do
169:55 - return
169:56 - answer but uh-oh we're going to run into
169:58 - an error return type argument in 256 is
170:02 - not implicitly convertible to expected
170:04 - type answer is an int 256 and we want to
170:08 - return a uint 256 so how do we rectify
170:11 - this we can fix this by using what's
170:13 - called typecasting if we just return
170:15 - answer we're going to be returning the
170:17 - wrong type however integers and solidity
170:20 - are really easy to cast into each other
170:22 - so we can just do uint 256
170:25 - and wrap it around this answer
170:27 - and then compile and save that instead
170:30 - as you can see now our compiler is happy
170:33 - because we've changed this answer into a
170:36 - unit 256
170:38 - awesome so now this get price should
170:41 - return the latest price of ethereum in
170:43 - terms of usd let's go ahead and deploy
170:46 - this new contract with this new function
170:50 - so same thing we're going to come to our
170:52 - deploy section
170:53 - hit the deploy button up remember we got
170:56 - to go to the fundbean.sol
170:58 - let's deploy it
171:00 - confirm with metamask here
171:04 - and let's scroll down to our newly
171:05 - deployed contract
171:07 - as you can see we have our get version
171:09 - function which still works exactly the
171:11 - same but we have a new function too
171:14 - called get price and this should return
171:17 - a uint 256 answer let's go ahead and
171:19 - click it
171:20 - amazing we've actually returned an
171:22 - answer now again if you're a little
171:25 - confused on why this number looks so big
171:27 - you have to remember that this actually
171:29 - has eight decimals we could call this
171:32 - decimal's function on the contract to
171:34 - learn that one two three four five six
171:36 - seven eight and we know that the current
171:38 - price of ethereum in terms of usd
171:40 - is two thousand four hundred and
171:42 - eighty-two awesome so now that we have
171:44 - the price we can actually get the
171:45 - conversion rate but let's clean up this
171:47 - function a little bit before we go on up
171:49 - there as you can see one thing that the
171:51 - compiler is complaining about is we have
171:53 - a lot of unused local variables
171:56 - but latest round data returns
172:00 - five different variables
172:01 - so how do we actually return the five
172:03 - variables but make our compiler happy
172:06 - with us well we can actually just return
172:08 - blanks for each one of these sections
172:10 - with commas in between each other to say
172:12 - hey there is a variable here but we're
172:14 - not going to use it
172:16 - this will also make our code look a lot
172:18 - cleaner
172:20 - because now this function's a lot
172:22 - smaller
172:23 - we say
172:24 - something's here we're ignoring it
172:27 - in 256 answer we're going to use some
172:29 - things here ignore it something here
172:31 - ignore it and ignore this too and we can
172:34 - even test this out by compiling it
172:37 - deploying it
172:39 - checking on rank b
172:42 - scrolling down
172:44 - hitting this
172:45 - and hitting get price and you can see
172:47 - indeed it's the exact same as before
172:51 - awesome so now we're all done cleaning
172:52 - things up right not quite yet
172:55 - see the other thing that's really
172:56 - annoying here we have this massive chunk
172:58 - of code at the top
173:00 - that is probably a little redundant
173:02 - there's a good chance that a lot of our
173:04 - contracts are going to want to use this
173:06 - aggregator v3 interface so let's just go
173:08 - ahead and add that at chain link
173:10 - contract syntax back in because it's
173:12 - going to look a lot cleaner here and do
173:14 - at chain link
173:16 - contracts if you ever get a little bit
173:18 - confused with what you should be
173:19 - importing to work with their contracts
173:21 - we can see right in the documentation at
173:24 - the top this at syntax is what this is
173:27 - going to use
173:28 - now you can also go ahead and browse
173:30 - that npm package of at chainlink
173:32 - contracts see what other applications
173:34 - are in there and what other files are in
173:36 - there
173:37 - or you can just peruse around the github
173:39 - now the third way we can actually do
173:41 - imports is we can import from contracts
173:43 - that are in the same file system as our
173:46 - contracts well awesome our contract is
173:48 - starting to look more and more put
173:50 - together now one other thing that i
173:51 - usually like to do with these is i
173:53 - usually like to put everything into the
173:55 - gray
173:56 - way standard so as we saw
173:59 - this get price had eight decimal places
174:02 - however
174:04 - the smallest unit of measure aka whey
174:08 - if we look at it has 18. one two three
174:11 - four five six seven eight nine ten one
174:13 - two three four five six seven eight
174:16 - so typically in these i like to try to
174:19 - make everything have 18 decimals as well
174:21 - you don't have to do this and it'll save
174:23 - some gas if you don't but i usually like
174:26 - to multiply everything so that
174:27 - everything has 18 decimal places so
174:30 - since i know this has 8 i can just do 1
174:32 - 2 three four five six seven eight nine
174:34 - ten
174:35 - and now this will return
174:37 - the price with eighteen decimal places
174:40 - instead of ten now we have the price of
174:42 - ethereum in us dollar which is fantastic
174:45 - so we could set the price of our funding
174:48 - function to anything that we want here
174:51 - for example let's say 50
174:53 - we could convert whatever value that
174:55 - they send us to its us dollar equivalent
174:59 - and see if it's greater than or less
175:01 - than fifty dollars
175:03 - all we have to do is make a new function
175:07 - that converts that value that they send
175:10 - to its us dollar equivalent so we could
175:12 - do function
175:15 - get conver
175:16 - generate
175:18 - and it will take a u 256
175:20 - f amount let's get this out of the way
175:23 - for the rest of this
175:24 - it'll be a public view function since
175:27 - again we're not actually going to have
175:29 - it make any state change
175:31 - we'll do returns you want 256
175:35 - and then in this function
175:36 - we can do uint 256
175:38 - f price
175:40 - equals
175:41 - get price
175:43 - and we can call
175:44 - this get price function up here
175:47 - now we have the price in here
175:49 - what we want to do is we want to convert
175:51 - whatever value that they send
175:53 - as f amount let's say they send one way
175:57 - or again that's going to be this much
175:59 - way
176:02 - what how do we convert this
176:04 - to fusd
176:05 - well
176:06 - we can now do unit 256
176:09 - s
176:10 - amount
176:11 - in usd
176:13 - equals
176:14 - this f price
176:16 - times
176:19 - the f amount that they sent
176:21 - this is actually going to
176:24 - result in a much bigger number than
176:26 - we're looking for and then of course
176:27 - we're going to return it
176:29 - let's test this out and see why we have
176:32 - to do one more thing here
176:34 - so let's again
176:35 - fund me we'll deploy
176:37 - rank
176:38 - b we'll scroll down and we have this new
176:42 - function called get conversion rate
176:44 - let's grab this one gray and put it in
176:46 - here whoa
176:47 - this seems like it's a really big number
176:50 - we're saying that
176:52 - one gray
176:53 - is equal to one two three four five six
176:55 - seven eight one two three four five six
176:57 - seven eight nine ten
177:00 - this many dollars
177:02 - now i don't know about you but i don't
177:05 - think the price of even one ethereum is
177:07 - that many dollars maybe in the distant
177:09 - future but definitely not right now the
177:11 - reason that it's off is we have to then
177:13 - actually divide by
177:15 - this number the reason that we have to
177:16 - do this is because both f price and f
177:19 - amount
177:20 - have an additional
177:23 - 10 raised to the 18th tacked on to them
177:25 - so now we have to divide it out in order
177:27 - to get the right number
177:29 - so we're going to compile
177:31 - compile
177:33 - deploy
177:34 - confirm
177:37 - we can scroll down
177:39 - and now let's try this one way
177:41 - we'll get the conversion right here
177:43 - and we can see we get a number that
177:46 - makes a little bit more sense now
177:47 - remember this has 18 decimals as well so
177:50 - the real number is 1 2 3 4 5 6 7 8 1 2 3
177:55 - 4 5
177:56 - 6 7 8 9 10.
178:00 - and we know that this number is actually
178:02 - accurate because we can go ahead and
178:03 - pull up a calculator
178:05 - pop that into here
178:07 - and we know that this is one way in us
178:10 - dollar
178:11 - if we get the conversion rate
178:13 - we're saying that this many gray equals
178:16 - one each
178:17 - so we can check it back by multiplying
178:19 - this number by that and we see that we
178:21 - do actually get the price of one
178:24 - ethereum in us dollar
178:26 - so our math here checks out
178:29 - awesome now since we're on the topic of
178:31 - math i do want to talk briefly about
178:33 - some of the pitfalls of solidity
178:35 - especially when it comes to math prior
178:37 - to solidity 0.8 if you added to the
178:40 - maximum size a uint number could be it
178:43 - would actually wrap around to the lowest
178:46 - number that it would be and in fact you
178:48 - can even demo this with a contract here
178:50 - now you don't have to follow along with
178:51 - this contract but just watch to see the
178:53 - example we're going to call this
178:56 - overflow
178:57 - dot sol
178:59 - now in here we're going to add all kind
179:00 - of the normal stuff
179:02 - contract
179:03 - overflow
179:05 - and we're going to add a function
179:08 - called
179:09 - overflow we'll make a public
179:11 - view and we'll have it return a uint 8.
179:14 - i'll show you why in just a minute a
179:16 - union 256 is a really really big number
179:19 - and it's hard to kind of imagine going
179:21 - over the maximum cap of a u and 256
179:24 - but a uint 8 is a lot smaller with the
179:28 - maximum number actually being 255. so if
179:31 - we create a uint 8 and we call it
179:34 - big
179:35 - equals 255 and then we just do return
179:39 - big
179:40 - what do we think we're going to get here
179:42 - for this we can go ahead and use
179:43 - javascript vm because we're not
179:45 - interacting with any other contracts
179:48 - let's deploy this
179:50 - and we'll see in our contract if we call
179:51 - overflow now we're just going to get
179:54 - 255.
179:55 - however what happens if we add 1 to this
179:57 - number or try to add 1 to this number if
180:00 - we do it just like this solidity
180:01 - actually knows that there's an issue
180:03 - here and says hey
180:04 - try not to do this
180:06 - but if we typecast this as a uint eight
180:10 - solidity gets a little bit more confused
180:11 - and goes ahead and lets us do this
180:14 - now what do we think big is going to be
180:16 - it should be 256 right
180:19 - but big is the uint 8 and this is the
180:22 - maximum size that it could be so what
180:24 - happens when we deploy this
180:26 - we look down
180:27 - we actually get zero
180:30 - what happens if we do 100 and we deploy
180:33 - that
180:37 - we actually get 99
180:39 - and this is because integers can
180:41 - actually wrap around once you reach
180:43 - their maximum cap they basically reset
180:46 - this is something we need to watch out
180:48 - for when working with solidity if we're
180:50 - doing multiplication on really big
180:52 - numbers we can accidentally pass this
180:54 - cap luckily as a version 0.8 of solidity
180:58 - it actually checks for overflow and it
181:00 - defaults to check for overflow to
181:02 - increase readability of code even if
181:04 - that comes a slight increase of gas
181:07 - costs you can use this unchecked if you
181:09 - want to have it keep that wrapping
181:11 - functionality so just be aware if you're
181:14 - using a lower version than 0.8 you're
181:17 - going to have to do something to make up
181:19 - for this and we could write a whole
181:20 - bunch of code here basically to check
181:22 - all of our math
181:24 - or we could just import something called
181:26 - safe math from another package
181:29 - similar to how we imported chain link we
181:31 - can go ahead and
181:32 - import a package called
181:35 - safe math
181:36 - from a tool called open zeppelin
181:41 - now open zeppelin is an open source tool
181:43 - that allows us to use a lot of already
181:45 - pre-built contracts
181:47 - we can go ahead to the documentation and
181:49 - go to their utilities and see safe math
181:52 - and they even have a little sticker here
181:54 - saying safe math is no longer needed
181:56 - started with solidity 0.8 safe math is a
181:59 - tool and a way for us to avoid some of
182:00 - these problems with doing math and
182:02 - solidity now i'm not going to spend too
182:03 - much time on the contracts that actually
182:05 - fix this but we can actually import
182:07 - right from the chain link directory as
182:09 - well
182:10 - a solidity file called safe math chain
182:13 - link and what we can do is right after
182:15 - our contract
182:16 - we can do using
182:19 - safe math chain link
182:21 - for
182:23 - uint256
182:25 - and what this will do
182:26 - is it will use safe math chain link for
182:29 - all of our unit 256
182:31 - and safe math chain link doesn't allow
182:33 - for that overflow to occur libraries are
182:36 - really similar to contracts except that
182:38 - they're isolated code that can be run in
182:40 - a reusable context
182:46 - in this case we're attaching the safe
182:48 - math chain link library to uint256 so
182:52 - that these overflows are automatically
182:54 - checked for just keep in mind if you're
182:55 - using anything less than 0.8 you're
182:58 - going to want to use some type of safe
183:00 - math just to check for your overflows
183:02 - now this is for those of you who are
183:04 - familiar with safe math and integer
183:05 - overflows and underflows we are not
183:08 - going to be calling the functions that
183:09 - safe math provides us like div add mole
183:12 - you know all those functions simply
183:14 - because in 0.8 moving forward we no
183:16 - longer have to use those and we can just
183:17 - use our regular operators like plus and
183:19 - minus so this is great our contract is
183:21 - coming along really well we now have a
183:24 - way to get the conversion rate of
183:26 - whatever f is sent and turn it into us
183:29 - dollar
183:30 - now we can set a threshold in terms of
183:32 - us dollar but how do we guarantee that
183:36 - whatever amount that the users send when
183:38 - they call fund is going to be at least
183:40 - fifty dollars well first we might want
183:42 - to set a minimum value so we can do unit
183:45 - 256
183:46 - minimum usd
183:49 - equals
183:50 - let's say 50
183:52 - and again since we're using everything
183:54 - in way terms we want to then multiply
183:57 - this by 10
183:59 - raised to the 18th
184:01 - and just want to take a pause for a
184:02 - second because this line is actually
184:03 - wrong this should be raised to the 18th
184:06 - so this line should really look like
184:08 - this where it has the double star so
184:10 - apologies the rest of this has that
184:12 - single star but it should be the double
184:14 - star here if you do have the single star
184:16 - though the rest of the contract will
184:17 - still work fine so this will be the
184:19 - minimum value it'll be 50
184:22 - times 10
184:23 - raised to the 18th so that everything
184:25 - has 18 decimals now that we have a
184:27 - minimum amount how do we actually make
184:30 - sure that this minimum amount is met in
184:33 - the value that they send us well if
184:34 - you're familiar with if statements we
184:36 - could do something like if message.value
184:40 - is less than minimum usd
184:44 - then
184:45 - revert
184:48 - or
184:49 - we could do something a lot easier and
184:51 - better practice and much cleaner we do
184:53 - what's called a require statement when a
184:55 - function call reaches a require
184:57 - statement it'll check the truthiness of
185:00 - whatever require you've asked so in our
185:02 - case the converted rate of message.value
185:07 - needs to be greater than or equal to
185:10 - our minimum usd
185:12 - this line
185:13 - says that if the conversion rate of
185:16 - message on value to usd if they didn't
185:18 - send us enough ether
185:20 - then we are going to stop executing
185:23 - we're going to kick it out we're going
185:24 - to say hey this doesn't count and we're
185:26 - going to do what's called a revert we're
185:28 - going to revert the transaction this
185:30 - means that the user is going to get
185:31 - their money back as well as any unspent
185:33 - gas and this is highly recommended we
185:36 - can also then additionally add a
185:40 - revert error message something like
185:43 - you need to spend more eath
185:48 - so now let's try this out as we saw one
185:50 - way
185:51 - is going to be way less than fifty
185:53 - dollars so if we send one way along with
185:56 - this fund contract call it should kick
185:59 - out and say you need to spend more eth
186:02 - so let's actually try this let's go to
186:04 - the deploy tab
186:06 - we'll get rid of our overflow
186:08 - we use injected web 3 because again we
186:10 - are working with the chain link
186:11 - aggregated contracts that are on chain
186:13 - we're going to move to
186:15 - fund me
186:16 - and we're going to hit deploy
186:18 - metamath's going to pop up and we're
186:19 - going to hit confirm
186:22 - now if i try to hit fund
186:25 - let's see what happens we're getting a
186:27 - gas estimation
186:28 - failed since gas estimation error failed
186:31 - with the following message
186:34 - execution reverted you need to spend
186:36 - more eth
186:37 - so
186:38 - the contract isn't even letting us make
186:40 - the transaction we can go ahead and try
186:42 - to send the transaction but here's
186:44 - what's going to happen
186:45 - on ether scan
186:47 - once this goes through
186:51 - you can see that once this transaction
186:52 - finished we got this status fail with
186:55 - error you need to spend more eth we
186:58 - don't want to force these transactions
186:59 - to go through if we look at our metamask
187:01 - we can even see this failed bit here
187:04 - so whenever you see these gas estimation
187:06 - failed errors usually that means
187:08 - something reverted or you didn't do
187:10 - something that was required however if
187:12 - we go to value here and we spend a lot
187:15 - more
187:16 - let's say
187:17 - 0.1 ether
187:20 - which if we take out our calculator 2500
187:25 - times point one it's going to be 250
187:27 - dollars this should easily be well and
187:30 - beyond past our 50 threshold
187:33 - so let's add 0.1 ether remember we got
187:36 - 0.1 by adding it in the converter and
187:38 - grabbing the way again the way is the
187:41 - smallest denomination now if we change
187:43 - this to way and hit fund this should go
187:45 - through we're gonna hit fun now you'll
187:47 - see men and mass pops up because
187:49 - metamask goes oh yeah this transaction
187:52 - isn't going to revert and that's what we
187:54 - want so we can go ahead and hit confirm
187:57 - and now we'll finally have sent some
188:01 - funding to our contract
188:04 - now that this is confirmed we go ahead
188:07 - and grab our address here
188:09 - pop it into our address to amount and we
188:12 - can see that indeed our funding has gone
188:15 - through
188:16 - now we can be part of this crowdsourcing
188:19 - application with our minimum value which
188:21 - is fantastic awesome great job
188:25 - awesome so now we can fund this contract
188:28 - with a certain minimum usd value in this
188:31 - case it's going to be 50
188:33 - now you'll notice though that right now
188:35 - we don't do anything with this money so
188:37 - we're going to fund this contract
188:38 - however that's it and we don't have a
188:40 - function in here to actually withdraw
188:43 - the money so there's no way that even
188:45 - though we just sent this contract some
188:46 - money there's no way for us to get it
188:48 - back so how do we fix this well we can
188:50 - add a withdraw function in here so let's
188:53 - go ahead and add that
188:55 - function
188:57 - withdraw
188:58 - and this is also going to be a payable
189:00 - function because we're going to be
189:02 - transferring eth
189:04 - we'll make this public
189:06 - and we can do
189:08 - message
189:09 - dot sender dot transfer transfer is a
189:12 - function that we can call on any address
189:14 - to send eth from one address to another
189:18 - this transfer function sends some amount
189:21 - of ethereum to whoever it's being called
189:23 - on in this case we're transferring
189:25 - ethereum to message.sender so all we
189:27 - need to do now is define how much we
189:28 - want to send well we're going to send
189:30 - all the money that's been funded so to
189:32 - get all the money that's been funded in
189:34 - this contract
189:35 - we can do address
189:37 - this
189:39 - dot balance
189:41 - now there's a couple of special things
189:43 - going on with this line
189:45 - first we're saying address of this
189:48 - this is a key word in solidity whenever
189:50 - you refer to this you're talking about
189:53 - the contract that you're currently in
189:56 - and
189:57 - when we add address of this we're saying
189:59 - we want the address of the contract that
190:01 - we're currently in whenever you call an
190:03 - address and then the balance attribute
190:05 - you can see the balance in ether of a
190:08 - contract so with this line we're saying
190:10 - whoever called the withdraw function
190:12 - because whoever calls the function is
190:14 - going to be the message.sender
190:16 - transfer them
190:18 - all of our money so let's go ahead and
190:19 - try this let's deploy fundme
190:24 - and now let's fund this with a lot of
190:26 - ether so that we can see it we'll fund
190:29 - it with one whole ether
190:31 - so that we can see it go into the
190:33 - contract and get pulled out of the
190:35 - contract
190:36 - we'll hit the fun
190:38 - button and you'll see we're sending one
190:41 - whole ether into this contract
190:45 - now if we look at our balance it's gone
190:48 - down from 17 to 16. or if you're still
190:51 - at 18 it went down from 18. so let's try
190:53 - to get it back
190:54 - if we call this withdraw function now
190:57 - confirm
190:59 - once this transaction goes through we
191:01 - should get all of our ether back
191:05 - let's look at our metamask and boom
191:07 - indeed we have got all of our eth back
191:10 - however looking at this contract we can
191:13 - see that hmm well maybe we don't want
191:16 - anybody to be able to withdraw all the
191:17 - funds in this contract that seems like
191:19 - it might be a really bad idea maybe we
191:21 - only want the funding admin to be able
191:23 - to withdraw funds so how do we set this
191:25 - up in a way that only the contract owner
191:28 - can actually withdraw funds well we
191:30 - learned before
191:31 - that the require function can actually
191:34 - stop contracts from executing unless
191:36 - some certain parameters are met we can
191:38 - do the same thing here with require
191:41 - message.sender
191:43 - equals
191:45 - the owner
191:46 - but we don't have an owner to this
191:48 - contract yet so how do we get an owner
191:50 - to this contract the instant that we
191:52 - deploy it well we could have a function
191:56 - called create owner but what happens if
191:58 - somebody calls this function right after
192:00 - we deploy it
192:02 - well then we wouldn't be the owner
192:03 - anymore
192:04 - so we actually need a function to get
192:06 - called the instant we deploy this smart
192:08 - contract and that's actually exactly
192:10 - what the constructor does so typically
192:13 - at the top of your smart contracts
192:14 - you'll see a constructor
192:16 - and this is a function that gets called
192:18 - the instant your contract gets deployed
192:21 - you don't even need to do add function
192:23 - here we can literally just call it
192:27 - constructor
192:28 - because it's what constructs the smart
192:30 - contract so we'll make constructor
192:33 - public and whatever we add in here will
192:35 - be immediately executed whenever we
192:38 - deploy this contract so one thing that
192:40 - we could do
192:41 - is we could have an owner be set the
192:44 - instant we deploy the smart contract so
192:45 - in the top we could add address
192:49 - owner
192:50 - and in our constructor
192:52 - we could say owner equals message.sender
192:56 - because the sender of this message is
192:58 - going to be us it's going to be whoever
193:00 - deploys this smart contract we can even
193:02 - test this out in the javascript vm to be
193:05 - a little bit quicker because we're not
193:06 - actually going to be calling the fund
193:09 - or the getprice function for now oops
193:11 - let's also make this public so that we
193:13 - can interact and see this owner variable
193:15 - so now if we go to fund me we deploy
193:18 - this in the javascript vm we should be
193:20 - able to see who the owner of this
193:22 - contract is and it should be our address
193:25 - because this constructor function should
193:27 - have been immediately called the instant
193:29 - that we deployed the smart contract
193:31 - awesome we can see the owner of this
193:33 - smart contract is indeed our wallet
193:36 - because remember we're working with the
193:37 - javascript vm our wallet is these fake
193:39 - wallets that they kind of give us
193:41 - we can even try this with an injected
193:43 - web 3
193:44 - with deploying this
193:47 - and the owner
193:48 - should be this
193:49 - ox 757 etc address
193:54 - let's go ahead and look at fundme see
193:55 - the owner and we do indeed see the owner
193:58 - is us okay great
194:00 - now we have an owner
194:02 - we can go down to our withdraw function
194:04 - and use that same require
194:08 - so we can call
194:10 - acquire
194:13 - message.sender
194:14 - equals equals
194:16 - owner equals equals is the way that
194:19 - solidity understands true false we're
194:22 - saying that message.sender has to equal
194:24 - owner now let's go ahead and try this
194:26 - and we'll try with the javascript vm
194:28 - again for speed reasons
194:31 - let's deploy this funding
194:34 - and if we go down here
194:36 - we try to call the withdraw function and
194:38 - it looks like it is successful because
194:40 - currently
194:41 - this is the address that deployed the
194:43 - contract and it's also the address that
194:45 - is calling withdraw
194:46 - however
194:48 - if we switch to a different account
194:50 - and call withdraw you'll see
194:53 - that remix actually freaks out down here
194:55 - it says uh oh something wrong happened
194:58 - and this is essentially the require
195:00 - statement kicking out if you want to try
195:02 - it with injected web 3 as
195:04 - well can absolutely do that too and
195:07 - remember the way to switch accounts in
195:09 - metamask is to either create a count
195:11 - right here or just switch like this
195:14 - and then we'll connect with account two
195:18 - so if i try to withdraw
195:20 - from this
195:21 - second account
195:23 - that didn't call the contract and i hit
195:26 - withdraw now
195:27 - it's going to give us gas estimation
195:29 - failed because the required statement is
195:31 - going to kick out but again if we switch
195:34 - back to account 1
195:36 - and we call withdraw
195:37 - metamask is going to pop up and it's
195:39 - going to allow us to withdraw now
195:41 - obviously there's nothing in this
195:42 - contract right now so we're going to
195:44 - withdraw nothing but we can still call
195:46 - it it's going to do message.transfer
195:48 - 0.
195:50 - so this is great
195:51 - we can now require this withdraw
195:54 - function is only callable by the owner
195:57 - now what if we have a ton of contracts
195:59 - that want to use something like this
196:01 - they require the message.sender to be
196:03 - some owner or maybe it's more
196:05 - complicated than this is there an easier
196:07 - way to wrap our functions and some
196:09 - require or some other executable well
196:12 - this is where modifiers come in we can
196:14 - use a modifier to write in the
196:16 - definition of our function
196:18 - add some parameter that allows it to
196:20 - only be called by our admin contract
196:23 - modifiers are used to change the
196:25 - behavior of functions in a declarative
196:27 - way let's create our first modifier
196:30 - we'll call it modifier
196:33 - which is a keyword
196:35 - only owner
196:40 - and we'll add this require statement in
196:42 - here
196:43 - require message.sender equals owner
196:46 - then after this we just add an
196:48 - underscore and a semicolon
196:51 - what a modifier is going to do
196:53 - is it's going to say hey before you run
196:55 - this function do this require statement
196:58 - first and then wherever your underscore
197:00 - is in the modifier run the rest of the
197:02 - code
197:03 - so we could also do a modifier where the
197:05 - underscore is up here and then this is
197:07 - afterwards but but we want to run the
197:09 - require first
197:10 - so now what we can do
197:12 - is we can make this function withdraw
197:15 - payable
197:16 - only owner public
197:19 - and what's going to happen
197:21 - is before we do this transfer we're
197:23 - actually going to check
197:24 - this modifier we're actually going to
197:26 - run this require message.sender equals
197:28 - owner and then again where this
197:30 - underscore is that's where we'll add the
197:32 - rest of the function
197:34 - so again
197:35 - for speed reasons and since we're not
197:37 - actually going to be interacting with
197:39 - the chain link data contract we can go
197:41 - to javascript vm
197:42 - switch to funding
197:45 - deploy
197:48 - and we can call withdraw
197:50 - obviously we can call withdraw from our
197:52 - account but if we switch accounts and
197:54 - try to call withdraw
197:56 - we're going to get an error which is
197:58 - perfect because that means our modifier
198:00 - is working correctly
198:02 - awesome now we have a fantastically
198:03 - succinct fund me contract here
198:06 - the only thing that we're really missing
198:07 - is that when we withdraw from this
198:09 - contract we're actually not updating our
198:12 - balances of people who funded this
198:14 - so even after with we withdraw this is
198:17 - always going to be the same so we need
198:18 - to go through all the funders in this
198:20 - mapping and reset their balances to zero
198:23 - but how do we actually do that we can't
198:25 - actually loop through
198:27 - all the keys in a mapping when a mapping
198:29 - is initialized every single key is
198:32 - essentially initialized now we obviously
198:34 - can't go through every single possible
198:36 - key on the planet
198:38 - however what we can do is create another
198:39 - data structure an array something we're
198:42 - already familiar with so let's go ahead
198:43 - and create a new funders array that way
198:45 - we can loop through them and reset
198:48 - everyone's balance to zero we'll do an
198:50 - address array
198:51 - because it's going to be an array of all
198:53 - the funders addresses
198:55 - we'll make it public
198:57 - and we'll call it
198:58 - funders
199:00 - now when somebody funds a contract
199:03 - what we're going to do is we're going to
199:05 - do funders
199:06 - now whenever a funder funds this
199:07 - contract we can go ahead and push them
199:10 - onto our funders array
199:12 - so we can do funders
199:13 - dot push message dot sender
199:18 - now if somebody funds multiple times the
199:21 - funders array is going to be a little
199:22 - bit redundant but we're going to ignore
199:24 - that for now now that we have an array
199:26 - of funders when we withdraw everything
199:28 - we're going to want to reset this to 0.
199:31 - when we withdraw everything we want to
199:33 - reset everyone's balance in that mapping
199:35 - to 0. so we're going to do what's called
199:38 - a for loop a for loop is a way to loop
199:40 - through a range of numbers to do
199:42 - something so we're going to say
199:44 - 4
199:47 - you and 256
199:50 - funder index
199:52 - equals zero because we want to start
199:54 - with the zeroth index
199:58 - we're going to give it a max size to go
200:00 - to we're going to say the funder index
200:02 - has to be less
200:03 - than funders dot length
200:07 - dot length is how we get the length of
200:09 - our array
200:11 - and then we're going to say funders
200:13 - index
200:14 - plus plus this means that we have an
200:16 - index variable called funder index
200:19 - and it's going to start from zero
200:21 - this loop is going to finish whenever
200:23 - funder index is greater than the length
200:25 - of the funders
200:26 - every time we finish a loop we're going
200:28 - to add one to the funder index that's
200:30 - what that funder index plus plus does it
200:34 - adds one to the funder index and every
200:36 - time whatever code is in this for loop
200:38 - executes we're going to restart at the
200:40 - top and all we're going to do in here is
200:42 - we're going to grab
200:44 - the address of the funder
200:47 - from
200:48 - our funders array
200:51 - funders
200:53 - so the funder
200:55 - at the index in our funders array
200:58 - we're going to use this
201:00 - as the key in our mapping
201:03 - so we're going to take
201:05 - address to amount funded
201:08 - of funder
201:10 - and we're going to set it equal to zero
201:13 - so now our mapping is going to be all
201:14 - updated to people having xero funded in
201:17 - there
201:18 - we do have to do one more thing as well
201:20 - we have to reset our funder array as
201:22 - well
201:23 - now there's a couple ways to do this but
201:24 - a really easy way is just to
201:27 - set funders equal to a new array so we
201:30 - could do funders
201:32 - equals a new
201:34 - blank
201:35 - address array
201:39 - so all right it looks like we've got
201:41 - everything in here we need right away
201:43 - when we deploy this we are set as the
201:45 - owner
201:46 - we can allow anybody to fund whatever
201:48 - public good that we're doing
201:50 - and they have to fund it with the
201:52 - minimum usd value that we actually set
201:55 - whenever they fund we'll keep track of
201:57 - how much they're funding and who's been
201:59 - funding us we can get the price of the
202:02 - ethereum that they send in the terms of
202:04 - usd
202:05 - and we can convert it to check to see if
202:07 - they're sending us the right amount
202:10 - we have our only owner modifier so that
202:12 - we're the only ones who can withdraw
202:14 - from the contract and when we do
202:16 - withdraw everything from the contract we
202:18 - reset all the funders who have currently
202:20 - participated in our crowdsourcing
202:22 - application
202:23 - awesome let's see if everything works
202:26 - end to end
202:27 - so we're going to go to fundme
202:29 - we're going to deploy it
202:31 - we're going to confirm from metamask and
202:33 - remember if you're ever confused about
202:35 - what's going on or or something weird is
202:37 - happening in your transactions or your
202:39 - deployments you can always go into
202:42 - etherscan and read more about your
202:44 - transaction and what's going on
202:47 - now that our transaction has been
202:49 - deployed let's go ahead and just take
202:51 - inventory as what's going on
202:53 - we have our owner
202:56 - which is our address right here
202:58 - we have the aggregator v3 interface
203:01 - version which is version 3 which we can
203:03 - kind of ignore
203:04 - we have the price of ethereum in terms
203:07 - of usd
203:08 - with 18 decimals instead of 8. we have a
203:12 - function that allows us to get the
203:13 - conversion rate of any ethereum amount
203:15 - to its us dollar equivalent
203:18 - we have an array of funders which right
203:20 - now starts out as empty
203:22 - we have a mapping of addresses which
203:24 - also right now starts out as empty let's
203:27 - go ahead and try to fund this contract
203:30 - we'll use way just that we're always on
203:32 - the same page
203:33 - and we'll fund it with 0.1 away
203:37 - remember everything has 18 decimal
203:39 - places so if we want to do 0.1 we just
203:42 - do 17. so we can do one one two three
203:44 - four five six seven eight one two three
203:47 - four five six seven eight nine and
203:49 - that'll be 0.1 ethereum now we can go
203:52 - ahead and hit fund
203:54 - and we're going to send 0.1 eth to this
203:57 - contract
204:00 - great so if we look at the zeroth index
204:03 - of funders we can see that indeed
204:06 - we have funded this contract
204:08 - let's even have
204:10 - our second account fund this contract
204:13 - so all we got to do is switch
204:15 - to this contract in metamask
204:17 - we can go ahead
204:19 - and put point one eth back in here
204:22 - for value
204:24 - and hit fund
204:26 - now as you can see we're deploying this
204:28 - from account two
204:29 - let's go ahead and hit confirm
204:33 - funder at index zero is going to be our
204:35 - admin and the funder at index one is
204:38 - going to be our second account
204:41 - and if we go ahead
204:43 - and we add
204:45 - this funder in here we can see we've
204:47 - indeed sent point one ether with this
204:50 - account if we go back to our count one
204:53 - and put this in here
204:54 - we can see that that address also has
204:57 - 0.1 ether
204:58 - fantastic
205:00 - so let's try to be malicious let's try
205:02 - to have account number 2 actually
205:04 - withdraw all the funds in here
205:06 - let's hit this withdraw function
205:08 - uh-oh
205:09 - the transaction has failed we're
205:11 - relentlessly malicious we want to send
205:13 - this transaction regardless so even
205:15 - though i'm not the admin of this
205:17 - contract i've gone ahead and still tried
205:19 - to send those withdrawal so what happens
205:21 - now
205:23 - we can see that remix is saying hey
205:26 - something went wrong
205:27 - and again if we look at ether scan we
205:29 - can see that there is a fail here since
205:31 - in our modifier we didn't give a reason
205:33 - here
205:34 - nothing shows up but we could have
205:35 - always put a reason in there and
205:36 - something would show up
205:38 - so all right let's go ahead back to the
205:40 - actual admin
205:42 - and now let's try to withdraw everything
205:45 - so if we hit withdraw now
205:48 - we can go ahead and confirm what should
205:50 - happen is everything in here should be
205:52 - back to zero and this array should be
205:54 - back to zero as well and if we watch our
205:57 - address we can see it literally just
205:59 - went from point four to point six
206:01 - because it got point one from the
206:03 - original funding that this account put
206:05 - in
206:06 - and the 0.1 that our second account put
206:08 - in
206:09 - so now if we look at funder 0 we can see
206:12 - it actually errored because it is now a
206:14 - brand new array and there is nothing at
206:16 - index zero if we try to see how much
206:19 - this address now is funded it's back
206:21 - down to zero awesome you've now learned
206:24 - how to deploy a relatively simple yet
206:26 - effective crowdsourcing application
206:29 - where users can fund and an admin can
206:32 - withdraw those funds to go spend them on
206:34 - things
206:39 - now we've been working with remix so far
206:41 - to start our smart contract in our
206:43 - solidity development journey remix is an
206:45 - incredibly powerful what's known as a
206:47 - web ide or an integrated development
206:50 - environment and in my opinion remix
206:52 - should always be the starting ground for
206:54 - anybody looking to start their smart
206:55 - contract journey because it is a
206:57 - wonderfully friendly way to really show
206:59 - what's going on behind the scenes and
207:01 - it's really easy to see everything we're
207:03 - doing with ethereum with chain link and
207:05 - with our smart contracts now it does
207:06 - have some limitations though it's really
207:09 - hard to integrate other parts of
207:10 - different projects it has some limited
207:12 - support for testing or custom
207:14 - deployments it's a little tricky to save
207:17 - files locally you need an internet
207:19 - connection to actually interact with it
207:20 - and it doesn't have python so in order
207:23 - for us to deploy test and automate
207:26 - everything about our smart contract
207:27 - development cycle we want to connect our
207:29 - solidity and our smart contracts with a
207:31 - more traditional programming language
207:33 - like python this way we can customize
207:35 - our entire development environment in
207:37 - any way that we like we're first going
207:39 - to teach you all how to work with what's
207:41 - known as web3.pi which is an incredibly
207:43 - powerful python package for doing
207:46 - everything that we want to do with smart
207:48 - contracts then once we learn some of the
207:50 - basics of web3.pi then we'll move on to
207:53 - browning which is a smart contract
207:55 - development framework built on top of
207:57 - web3.pi which makes our lives even
208:00 - easier however it's still really
208:02 - important to learn web3.pi first because
208:04 - this will teach you what's going on
208:05 - behind the scenes of brownie
208:11 - now for the rest of this course i'm
208:12 - going to be working with visual studio
208:14 - code which is an incredibly powerful
208:17 - text editor that will give us a lot of
208:18 - formatting and a lot of really nice
208:20 - tools to work with deploying and
208:22 - interacting with our smart contracts if
208:24 - you've already got vs code and python
208:25 - and your entire coding setup set up the
208:27 - way that you like it feel free to use
208:28 - the timestamps in the description to
208:30 - skip ahead to the next section you'll
208:32 - often hear people referring to this as
208:34 - vs code or visual studio code but just
208:36 - to point out this is not what you're
208:38 - looking for right in front of you here
208:39 - visual studio is a different application
208:41 - make sure you're on visual studio code
208:44 - if you want to be a total hardo and just
208:46 - work with vim or emacs or whatever else
208:48 - you want to do you absolutely can but
208:50 - i'm going to go through setting up
208:51 - visual studio code the way that i like
208:54 - it and if you guys want to follow along
208:55 - i highly recommend it because it's going
208:57 - to make your life a lot easier there's a
208:58 - link to download visual studio code in
209:01 - the github repository basically all you
209:02 - have to do is come to the site right
209:04 - here and you can hit this big download
209:05 - button it should recognize what
209:07 - operating system that you're on be it
209:09 - windows be it mac or some other
209:11 - operating system and if it doesn't you
209:13 - can go ahead and hit this little drop
209:14 - down and pick one there so let's go
209:16 - ahead and download visual studio code
209:18 - and open it up
209:21 - awesome once you've downloaded visual
209:23 - studio code this is approximately what
209:25 - you should be seeing
209:26 - there's a fantastic getting started
209:29 - section here where if you're brand new
209:30 - to vs code and you want to learn a
209:32 - little bit more quickly you absolutely
209:34 - can and we have some links as well in
209:36 - our github repository giving you a crash
209:38 - course in vs code if you want to learn
209:40 - more let's set this up though so it's
209:42 - going to be really friendly for us to be
209:43 - doing our smart contract development
209:45 - here so first we want to go to this
209:46 - extensions tab it looks like these
209:48 - little blocks thing right here
209:51 - and first we're going to look up python
209:53 - and you want to install this python
209:55 - extension right here this is going to
209:57 - make our lives a lot easier for
209:59 - interacting with python and doing a lot
210:01 - of things with python
210:04 - then you're going to want to go ahead
210:05 - and download this and install this
210:07 - solidity extension this is going to make
210:09 - formatting our solidity a lot easier now
210:11 - we want to download python if you
210:13 - haven't already so go ahead to
210:15 - python.org
210:16 - let's go to downloads and it should
210:18 - recognize what operating system that
210:20 - you're on and you can just go ahead and
210:21 - hit the download button and then follow
210:23 - the steps to download this i've already
210:25 - got it download so i'm not going to walk
210:26 - through this
210:29 - okay great now that we have python
210:31 - installed one of the other amazing
210:32 - things about vs code is you can actually
210:34 - open a terminal up inside a visual
210:37 - studio code the way you can open your
210:38 - own terminal if this is your vs code
210:41 - you can go over on this top bar to
210:43 - terminal
210:44 - and select new terminal
210:46 - and you'll see something that looks like
210:48 - this
210:49 - it might be a bash it might be a zch it
210:52 - might be a powershell there's a lot of
210:53 - different types of terminals that you'll
210:55 - be able to see by looking right here we
210:57 - can now test to see if python is
210:59 - installed correctly if we type in python
211:02 - space
211:03 - dash dash
211:05 - version
211:06 - we should get something that looks like
211:07 - this the exact version of python doesn't
211:10 - really matter here but ideally you're at
211:12 - least on python 3.8 if python dash
211:15 - version doesn't work you can also try
211:17 - python
211:19 - 3-version now if neither one of those
211:22 - works we actually have a number of
211:24 - troubleshooting tips in the github
211:26 - repository for this course and
211:27 - oftentimes a quick google search on
211:29 - whatever error that you have you'll get
211:31 - a link which will lead you to the answer
211:33 - but if that google search doesn't lead
211:35 - to the answer then just go ahead and
211:37 - drop an issue or conversation associated
211:39 - with your issue on the github repo
211:41 - associated with this course in
211:42 - particular there are a couple of common
211:44 - errors that i've definitely seen a
211:46 - number of times so if you see an issue
211:48 - on your instance that matches something
211:49 - on the screen here definitely 100 be
211:51 - sure to check out those troubleshooting
211:53 - tips sometimes just installing some of
211:54 - these applications is really the hardest
211:56 - part of doing the entire coding journey
211:58 - here so please make sure you have python
212:00 - and vs code installed correctly before
212:02 - moving on and don't be discouraged if
212:03 - this doesn't work exactly the way that
212:05 - it should right away now if you're on a
212:06 - mac you can actually hit control back
212:08 - tick and it will toggle back and forth
212:10 - between having the terminal open and
212:12 - closing it i find this really helpful
212:14 - and i use it all the time instead of
212:16 - hitting
212:17 - the buttons a key tip for productivity
212:19 - is going to be using keyboard shortcuts
212:20 - instead of clicking around all the time
212:22 - you'll be much faster okay great we have
212:24 - python installed we have python and
212:26 - solidity extensions of visual studio
212:28 - code installed let's start working on a
212:31 - new project so in our terminal so in our
212:33 - terminal we can create some folder i've
212:35 - already created a demos folder here
212:38 - you can create one as well if you'd like
212:40 - by doing mkdir
212:42 - demos
212:43 - since i've already done it the file
212:44 - already already exists
212:46 - and then cd into demos
212:51 - you can type clear or if you're on a mac
212:54 - command k to clear the terminal now
212:56 - here's what we're going to be doing
212:58 - we're going to be working with
212:59 - simple storage again the exact same
213:01 - contracts but instead we're going to be
213:03 - using web3.pi
213:05 - so we're going to make a new directory
213:07 - inside of our demos folder slash
213:09 - directory called web3
213:12 - pi
213:13 - simple storage
213:15 - and we're going to cd
213:16 - into this new
213:19 - folder right here now again all the
213:21 - completed code is going to be in our
213:23 - github and there's going to be a link to
213:25 - everything that we do in this folder in
213:28 - this github so you can always refer to
213:30 - that if you get lost and the next thing
213:32 - that we want to do is we want to have
213:34 - our visual studio code know that we're
213:36 - in this folder so we can go ahead and
213:39 - click this files icon and hit open
213:42 - folder
213:45 - and i'm just going to go to this web 3
213:47 - pi simple storage and hit open and
213:49 - another vs code will actually pop up we
213:52 - can see on the left hand side here
213:54 - we have a folder this will show all the
213:56 - different files and folders in our web 3
213:59 - pi simple storage directory let's go
214:01 - ahead and create a file
214:04 - dot sol we can right click on this area
214:07 - and select new file and do
214:10 - simple
214:12 - storage
214:13 - dot soul and then we can go back to our
214:15 - simple storage dot soul in remix copy
214:18 - everything and then paste it into here
214:20 - if you don't have it up remember you can
214:21 - always refer back to the github
214:22 - repository which will have it in there
214:24 - for you awesome now we have our solidity
214:27 - in its own file called
214:29 - simplestorage.soul you'll notice that
214:31 - some of the words are actually
214:32 - highlighted different colors this is
214:34 - known as syntax highlighting and it's
214:36 - due to the fact that we added the
214:37 - solidity extension in it makes reading
214:39 - this code a lot easier now this file is
214:42 - in here we'll see that we have this
214:44 - little dot here
214:46 - whenever you see this little dot this
214:48 - means that your vs code file isn't saved
214:51 - so we want to always save it otherwise
214:53 - when we compile or we go to write a
214:55 - script things might not work correctly
214:57 - so we can save it by going up to file
215:00 - and then selecting save or again you're
215:02 - going to want to learn how to do the
215:03 - keyboard shortcuts because you're going
215:04 - to want to hit save often for mac it's
215:07 - command s and for windows it's ctrl s
215:10 - now the other thing that you'll see is
215:12 - you get this red line here this is vs
215:14 - code's way of telling us it thinks that
215:16 - there's an error at this position so
215:18 - this is really just the extension being
215:19 - a little bit confused here and we can
215:22 - safely ignore this and normally when i'm
215:23 - coding i do just ignore it we're often
215:25 - going to be flipping back and forth
215:27 - between compiler versions so oftentimes
215:30 - this isn't really a helpful warning here
215:31 - but if it is really bothersome you could
215:33 - right click it and do something like
215:35 - solidity change global compiler version
215:37 - or we can go to code
215:39 - preferences
215:41 - settings
215:42 - let's close this so we can see some more
215:43 - things in here we'll look up solidity
215:46 - and we'll come to this solidity
215:48 - extension config what we can do then is
215:51 - scroll down
215:52 - and we can see solidity compile using
215:54 - remote version this will allow us to
215:56 - choose what version we want to compile
215:58 - with if we do 0.6.0
216:01 - and hit save
216:03 - and go back to simple storage you'll see
216:06 - the red line is now gone while we have
216:07 - this up another really helpful piece
216:09 - that we can do here is we can add what's
216:12 - called a formatter so if we scroll down
216:14 - to solidity formatter you'll see that
216:16 - this enable slash disables the solidity
216:18 - formatter we can go from none to
216:21 - prettier then we'll also look up format
216:24 - on save and we want to make sure we have
216:27 - this editor format on save check marked
216:30 - what we can do then is we can come over
216:32 - to simplestorage.sol
216:34 - and
216:35 - maybe i've got some bad formatting in
216:36 - here we'll move over favorite number
216:38 - string name and put a whole bunch of new
216:41 - spaces in here or something
216:43 - now if i hit save it automatically
216:45 - reformats our file to look a lot nicer
216:48 - so to recap we want to turn on format on
216:51 - save and if you get issues with a red
216:52 - line under pragma solidity you can just
216:54 - change the compiler version in your
216:56 - settings here now while we're in here
216:58 - we're also going to go ahead and set up
217:00 - our python formatting as well
217:02 - so the first thing that we're going to
217:03 - do is we're going to install the black
217:06 - python formatter so we're going to open
217:07 - up our terminal here
217:09 - and whenever you install python it comes
217:12 - pre-installed with this package called
217:14 - pip to check to see if you have pip
217:16 - installed correctly run pip dash dash
217:18 - version
217:20 - now we can install the black formatter
217:22 - by running pip
217:24 - install
217:25 - black
217:27 - i already have it installed so it's
217:28 - going to be pretty quick for me
217:30 - then we'll come to our settings
217:33 - and we'll look up
217:34 - python
217:36 - formatting
217:38 - and we'll scroll down
217:42 - to python formatting provider you might
217:44 - have autopet bait or none in here you're
217:47 - going to want to change it to black
217:49 - this way whenever we save our python
217:51 - files now they will also get
217:53 - automatically formatted to be very
217:54 - readable and really nice and just to
217:56 - note for my demos in solidity i don't
217:59 - always have format on save for solidity
218:01 - i do have format on save for my python
218:03 - but i'm still going to highly recommend
218:05 - you have format on save for both your
218:06 - python and for your solidity anyways so
218:09 - how are we going to actually deploy this
218:11 - well this is where our python is going
218:13 - to come into play
218:15 - let's go ahead and create a new file on
218:17 - the left here
218:18 - and we'll call it
218:20 - deploy dot pi now let's go into this
218:23 - deploy.pi file and let's start actually
218:26 - figuring how we can deploy this in
218:28 - python and this is the part of the
218:30 - course where we start using python here
218:32 - if you're unfamiliar with python or a
218:34 - little bit weaker on python there is a
218:36 - fantastic free code camp course that
218:38 - goes through all the basics of python if
218:40 - you want to learn more i definitely
218:41 - recommend checking it out however we are
218:43 - going to walk you through all the
218:45 - scripts that we write anyways so don't
218:46 - be afraid to just jump in and follow
218:48 - along with what we're doing here even if
218:50 - you have no experience so the first
218:52 - thing that we're going to want to
218:52 - actually do is read this simple storage
218:55 - solidity file we need to get this into
218:58 - this deploy script so that our python
219:00 - file knows what it's going to deploy so
219:02 - how do we do this well we're going to
219:04 - type with
219:05 - open
219:08 - quote dot slash
219:11 - simple storage dot sol
219:14 - comma r
219:16 - as file
219:19 - simple
219:20 - storage file equals file dot read now
219:23 - what is this actually doing
219:26 - well it's saying that we're going to
219:28 - execute some code
219:29 - inside this indented area
219:32 - after the colon and then once this code
219:34 - is finished we're actually going to
219:36 - close this file because right now we're
219:37 - opening it we're going to close it once
219:39 - it's done
219:40 - the file that we're going to open is
219:42 - going to be this simple storage.sol
219:43 - which is located right here in this same
219:46 - directory that we're in we're going to
219:48 - only read from it and we're going to
219:50 - call it file and then we're going to
219:51 - read all the contents of this file and
219:53 - place it in a variable simple storage
219:55 - file
219:56 - so then we can go ahead and write a
219:58 - print statement print simple storage
220:00 - file and if you hit save here you'll see
220:01 - that it automatically gets formatted
220:03 - which is really nice if you want to run
220:05 - black yourself you can just type black
220:07 - dot and it'll automatically format all
220:10 - the python files in your folder here
220:12 - you'll know that you're doing it right
220:14 - if you add a whole bunch of new lines
220:16 - and then save it anyways enough on
220:18 - formatting let's head on down to the
220:20 - terminal and let's call python deploy.pi
220:25 - and we can see
220:26 - our terminal printed everything in
220:29 - simple storage file
220:31 - which is perfect now our python script
220:34 - has what it needs to actually get
220:35 - started working with our solidity now
220:38 - something you'll see i do a lot is i
220:40 - save a lot and if you're looking for
220:41 - some keyboard shortcuts you can always
220:43 - do command p add a little bracket here
220:46 - and look
220:47 - up keyboard shortcuts reference
220:50 - and click this
220:51 - it'll bring you to this keyboard's
220:53 - reference page based off of what
220:54 - operating system that you have all right
220:56 - great so now that we can actually read
220:58 - from our simple storage.soul file we
221:01 - actually have to compile it because
221:02 - remember back in remix every single time
221:05 - we did anything with our files we had to
221:07 - compile them first
221:09 - so we need some compiler in python
221:12 - luckily there is a fantastic python
221:13 - package called pi silk x that does
221:16 - exactly this now i also want to point
221:18 - out though that pi silk x is actually a
221:20 - fork of this package called pi silk now
221:23 - you can still use pysol however i'm
221:24 - going to highly highly recommend that
221:26 - you use pi silk x instead as pike sulk x
221:29 - is a lot more actively maintained than
221:31 - ethereum pixel we can install it with
221:33 - pip install pi sulk x we could even hit
221:36 - this little copy button move back on
221:38 - over here paste it in and hit enter
221:41 - again i've already installed it so it's
221:42 - pretty quick for me the way that we can
221:43 - use it now is by importing it into our
221:45 - python here so we'll say from
221:48 - sulk x
221:49 - import
221:51 - compile
221:53 - standard compile standard is going to be
221:54 - this main function that we actually use
221:56 - to compile this code so let's go ahead
221:58 - and compile
222:00 - our solidity
222:01 - we're going to save our compiled code to
222:03 - a variable called
222:05 - compiled soul
222:08 - this is going to be equal to
222:11 - us calling this compile standard
222:12 - function
222:13 - but we're going to add a lot of
222:15 - variables and a lot of parameters into
222:17 - this function here first we have to add
222:18 - is a language
222:21 - which in this case is
222:23 - solidity we're going to add in some
222:25 - sources
222:27 - which we're going to say our sources are
222:29 - going to be simple
222:32 - storage.soul
222:34 - and it's going to have some
222:36 - content which is equal to this simple
222:39 - storage file variable that we made
222:42 - oh excuse me this all has to be in a
222:45 - bracket piece as well
222:47 - and see if i hit save here it auto
222:49 - formats which is really nice and another
222:51 - quick tip you can see how even my
222:52 - brackets are highlighted in these fun
222:54 - colors if we go down to extensions and
222:56 - look up
222:58 - bracket
222:59 - you can add this bracket pair colorizer
223:01 - which will help make the brackets look a
223:03 - little bit nicer kind of as you see here
223:05 - you can go ahead and install that as
223:06 - well anyways then we'll add some
223:08 - settings
223:12 - and a lot of this is a little bit lower
223:13 - level stuff than what you're really
223:14 - going to have to know or use so i'm not
223:16 - going to go too deep into everything
223:18 - that's actually going on here for now
223:19 - but in our settings
223:20 - we're going to choose an output
223:22 - selection
223:25 - which is going to choose what we output
223:27 - when we compile this
223:29 - we do a little star here
223:35 - and in the star we're going to do
223:36 - another star
223:40 - we're going to choose our output list
223:41 - we're going to get an abi out that's
223:43 - incredibly important which we've talked
223:45 - about before
223:46 - we're going to get some metadata
223:48 - we're gonna get an evm dot byte code
223:51 - we're gonna get an evm dot
223:54 - source map
223:55 - that's pretty much it again i'm not
223:56 - gonna go too deep into what this output
223:58 - selection and what these settings are
224:00 - actually doing but if you want to learn
224:01 - more you can go to the home page of pi
224:03 - sulk x
224:04 - scroll down to the documentation section
224:07 - and read more in the docs on what you
224:08 - can actually put and all the different
224:10 - features that this actually has the last
224:11 - thing we're going to do is we're going
224:12 - to add a sulk version or solidity
224:14 - version we're going to say
224:16 - sulk
224:18 - version
224:20 - equals and then we'll choose the version
224:21 - that we want to use so we'll put in
224:23 - 0.6.0
224:26 - and then what we should be able to do is
224:28 - print out
224:29 - this compiled soul
224:32 - and we'll see just a whole bunch of
224:34 - really really low level stuff
224:36 - so let's go ahead and run this we'll run
224:38 - python
224:39 - deploy.pi
224:41 - and you'll see we get this
224:42 - massive object here which has a whole
224:45 - bunch of basically unreadable pieces but
224:47 - this is a lot of the low-level code that
224:49 - actually gets compiled whenever we use
224:51 - the compiler in remix or now in python
224:53 - remix actually does the exact same thing
224:56 - once we compile something on remix you
224:58 - can actually copy the bytecode if you
225:00 - hit this little
225:01 - copy button and copy the bytecode and
225:03 - come back to your vs code and create a
225:05 - new file a keyboard shortcut to create a
225:07 - new file is command n and we paste
225:10 - everything
225:11 - we can see there's a whole bunch of
225:12 - stuff in here these op codes are the low
225:15 - level code that our contract is actually
225:18 - doing that actually governs how this
225:20 - code works this is what our written code
225:21 - is getting compiled down to so solidity
225:24 - can actually read it and understand
225:25 - what's going on you'll also see this
225:26 - thing called abi which is in remix and
225:30 - we're even going to output it right here
225:32 - we have this abi thing now in remix if
225:34 - you hit copy the button on the api
225:37 - come back
225:38 - create new file paste it you can see we
225:40 - have this long json object this is that
225:43 - application binary interface that we've
225:45 - talked about so much you can see that
225:46 - it's actually describing all the
225:48 - functions and variables
225:50 - so for example
225:52 - we have a function
225:53 - called add person
225:55 - and it takes two parameters a name
225:58 - and a favorite number
225:59 - so we have this input section for the
226:01 - function and we have this section that
226:03 - describes what the function can is
226:05 - actually doing so the name is ad person
226:08 - it doesn't have a return type it's
226:10 - non-payable and it's a function and we
226:12 - can see that for pretty much everything
226:14 - in here this is the lowest digestible
226:16 - way to say hey here's where all the
226:18 - functions are here's what the parameter
226:20 - types are here's what the return types
226:22 - are going to be and everything like that
226:23 - so we're going to close it out for now
226:24 - though so this is fantastic we've now
226:27 - compiled our solidity typically i
226:29 - usually also like to output it and print
226:32 - it out to a file as well so to do that
226:35 - we'll do with
226:37 - open
226:39 - compiledcode.json
226:42 - and this time instead of reading we're
226:44 - going to write
226:45 - and we'll call this as file as well
226:48 - instead of doing file.write we're going
226:50 - to do what's called a json.dump
226:54 - compiled soul file
226:57 - we do need of course to import
227:00 - json also just a note i know it says
227:02 - we're using sulk here but please use
227:04 - sulk x still i ended up filming a little
227:06 - bit of both versions so i did a little
227:08 - bit of a mix and match but please use
227:10 - sulk x even if you see seoul what this
227:12 - line is going to do
227:13 - is it's going to take our compiled soul
227:15 - jason variable and just dump it into
227:18 - this file here
227:19 - but it's going to keep it in the json
227:21 - syntax so it's still going to be json e
227:24 - so now if we run python deploy.pi we'll
227:26 - see we have a new file in here called
227:28 - compilecode.json
227:30 - the other reason that i wanted to do
227:32 - this was because
227:33 - if i hit control s
227:35 - it actually formats this into a readable
227:38 - way now again we can go into these
227:40 - settings here
227:41 - we can look up
227:44 - json and we can do enable json formatter
227:48 - and this will automatically make it so
227:50 - that we format this json so it's a lot
227:51 - more readable again the reason i like to
227:54 - output this is because this abi is so
227:56 - important and we're going to use it so
227:57 - much that i like to kind of be able to
227:59 - see it and and read through it really
228:01 - quickly the rest of this lower level
228:03 - stuff like evm and byte codes and op
228:05 - codes we don't really work with so much
228:08 - however as you learn more and more about
228:09 - solidity you'll probably see more and
228:11 - more of opcode so if you really want to
228:13 - learn a lot of really low-level stuff
228:16 - look into opcodes but for the purpose of
228:17 - this tutorial we're not going to be
228:18 - going too deep into it okay awesome so
228:21 - we've compiled our solidity we've even
228:23 - stored our solidity code to this
228:26 - compiledcode.json file
228:28 - now what do we do we probably want to
228:30 - deploy it and test it out
228:32 - so how do we actually do that well first
228:34 - we actually have to get the bytecode we
228:36 - need the bytecode of the file so that we
228:38 - can actually deploy it so we're going to
228:39 - do
228:40 - bytecode
228:42 - equals
228:44 - compiled soul
228:47 - contracts
228:52 - simple storage dot sol
228:57 - simple storage
229:00 - evm
229:03 - white code
229:06 - object
229:08 - all right great there we go so now we
229:09 - have our byte code we also need to get
229:12 - our abi so we need to get the api so
229:15 - what we're doing here when we're typing
229:17 - in all these words like contract simple
229:19 - storage simple storage
229:21 - is we're walking down the json here so
229:23 - when we say we want to get the byte code
229:25 - in this compiled solidity json we want
229:27 - to go to contracts
229:29 - simple storage symbol storage evm byte
229:31 - code
229:32 - so contracts inside this contracts json
229:35 - you got to go to simple storage inside
229:37 - this simple storage dot soul there's
229:39 - another simple storage
229:41 - inside that there's an avi but that's
229:43 - not what we want we want the evm so
229:45 - we're going to scroll down
229:47 - we're going to get the evm then what do
229:49 - we want then we want the bytecode great
229:52 - and then we want the object so this
229:54 - is the bytecode of our contract
229:57 - it's the really low level stuff that
229:59 - the ethereum virtual machine or the evm
230:02 - is going to understand now we also need
230:04 - the avi when we deploy this to a chain
230:07 - this is what we're going to need we need
230:08 - the byte code and the abi the abi we can
230:12 - of course get from this kind of same
230:14 - method here so to get this we can do abi
230:18 - equals
230:19 - compiled soul
230:21 - same thing
230:22 - contracts
230:27 - simple storage dot soul
230:33 - simple storage
230:34 - and as you can see
230:35 - we're right here and then we can just
230:37 - grab this api object
230:40 - avi
230:41 - and we can even do print api we'll do
230:44 - python develop.pi
230:46 - and indeed our abi is printed here
230:49 - awesome so now that we have our two main
230:51 - pieces to deploy this now all we have to
230:52 - do is deploy it but the question then
230:54 - becomes is where are we going to deploy
230:56 - it to which blockchain are we going to
230:58 - deploy to in remix
231:00 - when we were first playing around
231:02 - we were using a javascript vm
231:05 - or a fake or a simulated environment we
231:08 - absolutely could and we absolutely will
231:10 - learn to deploy this to a test in
231:13 - because that's going to be the same way
231:14 - that we're going to deploy to a mainnet
231:16 - but before we do that we should learn
231:18 - how to deploy this on a simulated
231:20 - environment or something similar to that
231:22 - javascript vm so it's much faster and
231:24 - easier to test things and this is where
231:26 - ganache is going to come to the rescue
231:28 - ganache is a simulated or a fake
231:31 - blockchain that we can actually use to
231:33 - deploy our smart contracts to and have
231:35 - it interact like it's a real blockchain
231:37 - ganache is going to allow us to spin up
231:39 - our own local blockchain
231:45 - and it'll look something like this now
231:46 - the user interface is really nice
231:48 - because it allows us to kind of do this
231:50 - one-click blockchain to create our own
231:52 - local blockchain
231:54 - that means that this blockchain isn't
231:56 - connected to any other blockchain out
231:58 - there but it'll act like a blockchain
232:01 - but it'll be a lot faster than us having
232:03 - to interact with a testnet and we
232:05 - control the entire blockchain because
232:07 - it's only one node we're the only node
232:10 - so ganache great way to test things
232:11 - quickly now we're going to mainly we're
232:13 - working with the user
232:14 - but i'm also going to show you how to
232:15 - work with the ganache command line you
232:17 - can really use either one depending on
232:19 - what you want to do but a lot of the
232:20 - tools actually have built-in ganache
232:22 - command lines so it's definitely really
232:24 - useful to learn that as well so again
232:25 - ganache is going to be our simulated
232:27 - environment here so what we're going to
232:29 - do
232:29 - once we get into ganache we can just go
232:31 - ahead and hit quick start this will
232:34 - automatically upload and get started
232:36 - with our own local fake blockchain you
232:40 - can even see it gives us some accounts
232:42 - this should look pretty familiar it
232:44 - should look very meta-masky right we
232:46 - have an address here
232:48 - and each one of these addresses has a
232:50 - private key in your ganache you can go
232:52 - ahead and just click the key and hit
232:54 - show keys and it'll show you the account
232:56 - address and the private key but of
232:58 - course these are for development
233:00 - purposes only each one of these accounts
233:03 - has a balance associated with it we can
233:04 - see a mnemonic or your secret phrase you
233:07 - can see blocks transactions and a whole
233:10 - lot of other really useful features here
233:12 - and it even tells us
233:14 - how to connect to this blockchain
233:17 - and these are the connecting features
233:19 - that we're going to want to use let's
233:20 - learn how to connect to this ganache
233:22 - blockchain from this user interface
233:24 - first and then we'll learn how to do the
233:26 - command line version this is when we
233:28 - finally start working with web3.pi you
233:31 - can just do pip
233:33 - install
233:34 - web3
233:36 - and now we can start working with
233:38 - web3.pi right at the top a little
233:40 - confusingly
233:41 - we're going to do import
233:43 - web3
233:44 - from
233:45 - web3 whoops and this should be
233:48 - from web3 import web3 sorry about that
233:51 - now to connect to this blockchain we
233:53 - choose what's called an http provider if
233:56 - we look at this ganache instance we have
233:58 - this rpc server which has this url http
234:02 - 0.0.0
234:05 - this is the url that we're going to use
234:07 - to connect to this blockchain in remix
234:10 - we're actually using our metamasks
234:12 - directly to connect to the blockchain
234:14 - however we want to connect directly to
234:16 - our simulated our fake blockchain right
234:19 - here so what we're going to do is we're
234:21 - going to do
234:22 - w3
234:24 - for
234:25 - connecting to ganache
234:28 - w3 equals
234:30 - web3 web3.http
234:35 - provider
234:37 - of http
234:40 - 0.0.0.0
234:42 - and it was on port
234:44 - 845.
234:47 - port 845. now with everything that we
234:50 - show you you're probably going to want
234:51 - to get really familiar with the
234:52 - documentation because even after being a
234:54 - pro you're going to want to use it more
234:56 - and more if you want to learn more about
234:57 - other providers you can go to the
234:59 - providers page of the documentation the
235:01 - next thing that we're always going to
235:02 - need as well is we're going to need the
235:04 - chain id or the network id what is the
235:08 - id of this blockchain
235:10 - and for ganache it's one three three
235:12 - seven
235:13 - supposed to be a funny leat reference so
235:16 - we'll do chain id
235:20 - equals
235:22 - one three three seven
235:24 - now
235:27 - we're also going to need an address
235:30 - and address to deploy from
235:32 - we can go ahead and grab one of these
235:34 - fake addresses in here to work with
235:38 - similar to how in remix when we were
235:40 - working with the javascript vm we were
235:42 - given a bunch of fake addresses we're
235:44 - doing the same thing but with ganache
235:46 - and then we're also of course going to
235:48 - want a private key
235:50 - we need the private key of course to
235:51 - sign our transactions
235:54 - so we'll do private key equals
235:57 - this
235:59 - now just note whenever you import a
236:00 - private key in python you need to add an
236:03 - ox to the front python is always going
236:05 - to look for the hexadecimal version of
236:07 - the private key awesome now we have all
236:09 - the parameters that we need for
236:11 - interacting with and connecting to our
236:13 - ganache local chain it's time to finally
236:15 - deploy our simple storage.soul contract
236:18 - let's do it so the credit contract that
236:19 - we're going to deploy with web3.pi we're
236:21 - going to do simple storage
236:23 - we're going to call this variable
236:25 - w3
236:26 - dot f
236:28 - dot contract
236:30 - and we're going to give it abi equals
236:32 - abi
236:33 - and byte code equals byte code great
236:36 - does this mean we've deployed it well no
236:38 - this just means we have a contract down
236:41 - so we can do print simple storage and
236:43 - you'll see if we run python
236:45 - deploy.pi
236:48 - we'll see we have a new type here
236:50 - class web3.utils.datatype.contract
236:54 - this is another type that if you want to
236:56 - learn more you should definitely check
236:58 - out the web3.pi documentation so we have
237:00 - a contract object
237:02 - awesome how do we actually deploy this
237:05 - well we need to actually build our
237:07 - transaction
237:08 - because again whenever we interact with
237:10 - the blockchain whenever we make a state
237:12 - change and in this case we'd be
237:13 - deploying a contract we're going to make
237:15 - a state change so we first need to build
237:17 - a transaction sign a transaction
237:20 - and then send a transaction and to do
237:22 - that we need to talk about that nuns
237:24 - thing again remember way back in our
237:25 - blockchain demo when we used a nuns to
237:28 - solve the answer to that really
237:29 - difficult mining problem well the
237:31 - definition of nuns is just a word coined
237:34 - or used for just one occasion and in
237:36 - cryptography it's an arbitrary number
237:38 - that can be used just once in a
237:40 - cryptographic communication so this nuns
237:43 - that's used to find the answer is going
237:44 - to be different from another nuns that
237:46 - we're actually going to need to make our
237:48 - transaction see if we look at our meta
237:50 - mask and we look at our activity
237:52 - and we look at one of the transactions
237:54 - we've made recently on etherscan
237:56 - if we scroll down we'll see nuns
237:59 - here as well this nunce is the number of
238:01 - transactions that our account has
238:03 - actually made every time we make another
238:05 - transaction our transaction is hashed
238:07 - with a new nuns this is what's going on
238:09 - behind the scenes with our transaction
238:12 - and we need this to send our transaction
238:14 - we can actually get our nuns by just
238:16 - grabbing our latest transaction count
238:18 - get
238:19 - the latest
238:21 - transaction we can do
238:23 - nonce equals w3
238:26 - dot eth dot
238:28 - get transaction count and we'll put in
238:32 - my address
238:34 - this will give us the number of
238:35 - transactions and it'll effectively give
238:37 - us our nuns
238:39 - we can even test it out with a print
238:41 - python
238:42 - deploy
238:45 - we can see we can see that the answer is
238:47 - zero because on our local blockchain
238:50 - this address that we're using hasn't
238:51 - been used before we can even go to the
238:53 - transactions tab we can see that there
238:55 - are no transactions that have ever
238:57 - occurred on our local blockchain now to
238:59 - deploy this contract we need to make a
239:01 - transaction remember everything that we
239:03 - do every time we change the state of a
239:05 - blockchain we're going to do it in a
239:06 - transaction let's create a transaction
239:08 - object to do this we can do
239:11 - transaction
239:12 - equals
239:14 - symbol storage which again is this
239:16 - contract object
239:18 - dot
239:19 - constructor
239:22 - dot build transaction
239:24 - now as you might have pointed out our
239:26 - simple storage.sol doesn't actually have
239:28 - a constructor every contract technically
239:30 - has a constructor this one's is just
239:33 - blank we're not telling our simple
239:35 - storage.soul to do anything
239:37 - we saw back in our fund me
239:39 - example that the fund me example does
239:41 - have a constructor so now we want to put
239:43 - in some parameters for the transaction
239:45 - in web3.pi we always have to give at
239:47 - least a couple of parameters
239:49 - we always have to give the chain id
239:52 - which we already got from above which is
239:54 - one three three seven
239:56 - so we can just do chain id
239:59 - we need a from
240:00 - address in this case
240:03 - my address
240:08 - and then
240:09 - we need a nuns
240:11 - which in our case is just nuts
240:13 - great now we have a transaction object
240:16 - let's even print this out and see what
240:17 - it looks like
240:20 - whoa what's this we can see there's even
240:24 - more parameters in here than just what
240:25 - we made
240:27 - so we have value which is the ether or
240:30 - the ethereum that we're going to send we
240:31 - have gas we have our gas price which we
240:33 - could arbitrarily set if we'd like
240:36 - we have the chain id we have from
240:38 - address we have the nuns
240:40 - and then we have this giant data object
240:43 - and then two is just empty because it's
240:46 - sending it to the blockchain this giant
240:47 - data object here is encompassing
240:49 - everything that's happening in this
240:51 - simple storage dot sol now that's just a
240:53 - transaction and anybody could actually
240:55 - send this transaction as long as it's
240:57 - signed by them so we have this
240:58 - transaction but we need to sign it from
241:00 - somebody since we're sending it from our
241:02 - address
241:03 - our private key is going to be the only
241:05 - key that's going to work to sign this
241:07 - remember back when we were talking about
241:08 - public and private keys we right now
241:10 - have a message that is defining how to
241:12 - deploy simple storage but it's not
241:14 - signed yet so we're going to need to use
241:16 - our private key to sign it to create
241:19 - this unique message signature that we're
241:21 - the only ones that can create the
241:23 - private key but anybody else can verify
241:25 - that it was us who signed it so now
241:28 - signed
241:29 - transaction
241:30 - equals web3
241:33 - dot eth
241:34 - dot account
241:36 - dot sign transaction
241:39 - and the parameters it takes are going to
241:40 - be transaction
241:42 - and then private key
241:45 - we're gonna say the private key equals
241:47 - private key because above we've actually
241:49 - gone ahead and added our private key in
241:51 - here now guys a really really important
241:54 - note about putting a private key in your
241:56 - code this is really bad practice if you
241:58 - push this to source or you push this to
242:00 - github somebody else can see your
242:02 - private key and steal all your funds so
242:05 - we don't want to hard code our private
242:07 - keys in our code like we're doing here
242:09 - so let's take this time to talk about
242:10 - environment variables and how to set
242:12 - them environment variables are variables
242:14 - that you can set and that we set in our
242:16 - terminal and in our command lines the
242:19 - following is a way to set an environment
242:20 - variable in macos and linux only don't
242:23 - worry we'll show a way to make an
242:24 - environment variable in windows as well
242:26 - you can set an environment variable by
242:28 - running something like export
242:30 - private key
242:32 - equals
242:34 - and then adding whatever variable that
242:35 - you want
242:38 - now if you type echo
242:40 - dollar sign private key
242:43 - this variable actually shows up to set
242:45 - environment variables with windows the
242:47 - process that we're going to do is
242:48 - actually a little bit different
242:50 - i've left a link in our github to
242:52 - actually set environment variables in a
242:54 - windows setting
242:55 - and we've left a couple of really
242:57 - helpful links for working more with
242:58 - environment variables you should
242:59 - definitely check them out it's important
243:00 - to note that this export method that
243:02 - we're doing here for creating
243:04 - environment variables only works for the
243:06 - duration that our shell is live so if we
243:08 - were to close out of our shell and then
243:10 - reopen it our environment variable that
243:12 - we set would be gone so we'd have to
243:14 - re-run that export command we're gonna
243:16 - show you a way to set environment
243:17 - variables so that you don't have to keep
243:19 - doing that now it's also not great to
243:20 - have in plain text on your computer
243:22 - however it's a lot better than hard
243:24 - coding it into our script here now
243:26 - remember if you're using an account that
243:28 - has real money in it which i highly
243:29 - recommend you do not do don't send this
243:32 - environment variable or this private key
243:34 - or any of this code anywhere because
243:35 - then people can steal all your funds
243:37 - once we move to brownie we'll show you a
243:38 - more effective way for private key
243:40 - management but for now be cautious here
243:42 - but if you followed along and set up a
243:44 - brand new account that has no real money
243:45 - and only test that money in it then
243:47 - great who cares because it's test and
243:48 - it's fake money anyways
243:51 - i think i've talked about it enough
243:52 - anyways let's get back to it we can
243:53 - actually access this environment
243:55 - variable in python using os.get env
244:02 - we just need to import os
244:04 - and now we can access our private key in
244:08 - our script without actually hard coding
244:10 - it in
244:11 - let's see what happens if we do print
244:13 - private key python deploy to pi
244:16 - you can see our python script was able
244:18 - to pull our private key from our
244:19 - environment variable the other thing
244:21 - that we can do is create a dot env file
244:23 - a dot emv file is typically where people
244:26 - store environment variables it's
244:27 - important to not push these to source if
244:29 - this is what you're going to do in this
244:31 - dot envy file in python we can just do
244:34 - export
244:35 - private key and then same as what we did
244:37 - before
244:38 - add the 0x at the start and then private
244:40 - key so we could put 100 environment
244:42 - variables in here
244:44 - export
244:45 - some
244:46 - other var equals
244:48 - seven
244:50 - if you're going to do it in this way
244:52 - please please please
244:53 - always set a dot git ignore
244:57 - and make sure dot env is in here this
245:00 - will help make it harder for you to
245:02 - accidentally push your env folder or
245:04 - your emp file to github python actually
245:06 - has a way of loading directly from a env
245:09 - file without having to export our
245:11 - environment variables or run source.env
245:13 - or export or really anything and we can
245:15 - do it with this python.env package
245:19 - if we close our shell and then reopen it
245:21 - if we run echo
245:23 - some other var
245:26 - we're going to get none here and in fact
245:28 - if we run
245:30 - python develop.pi when we print this
245:32 - environment variable we're going to get
245:34 - none
245:35 - however we can use this.env to have it
245:38 - pulled directly from our.emv so we just
245:40 - do pip
245:42 - install
245:43 - python.env
245:45 - i've already downloaded it so it just
245:47 - says requirement already satisfied and
245:49 - then
245:50 - what we can do at the top of this we can
245:52 - do from
245:53 - dot env
245:55 - import
245:56 - load.enb and we can run
245:59 - a load.enb function right at the top
246:02 - this load.env looks for this.env file
246:05 - and automatically imports it into our
246:07 - script so if we run this now you'll see
246:09 - that the environment variable was
246:10 - successfully imported into our script
246:12 - and now we can use it so let's let's use
246:14 - it for example with our private key
246:16 - private key
246:17 - equals os that get
246:24 - private key now we can even print it out
246:29 - just a test
246:32 - we'll run our script
246:34 - and awesome
246:35 - we can see our private key is being
246:36 - successfully pulled in and we didn't
246:38 - hard code it into our application
246:40 - all right let's get back down to our
246:41 - signed transaction here now let's go
246:43 - ahead and print this out and take a look
246:44 - at what this looks like now we can run a
246:46 - script and great what we see here is an
246:49 - example of a signed transaction remember
246:52 - this is exactly what's happening when we
246:54 - were looking back at public private keys
246:56 - we are signing a transaction that is
246:58 - actually deploying a contract to the
247:01 - blockchain that anybody can easily
247:03 - verify all right so we finally have our
247:05 - signed transaction now we want to send
247:07 - this to the blockchain so it actually
247:08 - can deploy let's send
247:11 - the signed transaction
247:13 - we can do transaction hash
247:16 - equals
247:19 - web3.eth
247:22 - here's a little helpful tip if you see
247:23 - this little box underneath with
247:25 - suggestions show up and you just hit tab
247:27 - it'll auto complete the rest of your
247:29 - text here that's send raw transaction
247:33 - and we'll give it
247:34 - our sign transaction
247:36 - dot
247:38 - broad transaction this will send our
247:41 - transaction to the blockchain now if we
247:42 - look at our local ganache and we look at
247:44 - transactions right now it'll be empty
247:47 - but let's see what happens when we run
247:49 - this script
247:52 - okay so we didn't print anything out but
247:53 - if we go to our ganache we can see that
247:56 - a transaction actually did go through
247:58 - it was from the address that we put in
248:00 - here we created a contract at this
248:03 - address
248:06 - this is how much gas it used
248:08 - and this is how much value was sent with
248:10 - it we can even click on it to see more
248:12 - information about this now this is the
248:14 - other advantage of doing this locally is
248:16 - that the transaction automatically went
248:19 - through we've sent our first transaction
248:21 - to a local blockchain and this
248:24 - transaction is deploying a contract
248:26 - great work you can already see how much
248:28 - faster this is than working with a test
248:30 - net one other thing that's really good
248:32 - practice whenever sending a transaction
248:34 - is we wait for some block confirmations
248:36 - to happen
248:37 - so we can do
248:39 - transaction
248:41 - receipt
248:42 - equals web3 dot eth
248:45 - wait
248:46 - for transaction receipt
248:49 - txhash
248:50 - this will have our code stop and wait
248:52 - for this transaction hash to go through
248:54 - awesome so i just ran it again and if we
248:56 - go to transactions
248:58 - we can now see that there are two
248:59 - transactions here
249:01 - and our code waited a little bit longer
249:03 - for this one to complete so of course
249:05 - we've deployed a contract but how do we
249:07 - actually interact and work with the
249:08 - contract let's start doing that so when
249:10 - working with contracts and we're working
249:12 - with on chain whenever we work with a
249:14 - contract we always need two things
249:17 - we need the contract address and the
249:20 - contract abi often times if you're
249:22 - looking for a specific abi of a type of
249:24 - contract you can usually just google it
249:27 - so we need to make a new contract object
249:29 - to work with contracts let's go ahead
249:31 - and create this simple storage contract
249:33 - so we can actually interact with it
249:35 - so we'll do simple storage
249:38 - equals
249:41 - dot w3.eth.com now we need our address
249:45 - which we can get from ganache
249:48 - but that might be a little bit hard to
249:49 - always be checking the blockchain for a
249:51 - transaction
249:52 - it's actually also in this transaction
249:54 - receipt address
249:56 - equals transaction receipt dot contract
250:00 - address
250:01 - and then since we've compiled this we
250:04 - also have our abi already
250:08 - abi
250:09 - equals abi
250:11 - sometimes you'll see people have a file
250:14 - called
250:15 - abis.pi or abis.json or something like
250:18 - that and they'll load apis in directly
250:20 - from there and great now that we have
250:22 - the address and the api we can start
250:25 - interacting with this contract exactly
250:27 - as we did in remix so let's do a print
250:29 - statement to get that initial value that
250:31 - is returned from our retrieve function
250:36 - remember it should be initialized to
250:38 - zero
250:40 - so if we do print
250:42 - simple storage dot functions
250:45 - dot retrieve
250:50 - let's see what happens here
250:53 - huh what's this
250:55 - we get this function retrieve bound to
250:58 - in these parentheses here
251:00 - so what's going on when making
251:01 - transactions in the blockchain there's
251:03 - actually two different ways that we can
251:04 - interact with them we can interact with
251:07 - a call
251:09 - or we can interact with a transact when
251:11 - we use a call
251:13 - this is just to simulate
251:16 - making the call
251:19 - and getting a return value
251:22 - calls don't make a state change to the
251:24 - blockchain and it's similar to how in
251:26 - remix we would call these blue buttons
251:28 - and nothing on the blockchain would
251:30 - actually change we can actually also
251:32 - call these orange buttons or these
251:34 - non-view functions and just not actually
251:37 - make a state change remix defaults these
251:39 - blue buttons to be calls and these
251:41 - orange buttons to be transacts in python
251:44 - we can actually pick which one we want
251:46 - to do a transact a transact call is when
251:49 - we actually
251:50 - make a state change
251:54 - and this is when we actually have to
251:55 - build a transaction and send a
251:56 - transaction you can always just call a
251:59 - function no matter what that function is
252:01 - but just keep in mind you won't make a
252:03 - state change you can also always
252:05 - transact on a function even if it's just
252:07 - a view and this will attempt to make a
252:09 - state change
252:11 - something like retrieve even if we
252:13 - transact on it it won't make a state
252:14 - change so for something like retrieve
252:17 - where we don't actually want to make a
252:19 - state change
252:20 - we just use the call function so we'll
252:23 - just do dot call
252:25 - now
252:26 - if we try to run this
252:28 - you'll see we do get the zero because
252:30 - now we're actually calling this
252:31 - transaction awesome so now we have our
252:34 - initial value for our retrieve function
252:37 - let's keep going let's try to update
252:39 - this favorite number using this store
252:41 - function this we'll just keep in mind is
252:43 - our initial
252:46 - value of
252:47 - favorite number we know that this store
252:50 - function is orange and we'll actually
252:51 - make a transaction
252:53 - but if we wanted to we can even just use
252:55 - call on it
252:56 - we'll do simple storage
252:58 - dot functions
253:00 - that's store
253:02 - we'll put that 15 in here
253:04 - call
253:06 - let's see what happens when we send this
253:10 - you can see it returned a blank that's
253:12 - because this store
253:15 - function has no return type if we give
253:17 - this returns
253:19 - unit 256
253:22 - and then we say return
253:26 - favorite number
253:28 - and now we go back here
253:32 - and we run this again
253:34 - you'll see now that we get a 15 back if
253:37 - we go to ganache you'll see that we keep
253:39 - making a whole bunch of different
253:40 - contracts but none of these are contract
253:42 - interactions that's because when we call
253:44 - a function we just simulate working with
253:47 - it if we call retrieve again right
253:48 - afterwards you'll see that it's still
253:50 - zero
253:54 - it's because calling is just a
253:56 - simulation now let's delete all that so
253:58 - let's actually build a new transaction
254:00 - to actually store some value
254:03 - into this contract since we want to make
254:04 - a transaction we got to go through the
254:06 - same process as when we deployed this
254:08 - contract
254:11 - let's first create a transaction
254:14 - called store transaction
254:16 - equals
254:17 - simple storage
254:19 - dot
254:20 - functions
254:22 - about store
254:24 - and we'll give it some number in this
254:26 - case 15
254:27 - and then we have to do dot
254:30 - build transaction
254:32 - and we'll put those same pieces in here
254:34 - from before we're going to have
254:37 - chain id
254:39 - be the chain id
254:42 - we're going to need from
254:44 - give me my address
254:47 - nunce
254:48 - is going to be the nuns
254:52 - plus 1.
254:55 - we're going to need to do nuns plus 1
254:57 - because we actually use this nuns
254:59 - already
255:00 - when we create our initial transaction
255:03 - remember a nuns can only be used once
255:05 - for each transaction
255:07 - so this transaction is going to have to
255:09 - have a different nuance than the nuns we
255:11 - use to deploy the contract now that we
255:14 - have the transaction let's go ahead and
255:15 - sign it
255:16 - we'll do signed
255:19 - store
255:21 - tx
255:22 - and
255:23 - we'll do web3
255:25 - that eath
255:27 - dot account
255:29 - dot sign transaction
255:33 - store transaction
255:36 - and then private key equals
255:39 - private key and we'll go ahead and save
255:42 - then of course we need to send it so
255:44 - we'll do
255:46 - transaction hash
255:48 - equals w3.eth
255:51 - dot send raw transaction
255:55 - signed
255:56 - store transaction
255:58 - dot raw
256:00 - transaction
256:02 - and let's grab that transaction receipt
256:04 - again
256:04 - by doing transaction receipt
256:07 - equals w3
256:08 - dot eth
256:11 - dot wait for transaction receipt and
256:14 - actually let's call this
256:16 - send
256:18 - store
256:19 - tx
256:22 - that way for receipt
256:23 - send store tx awesome it looks like
256:26 - we're following the same steps here as
256:28 - we did above
256:31 - we created the transaction
256:33 - we signed the transaction
256:35 - and then we send the transaction
256:37 - down here
256:38 - we create a transaction
256:40 - we sign the transaction we sent the
256:42 - transaction and then we waited for the
256:44 - transaction to finish
256:47 - so let's run this
256:52 - all right great we still have this print
256:54 - function printing out the current value
256:56 - of retrieve let's go over to ganache and
256:58 - see if there's anything different here
257:00 - there is instead of all these contract
257:02 - creations here we now have a contract
257:04 - call
257:05 - we can see there's some transaction data
257:07 - that was sent
257:08 - a different amount of gas same gas
257:10 - prices
257:12 - however
257:13 - this
257:14 - actually updated and sent the
257:16 - transaction to our blockchain
257:19 - now if we call this retrieve function
257:21 - again
257:22 - this should print out our newly updated
257:25 - value which in this case was 15.
257:28 - let's go ahead and run
257:30 - python deployed up high
257:32 - and we can see it started at zero
257:34 - and then it turned to 15. awesome we've
257:37 - made our first state change to a
257:39 - contract that we've deployed on our
257:41 - local blockchain great work sometimes
257:43 - it's nice to put some lines in here to
257:45 - tell you what's going on to make it a
257:47 - little bit more clear so i'll put
257:48 - something like
257:50 - deploying
257:52 - contract dot dot
257:54 - right before we deploy our contract
257:57 - after we do it i might do
258:02 - deployed
258:07 - then
258:08 - right before we update our contract
258:10 - we'll print out something
258:13 - like updating contract
258:18 - and then right after it's done
258:20 - maybe something like
258:22 - updated
258:26 - now if we run this now
258:28 - you'll see as this goes along we'll get
258:31 - these things printed out saying
258:33 - deploying contract contract deployed
258:36 - updating contract updated this will make
258:38 - those moments when waiting for these
258:40 - contracts to actually finish a lot
258:41 - easier you're doing fantastic so ganache
258:44 - user interface is really nice because we
258:46 - can see a lot of things that are going
258:48 - on here however it's a little tricky to
258:50 - do a lot of programmatic stuff
258:51 - oftentimes engineer will use what's
258:53 - called a command line interface of
258:56 - ganache instead of the ui so we're going
258:58 - to go ahead and close this out and we're
259:00 - going to use the ganache cli instead of
259:02 - that user interface that we just saw and
259:04 - this is what and this is what brown is
259:06 - going to use on the back end when we
259:08 - move to brownie let's learn how to
259:09 - actually do that so in order to use the
259:11 - ganache cli or command line interface
259:13 - the first thing that we need to do is
259:14 - download node.js yes i know this is a
259:17 - python video however we do need to
259:19 - install node.js to work with the ganache
259:21 - cli you can come to this download page
259:23 - and choose your operating system and
259:26 - download it accordingly we will link to
259:28 - a video showing you how to do this in
259:29 - the github you'll know you've done it
259:31 - right if you can run node
259:33 - dash version in your command line and
259:35 - you get a version it might be 12 might
259:36 - be 14 might be something else depending
259:38 - on what version you downloaded next
259:40 - we're actually going to install yarn
259:42 - yarn is a package manager similar to pip
259:45 - and will allow us to actually download
259:48 - pieces and packages like the ganache cli
259:50 - from the package repository we can
259:52 - install it with npm install dash dash
259:55 - global yarn and you'll know you've done
259:57 - it right
259:58 - if you can run yarn
260:00 - dash dash version in your command line
260:02 - and you get the version outputted here
260:04 - then we want to install the actual
260:06 - ganache cli we're gonna be installing it
260:08 - with yarn so to install this we're gonna
260:10 - yarn global
260:13 - add
260:14 - ganache cli
260:18 - this will install our ganache cli as a
260:20 - global command in our terminal we can
260:22 - test to see if we've done it right if we
260:24 - can run
260:25 - ganache
260:26 - cli
260:28 - dash dash version perfect we now have
260:30 - the ganache cli let's spin up a ganache
260:32 - chain with the cli
260:34 - if you have your ganache ui open right
260:36 - now please close it otherwise it'll
260:38 - conflict so to run a local blockchain
260:41 - from the command line all you need to do
260:42 - is run
260:43 - ganache
260:45 - cli
260:48 - and the node will start running directly
260:50 - in your terminal
260:51 - if you scroll up you can see a lot of
260:53 - familiar pieces
260:55 - we see the available accounts just like
260:58 - on the ui
260:59 - these are the different addresses
261:01 - and then we see a whole bunch of
261:02 - different private keys this ganache
261:05 - spins up with a bunch of random
261:06 - addresses and random private keys if we
261:08 - wanted to always spin up with the exact
261:10 - same private keys so we don't have to
261:12 - update our private key every time
261:14 - we can do ganache
261:16 - cli
261:18 - dash dash
261:19 - deterministic
261:24 - this way we'll always get the exact same
261:26 - private keys
261:27 - and the exact same addresses you can
261:29 - check out the documentation to see a
261:30 - bunch of other flags that you can use to
261:32 - run this and you can see it's listening
261:34 - on 127.2
261:39 - 127.0.0.1 is also known as the loopback
261:42 - address or localhost now to work with
261:44 - ganache in the command line
261:46 - all we need to do now is update our
261:48 - private keys and our addresses let's
261:50 - also update the http provider since now
261:53 - we're going to be looking at the
261:54 - loopback address for my address
261:56 - we'll scroll up
261:58 - to this top address here
262:00 - and we'll place it in
262:02 - for our private key
262:04 - we're going to copy this
262:06 - and put it into our dot emv file
262:10 - it already has the ox at the top here
262:12 - great now let's open up a new terminal
262:14 - you can open up a new terminal by
262:16 - hitting this plus button here
262:18 - and you can flip back and forth by
262:20 - hitting this drop down and flipping back
262:23 - to the ganache terminal now let's go
262:25 - ahead and run
262:26 - python
262:27 - deploy.pi
262:29 - we can see
262:30 - the exact same output as we got when
262:32 - working with the ui and if we flip over
262:36 - to the command line we can see we've
262:38 - made a whole bunch of different calls to
262:40 - our blockchain each one of these calls
262:42 - is a specific json rpc call to our
262:44 - blockchain that we're making to interact
262:47 - with it we can see information about the
262:48 - transactions that we send this one
262:50 - creates our simple storage contract
262:53 - this one updates our simple storage
262:55 - contract and great you now know how to
262:57 - work with the ganache cli and the
262:58 - ganache ui fantastic so how do we
263:01 - actually deploy this to a test net or a
263:03 - real network we were working with remix
263:05 - all we had to do was switch to injected
263:08 - web 3 and we used our meta mask as our
263:10 - blockchain connection well in our script
263:12 - here we don't have metamask natively
263:14 - with our script so we need some way to
263:17 - connect to the blockchain we can see
263:20 - that when we're connecting to our own
263:22 - local blockchain we just use an rpc url
263:25 - that connects to our local blockchain to
263:27 - connect to a test net or to a mainnet we
263:29 - can actually do the exact same thing all
263:31 - we have to do is swap this out with the
263:33 - url that connects us to a mainnet or a
263:36 - test app we can also run our own
263:37 - blockchain node similar to how we're
263:39 - running our own local blockchain node we
263:42 - can run a node that actually connects to
263:43 - a real blockchain however it's not
263:45 - always practical or really easy to do
263:47 - this so sometimes we want to use an
263:50 - external or a third-party client that
263:52 - actually will run a blockchain for us
263:54 - let's learn a little about inferior
263:56 - inferior.io is an application that will
263:58 - give you a blockchain url for you to
264:00 - connect with for you to run whatever you
264:02 - want to run and you can get started for
264:04 - free let's go ahead and register
264:09 - then we just check our email
264:11 - confirm email address and awesome now
264:13 - we're inside of infira there's a couple
264:16 - other services out there that you can
264:17 - also check out like alchemy which is
264:19 - another fantastic blockchain as a
264:20 - service platform fura is a freemium
264:22 - service it starts out as free if you
264:23 - make too many api calls or too many
264:25 - calls to the url they'll start charging
264:28 - you
264:29 - but we can create a project for free for
264:31 - now let's go ahead
264:32 - hit the ethereum tab
264:34 - hit create project we'll call
264:36 - this free code camp
264:41 - brownie
264:42 - hit create now we'll have a whole bunch
264:44 - of project keys and project secrets we
264:48 - also have this endpoint section as well
264:50 - this is how we're going to be deploying
264:52 - to the different networks we can see we
264:54 - have an ethereum mainnet connection as
264:56 - well as robson coven rink b and gorilla
265:00 - testnets there's also polygon in here as
265:02 - well since we want to test and deploy to
265:04 - a ring b chain we can go ahead and move
265:06 - to ring b and then
265:08 - we can copy this url back in our
265:10 - application all we have to do is swap
265:13 - this out
265:14 - for the new url we also have to change
265:17 - the chain id
265:19 - our address and the private key if you
265:21 - ever are confused as to what is the
265:23 - chain id of the chain that you're
265:24 - working on you can always check this
265:25 - chain id dot network or you can usually
265:27 - ask somebody let's look up ring b we see
265:30 - the chain id is four so we'll grab four
265:32 - and we'll place that in our script now
265:34 - this address and the private key that we
265:36 - gave it now this address and the private
265:38 - key that we gave it aren't going to have
265:40 - any testnet ring be in them so we need
265:42 - to go in our metamask and grab the
265:44 - address place it in for address and then
265:47 - account details
265:49 - export private key
265:52 - type in our password
265:53 - and grab the private key go into our dot
265:55 - emb file
265:57 - leave the 0x and replace the rest with
265:59 - our private key since i have my private
266:01 - key stored as an environment variable i
266:03 - need to then run source.env so that my
266:06 - private key is now updated the reason
266:08 - we're using this is because again since
266:10 - we're making transactions to a testnet
266:12 - we need some test and eth alright so now
266:14 - we have everything updated for deploying
266:17 - to rinkeby let's go ahead and run this
266:19 - now
266:22 - as you can see it's going a lot slower
266:25 - this is because we actually have to wait
266:27 - for the contracts to get mined and for
266:29 - everything to happen
266:30 - on the test net deploying to a tesla
266:32 - will result in nearly the exact same
266:35 - experience that you'll get when
266:37 - deploying to an actual main net so it'll
266:39 - take a lot longer but you can see we got
266:41 - the exact same responses here now if we
266:44 - take this address
266:46 - and we go to the rink be ether scan
266:50 - we can verify what just happened
266:53 - we can see that 38 seconds ago
266:56 - we made this transaction
266:58 - and then 23 seconds ago we made this
267:01 - transaction
267:03 - we can look at all the different details
267:05 - of this transaction that we just made
267:07 - from our python script
267:08 - we can see it even tells us we created a
267:10 - smart contract
267:12 - and then
267:13 - we made this call
267:15 - which called this store function on this
267:17 - contract
267:18 - we've learned a lot so far this is
267:20 - fantastic now is a perfect time to take
267:23 - a break and take a quick breather and
267:25 - reflect back on what we've just learned
267:27 - we've learned a lot about python
267:28 - deploying to our own local blockchain
267:30 - deploying to a test net and deploying to
267:33 - a mainnet working more with private keys
267:36 - creating transactions
267:37 - signing transactions and then sending
267:39 - transactions
267:44 - now as you can see there's going to be a
267:45 - lot to actually managing all the
267:47 - contracts that we work with having to
267:48 - write our own compile code our own
267:50 - storage code is going to take a lot of
267:52 - work and what if we wanted to interact
267:54 - with one of the contracts that we
267:56 - deployed in the past well we'd have to
267:58 - keep track of all those addresses and
268:00 - manually update our address features
268:02 - here with an address maybe we didn't
268:04 - want to deploy a new contract every
268:06 - single time maybe we want to work with a
268:08 - contract that we've already deployed
268:09 - what if we want to work with a whole
268:11 - bunch of different chains what if we
268:13 - want to work with rink b and mainnet and
268:16 - our own local network there seems to be
268:18 - a lot to manage here and we still
268:19 - haven't even talked about writing tests
268:21 - this is where brownie is going to come
268:23 - into play brownie is currently the most
268:25 - popular smart contract development
268:27 - platform built based on python it's used
268:30 - by d5 giants like yearn.finance
268:33 - curve.phi and out each having billions
268:36 - of dollars currently locked in value and
268:38 - the reason that we learned a little bit
268:40 - about web3.pi first is because brownie
268:42 - heavily relies on web3.pi so let's do
268:45 - all this again but in brownie and we'll
268:47 - see how much easier it is to actually
268:49 - interact with in our shell
268:51 - let's go back one directory and let's
268:53 - make a new one we'll call it
268:56 - brownie
268:58 - simple
268:59 - storage
269:01 - now another really cool trick that vs
269:03 - code has is instead of us having to go
269:05 - to file and open up this folder in this
269:09 - explorer here
269:10 - what we can do is we can type code
269:12 - and then type the directory that we want
269:14 - to work with in our case
269:16 - this directory so we can just type code
269:18 - dot
269:19 - and we'll get a new vs code pop-up
269:22 - inside of this brownie simple storage
269:24 - folder let's get learning about brownie
269:26 - and this is where you're going to spend
269:28 - the majority of your time move forward
269:30 - brownie is incredibly powerful and makes
269:32 - our lives fantastically easier so get
269:34 - ready to learn one of the most powerful
269:36 - tools in the smart contract developing
269:38 - ecosystem let's go ahead and open up our
269:40 - terminal and let's get started
269:42 - installing brownie it's recommended to
269:43 - install brownie via pipex pepex installs
269:46 - brownie into a virtual environment and
269:48 - makes it available directly from the
269:50 - command line once installed you'll never
269:51 - have to activate a virtual environment
269:53 - prior to using browning which is really
269:55 - good to install it with pipex we can go
269:57 - ahead and run python dash m
270:01 - pip install dash dash user pipex
270:04 - once we've run that we can then run
270:07 - python3-m pick at pipex in surepath
270:11 - then we'll want to close the terminal by
270:13 - hitting the little trashcan and then
270:14 - reopen it and then we just need to run
270:17 - pipex install f brownie i've already got
270:20 - it installed so that's why we see this
270:21 - here and then just one more time we're
270:23 - going to close and reopen the terminal
270:26 - you can tell you have brownie installed
270:27 - correctly if you run brownie dash dash
270:30 - version
270:32 - and you get some output that looks
270:33 - something like this
270:36 - or you just run straight up brownie
270:39 - and it'll output a bunch of commands
270:40 - that we can run let's create our first
270:43 - brownie project
270:44 - we're going to be using the exact same
270:46 - simple storage code that we just went
270:48 - through except for we're going to use it
270:50 - in brownie this is going to make our
270:51 - lives a lot easier when working with
270:53 - simple storage to create a sample folder
270:55 - with everything we need with brownie we
270:57 - can just run brownie
270:59 - init
271:00 - and we will get a new brownie project
271:02 - initialized in the directory that we're
271:04 - currently in
271:05 - if you type ls you'll be able to see all
271:07 - the folders that are created or you can
271:09 - just see them on your side panel in vs
271:11 - code let's talk really quickly about
271:12 - what each of these folders is going to
271:14 - do the build folder tracks a lot of
271:16 - really important low-level information
271:19 - it's going to track any interfaces that
271:21 - we're working with or deploying it's
271:23 - going to keep track of all of our
271:24 - deployments across all of the different
271:26 - chains so we no longer have to manage
271:28 - that ourselves
271:30 - and it's going to store all the compiled
271:32 - code remember how in our simple storage
271:33 - code we actually saved everything to
271:35 - this compile code.json well brownie is
271:37 - actually going to do all of that for us
271:39 - into this contracts directory so we can
271:40 - always reference it later this contracts
271:43 - directory outside the build folder is
271:45 - where we're going to put all of our
271:46 - contracts brownie knows to look inside
271:48 - of this folder when looking for new
271:50 - contracts to compile deploy or anything
271:52 - else interfaces is where we can save and
271:54 - store different interfaces remember how
271:56 - when we were working with chain link
271:58 - working with interfaces makes it really
272:00 - easy to interact with a blockchain
272:02 - application reports are to save any type
272:04 - of report you run scripts or we can
272:07 - automate tasks like deploying calling
272:09 - different functions or really anything
272:10 - we want and then we have a test folder
272:12 - which is incredibly powerful and we're
272:14 - going to be using a lot we also have git
272:16 - attributes and get ignore which are
272:17 - helpful when working with version
272:19 - control like git so let's go ahead and
272:22 - start working with brownie and really
272:23 - understand what's going on here so let's
272:26 - go ahead and add our simple storage
272:28 - contracts to the contracts folder so in
272:30 - here we're just going to make a new file
272:32 - we'll call it simple
272:34 - storage.soul and i'm just going to copy
272:36 - and paste the code i have
272:38 - from the simple storage that we've been
272:40 - using this whole time let's go ahead and
272:42 - save that with command s okay great now
272:45 - that we have our contract in here we can
272:46 - already start working with brownie and
272:48 - even compile this code without even
272:50 - having to write or work with our own
272:51 - compiler all we need to do
272:54 - is run brownie
272:55 - compile
272:57 - brownie will automatically read the
272:58 - version of solidity and then store all
273:01 - of the compile information in this build
273:04 - folder so if we go to contracts we can
273:06 - see we have a simple storage.json and
273:09 - there's a lot of familiar pieces in here
273:11 - for example we see the abi opcodes
273:13 - section which is the low level language
273:16 - we'll see a pc map and we'll see a lot
273:18 - of useful information and great
273:20 - obviously deployments and interfaces are
273:21 - still empty so great we've already
273:23 - compiled our smart contract so why don't
273:25 - we actually deploy this to a blockchain
273:27 - to do this we do have to write a script
273:29 - which will allow us to do whatever we
273:31 - want so we're going to create a new file
273:33 - and we're just going to call this
273:34 - similar to last time deploy dot pi this
273:37 - is where we're going to define working
273:39 - with and deploying our code brownie can
273:41 - run scripts by running brownie run in
273:44 - fact if you want to take a quick minute
273:45 - to familiarize yourself with all the
273:47 - different commands that brownie has just
273:49 - run brownie and you'll see we can do a
273:50 - lot of different things we do brownie
273:53 - init which will create a new brownie
273:54 - project we will do brownie bake which
273:56 - allows us to pull from the brownie mix
273:58 - which we'll talk about later we can
274:00 - compile we can go into a console test
274:02 - run we do a lot of wonderful things in
274:04 - here if we do brownie run it'll run a
274:06 - script for us and we can define that we
274:08 - want to run this deploy all we have to
274:10 - do is add a def
274:12 - main
274:13 - so def in python is the way to define a
274:16 - function we're going to call this
274:17 - function main and for now let's just say
274:19 - print
274:21 - hello
274:22 - and we can run
274:23 - brownie
274:24 - run
274:25 - scripts deploy
274:28 - and as you can see it automatically does
274:31 - this launching thing
274:33 - so brownie defaults to always working
274:35 - with a local ganache cli blockchain it's
274:38 - running the exact same command that we
274:40 - ran earlier and it has a bunch of
274:41 - different flags like accounts 10 a
274:43 - certain hard fork a certain gas limit
274:45 - etc so at the beginning of all of our
274:47 - scripts if we don't give brownie a
274:50 - network to use it'll spin up a local
274:52 - ganache and at the end of the script
274:54 - it'll tear it back down typically what i
274:56 - like to do is actually put all the logic
274:58 - of our deployment in its own function
275:00 - def
275:01 - deploy
275:03 - simple storage
275:05 - and we'll do pass for now and then our
275:07 - main function we can just call
275:09 - deploy symbol storage now in order to
275:11 - deploy our contract let's look back at
275:13 - our web 3 pi version of deploying this
275:15 - and see what we did so first we compiled
275:18 - it great brownie does that automatically
275:20 - then we jumped into a file great brian
275:23 - does that automatically
275:25 - we got a byte code and an abi
275:28 - great brand does that automatically we
275:30 - added a local blockchain to use great
275:32 - brownie automatically spins up a local
275:34 - ganache we'll learn how to do test nets
275:37 - in a little bit aha we do need an
275:39 - address though and a private key so how
275:41 - do we actually get our private key get
275:43 - our account into brownie brownie has an
275:45 - account package that actually natively
275:47 - understands how to work with accounts
275:49 - and we can import it into our script
275:51 - here so we can do from
275:53 - brownie import accounts
275:57 - and with this accounts keyword
275:59 - we can add an account a number of
276:01 - different ways if we're going to work
276:03 - with our local chain as you see here the
276:06 - ganache cli will spin up 10 fake
276:09 - accounts for us and brownie
276:11 - automatically knows that we can work
276:12 - with that account so we can do something
276:14 - like account equals account zero and
276:17 - then just do something like print
276:20 - account so we're going to take the
276:21 - account that's spun up at the zerowith
276:24 - index because this accounts object is
276:26 - just an array so if we run this now
276:29 - brownie
276:30 - runs scripts
276:32 - deploy
276:33 - it's going to spin up us an address and
276:36 - a private key that we can just work with
276:38 - without having to define a private key
276:40 - or do anything it does all of that for
276:42 - us which is fantastic we do of course
276:44 - still want to know how to add our own
276:46 - private keys so that we can work with
276:48 - the test net so this is great and works
276:50 - when we're working with a development
276:51 - network or working with brownie's
276:53 - automatic ganache cli if we want to work
276:55 - with a test net though we have to do
276:57 - something else another way to add your
276:59 - accounts in brownie is to use the
277:01 - command line and actually add them
277:03 - natively into brownie we can do brownie
277:05 - accounts
277:07 - new and we'll give it a name free code
277:10 - camp account
277:13 - this will then prompt us and say enter
277:15 - the private key that you wish to add
277:17 - let's go ahead and grab our private key
277:19 - from metamask account details export
277:21 - private key
277:23 - put your password in
277:24 - grab the private key and then we just
277:26 - add ox and paste it in
277:29 - brownie will actually password encrypt
277:32 - your private key in this way
277:34 - so we'll give it a password and now we
277:36 - have a new account natively integrated
277:39 - into brownie to see it we can do brownie
277:43 - accounts list and you'll see that we
277:45 - have a free code camp account with this
277:47 - address and also a testing account i
277:50 - made this a little bit earlier we can
277:51 - get rid of it
277:52 - by running brownie
277:54 - accounts delete
277:57 - testing helpful terminal tip time so if
278:00 - you hit up or down on your keyboard you
278:02 - can actually toggle through the history
278:04 - of the commands that you've written so
278:06 - if you hit up it'll actually bring you
278:08 - to the most recently run command which
278:10 - can allow you to run previous commands a
278:12 - little bit faster and if we run browning
278:13 - accounts list again
278:15 - we'll see it's now just free code camp
278:17 - if we want to work with this free
278:18 - codecamp account that we've added to
278:21 - brownie via the command line
278:23 - we can get it with account
278:25 - equals accounts dot load
278:29 - free code camp account
278:31 - and then we can do print account let's
278:33 - run this script again
278:36 - this time when we on the script it's
278:37 - going to ask us for the password we need
278:40 - to enter the password to decrypt the
278:42 - account because right now it's password
278:44 - encrypted so we're going to type in the
278:46 - password and it's going to go ahead and
278:48 - execute with our unlocked private key we
278:50 - can see the address it printed out was
278:52 - right here
278:53 - and if we copy the address and we go
278:56 - back we can see that that is correct
278:58 - now if we're going to talk about safety
279:00 - and you want to safely secure your keys
279:02 - this is one of the safer ways to do it
279:04 - because it's not going to store it in
279:05 - git
279:06 - you're not going to accidentally push it
279:08 - up to github or show it to anybody and
279:10 - it's going to be password encrypted this
279:12 - is going to be one of the ways that i
279:13 - highly recommend you store your keys
279:15 - oftentimes you're going to want to do a
279:16 - mix of working with the local ganache
279:18 - ones and your own keys and we'll learn
279:21 - how to flip back and forth between them
279:23 - in a little bit now the third way that i
279:24 - like to use is still again using an
279:26 - environment variable script oftentimes
279:28 - it's really easy just to have your
279:30 - private key be an environment variable
279:32 - this way you won't have to keep putting
279:33 - the password in every single time you
279:35 - run a script so it's a little bit less
279:36 - secure and just another tip for myself i
279:38 - never put my private keys associated
279:40 - with wallets that have real money in
279:42 - them as environment variables or in a
279:44 - env file just in case i accidentally do
279:47 - something really stupid i don't trust
279:49 - myself enough so i'm gonna highly
279:50 - recommend that whatever private key that
279:52 - you use and you store it as an
279:53 - environment variable here always have it
279:54 - be just kind of a test account that
279:56 - you're gonna use to test things and then
279:57 - for some of your more serious accounts
279:59 - that's what you'll use the encryption
280:00 - for so let's go ahead and create an
280:02 - environment variable file
280:03 - so we'll do a new file call it env
280:06 - and we'll do export
280:08 - private key
280:10 - ox this
280:11 - now we have a private key set as an
280:13 - environment barrel so brownie has an
280:15 - additional feature that allows us to
280:17 - easily work with environment variables
280:19 - in an environment variable folder we can
280:21 - tell brownie to always pull from our env
280:24 - file in a brownie config
280:28 - yaml
280:30 - this is a special file that brownie
280:32 - always looks for to grab information
280:34 - about where you're going to build where
280:36 - you're going to deploy and where you're
280:37 - going to grab things in this config all
280:39 - we need to do is add env
280:43 - and set dot env this is telling brownie
280:46 - hey when you run scripts grab the
280:48 - environment variables from the dot env
280:50 - file and what we can do is after we
280:53 - import os we'll do account equals
280:55 - accounts dot add os dot get env this is
280:58 - how we get that environment variable a
281:00 - private key then let's just print out
281:02 - that account see if we did it right
281:04 - brownie run
281:06 - scripts deploy.pi
281:10 - and great
281:14 - all right great so this seems to work
281:16 - perfectly but i like to make this method
281:18 - even more explicit so we're going to
281:19 - take this version that we just learned
281:21 - and improve it in our brownie config we
281:23 - can actually add more information about
281:25 - what wallets we want to use and when we
281:27 - want to use them
281:29 - what we can do
281:30 - is we can add a wallets section
281:33 - and add in here a from
281:36 - key section
281:37 - and then add that environment variable
281:39 - private key in your yaml file if you
281:42 - surround a string with dollar sign and
281:45 - some curly brackets it will
281:47 - automatically get transformed into the
281:49 - environment variable so if we go back to
281:51 - deploy we can actually change this we
281:54 - can grab right from our config file so
281:56 - we'll do from brownie import accounts
281:59 - config
282:01 - instead of using os
282:04 - we can do accounts
282:05 - dot add
282:07 - config
282:08 - and then we'll do wallets
282:10 - since that's what we're defining right
282:12 - here
282:13 - and then from key
282:14 - wallets
282:18 - from
282:19 - key
282:20 - and this will do the exact same thing as
282:22 - our os dot get emv
282:24 - the reason that this is better is
282:26 - because now we have one canonical place
282:29 - where we're always going to pull our
282:31 - private key from instead of having to go
282:33 - through all of our scripts and update it
282:35 - based on whatever we change an
282:36 - environment variable now let's try this
282:38 - out
282:39 - brownie run
282:40 - scripts deploy
282:44 - and great we see our address printed
282:47 - here
282:48 - for now let's just stick with using
282:50 - accounts zero since we want to just use
282:52 - the account that brownie makes for us
282:54 - with ganache now brownie is really
282:56 - intelligent and we can actually go ahead
282:59 - and import
283:00 - a contract directly into our script and
283:02 - a web3.pi version we opened a contract
283:05 - and read from it and that's how we were
283:06 - able to interact with it after we
283:08 - deployed it in brownie what we can do is
283:11 - from brownie
283:12 - import
283:14 - and then just the name
283:16 - of the contract simple storage then
283:20 - we can do simple storage
283:22 - dot deploy and this is how we're going
283:24 - to deploy it to a chain anytime you
283:26 - deploy to a chain or you make a
283:28 - transaction you always need to do a from
283:31 - and then say who you're going to be
283:32 - deploying from what's the account that's
283:34 - going to be deploying this as you can
283:36 - see
283:37 - this step of just deploying is
283:40 - much quicker
283:41 - than what we did in web3.pi in web3.pi
283:45 - we had to
283:46 - get the byte code and the abi then we
283:48 - had to get the nuns
283:50 - we had to create the contract we had to
283:52 - create the transaction
283:53 - sign the transaction and then send the
283:56 - transaction remember how i said before
283:58 - you could either make a transaction
284:01 - or a call brownie is smart enough to
284:03 - know whether or not what you're doing is
284:05 - going to be a transaction or a call
284:07 - in this case since we're deploying a
284:08 - smart contract brownie's smart enough to
284:10 - know that ah we want to make a state
284:12 - change so let's make a state change
284:15 - it'll return a contract object
284:18 - so we can just add print
284:21 - simple storage and we'll see what prints
284:24 - so let's run this brownie run scripts
284:27 - deploy.pi
284:28 - awesome so what happened was brownie
284:31 - again per usual it launched a local
284:33 - ganache chain
284:35 - and then it sent a transaction to deploy
284:38 - simple storage
284:39 - and it says simple storage deployed at
284:41 - and then the address it was deployed at
284:43 - and we can see how much quicker this is
284:45 - to actually deploy now let's go ahead
284:47 - and do exactly what we did with web3.pi
284:49 - let's call this initial retrieve
284:51 - function and then we'll update it with a
284:53 - new value of 15. but we'll do it in
284:56 - brownie now
284:57 - remember here's how we did it back in
284:59 - web3.pie in brownie what we're going to
285:01 - do is first we're going to do
285:04 - stored value
285:06 - equals
285:07 - simple storage
285:08 - dot retrieve now since this is a view
285:11 - function we don't have to add from
285:13 - account in here again brownie is
285:15 - intelligent enough to know if this is a
285:18 - call or transaction and we know that
285:20 - retrieve is
285:21 - a view function so we know we don't
285:23 - actually have to make a transaction here
285:25 - then we can print out the value of
285:27 - stored value
285:28 - print
285:29 - stored value
285:30 - let's go ahead and try this
285:34 - great we get 0 right here perfect
285:37 - now let's try updating this so we can do
285:39 - transaction
285:41 - equals
285:42 - simple storage
285:44 - dot store
285:45 - and in here we'd want to do 15. but
285:47 - remember since we're doing a transaction
285:49 - in brownie we always have to add who
285:51 - we're going to transact from
285:53 - in this case we're going to do from
285:55 - account similar to web3.pi we can do
285:58 - transaction.wait
285:59 - for how many blocks we want to wait and
286:01 - then let's call that retrieve function
286:04 - again to see if it's been updated
286:06 - so we can do updated
286:09 - stored value equals
286:12 - symbol storage dot retrieve and then we
286:14 - can print
286:16 - the updated stored value
286:20 - and if we run this
286:22 - we now see we have two transactions here
286:25 - one that deployed our original simple
286:27 - storage contract and we called the
286:29 - retrieve function and we returned zero
286:31 - here
286:32 - then we updated with our store function
286:34 - and then we called retrieve again and we
286:36 - see we did indeed update it to 15. you
286:38 - see how much smaller and easier and more
286:41 - intuitive this is in brownie and how
286:43 - much our lives are going to be much
286:44 - better awesome now you've learned how to
286:46 - deploy to a local chain now running
286:48 - these scripts is fantastic but we need a
286:51 - way to actually automate that our
286:53 - contracts are doing what we want them to
286:55 - do we don't want to always have to
286:56 - manually check that all of our stuff is
286:59 - doing what we want to do right we don't
287:00 - want to have to manually check that 15
287:02 - is actually updating appropriately this
287:04 - is why running tests are so important
287:07 - and automating your tests is going to be
287:08 - crucial to becoming a successful smart
287:11 - contract developer now i do want to
287:12 - point out that you actually can write
287:14 - tests directly in solidity and this is a
287:17 - great way to actually test your smart
287:18 - contracts is to learn how to do it right
287:20 - in solidity however a lot of the
287:22 - professional developers code their tests
287:24 - in the smart contract development
287:26 - framework language like python or
287:28 - javascript doing it in this way allows
287:30 - you to get a lot more flexibility and
287:32 - customization with what you're doing
287:33 - with your smart contracts and not being
287:35 - confined to whatever only solidity has
287:37 - so let's go ahead and learn how to
287:39 - actually write our smart contract tests
287:41 - in python this is what this test folder
287:44 - is for so we're going to create a new
287:45 - file called test
287:50 - simple storage
287:52 - dot pi
287:53 - make sure you do add tests to the front
287:55 - of these because this is the syntax that
287:57 - pi test is going to be looking for and
287:58 - then in our test we can actually set it
288:00 - up the exact same way we set up our
288:01 - deploy function we can do from
288:04 - browning
288:05 - import
288:06 - simple storage
288:08 - and accounts
288:10 - then we can start defining our tests we
288:13 - want to test to see that when we deploy
288:15 - our smart contract that it gets started
288:17 - off with zero in that retrieve function
288:20 - so we'll create our first test we'll do
288:22 - def
288:24 - test
288:24 - deploy and typically
288:28 - testing in smart contracts or testing
288:30 - really in anything is going to be
288:31 - separated into three categories
288:33 - arranging
288:35 - acting
288:37 - and asserting we're going to bounce
288:39 - around and be a little bit loose with
288:41 - this definition for the duration of our
288:44 - tutorials here however keep in mind that
288:46 - typically this is the setup that you
288:48 - want to use later on in one of our later
288:50 - smart contract examples we're going to
288:52 - go through a much better testing setup
288:54 - so in our arrange stage we're going to
288:56 - set up all the pieces that we need to
288:57 - get set up
288:58 - so first
289:00 - we're going to grab an account
289:01 - we're going to say accounts equals
289:03 - account zero and this is really all we
289:05 - need to do to start getting set up now
289:07 - for our acting stage we're going to
289:09 - deploy
289:10 - a simple storage contract
289:12 - exactly as we did with deploy
289:14 - so we do simple storage
289:16 - equals simple storage dot deploy
289:21 - from
289:22 - account then we're going to get our
289:24 - starting value
289:26 - starting value
289:28 - is going to be equal to
289:30 - simple storage dot
289:33 - retrieve and we're expecting
289:35 - [Music]
289:39 - this to be zero
289:41 - so then all we have to do in our search
289:43 - sage is we have to run assert
289:45 - starting value
289:47 - equals
289:48 - expected so let's recap this in our
289:51 - arrange stage we're just getting our
289:54 - account so that we can actually make
289:55 - contracts then in our x stage we're
289:57 - going to deploy this simple storage
289:58 - smart contract we're going to call the
290:00 - retrieve function to see what its
290:02 - starting value is and we're going to
290:04 - compare to see if that starting value is
290:06 - what we expect and we expect it to be
290:07 - zero we can then test this with brownie
290:11 - test
290:11 - and per usual brownie is going to kick
290:13 - off a ganache lie
290:15 - and then it's going to test this
290:17 - for every test you have you're going to
290:18 - get a little green dot and we're going
290:20 - to say one pass in 1.86 seconds which is
290:23 - perfect if we had expected to be 15 and
290:25 - we ran brownie test we should get a fail
290:28 - here
290:30 - awesome and that's exactly what we got
290:32 - now let's go ahead and test updating
290:34 - this with 15 and see if it works as we
290:37 - want it to so we can do a new test in
290:40 - here
290:41 - we'll do def
290:42 - test
290:44 - update thing
290:47 - storage
290:49 - and we'll do those three phases
290:51 - arrange
290:53 - act
290:54 - and assert in our range all we need to
290:56 - do is get our account
290:59 - from account zero and in this one
291:01 - arranging is also going to be deploying
291:04 - our smart contract
291:07 - since this is really just part of the
291:09 - setup and not the act that we're really
291:10 - testing now in our act we're going to
291:12 - add expected
291:15 - to be equal to 15 and we're going to run
291:18 - simple storage
291:19 - dot store
291:21 - expected
291:23 - and then from account
291:27 - you'll notice this is nearly exactly the
291:28 - same as this deploy function here
291:31 - now same as last time all we have to do
291:34 - is assert
291:37 - expected
291:39 - equals equals
291:41 - simple storage dot
291:44 - retrieve we're saying we want to store
291:47 - 15 in our smart contract and then when
291:49 - we call our retrieve function it is
291:51 - stored correctly so let's go ahead and
291:54 - run
291:55 - brownie test
291:59 - awesome we can see two dots here this
292:01 - means two have actually passed correctly
292:04 - that's great now i do want to quickly
292:06 - show you a couple of useful tips that i
292:08 - pretty much always do when i'm running
292:09 - my tests if you want to test just one
292:12 - function you can do dash k
292:14 - brownie test k
292:16 - test updating storage and we will only
292:19 - test this test updating storage we can
292:21 - run brownie test dash dash pdb
292:25 - and add something wrong in here like
292:27 - five equals simple storage dot retrieve
292:32 - and what will happen is once this kicks
292:34 - out and is wrong will actually get put
292:36 - into a python shell and now we can check
292:39 - to see some variables in here like if i
292:41 - see what expected is expected is 15.
292:44 - if i try to run
292:45 - simple storage.retrieve expected is 15.
292:49 - if i run simple storage
292:53 - i'll see this is the simple storage
292:54 - contract
292:56 - pdb is a really useful way to mess
292:58 - around and see okay well what did i
293:00 - really go wrong why is my test failing
293:02 - another important flag is going to be
293:04 - dash s
293:05 - so you'll notice that no print lines
293:07 - actually get sent out when you're
293:09 - working with these tests
293:10 - if you do dash s
293:13 - it'll be a little bit more robust and
293:14 - telling you exactly what's going on and
293:16 - if we had any print lines it would print
293:18 - the lines out as well everything that
293:19 - you can do with brownie test actually
293:21 - comes directly from pi test so if
293:23 - there's some flag you want to use or
293:25 - some awesome debugger you want to use
293:27 - you can use it with brownie just by
293:29 - looking at the pi test documentation all
293:31 - the tools are exactly the same all right
293:34 - we're coming along fantastically we have
293:36 - a script to deploy we have some tests we
293:38 - have our contract this is great but now
293:41 - we actually want to deploy to a test net
293:43 - how are we going to do this let's look
293:45 - at back how we did it with web3.pi back
293:47 - in web3.pi to deploy this to a test net
293:50 - we just needed to add our http web3
293:52 - provider which was our infira account
293:54 - and that was pretty much it and add our
293:56 - address and our private key brownie our
293:58 - lives are even easier brownie comes
294:00 - pre-packaged with a list of networks
294:02 - that it's already compatible with you
294:04 - can see all the networks by running
294:06 - brownie
294:07 - networks
294:09 - list
294:11 - now mine has a couple more actually
294:13 - because i've been playing around with
294:14 - this for a long time but if you want to
294:16 - see all the different networks you can
294:18 - look at this list here something
294:19 - important to note is that there's a
294:21 - difference between the development
294:22 - networks
294:23 - and the ethereum networks whenever we
294:25 - deploy to a network we default to this
294:28 - development network any network that you
294:30 - see under this development section is
294:32 - going to be a network that is temporary
294:34 - these are networks such as the temporary
294:36 - ganache network that brownie
294:38 - automatically spins up when we've run
294:40 - any of the scripts we've written so far
294:41 - so this is really important to know
294:43 - remember anything in this development
294:44 - section is going to get torn down
294:47 - after it's deployed however the ethereum
294:49 - ones are going to be our persistent
294:51 - networks anything under this ethereum
294:53 - tab brownie is actually going to keep
294:55 - track of our deployments and keep track
294:57 - of everything in there these networks
294:58 - under here represent persistent networks
295:01 - like mainnet rink b coven etc now in our
295:04 - web3.pi we used an rpc url or an http
295:08 - provider from infira to connect to a
295:10 - testnet we're going to use that exact
295:12 - same methodology here so how do we
295:14 - actually get this rpc url this
295:16 - blockchain url into our brownie smart
295:19 - contract package well one of the easiest
295:21 - ways is with an environment variable so
295:24 - brownie actually already knows that
295:26 - infuria is thing and can look natively
295:29 - right away for inferior web 3
295:32 - infuria
295:34 - project id
295:37 - and use our project id from infira if we
295:40 - go to our project back in inferior
295:43 - and we go to settings
295:45 - you'll see the project id is a little
295:47 - bit different than the whole url it's
295:50 - just going to be this id right here
295:52 - we can then copy this and paste this
295:55 - right into our emv now that we have our
295:57 - web3 inferior product id directly in our
296:00 - project
296:01 - if we do
296:02 - brownie
296:04 - networks list any network that infuria
296:07 - has access to you'll see a little
296:09 - inferior in colons here these are
296:11 - networks that brownie will automatically
296:13 - know about if we're working with
296:14 - inferior so we can see here that ring b
296:17 - is one of these inferior keys if we
296:19 - wanted to deploy to ring b we could then
296:21 - just run
296:23 - brownie run
296:25 - scripts deploy.pi
296:27 - and then select the network with dash
296:30 - network
296:31 - rink b
296:34 - now we're going to get an issue here
296:36 - because remember account zero only works
296:39 - when brownie works with a ganache cli we
296:42 - have to use our actual private key here
296:44 - and that's where some of those other
296:45 - versions of working with private keys is
296:47 - gonna come into play sometimes i'll even
296:49 - add a get account function
296:52 - so down here we'll do def
296:54 - get account
296:56 - and then in here i'll just natively
296:58 - check if we're working on a development
297:00 - chain we'll use account zero
297:03 - and if not we'll use the method that
297:05 - pulls from our config so we can check by
297:08 - saying if
297:10 - network
297:11 - does show active
297:15 - equals equals
297:17 - development
297:21 - then
297:22 - return
297:25 - accounts 0. network is another keyword
297:27 - that brownie actually has
297:29 - this network keyword allows us to
297:32 - interact with different networks
297:37 - now if it's not on the development
297:39 - network we're going to pull directly
297:41 - from our config
297:43 - so we'll return
297:48 - config
297:52 - wallets
297:55 - from key
297:56 - and instead of doing account equals
297:58 - account zero we can just do account
298:01 - equals get account
298:04 - now if we run brownie run scripts deploy
298:06 - to pi network ringby it should pull
298:09 - directly from our
298:11 - config
298:12 - file and great we can actually see
298:15 - transactions being sent directly on the
298:17 - rinkby chain
298:19 - if we pull up ether scan
298:21 - the ring be ether scan and we take this
298:23 - transaction has and post it into the
298:24 - bring to ether scan we can see this
298:26 - transaction actually going through we've
298:28 - deployed our simple storage contract and
298:31 - it's initialized to zero
298:33 - then we're going to go ahead and update
298:35 - it and it gets updated to 15. now once
298:37 - we've deployed to a blockchain
298:40 - you'll see our build contract will
298:42 - actually change
298:43 - our deployments folder will have a new
298:46 - deployment every time you deploy to a
298:48 - blockchain brownie will actually save
298:50 - that deployment so you can always go
298:52 - back and say hmm where did i deploy that
298:54 - or what happened with that deployment
298:56 - you'll notice that it's separated by
298:58 - chain id remember the chain id ring b is
299:01 - four you'll also notice that none of our
299:03 - development deployments are in here
299:05 - again anything that's in this
299:07 - development section isn't going to get
299:08 - saved to the deployments area however
299:12 - anything up here
299:13 - and these ones will get saved and that's
299:16 - going to be really powerful because we
299:17 - can actually interact with contracts
299:19 - we've already deployed onto a chain so
299:21 - let's go ahead and even add
299:23 - a new file in here
299:25 - called
299:26 - read value this function is going to
299:28 - read directly from the ring blockchain
299:30 - and it's going to read from a contract
299:32 - that we've already deployed remember we
299:34 - did something similar in web3.pi
299:36 - by using the address
299:38 - and the abi
299:40 - we're going to do the exact same thing
299:41 - but in brownie so in brownie again we're
299:43 - going to do from brownie
299:46 - import
299:48 - simple storage
299:51 - accounts
299:54 - and config
299:58 - we'll do def
300:02 - read contract
300:05 - and we'll just do pass for now
300:07 - and then def main
300:11 - is going to be read contract oops didn't
300:13 - mean to do that down here and if we run
300:15 - brownie run scripts
300:18 - read value to pi
300:20 - network rank v obviously right now
300:22 - nothing's going to happen so how do we
300:24 - actually interact with this simple
300:25 - storage contract that we've already
300:26 - deployed well this simple storage object
300:29 - is actually just an array
300:31 - if we were to print simple storage
300:34 - let's see what we get
300:37 - see we get this
300:39 - brownie.network.contract.contractcontainer
300:41 - object at here this object works the
300:43 - same as an array we can access the
300:45 - different indexes inside of it so what
300:46 - if we do print simple storage at
300:48 - position zero
300:53 - you'll see we get this address here
300:55 - and if we check on ether scan
300:57 - we can see that this is indeed the
300:59 - contract that we just deployed
301:02 - ronnie knows that we just deployed it
301:04 - because again
301:05 - in our build section in the deployments
301:07 - on the rink b chain which has the chain
301:09 - id of four
301:10 - we have this contract that we've
301:12 - deployed now we can actually just
301:14 - directly interact with this contract
301:16 - we can do simple
301:18 - storage
301:20 - equals
301:21 - simple storage of xero or if you're
301:24 - always looking to get the most recent
301:26 - deployment
301:27 - minus one is a little bit easier if we
301:29 - always do zero we're just going to get
301:31 - the first deployment that we made and if
301:33 - we make deployments later we're never
301:35 - going to get past it
301:37 - i want to always work with the most
301:39 - recent deployment so i can just do minus
301:41 - one remember how i said whenever we work
301:43 - with a smart contract we need to know
301:45 - its abi
301:47 - and its address
301:50 - well brownie already knows what the
301:52 - address of this contract is it's got it
301:54 - saved in this deployments folder
301:57 - it also knows what the abi is because
301:59 - when we compile it we get this big json
302:02 - file and one of the first inputs that it
302:04 - has is the abi so brownie automatically
302:07 - knows what the abi is and what the
302:09 - address is already
302:11 - so then we can just go ahead and run
302:13 - simple storage
302:15 - dot retrieve
302:17 - and print it out
302:18 - and we should see 15 since we already
302:21 - updated it
302:23 - brownie run scripts
302:26 - read value to pi dash dash network rink
302:29 - b
302:32 - and great we do indeed see 15. now that
302:34 - we know how to write some scripts and
302:36 - actually deploy things with brownie and
302:38 - work with brownie i'm going to show you
302:39 - one of the most powerful features to
302:41 - also work with brownie typically we
302:43 - write our scripts when we want something
302:45 - to be reproducible and we want to do
302:47 - something over and over again
302:48 - deploying simple storage or reading of
302:51 - value is something that we're probably
302:52 - going to want to do over and over again
302:54 - however maybe we want to work with some
302:56 - of these contracts a little bit ad hoc
302:57 - and get into a shell where we can
302:59 - actually interact with these contracts
303:01 - this is where the brownie console is
303:03 - actually going to come into play and
303:04 - make our lives a lot easier
303:06 - so what we can do
303:08 - is we're going to brownie
303:10 - console
303:12 - and what will happen
303:13 - is brownie will actually kick us off
303:16 - into a console it has all of our
303:18 - contracts and everything already
303:19 - imported
303:20 - so if i run simple storage it gives me
303:23 - back an array it's saying
303:25 - great that's your simple storage
303:26 - contract since we're working on a brand
303:29 - new local test environment there are no
303:31 - simple storage contracts deployed so
303:33 - what i can do
303:34 - is i can say account
303:36 - equals
303:38 - account zero
303:40 - and we now
303:42 - have
303:42 - our account that we can work with
303:44 - accounts is one of these keywords that's
303:46 - automatically imported into our brownie
303:48 - console
303:49 - everything that is imported via brownie
303:51 - in our script is automatically already
303:54 - imported into this little shell here so
303:56 - with that being said we can go ahead and
303:58 - even deploy our simple storage contract
304:00 - so we can literally take this line
304:03 - copy it paste it in here
304:05 - and you'll see exactly the same thing
304:07 - that happens as if we ran our script we
304:09 - get a little transaction hash here and
304:11 - we get a simple storage
304:13 - now
304:15 - if i type simple storage the simple
304:18 - storage variable now has a storage
304:20 - contract here
304:22 - if i type simple storage
304:24 - you'll see i now have a contract in here
304:28 - the length
304:29 - a simple storage is now one because i've
304:33 - deployed one simple storage contract
304:36 - if i were to deploy it again
304:39 - the length is now two
304:41 - browning now knows i'm holding on to two
304:44 - simple storage contracts and i've
304:45 - deployed two simple storage contracts
304:48 - i can then even do things like simple
304:51 - storage
304:53 - dot retrieve
304:55 - and we can see
304:56 - we start with zero i can go ahead and
304:59 - even run
305:01 - simplestorage.store
305:05 - 15
305:08 - from
305:09 - account
305:12 - and we'll see we'll get a transaction
305:15 - now if i rerun simplestorage.retrieve a
305:17 - nice little hack here is in these shells
305:19 - if you just hit the up key you'll
305:21 - actually be able to go back in the
305:22 - history of the shell so if i just hit up
305:24 - twice here i can go back to this command
305:26 - and i hit enter now we see the 15 is
305:28 - here so the brownie console is a great
305:31 - way to interact with these scripts in a
305:33 - more ad hoc manner maybe we want to test
305:36 - some weird functionality or maybe we
305:38 - have some experiment that we want to try
305:40 - it's a great way to really interact with
305:42 - anything that we have in browning and
305:44 - the other thing is we can do everything
305:45 - that we normally do in python in here so
305:47 - for example i could write print
305:50 - hello
305:51 - and it'll print out hello i could do
305:54 - cat equals 1 plus 2
305:57 - and i type cat and i get 3. so this
305:59 - brownie shell is a python shell with all
306:02 - of our smart contract features already
306:04 - natively integrated and it's incredibly
306:06 - powerful here
306:07 - we go and quit it by doing quit so i
306:09 - know we've learned a lot so far i'm sure
306:11 - you're starting to see why working with
306:13 - brownie is so much easier and makes our
306:16 - lives as smart contract developers a lot
306:17 - easier for testing them deploying them
306:20 - and working with them
306:26 - all right let's move on to our next
306:29 - project is we're going to take the fund
306:31 - me contract that we made recently in
306:32 - remix and actually import that one into
306:35 - brownie with this we're going to go over
306:36 - a lot more of the advanced features that
306:38 - brownie has to offer us and we're going
306:40 - to get into some more sophisticated
306:42 - testing and deployment mechanisms for
306:44 - this so i'm going to make a new
306:45 - directory
306:47 - brownie
306:49 - fund me
306:51 - we're going to cd
306:52 - into brownie fund me
306:55 - and remember if you hit tab it will auto
306:57 - complete i'm going to open this up in a
306:59 - folder
307:01 - again if code period doesn't work you
307:03 - can always go up to file open folder and
307:06 - do it like that we're in our brownie
307:07 - fund me project and we're going to
307:09 - initialize a new project
307:10 - by running brownie
307:13 - init
307:14 - we're going to create a new contract
307:17 - called
307:18 - fundme.soul
307:19 - this is going to be exactly what we had
307:21 - before for our fund me contract so if
307:23 - you have remix up great you can go ahead
307:25 - and grab it or you can check the github
307:27 - repository associated with this course
307:29 - and just copy paste the code
307:34 - now typically this is where in our last
307:36 - project we just ran brownie compile
307:40 - what happens if we run brown and compile
307:41 - here brownie is going to give us this
307:43 - error it's going to say hey this source
307:45 - wasn't found so what's going on here
307:47 - well remix understands that at chain
307:50 - links slash contracts is an npm package
307:52 - that it can import from however
307:54 - brownie isn't aware of npm packages and
307:57 - brownie can't actually download directly
307:59 - from npm however brownie can download
308:02 - directly from github so we have to tell
308:05 - brownie where it should be downloading
308:07 - these external these third-party
308:08 - packages from so that we can use them in
308:10 - our contracts here and while i'm in here
308:12 - i might as well change the global
308:13 - compiler version to 0.6.6
308:20 - and we'll just change the compiler
308:21 - version to carrot 0.6.6 so that our
308:24 - linter is happy so we need to tell
308:25 - brownie where to import these contracts
308:27 - from from github instead of from npm
308:31 - luckily there is a package out there
308:32 - specifically created for downloading
308:34 - chain link contracts the way that we can
308:36 - tell brownie where to get these from
308:38 - is in our browning config
308:40 - so let's create our browning config
308:43 - in here we're going to create a the pen
308:46 - then sees section and this is where we
308:48 - tell brownie the organization
308:52 - slash repo name
308:54 - at
308:55 - version
308:57 - that we want to download from
308:59 - so so to get these chain link contracts
309:02 - we can look up
309:03 - chain link
309:04 - brownie contracts
309:06 - and we can use this repository to get it
309:08 - so instead of downloading from npm we're
309:09 - just going to download directly from
309:11 - this github repo so we need to tell
309:13 - brownie the organization which is going
309:15 - to be smart contract kit
309:19 - the repository name which is going to be
309:21 - chain link brownie contracts
309:26 - and then the version you don't always
309:28 - have to use the latest version here in
309:30 - fact we can go to the past nine versions
309:32 - by clicking on the version history we're
309:34 - actually going to be using 1.1.1
309:36 - and yes it does look like the latest
309:38 - version went backwards but as of a
309:40 - recent release as a 1.2.0 version of
309:43 - this package all the releases of
309:45 - chainley brownie contracts is going to
309:46 - match exactly the at chainlink contracts
309:49 - npm tag so that's why it looks like this
309:51 - is an earlier version so we'll say 1.1.1
309:54 - so great so now brownie knows to
309:55 - download this repository from github
309:57 - once we do that everything everything in
309:59 - this contract section will be available
310:02 - for our solidity code to import and use
310:04 - however that's not the final story here
310:06 - we also need to tell brownie
310:08 - what this at chain link thing means
310:10 - because we're downloading from smart
310:11 - contract kit slash chain link brownie
310:13 - contracts ronnie's going okay cool well
310:16 - what's the sat chain link thing so we
310:18 - need to tell brownie whenever we're
310:19 - using at chain link we're actually
310:21 - referring to this import so we need to
310:24 - tell the compiler this
310:26 - so let's add a new section we'll say
310:27 - compiler
310:29 - when it compiles sulk
310:31 - we need to remap
310:35 - at chain link
310:40 - say whenever you see at chain link here
310:44 - it means
310:46 - we're referring to this package
310:48 - so compiler soccer mappings at chain
310:51 - link
310:52 - is equal to this package up here now
310:55 - let's go ahead and try to compile
311:01 - perfect we see here that it compiles
311:04 - successfully and if we look at our build
311:06 - folder
311:07 - in the contract section we now have this
311:09 - new folder called dependencies
311:12 - and if we even expand this a little bit
311:14 - we can see
311:15 - it says dependencies smart contra kit
311:17 - chain link browning contracts at 1.1.1
311:20 - and this is what it downloaded from that
311:22 - github repository it downloaded
311:24 - aggregator v3 interface and smart math
311:27 - chain link because we're using both of
311:29 - those files in our solidity code all
311:32 - right great so let's write our first
311:33 - script to deploy this to a development
311:36 - ganache chain to brownie's built-in
311:38 - chain
311:39 - let's do this
311:40 - so in scripts let's go ahead we'll
311:42 - create a new file let's go ahead and
311:44 - build a simple deploy script to work
311:46 - with rink b and then we'll actually
311:48 - learn how to deploy this to our own
311:50 - local ganache development chain so let's
311:53 - build our deploy script so in scripts
311:55 - we'll do new file
311:58 - deploy.pi and we'll start by doing def
312:02 - deploy
312:03 - fund me
312:06 - then we'll do pass for now
312:08 - and then we'll do our entry point of
312:09 - deaf main and then we'll call
312:12 - deploy fund me in this file of course
312:15 - we're going to do from
312:17 - brownie
312:18 - import
312:19 - fund me
312:21 - so we can actually use this and let's go
312:24 - ahead and build this deploy fund me
312:25 - function so first we're going to need to
312:27 - get an account
312:30 - and same as last time we used a function
312:33 - called get account which would know to
312:35 - switch back and forth between if we were
312:36 - on development or if we were with an
312:39 - actual testnet that we could pull from
312:40 - our config we can actually once again
312:43 - copy that function
312:45 - and use that and use that in our script
312:47 - here so once again we can use that get
312:49 - account function that we had before what
312:51 - i like to do with this get account is
312:53 - add it into its own file called helpful
312:56 - scripts
312:57 - so what i'll do is create a new file
312:59 - called helpful
313:01 - scripts.pi
313:04 - and in here i'll add that getaccount
313:06 - function right so literally just pasted
313:08 - it from our last project and just a
313:10 - quick recap on what this is doing
313:12 - is we're saying if the network is in
313:14 - development we're going to use the
313:16 - accounts 0 syntax otherwise we're going
313:18 - to pull from our config
313:20 - and of course we're going to have to
313:22 - from brownie
313:24 - import network
313:27 - config
313:28 - and accounts
313:30 - and then of course in our browning
313:31 - config we're going to have to add
313:32 - wallets and from key so let's go to our
313:34 - config
313:36 - we'll do wallets
313:39 - from key
313:41 - and we'll add
313:42 - our private key environment variable
313:44 - setup
313:46 - which of course means that we're going
313:48 - to have to set dot env
313:51 - to dot e and v and we're going to create
313:53 - new file dot amv
313:56 - and we'll paste
313:57 - the exact same values from our last dot
314:00 - emv so it's going to be our private key
314:02 - and our project id kind of just a lot of
314:04 - the basics of the setup here
314:06 - but now that we've added this get
314:08 - account to its own script how do we
314:10 - actually use that in our deploy script
314:12 - depending on the version of python that
314:14 - you're in you might actually have to
314:15 - create a new file first named underscore
314:18 - underscore init underscore underscore
314:20 - dot pi
314:21 - you might not but just in case let's
314:23 - make it here because it doesn't hurt and
314:25 - with this now python knows that it can
314:28 - import from other scripts and other
314:30 - packages
314:31 - in this project so now we can do from
314:34 - scripts
314:36 - dot helpful scripts
314:39 - import get account so we're importing
314:43 - that get account function
314:44 - from our helpful script here and we're
314:47 - gonna make this get account function a
314:48 - little bit more robust a little bit
314:49 - later but for now it'll work perfectly
314:51 - for what we're looking to do now we can
314:53 - just run our typical deploy function
314:55 - funny we'll do the fundme contract
314:57 - equals fund me
314:59 - dot deploy
315:03 - and of course we'll do from
315:06 - account
315:12 - because again since this deploy is going
315:14 - to make a state change to the blockchain
315:16 - we always need to do a from account
315:18 - section here then we can even do a
315:20 - little print
315:21 - we'll do a print f here
315:23 - so we'll say
315:24 - contract
315:25 - deployed to
315:29 - fund me
315:30 - dot address
315:32 - this is how we'll get the address of our
315:34 - fund me and great we can even go ahead
315:36 - and try this out right now remember
315:38 - you'll need some testing
315:39 - ethereum in your metamask
315:42 - brownie run scripts deploy.pi
315:45 - dash dash network
315:49 - rank b
315:51 - and
315:53 - perfect contract deployed here it is
315:56 - we can even go to
315:58 - bring the ether
316:00 - scan again
316:05 - and we'd see the contract right here now
316:07 - this is great and all but if we look at
316:08 - our contract
316:09 - it's kind of this blank jarble of
316:12 - bytes here right nobody can actually see
316:14 - this contract and and easily interact
316:16 - with it and we want to make our
316:17 - contracts easy to interact with what we
316:19 - can do on etherscan is verify and
316:22 - publish our smart contracts to verify
316:24 - our smart contract all we have to do is
316:26 - hit that verify button
316:28 - we'll choose our solidity compiler type
316:31 - which we know is going to be
316:33 - 0.6.6
316:36 - and we know we're working with the mit
316:37 - license here
316:41 - now to continue we would then have to
316:43 - add in all of the
316:45 - rest of these pieces we'd have to do
316:47 - optimization which is going to be yes
316:49 - we'd enter our solidity contract code
316:51 - below which importing fund me like this
316:55 - wouldn't actually work
316:56 - because etherscan doesn't know what at
316:58 - chainlink contracts is
317:01 - so we would have to
317:02 - copy paste the code
317:04 - from these imports to the top of our
317:06 - contract here removing these imports and
317:08 - copy pasting the code associated with
317:10 - those files is known as flattening and
317:13 - this is an important concept for
317:14 - verifying our smart contracts on
317:17 - platforms like etherscan
317:19 - however brownie has a really nice way to
317:21 - get around this actually what you can do
317:24 - is go to their main site etherscan.io
317:27 - you can sign in and sign up and get an
317:29 - api key i've already signed up so i'm
317:32 - going to go ahead and sign in here
317:34 - log in and what we can do is we can go
317:36 - to my profile
317:38 - and scroll down to api keys
317:40 - and this is where we can create an api
317:43 - key for us to interact with and
317:45 - programmatically verify our smart
317:47 - contracts on etherscan i've already got
317:49 - one here but all we need to do is hit
317:51 - add
317:52 - we'll give it a name i'll call it verify
317:56 - browning continue and we've created this
317:59 - new api token that will allow us to
318:01 - verify our smart contracts what we'll do
318:04 - to use this in brownie
318:06 - is we'll copy this api key
318:09 - and we'll move back to our scripts here
318:11 - we'll set this api key as an environment
318:14 - variable so we'll do export
318:16 - the name of this is etherscan
318:19 - token
318:20 - and we'll set it equal to that key that
318:22 - we just got now to verify this all we
318:25 - have to do then is once we deploy this
318:27 - contract we'll tell brownie whether or
318:28 - not we want to verify the contract
318:31 - so after
318:32 - our dictionary here
318:34 - we'll do comma
318:36 - publish
318:37 - source equals
318:39 - true we're saying yes we would like to
318:41 - publish our source code
318:44 - now if we rerun this script
318:46 - let's see what happens again remember
318:48 - we'll do browning
318:50 - run
318:51 - scripts
318:53 - deployed up high dash dash
318:55 - network space
318:58 - rinkaby
319:00 - and says fund me has been deployed to
319:02 - here
319:03 - now we're going to say waiting
319:06 - for api
319:07 - rink b dot etherscan.io to process
319:10 - contract
319:11 - and we're submitting our code for
319:13 - verification here and it'll say
319:15 - verification pending verification
319:17 - complete pass verified it'll say where
319:20 - the contract has been deployed and
319:22 - what's been done with it
319:24 - now if we go back to ether scan again
319:26 - we're going to have to go back to rink
319:27 - be ether scan because we deployed this
319:29 - to rank b and we paste this in
319:32 - we now have this little check mark
319:34 - associated with our contract
319:36 - and if we click contract we can see all
319:39 - of the code in here
319:41 - for our contract
319:44 - we have contract fund me
319:45 - payable you need to get more everything
319:48 - that we defined in here and if we scroll
319:50 - up we can see that they did indeed
319:52 - flatten this contract right they
319:55 - pasted that aggregator v3 interface
319:57 - import
319:58 - and they also pasted that library safe
320:01 - math chain link now that's verified we
320:03 - can even read the contract see the
320:05 - different public variables in here such
320:07 - as the owner get version get price and
320:10 - all the exact same buttons that we saw
320:12 - in remix this read contract section is
320:15 - for all these view functions right the
320:16 - ones that aren't going to be making a
320:17 - state change
320:19 - right contract
320:20 - is going to be for when we want to call
320:22 - something like fund or withdraw and we
320:24 - could even go ahead and interact with
320:25 - this so for example we could connect to
320:27 - web3
320:28 - metamask
320:30 - okay and it would automatically get
320:32 - connected to our metamask here then we
320:34 - could call fund and withdraw just like
320:36 - we did in remix if you want to give it a
320:38 - shot go for it all right we're back in
320:40 - our code editor after successfully
320:42 - verifying one of our smart contracts on
320:43 - etherscan now just a quick note
320:45 - sometimes the verification process can
320:47 - be a little bit touchy and for version
320:49 - of solidity 0.8.4 there's currently a
320:51 - bug that makes it verifying a little bit
320:53 - tricky but it's being worked on so don't
320:55 - be discouraged if it gets a little bit
320:56 - funky so this is great that we've
320:58 - written a deploy script for deploying
320:59 - directly to ring b however as you know
321:01 - we're always going to want to be able to
321:02 - deploy to our own local blockchains or
321:06 - or brownies built-in development chain
321:07 - so we can test a lot quicker and that
321:11 - yes so that we can write some tests but
321:13 - we have a little bit of an issue here
321:14 - the first issue being that our fundme
321:16 - contract currently has an address
321:19 - hard-coded to work with the rink be
321:21 - chain so in fact the way it's written
321:23 - right now it's going to be hard to work
321:24 - with any other chain other than ring b
321:26 - the second bit is that these price feed
321:28 - contracts don't exist on a local ganache
321:31 - chain or a gnost chain that brownie
321:33 - spins up there's two ways we can get
321:34 - around this we can do what's called
321:36 - forking and work on a forked simulated
321:38 - chain
321:39 - or we can deploy a mock or deploy a fake
321:42 - price feed contract on our ganache local
321:44 - development chain deploying mocks is a
321:46 - common design pattern used
321:48 - across all software engineering
321:49 - industries and what it applies doing is
321:51 - deploying a fake version of something
321:54 - and interacting with it as if it's real
321:57 - so again right now if i run brownie
322:01 - run
322:03 - scripts deploy.pi and i don't set this
322:06 - network flag we're going to actually
322:07 - have a default spinning up a ganache
322:09 - chain it's even going to try to verify
322:12 - which it's going to run into an issue
322:13 - because we can't verify on a ganache
322:15 - chain so we have a couple issues that we
322:17 - need to address here in order for us to
322:19 - get this to work on a ganache chain
322:21 - similar to how in this get account
322:23 - function in our helpful scripts
322:26 - we do a little bit checking we say hey
322:28 - if we're on a development network
322:30 - use this development accounts version
322:33 - otherwise
322:34 - pull from our config
322:36 - we can do that exact same mentality but
322:39 - with working with these marks so the
322:40 - first thing that we need to do is we
322:42 - need to parameterize our fund me
322:45 - solidity smart contract
322:47 - so that we don't have this hard-coded in
322:49 - here anymore so what we can do
322:51 - is right when we deploy this contract
322:54 - we'll tell it what price feed address it
322:56 - should use right when we call our deploy
322:59 - function here instead of having it hard
323:01 - coded
323:02 - and we can add this parameter to our
323:04 - constructor we'll say
323:06 - address
323:08 - price feed
323:10 - as an input parameter and whatever input
323:13 - parameter we use here is going to be our
323:15 - global price feed address so instead of
323:18 - us creating
323:19 - these aggregator v3 interface contracts
323:21 - right in the functions here we're just
323:23 - going to create a global one so we'll
323:25 - say
323:27 - aggregator
323:28 - v3 interface public
323:31 - price feed
323:33 - and right in our constructor
323:35 - right when we create this we'll set
323:38 - price feed
323:40 - equals
323:42 - aggregator v3 interface
323:46 - price feed
323:48 - and now what we can do is we can just
323:50 - delete this part because as you can see
323:52 - this is doing the exact same thing
323:54 - is up here this is doing aggregator v3
323:56 - interface price feed equals aggregator
323:58 - v3 interface and then the address here
324:00 - and we're going to do the exact same
324:02 - thing but in our constructor meaning
324:04 - right when we deploy this contract so we
324:06 - can delete this
324:08 - and we can delete it here as well in our
324:10 - get price function we can even verify
324:12 - this with brownie
324:14 - compile
324:17 - great looks like it's compiling
324:19 - perfectly
324:20 - now
324:20 - our deploy function is going to need to
324:22 - look a little bit different we're going
324:24 - to need to pass
324:26 - the price feed address
324:29 - to our fund me contract to do this all
324:32 - we'd have to do is paste
324:36 - that address before we have our from
324:39 - account variable here
324:40 - so this is how you can actually pass
324:42 - variables to constructors anything
324:44 - inside this constructor function you can
324:46 - pass through brownie in our deploy
324:48 - script here so great so we could 100
324:51 - always just pass this rink b address
324:53 - here but that's not really going to
324:54 - solve our problem obviously right the
324:56 - problem is that the problem right now is
324:57 - that we always have this ring b address
324:59 - when we say if we are on
325:02 - a persistent network like rink b
325:06 - use the associated
325:09 - address
325:11 - otherwise
325:12 - deploy mocks and i know we've been
325:14 - talking about mocks we'll get into them
325:15 - in a second but let's first set this one
325:17 - up here so we can check what network
325:19 - that we're on again by importing from
325:21 - browning this network bit and we can say
325:23 - if
325:24 - network dot show
325:26 - active
325:27 - does not equal
325:30 - development then
325:33 - we'll say price feed
325:36 - address
325:38 - equals
325:41 - this address here and we'll just pass
325:43 - this price feed address now this still
325:46 - doesn't solve our issue because we're
325:47 - just always passing this the rink be
325:49 - hard-coded piece here so what we want to
325:50 - do is parameterize where we get these
325:52 - addresses from so instead what we can do
325:55 - is in our browning config we can add
325:58 - different addresses for different
325:59 - networks so right underneath our dnv
326:02 - we'll add a new section called networks
326:04 - and we'll do one called rink b and we'll
326:06 - say the fusd
326:11 - price feed
326:12 - address is going to be
326:14 - this price feed address now what we can
326:17 - do in our deploy script
326:20 - is we can say
326:21 - if we're not on a development network
326:23 - let's grab the address from our networks
326:26 - section this way we can define
326:29 - different addresses for this price feed
326:31 - across different networks so we can add
326:34 - we could add a coven section
326:37 - we could add a mainnet section any other
326:39 - networks that we want to work with all
326:40 - we need to do is add add these flags for
326:42 - those contracts so back in our deploy
326:44 - now we can see the price feed address is
326:46 - going to get pulled from the config
326:48 - instead so we'll say config and
326:51 - this means we're going to import config
326:55 - or brownie
326:57 - say config of networks
327:01 - based off of the network dot show
327:05 - active
327:08 - and then we'll use the fusd price feed
327:11 - flag here
327:13 - perfect
327:14 - so this little if statement is going to
327:16 - say hey if we're not on a development
327:18 - network
327:19 - pull the address right from the config
327:21 - and this will make it so that we can
327:22 - deploy to really anywhere that we want
327:24 - to deploy to but what if we are on a
327:26 - development chain well what do we do
327:27 - then we can say else if we're not on a
327:30 - development chain we're going to have to
327:31 - deploy a mock so right now
327:33 - on all these live networks that we're
327:35 - working with there is a version of this
327:37 - price feed contract this price feed
327:39 - address our development chain obviously
327:41 - there won't be one because it's going to
327:43 - start off as blank so what we can do is
327:45 - we can deploy our own version of the
327:47 - price food contract this is known as
327:49 - mocking and we can interact with it
327:51 - accordingly in order for us to deploy a
327:53 - price feed contract ourselves we're
327:55 - obviously going to need to have the
327:56 - solidity code associated with it so what
327:58 - we can do
328:00 - is in our contract section we'll create
328:02 - a new folder called test
328:07 - when you create a test folder in your
328:09 - contracts folder this is typically where
328:11 - mock contracts are going to go and we'll
328:13 - create a new file
328:15 - called mock
328:16 - v3
328:18 - aggregateor dot sol
328:21 - and this is where we'll add the code for
328:23 - us to deploy our own price feed now i'm
328:25 - going to show you another repository
328:27 - pretty soon called the chain link mix
328:29 - that we're going to work with
328:31 - for now if you're looking for one of
328:32 - these mocks i highly recommend just
328:34 - pulling it from this chain link mix
328:36 - repository so we can grab it by going to
328:39 - contracts
328:40 - test
328:42 - and grabbing my aggregator dot soul we
328:44 - can just copy this whole code
328:47 - and paste it into our mockv3
328:49 - aggregator.sol this has all the same
328:52 - exact functions as a real price feed
328:53 - contract such as decimals and latest
328:56 - answer which are going to be two of the
328:57 - ones we use the most we can also see its
328:59 - constructor here
329:01 - these are the variables that it takes
329:03 - whenever this contract is deployed
329:05 - it takes a decimals and an initial
329:08 - answer decimals is of course going to be
329:10 - how many decimals that this contract
329:12 - should have an initial answer is going
329:14 - to be its starting value like 2000 for
329:16 - example once we have this contract in
329:19 - our test section we can of course run
329:21 - brownie compile and brownie will go
329:23 - ahead and compile this mock v3
329:25 - aggregator as well because remember
329:27 - brownie compiles any contract in this
329:30 - contracts folder let's go back to our
329:32 - deploy script now that we have this mock
329:34 - v3 aggregator in here now we can do is
329:37 - we can do a little else here
329:38 - saying okay well if we are on a
329:40 - development chain let's do something
329:42 - let's deploy these mocks so let's do a
329:45 - little print statement here a little
329:46 - printf saying
329:48 - the active network
329:50 - is
329:51 - we'll do network
329:53 - dot show active
329:58 - another print statement print f saying
330:01 - deploying
330:02 - mocks dot dot dot oops i need a little
330:05 - closing there
330:07 - and this doesn't need to be print f
330:09 - it can just be a regular print and then
330:11 - now the same way we import fund me we
330:14 - can import mach v3 aggregateor
330:19 - we can just deploy this contract the
330:21 - same way we deploy all of our other
330:23 - contracts so we'll do mach v3 aggregator
330:26 - dot deploy and as we just learned we
330:28 - have to add the parameters the
330:30 - constructor takes which is going to be
330:32 - decimals and initial answer
330:34 - so maybe we'll set decimals to 18 and
330:36 - then maybe we want to set the initial to
330:38 - answer to 2000 so two one two three one
330:41 - two three four five six seven eight nine
330:42 - ten one two three four five six seven
330:44 - eight comma and of course since we're
330:46 - deploying we've got to do a from
330:50 - and we'll use our account here
330:52 - we'll do another print
330:54 - saying
330:57 - mox
330:58 - deployed and of course we're going to
331:00 - need to get this mock v3 aggregator's
331:02 - address so we'll do
331:04 - mock aggregator
331:06 - equals this and we'll set
331:09 - price
331:11 - feed address
331:12 - to equal
331:14 - our mock aggregator dot address
331:18 - and now we're development or live
331:20 - network agnostic if we deploy this on a
331:23 - live network we'll use the address from
331:25 - our config otherwise we'll use a fake
331:27 - aggregator contract that we've deployed
331:29 - let's go ahead and even try this on a
331:31 - development network
331:33 - so we can do brownie
331:35 - run scripts deploy.pi we don't need a
331:38 - network flag here we'll hit enter it'll
331:40 - spin up the ganache
331:42 - and we even will deploy a mock
331:45 - aggregator contract first
331:47 - and then we'll do our fund me part of
331:50 - course we are running to an issue
331:51 - because we're trying to verify a
331:54 - contract on a chain that doesn't exist
331:56 - etherscan doesn't know about our local
331:57 - gnost chain so to fix this
332:00 - instead of doing publish source equals
332:02 - true we can have this published source
332:04 - be again based on what chain that we're
332:06 - on so we'll go back to our browning
332:07 - config and for rank b
332:09 - we'll say verify
332:11 - will be true but for development
332:15 - we'll say verify will be false and back
332:18 - in our deploy script we now say publish
332:20 - source
332:21 - is going to be pulled from our config so
332:23 - again we'll do config
332:28 - networks
332:30 - network dot show active
332:33 - and then we'll do dot get
332:35 - verify
332:37 - this dot get verify
332:39 - will make our lives a little bit easier
332:41 - if we forget to add verify in here you
332:43 - could still do like this
332:45 - like verify but you run into some index
332:47 - errors if you forget to actually put the
332:48 - verify so sometimes i get lazy and uh
332:51 - it's just a little bit nicer like this
332:52 - now if we run this again
332:54 - deploy.pi
332:56 - we'll spin up our local ganache we'll
332:58 - deploy a mock price feed contract
333:01 - and then we'll deploy our fund me
333:02 - contract
333:04 - and it completes successfully so this is
333:06 - awesome we have a way
333:09 - our fund me contract that uses a price
333:11 - feed contract to our own local
333:13 - development environment with a mock aka
333:15 - a fake price feed contract this is
333:18 - awesome now this is great but our deploy
333:20 - script is starting to look a little big
333:21 - and a little clunky so let's actually
333:23 - clean this up to make it look a lot
333:25 - nicer the first thing that we want to do
333:27 - is we want to fix this this big 2000
333:30 - number just looking at right away i'm
333:32 - not exactly sure how many zeros it has
333:34 - so to make this look a little bit nicer
333:36 - and more readable we can once again call
333:38 - on our friend web3.pi from
333:41 - web3
333:42 - import
333:43 - web3
333:45 - and down here we'll do web3.2
333:48 - way
333:49 - 2000
333:51 - comma
333:52 - ether this two-way function will just
333:55 - add 18 decimals to this 2000 so now this
333:58 - is much more readable that the initial
334:00 - value for this is going to be 2 000. the
334:02 - next bit is that we're always deploying
334:04 - this mock v3 aggregator here and if we
334:07 - already have a mock deployed to whatever
334:09 - network that we're working on we don't
334:10 - need two marks here so what we can do
334:13 - then is right before
334:15 - we deploy this mock is we can do a
334:17 - little if statement
334:18 - we can say if
334:20 - the length
334:22 - of our
334:23 - mock v3
334:26 - aggregator
334:30 - is less than or equal to zero
334:32 - only then will we deploy
334:35 - this mock v3 aggregator remember we can
334:37 - check the length of our v3 aggregator
334:39 - because this v3 aggregator is just going
334:41 - to be a list of all the different v3
334:43 - aggregators that we've deployed now
334:46 - instead of using mock
334:48 - aggregator.address we can just
334:50 - use mach v3 aggregator
334:54 - minus one dot address so we're just
334:56 - saying okay great just use the most
334:58 - recently deployed mock v3 aggregator
335:01 - and then of course we don't we no longer
335:03 - need to set this as a variable and that
335:05 - looks a little bit cleaner and we'll
335:06 - make this a little bit more efficient so
335:08 - this deploying mox bit though is going
335:10 - to be something that so this deploying
335:11 - mox bit though is going to be something
335:13 - that we're actually going to do
335:14 - relatively frequently let's even move
335:16 - this print statement up here so instead
335:19 - what i like to do is put this whole mock
335:20 - deploying bit in its own function in our
335:22 - helpful scripts so let's open back up
335:24 - our helpful scripts we'll do a new
335:27 - function called def
335:29 - deploy mocks
335:32 - and we'll just paste that code in here
335:33 - of course this means that in our helpful
335:35 - scripts we're gonna have to import
335:37 - mock v3 aggregator we'll also have to do
335:39 - from web3
335:42 - import
335:43 - web3 instead of account we'll just use
335:46 - this get account function now back in
335:48 - our deploy script
335:49 - we just delete this whole part
335:51 - replace with
335:52 - deploymox
335:55 - and then import deploymox from our
335:57 - helpful scripts
335:59 - and then we can also delete this import
336:01 - now let's remove some of these comments
336:03 - if you'd like this is starting to look a
336:05 - lot more sophisticated and this is great
336:07 - because now we have a way to deploy base
336:09 - off if we're on a live chain or a
336:11 - development chain and then one more
336:13 - thing i like to
336:14 - do so that everything is parameterized
336:18 - i like to set these as static variables
336:21 - in the top of our helpful scripts
336:23 - so i'll set decimals
336:25 - equals 18
336:27 - and then i'll set starting
336:31 - price
336:32 - equals 2000 and then i'll have
336:35 - mock v3 aggregator to deploy to decimals
336:38 - web 3.2 way
336:40 - to
336:41 - starting price here
336:43 - so no so let's say now that i wanted to
336:44 - deploy this to my own ganache instance
336:47 - well what we could do is we can open up
336:49 - our ganache here we'll do quick start
336:51 - and we'll just quickly create our own
336:53 - ganache blockchain in our script let's
336:56 - go ahead and just run this deploy script
336:58 - again
336:59 - let's see what happens instead of
337:01 - brownie spinning up its own ganache here
337:04 - it says attached to local rpc client
337:06 - listening ad and then this address here
337:09 - brownie is smart enough to detect if
337:11 - you're running your own ganache instance
337:13 - here and will automatically
337:15 - attach itself to it knowing that that is
337:18 - going to be a development environment if
337:20 - we go to our ganache we'll see
337:22 - we have two transactions which are going
337:24 - to be
337:25 - contract creations we're going to create
337:27 - a price feed contract and then also our
337:29 - fund b contract so this is great this is
337:32 - great for testing quickly and locally
337:33 - but there is an issue with this for
337:35 - development networks again brownie
337:37 - doesn't keep track of those so in our
337:39 - build folders if we go to deployments we
337:41 - only are saving stuff from the rink b
337:44 - chain here so we would need to tell
337:45 - brownie hey there's another network that
337:47 - we want you to work with and we want you
337:49 - to remember the deployments to that
337:52 - chain so what we can do is we can add a
337:54 - new network to our browning networks
337:56 - list remember
337:58 - in brownie
338:00 - networks list we have all these
338:02 - different pieces in here these are the
338:03 - ones that brownie is going to not
338:05 - remember and these are going to be the
338:07 - ones that brownie remembers so let's say
338:09 - we want to deploy to a grenache chain
338:11 - and we want brownie to remember those
338:12 - deployments well we can add a network
338:15 - here and this is going to be how we add
338:17 - any blockchain that we want any evm
338:20 - blockchain like avalanche like polygon
338:22 - etc to add a new network to the brown
338:24 - networks is we'll run
338:27 - brownie
338:28 - networks add
338:30 - we'll choose development or ethereum
338:34 - we're going to choose ethereum because
338:35 - we want this to be a persistent network
338:37 - we'll do ethereum
338:39 - we'll give it a name i'm going to call
338:40 - this ganache
338:43 - local
338:45 - we need to give it a host
338:47 - aka an http address which
338:50 - we know
338:52 - is right here
338:57 - and then i'm just gonna
338:59 - make this lower case
339:05 - and then a chain id
339:08 - which for this we know is one three
339:10 - three seven
339:13 - hit enter
339:14 - now if i do brownie networks list i see
339:17 - a new blockchain called ganache local
339:20 - and this is going to reach out to our
339:23 - ganache ui or our ganache command line
339:26 - depending on what we're running now just
339:27 - a note we are going to be deploying to
339:29 - this ganache ui or ganache cli
339:32 - a lot for the rest of this lesson so
339:34 - please keep your ganache instance
339:35 - running now what i can do
339:37 - is i can run brownie
339:39 - run scripts deploy.pi
339:42 - network
339:43 - ganache
339:44 - local let's see what happens of course
339:47 - we run into our first issue ganache
339:49 - local isn't development so it's going to
339:52 - go ahead and try to pull from our config
339:55 - file we don't want this we want to
339:57 - actually deploy mock for our local
339:59 - ganache if a mock hasn't been deployed
340:01 - so what we can do
340:02 - is we can extend our definition of what
340:05 - a development environment is in our
340:06 - helpful scripts we can add a flag in
340:08 - here we'll say local
340:12 - blockchain and vi romance
340:16 - equals and this will be a list we'll say
340:19 - development
340:20 - of course will be one but we can also
340:22 - say
340:23 - ganache
340:25 - local
340:26 - will be another and now we can import
340:28 - this local blockchain environments into
340:31 - our deploy so from at the top from
340:33 - scripts.helpful scripts
340:35 - do a comma here
340:36 - paste that and save
340:38 - mine gets reformatted which is really
340:39 - nice and instead we'll say if
340:42 - network.showactive
340:45 - not in
340:47 - local blockchain environments
340:49 - then go ahead and pull from the config
340:50 - what this is saying is it's saying if
340:53 - whatever network that we're on if it
340:55 - isn't development
340:56 - or ganache local
340:59 - then go ahead and use a config
341:01 - if it is one of these two
341:03 - we're gonna go ahead and deploy a mock
341:05 - here now that we have that let's try
341:07 - this again ronnie run scripts
341:10 - deploy.pi dash dash network
341:14 - ganache
341:16 - local and we run into a different issue
341:18 - we're saying hey you don't actually have
341:20 - enough gas well
341:22 - why is this let's look at our get
341:24 - account function aha this one is also
341:27 - looking directly for this development
341:29 - chain this one will say if
341:30 - network.showactive
341:32 - is in
341:35 - local blockchain environments then
341:37 - return accounts zero so we're saying if
341:39 - the network we're working on is
341:40 - development
341:41 - or our ganache local then just return
341:44 - accounts zero so let's try this okay
341:46 - we're getting closer now we're running
341:48 - to this key error of ganache local
341:50 - well we do know how to fix that as well
341:52 - in our config we'll add this new network
341:55 - we'll say ganache local
341:57 - and we'll set verify
341:58 - to false so let's try this one more time
342:01 - perfect now mocks have been deployed and
342:04 - our fundme has been deployed
342:06 - and if we look in our build folder in
342:08 - deployments we now have a new chain id
342:10 - for one three three seven for saving
342:12 - these deployments and it looks like in
342:15 - our ganache chain we have these actually
342:17 - saved in here which is great now an
342:19 - important thing to note if you were to
342:20 - close this or delete this ganache chain
342:23 - all of your contracts will be lost so
342:25 - you won't be able to interact with them
342:26 - again to account for this you can always
342:29 - delete 1337 and delete the entries in
342:33 - one three three seven from your map.json
342:36 - or if you're fine deleting the whole
342:37 - build folder you can delete the whole
342:39 - build folder so now that we've deployed
342:40 - this let's actually write a script to
342:42 - interact with this so let's create a new
342:44 - file we'll call it fund and
342:47 - withdraw
342:48 - dot pi
342:49 - and this will be the script we use to
342:51 - fund and withdraw so let's create a
342:53 - function called
342:54 - fund we can say fund me
342:57 - equals
342:58 - the most recently deployed
343:00 - fund me we have to do from
343:02 - brownie
343:04 - import fund me we're gonna have to get
343:05 - an account since we are gonna be making
343:07 - some state changes and we just have this
343:09 - equal to get account
343:11 - and we can do from
343:13 - scripts dot helpful scripts
343:17 - import
343:18 - get account
343:20 - let's get the entrance fee so we can
343:21 - figure out how much we want to fund
343:24 - actually sorry since this is going to
343:26 - resemble that fusd price feed it
343:28 - actually only has eight decimals two one
343:31 - two three four two thousand and one two
343:32 - three four five six seven eight
343:34 - the reason we want to do it like this
343:36 - too
343:36 - is because
343:38 - in our get price function we know that
343:40 - it only has eight decimal places so
343:42 - we're multiplying it by an additional 10
343:44 - here
343:45 - we want to resemble that as well so
343:47 - we'll do eight decimals starting price
343:49 - of 2000 with eight decimals here and for
343:51 - our mock v3 aggregator we're just going
343:52 - to use those exact values and we're not
343:55 - going to do the web 3 converting we're
343:56 - just going to make it exactly those
343:57 - hard-coded values now we're going to
343:59 - want to get the entrance fee so i've
344:01 - gone ahead and actually added a function
344:03 - called get entrance fee to our contract
344:05 - to make our lives a little bit easier
344:07 - here i'm going to recommend that you
344:08 - take a look at this and then
344:10 - type it in yourself or you just copy
344:12 - paste it from the github repository so
344:14 - that we can use this get entrance fee
344:16 - because it's just a whole bunch of math
344:17 - here so back in our fund and withdraw
344:19 - what we can do then is we can do
344:21 - entrance fee
344:24 - equals
344:25 - fund me dot get
344:27 - entrance fee
344:29 - excuse me get interested
344:32 - and we can even print out this entrance
344:34 - fee just to see if we're doing it right
344:36 - but first we're going to want to run
344:38 - brownie
344:39 - run scripts
344:41 - deploy
344:42 - network ganache local because we changed
344:45 - our fundry.soul
344:48 - all right great
344:50 - and now we can run brownie
344:52 - run scripts
344:54 - find and withdraw
344:56 - network
344:57 - local
345:00 - and whoops i need a main function so
345:02 - we'll do def main
345:04 - fund in here
345:06 - and let's rerun this
345:09 - and great we can see this is the
345:10 - entrance fee do a little print statement
345:12 - here printf saying the current
345:16 - entry fee
345:17 - is
345:20 - entrance fee
345:22 - we'll do a little print saying
345:26 - funding
345:28 - and then we'll call fundme.fund
345:33 - and of course we're going to do a from
345:36 - account
345:37 - and we're also going to send a value
345:40 - of
345:41 - entrance fee
345:45 - any low level transaction data that we
345:47 - want to send with our transactions and
345:50 - function calls we'll add in this little
345:51 - bracket piece here let's set up let's do
345:54 - brownie run scripts funder withdraw
345:56 - again
345:57 - and great it looks like it's going
345:58 - through perfectly
346:00 - awesome let's also do a withdraw
346:02 - function for the owner to withdraw
346:05 - we'll say fund me equals fund me
346:08 - minus one
346:10 - do account
346:12 - equals get account
346:15 - and then we'll just call fund me
346:17 - dot withdraw
346:22 - from
346:24 - account
346:27 - and then right after fund is called
346:29 - we'll have withdraw be called and our
346:30 - main function here
346:33 - let's go ahead and try this
346:35 - brownie run scripts
346:38 - find and withdraw
346:39 - network
346:42 - ganache local
346:47 - this is our funding script
346:49 - our funding transaction going through
346:51 - and then our withdrawal transaction
346:53 - going through perfect so it looks like
346:55 - our approximate functionality here works
346:57 - great and this is a script that we can
346:58 - run on a main network if we'd like
347:01 - now again it's still much better for us
347:03 - to run so now we're going to move into
347:06 - actually
347:07 - writing those tests and for these tests
347:10 - we're going to want to quit our ganache
347:12 - ui let's go ahead and write some of
347:14 - these tests create a new file
347:15 - called test
347:17 - fund me
347:18 - dot pi we'll quickly speed through this
347:20 - test because we're not going to learn
347:21 - too much new here keep in mind when
347:23 - we're on this test we're going to want
347:24 - it to be able to work independent of the
347:26 - network that we're working on so let's
347:28 - just keep that in mind let's do a test
347:30 - just to see if we can fund a withdrawal
347:31 - so we'll do def test
347:33 - can fund
347:34 - and
347:35 - withdraw
347:37 - and we'll do basically exactly what
347:38 - we've done before
347:40 - do account equals get account
347:42 - of course
347:46 - we'll do from scripts
347:47 - that helpful scripts
347:50 - import get account then we'll want to
347:52 - deploy fund me and we can even just use
347:56 - our deploy fund me script in our
347:57 - deploy.pi so we can do from
348:00 - scripts
348:01 - dot deploy
348:03 - import
348:04 - deploy
348:05 - fund me in our deploy fund me at the
348:08 - bottom we'll just say return
348:11 - fund me so that our test can now have
348:13 - this fundme contract for it to work with
348:15 - so now we'll say fund me
348:18 - equals
348:19 - deploy
348:20 - fund me
348:22 - grab the entrance fee
348:24 - which will be equal to
348:26 - fund me dot get
348:28 - entrance fee
348:31 - and then let's go ahead and fund it so
348:33 - do transaction equals fund me
348:36 - dot fund
348:38 - and we'll call from
348:40 - account
348:41 - we'll do value
348:43 - entrance fee
348:47 - we'll do tx.weight one
348:49 - we'll do an assert here we'll do assert
348:53 - fund me dot address
348:56 - to amount
348:58 - funded
349:00 - it's going to be account dot address
349:03 - it's going to be equal to the entrance
349:04 - fee
349:05 - so we want to check
349:07 - that our address
349:09 - and the amount that we funded is being
349:11 - adequately recorded and then we'll do
349:13 - transaction two will be fund me
349:16 - dot withdraw
349:20 - from
349:21 - account
349:24 - tx2.weight
349:26 - one
349:28 - and then we'll assert
349:29 - fund me dot address
349:32 - to amount funded
349:35 - account dot address
349:38 - equals zero
349:40 - and let's go ahead and run this test so
349:42 - we'll do brownie
349:44 - test
349:48 - and perfect looks like it's doing well
349:50 - now you may be wondering why sometimes
349:51 - we use the dash dash network flag and
349:54 - sometimes we don't in our network
349:56 - section brownie automatically picks a
349:58 - default network to use and the default
350:02 - is always set
350:04 - to development
350:05 - however we could set this to be anything
350:08 - that we wanted we could set the default
350:09 - to be ganache
350:11 - local we could set it to be rink b
350:13 - whatever we want it here whatever you
350:14 - set for the default in your brownie
350:16 - config is what the network will be
350:18 - defaulted to so right now when we run
350:20 - brownie test this is equivalent to
350:22 - running brand test dash dash
350:25 - network
350:26 - development we can even go ahead and run
350:28 - that too now we could also run this test
350:31 - on rink b and we will in a second but
350:32 - oftentimes we don't want to test all of
350:35 - our functionality on rink beat and on
350:38 - live networks because it's going to take
350:39 - a long time for them to run so sometimes
350:42 - we only want to run tests
350:44 - on our local chains well how do we do
350:46 - that we can use pi tests skip
350:49 - functionality to do so to work with pi
350:50 - test we're going to first need to
350:52 - install it so go ahead and run pip
350:54 - install pi test to demonstrate this
350:56 - let's create a test that makes sure only
350:59 - the owner can withdraw and nobody else
351:01 - can so we'll call this def test only
351:05 - owner
351:07 - can
351:08 - withdraw
351:09 - to skip this test if we're not on a
351:11 - local network we'll first check the
351:13 - network we'll say if
351:15 - network.showactive is not in
351:18 - and yep probably would have guessed it
351:20 - we're going to pull this local
351:21 - blockchain environments in from our
351:23 - helpful scripts so we'll do comma local
351:25 - blockchain environments
351:27 - and we're going to say if the network
351:29 - dot showactive
351:31 - is not in this list of local blockchain
351:34 - environments we're going to do pi
351:35 - test.skip
351:37 - and say only for local testing
351:42 - of course we're going to import network
351:48 - and we're also going to import pi test
351:51 - now if i try to run
351:52 - this test here
351:55 - with brownie
351:57 - test
351:58 - dash k
351:59 - dash dash network rinkeby it should skip
352:04 - perfect and we do see with this s here
352:06 - meaning that it's skipped this function
352:08 - if we run this
352:10 - with dash network
352:12 - development
352:13 - it should go ahead and run this and it
352:14 - will pass because nothing happens in
352:16 - this function and it does perfect let's
352:18 - keep going so now we'll say account
352:21 - equals get account
352:23 - we'll say fund me
352:25 - equals
352:27 - deploy
352:28 - fund me
352:29 - and now let's get a different account
352:32 - to try to call the withdraw function
352:34 - so we'll say bad actor
352:37 - equal and this will just give us a blank
352:40 - random account
352:41 - but we do have to import accounts
352:44 - from about here
352:45 - now we want to test to see that them
352:48 - calling this withdraw function actually
352:50 - reverts them and causes an exception
352:53 - because if i try to do
352:54 - fund me
352:55 - dot withdraw
352:58 - from
352:58 - [Music]
353:02 - bad actor right now
353:04 - what do you think will happen well that
353:06 - well we know in our fundme.soul our
353:09 - withdrawal function has the only owner
353:11 - modifier so technically only the owner
353:14 - should be able to call this function
353:16 - so what happens actually we don't even
353:18 - need this account get account bit let's
353:19 - just go ahead delete that so what
353:21 - happens if somebody else tries to call
353:24 - this withdraw function well let's go
353:26 - ahead and test this we'll do browning
353:29 - test
353:31 - dash k
353:33 - test only owner can withdraw
353:36 - hmm and you can see we're getting this
353:38 - error here writing
353:39 - browning.exceptions.virtualmachineerror
353:42 - revert from this fundme.withdraw well we
353:45 - want this to happen we were expecting
353:47 - this to happen so how do we test that we
353:49 - want this to happen well we just need to
353:51 - tell our test that we want this to
353:52 - happen
353:53 - so first we're going to import from
353:55 - brownie this exceptions
353:58 - package this way we can tell our test
354:01 - exactly what exception we're expecting
354:02 - to see then we'll say with
354:05 - pi test
354:06 - dot
354:07 - raises
354:08 - exceptions dot
354:10 - virtual machine error
354:14 - fund me
354:15 - dot withdraw
354:17 - and then we'll just actually we'll just
354:19 - copy this line down here
354:20 - now what this is telling our test is
354:23 - that if this reverts with this virtual
354:26 - machine error that's good we're saying
354:28 - we want you to revert when you try to
354:30 - call this line so if we delete this line
354:33 - and hit up and try to run this again
354:36 - we can see that it now passes and this
354:39 - is exactly what we're expecting so this
354:41 - is awesome all right we've learned a lot
354:43 - of fantastic tools for working with
354:45 - brownie here now the last version of
354:47 - testing that i want to show you how to
354:48 - use is mainnet forking maintenance
354:50 - forking is incredibly powerful when
354:52 - we're working with smart contracts on
354:54 - mainnet that we want to test locally so
354:56 - let's talk about forking for a minute so
354:59 - on the left here i have a blockchain
355:00 - right an example of a blockchain this is
355:04 - going to be like a test net
355:06 - like rinkaby
355:08 - or something like mainnet right this is
355:10 - going to be a blockchain that we
355:11 - actually deploy to
355:13 - now there are a whole bunch of blocks in
355:14 - here right and there's a huge chain that
355:17 - we can actually work with all this
355:19 - information is public information right
355:21 - this block is going to have like
355:24 - transaction
355:25 - transaction
355:28 - transaction
355:30 - it's going to have you know each one of
355:32 - these blocks is going to have a whole
355:33 - bunch of transactions and all this
355:35 - information is here in addition to all
355:37 - these transactions it's going to have
355:41 - price feed contracts
355:44 - ave contracts
355:46 - you know et cetera it's going to have
355:47 - all these different contracts in it so
355:50 - hypothetically if it's already there we
355:52 - should be able to basically copy this
355:55 - all this whole blockchain and do some
355:57 - simulations ourselves
355:59 - and that's exactly what forking does
356:02 - a forked blockchain literally takes a
356:05 - copy of an existing blockchain on the
356:08 - left here and brings it into our local
356:10 - computer for us to work with we actually
356:13 - have control of this blockchain since
356:15 - it's going to run on our local computer
356:17 - similar to ganache now all the
356:19 - interactions that we do on this local
356:21 - blockchain are not going to affect the
356:23 - real blockchain because it's our local
356:25 - chain right it's a simulated blockchain
356:27 - but because it's simulated we can go
356:29 - ahead and interact with price feeds we
356:30 - can interact with avid we can interact
356:32 - with all these different contracts that
356:33 - are already going to be on chain
356:35 - maintenance fork is a built-in part of
356:37 - brownie and also pulls from inferior the
356:39 - same way it works with rink b and coven
356:41 - and everything else we can start to
356:43 - interact with the mainnet fork contracts
356:45 - the exact same way therefore so we can
356:47 - take this whole ring big section
356:50 - copy it
356:51 - paste it
356:52 - and we'll just change this fusd price
356:55 - feed address
356:57 - to its mainnet address so we'll go to
356:59 - docs.chain.link
357:00 - ethereum price feeds
357:04 - get fusd here
357:06 - copy that
357:08 - and we'll paste it into here and we'll
357:10 - change this to mainnet fork and since
357:12 - this is going to be a fork of course for
357:14 - verify we're going to do false
357:17 - now if we try to run one of our scripts
357:19 - like brownie run scripts deploy.pi
357:22 - network
357:23 - mainnet fork
357:24 - you'll see we'll actually run into an
357:26 - issue here it's saying insufficient
357:28 - funds for transfer in our deploy script
357:32 - when we do our get account and our
357:34 - helpful scripts
357:36 - right now we're using accounts.ag config
357:39 - while it's from key yes it's going to be
357:41 - our account which right now has zero
357:43 - money in it on mainnet so brownies right
357:45 - away gonna say hey you don't have any
357:47 - money on mainnet what's the deal so we
357:49 - need to tell brownie that when we're
357:51 - working with mainnet fork it should
357:53 - create us a fake account with a hundred
357:55 - ethernet however
357:57 - we don't want it to deploy a mock
358:00 - because the price feed contracts already
358:02 - exist so we don't want it to deploy a
358:04 - mock but we do want it to get us an
358:07 - account here so typically what i like to
358:09 - do
358:10 - is i'll add another variable here and
358:12 - i'll call it
358:14 - forked
358:15 - local environments
358:19 - and i'll add
358:21 - maintenant fork in here and i'll use
358:23 - this now as part of my if statements
358:26 - so i'll say if network does show active
358:28 - in local blockchain environments or
358:32 - network dot show active
358:35 - in forked local environments then we're
358:38 - going to go ahead and return account 0.
358:40 - however
358:41 - in our deploy.pi mainnet fork is not
358:44 - going to be in this local blockchain
358:45 - environment so we will just get our
358:47 - price feed from our config so now if i
358:50 - run this maintenance fork again now if
358:52 - we run this you'll see we'll still get
358:54 - an error we'll get list index out of
358:56 - range so brownie's built-in forking
358:58 - mechanism doesn't actually come with its
359:01 - own accounts here however it has these
359:03 - issues so what normally i like to do is
359:05 - i like to create my own custom
359:07 - maintenance fork right in browning the
359:08 - way we can create our own development
359:10 - custom network is by using the brownie
359:12 - network's add key so
359:15 - we do brownie
359:17 - networks
359:18 - add
359:19 - we'll make this a development network
359:21 - instead of a persistent network
359:23 - and we'll call this
359:25 - mainnet fork
359:27 - dev
359:30 - to set this up we'll do a ganache cli
359:34 - so we'll say the command to run this
359:36 - fork is going to be ganache cli
359:39 - the host is going to be the same as
359:40 - always http
359:42 - dot
359:43 - colon slash 127.0.0.1
359:48 - fork is going to be equal to and this is
359:51 - where we just put https
359:54 - mainnet
359:56 - dot infira dot io
359:58 - v3
360:00 - slash
360:01 - web 3
360:03 - infira
360:05 - project
360:06 - id
360:08 - now don't hit enter quite yet i'm going
360:09 - to explain a couple things
360:11 - so this single quote means
360:14 - run this as is if we run this without
360:16 - the single quote our environment
360:17 - variable would get actualized here and
360:19 - we'd always have to use whatever our
360:21 - current environment variable is so we
360:23 - want to have this little semicolon here
360:25 - then we would do accounts equal 10
360:29 - this tells brownie for us to set up 10
360:31 - fake accounts for us we'll give it a
360:33 - mnemonic
360:34 - of brownie so we'll say great make those
360:36 - accounts just have a new monica brownie
360:39 - and we'll do a port equals eight five
360:41 - four five now once again don't hit enter
360:43 - quite yet i do wanna explain one other
360:45 - thing so this is great for working with
360:46 - inferior and forking from inferior
360:49 - however i have to note that performance
360:51 - wise forking forming fura has pretty
360:54 - much always given me an issue
360:56 - so i prefer actually to fork from this
360:59 - application called alchemy and in fact
361:01 - if you'd like you could set up all of
361:03 - your networks to work with alchemy by
361:05 - modifying them i'm going to go ahead and
361:08 - sign in here and we're going to give it
361:09 - an alchemy url instead of an inferior
361:12 - url so i'm going to go ahead and create
361:14 - an app
361:15 - i'm going to call this fund me
361:17 - demo
361:18 - description will also be a fund me demo
361:21 - via development environment on the
361:22 - ethereum mainnet let's create this we
361:25 - can now view the details of this we'll
361:27 - go to view key and we'll copy
361:30 - this http address
361:32 - and we'll move back over here and for
361:34 - forking
361:36 - we can just
361:37 - delete
361:38 - everything next to this fork
361:42 - and we'll just paste that in here
361:43 - instead and let's go ahead and hit enter
361:46 - you'll know you've done this right if
361:48 - you can see something like this mainnet
361:50 - fork dev has been added oftentimes in my
361:52 - example i will actually just delete
361:54 - maintenance fork
361:55 - and have mainnet fork dev be my default
361:57 - for maintenance for but for us we're
361:59 - going to go ahead and do mainnet fork
362:01 - dev
362:02 - so in our config
362:04 - we're going to change mainnet fork to
362:05 - mainnet fork dev
362:08 - so since we're giving this a different
362:09 - name
362:10 - that means in our helpful scripts
362:12 - we're gonna have to have do a comma here
362:14 - and say mainnet fork
362:17 - dev all right great now our get account
362:21 - should return accounts 0 for maintenance
362:24 - fork dev and it should actually work so
362:25 - let's run our script again brownie run
362:27 - scripts
362:29 - deploy dash dash
362:31 - network
362:31 - mainnet
362:32 - fork dev
362:35 - and perfect we're running our
362:37 - maintenance fork dev
362:38 - and it is running successfully
362:41 - now we should also be able to test
362:43 - exactly the same way let's look at our
362:45 - test real quick
362:46 - test fund me and see okay cool we're
362:48 - going to be skipping this one since main
362:50 - at fork forkdev isn't in the local
362:52 - blockchain networks but this should work
362:55 - perfectly and then oftentimes in my
362:57 - tests here i'll actually do like a
362:58 - little plus
362:59 - 100 or something for entrance fee just
363:02 - in case i need like a little bit more
363:04 - money for whatever reason so now if we
363:06 - run founding test dash dash network
363:08 - mainnet fork dev
363:10 - we'll see that this does indeed pass and
363:12 - this is awesome so this is fantastic
363:15 - incredibly powerful project here now
363:17 - we're going to teach you how to actually
363:19 - share your code and enter the world of
363:21 - open source and decentralized code the
363:23 - way the world works when sharing code
363:25 - and sharing ideas and collaborating
363:27 - together is they use what's called open
363:29 - source git repositories github is an
363:31 - example of one of these git repositories
363:33 - that we can use to share our code and
363:35 - it's one of the dominant ways that smart
363:37 - contract engineers share ideas and share
363:40 - code we are now going to learn how to
363:42 - add our code to github and then we can
363:45 - even share the code and show the world
363:47 - what we've built and what we've done
363:48 - this isn't going to be a full end-to-end
363:50 - git course however there are some links
363:52 - in the course repository that will show
363:54 - you how to work with git work with
363:56 - github and work with version control so
363:58 - the first thing that we're going to do
363:59 - is we're going to come to github and
364:01 - we're going to sign up for
364:03 - a service
364:04 - add our email
364:06 - create a password
364:09 - enter your username no now we'll go to
364:11 - our email to verify it
364:14 - continue we're going to be working with
364:16 - some collaborative coding we're going to
364:18 - choose the free edition and perfect we
364:20 - are now in github now that we're in
364:22 - github we're going to create our own
364:24 - first open sourced repository so we're
364:27 - either going to hit this plus button
364:28 - here or create repository let's choose a
364:32 - repository name for this we'll give it
364:33 - the same name as our main folder so call
364:37 - this brownie fund me give it a
364:39 - description maybe smart contract
364:43 - application
364:45 - and we'll hit create repository this is
364:47 - where we're going to upload our code to
364:49 - share with the world back in our vs code
364:51 - now we're going to send this folder to
364:53 - that repository first thing we need to
364:55 - do is installing git there are a couple
364:58 - different ways to install git depending
365:00 - on the version that you're on we'll put
365:01 - this link in the description to our
365:03 - course to actually install git once you
365:05 - have it installed you should be able to
365:06 - run git dash dash version
365:09 - and see a git version here now we're
365:11 - going to initialize our repository in
365:13 - here by doing git init
365:16 - we're going to choose a branch name
365:17 - we're going to call it main
365:19 - we'll go ahead and add our username and
365:22 - email to our git config user dot
365:25 - name
365:26 - quotes
365:27 - free
365:28 - code camp
365:30 - video
365:31 - git config
365:33 - user dot email
365:36 - free code
365:37 - camp
365:38 - video gmail.com
365:40 - now we're going to do a couple things to
365:42 - push all of our code to github here
365:44 - however remember we do not want to push
365:48 - our dot env pieces up here so we can do
365:50 - a couple of things we can a we can go
365:53 - ahead and delete this of course but we
365:55 - can also add in our dot git ignore file
365:58 - a dot env this will help us so that we
366:01 - don't accidentally push our dot env file
366:04 - to github we can choose what files we
366:06 - want to push by doing git
366:09 - add and then a period and if we do get
366:11 - status
366:12 - it will now show us all the different
366:14 - files that we have staged to push to
366:17 - github if we look in here we see we have
366:20 - git attributes git ignore browning
366:22 - config
366:23 - fund me some contracts some scripts but
366:25 - we do not have that dot emv file
366:29 - if you were to remove dot emv from dot
366:31 - git ignore and you ran git add dot again
366:34 - and then we did get status
366:37 - we now see the dot env in here
366:39 - we do not want this in here so we can do
366:42 - git
366:43 - remove dash dash cached
366:46 - dot e b
366:47 - we'll add
366:48 - dot env
366:50 - back to our dot get ignore file
366:53 - and then we'll run git status again and
366:55 - then we'll run git add period
366:57 - and then get status
367:00 - and great we do not see that dot env in
367:02 - here so that's very good now we'll
367:04 - commit this by git
367:06 - commit
367:07 - minus m
367:09 - first commit
367:13 - and now we can add
367:16 - this folder to our github back in our
367:18 - github there's a little line here which
367:20 - even tells us how to do it we're going
367:22 - to copy this line right here
367:24 - git remote add origin https free code
367:27 - camp brownie fund me i'm going to copy
367:29 - that
367:30 - paste it in here
367:32 - hit enter and now we can just do this
367:35 - second line
367:36 - git push dash u origin main we'll do git
367:40 - push dash u
367:42 - origin main we get an output like this
367:44 - and if we go back we'll now see all of
367:47 - our files and folders in here now i've
367:49 - already added my email and password in
367:51 - here but instead of this you'll probably
367:53 - get github asking you for authorization
367:56 - you can just go ahead and put your
367:57 - github username in and your password in
367:59 - there if your username and password
368:00 - doesn't work you can come into github go
368:03 - down to settings
368:05 - scroll down to developer settings
368:08 - personal access tokens and generate new
368:10 - token we'll call this f
368:12 - brownie and we'll want to give it at
368:14 - least repo authorization here and we'll
368:17 - hit generate token
368:19 - and instead of using your password you
368:21 - can go ahead and use this github token
368:24 - amazing and you now have your first
368:26 - github repository
368:29 - we could even come in here add some
368:30 - topics
368:32 - like solidity
368:33 - chain link
368:35 - python
368:36 - brownie
368:38 - etc so that we know what our file is
368:40 - about and this is incredibly exciting
368:44 - now i'm gonna even encourage you
368:46 - to pop onto twitter and share your
368:48 - excitement
368:50 - i just made
368:52 - my first first
368:54 - at
368:59 - thanks to at free code camp
369:03 - at
369:04 - solidity
369:08 - brownie s
369:11 - at chain link if you want to tag me you
369:12 - can also tag at patrick alpha c
369:16 - and pop your repo in there go ahead and
369:18 - hit tweet the community absolutely loves
369:21 - hearing about all the fantastic things
369:23 - people are doing in this ecosystem so be
369:25 - sure to reach out have fun and engage i
369:27 - know we've gone over a lot here but
369:29 - let's talk a little bit about some
369:31 - testing pieces here
369:33 - now a big question you might have is
369:35 - well okay so i learned a ton of stuff we
369:37 - learned about maintenance forking i
369:38 - could do stuff on ganache i can use
369:40 - brownies ganache i can use brownies main
369:42 - net fork there's
369:43 - i can do a test there's all these places
369:45 - to do stuff where do i need to run my
369:48 - tests the default for every single one
369:50 - of your contracts is as follows you
369:53 - always 100
369:55 - need to have tests that pass on a local
369:59 - brownie spun up ganache instance that
370:02 - should be priority number one to get all
370:04 - your tests to pass on this this means
370:06 - that you will need to deploy mocks after
370:09 - that the other place you absolutely need
370:11 - to have tests or do some type of
370:13 - development is on a test knob these are
370:16 - going to be what's known as your
370:17 - integration test and we'll talk more
370:18 - about those later so those are the two
370:20 - places you always need to have tests
370:22 - development and a test net
370:24 - i think testing on main net fork and
370:26 - your own local ganache are optional
370:29 - testing on mainnet fork can be done and
370:32 - probably should be done whenever all of
370:34 - your contracts and all of your
370:35 - interactions are going to be on chain on
370:37 - one chain without any external off-chain
370:39 - components testing on your own local
370:41 - ganache is really more meant for
370:43 - tinkering and kind of exploring and
370:44 - seeing things yourself so that's going
370:47 - to be the setup here so great now let's
370:49 - move into our most challenging example
370:51 - once you pass and once you complete this
370:53 - example you basically will have all the
370:56 - tools to be an incredibly powerful smart
370:59 - contract developer then after that we're
371:01 - going to show you the chain link mix
371:03 - package and how to do what's called a
371:04 - brownie bake to automatically open up
371:07 - this package with all these scripts and
371:09 - all these contracts pre-built in this is
371:11 - going to make our lives substantially
371:13 - easier and faster for deploying our
371:14 - smart contracts however let's go through
371:17 - the process of understanding all the
371:18 - pieces that are going to be inside of
371:20 - this brownie mix
371:21 - are you ready you should be let's get
371:24 - excited and jump in
371:29 - okay so let's get into our most advanced
371:31 - smart contract project that we've made
371:33 - so far this is going to be the best
371:35 - example of a full scale application and
371:37 - by full scale i really mean end-to-end
371:40 - full suite of our brownie all of our
371:41 - smart contracts are really solid here
371:43 - what we're going to want to do is create
371:45 - a lottery application where anybody can
371:48 - enter the lottery and a random winner is
371:51 - selected so let's get to it and let's
371:53 - get started so first of course
371:56 - we're going to make new directory
371:59 - we'll call it smart contract lottery
372:03 - cd and a smart contract lottery and then
372:05 - open that folder
372:10 - great we are now in our lottery
372:11 - application
372:13 - so let's go ahead and start a new
372:14 - project
372:17 - brownie init we've got our project here
372:19 - now let's create a quick readme.md
372:22 - to explain what we're going to be trying
372:23 - to do here so number one we're gonna say
372:25 - users can enter the lottery with f
372:29 - based on a usd fee
372:31 - so for example let's set the price to be
372:33 - like fifty dollars and the users
372:35 - actually pay with ethereum so we're
372:36 - gonna have to get that conversion rate
372:38 - number two an admin
372:41 - will choose
372:43 - when the lottery is over and then three
372:47 - lottery will select
372:50 - a random winner now something important
372:52 - to note here
372:53 - is since we have an admin here this
372:55 - means that our application isn't
372:57 - necessarily going to be truly
372:59 - decentralized because we have a single
373:01 - person chooses when the lottery is over
373:04 - we could scale this out to have maybe a
373:06 - dow being the admin or something like
373:07 - that
373:08 - or we could have the lottery
373:09 - automatically open and close based off
373:11 - some time parameters but for the moment
373:13 - this is the setup that we're going to
373:15 - have keep in mind even though this is
373:16 - much less decentralized it's still going
373:18 - to be a great use of smart contract
373:20 - technology so first thing that we're
373:22 - going to get started with of course is
373:23 - our lottery contract so create a new
373:26 - file
373:27 - called lottery
373:29 - dot sol and let's begin with our initial
373:31 - setup here so let's choose our version
373:34 - pragma
373:37 - solidity
373:38 - carrot 0.6.6
373:43 - and this will be the version that we
373:44 - want to work with here
373:46 - we'll do contract
373:49 - lottery
373:51 - bracket here now let's think for a
373:53 - second on what some of the functions
373:54 - that are going to be what our main
373:56 - functions are going to be here we'll
373:57 - probably have a function enter
374:01 - that'll be public
374:04 - we'll probably have a function
374:05 - get
374:07 - entrance fee
374:11 - to get the entrance fee of the
374:14 - lottery we'll probably have a function
374:17 - start lottery that only the admin can
374:19 - call this will be public as well which
374:21 - means we'll also probably have an end
374:23 - lottery function
374:27 - and those are really going to be the
374:28 - main functions
374:30 - the user can enter
374:31 - based off the entrance fee we can start
374:34 - the lottery and then of course we can
374:35 - end the lottery so let's get started
374:37 - with this enter function just because
374:38 - this is most likely going to be the
374:40 - entry point as we know since we're going
374:42 - to want them to pay
374:44 - using this entry function in ethereum
374:47 - we're going to need to make this
374:48 - function payable
374:50 - and in here we're going to need to keep
374:51 - track of all the different players
374:53 - everybody who signs up for this lottery
374:56 - to keep track of all the players we're
374:57 - going to make
374:58 - an address
375:00 - payable
375:02 - array
375:03 - we'll make it public call players
375:06 - and anytime somebody enters we'll just
375:08 - do player
375:10 - dot push
375:12 - message dot sender
375:14 - however right now we're not checking to
375:16 - see how much value that they're actually
375:17 - sending we want to set the price of this
375:19 - to be at least 50
375:21 - so we'll say 50 minimum so here we're
375:23 - gonna have to do a require statement
375:26 - requiring them to do at least 50
375:29 - in order to do that we're probably going
375:30 - to need to have some function to get the
375:31 - entrance fee to check whether or not how
375:34 - much they're sending is actually 50
375:37 - so let's go ahead and make that get
375:38 - entrance fee function now since we're
375:39 - just going to be returning a number for
375:41 - get entrance fee we can probably go
375:42 - ahead and make this a public view and
375:44 - have this return
375:47 - a u and 256.
375:49 - to get this entrancy we're first going
375:51 - to have to have stored somewhere what
375:53 - the entrance fee is we're going to store
375:55 - this 50 minimum somewhere this is
375:56 - something we'd probably want to set
375:58 - right when our contract is deployed so
376:00 - where can we put stuff like that
376:02 - well in our constructor we'll do
376:04 - constructor
376:07 - public
376:08 - we'll create a new variable
376:10 - outside here we'll call it un256
376:14 - public usd entry fee
376:20 - in our constructor we'll set usd entry
376:22 - fee equals
376:24 - 50. now because i like to have units of
376:26 - measure always in way we'll also do
376:28 - times
376:29 - 10
376:30 - raised to the 18th
376:32 - now we have some usd entry fee let's go
376:34 - ahead and get this entrance fee as we
376:36 - know since we're going to try to get a
376:37 - conversion rate here we're going to want
376:39 - to use a chain link price feed
376:41 - so
376:42 - we can head on over to docs.chain.link
376:44 - we'll scroll down to get the latest
376:46 - price
376:47 - and we can even just go ahead and copy
376:49 - paste this again
376:50 - but for the sake of robustness let's
376:52 - just walk through again how to actually
376:54 - set this up we're going to need to pull
376:56 - from the price feed to convert fifty
376:58 - dollars to fifty dollars in each
377:02 - so let's go ahead and create an agra
377:04 - gator v3 interface
377:09 - internal
377:10 - f usd
377:12 - price feed
377:13 - and in our constructor
377:15 - we'll go ahead and set this we'll say
377:17 - fusd price feed
377:19 - equals
377:22 - ag redgate tor v3 interface
377:25 - and we're going to want to grab an
377:27 - address
377:28 - from our contract addresses but of
377:30 - course as you know as we've learned from
377:32 - last time we're going to want to
377:33 - parameterize this so we're going to want
377:35 - to pass the address of our price feed as
377:38 - a constructor parameter
377:40 - so we'll do address
377:43 - price
377:44 - feed
377:45 - address
377:47 - and we'll have our aggregator v3
377:49 - interface
377:50 - we passed that price feed address then
377:52 - of course since we're using an
377:54 - aggregator v3 interface we're gonna have
377:55 - to import this
377:57 - from chain link
377:58 - so we can just go ahead and copy this
378:00 - from the documentation
378:02 - and paste it right at the top
378:05 - or if you want to rewrite it out
378:07 - yourself feel free to do so
378:09 - and of course since we're doing this
378:10 - import here
378:12 - new file
378:14 - browning config.
378:17 - we're going to want to add this as a
378:19 - dependency so we'll do d
378:21 - pendancies
378:25 - smart contract kit
378:27 - chain link
378:29 - browning contracts
378:30 - and we'll do add 1.1.1 again
378:34 - and then compiler
378:37 - sulk
378:38 - remappings
378:43 - we'll say at chain link
378:45 - equals
378:48 - this right here
378:50 - we'll pull up our terminal
378:53 - and we'll try this out do brownie
378:55 - compile see if we're doing everything
378:57 - right we forgot an spdx license
378:59 - identifier
379:00 - which is just a warning but let's add it
379:02 - in anyways
379:05 - spdx
379:09 - license
379:10 - identifier
379:12 - mit i should probably spell me
379:14 - remappings right
379:17 - mappings
379:18 - and let's try to compile again
379:20 - all right lovely so we at least know
379:22 - that
379:23 - we are compiling correctly here awesome
379:26 - so now that we have a price feed let's
379:27 - go ahead and set up this entrance fee so
379:30 - we're of course going to need to get a
379:31 - price from this price feed so we can
379:33 - even check the documentation how to do
379:35 - that
379:36 - we can call this latest round data
379:38 - function
379:38 - so we could copy paste it i'm just going
379:40 - to go ahead and rewrite it but again we
379:43 - don't need round id started at timestamp
379:46 - or answered in round we only need price
379:48 - so we can go ahead and ignore these
379:49 - variables on our call
379:51 - so what we'll do is we'll do blank comma
379:56 - into price
379:59 - and then
380:00 - comma comma comma
380:04 - equals
380:08 - fusd price feed dot latest
380:11 - round data
380:14 - and this means we're just going to get
380:15 - the price here now we're going to want
380:17 - to do a little bit of quick math
380:18 - typically if we're setting the price at
380:19 - 50
380:21 - and we have
380:22 - a price feed of two thousand dollars per
380:24 - eth
380:26 - we would just wanna do
380:28 - fifty divided by two thousand
380:31 - but of course since solidity doesn't
380:33 - work with decimals we can't actually
380:34 - just do this
380:36 - so we'll have to do
380:38 - 50
380:39 - times
380:40 - some big number divided by the 2000 so
380:43 - we're going to go ahead and do it like
380:44 - that but first let's go ahead and
380:47 - convert this price from into 256 to uint
380:50 - 256.
380:52 - so we'll say
380:54 - you went 256
380:56 - adjusted price
380:58 - equals
381:00 - you went 256.
381:04 - you in 256 price
381:08 - and then
381:10 - since we know
381:12 - we're going to be using an ethereum usd
381:14 - price feed that has eight decimals
381:16 - let's also just convert it to having 18
381:18 - decimals as well
381:20 - so we can also do times 10
381:22 - raised to the 10th
381:25 - so now we can have 18
381:27 - decimals
381:29 - now that we have this adjusted price
381:32 - we'll do um 256
381:34 - cost to enter
381:36 - it's going to equal
381:38 - usd
381:40 - entry fee
381:41 - times
381:42 - again we're going to want to times it by
381:44 - some big number here so we'll just times
381:45 - it by 10 raised to the 18th
381:49 - this way usd entry fee
381:51 - has 18 decimals but it has an additional
381:53 - 18 decimals here that'll be canceled out
381:56 - with our price feeds and the math will
381:57 - work divided by price
382:01 - and then we'll return
382:03 - cost to enter
382:06 - now of course since we're doing some
382:07 - interesting math here it's recommended
382:10 - to use safe math and use safe math
382:11 - functions we're going to skip over the
382:13 - safe map functions here again because in
382:15 - the newer versions of solidity you don't
382:17 - really have to use them but i think it's
382:19 - important to note here that sending this
382:21 - code this exact code to production would
382:23 - be a bad idea for at least the reason of
382:26 - the safe math functions but in any case
382:28 - we have a function here we think our
382:30 - math is pretty good but i know for a
382:32 - fact that my math is usually not very
382:34 - good so let's go ahead and do some
382:36 - testing as we code just to make sure our
382:39 - get entrancy function is working
382:41 - properly so based off of our last lesson
382:43 - let's talk about
382:45 - how do we want to test
382:48 - this
382:50 - well we could do a main net fork here
382:54 - because we're only working with some
382:56 - on-chain contracts and some math we will
382:58 - at some point have to do our develop
383:00 - mint
383:02 - with marks
383:05 - and of course our test net
383:07 - i kind of want to just do a quick and
383:09 - dirty way so let's try our maintenance
383:11 - fork just for now just to see if
383:13 - if this is really making any sense if
383:15 - the current price of ethereum is 2 500
383:19 - or this much here
383:21 - and we want the price of this to be
383:23 - fifty dollars we do 50 divided by this
383:26 - and we get
383:28 - .019 so this should be approximately
383:32 - what we get for our eat value so if we
383:34 - were to write a test
383:36 - test
383:38 - lottery dot pi
383:40 - if we were to test this function we
383:42 - would expect to get 0.019
383:47 - or in way it'll be 1 9
383:50 - 1 2 3 4 5 six seven eight nine ten one
383:52 - two three four five six
383:54 - we expect to get approximately this so
383:57 - let's go ahead and create a function
383:58 - that tests us so we'll do test get
384:02 - entrance fee
384:05 - and here we'll deploy lottery
384:07 - and in here the first thing we need to
384:09 - do is deploy this lottery function of
384:11 - course so we'll do from
384:13 - brownie
384:14 - import
384:16 - lottery
384:17 - in order to deploy this we're going to
384:19 - need to get an account
384:23 - we are going to import our helpful
384:24 - scripts from the last project to this
384:26 - one too so we can get our get accounts
384:28 - but for the time being
384:30 - we can actually just use accounts 0 from
384:32 - brownie so we'll say count zero
384:35 - let's start with def then we'll do
384:37 - lottery equals
384:39 - lottery dot deploy
384:42 - from
384:44 - account
384:46 - and ah of course we have a parameter
384:49 - here of our price feed address
384:52 - so we're gonna have to add
384:54 - some type of parameter here for now
384:56 - let's just hard code it from our config
384:59 - and we'll go into our config and we'll
385:00 - start our networks flag
385:03 - we're going to be working like i said on
385:04 - the maintenance fork for this quick and
385:06 - dirty here
385:07 - we'll call f
385:09 - usd price feed
385:12 - grab the fusd price feed
385:15 - from mainnet since we're going to be
385:16 - doing a main net fork here
385:19 - pop that in here
385:24 - now we can just say
385:27 - from config
385:33 - networks
385:37 - network dot show active
385:44 - usd
385:46 - price feed
385:54 - of course we're going to need to import
385:55 - network here
385:57 - and now we can do our kind of quick and
385:59 - dirty test we can do lottery
386:01 - dot
386:02 - get entrance fee
386:05 - am i spelling that right get entrance
386:07 - fee
386:09 - yes
386:12 - assert
386:14 - lottery.get entrance fee should be
386:16 - greater than
386:18 - let's just say let's just go down 18
386:23 - or if we wanted to make sure we're
386:24 - actually doing this right we'll do from
386:27 - three import
386:28 - web three
386:31 - we'll do web3.2 way
386:34 - 0.019
386:38 - comma ether
386:42 - should be greater than
386:43 - and then we'll
386:44 - even do
386:46 - 0.018 just to make sure
386:48 - and it should be less than
386:52 - 0.01
386:56 - now these numbers are of course going to
386:57 - be a little bit different for you
386:59 - and if you want you can go ahead and
387:00 - skip this part so that you don't have to
387:02 - do the math but it is kind of nice to do
387:04 - a quick sanity check saying okay like
387:06 - based off what things are right now what
387:07 - would this price end up to be now in our
387:09 - last section we made a mainnet fork dev
387:13 - network
387:14 - i'm going to just go ahead and customize
387:16 - our mainnet fork the way that we showed
387:18 - you guys how to do maintenance fork dev
387:19 - this way you can use accounts and we can
387:21 - be a little bit more robust here
387:23 - to do this we're first going to have to
387:24 - delete brownie's internal built-in
387:26 - mainnet fork
387:28 - so we'll do brownie
387:30 - networks
387:31 - delete
387:33 - mainnet fork
387:35 - maintenance fork has been deleted
387:37 - and now let's go ahead and add our own
387:40 - maintenance fork using alchemy
387:45 - as our ethereum connection
387:49 - so you'll want to create a new app i've
387:51 - already created one here called smart
387:52 - contract lottery
387:54 - we'll view the key
387:55 - and this is the http endpoint that we'll
387:58 - use
387:58 - so to do this we'll do brownie
388:01 - networks
388:02 - add this will be a development chain
388:04 - we'll call this
388:06 - maintenant fork
388:08 - it'll be a ganache cli
388:12 - the host is going to be our local host
388:14 - so 127.0.0.1
388:18 - and the fork is going to be equal to
388:23 - our alchemy http here
388:27 - we'll do accounts equal 10 that way we
388:29 - can use the accounts
388:31 - do the new monarch
388:34 - equals brownie
388:37 - import is going to be eight five four
388:39 - five
388:42 - and great maintenance fork has been
388:44 - added now that we have this here we can
388:46 - go ahead and run our test
388:48 - brownie
388:50 - test dash dash network
388:53 - mainnet fork
388:57 - whoops looks like we got a little
388:59 - compile error on our math here
389:01 - oops it looks like we're divided by
389:02 - price when we need to be divided by
389:05 - adjusted price and we forgot the
389:07 - parentheses on latest round data
389:10 - let's try this again
389:14 - and i put an extra comment in here
389:16 - let's try this one more time
389:20 - lovely and it looks like we're forking
389:22 - correctly
389:24 - and awesome it looks like our test
389:25 - indeed passes here
389:27 - of course we know that we're going to
389:28 - want to change this because this isn't a
389:29 - great way to actually test our contracts
389:31 - here but it can be a nice sanity check
389:34 - and we know we're going to have to
389:35 - refactor this as well
389:37 - for mocks and for accounts
389:39 - but we'll get to that in a little bit
389:41 - awesome sanity check complete let's get
389:43 - back to our contract here
389:45 - so we are getting the cost to enter
389:47 - correctly perfect we're getting this
389:49 - entrance fee what that means we can do
389:52 - in our enter function we can do require
389:56 - message.value
389:57 - it's got to be greater than or equal to
390:01 - our get entrance fee function
390:07 - and if it's not
390:09 - give them an error of not
390:11 - enough
390:12 - eath
390:15 - we have a way for them to enter and we
390:16 - have a way to get the entrance fee but
390:18 - we want to make sure that we're not
390:20 - ending the lottery before the lottery
390:22 - even starts right or we're not entering
390:24 - a lottery when a lottery hasn't even
390:26 - begun so we're going to want a way to
390:28 - iterate through the different phases of
390:30 - this lottery and we can do that with
390:31 - what's called an enum or an enum
390:33 - according to the solidity documentation
390:35 - enums are another way to create
390:37 - user-defined types in solidity
390:40 - we saw an earlier version of doing this
390:43 - with a struct enums are a little bit
390:45 - different in that they're explicitly
390:47 - convertible to and from all integer
390:50 - types so what does that actually mean
390:52 - well
390:53 - we can have an enum
390:54 - like this action choices go left go
390:57 - right go straight and sit still they're
391:00 - just more readable ways to say
391:02 - go left is going to be represented as
391:04 - state 0 go right it's going to be state
391:06 - 1 go straight state 2 sit still state 3.
391:10 - so for our lottery contract we're going
391:12 - to want to create
391:14 - this new type that represents the
391:15 - lottery state so to do this we'll do
391:18 - enum
391:20 - lottery state open
391:23 - closed
391:26 - and calculating winner
391:28 - this means that we have a new type
391:31 - called lottery state with three
391:33 - positions open closed and calculating
391:36 - winner these different states are
391:37 - actually represented by numbers so open
391:40 - is actually a zero
391:41 - closed is actually one and calculating
391:43 - winner is actually a two now that we
391:46 - have this new type we can create a
391:48 - variable of type lottery state so we'll
391:50 - say
391:51 - lottery state
391:54 - public
391:55 - lottery state
391:57 - and right when we initialize our
391:59 - contract here we're going to want to set
392:00 - our lottery state to being closed
392:03 - so in our constructor we'll do lottery
392:05 - state
392:06 - equals
392:09 - lottery state
392:10 - dot closed
392:12 - now since these are represented by
392:14 - numbers as well we could also just do
392:16 - lottery state equals
392:18 - 1
392:19 - because 1 stands for closed however it's
392:22 - much more readable to do
392:23 - lotterystate.closed
392:25 - now that we have a lottery state
392:28 - in our enter function we can require
392:32 - that the lottery state
392:35 - is going to be
392:36 - equal to
392:38 - lottery state
392:39 - dot open
392:41 - so we can only enter if somebody's
392:43 - started this lottery and that's exactly
392:46 - what we're going to do in our start
392:47 - lottery function
392:49 - we're going to do a require in here
392:52 - that the lottery state
392:54 - is going to be equal to
392:56 - lottery state dot closed
393:00 - we can even add
393:02 - a failure function here
393:04 - saying
393:07 - can't start
393:08 - a new
393:10 - lottery yet
393:11 - and when we do start this lottery we'll
393:13 - say lottery
393:14 - state
393:16 - equals
393:17 - lottery state dot open
393:20 - now when somebody starts the lottery
393:23 - they'll be able to
393:24 - enter of course this
393:27 - start lottery bid here needs to be
393:29 - called only by our admin so this is
393:32 - where our
393:33 - only owner modifier is once again going
393:36 - to come into place we could write our
393:38 - own only owner modifier or we can once
393:41 - again use open zeppelin's access control
393:44 - and open zeppelin's ownable function
393:46 - instead which is what i'm going to use
393:47 - here so we're going to go ahead and grab
393:49 - this
393:50 - copy this
393:51 - paste it in
393:54 - import at open zeppelin contracts slash
393:57 - access ownable
393:59 - and of course since we're doing this
394:02 - we're gonna have to add this dependency
394:04 - into our config
394:06 - we're gonna be using
394:07 - open
394:10 - zeppelin
394:11 - open
394:13 - zeppelin
394:14 - contracts at 3.4.0
394:19 - we're going to remap
394:22 - at
394:23 - open
394:24 - zeppelin equals
394:27 - this
394:29 - oops
394:33 - and then we'll say our lottery is
394:36 - ownable
394:39 - perfect
394:40 - now we'll try to compile this
394:44 - awesome looks like brownie grabbed
394:46 - everything correctly and we're good to
394:48 - go great
394:49 - now we can finally move into our end
394:51 - lottery function
394:53 - this is where we're actually going to
394:54 - choose a random winner here
394:56 - we only want the admin to be the one to
394:58 - actually end the lottery so let's add
395:00 - the only owner modifier here
395:02 - and let's talk a little bit about
395:04 - randomness because this is what we're
395:05 - looking to do now we're looking to get a
395:07 - random winner here now as you know the
395:09 - blockchain is a deterministic system
395:12 - right and this is super ambitious
395:13 - because that allows us to do all these
395:15 - smart contracts and have this system
395:18 - that can actually reach consensus very
395:19 - easily random numbers are much harder if
395:22 - let's say you had a blockchain with a
395:23 - whole bunch of different nodes and each
395:24 - node responds and gives their own random
395:27 - value well each node is never going to
395:29 - be able to sync up and say hey you know
395:31 - we all agree on a random number what you
395:32 - could do is you could base the random
395:34 - number on some other attributes in the
395:36 - system
395:37 - but then it's not really random it's
395:39 - actually going to be pseudorandom so
395:41 - getting truly random numbers in a
395:43 - deterministic system is actually
395:45 - impossible and if you know a lot about
395:47 - computer science you actually know that
395:49 - even when you call like math.random in
395:51 - your javascript what your computer is
395:53 - really doing is it's looking at some
395:54 - place in memory grabbing some value and
395:56 - saying hey this is probably random
395:59 - enough here go ahead and use this now in
396:01 - smart contracts especially when working
396:03 - with any type of financial application
396:05 - such as a lottery having an exploitable
396:07 - randomness function means that your
396:09 - lottery is at risk of being hacked or
396:12 - destroyed and this isn't even a fairy
396:14 - tale at the time of recording about two
396:16 - weeks ago i did a rundown on an exploit
396:18 - where a protocol used insecure
396:20 - randomness and got hacked for seven
396:22 - hundred thousand dollars so i am going
396:24 - to show you this insecure way first and
396:26 - the reason that i'm going to show you is
396:27 - that it is a quick and dirty way to get
396:29 - a pseudo random number but please do not
396:32 - use this in any production use cases i'm
396:35 - going to show you a method that's often
396:36 - used to teach people how to get random
396:38 - numbers and then we're going to explain
396:40 - why it's so vulnerable and not a good
396:42 - method of randomness and what some
396:44 - insecure protocols will do is they'll
396:46 - use a globally available variable and
396:50 - hash it so in your smart contracts
396:52 - there's actually a number of globally
396:53 - available variables one of those as we
396:56 - saw above
396:58 - is going to be message.value right it's
397:00 - going to be the value that's sent with
397:01 - the transaction another globally
397:03 - available variable is going to be
397:05 - message.sender
397:07 - you can actually see a whole list of
397:08 - these different globally available
397:10 - variables in the solidity documentation
397:13 - here so since there are these globally
397:15 - available variables a lot of times some
397:17 - will see something like block.difficulty
397:20 - which returns the current block
397:22 - difficulty
397:23 - now one of these globally available now
397:25 - one of these globally available
397:27 - variables is going to be block
397:28 - difficulty or block dot difficulty it's
397:30 - the current block difficulty remember
397:32 - how i said that the time between
397:34 - different block generation is called the
397:36 - block time
397:37 - well you can always keep that block time
397:39 - as is by changing the block difficulty
397:42 - over time the harder the problem or the
397:45 - harder the proof of work algorithm
397:47 - the longer it's going to take or the
397:49 - more nodes you're going to need to solve
397:51 - that problem there's this constantly
397:53 - recalculating metric called ethereum
397:55 - difficulty or block difficulty depending
397:57 - on the chain that you're working on that
397:59 - constantly changes
398:01 - so you might think this would be a great
398:03 - use of randomness right because it's a
398:06 - somewhat hard to predict number so what
398:09 - a lot of people do is they think that
398:11 - hey those sound pretty random let's use
398:14 - them as a unit of randomness and what
398:16 - you'll see is you'll see like something
398:17 - like uint
398:24 - 256 which is
398:26 - again this hashing algorithm
398:29 - let's do something like abi dot encode
398:31 - pact
398:50 - so i know there's a whole lot going into
398:52 - this line and let's talk about it
398:54 - so first as we can see
398:56 - is that we're casting or we're
398:58 - converting everything in here to being a
399:00 - uni-256 the reason that we're doing this
399:03 - of course is because we're going to want
399:04 - to pick
399:05 - a random winner based off of an index
399:08 - right we're going to want to pick
399:09 - somebody some random winner in our
399:11 - players array or our players list
399:14 - so we say okay whatever number that
399:16 - we're going to use that's going to be
399:17 - the index of the winner that we're going
399:19 - to randomly pick
399:20 - then they use cache 256 which is again
399:22 - our hashing algorithm so they hash a
399:24 - whole bunch of variables together
399:27 - and they do this abi dot encode packed
399:29 - api is another keyword
399:31 - for some low-level work
399:33 - and they'll add maybe a nunsen they'll
399:35 - add the message on sender
399:37 - block that difficulty and block the
399:39 - timestamp basically what they're trying
399:40 - to do here is take a bunch of seemingly
399:43 - random numbers
399:44 - mash them all together in a hashing
399:46 - function and then say yeah this this is
399:48 - pretty random but the issue here is that
399:50 - the hashing function itself isn't random
399:52 - the hashing function is always going to
399:54 - be exactly the same could check 256 it's
399:56 - always going to hash everything exactly
399:58 - the same way so we're not actually
400:00 - making it more random by hashing it all
400:02 - these numbers inside are the pieces that
400:05 - actually determine how random it is so
400:07 - if the block to difficulty is random
400:09 - then this will be a random method if the
400:11 - blocked out difficulty isn't random then
400:12 - this won't be a random method and the
400:15 - blocked difficulty is not random
400:17 - difficulty
400:19 - can actually
400:20 - be manipulated by the miners
400:25 - in time stamp
400:27 - timestamp is predictable
400:29 - nuns is predictable
400:31 - aka
400:33 - transaction number because in this
400:34 - regard they're using the nuns as some
400:36 - transaction number
400:38 - and message.sender
400:41 - is predictable
400:44 - when using a random number in this way
400:47 - the hashing algorithm is always going to
400:48 - be the same union 256 is always going to
400:51 - be the same we have a predictable number
400:53 - a predictable address
400:56 - a predictable timestamp
400:59 - and then a manipulatable value
401:01 - so all this is really doing is giving
401:04 - the miners the ability to win the
401:06 - lottery or win whatever lottery that
401:08 - you're working on
401:09 - so this isn't going to be an effective
401:11 - way to get a random number this is an
401:13 - unacceptable way to get a random number
401:15 - in our applications yes we do have this
401:17 - only owner modifier here which means
401:19 - that we are the ones who are going to
401:21 - choose when to call this so it is still
401:22 - centralized in that regard
401:24 - but let's just teach you the best
401:26 - practices for working with random
401:27 - numbers right from the get-go so you
401:29 - don't run into any issues
401:31 - i'll explain what this part is doing in
401:32 - a little bit in order to get a true
401:34 - random number we are going to have to
401:35 - look outside the blockchain the
401:37 - blockchain itself like i said is a
401:39 - deterministic system so we need a number
401:41 - outside the blockchain but what we can't
401:43 - do is we can't use just an api that
401:46 - gives a random number right if that api
401:48 - becomes corrupted if they're malicious
401:50 - if they go down if something happens
401:52 - etcetera what we need is a provable way
401:55 - to get a random number and chain-link
401:57 - vrf is actually that solution chain-link
401:59 - vrf it stands for chain-link verifiably
402:01 - randomized function and it's a way to
402:03 - get a provably random number into your
402:06 - smart contract it has an on-chain
402:07 - contract that checks the response of a
402:10 - chain-link node to make sure the number
402:12 - is truly random using some cryptography
402:15 - magic it's able to check a number of the
402:17 - parameters that the chainlink vrf
402:19 - started and ended with to make sure that
402:21 - it's truly random it's already used for
402:23 - protocols like avagochi
402:25 - ethercards pool together and a whole
402:28 - bunch of other protocols as well because
402:29 - it is a secure reliable truly provable
402:32 - way to get a random number which is
402:34 - incredibly powerful in a decentralized
402:35 - system so that's how we're actually
402:37 - going to get our random number here so
402:39 - let's work on getting that
402:41 - what we can do is we can go ahead and
402:43 - head right over to the chain link
402:44 - documentation to actually learn how to
402:46 - work with one of these let's go over the
402:48 - chain link documentation just to make
402:50 - sure that we get it right so if we go to
402:52 - the get a random number here
402:54 - we have all the documentation you could
402:56 - ever want so if you ever get lost or
402:57 - confused you can always come right back
402:59 - here to work with it what we're going to
403:01 - do is we're going to deploy their simple
403:03 - version in remix version of working with
403:06 - the chainleaf vrf and we're going to
403:08 - walk through a minimalistic contract to
403:10 - see how it actually works in a contract
403:14 - so once again we hit this remix button
403:16 - remix pops up and we immediately get
403:18 - this random number consumer.soul
403:21 - in our files that we can check out so
403:23 - awesome so here is our files right here
403:26 - we can see that this is actually using a
403:28 - different chain than what we've been
403:30 - using we've been mostly working with
403:32 - rink b
403:33 - but for this demo it's actually on coven
403:36 - so we can do some work with kovin here
403:38 - and remember if you do want to stay with
403:40 - rink b you can always go to this
403:42 - contract addresses section of the vrf
403:46 - and grab these addresses to use so
403:49 - what's going on in this contract how do
403:52 - we actually use this well as you can see
403:54 - the first thing that happens is we're
403:56 - importing some code from the chain link
403:58 - package and our contract is inheriting
404:01 - the abilities of this vrf consumer base
404:03 - contract so we're going to see what
404:05 - functions we're actually going to use
404:06 - that are inherited from this contract
404:08 - and the first thing that we notice is we
404:10 - can see that our constructor in here
404:12 - does some weird stuff
404:15 - it looks like it almost has two
404:16 - constructors
404:18 - so what's actually going on here well
404:20 - let's look at this vrf consumer
404:21 - base.cell contract in the chain link
404:23 - github
404:26 - so we can come to the chain link github
404:28 - here
404:30 - we'll go to evm contracts or depending
404:32 - on when you're watching in this it's
404:33 - migrating to contracts at some point
404:35 - we go to evm contracts we'll go to src
404:38 - so once we're using v0.6 we'll go there
404:42 - and we'll look at this vrf
404:43 - consumerbase.sol
404:45 - as we can see this vrf consumer base
404:47 - that we're importing has its own
404:49 - constructor and it takes an address for
404:52 - the vrf coordinator this is the on chain
404:54 - contract that actually checks to make
404:55 - sure our numbers are random and the
404:57 - address of the chain link token which
404:59 - we'll talk about erc20s in a little bit
405:01 - what we're doing is we're also
405:02 - inheriting the constructor into our
405:04 - contract
405:05 - so this is our constructor for our
405:08 - random number consumer but we can also
405:10 - use the constructor of the vrf consumer
405:12 - base
405:13 - and this is actually how we go ahead and
405:15 - do that we grab the constructor of the
405:17 - vrf consumer base and pop it in here
405:20 - now it's taking two addresses it's
405:22 - taking the vrf coordinator
405:24 - and the link token like i said the vrf
405:27 - coordinator is a contract that's been
405:29 - deployed on chain that's going to verify
405:31 - that the return of the chain link node
405:33 - is truly random and we're going to use
405:35 - the link token as a payment to the chain
405:38 - link node for its services and then we
405:40 - also have a key hash and a fee defined
405:43 - inside of this constructor as well the
405:45 - key hash uniquely identifies the chain
405:48 - link node that we're going to use and
405:49 - then the fee is how much link we're
405:51 - actually going to pay to the chain link
405:52 - node for delivering us this random
405:54 - number now let's talk about a couple
405:56 - things here
405:57 - in ethereum whenever you make a
405:58 - transaction you have to
406:00 - pay some eath gas
406:03 - right or transaction gas
406:07 - this is to pay the smart contract
406:08 - platform a little bit of eth for
406:10 - performing our transaction with a smart
406:12 - contract with a smart contract that
406:14 - operates with an oracle we have to pay
406:16 - some link gas or oracle gas
406:19 - this is to pay the oracles a fee for
406:22 - their services for providing data or
406:24 - doing some type of external computation
406:26 - for a smart contract the question that
406:29 - might then follow up is oh okay well how
406:32 - come i didn't have to pay
406:33 - when we did this price feeds thing
406:36 - well for price feeds
406:39 - somebody had actually already paid
406:41 - for the data to be returned and if we go
406:44 - to data.chain.link and we scroll down we
406:46 - can actually see a list of sponsors here
406:48 - that are paying to get this data
406:50 - delivered so they're already paying the
406:52 - oracle gas to bring this data on chain
406:54 - for us since no other protocol is
406:57 - getting a random number for us we're
406:59 - actually going to have to pay the oracle
407:00 - gas here now in this contract we have a
407:03 - function called get random number which
407:05 - is going to return a bytes 32
407:08 - and what it's going to do it's going to
407:09 - call this request randomness function
407:11 - which is inherited from this vrf
407:14 - consumer base if we look in here
407:16 - we look for request
407:19 - request randomness we can see there's a
407:21 - function right here
407:23 - called request randomness this function
407:25 - is going to send our oracle fee or the
407:28 - link token
407:29 - and it's going to call this
407:31 - specific to the link token function
407:33 - called transfer and call
407:35 - this function is going to call a chain
407:36 - link node now i'm not going to talk now
407:38 - i'm not going to go into exactly how
407:40 - it's doing that right now but we will
407:42 - talk about it in a little bit so we call
407:44 - this request randomness function
407:46 - and we send the key hash and the fee
407:49 - remember the key hash uniquely
407:51 - identifies the chain link node
407:53 - and the fee is going to be how much
407:55 - oracle gas we're going to pay if you
407:57 - ever get lost on how much to pay or what
407:59 - the contract addresses are you can
408:01 - always head over to this vrf contract
408:03 - section and see where the most recently
408:05 - deployed
408:06 - vrfs are how much the fee is etcetera
408:10 - now here's where it gets a little bit
408:11 - interesting
408:12 - getting a random number actually follows
408:14 - what's called the request and receive
408:16 - style of working with data let's go
408:18 - ahead and just try this out and i'll
408:20 - explain what this means once we see it
408:23 - now we're going to save the answer to
408:24 - this random result variable here and
408:27 - let's just go ahead and try this and see
408:29 - what happens
408:30 - so we're going to switch to our injected
408:32 - web 3 and since we're now swapping to a
408:34 - new test network this means that we have
408:36 - to get tested eth and test that link
408:38 - again
408:40 - we can always look for the link token
408:41 - contracts page to find the most
408:43 - up-to-date faucets so we'll scroll down
408:46 - we'll find coven
408:47 - looks like this is the at link faucet
408:50 - and the test and eat faucet
408:52 - so here's our kovin faucet we'll just
408:54 - want to switch from rink b to coven
408:58 - grab our address
409:00 - paste it in
409:02 - send me a hundred test link
409:07 - here's our transaction
409:08 - we can see we're transferring
409:11 - some erc20
409:14 - we'll take this contract address we'll
409:15 - add it to our metamask by copying the
409:17 - address
409:19 - scrolling down to add token
409:21 - pasting it in here i already have the
409:23 - address in here so i'm just going to go
409:24 - ahead and hit cancel for now
409:27 - and we'll also want some testnet coven
409:29 - ethereum which looks like this faucet
409:31 - has it
409:32 - so we'll paste the address in here
409:34 - i'm not a robot and we'll do send me 0.1
409:37 - test eth and perfect now that we have
409:40 - some tests on ethereum
409:42 - and some test that link we can proceed
409:44 - we're going to make sure we're on the
409:46 - coven test network
409:48 - and we're going to deploy
409:49 - our random number consumer gist here
409:51 - let's go ahead and hit deploy
409:54 - metamask pops up we're going to go ahead
409:55 - and confirm
409:56 - i didn't explain this fulfill randomness
409:58 - function intentionally you'll see why in
410:01 - a second
410:02 - and great a random number consumer comes
410:04 - up
410:05 - let's check what our random result is
410:06 - right now it's obviously zero because we
410:08 - haven't got a random number so i'm going
410:10 - to do something intentionally wrong
410:12 - because there's a good chance that
410:13 - you'll run into this at some point
410:14 - if i hit get random number right now we
410:17 - see this air gas estimation failed
410:19 - we have plenty of eath why would this
410:21 - fail the reason that it's failing is
410:23 - because the contract doesn't have any
410:25 - oracle gas so we got that gas estimation
410:27 - failed because we need to fund this
410:29 - contract address with some link to
410:31 - actually get a random number so we're
410:32 - going to hit this copy button and this
410:34 - is going to copy the address
410:36 - and we're going to come into our meta
410:37 - mask here
410:38 - and we're going to send
410:40 - this address we're going to paste it
410:41 - there
410:42 - swap to link and we'll send it one link
410:46 - this is probably overkill
410:48 - because as you saw
410:50 - the fee is only 0.1
410:52 - but we're just going to be overkill for
410:54 - now
410:56 - and great now that this contract has
410:58 - some test net link now we can call this
411:00 - get random number button because we can
411:03 - actually pay the chain link node to
411:05 - actually return our random number so
411:07 - we're going to go ahead and do confirm
411:09 - and this is fantastic so we're paying a
411:11 - little bit of transaction gas to make
411:13 - this transaction to make this request
411:15 - and then we're paying a little bit of
411:17 - oracle gas to make this transaction now
411:19 - so the transaction
411:22 - now so the transaction confirmed but if
411:24 - i hit random result now it's still going
411:26 - to be zero
411:27 - so why is that what's going on well
411:29 - getting a random number like this
411:31 - actually follows what's known as the
411:32 - request and receive cycle of getting
411:35 - data you can read more about it here in
411:37 - this basic request model in the
411:39 - documentation so in one transaction we
411:42 - actually request some data or in this
411:45 - case a random number and then in a
411:46 - second transaction the chain link node
411:48 - itself
411:49 - will make a function call and return the
411:52 - data back to the smart contract in this
411:55 - case the function that we're calling is
411:57 - fulfill randomness it calls this fulfill
411:59 - randomness
412:00 - with byte32 request id which is going to
412:03 - be the request number of when we call
412:05 - this
412:06 - and it's going to return with this
412:07 - random number called randomness
412:10 - so after we wait a little bit
412:12 - if we hit random result now we can see
412:14 - indeed our random number is in here
412:16 - again the reason that it's in here is
412:17 - because we actually had two transaction
412:20 - occur
412:21 - one paid by us
412:22 - when we called get random number and one
412:25 - paid by the chain link node when it
412:26 - called fulfill randomness now i lied to
412:29 - you a little bit technically that vrf
412:31 - coordinator contract calls this function
412:33 - and then the chain link node calls the
412:35 - vrf coordinator function but for
412:37 - simplicity's sake you can kind of just
412:38 - think of it as the chain link node
412:40 - itself is calling this fulfill
412:41 - randomness function so now that we know
412:43 - how to do this from remix let's go ahead
412:44 - and add this to our brownie project
412:47 - so actually before we even do that we
412:49 - need to require so before we even get a
412:51 - random number let's change the state of
412:53 - our lottery so now we'll do lottery
412:56 - state
412:57 - equals
412:59 - lottery state
413:00 - dot calculating winner
413:03 - and while this is happening no other
413:04 - functions can be called right this will
413:06 - lock out
413:07 - nobody can start a lottery and nobody
413:09 - can enter a lottery while we're
413:11 - calculating the winner
413:12 - awesome so now that we know a little bit
413:14 - more about random numbers and everything
413:16 - that we're doing here let's go ahead and
413:17 - try implementing this now
413:19 - so in our chain link smart contract docs
413:21 - of course we're going to scroll down
413:23 - we're going to go to our get a random
413:25 - number bit here
413:27 - we can copy and paste all this code as
413:28 - well
413:29 - into our smart contracts so the first
413:31 - thing that we're going to need to do of
413:32 - course is
413:34 - import the vrf consumer base code
413:37 - let's move back over
413:39 - scroll to the top and we'll just paste
413:41 - this in at chain link slash contracts
413:43 - src
413:44 - v0.6 vrf consumer base and we'll inherit
413:48 - this into our lottery contract so we'll
413:50 - say the lottery is vrf
413:52 - consumer base
413:55 - and it's ownable let's take a look at
413:58 - this vrf consumer base in the chainlink
414:00 - github here
414:01 - if we scroll down
414:03 - to the constructor of our vrf consumer
414:05 - base we can see it takes these two
414:07 - parameters the address of the vrf
414:09 - coordinator and the address of the chain
414:11 - link token
414:12 - we can use a constructor we can use a
414:15 - constructor of a contract inherited in
414:18 - our contract inside our constructor
414:22 - so what we'll want to do is we want to
414:24 - come down to our constructor and right
414:26 - after this public keyword we can add any
414:28 - additional constructors from inherited
414:30 - smart contracts
414:32 - so we'll say constructor and this is our
414:34 - normal constructor and then we'll put
414:37 - vrf
414:38 - consumer base
414:41 - and we'll add the vrf consumer base
414:43 - addresses in here
414:45 - we know that it's going to be a vrf
414:47 - coordinator address and a link token
414:49 - address
414:50 - similar to the price feed these two
414:52 - addresses are going to change based on
414:54 - the blockchain that we're on
414:56 - so it'll probably make sense for us to
414:58 - parameterize them the same way we
415:00 - parameterize the price feed address
415:03 - so in our top level
415:06 - constructor parameters we'll add
415:09 - an address
415:10 - for the vrf
415:12 - coordinator
415:13 - and we'll pass this to the constructor
415:16 - of our vrf consumer base
415:18 - then we'll also grab an address for the
415:20 - link token so we'll do address
415:24 - link
415:25 - and we'll pass this
415:27 - to the vrf consumer based constructor as
415:29 - well
415:30 - great what else do we need to make this
415:32 - work well back in the documentation we
415:34 - can see we need a fee
415:36 - and a key hash the fee is associated
415:38 - with the link token needed to pay for
415:40 - this request
415:42 - so we'll make a public variable
415:45 - uint 256
415:47 - public
415:48 - fee since this might change blockchain
415:51 - to blockchain we'll have this as an
415:54 - input parameter as well
415:56 - so we'll do uni-256
415:58 - underscore fee
415:59 - and in our constructor
416:02 - we'll do fee
416:04 - equals underscore fee
416:06 - we'll set our global variable
416:08 - to fee
416:09 - and i need a comma here and no semicolon
416:12 - here what else do we need
416:14 - well we need a key hash
416:16 - the key hash is a way to uniquely
416:18 - identify the chain link vrf node
416:22 - so create another one we'll do
416:25 - bytes 32 public key hash
416:30 - we'll add this as a parameter in here
416:33 - bytes32
416:35 - keyhash
416:37 - and then we'll say
416:39 - keyhash equals
416:41 - underscore keyhash
416:43 - perfect our contract is coming along
416:45 - great here
416:46 - now that we have the main pieces that we
416:48 - need how do we then request this random
416:50 - number
416:51 - well if we scroll down in the
416:52 - documentation
416:54 - we can see we have this request
416:56 - randomness function that we need to call
416:58 - if we scroll back to our vrf
416:59 - consumer-based contract this request
417:02 - randomness function is a built-in
417:04 - function from the vr of consumer base so
417:06 - our contract can natively call this
417:07 - request randomness function right in our
417:10 - contract and you can see it takes a key
417:12 - hash and a fee as its parameters
417:16 - so right in our end lottery function
417:20 - we can add this function and we can see
417:22 - this also returns a bytes32 called
417:26 - request id this return syntax is pretty
417:28 - powerful
417:29 - you can actually identify the name of
417:32 - the variable you want to return right in
417:34 - your write in your function declaration
417:36 - so by saying bytes32 request id we're
417:38 - saying we're going to return a bytes32
417:41 - variable named request id so right in
417:43 - our function here
417:44 - we can do request
417:46 - randomness
417:48 - because again that's this function that
417:50 - we're importing
417:52 - passing it the key hash
417:54 - and the fee
417:55 - this will return
417:57 - a bytes 32 called request id
418:01 - so this is actually doing this
418:03 - and having our function
418:05 - having our function declaration tell us
418:08 - that there's going to be a variable name
418:09 - request id
418:10 - is going to be exactly the same as if we
418:12 - did bytes 32
418:14 - request id equals request randomness now
418:17 - this function call follows again what
418:19 - we've talked about as the request and
418:20 - receive mentality the request and
418:23 - receive architecture
418:25 - this means that in this first
418:27 - transaction we're going to request the
418:29 - data from the chain link oracle in a
418:32 - second callback
418:33 - transaction the chain link node is going
418:35 - to return
418:37 - the data to this contract
418:39 - into another function called fulfill
418:42 - randomness so again if we look back in
418:45 - our vrf consumer base we can see it has
418:47 - this function raw fulfill randomness we
418:49 - can read some of the comments in here
418:51 - saying raw fulfill randomness is called
418:53 - by a vrf coordinator when it receives a
418:55 - valid vrf proof raw fulfill randomness
418:59 - will then call fulfill randomness so
419:01 - there's a little bit of contract tag
419:03 - going on but it's going to eventually
419:04 - call this fulfill randomness function
419:07 - which is going to be what we define in
419:09 - here
419:10 - and that's how our contract is going to
419:12 - know what to do once it gets the random
419:14 - number back so in our first transaction
419:17 - we're going to end the lottery request a
419:19 - random number
419:20 - and then a second transaction later on
419:22 - once the chain link node has created a
419:24 - provably random number it's going to
419:26 - call a second transaction itself
419:29 - based off of what we define
419:31 - we just have to call it
419:33 - fulfill
419:34 - randomness
419:36 - and as you can see it takes a byte 32
419:38 - request id and a random number so
419:41 - in here we'll do fulfill randomness it
419:43 - takes a byte 32
419:45 - request id
419:47 - and then a uin256
419:50 - randomness
419:52 - we don't want anyone else to be able to
419:54 - call this function we only want our
419:56 - chain link node to call this function so
419:57 - we can return a truly random number
420:00 - so we're going to make this an internal
420:01 - function
420:02 - it's internal because actually the
420:04 - chain-link node is calling the vrf
420:07 - coordinator
420:08 - and then the vrf coordinator is calling
420:10 - our fulfill randomness
420:12 - so we'll make this internal so that only
420:14 - the vrf coordinator can be the one to
420:15 - call and return this function
420:17 - and then we're going to give it a
420:19 - keyword of override this override
420:21 - keyword means that we're overriding the
420:23 - original declaration of the fulfill
420:25 - randomness function our vrf consumer
420:27 - base has a function fulfill randomness
420:30 - defined but it doesn't have any
420:33 - parameters or anything about this
420:35 - function actually laid out this function
420:37 - is meant to be overridden by us and
420:40 - that's exactly what we're doing right
420:41 - here so in this fulfill randomness
420:43 - function let's go ahead and define
420:45 - what's going to happen once we get this
420:47 - random number back so before we can
420:49 - process this random number let's just
420:51 - check to make sure we're even in the
420:52 - right state so we'll do require
420:56 - our lottery state is going to be equal
420:58 - to
421:00 - lottery state dot
421:02 - calculating winner
421:04 - and if we're not in that state
421:06 - we'll just say
421:08 - you
421:10 - aren't there yet
421:14 - my auto format is is on for this one so
421:17 - it's uh it's jumping in then let's just
421:19 - do another check to make sure we
421:21 - actually get a response so we'll do
421:22 - require
421:24 - underscore randomness
421:27 - is greater than
421:29 - zero
421:30 - and if it's not we'll just say random
421:34 - not found
421:37 - now we need to pick a random winner
421:40 - well we need to pick a random winner
421:42 - specifically
421:43 - out of our list of players our list of
421:47 - payable public players so our players
421:49 - array is just a list of players so it's
421:52 - like one player one player two player
421:54 - three player four
421:56 - and they're each at a different index
421:58 - what we can do then to pick a random
422:00 - winner is to do what's called a modulo
422:02 - function in fact let's even open remix
422:05 - to do an example of this remix let's pop
422:08 - open a new contract we'll call it
422:10 - mod.sol
422:12 - do pragma
422:14 - solidity
422:15 - carrot 0.6.6
422:17 - we'll do contract
422:21 - mod
422:22 - and in here we'll do a constructor
422:27 - blank constructor
422:28 - and we'll get a global variable you went
422:31 - 256
422:32 - number and we'll set it equal to 5. and
422:36 - we'll go down to 0.6.6
422:39 - save compile
422:42 - and you know let's even just get rid of
422:43 - the constructor
422:45 - let's now create a function
422:47 - called do mod
422:48 - we'll take a un256
422:54 - mod value
422:55 - make this a public function
422:59 - public
422:59 - view returns
423:02 - ui 256
423:03 - and we'll just return
423:06 - 5
423:07 - modulo
423:09 - mod value
423:11 - now let's go to javascript vm we'll
423:13 - deploy this
423:15 - we'll go in here
423:16 - so our number is right now five and
423:18 - let's learn about how the modulo works
423:20 - if we have this do mod function
423:23 - what we're doing
423:25 - is
423:25 - the module divides
423:28 - by
423:29 - the number
423:31 - and returns the remainder
423:34 - for example if we did 5 mod 5 what do
423:38 - you think we're going to get
423:39 - so we're going to do 5 divided by 5 and
423:42 - then return the remainder
423:44 - well 5 divided by five is one and
423:46 - there's no remainder there's no decimal
423:48 - there so five mod five should be what
423:51 - zero exactly well what's five mod four
423:53 - then
423:54 - well four can go into five evenly once
423:57 - but there's one number left over so five
424:00 - mod four is going to be
424:02 - one
424:03 - five mod three is going to be two five
424:06 - mod one is going to be zero right since
424:09 - one goes with everything this is how the
424:11 - mod function works and it's this little
424:12 - percent here we can use that mod
424:15 - function
424:16 - in our fulfill randomness
424:18 - with the length of our players so we can
424:20 - say uint 256
424:23 - index of winner
424:26 - is going gonna be equal to
424:28 - the random number that we got
424:31 - modded
424:32 - by the players dot length so let's say
424:35 - for example we had seven players
424:38 - sign up and our random number was 22
424:41 - well we want to get one of these random
424:43 - seven players so
424:45 - we would do 22
424:47 - mod 7.
424:49 - 7 divides evenly into 22 three times
424:52 - with one left over seven
424:55 - times 3
424:56 - equals
424:57 - 21.
424:59 - difference between 21 and 22
425:01 - is 1
425:02 - 7 times
425:04 - 4
425:04 - is 28 so we know this is how we know
425:08 - we've reached our upper limit so this is
425:10 - how we can get a random number
425:13 - based off of the index
425:15 - now that we have this index what we can
425:16 - do
425:18 - is we can say the winner
425:19 - equals
425:21 - players
425:24 - of the index of winner
425:27 - and just to keep track let's make a new
425:30 - variable called recent winner at the top
425:33 - we'll do address
425:35 - public
425:36 - recent winner
425:39 - we'll grab this recent winner instead of
425:41 - winner we'll say recent winner equals
425:43 - players and this index of winner here
425:46 - now that we've got a winner wallet we
425:48 - want to pay them all the money
425:50 - gathered from our enters here
425:52 - so what we can do
425:54 - is we'll do
425:55 - this recent winner
425:58 - dot transfer
426:01 - the entire balance of this address
426:04 - so we'll say address of this
426:08 - that balance
426:10 - and perfect
426:11 - we'll transfer them everything that we
426:13 - have
426:15 - then of course
426:16 - we're going to want to reset the lottery
426:18 - so that we can start from scratch we can
426:20 - start blank again
426:22 - so we'll do players
426:25 - equals new
426:28 - address payable
426:31 - array of size 0.
426:33 - so
426:34 - we're just resetting players to just be
426:36 - a brand new array then we're going to
426:38 - change our lottery state
426:41 - to being
426:42 - lotterystate.closed
426:44 - because the lottery is now complete and
426:46 - i often also like to keep track of the
426:48 - most recent random number
426:50 - so at the top
426:53 - i'll do a uint 256 public
426:56 - randomness
426:58 - variable
427:00 - and in our fulfill randomness i'll say
427:02 - randomness now equals
427:05 - underscore randomness
427:08 - and perfect we now have a contract here
427:10 - of course we haven't actually tried it
427:12 - out but we're assuming that it works
427:14 - great so you know what this means it's
427:17 - time to go into testing mode testing and
427:19 - development mode but let's even just try
427:21 - to do a brownie
427:23 - compile first
427:25 - looks like we have
427:27 - an issue here
427:28 - send and transfer are only available for
427:31 - objects of type address payable
427:33 - not address oops looks like we made our
427:36 - recent winner just an address but it
427:38 - needs to be an address
427:40 - payable
427:44 - so let's try browning compile again
427:46 - and beautiful we at least know it's
427:48 - compiling so that's a great sign let's
427:50 - now move into our testing and
427:52 - development phase as you are starting to
427:54 - figure out we can ignore these file
427:57 - import callback not supported bugs and
428:00 - vs code for now i'm sure the solidity
428:02 - linter will get better as time
428:04 - progresses but great so now let's go
428:06 - ahead and move into actually testing and
428:08 - working with everything here
428:10 - so let's go ahead into our scripts
428:12 - and we'll make a little deploy script
428:14 - first
428:16 - let's do a new file
428:19 - call it deploy lottery that pi
428:22 - and let's go ahead and deploy our
428:24 - lottery
428:25 - so same as always we'll do def main
428:29 - we'll come with a new function called
428:31 - deploy
428:33 - lottery
428:35 - and then we'll do def
428:36 - deploy
428:38 - lottery
428:40 - and then we'll just have a pass for now
428:42 - and if we run this
428:44 - brownie run scripts
428:46 - deploy lottery.pi
428:49 - our default network is not defined which
428:51 - means the default is going to be
428:53 - development
428:54 - and we can even
428:56 - verbose here develop
428:58 - meant write that in our brownie config
429:02 - run this
429:03 - gnosh will get spun up
429:05 - and nothing will happen because our
429:07 - deploy lottery function doesn't do
429:08 - anything right now
429:10 - awesome the first thing we need always
429:12 - to deploy a contract is we need an
429:14 - account
429:15 - so we'll do account
429:17 - equals and we've been using this
429:19 - getcount function for some time that
429:22 - we've been adding in a helpful script
429:24 - section so that can pull from a real
429:26 - test net or from a local development
429:28 - environment if we like so to do this of
429:30 - course let's create our new
429:32 - helpful scripts
429:33 - dot
429:34 - pi we'll create our underscore
429:36 - underscore init underscore underscore
429:38 - dot pi
429:40 - so that python recognizes it as a
429:41 - package
429:43 - and in here we'll create a new function
429:45 - f get
429:46 - account
429:48 - for now we'll just have it pass
429:50 - we'll copy this
429:53 - into our deploy lottery we'll do from
429:58 - scripts.helpful
429:59 - scripts
430:01 - import get account
430:03 - now this
430:06 - now this
430:07 - is what our get account looked like
430:09 - in our last project
430:12 - along with that we had
430:14 - these forked local environments
430:17 - we also had from
430:18 - brownie imports accounts
430:21 - and network and config
430:24 - to make this look really nice right
430:26 - let's flush this out just a little bit
430:27 - more so it's even more robust
430:29 - right now as we know
430:32 - we have a way to use
430:34 - brownies ganache accounts
430:36 - and we have a way
430:38 - to use
430:40 - our environment variables
430:42 - however there was a third method that we
430:44 - learned that isn't identified here
430:47 - accounts.load
430:49 - and this is with our id
430:51 - if you still have your account and you
430:52 - still have all your brownies set up if
430:54 - we do brownie
430:55 - accounts
430:57 - list
430:59 - you'll see we have a couple accounts
431:00 - here
431:01 - we want our get account to be
431:04 - even more liberal so that if we wanted
431:06 - to use one of these as well we could so
431:08 - let's modify our get account script here
431:09 - a little bit let's first get rid of this
431:11 - else
431:13 - and rid of this indent
431:14 - what this will do is this will be our
431:17 - default
431:18 - if nothing that we define prior to this
431:20 - is defined we'll just default to grab
431:23 - right from our config which since we are
431:25 - doing that
431:26 - let's create our dot env
431:28 - we'll paste our different variables in
431:30 - here our private key web 3 and fura and
431:33 - etherscan token
431:35 - and in our brownie config of course
431:37 - we'll do wallets
431:39 - from key
431:44 - private key
431:45 - and now let's flesh this out a little
431:47 - bit let's add an index
431:50 - and an id
431:53 - index equals none
431:55 - and id
431:57 - this way if we pass an index to our get
431:59 - account function we'll just use
432:02 - an index from this accounts variable
432:04 - if we pass an id
432:06 - we'll have
432:07 - trying to do this accounts.load here so
432:10 - now let's change this up a little bit
432:12 - we'll say if an index was passed
432:15 - we'll just return
432:17 - accounts
432:18 - on that index
432:21 - otherwise if we're doing a local
432:23 - blockchain we'll just return account to
432:25 - zero
432:27 - but if there's an id
432:29 - we'll return
432:32 - accounts.load
432:34 - id
432:35 - whoops we need to actually move this up
432:37 - a little bit
432:41 - so that it's before
432:43 - our local blockchain checking
432:45 - so now in our deploy lottery
432:47 - we could do something like get account
432:49 - id equals
432:51 - free code camp
432:53 - oops and this is actually free code
432:55 - account
432:57 - precode camp account let's try one more
432:59 - time
433:01 - it's going to ask for our password here
433:03 - now we have a much more liberal get
433:05 - account function
433:07 - so now that we have a count we can
433:08 - actually deploy our lottery
433:11 - so we'll say lottery
433:12 - equals
433:13 - lottery.deploy
433:16 - and this is where we're going to import
433:18 - from brownie
433:20 - import our contract lottery
433:22 - and we're gonna have to add in
433:25 - all these different variables so if we
433:27 - go back over to our lottery contract
433:30 - we need to give it a price feed address
433:32 - a vrf coordinator
433:34 - a chain link token
433:36 - a fee and a key hash
433:38 - now the way we did that in fund me is
433:40 - that we did it in a way where we checked
433:42 - to see if we were on a local chain or
433:45 - not if we weren't on a local chain then
433:47 - we would just pull our addresses
433:48 - directly from our config if we weren't
433:51 - on a local chain though we'd deploy some
433:52 - mocks and use the address of those mocks
433:55 - we're going to want to do the same thing
433:58 - here but let's make our lives a little
433:59 - bit easier
434:01 - we can take this whole process and put
434:03 - it into its own function
434:04 - so let's make this a little bit easier
434:06 - mentally the first thing we're going to
434:07 - need is this price feed address
434:09 - if we're on a real test net of course we
434:11 - would just go into our brownie config
434:13 - and add the address which we will do
434:15 - we'll add our rink b
434:18 - network here in a little bit but for now
434:20 - don't worry about that
434:22 - but if we're not on a wrinky chain what
434:24 - we're going to need to do is deploy our
434:25 - mock
434:26 - we're going to wrap
434:28 - all of this mocking and checking into a
434:30 - single function called
434:32 - get contract
434:35 - and we're going to add this function in
434:37 - our helpful scripts
434:39 - so let's create this function called get
434:41 - contract
434:42 - do def get contract
434:45 - pass
434:48 - let's talk a little bit about what we
434:49 - want this function to do
434:51 - let's add one two three
434:54 - three double quotes here and three
434:56 - double quotes here to start what's
434:57 - called a doc string this will define
435:00 - everything about this contract so we're
435:02 - just going to say
435:04 - this function
435:06 - will
435:08 - grab the contract addresses
435:11 - from the brownie config
435:16 - if defined
435:18 - otherwise
435:20 - it will deploy
435:21 - a mock version
435:24 - of that contract
435:26 - and return
435:28 - that mock contract
435:31 - for the arguments of this chain
435:33 - we're going to take a contract name
435:37 - this is going to be a string
435:39 - and it'll return
435:41 - a contract
435:42 - or in particular it's going to return a
435:44 - brownie
435:45 - dot network
435:47 - dot contract dot project
435:50 - contract
435:51 - the most
435:53 - deployed
435:55 - version of this contract
435:58 - so for example if we have a mock v3
436:01 - aggregator contract
436:03 - it'll do the most recently deployed
436:05 - version of that with this -1 syntax
436:09 - now this get contract function if this
436:10 - is a little confusing to you
436:12 - again we're going to go over this chain
436:14 - link mix in a little bit and inside of
436:16 - this it has a more robust
436:19 - description of what's going on in this
436:21 - get contract bit
436:22 - so you can check that out if you want to
436:23 - learn more but let's go ahead and
436:25 - actually define this
436:27 - so we obviously want a contract name
436:29 - as an input parameter so let's go ahead
436:31 - and add contract name in here
436:33 - meaning that this getcontract function
436:36 - we'll get something like f
436:37 - usd
436:39 - price feed
436:41 - right
436:41 - that's gonna be the same as what's
436:43 - defined in our browning config and from
436:45 - this name we're gonna get the type of
436:47 - contract that it is
436:48 - contract type
436:50 - and to do that we're gonna have to
436:51 - create some mapping that'll map the
436:54 - contract names to their type
436:57 - so right above we're gonna do contract
436:59 - to mock
437:02 - and we're to create a mapping in here
437:04 - which will map everything out
437:06 - so
437:08 - an fusd price feed
437:10 - is going to be of type
437:12 - mock v3
437:14 - aggregator
437:15 - so
437:16 - we have to import mock v3 aggregator
437:18 - from rounding
437:19 - so now we're saying anytime you see fusd
437:21 - price feed you know that that's going to
437:23 - be a mock v3 aggregator if we need to
437:25 - deploy a mock
437:27 - so we'll say contract type
437:29 - is going to equal
437:30 - contract to mock
437:33 - of the contract name
437:37 - now we need to check okay do we actually
437:39 - even need to deploy a mock
437:42 - so sure let's check if we're on a local
437:43 - blockchain
437:45 - so we'll say if
437:46 - network.showactive
437:49 - is in
437:52 - our local blockchain environments
437:54 - and we'll skip the forked local
437:56 - environments because again
437:59 - we don't need to deploy a mock price
438:01 - feed address on a fourth local
438:03 - environment
438:04 - which say if network.showactive is in
438:06 - the local blockchain environments
438:09 - then we'll check
438:11 - to see if one of these contracts has
438:13 - already been deployed we'll say if the
438:14 - length
438:16 - of contract type
438:18 - is less than or equal to zero
438:21 - then we're going to go ahead and deploy
438:22 - mox
438:23 - so this is equivalent to doing
438:26 - something like mach v3
438:30 - aggregate or
438:32 - length
438:34 - we're checking how many mach v3
438:36 - aggregators have actually been deployed
438:38 - if none have been deployed we're going
438:40 - to go ahead and deploy them so
438:43 - we're gonna have to create this deploy
438:44 - mox function so we'll do def deploy
438:47 - mox
438:48 - and this is gonna be the same as what we
438:50 - did
438:52 - in our brownie fund me right it's gonna
438:54 - be the exact same
438:56 - so we'll say
438:58 - account equals
439:00 - get account
439:01 - i'm not going to put the prints in here
439:03 - but you absolutely can we'll say mock
439:06 - price feed
439:07 - equals
439:09 - mock v3 aggregator
439:11 - [Music]
439:13 - dot deploy
439:15 - we'll need to give this some decimals
439:17 - and an initial value so right above
439:19 - we'll do
439:20 - decimals
439:22 - equals eight initial
439:25 - value equals two thousand one
439:29 - two thousand one two three four five six
439:31 - seven eight
439:33 - and in our deploy max we'll say decimals
439:35 - equals
439:36 - decimals
439:41 - initial value equals initial value
439:46 - to deploy decimals and
439:49 - initial value
439:51 - of course this is going to be from
439:53 - account
439:55 - and for now that's it i'll say print
439:58 - deployed
440:00 - all right great so now we have a way to
440:02 - actually deploy the mock price feed here
440:05 - so let's go back up to our get contract
440:06 - function
440:07 - so we have a way to deploy the mock
440:10 - if one already isn't deployed
440:12 - now what we're going to want to do is we
440:14 - want to get that contract right we're
440:16 - going to want to get that mock so we'll
440:18 - say contract
440:19 - equals
440:21 - contract type
440:22 - minus one
440:24 - right so this is going to be equal to
440:25 - doing
440:27 - mock v3r gregator
440:30 - minus one
440:31 - this is saying hey let's grab the most
440:34 - recent deployment of the mock v3
440:35 - aggregator which is exactly what we want
440:38 - perfect so this will work
440:40 - perfectly
440:41 - for our
440:42 - development context however we're not
440:45 - always going to just want to deploy to a
440:47 - development network we're also going to
440:50 - want to deploy to testnets
440:52 - so then we'll say else and this is where
440:55 - we'll just grab that contract from the
440:58 - running config for example fusd price
441:01 - feed so we'll say
441:03 - contract address
441:05 - equals config
441:08 - networks
441:11 - network.show active
441:14 - and that contract name
441:18 - for example again if it's fusd price
441:20 - feed it'll be fused price feed here
441:23 - and the way we're setting it up it's got
441:24 - to be the same as what's in our contract
441:26 - to mock dictionary here so up here the
441:29 - way that we did it was we actually got
441:30 - the contract because we had its contract
441:33 - type
441:34 - based off of browning for here we're
441:36 - gonna have to interact with the contract
441:38 - getting those two pieces that we always
441:39 - need which are gonna be the address we
441:42 - actually have the api from our mock v3
441:45 - aggregator type right here and we just
441:47 - got the address so we can create this
441:49 - new contract type by saying contract
441:51 - equals contract
441:53 - dot from abi
441:55 - and this contract package can be
441:58 - imported right from brownie
442:00 - and it has this function from abi
442:03 - that allows us to
442:04 - get a contract from its abi and its
442:06 - address
442:07 - so we'll just give it a name
442:09 - we can say contract
442:11 - type dot underscore name
442:14 - we do the contract address
442:18 - and then
442:20 - the contract type dot abi
442:24 - so these mock v3 aggregators and all
442:26 - these contracts
442:27 - have a dot avi
442:29 - attribute that returns the api
442:32 - they also have a dot underscore name
442:34 - which returns their name so this is
442:36 - perfect this is how we'll get the
442:37 - contract otherwise and then at the end
442:39 - of all this we'll just do return
442:42 - contract awesome so this is an
442:44 - incredibly powerful function for us
442:46 - to get a contract based off of if it's
442:49 - already deployed as a mock or it's a
442:51 - real true contract i know there's kind
442:53 - of a lot here but definitely check the
442:55 - github repository if you're a little bit
442:56 - confused on what's going on with this
442:58 - function and let's
443:00 - and let's also just deploy this to make
443:02 - our linter happy why not
443:04 - yeah vs code's happy now but now that we
443:06 - have this function let's go back to our
443:08 - deploy lottery
443:09 - now we can do a comma get account
443:12 - and now we have a get account function
443:14 - so let's go through this again
443:16 - this lottery.deploy getaccount is going
443:20 - to get an fusd price feed
443:22 - if we don't have a mock deployed it's
443:24 - going to deploy a mock price feed for us
443:27 - and we're going to return that mock
443:29 - price feed
443:30 - however if we're on a test net if we're
443:33 - on a real network we're going to grab
443:35 - its actual address and return
443:38 - a mock contract of it our mock contract
443:40 - here has all the same functions of a
443:41 - regular contract so we can just use it
443:44 - as the same this way we don't have to
443:46 - adjust this function for whether or not
443:48 - we're deploying to a test net or to an
443:50 - actual address the only additional piece
443:52 - we should put in here just for clarity
443:54 - is we should add dot address here
443:57 - because this is going to return the
443:59 - actual contract and we really only want
444:01 - the address this is going to make our
444:03 - coding a lot more robust for
444:05 - moving between development environments
444:07 - and test environments and working with
444:09 - scripts in a really effective manner so
444:11 - now that we have this incredibly
444:12 - powerful function let's go back to the
444:14 - lottery and figure out what are the
444:15 - different pieces we need in here okay
444:18 - great we also need a vrf coordinator
444:21 - so
444:22 - to do this we're going to go back to our
444:24 - docs.chain.link
444:26 - we'll go to contract addresses
444:28 - and we could do mainnet here but let's
444:30 - also just set this up to work with rank
444:32 - b so we'll do ctrl f for rink b
444:35 - vrf coordinator is going to be this
444:37 - address right here so we'll copy it
444:40 - we'll go back
444:41 - and we're going to have to do
444:43 - in our config
444:44 - is we're going to have to add a new
444:46 - network here for rank b
444:48 - we'll do vrf core data nato
444:52 - will be that address right there
444:53 - and then while we're doing this let's
444:55 - also get the rink b address for our
444:57 - price feed so ethereum price feeds
444:59 - rink b
445:00 - let's scroll down for fusd
445:03 - fusd here we go
445:05 - grab that
445:07 - enter this will be f usd
445:09 - price feed
445:11 - face adder sit here perfect
445:14 - so now we can do get contract
445:17 - vrf coordinator dot address of course
445:21 - we are gonna have to go back to our
445:22 - helpful scripts
445:24 - because there's currently no mapping
445:26 - between what a vrf coordinator is and
445:30 - what its mock needs to be so we'll add a
445:32 - comma here
445:34 - and we'll do vrf coordinator
445:38 - and we need to get
445:40 - a mock vrf coordinator well first of all
445:42 - we don't even have our mach v3
445:44 - aggregator so let's go grab that as well
445:46 - so we can grab both of these again i'm
445:48 - going to highly recommend going to the
445:49 - chain link mix
445:51 - going into the contracts here going to
445:53 - the test folder for these different
445:54 - mocks because these are already set up
445:56 - to work with the chain link mix however
445:58 - you can definitely go into the chain
445:59 - link github as well
446:01 - go to contracts
446:03 - src
446:04 - 0.6
446:06 - tests
446:08 - and then look for the different mocks in
446:09 - here so mock oracle vf coordinator mock
446:12 - et cetera so we're just gonna i'm just
446:14 - gonna grab it though from this chain
446:15 - link mix so let's go to vrf coordinator
446:17 - mock
446:18 - and i'm just gonna grab this whole thing
446:20 - here
446:21 - so i'll do contracts new folder
446:23 - test
446:25 - new file vrf
446:27 - core
446:28 - core
446:29 - [Music]
446:32 - moc.sol
446:34 - paste it in here
446:38 - and then while we're in here we want to
446:39 - do new file
446:40 - mock v3 ah
446:42 - greg
446:44 - sol
446:47 - we'll grab this as well
446:50 - from our chain link mix
446:55 - again it's got all the functions of a
446:56 - price feed update answer
446:59 - latest round etc
447:02 - vrf coordinator walk has different
447:04 - functions for actually working with the
447:05 - vrf coordinator
447:07 - one of the specific ones in particular
447:08 - is this callback with randomness that
447:10 - we're going to use
447:11 - in our tests so our vrf coordinator is
447:14 - going to get mapped to
447:15 - our vrf core
447:18 - nator mock
447:21 - which will also import this
447:24 - from brownie
447:26 - great and just to double check
447:27 - everything's working we'll want to run
447:28 - just a quick brownie compile
447:30 - make sure we are importing our mocs
447:32 - correctly and everything is compiling so
447:34 - it looks like we're good there
447:36 - all right
447:37 - so now we have
447:39 - git contract vrf coordinator dot address
447:42 - perfect what else do we need in here
447:45 - we need a link token the chain link
447:47 - token is of course just another smart
447:49 - contract so we're going to do the exact
447:51 - same thing here
447:53 - get contract
447:56 - link token
447:57 - dot address
448:01 - of course this means
448:04 - in our config
448:06 - for rink b
448:07 - let's add a link token address
448:10 - we'll go to the chain link documentation
448:13 - go to
448:15 - link token contracts
448:18 - look for rink b
448:20 - we'll grab this address
448:25 - we'll drop it in here
448:27 - perfect now we have it in our brownie
448:28 - config
448:29 - we'll also need to add it to our
448:32 - helpful scripts
448:35 - so we'll need
448:39 - a mock link token
448:40 - which again
448:42 - we can just go ahead and grab
448:44 - from our chain like mix here
448:46 - so we can go to test and as you can
448:48 - probably see what i often normally do is
448:50 - literally just copy this entire test
448:52 - folder project to project
448:54 - so i'm going to copy this whole thing
448:58 - create a new file
449:00 - we're just going to call this one
449:04 - link token.sol
449:08 - contract link token perfect
449:10 - and then in our helpful scripts we're
449:12 - going to have this be linked token
449:15 - and of course we're going to import this
449:17 - from brownie
449:19 - great git contract link token.address
449:22 - perfect
449:23 - what else do we need we need a fee and a
449:25 - key hash so the fee and the key hush are
449:28 - both just numbers right these aren't
449:30 - actually contracts so we don't need to
449:31 - put this through that get contract bit
449:34 - what we can do
449:35 - is just in our config
449:38 - and our development network
449:40 - we just add a default for the key hash
449:43 - and for the fee
449:46 - i'm just going to set my development key
449:47 - hash and fee equal to the rink b ones
449:51 - so to grab
449:52 - those go to the chain link docs once
449:55 - again we'll scroll down to using
449:58 - randomness
449:59 - contract addresses
450:01 - we'll look up rink b
450:04 - we'll grab the
450:05 - key hash
450:06 - here which we'll paste in for both
450:13 - are development
450:15 - and rink b
450:18 - and then the fee it says 0.1 link so
450:22 - we'll just do
450:23 - that in way here which will be one
450:26 - one two three four five six seven eight
450:27 - nine ten
450:29 - one two three four five six seven
450:32 - and we'll do this
450:33 - line for ring p as well
450:36 - now in our deploy lottery we can just
450:38 - grab this directly from a browning
450:40 - config because we're always going to
450:42 - have this default key hash and this
450:44 - default fee here for our development
450:46 - network
450:47 - so we'll do config
450:50 - networks
450:53 - network dot show active
451:00 - which one's first the fee
451:03 - fee
451:05 - of course this means we're going to
451:07 - grab network from brownie
451:10 - and also config
451:14 - then we'll do config
451:16 - networks
451:19 - network dot show active
451:30 - and then of course
451:31 - our last bit here
451:34 - from
451:35 - account
451:39 - and then additionally as we learned last
451:41 - time if we want to publish this
451:43 - we'll do publish
451:45 - source
451:47 - equals config
451:50 - networks
451:56 - network dot show active
452:00 - we'll say dot get
452:02 - verify
452:04 - and then we'll add this false bit here
452:06 - what this is saying is get that verify
452:09 - key
452:10 - but if there's no verify key there just
452:12 - default to false this way if we don't
452:14 - set a verify key in development that's
452:16 - fine it just won't get verified for ring
452:18 - b let's go ahead and set verify
452:20 - to true
452:21 - so we can actually verify this on the
452:23 - rigby chain
452:24 - and then we'll even do a print statement
452:26 - here
452:28 - deployed
452:29 - lottery
452:32 - all right lovely let's try this out
452:36 - we'll do brownie
452:37 - run scripts
452:40 - deploy lottery.pie we won't set a
452:42 - network flag so it will go to the
452:44 - default development network let's try
452:46 - this out
452:48 - things are compiling ganache is spinning
452:50 - up
452:51 - it looks like we did run into a little
452:53 - issue here with our our get contract
452:55 - function
452:57 - ah of course we forgot to add deploying
453:00 - these mocks in our deploy mock script
453:02 - whoops let's go ahead and add that as
453:04 - well
453:05 - right now our deploymox only deploys the
453:07 - mach v3 aggregator
453:09 - so let's add the rest of our mocks in
453:10 - here
453:12 - we're going to need to deploy a vrf
453:14 - coordinator mock and a chain link token
453:16 - mark so let's open up those contracts
453:18 - see what they need
453:20 - a link token
453:21 - for a constructor
453:24 - doesn't have a constructor so we can
453:26 - just have it be blank
453:27 - so we'll do
453:29 - link token
453:32 - dot deploy
453:34 - and all we need is a from
453:36 - account here
453:38 - and then let's see what that vrf
453:40 - coordinator mock takes
453:41 - prf coordinator mock
453:46 - it takes the link token as an address
453:49 - perfect
453:51 - so then when we deploy the link token
453:52 - here
453:53 - we'll say link token
453:54 - equals link token.deploy and then we'll
453:56 - do vrf
453:59 - core
454:00 - donator mock
454:03 - dot deploy
454:04 - ploy
454:07 - and then we'll use the link
454:08 - token.address
454:11 - as an input parameter
454:13 - and then of course from
454:15 - account
454:16 - all right so now we're deploying all
454:19 - three of those mocks right away
454:22 - let's try this again
454:23 - brownie run scripts
454:25 - deploy lottery.pi
454:28 - ganache is spinning up
454:30 - perfect
454:32 - so we can see here that our mach v3
454:35 - aggregator was deployed
454:37 - then our mock link token was deployed
454:39 - then our mock vrf coordinator was
454:41 - deployed and then our lottery was
454:43 - deployed with those mocks defined
454:45 - and we deployed the lottery awesome
454:48 - now we could 100 percent
454:51 - go ahead and then run this script on an
454:53 - actual test net right because our config
454:56 - is set up well let's write some more
454:58 - functionality for actually interacting
455:00 - with this lottery
455:02 - before we actually do that and then we
455:04 - can actually just run a script which
455:05 - will do all this functionality end to
455:07 - end because again deploying to testnet
455:10 - takes a long time and we really only
455:11 - want to do that when we're done and
455:12 - we're fairly confident that everything's
455:14 - working well let's even just delete this
455:16 - here
455:17 - so now what's the next thing that we'd
455:18 - want to do here what's the next thing we
455:20 - want to do in a script here well we'd
455:21 - probably want to go ahead and start the
455:23 - lottery so let's write a script that can
455:25 - actually do that
455:26 - we'll do def
455:28 - start lottery
455:30 - and then here we get our account
455:33 - equals get account
455:36 - we'll say the lottery is going to be the
455:38 - most recent deployment
455:40 - of the lottery
455:42 - and we're going to call this start
455:44 - lottery function here this is indeed
455:46 - changing state so we do have to make a
455:48 - transaction
455:50 - we'll do lottery
455:51 - let's start
455:53 - lottery
455:55 - we'll say from
455:57 - account
456:00 - then we'll do a little print and just
456:02 - say
456:03 - the lottery is started
456:07 - and then in our main function down here
456:08 - we can even call this start lottery
456:10 - function
456:12 - so if we run this
456:13 - again on our development chain
456:16 - we'll see if everything works smoothly
456:17 - here okay we did run into an issue and
456:19 - this is something that you'll see from
456:20 - time to time
456:21 - typically the workaround is you want to
456:23 - wait for that last transaction to
456:24 - actually go through so we'll say
456:26 - starting
456:27 - transaction
456:29 - equals lottery.start lottery it will do
456:31 - starting
456:32 - transaction.weight
456:34 - 1.
456:35 - brownie sometimes gets a little confused
456:36 - if you don't wait for the last
456:37 - transaction to go through
456:39 - so let's try it again and perfect we do
456:41 - get this working as intended so that is
456:44 - really helpful helpful tip if you run
456:45 - into those weird issues you'll notice
456:47 - that even when we didn't have this it's
456:48 - still completed successfully i just got
456:51 - a little confused at the end
456:52 - all right cool so what do we want to do
456:55 - next well we probably want to enter the
456:57 - lottery let's do def
457:01 - enter
457:02 - lottery so how do we enter the lottery
457:05 - say account equals get account
457:09 - lottery is going to be
457:11 - lottery
457:14 - minus one
457:15 - we need to pick some value to send when
457:18 - we call the enter function
457:20 - right because we need to send that
457:22 - entrance fee with it
457:24 - so we'll say value equals lottery dot
457:27 - get
457:28 - entrance fee
457:31 - and just to be safe i usually will tack
457:33 - on a little bit of whey as well because
457:36 - sometimes it might be off by like one or
457:38 - two or something like that so we'll do
457:39 - lottery. get entrance fee plus you know
457:41 - maybe something like this which is like
457:43 - barely anything then we'll do
457:46 - transaction equals lottery.enter
457:49 - do from account
457:52 - send a value which will be value
458:02 - we'll do tx.weight
458:04 - and then we'll do print
458:08 - you entered the lottery
458:12 - and we'll do this enter lottery bit down
458:14 - here too enter lottery
458:17 - we'll run this see if our enter script
458:19 - is working appropriately
458:21 - you entered the lottery looks great and
458:24 - let's do our last function here we'll do
458:26 - def
458:27 - end lottery
458:30 - count equals get account
458:34 - lottery equals
458:36 - lottery minus one we'll make a
458:38 - transaction which will be lottery dot
458:40 - end lottery
458:44 - now before we actually end this lottery
458:47 - we're going to need some link token in
458:49 - this contract
458:50 - because remember our end lottery
458:52 - function
458:53 - calls this request randomness function
458:56 - and we can only request some randomness
458:58 - if
458:59 - our contract has some chain link token
459:01 - associated with it so we're going to
459:03 - need to first
459:04 - fund the contract
459:07 - and then
459:08 - end the lottery since funding our
459:10 - contracts with the link token is going
459:11 - to be a pretty common function that we
459:13 - use let's go ahead and turn this also
459:15 - into a helpful script
459:17 - so let's go to our helpful scripts we'll
459:19 - make a new function
459:20 - called fund with
459:23 - link
459:25 - and let's have this take a couple of
459:27 - parameters so first we'll want to have a
459:29 - contract address of course
459:31 - we'll want to know who we're going to
459:32 - fund with link we'll set a default
459:35 - account to being none
459:36 - so if you want you can send an account
459:38 - but you don't have to if you don't want
459:40 - to we'll also do the same thing with a
459:42 - link token we'll say if you want to use
459:45 - a specific link token you can otherwise
459:48 - we'll just grab it ourselves
459:50 - and then we'll also do a default amount
459:52 - which we'll set to
459:54 - 1
459:54 - one two three four five six seven eight
459:56 - nine ten one two three four five six
459:58 - seven
459:59 - which is going to be
460:01 - 0.1 link
460:03 - so first let's get an account we'll say
460:05 - account
460:06 - equals
460:07 - we're going to do a little clever python
460:09 - stuff here
460:10 - we'll say account equals the account
460:12 - if somebody sent it
460:14 - if account
460:16 - so we're saying
460:17 - the account that we use
460:19 - is going to be
460:20 - this account thing if this account thing
460:23 - even exists otherwise we'll call our get
460:26 - account otherwise we'll just do our
460:27 - regular get account function
460:29 - then we'll do the same thing with the
460:31 - link token
460:32 - say the link token
460:34 - is going to be equal to
460:35 - the link token
460:37 - that somebody supplies as a parameter
460:40 - if
460:41 - they applied something as a parameter
460:43 - otherwise we'll just do that get
460:44 - contract stuff that we did before
460:47 - of the link token
460:50 - now that we have this link token
460:52 - contract from our get contract function
460:55 - which again is basically the equivalent
460:56 - of doing which again is doing this
460:58 - contract up from abi on our link token
461:02 - pulling from
461:04 - our config or from our mock now we can
461:07 - just call the functions on this link
461:09 - token so we can say our transaction
461:11 - equals
461:12 - link token
461:14 - dot transfer
461:16 - we're going to transfer token to
461:19 - the contract address
461:21 - with a certain amount
461:23 - and of course we'll do from
461:26 - account
461:28 - we'll do tx.weight
461:30 - and then we'll do print
461:33 - funded contract
461:35 - and then we'll even return that
461:36 - transaction
461:37 - i do however want to show you another
461:39 - way to work with this using the
461:41 - interfaces instead of doing this
461:43 - linktoken.transfer directly on the
461:45 - contract we can use this interfaces
461:47 - section
461:49 - to actually interact with some contracts
461:51 - so right now we have our mock link token
461:53 - in here which is great because it has
461:55 - all the definitions and all the
461:56 - functionalities defined in here
461:58 - sometimes you're going to have contracts
461:59 - that you don't have everything you don't
462:01 - have all the functionality and maybe you
462:03 - only have the interface maybe you only
462:05 - have some of the function definitions so
462:07 - we can still interact with contracts
462:09 - with just an interface because again
462:11 - that interface will compile down to our
462:13 - api
462:14 - so as another way of teaching us how to
462:17 - actually work
462:18 - with some of these contracts
462:20 - what we can do
462:22 - is we can use we can use the link token
462:24 - interface basically the same way as we
462:27 - used the link token contract here so
462:28 - again i'm in my chain link mix because
462:30 - there's already a link token interface
462:32 - in here and this will compile down to a
462:35 - way that our brownie package knows how
462:37 - to interact with these contracts
462:39 - so if you wanted to we could just grab
462:40 - this
462:41 - go to our brownie section
462:43 - we'll do a new file in interfaces
462:47 - we'll call it link
462:49 - token interface
462:51 - dot soul
462:53 - we'll paste it in here
462:55 - save my auto format auto formatted here
462:58 - and what we can do in our helpful
462:59 - scripts instead
463:01 - is transaction
463:02 - equals interface
463:05 - and we can also just import interfaces
463:08 - right from brownie
463:10 - interface dot
463:13 - link
463:14 - token interface
463:16 - and we just need to give it
463:18 - a contract address so we can say link
463:22 - token dot address
463:25 - excuse me we could say
463:27 - link token
463:31 - contract equals interface dot link token
463:34 - interface link token dot address
463:36 - so this is another way we can actually
463:38 - create contracts to actually interact
463:40 - with them
463:41 - so we saw up here
463:42 - this contract.from abi which is great
463:45 - this is another way we can do that exact
463:47 - same thing so then we can just do
463:49 - linktokencontract.transfer
463:51 - contract address
463:53 - amount
463:55 - from
463:57 - account
464:01 - so this is tx equals
464:03 - so this is another way to actually
464:05 - interact with contracts that already
464:07 - exist you're probably starting to see
464:08 - that brownie has a lot of built-in tools
464:10 - that make it really easy for us to
464:12 - interact with contracts if we have the
464:14 - api we can just pop it into
464:16 - contract.from avi and again with the
464:18 - address and the api and then just give
464:20 - it some name if we have the interface we
464:22 - don't even need to compile down to the
464:24 - api ourselves because brownie is smart
464:26 - enough to know that it can compile down
464:28 - to the api itself and we can just work
464:30 - directly with that interface which is
464:32 - incredibly powerful for now
464:34 - i'm going to comment these two lines
464:36 - though and we'll just use the
464:38 - linktoken.transfer for now now that we
464:39 - have a funding script or a funding
464:41 - function we can import this from our
464:43 - helpful scripts
464:45 - from scripts.helpful scripts import get
464:47 - account get contract
464:49 - fund with link
464:51 - and we can just call in our end lottery
464:54 - function
464:55 - we'll do fund with link
464:57 - and parameters we just we only really
464:59 - need a contract address because the way
465:01 - we set this up we'll just automatically
465:03 - grab a default otherwise so we can say
465:07 - lottery dot address
465:10 - and that's it that's all we need and
465:12 - then i know we're doing tx.weight right
465:14 - in the fund with link but just for to be
465:16 - verbose here
465:18 - we'll get the transaction from the fund
465:20 - with link and we'll do tx.weight here as
465:23 - well
465:25 - and then once we're funded with link
465:27 - then we can go ahead and call our end
465:29 - lottery function because again this is
465:31 - going to call that request randomness
465:33 - function from the vrf we'll do
465:37 - end
465:38 - ending transaction
465:40 - equals
465:42 - lottery dot end
465:44 - lottery and all we have to do is from
465:49 - count
465:52 - to ending
465:54 - transaction.weight
465:56 - one
465:57 - so from our end this is really all that
465:59 - we need to do
466:01 - right but remember
466:03 - when we call this end lottery function
466:05 - we're going to make a request to a chain
466:07 - link node and that chain link node is
466:09 - going to respond by calling this fulfill
466:11 - randomness function
466:12 - so we actually have to wait for that
466:14 - chain link node to finish
466:16 - now typically it's within a few blocks
466:18 - so normally what we can do is we can
466:20 - just do a time dot sleep
466:23 - for something like 60 seconds
466:25 - and typically in that time the chain
466:26 - link node will have responded
466:28 - so we'll just do import time
466:30 - at the top
466:32 - time dot sleep
466:33 - and then
466:34 - we can see
466:36 - who that recent winner is if that chain
466:38 - link node responded with a recent winner
466:40 - so we can say print
466:43 - f
466:45 - lottery dot resent
466:47 - winner
466:50 - is the new winner
466:53 - all right now of course for those of you
466:56 - who are thinking ahead a little bit you
466:57 - might be thinking hey well there's no
466:59 - chain-link nodes watching our local
467:01 - ganache
467:02 - and you're exactly correct so what
467:03 - happens when
467:05 - we add
467:06 - our end lottery function
467:08 - to our main function here
467:10 - do you think that we're going to
467:11 - actually get a recent winner back why
467:14 - are we not what do you actually think
467:16 - well let's give it a shot
467:18 - do brownie run scripts deploy
467:20 - lottery.pie
467:24 - so we're doing a lot of transactions
467:25 - here we've started the lottery we're
467:28 - entering the lottery you entered the
467:30 - lottery we're sending some link token
467:33 - now we just called the end lottery
467:35 - function
467:36 - while we're waiting here
467:38 - this is when the chain-link node would
467:40 - go ahead and start responding with our
467:43 - randomness however as you're probably
467:45 - astutely telling however as you probably
467:47 - astutely guessed
467:49 - there's no chain-link node that's going
467:50 - to call this fulfill randomness function
467:52 - right now so for our grenache chain this
467:54 - will hypothetically end
467:57 - with nothing right because there's no
467:59 - chain-link node actually responding here
468:00 - zero is the new winner of course this
468:02 - means that the chain-link node actually
468:04 - didn't respond because there is no chain
468:06 - link node on our local ganache for our
468:08 - testing purposes we're going to figure
468:09 - out how to actually get around that and
468:11 - deal with that
468:12 - awesome it looks like we have everything
468:14 - set up to be successful in our lottery
468:16 - here
468:17 - but we want to do our due diligence we
468:19 - want to make sure that our tests are
468:22 - really solid on a development chain
468:24 - before we actually test this on an
468:26 - actual test then so let's jump into some
468:28 - of these tests we've already started
468:30 - with this testlottery.pi bit here but
468:32 - we're going to iterate on this and make
468:34 - this even better
468:36 - now before we get into these tests
468:37 - there's a couple of things we want to
468:38 - talk about here and that's going to be
468:40 - integration tests and unit tests unit
468:43 - test is a way of testing the smallest
468:45 - pieces of code in an isolated system
468:48 - and we're going to use it to loosely
468:49 - define testing independent functions in
468:51 - our lottery contract
468:53 - we also want to do what's called
468:55 - integration testing which is going to be
468:57 - testing across multiple complex pieces
469:00 - typically i like to run my unit tests
469:01 - exclusively on a development environment
469:04 - and my integration tests on a test net
469:06 - this is really helpful because we can
469:07 - test the majority of our application
469:09 - like we said on a development network
469:11 - and then still be able to see what
469:13 - actually happens on a real test net and
469:15 - see what happens on etherscan and
469:16 - everything like that
469:18 - typically
469:19 - what people do is in their side their
469:21 - tests folder they'll create two
469:23 - different folders one for unit
469:26 - and another folder for intergration
469:30 - since for this demo we're only going to
469:31 - have one file for both i'm just going to
469:34 - go ahead and not create these folders
469:35 - but
469:37 - but it's a pretty common practice
469:41 - instead what i'm going to do is i'm
469:42 - going to rename this i'm going to hit
469:43 - enter to rename it
469:45 - i'm going to do underscore type unit
469:49 - for unit tests and we're going to create
469:50 - a new file
469:52 - called test
469:53 - lottery
469:55 - integration
469:56 - dot pi so this one we'll do our
469:59 - integration test and in this one we'll
470:02 - do our unit tests now when writing unit
470:04 - tests we really want to test
470:06 - hypothetically every single line of code
470:09 - in our smart contract this is incredibly
470:11 - important of course because smart
470:12 - contracts are open to everybody to see
470:15 - and interact with so we really want to
470:17 - test every single line of code we have
470:19 - in here
470:20 - so let's go ahead and let's go ahead and
470:21 - finish writing a get entrance fee test
470:24 - that will work on a local development
470:25 - network as you can see we're already
470:27 - going to have to refactor this from what
470:29 - we originally had let's go ahead and
470:31 - just delete everything under here for
470:32 - now
470:33 - we already learned so much more from
470:34 - there all right so how are we going to
470:36 - test this get entrance view function now
470:38 - so first we're going to want to deploy
470:39 - our lottery again
470:41 - since we have
470:43 - a deploy lottery script already
470:47 - we can just use this deployed audio
470:48 - script as well
470:50 - if we wanted to we could just copy paste
470:52 - this hold part into our test but
470:54 - we're just going to go ahead and work
470:55 - from this deploy lottery script so
470:58 - we're going to import this and then we
470:59 - can actually even
471:01 - get rid of this from web3 line for now
471:03 - we can get rid of these two comments too
471:05 - and we'll say from
471:06 - scripts that deploy lottery
471:10 - import
471:12 - deploy
471:14 - lottery and on this deploy lottery
471:16 - function would say lottery
471:18 - equals deploy lottery
471:20 - and we will return our lottery
471:23 - now our unit test we'll say lottery
471:26 - equals deploy
471:28 - lottery
471:30 - and this will give us our lottery
471:31 - contract once we have our lottery
471:33 - contract
471:34 - we can just call this get entrance fee
471:37 - so we can say entrance fee
471:40 - equals lottery dot get
471:42 - entrance fee
471:44 - and oops let's just make sure we're
471:46 - doing the arrange
471:49 - act
471:52 - assert mentality here
471:54 - and we're going to want to make sure
471:55 - this entrance fee is what we expect it
471:58 - to be so what do we expect it to be
472:01 - well
472:02 - again our helpful scripts is going to
472:04 - deploy these mocks right
472:06 - it's going to deploy this mock and the
472:07 - initial value is this 2000 number so if
472:10 - the price
472:12 - of eth here is 2 000
472:15 - 2 000 f usd feed and the usd
472:20 - entry fee
472:22 - is 50.
472:23 - we'd say 2 000
472:25 - over 1
472:26 - is equal to 50 over x
472:30 - which is going to be equal to 0.025
472:34 - so we can go ahead and even do this math
472:35 - here
472:37 - we can say expected
472:42 - expected
472:44 - entrance fee
472:46 - is going to be equal
472:48 - to
472:48 - it's going to be equal to 50 divided by
472:50 - 2000.
472:51 - we'll just do 0.025
472:54 - but we'll do this in
472:56 - way so do from web3
472:59 - import web3
473:01 - we'll say this is web
473:03 - 3.2
473:05 - way
473:06 - 0.25 ether
473:09 - and now we'll assert
473:11 - our expected entrance fee
473:13 - equals
473:15 - the entrance fee now to test this we'll
473:18 - do brownie test k
473:22 - and perfect this is working
473:24 - exactly as we anticipated so that's
473:26 - awesome now as we mentioned since this
473:28 - is a unit test we really only want to
473:30 - run this when we're working on a local
473:32 - environment a local blockchain
473:34 - environment or a local development
473:35 - network so we'll go ahead and do this
473:37 - with pythons again
473:38 - so if network dot showactive
473:41 - is not
473:42 - in
473:43 - local blockchain environments
473:46 - pi test dot skip of course we're gonna
473:48 - have to import pi test
473:51 - we're gonna have to import this local
473:53 - blockchain environments from our
473:54 - scripts.helpful scripts my vs code
473:56 - automatically added that bit here now if
473:58 - we try to run this
473:59 - brownie run
474:01 - excuse me brownie test
474:03 - dash k
474:05 - get entrance fee dash dash network rank
474:09 - rink eb it should go ahead and skip this
474:13 - perfect that's what it does
474:14 - what's the next piece that makes sense
474:16 - here enter is going to be one of the
474:18 - first things that these developers do so
474:20 - let's do test def
474:22 - test enter but let's even be more
474:24 - specific than that we don't want people
474:26 - to be able to enter our lotteries unless
474:28 - the lottery is actually started so let's
474:30 - make sure that this line actually works
474:32 - so we'll call
474:34 - def test
474:36 - can't enter unless
474:39 - started and again we're only going to
474:41 - run this on a local development chain so
474:44 - we'll just copy paste this section down
474:46 - here we'll say lottery
474:48 - equals
474:50 - deploy
474:51 - lottery because we're going to want to
474:53 - work with the lottery and now we're
474:55 - going to want to that when people try to
474:57 - enter a lottery that hasn't started yet
474:59 - it's going to revert so we can use what
475:01 - we've used before we'll say with pi
475:03 - tests dot
475:04 - raises exceptions dot virtual machine
475:09 - error
475:11 - lottery dot enter
475:15 - from
475:16 - get account
475:20 - value
475:22 - lottery dot get entrance fee
475:26 - of course we're going to import both get
475:28 - account
475:30 - from our helpful scripts
475:32 - and exceptions from ronnie
475:37 - perfect and this as well is following
475:39 - the arrange
475:42 - and this is actually act slash
475:46 - assert so let's go ahead and test this
475:52 - brownie test k
475:54 - test can't enter unless starter
475:57 - oops let's do start ed
475:59 - and great that's passing as well let's
476:02 - go ahead and keep going down this list
476:04 - what else now we've tested whether or
476:05 - not they can't enter let's test whether
476:07 - or not they can enter so we'll do def
476:10 - test
476:11 - can
476:12 - start
476:14 - and
476:14 - enter lottery
476:17 - so we're going to copy this again
476:20 - paste it down here since we're going to
476:21 - work on a local blockchain
476:23 - we'll do lottery
476:24 - equals
476:25 - deploy
476:27 - lottery
476:29 - account equals get account
476:32 - we'll start the lottery
476:34 - lottery.start
476:38 - lottery
476:40 - we'll do from
476:42 - account
476:44 - we'll do lottery.enter
476:48 - from
476:49 - account
476:51 - save value is
476:53 - lottery
476:54 - dot get
476:56 - entrance fee
477:00 - and then we'll assert
477:03 - that
477:03 - we've correctly added a player to this
477:05 - lottery so we'll assert
477:07 - lottery.players
477:10 - of zero is going to be this account
477:14 - right because we have our players array
477:17 - and we're going to assert
477:18 - that we're pushing them onto our array
477:20 - correctly
477:22 - lottery.players 0 equals
477:24 - account so here's our act
477:28 - here's our assert
477:30 - so let's try this now
477:32 - brownie test dash k test can
477:35 - start and enter lottery
477:37 - and once again awesome things are
477:39 - looking great
477:40 - now let's test to see if we can actually
477:43 - end a lottery so we've tested we can
477:45 - start a lottery so we'll do def
477:48 - test can and
477:50 - lottery we're going to copy this again
477:53 - paste it down here
477:55 - do lottery equals deploy
477:58 - lottery
478:01 - account equals get account
478:05 - we'll start the lottery with
478:06 - lottery.start
478:08 - lottery
478:09 - now we could 100
478:11 - just import the rest of these functions
478:12 - in here like n lottery enter lottery and
478:15 - start lottery and similar to how we're
478:17 - just doing lottery equals deploy lottery
478:19 - we could absolutely do that for being
478:21 - very verbose here i'm just going to go
478:23 - ahead and write all the functions and
478:25 - transactions myself and this way we'll
478:28 - actually be able to test a little bit
478:30 - more granularly anyways
478:33 - we'll do lottery dot
478:35 - start lottery
478:37 - from
478:39 - account
478:42 - do lottery dots enter
478:45 - from
478:47 - account we'll give it a value
478:50 - lottery dot get entrance fee
478:56 - so i'm gonna have to do account
478:58 - course equals get account
479:02 - now
479:03 - to actually end the lottery we do need
479:05 - to send this some link because we're
479:07 - calling request randomness we use our
479:09 - fund with link script
479:11 - that we have in our helpful scripts
479:14 - we'll import this from our helpful
479:16 - scripts
479:18 - we'll call
479:19 - fund with link
479:21 - on our
479:22 - lottery contract
479:25 - once we fund with link we'll then call
479:27 - lottery dot
479:29 - end lottery
479:33 - from
479:34 - account
479:37 - and then how do we actually know
479:39 - that this is being called correctly well
479:42 - if we look back in our lottery contract
479:45 - here when we call end lottery we don't
479:47 - we're not really doing a whole lot all
479:48 - we're doing is changing our state so
479:50 - let's go ahead and check to see if our
479:53 - calculating winner state is different so
479:55 - we'll say assert
479:57 - lottery
479:59 - dot
480:01 - lottery state
480:03 - is equal to what
480:05 - so calculating winner if we scroll up to
480:07 - our enum
480:09 - is in position two open is zero close is
480:12 - one calculating winner is two
480:14 - so we can say
480:16 - assert lottery.lotterystate equals two
480:19 - two
480:21 - we can go ahead and test this as well
480:23 - we'll do brownie
480:25 - test k test can end lottery
480:29 - we'll see if this works
480:32 - and it does
480:33 - now let's test the most interesting
480:35 - piece of this entire lottery contract
480:37 - we're going to test whether or not our
480:39 - fulfill function actually works
480:41 - correctly
480:42 - does this correctly choose a winner does
480:45 - it correctly pay the winner
480:47 - and does it correctly reset so let's go
480:50 - ahead and build our most
480:52 - complicated and most important test of
480:54 - this whole contract choosing the winner
480:57 - we'll do def
481:00 - test
481:02 - can pick
481:03 - winner
481:05 - correctly
481:07 - let's copy paste this bit
481:10 - about getting started
481:12 - we'll do lottery equals
481:15 - deploy lottery
481:17 - account equals get account
481:20 - we'll do lottery dot start
481:23 - lottery
481:25 - from
481:27 - account
481:31 - and then we'll enter with a couple
481:32 - different players we'll do lottery dot
481:34 - enter
481:37 - let's say from
481:40 - account
481:42 - value
481:44 - lottery dot get
481:46 - entrance fee
481:51 - enter
481:53 - and we'll copy this two more times
481:55 - but instead
481:58 - we use some different ids we'll do index
482:01 - equals one
482:03 - and we'll do index equals 2.
482:06 - these are going to be different accounts
482:07 - here because we're going to use a
482:09 - different index
482:10 - because we want to just test for
482:11 - multiple different people here
482:14 - this unit test is getting drastically
482:16 - close to being an integration test but
482:17 - as i said we're being a little bit loose
482:19 - with the definitions here now we're
482:21 - going to want to fund it with link so we
482:23 - can just go ahead and copy this line
482:25 - here
482:26 - fund with link lottery
482:28 - and now we're going to want to choose a
482:29 - winner here
482:31 - and this is where we actually have to
482:32 - modify one more thing
482:34 - in our lottery contract so in order to
482:36 - test actually calling this fulfill
482:38 - randomness function
482:40 - and testing everything in here
482:42 - we're going to need to call this fulfill
482:45 - randomness function
482:47 - now if we look at our vrf coordinator
482:49 - moc
482:50 - we have this function called callback
482:52 - with randomness
482:53 - and this is the function
482:55 - that actually calls this raw fulfill
482:58 - randomness.selector which eventually
483:00 - will call that fulfill randomness
483:02 - function but this is the entry point
483:04 - that the that the node actually calls
483:07 - we have to pretend to be a chain-link
483:08 - node and call this function
483:11 - we're going to return
483:12 - a random number of course we're going to
483:14 - choose the contract we want to return to
483:17 - but we also have to pass the original
483:20 - request id
483:21 - associated with the original call now in
483:25 - our lottery contract
483:27 - our end lottery function
483:29 - isn't going to return anything
483:31 - and even if it did it would be really
483:33 - difficult for us to get that return type
483:35 - in our python so what we want to do
483:38 - to keep track of when this contract
483:40 - actually entered the calculating winner
483:42 - state is we want to do what's called
483:45 - emitting an event events are pieces of
483:47 - data executed in the blockchain and
483:49 - stored in the blockchain but are not
483:51 - accessible by any smart contracts you
483:54 - can kind of think of them as the print
483:56 - lines of a blockchain or the print
483:58 - statements of a blockchain
484:12 - we can go to this logs section which
484:14 - also includes all the different events
484:16 - now there's a lot of information here so
484:18 - we're actually going to do an event
484:20 - ourself just so that we can see what
484:22 - this really looks like you can see here
484:24 - that when we call this end lottery
484:25 - function
484:27 - in the logs if we scroll to the bottom
484:30 - there's an event here called
484:32 - randomnessrequest
484:33 - this was spit out by the vrf coordinator
484:36 - this was spit out by the vrf consumer
484:39 - base that we inherited and it even has
484:41 - some data that's already been decoded
484:43 - one of those pieces of data is the
484:45 - request id now to add an event we first
484:48 - need to create our event type
484:50 - so at the top we'll go ahead and do
484:53 - event
484:54 - requested
484:57 - randomness
484:59 - we'll say bytes 32
485:02 - request id
485:04 - so now we've identified
485:06 - a new type of event called requested
485:08 - randomness
485:10 - it's really similar to the enum in this
485:12 - regard
485:14 - to omit one of these events
485:16 - all we have to do in our end lottery bid
485:18 - is we'll do omit
485:20 - requested randomness and then request id
485:24 - because requested randomness takes a
485:26 - bytes32
485:28 - as an input parameter
485:30 - and we're going to pass it that request
485:31 - id as an input parameter now that we
485:34 - have this event being omitted back in
485:36 - our test when we call
485:38 - end lottery it will actually omit one of
485:40 - these events to our transaction
485:43 - so what we can say then
485:45 - is transaction
485:49 - equals lottery.nd lottery
485:53 - same way we've always done it
485:56 - but now we can look inside of this
485:57 - transaction object
485:59 - inside of this transaction object is
486:01 - actually an attribute called events
486:04 - which stores all of our events we can
486:07 - then look for
486:08 - a certain event name which we know is
486:10 - requested randomness so we'll say out of
486:13 - all the events look for the requested
486:14 - randomness event
486:18 - and in there
486:19 - in that request randomness event
486:22 - find the request id
486:26 - request id
486:29 - now we can say request id
486:33 - request
486:34 - id
486:36 - is going to get grabbed from this
486:38 - event that we omit so these events are
486:40 - going to be really helpful for writing
486:41 - tests these events are also really
486:43 - helpful for a number of other reasons
486:46 - one of the big ones is is upgrading our
486:48 - smart contracts or understanding when a
486:50 - mapping is updated but for now we're
486:52 - going to be using them for testing now
486:54 - that we have this request id what we can
486:56 - do is pretend to be the chain link node
486:59 - and use this callback with randomness
487:01 - function to dummy getting a random
487:03 - number back from the chainlike node so
487:05 - what we're going to do
487:07 - is we're going to call our getcontract
487:08 - function
487:13 - and get that vrf coordinator
487:16 - of course we're going to import it
487:18 - from our helpful scripts
487:20 - and we're going to call that callback
487:22 - with randomness function
487:23 - so we're going to do dot callback
487:27 - with
487:28 - randomness
487:31 - and we need to pass it
487:33 - this request id
487:35 - a random number
487:37 - and then the contract to return to
487:39 - so we'll do request id we'll do some
487:41 - random number
487:44 - like we'll say static
487:47 - rng
487:48 - equals 777.
487:51 - so we'll say the random number that
487:52 - we're going to return is going to be 777
487:55 - and then we'll do lottery dot address
487:57 - because we're going to return it to the
487:58 - lottery
488:00 - once again we're going to say from
488:02 - account because this is making a state
488:04 - change and now that we've got a call
488:06 - back what we can do is do our asserts
488:08 - now so this
488:10 - is us dummying getting a response from a
488:13 - chain-link node and this is how we mock
488:14 - responses in our tests to make our lives
488:17 - way way easier
488:19 - so now we can do we can figure out who
488:22 - the winner of this lottery actually is
488:24 - if these are our three enter entries
488:28 - that means it's 777
488:30 - mod 3 since our random number is going
488:32 - to be 777
488:34 - if we pull out a calculator
488:36 - 777 divided by three
488:39 - it divides evenly so we know that this
488:42 - means the answer to this is going to be
488:45 - zero
488:46 - aka our account is going to be the
488:48 - winner
488:49 - so let's assert
488:51 - the lottery dot
488:53 - recent winner
488:55 - is going to be equal to our account
488:57 - right because
488:59 - we set a recent winner
489:02 - in here
489:03 - we transfer them some money
489:07 - we'll assert
489:08 - lottery.balance
489:11 - is now zero because we're transferring
489:14 - this account all the money
489:17 - and let's even make sure that the
489:19 - account gets more money right so we'll
489:21 - do
489:22 - starting balance
489:23 - of our account
489:25 - starting balance of account
489:28 - equals
489:30 - account.balance
489:32 - count balance and we'll do balance
489:36 - of
489:37 - lottery
489:38 - equals lottery dot balance and then
489:41 - we'll assert
489:43 - account dot balance
489:44 - is now going to be
489:46 - these two added together
489:48 - started balance of account plus
489:51 - the balance of the lottery
489:54 - because we should get all of the lottery
489:56 - winnings here okay so this is a long
489:59 - test but this is probably the most
490:00 - important test let's make sure
490:03 - this is doing what we wanted to do so
490:05 - we'll do brownie test k
490:07 - test can pick winner correctly let's see
490:09 - if this works
490:10 - oops i forgot to put a
490:14 - put some parentheses here let's
490:16 - parentheses here
490:18 - let's try this again
490:19 - and perfect
490:21 - we are actually updating paying out and
490:25 - running our lottery correctly and fairly
490:27 - with true randomness this is incredibly
490:30 - exciting and we've emitted events in our
490:33 - lottery contract to use in the off chain
490:35 - event logging of ethereum i know we're
490:37 - getting antsy
490:39 - to actually run this on a real chain
490:42 - so let's go ahead and do our last bit
490:44 - here create our integration test which
490:47 - we will run on an actual chain and then
490:50 - if we wanted to we go ahead and try our
490:52 - deploy lottery function on a real chain
490:54 - as well all right so let's do our
490:57 - integration test here this is where
490:59 - we're going to actually test on a real
491:02 - live chain we're going to use ring
491:04 - because that's the network that we've
491:06 - been using this whole time which is
491:07 - great now i'm being a little bit liberal
491:09 - in the way that we're doing our tests
491:11 - here and we're just going to do one test
491:13 - for this integration test but keep in
491:15 - mind you're going to want to test every
491:16 - piece of your code so let's just create
491:18 - a test called def
491:20 - test
491:21 - can pick
491:22 - winner
491:24 - now this is going to be
491:27 - the opposite of our unit test
491:29 - our unit tests are only going to be on
491:31 - our local blockchains right we're going
491:33 - to skip if it's not on our local
491:34 - blockchains
491:36 - we're going to do the opposite of this
491:37 - one
491:38 - so we can even just copy this or we can
491:40 - type it out we'll say if
491:42 - our network
491:44 - dot show active
491:47 - is in those local
491:50 - blockchain environments
491:55 - then we're gonna do pi test
491:57 - dot skip
492:00 - of course since we're grabbing these
492:01 - pieces we're gonna do from
492:04 - brownie import
492:06 - network
492:08 - we're going to import pi test
492:11 - and we're going to do from scripts
492:13 - dot
492:14 - helpful scripts
492:16 - import
492:18 - local
492:20 - blockchain and by enronments
492:24 - we're going to deploy our lottery so
492:25 - lottery equals deploy
492:29 - lottery
492:31 - which we're just going to grab from
492:34 - scripts deploy lottery
492:38 - import deploy
492:41 - lottery
492:43 - we'll do account equals get account
492:46 - of course we're going to grab that from
492:48 - our helpful scripts as well
492:52 - so we'll do lottery
492:55 - let's start lottery
492:59 - this will be from
493:01 - account
493:04 - do lottery.enter
493:08 - say this will be from
493:10 - account
493:13 - we'll do some value which is going to be
493:17 - dot lottery.get entrance fee
493:20 - and if we run into an issue here
493:21 - sometimes again we can do lottery dot
493:23 - get interest fee plus like 100 or a
493:25 - thousand or something like that this is
493:26 - going to be barely any way but
493:28 - for now let's keep it like this
493:30 - then let's just copy this line
493:33 - right again we'll have two people enter
493:35 - the lottery
493:36 - of course it's going to be us both times
493:39 - and great
493:40 - now we're going to want to actually end
493:41 - the lottery so first we're going to want
493:43 - to fund it so let's import that funding
493:45 - script so we'll get fund with link or
493:48 - that function
493:51 - so we'll call our fund with link
493:53 - function on our
493:55 - lottery contract here and then we'll go
493:58 - ahead and end the lottery so we'll say
494:00 - lottery
494:02 - dot
494:04 - and lottery
494:06 - we have to do this
494:07 - from our main account we have to do this
494:09 - from the admin account
494:11 - now this is where it's going to be a
494:12 - little bit different from our
494:14 - integration tests
494:16 - or from our unit tests
494:18 - in our unit tests
494:20 - we pretended that we were the vrf
494:22 - coordinator and we called the callback
494:23 - with randomness we pretended that we
494:25 - were a chain-link node
494:27 - here we're not a chain link node because
494:29 - we're on an actual network so we're
494:31 - actually just going to wait for that
494:32 - chain link node to respond so for
494:34 - simplicity we'll just do time dot sleep
494:37 - and we'll wait like a minute for it to
494:38 - respond
494:40 - of course since we're using time
494:43 - we're going to want to import time right
494:45 - at the top
494:46 - and then since account was the only one
494:48 - to actually be in this
494:50 - we'll do assert
494:52 - lottery
494:53 - recent winner
494:56 - equals equals account
494:58 - and we'll also assert
495:00 - lottery.balance
495:02 - 0. all right great so we have an
495:05 - integration test that we can run which
495:07 - is going to run through pretty much the
495:08 - vast majority of our functionality here
495:11 - so we can go ahead and test this with
495:13 - brownie
495:16 - test
495:17 - will be a little bit verbose here we'll
495:19 - say dash k
495:21 - test can pick winner
495:22 - and then of course we'll do dash dash
495:24 - network
495:25 - rink b now before we run this
495:28 - per usual we got to make sure do we have
495:31 - any test that ring the ethereum we do
495:33 - great do we have any test net chain link
495:36 - we do perfect we have a dot env
495:41 - we do it's got all of our pieces let's
495:43 - check our brownie config
495:45 - dot env dot env awesome and again if you
495:48 - don't want to use the dot envy
495:50 - you can use that other method that we
495:52 - showed you guys how to encrypt with a
495:54 - password that you can actually use
495:56 - oops before we run this
495:58 - let's set this to start lottery because
496:00 - that's the
496:01 - actual function here and we'll also need
496:03 - to be lottery.balance with parentheses
496:05 - here sorry about that and now we can run
496:07 - brownie test dash k
496:10 - fast can pick winner dash network
496:13 - rink b
496:14 - we'll also add this dash s flag which
496:17 - will print out whatever brownie is going
496:18 - to be printing out make everything a
496:20 - little bit more verbose here and if you
496:22 - want to you absolutely should because
496:24 - this is something that we'll have to do
496:25 - at some point anyways however if for
496:27 - this tutorial you want to skip it go
496:29 - ahead because we're actually going to
496:31 - run through this whole process of
496:33 - deploying and waiting again anyways so
496:35 - now we've added all of our tests what we
496:37 - can do is run our entire test suite
496:40 - so we'll do brownie
496:41 - test
496:42 - and this is going to run through all of
496:44 - our development tests here you'll see
496:46 - it'll go really quickly
496:48 - and you see how much faster it is for us
496:50 - to run our test on a local chain as
496:53 - opposed to doing everything on a test
496:54 - map so it's going to make your life way
496:56 - easier and we have everything passed
496:57 - here so we know that our contract code
497:01 - is doing approximately what we wanted to
497:02 - do
497:04 - so
497:05 - it's time for the moment of truth let's
497:07 - deploy this to an actual test net so we
497:10 - have our deploy lottery script which
497:12 - oftentimes
497:13 - i'll have it be just this deploy lottery
497:15 - bit and then i'll have some other
497:17 - scripts for these other pieces or maybe
497:18 - i'll do it in the brownie console
497:20 - but
497:21 - just to demonstrate everything end to
497:23 - end we'll have deploy lottery start
497:25 - lottery enter lottery and end lottery
497:27 - all in this one script
497:29 - so that we can see everything end to end
497:31 - and see what it looks like on etherscan
497:33 - so let's go ahead
497:35 - and run this script on a ringbeat
497:37 - network and then we'll go jump onto
497:38 - etherscan and see everything
497:41 - so let's do it brownie run scripts
497:44 - deploy lottery
497:46 - network ring can be
497:51 - so first we went ahead and we deployed
497:53 - our lottery we got our addresses with
497:55 - our get contract method
497:57 - we got our fee we got our key hash
497:59 - we got our published source and
498:00 - everything here then we went ahead and
498:02 - verified it because of this published
498:04 - source
498:05 - so if we grab this address lottery
498:07 - deployed here
498:09 - we jump over to
498:11 - rank the ether scan
498:13 - paste this address in here
498:15 - we'll see
498:16 - this contract with a little check mark
498:18 - is verified
498:19 - again we'll go to the read contract we
498:21 - can see all the public variables and all
498:23 - the public functions we can go to write
498:24 - contract and we'll see all the
498:26 - transacting functions that we can
498:27 - interact with after we get verified
498:30 - and things get deployed we went ahead
498:32 - and called our start lottery function to
498:34 - actually start the lottery we got our
498:36 - little print line saying the lottery
498:38 - started then we entered you entered the
498:40 - lottery we then funded the contract with
498:43 - link so we could get our random winner
498:44 - back
498:45 - and then right now our end lottery is
498:48 - confirmed and we're just waiting this 60
498:51 - seconds right because we did this
498:52 - time.sleep and if we sit on this
498:54 - contract if we go to transactions
498:56 - and we refresh we can actually see some
498:59 - of these different method calls over
499:00 - here we can see we did a contract
499:02 - creation
499:03 - we started the lottery we entered the
499:05 - lottery and then we recently ended the
499:07 - lottery and you'll see
499:09 - in our script here it says
499:11 - zero x blah blah is the new winner which
499:15 - is perfect right that means that the
499:16 - chain link node actually responded we
499:18 - can actually verify that by looking in
499:22 - the contract
499:23 - we'll go to read contract
499:25 - we can go to the recent winner and see
499:27 - somebody did indeed recently win we can
499:30 - also go to events
499:31 - and we can see some of the events that
499:33 - we created
499:34 - we can see this first event right here
499:37 - is this requested randomness event this
499:39 - is the event that we called we have this
499:41 - end lottery here we can also see an
499:43 - ownership transferred function that got
499:45 - called this was called when we actually
499:46 - deployed this in the first place
499:48 - now a little bit more on these events
499:50 - aka these logs right
499:52 - so topic zero this hash represents this
499:56 - entire event right here
499:58 - and this
499:59 - bit is going to be our topic one our
500:01 - first topic which represents that
500:03 - request id
500:04 - so this is going to be the request id
500:07 - awesome we have successfully created a
500:09 - working smart contract lottery with true
500:11 - provable randomness this is absolutely
500:14 - insane incredible job here now one
500:16 - additional piece that i want to talk
500:18 - about before we jump off here
500:20 - is again in our testing
500:22 - a file that you're often going to see
500:24 - is what's called conf test dot pi python
500:28 - automatically knows to look for this
500:29 - comp test file and we'll grab different
500:31 - functions from it we can also add
500:33 - external plugins
500:34 - fixtures hooks testing root path it adds
500:37 - a lot of really fantastic features and
500:39 - is a common thing that you'll see we
500:41 - skipped over in here for simplicity but
500:43 - in future projects you'll probably see
500:44 - this comp test file which has a lot of
500:46 - really nice testing configuration pieces
500:49 - in it
500:54 - now that was a lot of stuff to code and
500:57 - quite frankly i don't think any of us
500:59 - want to have to do that every single
501:00 - time have to code everything from
501:02 - scratch now you can absolutely get clone
501:04 - all these repositories right from their
501:06 - github but there's actually an even
501:08 - easier way first to start with a blank
501:11 - project here and this is with brownie
501:13 - mixes so if we google brownie mixes
501:16 - github we'll get this mixes organization
501:19 - which just has a ton of boilerplate code
501:22 - for us to go ahead and get started and
501:25 - start developing the one we're going to
501:27 - be working with is this chain link mix
501:29 - piece which is forked from this official
501:31 - one here this gives us some wonderful
501:33 - contracts some tests a browning config
501:36 - and really everything that we need to do
501:38 - to get started so if you have brownie
501:40 - installed
501:41 - we can just bake this mix so we'll do
501:43 - brownie
501:44 - bake
501:45 - chain lick mix and in our new empty
501:47 - directory here
501:48 - we'll get this new chain link folder
501:51 - with everything inside of it so then we
501:53 - can see the chain link
501:55 - and we can see it has all these pieces
501:57 - in here here already
501:59 - in the contracts we have a whole bunch
502:01 - of different samples of working with the
502:03 - vrf working with the price feed
502:06 - working with this thing called keepers
502:08 - to automate our smart contracts and
502:10 - making api calls and delivering any api
502:12 - call that we want to the blockchain it
502:14 - also has a brownie config which already
502:16 - has a number of wonderful pieces in each
502:20 - one of these networks so that we don't
502:21 - have to go copy paste and add it in here
502:23 - it's even got support for test nets like
502:25 - avalanche polygon
502:27 - finance and more it has a number of
502:30 - really powerful tests including testing
502:32 - some price feeds it has a whole bunch of
502:34 - deployment scripts some mocking scripts
502:37 - some helpful scripts and really
502:38 - everything that we need to get started
502:39 - and get going for starters we can run
502:41 - brownie test
502:45 - and it's going to compile everything
502:47 - and then on a development chain run all
502:49 - these
502:50 - unit tests and if we wanted to test this
502:52 - on a real test net we could do brownie
502:54 - test dash dash
502:55 - network ring b or any network that we
502:57 - wanted if you're looking for a good
502:59 - starter place that has a lot of really
503:01 - powerful smart contracts for you to get
503:03 - started i highly recommend using this
503:05 - mix as a boilerplate starting point for
503:08 - any of your contracts or any of your
503:10 - projects here
503:16 - now we are cooking so we've learned a
503:18 - ton of the fundamentals of working with
503:20 - brownie and working with smart contracts
503:23 - now that we have kind of all the
503:24 - building blocks though we can actually
503:26 - code a lot of these much faster and much
503:28 - more efficiently than before one of the
503:30 - things that we've seen over and over and
503:32 - over again is working with tokens and
503:35 - the erc20 token standard
503:38 - we're going to learn how to build our
503:40 - own token before we do that let's
503:42 - understand why we'd even want to do this
503:44 - now first let's define even what are
503:46 - erc20s so erc20s are tokens that are
503:49 - deployed on a chain using what's called
503:51 - the erc20 token standard you can read
503:54 - more about it in the erc20 token
503:55 - standard here link in the description as
503:57 - well but basically it's a smart contract
503:59 - that actually represents a token so it's
504:01 - token with a smart contract it's both
504:03 - it's really cool tether chain link uni
504:05 - token and die are all examples of erc20s
504:09 - technically chain link is in the rc677
504:12 - as there are upgrades to the erc20 that
504:14 - some tokens take that are still
504:16 - backwards compatible with erc20s and so
504:19 - basically you can think of them as
504:20 - erc20s with a little additional
504:22 - functionality now why would i even care
504:24 - to want to make an erc20 well you can do
504:25 - a lot of really cool stuff with it you
504:27 - make governance token you can secure an
504:29 - underlying network you can create some
504:31 - type of synthetic asset or really
504:33 - anything else in any case how do we
504:35 - build one of these erc20s how do we
504:37 - build one of these tokens well all we
504:39 - have to do is build a smart contract
504:41 - that follows the token standard all we
504:43 - have to do is build a smart contract
504:45 - that has these functions it has a name
504:47 - function a symbol function decimals
504:49 - function etc all these functions we need
504:51 - to be able to transfer it we need to be
504:53 - able to get the balance of it etc and
504:55 - again if you want to check out some of
504:56 - the improvements that are still erc20
504:58 - compatible like the erc677 or the erc777
505:03 - you definitely go check those out and
505:04 - build one of those instead so let's
505:06 - create a new folder and get started
505:08 - we're going to create our new browning
505:09 - file of course with brownie init it's
505:11 - going to start up our repository and
505:14 - start up everything that we are going to
505:15 - work with here we can kind of actually
505:17 - just jump in and start right with our
505:19 - contracts so let's create a new file and
505:21 - we'll call it our token
505:24 - dot sol
505:26 - and this is where we're going to add all
505:28 - of our token code
505:30 - now since this is an eip right this all
505:33 - this is is a smart contract so what we
505:35 - could do is we could grab all these
505:37 - functions
505:38 - copy and paste them in here one at a
505:40 - time
505:41 - grab the name
505:43 - grab the symbol
505:44 - grab the decimals and then you know code
505:47 - all these up be like this does some
505:49 - stuff blah blah blah or
505:52 - we could do it the much easier way right
505:54 - since we're engineers we don't always
505:55 - want to reinvent the wheel so once again
505:59 - our friends at open zeppelin
506:02 - have some amazing contract packages for
506:04 - actually building our own erc20 token so
506:07 - we can go right to the opens up and
506:08 - documentation i'm working on the 4x
506:10 - version but again it doesn't matter the
506:12 - version that you use so long as in our
506:15 - config file we add the version that
506:17 - we're going to use which again we've
506:19 - already gone over so let's go over to
506:20 - their erc20 documentation and this is
506:23 - the entirety of the code that is needed
506:26 - to make an error c20 so we can just go
506:28 - ahead and even copy this
506:30 - paste it in here and boom
506:32 - we have some erc20 code in here let's
506:34 - actually just change the name of
506:36 - everything in here though so we're going
506:37 - to call this our token
506:41 - dot sol
506:42 - we have
506:43 - this spdx license identifier mit great
506:47 - we're going to be using solidity version
506:48 - 0.8 which i know i've done a lot of this
506:51 - code actually in point in 0.6 but i
506:54 - highly recommend working with 0.8
506:56 - because it has a lot of really fantastic
506:59 - improvements to solidity you'll notice
507:01 - this is our first dive into using a
507:03 - different version of solidity here
507:05 - you'll notice that most of the syntax is
507:07 - exactly the same there are like i said a
507:09 - couple of nice improvements with 0.8 the
507:11 - main one being you no longer have to use
507:13 - those safe math functions that we talked
507:14 - about before but then we're going to go
507:16 - ahead and import opens up when contracts
507:18 - token erc20.sol now of course since
507:21 - we're importing open zappone we're
507:22 - importing this package we've got to add
507:24 - this to our browning config
507:28 - diamo
507:30 - and before we even get started you
507:32 - technically have all the tools that you
507:34 - need to code and deploy your own erc20
507:36 - token now i'm actually going to
507:38 - challenge you to go ahead and try to
507:41 - start a browning project create your own
507:43 - token using opensupplement packages and
507:45 - then deploy it on a test net i'm going
507:47 - to show you how to do all of it here
507:48 - anyways but challenging yourself and
507:51 - trying to do things your own and
507:52 - exploring is really one of the fastest
507:54 - ways to learn and grow in this space
508:00 - did you give it a shot no really pause
508:02 - it now and give it a try
508:04 - all right welcome back now we'll go
508:06 - through it and we'll do it together
508:08 - of course we need to add these
508:09 - dependencies
508:13 - open zeppelin
508:15 - open
508:17 - zeppelin contracts
508:19 - let's do their version four
508:23 - so let's even go to github
508:26 - open zeppelin
508:31 - and we'll do
508:32 - 4.2.0 which was released yesterday at
508:34 - this time which is great 4.2.0
508:38 - and of course again compiler
508:41 - we'll have silk
508:47 - remappings
508:54 - we'll add
508:55 - at open zeppelin
508:58 - equals
509:00 - this
509:03 - and then we're going to go ahead and
509:04 - save
509:05 - now we can use this at opens up line and
509:07 - it will refer to the opens up and
509:09 - contracts here so great now we can go
509:11 - ahead and import these
509:12 - let's change the contract name to our
509:14 - token we're going to inherit this
509:17 - erc20.sol from open zeppelin we can even
509:20 - go ahead to opens up on contracts github
509:22 - and we can even see what this erc20
509:24 - looks like so we can go to
509:26 - their contracts down to token
509:29 - erc20
509:31 - erc20.sol
509:33 - and this is their initiation of an erc20
509:36 - which has all these functions like name
509:39 - symbol
509:41 - decimals total supply etc in our
509:43 - constructor we're going to add an
509:45 - initial supply which is going to be in
509:47 - way of course so the initial supply of
509:49 - that token and we're going to use the
509:50 - constructor of the erc20.sol which again
509:54 - we can go ahead and check in the code
509:56 - here and we can see the constructor uses
509:58 - a name
509:59 - and a symbol
510:00 - so we have a name we'll call it r token
510:04 - and the symbol will do ot and boom that
510:07 - is literally all we need for our token
510:09 - here i told you this is going to be a
510:10 - much faster project now for scripts all
510:13 - we have to do is create a new file
510:15 - we'll add a 1
510:17 - deploy token dot sol and we'll also add
510:21 - a helpful
510:23 - scripts apply
510:25 - excuse me this deploy token dot pi
510:27 - excuse me
510:29 - we'll just quickly add a account
510:31 - function we'll say def get account and
510:34 - you can go ahead and just copy paste
510:35 - from the last one and if you want you
510:37 - can actually just copy paste from our
510:38 - last helpful scripts because it's pretty
510:39 - much going to be exactly the same so we
510:41 - have all these wonderful
510:43 - ifs statements so that we can deploy
510:46 - from really anything that we want now in
510:48 - our deployment token script we'll do
510:50 - from
510:51 - brownie
510:53 - import
510:55 - our token
510:59 - and then from
511:00 - scripts that's
511:03 - helpful scripts
511:05 - import
511:06 - get account and just to make sure let's
511:08 - add an init
511:11 - dot pi in here
511:13 - just to make sure that our scripts can
511:14 - actually import so since we know
511:17 - since we know that we need an initial
511:19 - supply here let's go ahead and do
511:21 - initial
511:22 - supply
511:24 - equals and then we can do you know
511:26 - whatever we want here
511:27 - if we want to make it a little bit more
511:28 - readable we'll also
511:30 - do
511:32 - from web3
511:33 - import web3
511:35 - and we can do
511:36 - web3.2
511:38 - way and we'll say
511:41 - 1000 as the initial supply and this is
511:44 - in ether
511:45 - so our initial supply is going to be
511:46 - 1000 ether
511:49 - then we just add our main function
511:52 - we do account
511:54 - equals get account
511:55 - we do our token
511:57 - equals
512:00 - our token
512:01 - dot deploy
512:03 - we just add as a parameter
512:05 - this is initial supply
512:08 - do from
512:10 - account and then we'll do print
512:14 - our token dot
512:16 - name
512:17 - and that's the whole function now of
512:19 - course if you don't have your
512:20 - environment variable set we're going to
512:22 - add our dot enb file
512:23 - this is where we can add our private key
512:26 - our web3
512:28 - infiera
512:30 - project id and then if we want our ether
512:32 - scan token i'm going to skip doing this
512:34 - for now because my environment variables
512:36 - are already set
512:37 - and then last but not least we'll add
512:39 - dot env
512:40 - dot env
512:42 - so private key equals ox blah blah blah
512:45 - when three inferior priority equals blah
512:47 - blah blah ether scan token equals blah
512:49 - blah blah
512:51 - and perfect now if we want to actually
512:53 - deploy this to a testnet all we have to
512:55 - do
512:56 - go into our config
512:58 - we'll add wallets
513:01 - from key
513:03 - we'll add our environment variable
513:04 - private key
513:07 - now brownie knows where to grab this
513:09 - from because we've defined it in our
513:10 - helpful scripts what i can do now
513:13 - so brownie runs scripts deploy token.pi
513:18 - and we can go ahead and see that our
513:19 - token is printed out
513:21 - we can see that we have this token
513:22 - deployed on our local ganache
513:24 - we can see our token here and this is
513:26 - great now i can go ahead and run
513:28 - this again
513:31 - network ring b
513:35 - now if i grab this address go to the
513:37 - ringby ether scan
513:39 - pop it in after a quick refresh i can
513:41 - now see that
513:42 - my contract has indeed been added and
513:45 - etherscan even picks up that it's a
513:47 - token
513:48 - now we could do we can grab this and
513:50 - grab this contract address
513:52 - go to assets
513:55 - add it in our metamask here
513:58 - next
513:59 - add tokens and you'll see we are the
514:01 - proud owners of 1000 hour tokens now
514:05 - something else that you might want to do
514:06 - is add this to a liquidity pool or add
514:08 - this to a place where you can actually
514:10 - go ahead and sell it and put it on the
514:11 - market you can do something like that as
514:13 - easily as just popping onto uniswap
514:16 - going to pool hitting more
514:19 - create a pool
514:20 - and then adding our token in here we'd
514:22 - have to manage the token list and be
514:24 - sure to add the token in here but we
514:26 - could go ahead and add a token
514:28 - create our own pool and automatically
514:30 - put it on your swap and that's how easy
514:32 - it is to actually sell it on one of
514:33 - these pools but alright so this was
514:35 - probably our easiest project of the
514:37 - course but it really shows how far
514:38 - you've come along everything here
514:45 - i thought we know a little bit more
514:46 - about d5 and why it's such an amazing
514:49 - amazing technology that only works in
514:51 - the blockchain world let's look at this
514:53 - site d5 pulse or if you want to look at
514:56 - another one uh there's another fantastic
514:58 - one out there called defined llama which
515:00 - also shows a lot of these different
515:02 - protocols in here so defy pulse is an
515:04 - application that shows some of the top
515:06 - d5 projects based on how much
515:09 - total asset is locked into each protocol
515:12 - ave which currently is the number one
515:14 - ranked d5 application with 9.32
515:18 - billion in assets under management in
515:20 - terms of usd then we have some fantastic
515:22 - ones like curve compound maker instadap
515:25 - etc now we're going to be looking at two
515:27 - of these protocols in particular the
515:29 - first one of course
515:31 - being ave and the second one is going to
515:33 - be a type of what's called a
515:34 - decentralized exchange you start with
515:36 - ave we're going to go to testnet.ave.com
515:41 - dashboard and it'll bring us to a screen
515:42 - that looks something like this with
515:44 - please connect your wallet and
515:45 - everything will be pretty empty parasop
515:47 - is what's known as a dex or a
515:49 - decentralized exchange it allows us to
515:51 - trade tokens incredibly easy on the
515:53 - blockchain now there's not a whole lot
515:55 - of test net indexes that actually work
515:58 - so we're just going to look at them and
515:59 - simulate as if we were working on them
516:02 - for example if i wanted to trade one eth
516:05 - for some usdt or maybe some wrapped
516:08 - bitcoin or some dye or some ave
516:11 - or link or really any token that we
516:13 - wanted
516:14 - all we would need to do is connect our
516:16 - wallet here
516:17 - and
516:18 - a swap button would show up and we would
516:20 - go ahead and hit swap some other really
516:22 - powerful these dexes and really popular
516:24 - ones are going to be curve finance
516:26 - uniswap and it's a really really easy
516:28 - way to go ahead and swap your tokens for
516:30 - one another depending on what you're
516:31 - looking to do ave is incredibly powerful
516:35 - and it's going to be one that we're
516:36 - going to be working a lot with because
516:37 - it has pretty much all the fundamentals
516:39 - of working with the d5 protocol that
516:41 - we're looking for and it has a test
516:43 - stand that we can go ahead and test and
516:45 - simulate actually working with some of
516:47 - these protocols so we're going to first
516:49 - work with the ui or the user interface
516:51 - and then we're going to do everything
516:53 - here programmatically first things first
516:55 - if you don't already have it make sure
516:56 - you have some test net ethereum at least
516:59 - and again you can get some test and
517:00 - ethereum from looking at the link token
517:02 - contracts
517:03 - and going to coven
517:05 - this one indeed uh the test net of ave
517:08 - right now is only on coven so we're
517:10 - going to go ahead here
517:12 - we're going to add our copy our address
517:14 - paste it in
517:16 - i'm not a robot
517:19 - 70.1 test eth remember we use this
517:21 - linked token contracts page because this
517:23 - is going to have the most up-to-date
517:24 - faucets here once we see some eath in
517:27 - our coventestnet here we can go back to
517:29 - ave
517:30 - so whereas paraswap allows you to simply
517:32 - swap between assets and do a lot of
517:34 - buying and selling of tokens
517:36 - ave is a lending and borrowing
517:38 - application so we can actually put down
517:40 - a token as collateral and we can borrow
517:42 - and we can generate some yield from
517:44 - interacting with this protocol borrowing
517:46 - and lending is a critical piece to doing
517:48 - any type of really interesting financial
517:50 - applications or financial instruments
517:52 - such as short selling being exposed to
517:54 - more assets etc
517:56 - you can also gain some percentage back
517:59 - if you look at apy
518:00 - it'll tell you how much percentage over
518:02 - a year you'll actually get in returns
518:05 - from staking or depositing an asset
518:08 - so here's what we're going to go ahead
518:09 - and do we're going to connect to the
518:10 - application
518:11 - using metamask and you'll see on the
518:13 - deposit tab here we'll see our balance
518:16 - be 0.1 each because that's how much i
518:18 - currently have in my wallet right now
518:21 - what we can now do
518:22 - is click on ethereum click this max
518:24 - button to deposit some ethereum
518:26 - we'll hit continue
518:28 - and a little dashboard will pop up
518:30 - asking us okay would you like to deposit
518:32 - clicking this deposit button will
518:34 - actually have us deposit right onto the
518:37 - ave contract on the coventest net make
518:39 - sure once you hit deposit here that
518:41 - you're actually on a test net here it
518:42 - looks like i actually have some
518:43 - insufficient funds so i'm actually going
518:45 - to go
518:46 - borrow a little bit more
518:48 - or from the faucet here
518:50 - grab a little bit more from the faucet
518:51 - here
518:52 - we're going to come back
518:54 - we're actually going to go back
518:57 - refresh and now it says i have
519:00 - 0.1
519:02 - we're going to deposit 0.1
519:05 - continue
519:06 - deposit and metamask is going to pop up
519:09 - saying hey are you sure you want to do
519:10 - this right we can check our data
519:13 - we can grab this address even if we want
519:16 - pop it on to
519:18 - coven.etherscan
519:23 - paste it in here
519:25 - we can even double check to make sure
519:27 - that this is indeed the right contract
519:29 - that we want funnily enough you'll see
519:31 - that this is the west gateway when we
519:33 - deposit our covent eath it actually gets
519:35 - transferred into an erc20 version of our
519:38 - ethereum and then it'll go ahead and
519:41 - deposit it into the ave contract so
519:43 - we're going to hit confirm
519:45 - now we're going to get this pending here
519:48 - we have a link to the explorer
519:50 - which shows us this transaction that's
519:51 - going through and then we'll see that
519:53 - we've indeed successfully deposited our
519:56 - ethereum now down here you'll see a
519:58 - little button add a eth to your browser
520:00 - wallet and we're going to go ahead and
520:01 - click this
520:02 - and this will automatically add this
520:04 - token
520:05 - to our wallet so we're going to hit add
520:07 - token
520:08 - and we see now in assets we have this ae
520:11 - down here
520:13 - we could also have manually hit added
520:15 - token got the contract address but avi
520:17 - was nice enough to just go ahead and add
520:19 - us a little button that does it for us
520:21 - ae is what's called an interest-bearing
520:24 - token and it goes up in real time you'll
520:26 - see if i sit here long enough you'll see
520:29 - this number actually continually going
520:30 - up this is the profit given to us from
520:33 - other people borrowing the eath that
520:35 - we've deposited into ave if we go to our
520:37 - dashboard now
520:39 - we can see we have 0.1 each deposited
520:42 - and if we roll over it you'll constantly
520:44 - see the amount go up and up and up we
520:47 - can go ahead and withdraw our eath
520:51 - which will convert our a
520:54 - back into eath with the additional
520:56 - interest that we got from depositing so
520:58 - depositing into ave will give us
521:00 - interest back as a payment for other
521:02 - people borrowing the eath that we've
521:04 - deposited we can also use this eath as
521:07 - what's called collateral so if i go to
521:09 - this borrow tab
521:10 - i can actually use the eath to borrow
521:13 - some other acid maybe i want to borrow
521:15 - dye which is a stable coin meant to
521:17 - always equal one dollar usdc and usdt
521:20 - also are meant to always reflect a
521:22 - dollar we can borrow what's called
521:24 - wrapped bitcoin which represents the
521:26 - bitcoin price we could borrow some
521:28 - ave token some bat token some link token
521:32 - we can borrow all these different tokens
521:34 - now borrowing an asset is incredibly
521:36 - incredibly powerful by borrowing you're
521:38 - allowed to obtain liquidity without
521:40 - selling your assets and borrowing is one
521:42 - of the first pieces in order to actually
521:44 - short sell borrowing in default
521:46 - protocols is absolutely massive because
521:48 - it allows you to frictionlessly short
521:50 - sell obtain liquidity without closing
521:52 - your position
521:53 - gain yield on some deposited collateral
521:55 - you can do a massive number of new
521:58 - things only in the default world such as
522:00 - flash loans
522:02 - now an important note on borrowing
522:04 - assets on mainnet since we're just
522:07 - borrowing it on test net and this isn't
522:08 - real money this is 100 okay to
522:10 - experiment with and work with however if
522:13 - you borrow an asset and you do not pay
522:15 - attention to how much you have for an
522:17 - underlying collateral you could get
522:19 - liquidated and lose some of your funds
522:21 - so be very careful and pay a lot of
522:23 - attention if you're going to do this on
522:25 - an actual network now let's say we want
522:27 - to borrow the ave token for example we
522:30 - click here and we can choose the amount
522:32 - that we want to borrow now here's the
522:33 - thing
522:34 - since we've placed down some collateral
522:37 - right 0.1 if the amount that we borrow
522:40 - ends up being too high
522:42 - we'll actually get what's called
522:43 - liquidated every time we borrow an asset
522:46 - we get some type of health factor the
522:48 - health factor represents how close to
522:50 - being liquidated you are once your
522:52 - health factor reaches one
522:54 - the collateral that you've actually
522:55 - deposited will get liquidated and
522:58 - somebody else will get paid to take some
522:59 - of your collateral this is so that the
523:01 - the ave application is always solvent
523:04 - being solvent means it's never in debt
523:06 - so when i want to borrow i want to
523:08 - choose some amount that might be a
523:10 - little bit safe here and so that i'm not
523:12 - going to get liquidated so
523:15 - zoom in a little bit
523:17 - i'm going to choose some number where i
523:19 - see a health factor maybe like 5.6 we're
523:22 - going to continue now we'll have to
523:23 - choose our interest rate when we borrow
523:26 - an asset we actually have to pay some
523:28 - interest this payment is actually going
523:30 - to go to the people who are depositing
523:32 - die or depositing the asset the interest
523:35 - rate that we're going to pay is actually
523:36 - going to be paid to those who are
523:38 - depositing the asset that we're
523:40 - borrowing so like how we're getting
523:42 - interest on our deposited collateral
523:44 - others are getting interest on their
523:45 - deposited collateral based off of how
523:47 - often people are borrowing it we choose
523:50 - a stable apy which will always be four
523:52 - percent
523:53 - or a variable apy which will change
523:56 - based off of how volatile and how in
523:58 - demand this asset is for now i'm going
524:00 - to choose variable but you can pick
524:02 - whatever you want especially for this
524:03 - demo we're going to hit continue i'm
524:06 - gonna zoom out just a little bit
524:08 - and the same interface is gonna show up
524:11 - we're gonna go ahead and hit borrow
524:14 - metamask is gonna pop up and ask us if
524:16 - we really want to borrow we're gonna go
524:18 - ahead and hit confirm
524:20 - and now we've successfully borrowed die
524:23 - into our application we can even hit
524:25 - this little add die to your browser
524:27 - wallet
524:28 - to add the token to our wallet
524:31 - now if we hit the button we go to assets
524:33 - we can now see die is indeed in our
524:37 - token assets here now if we go back to
524:39 - our dashboard you'll see we have a
524:40 - health factor score here this is a
524:43 - really important score if you click on
524:45 - this little i thing it says the health
524:47 - factor represents the safety of your
524:48 - loan derived from the proportion of
524:50 - collateral versus amount borrowed keep
524:53 - it above one to avoid liquidation
524:56 - and we'll see all of our deposits here
524:58 - so we still have 0.1 in each deposited
525:00 - we also have 28 die deposited you can
525:04 - see a whole lot of different stats here
525:05 - for working with our application we can
525:08 - withdraw our die we can withdraw our eth
525:11 - we can borrow more die or we can go
525:13 - ahead and repay we can either repay from
525:15 - our wallet balance or from our current
525:17 - collateral yes we could repay with our
525:20 - collateral
525:21 - let's go ahead and do from our wallet
525:22 - balance
525:24 - we'll hit max
525:25 - continue
525:26 - and we even get this little thing that
525:27 - says you don't have enough funds to
525:29 - repay the full amount well why is this
525:31 - the case we just borrowed this amount
525:33 - it's because already since depositing
525:35 - we've accrued a little bit of we've
525:38 - accrued a little bit of extra debt
525:40 - remember we hit that variable apy
525:42 - and every second it's going to tick up
525:44 - just a little bit so let's go ahead and
525:46 - pay back what we can with our wallet
525:48 - we're going to confirm
525:49 - we're going to approve our data to be
525:51 - spent
525:52 - and then we're going to go ahead and hit
525:53 - the repay button and gray now if we go
525:56 - back to our dashboard you can see we've
525:58 - repaid almost everything here but we
526:00 - have a little bit left so let's just go
526:02 - ahead and hit repay with our current
526:04 - collateral we'll hit max
526:06 - continue
526:07 - and this will use our eth to pay back
526:10 - the collateral instead of the die
526:12 - and then we'll hit repay this way we'll
526:14 - have no more debt
526:16 - great now if we go back to our dashboard
526:18 - we can see we have no more debt which is
526:19 - fantastic ave is one of these
526:21 - applications that relies on the
526:23 - chainlink price feeds in order to
526:24 - understand the ratio between how much
526:27 - you have deposited as collateral and
526:29 - then how much you can borrow and take
526:30 - out if we look in our wallet now we can
526:32 - see we still have some aethe
526:35 - we also have some eath and now we have
526:37 - zero die because everything's paid back
526:39 - but we're still gaining interest on the
526:41 - eth we have deposited
526:43 - let's go ahead just reconnect
526:45 - let's go ahead back to testnet.aver.com
526:49 - and let's just withdraw all of our eth
526:56 - now keep in mind when working with some
526:57 - of this this is a test net right and
527:00 - working the way we're working right now
527:02 - is just on a test head so sometimes the
527:04 - test net doesn't work quite as well as a
527:06 - main net because it's just for testing
527:08 - and doesn't have the exact same support
527:09 - we were just working on the test net
527:11 - but if you want to go to ave for real
527:15 - you can go to
527:17 - app.avefork.com connect your wallet on
527:19 - the ethereum mainnet
527:21 - connect your wallet
527:23 - move to the ethereum maintenance and
527:25 - interact with it exactly the way we just
527:27 - saw now if we're on the maintenance here
527:28 - we can see some additional pieces when
527:30 - you deposit something like die
527:33 - yes you get 2.3
527:34 - back as interest paid to you for
527:36 - depositing the die
527:38 - you also get a little bit of what's
527:39 - called a governance token you also get a
527:42 - little bit of ave token i know it's
527:43 - really small here but
527:45 - this is an additional incentive that ave
527:47 - has given the users for working with
527:48 - their protocol since ave is a
527:50 - decentralized protocol in order for
527:52 - anything to be improved or anything to
527:54 - be updated on the protocol it actually
527:56 - has to go through a decentralized vote
527:59 - so these governance tokens actually
528:00 - dictate and decide how the protocol
528:03 - improves moving forward now that we
528:05 - understand how to work with all of that
528:06 - through the ui
528:07 - let's actually learn how to interact
528:09 - with ave and interact with defy all from
528:12 - our scripts learning how to do it this
528:14 - way will get us one step closer to being
528:16 - a quantitative defy engineer or d5
528:19 - researcher this is someone who
528:20 - programmatically does algorithmic trades
528:22 - algorithmic modeling and just does
528:24 - everything in a programmatic sense
528:26 - making them much more efficient and
528:28 - powerful interacting with d5 now all the
528:30 - code that we're going to be working with
528:31 - here is in this avi brownie pie
528:33 - application and you can always refer
528:35 - back to it in the link in the
528:36 - description or in the link in the github
528:38 - repository and see all the code written
528:40 - yourself so with that create a new
528:43 - folder and open up your vs code to that
528:44 - folder and let's get into it and ave has
528:46 - some fantastic documentation that we're
528:48 - going to use as well link here is also
528:50 - in the description let's go ahead and
528:52 - start
528:54 - with our our basic brownie setup just
528:57 - with brownie init and we got a new
528:59 - brownie project we got all of our
529:00 - folders in here and we are good to go
529:03 - now for working with browning we're
529:04 - actually not going to really be
529:06 - deploying any contracts because all the
529:08 - contracts that we're going to work with
529:09 - are already deployed on chain all of
529:11 - them are just going to be working right
529:13 - with ave here create a quick readme.md
529:16 - so we can know what we're doing here
529:18 - number one we're going to try to deposit
529:21 - some eath into ave
529:24 - then we're going to borrow
529:27 - some acid
529:29 - with the eth collateral
529:32 - and then if you wanted to i challenge
529:34 - you to actually sell
529:36 - that borrowed acid
529:39 - this is what's known as
529:41 - short selling but we're not going to do
529:43 - that here and then we're just going to
529:44 - repay everything back
529:49 - great and this will be the full
529:50 - functionality of working with ave in
529:52 - this deployed contract everything that
529:54 - we're going to learn here will teach you
529:55 - how to work with other
529:56 - contracts as well such as paraswap or
529:59 - unit swap
530:00 - or any other type of swapping contract
530:02 - that will allow us to buy and sell
530:04 - so let's just go ahead and create a
530:06 - script we'll call it ave
530:08 - borrow that pie let's go ahead and
530:10 - create a function called def main and
530:13 - we'll just do
530:14 - pass for now the first thing that we
530:15 - need to figure out how to do is deposit
530:17 - some f into ave
530:19 - when we actually deposited our f via the
530:21 - ui
530:23 - you can actually see
530:24 - when we call this deposit function if i
530:26 - hit this deposit button here
530:29 - oddly enough
530:31 - if we go to this contract address
530:33 - on the coven ether scan
530:35 - we'll see
530:37 - that this address is actually what's
530:39 - called a west gateway
530:42 - what ave is doing like i was saying
530:43 - before and let's go ahead and actually
530:45 - cancel this for now reject what ave is
530:47 - actually doing here is swapping our
530:50 - ethereum for west
530:52 - again west is an erc20 version
530:55 - of ethereum and this allows it to easily
530:58 - work with all the other erc20s on the
531:00 - obvi protocol like die usd coin
531:03 - you know ample fourth link et cetera
531:06 - so we actually have to do the that as
531:08 - well
531:09 - so the first thing we're going to need
531:10 - to do
531:12 - actually isn't deposit some of our eth
531:14 - the first thing we're going to need to
531:15 - do is going to swap our
531:17 - eth for
531:19 - west so let's even just put this in its
531:21 - own little script we'll call it get
531:24 - weth.pi so we're going to have a
531:26 - function
531:27 - def main
531:30 - i'm just going to do pass for now but
531:31 - we're actually going to want to use this
531:32 - get wet function in our ave borrowed a
531:34 - pi
531:35 - so we're going to actually have a main
531:37 - and we're going to have a def
531:39 - get weth
531:42 - and our main function is just going to
531:43 - call
531:44 - getwef so how do we actually
531:47 - convert our ethereum to wef or wrapped
531:50 - ether we'll even do a little dock string
531:52 - here
531:54 - mint's weth by depositing eth
531:56 - now to save gas we could actually
531:58 - interact with this weft gateway for ave
532:00 - but i'm going to teach you guys how to
532:02 - just get west in general so we can look
532:04 - up the west contract
532:06 - ether scan
532:08 - the west coven contract ether scan
532:11 - and we'll see here
532:13 - we have this wrapped ether page
532:15 - and we can go to the contract and we can
532:16 - see that this is indeed verified
532:19 - the way ath works is there's
532:22 - a withdrawal and deposit
532:24 - we deposit eth into this contract and it
532:27 - transfers us some wealth
532:31 - so this is the first contract that we
532:33 - actually want to interact with so we
532:35 - need our script to be able to call this
532:37 - deposit contract
532:39 - so
532:40 - per usual the two things that we need to
532:42 - do this are going to be an api
532:44 - and an address
532:46 - for this web contract i really like just
532:49 - doing everything directly from the
532:50 - interfaces i've already copy pasted the
532:52 - interface
532:55 - into this here so we're going to go to
532:57 - interface dot sol and we're just going
532:59 - to copy all this right here
533:02 - so in our interfaces
533:04 - we create a new file we're going to call
533:06 - it iweth
533:08 - dot soul
533:09 - we're going to paste it in
533:11 - you can see this has all the exact same
533:13 - functions as our deposit contract
533:16 - symbol name
533:18 - transfer pretty much everything you'd
533:20 - expect from erc20 plus this extra
533:22 - deposit piece
533:25 - we'll call this iweb it's a common
533:27 - naming standard to just have i in the
533:29 - name of what your contract is when
533:31 - you're talking about an interface so we
533:33 - have an interface now
533:35 - and we also have
533:37 - an address
533:38 - but again this is our address on the
533:40 - coven network since we know ahead of
533:42 - time that we're probably going to be
533:43 - using this on different networks like
533:45 - mainnet and coven and etc we're actually
533:47 - going to create a new file we're going
533:49 - to add our brownie config
533:51 - hopefully this is starting to look a
533:52 - little familiar to you now
533:54 - we're going to go ahead and add our
533:55 - networks in here
533:57 - in here we're going to go ahead and add
533:58 - coven and in here we're going to write
534:01 - west
534:02 - token
534:04 - and we're going to add
534:06 - this address of the web token
534:09 - paste it in here
534:10 - while we're in here
534:11 - we're going to add the rest of our
534:12 - pieces we're going to add wallets
534:16 - from key
534:20 - private key
534:21 - and that's all we really need for now
534:23 - speaking of which we probably are still
534:24 - going to want to test this locally
534:27 - now since we've done some work with
534:28 - testing we know that for testing
534:32 - we can do our
534:33 - integration test into
534:37 - integration tests
534:39 - on kovan because there's an integration
534:42 - test there
534:43 - what about our local tests
534:46 - well this is something good that we're
534:47 - thinking about right now we know that
534:49 - ave actually has
534:51 - all these same contracts on the main net
534:54 - as well
534:55 - and we also know that we're not going to
534:56 - be working with any oracles because that
534:58 - we don't actually have to deploy any
535:00 - mocks ourselves we can if we want to but
535:02 - we don't have to what we can do is for
535:04 - our unit tests
535:07 - we can actually just use
535:09 - the mainnet fork network and just fork
535:11 - everything that's on the mainnet into
535:13 - our own local network so instead of
535:15 - actually using mocs we'll basically just
535:17 - mock the entire mainnet and one more
535:19 - time just so that we absolutely have it
535:21 - here if you're not working with oracle's
535:23 - and you don't need to mock responses we
535:25 - can just go ahead and use a mainnet fork
535:27 - to run our unit tests if you are using
535:29 - oracle then it makes a lot more sense to
535:32 - do the development network where you can
535:34 - mock oracles and mock oracle responses
535:36 - with this in mind we know that we're
535:38 - going to be doing a lot of our tests on
535:39 - mainnet fork
535:41 - we can go ahead and add a mainnet fork
535:44 - network here and then we can just add
535:47 - the mainnet web token
535:49 - for mainnet fork so we'll look up web
535:51 - token
535:53 - etherscan
535:55 - web token etherscan
535:57 - and we'll grab this contract address
536:00 - remember absolutely positively if you
536:02 - want to double check that the contract
536:04 - address that you're working with is
536:05 - correct i highly recommend you do so
536:08 - because if you get it wrong you could
536:10 - accidentally add some money to a
536:12 - contract address that you don't want
536:15 - so we're going to have the mainnet fork
536:17 - address b the web token address
536:19 - and in our terminal
536:21 - we can do brownie
536:23 - networks list
536:26 - and see that indeed we have a mainnet
536:28 - fork here that's going to use the
536:29 - ganache cli to fork mainnet for us
536:32 - there's there's a link in the
536:33 - description to refer back to the section
536:34 - where we actually set this up so now
536:36 - that we have the interface we know that
536:38 - we can actually compile it down to the
536:40 - abi so back in our get wet here
536:42 - first thing we need to do to make any
536:44 - transaction obviously is get an account
536:48 - well
536:49 - this is where we can go back and make
536:50 - our helpful scripts
536:54 - so we can go ahead
536:56 - do def
536:58 - get account
537:00 - index equals none
537:02 - id equals none
537:03 - same as before
537:04 - and if you have your get account
537:06 - function from our last demo you can just
537:08 - go ahead and copy paste it in here all
537:09 - right great now we have our get account
537:11 - function so we can do account now equals
537:14 - get account
537:15 - oh but we have to import it in here so
537:18 - we'll do
537:19 - from
537:20 - scripts dot
537:22 - helpful scripts
537:24 - import
537:25 - get account
537:27 - and depending on your python version
537:29 - we'll add in it that pi just so that
537:32 - python recognizes that scripts is indeed
537:33 - a module all right cool so we have our
537:36 - account where we can make some
537:37 - transactions with
537:38 - now let's go ahead and get our wef
537:40 - contract
537:42 - to do this we can import interfaces from
537:44 - routing
537:45 - browning
537:47 - import interface
537:49 - same as we did before
537:51 - and we can do with
537:53 - equals interface
537:55 - dot i with
537:58 - and the address here is going to be from
538:00 - our config
538:01 - config
538:03 - networks
538:05 - dot show active
538:09 - and then
538:11 - web token
538:14 - we also have to import config from
538:16 - browning
538:19 - and network as well
538:23 - now you might be asking why aren't we
538:24 - using the get contract function here
538:27 - well you can absolutely 100 go ahead and
538:29 - use that get contract function but since
538:31 - we're going to be testing on mainnet
538:32 - fork here i know that we're always going
538:34 - to refer back to the config so i'm
538:36 - confident that i'm not going to be
538:37 - deploying any mocks
538:38 - it's better practice to go ahead and use
538:40 - that getcontract function but for this
538:42 - one we'll just make it a little simpler
538:44 - and use the config
538:46 - and now in a fig if we're on the coven
538:48 - network we're going to use this one
538:50 - if we're on mainnet or maintenance fork
538:52 - we're going to use this one
538:54 - for going to mainnet or for to real
538:56 - production you could also have a mainnet
538:58 - network and it'll just be an exact copy
539:00 - of the maintenance fork
539:02 - and remember we're going to want our dot
539:04 - env our env file
539:06 - our environment variables to get pulled
539:08 - from that dot env file so we can just
539:10 - set it like this now everything in our
539:12 - env file will get pulled in
539:14 - automatically
539:15 - great so we have an address and we have
539:17 - an abi which comes from the interface
539:20 - now we can just call we can just call
539:22 - this deposit function where we deposit
539:24 - ethereum and we get wef so now we'll
539:28 - just do transaction equals wealth
539:32 - dot deposit
539:36 - and we'll do from
539:38 - account
539:41 - value
539:43 - is going to be let's just say 0.1 so 0.1
539:47 - times 10
539:48 - raised to the 18.
539:50 - so we'll deposit 0.1
539:52 - and we should get 0.1 wef in return do a
539:56 - printf string
540:00 - received 0.1 weft
540:04 - this doesn't even need to be printf
540:06 - and then we'll just return tx
540:08 - now per usual
540:10 - if your environment variables aren't set
540:12 - such as private key we're going to want
540:14 - to do that so in our emb we do export
540:17 - private key
540:19 - equals 0x at the beginning right here
540:22 - we're going to export web 3
540:24 - infero
540:26 - project id we'll want our ad our web3
540:29 - inferior project id which we've got
540:31 - before
540:32 - if we want to use our etherscan token we
540:35 - absolutely can
540:36 - and since we're putting a whole bunch of
540:38 - stuff into dot and v we want to make
540:39 - sure in our git ignore we have
540:42 - dot and v so we don't actually push this
540:44 - up to github again if you're nervous
540:47 - about having all these ambs in here you
540:49 - can absolutely do the accounts.add or
540:51 - whatever other methodology you like to
540:53 - set your environment variables anyway
540:55 - let's go ahead and run this script now
540:57 - so we can do brownie run scripts
541:00 - get wet pie
541:02 - network
541:03 - coven
541:04 - generating the apis from our interface
541:07 - we have a little transaction hash that
541:09 - we can use
541:11 - pop into the coven etherscan
541:13 - and we can see
541:15 - the transaction going through in our
541:17 - wallets
541:18 - we'll get minus 0.18 and we'll get plus
541:22 - 0.1 weth
541:24 - so we can see it's actually been
541:25 - successful
541:27 - to add this and see this on our metamask
541:29 - we're going to grab the contract address
541:30 - here we're going to go back to metamask
541:33 - add token paste it in here
541:35 - add tokens and you can see we now have
541:37 - 0.1 with if you want to switch back your
541:40 - weft to ethereum you would just hit this
541:43 - withdraw function or
541:45 - we could programmatically add a
541:46 - withdrawal function in here this
541:48 - withdrawal function will run for
541:51 - ethereum withdrawal and take our
541:53 - ethereum out of the contract and burn
541:55 - the weapons replace it with weft so you
541:57 - need to swap your weft back to get your
541:59 - eth out awesome we have some weft and
542:02 - now we have an erc20 token we have an
542:05 - erc20 token that we can use to interact
542:07 - with the ave application now that we've
542:10 - got this get weth function let's go
542:12 - ahead and start borrowing so let's go
542:14 - ahead and start with our account
542:17 - it's going to equal to get account
542:19 - which now we're going to want to import
542:21 - right at the top
542:22 - like so
542:23 - then we're going to get our west address
542:26 - or we can even just do our erc20 address
542:28 - because the web token is in erc20 and
542:30 - maybe we want to deposit some other
542:32 - erc20
542:33 - we'll do config
542:37 - networks
542:39 - network dot show active
542:43 - left token
542:45 - and of course
542:46 - we're going to have to now add from
542:48 - brownie
542:51 - import
542:52 - network
542:53 - and now we want to call this get weth
542:55 - contract
542:57 - just in case we don't already have wef
542:59 - we would just add another from scripts
543:02 - dot get weft
543:04 - import
543:06 - get west but we don't actually need to
543:08 - call it right now because we already
543:10 - have some wrapped ethereum in our
543:12 - covenant address now if we want to test
543:14 - this though on our local mainnet fork we
543:16 - probably will want to call this getweft
543:19 - so i'm just going to add a little if
543:21 - if
543:23 - network.showactive
543:25 - is going to be our
543:27 - mainnet fork
543:33 - we should go ahead and call this get wet
543:35 - function and for brownie we're also
543:37 - going to want to import this config
543:38 - we'll also have to add
543:40 - mainnet fork
543:42 - to our local blockchain environments
543:47 - like so
543:49 - so that when we call git account in our
543:51 - scripts it actually knows that it's a
543:53 - local environment that we're working
543:55 - with and it will just return accounts
543:56 - zero instead of us having to actually
543:58 - load a private key in every single time
544:01 - and we want to actually wait for our
544:03 - transaction to complete here so we'll go
544:05 - ahead and add this weight and then do
544:06 - tx.weight
544:08 - and wait for this transaction to
544:09 - actually finish otherwise brownie will
544:11 - get a little bit mad
544:12 - so now that we have that we can run
544:15 - brownie
544:16 - run scripts
544:18 - ave bar to pie
544:20 - network
544:21 - maintenance fork
544:23 - so you can see that actually in this
544:24 - case testing everything on mainnet fork
544:27 - is going to give us a really really
544:29 - accurate view of what doing this on
544:30 - mainnet actually is going to give us we
544:32 - don't have to do any mocking we can
544:33 - literally just fork all of mainnet and
544:36 - go from there we are still going to test
544:38 - on kovan though in a little bit just so
544:39 - we can see all the transactions that go
544:42 - through how long it takes for stuff to
544:43 - happen
544:44 - so
544:45 - now that we've gotten some wealth here
544:48 - we actually need to go into our second
544:50 - bit we're going to deposit some f or in
544:53 - our case
544:54 - some
544:55 - wealth into ave so how do we actually do
544:58 - that
544:58 - well everything that we need is going to
545:00 - be in this ave
545:03 - documentation here
545:04 - where we deposit and borrow from in ave
545:07 - is in their contract this lending pool
545:09 - you can see here the lending pool
545:11 - contract is the main contract for the
545:12 - protocol it exposes the user-oriented
545:14 - actions that can be invoked in solidity
545:16 - and web-three libraries and these have
545:18 - all of the functions that we need it has
545:19 - deposit where we deposit our asset as a
545:21 - collateral withdraw where we take it
545:23 - back we have borrow we have repay
545:27 - and we can have we have swap borrow
545:29 - rates
545:30 - and a couple other interesting ones
545:31 - which we'll go into later but for now we
545:33 - just really need to focus on repaying
545:36 - borrowing
545:37 - withdrawing and depositing
545:40 - so as you probably guessed deposit is
545:41 - the function that we're going to work on
545:42 - right now
545:43 - and since this is the contract that
545:45 - we're going to work with as always the
545:47 - two things you need when working with a
545:48 - contract are going to be the abi and the
545:50 - address so we're going to get this
545:52 - lending pool contract we're going to say
545:54 - lending pool
545:56 - equals and we're actually going to even
545:58 - make a function called get
546:01 - lending pool
546:04 - so down below we're going to do def
546:06 - get lending pool
546:10 - lending pool not poll
546:12 - and we're going to get the lending pool
546:14 - address and the lending pool contract so
546:16 - we can interact with it down here now
546:17 - something about this lending pool is
546:19 - that the lending pool address can
546:21 - actually change a little bit depending
546:23 - on a lot of different pieces
546:25 - so there's actually this address
546:27 - provider which gives us the address of a
546:29 - specific or particular market if we go
546:32 - back to this ave ui there's actually
546:33 - different markets so there's different
546:35 - types of ways we can interact with ave
546:37 - we're just going to work with the basic
546:39 - ave v2 because it's easily the most used
546:42 - on mainnet as well the address provider
546:44 - registry will give us so this address
546:46 - provider will give us the address of the
546:49 - lending pool for our market if we want
546:51 - to go across different markets we'll
546:53 - have to go to the address provider
546:54 - registry to find it but the addresses in
546:56 - here don't change and the addresses in
546:58 - here don't change it's just the lending
546:59 - pool address itself might change so we
547:01 - just have to go to
547:02 - this address provider here and there's
547:04 - just one function that we need to work
547:06 - with it's this get lending pool which
547:09 - will give us the address of the actual
547:11 - lending pool so don't let this confuse
547:13 - you too much basically all we're trying
547:14 - to do is we're saying hey where is ave
547:16 - located right now and ave has a contract
547:19 - that will always tell us where the main
547:21 - ave contracts are and that's this
547:23 - addresses provider right here so this is
547:26 - another contract that we have to work
547:27 - with and again when we have a contract
547:29 - what do we need we need an api
547:32 - and we need an address so we can
547:35 - absolutely once again we could go ahead
547:37 - and
547:38 - you know copy paste like abi equals
547:40 - whatever the abi is but we're just going
547:42 - to use an interface because because life
547:44 - is great with an interface
547:46 - so a couple of great things about
547:47 - interfaces too if we know we're only
547:50 - going to work with one or two functions
547:52 - we can actually just make the interfaces
547:53 - ourself
547:54 - so an interface we could do a new file
547:57 - we could do i
547:59 - lending pool
548:00 - address provider that's sol
548:03 - and we can just add it in here ourselves
548:06 - so we'll first do sp dx
548:10 - license
548:12 - identifier
548:13 - and we'll do like mit or something
548:16 - we'll do pragma
548:17 - solidity
548:19 - 0.6.6 or whatever we want to do
548:22 - and then we'll do interface
548:25 - i
548:27 - landing pool
548:28 - addresses pro
548:30 - divider
548:31 - excuse me this should be a lending pool
548:34 - address says
548:37 - provider
548:39 - and we know that there's only one
548:40 - function
548:42 - called get
548:43 - lending pool
548:45 - and we're not exactly sure what
548:48 - getlendingpool is defined as but what we
548:50 - can do
548:52 - is we can go to
548:54 - ether scan eat the scan ave
548:57 - lending pool addresses
548:59 - you can see here this is actually the
549:00 - lending pool
549:01 - but what we can look at is the ave
549:03 - protocol we can go right to the github
549:05 - we can go to contracts
549:08 - we can see they have an interfaces
549:10 - section
549:12 - and they have
549:13 - this lending pool addresses provider
549:16 - get lending pool and kind of as we
549:18 - expected it's an external view and it
549:20 - returns an address so we can literally
549:21 - just copy paste this
549:23 - into here
549:24 - and we could run with this and this
549:25 - would work perfectly fine
549:27 - but this leads us to the next point we
549:29 - might as well just grab the whole thing
549:31 - this way we know for a fact we're not
549:32 - getting anything wrong but yes if we
549:35 - wanted to
549:36 - our interface could be this
549:38 - right because this is going to compile
549:40 - it could be this
549:41 - because this interface is going to
549:42 - compile down to an abi and the abi is
549:45 - going to say hey there's a function here
549:47 - and that's all the abi is really doing
549:49 - it's just telling us how we can interact
549:50 - with a contract but let's just go ahead
549:53 - and add everything so that if we want to
549:55 - interact with more things we can so now
549:58 - we have the api we also now need an
550:00 - address which we can definitely find
550:03 - from the ave documentation we can go to
550:05 - their deployed contract section we find
550:08 - lending pool
550:09 - addresses provider which is going to be
550:11 - right here
550:12 - we're going to copy that
550:15 - and where are we going to put this well
550:17 - as you know we're going to put this in
550:18 - our brownie config we're going to do
550:20 - lending
550:21 - pool
550:22 - addresses
550:24 - provider
550:26 - i'm going to paste that right there and
550:28 - since we know we're also going to do
550:29 - coven
550:31 - we can also grab from kovin here
550:33 - so lending pool addresses provider
550:37 - we're going to copy this here
550:40 - and do
550:42 - and we're going to add this addresses
550:44 - provider for coven as well
550:47 - boom now we have it for both coven and
550:50 - for maintenance fork
550:52 - awesome
550:53 - so we can keep going now now that we
550:54 - have an avi and we have an address for
550:56 - both coven and for our mainnet
550:58 - maintenance fork
551:00 - what we can do now
551:01 - is we first get the lending pool
551:06 - addresses provider
551:09 - it's going to be
551:10 - from our interface which again
551:13 - we're going to grab from brownie
551:18 - interface dot i
551:20 - lending pool
551:22 - addresses provider
551:25 - which the address of that is going to be
551:27 - config
551:29 - networks
551:31 - network.showactive
551:37 - lending
551:39 - pool
551:41 - addresses provider
551:43 - and then we're just going to say
551:46 - lending pool
551:47 - address
551:48 - it's going to be equal to
551:50 - blending pool
551:52 - i'm just going to copy and paste instead
551:54 - of typing the whole thing address
551:56 - divider provider dot get
551:59 - lending pool
552:02 - right because again
552:04 - this address provider has this get
552:07 - lending pool which returns this address
552:09 - which is the address of the lending pool
552:11 - then now that we have this address we
552:13 - can actually return the lending pool
552:15 - contract
552:16 - by once again getting the api
552:20 - and the address
552:22 - of the actual landing pool so we have
552:25 - the address
552:26 - check
552:27 - we just now need the api which once
552:30 - again we can work with our wonderful
552:32 - interfaces here do new file
552:34 - i
552:35 - lending pool
552:37 - and there's only going to be a couple of
552:39 - functions we're going to work with here
552:40 - but ave actually gives us the interface
552:42 - right here
552:43 - and
552:44 - ave actually even gives us the interface
552:46 - of the lending pool address provider for
552:48 - us so we can go ahead and copy this pop
552:50 - it over into here now we do need to
552:52 - actually change one thing in here as
552:54 - well this interface imports locally with
552:57 - this dot slash so we actually just need
552:59 - to change these imports to actually
553:01 - import directly from github instead of
553:03 - importing locally
553:05 - luckily this is something we already
553:07 - know how to do so let's go to our
553:08 - brownie config
553:10 - and up at the top we're going to add
553:12 - this dependencies bit in pen
553:14 - then c's
553:17 - so we're just going to work with ave's
553:20 - protocol right from github
553:22 - so
553:24 - we're going to work with ave slash pro
553:26 - tow call
553:29 - v2
553:31 - and let's see what their latest version
553:33 - is
553:34 - looks like they got a couple different
553:35 - versions here
553:36 - 1.0.1
553:38 - so let's go ahead and work with this one
553:40 - at
553:41 - 1.0.1
553:43 - and then with compiler
553:46 - sulk
553:48 - remappings
553:50 - per usual
553:52 - we're going to say at
553:53 - ave
553:55 - is going to be equal to this dependency
553:58 - this way brownie will download this
554:00 - right from github and now we can just
554:01 - use this at ave
554:03 - instead
554:04 - so back in our eye lending pool.sol we
554:07 - can just change this
554:09 - to poll right from github and if we look
554:12 - in github
554:15 - we go to their contracts section
554:17 - we go to their interfaces section
554:20 - by lending pool
554:22 - we know that we can pull this from
554:25 - at ave
554:26 - slash contracts
554:28 - slash interfaces
554:32 - because we see this eye lending pool
554:33 - addresses provider
554:35 - right in here
554:36 - and then this data types bit
554:38 - you can actually look in contracts
554:40 - and this i know because i've i've been
554:42 - through already it's in protocol
554:45 - libraries
554:48 - types
554:50 - and here it is datatype.sol so we can
554:52 - just take this exact path again
554:54 - and do at ave
554:56 - contracts
554:58 - slash protocol
555:00 - slash libraries slash types
555:04 - data type dot sol okay great so now that
555:06 - we've actually imported this interface
555:08 - for us to use we can go ahead and
555:10 - compile just to make sure that
555:11 - everything is working correctly brownie
555:14 - compile
555:18 - and perfect if these interfaces had an
555:20 - issue they actually wouldn't compile
555:22 - through brownie here so we know that
555:23 - they're compiling correctly but great so
555:25 - now that we have an interface we know
555:27 - that these interfaces compile down to
555:29 - the abi
555:30 - and we already have the address here so
555:33 - to actually interact with the lending
555:35 - pool now we can just do
555:37 - lending pool
555:39 - equals
555:40 - interface
555:42 - dot i
555:44 - lending pool
555:46 - and we'll add this lending pool address
555:48 - blending pool and then we can return
555:53 - lending pool so now we have a function
555:56 - that goes through the lending pool
555:57 - addresses provider from the ave
555:59 - documentation and returns this lending
556:01 - pool contract that we can now interact
556:03 - with and we can even test this out by
556:05 - just printing this landing pal address
556:07 - in our script
556:08 - so we'll do brownie
556:10 - run
556:11 - scripts
556:13 - ave borrow network
556:16 - mainnet fork
556:20 - and perfect we we can see the address
556:22 - here is printed out and there are no
556:23 - errors so we know we're doing it right
556:25 - so now that we have the actual address
556:27 - what we're going to do now is we're
556:28 - going to take this wrapped aetherium
556:30 - that we've got this erc20 version of
556:32 - ethereum and we're going to deposit it
556:35 - into this contract just like what we did
556:37 - in the user interface in order to
556:40 - actually first deposit it we need to
556:41 - approve this erc20 token erc20 tokens
556:45 - have an approved function that makes
556:46 - sure that whenever we send a token to
556:49 - somebody or whenever a token calls a
556:51 - function that uses our tokens we
556:54 - actually have given them permission to
556:55 - do so so that's the first thing that
556:57 - we're going to actually have to do
556:59 - is we're going to have to approve
557:00 - [Music]
557:01 - sending our erc20 tokens
557:04 - and this resembles so since i know that
557:06 - we're going to have to approve a lot i'm
557:08 - actually just going to go ahead and make
557:10 - an approve
557:12 - erc20 token function similar as to what
557:16 - we did with the get lending pool
557:18 - so we're going to need to approve this
557:20 - erc 20 so we're going to need to approve
557:22 - this erc20 so let's go ahead and make a
557:24 - function we'll call it def
557:26 - approve
557:27 - erc20 so how do we actually call this a
557:30 - prove function on a token contract
557:32 - well
557:33 - as always we're going to need the abi
557:36 - and the address of the token contract
557:39 - same as always i told you i was going to
557:40 - be saying this a lot now we could create
557:43 - our interface ourself looking at all the
557:45 - functionalities of the erc20 tokens so
557:48 - we could go to eip20 look at the token
557:51 - standard find all the different
557:54 - functions and put them into our
557:55 - interface
557:56 - or we can go ahead and just cheat and
557:58 - just grab it from my github repository
558:01 - here
558:02 - so i already have an ierc20.soul right
558:04 - here
558:05 - and we're just going to copy everything
558:07 - in here and
558:08 - add it in a new file called i yourc20
558:11 - that's sold
558:13 - and paste it in here so you can see
558:14 - there are a number of different
558:16 - functions in here
558:17 - we can check the allowance we can check
558:19 - the balance of different addresses
558:22 - how many decimals a token has the name
558:24 - the symbol we can do some transfers and
558:26 - transfer from and then the function that
558:29 - we're going to be using is this approve
558:30 - function so right here we can already
558:33 - see
558:33 - the parameters this approved function
558:35 - takes
558:36 - we're going to need to have a spender of
558:39 - who to approve can spend our tokens and
558:42 - then how much they can actually spend so
558:44 - if we come back over to approve erc20
558:47 - we know that for input parameters we're
558:49 - probably going to need an amount
558:51 - a spender
558:53 - address
558:54 - the erc20 token address
558:58 - so which token we're actually allowing
558:59 - to spend
559:01 - and then an account right or this is
559:03 - going to be that from
559:07 - account bit so we'll just have this be
559:09 - passed as part of the function
559:11 - parameters so let's go ahead and code
559:12 - this let's first just do a quick print
559:14 - line
559:15 - so that people know what this
559:17 - transaction is doing we'll say approving
559:21 - prc20
559:22 - token
559:24 - and then we'll get the erc20 token by
559:26 - saying e or c equals interface
559:29 - same as always dot i e or c 20
559:33 - and then we'll give it
559:34 - whatever erc20 address that we pass to
559:36 - this function
559:38 - and now we can actually interact with
559:39 - this contract and we can call that
559:41 - approve function
559:43 - so we'll say transaction
559:45 - tx or again tx usually stands for
559:47 - transaction
559:48 - equals erc20
559:50 - dot approve and we're going to approve
559:53 - this spender
559:54 - for
559:56 - an amount
559:57 - and then we'll say from
560:00 - account we'll do tx.wait we'll wait one
560:03 - block confirmation for it to finish
560:05 - and then once it's done
560:07 - we'll do print
560:09 - approved and we'll return the
560:12 - transaction
560:13 - awesome so now we have an approved erc20
560:15 - function that we can use to approve any
560:18 - erc20 token so back up in our main
560:20 - function we can run approve vrc20 for
560:23 - some amount which right now we don't
560:25 - have defined
560:27 - the spender is going to be this lending
560:29 - pool but the address of the lending pool
560:32 - because remember lending pool is the
560:33 - entire contract we just want the address
560:36 - the erc20 address of course is going to
560:38 - be the erc20 address and the account of
560:40 - course is going to be our account
560:43 - the only thing we don't have to find
560:44 - right now is some amount which we can
560:47 - make it really whatever we want to be to
560:48 - keep things standard let's just go ahead
560:50 - and do 0.1 so i'm going to make this a
560:53 - global variable i'm going to say amount
560:56 - equals
560:58 - one
560:59 - one two three four five six seven eight
561:00 - nine ten one two three four five six
561:02 - seven and we can go ahead and do
561:05 - amount
561:06 - we're gonna of course doing all these
561:07 - zeros is from incredibly disgusting so
561:10 - we're just gonna refactor to do from web
561:11 - 33 import web and then instead of always
561:14 - and we'll just do web three three
561:16 - two two
561:17 - 0.1 0.1 which is the amount that we
561:20 - actually want and we'll say either
561:22 - now we can run browning
561:24 - run scripts ave borrowed a pie
561:27 - network main net fork
561:30 - and we can go ahead and see that our
561:32 - approval function is working as intended
561:34 - network that will always be doing this
561:35 - fine
561:36 - any type of
561:38 - we can do so let's go foreign and change
561:40 - our default network to mainnet for
561:42 - mainnet so we don't have any network in
561:44 - our browning let's go back to our ave
561:45 - borrowing section now so we have
561:47 - everything approved
561:48 - now we just need to go ahead and deposit
561:51 - it into ave
561:53 - since we know we're probably going to
561:54 - use this a lot too let's go ahead and
561:56 - create a
561:57 - deposit function since we have
561:58 - everything approved we can now go ahead
562:01 - and use the lending pool deposit method
562:04 - and we can check the documentation here
562:06 - or look on github or etherscan to see
562:08 - what the parameters that it takes are so
562:10 - i'm even just going to go ahead
562:12 - and copy all this
562:14 - bring it over here
562:16 - so what we can do now
562:17 - is we do lending pool
562:21 - dot deposit
562:24 - and then all these parameters let's go
562:26 - ahead and walk through them one by one
562:28 - so first thing is going to be the
562:29 - address of the asset which we know
562:32 - is going to be your erc20 address
562:34 - boom
562:35 - the amount
562:37 - of the token which we can go ahead with
562:39 - our amount variable
562:41 - address on behalf of is just going to be
562:44 - our account.address we're depositing
562:47 - this collateral for ourselves
562:50 - and then referral code so referral code
562:52 - is so the referral code is actually
562:54 - deprecated and workloads don't actually
562:57 - work anymore so we're just always going
562:58 - to pass 0 here and just to make sure we
563:00 - know that this is what we're doing we're
563:02 - going to go ahead and print
563:04 - depositing
563:06 - one two three
563:07 - and then after we're done we're gonna do
563:09 - print
563:11 - the ted
563:12 - and whoops looks like we forgot to add
563:14 - that final dictionary here
563:16 - of from
563:18 - accounts
563:21 - ah one more thing here let's go ahead
563:23 - and do tx for transaction
563:25 - equals lendingpool.deposit and we're
563:27 - going to go ahead and once again we're
563:29 - going to wait for one block confirmation
563:31 - wait
563:32 - one
563:33 - transactions still being processed so
563:35 - now if we run brownie run scripts ave
563:37 - borrowed up high
563:41 - we can see that this actually went
563:42 - through fine
563:43 - all right now that we have some
563:45 - collateral deposited we can go ahead and
563:48 - actually take out a borrow we can go
563:50 - ahead and borrow some other asset the
563:52 - question is going to be how much how
563:54 - much can we actually borrow how much
563:57 - should we borrow
563:58 - what would result in a positive health
564:00 - factor well maybe we should actually
564:03 - pull off chain some of our stats how
564:05 - much do we actually have deposited
564:07 - how much collateral we have how much
564:09 - debt we have and so on and so forth that
564:12 - way in the future when we don't start
564:13 - clean we can take some inventory of
564:15 - where we stand with our collateral in
564:17 - our debts at the ave documentation
564:20 - we can go ahead and see this this
564:22 - function called get user account data
564:25 - this is going to return the user account
564:27 - data across all reserves so it's going
564:29 - to get the total collateral that we've
564:31 - deposited in terms of ethereum it's
564:34 - going to get our total debt in terms of
564:36 - ethereum how much we can borrow the
564:37 - borrowing power that we have the
564:39 - liquidation threshold or how close to
564:41 - that liquidation threshold will be the
564:44 - loan to value ratio and again this
564:46 - health factor this health factor is
564:48 - obviously incredibly important because
564:50 - if it drops below one or reaches one
564:52 - users can call this liquidation call now
564:55 - this function returns all these
564:57 - variables but for now we really only
564:59 - care about how much collateral we have
565:01 - how much debt we have and how much we're
565:03 - available to borrow so let's go ahead
565:05 - and write a function that will actually
565:06 - sort that out for us we'll call it get
565:10 - borrowable
565:11 - data
565:14 - borrow a bull
565:16 - data so let's go ahead and create this
565:18 - def
565:20 - get borrowable
565:22 - data
565:23 - and we're going to pass in the lending
565:25 - pool as a first parameter and then the
565:27 - account as the second parameter because
565:29 - we're looking to call this function on
565:31 - the lending pool from an account so
565:33 - let's go ahead and just call that
565:34 - function so we'll do lending pool
565:37 - dot get user account
565:39 - data
565:40 - and we'll pass in account that address
565:43 - because we look at the api again
565:45 - all that it needs is a user's address to
565:47 - get started here
565:49 - and it returns one two three four five
565:52 - six
565:54 - variables so we can go ahead
565:57 - and get all of them
565:59 - with this tuple syntax here so we'll say
566:01 - total
566:05 - collateral eath
566:08 - total debt eath
566:11 - available
566:12 - borrow eth
566:15 - current
566:17 - liquidation
566:20 - loan to value
566:22 - and then the health factor
566:26 - so it's with this syntax here that we
566:27 - can actually get all of these variables
566:29 - with this one call and again this get
566:31 - user account data is a view function so
566:33 - we don't need to spend any gas all of
566:35 - these variables are going to return in
566:37 - terms of way so let's just go ahead and
566:39 - convert these from whey to something
566:42 - that makes a little bit more sense to us
566:44 - so we want to get this available borrow
566:46 - each so we can figure out how much we
566:47 - can borrow let's get that
566:49 - in terms
566:51 - that we can actually understand so we'll
566:53 - do fromway
566:54 - available borrow eth in terms of ether
566:58 - we'll do total
567:00 - collateral eth equals web3
567:02 - that from way
567:05 - and we'll do total collateral eth
567:07 - ether
567:09 - ether
567:10 - and then we'll do total
567:12 - debt eth
567:14 - equals same thing web3 dot from way
567:18 - total debt eth
567:20 - terms of ether
567:22 - and let's even do a little printf
567:23 - statement for each one of these so we'll
567:24 - do print
567:26 - f
567:28 - this f allows us to put variables inside
567:30 - the print function and we'll say
567:33 - you have
567:36 - total collateral eath
567:39 - worth
567:41 - of eath deposit 10.
567:44 - we'll even copy paste that a couple
567:46 - times and we'll change this one to
567:49 - total debt eath
567:51 - and we'll change this one to
567:53 - available borrow eth
567:55 - so we'll say you have
567:57 - worth of ease deposited
567:59 - you have total death eat worth of
568:02 - f borrowed
568:04 - and you can borrow
568:07 - available borreeth worth of eath
568:11 - and then we're going to go ahead and
568:12 - return
568:14 - again we're going to use this tuple
568:15 - syntax so we can return two variables
568:18 - and we're going to say a float
568:21 - of this available borrow eth
568:24 - and a float
568:26 - of the total debt eth
568:28 - the reason that we have to add this
568:29 - float variable here is that without it
568:31 - some of the math that we're going to try
568:32 - to do later won't pan out as well so now
568:34 - we have this function get borrowable
568:36 - data we're going to pass the lending
568:38 - pool
568:39 - and we're going to pass our account here
568:41 - since we're returning
568:43 - the borrowable eth and the total debt we
568:46 - can say borrowable
568:50 - eath and then total
568:52 - debt
568:53 - equals that function right there so
568:56 - let's go ahead and try this out
568:59 - with
569:00 - running run scripts ave borrowed a phi
569:02 - pi
569:03 - again
569:05 - because in our config
569:07 - we have a default network of mainnet
569:08 - fork
569:10 - things seem to be approving things seem
569:12 - to be depositing and awesome
569:14 - we have we have our output here we
569:16 - deposited 0.1 worth of f we have 0 f
569:21 - borrowed and we can borrow 0.8 worth of
569:24 - f yes this is correct even though
569:27 - we have 0.1 f deposited
569:30 - we can only borrow
569:32 - 0.08 this is because the liquidation
569:35 - thresholds of different assets are
569:37 - different in this risk parameters
569:39 - documentation here we can see
569:41 - the different liquidation thresholds on
569:42 - the different assets we can see that
569:44 - ethereum has an 80
569:46 - loan to value so with ethereum we can
569:48 - only borrow up to 80 percent of the
569:51 - deposit assets that we have
569:53 - and
569:54 - if we have more than 82.5 percent
569:57 - borrowed will actually get liquidated it
569:59 - also tells about the liquidation bonus
570:01 - reserve factor and some other helpful
570:02 - pieces in here as well but now that we
570:04 - have this borrowable ether mount we can
570:06 - go ahead and actually borrow some dye so
570:09 - let's do a quick print saying
570:11 - let's borrow now in order for us to
570:13 - borrow some dye we also need to get the
570:15 - conversion rate
570:16 - we need to get die in terms of f so
570:20 - we're going to have to use some price
570:22 - feed here luckily we already know how to
570:24 - work with chain link and how to get
570:25 - price feeds ave uses the chain-link
570:27 - price feeds as well so we're using the
570:29 - exact same conversion rate tools that
570:31 - avi is going to use so let's go ahead
570:33 - and create a function to get us this
570:35 - conversion rate we'll say the die to f
570:37 - price
570:38 - is equal to get
570:41 - asset price and then here we'll pass the
570:44 - die
570:44 - f
570:45 - price feed
570:47 - this will be the address of the die
570:48 - ethereum conversion rate let's go ahead
570:50 - and create this function call it def
570:52 - get
570:54 - asset price
570:56 - and the parameter needs is going to be
570:58 - price feed address so the first thing
571:00 - that we're going to need is we're going
571:01 - to need to get this die f price feed
571:03 - where can we get this
571:05 - well as we know per usual we'll head
571:08 - over to the chain link documentation
571:10 - we'll go to ethereum price feeds we'll
571:12 - find done
571:15 - and we'll paste it into our config for
571:18 - mainnet so we can go ahead and add the
571:20 - die
571:21 - f
571:22 - price feed
571:23 - in here and paste it into our config
571:25 - again if we want to test the coven we
571:28 - can obviously just scroll down
571:30 - look for coven
571:32 - find the dieth right here
571:34 - grab that address
571:35 - pop it in for coven
571:40 - and then we can get this the same way
571:42 - that we got the address of the web token
571:44 - so i'm just going to go ahead and copy
571:45 - this
571:47 - paste it here but instead of having weft
571:49 - token in here
571:51 - we'll do die
571:52 - f
571:53 - price feed
571:55 - and now we have a way to change the
571:57 - price feed address depending on what
571:59 - network we're on so in our get asset
572:01 - price function we're going to do the
572:02 - same exact thing that we always do we're
572:04 - going to grab an api
572:06 - and an address
572:08 - to work with the contract so again we
572:10 - can get the abi by just working directly
572:13 - with the interface
572:14 - so we'll say die
572:15 - f
572:17 - price feed
572:19 - equals interface
572:22 - dot
572:24 - aggregator
572:25 - v3 interface because this is the name of
572:28 - the price feed interface
572:30 - which again if we look in our interfaces
572:32 - it looks like we don't actually have so
572:34 - what we can do
572:35 - is we can go to the chain like github or
572:38 - as you guys are already starting to
572:39 - figure out all my example code has all
572:42 - these interfaces as well but we can go
572:43 - right to the source too
572:45 - what we can do we go here we go to
572:46 - contracts
572:48 - we're going to add source
572:50 - we'll do
572:51 - 0.6 we'll do interfaces and right here
572:54 - is the aggregator v3 interface so if we
572:57 - want we can just copy this whole thing
572:59 - move back over to our interfaces
573:01 - new file and this file is actually named
573:04 - aggregator v3 interface you could call
573:06 - it eye aggregator v3 or aggregator v3
573:08 - interface you could keep it with i
573:10 - aggregate or v3 outsole to keep with the
573:14 - convention that we have
573:15 - or you can just call it aggregator
573:19 - v3 interface dot sol
573:22 - to keep in line with what the chain link
573:24 - code is actually called them i'm going
573:25 - to call mine aggravated v3 interface
573:27 - you'll notice a couple different
573:28 - projects have a couple different
573:29 - conventions but now that we have it
573:31 - saved we can do interface the aggregator
573:34 - v3 interface and we'll pass it this
573:36 - price feed address now this diet price
573:39 - feed is going to be a contract that we
573:41 - can call a function on again we can
573:43 - always refer back to the get the latest
573:45 - price documentation to see how to
573:47 - actually work with it there's even some
573:49 - python code here for working with it in
573:51 - web 3. we're going to go ahead and call
573:53 - this latest round data function which we
573:56 - can also find in our aggregator v3
573:58 - interface this latest round data
574:00 - which returns a round id
574:02 - answer started at ended at and answered
574:04 - it around
574:05 - all we're really concerned with is this
574:07 - answer bit here so the way we can do
574:08 - this is we can say latest price equals
574:11 - die dieth price feed the latest
574:15 - round data and instead of grabbing
574:18 - all five of these one two three four
574:20 - five
574:21 - what we can do is we can actually just
574:23 - grab
574:24 - the price which is at the one index so
574:27 - round id is at zero price is at one
574:30 - started it's two et cetera
574:32 - so we can just say
574:34 - at the first index and then we can
574:36 - return
574:38 - a float
574:40 - of
574:41 - this latest price
574:43 - we can even print
574:45 - another printf statement
574:46 - the die
574:48 - f
574:49 - price is
574:51 - latest price
574:53 - so let's go ahead and run this
574:57 - and great we have the die f price video
575:00 - which of course we know that looking at
575:02 - this right now this isn't in the right
575:05 - units we know the diet price feed has 18
575:08 - decimal places so what we can do then is
575:10 - we know that this number would be one
575:12 - two three four five six seven eight nine
575:14 - ten one two three four five
575:16 - six seven eight
575:19 - this number is really zero point zero
575:21 - zero zero four blah blah blah blah blah
575:24 - so maybe we don't want to return it like
575:26 - so maybe we want to say the diet price
575:29 - feed is and we add
575:31 - a little bit of web3.pi to make this
575:33 - make a little bit more sense so we'll
575:34 - say web3
575:36 - dot from
575:37 - way
575:38 - and we'll add this latest price bit in
575:41 - here comma
575:42 - ether
575:44 - maybe we'll even do a converted
575:47 - latest price which is going to be equal
575:49 - to
575:50 - web3 dot from way
575:53 - latest price
575:55 - ether
575:56 - and we'll print that out instead
575:58 - so let's go ahead and run this again
576:02 - all right that looks a little bit more
576:04 - accurate perfect
576:06 - okay great now we have the die eat price
576:08 - we're getting really close to being able
576:10 - to borrow this actual asset and let's
576:11 - even return this converted lated price
576:14 - here just so that we're always working
576:15 - in units that we understand
576:17 - okay now we're getting somewhere now we
576:19 - can calculate the amount of dye that we
576:22 - want to borrow we can find this by doing
576:24 - a little bit of math we're going to do
576:26 - the reciprocal of the die eat price
576:29 - times
576:31 - our borrowable eath and just to be safe
576:34 - we're going to times it by 0.95
576:36 - so this line we're converting our
576:38 - borrowable each
576:40 - to
576:42 - borrowable
576:43 - die and then we're timing it by
576:45 - 95 percent we're timing it by 95 because
576:48 - we don't want to get liquidated so we're
576:50 - going to be a little bit more cautious
576:51 - remember how we slid that sliding scale
576:53 - around to make it safer and less safe
576:56 - well the lower percentage that we
576:57 - actually borrow maybe we even borrow 50
577:00 - of our collateral the safer that we're
577:02 - going to be so keep that in mind when
577:04 - you're deciding how much to actually
577:05 - borrow if you want to run this in a
577:07 - production environment so now that we
577:09 - have this amount data borrow let's even
577:11 - print it out let's say print
577:13 - f
577:14 - we
577:14 - are going to borrow
577:18 - amount down to borrow
577:20 - die and then
577:22 - we're finally going to do it
577:24 - now we will borrow
577:28 - looking at the ave documentation we can
577:30 - look at their borrow function and we can
577:32 - see the api here let's go ahead let's go
577:34 - ahead and call this function so we'll do
577:36 - borrow transaction it's going to be
577:38 - equal to
577:39 - lendingpool.borrow
577:41 - let's look at those parameters so the
577:43 - asset that we want to borrow die address
577:45 - so first we should get a die address
577:48 - which we can once again we'll want to
577:49 - put in our config
577:51 - so we'll go over to our config
577:53 - and we'll add
577:54 - a die address or a die token here which
577:57 - we can find on etherscan
577:59 - token it looks like this is the token
578:01 - right here so we'll copy this address
578:03 - for mainnet remember if you want to run
578:06 - this on coven you're also going to need
578:07 - to have a die token for coven now on
578:10 - test nets avi actually changes up where
578:12 - the tokens for its test nets are
578:14 - actually going to be so if we go to
578:15 - their documentation we go to deployed
578:17 - contracts
578:19 - and we go to coven here you'll always
578:21 - see this little flag thing pop up say
578:23 - always ensure using the latest lending
578:25 - pool address since coven is updated from
578:27 - time to time it's going to be the same
578:29 - thing if we scroll down for tokens they
578:32 - have an up-to-date list of coven
578:34 - addresses in a json file here so it
578:37 - looks kind of gross but if we look up
578:39 - die
578:40 - we can see symbol die and the address of
578:43 - die on the coven test net so sometimes
578:45 - this does change so if you run into an
578:47 - issue maybe it's because the die token
578:49 - that you were working with on their
578:50 - coventestnet has actually changed then
578:53 - we're going to do config networks
578:57 - network dot show active
579:02 - diet token great now let's move on to
579:04 - the next parameter
579:05 - the amount which we just figured out
579:07 - here
579:08 - amount diet to borrow
579:10 - which we do need to change back to whey
579:12 - so we're going to do web3.2a
579:15 - mount dye to borrow
579:17 - ether
579:18 - because right now amount down to borrow
579:20 - is in our human readable version which
579:21 - we need it in way
579:24 - then our interest rate mode which is
579:26 - going to be stable or variable stable is
579:29 - where the interest rate will always be
579:30 - exactly the same
579:32 - variable will change depending on a lot
579:34 - of different things going on with ave
579:36 - for safety we're just going to go ahead
579:38 - and add one here
579:39 - then we're going to do a referral code
579:41 - and on behalf of so referral codes no
579:44 - longer exist so we'll leave zero it's
579:46 - going to be on behalf of our self
579:49 - so we'll do a countdown address
579:51 - and then of course we have to do a from
579:55 - account
579:56 - then we'll wait for this transaction to
579:58 - complete
580:00 - and if we've done this right we should
580:02 - have borrowed some dye programmatically
580:05 - from the ave protocol so let's even
580:06 - print
580:09 - borrowed some die
580:12 - and we can once again call our get
580:15 - borrowable data function
580:17 - since this get borrowable data function
580:19 - will print out our new account
580:22 - information for how much we borrowed so
580:24 - let's go ahead and run this on mainnet
580:25 - fork again
580:29 - awesome so if we've done this correctly
580:32 - we now see that we've borrowed some die
580:35 - so we can see here we now have 0.1 worth
580:37 - of f deposited
580:41 - 0.059999 worth of f borrowed
580:44 - and we can borrow a little bit more
580:46 - worth of f
580:47 - this
580:48 - 0.75999 is actually
580:51 - the die that we've borrowed so we've
580:53 - deposited some eath and we've borrowed
580:55 - some dye and obvious telling us how much
580:57 - that dye converted to eat is there so we
581:00 - actually borrowed 160 die
581:02 - which is great all right we've now
581:05 - learned how to borrow everything which
581:06 - is fantastic let's go ahead and actually
581:09 - repay that back so we're going to call
581:11 - their repay function and let's just put
581:14 - this into its own function called repay
581:17 - all and we'll give it the amount that we
581:20 - want to repay
581:21 - the lending pool address and our account
581:23 - so let's call
581:25 - let's define
581:26 - repay all or we're just going to repay
581:28 - everything that we have
581:30 - again we're going to add an amount
581:33 - lending pool
581:36 - and account
581:37 - for parameters
581:38 - so if we're going to pay back this
581:40 - network first thing that we need to do
581:41 - is actually call the approve function
581:43 - i'm going to prove that we're going to
581:45 - pay back so the first thing we're going
581:47 - to have to do per usual is we're going
581:48 - to actually have to approve that erc20
581:51 - so
581:52 - let's say how much
581:53 - we're going to approve
581:54 - web 3.2 way
581:57 - amount
581:58 - ether to the lending pool
582:02 - and we'll grab it from the config
582:07 - networks
582:11 - network dot show active
582:16 - and this is going to be the
582:18 - die token again
582:21 - and of course
582:22 - with our account i believe our proof
582:25 - erc20 already calls weight so we don't
582:27 - have to call it here so once we approve
582:29 - we're going to be using this die that we
582:31 - borrowed to pay most of what we have
582:33 - borrowed back now we're going to call
582:36 - the repay function so we'll say repay tx
582:40 - equals
582:41 - lendingpool.repay
582:44 - first we need the asset
582:46 - that we're going to use to repay which
582:48 - we're going to use config
582:55 - networks
582:58 - network dot show active
583:04 - diet token the amount which is going to
583:07 - be passed in here amount
583:10 - the rate mode
583:11 - which
583:12 - we've hard coded to one
583:14 - and the address on behalf of which is
583:16 - going to be account
583:17 - dot address
583:19 - and then of course we always have to do
583:20 - from account
583:23 - then we're going to do repay tx
583:26 - dot wait
583:27 - we're going to wait one block
583:28 - confirmation
583:29 - and then we'll print
583:31 - repaid
583:33 - and if we've done all this right we'll
583:35 - do one more print line saying
583:37 - you just deposited
583:39 - borrowed
583:42 - and repaid
583:43 - with ave
583:46 - brownie
583:47 - and chain link
583:50 - all right moment of truth
583:52 - let's see if this works
584:01 - we did it repaid you just deposited
584:04 - borrowed and repaid with ave brownie and
584:06 - chain link awesome work now if you want
584:08 - to what we can also do is we can see if
584:11 - this will work
584:12 - with our wallet address here so what i
584:15 - can do is i can copy my address
584:18 - go to coven ether scan
584:20 - and paste it in here
584:22 - and right now we can see
584:24 - that i have a whole bunch of link and
584:26 - some ether
584:27 - what i can do
584:29 - is actually test everything that we just
584:31 - ran through on the cove intestine and
584:33 - see
584:34 - everything happen
584:36 - right on this ether scan address so if
584:39 - we've been following along correctly and
584:41 - we've added contract addresses
584:43 - appropriately
584:44 - we should be able to run the exact same
584:46 - script on the coven test net i'm going
584:49 - to do one additional thing here though
584:51 - i'm going to have us not repay so we can
584:54 - see
584:54 - us with a little bit of debt
584:57 - so let's go ahead and run brownie
584:59 - run scripts
585:01 - ave bar to pie and we'll change to
585:02 - network coven
585:04 - and now it's going to take a lot longer
585:06 - as we've seen before because we're
585:08 - actually
585:09 - making these transactions on a real
585:11 - network whoops it looks like i got one
585:13 - of the die f price feeds wrong for coven
585:17 - so i can once again just go over to the
585:18 - documentation
585:20 - die
585:22 - s
585:23 - it looks like this is the real address
585:26 - for coven
585:27 - so we'll copy that
585:29 - paste it in here whoops we should also
585:32 - probably have some wet token so first
585:34 - let's go ahead and run
585:36 - our get wet script for coven
585:38 - and we're going to change this account
585:40 - to get account brownie
585:43 - run scripts
585:47 - from our helpful scripts that way we can
585:50 - actually
585:51 - that way we can actually use our wallets
585:53 - correctly all right great so now we have
585:55 - 0.1 weft
585:57 - and actually
585:59 - again what we can do
586:01 - is grab
586:02 - this address here
586:04 - add token paste it in
586:07 - add tokens for the web token and now we
586:09 - can see we have 0.1 with which is
586:12 - perfect
586:13 - so now that we have some width we can
586:15 - run the borrow script ave
586:18 - brownie run
586:20 - scripts ave borrow
586:23 - network coven
586:30 - and wow we can see that everything went
586:32 - through correctly and successfully
586:35 - so since i actually commented out this
586:37 - repay function we still should have die
586:40 - in our address here in our wallet here
586:43 - and again we can see that
586:44 - by going to our brownie config
586:47 - grabbing this dye token address
586:49 - add token custom tokens next
586:52 - ad tokens and we can see we do indeed
586:54 - have 160 die in our wallet
586:57 - we have no weft since it'll be in ave
586:59 - now and we have borrowed die instead you
587:02 - can also see that we now have this a
587:04 - weft if we added it from when we were
587:06 - working with the ui
587:08 - we have this interest bearing with
587:10 - instead of regular wrapped ethereum
587:13 - let's look at one of these transactions
587:15 - we can see
587:17 - that our borrowed transaction
587:19 - gave us some stable debt bearing dye and
587:22 - also some dye so we owe ave some die
587:26 - from this debt we got some debt we got
587:28 - some dye and we gave out some ave
587:30 - interest bearing dye to the rest of the
587:32 - albe protocol you'll notice now if we go
587:35 - to test.ava.com dash dashboard we'll see
587:38 - exactly what our script just did we have
587:40 - 160 borrowed
587:42 - and we have 0.1 eth deposited if we want
587:45 - to repay
587:47 - our funds we can do it
587:49 - with our current collateral or from our
587:51 - wallet balance
587:52 - and you'll notice something if i try to
587:54 - repay
587:55 - everything from my wallet all the diet
587:57 - that i've actually borrowed you'll
587:59 - notice we don't have enough funds to
588:01 - repay the full amount
588:02 - this is because since we actually
588:04 - borrowed a little bit we've include some
588:07 - of that interest so we actually owe more
588:09 - back than we originally borrowed that's
588:12 - how the loans work so when you're
588:13 - designing this repay functions be sure
588:16 - to have that in mind you can also have
588:17 - your repay be -1 to repay the entire
588:21 - debt it's recommended to send an amount
588:23 - slightly higher than the current amount
588:25 - borrowed but in any case maybe we say we
588:27 - want to do from our
588:28 - current wallet we'll hit max but maybe
588:31 - we want to actually just repay with our
588:32 - current collateral we can go ahead and
588:34 - repay the maximum amount again we could
588:36 - do this all from the ui
588:38 - we'll approve and this is exactly what
588:40 - our repay function actually did and now
588:42 - we're all repaid up if we go back to our
588:44 - dashboard and we hit refresh we'll see
588:46 - we just have a tiny bit of ethereum and
588:49 - no more borrowed assets awesome you've
588:51 - essentially learned everything that we
588:53 - need to go through for here
588:54 - this is a massive step forward in
588:56 - teaching you how to become
588:58 - quantitative defy wizards and build
589:00 - really robust applications and really
589:03 - robust financial applications in the
589:05 - default world now something i want to
589:06 - point out even though this isn't a
589:08 - python course and we're teaching more
589:10 - about solidity and smart contracts it's
589:12 - still in your best interest to test
589:14 - these functions
589:15 - yes i know they're python functions but
589:17 - it's still going to be in your best
589:18 - interest to test them to make sure your
589:20 - application always works as you expect
589:22 - it to now i'm not going to go through
589:25 - this testing suite that i put here but
589:27 - it's a really simple testing suite to
589:29 - test some of the different functions
589:30 - that we created
589:31 - it can be really helpful especially for
589:33 - something like get asset price where the
589:36 - math might be a little bit off and you
589:38 - want to make sure it's correctly again
589:39 - link in the description to seeing some
589:41 - of these tests
589:42 - this is actually going to be even easier
589:43 - than that lottery contract that we did
589:45 - since we're just testing python
589:46 - functions
589:47 - and again you can test these all with
589:49 - brownie test
589:51 - all right you are all doing
589:53 - fantastically now is another fantastic
589:56 - time to take a break go for a walk get
589:58 - some food because our next session our
590:00 - next lesson we're going to be learning
590:02 - about nfts how to build them use them
590:05 - and deploy them
590:12 - look nfts are hot right now nfts also
590:14 - known as
590:15 - erc721s are a token standard that was
590:18 - created on the ethereum platform nft
590:20 - stands for non-fungible token and is a
590:22 - token standard similar to the erc20
590:25 - again erc20s like link ave maker all
590:29 - those goodies that are found on the
590:30 - ethereum chain an nft or a non-fungible
590:33 - token is a token that is
590:36 - non-fungible this means that they are
590:38 - starkly unique from each other and one
590:40 - token isn't interchangeable with any
590:42 - other token of its class a good way to
590:44 - think about it is one dollar is
590:45 - interchangeable with any other dollar
590:47 - one dollar is going to have the same
590:49 - value of another dollar those are
590:51 - fungible tokens that's like erc 20s one
590:53 - link is always going to be equivalent to
590:55 - one other link by contrast is going to
590:57 - be nfts those you nerds out there would
591:00 - know like a pokemon would be a good
591:02 - example of an nft your one pokemon is
591:04 - going to have different stats different
591:06 - move sets and isn't interchangeable with
591:08 - any other pokemon or maybe a more
591:10 - relatable one is like a trading card a
591:12 - unique piece of art or the like so
591:14 - that's what these nfts are they are
591:16 - non-fungible non-interchangeable tokens
591:19 - that for the moment are best represented
591:22 - or thought about as digital pieces of
591:24 - art that are incorruptable and have a
591:26 - permanent history of who's owned them
591:28 - who's deployed them etc now like i said
591:31 - nfts are just a token standard so you
591:33 - can actually make them do much more than
591:35 - just be art you can give them stats you
591:37 - can make them battle you can do really
591:38 - unique things with them you can do
591:40 - pretty much whatever you want with them
591:41 - but right now the easiest way to think
591:43 - about it and the most popular way to
591:44 - think about it is by calling them art
591:52 - it's odd or some type of collectible or
591:55 - just anything that's unique now they've
591:57 - been getting a ton of buzz recently
591:58 - because we've been seeing more and more
592:00 - of these being sold at insane prices
592:02 - like we saw axe infiniti sell nine plots
592:05 - of their land nine plots of their unique
592:07 - land for 1.5 million dollars we also saw
592:11 - the original creator of the neon cat you
592:13 - know this cap
592:17 - sold for like 300 eth so like i said
592:20 - they're just tokens that are deployed on
592:21 - a smart contract platform and you can
592:23 - view them on different nft platforms
592:25 - like openc or wearable and these are the
592:28 - nft marketplaces that let people buy and
592:30 - sell them you obviously can do that
592:31 - without these marketplaces because it's
592:33 - a decentralized but they help and give a
592:35 - good user interface so that's the basic
592:37 - gist of it let's talk some more about
592:39 - the standards the erc721 standard or the
592:42 - nft standard this is the basis of it all
592:45 - there is another standard that's
592:46 - semi-fungible tokens the 1155 we're not
592:50 - going to talk about that here but you
592:51 - can check it out the main differences
592:53 - between a 721 and an erc20 on erc20s
592:56 - they have a really simple mapping
592:57 - between an address and how much that
592:59 - address holds 721s have unique token ids
593:03 - each token id has a unique owner and in
593:05 - addition they have what's called a token
593:07 - uri which we'll talk about in a minute
593:09 - each token is unique each token id
593:12 - represents a unique asset so since these
593:14 - assets are unique and we want to be able
593:16 - to visualize them and show what they
593:17 - actually look like we need to define
593:19 - those attributes of the object if it's a
593:21 - piece of r we need a way to define what
593:22 - that art looks like if it's some type of
593:25 - character in game we need a way to
593:26 - define that character's stats in the nft
593:29 - this is where metadata and token uris
593:31 - come in so if you know anything about
593:33 - ethereum you know that sometimes gas
593:34 - prices get pretty high especially when
593:36 - it comes to storing a lot of space it
593:38 - can get really really expensive so one
593:40 - of your first questions might be well
593:41 - are they storing these images and and
593:43 - these are pieces on chain and the answer
593:46 - is sometimes back when they were coming
593:48 - up with nfts and artists were deploying
593:49 - stuff the eth devs and the artists were
593:51 - like yeah art let's do that art i'm just
593:53 - going to deploy this one megabyte image
593:55 - onto the ethereum chain and oh god it's
593:58 - so much a gas expensive how do i
594:01 - totally find it
594:03 - i don't know why it's not um it's not
594:06 - delivered and they realize that if they
594:08 - put all this art on chain it's gonna be
594:09 - incredibly expensive so to get around
594:11 - this what they did is they put in the
594:13 - standard what's called the token uri
594:15 - this is a universally unique indicator
594:17 - of what that asset or what that token
594:20 - looks like and what the attributes of
594:21 - that token are and you can use something
594:23 - like a centralized api or ipfs to
594:26 - actually get that token uri typical
594:28 - token uri has to return something in
594:30 - this format like this it has the name
594:32 - the image location the description and
594:34 - then any attributes below now if you're
594:36 - like me your first question would
594:37 - probably be we paul from a single
594:41 - source
594:42 - seems pretty
594:44 - centralized
594:46 - this is a current limitation of the end
594:47 - of the ecosystem there is often this
594:49 - talk of on-chain metadata versus
594:51 - off-chain metadata because it is so much
594:53 - easier and cheaper to store all your
594:55 - metadata off-chain a lot of people will
594:56 - use something like ipfs that is
594:58 - decentralized but does take a little bit
595:01 - of centrality to keep persisting but
595:02 - they can also use their own centralized
595:04 - api however obviously if that goes down
595:06 - then you lose your image you lose
595:08 - everything associated with your nft
595:09 - because of this most nft marketplaces
595:11 - actually can't and won't read off
595:13 - on-chain attributes or on-chain metadata
595:15 - because they're so used to looking for
595:17 - the token uri obviously if you do
595:19 - off-chain metadata you can't do anything
595:21 - really cool or really interesting or
595:23 - have any games with your nfts for
595:24 - example if you wanted to create an
595:26 - on-chain pokemon game all your
595:27 - attributes would need to be on chain in
595:29 - order for your pokemon to interact with
595:31 - each other because if it was off chain
595:33 - then that becomes a lot harder to
595:34 - cryptographically prove so if you're new
595:36 - with nfts and you're like wait this is
595:38 - kind of a lot of information i'll make
595:39 - it easy for you if you're looking to
595:41 - render an image of an nft add your image
595:43 - to ipfs add a metadata file pointing to
595:46 - that image file on ipfs and then grab
595:48 - that token uri and put it and set it as
595:50 - your nft the chain link dnd article does
595:52 - a great job of walking you through this
595:54 - and showing you how to do this so be
595:55 - sure to read that if you're looking to
595:56 - learn how to do that so all the code
595:58 - that we're going to be working with is
595:59 - actually available for you in this
596:02 - nft mix brownie mix it's an official
596:04 - brownie mix and it allows us to deploy
596:06 - these three adorably cute dogs
596:10 - and there are two different types of
596:11 - contracts that we're going to be working
596:12 - with we're going to be first working
596:14 - with a simple collectible and then we're
596:16 - going to work with an advanced collect
596:18 - the simple collectible is going to be a
596:19 - very simple erc721 standard we're not
596:21 - going to really add any bells and
596:23 - whistles other than give it like a name
596:25 - and then our advanced collectible is
596:26 - going to take advantage of some of those
596:28 - more advanced true scarcity features
596:30 - that we were talking about so protocols
596:32 - like avagochi and ethercards use
596:34 - chainlink vrf to get verifiably random
596:36 - numbers to create verifiably scarce nfts
596:39 - something that's important to keep in
596:40 - mind is that in the real world when
596:43 - companies create trading cards there's
596:44 - no way to prove how scarce or how
596:47 - valuable these trading cards actually
596:49 - are if we use a verifiable random number
596:51 - then whoever is deploying these nfts
596:54 - can't even control how rare these nfts
596:56 - really are so we get this verifiable
596:58 - scarcity and this verifiable rarity
597:00 - which adds some value to the tokens if
597:03 - you want to just go ahead and work right
597:05 - from the brownie mix you can actually
597:06 - just run brownie bake nft mix
597:11 - and then cd into nft
597:14 - and all of our code
597:16 - is gonna be right in here we're gonna go
597:17 - through and deploy and develop
597:19 - everything from scratch because we're
597:20 - going to actually take some previous
597:22 - concepts that we've learned improve on
597:24 - them and we're going to learn a lot of
597:26 - nitty gritty interesting pieces about
597:28 - making this hybrid smart contract
597:30 - because these nfts really are a perfect
597:32 - example of a hybrid smart contract they
597:35 - have some off-chain component
597:36 - interaction with a random number and
597:38 - restoring their metadata with ipfs and
597:41 - i'll explain ipfs a little bit more in
597:43 - depth as we go on here
597:45 - so let's go ahead and get to it i'm
597:47 - going to go ahead and make a new
597:48 - directory
597:50 - called nft demo
597:51 - i'm gonna cd into it
597:54 - code
597:55 - period
597:56 - and perfect i have a blank project here
597:59 - and you already know what the first step
598:00 - we're gonna do is
598:02 - is do brownie init to create our blank
598:04 - brownie repository now let's go ahead
598:07 - and create our first
598:08 - contract we'll call this
598:11 - simple
598:12 - collectible
598:14 - dot soul since this is going to be it
598:15 - since this is going to be a simple
598:17 - collectible a simple nft that we're
598:19 - going to get started with now similar to
598:21 - the erc20 this erc 721 standard
598:25 - has a number of functions that we can
598:26 - actually work with we can go ahead and
598:28 - even look at the 721 the erc721
598:31 - non-fungible token standard on the
598:34 - eips.ethereum.org website and we can see
598:36 - a sample interface and some sample
598:38 - events and some functions and kind of
598:40 - everything that we've grown to know and
598:42 - love and once again instead of us kind
598:44 - of recoding copy pasting all this from
598:46 - scratch we're going to be using we're
598:48 - going to be using open zeppelin's erc721
598:51 - documentation for this
598:53 - now we're going to be working with
598:54 - version 3.x there is a version 4.x that
598:58 - has come out using version 3.x of their
599:00 - open zeppelin contracts is also i think
599:02 - a little bit easier to explain but again
599:04 - those who want to challenge yourself
599:06 - definitely try their 4.x version so
599:08 - let's go ahead and jump right into it
599:10 - first we'll do our srspdx
599:14 - license identifier
599:17 - mit
599:18 - then we'll choose our solidity version
599:21 - we're going to use pragma solidity 0.6.6
599:24 - but again most of this should work for
599:27 - 0.8 moving forward
599:29 - and then we're going to go ahead and
599:30 - look at the open zeppelin erc721
599:33 - documentation
599:35 - and we're going to go ahead and
599:37 - grab this line right here
599:39 - import open zeppelin slash contracts
599:41 - token
599:42 - erc721
599:43 - erc21.soul you can even see
599:46 - a sample erc721 that they give you and
599:49 - this is actually going to be similar to
599:50 - the erc721 that we're going to make so
599:52 - we're going to go ahead and paste that
599:54 - and of course since we're doing this at
599:56 - opensupplement contracts we're going to
599:58 - need to
599:59 - create our brownie config
600:04 - and same as always the pen
600:06 - [Music]
600:08 - then sees
600:10 - it's going to be
600:13 - open zeppelin slash open
600:16 - zeppelin contracts
600:18 - and again like i said we're versing
600:20 - we're using version three
600:21 - so
600:22 - 3.4.0 again and then we'll do compiler
600:27 - sulk
600:31 - remappings
600:34 - and we'll say
600:35 - at open
600:37 - zeppelin
600:39 - equals
600:41 - this
600:43 - and great let's even try to just compile
600:45 - this right now browning compile
600:50 - and perfect it has been compiled now
600:52 - similarly to our erc 20 that we did with
600:54 - open zeppelin we're going to do the same
600:56 - startup here so we're going to say
600:58 - contract
601:02 - simple collectible is erc erc721
601:07 - and this is how we're going to inherit
601:09 - all of those functions
601:12 - in the erc721 token standard here and we
601:16 - can start adding r
601:18 - and we can start coding our simple erc
601:20 - 721 now for our erc 721 we're going to
601:24 - make it be a couple of these cute
601:26 - adorable dogs so it's going to be one of
601:28 - these three dogs for our simple
601:30 - collectible we're just going to go ahead
601:31 - and use the pug here so so you can use
601:34 - any image that you want for this demo um
601:37 - however if you want to just follow along
601:38 - with us
601:39 - we can just download this
601:41 - dog and we'll call it pug create a new
601:44 - folder
601:45 - here called img and then i'm just going
601:48 - to add pug.png to this img folder so
601:51 - this is going to be the mft that we're
601:53 - going to deploy we're going to deploy
601:55 - this very simple pug for our smart
601:57 - contract so we're going to be deploying
601:59 - this pug this is the image that we're
602:01 - going to use for our nft it's going to
602:03 - be this adorable pug so let's go ahead
602:05 - and create the rest of the contract for
602:07 - this pug so the first thing we're going
602:09 - to make is our constructor
602:12 - it's going to take no input parameters
602:14 - it's going to be a public constructor
602:16 - and then we're going to go ahead and use
602:18 - the erc721 constructor
602:21 - which if we look at the documentation
602:23 - we give it a name
602:25 - and then a symbol
602:27 - we're going to use the erc721
602:29 - their parameters
602:31 - which is going to be a name which we're
602:33 - going to say is doggy and a symbol
602:35 - which we're going to say is dog and
602:38 - perfect
602:40 - that's all i really need to do for the
602:41 - first part this nft contract is actually
602:44 - what's known as a factory contract
602:46 - there's a main contract and in it it has
602:48 - a list of all the nfts and the owners
602:51 - that are of this type of nft so in this
602:54 - example all the type of nft is just
602:56 - going to be this pug and it's just going
602:58 - to be this dog and we actually need a
603:00 - function to mint new nfts based off of
603:04 - this pug now we can absolutely have an
603:06 - nft factory contract that only creates
603:09 - one single nft but we're going to use
603:11 - this factory implementation to create
603:13 - multiple nfts we're going to do it with
603:16 - a function called create collectable
603:18 - this will create a new nft and assign it
603:21 - to whoever called this function so
603:24 - anybody can come here and create a new
603:25 - puppy for themselves or in other words
603:28 - adopt a puppy so we're going to say
603:29 - function
603:31 - crate collectible
603:34 - public
603:35 - and we're going to say returns
603:38 - you went 256.
603:40 - you'll see why we need to do this in a
603:41 - minute now when we create this
603:43 - collectible all we're doing is we're
603:45 - assigning a new token id to a new owner
603:49 - and if we look at the open zeppelin
603:51 - erc721
603:53 - github
603:55 - we can see they have this safe mint
603:57 - function this is the function that they
603:59 - use to
604:00 - mint or create a new nft
604:03 - this function it's it takes a new
604:05 - address 2 which is going to be the new
604:07 - owner of the nft and a token id every
604:10 - nft in this factory contract has a
604:12 - unique token id we're going to have our
604:15 - token ids start from 0 and and just
604:18 - increment every time we have a new token
604:19 - minted this safe mint function calls
604:21 - this safement function which calls this
604:23 - minting function so
604:25 - if you're looking at the code here
604:27 - this mint function is really the the
604:29 - function that calls and creates this nft
604:32 - you'll see actually that they just have
604:34 - two mappings that they update
604:36 - they update this owner's mapping
604:39 - which is just a mapping of token ids to
604:42 - the owners of the token ids
604:44 - and then they update this balances
604:47 - mapping
604:48 - which is a mapping of owner address to
604:50 - the token count so the number of tokens
604:53 - that an owner actually has and that's
604:55 - all that's happening when we call this
604:57 - mint or in our case safement function
604:59 - the difference between safe mint and
605:01 - mint
605:02 - is safement checks to see if a token id
605:04 - has already been used or not and this
605:06 - way we don't actually override who owns
605:09 - tokens and who owns tokenids so we're
605:11 - going to use the safement function so
605:13 - first we need to think okay well we're
605:15 - going to need to a way to count these
605:17 - token ids so that every single person
605:19 - has a unique token id
605:21 - so let's create a global variable un256
605:24 - public
605:26 - token counter
605:27 - and we'll initialize it tokencounter to
605:30 - zero of course
605:32 - this is the same as initializing token
605:34 - counter to zero
605:36 - but let's just make it very explicit so
605:39 - when we create a new collectible
605:41 - we're going to say uwen256
605:44 - new token id is going to be equal to
605:47 - this
605:48 - token counter and we're going to iterate
605:50 - this every time we mint a new token so
605:52 - for example we're going to iterate that
605:54 - in this create collectable here so new
605:56 - token id equals token counter we're
605:59 - going to call
606:01 - this safement function since we're
606:03 - inheriting it from open zeppelin's
606:05 - erc721 we need to give it this new nft
606:08 - and owner which is going to be
606:10 - message.sender so whoever calls this
606:12 - function
606:13 - and then we need to give it
606:15 - a unique token id which is going to be
606:17 - this new token id now whenever we mint
606:19 - one we're going to want to
606:21 - increment this token counter so then we
606:23 - can say token counter
606:24 - equals token counter plus one
606:27 - and we can then return
606:29 - this new token id so we'll return the
606:31 - token id of the token that we just
606:33 - created and boom if you're looking for
606:36 - an incredibly minimalistic contract to
606:38 - deploy nfts this is all that you need so
606:41 - we can run brownie compile
606:44 - to make sure we did everything right
606:46 - and project has been compiled we can see
606:48 - it in the build so great job obviously
606:50 - this might be a little dissatisfying to
606:53 - you after the breakdown that we just
606:55 - gave how do we view this token what does
606:57 - this token look like i thought we wanted
606:59 - this to be a doggy how do we know that
607:01 - this looks like a dog how do we get this
607:03 - image on the blockchain this is where
607:06 - metadata is going to come into play now
607:08 - if we look at the original erc 721 there
607:11 - is this part called the metadata
607:13 - extension is optional for erc 721 smart
607:16 - contracts as we've talked about anytime
607:18 - you make a transaction on chain it costs
607:21 - some gas even very tiny amounts of data
607:24 - can cost more and more gas images are
607:27 - much bigger than these little bits of
607:29 - data here and they can cost a lot more
607:31 - gas
607:32 - so when this standard was being created
607:34 - the developers kept this in mind and
607:36 - knew that storing entire images and
607:39 - entire gifs and entire videos on chain
607:41 - was going to be incredibly costly so
607:44 - they added this piece about metadatas
607:46 - and token uris the token uri is a
607:49 - distinct uniform resource identifier for
607:52 - a given asset this is an example of a
607:54 - uri and the metadata that we're going to
607:56 - be demoing today a uri is just a unique
607:59 - resource identifier so this can be
608:02 - something like https or ipfs or any url
608:05 - string that uniquely points to some
608:08 - metadata your metadata file is going to
608:10 - look like this
608:12 - it's going to have a title
608:14 - for the title of the nft
608:16 - can have a type
608:17 - and it can have all these different
608:18 - properties or stats or attributes for
608:21 - example we're going to have our pug nft
608:24 - which is going to be defined like this
608:26 - it's going to have a name as pug
608:29 - description is going to be an adorable
608:31 - pug pup and it's going to have what's
608:33 - called the image uri which defines what
608:35 - the token actually looks like and if we
608:38 - copy paste this into another browser
608:40 - we get returned this it's this token uri
608:44 - with this metadata json object that's
608:46 - going to enable different nft platforms
608:48 - to actually render our nft so this is an
608:51 - example of what this pug is going to
608:53 - look like on different nft
608:55 - marketplaces like openc
608:58 - platforms like openc understand that
609:00 - they need to show this image they need
609:02 - to use this name they need to use this
609:04 - description and have these traits so if
609:06 - we look back at this
609:08 - nft on openc we can see the name is pug
609:11 - we can see the description here if we go
609:13 - to levels we see its cuteness as 100 out
609:15 - of 100 now this of course leads us to a
609:18 - really interesting point if we're
609:20 - storing the image off chain then how is
609:22 - this image decentralized if we're
609:24 - storing this image off chain how can we
609:27 - guarantee this nft is going to stay
609:29 - forever now this leads us into a little
609:31 - tidbit about storing data on blockchain
609:34 - as of current recording storing a lot of
609:37 - data on chain can get incredibly
609:39 - expensive the more data that you store
609:41 - the more transactions that you have to
609:43 - make to store that data on chain and the
609:46 - more gas that you're going to have to
609:47 - spend at the time of recording ethereum
609:49 - is about little less than 900 gigabytes
609:52 - in size if a ton of people were to put
609:54 - full videos or movies or
609:57 - massive images ethereum would grow
609:59 - exponentially out of proportion and this
610:01 - would become unsustainable for the
610:03 - blockchain network as a whole so
610:05 - ethereum isn't great for actually
610:06 - storing a ton of data it can store a lot
610:08 - of data but it's a lot better for doing
610:11 - the logic and the smart contracts so
610:13 - there are a lot of different platforms
610:14 - that are actually working on this
610:15 - problem of storage these platforms allow
610:18 - people to store data in a decentralized
610:20 - way that isn't going to exponentially
610:22 - explode the size of ethereum or
610:24 - different smart contract platforms the
610:25 - decentralized storage methodology we're
610:27 - going to work with is going to be ipfs
610:30 - or interplanetary file system and this
610:33 - is where we're actually going to store
610:34 - our image and this is actually where
610:36 - we're going to store our image so that
610:37 - nft marketplaces know what our nft looks
610:40 - like now here's what some protocols do
610:43 - some protocols just set up a server and
610:46 - set this token uri to instead be from a
610:49 - decentralized service like ipfs and use
610:52 - just maybe their own centralized server
610:55 - this is obviously a massive issue
610:57 - because if their server goes down or if
610:59 - they want to change the
611:00 - image or they want to change the stats
611:03 - all they have to do is change it in
611:04 - their server and this is why a protocol
611:06 - like ipfs is going to be a lot easier
611:08 - quicker and more decentralized version
611:10 - of doing this the full solution is going
611:12 - to be using something with ipfs and
611:14 - filecoin but easy solutions to do that
611:16 - are still being built out so for now
611:18 - we're just going to use ipfs because
611:20 - it's free it's quick and it's easy and
611:22 - it can be expanded to combine with file
611:24 - coin to be even easier to work with now
611:26 - something else that i want to touch on
611:28 - too when it comes to this metadata right
611:30 - now all these nft marketplaces only know
611:32 - how to pull attributes
611:34 - from this token uri now if we want to
611:37 - build really cool nfts that can interact
611:39 - with each other having some attributes
611:41 - or maybe some like like attack stats or
611:43 - attack moves like in pokemon for example
611:45 - or trading cards we can't just store
611:48 - these in this token uri
611:50 - because the blockchain doesn't know
611:51 - anything about this token uri so we
611:54 - actually need to store these attributes
611:56 - on chain i'm really hoping in the future
611:58 - a lot of these nft marketplaces are
612:00 - going to get better at
612:02 - and pulling metadata from on chain but
612:05 - now right now any attribute that we give
612:07 - our nfts we actually have to reproduce
612:09 - in the token metadata and the token uri
612:12 - as well so we've just learned a lot
612:14 - about metadata ipfs token uris and
612:18 - everything like that let's update this
612:20 - simple nft to be able to render on openc
612:23 - and render on these nft platforms
612:26 - because right now if we were to deploy
612:27 - this nobody would know what this doggie
612:29 - looks like so let's give it a token uri
612:33 - so in this crate collectible let's do
612:35 - string
612:36 - memory
612:38 - token uri
612:40 - and after we call this safemint function
612:43 - there's another function that we're
612:44 - importing
612:45 - called set
612:47 - token uri
612:49 - and we're going to set the token uri
612:51 - for the token id
612:54 - and we're going to give it this token
612:56 - uri
612:59 - this will allow our nft to actually have
613:01 - an image associated with it that we can
613:03 - actually see
613:04 - so let's go ahead and so let's go ahead
613:06 - and create a script that's going to
613:08 - deploy this nft factory contract and
613:11 - then create us a collectible
613:13 - so we're going to do new file we'll call
613:15 - it deploy
613:17 - and create
613:19 - dot pi and let's jump into our script
613:21 - so we'll do def main
613:24 - first we need to start with an account
613:26 - and
613:28 - once again we can go ahead and create
613:32 - helpful scripts
613:34 - dot pi
613:35 - we can go ahead and copy paste this get
613:37 - account function in here if you want
613:53 - but of course since we added this config
613:55 - wallet from key we're going to go to our
613:57 - browning config we'll add wallets
614:01 - from key
614:02 - and we're going to grab our private key
614:06 - environment variable
614:07 - since we're using a private key
614:09 - again
614:10 - we're going to create a dot env
614:13 - and we need our to export private key
614:16 - and we're also going to need to export
614:17 - our web3
614:18 - infuro
614:20 - project id
614:22 - so we can just copy paste for my last
614:25 - project the private key web3 inferior
614:27 - project id and our etherscan token so
614:30 - that we can actually verify this on
614:31 - chain and we'll add a new file
614:34 - init
614:35 - dot pi
614:36 - so that older versions of python know
614:38 - that this is indeed a package
614:40 - so we'll go ahead and do from
614:43 - scripts
614:45 - dot helpful scripts
614:46 - import
614:48 - get account now all we have to do
614:50 - is import our simple
614:53 - collectible
614:55 - and run
614:58 - simple
614:59 - collectible
615:01 - equals
615:03 - simple collectible
615:05 - dot deploy and if we look ours and if we
615:08 - look at our simple collectible we have
615:09 - no constructor parameters here so we can
615:12 - just do from
615:15 - account
615:16 - and now this will have our simple
615:18 - collectable deployed now we need to
615:20 - actually call this now we actually need
615:22 - to call this create collectable function
615:24 - and we're going to pass it a string
615:25 - which is going to be this token uri
615:29 - i'm going to go ahead and use this
615:31 - sample token uri that is included in our
615:34 - nft mix so if you're looking to get this
615:37 - token uri
615:38 - look up nft mix patrick collins
615:41 - hopefully the github will show right up
615:43 - and we can just go right to the scripts
615:45 - in here
615:47 - it's in the simple collectible folder
615:49 - create collectable
615:52 - that's the bigfoot we're going to grab
615:53 - this and in our script we're going to do
615:55 - sample
615:57 - token uri
615:58 - equals
616:00 - this
616:01 - now when you paste this token uri in
616:03 - your browser if you can't see it you
616:05 - might have to add something like ipfs
616:07 - companion to your browser like this
616:10 - some browsers don't natively have it so
616:12 - so there is a link to ipfs companion for
616:15 - this project in the github repo but now
616:17 - that we have a token uri we can call
616:19 - this create collectable function so
616:21 - we'll do
616:23 - transaction
616:25 - equals
616:26 - simple collectable
616:28 - dot create
616:30 - collectible
616:32 - and we'll pass in this sample token uri
616:35 - and then of course we'll do from
616:39 - account
616:41 - we'll do tx.weight we'll wait for one
616:43 - block and then if we've done this
616:45 - correctly we'll actually be able to see
616:47 - this nft
616:49 - on an nft marketplace like open c
616:52 - so let's do a quick print line here
616:53 - we'll do print
616:55 - awesome
616:56 - you can now
616:58 - you can view your nft
617:03 - at
617:04 - and we'll do this in fstring
617:06 - and this is where we're going to put the
617:07 - openc url for this ring b
617:10 - so we're going to say open c url
617:13 - which is going to be equal to if we pop
617:15 - over to open c if we pop over to this
617:17 - open c pug here on the ring p test net
617:20 - we can go ahead and grab
617:22 - this first start of the string so it's
617:24 - going to be https testnets.openc.io
617:28 - assets and then this is the address of
617:30 - the contract
617:32 - so we can say openc url is going to be
617:34 - this slash
617:36 - and we'll put this little brackets here
617:38 - slash and then another one of these and
617:40 - this is because the url for here
617:43 - testness.openc.io assets
617:46 - it's the contract address and then the
617:48 - token id on the end here so this is what
617:51 - it's going to look like
617:52 - so in our print line awesome you can
617:54 - view your nft openc.format
617:57 - simplecollectable.address
617:59 - comma
618:00 - and we do simplecollectable dot
618:08 - token counter
618:09 - minus one
618:11 - for the most recently deployed one and
618:13 - then we'll run this now
618:15 - brownie run scripts
618:17 - deploy and create
618:19 - network
618:20 - rink b
618:25 - and awesome we get this print line here
618:27 - saying
618:28 - awesome you can view your nft at https
618:31 - testness.openc.io just keep in mind
618:33 - obviously for mainnet we can't use this
618:35 - testnet.openc.io
618:36 - but
618:37 - assets the address of the nft contract
618:40 - and then the token id as well
618:42 - so if we go ahead
618:44 - and click this and it looks like it's
618:46 - already actually been rendered here in
618:48 - openc we could even go ahead and hit
618:50 - refresh metadata just in case it doesn't
618:51 - show up right away but it looks like for
618:53 - us it did show up right away which is
618:55 - awesome some other kind of fun parts
618:57 - about openc is if we go to our profile
618:59 - here
619:00 - we'll actually be able to see all the
619:01 - nfts that we own on this testnet i've
619:04 - actually deployed this this doggie twice
619:06 - here once to test and then once i
619:07 - actually do it great we've created our
619:10 - simple collectable of course no project
619:12 - is complete without some tests so let's
619:14 - create some tests since we're also going
619:17 - to be doing an advanced collectible i'm
619:18 - going to skip the integration test and
619:20 - i'm just going to write a really simple
619:22 - unit test so we'll create a new folder
619:24 - we'll call it unit
619:25 - and in here we'll do a new file
619:27 - test
619:29 - simple collec
619:33 - so let's create our first test we'll do
619:35 - def test can
619:37 - create
619:38 - simple collectible
619:40 - we'll just make sure that we can
619:42 - actually create a simple collectible now
619:44 - we'll make sure that this is our unit
619:46 - tests so we'll do from scripts dot
619:49 - helpful scripts
619:50 - import local blockchain environments
619:54 - and then we'll do if
619:56 - network.showactive
619:59 - not in
620:00 - local blockchain environments
620:02 - pi test.skip
620:05 - so of course we need to do from
620:08 - brownie
620:10 - import
620:11 - network
620:13 - and then also import pi test
620:16 - now something that we could do here is
620:18 - actually in our test we could go ahead
620:19 - and even test our scripts by importing
620:22 - uh deploy and create here and testing
620:24 - this we do something like return
620:28 - simple collectible
620:30 - and in our test then we could do
620:33 - from scripts
620:36 - dot deploy and create import deploy and
620:39 - create
620:41 - and then back in our deploy and create
620:42 - script we can modify this a little bit
620:44 - instead of main here we'll call this
620:46 - deploy and create and then we'll have
620:49 - our main function
620:51 - just call
620:52 - deploy and create
620:54 - and you'll see ronnie runs scripts
620:58 - deploying create to pi if we go ahead
620:59 - and run this again we can just run this
621:01 - on the development network real quick
621:03 - instead of on ring p you'll see that
621:04 - this does also work obviously we won't
621:06 - actually be able to see our nft on openc
621:09 - because this is deployed to the brownie
621:11 - temporary ganache chain as opposed to a
621:13 - persistent wrinkly chain in our test
621:15 - here
621:16 - we could then just do we just run
621:19 - simple
621:20 - collectible
621:22 - equals deploy and create
621:25 - and then we'll do an assert here we'll
621:27 - assert
621:29 - simple collectible
621:34 - that owner of zero
621:37 - is going to be equal to get account
621:39 - and then we'll also import
621:42 - get account
621:45 - so we can run brownie test
621:49 - make sure this works and perfect now
621:51 - this was all fun and dandy but there's a
621:53 - couple of things that we didn't go over
621:55 - and that we didn't do so let's create a
621:57 - quick readme.md for a couple of notes
622:00 - so number one
622:02 - we didn't upload an image
622:05 - to ipfs ourselves so we just used a
622:08 - token uri that was already existing
622:10 - right we didn't actually upload
622:11 - something to ipfs we didn't go over why
622:14 - is ipfs
622:16 - decentralized we didn't really talk too
622:18 - much about what ipfs is number three
622:21 - anyone can mint an
622:24 - nft here
622:26 - with any type of stats right it's not
622:28 - going to be it's not verifiably scarce
622:32 - or random right this isn't that cool so
622:35 - we want to actually build an nft project
622:38 - that has all these pieces where we
622:41 - upload the image to ipfs ourselves we're
622:43 - going to talk a little bit more about
622:44 - why ipfs is decentralized and it's the
622:47 - preferred solution for storing nft
622:49 - metadata and we're going to make our nft
622:52 - more verifiably random and verifiably
622:54 - scarce like for things like ethercards
622:57 - and avagoji let's go ahead and do this
622:59 - project again but we'll integrate the
623:01 - chain link vrf
623:02 - to make this nft verifiably scarce and
623:05 - verifiably random and then we'll also
623:07 - teach you guys how to upload to ipfs and
623:10 - work with ipfs ourselves so let's go
623:12 - ahead and do this so let's create a new
623:15 - file in our contracts and we'll call it
623:18 - advanced
623:20 - collectible dot sol and what we're going
623:22 - to do here is we're going to make again
623:25 - an nfc contract
623:28 - where the token uri
623:31 - can be one of three different dogs so if
623:35 - we look at this nft mix in the images
623:37 - section there's a pug a shibba in you
623:39 - and a saint bernard or one of these
623:42 - three dogs
623:43 - we're gonna make it so that when you
623:44 - mint one of these nfts you're gonna get
623:46 - you're gonna get a random one of these
623:48 - three dogs now i'm not gonna go over
623:50 - stat generation
623:52 - and like creating battle battling nfts
623:54 - or really games out of these nfts if you
623:56 - guys wanna see a version of those
623:58 - contracts check out this dungeons and
624:00 - dragons nft there's a link in the github
624:02 - to see this and it actually creates
624:04 - characters that can do battle and have
624:06 - like stats and attributes like
624:08 - um like attack
624:11 - and different things you'd find in
624:13 - dungeons and dragons this one's done
624:15 - actually with truffle as opposed to
624:17 - being done with brownie but all the
624:20 - contracts are going to be the same other
624:21 - than this migrations.soul so if you're
624:23 - looking to check this out you absolutely
624:25 - can it is a ton of fun and they have
624:27 - some really cool images as well so be
624:29 - sure to check that out if you're looking
624:30 - for more anyways here's what we're going
624:31 - to be looking to do we're going to make
624:32 - an nft contract where the token uri can
624:35 - be one of three different types of dogs
624:36 - and it's going to be randomly selected
624:38 - so let's go ahead and do it so first
624:41 - again we're going to do this spx license
624:43 - identifier right at the top so we can go
624:45 - ahead and put that there
624:47 - and we're going to even use
624:49 - same solidity version and we're going to
624:51 - use open zipline again so
624:53 - we can literally just copy and paste
624:54 - that from our last project now we're
624:57 - going to create our contract
624:58 - advanced
625:00 - collectible
625:02 - we're going to say is erc
625:04 - 721
625:07 - great
625:09 - and then since we're going to want to
625:10 - work with chain link vrf to get a
625:12 - provably random nft we're also going to
625:14 - want to import
625:16 - at chain link
625:18 - contracts
625:19 - slash src
625:21 - v0.6 vrf con
625:24 - consumer
625:26 - base dot sol
625:28 - and of course that means we're going to
625:29 - go back to here and we're going to add
625:31 - smart contract kit
625:33 - slash chain link
625:37 - brownie
625:39 - contracts
625:40 - at 1.1.1 and then we're going to go
625:43 - ahead
625:44 - and add the remapping in
625:46 - we'll say
625:48 - at chain link equals
625:51 - boom
625:53 - awesome so we've imported the chain link
625:55 - bit
625:56 - our advanced collectible is erc 721 and
626:00 - it's going to be vrf
626:02 - consumer base so same as always let's go
626:05 - ahead and start with the constructor we
626:07 - know from our lottery smart contract
626:08 - that we're actually going to want to
626:09 - parameterize a lot of these pieces for
626:11 - working with the vrf coordinator for
626:13 - working on different chains and
626:15 - different test nets
626:16 - so we're going to do address
626:19 - vrf
626:20 - coordinator we're going to do address
626:23 - link token
626:25 - bytes32
626:27 - keyhash
626:28 - and we can always head back over to
626:30 - docs.chain.link go to get a random
626:32 - number just in case we forget what some
626:34 - of the parameters are vrf coordinator
626:37 - link token keyhash and fee
626:39 - great you went 256 feet
626:42 - i will make this
626:44 - public as well
626:46 - add a little curly bracket there
626:49 - and we can go ahead and start doing the
626:51 - rest of this of course we need to do the
626:53 - vrf consumer based constructor and the
626:55 - erc721 constructor
626:57 - so
626:58 - vrf consumer base
627:02 - is going to be this vrf coordinator
627:06 - and this link token
627:08 - and the erc 721
627:11 - we could paramore ties these as well but
627:13 - we know it's going to be a dog so we'll
627:14 - do doggy and the symbol of dog
627:17 - which is the same
627:19 - as our simple collectible here we know
627:22 - we're also going to need to do this
627:23 - token counter bit
627:25 - so we'll do
627:26 - you want 256
627:28 - token counter
627:32 - and right in here
627:33 - we're going to do
627:35 - token counter
627:36 - equals zero of course we're going to
627:38 - need a key hash
627:40 - so let's make this unit 56 public token
627:43 - counter
627:44 - excuse me
627:45 - we're going to do a bytes32
627:48 - public key hash
627:53 - and we're going to do
627:54 - a uint256
627:56 - public fee
627:58 - and we'll set
628:00 - key hash
628:01 - equals
628:03 - key hash
628:04 - and fee equals
628:06 - fee
628:07 - great so this is a combination of a lot
628:09 - of the stuff we did in our lottery smart
628:11 - contract and some of the pieces that
628:14 - from our erc 721 we need the key hash
628:17 - the fee vrf coordinator link token all
628:20 - for the vrf consumer base
628:23 - oops i should put a extra quote here and
628:25 - then we need dog doggy and a token
628:28 - counter for erc 721 so now
628:31 - we're going to create
628:33 - our function create collectable
628:36 - so we're going to do function
628:39 - create collectible
628:41 - and again we're going to do a string
628:43 - memory token uri
628:45 - but this time in our python scripts
628:47 - we're actually going to define where
628:49 - we're getting this token uri from and
628:51 - we're going to create it ourselves but
628:52 - we're going to make this public
628:54 - and it's going to return
628:58 - a bytes32 remember way back in our
629:00 - lottery when we did this event requested
629:02 - lottery winner when we called the
629:04 - chainlink vrf we're going to do a
629:06 - similar thing here where we're going to
629:08 - make an event for whenever we request
629:10 - one of these new dogs and that is also
629:13 - what we're going to return we're going
629:14 - to return that request id here so since
629:17 - we're using the chainlink vrf here we
629:19 - can go ahead and call that request
629:21 - randomness function which again
629:23 - over the docs.chain.link this is
629:25 - imported from the erc721
629:28 - and then in that request and receive
629:30 - model it's going to call back with our
629:32 - fulfill randomness function we're going
629:33 - to need to do a couple of different
629:35 - things here because we want the user who
629:37 - called create collectable to be the same
629:39 - user who gets assigned the token id
629:43 - so first we'll do bytes 32
629:46 - request id equals request
629:50 - randomness
629:52 - and we're going to pass obviously the
629:53 - key hash
629:55 - and the fee
629:56 - this is going to create our randomness
629:58 - request to get a random breed for our
630:00 - dogs so let's go ahead and just define a
630:03 - little bit of the fulfill randomness
630:04 - function so we can figure out how we're
630:06 - actually going to pick a random dog well
630:08 - the first thing that we're going to need
630:09 - is we're going to need some definition
630:11 - of what the different breeds that the
630:13 - dog can actually be and again similar to
630:15 - the lottery we're going to create a new
630:17 - type called breed using the enum
630:19 - so we're going to do enum breed
630:23 - and then we're going to give it three
630:24 - types
630:25 - pug which is going to be state 0
630:28 - shiba inu which is going to be state 1
630:31 - and say bernard which is going to be
630:34 - state 3. so our breed is going to be one
630:37 - of these three breeds here so then in
630:41 - our function
630:41 - [Music]
630:42 - fulfill randomness
630:46 - when we get that random number back we
630:48 - can use that random number to pick one
630:50 - of these three breeds
630:52 - so of course we need to have a byte32
630:56 - request id and uint256
631:00 - random number
631:02 - and we're going to make this internal
631:04 - override so that only the vrf
631:07 - coordinator can call this and what we're
631:09 - going to do now is we're going to select
631:11 - a breed based off of this random number
631:13 - so we're going to say breed
631:15 - breed which we're saying
631:18 - this breed variable is of type breed
631:21 - it's going to be equal to
631:23 - breed generated from that random number
631:27 - mod 3.
631:29 - since we have one two
631:32 - three different breeds awesome so this
631:34 - is how we're going to get our random
631:35 - breed however we do need to assign this
631:38 - breed to its token id so now that we
631:42 - have a random breedback how do we
631:43 - actually go ahead and assign this well
631:46 - we're going to have to create a mapping
631:47 - to do this it'll look something like
631:49 - token id
631:51 - 2
631:53 - breed we're going to have to get our
631:54 - token id somehow
631:56 - and we're going to have to equal it to
631:58 - the breed
632:00 - so then our first question is okay well
632:02 - in order for us to assign this breed to
632:04 - the token id
632:05 - how do we actually get the token id well
632:07 - we're going to grab the token id by
632:09 - doing
632:10 - uin256
632:13 - new token id
632:15 - equals
632:17 - token counter
632:19 - and then
632:21 - we'll just set the token id to breed
632:23 - using this new token id equal to the
632:25 - breed so we're going to want to make
632:27 - this token id to breed
632:30 - mapping up here
632:31 - so which we can do
632:33 - mapping
632:35 - uint256
632:37 - map2
632:38 - breed
632:39 - and we'll call it
632:40 - tokenid to breed this way each token id
632:43 - is going to have
632:45 - a very specific breed based off of this
632:47 - mapping's results perfect okay what else
632:49 - do we need in this fulfillment we need
632:51 - to mint the nft and we need to set a
632:54 - token uri well when we minted it before
632:57 - we call this safement function however
632:59 - message.sender here is always going to
633:01 - be the vrf coordinator since the vrf
633:03 - coordinator is actually the one calling
633:05 - this fulfill randomness so we can't
633:07 - actually have this just be
633:08 - message.sender we need to figure out how
633:11 - we can get the original caller of create
633:14 - collectable here how do we get
633:16 - the original message.sender of create
633:18 - collectable
633:19 - well the answer there is actually going
633:21 - to be in another mapping when we call
633:22 - create collectable we can create a
633:25 - mapping of request
633:27 - id
633:28 - to
633:28 - [Music]
633:29 - sender and this is going to take the
633:31 - request id as a key
633:34 - and then whoever sent it as the value
633:38 - so we're going to create this new
633:39 - mapping at the top
633:43 - and then actually let's make this other
633:45 - mapping public as well
633:47 - we'll do
633:48 - mapping bytes32
633:50 - to
633:52 - address
633:54 - we'll call this public
633:56 - request id
633:57 - to
633:58 - sender now in our fulfill function the
634:02 - same request id that requested the
634:04 - random breed is returned so what we can
634:07 - do is we can say address
634:10 - owner
634:11 - or sender
634:13 - is going to equal
634:14 - request id to sender
634:20 - of request id
634:22 - and then this address owner is who we're
634:24 - going to safemint the nft to and of
634:26 - course while we're matching up the
634:28 - functions we don't want to forget to
634:29 - always do token counter equals token
634:31 - counter plus one at the end
634:33 - awesome now we still need to set the
634:35 - token uri here
634:37 - so back in our advanced collectable
634:39 - we're gonna have to do this set token
634:41 - uri at some point so let's actually
634:43 - think about this for a second
634:45 - we're only going to know breed of our
634:47 - dog once this random number is returned
634:50 - and we know the breed of the dog is
634:51 - going to be one of these three breeds
634:53 - it's going to be a bug a shiba inu or a
634:55 - saint bernard and let's actually for now
634:57 - let's even just go ahead and add those
634:59 - three images to our project here create
635:02 - a new folder
635:03 - we'll call it image
635:05 - and you can put whatever images you want
635:07 - here i'm actually just going to download
635:09 - i'm actually just going to download the
635:10 - three images right from
635:12 - the nft mix boom and now i have my pug
635:16 - my shiba inu and my saint bernard in
635:18 - here so anyways it's going to be a pug
635:21 - shipping in you or a saint bernard here
635:23 - we're only going to know what the breed
635:24 - is once the random number is returned
635:27 - and the breed is actually going to
635:28 - govern if it's a pug ship in you or a
635:31 - saint bernard so we technically could
635:34 - actually just get rid
635:36 - of the input parameters for crate
635:38 - collectible since there's going to be no
635:40 - token uri initially created what we
635:42 - could do is we could create a new set
635:44 - token uri function that sets the token
635:47 - uri based on
635:50 - the breed of the dog for the simplicity
635:52 - of this project we're actually just
635:53 - going to create our own set token uri
635:55 - function that we're going to update
635:57 - based off the breed of the dog a
635:59 - challenge for you after we finish this
636:01 - project is to make this even more
636:03 - decentralized and have the fulfill
636:04 - randomness function actually
636:06 - be the one to decide what the token uri
636:09 - is but for now in our fulfill randomness
636:11 - function we're going to skip setting the
636:13 - token uri and we're actually going to
636:15 - call it in a separate function we're
636:17 - going to create our own
636:19 - function called set
636:20 - token uri
636:22 - and we're going to pass it a uin256
636:25 - token id
636:27 - a string
636:28 - memory
636:30 - token uri
636:31 - and we're going to make this a public
636:33 - function once this fulfill randomness
636:35 - function is responded the breed of the
636:37 - dog is going to be set right this token
636:39 - id to breed is going to say hey this
636:41 - token id
636:42 - now is associated with this breed which
636:44 - is going to be pug shiba inu or saint
636:46 - bernard all we want to do then is now
636:48 - that we have the on chain metadata we're
636:50 - just going to reciprocate that with the
636:52 - off chain metadata so we're going to
636:54 - need three token uris for those three
636:57 - dogs we're going to need one for pug
636:59 - ship inu and then obviously saint
637:01 - bernard however we want to make it so
637:03 - that only the owner of the token id can
637:06 - actually be the one to update the token
637:08 - uri
637:09 - so we can use a require function for
637:10 - this we can say require and we're going
637:12 - to use an imported open zeppelin
637:14 - function called is approved or owner
637:20 - message sender
637:23 - token id
637:25 - and we're gonna do comma here
637:27 - erc 721
637:30 - caller
637:31 - is not owner nor approved
637:34 - this is approved or own a function if we
637:37 - go into the erc 721 github for open
637:40 - zeppelin
637:41 - we can find this this function is
637:44 - approved or owner which checks the owner
637:47 - of the erc721 of that token id and it
637:49 - makes it so that only the owner or
637:51 - somebody approved to work with this
637:54 - token id can actually change the token
637:56 - uri so then we're just going to call
637:58 - that function called set token uri of
638:02 - the
638:03 - token id
638:04 - and the token uri now we're actually
638:07 - manually going to be the ones to call
638:08 - this set token uri once the breed has
638:10 - been decided we could of course like i
638:12 - said use a mapping at the top that
638:14 - automatically routes it there but so
638:16 - that we can experiment a little bit more
638:18 - and learn a little bit more about ipfs
638:20 - we're gonna leave it a little bit more
638:21 - general like this and perfect this is
638:24 - pretty much the majority of what we're
638:25 - going to need for our erc 721 contract
638:28 - obviously we still need to work with
638:30 - ipfs and getting our token uri but for
638:32 - the most part this is everything that we
638:34 - need now i do i am going to introduce a
638:36 - new best practice here whenever we
638:38 - update a mapping typically a good best
638:40 - practice is going to actually be to omit
638:42 - an event so let's create an event for
638:45 - each one of these mapping updates we'll
638:47 - call it event
638:50 - requested collectible
638:53 - and we'll do a bytes32
638:55 - indexed
638:58 - request id
639:00 - and we'll also do a
639:03 - address
639:05 - requester this requested collectible
639:08 - event is going to be omitted when we
639:10 - request id to sender because we're
639:12 - updating the mapping here this is also
639:14 - going to be really helpful when we run
639:15 - our tests so we can get this request id
639:17 - similar to what we did with the lottery
639:20 - so down here we're going to do omit
639:22 - requested collectible let's collect
639:25 - dibble here
639:26 - let's use an i instead of an a here
639:30 - collectible
639:31 - and we'll pass it
639:33 - this request id
639:35 - and then message.sender
639:38 - we also update a mapping down here with
639:40 - tokenid to breed
639:42 - so we're going to do a new event
639:45 - we're going to call event
639:48 - breed assigned
639:50 - and we'll do uint256
639:53 - indexed
639:55 - token id
639:58 - and then we'll do a breed
640:00 - breed
640:01 - and then when we assign the breed here
640:05 - we're going to omit
640:07 - breed assigned
640:09 - with
640:10 - new token id
640:13 - and breed
640:15 - so let's see if we did everything right
640:16 - let's do brownie compile
640:18 - looks like we have a quick error here
640:21 - did you mean fee or fee
640:23 - let's
640:24 - do a quick underscore there
640:28 - now let's try to compile
640:32 - much nicer all right great let's move on
640:35 - all right so now let's take a little
640:36 - look-see at our scripts here so we have
640:38 - this deploy and create script which is
640:40 - going to work for our simple collectable
640:42 - so let's go ahead and actually give them
640:44 - both their own folder so we're going to
640:46 - do a new folder
640:47 - we'll call one simple
640:50 - collectible
640:53 - and we'll do another new folder
640:55 - called advanced
640:58 - collectible and we'll grab this original
641:01 - deploy and crate and we'll place it into
641:03 - this simple collectable folder here
641:07 - awesome
641:08 - now if we wanted to run this we would do
641:10 - brownie
641:12 - run scripts
641:13 - simple collectible deploy and create and
641:16 - we can go ahead and test this out on our
641:18 - local ganache here
641:20 - and cool looks like it's working
641:22 - correctly great so now let's create our
641:24 - advanced collectable script and a lot of
641:26 - what we're going to do is going to be
641:28 - the same as this simple one deploy and
641:30 - create so i'm actually going to copy
641:31 - this
641:33 - we're going to create a new file called
641:35 - deploy and create
641:37 - dot pi we're going to paste everything
641:39 - in here but we are going to change a
641:40 - couple things up so let's do a little
641:42 - bit of refactoring first so this opencrl
641:46 - we're going to be accessing in a couple
641:47 - different scripts so we're actually
641:49 - going to take this
641:51 - copy it
641:52 - get rid of it in our deploy and create
641:54 - here
641:55 - and we're going to move it to our
641:56 - helpful scripts
641:58 - and place it under here openc url equals
642:01 - this script right here
642:02 - and now what we do in our simple
642:06 - deploy and create
642:07 - is we're going to do from
642:08 - scripts.helpfulscript
642:10 - import
642:11 - openc url
642:13 - we're going to delete that here
642:17 - so now in this script
642:19 - this openc url is going to come from our
642:22 - helpful scripts which is what we want
642:24 - and we're going to do the same thing for
642:26 - our deploying create for advanced
642:29 - okay great so i've now copied and pasted
642:32 - all the code from deploying create into
642:34 - this deploy and create for our advanced
642:35 - collectable so let's go ahead and modify
642:37 - this now
642:38 - so instead of from brownie import simple
642:40 - collectible we're going to import
642:42 - advanced
642:44 - collectible
642:47 - and we're going to do the same thing
642:49 - down here
642:50 - and i'm just going to go ahead and
642:51 - delete everything
642:53 - before this we're going to change this
642:55 - to advanced
642:58 - collectible
643:00 - and awesome okay this is going to be our
643:02 - starting point and we actually we can
643:03 - even get rid of this sample token uri
643:06 - great so this is going to be our new
643:08 - starting point we've done a little bit
643:09 - of refactoring now openc url is going to
643:12 - be in the helpful scripts we're pulling
643:14 - in advanced collectible instead of
643:16 - simple collectable and the rest applies
643:18 - we're still using our get account to get
643:20 - the account and now we have this
643:22 - advanced collectible equals
643:23 - advancedcollectable.deploy
643:25 - of course
643:27 - our advanced collectable has a different
643:29 - constructor
643:30 - it's got a vrf coordinator a link token
643:33 - a key hash and a fee so we're going to
643:35 - have to add those
643:38 - as the parameters in here we want to
643:39 - work with ringpi for this because the
643:41 - openc marketplace right now for test
643:44 - nets only works with rinkby so that's
643:46 - why we're going to work with ringby here
643:47 - so let's get started and just grab those
643:49 - ringpie addresses first
643:50 - so our advanced collectable needs a vrf
643:53 - coordinator and a link token so if we
643:55 - head over to the chainlink documentation
643:58 - we go to contract addresses for the vrf
644:02 - we can scroll down to
644:04 - rank b
644:05 - we'll grab the vrf coordinator here and
644:07 - same as before
644:10 - we'll jump into our browning config
644:12 - we'll do
644:13 - networks
644:15 - rinkaby
644:17 - and we'll do vrf
644:19 - core did nator
644:20 - we're also going to need the
644:22 - link token here
644:24 - so we'll do link token
644:27 - we need the key hash
644:30 - key hash
644:35 - and we need the fee which is going to be
644:37 - 0.1 link which we can do fee as one one
644:42 - two three four five six seven eight nine
644:43 - ten one two three four five six seven
644:45 - which can be 0.1 you can of course just
644:48 - copy and paste brownie configs over to
644:50 - different projects because
644:52 - because these values are always going to
644:54 - be the same now on our advanced
644:56 - collectable deploy and create we can go
644:57 - ahead and add those variables in here
645:00 - since we're going to be interacting with
645:01 - actual contracts that are on chain and
645:03 - we're going to want to be able to flip
645:04 - back and forth between the mock versions
645:06 - of them we're going to bring back that
645:08 - get contract function that we used
645:09 - before this is the function that's going
645:11 - to be smart enough to know if we need to
645:13 - deploy a mock or just grab from an
645:15 - actual contract i'm going to show a
645:17 - little fast forward of me rebuilding
645:19 - this function but feel free to copy and
645:21 - paste it from our last project now
645:23 - something that we do need to talk about
645:24 - though is our deploy mocks function the
645:27 - syntax here is going to be basically
645:28 - exactly the same however we do need to
645:31 - deploy a couple of mocks so make sure
645:33 - you have these in your deploy marks
645:34 - function
645:35 - specifically we're going to need a mock
645:37 - link token and a mock vrf coordinator
645:40 - and again feel free to just grab these
645:42 - from our last projects
645:54 - and then of course be sure to add your
645:56 - contract to mock dictionary where the
645:58 - link token is mapped to the link token
646:01 - and the vrf coordinator is mapped to the
646:03 - vrf coordinator if you guys look in the
646:05 - github repo there's a couple try catches
646:07 - there that just make it a little bit
646:09 - nicer for error handling
646:10 - but this is basically the entire script
646:13 - so now what we can do we can go back to
646:15 - our advanced collectable deploy and
646:17 - create
646:18 - import this get contract from our
646:21 - helpful scripts
646:23 - and we'll just replace this with get
646:25 - contract
646:26 - vrf coordinator
646:30 - get contract
646:32 - link
646:34 - token and then for key hash and fee
646:38 - since these don't really matter these
646:39 - can be whatever we want and these aren't
646:41 - really contracts
646:43 - we can go back to our config
646:45 - we'll add
646:47 - the development network and we'll just
646:49 - add key hash
646:52 - and fee
646:54 - and again since it's just testing we can
646:56 - just go ahead and make them exactly the
646:58 - same as ring b
647:02 - done a lot of work now let's go ahead
647:04 - and run this on the development network
647:06 - again so we'll do brownie
647:08 - run scripts
647:09 - advanced
647:11 - deploy and create
647:13 - no network so it's going to default to
647:14 - development let's see what happens here
647:17 - and awesome so we can see we actually
647:18 - did a couple of things here
647:20 - so first we deployed this mock link
647:23 - token
647:24 - then we deployed our mock vrf
647:25 - coordinator
647:27 - we finished that and then we deployed
647:30 - our advanced collectible all on a local
647:32 - network so let's go ahead and continue
647:34 - here once we deploy this code we're
647:36 - going to want to fund this contract with
647:39 - some link the reason we're going to want
647:41 - to fund it with some link of course
647:43 - is that we can call the random number i
647:45 - like to have my funding with link also
647:47 - in a function so we'll do fund with link
647:50 - and we'll give an address
647:52 - advancedcollectable.address
647:54 - and let's go ahead and create this
647:56 - function in fastforward we're going to
647:57 - fast forward this as well but feel free
647:59 - to copy and paste your fund with link
648:02 - functions from past projects or if you
648:04 - want to slow this down and follow along
648:06 - feel free to do that too
648:07 - let's go back to our deploy and create
648:09 - we now have this fund with link that
648:11 - we're going to do right here and then
648:13 - all we have to do now
648:14 - is call our create collectable function
648:17 - here so we'll just do advanced
648:18 - collectible
648:20 - dot
648:23 - create collectible
648:25 - of course
648:26 - from
648:28 - account
648:30 - and we'll do
648:32 - creating tx
648:35 - we'll wait one block confirmation
648:39 - and then we'll print
648:45 - your token has been created
648:49 - so we are definitely going to want to
648:51 - test this because we have a number of
648:52 - custom scripts here right
648:55 - so let's go ahead and just do a manual
648:57 - test
648:58 - so we'll do brownie
648:59 - run scripts
649:02 - advanced collectible
649:04 - deploy and create and we'll do it on a
649:06 - development network
649:08 - whoops we got to add ether here sorry
649:11 - about that in the web 3.2 way one ether
649:14 - so let's go ahead and run this script
649:15 - again
649:17 - and all right it looks like everything
649:19 - worked everything was deployed new token
649:21 - has been created
649:23 - great this is fantastic now ideally
649:25 - before we do an integration test we
649:27 - would of course write some tests but i
649:30 - want to teach some things that are
649:32 - easier to demonstrate on an actual test
649:34 - net so we're going to go ahead and
649:35 - deploy this to an actual test dent
649:37 - before we write our tests so we're just
649:39 - going to run the script again
649:41 - and do dash dash network
649:44 - rank b
649:48 - and awesome a new token has been created
649:50 - so what we can do
649:53 - is we can grab the contract address once
649:55 - again
649:57 - we'll paste it into the rank b ether
649:59 - scan
650:00 - and we can see everything in here we can
650:02 - see we've given it a little bit of link
650:05 - we can see our two function calls one is
650:08 - going to be the contract creation one is
650:09 - going to be create collectable
650:11 - our contract has already been auto
650:13 - verified actually because i verified
650:16 - this contract on rank b already and
650:19 - etherscan says ah this bytecode is the
650:22 - exact same of another contract that
650:24 - we've already verified and if we go to
650:25 - read contract and we go to token counter
650:28 - we'll see
650:29 - one token has been created
650:31 - we've actually created our first token
650:34 - now what we can do in our advanced
650:36 - collectable scripts we can create a new
650:38 - script and just call it create
650:39 - collectable
650:42 - dot pi
650:44 - and in here we'll just create a
650:46 - collectable
650:47 - so well all we have to do is we'll do
650:49 - def main per usual
650:51 - we'll have to do from
650:53 - brownie
650:55 - import advanced
650:57 - collectible
651:00 - we'll import accounts from our helpful
651:03 - scripts
651:08 - we'll import
651:10 - fund with link
651:12 - in our main function we'll do account
651:14 - equals get account
651:17 - of course we need to import this as well
651:20 - for my helpful scripts
651:23 - then we'll do
651:24 - advanced
651:27 - collectible
651:29 - equals
651:30 - advanced collectible minus one because
651:32 - we just want to get the most recently
651:33 - deployed we'll fund this contract with
651:36 - link so we'll do advanced
651:37 - collectible.address
651:39 - and we'll also choose an amount here
651:41 - we'll just do web3.2
651:44 - way
651:45 - of 0.1
651:47 - with ether
651:48 - that means we also have to do from web3
651:51 - import
651:52 - web3
651:53 - then
651:54 - we'll do transaction
651:56 - then we'll do
651:59 - creation transaction
652:02 - equals
652:03 - advanced collectible
652:05 - dot create
652:06 - collectible
652:11 - from
652:13 - account
652:15 - we'll do creation transaction dot wait
652:18 - we'll wait one block confirmation
652:21 - and then we'll print
652:23 - collectible
652:25 - created
652:28 - oops sorry i actually don't have to
652:29 - import account here or accounts excuse
652:32 - me
652:33 - and sorry this actually needs to be
652:34 - amount equals excuse me
652:37 - now let's go ahead and run this and what
652:39 - we're going to do
652:40 - is we're going to fund our advanced
652:42 - collectible with link which is 0.1 link
652:45 - and then we're going to create a new nft
652:54 - awesome collectible created so if once
652:56 - again
652:58 - we take this address
653:00 - go back over to etherscan
653:02 - do a quick refresh here
653:04 - we go to our contract read contract
653:10 - we'll look at the token counter it may
653:12 - still be one so you might have to give
653:14 - it a second for the chain link vrf to
653:16 - respond
653:19 - once the chain vrf responds we'll see 2
653:22 - in here we can also check the token id
653:24 - to breed
653:25 - if we look at 0 with 1 we'll see the
653:27 - breed
653:29 - is 2.
653:30 - and if we look back at our contract
653:33 - the advanced collectible without soul we
653:35 - know that if the breed is two that means
653:37 - it's a saint bernard
653:39 - see the token id of one
653:42 - it has a breed of one so it got randomly
653:44 - assigned a shiva inu
653:46 - awesome so we have tokens and they're
653:48 - get randomly assigned breeds fantastic
653:51 - as you can see we're doing kind of a lot
653:52 - of manual testing work here right so
653:55 - what we're probably going to want to do
653:56 - instead is you guessed it automate these
654:00 - tests
654:01 - now go ahead and want to deploy dance
654:03 - import that deploy script that we just
654:05 - wrote
654:06 - so we would do
654:08 - from scripts
654:10 - dot advanced collectible
654:12 - dot deploy and create
654:14 - import deploy and create
654:18 - and then all we have to do is call
654:21 - deploy and create
654:24 - in this function we'd probably want to
654:26 - then return the advanced collectible
654:28 - contract so we can make sure that we
654:30 - actually get what we want here
654:32 - so we'll say advanced collectible
654:35 - equals deploy and create
654:38 - and that'll be our acting
654:41 - step
654:42 - beginning we'll do arrange
654:46 - then we'll do an assert
654:47 - of
654:50 - we'll just check to see
654:51 - that the token counter has been
654:53 - increased we'll do assert
654:55 - advanced collectible
654:58 - the token counter
654:59 - is equal to one all right great so this
655:02 - will return our advanced collectable
655:04 - however we know that since we're
655:05 - actually going to be working with a mock
655:07 - vref coordinator if we look at our
655:09 - advanced collectible
655:11 - we know that the bulk of the work
655:13 - actually comes in this fulfill
655:14 - randomness function and we're going to
655:16 - have to tell our mock to actually return
655:18 - and call this function so in order to do
655:21 - that we should probably also return this
655:23 - creating transaction here so that we can
655:25 - get the request id remember how in our
655:27 - lottery we actually just directly called
655:29 - everything
655:30 - and we needed this request id to call
655:32 - this callback with randomness function
655:35 - in our test here we're actually using
655:36 - our scripts a little bit so we could
655:38 - either just go ahead and write out all
655:40 - the steps similar to what we did in the
655:42 - lottery or we could adjust our scripts a
655:44 - little bit for simplicity here we're
655:46 - just going to go ahead and have this
655:48 - deploy and create function also return
655:50 - the creating transaction this way we can
655:52 - go ahead and get the request id so back
655:55 - in our test here that means we have to
655:56 - do deploy and create
655:58 - equals advanced collectible and
656:02 - creation
656:05 - transaction now that we have this
656:07 - creation transaction we can use it to
656:09 - get our events
656:10 - and again if we look back in our
656:12 - advanced collectible we can see here
656:15 - that we're omitting this requested
656:16 - collectible with request id so we can go
656:19 - and do request id
656:22 - equals creation transaction dot events
656:28 - we'll add the name
656:32 - of our event here which is requested
656:33 - collectible and then we'll get
656:36 - that request id once we have this
656:38 - request id we can then go ahead and grab
656:41 - the vrf coordinator so from our scripts
656:44 - we'll grab this get contract
656:46 - and we've coded our get contract in a
656:48 - way that if the mock has already been
656:50 - deployed again if we go back to our
656:52 - helpful scripts if the contract has
656:55 - already been deployed then we're just
656:57 - going to go ahead and grab it so since
656:59 - here our mock will have already been
657:00 - deployed so we don't have to redeploy it
657:02 - so we can just do get contract
657:06 - vrf
657:07 - core did nator
657:10 - dot call back
657:14 - with
657:15 - randomness
657:17 - and we'll use the request id
657:20 - we'll pick some number like 777 we'll
657:23 - give it to
657:26 - the address of our advanced collectible
657:30 - and remember we're going to be calling
657:32 - the callback with randomness this is
657:34 - what a real chain link node is actually
657:35 - going to call back and it just needs a
657:37 - request id a randomness number and a
657:39 - consumer contract
657:41 - so request id random number and then the
657:44 - consumer contract
657:46 - and then of course we have to do a from
657:49 - account
657:51 - from get account
657:55 - and we'll import get account as well
657:59 - now we can move into our cert phase
658:02 - so first if this is correct then our
658:05 - token counter
658:07 - should be at least one so we can assert
658:11 - advanced collectible
658:12 - dot token counter
658:14 - is greater than zero
658:17 - or we could be a little bit more
658:18 - specific here
658:20 - equals equals
658:21 - one we also should technically be able
658:23 - to get the breed and figure out the
658:25 - breed of this first token of this first
658:28 - collectible let's go ahead and
658:30 - parameterize the 777 we'll call it
658:33 - random number
658:34 - equals 777.
658:36 - we'll place that here
658:39 - and then what we can do is we can say
658:41 - certain
658:44 - collectible
658:45 - dot token id
658:47 - to breed
658:49 - of zero
658:50 - right in our fulfill randomness we're
658:52 - going to assign the token id
658:54 - to being the breed and the breed is
658:56 - going to be this random number mod 3.
658:59 - so on our test we can say
659:01 - the token id to breed of dog 0 is going
659:04 - to be equal to
659:06 - random number
659:08 - mod
659:09 - 3 and this is pretty much our full test
659:12 - so let's go ahead and run this
659:17 - we can do that test with dash k
659:19 - whoops it looks like our simple test has
659:21 - actually got an error now we're getting
659:23 - this module not found no module named
659:26 - scripts.deploy.create
659:28 - this now since we actually changed it
659:30 - it's going to be
659:34 - scripts.simplecollectable.deploy and
659:35 - create
659:37 - so now if we rerun our test
659:39 - we'll see brownie isn't going to err out
659:41 - anymore
659:42 - so even though we skipped this test
659:44 - brownie still compiles it to make sure
659:46 - that everything makes sense but what we
659:48 - see here is fantastic our advanced
659:50 - collectible unit test has worked
659:52 - perfectly let's go ahead and make an
659:54 - integration test for our advanced
659:56 - collectible here so now we'll have our
659:58 - test folder here and we'll have unit and
660:00 - we'll have integration
660:02 - our integration test is actually going
660:04 - to look really similar to our advanced
660:06 - collectable here so i'm just going to go
660:07 - ahead and copy everything new file
660:10 - test
660:11 - advanced
660:13 - collectible
660:15 - integration
660:17 - pi
660:19 - and we'll just paste everything in here
660:20 - now the only thing that we're going to
660:21 - have to change is that we're not going
660:23 - to be the ones to call back with
660:24 - randomness here
660:26 - so we can remove this part
660:28 - we also don't need the request id
660:30 - anymore since the chain link node is
660:31 - going to be responding this means that
660:33 - the breed that we're going to get is
660:34 - actually going to be random so we can
660:36 - get rid of that assert as well all we
660:38 - need to do is wait for the transaction
660:41 - to get called back
660:42 - so we're going to import time
660:44 - and instead of us calling back with
660:46 - randomness
660:48 - we're just going to do
660:50 - time dot sleep
660:54 - then we'll wait 60 seconds
660:56 - test can create collectible we should
660:58 - also give this a different name
661:03 - integration
661:04 - now we should be able to test this on a
661:06 - ring b chain and our token counter
661:08 - should indeed increase with the chain
661:10 - link node actually responding so now we
661:12 - can run brownie test dash k
661:16 - just that test dash dash network
661:20 - rink b
661:22 - oh whoops right now we're skipping this
661:24 - because we're saying only for local
661:25 - testing now since this is going to be
661:28 - our integration test we're going to do
661:29 - the opposite
661:30 - if network.showactive is in these local
661:33 - blockchain environments then we're going
661:35 - to skip it and say only for
661:37 - integration testing
661:39 - all right great so now we have a quick
661:41 - and dirty integration test that we can
661:43 - run we're not going to run it for now
661:44 - because we're going to be working a lot
661:46 - with this rigby chain and we're going to
661:47 - be deploying a lot of different things
661:49 - and we don't want to wait so long so
661:51 - this is fantastic we have a way to
661:52 - deploy this we have a way to get these
661:54 - new collectible tokens and create them
661:57 - but if we were to take this address
661:58 - right now and try to view this token on
662:00 - something like openc
662:02 - we would get nothing back we wouldn't
662:03 - get any result right now our token
662:05 - doesn't have a way to be viewed or be
662:08 - visible by everybody else these mt
662:10 - platforms don't know what they look like
662:12 - and again this is where that set token
662:15 - uri is going to come into play
662:17 - so we have to figure out a way to host
662:19 - an image and host all the metadata for
662:22 - our token uri
662:23 - and the way that we're going to do this
662:25 - is by using
662:26 - ipfs and this is a lot better than
662:28 - actually hosting this on our own server
662:31 - because anybody can then go ahead and
662:33 - host this image or this metadata
662:35 - themselves
662:37 - now there's further improvements to this
662:38 - with something like filecoin
662:40 - where you actually pay to have your
662:42 - image hosted forever however ipfs can
662:44 - hook into filecoin in the future and is
662:46 - going to be a good enough solution for
662:48 - what we're looking to do here
662:49 - just keep in mind that what we do not
662:52 - want to do is run this on a centralized
662:54 - server when we spin up our ipfs node we
662:57 - will be the only node that actually runs
663:00 - and actually hosts our image however the
663:02 - image is open for anyone to pin to their
663:05 - nodes as well
663:06 - so it's much easier for us to host our
663:08 - images in a decentralized manner what's
663:11 - bad obviously is if we just had the
663:13 - image stored on our own centralized
663:14 - server because if our server goes down
663:17 - then that url no longer exists if at
663:19 - least one node on the ipfs network is
663:22 - hosting this image it will be available
663:24 - for anybody to see so that's why it's
663:26 - going to be a much better solution than
663:28 - some centralized server as i mentioned
663:30 - decentralized storage is a topic that's
663:32 - getting better and better and we're
663:33 - looking forward to seeing more and more
663:35 - ways to interact with them in any case
663:37 - we need to create an ipfs node that's
663:39 - going to host some data that looks like
663:41 - this or like what we saw with our simple
663:43 - collectable
663:45 - it needs to host metadata that will look
663:47 - like this we both have to host a
663:49 - metadata file and an image uri file
663:52 - which will host the actual image
663:54 - both of these need to be stored on ipfs
663:57 - so let's go ahead and create a new
663:58 - script called
664:00 - create
664:03 - metadata
664:04 - which will read off chain and create our
664:07 - metadata file so we'll start our scripts
664:09 - per usual
664:10 - with def main
664:17 - and we'll get the most recently deployed
664:19 - advanced collectible
664:24 - using this -1 syntax
664:26 - of course we're going to do from
664:29 - browning
664:30 - import
664:33 - advanced
664:34 - collectible once we have this advanced
664:37 - collectible we can then loop through all
664:39 - of the tokens and actually figure out
664:42 - the metadata for each one of them so
664:44 - we'll do
664:45 - number
664:46 - of advanced
664:50 - collect
664:52 - bowls
664:54 - equals
664:55 - advanced collectible.tokencounter
664:58 - because we want this crate metadata to
665:00 - create the metadata for every single
665:02 - token that we've created do a quick
665:04 - print line here just saying print
665:06 - you
665:07 - have created
665:12 - number of collectibles
665:14 - collectibles
665:17 - we even run this really quick brownie
665:19 - run scripts
665:21 - advanced
665:22 - create metadata
665:25 - network rank b since we've already run
665:27 - this on the ringpi chain
665:29 - we'll see you've created one collectible
665:31 - if i were to run our create collectable
665:33 - script again and then our create
665:35 - metadata script would of course get more
665:37 - but right now we only have one
665:38 - collectible
665:39 - now let's loop through all these
665:41 - collectables and create their metadata
665:43 - so we're going to create that that file
665:45 - it looks like this and it's going to
665:46 - have it's going to have the name which
665:48 - is going to be based off of the random
665:49 - breed that i got it's going to have the
665:50 - description which is based off of again
665:53 - the random breed that i got it's going
665:54 - to have an image which will also be
665:56 - based on the random breed that it got
665:58 - and i just put some attributes in here
666:00 - but again these attributes so we're
666:02 - going to say for each token id
666:06 - in the range
666:10 - of number of advanced collectibles
666:14 - for each one of these advanced
666:15 - collectibles
666:17 - first we need to get the breed so we're
666:18 - going to say the breed the breed is
666:20 - going to be equal to advanced
666:21 - collectible dot token id
666:24 - to breed
666:26 - of the token id
666:29 - now advanced collectible that token id
666:31 - to breed this is going to return an
666:33 - integer right because again our advanced
666:35 - collectible
666:36 - this enum breed is going to be 0 one or
666:39 - two so we actually want to create a
666:42 - quick mapping that represents that zero
666:44 - is pug one is shipped in u and two is
666:46 - saint bernard so i actually like to
666:48 - create this in a helpful script
666:51 - called def get breed
666:55 - and then it takes as an input it takes a
666:56 - breed
666:59 - number
667:00 - and it uses a switch statement so up top
667:03 - we'll say
667:07 - breed mapping
667:09 - equals
667:11 - zero is going to be pug
667:16 - one is going to be
667:18 - shiba inu
667:21 - and two
667:22 - is going to be saint bernard
667:26 - so in this get breed function now
667:29 - we can just do return
667:30 - breed mapping
667:33 - of that breed number that we get
667:36 - so
667:37 - instead of doing advanced collectible
667:38 - the token id to breed we can now just do
667:43 - get breed
667:45 - and this will this will return the
667:47 - number and this will return the actual
667:49 - string so we can just do from scripts
667:54 - dot helpful scripts import get
667:57 - read
667:58 - now that we have the breed we can start
668:00 - creating this metadata file now what
668:03 - we're going to want to do is we're going
668:04 - to want to have some type of format for
668:06 - our contract to always pull from so what
668:08 - i like to do here is i'll create a new
668:11 - folder
668:12 - called metadata
668:15 - and in this folder
668:17 - i'll have a new file
668:24 - called samplemetadata.pi
668:26 - and then i just have metadata
668:29 - template
668:30 - equals and i'll just have this this
668:33 - template that we're always going to use
668:35 - now in here we're going to need a name
668:38 - and then
668:39 - we're going to leave the name blank
668:41 - because we're going to want to fix it
668:42 - later
668:43 - we're going to have a
668:44 - description which we're also going to
668:46 - leave blank for now
668:48 - we're going to have that image uri which
668:51 - will also leave blank
668:52 - and then we're going to have some
668:54 - attributes which should be blank for
668:56 - this dog because we don't actually have
668:58 - any on-chain attributes but i'm just
669:00 - going to go ahead and add some to show
669:02 - you what you could do if you wanted to
669:04 - give your dog some stats you know maybe
669:06 - maybe cuteness maybe
669:08 - maybe raw power maybe speed agility you
669:10 - know whatever you want to do so we'll do
669:12 - trait
669:14 - type
669:15 - gonna be cuteness
669:17 - and then
669:18 - value is gonna be 100. this would
669:21 - basically say hey there's a trait type
669:23 - called cuteness and the value of that is
669:25 - a hundred so the cuteness of the dog is
669:27 - 100. so now once we have this sample
669:30 - metadata file we can import this into
669:32 - our script here so we'll say from
669:35 - metadata
669:37 - dot sample metadata
669:39 - import
669:41 - metadata template
669:43 - and another quick note you might have to
669:45 - put a underscore underscore init
669:47 - underscore underscore dot pi file in
669:49 - that metadata folder
669:51 - if you're working on older versions of
669:52 - python and we start creating our new
669:55 - metadata file for this break for this
669:57 - dog we want to save each collectible
670:00 - under their network and with their token
670:02 - id so let's go ahead and create a new
670:03 - folder
670:05 - call it rink b and this is where we'll
670:07 - save all of the rink b metadata for all
670:09 - these collectables for all these token
670:11 - ids now before we actually save it
670:13 - though we should just check to make sure
670:15 - that the file doesn't already exist
670:17 - right because if the file already exists
670:19 - that means we've already created the
670:20 - metadata for that token and we don't
670:22 - need to
670:23 - so we can just go ahead and get the
670:24 - metadata
670:26 - file name
670:28 - which is going to be equal to
670:31 - dot slash metadata
670:35 - slash network dot show active
670:39 - of course this means we need to import
670:42 - network from brownie
670:43 - slash
670:47 - the token id
670:50 - token id with a hyphen
670:53 - with the breed
670:56 - dot json
670:57 - just to make sure we're doing this right
670:58 - we can even just print this out
671:01 - do a quick manual test
671:04 - brownie run scripts
671:07 - advanced
671:09 - create metadata
671:11 - network rink b
671:13 - so this will be the name of the file so
671:15 - metadata rink b
671:17 - token id and then the
671:18 - breed.json okay cool now we can actually
671:21 - check this to see if this already exists
671:23 - and we're going to use a python library
671:25 - called path so we're going to say from
671:28 - pathlib
671:29 - import path
671:31 - and we're going to say if that path
671:34 - this metadata file name
671:36 - dot exists
671:38 - if that path exists
671:40 - we'll do a quick print saying
671:43 - metadata file name
671:45 - already
671:47 - exists
671:50 - delete it to overwrite
671:52 - this way we won't accidentally overwrite
671:54 - metadata that we've already created and
671:55 - do extra work so if it exists we'll
671:58 - print that out great otherwise
672:02 - we can go ahead and print
672:06 - print def
672:08 - creating metadata file
672:13 - metadata file name
672:16 - you can even run this real quick
672:21 - great you have one collectible
672:23 - creating metadata file perfect
672:26 - so let's go ahead and start creating
672:27 - this metadata file so we're have to give
672:29 - it a name description
672:31 - image uri and we're not gonna give it
672:33 - any attributes though so just name
672:35 - description and image uri so name is
672:37 - easy enough since this is a dictionary
672:40 - or a mapping in python we can actually
672:42 - just go ahead and start mapping so up
672:44 - above before this if
672:46 - we'll do
672:47 - collectible
672:49 - metadata it's going to be equal to
672:53 - this template
672:54 - so this is going to be where all we sort
672:56 - all of our metadata and we'll say
672:58 - collectible metadata of name
673:00 - is just going to be the breed so if it's
673:02 - a pug the name will be pog if it's
673:04 - shipped in you name it will be shipped
673:05 - in you if it's st bernard name will be
673:07 - saint bernard and we'll give it
673:10 - collection metadata
673:12 - description
673:16 - is going to be equal to
673:19 - we're going to do an f string here
673:21 - and adorable
673:24 - breed
673:27 - pop
673:30 - now if we print out this collectible
673:31 - metadata we should see
673:37 - at least the start of the metadata which
673:39 - we do great name saint bernard
673:42 - description and adorable saint bernard
673:44 - pup of course you'll have a different
673:45 - random breed but it should look
673:47 - something like this
673:48 - now we're going to need
673:50 - collectible metadata
673:53 - image uri
673:54 - this is where we're going to have to
673:55 - have our image already uploaded to ipfs
673:58 - so we can assign it to our metadata here
674:00 - so how are we going to do this well
674:02 - we're probably going to need some upload
674:04 - to ipfs function it's going to return
674:07 - our image uri and then we can just set
674:10 - that image uri to the collectible
674:12 - metadata
674:14 - of image
674:16 - so let's go ahead and start doing that
674:18 - let's create
674:19 - our upload to ipfs function now in order
674:23 - to upload to ipfs we of course need to
674:25 - have the images ourselves i already have
674:27 - them downloaded here and again you can
674:29 - download them right from the github
674:30 - yourselves if you like to make this a
674:32 - little bit generic we'll have this
674:34 - upload to ipfs take a file path
674:36 - that way we can pass
674:38 - this imagery upload to ipfs we're going
674:41 - to give it some type of file path here
674:43 - we're going to have to grab that image
674:44 - path so we'll grab that image file name
674:48 - by just doing breed
674:53 - dot lower
674:57 - because right now our breeds are all
674:59 - upper case so we're going to want to
675:01 - make a lower case then we're going to
675:02 - replace
675:05 - the underscores with
675:07 - hyphens
675:08 - dot png
675:12 - so we'll say plus
675:15 - dot png
675:16 - and then you know let's just go ahead
675:18 - and add the full path here so we'll say
675:21 - dot slash image
675:23 - slash
675:25 - plus
675:26 - 3. lower perfect
675:29 - so and then we'll even change this
675:30 - to image path and then we can pass this
675:35 - to our upload to ipfs so this file path
675:38 - now is going to be the location of the
675:40 - object that we're going to upload to
675:41 - ipfs we're going to use this path
675:43 - library to actually grab that path to
675:45 - upload it to ipfs so we're going to say
675:47 - with path
675:50 - file path
675:51 - dot open
675:53 - rb
675:54 - as file path
675:56 - now this is a little bit of
675:57 - sophisticated python here what we're
675:59 - doing is we're taking this path here
676:02 - we're opening the file rb means we're
676:05 - going to open it in binary since these
676:07 - are images that's how we're going to
676:08 - actually
676:09 - open it and we're going to upload the
676:10 - binary actually to ipfs and then as fat
676:13 - fp so we're saying this opened file
676:16 - is going to be named fp or file path
676:19 - we're going to do image
676:21 - binary
676:22 - equals fp.read
676:24 - and that's how we actually read the
676:26 - whole binary and now this whole image is
676:28 - stored as binary in this image binary
676:30 - here now here's where we're going to do
676:33 - the upload stuff now to get started here
676:36 - we're actually going to have to download
676:37 - the command line for ipfs download
676:41 - command line ipfs
676:44 - we'll come right to the docs here and
676:46 - again there's going to be a link
676:48 - in that github and in here there are
676:49 - instructions to
676:51 - to download it for whatever system that
676:53 - you're working on right if you're
676:54 - working on windows if you're on linux if
676:56 - you're on mac these are the different
676:58 - ways to actually download this ipfs
677:00 - command line you'll know you've done it
677:01 - right if you can type ipfs
677:04 - version and you see something like ipfs
677:06 - version 0.9.0 it's important to note
677:09 - that we could also do the ipfs download
677:12 - desktop
677:13 - and we could download the desktop
677:14 - version of this and we'd see a user
677:16 - interface which looks something like
677:18 - this we could upload our files manually
677:20 - and then manually go ahead and
677:22 - grab those files and place it into our
677:24 - scripts but we're engineers we want to
677:26 - do this programmatically in any case
677:28 - once we have this api downloaded we can
677:30 - actually follow the documentation here
677:33 - the http api reference for actually
677:35 - uploading our code we're going to be
677:37 - mainly working with this endpoint api v0
677:41 - slash add as this is the endpoint that's
677:42 - actually going to add our file or
677:44 - directory to ipfs now what we're going
677:47 - to want to do is we're going to actually
677:48 - upload our images to our own ipfs node
677:51 - we can run our own ips node by doing
677:53 - ipfs
677:56 - daemon and we'll see an output that
677:58 - looks something like this we can even
678:00 - see a web ui using this web ui url here
678:03 - this will look similar to what the ipfs
678:06 - desktop looks like but again we're going
678:08 - to work just mainly from this damien
678:10 - from our own ips note congratulations
678:12 - you're running your own ipf's node right
678:14 - now as you can see it's currently
678:16 - running on our own localhost right here
678:18 - http 127 0.0.1 at port 5001. so to
678:24 - actually upload this we're we first need
678:26 - to get that ipfs url
678:31 - which is going to be equal to
678:33 - this url right here
678:35 - paste
678:37 - now we want to make an api call or a
678:39 - post request to this
678:42 - endpoint
678:43 - using
678:44 - this
678:45 - api v0 ad and these are all the
678:47 - different parameters that this ad
678:50 - can actually take in
678:51 - so that we can actually post it to ipfs
678:54 - for those of you familiar with curl and
678:55 - you want to test this out using a curl
678:57 - i've added a curl into this create
678:59 - metadata file as a comment so that you
679:02 - can actually go ahead and test this if
679:03 - you want to use this now what we're
679:04 - going to want to do to keep working with
679:06 - our scripts
679:07 - is you should have like a little plus
679:09 - button somewhere on your vs code
679:11 - we're going to hit that plus button
679:13 - and now we're actually going to have two
679:14 - different shells one which is running
679:16 - our ipfs node
679:18 - and one which is running our bash or zch
679:20 - or whatever other shell that your os
679:23 - natively works with now that we have
679:24 - this ipfs url we're going to grab the
679:27 - endpoint
679:28 - which is going to be
679:30 - again this right here
679:34 - dash api dash v0 add
679:37 - and we can make a post request to it so
679:40 - for us to do that we're going to say
679:41 - response equals requests dot post
679:45 - we're gonna do the ipfs url
679:48 - plus the endpoint and we're gonna say
679:50 - the files that we're gonna upload
679:53 - is gonna be equal to
679:54 - file
679:56 - image binary
679:59 - requests is a python package that we're
680:00 - going to import so we're going to say
680:02 - import requests
680:04 - now if we go back to the ipfs
680:06 - documentation we can scroll down to see
680:08 - what the response looks like
680:10 - it's going to return a bytes
680:12 - a hash
680:13 - a name
680:14 - and a size
680:16 - now if we look at this sample
680:18 - token uri we can see the api call here
680:21 - ipfs stores all its data using a hash
680:24 - and if we're looking at this and if
680:26 - we're looking at the simple collectible
680:28 - this hash here
680:30 - is the hash that represents this
680:32 - pug.json file everything in ipfs gets
680:35 - hashed and every single piece of data
680:37 - has a unique hash which is why it's so
680:40 - fantastic if we were to change anything
680:42 - with this image this hash would be
680:44 - drastically different all we need to do
680:47 - is get the hash that ipfs gives the
680:49 - image that we upload we go ahead and
680:51 - plug it into a template url like this
680:53 - one here so what we're going to do then
680:55 - is we're going to say ipfsh
680:57 - it's going to be equal to
680:59 - this response.json
681:02 - since
681:03 - we're just going to jsonify the response
681:05 - to make it look like this response here
681:07 - and we're going to grab
681:10 - that hash
681:11 - right since it's going to return this
681:12 - dictionary
681:14 - we just want the hash here
681:16 - then
681:17 - we're going to give it a file name
681:20 - by saying it's going to be that file
681:22 - path
681:23 - dot split we're going to do some fancy
681:26 - python stuff here we're going to say -1
681:30 - to 0
681:32 - which basically all this line is doing
681:34 - is saying you know if we have dot slash
681:38 - image slash pug
681:40 - dot png
681:42 - we're going to remove
681:45 - we're going to split it up by these
681:46 - slashes
681:48 - into an array and we're going to grab
681:51 - the last part of the array so we're
681:53 - basically just
681:54 - changing this to this with this line
681:56 - right here then with this we can get the
681:58 - image uri which is going to be equal to
682:01 - an f string again
682:03 - https
682:05 - ipfs.io
682:07 - ipfs
682:09 - slash
682:11 - ipfshash
682:12 - question mark file name
682:15 - equals
682:18 - file name
682:19 - and it's this format right here which
682:22 - will give us
682:23 - this
682:26 - so if i go ahead and even just copy
682:28 - paste this under as a comment to show
682:29 - you guys
682:32 - we see this part's exactly the same
682:34 - and then this is that hash here
682:36 - represented here
682:38 - and then we have question mark file name
682:40 - equals
682:41 - and then the file name
682:43 - so excuse me this is actually gonna be
682:44 - like
682:45 - zero hyphen pug
682:47 - zero hyphen pod and that's exactly what
682:49 - we need we need this image uri so we'll
682:52 - do a quick print
682:54 - image
682:56 - image uri
682:58 - and then we'll go ahead and return
683:01 - the image
683:02 - uri
683:04 - now since we're actually going to be
683:06 - testing this with
683:07 - ipfs we can add a new integration test
683:10 - so we'll call this test
683:12 - ipfs
683:14 - upload.pi
683:16 - now you might want to write a test for
683:17 - this and we're not going to do one but i
683:20 - challenge you to later on maybe come
683:22 - back and and write your own test for
683:24 - this upload to ipfs
683:26 - for now we're actually just going to
683:27 - manually test it
683:29 - so we're going to go back up to our
683:30 - script here and we're going to run image
683:32 - uri equals upload to ipfs image path
683:36 - and then we're going to get printed in
683:37 - image url since we're working with the
683:39 - saint bernard here we should get a saint
683:42 - bernard image uri
683:44 - so if i run brownie
683:46 - run scripts
683:48 - advance
683:50 - create metadata
683:56 - network rink b
683:59 - let's see what happens i need to add
684:01 - brackets here sorry about that
684:03 - now let's try it again
684:05 - awesome we were able to create this
684:07 - metadata file
684:08 - now if we go ahead and copy this
684:11 - and paste it
684:13 - perfect we see exactly what we're
684:15 - looking for we see our saint bernard
684:17 - awesome job and this has been uploaded
684:19 - to our own ipfs node now i want to show
684:22 - you guys actually another service and
684:23 - another way we can actually upload these
684:25 - to ipfs some people don't want to run
684:27 - their own ipfs node because they're not
684:29 - actually going to be keeping it running
684:31 - the whole time anytime their node goes
684:33 - down this means that nobody will be able
684:36 - to see your image unless somebody else
684:38 - pins your image or or uses your image so
684:41 - what i also like to do is i like to
684:43 - upload it to some other third-party
684:45 - service as well as uploading it to my
684:48 - own ipfs note so i like to create
684:50 - another script actually called
684:52 - deploy to pinata
684:54 - so let's go to scripts new file
684:58 - upload to
685:00 - pinata.pi
685:02 - so pinata
685:03 - pinata is an ipfs file management
685:06 - service and they actually will pin
685:08 - whatever files that we're working with
685:09 - as well so we'll have it pinned in our
685:11 - node and they will have it pinned as
685:13 - well so we can go ahead and register
685:19 - awesome this is what pinata looks like
685:22 - it's a way to upload and work with ipfs
685:26 - and they'll give us some extra support
685:27 - and they have a free tier which is
685:29 - fantastic as well they have some
685:31 - wonderful documentation as well under
685:32 - this documentation section so let's go
685:35 - ahead and upload this to ipfs so that
685:37 - when our node goes down our images don't
685:39 - go down so we'll do pinata
685:42 - base
685:44 - url
685:45 - is going to be equal to
685:48 - https dash dash api.pinata.cloud
685:53 - you can find all this in the
685:54 - documentation as well if we scroll down
685:57 - the documentation we're going to be
685:58 - using this pin file to ipfs endpoint
686:01 - here and you can see that entire
686:03 - endpoint right here
686:05 - with the base and then the endpoint so
686:07 - we're going to copy that endpoint
686:09 - we're going to say endpoint
686:11 - equals
686:12 - pinning
686:13 - pin file to ipfs we're going to choose
686:16 - some file path
686:19 - and for us we're just going to do dot
686:21 - slash image
686:23 - slash
686:24 - pug.png
686:26 - of course if you want to upload some
686:27 - other image you can you know change this
686:29 - file path or you could even do some type
686:32 - of for loop to pin everything uh in the
686:35 - image section here again we're going to
686:37 - do file name we're going to use that
686:38 - same syntax before that's
686:41 - we're doing file path
686:43 - dot split
686:45 - slash
686:47 - some fancy python stuff
686:50 - just to get
686:51 - this last part and we also need and we
686:54 - need to use some headers in this post
686:56 - request so it's a type post request we
686:59 - need to use some headers here so we're
687:00 - going to say headers
687:02 - equals
687:05 - copy this pinata api key
687:08 - which is going to be some api key and
687:10 - then we also have this pinata secret api
687:13 - key pinata secret api key
687:16 - which is going to be something else
687:18 - we can find these two api keys if we
687:20 - scroll all the way down we hit api keys
687:23 - create a new api key
687:26 - i'm going to call this you can make this
687:28 - an admin key i'm just going to do limit
687:29 - max users
687:31 - limit max uses i'm going to set this to
687:33 - 200
687:34 - because i'm going to make this a public
687:36 - key so i don't want people using this a
687:38 - million times
687:39 - please make sure you select at least one
687:41 - permission
687:43 - pin file to ipvs for those of you guys
687:45 - watching you can absolutely just grab
687:47 - all these if you want you can make this
687:49 - an admin you know do whatever you want
687:51 - to do here since i'm only going to be
687:53 - using this pin file to ipfs that's all
687:54 - i'm going to do
687:56 - hit create key and here are our tokens
687:59 - here so our api key is going to be right
688:01 - here and we're going to copy that
688:03 - we're going to open back up that dot env
688:07 - and add this as one of our environment
688:09 - variables here so we're going to export
688:11 - pinata
688:12 - api key
688:14 - equal to that key there
688:16 - this api secret we're going to copy and
688:19 - we're going to export pinata api secret
688:24 - equals that key there
688:26 - and we actually don't need this
688:28 - jwt but if you guys wanted to you could
688:30 - copy it as well
688:31 - so now that we have them in our dot env
688:33 - file these are now going to be
688:35 - environment variables that we can use
688:37 - and brownie's going to automatically put
688:39 - them into our
688:40 - environment
688:41 - so what we can do then is we can do os
688:45 - dot get env
688:48 - pinata
688:51 - api key
688:53 - and then of course we're going to import
688:58 - import os
689:00 - and then
689:05 - for our secret key we're going to do the
689:07 - same thing os dot get env
689:11 - pinata api secret
689:15 - this is how we get those two headers for
689:17 - uploading to pinata then we're going to
689:19 - do a lot of the same code we did before
689:21 - we're going to say with path
689:23 - a file path dot open
689:26 - rb for the binary as fp
689:29 - of course since we're using path we're
689:30 - going to do from path lib
689:34 - import
689:36 - path
689:38 - we're going to do this same piece image
689:39 - binary
689:41 - equals fp.read
689:44 - response is going to be equal to
689:46 - requests which we have to import
689:48 - requests
689:50 - import requests
689:53 - dot post
689:56 - pin you have a base url
689:57 - plus that endpoint that we have
690:00 - and for files
690:02 - oops
690:04 - it's going to be equal to
690:07 - file
690:09 - and we're going to upload a couple of
690:10 - things here though we're going to give
690:11 - it a file name
690:13 - we're going to do the image binary and
690:15 - that is getting really annoying when it
690:16 - keeps getting in the way
690:18 - file name image binary
690:21 - and then outside of these brackets here
690:22 - we're going to do comma
690:24 - headers equals
690:28 - equals headers
690:30 - and then we're just going to print
690:35 - response.json so to have this run in
690:37 - browning we're just going to do a def
690:38 - main function here
690:40 - a nice little trick we can do is we can
690:42 - select all this text and just hit tab
690:45 - and it'll move it over one
690:47 - and perfect we can now run this inside
690:49 - of brownie
690:51 - so we can do brownie
690:53 - run scripts
690:54 - upload to pinata
690:56 - and perfect we get a little output
690:58 - that's going to look something like this
690:59 - it's going to give our ipfs hash the pin
691:01 - size the timestamp
691:03 - so now if we go back to pinata
691:06 - we go to pin manager
691:09 - do a little refresh here
691:11 - we now see
691:12 - our pug has actually been uploaded to
691:15 - pinata awesome work we're going to keep
691:16 - going using the ipfs daemon to actually
691:19 - upload things but if you want you could
691:20 - totally swap out this upload to ipfs to
691:23 - use that script that we just created to
691:25 - upload it via pinata instead of our own
691:27 - ipfs node anyways this upload to ipfs is
691:31 - going to return this image uri so we can
691:33 - go ahead then
691:35 - and set the image uri it's going to be
691:37 - set on this collectible metadata image
691:40 - and then all we have to do is dump this
691:43 - collectible metadata into its own file
691:45 - and then upload that as well to ipfs
691:48 - we'll dump this to its own file by doing
691:49 - with
691:51 - open
691:52 - metadata file name
691:54 - and we
691:55 - open it with a w which means that we're
691:57 - going to write
691:58 - as file
692:00 - json.dump
692:02 - collectable metadata to the file
692:05 - so we're going to import json to do this
692:08 - and what this is going to do is just
692:10 - going to dump this dictionary as json to
692:13 - this collectable metadata file then we
692:15 - can upload to ipfs also
692:17 - this metadata file name and this upload
692:19 - to ipfs should print out the image uri
692:22 - or in this case the metadata uri so
692:25 - let's go ahead and try this out
692:27 - so remember we do need our ipfs daemon
692:30 - running
692:31 - let's go back to our scripts and we'll
692:33 - do brownie
692:35 - run scripts
692:37 - advanced
692:38 - create metadata
692:40 - network
692:41 - rank b
692:42 - and boom okay so here is our image uri
692:47 - which we click this will be able to see
692:49 - looks just like this
692:51 - and then here is our uploaded
692:54 - saint bernard metadata file which is
692:57 - fantastic so now we have both a metadata
693:00 - file
693:01 - and we have an image uri
693:04 - this is fantastic we've uploaded both of
693:07 - these
693:07 - to our ipfs
693:09 - and if we scroll over
693:11 - go to our metadata file in ring b we'll
693:13 - see
693:15 - we have this new file in here because
693:17 - we've gone ahead and saved it in here
693:20 - it has everything that we need it has st
693:21 - bernard
693:22 - it has the description it has this image
693:25 - uri that we just created and it has some
693:27 - attributes that again we're basically
693:29 - ignoring now to make our lives a little
693:31 - bit easier and since i've already
693:33 - actually uploaded these to ipfs myself a
693:35 - couple times and since the hashes of
693:37 - these are going to be the exact same for
693:40 - all of us when we upload this we're
693:42 - going to go ahead and just quickly
693:43 - refactor this to make it a little bit
693:45 - easier so we don't always have to have
693:46 - ipfs running so in our dot env i'm going
693:49 - to add a new environment variable called
693:51 - upload
693:52 - ipfs
693:54 - and we're going to set it equal to false
693:56 - so now down here i'm just going to say
693:58 - if os dot get env
694:02 - upload
694:04 - ipfs
694:06 - equals equals true
694:08 - anyway since we're going to do os here
694:10 - we're going to do import os
694:12 - and before this i'm going to do
694:18 - image uri equals none
694:20 - and we're going to say
694:22 - image uri
694:24 - equals image uri if image uri which
694:28 - again i know this could be a little
694:29 - confusing but we're saying
694:31 - we're setting image uri to whatever
694:33 - image uri is if image uri isn't none
694:37 - else we're going to create a mapping
694:38 - called breed
694:40 - to
694:41 - image uri
694:43 - of the breed so again
694:45 - since i've already uploaded them i
694:47 - already know what all these image uris
694:49 - for these three dogs are going to be
694:51 - so up at the top we're just going to
694:52 - create a new mapping called breed to
694:55 - image uri
694:56 - equals
694:58 - i'm actually just going to go ahead and
694:59 - copy paste this whole thing
695:00 - now you can skip this you don't have to
695:02 - refactor here
695:04 - and you can just always have your daemon
695:05 - running and always upload to ipfs it's a
695:08 - little bit quicker to not always have to
695:09 - do that again this brief image uri is in
695:12 - the github repo feel free to just copy
695:14 - paste it to use it you can even click
695:15 - the links to check it to check to see
695:17 - that those image uris are really there
695:19 - and this is what we'll use
695:21 - so back down here reach the image uri
695:24 - uri perfect and then we're also going to
695:26 - add if
695:28 - again os.get
695:30 - env
695:32 - upload ipfs
695:35 - equals equals true
695:37 - then we're also going to upload to ipfs
695:39 - down here but this is to go and actually
695:41 - just show you how exactly we could
695:43 - upload all this stuff to ipfs since i've
695:45 - already done it we're going to make it a
695:46 - little bit easier on ourselves another
695:48 - thing that you might do is you might
695:50 - actually save
695:51 - all these urls to their own file to
695:54 - their own json object maybe inside of
695:56 - the metadata folder maybe under wrinkby
695:59 - or something
696:00 - and then you could go ahead and just
696:01 - pull directly from those files same
696:04 - thing with the metadata once we upload
696:06 - to ipfs we're not actually going to save
696:07 - these urls anywhere you could absolutely
696:10 - 100 percent
696:11 - after you run this upload to ipfs script
696:14 - we go ahead and save it to a file and
696:16 - pull directly from there moving forward
696:18 - but awesome okay so
696:20 - we've done a lot of work here we have
696:23 - uploaded to ipfs our metadata
696:26 - and our image uris so we have everything
696:29 - that we need to actually just set the
696:30 - token uri
696:32 - finally for our advanced collectible we
696:35 - finally can call this set token uri
696:38 - function so let's go ahead and do this
696:40 - last bit here this last set token uri
696:43 - function
696:44 - so let's go to scripts advanced scripts
696:46 - create a new file we'll call it set
696:49 - token uri
696:50 - uri dot pi
696:52 - and this is where we're gonna set the
696:54 - token uri so we'll do def main
696:57 - and in here we'll do a quick print print
696:59 - f
697:00 - working on
697:02 - network dot show active
697:06 - of course since we're using network
697:08 - from browning
697:10 - imports network
697:13 - to close that there and let's grab the
697:15 - most recent advanced
697:18 - collectible
697:20 - it's going to be equal to advanced
697:23 - collectible
697:25 - minus one
697:26 - since we're using advanced collectible
697:28 - contract let's import that from brownie
697:30 - let's once again loop through all the
697:33 - tokens that have been deployed
697:34 - so we'll do number
697:36 - of collectibles
697:39 - equals
697:40 - advanced collectible dot token counter
697:44 - do a quick print
697:47 - you have
697:49 - print f excuse me
697:54 - number of collectibles
697:56 - token ids
697:58 - and let's loop through this list of
697:59 - collectibles again so we'll say for each
698:02 - token id
698:05 - in range
698:08 - number of collectibles
698:11 - first we'll get the breed
698:13 - saying breed
698:15 - equals advanced
698:18 - collectible
698:20 - token id to breed
698:23 - of the token id
698:24 - we actually have to call this
698:26 - getbreed function again
698:28 - which luckily we generalize so we can do
698:30 - from
698:31 - scripts.helpfulscripts
698:35 - import
698:38 - get breed
698:41 - and now let's first before we actually
698:43 - set the token uri let's check to see
698:46 - if it already has a token uri set so
698:49 - we're going to say if not advanced
698:52 - collectible dot token uri
698:56 - of token id
699:00 - dot starts
699:03 - with
699:04 - https
699:07 - so what this line is doing i know it's a
699:09 - little bit long is we're grabbing
699:11 - advanced collectible.token uri
699:14 - of the token id so we're grabbing this
699:16 - token ids token uri
699:18 - and we're saying if it doesn't start
699:20 - with https that means we know that it
699:23 - hasn't been set
699:25 - so we can go ahead and print
699:29 - setting
699:30 - token uri
699:33 - let's actually make this a print f
699:35 - of
699:38 - token id
699:39 - and then we can set the token uri so i'm
699:41 - actually going to generalize this out
699:45 - into its own function
699:48 - so let's go ahead
699:50 - and we'll do def
699:51 - set
699:52 - token uri
699:55 - and as inputs this is going to take the
699:56 - token id
699:58 - the nft contract which is going to be
700:00 - our advanced collectible contract
700:03 - and the token uri so the first thing
700:05 - that we're going to do we'll say account
700:06 - equals get account
700:09 - so we're going to grab this
700:11 - get account of course
700:13 - from our helpful scripts
700:15 - because this set token uri is actually
700:17 - going to call that set token uri
700:19 - function we're going to say
700:21 - nft contract
700:22 - dot set
700:24 - token uri
700:27 - of the token
700:28 - [Music]
700:29 - and the token uri
700:31 - remember this is a function that we
700:33 - added to our advanced collectible right
700:35 - here set token uri it takes a token id
700:38 - and a token uri and this is going to be
700:40 - from of course
700:45 - account we just created so we're going
700:47 - to say
700:48 - transaction
700:50 - equals that we'll do transaction.wait
700:53 - wait one second for it or one block for
700:55 - it and then we'll print
700:58 - we'll do printf
701:00 - awesome
701:02 - you can view
701:05 - your nft at
701:08 - we use that openc url
701:13 - dot format
701:16 - nft contract.address comma token id
701:24 - then i'm just going to add another print
701:25 - here saying
701:27 - please wait up to 20 minutes
701:30 - and hit refresh
701:33 - metadata and hit the refresh metadata
701:37 - button
701:38 - so now we have our set token uri
701:40 - function
701:41 - we can add
701:43 - the token id in here
701:45 - the advanced collectible contract and
701:47 - then we just have to add the token uri
701:49 - here so since we've already uploaded and
701:52 - since i've already actually uploaded all
701:53 - three
701:54 - what you could do
701:55 - and what i like to do is just have a
701:57 - dictionary here so we don't always have
701:58 - to be pulling from something
702:00 - so i have a dog
702:03 - metadata
702:04 - dictionary it's going to be equal to and
702:07 - we're going to add those different dogs
702:08 - in here so saint bernard
702:10 - this this saint bernard url
702:13 - we're going to paste it here i've
702:14 - actually gone ahead like i said and
702:16 - uploaded this metadata for all three
702:18 - dogs
702:19 - so i'm just going to go ahead and copy
702:20 - paste all three in here
702:23 - again we're shortcutting a little bit
702:24 - here but what you could do is you could
702:26 - save all these metadatas to their own
702:29 - file and you could just pull from that
702:30 - file instead of doing kind of this dog
702:32 - metadata dictionary so in any case
702:35 - though we're going to do
702:37 - dog metadata dictionary
702:39 - of breed
702:40 - right because dog metadata dictionary of
702:42 - saint bernard is going to be this which
702:45 - again
702:46 - has
702:48 - our image uri has everything about our
702:50 - dog and is perfect what we also might
702:52 - want to do is write some tests around
702:54 - our set token uri function of course but
702:57 - i'm just going to move on so
702:59 - in any case we've done a lot here i'm
703:01 - actually going to even close down my
703:04 - ipfs node
703:06 - and we should be just about ready for
703:09 - everything
703:10 - so of course we'll run our brownie
703:13 - test
703:14 - we want to make sure that all our unit
703:16 - tests are working great
703:18 - which they look like they are working
703:19 - fantastically but we are ready to
703:22 - do a full end-to-end manual test here
703:27 - and you could 100
703:28 - and i actually highly encourage you to
703:30 - 100 we're just gonna run these scripts
703:33 - in order and look to see if our stuff
703:35 - shows up on the openc nft marketplace so
703:38 - are you guys ready let's do this so make
703:41 - sure of course your environment
703:43 - variables are set here make sure that
703:45 - your metamask
703:47 - for rink b
703:49 - has some eth and
703:51 - has some link and then we can go ahead
703:53 - and start running some of these scripts
703:55 - so we'll do brownie
703:57 - run scripts
703:58 - advanced collectible deploy and create
704:01 - network
704:02 - rink b integration test moment of truth
704:08 - and perfect a new token has been created
704:11 - awesome
704:12 - we can even go grab this address
704:15 - let's delete all these tabs that we have
704:17 - opened up
704:19 - and we'll go to ringpi.etherscan.io
704:23 - we'll paste it in here
704:24 - and we can see
704:26 - contract has been verified even though
704:28 - we didn't verify it because it matches
704:30 - some other source code we can see token
704:32 - counter is one and we can even go to
704:35 - tokenid to breed of zero see what breed
704:37 - it is
704:38 - so it's breed two and it looks like
704:40 - we're getting a saint bernard again
704:42 - which is incredibly adorable we can even
704:44 - go to events here and we can see the
704:47 - different events since this is verified
704:49 - we can even see the name of the events
704:51 - so we have our breed assigned event
704:54 - and we have our requested collectible
704:57 - event first is an index topic of token
704:59 - id and then there's the un8 read
705:02 - and then we have the bytes32 request id
705:04 - and the address requester now let's run
705:06 - our create metadata script here
705:09 - so we'll do brownie
705:11 - run scripts
705:12 - advanced
705:14 - create
705:15 - metadata
705:17 - network rink beam we don't have to run
705:19 - create collectible since our deploying
705:21 - crate already does that so now if we run
705:24 - our create metadata
705:27 - i've actually already have i actually
705:30 - since this is the same bernard again i'm
705:31 - going to go ahead and get this already
705:33 - exists delete to overwrite
705:35 - so what i'm going to do is i'm actually
705:37 - going to even create another one so that
705:39 - i get a new nft so i am actually going
705:42 - to run this crate collectible script so
705:43 - we're going to do brownie
705:45 - run scripts advanced collectible
705:48 - create collectible
705:50 - network rank b
705:54 - and what this is going to do all it's
705:55 - going to do is it's going to fund with
705:57 - some link
705:58 - which it's going to be a little bit
706:00 - overkill with the link but that's fine
706:02 - and then we're going to do advanced
706:03 - collectible.create collectable
706:05 - so we're just going to do two
706:06 - transactions here
706:08 - perfect collectible has now been created
706:11 - now i'm going to wait a solid 30 seconds
706:13 - to have that chainlink vrf respond
706:16 - and i'm even going to go to the contract
706:18 - give it a quick refresh look at this
706:20 - token counter once the chain-link vrf
706:22 - responds this token counter will then be
706:24 - 2. now that i see a token counter of 2
706:26 - here that means that it actually has
706:28 - responded so we can now run
706:30 - the create metadata script
706:33 - and we should have
706:36 - a new metadata file now you have two
706:38 - collectibles
706:40 - zero saint bernard already exists
706:41 - deleted to overwrite create a metadata
706:44 - file metadata ring b pug so now if we
706:46 - look in metadata
706:48 - for rink b we have a saint bernard and
706:51 - we now have a pug awesome so we're going
706:54 - to set the token uri of both of these if
706:56 - i grab this contract and i go to
706:58 - testnets.openc
707:03 - open c
707:05 - i can paste this address in
707:07 - and i'll get this doggy and then this
707:10 - random hash here right and we see there
707:12 - are two
707:14 - token uris deployed again if they're not
707:16 - here you might have to refresh but they
707:18 - don't have the images right because we
707:20 - haven't set the token uri so we'll go
707:22 - back look at the advanced collectible
707:23 - we've deployed and created we've created
707:26 - another collectible we've created their
707:28 - metadata now all we have to do is set
707:30 - the token uri
707:32 - so brownie run scripts
707:34 - advanced collectible
707:36 - set token uri
707:38 - network rink b
707:40 - and this script it's going to loop
707:41 - through
707:42 - all
707:44 - of them and actually going to set those
707:46 - token arrives so we have
707:48 - setting token uri of 0
707:50 - so this transaction is doing exactly
707:52 - that
707:54 - and it's going to go ahead and say
707:55 - awesome here's your output and then it's
707:58 - going to say setting token uri of token
708:00 - id one and that's that second
708:02 - transaction and it also gives us an
708:04 - output to that one as well
708:06 - so if we've done this correctly
708:08 - and we hit refresh metadata on this
708:11 - testnet openc.io
708:13 - and we do a little refresh here
708:15 - we can now see our saint bernard which
708:18 - is fantastic and then if we change
708:21 - this from 0 to 1 since i've deployed 2
708:24 - and i refresh this one's metadata and
708:26 - then refresh the page
708:28 - we can now see the pug as well
708:31 - again just keep in mind sometimes the
708:33 - refreshing metadata does take some time
708:35 - and you might have to wait up to 20
708:36 - minutes
708:37 - but for all intents and purposes we have
708:39 - just deployed our nfts given them token
708:43 - uris that aren't around centralized
708:45 - servers we can now see them on an nft
708:48 - marketplace like openc
708:50 - you can let out a big sigh of relief
708:52 - because you just did something fantastic
708:53 - that not a lot of other engineers can do
708:55 - you should be incredibly proud of
708:57 - yourself at this point let's take a
708:58 - minute go back over to some of the new
709:00 - things that we've learned here
709:06 - when deploying your smart contracts on
709:07 - chain we all know that those smart
709:08 - contracts are immutable or unchangeable
709:11 - but what if i told you that they were
709:13 - mutable
709:15 - well technically i wouldn't be correct
709:17 - however smart contracts actually can
709:19 - change all the time when people transfer
709:21 - tokens when people stake in a contract
709:23 - or really do any type of functionality
709:25 - those smart contracts have to update
709:27 - their balances and update their mappings
709:29 - and update their variables to reflect
709:31 - this the reason that they're immutable
709:32 - is that the logic itself never changes
709:34 - and will be on chain like that forever
709:37 - so technically yes once they are
709:38 - deployed they are immutable and this is
709:40 - actually one of the major benefits of
709:41 - smart contracts in the first place that
709:43 - nobody can tamper with or screw with our
709:44 - smart contracts once we deploy them
709:46 - however this can be an issue if for
709:48 - example we want to upgrade our smart
709:49 - contractor protocol to do more things or
709:51 - we want to fix some glaring bug or issue
709:54 - that we have now even though we can't
709:55 - change the specific code that's been
709:57 - deployed to an address we can actually
709:58 - do a lot more than you think we're going
710:00 - to explain the different methodologies
710:02 - behind upgrading your smart contracts
710:04 - and then we're going to show you how to
710:05 - do it now at first glance you might be
710:07 - thinking
710:08 - if you can upgrade your smart contracts
710:10 - then they're not really immutable then
710:14 - in a way you'd be right so when
710:16 - explaining kind of the different
710:17 - philosophies and patterns that we can
710:18 - use here we do need to keep in mind the
710:20 - philosophies and decentralization
710:22 - implications that each one of these
710:23 - patterns have as they do all have
710:25 - different advantages and disadvantages
710:27 - and yes some of the disadvantages here
710:30 - are going to affect decentrality so we
710:32 - need to keep that in mind and this is
710:33 - why it's so important that before you go
710:35 - ahead and jump in and start deploying
710:37 - upgradable smart contracts you
710:38 - understand the trade-offs we're going to
710:40 - look at three different ways to upgrade
710:41 - your smart contracts the not really
710:43 - upgrading method the social aka my
710:46 - grading method and then the method that
710:48 - you're probably here for which is
710:49 - proxies so let's talk about the not
710:51 - really upgrading method or the
710:53 - parameterization method or whatever you
710:54 - want to call it this is the simplest way
710:57 - to think about upgrading your smart
710:58 - contracts and it really isn't upgrading
711:00 - our smart contracts because we can't
711:02 - really change the logic of the smart
711:04 - contract whatever logic that we've
711:05 - written is there we also can't add new
711:07 - storage or state variables so this is
711:09 - really not really upgrading but it is
711:11 - something to think about upgrades is
711:13 - just parameterizing everything whatever
711:15 - logic that we've deployed is there and
711:17 - that's what we're interacting with this
711:18 - function means we just have a whole
711:20 - bunch of setter functions and we can
711:21 - update certain parameters like maybe we
711:23 - have a reward parameter that gives out a
711:25 - token at one percent every year or
711:28 - something like that maybe we have a
711:30 - center function that says hey update
711:31 - that to two percent or update that to
711:33 - four percent it's just a setter function
711:35 - that changes some variable now the
711:37 - advantages here are obviously this is
711:38 - really simple to implement the
711:40 - disadvantage is that if you didn't think
711:42 - of some logic or some functionality the
711:44 - first time you deployed their smart
711:46 - contract that's too bad you're stuck
711:48 - with it you can't update the logic or
711:50 - really update anything uh with the
711:52 - parameterization aka not really method
711:55 - and the other thing you have to think
711:55 - about is who the admins are who has
711:57 - access to these setter functions to
711:59 - these updating functions if it's a
712:02 - single person
712:03 - guess what you have a centralized smart
712:04 - contract now of course you can add a
712:06 - governance contract to be the admin
712:08 - contract of your protocol and that would
712:10 - be a decentralized way of doing this so
712:12 - just keep that in mind you can do this
712:13 - method just need a governance protocol
712:15 - to do so another example of this might
712:17 - be a contract registry and this is
712:18 - something actually that early versions
712:20 - of ave used before you call function you
712:22 - actually check some contract registry
712:24 - that is updated as a parameter by
712:26 - somebody and you get routed to that
712:27 - contract and you do your call there
712:29 - again this really doesn't allow us to
712:30 - have the full functionality of upgrades
712:32 - here you can argue that this registry is
712:34 - a mix of one of the later versions but
712:36 - for all intents and purposes this
712:38 - doesn't really give us that flexibility
712:39 - that we want for our upgrades but some
712:41 - people might even think that upgrading
712:42 - your smart contract is ruining the
712:44 - decentrality and one of the things that
712:46 - makes smart contracts so potent is that
712:47 - they are immutable and that this is one
712:49 - of the benefits that they have so there
712:51 - are some people who think that you
712:52 - shouldn't add any customization or any
712:54 - upgradability you should deploy your
712:56 - contract and then that's it trillabits
712:59 - has actually argued that if you deploy
713:00 - your contract knowing that it can't be
713:02 - changed later you take a little bit
713:04 - extra time making sure you get
713:06 - everything right and there are often
713:08 - less security vulnerabilities because
713:10 - you're just setting it for getting it
713:12 - and not looking at it again now if i
713:13 - were to deploy a smart contract and i
713:15 - wanted to upgrade it with this
713:16 - philosophy in mind that hey we got to
713:18 - keep it immutable we could use the
713:20 - social yate method to actually upgrade
713:22 - to new versions the social yet method or
713:25 - the migration method is just when you
713:27 - deploy your new contract not connected
713:29 - to the old contract in any way and by
713:31 - social convention you tell everybody hey
713:34 - hey this new contract this new one that
713:36 - we just deployed yeah this is the real
713:37 - one now and it's just by convention of
713:39 - people migrating and over into using
713:41 - this new one that the upgrade is done
713:43 - hence my slang name of social yi because
713:45 - you
713:46 - yeet the first one out of the way and
713:48 - move to the second one
713:52 - i think i'm funny
713:53 - this has the advantage of truly always
713:55 - saying hey this is our immutable smart
713:57 - contract and this is our new one this is
713:59 - really the truest definition of
714:00 - immutable because since you give it no
714:03 - way of being upgraded in place then if
714:05 - somebody calls that contract in 50 000
714:08 - years in the future it'll respond
714:10 - exactly the same another huge
714:12 - disadvantage here is that you have to
714:13 - have a totally new contract address
714:16 - so if you're an erc20 token for example
714:18 - you have to go convince all the
714:20 - exchanges to list your new contract
714:22 - address as the actual address keep in
714:24 - mind that when we do this we do have to
714:25 - move the state of the first one over to
714:28 - the second one so for example if you're
714:30 - an erc token moving to a new version of
714:32 - that erc token you do have to have a way
714:35 - to take all those mappings from the
714:36 - first contract and move it to the second
714:38 - one obviously there are ways to do this
714:40 - since everything is on chain but if you
714:42 - have a million transfer calls i don't
714:43 - want to have to write the script that
714:45 - updates everyone's balance and figures
714:46 - out what everyone's balance is just so i
714:48 - can migrate to my new version of the
714:49 - contract so there is a ton of social
714:51 - convention work here to do trailer bits
714:53 - has actually written a fantastic blog on
714:55 - upgrading from a v1 to a v2 or etc with
714:59 - this yeet methodology and they give a
715:01 - lot of steps for moving your storage and
715:02 - your state variables over to the new
715:04 - contract so link in the description if
715:06 - you want to read that now let's get to
715:07 - our big ticket item so in order to have
715:08 - a really robust upgrading mentality or
715:11 - philosophy we need to have some type of
715:12 - methodology or framework that can update
715:14 - our state
715:15 - keep our contract address and allow us
715:17 - to update any type of logic in our smart
715:20 - contracts in an easy way which leads us
715:22 - to our big ticket item the proxies
715:24 - proxies are the truest form of upgrades
715:27 - since a user can keep interacting with
715:29 - the protocols through these proxies and
715:31 - not even notice that anything changed or
715:33 - even got updated now these are also the
715:35 - places where you can screw up the
715:37 - easiest proxies use a lot of low-level
715:39 - functionality and the main one being the
715:41 - delegate call functionality daily gate
715:43 - call is a low-level function where the
715:46 - code in the target contract is executed
715:49 - in the context of the calling contract
715:51 - and message.sender and message.value
715:53 - also don't change so you understand what
715:55 - delegate call means now right great and
715:57 - in english this means if i delegate call
716:00 - a function in contract b from contract a
716:03 - i will do contracts b's logic in
716:06 - contract a so if contract b has a
716:08 - function that says hey store this value
716:11 - in a variable up top i'm going to store
716:13 - that variable in contract a this is the
716:16 - powerhouse and this combined with the
716:18 - fallback function allows us to delegate
716:21 - all calls through a proxy contract
716:23 - address to some other contract this
716:26 - means that i can have one proxy contract
716:28 - that will have the same address forever
716:30 - and i can just point and route people to
716:33 - the correct implementation contract that
716:35 - has the logic whenever i want to upgrade
716:38 - i just deploy a new implementation
716:40 - contract and point my proxy to that new
716:43 - implementation now whenever a user calls
716:45 - a function on the proxy contract i'm
716:47 - going to delegate call it to the new
716:49 - contract i can just call an admin only
716:52 - function on my proxy contract let's call
716:54 - it upgrade or something and i make all
716:55 - the contract calls go to this new
716:57 - contract when we're talking about
716:58 - proxies there are four pieces of
717:00 - terminology that we want to keep in mind
717:01 - first is the implementation contract the
717:03 - implementation contract has all of our
717:05 - logic and all the pieces of our protocol
717:07 - whenever we upgrade we actually launch a
717:09 - brand new implementation contract the
717:11 - proxy contract proxy points to which
717:14 - implementation is the correct one and
717:16 - routes everyone's calls to the correct
717:19 - implementation contract you can think
717:20 - the proxy contract sits on top of the
717:23 - implementations the user the user is
717:25 - going to be making contracting function
717:27 - calls through the proxy contract and
717:29 - then some type of admin the admin is the
717:31 - one who's going to decide when to
717:33 - upgrade and which contract to point to
717:36 - in this scenario the other cool thing
717:38 - about the proxy and delegate call is
717:40 - that all my storage variables are going
717:41 - to be stored in the proxy contract and
717:44 - not in the implementation contract
717:46 - this way when i upgrade to a new logic
717:49 - contract all of my data will stay on the
717:51 - proxy contract so whenever i want to
717:53 - update my logic just point to a new
717:55 - implementation contract if i want to add
717:57 - a new storage variable or a new type of
717:59 - storage i just add it in my logic
718:01 - contract and the proxy contract will
718:03 - pick it up now using proxies has a
718:05 - couple of gotchas and we're going to
718:06 - talk about the gotchas and then we're
718:08 - going to talk about the different proxy
718:09 - contract methodologies because yes there
718:11 - are many proxy contract methodologies as
718:13 - well and this is why trillabits doesn't
718:15 - really recommend using upgradable
718:16 - proxies for your smart contracts because
718:19 - they're fraught with a lot of these
718:20 - potential issues not to mention again
718:23 - you do still have some type of admin
718:25 - who's going to be upgrading your smart
718:26 - contracts now if this is a governance
718:28 - protocol then great you're decentralized
718:30 - but if this is a single group or entity
718:33 - then we have a problem
718:35 - the two biggest gotchas are storage
718:37 - clashes and function selector clashes
718:40 - now
718:41 - what does this mean when we use delegate
718:43 - call remember we do the logic of
718:45 - contract b
718:46 - inside contract a so if contract b says
718:49 - we need to set value to 2 we go ahead
718:52 - and set value to 2. but these smart
718:54 - contracts are actually kind of dumb we
718:56 - actually set the value of whatever is in
718:58 - the same storage location on contract a
719:01 - as contract b so if our contract looks
719:03 - like this and we have two variables in
719:05 - contract a we're still going to set the
719:07 - first storage spot on contract a to the
719:09 - new value this is really important to
719:11 - know because this means we can only
719:13 - append new storage variables in new
719:15 - implementation contracts and we can't
719:17 - reorder or change old ones this is
719:19 - called storage clashing and in the
719:21 - implementations we're going to talk
719:22 - about they all address this issue the
719:25 - next one is called function selector
719:27 - clashes when we tell our proxies to
719:29 - delegate call to one of these
719:30 - implementations it uses what's called a
719:32 - function selector to find a function the
719:35 - function selector is a four byte hash of
719:37 - the function name and the function
719:39 - signature don't worry about the function
719:40 - signature for now now it's possible that
719:43 - a function in the implementation
719:45 - contract has the same function selector
719:48 - as an admin function in the proxy
719:50 - contract which may cause you to do
719:52 - accidentally a whole bunch of weird
719:53 - stuff for example in this sample code in
719:55 - front of you even though these functions
719:57 - are totally different they actually have
719:59 - the same function selector so yes we can
720:01 - run into an issue where some harmless
720:03 - function like
720:05 - get price has the same function selector
720:07 - as upgrade proxy or destroy proxy or
720:10 - something like that this leads to our
720:12 - first out of the three implementations
720:14 - of the proxy contracts this is called
720:16 - the transparent proxy pattern and this
720:18 - is actually going to be the pattern that
720:20 - we're going to be demoing to you today
720:21 - in this methodology admins are only
720:23 - allowed to call it admin functions and
720:25 - they can't call any functions in the
720:27 - implementation contract and users can
720:30 - only call functions in the
720:31 - implementation contract and not any
720:33 - admin contracts this way you can't ever
720:35 - accidentally have one of the two
720:37 - swapping and having a function selector
720:39 - clash and you run into a big issue where
720:41 - you call a function you probably
720:42 - shouldn't have if you're an admin you're
720:43 - calling admin functions if you're a user
720:45 - you're calling implementation functions
720:47 - so if you're an admin and you build some
720:48 - crazy awesome d5 protocol you better
720:50 - come up with a new wallet address
720:51 - because you can't participate the second
720:53 - type of proxy we're going to talk about
720:55 - is the universal upgradable proxy or the
720:57 - ups
721:03 - this version of upgradable contracts
721:04 - actually puts all the logic of upgrading
721:07 - in the implementation itself this way
721:09 - the solidity compiler will actually kick
721:11 - out and say hey we got two functions in
721:14 - here that have the same function
721:15 - selector this is also advantageous
721:17 - because we have one less read that we
721:19 - have to do we no longer have to check in
721:21 - the proxy contract if someone is an
721:23 - admin or not this saves on gas of course
721:26 - and the proxy is also a little bit
721:27 - smaller because of this the issue is
721:29 - that if you deploy an implementation
721:30 - contract without any upgradeable
721:32 - functionality
721:33 - you're stuck and it's back to the yeet
721:35 - method with you and the last pattern or
721:38 - methodology that we're going to talk
721:39 - about is the diamond pattern which does
721:41 - a number of things but one of the
721:43 - biggest things that it does it actually
721:44 - allows for multiple implementation
721:46 - contracts this addresses a couple
721:48 - different issues for example if your
721:50 - contract is so big and it doesn't fit
721:52 - into the one contract maximum size you
721:55 - can just have multiple contracts through
721:56 - this multi-implementation method it also
721:59 - allows you to make more granular
722:00 - upgrades like you don't have to always
722:03 - deploy and upgrade your entire smart
722:04 - contract you can just upgrade little
722:05 - pieces of it if you've chunked them out
722:07 - the disadvantages here really only seem
722:09 - like you have a lot more complicated
722:11 - code all the proxies mentioned here have
722:14 - some type of ethereum improvement
722:15 - proposal and most of them are in the
722:17 - draft phase there isn't really a
722:18 - standard here for the proxy that the
722:19 - whole community has landed on and says
722:21 - yes
722:22 - this is great let's do it so for all
722:24 - these be sure to jump on the discussion
722:25 - and give your thoughts all right so now
722:27 - that we know a lot more about upgrades
722:30 - and how they actually work and some
722:31 - different methodologies behind them
722:33 - let's go ahead and learn how to actually
722:35 - implement some of these strategies and
722:37 - implement our contract so that we can
722:39 - upgrade them now there is a brownie
722:41 - upgrades mix directly in the brownie
722:44 - mixes organization that if you want to
722:46 - use you absolutely can once again to do
722:49 - that it's just brownie
722:50 - bake upgrades mix and this will have all
722:53 - the code that we're going to teach you
722:54 - how to use right now but let's go ahead
722:57 - and build this up from scratch ourselves
722:59 - so
723:00 - we're going to go ahead and run brownie
723:02 - knit
723:03 - this of course we're going to create our
723:05 - new browning project here we're going to
723:07 - be using the open zeppelin proxy
723:09 - contracts to actually work with this and
723:11 - run with this the methodology that we're
723:13 - going to be working with is the
723:14 - transparent upgradable proxy now they've
723:16 - been using the universal upgradable
723:18 - proxies a little bit more however the
723:20 - transparent upgradeable proxy is really
723:22 - fantastic and easy to understand so
723:24 - that's going to be the one that we're
723:25 - going to be working with here and these
723:26 - are the two contracts that we're going
723:28 - to be importing directly from open
723:30 - zeppelin so let's get to it we're going
723:32 - to create a really simple contract that
723:33 - we can easily tell if it's upgraded or
723:36 - not
723:36 - we're going to be using the exact same
723:38 - ones that open zeppelin actually uses so
723:40 - let's create a new file and this is
723:42 - going to be called box.soul we're just
723:44 - going to have it store and retrieve some
723:46 - type of value so let's give the spdx
723:50 - license
723:52 - identifier
723:54 - of mit so let's pick our solidity
723:56 - version
723:57 - and for this we're actually going to use
723:59 - 0.8.0
724:01 - oftentimes you're going to have to
724:02 - quickly pick up new versions of solidity
724:03 - anyways anyways we're going to do
724:05 - contract box and we're going to give it
724:07 - a uint256
724:10 - private value
724:11 - we're going to do an event called
724:14 - value changed
724:18 - i'm going to give it to you in 256 new
724:20 - value
724:21 - give it a function store
724:24 - uin256
724:26 - new value
724:27 - and this is going to be a public
724:28 - function that anybody can call
724:30 - and all we're going to do is we're going
724:32 - to set value
724:34 - to be new value
724:36 - and we're going to omit
724:39 - this value changed
724:42 - event then we're going to have a
724:44 - function
724:46 - retrieve and this will be a public view
724:50 - and it's just going to return
724:52 - the ui 256
724:55 - value return value and this is going to
724:58 - be our whole contract hopefully you can
724:59 - understand everything that's going on in
725:01 - this contract i should spell license
725:03 - right shouldn't i now we're going to
725:04 - copy all of this code
725:07 - and create a new contract called box
725:10 - v2.sol
725:12 - we're going to paste it in
725:14 - and box version 2 is going to be exactly
725:16 - the same
725:17 - except we're going to add
725:19 - one more function called increment
725:24 - this is going to be a public function
725:25 - and we're going to set value equals
725:27 - value plus one
725:29 - and we're also going to omit
725:31 - a value changed event
725:34 - with that new value
725:35 - now this is going to be really easy for
725:37 - us to check to see if a contract has
725:39 - been upgraded or not
725:41 - if we can call increment
725:43 - on the same address that we originally
725:45 - deployed box to then this means that the
725:48 - contract has been upgraded we shouldn't
725:50 - be able to call increment
725:52 - on this box contract but we should be
725:54 - able to call it on box v2 perfect so
725:58 - that's all we need to do to get started
725:59 - now to actually work with the proxies
726:01 - and the transparent proxy that we're
726:02 - going to be working with we do need to
726:04 - add them
726:05 - to our browning project
726:07 - so we're going to create a new folder
726:09 - and we're going to call it transparent
726:12 - proxy
726:13 - and in here we're going to add those two
726:15 - contracts we're going to add one
726:18 - called proxyadmin.sol
726:21 - and all we're going to do is we're going
726:22 - to grab all the code
726:24 - from the opens up and proxy contract and
726:26 - paste it right in here
726:29 - since
726:30 - since this code is pulling directly from
726:32 - it it opens up one package we are going
726:34 - to have to
726:35 - fiddle with the imports a little bit to
726:37 - make a match so brownie can actually
726:38 - compile it
726:39 - and of course since we're going to be
726:40 - working with another package we have to
726:43 - add this dependencies to our browning
726:45 - config
726:53 - so
726:54 - dependancies
726:57 - open
726:59 - zeppelin
727:00 - open
727:01 - zeppelin hyphen contracts
727:04 - and for this one we are going to
727:05 - actually use 4.1.0
727:07 - then we have to do compiler
727:10 - soak
727:13 - remappings
727:15 - at open
727:18 - zeppelin
727:19 - is going to be equal to this dependency
727:22 - now while we're in here we might as well
727:24 - do our dot env
727:26 - so we can get our environment variables
727:28 - and we'll add our wallet in here
727:30 - while it's
727:32 - from key
727:35 - private
727:36 - key
727:38 - we can now just have this be
727:40 - at open zeppelin
727:44 - contracts
727:45 - access
727:46 - ownable.soul and we don't need to change
727:49 - this at all because we're actually going
727:50 - to keep this transparent
727:51 - upgradableproxy.com
727:53 - because this
727:55 - is the second contract that we're
727:56 - actually going to grab from open
727:57 - zeppelin
727:59 - so let's create a new file
728:01 - to be called transparent
728:02 - upgradableproxy.soul this exact
728:05 - text here
728:08 - and we're going to copy paste this whole
728:10 - thing from open zeppelin
728:13 - boom
728:15 - paste it in here
728:18 - awesome and then same thing here we just
728:19 - have to a little reverse engineer this
728:22 - at open
728:23 - zeppelin slash contracts slash proxy
728:27 - erc
728:28 - 1967 erc 1967 proxy and perfect that is
728:32 - exactly where we are
728:33 - so great now if we've done this right we
728:35 - should be able to run a quick
728:38 - brownie compile
728:40 - oops i got to change this to box
728:45 - v2
728:48 - now let's run a brownie compile
728:50 - and perfect
728:52 - looks like we have compiled we've got
728:54 - some stuff in build great everything's
728:56 - working correctly so okay so we have our
728:58 - box here our box v2 and we have our
729:02 - proxy contracts as well that we can use
729:04 - to upgrade this box to a new version we
729:07 - can even look if we go back to proxy of
729:10 - open zeppelin if we look at our proxy
729:12 - admin here
729:13 - we see it has this function upgrade and
729:16 - call and this calls the upgrade to and
729:18 - call on the proxy contract if we look in
729:21 - the transparent proxy this upgrade to
729:23 - and call calls upgrade to and call which
729:26 - has been imported actually so we can
729:28 - actually even go back go back
729:30 - go to erc 1967 proxy upgrade
729:34 - look for that again and this is the
729:35 - function that it's actually going to
729:37 - call
729:38 - and it calls this upgrade to function
729:40 - which calls this set implementation
729:43 - function
729:44 - and all we're doing is we're doing
729:45 - storage slot dot get address slot of
729:48 - this implementation slot
729:50 - that value is going to be this new
729:51 - implementation
729:52 - all it's doing is it's setting the
729:54 - implementation slot to being our the new
729:56 - address that we wanted to use and we can
729:59 - see now if we look in the proxy contract
730:01 - the way that it actually works is it has
730:03 - this fallback function
730:04 - where it's always going to delegate all
730:06 - of our calls to whatever the
730:08 - implementation contract is
730:10 - this delegate function if we look at him
730:13 - there's a little bit of low-level
730:14 - assembly here
730:16 - and he uses this low-level delegate call
730:18 - to send any
730:20 - function call or any call to this
730:22 - contract to the implementation contract
730:25 - so this is exactly the function doing
730:27 - all that delegation all right so now
730:29 - that we've dug deep into the code let's
730:31 - actually script this out and turn this
730:32 - into a script so let's create a new file
730:35 - and we'll call it zero one deploy box
730:38 - dot soul and this is gonna be how we're
730:40 - actually gonna deploy the box so since
730:42 - this is a brand new script
730:43 - we're gonna do def
730:45 - main of course
730:47 - our account
730:49 - going to be equal to get account
730:51 - which
730:53 - we're going to do from scripts dot
730:55 - helpful
730:56 - scripts import
730:59 - get account
731:01 - so let's go ahead create a new file
731:04 - help
731:06 - full scripts
731:08 - oops
731:10 - scripts.pi
731:11 - and again we're just going to paste in
731:13 - that getaccount function from our past
731:16 - helpful scripts
731:21 - all right our get account script again
731:24 - so we can just do account equals get
731:25 - account oh this should be sorry should
731:28 - be dot pi excuse me
731:31 - do a quick print
731:33 - deploying
731:35 - to
731:35 - we'll do
731:37 - network dot show
731:39 - active
731:41 - that means we got to do
731:42 - from
731:43 - brownie import network and then we'll do
731:46 - box equals box
731:50 - dot deploy
731:53 - from
731:55 - account
731:57 - little brackets
731:58 - here of course since we're going to be
732:01 - deploying this contract we also have to
732:03 - import that from brownie and perfect
732:05 - this alone should just deploy the box
732:07 - contract right so this means we could do
732:09 - something like print
732:11 - box dot
732:13 - retrieve
732:14 - and it should be zero right so if we run
732:17 - brownie run scripts
732:19 - o1 deploy
732:21 - it will deploy that
732:22 - whoops we also got to add our env
732:26 - we don't have to put anything in here
732:27 - yet because we're not actually deploying
732:29 - to a real network
732:31 - but let's go ahead and run this
732:33 - i spelt retrieve wrong
732:36 - it's probably good to
732:38 - spell things right let's try it again
732:41 - and great so we get 0 here perfect
732:44 - that's exactly what we'd expect it's
732:45 - cool however though if we run
732:48 - box dot increment this should error out
732:50 - right
732:54 - boom exactly it has no attribute
732:56 - increment so this is what's known as our
732:58 - implementation contract this box is
733:01 - implemented it's the implementation
733:02 - contract
733:04 - now we have to hook it up to a proxy so
733:06 - let's first give it a proxy admin and
733:09 - proxy admins are optional um and it's
733:12 - also recommended that if you do have a
733:14 - proxy admin you're and you're going to
733:16 - use some type of default protocol
733:17 - sometimes it's great to have your proxy
733:19 - admin be something like a multi-sig
733:21 - gnosis safe which is really fantastic
733:24 - there's going to be a link
733:25 - in the github for learning how to
733:27 - actually spin one of those up let's go
733:29 - ahead and do a proxy admin because
733:31 - they're really helpful anyways we could
733:33 - optionally we could just set ourselves
733:35 - to be the proxy admin but let's set it
733:36 - to be this this contract
733:39 - so we'll do proxy admin
733:41 - equals
733:43 - proxyadmin.deploy and again this will be
733:46 - from
733:47 - account
733:49 - and since we're using this proxy admin
733:51 - we're going to import that as well
733:53 - so if we look at the proxy admin we see
733:55 - a couple functions here we see like get
733:56 - proxy implementation which is just going
733:58 - to return the address of the
734:00 - implementation
734:01 - we have get proxy admin
734:03 - it's going to be us
734:05 - change proxy admin we have this upgrade
734:07 - which is just going to call that upgrade
734:09 - function on the proxy and then we have
734:11 - upgrade and call upgrading call
734:14 - changes the implementation to the new
734:16 - implementation and then calls that
734:18 - initializer function since we want these
734:20 - to be proxies you can see here that we
734:23 - don't have a constructor
734:25 - this is intentional instead we could
734:27 - have some type of initializer
734:30 - function for example maybe we want to
734:32 - have this store be our constructor
734:34 - instead of having a constructor what we
734:36 - do is we call what's called our
734:38 - initializer function the instant we
734:40 - deploy this contract for the demo here
734:42 - we're just not going to have an
734:43 - initializer anyways so now we have this
734:46 - proxy admin we have the implementation
734:48 - contract we have the proxy admin let's
734:50 - now hook them up to the actual proxy
734:53 - first thing that we need to do actually
734:54 - is we need to
734:56 - encode the initializer function if we
734:58 - wanted store to be our initializer
735:00 - function like i said we could do
735:02 - something like ini shi al
735:05 - lizer
735:06 - equals
735:07 - box.store comma one and this would be
735:11 - our initializer box.store combined with
735:13 - one
735:14 - what we then have to do is we'd have to
735:17 - encode this for our proxy if we look at
735:20 - our transparent upgradable proxy if we
735:23 - look at the constructor
735:24 - we have address logic address admin and
735:28 - data here
735:29 - the logic is that implementation right
735:31 - this is going to be the address of our
735:32 - box the admin is going to be ourselves
735:35 - or in our case it's going to be that
735:37 - proxy admin contract
735:38 - and then data is going to be
735:41 - that initializer function if we go into
735:43 - the erc
735:45 - 721 proxy
735:47 - contract
735:48 - should go back to proxy erc
735:51 - 1967 upgrade
735:53 - and we look at this as one's constructor
735:56 - we can see that this data bit here
735:58 - once this is built with this constructor
736:00 - it's immediately going to call this
736:01 - upgrade to and call so it's going to
736:04 - call this this initializer if we go to
736:06 - upgrade to and call if we go back to
736:08 - this upgrade contract we can see this
736:10 - upgrade to and call it's going to call
736:12 - this address dot function delegate call
736:15 - new implementation data and this is how
736:17 - it actually
736:19 - calls that initializer function we have
736:21 - to actually encode this
736:23 - into bytes so we have to say box.store
736:26 - is the is the function a call
736:29 - and then one is going to be the first
736:31 - parameter right if this is what we'd
736:33 - want to do
736:34 - so we do box
736:37 - encoded
736:38 - initially
736:40 - function
736:42 - equals encode
736:44 - function data and this is where it gets
736:46 - a little bit tricky
736:48 - but i usually have this encode function
736:49 - data once again in my helpful scripts
736:52 - so we'll do quick def encode function
736:54 - data
736:55 - and it's going to take
736:57 - an init
737:01 - which we're going to start off as none
737:03 - and then any number of arguments after
737:05 - that so again this could be like
737:08 - you know
737:10 - initializer equals box.store
737:13 - and then the arguments could be you know
737:16 - one two three four
737:18 - five etc or whatever right for us we
737:20 - only have one variable that can be put
737:22 - into store but this is how you would do
737:24 - it and to do this brownie actually has a
737:26 - built-in function that can actually do
737:28 - this we just return initializer dot and
737:31 - code
737:32 - input
737:33 - star args
737:35 - and that's all we'd have to do however
737:37 - there is a bit of an issue when the
737:39 - length of the args is zero so i've
737:42 - already hacked away at it for you guys
737:44 - so we're just gonna do if
737:45 - the length of the args
737:48 - is zero or we're not using an
737:51 - initializer
737:53 - then we're going to return
737:55 - s utils dot two bytes
737:59 - x string
738:00 - equals ox
738:03 - and we do have to import f util
738:05 - import
738:07 - at utils and of course we'd have to pip
738:09 - install it with pip
738:11 - install
738:13 - ethertails so i know i kind of rushed
738:15 - through that but basically what we're
738:16 - doing like i said
738:18 - is we're encoding this into bytes so
738:20 - that our smart contracts actually know
738:23 - what function to call
738:24 - so we're just encoding it that's all
738:26 - we're doing and if it's blank or there's
738:28 - no initializer we're going to return an
738:30 - empty hex string and our smart contract
738:32 - will understand ah okay arguments are
738:34 - blank here perfect i've got a nice doc
738:37 - string in the upgrades mix that explains
738:40 - this even better i'm even just going to
738:41 - paste it in here for now if you'd like
738:43 - to pause and read this a little bit more
738:45 - to
738:46 - kind of get the full depth of what this
738:48 - function is really doing feel free to do
738:50 - that this is a little bit lower level
738:52 - solidity and evm stuff that we're
738:53 - getting into here but it can be good to
738:55 - know anyways
738:56 - okay great so now that we have this we
738:59 - could go ahead and run box encoded
739:01 - initializer function equals encode
739:03 - function data
739:04 - which we would import from our helpful
739:06 - scripts and this is what we use when we
739:09 - call the constructor for our transparent
739:11 - upgradable proxy
739:13 - i'm just going to have it be blank for
739:14 - now but feel free to fiddle around and
739:16 - try to actually use an initializer after
739:18 - we run through this demo so this box
739:20 - encoded initializer function is going to
739:22 - be blank we're saying hey
739:23 - don't use an initializer and that's
739:25 - totally fine
739:27 - if we were to add some stuff to here we
739:29 - would say hey use an initializer so now
739:31 - we can actually deploy this transparent
739:33 - upgradable proxy if we open this up with
739:36 - the constructor we can see
739:38 - what we need here
739:40 - so
739:41 - we're going to say proxy
739:42 - equals
739:44 - transparent
739:46 - upgrade able
739:48 - proxy.deploy
739:51 - of course
739:53 - import this from brownie
739:57 - and what are those
739:58 - variables that we need okay we're gonna
740:01 - need the address the logic this is gonna
740:03 - be our implementation contract address
740:05 - so we just say box.address which is our
740:08 - because we've already deployed this
740:09 - which is great
740:11 - then we're going to need our admin which
740:13 - we could just say is us but we're going
740:15 - to use the proxy admin
740:18 - dot address and then last we need that
740:22 - function selector we need that encoded
740:24 - function call which for us is just blank
740:26 - but we still need that
740:28 - so
740:29 - box encoded initializer function and
740:31 - then we have to add from
740:34 - account of course and i've also noticed
740:37 - that sometimes it's helpful to add some
740:39 - type of gas limit
740:41 - so i'll even add a gas limit
740:44 - of one
740:46 - one two three one two three that's six
740:49 - zeros there but sometimes you might be
740:51 - fine but uh
740:52 - with the proxies they they sometimes
740:54 - have a hard time figuring out the gas
740:55 - limit so i've just manually put it in
740:57 - here you can if you want to it might
740:59 - work fine without it and then great
741:00 - let's do a quick print function we'll
741:02 - print
741:04 - f
741:06 - proxy deployed to
741:09 - proxy
741:11 - you can now upgrade to v2
741:15 - now what we can do is on the proxy's
741:18 - address we can call functions so
741:21 - typically right if we wanted to call a
741:22 - function on this box contract we do box
741:24 - dot you know retrieve or however you
741:27 - spell it box.store let's just do box
741:30 - store right you'd call it like this
741:32 - however we want to actually call these
741:33 - on the proxies right because box this
741:36 - box contracts address this box contract
741:39 - is always going to be the same address
741:41 - and can't change
741:42 - the proxy code can change we want to
741:44 - always call these functions to the proxy
741:47 - and not to the box here right so the way
741:50 - we do that is we can do proxy box
741:53 - equals
741:55 - contract dot from
741:57 - abi
741:58 - we'll call it box
742:01 - on the proxy.address
742:03 - box.abi
742:05 - and of course we'll
742:07 - import this from brownie
742:09 - what we're doing here
742:11 - is we're assigning
742:13 - this proxy address the abi
742:17 - of the box contract and this is going to
742:19 - work because the proxy is going to
742:22 - delegate all of its calls to the box
742:24 - contract
742:25 - typically if you put an abi on top of an
742:28 - address that doesn't have those
742:30 - functions that the api defines it would
742:31 - just error
742:32 - right but the proxy is actually going to
742:34 - delegate all those calls to the box
742:37 - so we could actually go ahead and try
742:40 - something like print
742:43 - proxybox dot
742:46 - retrieve hopefully that's about that
742:48 - right and even though
742:50 - we're using the proxy address here we
742:53 - are going to delegate the call
742:55 - to
742:56 - box so let's go ahead and run this so
742:58 - we'll do brownie run scripts
743:01 - deploy box it's going to deploy the box
743:04 - it's going to deploy the admin it's
743:06 - going to encode that initializer
743:08 - function which we've set to nothing then
743:10 - it's going to deploy our transparent
743:12 - upgradable proxy and then it's going to
743:14 - call
743:15 - retrieve
743:16 - on the transparent upgradable proxy
743:19 - instead of our box so let's do this
743:23 - and perfect we did it right it's
743:24 - returning zero here that's awesome what
743:27 - we could also do is we could also do
743:29 - proxybox.store
743:32 - one
743:33 - and then we'll call retrieve we'll see
743:35 - what happens here
743:38 - whoops it's yelling at me because i got
743:39 - to do
743:40 - from
743:43 - account
743:45 - now let's go ahead and run it
743:47 - and perfect see so after we stored on
743:50 - the proxy box on this proxy
743:52 - we're able to retrieve the value there
743:55 - so this is fantastic all right now that
743:57 - we've deployed it let's learn how to
744:00 - upgrade it we're going to change this to
744:02 - deploy
744:03 - and upgrade
744:05 - dot pi and we're just going to do
744:06 - everything in here so now that
744:08 - everything's deployed let's go ahead and
744:10 - now upgrade this so so now we can always
744:14 - point to this proxy box address and it's
744:16 - going to be the most recent upgrade it's
744:18 - always going to have the code that we
744:20 - want it to have so let's go ahead and
744:22 - upgrade from box that doesn't have that
744:25 - increment to box v2 that does indeed
744:28 - have this increment function so let's
744:29 - try this out so first thing we need to
744:32 - do is we actually need to deploy that
744:33 - box v2
744:34 - so we'll do box v2
744:36 - equals box
744:40 - b2
744:41 - dot deploy
744:45 - we'll save from
744:48 - account
744:49 - and we'll leave it like that of course
744:51 - we're going to have to import box v2
744:53 - from brownie
744:55 - and right now actually let's even do
744:57 - proxy box
744:59 - increment
745:02 - if we call boxy proc
745:04 - proxy box that increments from account
745:07 - this should error right it shouldn't be
745:08 - able to call this increment function
745:10 - because that doesn't exist
745:12 - oh and then we also change the name of
745:13 - the script sorry
745:15 - this is actually going to be
745:17 - deploy and upgrade
745:19 - and perfect we see it actually errors
745:21 - out here it says hey box object doesn't
745:23 - have this increment function you're
745:24 - crazy i don't know what you're talking
745:25 - about
745:26 - well good that's what we want to do
745:28 - so let's delete that line
745:30 - box v2 and we'll even do a quick little
745:34 - upgrade here
745:36 - now all we need to do is call
745:40 - an upgrade function now basically all we
745:42 - have to do is call this upgrade to
745:44 - function right but depending on if we've
745:47 - added a proxy admin contract if we're
745:49 - using initializer function there might
745:51 - be a couple of of different ways to go
745:53 - about this so i like to just wrap
745:55 - everything up into its own upgrade
745:57 - function you'll see what i mean in just
745:58 - a second so
746:00 - what i like to do again we're going to
746:01 - pop into our helpful scripts and we're
746:03 - going to create a new one called upgrade
746:06 - now for parameters in here of course
746:08 - we're going to take some type of account
746:09 - so that we have something to account
746:12 - to deploy from
746:14 - we're going to use the proxy which is
746:16 - again going to be that proxy contract
746:19 - which is going to be our proxy contract
746:21 - here we're going to need a new
746:24 - implementation
746:26 - address we're gonna need the proxy admin
746:31 - contract
746:33 - which could be none for us we're gonna
746:35 - have one but it could be none and then
746:37 - we're gonna have an
746:39 - initializer
746:40 - which also could be none
746:42 - and then we're going to have the args
746:43 - for the initializer which also could be
746:45 - known again this star
746:48 - is a special thing in python which says
746:49 - any number of arguments
746:51 - will just get stored into this list
746:53 - called args and perfect this is going to
746:55 - be our function that's just going to
746:56 - take care of everything for us so first
746:58 - thing let's check to see if there is a
747:00 - proxy admin contract
747:01 - so we'll say if
747:03 - there is a proxy admin contract
747:06 - then we want to check to see if there is
747:07 - an initializer
747:11 - what we're going to do is we're first
747:12 - going to want to encode that function
747:14 - data of course so we'll say encoded
747:18 - function call
747:20 - equals and code
747:22 - function data
747:23 - with the initializer
747:26 - and those star args
747:28 - this is going to be the encoded
747:30 - initializer function here
747:32 - then all we have to do and actually
747:34 - let's do start with a blank transaction
747:37 - equals none
747:38 - we'll say
747:40 - transaction
747:42 - equals
747:44 - proxy admin contract since we're using
747:46 - one of these proxy admin contracts since
747:47 - we've detected one
747:49 - dot
747:50 - upgrade and call since we also have an
747:53 - initializer
747:56 - we're going to pass the
747:57 - proxy.address
748:00 - new implementation address
748:03 - and the encoded function call and then
748:05 - of course
748:06 - from
748:08 - account
748:09 - so this upgrade and call if we look in
748:11 - that proxy admin
748:14 - there's this upgrading call function
748:16 - right on the proxy admin and it just
748:18 - calls upgrade to and call of the proxy
748:20 - contract
748:21 - so hopefully don't don't let this bog
748:23 - you down a little bit that there's kind
748:24 - of a lot of mix and matching going on
748:26 - but this is what's going on
748:28 - i'm sorry this is encoded function call
748:29 - not encoded function data
748:31 - great now if they don't have an
748:33 - initializer
748:35 - well what do we do well we don't need to
748:37 - encode any function call here we need to
748:39 - say
748:40 - transaction
748:41 - equals
748:42 - that proxy admin contract
748:44 - dot upgrade
748:46 - so it has an upgrading call it also just
748:49 - has a regular old upgrade so we'll just
748:51 - call upgrade
748:52 - and we'll give it the proxy.address
748:56 - the new implementation address
748:59 - and then
749:00 - from
749:02 - account
749:04 - now if it doesn't have a proxy admin
749:05 - contract this means that the admin is
749:07 - just going to be a regular old wallet
749:09 - well what do we do then well first
749:12 - check to see if it has an initializer
749:14 - still
749:15 - and if it does we need again
749:17 - to encode that function call we can just
749:19 - copy and paste that there and then once
749:21 - that's encoded we can just call directly
749:23 - off the proxy contract we're going to
749:25 - call exactly what the proxy admin
749:27 - contract is calling which can be
749:29 - proxy.upgrade
749:32 - to
749:33 - and call
749:35 - we're going to give it the new
749:36 - implementation address
749:38 - the encoded
749:39 - function call
749:42 - and then from
749:43 - account
749:45 - and let's wrap this all up in a big else
749:48 - so if proxy admin contract do this stuff
749:52 - else do this stuff
749:55 - if initializer do that otherwise we can
749:58 - just do
749:59 - transaction equals
750:01 - proxy dot
750:03 - upgrade 2 and we just add that new
750:05 - implementation address
750:08 - from
750:10 - account
750:12 - and then we'll finally return
750:14 - transaction
750:16 - so i know that there's a lot here but
750:18 - we're really just making this upgrade
750:20 - function really general we could always
750:22 - just know okay if we we we're going to
750:25 - use a proxy admin let's just do it like
750:26 - this okay no we're not going to use a
750:28 - proxy admin we're also not going to use
750:30 - an initializer great it would just look
750:32 - like this but this is essentially all
750:34 - that we have to do so now that we now
750:36 - that we have our upgrade function
750:38 - we can go ahead and use it here
750:41 - so we need to give it an account a proxy
750:43 - a new implementation address
750:45 - so we'll say account so we'll say
750:47 - upgrade
750:49 - transaction equals upgrade account
750:54 - we need a proxy and a new implementation
750:56 - address we're going to give it the proxy
751:01 - and we're going to give it
751:03 - box
751:05 - v2.address for that new address
751:10 - we do have a proxy admin contract
751:13 - so we'll say proxy
751:15 - admin
751:18 - contract equals
751:20 - proxy admin and we don't have an
751:23 - initializer so we can leave that part
751:25 - blank
751:27 - of course we need to import this upgrade
751:29 - function from our helpful scripts
751:32 - and this is all that we need so now we
751:34 - can do print
751:36 - proxy has been upgraded and what we
751:38 - could do now is we can do proxy box
751:41 - equals contract dot
751:44 - from abi
751:46 - we'll call it box v2
751:48 - we'll give it the proxy.address
751:51 - box v2.abi
751:54 - and now we should be able to call
751:55 - proxybox.increment
752:02 - from account and then we can print
752:07 - proxy box
752:08 - dot re
752:10 - retrieve
752:11 - and this should now be one and what
752:13 - we'll actually see is that this will
752:15 - return two
752:17 - why does it return two
752:19 - well in our original proxy box we stored
752:22 - one so it started with one we then
752:24 - upgraded to this new contract and then
752:27 - let's actually just do a
752:29 - wait of course
752:31 - we upgraded to a new contract
752:34 - right here
752:35 - however the storage of that contract
752:37 - stayed in the proxy so that one stayed
752:40 - in the proxy so even though we upgraded
752:42 - the contract
752:43 - there's still one stored at the location
752:46 - in storage so then when we call
752:47 - increment now and then we call retrieve
752:49 - it's gonna go from one to two so let's
752:52 - go ahead and run this
752:54 - brownie run scripts
752:56 - deploy an upgrade enter
752:59 - and boom that is exactly what we see
753:01 - output here this is an incredibly
753:03 - incredibly powerful and advanced feature
753:05 - and if you've gotten to this point you
753:07 - are on the border of being one of the
753:09 - most powerful smart contract engineers
753:11 - on the planet huge congratulations for
753:13 - getting this far but we're not quite
753:14 - done we of course need to write some
753:17 - tests because that is what's going to
753:19 - make sure our project always stays in
753:21 - sync and always stays up to date so
753:23 - let's write a couple of tests here so
753:24 - let's create a new file
753:26 - we'll call test
753:27 - box proxy dot pi
753:30 - and for this we're really just going to
753:31 - test to see that our contracts work
753:33 - we're going to see that this box
753:35 - actually is going to work correctly so
753:36 - let's create a new test
753:38 - def
753:39 - proxy
753:41 - delegates calls
753:44 - so we're going to make sure that we
753:46 - actually can delegate calls to our
753:47 - contract we're going to say account
753:49 - equals
753:51 - get account
753:53 - which means we have to do from
753:57 - scripts.helpfulscripts
754:00 - import get account
754:02 - then we're gonna do
754:03 - box
754:04 - equals
754:07 - box.deploy
754:09 - of course this is going to be from
754:12 - account
754:13 - since we're using box we're going to do
754:15 - from brownie import
754:18 - box
754:19 - we're going to do this proxy admin so
754:21 - we're going to say proxy admin
754:23 - equals proxyadmin.deploy
754:28 - of course from
754:32 - account
754:34 - let's import proxy admin from brownie
754:36 - all right so now we'll do the box
754:38 - encoded
754:40 - initializer function
754:43 - or whatever we call to perform this is
754:44 - going to be that encode
754:47 - function data which
754:49 - my vs code actually automatically
754:51 - imported thanks vs code
754:52 - and again we're leaving it blank
754:55 - because we're not actually going to have
754:56 - a store there and then we're just going
754:58 - to go ahead and run that deployment so
755:00 - we're going to say proxy equals
755:03 - transparent
755:04 - upgrade
755:06 - proxy
755:08 - and we're going to grab this from
755:10 - brownie dot deploy
755:14 - say again the box.address
755:17 - proxyadmin.address
755:21 - box encoded initializer function
755:25 - i'm going to say from
755:27 - account and then we'll give this a gas
755:29 - limit
755:32 - of
755:34 - two three one two three
755:36 - now we're gonna put the abi on top of
755:38 - this proxy so we're gonna say proxy box
755:41 - equals
755:43 - contract dot from abi
755:46 - we're gonna name it box
755:49 - this is going to be with the
755:50 - proxy.address
755:51 - [Music]
755:53 - and the box.api
755:56 - of course we're going to need to
755:58 - import contract from brownie
756:01 - and okay so now we can assert
756:04 - proxybox
756:07 - dot retrieve
756:09 - if i spot that right is equal to zero
756:12 - then we're going to do proxy box
756:15 - that's store
756:17 - we'll do one
756:19 - and this will be from account
756:22 - and then we're going to sir again
756:24 - this proxybox.retrieve
756:26 - should now equal 1.
756:28 - so we're using this proxy contract
756:31 - we've slapped the abi on top of it and
756:34 - this should work
756:36 - so we're just testing to see that our
756:37 - proxy is working correctly
756:39 - so we can go ahead and test this then
756:41 - with
756:42 - rounding test
756:44 - and beautiful it passed
756:46 - now let's go ahead and create a new
756:49 - script for testing the upgrades create a
756:52 - new file called test
756:54 - box v2 upgrades
756:57 - dot pi
756:58 - and let's do it
756:59 - called def
757:01 - test
757:02 - proxy upgrades
757:05 - so account
757:07 - it's gonna be equal to get account
757:09 - hopefully at this point you're getting
757:10 - pretty good at writing these these tests
757:12 - from
757:13 - scripts.helpfulscripts
757:16 - imports
757:17 - and of course we want to add this init
757:20 - dot pi just in case you forgot so now
757:23 - we're going to import get
757:24 - account perfect so we have our account
757:27 - here now as you can see we're doing a
757:28 - lot of this box equals box dot deploy
757:31 - deploy the proxy admin it would probably
757:34 - make sense in one of your scripts to
757:35 - just write a deploy three
757:37 - to write a function called like deploy
757:39 - all or something like that
757:41 - so again if you guys want to learn more
757:42 - if you want to improve upon this i would
757:44 - highly recommend you go back and you
757:46 - make some of those improvements to to
757:47 - really modularize this up but for the
757:49 - time being let's just keep going
757:51 - so box.deploy
757:55 - from
757:56 - account
757:58 - and since we're doing this we're going
757:59 - to do from
758:00 - brownie import box
758:02 - say proxy
758:04 - admin
758:05 - equals
758:07 - proxyadmin.deploy
758:10 - this will also be from
758:11 - [Music]
758:12 - account
758:15 - comma proxy admin
758:17 - we're going to get those initializer
758:19 - functions so we'll say box
758:21 - encoded
758:22 - initializer
758:24 - function
758:26 - equals encode
758:28 - function data which we're going to grab
758:30 - from our helpful scripts as well
758:32 - and then we're going to do the proxy
758:34 - again
758:36 - box equals transparent up
758:41 - gradable proxy
758:43 - that deploy
758:45 - we've got to import this from brownie as
758:47 - well oops not twice though
758:51 - deploy
758:53 - it's going to have the box that address
758:57 - proxy admin dot address
759:00 - box encoded initializer function
759:04 - from account
759:08 - gas limit
759:10 - one two three one two three
759:13 - all right
759:14 - so we have the proxy deployed we've
759:16 - already tested that this proxy works in
759:18 - this test box proxy so we're not going
759:20 - to go ahead and test that again
759:23 - what we're going to do instead now is
759:24 - now we're going to deploy
759:26 - box v2
759:28 - and we're going to update the proxy and
759:30 - make sure that everything still works
759:33 - so we're going to do box v2
759:35 - equals box v2
759:38 - dot deploy
759:40 - it's going to be from
759:41 - [Music]
759:43 - account of course
759:45 - now we're going to say proxy
759:47 - box
759:49 - equals
759:50 - contract.from api
759:54 - box v2
759:56 - proxy.address
760:00 - v2.abi
760:02 - and we're going to grab
760:05 - both this
760:07 - and this from brownie
760:10 - and what we're going to try to do
760:12 - is slapping this abi
760:14 - onto this proxy address we're going to
760:16 - try to call a function only box v2 can
760:18 - call
760:19 - however we know that
760:21 - like what we tested before it actually
760:23 - should revert
760:24 - so we can actually check for reverts by
760:27 - importing
760:30 - pi test
760:32 - and we can say
760:33 - with pi test
760:35 - dot
760:36 - raises
760:37 - and i know that
760:39 - this is a brownie exception i know what
760:40 - type of exception this is it's an
760:42 - exceptions dot virtual machine error
760:47 - you can figure out what type of error
760:48 - this is by
760:50 - just just running it and getting the
760:51 - error so this is actually from brownie
760:53 - this exceptions thing so we're going to
760:55 - actually also import exceptions from
760:57 - brownie we're going to say
761:00 - proxybox.increment
761:06 - from
761:07 - count
761:09 - and i saved and everything sorry got
761:11 - formatted here but calling
761:13 - proxybox.increment should throw this
761:16 - exceptions.virtual machine error so this
761:18 - test will pass if this throws an error
761:22 - and that's how we test that so we want
761:23 - this to throw an error the first time we
761:25 - call it then we're going to upgrade and
761:27 - then we'll call it again and it'll
761:28 - actually work
761:29 - now we're going to call upgrade
761:32 - on account
761:34 - proxy
761:35 - box v2
761:37 - proxyadmin
761:40 - contract equals
761:44 - proxy admin
761:47 - we're going to need to grab upgrade from
761:49 - our helpful scripts and now we should
761:52 - actually be able to
761:54 - call increment with our proxy box
761:56 - so first we'll do a quick assert
761:58 - proxy box dot
762:01 - retrieve equals zero
762:03 - then we'll do proxy proxybox.increment
762:11 - from
762:13 - account
762:14 - and then we'll assert
762:16 - proxybox dot retrieve
762:20 - is
762:21 - one so we're deploying our box we're
762:23 - deploying our proxy and everything
762:25 - around it
762:26 - then we're deploying our v2
762:28 - implementation
762:29 - we're trying to call increment which
762:31 - won't work we then upgrade our proxy to
762:34 - this new address
762:36 - and then we can go ahead
762:38 - and call
762:39 - increment and it should actually
762:41 - increment our box here
762:42 - so let's go ahead and run this test
762:44 - brownie run test
762:47 - excuse me
762:48 - ronnie test dash k
762:51 - grab this paste it in
762:55 - and we've done it our tests are working
762:57 - correctly so we know that our box is
762:59 - working correctly
763:01 - awesome great job like i said this is an
763:04 - incredibly incredibly powerful feature
763:05 - to be able to do these upgrades with
763:08 - these there comes a lot of risk at least
763:10 - in the form of centralization risk if
763:12 - you're the only wallet that controls the
763:15 - proxy that means your application is
763:18 - centralized full stop so if you're going
763:20 - to deploy anything with proxies to
763:22 - mainnet
763:23 - absolutely absolutely be sure to get it
763:25 - audited beforehand
763:27 - now before we close this project up
763:28 - let's actually deploy this to an actual
763:30 - test snap
763:32 - so that we can see everything that goes
763:34 - on when we call this deploy and upgrade
763:36 - let's go ahead and do it
763:38 - so
763:39 - let's pop into our emv file
763:41 - and let's paste the variables that we
763:43 - have in here we need the private key web
763:46 - three inferior project id the ether scan
763:48 - token
763:49 - awesome
763:50 - let's even
763:51 - let's even publish the source of all
763:54 - these contracts so that we can see them
763:55 - on etherscan
763:57 - so for box we'll do a little comma here
763:59 - we'll say publish
764:01 - source equals true
764:03 - i'm just going to copy this comma to
764:05 - publish source equals true
764:06 - and paste it on all of my deployments
764:12 - over source equals true
764:15 - publish source equals true on the
764:17 - on the admin
764:19 - on the initial transparent upgradable
764:21 - proxy
764:23 - on the box v2 deployment
764:25 - and that's it
764:26 - i've got my ether scan token my web 3
764:28 - and fira my private key my brownie
764:30 - config is indeed pulling from the
764:32 - private key my env has env let's check
764:36 - to see my wallet
764:37 - we have some rink being here perfect
764:40 - let's do this
764:42 - brownie run scripts
764:44 - deploy and upgrade
764:46 - network
764:48 - rink
765:03 - all right so it looks like a couple of
765:04 - our contracts weren't able to actually
765:06 - verify there are a couple bugs being
765:08 - worked out with some of the verification
765:09 - so we're going to ignore the ones that
765:11 - weren't able to be verified here but
765:12 - let's go ahead grab these addresses pop
765:14 - them onto the rink etherscan and see
765:17 - what just happened
765:18 - this is our box implementation let's
765:20 - grab this address let's paste it into
765:22 - the rinkby testnet ether scan awesome
765:25 - this is exactly what we have contract
765:27 - has been verified this is exactly the
765:29 - code that we have here
765:30 - and we can see all we have is a contract
765:33 - creation and this is exactly correct
765:35 - because when we call
765:37 - the store function on this it's actually
765:40 - going to get stored we never actually
765:42 - called any functions directly on this
765:44 - contract all we did was deploy it which
765:46 - makes perfect sense let's go check out
765:48 - this proxy admin now
765:50 - this second address
765:53 - the second counter that we deployed
765:55 - sadly this one didn't get
765:57 - verified however we can see we did
765:59 - indeed call this upgrade function at
766:02 - some point
766:03 - which makes a lot of sense
766:05 - if we look at our script
766:06 - proxy admin
766:08 - in our upgrade code since we did have a
766:10 - proxy admin contract we did call that
766:12 - upgrade function
766:13 - perfect makes sense now let's go to this
766:16 - transparent upgradable proxy this is
766:19 - going to be the most interesting one out
766:21 - of all of our
766:23 - applications
766:24 - interestingly enough we look at this
766:26 - contract we can see store in increment
766:28 - both have been called on this contract
766:32 - not on the box because again this is the
766:34 - proxy that we're going to call all the
766:36 - functions on to make our contracts
766:38 - upgradable internal transactions are
766:41 - calls that another smart contract made
766:43 - to this transaction and if we look at a
766:45 - couple of these
766:47 - we can see if we click more
766:49 - we had increment called from another
766:51 - contract which makes sense we had
766:53 - upgrade called from the proxy admin
766:57 - and then we also of course we had store
766:59 - called from another contract and if we
767:01 - verified this we would be able to see
767:03 - etherscan recognize this as a proxy
767:05 - contract as well hopefully when you work
767:07 - with this you'll be able to verify it as
767:09 - well but if not not a big deal you can
767:11 - always just manually do it later
767:12 - yourself so this was an incredibly
767:14 - powerful project that we just did here
767:16 - and that we worked on and all right
767:19 - maybe take a nap maybe go for a walk get
767:21 - some food get a drink because we are on
767:23 - to our last coding project now i do want
767:26 - to say that this project is considered a
767:28 - bonus because we're going to be going
767:30 - very quickly over the front end pieces
767:33 - we're going to take all the building
767:34 - blocks that we've learned and build an
767:36 - amazing full stack application gear up
767:39 - get ready let's jump into this bonus
767:41 - project and then after we finish this up
767:44 - we're going to close everything out with
767:45 - a final quick section about security the
767:49 - future and and thank you for joining
767:51 - this course so let's do this last one
767:57 - all right now we are moving on to our
768:00 - final project this is going to be the
768:03 - most advanced products and combine all
768:06 - the knowledge that we've learned so far
768:08 - into one project
768:09 - then we're additionally going to put a
768:11 - front end or a user interface onto this
768:14 - project when we build our own
768:15 - applications we're going to need a way
768:17 - for non-devs to actually interact with
768:19 - it in a meaningful way so now this isn't
768:22 - a front end or react tutorial course
768:25 - although we will be explaining some of
768:27 - the choices that we've made and how to
768:29 - actually do them you should be able to
768:30 - follow along fine even if you don't have
768:32 - any front end experience here if you're
768:34 - looking for a full front end tutorial
768:36 - free code camp has some amazing videos
768:38 - that you can absolutely try out all
768:40 - right welcome back everybody and now
768:43 - we're going to be embarking on the most
768:45 - exciting the most end to end we're going
768:48 - to take everything that we've learned
768:50 - and wrap it all together in this single
768:53 - last application here and we're also
768:56 - going to be learning about front end
768:58 - development we're going to be building a
769:01 - front end on top of our application on
769:03 - top of our contracts here now this isn't
769:06 - a front end tutorial however free code
769:08 - camp has some wonderful wonderful react
769:10 - tutorials we're going to be teaching you
769:12 - guys just enough so that you can go
769:13 - ahead jump in and build your own simple
769:16 - but also kind of nice looking front ends
769:18 - on top of whatever contracts that you
769:21 - have
769:22 - for those of you who want users to
769:23 - actually interact with your applications
769:25 - and interact with your contracts
769:26 - building a usable front end is a really
769:28 - important piece so let's take a quick
769:31 - walkthrough of what this application is
769:32 - going to look like so here is our our
769:35 - front end here and what this application
769:37 - is going to allow users to do is it's
769:39 - going to allow users to stake or deposit
769:42 - their tokens into what's called our
769:44 - token farm contract once they have some
769:46 - token deposited that's when you can kind
769:48 - of go get creative with what you want
769:49 - those tokens to do
769:51 - you could use it as staking in some
769:52 - governance you could use it to you could
769:54 - go ahead and invest it in something like
769:56 - ave or another d5 protocol to gain
769:58 - interest you could build a yield
770:00 - aggregator there's a ton a ton of
770:02 - different features that you can actually
770:03 - do once you have users stake their
770:05 - tokens and here's how they would do it
770:07 - on their ui side so we have this little
770:09 - button here which we go ahead and click
770:11 - connect on metamask is going to pop up
770:14 - and we're automatically going to sign in
770:17 - that's going to connect our meta mask to
770:20 - this user interface now so if i look at
770:23 - my meta mask i'm on the coven test
770:25 - network we can see that i am indeed
770:26 - connected now what i can do
770:28 - is i can now stake some of my tokens
770:31 - into this contract we currently have
770:34 - three different types of tokens that
770:35 - this platform allows you to stake
770:37 - wrapped ether
770:39 - fiu which is mimicking die on the test
770:41 - network and our dap token this dap token
770:45 - is going to be the reward token that our
770:47 - platform gives users as an incentive for
770:49 - staking on our platform once we stake we
770:52 - can actually then unstake and that's
770:54 - really it
770:55 - so we'll go ahead and stake maybe we'll
770:56 - stake 10 dap we'll hit stake metamask
771:00 - will pop up this is the approve function
771:02 - this first approved function that gets
771:04 - called we get a really nice little
771:07 - waiting
771:08 - bar here and once it's been approved we
771:10 - get a notification saying the transfer's
771:12 - unapproved we then go ahead and we'll
771:15 - confirm staking we'll get this little
771:17 - loading bar while it's being staked and
771:19 - we'll see that pop-up that says tokens
771:21 - staked successfully
771:23 - now if we go to the token farm contract
771:25 - we can see that we have 10 of this dap
771:28 - token state
771:30 - we can also unstake it the other thing
771:32 - that we can do is as admins of this
771:34 - wallet we can actually issue a reward
771:37 - to our users based on how much they've
771:38 - staked so you see right now we have 95
771:40 - dap token
771:42 - we have 10 dap tokens staked on the back
771:45 - end i'm going to run an issue token
771:47 - script it's going to send all users that
771:49 - have some stake a little bit of a dap
771:51 - token reward now you can see it's been
771:54 - updated
771:56 - and we have we've been given a little
771:58 - bit of dap token that resembles the
772:00 - amount of dap token that we have staked
772:03 - the way that we figure out the value of
772:05 - all of our different tokens is using of
772:07 - course chaining price feeds we can then
772:09 - of course unstake everything
772:13 - and we see tokens unstaked successfully
772:16 - and that's it and this is what we're
772:17 - going to build now we aren't going to go
772:19 - over the unstaking portion of the front
772:21 - end application here right here's what
772:23 - it would look like if you were to go
772:24 - ahead and finish building out the front
772:25 - end yourself there is a full repository
772:27 - with the entire front end with this
772:29 - unstaking piece but for simplicity we're
772:31 - just going to skip over this unstaking
772:33 - bit so let's go ahead and get started
772:35 - i'm going to go ahead and make a new
772:36 - directory called defy
772:39 - stake
772:40 - yield
772:42 - brownie
772:44 - and then i'm going to open
772:46 - this up in a new text editor now the
772:48 - first thing of course that we want to
772:50 - work with
772:51 - is going to be our contract so we're in
772:53 - here remember
772:54 - always start with brownie init
772:56 - or you can start with the chain link mix
772:58 - i'm just going to go ahead and start
772:59 - with brownie unit and perfect here is
773:02 - our setup all right first thing we're
773:03 - going to do is we're going to make our
773:07 - app token dot sol
773:09 - this is going to be the token that we're
773:10 - going to give out to users who are
773:13 - staking on our platform this is our
773:14 - reward token you might have heard of
773:16 - yield farming or liquidity mining this
773:18 - is our token that allows users to
773:19 - actually engage and participate in that
773:22 - and this is just a regular old erc20 so
773:25 - you guys already know we've done this
773:26 - before and for this one we're even going
773:28 - to use the latest and greatest in
773:30 - solidity remember i said that you're
773:31 - going to have to get really good at
773:33 - bouncing around between solidity
773:34 - versions so for this one we're going to
773:36 - do everything in 0.8
773:39 - so let's go ahead and do that so we're
773:41 - going to do pragma
773:44 - solidity
773:47 - 0.8.0
773:50 - and we're going to do this the exact
773:51 - same way we made our other erc20 token
773:54 - we're going to go ahead and use open
773:56 - zeppelin again we can even just copy
773:58 - paste the import from their
774:00 - documentation or we can just write it
774:02 - out
774:03 - import
774:04 - at open zeppelin
774:07 - contracts slash token
774:10 - erc20
774:11 - erc20.sol
774:14 - and you guessed it because we're using
774:16 - this at opens up on syntax we're gonna
774:18 - make a new file
774:21 - routing config.yaml
774:23 - we're gonna make some dependencies
774:26 - we'll do open
774:29 - zeppelin slash open
774:31 - [Music]
774:32 - zeppelin
774:34 - contracts
774:35 - this time we're going to actually use
774:37 - version 4 of these
774:39 - at 4.2.0
774:41 - and again you can find out everything
774:42 - about this package by going to opens up
774:44 - when slash opens up on contracts on
774:46 - github and then compiler
774:49 - sulk
774:52 - remappings
774:55 - at open
774:57 - zeppelin
774:58 - equals
775:01 - this part right here
775:03 - paste it in okay
775:05 - great
775:06 - then what we can do
775:08 - we can go back to our dap token and just
775:10 - do some basic erc20 bits here
775:12 - so do contract
775:14 - dap token
775:15 - is erc20
775:17 - and we'll give it our constructor
775:19 - public
775:22 - erc20
775:25 - we'll call it
775:29 - depth token and we'll give it a symbol
775:31 - of dep
775:32 - and we'll give it an initial supply as
775:34 - well
775:35 - so we'll call the mint function
775:38 - and we'll set the
775:40 - meshes.sender as the owner give it an
775:43 - initial supply of one million which will
775:44 - be one one two three one two three plus
775:47 - those eighteen zeros so one two three
775:49 - four five six seven eight nine ten one
775:51 - two three four five six seven eight
775:54 - and now that we have our first contract
775:56 - we can try to compile it
775:57 - ronnie
775:59 - compile
776:01 - and looks like it worked great
776:04 - now we're gonna go on and to create our
776:06 - more interesting contract
776:09 - our token farm
776:11 - we can even take a quick second and
776:13 - figure out what we want this to be able
776:14 - to do
776:15 - well we want to be able to stake tokens
776:19 - tokens
776:21 - issue tokens this is going to be issuing
776:22 - those token rewards
776:25 - we're probably going to want to add
776:27 - allowed
776:28 - tokens to add more tokens to be
776:31 - allowed to be staked on our contract
776:34 - and we're probably going to want some
776:35 - type of
776:36 - get f value function where we can
776:38 - actually get the value of the underlying
776:40 - stake tokens in the platform with that
776:43 - in mind let's move on so
776:46 - you know the drill pragma solidity
776:49 - carrots 0.8.0
776:52 - and we're going to be here for a while
776:53 - so i'm going to close those out
776:56 - and this will be our contract
776:59 - token farm
777:01 - contract token farm oh and let's not
777:03 - forget
777:04 - our s
777:06 - pdx
777:09 - license
777:10 - identifier
777:13 - of mit well let's go ahead and start
777:15 - with the staking of the tokens right
777:16 - because that's going to be the most
777:18 - important piece of our application so
777:21 - we're going to do function
777:24 - state tokens
777:25 - you'll probably want to stake
777:27 - an amount of token
777:30 - and they'll probably want to stake
777:33 - a certain address of the token
777:35 - so
777:36 - some amount of some token
777:39 - now there's a couple things we need to
777:40 - keep in mind here what tokens can they
777:42 - stake
777:48 - how much
777:49 - can they stake
777:51 - so these are our first two questions
777:53 - for our application we're just going to
777:55 - say you can stake any amount greater
777:56 - than zero so we can even add that we'll
777:58 - do require
778:01 - amount
778:02 - is greater than zero
778:04 - and if it's not we'll just say
778:06 - amount
778:07 - must be more
778:09 - than zero
778:12 - since we're using version 8 we don't
778:14 - have to worry about anything to do with
778:16 - safe math which is awesome so we can
778:18 - just go ahead and do stuff like this we
778:20 - now we only want certain specific tokens
778:22 - to be staked on our platform so we could
778:24 - say require token
778:27 - is allowed
778:29 - or something to this effect so we might
778:30 - have to actually create a token is
778:32 - allowed function
778:33 - so let's go ahead and create that
778:35 - function
778:38 - token is
778:40 - allowed
778:42 - it'll take
778:43 - some token address make it a public
778:45 - function and it'll return
778:47 - a boolean it'll return true if that
778:49 - token's allowed or false if it's not
778:51 - allowed so how do we know if a token is
778:53 - actually allowed we probably want some
778:55 - list or some mapping of these tokens and
778:58 - whether or not they're allowed after all
779:00 - we've learned you'll probably learn that
779:01 - there definitely are some trade-offs
779:03 - between lists and mappings here for
779:05 - simplicity's sake we're just going to
779:06 - stick with a list for now
779:08 - so we're going to create an address
779:10 - array
779:12 - we'll make it public
779:14 - called allowed token
779:17 - and this will just be a list of all the
779:19 - different allowed tokens
779:21 - for our token is allowed function we'll
779:23 - just loop through this list and see if
779:25 - that token is in there
779:27 - so we'll do a for loop
779:30 - four
779:32 - uint256
779:34 - allowed tokens index
779:36 - equals zero
779:38 - allowed tokens index
779:40 - is less than
779:41 - [Music]
779:42 - allowed tokens dot length
779:47 - allowed tokens index plus plus
779:51 - so we're going to loop through this list
779:53 - and we're just going to say if
779:56 - allowed tokens
779:59 - of allow token index
780:02 - equals equals
780:05 - this token
780:08 - then we're going to return
780:10 - true
780:12 - otherwise if we get through this whole
780:14 - for loop and we don't find this token in
780:17 - here we're just going to return false
780:20 - now we have a way to check to see if
780:21 - allowed tokens are there let's actually
780:23 - write a function to add aloud tokens
780:26 - so we can do function
780:27 - add aloud tokens
780:30 - address token
780:32 - public function and we'll do allowed
780:35 - tokens and we'll just push
780:38 - it onto that array now adding allowed
780:41 - tokens is probably something we only
780:42 - want the admin wallet or the owner of
780:44 - this contract to do so we'll add only
780:47 - owner
780:48 - as a modifier to this function and we'll
780:51 - make this token farm ownable is
780:54 - ownable and we'll import from open
780:57 - zeppelin here too
780:58 - import at open
781:01 - zeppelin
781:02 - contracts slash access
781:05 - ownable.soul
781:07 - let's do a quick compile
781:12 - great things are being compiled
781:14 - fantastically now that we have a little
781:15 - bit of functionality here now might be a
781:17 - good time to actually go ahead and start
781:19 - writing some tests if you want to since
781:21 - i know that we're going to change the
781:23 - constructor a little bit and we're going
781:24 - to change a little bit of how this is
781:26 - actually formatted i'm just going to
781:27 - keep going but now might be a great time
781:30 - should i start writing some tests for my
781:31 - application
781:32 - you know we're going to do those tests
781:34 - later on anyways though all right great
781:36 - but in any case now that we have these
781:37 - two functions we can go ahead and
781:39 - actually start checking to see if the
781:41 - tokens that these stakers are going to
781:42 - stake is actually allowed
781:44 - so what we can do now is we're going to
781:46 - add this require statement in we can
781:48 - require token
781:50 - is allowed
781:52 - of token
781:54 - otherwise we'll just say token
781:56 - is currently
781:58 - not allowed
782:02 - and perfect now we have two required
782:04 - statements that answer these questions
782:05 - what tokens can they stake
782:08 - and how much can they stake so now all
782:10 - we have to do is we just have to call
782:13 - the
782:14 - transfer from function on the erc20
782:17 - remember erc20 remember erc20s have
782:20 - these two transfer type functions they
782:22 - have transfer and they also have
782:24 - transfer from
782:26 - transfer only works if it's being called
782:28 - from the wallet who owns the tokens if
782:31 - we don't own the token we have to do
782:33 - transfer from and they have to call
782:35 - approve first so we're going to call the
782:37 - transfer from so we're going to call the
782:39 - transfer from function on the erc20
782:42 - since our token farm contract isn't the
782:45 - one that owns the erc20 we also have to
782:48 - we also have to have the avi to actually
782:51 - call this transfer from function so
782:53 - we're going to need
782:54 - the ierc20 interface we could go ahead
782:57 - and pop it in here we could also make it
782:59 - near c20 contract we could also just
783:01 - grab it from openzep1
783:03 - so we'll do import
783:05 - at open
783:06 - zeppelin contracts slash token slash
783:10 - erc20
783:11 - ierc20.sol
783:14 - we're using the interface here because
783:16 - we don't need the whole contract anyways
783:18 - let's now wrap ier c20 let's wrap this
783:21 - token address
783:23 - as an erc20 token so now we have the abi
783:27 - via this interface and the address
783:30 - and we'll call that transfer
783:34 - from
783:36 - from the message.sender
783:39 - and we'll send it
783:44 - to this token farm contract so from
783:47 - whoever calls stake tokens
783:49 - to this token farm contract
783:52 - and we'll send the amount
783:55 - and perfect now we just need to keep
783:57 - track of how much of these tokens
783:59 - they've actually sent us so we're going
784:02 - to want to create
784:03 - some type of mapping here
784:05 - and this mapping is going to map token
784:08 - address
784:10 - to
784:12 - sticker address
784:13 - to
784:14 - the amount this way we can keep track of
784:17 - how much of each token each staker has
784:21 - staked
784:22 - so it's a mapping per token per staker
784:25 - per amount
784:26 - so we'll just call this
784:28 - mapping of that token address
784:32 - which is going to get mapped to
784:35 - another mapping
784:37 - of those
784:39 - user addresses which then gets mapped to
784:42 - a uni-256 so we're mapping the token
784:45 - address to the staker address to the
784:48 - amount we'll make this a public mapping
784:52 - we'll call it
784:55 - staking balance now that we have this
784:57 - mapping
784:58 - in our state token function
785:00 - what we can do is we can say staking
785:02 - balance of this token
785:05 - from message.sender
785:08 - is now going to equal whatever balance
785:10 - that they had before plus
785:14 - the amount
785:15 - all right this is great now we have a
785:16 - way for users to stake different tokens
785:19 - that we've actually allowed them to
785:21 - stake on our platform awesome work so
785:23 - what do we want them to be able to do
785:24 - next we want them to unstate tokens we
785:27 - want to be able to issue some reward we
785:29 - want to be able to get the eth value
785:31 - based on that reward typically you might
785:33 - want to do this unstake tokens bit first
785:35 - however i know that we're actually going
785:37 - to need some additional functionality in
785:40 - our state tokens function for us to
785:42 - actually issue tokens properly so let's
785:44 - just go ahead and do this issue tokens
785:46 - bit remember this issue tokens is a
785:48 - reward we're giving to the users who use
785:50 - our platform so we want to issue some
785:53 - tokens based off the value
785:55 - of the underlying tokens that they've
785:57 - given us
785:58 - so for example
786:00 - maybe
786:01 - they've deposited 100 eth and we want to
786:04 - do
786:06 - a ratio of one to one
786:08 - for every one each
786:12 - we give one depth token
786:14 - that's pretty easy for us to figure out
786:16 - however let's say they have 50 each and
786:18 - 50 die staked and we want to give a
786:22 - reward of
786:24 - one dap
786:27 - one dapp token
786:28 - per one die
786:31 - well then we'd have to convert all of
786:32 - our eath into die so we know that
786:35 - conversion ratio for the dap token so
786:38 - that's the problem that we're going to
786:39 - work on now let's create this function
786:41 - called issue tokens
786:44 - and this
786:46 - is going to be a function only callable
786:48 - again by the owner
786:51 - or the admin of this contract so how do
786:54 - we actually go ahead and issue tokens
786:55 - here well the first thought would be to
786:58 - loop through a list of all the stakers
787:00 - that we have but right now we don't have
787:02 - a list of stakers what do we have we
787:05 - have a mapping of stakers and we have a
787:07 - list of allowed tokens well we're
787:10 - probably going to need to have a list of
787:12 - stakers so we'll do an address array
787:15 - because again we can't loop through a
787:17 - mapping so we'll do an address array
787:19 - we'll make it public
787:21 - called stakers
787:23 - this is just a list of all the different
787:25 - stakers on our platform now when
787:27 - somebody stakes a token
787:29 - we're going to have to update this
787:31 - list
787:32 - we want to make sure they're only added
787:34 - if they're not already on the list
787:36 - so in order for us to do this we should
787:38 - get an idea of how many unique tokens a
787:41 - user actually has
787:43 - so i'm going to create a function called
787:45 - update
787:46 - unique
787:48 - tokens staked
787:50 - with message.sender
787:52 - and the token
787:54 - and what this function is going to do
787:56 - it's going to get a good idea of how
787:58 - many unique tokens a user has
788:00 - and if a user has one unique token we
788:03 - can add them to the list
788:05 - if they have more than one we know that
788:08 - they've already been added to the list
788:09 - so we don't need to add them there
788:11 - so let's create this
788:12 - function update unique token state
788:16 - we'll have it input an address
788:19 - user
788:21 - and an address
788:23 - token
788:24 - and we'll make this
788:27 - an internal function
788:29 - so that only this contract can call this
788:31 - function and what we'll say is if
788:37 - staking balance
788:41 - let's even do a little underscores here
788:46 - of token
788:50 - of user
788:51 - is less than or equal to zero
788:54 - we're going to update some unique tokens
788:56 - staked mapping so we'll say unique token
788:59 - staked
789:01 - of the user
789:03 - it's going to equal
789:04 - the unique token staker of the user
789:06 - plus one and since we have this new
789:08 - mapping called unique token staked we'll
789:11 - make that as well
789:13 - so we'll do a mapping
789:16 - of an address
789:18 - to
789:19 - the un256
789:22 - public called unique tokens state so
789:25 - this way we know how many different
789:26 - tokens each one of these addresses
789:28 - actually has staked now that we have a
789:30 - better idea of the unique tokens each
789:32 - one of these users has staked what we
789:34 - can do
789:35 - is we can figure out whether or not we
789:37 - want to push them onto this stakers list
789:39 - if they're already on there we don't
789:41 - want to push them on there if they're
789:42 - not on there then we do want to push
789:44 - them on there so we can just do is say
789:46 - if unique token staked
789:49 - of
789:50 - message.sender
789:52 - it's equal to one if they have one
789:55 - unique token state if this is their
789:57 - first unique token we're going to add
789:59 - them to that stakers list so we'll say
790:01 - stakers.push
790:04 - message.sender and this is going to be
790:07 - our completed sake tokens function here
790:09 - so we had to add this little extra
790:11 - functionality between the unique tokens
790:14 - to figure out how to actually issue some
790:16 - reward for them but now that we have
790:17 - this list and it's going to get updated
790:19 - here
790:20 - and it will also get updated when we
790:22 - unstake
790:23 - what we can do now is just loop through
790:25 - this list of stakers so we can say 4
790:29 - unit 256
790:31 - staker's index equals zero
790:34 - stakers index is less than stakers dot
790:38 - length
790:39 - stakers index
790:41 - plus plus
790:42 - and now we're going to issue some of
790:44 - these tokens here so we're going to say
790:46 - the address
790:49 - recipient
790:50 - equals stickers
790:54 - stakers index so one at a time we're
790:56 - going to loop through grab these
790:57 - recipients and then we're going to send
790:59 - them
791:02 - a token reward
791:05 - based on their total
791:08 - value locked
791:10 - so we got to do a couple things here we
791:12 - have to send them a token reward we have
791:14 - to figure out how to actually send them
791:16 - this token and then we also have to get
791:18 - their total value locked
791:20 - so let's do this to send them a token
791:22 - reward this is going to be this dap
791:24 - token that we created in the beginning
791:26 - this is going to be our dap token so
791:28 - right when we deploy this contract we
791:30 - need to know what a reward token is
791:33 - actually going to be so we can do
791:35 - right at the top and then i'm actually
791:36 - going to
791:38 - i'm actually just going to move this
791:39 - array
791:41 - up here so that they're all kind of
791:42 - nicely together what we need to do
791:44 - is we need to create a constructor
791:47 - right when we deploy this contract we
791:48 - need to know what is the address of the
791:51 - dap token what's the address of the
791:52 - reward token that we're going to give
791:54 - out
791:54 - so we can say constructor it will be
791:56 - passed an address of the dap token
791:59 - address
792:01 - this will be a public function
792:03 - and
792:04 - we'll store this dap token as a global
792:06 - variable
792:07 - so we can say
792:09 - ierc20 since we're already importing it
792:12 - here
792:13 - public
792:15 - dap token
792:17 - what we can do now is set depth token
792:20 - equals ierc20
792:22 - underscore
792:24 - dap token address so now we have this
792:27 - dap token with its associated address
792:30 - and what we can do now
792:32 - is call functions on it for example we
792:34 - can call
792:36 - dap token
792:37 - dot transfer
792:39 - we can call transfer here because our
792:40 - token farm contract is going to be the
792:42 - contract that actually holds all these
792:44 - dap tokens and we're going to send this
792:46 - token to
792:50 - the recipient of course
792:52 - but how much are we going to send right
792:54 - how much this of this token
792:57 - are we going to send to them well we
792:59 - need some function to get the total
793:00 - value so we're going to say u and 256
793:04 - use your total value
793:06 - equals
793:07 - some function
793:08 - right and we can go ahead and define
793:10 - that right now we'll call this function
793:13 - get user total value right or get
793:15 - recipient total value or whatever you
793:17 - want to say
793:18 - so we'll pop recipient in here and let's
793:20 - go ahead and create this function so
793:22 - we'll call function get user
793:24 - total
793:26 - value
793:27 - address
793:29 - user
793:31 - and this is where we do a lot of looping
793:33 - right we're gonna we gotta find out how
793:35 - much each of these tokens actually has
793:38 - now what a lot of protocols do instead
793:40 - of actually them sending and them
793:42 - issuing the tokens is they actually just
793:43 - have some internal method that allows
793:45 - people to go and claim their tokens
793:47 - right you've probably seen that before
793:49 - people claiming airdrops that's because
793:50 - it's a lot more gas efficient to have
793:52 - users claim the airdropped instead
793:55 - of the application actually issuing the
793:57 - tokens right it's going to be very gas
793:59 - expensive to do looping through all
794:01 - these addresses and checking all these
794:02 - addresses right we're going to do it
794:04 - though because we are a wonderful
794:07 - amazing protocol and we want to give our
794:09 - users the best experience but in any
794:11 - case this is going to be a public view
794:13 - function
794:14 - that will return
794:15 - a uin256 right because we want to return
794:19 - this total value to our issue tokens
794:22 - function up here so how do we actually
794:24 - get started here well let's create
794:27 - a unit 256
794:29 - total value
794:31 - and we'll set it off to start it to be
794:33 - zero here and let's even start it off
794:36 - with a quick require statement right we
794:38 - want to require
794:40 - that the unique
794:41 - token state
794:43 - of this user
794:45 - going to be greater than 0
794:47 - right and if it's not we'll say
794:50 - they don't have any tokens state right
794:51 - so the value is going to be nothing
794:53 - now if this is true
794:55 - if they have some token staked
794:57 - we'll go ahead and find it so we're
794:59 - going to loop through those allowed
795:01 - tokens up here
795:03 - the allowed tokens and we're going to
795:04 - find how much this user has for each one
795:06 - of these allowed tokens
795:08 - so we're going to say 4
795:10 - uint
795:11 - 256
795:12 - allowed tokens index
795:14 - equals zero allowed tokens index is less
795:18 - than allowed tokens dot length
795:21 - allowed tokens index plus plus
795:25 - and let's go ahead and we'll add the
795:28 - total value and now we'll say the total
795:30 - value is going to be equal to
795:33 - the total value plus
795:35 - however much
795:37 - value this person has in these tokens in
795:39 - this single token so get user total
795:41 - value is the total value across all the
795:44 - different tokens we need a way to get
795:45 - the total value across one token so
795:48 - we're going to create a new function
795:49 - called get
795:50 - user single token
795:53 - value
795:54 - and we'll pass it our user
795:57 - and we'll also pass it the single token
796:00 - that we're on right now so we'll pass it
796:02 - allowed tokens
796:04 - allowed token index
796:07 - so we got to create a new function here
796:09 - function get user single token value
796:12 - this is going to take an address of a
796:15 - user and an address of a token
796:18 - it's going to be a public function
796:20 - i'm just going to put this on a new line
796:21 - to make it a little easier to see it's
796:24 - going to be a view function
796:26 - and it's going to return
796:28 - a u in 256. we want to get the value of
796:31 - how much this person staked of this
796:33 - single token
796:34 - so for example if they've staked
796:37 - one each
796:39 - and the price of one eath is two
796:41 - thousand dollars we wanna make sure that
796:43 - this returns two thousand
796:46 - or if they have two hundred die stakes
796:48 - and the price of two hundred die is two
796:50 - hundred dollars we want to make sure
796:52 - this returns 200 right so we're getting
796:56 - that conversion rate we're getting
796:57 - exactly how much value this person has
796:59 - staked in our application now we'll do a
797:02 - quick if we'll say if
797:06 - token staked
797:08 - of the user
797:09 - is less than or equal to zero
797:12 - then we'll just go ahead and return zero
797:14 - right we don't want to do a require here
797:17 - right as we did up here because we want
797:21 - this to actually keep going right if
797:22 - this is zero we don't want the
797:24 - transaction to actually revert okay we
797:27 - want this to keep going so how do we
797:29 - actually get
797:30 - the value of a single token well we're
797:32 - going to need to get the staking balance
797:34 - right but we also need the price of that
797:36 - token so we're going to need to get the
797:38 - price of the token
797:40 - and then multiply that
797:42 - by the staking balance
797:44 - of the token
797:46 - of the user so once again we need to
797:49 - create another function we'll call this
797:51 - one
797:52 - get token value
797:54 - so in another function
797:57 - we're going to call get token value
798:00 - you could pass an address of a token
798:03 - we'll make this a public view function
798:06 - that will return
798:07 - a uin256
798:10 - and this of course is where we need some
798:12 - pricing information and this is where
798:14 - we're going to actually work with the
798:15 - chain link price feeds once again and
798:18 - hopefully this part is going to be a
798:19 - little bit more familiar for you
798:21 - so what we're going to need is a price
798:23 - feed
798:25 - address that's the first thing that
798:27 - we're going to need so we're going to
798:28 - actually have to map each token to their
798:30 - associated price feed addresses so we're
798:33 - going to need some mapping that does
798:34 - that right so we're going to need some
798:35 - mapping
798:36 - that's going to map
798:38 - an address
798:40 - to
798:41 - an address
798:43 - it's going to be a public one and this
798:44 - is going to be token
798:46 - price feed
798:47 - mapping right it's going to map the
798:49 - token to their associated price feeds
798:52 - and with that that means we're going to
798:54 - have to have a function
798:56 - called set
798:57 - price feed contract
798:59 - where we actually set the price feed
799:02 - associated with
799:03 - a token
799:04 - so this will take an address of a token
799:08 - and an address
799:09 - of a price fee
799:11 - this will be a public and this will be
799:13 - only owner
799:15 - we don't want anybody to be able to set
799:18 - what these price feeds should be we just
799:20 - want the owner to be able to do this
799:22 - so we'll do token price feed mapping
799:26 - of the token
799:28 - is going to equal
799:30 - the price fee and that's it so now we
799:32 - have a way to set the price feed
799:34 - contracts we have a way to map the
799:35 - tokens to their price feeds right and
799:37 - again
799:38 - go to docs.chain.link we can go to price
799:40 - feeds ethereum price feeds we can find
799:43 - these different price feeds here and
799:45 - this is where we're going to set those
799:47 - price feeds now back down in our get
799:49 - token value
799:51 - we can grab that price feed address now
799:53 - by saying
799:54 - address
799:56 - price feed address is going to equal
799:59 - that token price feed mapping
800:02 - of
800:04 - that token parameter and now that we
800:06 - have this we can use it on an aggregator
800:09 - v3 interface again we can always go back
800:12 - to the docs here we can grab this bit
800:14 - right here
800:15 - of course we're going to change it
800:19 - to 0.8
800:21 - and for those who would rather i just
800:23 - wrote it out
800:24 - we're going to import
800:27 - at chain link slash contracts slash src
800:31 - slash interfaces
800:34 - slash agreed gate or v3 interface
800:38 - dot sol
800:39 - and since we're doing this import
800:41 - we're gonna go to our browning config
800:44 - smart contract kit
800:46 - chain link
800:48 - brownie contracts
800:50 - and we're going to see what's the latest
800:52 - version of these
800:53 - now i'm going to point something out
800:55 - this package recently changed to mirror
800:57 - the mpm package versions so it does look
801:00 - like it went backwards in versions and
801:02 - there's even a little little update here
801:05 - but this is the the newest version even
801:08 - though it's a 0.2.1 it's literally just
801:10 - to match the mpm contract tags
801:13 - so this is what we're going to use so
801:14 - we're going to at 0.2.1
801:17 - and then in our remappings we'll also do
801:20 - at chain link
801:22 - equals
801:24 - this bit right here
801:26 - now that we've imported that we can now
801:28 - grab that aggregator v3 interface
801:34 - or that price feed
801:38 - and say
801:39 - aggregator v3 interface of price feed
801:42 - address
801:45 - and grab that price feed contract then
801:47 - once we have this price view contract we
801:49 - can call
801:50 - dot latest
801:52 - round data
801:54 - and again you can always check back to
801:56 - the documentation to see what that
801:57 - function actually looks like and this is
801:59 - going to return it's going to return a
802:01 - whole bunch of stuff
802:02 - but we only care about the price so the
802:05 - first thing it returns is round id
802:08 - we don't care about that so we'll just
802:09 - put a comma
802:10 - we do care about the n256 price so we'll
802:13 - put that in there but we don't care
802:15 - about the rest of these
802:16 - so we'll just do
802:18 - comma comma comma
802:19 - because we only care about the price
802:20 - here
802:22 - we also care about the decimals we need
802:24 - to know how many decimals the price feed
802:26 - contract has that way we can match
802:28 - everything up to be using the same units
802:31 - so we'll say u and 256
802:33 - decimals
802:35 - equals price fee dot
802:37 - decimals
802:39 - and what we can do now is we can return
802:41 - both of these so this actually needs to
802:43 - return a un256 and another uint 256.
802:49 - put the decimals here
802:51 - and we do return
802:53 - we can return both of these so we'll do
802:55 - a uint
802:57 - 256 price we'll wrap that price into a u
803:00 - and 256 and then we also need to wrap
803:05 - the decimals in the u and 256 since
803:07 - decimals actually returns a u uint eight
803:10 - so we'll return the price and the
803:12 - decimals all right now we're cooking
803:16 - now
803:17 - we can go ahead and start scrolling back
803:19 - up and adding all this stuff in so we
803:20 - can say you and 256
803:22 - price you went 256 decimals
803:27 - equals
803:28 - this get token value that we just
803:30 - created right here and then we can just
803:32 - have this return
803:33 - staking balance
803:35 - of the token
803:38 - of the user times the price
803:42 - and do some interesting math here
803:44 - divided by those decimals
803:46 - 10
803:47 - raised to
803:49 - decimals
803:51 - and i know there's a little bit of math
803:52 - here right and so you might be going
803:53 - wait wait what are we doing here wrap
803:55 - that up like that just so that we're
803:57 - absolutely certain we're doing correct
803:58 - order of operations here
804:00 - so we're taking the amount
804:02 - of token that the user has staked right
804:05 - let's say for example
804:07 - 10 die
804:09 - and we're taking the price of that die
804:11 - maybe we have
804:12 - all of our contracts all of these tokens
804:15 - get converted back to the usd price so
804:17 - we have die
804:18 - usd actually better yet let's say we
804:21 - have 10 eth
804:22 - right our price feed contract is going
804:24 - to be eth usd
804:27 - let's say the price
804:28 - is is 100 100 dollars per usd
804:32 - so this first bit is we're going to do
804:34 - that 10 eth
804:36 - times 100 so we're going to do 10
804:38 - times 100 which is going to equal to
804:41 - 1 000. 1000 value the only thing is we
804:45 - also have to divide
804:46 - by the decimals so our staking balance
804:50 - is going to be in 18 decimals so it's
804:52 - going to be one two three four five six
804:54 - seven eight one two three four five six
804:55 - seven eight nine ten
804:57 - but let's say our fusd only has eight so
805:01 - one two three four five six seven eight
805:04 - so we need to multiply these first
805:06 - and then divide by the decimals that way
805:09 - we can arrive at a price that actually
805:11 - makes sense is going to be a function
805:13 - that we're definitely definitely
805:14 - definitely going to need to test to make
805:16 - sure that we're doing everything right
805:18 - so that we're doing all the math
805:19 - correctly but okay now that we have this
805:22 - user single token value we go ahead
805:26 - and come back up to our user total value
805:28 - and we can literally finish this
805:30 - function by just calling return
805:32 - total value
805:33 - and then we can pull up to our issue
805:36 - tokens now that we have the total value
805:39 - that this
805:40 - user has actually logged we can just
805:42 - transfer the amount of tokens that they
805:45 - have in total value so we can say dap
805:48 - token
805:50 - dot transfer
805:52 - this recipient we can transfer them
805:55 - the total value right we'll say however
805:57 - much they have in total valued staked on
805:59 - our platform we'll issue them as a
806:01 - reward and that is our issue tokens
806:03 - function we are making great progress
806:06 - all right so we have a way to stake done
806:10 - we have a way to issue
806:12 - done
806:13 - we have a way to get
806:15 - value or just get value
806:18 - done
806:19 - we've added a way
806:20 - [Music]
806:21 - to add allowed tokens and all we have to
806:23 - do now is add some way to unstake the
806:26 - tokens
806:27 - so let's go ahead and create this
806:28 - function
806:30 - i'm going to make it right underneath
806:32 - the state token one
806:34 - we'll do function
806:35 - unstake tokens
806:38 - we'll do we'll pass it the token address
806:41 - we'll make this a public function so
806:43 - anybody can call this the first thing
806:45 - we're going to want to do
806:46 - is fetch the staking balance how much of
806:49 - this token does this user have so we'll
806:51 - see you in 256
806:53 - balance equals
806:56 - staking balance
806:57 - of the token
806:59 - from message.sender
807:02 - and we're going to require
807:05 - the balance
807:07 - is greater than zero
807:09 - otherwise we'll say staking
807:12 - balance
807:13 - cannot be zero
807:17 - and then we're going to do a transfer
807:19 - so we'll do ierc ierc20
807:22 - of the token
807:24 - dot transfer
807:26 - message.sender
807:29 - balance
807:31 - once we actually transfer the token
807:33 - we'll do staking balance
807:37 - of this token
807:39 - of message.sender
807:41 - we're going to update this balance
807:43 - to now be zero right because we're going
807:45 - to transfer the entire balance here and
807:47 - then we're going to update how many of
807:49 - those unique tokens that they have
807:51 - now a quick note here later on we're
807:53 - going to learn about reentrancy attacks
807:55 - so at some point come back here and
807:57 - figure out hey is this vulnerable to
807:59 - re-entrance the attacks so we'll say
808:01 - unique
808:02 - token staked
808:04 - of message.sender
808:06 - it's going to equal
808:08 - unique token state
808:11 - message.sender
808:13 - minus 1.
808:14 - now the last thing that we could do is
808:16 - we probably should actually update our
808:19 - stakers array
808:20 - to remove this person if they no longer
808:23 - have anything staked this is a little
808:25 - bit sloppy but we're just going to skip
808:27 - doing that for the time being however if
808:29 - you want to go back and add the
808:30 - functionality to remove the stakers from
808:33 - the stakers list as they unstag please
808:35 - go for it it's not a big deal if we
808:37 - don't actually do this because our issue
808:39 - tokens function is actually going to
808:41 - check to see how much they actually have
808:42 - staked and if they don't have anything
808:44 - staked then they're not going to get
808:45 - sent any tokens
808:46 - but all right that's basically all of
808:48 - the functionality here
808:50 - let's just try a quick sanity check with
808:52 - a brownie compile
808:54 - whoops i forgot to add v0.8 in here
808:58 - let's try again that little bit
809:00 - this needs to be token
809:02 - and this needs to be user whoops and
809:05 - then it looks like i did the same thing
809:07 - down here this is actually staking
809:09 - balance
809:10 - let's try it again
809:13 - and perfect everything is at least
809:14 - compiling correctly just because it's
809:17 - compiling correctly though doesn't
809:18 - necessarily mean that we're doing
809:20 - everything correctly
809:21 - so this is fantastic typically now we'd
809:24 - want to go ahead and start doing our
809:25 - tests i'm actually going to go ahead and
809:27 - build one of our scripts first the
809:29 - reason i'm going to build one of the
809:30 - scripts first is because i'm going to
809:32 - use my deploy script pretty regularly in
809:34 - my test i'm going to use it as part of
809:36 - my testing this way i can also test some
809:39 - of my scripts as well in addition to the
809:41 - contracts so let's go ahead and make our
809:43 - deploy script
809:45 - so let's create a new file in here
809:47 - we'll call it deploy.pi
809:50 - we'll also create
809:52 - an init.pi for those of you on older
809:54 - versions of python and let's go ahead
809:56 - and do this so we're going to have a
809:58 - main function in here and in our main
810:00 - function we're actually just going to
810:01 - call deploy
810:04 - token farm
810:06 - and
810:08 - dap token
810:10 - and then we're going to have a function
810:12 - def
810:13 - deploy
810:14 - token farm
810:16 - and
810:21 - token
810:23 - right and i should be able to run
810:26 - running run scripts deploy.pi
810:30 - and great everything's compiling right
810:32 - and we're running our scripts here so
810:34 - first thing that we're going to want to
810:35 - do as always is get our account and i am
810:38 - going to copy a couple of those helpful
810:40 - scripts from our past projects so i'm
810:43 - actually going to pull up our nft demo
810:45 - that we did so i'm actually going to go
810:48 - to our chain link mix that we did i'm
810:50 - going to grab our helpful scripts
810:52 - remember we can always jump onto the
810:54 - chain link mix here and we can just grab
810:56 - some of the scripts from here so we
810:57 - could go to scripts helpful scripts and
810:59 - just copy paste this whole thing or just
811:01 - grab it like i did right these are going
811:02 - to be those exact same scripts that we
811:04 - built previously so now we have our
811:06 - helpful scripts in here right we're
811:08 - going to have this contract to mock for
811:10 - running our tests we have get account so
811:13 - we can get our accounts easily we have
811:15 - encode function data which we're not
811:17 - going to have to work with since we're
811:18 - not doing upgradable contracts but we
811:20 - have it here anyways we have upgrade
811:22 - which we're also not going to use but we
811:24 - have it here anyways we have get
811:26 - contract which returns mocks if they're
811:28 - not already deployed or it just returns
811:30 - whatever contract that we're looking for
811:33 - and then of course we have our deploy
811:35 - mox script here so now we can do from
811:38 - scripts dot helpful scripts
811:42 - import
811:43 - get account
811:45 - and perfect we can get our account like
811:48 - that no problem now and now we're going
811:49 - to want to start deploying some
811:51 - contracts so we're going to deploy that
811:53 - dap token first so we'll do from brownie
811:56 - import dap token and we'll do
811:59 - dap token
812:01 - equals
812:03 - gap token
812:04 - dot deploy
812:06 - and this takes no parameters so we can
812:08 - just do from
812:10 - count
812:12 - then we're going to want to deploy our
812:13 - token farm
812:15 - so we could say tokenfarm equals
812:17 - tokenfarm.deploy
812:20 - and this takes one parameter which is
812:22 - the dap token address right because we
812:24 - need that address so we can give it out
812:26 - as a reward so we're going to say
812:28 - dab token dot address we'll do a comma
812:32 - and then we'll say from
812:34 - account
812:37 - and we'll need to import this
812:38 - from
812:40 - brownie as well and while we're here we
812:42 - might as well add some publish source
812:44 - bits on here so we can say publish
812:47 - source equals
812:49 - config we'll grab this from the config
812:53 - networks
812:56 - network dot show active
813:00 - verify
813:03 - grab network from brownie
813:06 - grab config from brownie
813:08 - and in our
813:09 - config here
813:10 - let's do networks
813:13 - lad development
813:15 - we'll set the verify here
813:18 - to be false
813:19 - and then we're going to work with the
813:20 - coven chain
813:22 - so we'll say coven
813:23 - verify will also be false actually kovan
813:26 - sorry covenant will be true
813:28 - and then we'll do a persistent ganache
813:31 - or verify for this will be false
813:35 - and i'm even just going to put this up
813:36 - here so that all these
813:39 - ganache chains are kind of with each
813:40 - other so we'll verify in coven but we
813:42 - won't on development or ganache
813:45 - now once we've deployed this token farm
813:47 - contract we need a couple things right
813:49 - we're going to need to send this some
813:51 - dap tokens right we're going to need to
813:53 - send pretty much all the dap tokens so
813:55 - that i can actually give those tokens
813:56 - out as a reward so we're going to want
813:59 - to do a transaction it's going to equal
814:01 - to
814:02 - dap token
814:03 - dot transfer
814:05 - we'll send it to the token farm
814:07 - address and then we have to choose how
814:09 - much we're going to send and we'll send
814:11 - the total supply
814:12 - but we'll keep a little bit for
814:14 - ourselves so we can do some testing and
814:16 - so just in case so we'll also do minus
814:19 - kept
814:20 - balance some static kept balance which
814:23 - we can say
814:25 - at the top
814:26 - we'll say the kept balance is let's keep
814:28 - like 100
814:29 - so this will be equal to
814:31 - web 3.2 way
814:33 - 100
814:35 - ether
814:37 - so we'll do
814:38 - from web 3
814:40 - import web 3. so in our transfer we'll
814:43 - do
814:44 - dab token dot total supply minus the
814:46 - kept balance and then of course we're
814:48 - gonna have to do a from
814:50 - [Music]
814:52 - account
814:53 - so now we're sending
814:55 - our token farm basically 99.9
814:58 - of the total supply of this dap token so
815:00 - that it has this token to actually give
815:02 - out as a reward we'll do a tx
815:05 - dot wait we'll wait for one block
815:07 - confirmation there now what do we want
815:09 - to do well if we look at our token farm
815:11 - we know at our state tokens function we
815:14 - can only stake tokens that are allowed
815:16 - in each one of these tokens also is
815:18 - going to need to have some price feed
815:21 - associated with it right and our token
815:23 - price feed mapping
815:24 - so we're going to have to add those so
815:26 - what we're going to want to do is we're
815:27 - going to want to create a function
815:28 - called add
815:30 - allowed tokens and what this is going to
815:32 - do it's going to add the tokens that we
815:34 - want to allow and it's going to give
815:36 - them a price feed contract associated
815:38 - with them so let's create this function
815:40 - we'll call it def
815:42 - add allowed tokens and this is going to
815:45 - take a couple things we're going to want
815:46 - to take that token farm because we're
815:48 - going to need to call the add aloud
815:50 - tokens function on it we're going to
815:52 - take a dictionary
815:54 - of
815:55 - allowed tokens and this is going to be
815:57 - the names this is going to be a
815:59 - dictionary of the different token
816:01 - addresses and their associated price
816:04 - feeds so we're just going to price
816:05 - everything in usd so so we can figure
816:07 - out the value of everything in usd and
816:09 - then last of course we're going to need
816:11 - an account
816:12 - for now i'm just going to do pass here
816:14 - let's look at the different inputs that
816:16 - we're going to put into this so
816:17 - obviously we're going to do token farm
816:18 - but then we're going to need to make
816:19 - this dictionary of allowed tokens so
816:21 - we're going to need the address of the
816:23 - different tokens that we want to have
816:25 - now how do we get the addresses of the
816:26 - different tokens that we're going to use
816:27 - and what are the tokens that we're even
816:29 - going to use here
816:30 - for simplicity we're just going to start
816:32 - with three tokens we're going to allow
816:34 - our platform to allow three different
816:36 - tokens to be state we'll use the dap
816:37 - token
816:39 - as one
816:41 - we use weth token or wrapped eth because
816:44 - that's pretty much a standard in most
816:46 - smart contract platforms and then we're
816:47 - also going to use an fau token which
816:50 - stands for faucet token and we're going
816:52 - to pretend that this fafsa token is dye
816:55 - or dai the reason we're going to use
816:57 - this faucet token is because there's
816:59 - this erc20 faucet.com which allows us to
817:01 - get this fake faucet token we can get
817:03 - unlimited amounts of this faucet token
817:05 - on different test nets we're going to
817:07 - pretend that this faucet token is going
817:08 - to be die right so fau token slash die
817:12 - so how do we actually get these
817:13 - addresses well dap token we know with
817:16 - token
817:18 - what we can do in our config so we can
817:20 - actually add those addresses here
817:22 - so for coven
817:24 - the weath token address is going to be
817:27 - this right here which again you can go
817:29 - check this out
817:30 - and you can find it on etherscan you can
817:33 - write your own if you want we're just
817:34 - going to use this already deployed one
817:36 - on coven fau token which is gonna be
817:38 - this token here which i know is gonna be
817:42 - this address right here
817:43 - and if you want you can come here
817:45 - and grab your address
817:47 - paste it into this erc20faucet.com
817:50 - put an amount of 10 in here
817:52 - connect to metamask oh and even tells us
817:55 - the token address right here which we
817:57 - can just copy paste we can do mint free
817:58 - tokens confirm
818:00 - great says success if we don't already
818:02 - have it we can take this token address
818:04 - go to our meta mask
818:06 - assets
818:07 - add token paste it in i've already got
818:09 - it
818:10 - we can see right now i have 5 fau
818:13 - once this confirms i'll have an
818:15 - additional 10 and now you can see 15
818:17 - here this is going to be this fau token
818:19 - that we're going to use we have wes here
818:21 - and then we know
818:23 - what the depth token address is going to
818:24 - be
818:25 - for when we deploy it here
818:26 - now we could do again we could do the
818:28 - config
818:30 - you know networks
818:31 - etc and just always get it from our
818:33 - config
818:34 - or we could use our get contract method
818:37 - that we grab from our helpful scripts
818:39 - which will deploy a mock weath token it
818:42 - doesn't exist in one of these and that's
818:43 - what we want because we're going to want
818:45 - to test this locally so we're going to
818:46 - want to deploy our own fake weath token
818:49 - so we'll say the weath token
818:51 - equals get contract
818:53 - with token
818:55 - and then the fau token
818:57 - is going to be get contract
818:59 - fau token and remember what we put in
819:01 - here our string that we put in here
819:03 - needs to match our string in our config
819:06 - now in order for this get contract to
819:07 - work for weth token and the fau token
819:09 - we're actually going to have to modify
819:11 - our helpful scripts here so if we copied
819:13 - and pasted it directly from our chain
819:16 - link mix this is basically what we're
819:17 - going to have here we're importing all
819:19 - of our mocs which we can go ahead and
819:22 - copy paste these as well from the chain
819:24 - link mix our test our mock contracts
819:27 - here
819:28 - we have some forking implementations we
819:30 - have contracts to mock which tells us
819:32 - based off of the key
819:34 - what token or what contract we use to
819:36 - mock we have get account which we use
819:38 - all the time in order for us to do this
819:40 - contract to mock correctly we're going
819:42 - to have to mock west and fau and
819:45 - actually we don't even need all these in
819:47 - here we don't even need this whole
819:48 - contract to mock in fact we can get rid
819:50 - of
819:51 - mock oracle we can get rid of vrf
819:52 - coordinator and we can even get rid of
819:54 - the link token for this we do need this
819:56 - sdusd price feed later on
819:59 - so i'm just going to leave it in here
820:00 - for now we definitely do need though fau
820:02 - token which is going to be mocked to
820:04 - something and we need weth token which
820:07 - was going to be mocked to something else
820:09 - so what are these tokens going to be
820:11 - mocked to well they're each an erc20
820:14 - mock but we want to give them kind of
820:15 - their own identity so what we're going
820:17 - to do is we're actually going to make a
820:19 - mock erc20 for both fau
820:22 - and for web so we're going to come in
820:24 - here we're going to do new file we'll
820:26 - call it mock die
820:28 - dot sol
820:29 - and this is going to mock that fau token
820:31 - so it could be mock die it could be mock
820:33 - fau whatever we want it to be and we're
820:35 - just going to make this a basic erc20 so
820:37 - we'll do pragma
820:39 - solidity
820:41 - 0.8.0
820:44 - we'll import at open
820:46 - zeppelin
820:47 - contracts token
820:50 - ear c20 your c20.sol obviously this is
820:53 - going to look
820:54 - very familiar this should spell pragma
820:57 - not whatever i just spelled this is
820:59 - going to look really similar to that dap
821:00 - token so now we can call contract
821:04 - mock die
821:05 - is erc20 and we'll do constructor
821:08 - public erc20
821:12 - mock die
821:14 - will be the name of this
821:16 - and the symbol will be die and perfect
821:18 - and that's all we need we'll copy this
821:20 - whole thing and then we'll do the same
821:22 - thing for
821:23 - mockweath.soul we'll paste this whole
821:26 - thing in here
821:27 - and we'll just change the name call this
821:29 - mock west
821:30 - crc20
821:32 - mock weft
821:34 - and this will be
821:35 - what token right so now that we have
821:37 - those mocks in here we can change fau
821:40 - token to
821:41 - mock die
821:42 - and west token to
821:44 - mock weft we can import those from
821:46 - brownie and in fact we can get rid of
821:48 - the mock oracle here and the vrf
821:50 - coordinator
821:51 - instead we'll do mock die
821:54 - and mock west
821:56 - now of course since we have diusd price
821:58 - feed and fusd price feed we're going to
822:00 - make sure we have these in our mocks
822:03 - here and then we're also gonna have to
822:04 - deploy these in our deploy mox script
822:06 - below
822:08 - so if we scroll down to deploy mocks we
822:10 - can see this is what it currently has
822:12 - which is pulling directly
822:15 - from the chain link mix so we just go
822:17 - ahead
822:18 - delete the vrf coordinator mark and the
822:20 - mach oracle and instead
822:22 - we'll deploy
822:24 - those that mock weath and that mock die
822:27 - so we'll do print
822:30 - deploying mock die
822:33 - die token equals
822:36 - mock die dot deploy
822:40 - from
822:41 - account
822:43 - and then we'll do print
822:45 - f statement
822:46 - floyd to
822:48 - die token.address
822:51 - and then we'll do
822:52 - print
822:54 - deploying
822:55 - mock mock web
822:57 - and then we'll do
822:58 - [Music]
822:59 - left token
823:00 - equals
823:02 - mock west dot deploy
823:04 - we'll say from
823:06 - account
823:09 - and then we'll print
823:13 - this deployed
823:13 - be another printf
823:15 - with token.address
823:19 - now additionally
823:21 - we have our fusd price feed left over
823:25 - from the chain link mix we also need
823:27 - this die usd price feed
823:30 - so we can go ahead in here
823:32 - we'll add
823:34 - usd price feed
823:35 - and we'll set this as a mach v3
823:38 - aggregator we could do is we could
823:40 - parameritize this up so that the mock v3
823:42 - aggregator takes maybe some different
823:44 - decimals a different initial value so
823:46 - that these could be different
823:48 - but for the sake of testing we're just
823:49 - going to leave them being the same here
823:51 - so great so we have the address of the
823:53 - wet token we have the addresses of the
823:56 - fau token and if those don't exist on
823:59 - the network we're working on we're going
824:00 - to deploy a mock so now that we have all
824:02 - these addresses we can do a dictionary
824:04 - of allowed tokens
824:06 - is going to be equal
824:07 - to this dictionary that we make so we're
824:10 - just going to route each one of these
824:12 - contracts like the depth token
824:14 - to
824:16 - its equivalent price feed for the dap
824:18 - token we're just going to say that the
824:19 - dap is going to be equal to die
824:22 - we're going to say the fau token
824:24 - is also equal to die
824:26 - and our weath token
824:28 - of course is going to be equal to eth
824:31 - so we're going to want to get a usd
824:33 - price feed another di usd price feed
824:36 - and an f usd price feed so in our config
824:41 - we can add i usd
824:42 - price feed
824:44 - and since we're going to be testing
824:46 - since we're going to be doing our
824:46 - integration test on coven here
824:49 - we'll come to the chain link docs
824:52 - we'll go to ethereum price feeds
824:55 - we're on coven
824:58 - and we'll scroll down to
825:00 - dye usd
825:02 - which is this address right here
825:04 - pop that in and then we'll also want the
825:07 - fusd price feed
825:11 - which we'll also go grab that from here
825:13 - on the coven network and we'll grab that
825:16 - from right here
825:17 - and we'll paste it in
825:19 - so now to complete this deck we can do
825:21 - this get contract again and we'll deploy
825:24 - mock price feeds if they don't exist
825:26 - so now we can just do
825:29 - get contract
825:30 - die usd price feed
825:34 - fau token is also going to be usd price
825:36 - feed
825:37 - and then our weft token is going to be
825:41 - fusd price feed and awesome now we have
825:44 - our dictionary of allowed tokens that we
825:46 - can pass to our ad allowed tokens this
825:48 - will map
825:49 - the tokens and their addresses with
825:51 - their associated price feeds so we can
825:54 - get them all to equal the same value in
825:56 - our contracts so we can go ahead and
825:58 - create this function called add allowed
826:01 - tokens we'll pass it this token farm
826:03 - we'll pass it the dictionary of allowed
826:05 - tokens and then of course we'll pass it
826:08 - the account
826:09 - now in our add allowed tokens function
826:12 - we're going to loop through all these
826:13 - different tokens and call the add allow
826:16 - tokens function on it so we're gonna do
826:17 - four
826:18 - each token in the dictionary of allowed
826:21 - tokens we're gonna do tokenfarm.add
826:25 - allowed tokens
826:26 - and we'll do the token.address and we'll
826:28 - do from
826:30 - account
826:32 - we'll say
826:34 - add tx equals that
826:37 - we'll do add tx dot weight
826:40 - 1
826:41 - then we're going to call this set price
826:44 - feed contract so we're actually going to
826:45 - set the price feed associated with that
826:48 - token
826:49 - so we'll do
826:50 - set tx
826:52 - equals token farm
826:54 - dot set price feed contract
826:58 - and we'll do token.address
827:01 - the dictionary of allowed tokens
827:04 - of
827:05 - that token that we're for looping
827:08 - and then of course
827:09 - from
827:11 - account
827:12 - and we'll do
827:13 - set text.wait one
827:16 - and then we'll just return
827:18 - the token farm but we probably don't
827:19 - have to return anything and great that
827:21 - deploy script looks pretty good and in
827:23 - fact we're going to end our deploy
827:25 - script here with returning token farm
827:28 - and
827:29 - adapt token this way we can actually use
827:31 - this deploy script in our tests so i'm
827:34 - just going to do a quick little zoom out
827:36 - and we can see
827:38 - our wonderful deploy script right here
827:40 - and awesome it looks like we have just
827:42 - about everything here
827:43 - let's give this an initial test
827:47 - on a local ganache chain see if our
827:49 - mocks all work see if everything at
827:51 - least makes sense we can call our
827:52 - functions awesome it looks like we can
827:54 - call all of our functions
827:56 - and we can deploy our mocks and the
827:58 - mocking is working at least somewhat
828:01 - correctly here this is great we'll zoom
828:04 - out a little bit here we've got our
828:05 - deploy scripts we've got our ad allowed
828:07 - token scripts we've got all of our mock
828:10 - contracts added under tests things are
828:13 - looking good now what do we want to do
828:16 - here
828:16 - well of course we want to run some tests
828:20 - we want to make sure our contract is
828:23 - actually going to do
828:24 - what we say it's going to do you guys
828:26 - ready let's jump into it so in our tests
828:29 - let's make a new folder called unit
828:32 - we'll add a new file we'll call it test
828:35 - token farm dot pi let's do some tests
828:39 - now ideally we would also write some
828:41 - tests for our dap token however we're
828:44 - going to skip over those because we're
828:45 - basically just doing open zeppelin's
828:47 - implementation
828:48 - but in a full-scale production here you
828:51 - probably would want to write some tests
828:53 - on your tokens as well so let's get into
828:55 - this let's look at our token farm and
828:58 - see what we need to test remember
829:01 - ideally every piece of code in our smart
829:04 - contract here should be tested in some
829:06 - form or another so with that in mind
829:09 - let's get started so one of the first
829:11 - functions that we see is set price feed
829:14 - contract so let's make a test for that
829:16 - so we'll do def
829:18 - test
829:20 - set
829:21 - price
829:22 - feed contract
829:24 - and we're literally gonna test just this
829:27 - one function so how do we test that well
829:29 - first let's make sure we're on a local
829:32 - network right because we only want to be
829:34 - doing this
829:35 - on our local network since this is one
829:37 - of our unit tests
829:38 - so in our arrange stage
829:40 - we're going to do if
829:42 - network dot show active
829:44 - is not in
829:46 - local
829:47 - blockchain
829:49 - environments
829:51 - then we're going to run pi test.skip
829:54 - and say only
829:55 - for
829:58 - local testing of course we've got a
830:00 - number of pieces here that we need to
830:02 - import we're going to do from browning
830:05 - import network
830:08 - we're going to do from
830:10 - scripts.helpfulscripts
830:13 - import local blockchain environments and
830:16 - then
830:16 - we're going to import
830:18 - pi test all right so now we're going to
830:20 - get an account
830:21 - to make these transactions we'll say
830:23 - account equals get count and let's grab
830:26 - that for my helpful scripts as well so
830:29 - now we have an account we can use let's
830:32 - even grab a non-owner account so we'll
830:35 - say non-owner
830:36 - equals get account
830:38 - and we'll do index equals one this will
830:41 - give us a different account rather than
830:43 - this account and we'll use this to check
830:45 - some only owner functions and then what
830:47 - we're going to do is we're going to get
830:48 - the token farm
830:50 - and the dap token
830:52 - based off of
830:54 - our deploy script so we're going to use
830:56 - this deploy token farm and dap token
830:59 - we're going to import that by saying
831:00 - from
831:01 - scripts.deploy
831:04 - import
831:05 - deploy token farm and dap token and
831:07 - we're just going to call this function
831:09 - in our test right here so we're going to
831:11 - say token farm dap token equals deploy
831:14 - token farm and dap token awesome this is
831:17 - how we're going to do this a lot this
831:18 - arrange step for a lot of these tests
831:21 - here because this is how we're going to
831:22 - set them up we could even hypothetically
831:24 - turn this into a conf test or into a
831:26 - wrapper if we wanted to but we're just
831:28 - going to leave it in here like this for
831:30 - now now we can move on to our act phase
831:32 - so we're going to want to do
831:34 - token farm
831:35 - dot
831:36 - set price feed contract
831:40 - because remember
831:41 - this is what we're testing right now and
831:43 - we're going to use
831:45 - a token and a price feed address so we
831:47 - use the dap token dot address we'll use
831:50 - get contract to actually get an fusd
831:54 - price feed address
831:57 - which we can also grab
831:59 - for my helpful scripts get contract an
832:02 - important note here if you try to set a
832:04 - contract as an address parameter like
832:06 - this ronnie will know okay that you're
832:09 - looking for an address instead of the
832:11 - actual contract in any case then we'll
832:13 - do from
832:14 - account
832:17 - save it and it re-shifts over here now
832:20 - this should work perfectly so we're
832:22 - going to assert this
832:23 - we're going to move into our assert
832:25 - stage right
832:26 - if we check our price feed mapping
832:29 - this should now be updated
832:31 - so we can do
832:33 - assert
832:34 - token farm
832:36 - dot token price feed
832:38 - mapping
832:40 - and remember
832:41 - token price feed mapping is an address
832:43 - to an address so we'll say dap token
832:47 - dot address this should be equal to
832:49 - get contract
832:51 - of fusd
832:53 - price feed
832:54 - this should be updated with exactly what
832:57 - get contract of fuc price feed returns
833:00 - in fact we can even make this a little
833:01 - bit better
833:02 - copy this we'll say
833:05 - price feed address
833:08 - equals get contract and then we'll
833:11 - pop this in here and we'll pop this here
833:16 - that way now we're just using this
833:17 - single variable for both
833:19 - all right that's our first test let's
833:21 - run it brownie
833:23 - test this will run the whole test suite
833:27 - and we're passing awesome now let's also
833:30 - do a test
833:31 - to make sure that
833:33 - non-owners can't call this function we
833:36 - want to make sure that somebody other
833:38 - than the owner who deployed this right
833:40 - because deploy token farm and dap token
833:42 - is going to be run by get account we
833:45 - want to make sure that
833:47 - somebody else can't call this function
833:49 - so we'll do with pi test dot raises
833:53 - exceptions dot virtual machine error
833:58 - excuse me for that
834:00 - getting in the way and then we'll try to
834:02 - call this exact same function here right
834:06 - we can even just copy paste it
834:08 - but instead we'll
834:10 - call it from non-owner
834:12 - right
834:14 - and then we do also have to import
834:15 - exceptions from browning so this should
834:18 - also pass
834:20 - it's expecting this contract call to
834:22 - actually revert so let's try this
834:24 - perfect it passes
834:26 - right we can double check to make sure
834:27 - that this pi test.raises is working
834:29 - because what if we did a count here
834:31 - right
834:32 - this now should fail because this isn't
834:35 - going to revert and that's exactly what
834:36 - happens perfect so we can leave this as
834:38 - non-owner and our first test is looking
834:41 - great let's even zoom out just a hairier
834:44 - we can sleep easy that this function is
834:46 - going to work as we intended isn't that
834:48 - a wonderful feeling yes it is great
834:50 - let's move on so let's look at our token
834:53 - farm what's the next function aha
834:55 - issue tokens all right great let's write
834:57 - some tests for issue tokens so what are
835:00 - we going to do
835:01 - def
835:02 - test
835:03 - issue
835:04 - tokens so how are we actually going to
835:07 - do this well in order to test issuing
835:09 - tokens
835:10 - we actually need to
835:12 - stake some tokens first
835:14 - so for now i'm actually just going to do
835:16 - pass here and before we test issuing the
835:19 - staking tokens we need to write a test
835:22 - for staking those tokens right because
835:24 - in order to issue tokens you need to
835:26 - have some tokens state so let's write a
835:28 - test
835:29 - stake tokens first and then we'll write
835:31 - this test issue tokens so we'll do def
835:34 - test
835:35 - stake
835:37 - tokens
835:39 - now let's set this up
835:40 - so we're going to copy this bit here
835:44 - because we are going to be working on a
835:46 - local network with this we'll do account
835:49 - equals get account and then
835:52 - we'll go ahead
835:53 - and deploy the token farm and the dap
835:56 - token so
835:57 - this initial bit is going to be exactly
836:00 - the same making sure we're on a local
836:02 - network getting the account deploying
836:04 - the token farm and the dap token
836:06 - so now let's move into the act phase
836:09 - let's go ahead and act let's go ahead
836:11 - and actually send some tokens to our
836:14 - token farm so first we obviously need to
836:16 - call approve on the dap token contract
836:20 - so we'll do dap token
836:22 - dot approve
836:24 - to the token farm dot address
836:27 - and again you can see and again we can
836:29 - go to the open zeppelin docs to figure
836:31 - out what the parameters of this are but
836:33 - it's going to be an address and it's
836:34 - going to be some amount and then
836:36 - obviously from
836:38 - account
836:40 - now i put a couple question marks here
836:42 - because we're going to constantly be
836:44 - using an amount right we're going to be
836:47 - using an amount staked for a lot of our
836:50 - tests here
836:51 - so what we're going to do is we're
836:52 - actually going to turn that into a
836:53 - fixture
836:54 - we're going to call it
836:56 - amount
836:57 - state and we're going to define this in
836:59 - our conf test folder so we're going to
837:01 - make our conf test file so in here we're
837:03 - going to do new file
837:04 - conf test dot pi
837:07 - and whoops it's in the wrong directory
837:10 - so we're going to go cd tests
837:12 - units
837:12 - i'm gonna do move
837:14 - confidence.pi
837:16 - down one directory and it should be in
837:18 - here now if that didn't work you should
837:20 - be able to drag and drop it
837:22 - uh into test you just wanna pull it out
837:24 - of unit is what we're doing here right
837:26 - just want to get it so that's just in
837:28 - this test directory here in the case in
837:30 - our conf test.pi we're going to create
837:32 - our first fixture
837:34 - so we're going to do at pi test.fixture
837:37 - we'll do def amount staked
837:40 - and then we're just going to return
837:42 - web3
837:44 - dot 2 way
837:46 - one
837:47 - ether now of course we need to import pi
837:49 - test here
837:50 - then we're going to need to import we're
837:52 - going to do from web3
837:55 - import web3 and now
837:58 - it saves
837:59 - perfectly so now we can use this amount
838:02 - staked fixture as basically a static
838:04 - variable right we could have done at the
838:06 - top we could do something like amount
838:08 - staked equals you know that exact same
838:10 - thing but
838:11 - we're going to get into the habit of
838:12 - working with these fixtures so we have
838:15 - our def test stake tokens and we're
838:17 - going to pass it this amount staked
838:20 - fixture pi test and brownie will
838:23 - grab all this stuff from the conf test
838:27 - folder and put it into here
838:29 - so now we can just use amount staked as
838:32 - a parameter in our test here so once we
838:34 - approve we can then do token farm
838:41 - we now call
838:43 - our stake tokens
838:45 - function right here
838:47 - and it takes an amount
838:49 - and then a token address
838:51 - so of course we're going to do amount
838:52 - staked
838:53 - as the amount and then we'll do depth
838:55 - token
838:57 - address
838:59 - as the address and of course from
839:02 - account
839:04 - and perfect this is going to be our
839:06 - basic action of testing the staking
839:08 - functionality so we can go ahead and
839:09 - down here and move into our assert phase
839:12 - and we can just assert a number of
839:14 - things
839:15 - right
839:16 - and do a little
839:18 - bracket here
839:19 - we're gonna do a couple of things here
839:20 - we're gonna assert the token farm
839:26 - that's staking balance
839:28 - of dap token
839:30 - that address
839:33 - of account dot address
839:36 - equals amount
839:38 - state
839:39 - so let's talk about this really quickly
839:41 - what is this actually doing so if we go
839:43 - to our token farm we know that we have
839:45 - this mapping called staking balance and
839:48 - this is a mapping of a mapping
839:51 - right so we need to actually pass
839:53 - two variables the first address and then
839:55 - the second address to get this amount
839:58 - this is how you do that syntactically
840:00 - with brownie you just pass it as
840:02 - additional parameters in here so we pass
840:05 - the dap token address
840:06 - which is going to be the token address
840:08 - here
840:09 - and then the account address
840:11 - which is going to be the address here
840:14 - and perfect
840:16 - so we can even run this by doing brownie
840:20 - test
840:21 - dash k
840:23 - test stake tokens
840:26 - and great looks like that passed
840:27 - perfectly
840:28 - but we have a couple of other assertions
840:30 - to make right because if we look at our
840:32 - stake tokens function it does a lot of
840:35 - things so let's check all of these and
840:37 - make sure that they all are working
840:39 - correctly so we'll also assert
840:41 - that the
840:43 - dot tokenfarm.unique
840:45 - token staked
840:49 - of account that address
840:51 - is going to be equal to one right this
840:53 - is going to be the first token so
840:56 - it should have a unique token state we
840:58 - should also assert that the token farm
841:02 - dot stakers
841:04 - at the zeroth index is going to be
841:06 - this account that we're using we update
841:09 - our unique token staked
841:11 - we update our staking balance
841:13 - and then we add
841:15 - stakers.push right so we're going to be
841:16 - the first
841:18 - address in this array now and then i'm
841:20 - going to do one other thing here too i'm
841:22 - going to do return
841:23 - token farm
841:25 - and dap token
841:27 - the reason i'm doing this is because now
841:29 - we can actually use this
841:31 - test in some of our other tests now
841:33 - we're getting a little bit integration
841:35 - here we're kind of mixing and matching
841:36 - some stuff we could even probably put
841:38 - this whole thing in a function in our
841:40 - regular scripts directory but for
841:42 - simplicity's sake this is how we're
841:44 - going to architect it but great let's
841:45 - test the rest of those we'll just hit up
841:48 - ground to test k test stake tokens we'll
841:50 - hit enter and perfect
841:52 - this is passing correctly as well
841:55 - awesome let's keep going now we're
841:57 - moving into this test issue tokens phase
842:00 - here and we're going to use our test
842:02 - stake tokens test here
842:04 - so the way that we're going to use this
842:06 - is we're going to grab this amount
842:07 - staked parameter
842:09 - place it in here
842:10 - and we're going to set this up exactly
842:12 - the same way we're going to set this up
842:13 - almost exactly the same way so we can
842:15 - even just copy these few lines here
842:18 - paste it
842:19 - we're going to do an arrange
842:20 - we're going to check to make sure we're
842:22 - on a local network we're going to get
842:24 - our account but instead
842:26 - of doing deploy token farm and dap token
842:30 - we're going to do
842:31 - token farm
842:33 - comma dap token
842:35 - equals test stake tokens and we're going
842:37 - to pass it that amount state so this is
842:40 - why we're returning the token farm in
842:42 - the dap token in our test stake tokens
842:45 - that way we can use that function now
842:47 - in our test issue tokens and perfect now
842:50 - we can test issuing these tokens so to
842:53 - test issuing tokens to issue this reward
842:56 - we want to first take some inventory of
842:58 - the current starting balances of our
843:02 - address we'll say starting balance
843:06 - equals
843:07 - depth token dot balance of
843:11 - account dot address and great this is
843:13 - how we're going to start off in our
843:15 - range phase now let's move to acting
843:17 - open our act phase and we'll just do
843:20 - tokenfarm.issue tokens
843:23 - we'll save from
843:25 - account
843:28 - and this is really the only thing that
843:30 - we're testing here so now we can move
843:32 - into the arrange
843:34 - stage
843:35 - and we'll do assert
843:37 - i'm going to do a little
843:39 - parentheses here because this is going
843:41 - to be a long thing and we're going to
843:42 - assert that the dap token
843:44 - dot balance of
843:48 - the account dot address
843:50 - should equal
843:52 - the starting balance
843:53 - plus
843:54 - some new amount
843:56 - what's that new amount going to be well
843:59 - if we look at our issue tokens function
844:01 - if we're staking in our conf test if
844:04 - we're staking one
844:06 - ether right
844:08 - or one
844:09 - die right because we're staking the dap
844:11 - token we're just taking one our marks
844:15 - are going to be this
844:16 - fusd price feed right our mock v3
844:19 - aggregator when we deploy it the initial
844:21 - value is going to be this 2000 right
844:23 - here and we're saying
844:25 - in our mock in our sample here we're
844:28 - saying
844:29 - we are staking
844:31 - one
844:32 - depth token
844:34 - which is equal
844:36 - in price
844:37 - to one each
844:39 - so we should get 2 000 depth tokens in
844:44 - reward since we're saying
844:46 - since the price
844:48 - of eth is
844:50 - 2000 usd
844:52 - so there's a little bit of math here
844:54 - but the initial value is going to be
844:55 - 2000 right you can almost think of it
844:57 - like this
844:58 - with 18 decimals and our application
845:01 - pays us reward based off of the total
845:03 - usd value that we have locked so we
845:05 - actually can know that this is going to
845:08 - be that 2000 price so what i'm even
845:10 - going to do is i and if this isn't
845:12 - already in the chain link mix shame on
845:14 - me i should add this in here
845:16 - because we're going to add a new
845:17 - variable called initial
845:20 - price feed value
845:24 - it's going to be equal to 2 000. one two
845:26 - three four five six seven eight nine ten
845:28 - one two three four five six seven eight
845:31 - that super big number and we're gonna
845:33 - take that and we're gonna set that here
845:36 - to our initial value is going to be now
845:37 - this initial price food value
845:40 - and what we can do in our test
845:42 - is we can then import that
845:45 - from our helpful scripts
845:47 - and we can just assume that our starting
845:49 - balance is going to be now we are
845:50 - starting balance plus that initial price
845:53 - feed balance and if we've done our math
845:55 - correctly and if we've done our issue
845:57 - tokens and if we've done all of our get
846:00 - value correctly this should work we
846:02 - should have done our testing already
846:04 - on the things like get
846:06 - user total value right because get user
846:08 - total value is a subset of issue tokens
846:11 - but we're jumping the gun a little bit
846:13 - here and we're going to test this later
846:15 - on anyways so
846:17 - with that being said let's run this test
846:21 - brownie
846:22 - test dash k
846:24 - test issue tokens and lovely so our math
846:27 - is correct
846:28 - awesome we are doing wonderfully with
846:31 - her tests here we've even gotten some of
846:33 - the harder ones out of the way early
846:34 - which isn't too bad either now as far as
846:36 - this video goes we're actually going to
846:37 - stop writing the test because we're
846:39 - literally just going to keep going down
846:41 - that solidity file and grabbing
846:43 - functions and adding tests to them we've
846:45 - got all the tests located in the github
846:47 - repository associated with this lesson
846:49 - there is both a unit test file and an
846:51 - integration test file in the github
846:52 - repository if you want to just go ahead
846:54 - and check that feel free to do so we're
846:56 - going to move on to the next section to
846:57 - keep things moving forward but i highly
846:59 - highly recommend you trying to write all
847:02 - these tests yourself so good luck we're
847:04 - gonna have all right now we're going to
847:06 - umv
847:07 - private
847:08 - and our website
847:10 - make sure your integration projects work
847:12 - well make sure that you get started if
847:14 - you run your deployment on copy paste
847:17 - network directly
847:19 - we're going to be testing everything
847:20 - works we'll save dots of course you're
847:22 - going to want to get out.env file you're
847:24 - going to want to add that to your
847:25 - browning config address privacy and add
847:28 - your web3 inferior project id and make
847:30 - sure you have plenty of test dent coven
847:32 - so that you can actually run these
847:33 - deploy scripts we can always find the
847:35 - latest faucets from the link token
847:37 - contracts page under our coven or rink b
847:40 - networks here we're also going to need
847:41 - our wallets section we'll do from key
847:45 - and this is where we'll put the dollar
847:46 - sign
847:47 - private
847:48 - key
847:50 - now
847:51 - now that we've got the contract now that
847:52 - we've done all the contract work we're
847:54 - going to learn something totally new
847:56 - that we haven't covered yet we're going
847:58 - to learn to do some front end
848:00 - development now like i said this isn't a
848:03 - front end course and the focus isn't
848:04 - going to be on front end and i want to
848:06 - point out right away that this is
848:08 - considered a bonus section there are a
848:10 - ton of pieces in this section that we're
848:12 - not going to have the time to go over
848:14 - thoroughly because we're not going to be
848:16 - going into what's going on on the front
848:17 - end side the editing is a little bit
848:19 - choppier and i highly recommend having
848:22 - the documentation having the github
848:24 - associated with this front end with you
848:26 - while you're going through this free
848:28 - code camp has an awesome video on doing
848:30 - front-end work and if you want to learn
848:31 - more about react and typescript and some
848:33 - of the technology that we're going to go
848:34 - over definitely check out those videos
848:36 - after this we're going to make this
848:38 - though so that you should be able to
848:39 - follow along with everything that we're
848:41 - doing if you're not interested in front
848:42 - end feel free to go ahead and skip this
848:44 - part
848:45 - however understanding how these front
848:47 - end applications work is really helpful
848:50 - and it'll give you a
848:51 - massive massive incredible skill to
848:53 - actually build front ends for your smart
848:55 - contracts having a really solid user
848:58 - interface is really important in the
849:00 - web3 in the blockchain world if people
849:02 - can't use your contracts then what good
849:04 - is your application so with that being
849:06 - said let's jump on and let's build our
849:09 - front end
849:10 - and i know we said we didn't like
849:12 - javascript we're gonna be working with
849:14 - typescript here which is a improved
849:16 - version of javascript and catches a ton
849:19 - of the different bugs and allows us to
849:20 - be much more explicit with how we're
849:23 - working with our front end we're also
849:24 - going to be working with react we're
849:26 - going to be working with create react
849:28 - app this is a front-end framework that
849:30 - allows us to quickly spin up a front end
849:33 - to build for our applications here we're
849:35 - also going to be working with this tool
849:36 - called used app it's a framework for
849:38 - rapid dap development
849:40 - and works great with react here so let's
849:43 - get started building this front end the
849:45 - first thing that we're going to want to
849:46 - do to build a front end for our full
849:48 - stack application create react app
849:51 - boilerplate so you should have mpx
849:54 - installed if you run mpx-version
849:56 - it should show up this should be
849:58 - installed from when we installed npm if
850:00 - you don't have mpx installed you can run
850:03 - mpm install
850:04 - g npx additionally we're going to want
850:07 - to install
850:08 - yarn here to install yarn again you just
850:11 - run mpm install dash dash global or dash
850:14 - g yarn you'll know you have yarn
850:16 - installed correctly if you can run yarn
850:18 - dash dash version you see a version of
850:20 - yarn and i have a link to install both
850:22 - npx and yarn in our github repo great
850:27 - once you have those we can actually
850:29 - create a folder with all of our
850:31 - boilerplate code in it we're going to
850:32 - run mpx
850:34 - create
850:35 - react app we're going to call it front
850:38 - end and this is going to create a new
850:40 - folder called frontend
850:42 - and we're going to do dash dash template
850:45 - type script
850:46 - because we're going to want to work like
850:48 - i said with typescript instead of
850:49 - javascript for those of you who've never
850:52 - worked with typescript before and who
850:53 - have worked with javascript don't worry
850:55 - the syntax is nearly identical for those
850:57 - of you who have never worked with either
850:59 - don't worry we're going to walk through
851:00 - everything that we do and then we'll hit
851:03 - enter here what's going to happen is
851:04 - you'll see we're going to create this
851:06 - new react app in this new front end
851:09 - folder in our project here
851:13 - awesome now that we've downloaded our
851:16 - create react app we have this new folder
851:18 - called frontend and it's got a whole
851:20 - bunch of stuff in it now typically what
851:23 - different applications will actually do
851:25 - is they'll have one repository for all
851:28 - their python and for all their contracts
851:30 - but they'll additionally have a
851:31 - different folder
851:33 - or different repository for their
851:35 - front-end application and their
851:36 - front-end work this is really good
851:38 - practice we're just going to bundle
851:39 - everything up into the same repo here
851:41 - just to get started and just to make it
851:43 - easier for us getting started here
851:45 - however what you will see across
851:47 - different projects is they'll have a
851:48 - totally separate repo for their front
851:50 - end so let's take some inventory on
851:52 - what's actually going on inside this
851:54 - folder so the first folder you'll see is
851:56 - node modules these are basically the pip
851:58 - installs these are the different
852:00 - packages pulled in from javascript and
852:02 - typescript we can pretty much ignore
852:04 - this folder for the majority of what
852:06 - we're working with here next we have our
852:08 - public folder we're also not really
852:10 - going to go in here but it's got some
852:12 - nice little images it's got our basic
852:15 - index.html which has the html that we're
852:18 - going to be running with it has a couple
852:20 - logo images and it has a manifest the
852:22 - manifest is something that we want to
852:24 - change this tells our browsers a little
852:27 - bit about what our app is and what our
852:29 - app actually does so this is something
852:31 - that we we would change but everything
852:32 - in here is pretty self-explanatory the
852:34 - short name of our application the long
852:37 - name of our application some icons start
852:40 - url this is something that if you want
852:42 - to fiddle with it later absolutely
852:44 - please go for it and then robots.txt
852:46 - we're not going to talk about this at
852:48 - all this helps web searchers and
852:49 - indexers learn a little bit more about
852:51 - your site we can ignore this one as well
852:53 - so for the most part we're not really
852:55 - going to do anything in the public
852:56 - folder or the node modules folder our
852:58 - source folder however we are going to be
853:00 - spending a lot of time in it has our
853:02 - app.css which includes a whole bunch of
853:06 - formatting for html we have app.test.tsx
853:10 - this is going to be testing our front
853:12 - end
853:13 - yes you can even test your front end
853:15 - we're going to totally skip over testing
853:17 - the front end which yes i know we've
853:18 - spent a lot of time testing our
853:20 - contracts if you want to learn more
853:22 - about testing your front ends there's
853:24 - some fantastic links in the github and
853:26 - in the description to go over this
853:28 - app.tsx which we are going to be
853:30 - spending some time in and it's one of
853:31 - our the main places for us to write some
853:34 - code index.css
853:36 - again a formatting and styling file
853:39 - anything that ends in css
853:41 - is some type of formatting and styling
853:43 - all these tsx are going to be type
853:46 - scripts index.tsx we're going to pretty
853:48 - much ignore we are going to change the
853:50 - logo and we can ignore all these last
853:52 - bits here a package.json this file tells
853:56 - our project what dependencies it needs
853:58 - and node.js packages it actually needs
854:00 - to get started we have a readme which of
854:02 - course is a readme we have a typescript
854:04 - config which gives us some options on
854:07 - how to work with typescript we're going
854:09 - to ignore this and then we have our
854:10 - yarn.lock which is an auto-generated
854:13 - file we're not going to touch it at all
854:15 - because yarn is going to automatically
854:17 - create this if you're not if you're
854:19 - unfamiliar with yarn.lock and unfamiliar
854:21 - with a lot of this stuff don't worry too
854:23 - much about it this isn't going to be a
854:24 - file you're really going to need to pay
854:26 - attention to but okay
854:28 - now that we've created the basic create
854:30 - react app we can actually go ahead and
854:32 - right now we can see what a front end
854:34 - will look like so we'll cd to the front
854:36 - end
854:37 - we'll run yarn just to make sure we have
854:39 - everything installed what yarn does is
854:42 - it actually installs all of our
854:43 - dependencies anything in this
854:45 - package.json
854:47 - yarn is going to go out and download
854:49 - these dependencies and store them into
854:51 - node modules
854:52 - and then yarn.lock is going to tell us
854:54 - exactly what it downloaded once running
854:56 - yarn now it just checks to see it says
854:58 - ah it looks like you already have
855:00 - everything installed because when we run
855:02 - create react app it already goes ahead
855:04 - and downloads everything but now we can
855:06 - just run yarn start
855:09 - if you want to know where this is coming
855:11 - from if you go in your package.json
855:14 - and you look under scripts
855:16 - these are the four different scripts
855:18 - that we actually run
855:20 - running yard start runs this mpx react
855:23 - scripts start which will actually start
855:25 - our front end so we'll do yarn start
855:27 - you'll see react script start you'll see
855:29 - it says starting the development server
855:31 - and after a little bit of time
855:33 - we'll get something that looks like this
855:36 - edit source
855:37 - slash app.tsx and save and reload and
855:40 - this is a super simple front end
855:43 - obviously this isn't at all what we're
855:45 - looking for but we've now started a
855:48 - front end which is fantastic it'll say
855:50 - compiled successfully it'll say you can
855:52 - now view frontend in the browser
855:54 - it'll tell you exactly where it's
855:56 - located on our local host on the network
855:59 - and it'll give you any outputs from the
856:01 - front end down below
856:03 - so we're just going to stop the front
856:04 - end for now by hitting command c or
856:06 - control c and closing it down
856:09 - of course if we reload now on the front
856:11 - end it's going to be blank but great so
856:13 - we have a really basic setup for working
856:16 - with a front end awesome if we look at
856:18 - an application like app.avi.com you'll
856:21 - see they have like this really fun
856:23 - connect button that pops up
856:25 - and they've got some nice user interface
856:27 - tools for actually working with the
856:29 - blockchain we don't want to have to
856:30 - reinvent the wheel and build all these
856:32 - custom tools for doing this so we're
856:34 - going to use this application called
856:36 - used app or this framework called used
856:38 - app which has a whole lot of these
856:40 - already built in to get started
856:41 - installing all we have to do is run this
856:44 - command right here yarn add use dap
856:47 - slash core so here in our front end
856:50 - we'll do yarn
856:51 - add at use dap slash core and this will
856:55 - go ahead and install all the used app
856:57 - pieces into our front end so we can
856:59 - actually work with used app and not
857:02 - reinvent the wheel with working with
857:03 - wallets and working with ethereum and
857:05 - other smart contract applications
857:06 - awesome now we have that installed we
857:09 - can actually go ahead and start building
857:11 - our front end now what we're going to do
857:13 - is we're going to go to
857:15 - app.tsx folder and we're going to start
857:17 - in here we're going to start adjusting
857:19 - some bits in here so what we can do is
857:21 - we can do the yarn start and we'll get
857:23 - our a little react front end here now
857:25 - what we could do is we go ahead and do
857:26 - something like change anything in here
857:28 - right see how this line says edit source
857:30 - that app source slash app and saved
857:32 - reload we could do we change this whole
857:34 - line
857:36 - being something just like
857:38 - hello
857:39 - we'll save it
857:40 - it'll recompile
857:42 - we can go back and now it just says
857:43 - hello right so this is how we can
857:46 - actually upload and update our front end
857:49 - we have these these wonderful return
857:51 - pieces here these return sections here
857:53 - which will return the html to actually
857:56 - render the front end and this is also
857:58 - our starting point for allowing our
858:00 - application to be web 3 compatible
858:03 - so if we go to this use dap
858:05 - documentation right we go to our getting
858:08 - started section we have a little example
858:10 - here that shows kind of what what
858:12 - something should look like right but
858:14 - it's not exactly clear where we put all
858:16 - this code
858:17 - so they do have this wonderful
858:18 - step-by-step bit and this is probably
858:20 - the most helpful bit here it says the
858:21 - first thing you need to do is set up dap
858:23 - provider with optional config and wrap
858:26 - your whole app in it so we're going to
858:28 - use these depth provider tags right this
858:30 - is the open tag and this is the closing
858:32 - tag we just wrap it around our app so we
858:35 - can see here this this whole thing right
858:38 - now
858:38 - is our app so we could take this whole
858:41 - thing
858:42 - delete it right and if we save right now
858:45 - we can go and see
858:46 - our friend is going to have nothing it's
858:47 - going to be blank this function app here
858:50 - that's getting exported export default
858:53 - app
858:53 - and this is getting rendered in this
858:55 - index.tsx we have this cool little
858:58 - app.html tag thing right but any case we
859:02 - want to wrap this whole thing with this
859:04 - tag here right
859:06 - so we can even just copy this paste it
859:08 - in i can do dap provider and then my vs
859:10 - code even auto adds a second dap
859:12 - provider here we can delete this div
859:14 - class name equals app
859:16 - i'll just put put a little divider in
859:18 - here and just say hi and at the top
859:20 - we'll just import this dap provider
859:22 - thing like what is this weird tag we're
859:24 - going to import it so we'll do import
859:27 - depth provider
859:30 - from
859:32 - and use dap
859:34 - core
859:36 - now if we hit save we'll get this weird
859:37 - error saying hey property config is
859:40 - missing in our dap provider and that's
859:42 - because
859:43 - this dat provider needs a config
859:45 - associated with it so we need to add
859:47 - this config bit into this dat provider
859:49 - so we're going to do
859:51 - config
859:52 - equals at this first bracket says we're
859:55 - going to type in typescript and the
859:56 - second bracket is saying we're an object
859:58 - here so in this config we're going to
860:00 - tell our application
860:02 - a couple of different things so we're
860:03 - going to tell it what supported chains
860:05 - there are what are the networks that our
860:07 - application can actually work with the
860:08 - default value for supported change in
860:11 - used app is going to be mainnet
860:13 - reli
860:14 - coven wrinkby robsten and xdi since
860:18 - we're going to be testing only on coven
860:20 - and ring b we could just do chain id dot
860:23 - coven
860:25 - and chain id dot chain id
860:28 - is another term that we can pull right
860:30 - from our used app slash core right and
860:31 - now if we wanted some other chain id we
860:33 - could just go ahead and put it in here
860:35 - right like if we wanted to work with our
860:36 - ganache we could just do one three three
860:38 - seven if we wanted some other random
860:39 - chain we could just put the other number
860:41 - in there right but chain id coven is
860:43 - going to be 42 and chain id that ring b
860:45 - is going to be what is it three yeah
860:47 - three or what or whatever it is and this
860:49 - is all we need to get started working
860:52 - with in a web 3 a blockchain compatible
860:55 - application so let's go back let's save
860:58 - and we'll refresh and now it just says
861:00 - hi
861:01 - how's it going so we're going to spend a
861:03 - lot of time in this source folder and
861:05 - since we're going to be here a lot let's
861:06 - let's do some cleanup just to cut down
861:08 - on the amount of fat that we have with
861:10 - that create react app
861:11 - so app.css we're going to toss this
861:15 - app.test yes tests are great but we're
861:17 - going to toss it we're going to leave
861:19 - index.css we do need index.tsx
861:23 - we don't need this logo bit anymore
861:25 - because we're going to use our own logo
861:27 - we do need this
861:29 - we also need this
861:30 - and since we're not running tests
861:32 - anymore we don't need this but i'm going
861:33 - to leave it in here just in case you
861:34 - guys want to later on go back and add
861:36 - some tests great so now we're looking a
861:39 - little bit lighter and in our app let's
861:41 - just remove
861:42 - amp.css let's remove logo.svb
861:46 - logo.svg goodbye
861:49 - now okay so we're going to create what's
861:51 - called a component we're going to create
861:53 - a header component now in react
861:55 - components are basically where you you
861:57 - put modular parts of your front end and
862:00 - we're going to create one of these
862:01 - components is going to be our header
862:02 - component to do this we're going to
862:04 - create a new folder called components
862:07 - and in here
862:08 - we're going to create a new file called
862:10 - header.ts
862:12 - and this is where we're going to put our
862:14 - header stuff and we're looking to to
862:16 - make a little button up here right we're
862:17 - looking to make a little button in this
862:19 - header so what we're going to do is
862:20 - we're going to import some stuff so
862:22 - we're going to import use ethers
862:25 - at usdap
862:29 - core again if we look at the
862:30 - documentation real quick this use ethers
862:33 - thing has got some cool stuff it's got
862:35 - this activate browser wallet thing got
862:37 - this account thing
862:39 - it's got some it's got some cool stuff
862:40 - so what do those actually do we're going
862:42 - to start by exporting a constant
862:44 - variable
862:45 - called header this is going to be a
862:47 - function and this is some really this is
862:50 - some really fancy typescript syntax what
862:52 - this is meaning is that we're saying
862:54 - header is a function
862:56 - and here's what the function is going to
862:58 - do we're going to use this use easter's
863:01 - thing to get a couple variables so we're
863:03 - going to say constant variable
863:04 - account
863:06 - activate
863:08 - browser wallet
863:11 - deactivate
863:13 - equals use ethers
863:16 - in order for us to actually use these
863:17 - though we need to figure out first if
863:19 - the user is connected
863:21 - so we're going to create another
863:21 - constant variable we'll call it is
863:24 - connected
863:26 - and this is going to equal
863:28 - an account it's going to equal an
863:29 - account it's going to equal account does
863:32 - not equal
863:33 - on d find
863:35 - so we're saying
863:36 - if the account
863:38 - is undefined we're not connected if it's
863:40 - not undefined then great we're connected
863:42 - so we're literally just looking to see
863:44 - if there's an account here and whether
863:45 - or not we're connected we'll decide if
863:47 - we show a connect button or not so to do
863:49 - that we're going to return
863:51 - a div this is where we're going to
863:52 - return
863:53 - some html stuff and we've got to check
863:55 - to see if we're connected so we'll do is
863:57 - connected i'm going to use this question
863:59 - mark which is known as a tertiary
864:01 - operator
864:02 - which means
864:03 - if this is true we're gonna do something
864:05 - and if it's false we're gonna do
864:06 - something else so we're saying okay if
864:08 - we are connected right what do we do if
864:10 - we're connected here well
864:12 - we're gonna create a button
864:15 - we'll have the color
864:17 - equal
864:18 - primary
864:19 - create this button here
864:21 - and then my vs code auto makes these
864:23 - closing tags we'd even leave this button
864:25 - blank if we want or we're actually going
864:28 - to put some fancy stuff in here and then
864:30 - we'll put a little function in it we'll
864:31 - say on click
864:33 - equals
864:35 - deactivate this is this deactivate
864:37 - function pulled in from our use ethers
864:40 - thing i should spell it right though and
864:42 - we're going to call this button
864:45 - oops there's a little
864:47 - parenthesis next to this so this is what
864:49 - this is connect thing does so we're
864:50 - saying if if we are connected
864:53 - right do this
864:54 - now we're going to do a little
864:56 - colon here
864:57 - and this is going to represent what
864:58 - we're going to do if we're not connected
865:00 - okay if we're not connected what we're
865:02 - going to show is a different button
865:04 - color can still be
865:06 - primary
865:08 - and we're going to do on click
865:10 - we're going to do
865:11 - a function
865:14 - activate browser wallet
865:17 - then we close up the button tag with
865:19 - another backslash button
865:21 - and we'll call this one though
865:23 - so if we are connected we're going to
865:24 - show a disconnect button and then if
865:26 - we're not connected we're going to show
865:28 - a connect button and that's it right
865:30 - just make sure all of your divs all your
865:32 - tags are matched up and we can go ahead
865:33 - and save this and if we look at our ui
865:36 - you'll see nothing's changed right okay
865:38 - well why isn't anything changed well
865:39 - this component that we just made it's
865:41 - living inside of this components folder
865:44 - and we've exported this this header
865:45 - variable this header function right
865:47 - however it's actually not in our app
865:50 - here right so if we look at our
865:51 - index.tsx this is what's actually
865:54 - getting rendered so we're just rendering
865:56 - this app variable which is pulled in
865:59 - from you know dot slash app right this
866:01 - app.tsx so index.tsx is really our true
866:05 - ground zero this is where everything
866:06 - really comes from this is kind of our
866:08 - entry point right this is our main
866:10 - function you kind of think of it that
866:11 - way that pulls from this app file that
866:14 - we have here you can see in here we
866:16 - don't have any reference to this header
866:18 - right we have our dat provider we have
866:20 - our div tag saying hi but we don't have
866:22 - the header in here so what we need to do
866:24 - is we need to import this component we
866:26 - just made into our app.tsx so we're
866:29 - going to do is we're going to import
866:30 - header
866:32 - from
866:34 - dot slash
866:35 - components
866:37 - slash
866:38 - header
866:40 - and now we can take this header bit we
866:42 - can place it
866:43 - inside our header tags here we can just
866:45 - do header
866:46 - and we'll close the tag
866:48 - by adding it right here we'll save
866:50 - and we'll head back and now we can see a
866:53 - little connect button here which is
866:54 - great obviously it doesn't look great
866:56 - but we have the functionality here which
866:58 - is what we want if we hit the connect
867:00 - button our meta mask will actually pop
867:02 - up and say hey would you like to connect
867:04 - which account would you like to connect
867:05 - i'm going to go ahead
867:07 - select my first one
867:08 - next connect it's connecting
867:11 - and now i'm actually going to be
867:12 - connected let's go to
867:15 - one of the supported networks like coven
867:17 - and now we can see here we have this on
867:19 - click equals disconnect if i click this
867:21 - now oops i need to actually sorry i need
867:24 - to put this
867:25 - inside the tag here so we just moved on
867:27 - click to be inside of this little button
867:29 - here now we can see it actually says
867:31 - disconnect and if i click it i get
867:32 - disconnected and if i connect i get
867:35 - automatically connected right so if we
867:36 - look at our metamask we can see we're
867:38 - connected right here right that little
867:40 - little green thing we can also manually
867:42 - disconnect by going right into our
867:44 - metamasks click this connected thing
867:46 - here
867:46 - click the account and hit disconnect the
867:48 - account and you'll see our front end
867:50 - does indeed update awesome this is how
867:52 - we can take our meta masks and actually
867:54 - inject it into our front ends so we can
867:56 - actually use the front ends great job
867:58 - this is absolutely massive where we are
868:01 - so far now you might be saying to
868:02 - yourself hey patrick this is cool uh but
868:05 - it doesn't look very good that's kind of
868:06 - a gross button in the top right corner
868:08 - can we can we style this up can we make
868:10 - this look a lot nicer and the answer is
868:12 - absolutely yes so there's a lot of
868:14 - different styling packages out there you
868:16 - can 100 write your own custom ones we're
868:19 - going to be using one called material ui
868:22 - it's a popular react framework for
868:24 - creating components and just doing a lot
868:27 - of styling and doing a lot of really
868:28 - nice work so we're going to be adding
868:30 - this to our project as well so to add it
868:32 - we're just going to use this this line
868:34 - and i'm just going to go ahead and do it
868:36 - myself and come in here we're going to
868:38 - cancel this with control c
868:40 - we do yarn
868:41 - add at material hyphen ui
868:46 - core and this will give us access to
868:49 - some really nice libraries
868:51 - for styling all these buttons installing
868:53 - a lot of the things that we're going to
868:54 - be working with back in our header we
868:56 - can add this styling here so we're gonna
868:58 - do import
868:59 - button
869:01 - make styles
869:05 - from
869:06 - app material
869:07 - hyphen ui
869:09 - core
869:10 - and we're gonna use their button and
869:11 - their make styles if we look in the
869:13 - documentation here you can find there
869:15 - but this is double narration kind of
869:16 - like what their default buttons look
869:18 - like and this looks pretty good looks a
869:19 - lot better than what we currently have
869:21 - we're also going to be taking advantage
869:22 - of their make styles bit here so make
869:25 - styles is a way to actually do styles
869:27 - for based off of different themes that
869:29 - you can actually use with materials ui
869:31 - we're not going to be working with css
869:33 - files because we're going to be working
869:34 - with this make styles instead if you
869:37 - prefer css you can absolutely easily
869:39 - translate these to css files so we are
869:42 - going to add some used styles first of
869:44 - all using make styles so in here we're
869:47 - going to do
869:48 - const
869:50 - use styles
869:52 - equals make styles and this is where we
869:54 - put a theme in here we're just going to
869:56 - set it to be a default theme um there's
869:57 - some documentation if you want to go
870:00 - ahead and add your old themes though so
870:01 - this make styles function it's going to
870:04 - have a container and in this container
870:06 - we're going to add some
870:08 - padding of theme.spacing
870:14 - for we're going to add display
870:17 - flex
870:19 - we're going to add justify content
870:22 - flex end
870:23 - and then we're going to add gap
870:25 - theme.spacing 1.
870:28 - so this is really just some typical css
870:30 - stuff now we're going to take this use
870:31 - styles constant that we just made
870:34 - and down here we're going to do const
870:36 - classes
870:37 - equals
870:38 - use styles so now we have this classes
870:40 - object that we can start working with
870:42 - we're going to take this classes object
870:43 - in our little is connected thing we're
870:45 - going to do div
870:49 - class name
870:50 - equals a little javascript in here
870:53 - classes.container
870:55 - we're going to wrap this whole thing in
870:56 - this div right and this is going to
870:58 - style
870:59 - this whole button div here so now if we
871:01 - go ahead and do yarn start again because
871:04 - we shut it off
871:05 - if we come back here we're going to see
871:07 - it's going to look a little bit
871:08 - different now it's been moved over here
871:11 - we have this like fun little disconnect
871:13 - connect button
871:14 - where there's some padding and it looks
871:16 - a little bit nicer and we're going to
871:17 - change all of our buttons to being kind
871:19 - of this built-in button
871:21 - from the materials ui
871:23 - so we're going to swap out all those
871:24 - buttons with this with our new button
871:26 - here if we go back we can see it's
871:29 - it looks even nicer now now that we've
871:31 - swapped it out with that with that new
871:32 - type of button right it's got a nice
871:35 - little clicky feel to it and then we can
871:37 - also do another line called variant
871:40 - equals contained
871:42 - for each of our buttons
871:44 - so right next to the color primary we'll
871:46 - do
871:47 - variant contained and then now we go
871:49 - back and we have
871:51 - a really nice button now
871:53 - so awesome now we have like a really
871:55 - nice button let's create a component
871:57 - that will contain the meat of our
871:59 - application now though from materials ui
872:01 - we're going to use what's called
872:02 - containers right and these are nice
872:04 - little containers that are going to
872:05 - allow us to style and make these
872:08 - different sections well we can use we
872:10 - can import
872:11 - this container bit from this materials
872:13 - ui
872:14 - by doing import
872:17 - container
872:19 - from at material
872:23 - hyphen ui
872:24 - core
872:25 - in our app.tsx
872:27 - and what we'll do to our header we'll
872:29 - make a little container here
872:31 - container
872:33 - give it a closing tag container
872:35 - and then maybe in here we'll put this
872:37 - little div high right so we'll remove
872:39 - that div we'll paste it in here and now
872:42 - we can see that it's been formatted a
872:43 - little bit right it's been pushed over
872:45 - from the side it still says hi we're
872:47 - going to want to do one more thing we're
872:49 - going to give it a max width of being md
872:52 - oops
872:53 - max width equals md
872:56 - and this max width now if we look in the
872:58 - docs again on materials ui these are the
873:00 - different sizes we have large medium
873:02 - small extra large extra small and then
873:04 - false right these are the different
873:06 - options we can have for max with we're
873:08 - just going to do medium so if we save
873:09 - this now go to wrap we can see it's been
873:11 - pushed over a little bit more it's time
873:13 - to add our main pieces right we're going
873:15 - to need that top piece for staking and
873:17 - the bottom piece for unstaking so we're
873:19 - actually going to create a new component
873:21 - called main and this is going to be our
873:23 - main component so we're going to create
873:24 - a new file in components called
873:26 - main.tsx so let's start by just showing
873:30 - some information about our wallet right
873:32 - showing what we have in our wallet
873:34 - associated with what we have in their
873:37 - smart contracts so we'll say export
873:40 - a constant variable called main and this
873:43 - will be a function here's that syntax
873:45 - for
873:46 - functions in typescript and javascript
873:48 - in order for us to show what amounts
873:50 - that we have in our current wallet we're
873:52 - going to need to know what chain that
873:54 - we're even on because the network that
873:55 - we're on is going to determine where the
873:57 - addresses are right because it's going
873:59 - to be different if you're on coven or
874:00 - mainnet etc now this is where it gets a
874:02 - little bit interesting because obviously
874:03 - with brownie we know where these
874:05 - addresses are right and brownie keeps
874:07 - track of this for us right it does it in
874:09 - our builds folder in our deployments
874:10 - folder if we look there now if you
874:12 - actually deployed something to coven
874:13 - you'll see this 42 you'll see some stuff
874:16 - in here you'll see this map.json which
874:18 - has the most recent deployments
874:20 - of our tokens our tokens and our token
874:23 - farm if you actually deployed it to
874:24 - coven if you haven't deployed it to
874:26 - coven i highly recommend you doing that
874:28 - now as well this way we can test our
874:30 - front ends against a real test net so in
874:32 - order to get these addresses we're going
874:33 - to have to ask brownie hey brownie what
874:35 - are these addresses where are these
874:36 - coming from so we're going to need to
874:38 - grab some information from this brownie
874:40 - config we're basically going to need to
874:42 - get all the information all the
874:44 - information that's in this brownie
874:45 - config right because this has
874:47 - has these addresses already and this is
874:49 - what we want however it's really hard
874:51 - for node.js to work outside of this
874:53 - source folder so what we're going to
874:55 - want to do is we're going to want to
874:56 - send that brownie config to our front
874:59 - end the way we're going to do that is
875:00 - we're going to actually modify
875:02 - by adding a new function
875:04 - called
875:05 - def
875:06 - update
875:07 - front end now the only reason that this
875:09 - works is because we have both our
875:11 - contracts and our frontend in the same
875:13 - repository in the real world once you
875:15 - deploy your contracts those addresses
875:17 - are pretty much set so you can just copy
875:19 - paste them over to your front end
875:20 - repository but for us we don't have set
875:22 - contracts yet so we need a way to update
875:24 - our front end so what we're going to do
875:26 - is we're going to send that brownie
875:28 - config
875:29 - over to the front end right that way our
875:31 - main
875:32 - can know where those addresses are
875:34 - we're also going to need to send
875:36 - so we need to send the brownie config
875:40 - to our
875:41 - source
875:42 - folder we're also going to send
875:46 - the build folder
875:47 - why because this will have access to the
875:49 - dap token address or any other mock
875:52 - addresses that we're using we're going
875:53 - to open up our brownie config and we're
875:55 - going to paste and we're going to dump
875:57 - the config into that source folder now
876:00 - typescript doesn't work with the ammo so
876:02 - well it works with json really well so
876:04 - we're actually going to convert it from
876:06 - yaml to json and dump it to the front
876:08 - end so we're going to open up our
876:09 - brownie config we're going to say with
876:12 - open
876:14 - brownie
876:15 - config
876:17 - yaml
876:18 - we're going to open it in
876:21 - read format
876:23 - we're going to say as
876:24 - brownie config
876:27 - we're going to say config
876:29 - dictionary
876:30 - equals
876:32 - yaml dot load
876:33 - brownie config
876:36 - loader equals yaml dot
876:42 - full loader
876:44 - so we're gonna have to import this yaml
876:46 - from the top we're gonna do
876:48 - import yaml
876:50 - and what this yaml is gonna do
876:52 - is it's going to allow us to
876:54 - load our yaml into a dictionary that's
876:57 - really it so you probably don't have it
876:58 - right now you're going to want to run
877:00 - pip install
877:02 - pi yaml
877:03 - to actually get it now we'll be able to
877:05 - have that now that we've got this in a
877:06 - dictionary we're going to want to send
877:09 - this to the front right we're going to
877:10 - want to write this dictionary as a json
877:12 - object to our front end so we're going
877:14 - to say with
877:15 - open we're going to open that front end
877:19 - source folder
877:20 - and that's just where we're going to
877:21 - dump this file we're going to call it
877:22 - brownie
877:24 - config
877:26 - dot json
877:27 - we're going to open this new file
877:29 - in write mode we'll say it's as
877:33 - brownie
877:34 - config json
877:37 - what we're going to do is just do what's
877:38 - called a json dump we're just going to
877:40 - take this dictionary and dump it as json
877:44 - into this file so we're going to say
877:45 - json.dump
877:48 - config dick
877:50 - brownie
877:52 - config
877:54 - json
877:55 - of course we're gonna have to import
877:56 - json and then at the end we'll even
877:58 - print
878:00 - front and updated so now we have this
878:02 - update front end script what we can do
878:05 - when we run our deploy token in-depth
878:08 - token we can just add this update front
878:10 - end bit now we don't want to always
878:12 - update the front end right we only want
878:13 - to do when we're working with the front
878:15 - end so in our deploy token farm in depth
878:17 - token we're going to set update front
878:20 - end
878:21 - equals false so by default this is false
878:24 - this way when we run our tests
878:26 - the front end won't get updated right
878:28 - and down here we'll just say
878:30 - if update front end
878:32 - and we'll update the front end otherwise
878:34 - we won't
878:36 - and in our main function here we'll just
878:38 - say update
878:39 - frontend equals true now if we deploy
878:42 - this to coven or rink b we'll
878:44 - automatically update and send this
878:47 - browning config and then let's actually
878:48 - change this to front and update instead
878:51 - of update front end so that we don't
878:53 - have the same method name as our boolean
878:54 - here so we'll do front
878:56 - and
878:57 - update instead so now
878:59 - when that we deploy
879:01 - we'll actually go ahead and update our
879:03 - front end here but we're not always
879:05 - going to redeploy so let's also
879:07 - create an up
879:09 - date front end dot pi script
879:12 - and this we'll just call that function
879:13 - that we just made so we'll do def main
879:16 - update
879:17 - front end and then we'll do from
879:20 - scripts
879:21 - dot deploy
879:23 - import update
879:26 - front end semicolon there great
879:30 - let's open up a new shell
879:31 - by hitting a little plus button here now
879:33 - we have two shells and we can just do
879:35 - brownie
879:36 - run scripts
879:38 - update front end doesn't matter the
879:40 - network
879:42 - and what this is just going to do
879:44 - it's just going to run that copy script
879:46 - right it's going to run our
879:48 - our update front-end script which we
879:49 - made right here so if we did this right
879:51 - we should now have a brownie config.json
879:54 - in our end
879:56 - source directory so if we go in here we
879:58 - go into our source directory we can
880:00 - indeed see it's right in here do we need
880:02 - anything else well so that's going to
880:03 - give us those addresses right it's going
880:05 - to give us it's going to give us some of
880:07 - the addresses but it's not going to give
880:08 - us everything what about dap token right
880:12 - the app token isn't going to be
880:13 - something in our brownie config last
880:15 - token and fau token sure they'll be in
880:16 - our config but dap token is going to be
880:18 - something that only is going to be
880:20 - deployed by us so we need to send that
880:22 - to the front end too we need to send
880:24 - basically our whole build folder so
880:26 - we're going to need to update this
880:28 - update frontend script to also send
880:30 - send the build folder i know that we're
880:32 - actually going to be copying a number of
880:34 - different folders so i'm just going to
880:35 - go ahead and make a new function called
880:38 - copy folders
880:40 - to front
880:42 - end
880:43 - and in here so we're going to make this
880:45 - copy folders to front end function here
880:47 - we're going to do a couple of clever
880:49 - python things this is going to take a
880:51 - source and a destination so we want a
880:54 - source folder and then a destination
880:56 - folder so we're going to copy this build
880:58 - folder and move it to you know some
881:00 - folder in the front end first we're
881:02 - going to check that that destination
881:03 - exists and if it exists we're gonna kill
881:06 - it we're gonna we're just gonna remove
881:07 - it so we're gonna say if os.path dot
881:09 - exists destination we're gonna do this
881:12 - shuttle dot rm tree
881:14 - dest
881:15 - and this is gonna kill everything so we
881:18 - need to import both of those we're going
881:19 - to import os
881:21 - we're going to import
881:22 - shuttle or shutil i actually have no
881:25 - idea how to pronounce that but we're
881:26 - going to remove that whole bit and we're
881:28 - just going to copy everything over from
881:31 - our build folder so we're going to do
881:32 - shuttle dot copy tree src
881:36 - dest so we're going to say hey if that
881:38 - build folder exists in the front end
881:40 - just delete it and we're just going to
881:42 - copy everything over from the build
881:44 - folder and we're going to do this copy
881:46 - folders to frontend a few times
881:48 - the first thing of course like i said is
881:50 - going to be with this build folder so
881:52 - we're going to do this copy folders to
881:54 - frontend the source
881:56 - is going to be dot slash build so we're
881:57 - going to take this whole build thing and
881:59 - we're going to move it to
882:01 - dot slash
882:03 - front end
882:05 - src and we're gonna create a new folder
882:07 - in here called chain
882:09 - info right and this is just gonna have
882:12 - all of the build information
882:14 - and all right
882:15 - cool so now we can run that
882:17 - brownie run scripts update frontend
882:20 - we'll go ahead and run that
882:22 - and great front end is now updated so if
882:25 - we look at our front end we're looking
882:26 - source
882:27 - we now have this chain info folder which
882:29 - is literally just the build folder which
882:31 - is awesome now we can actually start
882:33 - working with these pieces in our front
882:35 - end so let's figure out how to get the
882:38 - depth token address
882:40 - well to get this dap token address we're
882:42 - going to need
882:43 - that map that we just got from chain
882:45 - info in our deployments but we're also
882:48 - going to need to know what chain that
882:50 - we're currently on like what we saw
882:51 - before we have this chain id
882:54 - from used app core which will tell us
882:56 - what chain id of the current network
882:59 - that we're on
883:00 - so we can go ahead and import that in
883:01 - here as well so we're going to do is
883:03 - we're going to import
883:05 - use ethers again
883:06 - from
883:08 - at use dap
883:10 - core what we're going to do here
883:12 - is use ethers
883:14 - allows us to get the chain id that we're
883:16 - working on so we can say cons
883:18 - chain id
883:21 - equals
883:22 - use ethers now that we have the chain id
883:25 - we're going to have to map it to the
883:27 - name of the network right because our
883:29 - browning config has this network section
883:31 - but it's mapped by the name of the
883:33 - network not by the id
883:36 - so what we're actually going to do
883:38 - is we're going to create a helper config
883:40 - in our src
883:42 - so we're just going to create a new file
883:43 - helper config
883:46 - dot json and it's literally
883:49 - just going to be a json object that maps
883:51 - numbers to their associated chain names
883:54 - so 42 for example is going to be kovan
883:56 - four is going to be rank b one three
883:59 - three seven gonna be dev
884:01 - or it could also be ganache right one is
884:04 - gonna be mainnet etc now that we have
884:06 - this helper config we can do import
884:08 - helper config
884:10 - from
884:11 - dot dot slash
884:12 - helpworkconfig.json
884:15 - and before we even get the dab token
884:17 - address we can do const network
884:20 - name is going to equal that helper
884:23 - config
884:25 - at the chain id now typescript is
884:28 - actually going to get a little bit mad
884:29 - at us here so we need to add a little
884:32 - bit more to this line actually so we
884:34 - need to say okay only grab from this
884:36 - helper config if chain id exists right
884:39 - because there might be a chance that
884:41 - train chain id is nothing or it's
884:42 - something really weird so we're going to
884:44 - say chain id i'm going to use this
884:46 - tertiary tertiary operator again we're
884:48 - gonna say if this chain id exists
884:51 - then go ahead and use the helper config
884:54 - however if it doesn't exist
884:57 - just use dev i should spell
884:59 - chain id right so it doesn't get really
885:01 - confused to me and whenever we return
885:03 - one of these components or try to use
885:04 - one of these components we're always
885:06 - going to have to return some type of
885:08 - html or div tag like this we head over
885:10 - to our app
885:12 - we add our little main bit here
885:15 - of course we're going to want to import
885:16 - this say import
885:18 - main
885:20 - from
885:21 - dot slash components
885:23 - slash main we save it we'll add our
885:27 - main tag
885:28 - syntax we're basically saying in it now
885:30 - depending on your setup you might
885:32 - actually run into this error here saying
885:34 - element implicitly has an any type
885:37 - because expression blah blah blah you
885:39 - might be saying okay well what's going
885:41 - on here now to make our lives easier
885:43 - we're going to tone down typescripts
885:46 - strictness here so what we're going to
885:47 - do
885:48 - is in our typescript config.json we're
885:52 - actually going to add suppress
885:54 - implicit
885:56 - any index errors
885:58 - so we're basically suppressing when we
886:00 - get this type of error because it's not
886:01 - ever actually going to affect anything i
886:03 - should probably i should probably spell
886:05 - this correctly we'll save it
886:07 - now if we save this file here
886:09 - we're going to actually get this saying
886:12 - everything's compiled everything looks
886:13 - good
886:14 - and if we refresh our front end we're
886:16 - gonna get back to exactly where we are
886:18 - before
886:19 - now what we can also do is we can also
886:20 - console.log these out we can also see in
886:23 - the console
886:24 - exactly what these are gonna look like
886:26 - so if we do console.log chain id and
886:29 - console.log network name
886:31 - we save and we go back we can go hit
886:34 - inspect
886:36 - go to the console
886:37 - and we'll see 42 and coven gets printed
886:41 - out in the console over here so that's
886:43 - 42 is the chain id and coven is the
886:46 - is the network name so we know that
886:48 - we're doing this right okay great
886:50 - so we have
886:51 - our network name and we have a chain id
886:54 - we've got a way for us to update our
886:56 - front end with a new script let's
886:59 - finally get those different addresses
887:00 - that we need say the constant variable
887:04 - gap token address
887:06 - is going to equal
887:08 - something from that build folder or that
887:11 - chain info folder that we created inside
887:13 - here inside deployments we have this
887:15 - map.json
887:17 - and since i've already deployed this to
887:19 - coven
887:20 - we have dap token and token farm on the
887:22 - cova network so we can then use that and
887:25 - say
887:26 - if
887:27 - if we are connected to a chain id and
887:29 - that's again that's what this question
887:30 - mark is doing
887:32 - saying if this chain id exists
887:34 - then
887:35 - look into that mapping else we're just
887:38 - going to use a zero address right so how
887:41 - do we actually get this mapping in here
887:43 - though so i'm going to say import
887:47 - network
887:48 - mapping
887:49 - from
887:50 - this is going to be in that chain info
887:53 - folder
887:55 - inside the deployments
887:56 - deployments
887:58 - and it's just going to be map.json
888:01 - so we're going to take this network
888:02 - mapping object
888:04 - and we're going to say if the chain id
888:05 - exists
888:06 - then inside this network mapping json
888:09 - object we're going to
888:12 - cast
888:13 - that chain id
888:15 - as a string
888:17 - and then we're going to grab
888:19 - the name of the dab token which is going
888:21 - to be dap token and we're going to grab
888:23 - whatever address is at the top right so
888:26 - this is going to be a big list the more
888:28 - times we deploy
888:29 - the more times brown is going to keep
888:31 - track of it and there's going to be all
888:32 - these different addresses and we just
888:33 - want this one right at the top right we
888:35 - want the most recent one here so we're
888:37 - just going to say at position zero
888:39 - otherwise if we're not on a chain id
888:42 - we're just going to use a zero address
888:44 - and ether's js actually has a really
888:46 - nice package to give us what's called
888:49 - constants so we're going to do
888:51 - constants
888:52 - dot
888:54 - address zero
888:56 - and we can import that from ethers
889:00 - so we'll do import
889:02 - cons
889:04 - dance
889:06 - from
889:07 - ethers
889:09 - if you don't already have ethers
889:11 - installed here
889:12 - we're going to do
889:14 - cd front end we're going to do yarn add
889:17 - ethers
889:19 - and now we have the ethers package in
889:21 - here now we're not going to do the same
889:23 - thing for the weft token or the fau
889:25 - token
889:26 - because those tokens are defined in the
889:28 - brownie config as opposed to being
889:31 - defined in our map.json here so to get
889:34 - those ones we're going to say const
889:36 - with token address
889:38 - it's going to equal let's check first if
889:40 - the chain id exists and if it does
889:42 - we're going to grab it from
889:44 - the brownie config so to grab that
889:46 - we're going to do
889:48 - import
889:50 - brownie config
889:52 - from
889:53 - again now that we've imported it
889:56 - brownie config.json
890:00 - now we can work with this brownie config
890:02 - inside of our front end so we'll say
890:04 - browning config
890:08 - of networks
890:09 - of that network name of the
890:12 - left token and if chain id oops chain id
890:17 - does not exist then once again
890:19 - we're gonna do constants dot address
890:22 - zero so we're just gonna leave it blank
890:24 - and then we're going to do the exact
890:26 - same thing for the fau slash the die
890:28 - token so we'll do const fau
890:31 - token address
890:34 - equals chain id question mark
890:37 - so if the chain id does exist it'll be
890:39 - the brownie
890:40 - config
890:43 - networks
890:46 - network name
890:50 - fau token
890:52 - and if chain id doesn't exist it'll be
890:55 - constants
890:56 - dot
890:58 - address
890:59 - zero
891:00 - okay awesome
891:02 - and if we save it
891:03 - oops looks like i put in an extra
891:05 - comment there by accident i'm just gonna
891:07 - get rid of that and resave
891:09 - and then refresh here so i'm getting an
891:12 - issue
891:12 - uh because i'm on the rink beat chain
891:14 - right now and it's saying hey there's no
891:17 - there's nothing for rink there's no dap
891:18 - token for rink b you gotta be on coven
891:20 - so if i go back to coven here
891:23 - and i refresh now it works out fine
891:26 - right this might still break for you if
891:28 - you're on coven and you haven't deployed
891:30 - anything to coven we can fix this in our
891:33 - config for the dap provider by changing
891:35 - the supported chains for this now
891:37 - typically a lot of the times you're
891:38 - going to want to test using a ganache
891:40 - chain or some type of local chain so
891:41 - that your front end testing can be a lot
891:43 - faster for this we're just going to do
891:45 - everything on coven but a nice little
891:47 - challenge for you would be to refactor
891:48 - this so that it also works with
891:50 - something like ganache and we're going
891:51 - to not use ganache so i'm just going to
891:53 - go back to app.tsx
891:55 - we're going to remove ganache
891:57 - even we're going to even remove rink b
891:59 - for now we're just going to work with
892:00 - coven just to make it simple if i go to
892:02 - our react page now
892:04 - refresh i can connect
892:06 - awesome
892:07 - if i go to
892:08 - ring b it's not going to freak out
892:10 - because it says hey ring b is not even
892:12 - supported so i don't care what you're
892:13 - doing
892:14 - however covent is supported
892:17 - so we're connected and we're looking
892:18 - good and the thing is we really don't
892:20 - want to couple our front end with our
892:22 - contracts right we really want to code
892:24 - the contracts independently and the
892:26 - front end independently anyways so let's
892:28 - get back into our
892:30 - main.tsx because we're going to be in
892:32 - here for a while but we've already done
892:34 - some great things we've gotten what
892:36 - network we're on what chain id we're on
892:38 - and we've gotten the different addresses
892:40 - for these different tokens so as you can
892:41 - probably see
892:43 - the place that we're actually going to
892:44 - put stuff on the front end is in this
892:46 - little return statement here right right
892:48 - now we're just returning i'm main and we
892:50 - just see my main right here to do this
892:53 - we're actually going to make another
892:54 - component we're going to make a
892:56 - component called your wallet this
892:58 - component is going to be a part of this
893:00 - main component here it's a component
893:02 - inside of a component that is literally
893:04 - only going to address our wallet needs
893:08 - so in our little components tab here
893:10 - we're going to go ahead and create a new
893:11 - folder
893:12 - and we're going to call it your
893:14 - wallet and this is just going to have
893:16 - everything to do with our wallet in here
893:18 - so let's get in here we'll create a new
893:20 - file because we're going to actually
893:21 - make a couple files and our first one is
893:24 - going to be your wallet.tsx
893:27 - this is going to be our component that
893:28 - is just going to deal with getting our
893:31 - wallet getting the token balances of the
893:33 - different tokens that we have since we
893:35 - know we're going to put this component
893:36 - in main and main is in our
893:39 - our home base our app.tsx you know that
893:42 - we're going to do an export
893:44 - const
893:45 - your wallet
893:47 - in here and we'll make this a function
893:49 - now in order to actually show these
893:51 - tokens we do need to
893:53 - get some information from our other
893:54 - component we need to get some
893:56 - information on what the supported tokens
893:58 - even are
894:00 - so we're going to have our main
894:02 - actually pass a variable
894:05 - to our wallet here
894:07 - we're going to call it the supported
894:10 - tokens
894:11 - and this is going to be of type
894:14 - your wallet props
894:19 - and this is going to be a your wallet
894:21 - props here just to tell typescript what
894:23 - this is what this supported tokens is
894:25 - going to look like we're going to say
894:27 - interface your wallet props it's going
894:30 - to look like this
894:31 - supported tokens
894:33 - and it's going to be an array
894:36 - of tokens and array of some token
894:40 - we're going to grab that token type
894:42 - from main as well so actually we're
894:44 - going to do import
894:45 - token
894:48 - from
894:50 - main
894:51 - and in our main we're going to pass this
894:53 - token and we're going to pass some
894:55 - supported tokens to our wallet
894:57 - so right underneath those three token
895:00 - addresses
895:01 - back in main we're going to do const
895:03 - supported tokens
895:05 - is going to be an array
895:08 - of token this token type
895:11 - so above here
895:13 - we do export
895:15 - type token
895:17 - equals
895:19 - and we're going to say a token type is
895:20 - going to involve an image which is going
895:23 - to be a string
895:24 - an address which is also going to be a
895:26 - string
895:27 - and a name which will also be a string
895:30 - so we're creating a new type called
895:31 - token here in our main function
895:34 - we're creating this supported tokens
895:37 - object which is an array of tokens and
895:40 - this is excuse me and this is going to
895:41 - equal
895:42 - that array syntax
895:45 - so our first token
895:47 - is going to be
895:48 - have an image
895:50 - that we haven't defined yet
895:53 - the address
895:54 - is going to be
895:56 - this dap token address
895:59 - and the
896:00 - name the name of course is going to be
896:04 - gap for dap token
896:06 - now we're going to need a couple images
896:08 - so at this point you should see where
896:10 - we're going with this we create this
896:11 - array of supported tokens
896:13 - first is our dap token and we need an
896:15 - image for this dap token so if you're
896:17 - following along you can just grab this
896:19 - image right off of the github
896:21 - and we're going to grab that dab token
896:23 - and we're going to pop it into src
896:26 - we're going to change this to
896:28 - dap.png
896:30 - now we can import this by doing import
896:33 - dap from dot dot slash dap dot png
896:38 - now i can take this dap image
896:40 - and under image i'll put
896:42 - now let's do the other tokens so we'll
896:44 - do a comma we'll do image
896:47 - we'll be f
896:48 - oops
896:50 - f
896:51 - address will be
896:53 - weath token
896:55 - with token address name will be
896:59 - wef
897:00 - and again we can either oh and let's
897:02 - close this off
897:03 - and again we can either grab right from
897:05 - my github or pop it into my src here
897:08 - we'll change this to f dot png we'll
897:11 - scroll up and we'll import this as well
897:13 - import f from dot dot slash at that png
897:18 - and boom that looks good
897:20 - one more comma image
897:22 - it's going to be
897:23 - fau
897:25 - or
897:26 - it's going to be our die token
897:28 - address is going to be fau
897:32 - token address
897:34 - name
897:36 - it's going to be fau
897:39 - or die
897:40 - this will be our die token
897:42 - we'll pop it into our src
897:45 - change the name to
897:46 - die dot png no import
897:50 - die from dot dot slash die dot png
897:54 - grab die and it looks like we're going
897:56 - to name it die actually instead and if
897:58 - your vs code starts yelling at you about
898:00 - this can't find module it's really
898:02 - confused what we're going to do at the
898:04 - top here so we're just going to add a
898:06 - little comment backslash star eslint
898:10 - disable
898:11 - spaced
898:13 - comment
898:16 - star backslash
898:18 - dash dash dash
898:20 - ref
898:21 - errant
898:23 - types
898:24 - equals react
898:26 - scripts
898:29 - and we'll save and that issue will go
898:31 - away
898:32 - all right well now that we have
898:34 - our supported tokens token array we can
898:37 - actually pass this to
898:39 - that your wallet bit
898:41 - right so now we're going to
898:42 - go to this return bit we're going to
898:44 - remove that div on main and we're going
898:46 - to actually start getting to some meat
898:47 - here so we're going to pass this to our
898:50 - your wallet component that we're going
898:52 - to import in just a second
898:53 - and we're going to send it our
898:55 - supported tokens let's say supported
898:58 - tokens equals
899:00 - supported tokens
899:02 - backslash like this
899:05 - and of course we're gonna have to import
899:06 - your wallet here
899:08 - so we'll scroll to the top we'll do
899:10 - import
899:12 - your wallet
899:14 - from
899:15 - dot slash
899:17 - your
899:18 - wallet
899:19 - we're actually going to make a new file
899:21 - in our your wallet folder called
899:23 - index.ts
899:25 - and we're just going to export
899:28 - your wallet
899:31 - from dot slash your
899:34 - wallet
899:35 - save that
899:37 - i'm getting an issue
899:39 - [Music]
899:40 - saying you wallet it's not defined
899:43 - it's because this should be your wallet
899:46 - okay cool so we're getting another issue
899:48 - but i'm going to fix that in a second
899:49 - great so now we have some supported
899:50 - tokens
899:51 - we have a wallet here
899:54 - we're exporting our wallet with our
899:56 - index.ts and our your wallet
899:58 - folder now let's finish our your wallet
900:01 - implementation
900:03 - and this needs a little equal sign here
900:05 - whoops
900:06 - and we're going to get this little error
900:07 - basically because we don't have a return
900:09 - here
900:10 - so we could just do return
900:12 - just to make it happy div
900:18 - hi
900:20 - and we'll even change this to i'm your
900:23 - wallet and we'll save and now
900:25 - everything's happy we'll go to our front
900:26 - end we'll do a quick refresh and now we
900:28 - see i'm your wallet so let's keep diving
900:31 - into your wallet here right because this
900:32 - is going to be
900:33 - where we're doing all of this stuff
900:35 - about what's in your wallet now we're
900:37 - going to use a couple of these
900:38 - components from the materials ui here to
900:40 - get started
900:42 - to start we're just going to use this
900:44 - box the box component it serves just as
900:46 - a wrapper component for most of the css
900:48 - utility needs it's
900:50 - just a box right it's a box that we can
900:52 - put on our front end so we're going to
900:54 - come over in into our your wallet and
900:57 - we'll start working with this box we're
900:59 - going to put everything
901:00 - inside
901:02 - of this little
901:04 - this little box here
901:05 - i'm going to import this box
901:08 - import
901:09 - box
901:11 - from
901:11 - [Music]
901:13 - at material
901:15 - ui core
901:17 - we'll give this a little header
901:19 - h1 we'll say
901:21 - your wallet
901:25 - h1
901:28 - get a little header your wallet on your
901:30 - wallet great
901:32 - now we'll get rid of this little i'm
901:33 - your wallet and we'll create another box
901:36 - and in here we're going to add
901:38 - all of our functionality for
901:40 - what is in our wallet now we're going to
901:42 - use some tabs here
901:43 - from the materials ui
901:45 - to swap between the tokens right we're
901:47 - going to have one tab for
901:49 - fau token another tab for zap token and
901:53 - for wrapped ether we're going to use
901:54 - this this this tabs thing here so to
901:56 - work with tabs we're going to need to
901:58 - import some
902:00 - tab stuff so we're going to import
902:04 - tab context tab list
902:08 - and tab panel
902:10 - from
902:12 - material ui
902:14 - lab
902:15 - so material ui
902:16 - material i slash lab these are some
902:18 - components that they're not quite ready
902:20 - to move to the core so we do have to add
902:22 - these as well so we'll go to our front
902:24 - end and our other shell and we'll do
902:26 - yarn add
902:27 - and material ui
902:29 - lab these are kind of their testy ones
902:31 - but they have some really nice features
902:32 - that we're going to use but let's get
902:34 - into this box and let's make
902:36 - our first tab context
902:39 - value
902:40 - equal to
902:42 - now in our box here the first tab
902:45 - that we're going to have to use is going
902:46 - to be whatever token that we have
902:47 - selected
902:48 - to select tokens we're going to use
902:50 - what's called a state hook
902:52 - so we're going to create a state hook
902:54 - here inside of this
902:56 - we're going to do
902:58 - const
903:01 - selected token index
903:04 - set selected token index
903:09 - equals
903:10 - use
903:11 - state
903:12 - number
903:14 - zero
903:15 - so use state we're going to grab from
903:17 - react it looks like i've already
903:19 - imported here
903:20 - import react
903:21 - comma
903:23 - brackets use state
903:24 - from react
903:26 - and what this is going to do it's going
903:28 - to create one variable select the token
903:30 - index this is going to be whatever token
903:33 - that we're on and then set selected
903:35 - token index is going to update this
903:37 - selected token index this u state state
903:40 - components thing is a way of saving
903:42 - state
903:43 - between renders of components so in our
903:45 - little box here
903:47 - we're going to start with a tab context
903:50 - we'll start basically with our own tab
903:52 - and the value is going to be equal to
903:55 - whatever
903:56 - token we currently have selected dot to
903:59 - string
904:03 - and we're gonna have to make a list of
904:04 - these tokens in our tab context
904:07 - we're gonna have to add some way to
904:09 - change
904:10 - between the tabs right when we change
904:12 - between the tabs we want a different
904:13 - token to be selected and we're going to
904:15 - make a
904:16 - tab list that's going to change whenever
904:18 - we
904:19 - click the different tab so
904:21 - we're going to add we're going to add
904:22 - some functionality to this but for now
904:24 - we're just going to give it an aria
904:26 - label
904:28 - call this our
904:30 - stake form tabs and based off the
904:33 - supported
904:35 - tokens
904:37 - in a mapping
904:39 - of token to index
904:41 - we're going to call a function in here
904:43 - where we return
904:44 - a tab
904:46 - which will have a label equal to the
904:49 - token.name the value would be equal to
904:52 - the index
904:54 - dot string or excuse me dot 2 string
904:58 - and the key
904:59 - is going to be equal to
905:02 - the index
905:03 - tab is something that is just from the
905:05 - material ui core so we're going to
905:08 - import
905:10 - tab
905:12 - from
905:13 - that material
905:15 - ui core
905:17 - i should probably spell supported tokens
905:19 - correctly
905:20 - supported tokens now
905:23 - if we look at our ui we can now see
905:24 - we've got a couple different buttons
905:26 - here which great we have dap west and
905:28 - die right these are the different
905:29 - supported tokens that we're mapping here
905:33 - now of course if we click the different
905:34 - buttons
905:35 - nothing actually happens so we do need
905:37 - to to handle a change we do need to code
905:39 - some functionality to handle a change
905:41 - whenever we do something different so in
905:43 - our tab list we're going to add on
905:46 - change
905:48 - on
905:49 - change
905:50 - equals
905:52 - handle
905:53 - change
905:54 - i'm going to code a little functionality
905:56 - at the top to actually handle a change
905:58 - so we'll say const
906:00 - handle change
906:03 - equal to
906:04 - an event
906:07 - a react dot
906:08 - change event
906:10 - we'll do a new value
906:11 - it's gonna be a string
906:13 - and this is a function
906:14 - so we're gonna do this little function
906:16 - syntax again
906:17 - and all we're going to do is we're going
906:18 - to use our little state hook here so
906:20 - we're going to do set
906:22 - selected
906:23 - token index
906:25 - and we're going to parse
906:27 - the int
906:28 - of the new value that we get
906:32 - so what's happening here we've added
906:34 - this new functionality where whenever we
906:36 - change
906:37 - one of those tabs we're going to change
906:39 - this the selected token right this
906:42 - selected token number is going to be
906:43 - different and what we do is we map the
906:46 - indexes to a token right so each one of
906:49 - these tokens is going to represent a
906:50 - certain number so now when we save let
906:53 - me go check out our front end you can
906:54 - now see that we do indeed swap between
906:58 - tabs here which is really nice all right
907:00 - let's keep going so that's cool we have
907:02 - a way to swap between the different
907:04 - tokens visually here but we need a big
907:07 - stake button right the reason that we
907:09 - need to swap between the tokens is
907:10 - because we need a way to stake
907:13 - between them
907:14 - so when we're on one of these tabs we're
907:17 - going to add a stake form here we're
907:19 - going to add a big button that allows us
907:21 - to stake so we're going to do some
907:22 - typescript we're going to do supported
907:25 - tokens.map
907:27 - i'm going to map that token and index
907:29 - again
907:30 - function use that and then here we're
907:32 - going to return
907:33 - a different tab panel
907:36 - the value in here is going to be the
907:37 - index
907:40 - dot to string
907:42 - key is gonna be
907:44 - the index
907:45 - we'll make a little div in here
907:48 - and we're gonna need to put two pieces
907:49 - in here we're gonna need to be putting
907:51 - our wallet balance in here and then also
907:53 - a big
907:55 - stake button right
907:57 - of course we're looking at right now
907:59 - it's just going to say our wallet
908:00 - balance and a big stake button but how
908:02 - do we actually do this how do we
908:03 - actually get our wallet balance and one
908:05 - of these big stake buttons
908:07 - well we're probably going to need some
908:09 - type of component to get our actual
908:11 - wallet balance that we're going to stick
908:12 - in here
908:13 - so yup you already know we're going to
908:15 - go in here into our your wallet
908:17 - component we're going to create a new
908:19 - file and this is where we're going to
908:20 - define
908:22 - that wallet balance component and we're
908:25 - going to import our wallet balance
908:27 - into our wallet here so that we can
908:28 - actually see
908:30 - the balance of our wallet right in the
908:31 - front end and right and this is where
908:33 - we're going to actually be reading off
908:35 - chain finally after a lot of typescript
908:38 - and react setup since we're going to be
908:40 - importing this into our your wallet
908:42 - component here of course we're going to
908:43 - start with export const
908:46 - wallet balance
908:48 - we're going to make this a function so
908:50 - we'll do this
908:51 - really weird
908:53 - function syntax and we're probably going
908:55 - to want to pass this
908:56 - the token right the token that we want
908:58 - to get the balance of
909:00 - so we're even going to set that up like
909:02 - this a token in here
909:04 - and we'll define
909:09 - what this looks like uh with the
909:11 - interface called wallet balance props so
909:14 - we'll say export interface
909:17 - wallet balance props
909:22 - and this will be
909:24 - a token right
909:26 - this will be that same
909:28 - token type that we defined before so
909:31 - we're gonna have to import that so we'll
909:32 - say import
909:35 - token
909:36 - from
909:36 - [Music]
909:38 - main
909:39 - all right great that's our initial setup
909:41 - here we'll grab
909:43 - from the token that we passed to this
909:45 - we'll pass we'll get the image
909:48 - address
909:49 - and the name
909:50 - from that token
909:51 - address and name
909:53 - we'll grab the account right because
909:55 - we're going to need the account with
909:56 - along with the token
909:58 - so we'll say const
910:00 - account
910:01 - equals use ethers
910:05 - and of course
910:07 - we're gonna have to import
910:09 - account
910:11 - from
910:12 - excuse me imports not account use
910:17 - ethers
910:18 - from at use dap
910:21 - slash core
910:22 - we're gonna need the account we're gonna
910:24 - need the address and use dab core has a
910:27 - nice little hook
910:29 - called
910:31 - use token balance that we're going to
910:32 - use you look check it out in the
910:34 - documentation provides a way to fetch
910:36 - the balance of erc20 tokens specified by
910:39 - a token address it makes our lives a lot
910:41 - easier so we'll just import that as well
910:43 - use
910:44 - token balance and all we have to do
910:47 - really is do const
910:49 - token balance
910:52 - equals
910:53 - use
910:54 - token balance
910:58 - of the address of the token
911:00 - and our count here we can even do a
911:02 - quick console.log
911:05 - token balance
911:07 - see if we're doing it correctly and we
911:10 - take this wallet balance and import it
911:12 - into our wallet here
911:14 - we should be able to see
911:17 - something so we'll import it into our
911:19 - wallet now let's go into the top we'll
911:21 - do
911:22 - import wallet
911:24 - balance from
911:26 - dot slash
911:29 - wallet balance and down inside our very
911:32 - large return function here we'll add
911:34 - this new
911:36 - tab
911:37 - or this new uh component we'll say
911:40 - wallet balance
911:43 - we still remember we need to send it the
911:45 - token
911:46 - so we'll send it
911:47 - tokens
911:48 - at the index of the selected
911:51 - token index
911:53 - i should spell supported tokens right
911:57 - i should spell wallet balance right
911:59 - capital b we do need to do a return
912:02 - so that it's actually a jsx component
912:04 - we'll do a div
912:06 - we'll just have to say i'm the wallet
912:10 - balance if we go to our front end we do
912:13 - a quick refresh
912:14 - we do indeed see this little print line
912:16 - here uh this is javascript's big number
912:20 - so if we really want to see this token
912:21 - balance we'll do dot to string
912:24 - and we have to put this question mark
912:25 - here to tell typescript hey
912:27 - turn it to a string if it's not
912:29 - undefined and now if we save we go to
912:32 - our front end
912:33 - we do a refresh
912:35 - since we are connected
912:37 - to coven here we can see
912:40 - we get an amount printed out here and if
912:41 - we switch tabs
912:44 - you'll see
912:45 - the different amounts being printed here
912:47 - which is fantastic cool so let's remove
912:50 - this little console.log we want to show
912:52 - this token balance obviously in our ui
912:55 - right we don't want to have people to
912:57 - have to go to the console.log right to
912:59 - actually see it we want it to represent
913:01 - we want to show up where it says i'm the
913:02 - wallet balance so what we're gonna do
913:04 - first we should probably format it
913:06 - right because this is in units of way
913:09 - so we're gonna do const
913:11 - formatted
913:12 - token balance
913:13 - this will be a number which will equal
913:15 - to
913:17 - token balance
913:19 - if token balance does exist
913:22 - again we're using this tertiary operator
913:24 - we're going to parse
913:26 - float
913:28 - format
913:29 - units
913:31 - balance
913:33 - 18
913:34 - otherwise we're just going to use zero
913:36 - format units is a nice little import
913:38 - that we're going to grab from
913:41 - the ethers project so we'll do import
913:44 - format units
913:46 - from at ether's project
913:50 - slash
913:51 - units
913:52 - and of course
913:54 - yarn add at ethers project and of course
913:57 - we're going to do a yarn add on this
913:59 - here we'll do yarn add
914:02 - at ether's project units and now this
914:05 - formatted token balance is going to be
914:07 - this token balance that we just got but
914:09 - formatted formatted much nicer in our
914:11 - little div here what we could just do so
914:14 - we could just add this formatted token
914:16 - balance
914:17 - we'll save and we'll look at the front
914:19 - end now
914:20 - and aha
914:21 - we now see we have 100 dapp zero weft
914:24 - and 15 die right these numbers might be
914:26 - a little bit different depending on how
914:28 - much you actually got but this is
914:29 - perfect this is exactly what we're
914:30 - looking for so let's close out the
914:32 - console and
914:34 - let's let's flesh this out a little bit
914:35 - let's make this look a little bit nicer
914:38 - here so instead of just returning a
914:40 - little div like this let's actually make
914:42 - a new component called
914:45 - balance message
914:47 - and we'll use this instead
914:50 - create a new component called balance
914:52 - message and it'll format up the way we
914:54 - actually show these formatted tokens and
914:57 - here we'll pass
914:59 - we'll pass it
915:01 - a couple variables we'll pass this
915:02 - component an amount we'll pass it a
915:04 - label
915:05 - we'll say the label is going to be
915:07 - your unstaked
915:11 - name
915:13 - balance
915:14 - right we're grabbing name from the token
915:16 - and we'll pass it a token image src
915:20 - which is going to be that image so we're
915:22 - going to pass it a label
915:24 - or excuse me not img it's going to be
915:26 - image we're going to pass it a label
915:29 - token image and an amount right and this
915:31 - component is just going to make us
915:33 - have this balance look a little bit
915:34 - nicer so in our our your wallet section
915:37 - i'm going to do a new file
915:40 - called balance message.tsx oops not tsx
915:46 - tsx and we can kind of rip through this
915:48 - pretty quickly so per usual we're going
915:50 - to export
915:52 - const
915:53 - balance message is gonna equal
915:56 - a function where it's gonna take those
915:58 - parameters a label
916:01 - and a mount
916:03 - and a token image
916:05 - src and this will be
916:08 - an interface of balance message props
916:11 - this will be a function of course so
916:12 - we'll do this weird
916:14 - function syntax of course we need to
916:16 - tell typescript
916:18 - what this looks like so we'll say
916:20 - interface
916:22 - balance message props
916:24 - what are those inputs
916:26 - we'll say the label
916:29 - is going to be a string
916:33 - the amount
916:35 - it's going to be a number
916:37 - and the token image src
916:40 - is going to be a string and in here
916:42 - we're going to use
916:44 - and in here we're going to once again do
916:45 - that use styles bit for materials ui
916:48 - because we want to style this up a
916:50 - little bit so we're going to import make
916:52 - styles
916:53 - from
916:54 - [Music]
916:56 - at material
916:58 - slash ui core
917:01 - we'll do a const use styles
917:04 - it's going to equal make styles
917:06 - theme which we're going to skip doing a
917:08 - theme but let's make some styles for the
917:11 - different pieces let's give it balance
917:13 - message be surrounded mainly by a
917:16 - container
917:18 - which will have a couple of styles in
917:20 - here we'll say the display
917:22 - it's going to be an inline grid the grid
917:25 - template columns
917:27 - are going to be
917:28 - auto auto auto again you can check out
917:31 - all these parameters in the
917:33 - documentation
917:34 - there's going to be a gap which will be
917:36 - theme dot spacing
917:38 - one again we're skipping theme but this
917:41 - will just be a way to add some spacing
917:43 - and then align items
917:45 - in the center we'll also give
917:48 - token image
917:50 - its own
917:51 - styling we give it a width
917:53 - of 32px
917:56 - 32 pixels and then
917:58 - the amount
918:00 - just do
918:02 - we go to font weight
918:03 - of 700. so we'll make that a a little
918:06 - thick
918:07 - so now that we have our use styles we
918:09 - have our styling here we can go into our
918:12 - export below
918:13 - we'll do const classes
918:15 - equals
918:16 - use styles
918:20 - and we're going to return we're going to
918:22 - return a div
918:23 - class name is going to be equal to that
918:26 - main container
918:27 - classes.container
918:31 - we'll do another div just for that label
918:34 - that we're looking for we'll do another
918:36 - div
918:37 - for class name
918:41 - equals
918:43 - classes dot amount
918:46 - so have that that nice font weight and
918:49 - then here we'll just have the
918:51 - amount
918:53 - and then we'll grab that image of the
918:55 - token
918:58 - class name is going to equal to
919:01 - classes dot token image
919:05 - we'll grab the source of that image is
919:07 - just going to be that token image src
919:09 - that we get passed
919:11 - and we'll give it an alt
919:13 - called token logo
919:16 - and we'll close that tab out
919:18 - great so we're going to want to do is in
919:21 - our wallet balance here it's balance
919:23 - message that we just created we'll do
919:26 - import
919:29 - balance message
919:32 - from dot
919:34 - dot com
919:37 - mints slash
919:39 - your wallet
919:42 - capital w and actually i know we're
919:43 - going to use this balance message a
919:45 - little bit later so i'm actually going
919:46 - to grab it
919:48 - and drag it into components move it into
919:50 - components and move it out of your
919:52 - wallet
919:53 - because i know that we're actually going
919:54 - to use it a little bit later so that
919:56 - means in our wallet balance
919:58 - we're just going to pull it right from
920:00 - components
920:01 - slash
920:03 - balance message
920:05 - and whoops we actually need to make this
920:07 - look like
920:08 - this
920:10 - close it out here
920:13 - remove this part
920:16 - like this boom right like that
920:20 - and now let's try out the front end okay
920:23 - we're looking a little bit nicer
920:25 - right we have a really thick number here
920:28 - explaining how much of the token we have
920:31 - we have the images popping up this looks
920:33 - starting to look great let's add this
920:36 - stake button right so that when they see
920:37 - this they can actually stake and
920:39 - interact with our contract here so to do
920:41 - this we do need to create another
920:43 - component called our stake form so in
920:46 - your wallet we're going to create a new
920:47 - file
920:48 - called stake form dot ts x and this is
920:53 - where we're going to add
920:54 - a little button
920:56 - and an amount for the users to actually
920:58 - stake on our contract so you already
920:59 - know we're going to start with export
921:01 - const
921:02 - state form
921:03 - equals
921:06 - and we're going to have
921:09 - our wallet pass
921:10 - the token just like we passed the token
921:13 - to wallet balance
921:14 - so we'll say token and we'll have this
921:16 - be stake form props
921:19 - which is an interface we're going to
921:20 - define in a second this is a function so
921:22 - we'll do this fun function
921:25 - syntax here
921:26 - and then stake form props as you know is
921:30 - just going to be a token so do inter
921:32 - export
921:34 - interface
921:35 - stake form
921:37 - [Music]
921:38 - props
921:42 - this is just going to be a token of type
921:44 - token which again
921:47 - we're going to import token
921:51 - from
921:54 - maine
921:56 - great and that is our starting point for
921:57 - this so we're going to create a stake
922:00 - form
922:01 - with a big button that says stake and
922:03 - the user can actually choose how much
922:05 - they want to stake on our smart contract
922:07 - so we're going to do some similar stuff
922:09 - as we did before we're going to grab
922:11 - some variables we're going to say the
922:13 - address is going to be that token
922:15 - address
922:16 - that we get from the pass token
922:19 - we're also going to get a name
922:20 - of the token
922:22 - from that token
922:24 - we're going to get our account
922:28 - from use ethers again
922:31 - so we can import that we'll say from or
922:33 - oops
922:34 - import
922:40 - use ethers
922:43 - from
922:46 - at use
922:48 - dap slash core we're going to want to
922:50 - grab the token balance so we'll do const
922:53 - token balance
922:54 - once again we can grab that with the use
922:57 - token balance with the token address
923:02 - and the account
923:04 - so we're going to use use token balance
923:08 - this will also grab from used app slash
923:10 - core we're going to want to format this
923:11 - token balance so we'll do const
923:14 - format it token
923:16 - balance it's going to be a number
923:19 - again this is going to be the exact same
923:21 - as we did before say token balance
923:25 - do parse float
923:27 - format units
923:30 - token balance
923:35 - 18
923:36 - or
923:37 - zero
923:38 - in format units once again we're going
923:40 - to import that import
923:44 - format units from
923:46 - at ether's project slash units
923:50 - perfect
923:51 - importing here we've gotten some some
923:53 - starter boilerplate let's just go ahead
923:55 - and grab those buttons right because
923:56 - those are really the things that we're
923:58 - going to care about here let's just
923:59 - return some stuff here so something can
924:01 - show up on our front end right so let's
924:03 - do return
924:05 - i'll start returning something here and
924:07 - whenever we return something it's all
924:08 - gonna be in one
924:10 - tag right so i'm gonna i know i'm gonna
924:12 - be doing a whole bunch of different tags
924:13 - so i'm just gonna go ahead and make an
924:15 - open and close tag here
924:17 - and this is where i'm going to put all
924:18 - my stuff now we know we're going to want
924:19 - to have a big stake button right so
924:21 - let's go ahead and just do
924:23 - let's get a let's get a button tag in
924:25 - here and of course since we're going to
924:26 - have a button
924:28 - we're going to pull this in
924:29 - from that materials eye material ui
924:32 - right so we'll do import
924:33 - button
924:35 - from
924:37 - material
924:38 - ui core just so we can get get started
924:41 - with something here and then back in our
924:42 - your wallet.tsx let's add this button in
924:45 - here inside of our tab panel
924:48 - right below our wallet balance we'll add
924:50 - this
924:51 - stake form thing we'll open and close of
924:54 - course we've got to import it
924:56 - so we'll say import
925:00 - stake form from
925:02 - dot slash
925:04 - stake form and
925:06 - we need to pass this that token object
925:09 - so back in our your wallet we're gonna
925:11 - say okay token
925:12 - equals
925:14 - supported tokens
925:16 - of that
925:17 - selected token
925:19 - index
925:22 - selected
925:24 - token
925:26 - index and let's not have this
925:29 - let's just do a little backslash here to
925:31 - close that out let's be sure to close
925:33 - this bracket here we'll give this button
925:35 - some stuff right we'll do color equals
925:38 - primary say size equals large then we'll
925:42 - give it some text called
925:44 - stake
925:46 - double exclamation point or however many
925:48 - you want to put in there and now if we
925:49 - look at the front we got this big stake
925:50 - button
925:51 - nice okay we're looking a little bit
925:53 - better currently doesn't do anything but
925:55 - we have a stake button great
925:57 - now we can start adding some
926:00 - implementation right we can have it do
926:02 - some stuff now
926:03 - when we hit this stake button what do we
926:05 - want it to do we want to do two things
926:07 - we want to approve
926:09 - whatever token that we have and then we
926:11 - want it to stake that amount we also
926:14 - need to have some type of form here we
926:16 - need to know how much we want to stake
926:17 - right so we're going to need some little
926:19 - input box that we can add a certain
926:21 - amount in well we can do that too with a
926:23 - little input box from materials ui so
926:26 - there's another package we're going to
926:27 - grab which is called input
926:29 - from materials ui core
926:32 - and then we're going to use this little
926:33 - input box before
926:34 - the button so we're gonna do input
926:37 - little slash here now if we save
926:40 - refresh the front end
926:42 - awesome now we can do some typing in
926:44 - here we can click this stake button now
926:46 - to do this though we're gonna need to
926:47 - keep track of how much amount is in here
926:50 - right we're going to need to keep track
926:51 - of how much amount's in here
926:54 - so we're going to inspect on the front
926:55 - end and we're going to go to console and
926:57 - see if we can follow along
927:00 - with how much is in here or what amount
927:02 - is in here and to do this we're going to
927:03 - make another one of those state hooks
927:06 - and we're going to track that amount in
927:07 - there
927:08 - so we're going to say const
927:10 - amount
927:12 - set amount
927:13 - for one of these stakeholders equals use
927:16 - state which is going to be a number
927:20 - or a string or an array number or string
927:26 - zero
927:27 - and we're going to import this use state
927:29 - here
927:30 - from react so we're going to do import
927:33 - import
927:35 - react
927:37 - use state
927:40 - from react
927:41 - and now we have this state hook that we
927:44 - can use to keep track of the amount
927:46 - that's going to be put in there with our
927:48 - input tag here we're going to say on
927:50 - change
927:51 - whenever this changes we're going to
927:53 - have to
927:54 - have some handle function right we're
927:56 - going to call it
927:57 - handle
927:58 - input change and this is going to handle
928:01 - the input change so we're going to
928:02 - create that function we're going to do
928:04 - const
928:05 - handle input change equals and we're
928:08 - going to use some event stuff in here
928:10 - we're going to say this is going to take
928:12 - an event
928:14 - a react
928:16 - dot change
928:18 - event
928:19 - of html input element
928:23 - this is going to be a function
928:25 - that's going to
928:27 - set amount
928:28 - it's going to say
928:30 - const
928:31 - new amount
928:33 - equals
928:34 - event.target.value
928:37 - whenever we change that value in that
928:39 - field if if it's equal to nothing
928:43 - then we're just going to say okay we're
928:45 - going to do nothing
928:46 - otherwise
928:48 - we're going to cast it as a number
928:50 - event.target.value
928:53 - we're going to cast whatever is in there
928:55 - as a number
928:57 - and then
928:59 - we're going to do set amount
929:01 - to this new amount what we could do is
929:03 - we can even do a console.log
929:06 - new amount
929:08 - and now and we can start using it right
929:10 - so if i go back here and do one two
929:12 - three right you can see it's
929:13 - console.logging every time i change
929:15 - something in here so now we have a way
929:17 - to actually get that amount with this
929:19 - input now we're going to need to weigh
929:21 - to send that amount as part of our stake
929:23 - right so we're going to first have to
929:25 - call that approve function with this
929:27 - amount and then we're going to have to
929:28 - call
929:30 - from our token farm then we're going to
929:32 - have to call the stake method so how do
929:34 - we get
929:35 - it to call this approve function here
929:38 - well to do these we're actually going to
929:39 - make some new state hooks that we're
929:42 - going to use in our staking form here
929:44 - we're going to make state hooks for
929:46 - approving and for staking and even for
929:49 - unstaking so
929:51 - back in our folder here we're going to
929:53 - create a new folder
929:55 - called hooks
929:56 - and this is where we're going to add
929:58 - some different hooks
930:00 - first hook that we're going to make is
930:01 - going to be called use
930:02 - use stake
930:04 - tokens dot type script and this is
930:07 - something that we're going to import
930:08 - into our our stake form here so we can
930:11 - actually stake some tokens and the way
930:13 - we want to do it too
930:14 - is that once we hit stake once we hit
930:17 - our stake button
930:18 - it kicks off the approve and then and
930:20 - actually right afterwards it kicks off
930:22 - ascend it kicks off a stake token we
930:24 - want to run these two
930:26 - functions sequentially and we're going
930:28 - to make this use stake token hook clever
930:30 - enough to do it in that order so let's
930:32 - do it hooks are basically just like
930:33 - components except for they're more
930:35 - functionality wise so since we know
930:38 - we're just like components we're going
930:39 - to do export const
930:41 - use stake tokens and this is going to be
930:45 - a function
930:47 - just like our other components and as
930:49 - input we're going to take a token
930:50 - address
930:51 - that's going to be a string and inside
930:53 - of this we're going to have some
930:55 - intelligent scripts to know if it's
930:58 - already been approved if it's not
930:59 - already been approved and what we need
931:00 - to do right we know we're going to need
931:02 - some approved thing and we know we're
931:04 - going to need some stake tokens thing so
931:06 - let's let's at least try to approach
931:08 - this approved thing first before we get
931:09 - too creative right how do we approve
931:11 - this transaction to get an approve we're
931:13 - going to need a couple things we're
931:14 - going to need the address
931:16 - as you guys know
931:18 - we're probably going to need the abi
931:20 - we're probably going to need
931:22 - the chain id so we know which chain it's
931:24 - on
931:24 - so let's go ahead and let's grab those
931:27 - so we'll do const chain id
931:32 - equals use ethers
931:35 - and since we're using use ethers here
931:38 - we're going to import this so we'll do
931:40 - import
931:42 - use ethers
931:44 - from at use dep
931:46 - slash core
931:49 - we're also going to want the abi of the
931:51 - token farm so we'll do const
931:54 - abi
931:55 - equals well where do we get this api
931:58 - from ha that's right we've imported it
932:01 - in our little chain info piece and
932:04 - should be right in here we could should
932:06 - be able to do
932:07 - import
932:08 - token farm
932:10 - from down to directory it'll be in
932:13 - chain info slash contracts
932:16 - slash
932:18 - tokenfarm.json and now we can say
932:21 - avi is going to be equal to this this
932:23 - token farm right because in token farm
932:26 - we have an abi key so we can just
932:28 - abstract that away and just pull out the
932:30 - api perfect we're going to need the
932:32 - token address of course we're also going
932:34 - to need our token farm address and we
932:36 - can find that the exact same way we
932:38 - found it before
932:39 - with const token farm
932:41 - address
932:43 - it's going to be equal to
932:44 - depending on if the chain id exists
932:47 - once again we're going to want to use
932:49 - that network mapping so we can even go
932:51 - back to main.tsx
932:53 - let's see how we did it here for the
932:55 - depth token address
932:57 - you can copy this as like a frame of
932:58 - reference
933:01 - we'll say if this chain id exists we'll
933:04 - pull
933:05 - right from that network mapping
933:07 - right we'll pull right from the network
933:08 - mapping so we got to import that too
933:10 - which we can grab from
933:13 - import
933:15 - network mapping
933:18 - from
933:20 - chain
933:20 - info chain info slash
933:24 - deployments
933:25 - slash
933:26 - map.json so once again we're going to
933:29 - say if that chain id exists
933:31 - in the network mapping
933:33 - we're going to use
933:35 - that string chain id
933:37 - so we'll do string
933:39 - chain id
933:43 - of
933:44 - the token farm
933:47 - at position 0 right because we obviously
933:49 - want the most recent one otherwise again
933:51 - we'll do constants dot
933:54 - address
933:55 - zero
933:57 - and since we're going to do that of
933:58 - course we're gonna have to do import
934:01 - constants
934:04 - from
934:04 - [Music]
934:06 - ethers
934:08 - and this hooks folder should be in
934:09 - source so let's just make sure that
934:11 - we have hooks in source here now we're
934:13 - going to want to interact with this
934:15 - token farm address contract right we're
934:17 - going to want to run that proof function
934:20 - first we want to create like an
934:21 - interface so we can do const
934:24 - token farm interface we'll say this
934:27 - equals new
934:29 - utils.interface with the abi
934:32 - this utils we can again grab from the
934:35 - ethers project or excuse me from uh from
934:37 - ethers so we'll do comma utils
934:41 - now we can create a token form interface
934:43 - here and now that we have interface
934:44 - we'll create a contract so we'll do
934:47 - const token farm contract
934:50 - equals new
934:52 - contract
934:54 - and this will be a combination of this
934:55 - token farm interface and the token farm
934:58 - address actually it's address first and
935:00 - contract is something we can grab from
935:03 - import
935:05 - contract from at ether's project
935:09 - slash
935:10 - contracts
935:12 - all right
935:13 - you're probably starting to follow along
935:15 - and figure out okay cool i have a token
935:16 - farm contract
935:18 - now that we have a contract we can
935:19 - actually call some functions which we
935:21 - totally can but right we need to call
935:23 - the approve first so let's get
935:26 - the token contract before we even work
935:29 - with the stake token right so to work
935:31 - with the token we're going to want to do
935:32 - the same thing so we'll do const
935:35 - erc20
935:36 - interface
935:38 - equals new utils dot interface
935:42 - interface
935:44 - and this will be from ear c20
935:47 - abi which we should probably make first
935:49 - so we'll do const erc20 avi
935:53 - equals
935:54 - we'll do it the same way we did up here
935:56 - except for instead of token farm we'll
935:58 - do something else we'll do
936:00 - look in our contracts here
936:02 - we'll do mock erc20 instead
936:05 - and then we'll just call this erc20
936:07 - or yeah we'll just call this erc20
936:10 - but we'll grab it from our mock erc20
936:13 - dot json
936:15 - so now that we have the crc20 we do
936:17 - const erc20 api equals
936:20 - erc20.avi
936:23 - and we can just pop this api
936:25 - to create our interface we'll now do
936:27 - const erc20
936:30 - contract
936:31 - equals new contract of
936:35 - the token address
936:37 - comma the erc20 interface
936:41 - boom okay
936:42 - now we have both of these contracts we
936:44 - have the erc20 contract we have the
936:46 - token farm contract now we should be
936:48 - able to go ahead and call some functions
936:50 - right now to actually send one of these
936:52 - we're going to use this thing called use
936:53 - contract function it's a hook in use dap
936:57 - that returns an object with two
936:59 - variables a state and a send this state
937:03 - bit is used to represent the status of
937:06 - the transaction and that's how we're
937:08 - actually going to automatically kick off
937:10 - the stake after we approve to send a
937:13 - transaction we have to actually have to
937:15 - we actually have to use this send
937:16 - function here
937:18 - so we're going to use this use contract
937:19 - function to get to get a state and
937:21 - ascend so that's what we're going to
937:23 - first need to do so we're going to const
937:25 - send
937:27 - and then we're going to call this
937:28 - approve erc
937:30 - 20 send
937:32 - and state because this is what it's
937:34 - returning it's returning send an estate
937:37 - i'm going to say state is going to be
937:38 - approved
937:39 - erc20 state
937:42 - equals
937:44 - use contract function
937:47 - we pass the token contract the erc20
937:50 - contract
937:52 - comma the name of the function which is
937:54 - going to be approve
937:55 - then we do a comma and then we'll do a
937:57 - little object here we'll call this
938:00 - transaction name
938:01 - and this will just be approve
938:03 - erc20
938:05 - transfer
938:08 - then of course i have to import this
938:10 - from used app this use contract function
938:15 - now oddly enough
938:16 - oops i got rid of the
938:18 - closing tag here but great so now in a
938:21 - weird way we actually have these two
938:23 - new pieces here we have this send
938:25 - function this approve vrc20 send
938:27 - and this approve erc20 state this is
938:30 - going to be
938:31 - the status of our transaction and this
938:33 - is going to be the actual function that
938:34 - we use and if we want to call this
938:36 - approve function what we can do
938:39 - is now we can return calling this proof
938:41 - function so we'll do const approve
938:45 - we'll have this be
938:47 - a function we'll say it'll take a string
938:50 - amount as an input parameter
938:52 - and we'll just have it return
938:54 - this approve erc20 send and we'll give
938:57 - it the token
938:59 - farm
939:01 - contract address
939:04 - as a first input parameter excuse me
939:06 - token farm address and we'll use this
939:08 - input amount as the second parameter and
939:11 - then we'll just have this
939:14 - this use stake tokens return this
939:17 - approve function
939:20 - and then also
939:21 - this state here so it's going to return
939:24 - approve
939:25 - and it's going to return state we could
939:26 - also just have it return this if we
939:28 - wanted
939:29 - but we're going to wrap it just all up
939:31 - in this approved thing here we also
939:33 - probably want to return this state right
939:35 - so we're going to turn this into
939:38 - hook as well
939:40 - so we're gonna do const
939:42 - state
939:44 - set state
939:47 - equals
939:48 - oops
939:51 - use state and we'll have this be the
939:54 - approved
939:55 - or the approved erc 20
939:58 - state
939:59 - as the input and of course since we're
940:01 - using use state we're going to grab this
940:03 - from react as well we also want to
940:04 - return the state so we'll return this
940:06 - approve erc20 state here so now we have
940:09 - a way
940:10 - to actually do all this
940:12 - so in our stake form
940:15 - what we're going to have
940:17 - is we're going to create const that's
940:19 - going to grab those two variables so
940:21 - we'll do const approve
940:23 - and approve erc20 state is going to be
940:26 - equal to use
940:28 - stake tokens
940:30 - with that token
940:32 - address
940:34 - pulled down from the token as the input
940:36 - parameter
940:37 - and this is our new hook so we're going
940:39 - to import
940:42 - use stake tokens
940:45 - from
940:46 - dot dot slash dot dot slash hooks now
940:49 - that we have these two functions we have
940:50 - the approve function and then we have
940:52 - the state of that function
940:54 - now we can add a handle submit
940:57 - functionality for our button here
941:00 - so now we can say okay on click
941:02 - when we click this button
941:04 - we're gonna do
941:06 - a handle
941:08 - stake
941:09 - submit
941:11 - right because this is that our big well
941:13 - it's not gonna show up now because i
941:14 - broke everything but this is our big
941:15 - button right this is our this is our
941:17 - stake button so we're going to create
941:18 - this function called handle stake submit
941:20 - let's go ahead and do const
941:23 - handle stake submit
941:24 - this will be a function
941:27 - and what it's going to do
941:28 - is we'll get this amount here so we'll
941:31 - do const
941:33 - amount
941:35 - which we're going to actually have to
941:36 - convert it from
941:38 - string to way so we'll call it amount as
941:41 - way
941:42 - we'll do equals utils.parse
941:44 - ether we'll grab parse ether
941:48 - we'll grab utils
941:50 - again from ethers
941:52 - utils from
941:53 - ethers
941:55 - and we'll do the amount dot 2 string
941:59 - so we're going to grab this amount this
942:01 - statehook amount here we'll turn it into
942:03 - a string
942:04 - and then what we can do is we can return
942:08 - this approve function
942:10 - with this amount as way
942:12 - okay oh and then we're getting a fail to
942:15 - compile so in our hooks section we're
942:17 - just gonna do an index.typescript
942:20 - and we're gonna export this use stake
942:23 - so we'll do export
942:25 - use
942:26 - stake tokens
942:28 - from dot slash use stake
942:31 - tokens
942:33 - close that
942:35 - we'll restart the server
942:37 - and then i should import this from the
942:38 - right place
942:40 - and i should import this from the right
942:41 - place as well
942:54 - and let's get rid of the brackets here
942:55 - whoops sorry
942:58 - and let's do this
943:00 - as a dot to string oops because you
943:02 - can't do a big number
943:04 - now let's save it'll recompile we'll pop
943:06 - into our front end here we'll do a
943:08 - refresh
943:10 - our stuff is up that's cool our stuff is
943:12 - getting
943:13 - logged out now if we hit stake
943:16 - we should call the approve function here
943:19 - metamask pops up we do get allow
943:21 - localhost to spend your dap this is
943:23 - amazing we're gonna reject this for now
943:25 - though because
943:26 - or don't want to bother testing it so
943:29 - amazing job getting this far we're
943:32 - hitting a button
943:33 - metamask is popping up and
943:35 - we're doing it we're actually sending a
943:37 - transaction this is incredibly exciting
943:40 - great work so far let's keep going uh
943:42 - the approve function is working
943:44 - perfectly it's working as intended or
943:46 - we're just we're kind of assuming it's
943:47 - working as intended but that's great
943:49 - this is perfect so now we've got to go
943:51 - one step further we need to have this
943:53 - call stake after it's been approved this
943:57 - is where we're going to do a little
943:58 - something called use effect we can
944:00 - import in here
944:02 - just to use effect
944:04 - comma what use effect does it allows us
944:08 - to do something if some variable has
944:10 - changed
944:11 - so the way that we're going to do that
944:13 - is we're going to say okay
944:15 - use effect
944:17 - and it takes one of these functions as
944:20 - an input and then we'll do a little
944:21 - comma here and similar to those state
944:23 - hooks we'll do an array
944:25 - of different things we want to track and
944:27 - if anything in this array changes we'll
944:29 - kick off this use effect and we'll do
944:31 - something in here
944:33 - so one of these things that we
944:34 - definitely want to
944:35 - track is this approved erc20 state
944:38 - if approved erc20 state if this
944:40 - transaction comes back successful
944:42 - then we want to do some stuff
944:44 - so we'll say we'll track this
944:46 - this state and we'll go ahead and say if
944:50 - approve erc20 state dot status
944:55 - equals
944:58 - success
945:00 - then
945:02 - we're going to go ahead and do like a
945:04 - stake function
945:06 - and to do a state function we're going
945:07 - to follow this exact same methodology
945:09 - that we did for the approve
945:12 - so first
945:14 - we're going to use this use contract
945:15 - function thing
945:17 - so we'll do const
945:19 - send is going to be
945:21 - stake
945:23 - send
945:24 - and then state
945:26 - will be
945:27 - stake state
945:30 - this is going to be equal to
945:32 - again we're going to use use contract
945:34 - function
945:35 - this is going to be on our
945:37 - token farm
945:40 - contract this is going to be our stake
945:43 - tokens
945:44 - function
945:46 - and this will be trans action name it's
945:49 - just going to be stake tokens
945:52 - and that's it
945:53 - so let's make this look a little bit
945:54 - more readable here lovely
945:57 - so we have our little used contract bit
946:00 - here and now this stake send we can just
946:02 - call this right in this approve erc20
946:05 - dot state does status we need to do
946:06 - stake send
946:08 - and if we look back in our token farm if
946:10 - we do stake
946:12 - tokens we have an amount and a token
946:14 - address so that's what we're going to
946:16 - have to put in here
946:17 - we have to put some amount
946:19 - and then token address will just be
946:21 - token address
946:23 - where do we actually get this amount
946:24 - from
946:25 - well when we originally called
946:28 - this approved function this is when we
946:30 - should actually do it and you might be
946:32 - asking hey
946:33 - how come we wrapped this approve your
946:35 - c20 into a function here but we're not
946:37 - going to do that here i'll tell you why
946:38 - in just a second so what we're going to
946:40 - have is we're going to have a state hook
946:42 - for how much we want to actually
946:44 - stake so we'll do const
946:47 - amount to stake
946:50 - and set amount to stake
946:53 - it's going to be equal to use state
946:56 - and we're going to start with zero we're
946:58 - just going to get this defaulted right
946:59 - to zero
947:01 - and what we're going to do actually
947:02 - is once we call this approve function
947:05 - the first time
947:06 - we're going to set amount to stake
947:08 - to be
947:10 - this amount and what we should do
947:12 - instead of calling this approve is we
947:14 - should call this approve
947:17 - and stake
947:19 - since it's this function that's going to
947:20 - kick off yes it's going to kick off our
947:23 - approve erc20
947:25 - but it's also going to change
947:27 - the amount that we're going to stake
947:29 - and later on
947:30 - once the transaction succeeds it will
947:33 - also then kick off our steak send
947:36 - or our staking function so we're going
947:38 - to change this to a proven stake that
947:39 - means below we have to actually return a
947:42 - proven stake and not just approve
947:44 - and for stake send the amount is going
947:47 - to be this
947:48 - amount to stake which we got from our
947:51 - original proven stake and then we just
947:53 - have to change this to approve
947:55 - and stake
947:57 - and we'll change this from improve to
947:58 - approve and stake and realistically
948:01 - that's all we really need to do here so
948:03 - if we save we go back to our front end
948:06 - let's go to one of these that i actually
948:07 - have some of i'll type in one
948:10 - for in here i'll hit the stake button
948:13 - and what should happen is approve will
948:14 - come up i'll confirm
948:17 - and once this actually confirms then
948:19 - i'll be able to another transaction
948:22 - should pop up
948:23 - telling us
948:25 - to actually stake and that's exactly
948:27 - what happens here so we've approved now
948:29 - we can stake we'll even watch metamask
948:31 - really really quick here i'm doing this
948:33 - on coven
948:35 - right i just called this state tokens
948:37 - function
948:38 - for those of you doing this on ganache
948:39 - will be a lot quicker but perfect that
948:42 - was fantastic our balance even got
948:44 - deducted by one now we have
948:47 - one
948:48 - of these tokens actually staked and this
948:50 - is fantastic however
948:52 - there's obviously a couple issues here
948:53 - right
948:54 - what was happening during that that
948:56 - whole section right there is there was
948:58 - no indication for us of what was really
949:00 - going on got no notifications we're
949:02 - totally left in the dark here
949:04 - additionally
949:06 - this page still looks disgusting so we
949:08 - want to clean this up we want to make
949:09 - this look a lot nicer so how can we
949:12 - actually do this
949:13 - so for switching between these we want
949:14 - to actually just change our use effect
949:16 - here
949:17 - so we do want to check let's approve
949:19 - erc20 state but we also want to see if
949:22 - we switch the token address
949:24 - we want to just check to see if approve
949:25 - vrc20 is done if we switch our token
949:28 - address
949:28 - and we also want to just check to see
949:31 - this if amount to stake actually changes
949:33 - so if we do amount to
949:36 - stake
949:37 - we want to check kind of during all
949:39 - these these three if any of these three
949:40 - changes we'll just do a quick check hey
949:42 - is the prove vrc20 done if yes great
949:46 - then we'll we'll stake some tokens so
949:48 - this is great but we're going to want to
949:49 - get some notifications that these
949:51 - transactions are going through these
949:53 - transactions are pending
949:55 - and these transactions finish so why do
949:57 - we actually add those pieces to this
949:59 - well used app has this thing called use
950:01 - notifications this notifications bit
950:04 - will help us actually get notified on
950:07 - whether or not our transactions are
950:08 - completing so to use these notifications
950:10 - we're going to do a couple of different
950:12 - things in here first all the way back in
950:14 - our app.tsx we're actually going to
950:16 - change our config here
950:18 - we're going to add some notifications
950:21 - in here
950:22 - to check periodically if our things are
950:25 - done
950:26 - and there's a couple of different
950:27 - parameters there's a
950:29 - x
950:30 - variation period and then we'll set it
950:33 - to be 1000 this is in milliseconds so
950:36 - we'll set it to be a thousand which is
950:37 - just one second
950:39 - and we'll do a check interval
950:42 - also of one thousand so basically we're
950:43 - saying hey every second check the
950:45 - blockchain on our transactions that we
950:47 - send please thank you and now that we
950:49 - have this notifications bit identified
950:51 - in our staking form
950:53 - we can add this bit so from used up
950:55 - decor we'll do comma use notifications
950:59 - and now we can actually start using some
951:01 - of these notifications so right here at
951:03 - the top
951:04 - we'll do const
951:07 - notifications
951:10 - equals use notifications
951:13 - we can actually start working
951:15 - with some of these notifications now
951:17 - we're going to want to see if anything
951:19 - in any of these notifications actually
951:21 - change and if these notifications change
951:23 - we're going to want to do something so
951:25 - since we're going to want to check to
951:26 - see if this if notification changes
951:29 - those who have been following along with
951:30 - what i've been explaining for use effect
951:32 - you know that means we're going to want
951:33 - to use a use effect we're going to say
951:36 - use effect
951:37 - it's going to be this function
951:39 - and if we don't have it imported let's
951:41 - go ahead and import this from react
951:43 - let's use effect
951:45 - we're going to be looking to see if
951:46 - these notifications change we're going
951:48 - to be looking to see if our transaction
951:49 - has completed so in our little watching
951:52 - array here
951:53 - we're going to say let's watch the
951:56 - notifications here let's make sure
951:59 - if any of those notifications changes if
952:01 - anything in our meta mask changes we're
952:03 - going to want to do something right so
952:06 - we're going to say
952:07 - if
952:08 - there are any notifications that are
952:10 - approved erc20 or transaction succeeded
952:14 - we want to show hey you know good job
952:16 - it's been approved
952:17 - so to do this we're going to say if
952:20 - notifications
952:21 - dot
952:23 - filter
952:24 - all right this is going to be a function
952:26 - based off the notification
952:29 - on this notification we're going to say
952:31 - notification.type
952:34 - it's going to be
952:35 - transaction dot succeeded
952:39 - succeed
952:40 - and
952:41 - that
952:42 - notification dot transaction name then
952:45 - this is why we need to give them names
952:47 - before
952:48 - in our use state
952:51 - it's going to be approve
952:53 - erc20 transfer
952:55 - dot length
952:58 - is greater than zero
953:00 - then we're going to do some stuff
953:02 - our transaction succeed
953:03 - so we're saying if
953:05 - in these notifications we're going to
953:07 - filter on a notification
953:09 - if the type is transaction succeeded and
953:12 - the name is approved erc20 transfer then
953:15 - we're going to do some stuff and for now
953:17 - we're just going to do console.log
953:20 - approved
953:21 - we can also then do the same thing for
953:23 - if
953:24 - notifications dot filter
953:26 - author on the notification
953:30 - notification dot type
953:33 - if that notification to type is going to
953:34 - be again that transaction
953:37 - succeed
953:39 - and
953:40 - notification
953:42 - dot transaction name
953:45 - equals stake
953:48 - tokens capital t
953:50 - stake tokens
953:52 - there are more than one dot length
953:55 - is greater than zero
953:57 - then
953:58 - we'll do console.log
954:01 - tokens staked
954:03 - okay so we've got some notifications put
954:05 - in
954:05 - we're gonna do a little console logging
954:07 - let's see if our use effect stuff is
954:09 - actually gonna work so let's go to our
954:11 - front end we'll do a quick refresh
954:14 - we'll go to where we have some tokens
954:15 - i'm gonna type one in here i'm gonna hit
954:17 - stake
954:19 - i'm gonna hit
954:20 - confirm and we're gonna wait a little
954:23 - bit and if this confirms correctly
954:26 - then we're gonna see a little
954:27 - console.log printout that says approved
954:29 - and we do indeed and that's perfect
954:32 - metamask pops up again for our stake
954:34 - tokens
954:35 - we hit approve there as well
954:37 - and we should see a little console.log
954:39 - out here for state token staked and we
954:41 - do perfect so now we have a way to
954:44 - actually track some of these
954:45 - notifications and track what actually
954:47 - happens on the blockchain
954:49 - console.logging stuff is great but we
954:51 - want to actually see it in our ui here
954:54 - what we're going to want to do is show a
954:56 - little waiting thing here
954:58 - while we're waiting for it to be
954:59 - approved and then she'll pop up when it
955:01 - actually does get approved we can add a
955:02 - little
955:03 - constant called is mining
955:06 - which will be based off of whether or
955:08 - not the transactions are approved so
955:10 - we'll do const
955:12 - is mining
955:14 - and this will be equal to
955:16 - the state of these transactions so this
955:18 - should actually instead be approved
955:20 - erc20 there should be approve
955:23 - and stake erc20 state now we'll say oops
955:27 - now we'll say is mining will be equal
955:30 - to approve and stake erc20 state dot
955:33 - status
955:35 - equals equals equals
955:37 - mining should probably have it look like
955:39 - this
955:40 - then back in our
955:42 - use stake instead of
955:44 - approve your c20 i'm going to change
955:46 - this to approve and stake your c20 state
955:49 - and then we're also going to return
955:51 - prove and stake erc20 stake
955:53 - let's make this make a little bit more
955:55 - sense here get that little red line to
955:57 - go away and now what we can do with this
955:59 - is mining thing is we can add this to
956:01 - our button now we have this is mining
956:03 - thing it's gonna be based off of whether
956:05 - or not approve and stake are done so we
956:08 - can scroll down to our button
956:10 - and we can add a little disabled flag so
956:12 - we'll say disabled
956:14 - equals
956:17 - it'll be equal to dependent on whether
956:18 - or not it's done we'll just add is
956:21 - mining
956:23 - and if this is true then disabled will
956:25 - be true and if this isn't mining then
956:27 - this will be false
956:28 - we can also add
956:30 - this to be kind of like a little loading
956:31 - thing so instead of just saying stake
956:33 - all the time
956:35 - we'll do a tertiary operator we'll say
956:37 - if it is mining
956:39 - then we'll do like a little loading
956:40 - thing material ui has this thing called
956:44 - circular progress that we can use it's
956:46 - like a little loading thing
956:47 - so we can do if it is mining we'll do a
956:50 - circular progress
956:52 - we'll say the size is 26 or whatever we
956:55 - want it to be
956:57 - we'll close the tag out
956:58 - and if it's not mining again we'll do
957:00 - this stake with a bunch of exclamation
957:02 - marks here so now if we save that go to
957:05 - our front end
957:06 - it looks like i need to fix something
957:08 - can't find name approve your c20 state
957:10 - that's because we changed it this is now
957:12 - a proven stake er20 state
957:15 - so let's change it to that
957:17 - now let's save go back to the front end
957:19 - and okay cool
957:20 - let's go to one of these that we have
957:22 - some stuff with we have a little dial
957:24 - we'll do one here
957:25 - we'll hit stake and if we did this right
957:28 - this should show a little loading thing
957:30 - while the transaction is going through
957:32 - so we're gonna hit approve
957:34 - and perfect we do see a little loading
957:36 - thing and it should stay like this
957:39 - until the transaction finishes
957:41 - this is a good way to indicate to the
957:42 - user that we've actually
957:44 - approved
957:46 - now i'll hit confirm for staking so we
957:49 - didn't actually see the loading thing go
957:51 - back up again so this probably means
957:53 - that we didn't actually reload this is
957:55 - mining correctly
957:57 - and the reason we don't see the little
957:58 - spinny thing is because this a proven
958:00 - stake erc20 state is really only
958:03 - tracking the approve right we have our
958:05 - cost a proven stake which does all this
958:07 - good stuff here but our staking part
958:10 - this stake state we actually never use
958:12 - right and we need to pass this back to
958:14 - our our stake form so it can actually
958:16 - know you know what's going on so what we
958:18 - can do is we can add a new state hook
958:21 - we'll do const we'll just call this one
958:23 - state
958:24 - and then we'll do set state it's going
958:26 - to be equal
958:27 - to
958:28 - use state
958:30 - and this will be that
958:32 - approve in stake ear c20 state
958:34 - we'll start it off there and this will
958:36 - represent kind of the overall state
958:38 - right for this will be the true proven
958:40 - stake ear c20 state
958:42 - what we're going to do now is we're
958:43 - going to have to track those both of
958:45 - those states we're going to track both
958:47 - the proving and the staking so we're
958:49 - going to do use effect and we're going
958:51 - to track both of those
958:53 - with our little
958:54 - our little wonderful
958:56 - use effect stuff so we're going to track
958:57 - them with by doing of course
958:59 - proven stake erc20 state and then
959:03 - stake state so if either one of these
959:05 - change now we're going to want to change
959:08 - this overall state function and that is
959:10 - going to get pushed back to our our
959:12 - stake form here so what we're going to
959:14 - say is we're going to say if proven
959:15 - stake erc20 state dot status
959:18 - equals equals equals
959:21 - success
959:24 - then
959:25 - we're going to set state to be the stake
959:28 - state
959:28 - otherwise we're going to set this
959:31 - overall state we're going to do set
959:32 - state
959:33 - to be this approve and stake bit
959:36 - or just or really just kind of approve
959:38 - here now we're going to pass this just
959:40 - kind of overall state variable here
959:43 - to our front end like this
959:45 - excuse me to our stake form and in our
959:46 - stake form we're just going to say we're
959:48 - just going to map this state variable to
959:50 - the proven stake erc20 state we'll save
959:53 - here that should work perfectly great
959:54 - now if we go back to our front end we'll
959:56 - go to die or whatever we'll do one we'll
959:58 - hit stake
960:00 - metamask will pop up we'll confirm we do
960:02 - indeed get this little loading thing
960:04 - which is perfect once it's done once
960:06 - it's approved we'll confirm again and we
960:08 - get loading again and this is perfect
960:10 - this is exactly what we want because now
960:12 - the user has a good idea ah okay i need
960:15 - to wait right the transaction is going
960:17 - through the transaction is being built
960:19 - and once it's done
960:21 - it's all set so this is fantastic we now
960:24 - have basically all the functionality for
960:25 - staking right we have a proof we have it
960:28 - doing some waiting we have it actually
960:29 - staking
960:30 - let's clean this up a little bit right
960:33 - let's make this look a little bit nicer
960:34 - so first we're gonna go to index.css
960:37 - we're gonna we're gonna add some bits in
960:38 - here for a body we're just going to do
960:40 - background
960:41 - color we're going to set this to
960:44 - set a background color
960:46 - to
960:46 - [Music]
960:48 - hsl we'll do 227 comma 61 percent
960:54 - 26 there's a whole bunch of tools the
960:56 - background color doesn't really matter
960:58 - but we'll save we'll refresh our front
961:00 - end and we'll get a nice little uh
961:02 - background color here which is cool but
961:04 - let's actually be even more creative
961:06 - than just this let's do a nice little
961:08 - linear gradient in here we'll just get
961:10 - rid of this actually we'll do background
961:12 - do lin ear
961:14 - gradient
961:17 - we'll do 135
961:20 - right here do hsl 227
961:24 - 61 percent
961:26 - comma 13 percent
961:28 - then we'll do hsl 227 61
961:32 - 26
961:34 - we'll do one more we'll do hsl again
961:37 - this will be 227
961:39 - 61
961:41 - 39
961:42 - for some colors in here semicolon there
961:45 - let's look at our front and k we're
961:47 - getting somewhere we got some cool
961:49 - double gradients going on in here we'll
961:51 - go to our main section here and we'll do
961:53 - that use styles bits again so right in
961:55 - our looks like we don't have any
961:57 - material ui in here so we'll do a little
961:58 - import
961:59 - make styles
962:01 - from
962:02 - at material
962:04 - dash ui dash core
962:08 - and right at the top
962:09 - we'll do const use styles
962:12 - equals make
962:14 - styles
962:16 - some theme which we're ignoring
962:18 - nice little function thing here let's
962:21 - then for our titles in here we'll do a
962:23 - little
962:24 - make the color be theme dot
962:27 - palette dot common dot white which again
962:30 - we're ignoring theme but if we did
962:32 - everything we would do like that we'll
962:33 - do text align
962:35 - center do some padding
962:37 - [Music]
962:38 - theme.spacing4
962:40 - and then our main of course we'll just
962:42 - add this in here const
962:44 - classes equals use
962:46 - styles
962:48 - and then we'll just put like a little
962:51 - little section in here
962:53 - do an h2
962:55 - or class name it's going to be equal
962:58 - to classes.title
963:01 - and we'll just call this dap
963:03 - token
963:05 - app
963:06 - we'll go back to the front end we got
963:07 - like a nice little deck token dap token
963:10 - app nice white right at the top that
963:12 - looks good we'll go to our your wallet
963:15 - component we'll add some styles in here
963:18 - looks like we don't have any styles in
963:19 - here so we'll do the same thing we'll
963:21 - grab
963:22 - make styles in here
963:25 - do a little const
963:26 - use styles equals make styles
963:31 - a theme that we're going to ignore
963:34 - some fun little function syntax stuff
963:36 - here
963:38 - we'll say tab content
963:41 - give this some styling we'll say all the
963:43 - tab content stuff we'll have
963:45 - display of flex
963:47 - flex direct
963:50 - sean will be
963:52 - column
963:52 - [Music]
963:54 - align items in the center
963:58 - and then we'll do a gap for this which
964:00 - will be
964:02 - theme.spacing04
964:04 - give our boxes some stuff so we'll say
964:06 - box
964:08 - we'll say
964:10 - background color is going to be white
964:14 - we'll say border
964:16 - radius it's going to be 25 px
964:20 - to give it some roundness here
964:22 - then we'll also do a header
964:25 - which we'll just do color of white
964:29 - we're going to grab tab content
964:31 - scroll down
964:33 - this is going to be inside this little
964:35 - tab panel bit here
964:37 - this div
964:38 - it's gonna have class name
964:41 - equals
964:43 - classes dot
964:45 - tab content
964:48 - oops we gotta add classes in here right
964:52 - before the return
964:53 - so do const
964:55 - classes equals that use styles
965:00 - we'll say this box
965:02 - well it's not we're not going to do the
965:04 - overarching box this could actually just
965:05 - be this if we wanted to we'll just say
965:07 - it's this first box so this will be
965:09 - class name
965:11 - equals
965:13 - classes dot box
965:16 - and then our h1 is going to be class
965:18 - name
965:19 - equals
965:20 - classes.header
965:23 - let's save it and let's take a look
965:26 - whoa
965:27 - this is already starting to look a lot
965:28 - better now as you guys can kind of see
965:31 - the functionality is really the
965:32 - important part behind the application
965:34 - and doing a lot of this use style stuff
965:37 - is what's really going to make it look a
965:38 - lot prettier right so if you're like hey
965:40 - how do i do this pretty stuff now i know
965:42 - i didn't really explain what any of this
965:43 - pretty
965:44 - prettiness was doing
965:46 - there's a ton of tutorials on doing css
965:48 - that's basically what this is that you
965:49 - guys can learn a little bit more to make
965:51 - your stuff look pretty now it looks like
965:53 - for the most part we have everything
965:55 - that we need to stay i know we have the
965:57 - spinning wheel which is great but let's
965:59 - also add a little bit of an alert at the
966:00 - bottom to say hey your transaction has
966:03 - gone through successfully
966:05 - so what we're going to do
966:06 - is we're going to pop back over to our
966:08 - stake form we're going to wrap
966:10 - our input and our button into their own
966:13 - little div here right and that is going
966:15 - to
966:16 - put a little bit of space actually
966:17 - between
966:19 - our little component here and some other
966:20 - stuff which is kind of nice
966:22 - but what we're going to do is the reason
966:24 - that we're doing this is so that we can
966:25 - add some alerts this section down here
966:27 - is where we're going to add some
966:29 - alerting
966:30 - to do that we're going to use what's
966:32 - called a snack bar
966:34 - and alerts from material ui
966:36 - you can look at both of these
966:39 - in the documentation
966:40 - provides a brief message about app
966:42 - processes and something like this like
966:45 - we're just going to say hey you did it
966:48 - transactions has come through
966:50 - so what we're going to do is we're going
966:51 - to import snack bar from material ui
966:55 - so we're going to do comma
966:57 - snack bar we're also going to import
966:59 - alerting
967:00 - like a little alert box import
967:03 - alert from
967:05 - at material
967:07 - ui lab slash alert and what this is
967:10 - going to do is it's also going to make
967:12 - these alerts basically down below our
967:15 - button and our input we're going to do a
967:17 - little
967:18 - little snack bar in here
967:20 - snack bar and we're going to say this is
967:21 - going to open when we want to show that
967:24 - the erc20 is done which we're not
967:26 - exactly sure how to do that quite yet
967:28 - we'll have it auto hide
967:30 - auto hide
967:31 - duration it's gonna be equal to
967:34 - about five seconds or five thousand
967:36 - milliseconds and then on close
967:38 - we're also going to do some stuff
967:40 - inside this little snack bar
967:42 - yes i know we haven't filled this out
967:43 - yet
967:44 - actually let's just do this for now
967:49 - having blanks for now
967:51 - inside the snack bar
967:52 - we're going to have some alerts
967:56 - where we say on close
967:58 - we're also going to do some stuff
968:00 - severity is going to be
968:03 - success
968:05 - and this alert
968:06 - is what's going to have our text in here
968:08 - so we'll say erc
968:11 - 20
968:12 - token
968:13 - transfer approved
968:15 - now approve
968:17 - the second
968:18 - transaction
968:20 - and we're going to have two of these
968:21 - little snack bars one is gonna be for
968:22 - the erc20
968:24 - and one is going to be for staking token
968:26 - so we're going to call this one
968:29 - token staked
968:31 - or excuse me tokens staked
968:34 - now we need to define when these open
968:37 - and also
968:39 - when they close and what to do when they
968:40 - close
968:42 - so
968:42 - this erc20 thing should pop up when
968:45 - erc20 has been approved so we're going
968:47 - to want to create
968:49 - some variable that's going to track
968:51 - whether or not it's actually been
968:52 - approved so we'll create another state
968:54 - hook here
968:55 - we'll do const
968:57 - show
968:58 - erc20
969:00 - approval
969:01 - success comma set show
969:04 - erc20 approval success this is going to
969:08 - be equal to
969:09 - use state and we're going to start with
969:11 - false right we don't want to show this
969:13 - thing right away
969:14 - and then we're going to want to do the
969:15 - same thing for staking tokens so we'll
969:17 - do const
969:19 - show
969:20 - stake
969:22 - token success
969:24 - and then set
969:26 - stake token
969:28 - success
969:29 - and this will be also used
969:32 - and we will start this out with false
969:34 - and what we're going to do
969:36 - is right now we're doing this
969:37 - console.login here right and this is
969:39 - cute
969:40 - but we want to actually turn this into
969:42 - changing show erc20 approval success
969:45 - right so when this actually goes through
969:48 - when notification says hey it's been
969:50 - approved we want to say okay great show
969:52 - that approval status
969:54 - so instead of doing console.log here
969:56 - we're going to say set show
969:58 - your c
969:59 - 20 approval
970:02 - success to true
970:05 - and then we're also going to set show
970:07 - stake
970:08 - token success
970:10 - tokens success
970:13 - to false
970:15 - i hopefully i'm spelling this right
970:18 - set
970:20 - show
970:22 - stake token success and let's
970:24 - make sure that's spelled right
970:26 - great
970:27 - and then we're going to do the same
970:28 - thing but the opposite for staking token
970:30 - so get rid of console.log
970:33 - we'll do set show erc 20 approval
970:36 - success to false and set show stake
970:38 - erc20 to true
970:40 - now we'll say the erc21 is going to open
970:44 - and now we can also have this
970:46 - notifications thing
970:47 - track
970:49 - these two
970:50 - if these ever change
970:52 - we'll also run through this
970:55 - so we'll grab both of these in here so
970:57 - this use effect will now track these as
970:59 - well and we'll say show erc20 approval
971:01 - status will open up
971:04 - the erc20 alert
971:06 - and then the show state token success
971:09 - will open up
971:10 - the state tokens alert and then for both
971:13 - of these we'll add a new function called
971:15 - handle close snack
971:17 - which will just close it out
971:20 - and turn those
971:21 - variables that we just made to false so
971:24 - we'll do
971:25 - const
971:27 - handle close snack
971:31 - this will be a function
971:32 - and we'll just say
971:34 - set show erc20 approval status to false
971:38 - and then set
971:39 - show stake
971:41 - token
971:42 - i'm just going to copy paste it
971:45 - this one also to false awesome now if we
971:47 - go back we refresh our front ends here
971:50 - looks like i forgot to do an on close
971:52 - ah okay yep
971:54 - we'll do handle on closed snack here
971:57 - for the alerts as well
971:59 - and there are no
972:01 - tags there there are no brackets there
972:02 - so i've got to change that
972:04 - but now if we go to our front end we'll
972:06 - do a quick refresh we see everything in
972:08 - here looking great
972:10 - let's add one in here we'll hit stake
972:12 - this will pop up we'll confirm we'll get
972:15 - the little progress bar which is exactly
972:17 - what we want and you see here now we get
972:20 - this little pop-up it says erc20 token
972:22 - transfer approved now approve the second
972:24 - transaction this should
972:26 - uh go away after a few seconds or not
972:30 - let's just approve this second one oh
972:32 - looks like it now went away so maybe it
972:34 - was a little bit longer than five
972:35 - seconds
972:36 - and now we can see the token stake
972:38 - popped up perfect
972:39 - so we have some pop-ups we have a little
972:41 - bit of ways to show the user how to do
972:43 - everything
972:44 - now you'll notice this doesn't look
972:46 - exactly like what we see in the github
972:48 - repo right and this github repo looks a
972:50 - little bit different it's got this
972:51 - little slidey bar it's got this second
972:53 - token farm contract for unstaking
972:55 - however a lot of what we're going to
972:57 - keep doing is just going to be a lot of
972:59 - more front-end stuff and at this point
973:01 - you pretty much should have everything
973:03 - that you need to build the rest of the
973:04 - contract
973:05 - so what we're going to do
973:07 - is we're going to have the rest of this
973:09 - be a challenge if you want if you would
973:11 - like to complete it you can absolutely
973:12 - add this second tokenfarb contract with
973:15 - this unstake all weth bit or unstay golf
973:18 - fau dap etc
973:20 - we're going to have two versions
973:23 - of this front end in here we're going to
973:24 - have kind of this more cleaned up
973:26 - version and then we're going to have a
973:28 - little bit more raw version this one's
973:29 - the the more raw version all the code is
973:31 - going to be there so if you want to say
973:33 - i don't really want to code and follow
973:34 - this along you can just copy paste the
973:36 - code or you can say you know what i'm
973:38 - going to do
973:39 - this unstaking part all myself and that
973:42 - will be awesome also fantastic you
973:44 - should be incredibly proud of yourself
973:46 - because at the end of the day at this
973:48 - point you have a way to stake
973:51 - tokens into a smart contract and build a
973:53 - front end which is absolutely massive
973:56 - absolutely fantastic you should be
973:58 - patting yourself in the back excellent
974:00 - job excellent job let's go ahead and
974:02 - wrap this course up welcome back friends
974:04 - how do you feel good
974:06 - smarter empowered ready to take on the
974:08 - world
974:09 - excellent well you absolutely 100 should
974:12 - be and you deserve a massive round of
974:15 - applause because you have just done
974:16 - something fantastic you have started
974:19 - your journey and equipped yourself with
974:21 - the tools to become an incredibly
974:23 - powerful intelligent smart contract
974:26 - engineer in the space now i would be
974:28 - remiss if i didn't comment on security
974:31 - and audits when it comes to doing your
974:32 - smart contracts as you know all these
974:35 - smart contracts are available on chain
974:37 - for anybody to see and anybody to work
974:39 - with this means that having a security
974:41 - mindset is incredibly incredibly
974:43 - important and i highly recommend if
974:46 - you're going to go maintenance if you're
974:47 - going to take your application onto a
974:49 - real network where it's going to be
974:50 - securing a lot of people's money and a
974:52 - lot of people's assets you absolutely
974:55 - need to get an audit there is no excuse
974:59 - for not getting an audit and having an
975:01 - application that's securing a lot of
975:02 - people's money getting an audit is
975:04 - essentially just having somebody else
975:06 - peer review your code looking for any
975:08 - vulnerabilities that could be exploited
975:10 - an audit can be the difference between
975:12 - your protocol
975:13 - skyrocketing into the future and doing
975:15 - fantastically successfully
975:17 - or dwindling getting hacked and everyone
975:20 - losing faith in your abilities audits
975:22 - are essential we've got some helpful
975:25 - links in the github repository
975:26 - associated with this course to learn
975:28 - more about audits who to get them from
975:30 - and some helpful tips on setting your
975:32 - smart contracts up to make auditors
975:34 - lives easier while we're talking about
975:36 - security it's also helpful to know some
975:38 - of the most common attacks in this space
975:40 - we've got another wonderful link in the
975:42 - github repository that will show you
975:44 - some of these attacks and how to get
975:46 - around them and what they actually look
975:47 - like two of them that are big enough
975:49 - that i think i need to mention here are
975:51 - going to be oracle attacks and
975:53 - re-entrancy attacks these are the two
975:55 - attacks that i see happen most often
975:58 - unfortunately right now in the state of
976:00 - d5 protocols get hacked for millions of
976:03 - dollars literally almost every day and
976:06 - it is a travesty to the space that this
976:08 - is happening most of the time these
976:10 - attacks are preventable so understanding
976:13 - some of these security tips doing your
976:15 - due diligence and getting an audit is
976:16 - going to make both you as a smart
976:18 - contract developer and as adapt
976:20 - developer and as a protocol better but
976:22 - also the entire space is going to be
976:24 - more safe secure and easier for
976:27 - newcomers to get into thankfully you can
976:29 - sleep a lot easier on those oracle
976:30 - manipulation attacks because you've
976:32 - learned some best practices for working
976:34 - with oracle's you've learned how to work
976:36 - with a chain-link decentralized oracle
976:38 - network to get your data and do your
976:40 - external computation using a chain-link
976:43 - decentralized oracle network or a dawn
976:45 - will solve these oracle manipulation
976:48 - attacks so that you don't have to deal
976:50 - with people manipulating a centralized
976:52 - oracle because you are going to be using
976:54 - a decentralized one reentrancy attacks
976:57 - are a little bit trickier to detect but
976:59 - whenever you call an external smart
977:01 - contract a smart contract outside your
977:02 - project you especially should think hm
977:05 - does somebody in that smart contract
977:07 - have access to changing some variables
977:09 - that i don't want them to change again
977:12 - we have some wonderful examples in that
977:13 - github repository associated with this
977:15 - course to teach you more about that
977:17 - additionally i highly recommend
977:19 - everybody check out both ethernet and
977:21 - damn vulnerable defy these are two games
977:24 - that show you some of the exploits and
977:25 - some of the low-level solidity things
977:27 - you can do that you might want to look
977:29 - out for when you're writing your smart
977:30 - contracts all right so now that we've
977:32 - got the security piece out of the way
977:33 - once again huge congratulations for
977:35 - getting this far you now have the tools
977:37 - to build a better world to build these
977:39 - smart contract applications and to
977:41 - empower yourself and your community with
977:43 - these blockchain applications now the
977:46 - first question you might be asking is
977:47 - patrick this is great but
977:49 - where do i go now what do i do i have
977:52 - all these tools i want to go use them
977:54 - absolutely my first bit of advice here
977:56 - is going to say you can always learn
977:58 - more and there's always going to be more
978:00 - places to learn and grow and even though
978:02 - this course gave you a full setup of
978:04 - everything that you're going to need to
978:06 - get going and get off the races and
978:08 - start building it's good to know where
978:09 - else you can learn more and where else
978:11 - you can grow some amazing places are
978:13 - going to be crypto zombies dapp
978:14 - university ivan on tech chain shop eat
978:17 - the blocks patrick collins my youtube
978:19 - channel austin griffith's youtube
978:21 - channel nader's youtube channel the
978:22 - ethereum.org website
978:24 - chain link blogs and really any other
978:26 - material you can get your hands on while
978:27 - you're learning you should 100 be
978:29 - growing with the community this is
978:31 - something that i've been pushing from
978:32 - the start
978:34 - blockchain and smart contract world is
978:36 - different from these corporate worlds we
978:38 - are a decentralized open source group
978:40 - open source open source ecosystem where
978:43 - we flourish if the people around us
978:46 - flourish so growing and connecting with
978:48 - the community is a absolute must and is
978:50 - eight and it's a way to really
978:51 - accelerate all the momentum that you're
978:53 - getting after taking this course twitter
978:55 - the reddit brownie discord the ethereum
978:58 - discord the chain link discord there are
978:59 - all these discords in all these
979:01 - communities that you can jump in you can
979:02 - grow ask questions chat spread ideas
979:06 - then once you're in these communities
979:07 - then you can start really coding and
979:09 - tinkering more hackathons are some of
979:12 - the best places to put your stuff to the
979:14 - test and also really learn and build and
979:16 - grow in the blockchain space there are
979:18 - hackathons happening all the time and
979:20 - these are places where you can show up
979:22 - you can learn from some of the sponsors
979:23 - you can build really cool things and you
979:25 - can win prizes as well we've seen some
979:28 - projects win a hackathon go on to raise
979:30 - millions in seed funding and become a
979:32 - billion dollar protocol some have gotten
979:34 - advisors from top investors like mark
979:36 - cuban and these products do wildly
979:38 - successful but at the same time we also
979:41 - see a huge uptick in a huge number of
979:43 - the newcomers in this space people have
979:45 - never written a smart contract never
979:47 - written any of the code come in try
979:50 - learn grow and come out an incredibly
979:51 - powerful engineer with more networking
979:54 - and with more people around them who
979:55 - they know they can lean on and talk to
979:57 - in this community so whether or not you
979:59 - want to win a hackbond doesn't really
980:01 - matter hackathons are a great place to
980:03 - sharpen your coding skills get better
980:05 - meet some people maybe win some prizes
980:07 - and a lot of these decentralized
980:08 - products do look at the hackathon
980:10 - winners looking for some talent to pick
980:12 - up for their teams a lot of the
980:13 - engineers that i work with right now i
980:15 - work with them because they got picked
980:17 - up from a hackathon so hackathons are
980:19 - great places to go eat global eath india
980:22 - eath global eth india and the chain like
980:23 - hackathon are some of the best
980:25 - hackathons in the business so be sure to
980:27 - check those out all these decentralized
980:29 - protocols have a ton of work that people
980:31 - can be doing to help grow their protocol
980:33 - in some way and they all have community
980:35 - grant projects where people can come in
980:37 - propose some grant propose something to
980:39 - the community and that person builds it
980:41 - out so if you have an idea on how to
980:43 - improve one of these decentralized
980:44 - applications you can go ahead propose
980:46 - what you want to improve and if you get
980:49 - approved you could be awarded a grant to
980:51 - work on that as well you can become a
980:52 - smart contract consultant here you can
980:54 - start offering your services to people
980:56 - who are looking for really strong
980:58 - solidity and smart contract developers
981:00 - you can start reaching out to some of
981:01 - these projects now that you have these
981:03 - skills you can start reaching out to
981:05 - other people saying hey i've got a great
981:07 - idea of something i want to build and
981:08 - i'm looking to take it to the next level
981:10 - and that's the most important piece of
981:12 - advice i have for you here
981:14 - just
981:15 - build just have a good time and build
981:18 - things that you enjoy building you'll
981:20 - learn the most the fastest by building
981:22 - tinkering and trying new things and this
981:25 - is also one of the best ways to meet
981:27 - people in the industry everybody that i
981:29 - work with in my life in this space i
981:32 - work with them because i was building
981:34 - something and we became close because we
981:36 - were working on the same things i feel
981:38 - incredibly lucky to have met and
981:39 - interact with so many fantastic people
981:41 - in this space and i hope that one day
981:43 - i'll get to meet and interact with you
981:45 - too so good luck to you all and let's
981:47 - rebuild this world let's make a world
981:49 - where there's more economic opportunity
981:51 - there's more equality and let's rebuild
981:53 - some of this institutional trust while
981:56 - having an absolute blast in this wild
981:58 - west that is cryptocurrency smart
982:00 - contracts and blockchain like i said i
982:02 - hope to meet you all one day and just do
982:04 - me a favor and make today an amazing day
982:07 - take care everybody