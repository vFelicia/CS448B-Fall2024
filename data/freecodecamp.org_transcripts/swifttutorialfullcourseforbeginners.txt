00:00 - hello welcome to learn swift programming
00:02 - for beginners lesson one today we're
00:05 - going to talk about variables you're
00:06 - going to learn about what they are how
00:08 - to declare them in swift code and
00:10 - furthermore how to use them
00:12 - alright so let's get started
00:16 - for the rest of the lessons in this
00:17 - series we're going to be working inside
00:19 - this app called xcode xcode is the tool
00:23 - that apple has provided for people to
00:24 - build apps with
00:26 - and inside xcode you're going to be able
00:27 - to create your user interfaces you're
00:29 - going to be able to write the code to
00:31 - express the logic in your app you're
00:33 - going to be able to test your app even
00:35 - so that's why this is where we're going
00:37 - to start in learning swift we're going
00:39 - to be writing the swift code inside the
00:41 - app that you're actually going to use to
00:43 - build apps with in the future
00:45 - so this is where you're going to get
00:46 - xcode just go to your browser
00:48 - go to
00:49 - developer.apple.com
00:51 - xcode or you can launch the mac app
00:53 - store on your computer and search for
00:56 - xcode there if you're on the web page
00:58 - you can see that there's this big blue
01:00 - download button up top
01:02 - now ideally you want to make sure you're
01:04 - using the latest version of xcode and
01:06 - right now as of this recording it's 8
01:09 - and you can check your version if you go
01:10 - to xcode you can see it here in the
01:13 - welcome screen and you can also go up
01:14 - here to xcode about xcode and you can
01:17 - see what the version is if you're a pc
01:19 - user and you're running windows there
01:21 - may be some additional work you need to
01:23 - do before you can run xcode or you might
01:25 - have to use an alternative solution to
01:27 - build ios apps so check in the
01:30 - description below for pc solutions
01:33 - however if you are a pc user don't let
01:35 - that discourage you
01:37 - for me personally i lost about two to
01:39 - three years of learning ios development
01:42 - simply because i didn't have a mac and i
01:43 - didn't want to get a mac but these days
01:45 - there are alternative solutions you
01:47 - don't actually have to buy a mac
01:49 - computer although i eventually did and
01:52 - now i haven't looked back so anyways now
01:55 - that you have xcode and after you've
01:57 - installed it it's a pretty large install
02:00 - it's pretty big program so i might take
02:02 - some time but after you have it
02:04 - installed and you launch it you're going
02:05 - to see this welcome screen you can see
02:07 - here that when you want to create an app
02:10 - for iphone ipad mac or whatever you're
02:12 - going to go to create a new xcode
02:14 - project and that's going to start a full
02:17 - out
02:18 - project for you to build an app in but
02:20 - here we're going to start a new
02:21 - playground because that's going to allow
02:23 - us to type some code quickly it's going
02:25 - to let us run that code and see the
02:28 - results and we're not committing to
02:30 - building in a project it's simply like a
02:32 - sandbox or a playground as it's named
02:34 - now if you don't see this welcome screen
02:37 - what you can do is just go up to file
02:39 - new and hit playground right there and
02:41 - that's going to start a new playground
02:42 - for you as well
02:44 - or you can just hit this button get
02:45 - started with the playground
02:47 - so that's going to launch this dialogue
02:49 - for you and i'm simply going to leave
02:52 - the default name there platform should
02:54 - be ios
02:55 - and i'm going to save this on my desktop
03:00 - okay so after your playground runs
03:01 - you'll see up here it's doing a whole
03:03 - bunch of stuff
03:05 - launching simulator getting it ready and
03:07 - when it's done all that it's going to
03:08 - say ready you can already start typing
03:11 - in code so there you go it says ready
03:14 - but
03:15 - when it doesn't say ready and it's doing
03:16 - something then chances are whatever
03:18 - you're typing here is not going to show
03:21 - up on the right hand side okay we're
03:22 - going to start with a quick tour of this
03:24 - playground window here
03:26 - so down on the left hand side i have a
03:29 - bunch of line numbers now if you don't
03:31 - have these and you want them they can be
03:33 - useful at times especially when i'm
03:35 - teaching and i need to refer to line
03:37 - numbers you can go to xcode preferences
03:40 - and you can go to text editing and you
03:42 - can simply enable line numbers there now
03:44 - this area right here is where we're
03:47 - going to type our swift code and it's
03:49 - already got a bunch of stuff for us
03:51 - right here which we're going to go
03:52 - through in a second on the right hand
03:54 - side you're going to see a quick preview
03:56 - of the results of what you typed there
03:58 - now a lot of people have trouble with
04:01 - getting output to show up on this right
04:03 - hand side based on what they type here
04:06 - well one of the things that you can
04:08 - check is just in this status bar up here
04:10 - make sure that it says ready
04:12 - and as you're typing something let's say
04:14 - i change something like that you're
04:16 - going to see that it
04:18 - for a brief second there there was a
04:20 - little spinner because it's evaluating
04:22 - your code here
04:24 - um if you want it to show up just make
04:25 - sure it says ready to process your next
04:27 - command
04:28 - and
04:29 - you know you should see that output
04:31 - there
04:31 - alternatively there is a tray down here
04:34 - which you may not notice because it's
04:36 - hidden at first you can hit this button
04:38 - to show the debug area or there's also
04:42 - this little button here to hide the
04:44 - different panels
04:46 - okay but we don't need to see all of
04:48 - that but this debug panel
04:51 - may be useful uh when we start to
04:54 - output things here this is called the
04:56 - console area where we can use swift
04:59 - commands to output things
05:01 - this blue icon here
05:03 - is to execute the code in your
05:04 - playground so if you can't get things to
05:06 - show up on the right here try
05:08 - clicking this button to run your
05:10 - playground
05:12 - right now it's blue because you can see
05:15 - there's a little drop down arrow there
05:17 - if you click and hold it you can see
05:19 - whether you want to switch it to
05:20 - automatically run
05:22 - and that's going to run the playground
05:23 - whenever you type something
05:25 - or you can set it to manually run and
05:27 - you can see now it's grayed out so if i
05:29 - type in some new code it's not actually
05:31 - going to
05:32 - change or display what i have on the
05:35 - right hand side here unless i click the
05:36 - play button to run it
05:38 - so i would recommend to have it set to
05:40 - automatically run so now that you know
05:42 - the main areas of the playground let's
05:45 - get into the meat of today's topic
05:46 - variables and in fact what we have here
05:50 - is a variable in swift a variable holds
05:53 - some data now this data could be a value
05:56 - it could be a reference to an object or
05:58 - it can even point to a function which
06:00 - are things that will get into the future
06:02 - but for now we're going to say that
06:03 - variables hold data now as you can see
06:06 - from this example line of code a
06:09 - variable has a couple of distinct parts
06:12 - let's break it down variables need to be
06:14 - declared before they can be used so this
06:17 - var keyword is used to declare a new
06:20 - variable
06:21 - following the var keyword you have the
06:23 - variable name in this case it's str
06:27 - and really that's it you've declared
06:28 - your new variable so it's got the var
06:31 - keyword and it's got the variable name
06:34 - now taking a look at the whole line what
06:36 - we have on the right hand side there
06:38 - that's some data we did say that
06:40 - variables hold data right and that equal
06:43 - sign in between the variable name and
06:45 - the piece of data well that's an
06:47 - assignment operator so what we're doing
06:49 - in this line of code is we're declaring
06:52 - a variable called str and then we're
06:54 - assigning that piece of data to that
06:57 - variable
06:58 - so now jumping back into the playground
07:01 - let's see the effect of that i can say
07:03 - something like print which is a keyword
07:06 - that is going to print something to that
07:08 - console area down below so if i say
07:11 - print and then in the parentheses i put
07:13 - str you can see that it's printed that
07:16 - hello player s rough
07:19 - line down there
07:21 - on the right hand side
07:22 - we can see a quick preview of that and
07:25 - notice that there's a slash n here and
07:28 - that is basically um just denoting that
07:31 - there's a new line associated with that
07:33 - print statement because
07:35 - uh the next time i print something it's
07:37 - going to be printed on the next line so
07:39 - you don't see that here because a new
07:41 - line is just
07:43 - a carriage return or a white space you
07:45 - can't really see it but in here in this
07:47 - preview it's visualized as that slash n
07:51 - which is just a new line
07:53 - so let's take a look at a couple of
07:56 - different pieces of data that we can
07:58 - store into variables so i'm going to
08:00 - declare
08:01 - another variable here called a
08:04 - and i'm going to assign
08:08 - a number into it so just var one
08:11 - and i'm going to declare another one
08:14 - called b
08:16 - which i'm going to also assign one
08:18 - and i want to show you that you can
08:19 - perform operations between the variables
08:22 - or on the variables
08:24 - so for example i can say print
08:27 - a
08:27 - plus b
08:29 - and you can see here that the result in
08:32 - the console here is 2.
08:33 - now notice that when i'm using the
08:36 - variables in
08:37 - an equation or an operation like this i
08:40 - don't need to use the keyword var
08:42 - because that's only for declaring
08:44 - variables right so this little part is
08:47 - declaring the variable
08:48 - but when you use them afterwards you
08:50 - just need to refer to them by name
08:53 - so let's try some other things print a
08:56 - minus b
08:59 - and print
09:00 - a
09:02 - times b
09:08 - okay so variables hold data and you can
09:11 - perform operations on variables
09:14 - now you can change the data that the
09:16 - variable is holding so i can say
09:18 - something like a equals 2 now
09:20 - right in fact actually let's not do it
09:22 - down here let's do it here after we've
09:25 - assigned one into a let's say a equals
09:28 - two
09:29 - and as a result you can see all of these
09:32 - operations have changed because a is now
09:34 - two so a plus b
09:36 - is three
09:38 - a minus b
09:39 - is one and so on because a is now two
09:43 - now when you assign something into a a
09:45 - different piece of data it replaces what
09:47 - it was holding on to before so a is no
09:49 - longer one
09:51 - it is now two but notice how when we
09:54 - assign a new piece of data into a we
09:56 - don't have to write var again
09:58 - that would cause an error because we've
10:00 - already
10:01 - declared that variable up here and
10:03 - memory in the system has been allocated
10:05 - to it and so we don't need to redeclare
10:07 - it all we need to do is assign new data
10:10 - into a like that now if you're playing
10:13 - around in the playground yourself you
10:15 - may notice something like what if you
10:17 - try to assign
10:18 - something into str
10:20 - like
10:22 - one
10:24 - well you're going to get an error and
10:26 - that's because of something called data
10:27 - types which we're going to learn about
10:30 - in the next lesson but for now
10:32 - just know that for str because we've
10:36 - assigned some text into it up there
10:38 - if we want to reassign some data into it
10:41 - again it has to be text as well
10:45 - so that would be valid
10:48 - furthermore
10:50 - you can also assign
10:52 - a variable as another variable so i can
10:54 - say
10:55 - a equals b down here
10:58 - and in that case a would now equal one
11:01 - again
11:02 - well
11:03 - it was one to begin with so let's say i
11:05 - did that so if a was two
11:07 - and then i said a equals b then now they
11:10 - would both be one
11:13 - now before we move on a quick note on
11:15 - naming variables here we have a variable
11:18 - str and i've named some variables a and
11:20 - b
11:21 - so normally you wouldn't name variables
11:23 - like a and b because they're not
11:25 - descriptive of the data that they hold
11:28 - so if you're going to be using variables
11:30 - just like this in an operation wouldn't
11:32 - it be easier if you knew what a
11:34 - represented and what b represented well
11:36 - you can declare your variables using any
11:39 - sorts of names that you'd want but you
11:41 - can't put some special characters and
11:42 - you can't put spaces in your variable
11:44 - name however the common practice is to
11:47 - use a form of camel case where the first
11:50 - letter is lowercase so let me show you
11:52 - what i mean so i can say var and if i
11:55 - want to describe my variable if it
11:57 - represents
11:58 - let's say the number of apples that i
12:00 - have i would say something like
12:04 - my
12:04 - number of apples
12:07 - like that and you can see that each new
12:09 - letter
12:10 - of each word is capitalized except the
12:13 - first one
12:16 - now you don't want to get too crazy with
12:17 - the length of the variable name as well
12:20 - and you don't want to go too short so
12:22 - short that it doesn't actually mean
12:24 - anything so there's no right or wrong
12:26 - answer or hard limits it's based on you
12:29 - know your own preference and it's more
12:31 - important if you're working in a team
12:33 - with other people that you agree on a
12:35 - certain coding style because you're both
12:38 - going to be working on the same code
12:40 - okay so one more thing i want to talk
12:41 - about are constants so they are like
12:44 - variables except that once you assign
12:46 - something to them you can't reassign
12:49 - data into them so that's really the only
12:51 - difference that and also how they're
12:54 - declared so with variables you use the
12:56 - keyword var but with constants you use
12:59 - the keyword let so i can say let c
13:02 - equals 10
13:04 - and then down here if i try to reassign
13:07 - something into c like that
13:09 - xcode is not going to like that and it's
13:11 - going to throw an error and it's going
13:12 - to tell you with this red dot down here
13:14 - and if you click it it's going to say
13:16 - cannot assign value to c because it's a
13:19 - let constant now it gives you this
13:21 - little bubble here which you can click
13:23 - and
13:25 - smartly it's going to change let to var
13:27 - because it senses that you want to
13:28 - reassign data into it so you might ask
13:31 - why would i ever want to use a constant
13:33 - if it's more limited in its
13:35 - functionality right if i declare
13:37 - everything as variables then i have all
13:39 - the flexibility i'd want
13:41 - well there are a couple of reasons why
13:43 - you'd want to use constants when it
13:45 - makes sense for one thing it helps the
13:47 - computer work a little more efficiently
13:49 - because it knows exactly what that
13:50 - constant will be and that's not going to
13:53 - change but more importantly it's that
13:55 - for you as a coder you know that that
13:59 - constant isn't going to change because
14:01 - when you're building your app you're
14:02 - going to have a lot of variables
14:04 - and when you have some sort of
14:06 - issue in your app and you don't know why
14:08 - it's happening and you're tracking down
14:10 - your code you're tracing it line by line
14:12 - and you're trying to see if maybe at
14:14 - some point you've accidentally assigned
14:16 - something to a variable and that's
14:18 - throwing off all your calculations or
14:19 - all of your logic it's going to be a
14:21 - nightmare to try to solve and untangle
14:24 - so if something you know it isn't going
14:26 - to change you can assign it to a
14:28 - constant and then when you're looking
14:30 - through your code you can be sure that
14:32 - the issue doesn't lie with that constant
14:34 - because you know it can't change okay so
14:36 - that's it for this lesson on variables i
14:38 - hope you're practicing on your own
14:40 - computer with xcode and check below this
14:42 - video for a link to the cheat sheet and
14:44 - the notes
14:46 - hello welcome to learn swift for
14:48 - beginners lesson two in this lesson
14:50 - we're going to talk about data types
14:53 - did you know in the previous lesson that
14:54 - you're already working with different
14:56 - data types well let me point it out to
14:58 - you
15:03 - let me open up the playground that we
15:04 - were working with in the previous lesson
15:08 - do you remember how we were trying to
15:09 - reassign data into the variable str
15:12 - and i was assigning something like
15:15 - a number into str and i told you that
15:17 - you couldn't do that in fact xcode tells
15:20 - you that you can't do that right here
15:22 - so if we take this little console area
15:25 - and we scroll the scroll bar all the way
15:27 - up to the top the error message actually
15:30 - tells you what's going on cannot assign
15:31 - value of type int to type string
15:34 - well what's an int and what's a string
15:37 - well those are two examples of data
15:38 - types just as the name implies
15:41 - a data type is a classification or
15:44 - a type of data
15:46 - for example a string is a data type that
15:49 - describes pieces of text
15:51 - an int short for integer is a data type
15:55 - for whole numbers negative or positive
15:57 - however there are many more data types
15:59 - than just these two
16:00 - other types of data that you'll commonly
16:02 - be working with are float for floating
16:05 - point numbers or decimal numbers and
16:08 - then there's double
16:09 - for decimal numbers where the decimal
16:11 - portion may be very large
16:13 - and then there's boolean which
16:15 - represents true or false or in other
16:17 - words yes or no
16:19 - these are some of the more common data
16:21 - types that you'll be using
16:23 - and the reason why there are different
16:25 - types of data is because the system
16:28 - stores different types of data
16:29 - differently and so when we go back to
16:32 - the playground and we take a look at
16:33 - this variable that we declared here str
16:36 - and it stores a
16:38 - string
16:40 - the system has allocated this variable
16:42 - to store this piece of
16:44 - text or string in other words and when
16:47 - you try to assign an int into that same
16:50 - variable
16:51 - it doesn't allow you to do that because
16:53 - strings and ins are stored differently
16:57 - now you might be wondering what
16:59 - differentiates a variable that stores a
17:01 - string like this str variable versus a
17:05 - variable that stores a number or an int
17:08 - like this variable a
17:10 - well when you declare a variable
17:13 - you learned in the previous lesson that
17:15 - you use the keyword var and then the
17:17 - name of the variable
17:19 - well optionally you can also put beside
17:22 - the variable name colon followed by the
17:25 - data type
17:26 - and if you declare your variable this
17:28 - way you're basically telling the system
17:30 - that this variable
17:33 - can only store this type of data
17:36 - and if you omit that part and you just
17:39 - simply declare your variable with var
17:41 - and then the variable name
17:43 - then what it's going to do is as soon as
17:46 - you assign a piece of data into that
17:48 - variable it's going to take a look at
17:50 - what type of data that is and assumes
17:53 - that that variable stores that data type
17:57 - so now going back into the playground
17:58 - here it's as if we declared this st our
18:03 - variable like this
18:06 - right and these ones
18:08 - are like this
18:13 - now for instance if i declared this str
18:17 - variable like this
18:19 - then this line would be an error because
18:22 - i'm trying to assign
18:24 - a string
18:25 - into a variable that is of type end
18:28 - so it's not going to like that
18:32 - now let's change this back to a string
18:34 - for a second
18:35 - and go back to this line where there's
18:37 - an error now you understand why
18:40 - this line is in red
18:42 - because we can't assign an in into a
18:44 - string variable well there are ways to
18:47 - convert data from type to type
18:52 - in some cases it makes sense like 29
18:55 - here this in can be represented as a
18:57 - piece of text simply like that
19:00 - right but conversely
19:02 - this hello playground line
19:05 - right here i can't convert that to an
19:08 - integer because it doesn't make sense
19:10 - that this message could be represented
19:13 - by a number
19:14 - so for example just as a little preview
19:17 - here if i wanted to convert this number
19:20 - or this integer into a string
19:23 - would create a new string and pass in
19:26 - the number like that now i'm not going
19:28 - to go into detail about why this works
19:30 - or what this line is
19:32 - because then you're going to have to
19:33 - learn about classes and initializers and
19:35 - stuff like that but for now in this
19:38 - lesson i want you to understand that
19:40 - there are different data types why there
19:42 - are different data types and how that
19:44 - comes into effect when you're declaring
19:46 - your variables and working with your
19:48 - variables and your data
19:50 - now before we end this lesson off let me
19:52 - just show you a couple of examples of
19:54 - the other data types we talked about
19:59 - so float could be something like that
20:01 - a double usually also looks like this
20:04 - and you're not going to have a really
20:06 - large decimal point unless it's like a
20:08 - result of a calculation that you're
20:10 - doing
20:12 - and let me show you
20:14 - a boolean which is represented as bool
20:16 - so you can set this to the keyword true
20:19 - or false which is going to come in handy
20:22 - for the next lesson that we're going to
20:24 - do on if statements
20:25 - oh and there is a mistake here because
20:28 - i'm redeclaring c did you see that
20:31 - in the previous lesson we talked about
20:33 - how you can't redeclare a variable see
20:35 - we declared var c up here but i forgot
20:38 - that we had tried to declare a constant
20:41 - with the same name down here
20:44 - so this is going to have to be f
20:47 - i'll show you some other types of
20:50 - data conversions here
20:52 - so i can say let's print out
20:55 - let's change
20:56 - c
20:58 - which is a float into an int
21:00 - and what's going to happen is that it
21:02 - just drops the decimal portion of that
21:05 - so if you did print
21:08 - let's convert d
21:10 - which is a double into an integer you
21:12 - can see here that it just chops off the
21:15 - 0.9 and you get 13. now there is a
21:17 - rounding function which we can try out
21:19 - right now
21:22 - like that and then inside the
21:23 - parentheses you can put d
21:26 - which is our double 13.9
21:29 - and what you're going to get as soon as
21:31 - it finishes processing is 14 like that
21:34 - but notice that the result is also a
21:37 - decimal number see it has a point zero
21:39 - there
21:40 - so what you can do is wrap the result of
21:42 - that rounding inside
21:45 - a pair of brackets like this
21:48 - inside an int
21:50 - and then you'll get 14 without the
21:52 - decimal
21:53 - okay so that does it for data types
21:56 - hello welcome to learn swift for
21:58 - beginners lesson three in this lesson
22:01 - you're going to learn how to express
22:02 - some simple decision making in your
22:04 - swift code using if statements
22:08 - all right let's get started
22:12 - so for this one we're going to start a
22:14 - brand new playground
22:18 - all right so we've done this before
22:20 - let's just call this one the
22:23 - if playground and i'm going to store
22:26 - this on my desktop
22:29 - okay so we're talking about if
22:31 - statements today
22:33 - and this is really exciting because it
22:35 - lets us finally start to make decisions
22:38 - through code and express some sort of
22:40 - logic so for example
22:42 - if i have
22:44 - let's declare a
22:46 - constant here
22:48 - so let
22:49 - a equals 10 for example
22:53 - and i wanted to print this statement
22:58 - only if a
23:00 - is
23:02 - less than
23:04 - let's say 11 which
23:06 - it is right here
23:07 - but
23:08 - um okay
23:10 - actually that is
23:12 - that is not right let's say four
23:17 - and this gives us a reason to use the if
23:19 - statement right
23:20 - okay so print only if a is less than 4
23:24 - but a is 10 right so we shouldn't be
23:27 - outputting this so what we can use here
23:30 - is an if statement and what it allows us
23:32 - to do is only execute some code
23:35 - if a certain condition is true
23:39 - so in this case we want to print this
23:42 - only if a is less than 4
23:45 - so we can write an if statement to
23:48 - check if that's true or not before we
23:50 - print that statement
23:51 - so let me show you what that syntax
23:54 - looks like and if you're not familiar
23:56 - with programming terms syntax is simply
23:59 - like the grammatical structure of the
24:02 - language so it's basically the key words
24:05 - to use and
24:06 - how we go about declaring an if
24:09 - statement or writing an if statement so
24:12 - it all starts with the if keyword
24:15 - following the if keyword we have the
24:17 - condition in which we want to check and
24:19 - following the condition we have a set of
24:22 - curly brackets
24:24 - now inside the curly brackets that's
24:26 - where we put the code that we want to
24:28 - run
24:29 - if that condition is true
24:31 - so that's your very basic if statement
24:34 - now going back to our playground let's
24:36 - write it out and print this only if a is
24:39 - less than four
24:40 - so we can do something like that if
24:43 - a
24:44 - and then we can use this operator less
24:46 - than
24:47 - 4
24:48 - and remember we need to surround the
24:50 - piece of code that we want to execute if
24:52 - the condition is true
24:54 - using a pair of curly brackets like that
24:59 - so you can put the curly bracket on the
25:00 - same line or you can put it on a second
25:02 - line it doesn't matter
25:06 - but what you usually want to do is
25:08 - indent the code
25:10 - that is inside it just so it's easier to
25:13 - read i usually like to put this curly
25:15 - bracket in
25:16 - the same line like that
25:19 - okay so now you can see that in the
25:21 - console there's nothing printed and also
25:23 - to the right here it doesn't give you a
25:25 - preview because this condition is false
25:29 - a is not less than 4 because a is 10.
25:32 - now what if we changed a to 1
25:36 - and let the playground process okay now
25:39 - it prints this statement and it previews
25:41 - the statement see it's printed down here
25:43 - so that's your very basic
25:46 - if statement
25:48 - now there are other cool things that you
25:50 - can do with an if statement there is an
25:53 - else if clause
25:55 - so for example using the else if clause
25:58 - you can check a second condition if the
26:01 - first condition evaluates to false and
26:04 - the syntax for that looks like that so
26:06 - you have your if condition and then you
26:08 - have your curly brackets and then you
26:10 - use the keywords else if
26:12 - and then you check another condition and
26:14 - you have another set of curly brackets
26:18 - so if you write it this way
26:20 - you're basically checking condition
26:23 - number one
26:24 - you know is that true if it's false now
26:27 - you're checking condition two
26:29 - and if that actually evaluates to true
26:31 - then you're running the code inside that
26:34 - else if block
26:36 - now keep in mind that it kind of goes
26:39 - from top down and if the first condition
26:42 - is actually true then it's going to run
26:45 - that piece of code inside the first set
26:47 - of curly brackets and it's just going to
26:49 - ignore your else if statement
26:53 - so let's take a look at that inside the
26:55 - playground so here
26:57 - i'm going to put else if
26:59 - a is
27:01 - less than
27:03 - let's say
27:04 - 8.
27:06 - then now i'm going to print
27:09 - only if a is less than 8.
27:13 - so now i'm going to change
27:16 - oops not this i'm going to change a
27:19 - back to 10 here
27:20 - and you can see nothing gets printed
27:22 - because
27:23 - first it checks this condition if it's
27:26 - false which it is
27:28 - then it's going to check this condition
27:30 - and it's also false so
27:32 - nothing gets printed
27:34 - now what if i changed a
27:37 - to 7
27:39 - if i change the a to 7 you can see that
27:42 - it prints the second statement because
27:45 - first it checks this condition
27:47 - that's false so now it checks this
27:50 - condition and that actually turned out
27:51 - to be true
27:53 - so it's going to run this line of code
27:55 - here
27:56 - however if a is 1
27:59 - then it checks this first one and then
28:02 - it prints this one and then it totally
28:04 - ignores
28:05 - all of the other else if conditions
28:09 - now i said all of the other else if
28:12 - conditions right
28:13 - i say that because you can have as many
28:15 - else if conditions as you want so you
28:18 - can say if als is less than
28:20 - 10 and then you can you can continue
28:22 - adding as many conditions as you want
28:24 - but keep in mind that it checks from top
28:26 - to bottom
28:27 - and as soon as it finds a condition that
28:29 - is true it's going to run that piece of
28:31 - code and ignore all of the other
28:33 - conditions
28:35 - now finally there is a clause that you
28:38 - can run
28:39 - if all of the conditions are true kind
28:42 - of like as a fail-safe or as a last
28:44 - resort
28:45 - and that is the else keyword so the way
28:48 - you write this is using the else keyword
28:52 - it's not else if it's just simply else
28:55 - and there's no condition attached
28:56 - because if all of the conditions above
28:58 - it are false then it's going to run the
29:01 - code inside of this else statement here
29:04 - so going back to the playground let me
29:06 - show you what that looks like
29:08 - else
29:11 - print
29:13 - nothing was true
29:15 - and now let me change a back to 10
29:18 - here
29:20 - so you can see that it prints nothing
29:22 - was true because it's checking the
29:24 - statement it's false this statement is
29:27 - false
29:28 - and sorry i mean conditions
29:30 - and this condition is also false because
29:33 - a is not less than 10 a is actually 10.
29:37 - so this would actually evaluate to false
29:40 - and finally it just
29:42 - gets to this else clause and it's going
29:45 - to print what's in here
29:48 - okay so let me show you a couple of
29:50 - other things that you can do with else
29:52 - statements and let's
29:54 - change these print statements to
29:56 - something that is a lot more
29:58 - recognizable or easy to read
30:00 - let's do that branch one
30:03 - branch two
30:04 - and here
30:08 - oops
30:10 - branch three
30:12 - okay
30:14 - so
30:16 - um first of all let me show you how to
30:20 - do less than or equal to
30:23 - now you see it prints branch three so
30:25 - that's how you do less than or equal to
30:28 - and likewise you can do greater than or
30:30 - equal to
30:31 - and you can see here it still prints
30:33 - branch three now what if you wanted to
30:36 - check if it was exactly 10
30:39 - you wouldn't do that because remember
30:41 - this equal sign is an assignment
30:43 - operator so what you need to do to
30:46 - compare
30:47 - if
30:48 - a is equal to 10
30:50 - you use the double equal sign like that
30:53 - you can see here it prints branch three
30:56 - okay so why don't we introduce another
31:00 - constant up here let's say b
31:02 - and let's have that equal to 4.
31:05 - i want to show you that your conditions
31:08 - for your if statements and your
31:09 - different branches can get pretty
31:11 - complicated
31:13 - and you can involve multiple pieces of
31:16 - data
31:17 - in your condition
31:18 - so you can go if a is less than 4
31:21 - if you want to check
31:23 - b as well and you want to say
31:26 - you know end
31:27 - b is less than 4
31:30 - that's how you would do it you would use
31:31 - this double ampersand sign and now
31:34 - you're checking two conditions
31:36 - you're checking is a less than four and
31:39 - b less than four and only if both of
31:41 - those are true
31:43 - are you going to get this branch here so
31:45 - let's try that out so if i set b to 1
31:48 - and a to 1
31:49 - then both of these conditions here are
31:52 - true
31:54 - so it's going to print branch 1.
31:56 - however if i set b to 10 right
32:01 - it's going to just
32:02 - see it hits this branch 2 now because a
32:06 - is 1
32:08 - which is less than 8 and it didn't print
32:10 - branch 1 because
32:12 - this was false right even though a is
32:15 - one and this part is true
32:17 - we have to have this part to be true as
32:20 - well because where you're saying is a
32:22 - less than four and b less than four and
32:25 - b is ten right now however
32:27 - you can also do or so you can say
32:31 - is a less than 4
32:34 - or b less than 4
32:36 - and in this case either condition can be
32:40 - true and that would cause it to go into
32:43 - this branch so you can see now it is in
32:45 - branch one
32:47 - all right so uh let's say a is ten and b
32:50 - is one
32:51 - so
32:52 - a
32:53 - is not less than four
32:55 - but b is
32:57 - right because you're using this or
32:58 - statement you're saying is a less than
33:00 - four
33:01 - or b less than four and if that's true
33:05 - then we're coming into here
33:08 - now furthermore if you wanted to involve
33:11 - let's do a c
33:14 - you can combine you know multiple
33:17 - conditions like this you can put this
33:18 - into
33:21 - a pair of parentheses like this and you
33:23 - can say you know end
33:25 - c is equal to three
33:28 - so you can see now that you're saying
33:30 - okay
33:31 - is
33:32 - a less than four or b is less than four
33:35 - and also is c equal to 3 then come into
33:39 - branch 1.
33:41 - now these brackets matter a lot because
33:44 - what you're doing is you're saying that
33:47 - this has to be true
33:49 - and
33:50 - this has to be true but for example if i
33:53 - just shift the brackets a little bit
33:56 - and i say something like
34:00 - this
34:04 - then that changes the meaning completely
34:06 - because now i'm saying
34:08 - is a less than 4 or
34:11 - is this part true right so where your
34:14 - brackets are matter a lot and it changes
34:17 - the meaning of what you're checking did
34:20 - you get that in this case i am checking
34:23 - is this true or
34:25 - is this true
34:27 - but the other way around
34:33 - i'm checking
34:35 - is this true and is this true
34:39 - right so the brackets matter
34:41 - finally let me show you another operator
34:44 - that we have here so here we have we're
34:47 - checking is c
34:49 - equal to three well what if we want to
34:51 - ask is
34:52 - c anything but three or is c not equal
34:56 - to three
34:57 - if we only care
34:58 - about the case where c is not three we
35:01 - can say something like this not equals
35:03 - to three
35:05 - and this is going to say
35:08 - is c
35:09 - not equal to three
35:11 - so you can see here that c is three so
35:14 - that's why it completely skips this
35:17 - branch and
35:18 - it ends up being a is equal to 10 and it
35:21 - prints branch 3.
35:25 - now you can use this not operator this
35:28 - exclamation mark here on other things as
35:30 - well so for example here i'm asking is a
35:34 - equal to 10
35:36 - right and i am
35:38 - uh it's coming in here because a
35:40 - actually is 10 and so it's printing
35:42 - branch 3
35:43 - but if i surround this
35:47 - like that
35:50 - let me put something else in here is a
35:52 - equal to 10
35:54 - and b
35:55 - equals to 1
35:57 - right that is true
36:00 - so that's why i'm still getting branch
36:01 - three
36:02 - but if i put an exclamation mark here
36:07 - like that it basically flips it around
36:10 - so
36:11 - this evaluates the true right a is a 10.
36:15 - this evaluates to true
36:18 - both
36:19 - this whole condition evaluates to true
36:21 - right
36:22 - a
36:23 - is a equal to 10 and b is equals to 1.
36:26 - and then so we get true
36:28 - but then we're adding this guy here it
36:30 - flips that true to a false
36:33 - so
36:34 - that's why
36:35 - this whole condition equates to false
36:39 - okay so that does it for if statements i
36:41 - hope you're trying this out on your own
36:43 - computer in the playground because trust
36:46 - me it's pointless to try to memorize all
36:48 - of the keywords and the syntax for the
36:50 - swift it's much better if you you know
36:53 - only spend 30 minutes instead of trying
36:55 - to memorize things spend 30 minutes in
36:57 - the playground
36:58 - just punching in different numbers like
37:00 - that playing around with the different
37:02 - conditions and expressions
37:04 - and printing out a bunch of stuff in the
37:06 - console in 30 minutes you'll remember
37:08 - a lot more just by doing that than
37:10 - trying to memorize you know how to
37:12 - declare a variable or how to declare an
37:14 - if statement so
37:15 - you know if you can get a mac get xcode
37:19 - open in a playground and then type this
37:21 - code out for yourself and play around
37:23 - with it it's going to do wonders
37:26 - so thanks again for watching and if you
37:28 - like this series so far please give the
37:30 - video a thumbs up please subscribe it
37:32 - really helps
37:34 - hello welcome to the learn swift for
37:36 - beginners series lesson four
37:39 - in this lesson you're going to learn
37:40 - about switch statements and like the if
37:43 - statement it allows you to make
37:44 - decisions with your code alright so
37:46 - let's get started
37:52 - let's start by creating a new playground
37:54 - for this example
37:56 - and i'm going to start labeling these
37:59 - after the lessons here
38:02 - and i should have done this sooner but i
38:04 - want to point out that apple does have a
38:07 - swift programming language guide
38:09 - and in this guide it goes through all of
38:12 - the syntax and the structure and the
38:14 - different concepts of the swift
38:16 - programming language it's what we're
38:18 - doing in these videos and more in fact
38:21 - so if you want something to read you can
38:23 - go ahead and visit this website here
38:26 - i'll have the link below the video
38:29 - but one thing to note is that it may be
38:32 - a little bit complicated for the
38:33 - absolute beginner who doesn't have
38:35 - programming background
38:37 - but give it a try and it's a great
38:39 - compliment to watch with this learn
38:41 - swift series that you're watching
38:43 - in fact as we're going through the
38:44 - different concepts in these videos i'll
38:46 - point out
38:47 - in the guide where they are so for
38:49 - example we're looking at the switch
38:50 - statement today and that resides under
38:53 - control flow and you can see here what
38:56 - the basic syntax is for this switch
38:58 - statement
39:00 - okay so let's jump back into our
39:02 - playground and we can do an example of a
39:05 - switch statement so in here i'm going to
39:09 - basically
39:10 - do the same example or similar example
39:13 - as the one in the guide
39:14 - and
39:17 - i'm going to introduce a new data type
39:19 - called character and it's basically like
39:22 - a string except that it's just a single
39:24 - character like that
39:27 - and with an if statement we can do
39:29 - something like this if some character is
39:33 - you know equals
39:36 - a for example okay like we have right
39:38 - here
39:40 - print
39:41 - is n
39:43 - a
39:44 - and this is going to be true and it's
39:46 - going to print this out and then we're
39:48 - going to have else if and we're going to
39:50 - maybe check another condition if we
39:51 - wanted to you know respond to different
39:54 - cases depending on what letter this
39:57 - variable is
39:59 - right but you can use a switch statement
40:00 - and it looks like this
40:02 - so we start with the switch keyword then
40:04 - you have the value which you're
40:06 - considering in our case that value is in
40:09 - the variable sum character
40:11 - so that's what we would put in there
40:13 - and then you open up a pair of curly
40:15 - brackets
40:17 - inside these curly brackets you have
40:19 - different case labels so you would have
40:22 - case if you wanted to consider the case
40:25 - where the value is an a you would have
40:28 - case a and then you have colon and you
40:31 - would have something to do if it were
40:34 - that case
40:35 - perhaps this would be easier to
40:37 - visualize if we take a look at the
40:39 - playground so let's jump back to the
40:40 - playground here
40:42 - so let me say
40:43 - switch statement
40:45 - right on the value that we're
40:46 - considering so that's some character
40:49 - and you open up a pair of curly brackets
40:52 - like that and then you have your case
40:53 - labels so i have case you know if it's
40:56 - an a
40:57 - and if i want to do something for this
40:59 - case right then you have a colon and in
41:03 - here you would print let's say is an a
41:07 - like that
41:08 - and if there's another case right i
41:10 - would have case
41:12 - b for example
41:14 - and i would say
41:16 - is a b
41:18 - and lastly if none of those cases are
41:21 - true i would have a default case like
41:23 - that
41:24 - and i would say
41:26 - print
41:28 - some fallback
41:33 - so in this switch statement
41:35 - this case was true
41:36 - right so it printed out the statement
41:38 - and it doesn't do the rest and you can
41:40 - have more lines of code in here than
41:42 - just the print statement in all of our
41:44 - examples you know i just wanted to show
41:46 - that it's coming into here this branch
41:49 - but you could execute more code in here
41:51 - now the case where you know
41:54 - character is a b
41:55 - then we would come
41:57 - into here and jump into here now if it's
42:00 - not none of those cases we would have
42:02 - default and it would print that
42:06 - and of course you can have
42:08 - a whole bunch of different case labels
42:10 - it just doesn't have to be the two that
42:12 - we have here the benefit of using a
42:14 - switch statement is that rather than
42:16 - using an if statement and having all of
42:18 - these else if clauses
42:20 - reading this is much more clean
42:23 - and it's a lot easier to read as well
42:27 - so what if you wanted let's say two
42:29 - different cases to run the same piece of
42:31 - code or the same block of code so for
42:33 - example if i change this to say
42:37 - is b
42:38 - or
42:39 - you know a c
42:41 - is a b or c
42:43 - i could do something like this with this
42:45 - case label here i can do that comma and
42:48 - then i can put
42:50 - this other case there
42:53 - so this saves me from having to have
42:55 - another case c and then you know the
42:58 - same
42:59 - code i can put a comma here put the
43:02 - other case here and have either one of
43:04 - these cases use the same block of code
43:08 - so now you can see that it comes into
43:11 - this case here prince is a b or c
43:14 - instead of coming into default
43:18 - so why would you want to use a switch
43:20 - statement over an if statement well if
43:22 - there are a lot of different conditions
43:24 - that you want to check on a certain
43:26 - value rather than using an if statement
43:29 - with a whole ton of else ifs you can use
43:32 - this switch statement which is easier to
43:34 - read and easier to understand
43:36 - you're probably going to use the if
43:38 - statement more than the switch statement
43:40 - but it's still a handy tool to have in
43:43 - your arsenal so i highly recommend that
43:44 - you try this out
43:46 - in your playground
43:48 - so that's it for switch statements this
43:50 - is a short one i hope you enjoyed it
43:52 - please help this channel grow by
43:54 - subscribing and hitting that thumbs up
43:56 - button below the video
43:58 - hello welcome to learn swift for
44:00 - beginners lesson five in today's lesson
44:02 - we're going to talk about loops
44:04 - when you're writing your app there's
44:06 - going to be many times you're going to
44:07 - find yourself needing to repeat pieces
44:10 - of code
44:11 - for instance let's say you're showing
44:13 - five things
44:14 - in your app and you need to turn each of
44:16 - them red
44:18 - so a loop is going to allow you to just
44:20 - write that single line of code to turn
44:22 - something red and you can repeat it five
44:25 - times for each of those five objects
44:28 - and that's going to save you from having
44:30 - to
44:31 - write out that code five times
44:33 - so
44:34 - that's a very simplified example
44:36 - but trust me you're going to use them a
44:38 - lot so let's take a look at how to use
44:40 - them
44:44 - so there are three types of loops we're
44:46 - going to cover today we're going to
44:47 - start with the four in loop as you can
44:51 - see in the swift programming guide here
44:54 - so let's go ahead and start a new
44:56 - playground in our xcode
45:00 - and i'm just going to call this
45:02 - the loop playground
45:05 - and save it on my desktop
45:10 - now a for in loop allows you to repeat a
45:13 - piece of code a certain specified number
45:16 - of times
45:17 - if you have a list of data otherwise
45:19 - known as an array which you're going to
45:21 - learn about in an upcoming lesson you
45:23 - can also use a for in loop to go through
45:26 - each of those pieces of data in that
45:29 - array and execute some sort of code on
45:32 - it so this is perfect for the example we
45:34 - mentioned in the intro about having five
45:37 - objects or five items on the screen and
45:39 - you need to turn each of them red for
45:41 - example
45:42 - so let's start with learning how to use
45:45 - a foreign loop to
45:47 - repeat a piece of code for a specified
45:49 - number of times and when you guys learn
45:51 - about arrays
45:52 - i'll show you how to use a foreign loop
45:54 - to go through each piece of data in that
45:56 - array
45:57 - so as you can see
45:59 - true to its name the keywords to use
46:02 - here are for and in
46:05 - so you start with the keyword for and
46:07 - next you have a variable name now you
46:10 - don't have to declare this variable
46:12 - using the var keyword like you've
46:14 - learned in the previous lessons you can
46:16 - simply have a name for this variable
46:20 - because you're only going to refer to
46:22 - this variable
46:23 - within the for in loop
46:25 - this variable that you specify here is
46:27 - going to keep track of which iteration
46:29 - of the loop is currently running
46:32 - next up you have the keyword in
46:34 - and then you have the lower range
46:37 - followed by
46:38 - dot dot and then the upper range and
46:41 - that last part there after the in
46:43 - keyword is the range which your for loop
46:47 - is going to run in
46:49 - and it's inclusive of those numbers so
46:52 - for example if you have
46:54 - 1.5 it's actually going to run five
46:57 - times
46:58 - and then after that you open a set of
47:00 - curly brackets and inside the set of
47:03 - curly brackets that's where you're gonna
47:04 - put the code that you want to repeat for
47:07 - that number of times
47:09 - so let's jump back to the playground and
47:11 - let's do a quick demo on that for in
47:14 - loop
47:15 - so i have the four keyword here
47:17 - and
47:18 - for my variable i can specify something
47:21 - like index
47:23 - and then i would put in and let's use
47:26 - that same example one to five and then i
47:29 - open up a set of curly brackets and then
47:32 - here i'm simply going to print
47:35 - hello
47:36 - and we're going to see this in the
47:38 - console down here
47:39 - it has printed it five times
47:43 - now part of the reason why you specify a
47:46 - variable name here called index
47:48 - is because you want to use that
47:51 - that number or this variable inside your
47:55 - for loop here so for example i can
47:59 - do something like this
48:01 - where i can say
48:03 - print index and you're going to see that
48:06 - index changes
48:08 - from 1 2 3 4 5 depending on
48:12 - which iteration of the loop it is it
48:14 - keeps track of
48:16 - basically where we're at
48:18 - in this range right here as we're
48:20 - looping through it
48:22 - but again what we've specified here as a
48:24 - counter is only available inside this
48:27 - scope here in between these curly
48:30 - brackets i can't specify
48:34 - you know printing index out here it's
48:36 - not going to recognize it
48:38 - okay so
48:40 - we can't do that
48:42 - and furthermore
48:44 - if you don't need to use index inside
48:46 - your for loop you can very simply place
48:49 - an underscore there
48:51 - so this is perfect for the example that
48:54 - we had
48:55 - initially
48:56 - where we're just printing hello five
48:58 - times we don't really need
49:00 - a counter of any sort we don't need to
49:03 - refer to index we don't care which
49:05 - iteration it's currently at
49:08 - one thing i want to mention which is
49:10 - confusing often for beginners is this
49:13 - idea of scope
49:14 - here for example if i wanted to sum up
49:18 - the numbers from one to five and i
49:20 - wanted to print out the result after the
49:22 - for loop
49:24 - let's say i declare a variable up here
49:26 - and i call it sum and i equate it to
49:29 - zero and then i say something like sum
49:33 - plus equals
49:35 - and actually let's add this
49:38 - index variable back here
49:40 - and i go like this now you haven't seen
49:42 - this plus equals
49:45 - sign yet
49:46 - but this operator basically
49:49 - equates to something like this
49:54 - it takes sum and it adds
49:56 - the index so this is equivalent to
49:58 - writing
50:00 - this it's just kind of like a short form
50:04 - okay so first of all
50:06 - if i declare this variable called sum
50:09 - inside my for loop inside these curly
50:11 - brackets
50:12 - well this variable is only available
50:15 - within that scope within these two curly
50:18 - brackets i can't go out here outside of
50:21 - the for loop after it's run five times
50:24 - and print out the result of sum
50:27 - see you can see that it can't find this
50:30 - variable even though i've declared it in
50:33 - here
50:34 - okay so why don't we move this print
50:37 - statement into the for loop what would
50:40 - you expect to happen in this case
50:42 - well we get one two three four five
50:45 - again
50:46 - and why is it that
50:48 - this sum isn't increasing why isn't it
50:51 - continually adding index to it and
50:55 - you know why aren't i getting the sum of
50:57 - the numbers from 1 to 5 by the last
51:00 - iteration of the loop well what's
51:02 - happening is that
51:04 - in the first iteration of the loop we're
51:06 - declaring sum
51:09 - equals to zero
51:10 - and then we're adding index to sum which
51:14 - is one and then we're printing some so
51:16 - that's why we get one down here
51:18 - in the second iteration of the loop what
51:20 - we're doing is we're declaring sum again
51:22 - we're setting it to zero
51:24 - and we are adding
51:26 - um this time the index is two and we're
51:28 - adding two to zero right and then it's
51:30 - going to print two so
51:32 - that's why you can see the output 2
51:35 - right there
51:36 - well right now you might point out to me
51:38 - hey chris i thought you said that you
51:40 - can't really declare the same variable
51:42 - you know in the first iteration of the
51:44 - loop we're declaring var sum
51:47 - right and then in the second iteration
51:49 - of the loop we're re-declaring var sum
51:51 - that's that's illegal that's not allowed
51:53 - in fact
51:54 - you might say that you know if i declare
51:57 - var string again up here
51:59 - it's going to throw an error right we
52:01 - can't redeclare the same variable
52:03 - because
52:05 - we've declared this guy up here we can't
52:07 - redeclare it using the var again
52:09 - and i would say that's true except that
52:13 - in each iteration in the loop it's
52:15 - almost as if
52:17 - it doesn't remember what happened in the
52:19 - previous iteration there's no memory or
52:22 - recollection of the previous iteration
52:24 - so each iteration is kind of like a
52:26 - clean slate and it's going to execute
52:28 - this code right here
52:31 - so just to say that again you're right
52:33 - if you're saying that
52:35 - i can't read a clear sum
52:38 - right because if i tried to do that
52:40 - right here
52:42 - xcode would throw an error
52:44 - however inside of a loop in this scope
52:47 - right here
52:49 - each iteration of the loop is like a
52:51 - clean slate okay
52:54 - now if i wanted to
52:56 - actually find out the sum of the numbers
52:59 - from one to five what i would actually
53:01 - do is i would move this declaration
53:04 - up here outside of the loop
53:07 - and then what i would do
53:09 - [Music]
53:10 - this way
53:11 - i could move this print statement
53:13 - outside of the loop and what this four
53:16 - in loop will do is simply loop from one
53:19 - to five each time
53:21 - adding index to the sum and now i'm
53:24 - actually keeping track of the sum so you
53:26 - can see that after five iterations of
53:30 - the loop
53:31 - adding the numbers from one to five into
53:33 - sum which started out as zero
53:37 - the result is 15 down here
53:40 - and that's from this print statement
53:43 - okay so i'm going to stop the lesson
53:45 - there
53:46 - while the syntax for the foreign loop is
53:49 - actually pretty simple and and the
53:50 - concept of repeating a piece of code for
53:53 - a certain number of time is pretty
53:54 - simple
53:55 - i want to give you some breathing room
53:57 - to digest what we talked about
54:00 - in regards to the variable scope
54:03 - so i would recommend that you try
54:05 - declaring and creating this loop
54:07 - on your own computer
54:09 - try declaring the variables inside the
54:11 - loop and outside the loop and see where
54:13 - you can access them and use them and
54:14 - where you cannot
54:16 - it's really going to help and aid you in
54:18 - your learning
54:20 - hello welcome to learn swift for
54:22 - beginners lesson six
54:24 - in this video i'd like to introduce you
54:26 - to two more types of loops and that is
54:29 - the while loop and the repeat while loop
54:31 - and these two loops lets you execute
54:33 - some code until some condition is met so
54:36 - that's different from the foreign loop
54:38 - where it repeated a certain number of
54:40 - times
54:41 - okay let's do it
54:47 - for this lesson we're going to create a
54:49 - brand new playground and i'm just going
54:52 - to call this the loop 2 playground
54:58 - okay so let's cover the while loop first
55:01 - take a look at this slide and let's go
55:03 - through how to declare a while loop
55:06 - so the keyword here is while
55:09 - followed by that you have some sort of
55:11 - condition and it's very similar to an if
55:13 - statement so the while loop is going to
55:16 - repeat that chunk of code
55:19 - as long as the condition is true but as
55:21 - soon as that condition becomes false
55:24 - it's not going to repeat the code
55:26 - anymore
55:27 - after your condition you have a set of
55:30 - curly brackets and inside of the curly
55:32 - brackets that's where you have the code
55:33 - that you want to repeat
55:35 - so let's do a quick example back in our
55:37 - playground
55:38 - so i'm just going to declare a variable
55:40 - here
55:42 - i'm going to call this
55:44 - let's say counter
55:45 - and i am going to
55:48 - set this counter to 10
55:52 - and then i would like to
55:54 - print hello
55:57 - let's use
55:58 - five instead so it doesn't print that
56:01 - many times and i would like to print
56:03 - hello as long as the counter is um
56:07 - above zero let's say
56:09 - so i would say something like while
56:12 - counter is greater than zero
56:16 - i would
56:18 - i would do this print right here
56:20 - however this is going to keep repeating
56:23 - as you can see because
56:25 - counter is always five so inside my
56:27 - while loop i'm going to
56:32 - computer is dying
56:36 - okay
56:39 - as you can see
56:43 - it eventually
56:45 - overflows and crashes
56:47 - okay so what i'm doing here
56:51 - is i am decrementing counter by one for
56:54 - each iteration of the loop so as you saw
56:57 - when i didn't have this line of code it
57:00 - just kept printing hello
57:02 - many many times because this condition
57:06 - would always be
57:08 - would always be false there was nothing
57:10 - changing the counter variable from five
57:12 - to zero
57:13 - so i'm just going to warn you about that
57:16 - if you're going to try this on your own
57:17 - computer
57:19 - you know if you have a slower computer
57:21 - it might it might take a lot longer for
57:23 - you to get out of that out of that loop
57:27 - so you can write this statement first
57:28 - make sure you have
57:30 - a statement that is
57:32 - decrementing your counter
57:34 - so again this minus equals
57:36 - is the equivalent of writing something
57:38 - like this
57:39 - counter equals counter minus one so
57:42 - you're just taking whatever value
57:43 - counter is you're minusing one and
57:45 - you're setting that as a new value for
57:48 - counter
57:49 - as you can see here
57:51 - it's what you would expect right you get
57:53 - hello
57:54 - five times
57:56 - now let me point something out to you
57:58 - right here
57:59 - uh what if counter was
58:03 - let's say negative five
58:05 - you can see here that nothing gets
58:07 - printed out because
58:09 - this loop is going to see if this
58:11 - condition
58:13 - is false or true
58:15 - before executing the code right so it
58:17 - evaluates the condition
58:19 - and then it decides whether or not it
58:22 - should run this and repeat it
58:25 - now the second type of loop the repeat
58:27 - while loop is very similar to the while
58:30 - loop except that
58:31 - it checks the condition
58:33 - after looping once so it checks the
58:35 - condition down here let's take a look at
58:38 - the syntax
58:39 - so you start with the keyword repeat
58:42 - and then you have a set of curly
58:43 - brackets and inside the set of curly
58:46 - brackets you place the code you want to
58:48 - loop or repeat
58:50 - and then after the ending curly bracket
58:54 - you have a while keyword and you then
58:56 - you have the condition
58:58 - so the syntax of this repeat while loop
59:01 - is very intuitive actually
59:03 - it's basically saying repeat this piece
59:05 - of code while this condition is true
59:10 - okay so let's go back to the playground
59:12 - and let's do an example here
59:14 - so i am going to use the same example
59:18 - okay let's print hello here
59:20 - and we're going to have the same thing
59:22 - counter equals counter minus 1
59:25 - and we're going to say repeat
59:29 - this chunk of code
59:31 - while
59:34 - counter is greater than zero so as you
59:36 - can see it's pretty much the same loop
59:41 - or same condition rather
59:43 - right while counter is greater than zero
59:45 - and that's the same thing i have up here
59:48 - for this while loop
59:49 - and
59:50 - let's just print something else here so
59:52 - we can differentiate it
59:54 - and you can see the repeat while loop
59:56 - actually prints it out
59:58 - once and then it checks the condition
60:00 - and it realizes oh i shouldn't repeat
60:02 - this chunk of code because
60:04 - this is false
60:06 - right
60:08 - whereas this while loop it checks the
60:09 - condition first and it realizes this
60:11 - condition is not true and it won't print
60:13 - at all
60:15 - so that's that's the main difference
60:17 - between the two types of loops
60:19 - both types of loops will repeat a chunk
60:21 - of code until a certain condition is
60:24 - false except that
60:26 - the while loop checks first
60:28 - and the repeat while loop checks the
60:30 - condition after repeating once
60:34 - hello welcome to learn swift for
60:36 - beginners lesson seven in this lesson
60:38 - you're going to learn about functions
60:40 - how to use them what they are and this
60:42 - is a critical part of the swift
60:44 - programming language if you want to
60:45 - build apps with it so let's get started
60:51 - so here i've got a brand new xcode
60:53 - playground where we're going to take a
60:55 - look at what functions are and how to
60:57 - use them how to define one how to call
60:59 - one if you don't know how to start a new
61:02 - playground just go back to lesson one of
61:04 - this learn swift series okay let's start
61:07 - with what a function is
61:09 - at its very core a function simply
61:11 - allows you to take a chunk of code give
61:14 - it a function name and then whenever you
61:16 - call that function name it's going to
61:18 - execute that chunk of code
61:20 - now that may seem simple but over the
61:23 - course of the next couple of videos
61:24 - you're going to see just how complex and
61:27 - powerful functions can be functions are
61:29 - really useful because it allows us to
61:31 - break down and group our code into
61:34 - smaller chunks
61:35 - and we can organize them so that each
61:38 - function or each chunk of code has a
61:40 - specific task
61:42 - and when you want to do that specific
61:44 - task then you just call that function
61:47 - so let's see how a function is defined
61:49 - in swift code and then we'll jump into
61:51 - some examples in our playground
61:54 - so here we have the syntax for our basic
61:56 - definition of a function now it can get
61:59 - more complex than this because there are
62:01 - a lot more features of functions that we
62:03 - can use but we're going to explore those
62:05 - in the next couple of videos for this
62:07 - example here is your kind of basic
62:11 - definition of a function you start with
62:13 - the func keyword that's func
62:15 - followed by the function name now this
62:17 - function name is what you're going to
62:19 - use to call the function
62:21 - now right after the function name you
62:23 - have two parentheses or two rounded
62:25 - brackets
62:26 - in this basic definition there is
62:28 - nothing in between these two brackets no
62:30 - spaces nothing in the next two videos
62:32 - you're going to see what those brackets
62:34 - are used for but for now
62:36 - those brackets are just there as part of
62:38 - the definition there's nothing in
62:39 - between them
62:41 - and then you're going to have a set of
62:43 - curly brackets and as you would expect
62:46 - in between the curly brackets you would
62:47 - put the code for the function
62:50 - so whenever you call the function name
62:52 - that code in between those curly
62:54 - brackets that code is going to be
62:56 - executed
62:58 - all right let's jump into the playground
63:00 - and do some examples
63:02 - i'm going to declare a function that is
63:04 - going to
63:05 - add two numbers together
63:08 - and it's going to print the result to
63:10 - the console so i'm going to start by
63:13 - using the func keyword to declare a
63:16 - function
63:16 - and now i have to have a
63:19 - function name
63:21 - so i'm going to say
63:23 - add
63:24 - to numbers
63:27 - that's my function name and you'll
63:29 - notice that i'm using the same
63:31 - camel case as i do for declaring
63:34 - variables where i start with a lowercase
63:37 - letter
63:38 - of the first word and the following
63:40 - words uses a capital letter then i have
63:43 - my two rounded brackets like that
63:45 - followed by
63:46 - a set of curly brackets like that
63:50 - and sometimes when you type in this
63:52 - first
63:53 - curly bracket or the opening bracket and
63:55 - then you press enter xcode will
63:57 - automatically add this ending curly
63:59 - bracket for you
64:01 - okay so in between the two curly
64:03 - brackets i am going to
64:05 - say let a equals one
64:08 - let b equals two
64:10 - and
64:11 - i am going to
64:13 - uh let's see equals
64:16 - a plus
64:18 - b
64:19 - okay
64:20 - and then finally we're going to print
64:22 - the result of c
64:25 - so you can see here that nothing
64:27 - actually happens because this function
64:30 - hasn't been called this code is sitting
64:32 - here if we had written this code instead
64:35 - of putting it into a function so let me
64:38 - just delete this for now
64:40 - like that
64:42 - and this is what we've been doing so far
64:44 - before we learned about functions we
64:45 - would just declare these constants here
64:48 - and then print c and you would see all
64:50 - of the stuff in the output now i'm just
64:52 - going to undo those two deletions
64:54 - so to wrap this code inside of a
64:57 - function now you can see nothing gets
64:59 - output until i actually call the
65:01 - function to execute this code right here
65:04 - so how do we call a function so in order
65:06 - to call a function you just have to
65:08 - write the function name followed by the
65:10 - two rounded brackets
65:12 - now because we don't have anything
65:13 - inside these two rounded brackets that's
65:15 - all we have to do but as you're going to
65:17 - learn in a couple of videos later
65:20 - if we have something in between these
65:21 - brackets the calling the function would
65:24 - require a little more work but for this
65:27 - basic function we can
65:29 - invoke that function simply by writing
65:31 - its name so add two numbers as you can
65:33 - see here autocomplete even suggests it
65:36 - so all i have to do is highlight that
65:37 - line
65:38 - press enter
65:40 - and what happens now we get three output
65:43 - into our console because by calling that
65:46 - function it just ran the code down here
65:50 - and i can call this again
65:53 - as many times as i'd like and anywhere
65:56 - i'd like one benefit is that if you need
65:58 - to execute a chunk of code several times
66:01 - this is a big savings rather than
66:03 - writing this code out multiple times i
66:05 - just put it inside a function give it a
66:07 - name and now i can invoke that piece of
66:09 - code whenever i call this function name
66:12 - like this
66:14 - so it helps you reuse code especially if
66:17 - that chunk of code is going to be used
66:19 - multiple times in your app you don't
66:21 - want to write out the same chunk of code
66:23 - multiple times in and around your app
66:26 - because
66:26 - it makes it really hard to debug for
66:29 - example if you've got an issue with this
66:31 - chunk of code and imagine if you had it
66:33 - repeated several times in your app in
66:35 - order to fix it you'd have to fix it in
66:38 - every single one of those places but if
66:40 - i have this chunk of code inside this
66:42 - function
66:43 - i would only have to troubleshoot and
66:45 - debug this piece of code once here
66:48 - and as soon as i change this let's say i
66:50 - change this a to a two and let's say
66:53 - that fixed my code and you can see here
66:56 - wherever i call add two
66:58 - numbers the code is updated so i only
67:01 - need to update and change the code in
67:03 - one place whereas if i wrote this chunk
67:06 - of code out in multiple places in my app
67:08 - i would have to change it in all of
67:10 - those places
67:12 - another benefit i mentioned is that it
67:14 - lets you group this chunk of code that
67:16 - performs a specific task into a function
67:20 - that describes what that chunk of code
67:22 - does so it helps you organize your code
67:26 - so there is one more thing i want to
67:28 - mention about functions and that is
67:30 - about scope so same thing we learned
67:32 - about inside of loops in terms of
67:35 - defining variables applies here as well
67:38 - so let me give you an example of what
67:41 - i'm saying so let's say i get rid of
67:43 - those two function calls and we simply
67:45 - have this function here we have these
67:48 - three constants c is obviously four
67:52 - right and inside this function i'm
67:54 - printing c so outside of my function
67:58 - let's say i want to print c
68:02 - well that is actually going to throw an
68:04 - error that doesn't work why because the
68:08 - constants and variables that you declare
68:10 - inside a function can only be used in
68:13 - the function in between these two curly
68:15 - brackets
68:16 - and likewise if i
68:19 - declared another function
68:21 - really quick quickly
68:27 - so inside this function i also cannot
68:30 - access the constants that i declared
68:32 - here so if i declared
68:35 - a constant
68:36 - like that d equals one i can't say
68:39 - you know uh
68:42 - let e equals c minus d or something like
68:45 - that
68:45 - um inside this function it's not going
68:47 - to recognize what c is right here
68:52 - so let's get rid of this first okay so
68:54 - there you can see the error it doesn't
68:56 - know what c is because c is defined
68:58 - inside add two numbers and so it only
69:02 - recognizes
69:04 - c within this scope a b and c in fact so
69:07 - inside here inside this function i'm
69:09 - free to declare a again because it only
69:12 - applies within
69:14 - these brackets like that
69:17 - so i can have a minus d
69:21 - and let's end off
69:23 - by printing e
69:25 - okay so the main takeaways for this
69:27 - lesson right here
69:29 - you've learned about what functions are
69:31 - and why they're beneficial you've
69:32 - learned how to define a simple function
69:34 - you've learned how to call that function
69:36 - so you can execute the code inside of
69:38 - that function
69:39 - and furthermore you learned about the
69:41 - scope inside of a function
69:43 - and just to remind you about that
69:46 - it's that whatever you declare inside of
69:48 - the curly brackets of a function is only
69:51 - recognized and can be used inside of
69:53 - those curly brackets
69:55 - in the next video we're going to build
69:57 - upon what we learned here in this lesson
70:00 - and you're going to learn how to make
70:01 - functions even more powerful
70:03 - so thanks for watching if you liked the
70:05 - video please give it a thumbs up it
70:07 - helps this video get seen by more people
70:09 - and subscribe for more
70:12 - hello welcome to learn swift for
70:14 - beginners lesson 8. in the previous
70:16 - lesson you learned about functions how
70:18 - to declare them and how to call them
70:21 - in this lesson you're going to learn how
70:23 - to use them in an even more powerful way
70:26 - by having your functions accept data and
70:28 - also return data to you when you call
70:30 - them all right let's see how that's done
70:37 - so here i have a fresh playground if you
70:39 - forget how to open up a new playground
70:41 - just go back to lesson one of this
70:43 - series and you can see how now there's
70:45 - one thing i want to mention before we
70:46 - move on that i forgot to mention in the
70:48 - previous video and that is that
70:50 - sometimes i may accidentally say method
70:53 - and when i say method i actually mean
70:56 - function now i noticed that a lot of
70:59 - other swift teachers also do this
71:02 - and the reason for this is because
71:04 - for many swift educators like myself
71:07 - swift isn't our first programming
71:09 - language and in many of the programming
71:12 - languages out there there is some
71:13 - concept of a function and sometimes
71:16 - they're called functions sometimes
71:18 - they're called methods and sometimes
71:19 - even other things so
71:21 - a lot of the educators out there when
71:23 - they're teaching sometimes they're going
71:24 - to slip up and they're going to say
71:26 - method instead so i just want to put it
71:28 - out there if you hear me say method
71:30 - uh
71:31 - just know that sometimes i use function
71:33 - and method interchangeably
71:36 - okay so we're going to start by
71:38 - just redeclaring that function that we
71:40 - had in the previous lesson and i want to
71:43 - redeclare it just for extra practice for
71:44 - you guys so i think it was something
71:47 - like
71:48 - um add to numbers
71:51 - like this
71:52 - and it was let a equals one
71:55 - let b equals one and let's see equals a
71:59 - plus b
72:00 - and then we're going to print c just
72:03 - like that
72:06 - now in the previous lesson i mentioned
72:08 - that functions are great for kind of
72:10 - organizing your little bits of code into
72:13 - um pieces of code that perform one task
72:16 - so in this case
72:17 - um this function would add the two
72:19 - numbers together and then it would print
72:21 - out that sum in the console but what if
72:24 - i wanted the function to just add the
72:26 - two numbers but don't print it out i
72:28 - just want the result
72:31 - so in fact functions have something
72:33 - called a return value
72:36 - and it's exactly how it sounds when you
72:39 - execute the function it returns a value
72:42 - to you
72:43 - so let's take a look at what the syntax
72:45 - is for specifying that a function
72:46 - returns a value
72:49 - so everything remains the same as our
72:51 - basic function definition but after the
72:54 - two rounded brackets you have an arrow
72:57 - that arrow is just comprised of a hyphen
73:00 - and a greater than sign and followed by
73:02 - that you have the data type of the value
73:05 - that this function should return
73:07 - so now that you specified that this
73:09 - function returns
73:11 - a value you have to use the return
73:13 - keyword inside of that function to
73:15 - actually return a value of that same
73:17 - data type that you specified
73:20 - so now let's go back to our playground
73:22 - and see how this applies to the function
73:24 - that we have there
73:25 - so let's say that for this function
73:28 - i don't want to print out the sum
73:30 - instead i wanted to return the sum to me
73:33 - i would then erase this print statement
73:35 - first of all
73:37 - after the rounded brackets i would put
73:38 - hyphen
73:40 - greater than sign and then i would put
73:42 - int
73:43 - specifying that this function should
73:45 - return an int data type
73:48 - now xcode immediately throws an error
73:51 - here because it notices that i
73:53 - don't have the return keyword i'm not
73:55 - returning
73:56 - an integer value like i said i would so
73:59 - what i would have to do actually to fix
74:01 - this is use the return keyword and i'm
74:03 - going to return c because that's the sum
74:06 - of a and b
74:08 - so now when i call
74:10 - add two numbers like that it actually
74:13 - returns c
74:15 - now let me show you something here so
74:17 - when i type that autocomplete it shows
74:19 - you the return value right there it
74:21 - tells me that add two numbers actually
74:24 - returns an integer like that so what i
74:27 - would do
74:28 - essentially is i would probably
74:31 - declare a constant
74:33 - and let's call it sum and i would say
74:35 - equals add two numbers what's happening
74:38 - here is that i'm calling this function
74:41 - add two numbers
74:42 - and this function is returning
74:45 - c
74:46 - as in the sum of one plus one
74:48 - and i'm assigning that value into this
74:51 - constant called sum
74:53 - so now if i print sum
74:56 - like that
74:58 - i would get 2.
75:01 - so this constant sum it stores the
75:04 - returned value from my function here
75:07 - so one more thing i can do up here
75:09 - instead of declaring this constant c
75:12 - equals a plus b and then returning c i
75:15 - could actually get rid of this constant
75:18 - and i could just return a plus b like
75:20 - that
75:21 - and that would actually take a and b add
75:24 - them together and then return it
75:28 - so that's return values for functions
75:30 - and this is really powerful because now
75:32 - you can
75:33 - write a function that does something and
75:36 - returns the result to you
75:38 - so your function is kind of like
75:41 - a little worker or a piece of code that
75:43 - does a specific task and then returns
75:45 - you back the result
75:48 - now there's another cool thing that you
75:50 - can do with functions and that's called
75:52 - parameters
75:53 - see this function by itself add two
75:55 - numbers
75:56 - it's always just going to add one and
75:58 - one together and return two to me
76:01 - but what if i wanted this piece of code
76:03 - to be reusable for any type of numbers i
76:06 - want to specify which two numbers i want
76:09 - to add together
76:11 - so essentially what it is
76:14 - is when i declare this function i can
76:16 - specify in between these two rounded
76:18 - brackets see i mentioned
76:20 - in the previous video that we would use
76:22 - this
76:22 - in between these two rounded brackets we
76:25 - can specify that this function needs
76:28 - some input parameters in order to
76:30 - execute so let's say that i'm going to
76:32 - declare this function and say that when
76:34 - you call this function you need to give
76:37 - me two numbers
76:38 - as inputs
76:40 - now when i call the function here i
76:43 - would have to specify two numbers in
76:45 - between these rounded brackets
76:47 - okay so before we actually do it let's
76:50 - go take a look at what the syntax looks
76:52 - like for declaring these
76:54 - input parameters so this syntax right
76:56 - here shows you what the function
76:58 - definition would look like for a single
77:01 - parameter now we're going to get to
77:02 - multiple parameters but this is an
77:04 - example of a single parameter
77:06 - function declaration
77:09 - so in between the two rounded brackets
77:11 - you have an argument label
77:14 - okay i'll explain to you in a second
77:16 - what that is and then you have a
77:18 - parameter name
77:20 - followed by a colon
77:22 - and then followed by the data type of
77:24 - the parameter
77:25 - you're accepting
77:27 - now let's talk about the parameter name
77:30 - colon data type part first
77:33 - so obviously the colon data type part of
77:36 - that
77:37 - specifies what sort of parameter you're
77:40 - going to be passing into the function
77:42 - and the parameter name
77:44 - is going to be the name of that
77:46 - parameter you use within the function
77:49 - so if i wanted to take that input and i
77:51 - wanted to add it to something
77:53 - and i wanted to reference that value
77:55 - that was passed in i would use the
77:57 - parameter name okay
77:59 - inside the function
78:02 - now the argument label for that
78:04 - parameter is what is going to be shown
78:07 - when you call that function
78:09 - i know it's a little bit confusing right
78:11 - now but let's jump into an example
78:14 - so it makes more sense
78:16 - all right so back to the playground here
78:17 - let's
78:19 - implement one parameter inside our add
78:21 - to numbers function here so i'm not
78:24 - going to use any descriptive names right
78:25 - now because i want to show you how
78:28 - the argument label and the parameter
78:30 - name plays out so i'm going to say
78:33 - add two numbers
78:35 - argument label is
78:37 - let's just say arg
78:39 - and then the parameter i'm just going to
78:42 - say para okay and then colon
78:45 - int
78:46 - so
78:47 - this
78:48 - function now accepts a parameter
78:51 - that is type of int
78:53 - and then xcode detects that now this
78:56 - function call is incorrect
78:58 - because we have no function that doesn't
79:00 - accept parameters
79:02 - so one cool thing you can do is just
79:04 - erase that and go
79:07 - add two numbers you can see that
79:09 - autocomplete now recognizes that we have
79:11 - a parameter so let's
79:14 - double click that and you can see here
79:16 - is the argument label
79:18 - let's pass in the number here let's pass
79:20 - in let's pass in 2
79:22 - like that
79:24 - so by specifying arg there as the
79:27 - argument label for the parameter when i
79:29 - call the function
79:30 - i'm going to have this label here
79:34 - if i wanted to use
79:36 - this number that i passed in remember
79:39 - you have to use the parameter name
79:41 - that's for inside the function so
79:45 - i would reference the value that's
79:46 - passed in using the parameter name like
79:48 - that so essentially what i would get
79:51 - here
79:53 - is because i'm passing in 2
79:56 - and i'm referencing i'm setting a as
80:00 - 2 right that's our parameter that just
80:02 - got passed in
80:03 - it would be two plus one
80:05 - so that's what is stored in the sum and
80:07 - when i'm printing some
80:09 - that's what i expect to get three
80:12 - okay that is helpful but it's not
80:15 - complete we want to be able to pass in
80:17 - both numbers so that we can specify
80:20 - which two numbers to add together let's
80:22 - take a look at the syntax for multiple
80:24 - parameters
80:25 - so the syntax for multiple parameters is
80:28 - very easy
80:29 - in the parameter list that is that's
80:32 - stuff between the rounded brackets you
80:34 - would just put a comma after the first
80:36 - parameter and then essentially repeat
80:38 - the same thing for the second parameter
80:40 - you'd have an argument label
80:41 - followed by space followed by a
80:43 - parameter name
80:45 - colon and then the data type
80:47 - now you want to use different argument
80:49 - labels and different parameter names
80:51 - obviously so that you'd be able to tell
80:53 - it apart
80:54 - now let's jump back to the playground
80:56 - and add our second parameter so what i
80:59 - would do in between these rounded
81:00 - brackets in this parameter list is i
81:02 - would just put comma and then i would
81:04 - put my second argument label
81:07 - my second parameter name followed by the
81:09 - data type which is another int
81:12 - now again xcode is going to throw this
81:13 - error here
81:15 - let's use autocomplete again add
81:18 - two numbers you can see here it's been
81:20 - updated to accept two arguments
81:23 - so argument
81:24 - just arg and arg2 so let's pass in two
81:29 - and two
81:30 - now we have to modify
81:32 - our code a bit right now i'm still
81:34 - getting three and that's because inside
81:36 - this function code i'm not using
81:39 - the parameter two yet we can change that
81:43 - like that
81:44 - so now a gets set to parameter
81:47 - i mean para and b gets set to para 2
81:51 - and then i'm returning a plus b
81:54 - so now i actually get four in here
81:57 - so one thing we can do with this
81:58 - function is actually we don't need to
82:00 - declare a equals para and b equals pair
82:03 - two that doesn't really do anything
82:06 - so we can get rid of these two constants
82:07 - here and we can simply return
82:10 - para plus para2 like that
82:14 - straight off the bat now our function is
82:16 - pretty simple
82:19 - so at this point you might be wondering
82:21 - why is it so confusing that i'm using
82:24 - argument labels here in the function
82:25 - call and then we're using parameter
82:28 - names inside the function code
82:31 - well
82:32 - what you can do is you can actually
82:34 - not specify argument labels
82:37 - like that and just have the parameter
82:39 - names and what it'll do is it's going to
82:42 - use the parameter name both
82:44 - as the argument label and the parameter
82:46 - name so now
82:48 - this is wrong you can see xcode here has
82:52 - an error let's use autocomplete to see
82:54 - what the new function looks like the new
82:56 - function call and you can see here that
82:59 - now the argument
83:01 - labels are the parameter names
83:11 - so we can also change our parameter
83:13 - names at this point you probably don't
83:14 - want to use para and para2 for your own
83:16 - function so we can say
83:18 - you know number one
83:21 - number two if we have these as our
83:24 - parameter names then you know this
83:25 - changes as well
83:27 - number one
83:29 - number two
83:30 - and then our function call would also
83:33 - change
83:34 - like that
83:38 - okay
83:40 - now you might be wondering why
83:42 - why use argument labels at all like what
83:44 - are they for
83:46 - well using argument labels you can make
83:48 - your function calls a little more like
83:51 - natural english so let me show you an
83:53 - example you can do something like this
83:55 - add two numbers
83:58 - so there's my first argument label
84:02 - and
84:04 - number two like that so let's take a
84:06 - look at what
84:08 - our new function call would look like
84:11 - so when i'm calling a function
84:14 - add two numbers using
84:17 - two and two
84:19 - right you can see how that reads more
84:22 - like natural english and it makes
84:24 - intuitive sense what the parameters are
84:26 - going to be used for
84:28 - meanwhile
84:29 - inside
84:30 - our
84:31 - um
84:32 - our function here if my parameter names
84:35 - were using
84:37 - right
84:38 - or and it doesn't make much sense
84:41 - right
84:42 - um
84:43 - you know if i didn't use
84:45 - if i used these as the parameter names
84:48 - like that
84:50 - these would be terrible parameter names
84:52 - because if my function is really long
84:55 - this doesn't tell me anything this
84:57 - doesn't tell me anything it doesn't mean
84:59 - anything to me
85:00 - while this function call still makes a
85:02 - lot of sense when you call it
85:05 - in terms of natural english but in in
85:07 - the actual code in here and add two
85:09 - numbers
85:10 - you know adding using an n doesn't
85:12 - really make sense so if you use the
85:14 - combination of
85:16 - argument labels and parameter names that
85:18 - make sense
85:21 - um you have this function call that is
85:24 - like natural english that makes sense
85:26 - and you also have meaningful parameter
85:28 - names that you can use inside of your
85:29 - function
85:32 - okay so i want to show you
85:34 - one more thing if you don't want to use
85:37 - these argument labels at all
85:39 - what you can do is replace your argument
85:42 - labels
85:43 - with an underscore like that
85:45 - or you can replace one or you can
85:47 - replace both so let me show you
85:50 - what that
85:51 - looks like
85:52 - so i'm going to replace both the
85:54 - argument labels with just underscore
85:56 - let's take a look at
85:58 - what that looks like now
86:00 - so you can see now that
86:02 - i just pass in 2
86:04 - and 2 like that
86:07 - no parameter names no labels no
86:09 - arguments no nothing it's just you pass
86:11 - in the input parameters like this
86:15 - and
86:16 - you these are your parameter names so
86:18 - that's what you're going to be using
86:19 - inside of your function
86:22 - okay so just to recap
86:24 - in this lesson you learned about return
86:26 - values you learned about the return
86:28 - keyword
86:29 - and you learned about input parameters
86:32 - and how to specify them what argument
86:34 - labels are what parameter names are and
86:37 - also how to omit argument labels
86:39 - altogether
86:42 - i hope you enjoyed this lesson if you
86:44 - did please give the video a thumbs up
86:46 - and please subscribe for more
86:50 - hello welcome to learn swift for
86:52 - beginners lesson nine in this video
86:54 - you're going to be introduced to classes
86:56 - which is an absolutely critical part of
86:59 - the swift programming language if you're
87:00 - going to be using it to build apps
87:03 - i'll tell you all about it let's get
87:05 - started
87:09 - so i'm going to start off with a
87:11 - hypothetical example so let's say you
87:14 - have something like a blog post which
87:16 - you would like to represent we might
87:18 - have something like a variable here
87:21 - for blog title right blog title can be
87:24 - hello playground i don't know what kind
87:26 - of article that would be
87:28 - but we would have another variable for
87:31 - the blog body and this is the you know
87:34 - text of the article or the blog post
87:37 - and then we might have something like
87:39 - blog
87:40 - author
87:42 - which in this case let's just put my
87:44 - name here
87:45 - so you can see here
87:47 - this is the data for
87:48 - one blog post
87:50 - now let's say i had two blog posts what
87:53 - what would i do in this case
87:55 - i might have another set of variables
87:57 - down here and of course i can't have the
88:00 - same variable names
88:01 - so let's just append two to these
88:07 - these variable names
88:10 - and let's say this is
88:12 - i don't know
88:13 - this article is goodbye playground okay
88:17 - now this is what i have for two blog
88:19 - articles now what if i had 10 what if i
88:22 - had a 100 how many variables would i
88:24 - have then it it'd be a ton right it'd be
88:27 - a mess
88:28 - there needs to be a better way to
88:30 - represent a blog post to kind of group
88:33 - these variables together
88:34 - and there is
88:36 - in fact that's what a class is
88:38 - you know how you learned about the
88:40 - different data types back in lesson two
88:43 - you learned about the string data type
88:45 - you learned about the int data type
88:47 - float double boolean
88:49 - all of those are data types to represent
88:51 - different types of data right
88:53 - well with classes you can define your
88:56 - own custom data type so what we're going
88:59 - to do here is we're going to create our
89:01 - custom data type
89:04 - called blog post for example
89:06 - you can do that with classes
89:09 - let's take a look at the syntax for
89:11 - declaring a new class
89:14 - so first of all you have the class
89:16 - keyword
89:17 - next you have the name of the class and
89:20 - this is going to be the name of your
89:22 - data type then you follow by two curly
89:26 - brackets
89:27 - and inside those two curly brackets
89:30 - is your class definition
89:33 - let's take a look at this back in our
89:35 - playground
89:36 - so for example
89:40 - up here let's create
89:42 - and define our class so first i would
89:45 - use the class keyword
89:46 - and then i would create a
89:50 - name of the data type or the name of the
89:52 - class in this
89:54 - case let's put blog post and notice that
89:57 - this time i'm starting off with a
89:59 - capital letter in fact all of the data
90:02 - types in swift start off with the
90:04 - capital letter so we should follow the
90:06 - same convention always start off your
90:08 - class names with a capital letter and
90:11 - that's different from what we've been
90:12 - doing with variables and constants and
90:15 - functions
90:17 - okay then i have these two curly
90:19 - brackets like that
90:21 - what do i put inside of my blog post
90:24 - class
90:25 - well
90:26 - why don't we put
90:29 - this stuff right here i'm just going to
90:32 - cut it
90:33 - and i'm going to paste it inside here
90:36 - and then i'm going to delete this right
90:38 - here
90:40 - and i am going to
90:42 - delete this text
90:46 - inside these variables inside my class
90:51 - and leave them empty and i'm going to
90:53 - explain why in a second
90:55 - okay so just like that we've defined a
90:57 - class called blog post
90:59 - and this class has three properties
91:02 - now a property is just a variable
91:05 - declaration like this but inside a class
91:08 - it's called a property and you're going
91:10 - to see why in a second why it makes more
91:12 - sense
91:13 - and because
91:14 - um this blog title blog body blog author
91:18 - is inside
91:20 - of blog post it it's kind of redundant
91:22 - to name them like this
91:24 - so i'm just going to name them title
91:27 - body and author like that
91:30 - okay so this
91:31 - this represents our blog post right here
91:35 - now that you've defined what a blog post
91:37 - is let's create an actual blog post
91:39 - because remember this class definition
91:42 - right here this is just
91:44 - a definition of a data type you're
91:46 - defining what a blog post data type is
91:50 - right so that's not an actual
91:53 - blog post just like how this is a string
91:57 - that's not the definition of a string
91:59 - that's an actual string so
92:01 - in order to create an actual blog post
92:05 - we're going to type in the class name
92:07 - followed by two rounded brackets like
92:10 - that and just like that this is a new
92:13 - instance of the blog post type
92:16 - and it's called an object or blog post
92:19 - object
92:21 - so when you define a new class using the
92:23 - class keyword that's what's known as a
92:25 - class definition or just class
92:28 - but when you create actual
92:31 - instances of that class
92:33 - those are called objects
92:36 - you can think of your class definition
92:38 - as a template or a blueprint
92:41 - and you use that template to create
92:43 - actual tangible
92:45 - blog post objects
92:48 - so let's jump back to the playground
92:49 - here this is a very important concept to
92:52 - understand
92:53 - we've defined a class called blog post
92:55 - here it's got these three properties or
92:58 - you can think of them as attributes of a
93:00 - blog post and then down here like this
93:02 - we've created a new blog post object now
93:06 - this blog post object has
93:08 - a title it has a body and has an author
93:11 - but all of it all of them are empty
93:13 - right now so what we're going to do is
93:15 - we're going to assign this blog post
93:17 - object into a constant let's call it my
93:20 - post like that so what we've done here
93:23 - is we've created new blog post objects
93:26 - we've assigned it to my post
93:28 - and now why don't we try setting the
93:30 - title of this blog post and the body and
93:33 - the author
93:34 - what we would do is say my post
93:37 - right that's referring to this new
93:38 - object and then we press dot
93:41 - and that lets us access those properties
93:44 - which we've defined in the class
93:45 - definition
93:47 - set the title
93:48 - to
93:51 - i don't know hello playground i think
93:53 - that's what we had before
93:54 - let's set the author of this one
94:00 - and let's set the
94:02 - body to
94:05 - hello
94:06 - okay just hello
94:08 - now if i print
94:10 - my post dot
94:13 - author
94:15 - i would get my name
94:18 - now let me show you something else we
94:20 - can create a second
94:23 - instance
94:24 - of blog post or a second blog post
94:26 - object and let's call this my
94:30 - second post and we're going to set this
94:33 - to a new blog post object like that
94:36 - and we're going to say my second
94:38 - post.title
94:40 - equals
94:42 - goodbye
94:44 - playground and
94:47 - we can set the author to
94:49 - someone else let's say
94:51 - um
94:53 - john travolta i don't know why that
94:55 - suddenly popped into my head
94:57 - and
94:59 - uh let's just do hello again
95:02 - now
95:03 - this is a second
95:05 - my post object this is
95:08 - different from my post these are
95:10 - completely
95:10 - two
95:11 - different blog post objects
95:15 - both of them contain these three
95:18 - properties which we can set because
95:19 - that's what we've defined here in this
95:21 - class
95:23 - now another very cool thing about
95:26 - classes is that you can put functions in
95:29 - them
95:29 - right you can see how all of the lessons
95:31 - so far are coming together
95:33 - let's create a new property for this
95:35 - first let's say
95:37 - a number of comments equals zero this is
95:41 - the number of comments in the blog post
95:43 - and we're gonna define a new function in
95:45 - this
95:46 - blog post class we're gonna say
95:48 - add comment okay
95:50 - and we're not gonna worry about the
95:52 - comment text just yet
95:54 - let's just define this
95:57 - so notice that in my function definition
96:00 - i have these two curly brackets again
96:02 - inside here this is going to be my
96:04 - function code so inside this function i
96:07 - am just going to increase the number of
96:10 - comments by one this is all stuff that
96:13 - you should have learned already in the
96:14 - previous lessons
96:16 - now okay so now every single blog post
96:19 - object is going to have this function
96:22 - now how do we access it
96:24 - we simply go my
96:28 - post
96:29 - dot you can see now in the autocomplete
96:32 - that there is this function called add
96:35 - comment and it doesn't have any return
96:38 - value it doesn't return anything so the
96:40 - return type is void right there
96:42 - let's call this function okay
96:44 - see what happens so add comment
96:47 - you can't visibly see what happens but
96:49 - let's print
96:50 - my post dot
96:52 - number of comments
96:55 - you can see that it's one
96:57 - okay now let's print
97:00 - my
97:02 - second post
97:03 - dot number of comments
97:05 - what would you expect
97:07 - this to print out
97:12 - it prints out zero
97:14 - why because we haven't called the add
97:17 - comment function on my second post
97:20 - we just did that with the first post
97:23 - each of these blog post objects
97:25 - maintains its own properties
97:28 - changing the properties of one object
97:30 - does not affect the other even though
97:32 - they're cut from the same cloth right
97:34 - they're both types of blog posts they're
97:38 - two independent entities and they
97:40 - maintain their properties separately
97:43 - now there's a lot more to classes but
97:45 - fundamentally i want you to understand
97:48 - what they are
97:49 - so i'm not going to make this video any
97:51 - longer than it needs to be i just wanted
97:53 - to introduce classes to you i hope you
97:56 - can see why classes are a fundamental
97:59 - building block to organize your
98:00 - information so thanks for watching
98:03 - please give this video a thumbs up if it
98:05 - helped you and please subscribe for more
98:08 - hello welcome to learn swift for
98:09 - beginners lesson 10. in this video
98:11 - you're going to learn about inheritance
98:13 - otherwise known as subclassing which
98:15 - allows us to build upon previous classes
98:18 - which we've already defined and it saves
98:21 - us a lot of time and effort and work so
98:23 - that we don't have to keep defining
98:24 - classes that do similar things okay so
98:27 - let's get started and see how this works
98:33 - let me start by doing a small recap of
98:36 - what you've learned in this series so
98:37 - far so you learn about variables and
98:40 - constants to store and keep track of
98:42 - data you also learned about some control
98:44 - flow and conditional statements so that
98:46 - you can express logic and make decisions
98:48 - with your code and then you learn about
98:50 - functions where you can define blocks of
98:53 - code that perform specific tasks as a
98:56 - way of organizing your code into more
98:58 - manageable chunks and then you learn
99:00 - about classes which is
99:03 - further away where you can organize
99:05 - related code and related functions
99:07 - together as well as related variables
99:10 - in the form of properties and then today
99:12 - you're going to learn about inheritance
99:14 - aka subclassing as a way to further
99:17 - organize your code okay so let's take a
99:20 - look at uh inheritance in a playground
99:23 - so i'm going to launch xcode here i'm
99:26 - going to get started with
99:27 - a brand new playground and let's call
99:30 - this
99:32 - inheritance playground
99:35 - okay let's just save it on my desktop
99:37 - there and get rid of this line of code
99:40 - so let's say that the app we're building
99:42 - is kind of like a car simulator or
99:44 - something like that and we need to
99:46 - define a class that represents a car
99:49 - so we're going to start by creating a
99:52 - car class just like that
99:54 - and some of the things that it may have
99:57 - is for example it needs to keep track of
100:01 - a top speed right because different cars
100:03 - may have different
100:05 - ranges for the top speed
100:07 - i'm just going to initialize that to 200
100:10 - so there may be a whole ton of other
100:12 - attributes or properties to do with cars
100:15 - but
100:16 - for demo purposes i only need one so i'm
100:18 - not going to go further than defining
100:20 - top speed there and i want to define a
100:23 - function so
100:24 - a car
100:25 - by definition is a vehicle that can be
100:27 - driven right so i'm going to create a
100:30 - function
100:32 - called drive
100:34 - just like that it doesn't accept any
100:36 - parameters
100:37 - and inside this function it's going to
100:39 - perform all the code that
100:42 - we need to drive a car
100:44 - but you know for this demo i'm just
100:46 - going to print
100:48 - driving at
100:51 - and then i'm going to put in top speed
100:55 - like that so this
100:58 - um this value in this top speed property
101:00 - gets substituted in there and then it
101:02 - prints out driving at whatever this
101:04 - value is 200. so when i call the drive
101:08 - function it's going to print this
101:09 - statement out into the console
101:12 - okay so we've defined our class here
101:14 - that represents a car
101:16 - and in the previous lessons you've
101:18 - learned about how to create a new object
101:20 - right from the car class
101:22 - so
101:23 - why don't we declare a constant
101:27 - called my ride
101:29 - and we're going to create a new car
101:31 - object and assign it into the constant
101:34 - myride
101:36 - just like that we've created a new car
101:37 - object now let me try
101:40 - accessing
101:42 - top speed right you press dot and then
101:44 - you can access the
101:47 - property there so you can see
101:49 - it's running the playground okay you can
101:51 - see 200 there and let's try calling the
101:54 - function myride.drive
101:58 - that
101:59 - and you can see it says driving at 100.
102:02 - okay so now let's say that in this
102:05 - driving simulator app i also have
102:08 - something called a super car or maybe a
102:11 - future car so it's the car of the future
102:15 - for example and it can fly so it's the
102:17 - flying car that it will probably come in
102:20 - the future so we can define another
102:22 - class to represent that and we can call
102:25 - it future car right
102:28 - and again this future car because it is
102:30 - a car still it's going to have a top
102:33 - speed and let's say this top speed is
102:35 - 250 like that
102:36 - and it's also got a function
102:39 - called
102:40 - drive and because you can still drive
102:43 - this car
102:44 - and again it's just going to print you
102:46 - know driving at
102:51 - top speed
102:54 - and also this car can fly
102:57 - so let me define another function that
102:59 - represents
103:01 - you know
103:02 - uh flying the car so
103:05 - flying i'm just gonna call it flying
103:06 - like that
103:07 - uh so here we've defined our car class
103:10 - we've defined a future car right here
103:14 - if i want to create another
103:18 - um let's call it my new ride this is a
103:21 - constant and this time i'm going to
103:23 - create a new future car object like that
103:27 - and then my new ride you can see
103:30 - has fly now right it has drive and it
103:32 - has top speed now let me ask you this
103:34 - question see you can see the
103:36 - similarities between car and future car
103:39 - right they both have the properties of a
103:42 - basic car like a top speed and they both
103:45 - have this drive function which is very
103:47 - very similar in fact it's actually
103:49 - identical so this is pretty redundant
103:52 - right there's a lot of redundancy
103:54 - between these two class definitions so
103:56 - this is where inheritance or subclassing
103:59 - comes into play and is very helpful
104:02 - so what inheritance allows us to do is
104:04 - say that
104:05 - one
104:06 - class inherits from another class
104:10 - and
104:11 - essentially what that means is that
104:13 - if future car inherits from car it's
104:16 - going to inherit its properties and
104:19 - functions so you don't need to redefine
104:21 - them inside future car so let me show
104:23 - you what i mean here
104:25 - let's in future car let's delete this
104:28 - top speed property and let's delete this
104:30 - drive function
104:32 - and what i'm going to do instead is i'm
104:34 - going to make
104:35 - future car inherit from car and the way
104:38 - you do that is after the
104:41 - class and then class name you put
104:45 - colon like that and then you put uh the
104:48 - the class that it inherits from so in
104:51 - this case i would put car
104:53 - so in this sort of relationship we have
104:55 - car at the top
104:57 - um and we have future car at the bottom
104:59 - inheriting
105:01 - all of the properties and the functions
105:03 - from the car class in this case future
105:06 - car would be called a subclass of car
105:09 - and car would be called the superclass
105:12 - of future car
105:13 - and some people might call it the parent
105:15 - class
105:16 - so carr
105:17 - is the super class or the parent class
105:21 - or maybe simply the parent of future car
105:25 - let's go back to our playground and take
105:27 - a look at what this means
105:29 - for our code here
105:31 - so you can see that my ride is still a
105:34 - car object and it still has top speed
105:36 - and it still has drive
105:38 - but take a look at
105:40 - my new ride right it's a future car
105:43 - object
105:44 - and remember inside future car we've
105:46 - just defined fly we haven't defined
105:48 - anything else in here
105:50 - but if i type in my new ride and i
105:53 - press dot here and let autocomplete do
105:56 - its thing you can see that future car
105:59 - actually has a drive function and
106:01 - actually has a top speed
106:03 - so
106:04 - you know if i do top speed
106:06 - you can see it's 200 and if i do drive
106:10 - you can see that now future car or my
106:12 - new ride rather is also driving at 200
106:15 - and furthermore
106:17 - actually my new ride can also fly
106:21 - okay so there's flying
106:23 - now there's actually a problem here
106:25 - because
106:26 - right now my car and my future car
106:29 - they're both driving at the same speed
106:30 - but remember the future cars are faster
106:33 - right initially i wrote the top speed
106:35 - was 250.
106:36 - so in this case what we can do is to do
106:39 - something called overriding
106:41 - and that allows you to take a function
106:43 - or a property from the parent class or
106:46 - the super class
106:48 - and redefine it to
106:50 - essentially that's where the word
106:51 - override comes from so you're overriding
106:54 - the parent's version of that function
106:58 - and you're providing your own
106:59 - implementation or your own version of it
107:02 - now let me just do it here so you can
107:04 - see what it means so
107:06 - we use the override keyword like that
107:09 - and then we have to declare drive
107:12 - exactly as it is in the parent class so
107:15 - uh
107:16 - what we're doing is we're going to say
107:20 - print driving at and we're going to
107:23 - instead say top speed plus
107:27 - 50
107:28 - because this guy goes faster so now you
107:30 - can see that when i call
107:32 - this guy when i call
107:34 - futurecar.drop
107:36 - it doesn't use
107:38 - the parent class's drive function it
107:41 - uses its own overridden definition of
107:44 - what drive is
107:46 - right so that this is the code that it's
107:48 - running here
107:49 - and you can see it's driving at 250.
107:53 - okay so that's an example of overriding
107:55 - to provide
107:56 - your own custom functionality
107:58 - now inside this overridden method there
108:01 - is
108:03 - a way that we can access still
108:06 - the parent functionality and you can do
108:09 - that by using the keyword super so let
108:13 - me show you what i mean
108:15 - inside this overwritten drive function i
108:18 - can actually access the parent class
108:22 - the definition
108:24 - all the functions and properties in
108:26 - there if i type in super dot
108:29 - and then i can access drive so when i do
108:32 - this super refers to the parent class or
108:34 - the super class
108:36 - and this drive function is actually
108:38 - calling this guy up here
108:40 - right so in this case it doesn't make
108:42 - sense you can see in the console
108:44 - when i type in futurecard.drive it
108:47 - you know it calls the original
108:48 - definition of drive and then it prints
108:50 - this
108:51 - you know its own definition of drive so
108:54 - you know in this example it doesn't
108:55 - really make sense but sometimes when
108:57 - you're building your apps
108:58 - what you want to do is add functionality
109:01 - and not override the functionality if
109:04 - that makes sense so you don't want to
109:06 - replace
109:07 - what's
109:09 - in the parent class you just want to add
109:11 - to it and so you can do that if you you
109:14 - know you can call the original
109:15 - definition and then you can add your own
109:17 - code before or after that
109:19 - to provide additional functionality so
109:22 - in this case maybe i'll just change the
109:23 - statement here
109:25 - and
109:29 - boosting at
109:31 - you know 50 or something like that so
109:33 - let's see
109:37 - so now you can see that
109:39 - this is my original car right when i
109:42 - call drive it says driving at 200 and
109:44 - then my future car is driving at 200
109:47 - and it's doing something extra
109:50 - and so that's that's how this overridden
109:52 - function works
109:54 - okay so this is a simplified example of
109:56 - how subclassing works
109:58 - but it's essentially how it works and
110:01 - it's very predominant in the swift
110:03 - programming language as i'm going to
110:04 - show you in the next lesson
110:06 - as you can see inheritance allows you to
110:09 - save a lot of work by taking what's
110:11 - already there
110:12 - and then improving it or providing you
110:15 - know alternate definitions so you don't
110:16 - have to redefine everything all over
110:18 - again but you can build upon the classes
110:21 - that you already have okay thanks for
110:23 - watching please help me continue to
110:25 - create more videos for you by giving
110:27 - this video a thumbs up and subscribing
110:28 - to the channel
110:30 - hello welcome to lesson 11 of the learn
110:33 - swift for beginners series in this
110:35 - lesson i want to introduce to you ui kit
110:38 - it's an apple framework that contains
110:40 - many of the classes we're going to need
110:42 - in order to construct ios apps
110:45 - alright so let's dive in and see what's
110:46 - available in ui kit
110:51 - so like i mentioned in the intro for
110:53 - this video the ui kit framework is
110:57 - essentially a library of classes that
110:59 - apple gives us to build apps with when
111:01 - you think about it there are a lot of
111:03 - common elements to any sort of app for
111:05 - example
111:07 - apps may have views they may have
111:08 - buttons you know all apps are going to
111:10 - have
111:11 - things that you need to present to the
111:13 - user
111:14 - apps are going to need to handle user
111:17 - interaction from the person using the
111:19 - app and so on and so forth so
111:21 - to build that functionality out every
111:23 - single time you're going to build an app
111:25 - is extremely tedious and not to mention
111:28 - complex and complicated so apple has
111:31 - provided ui kit for us to use
111:33 - and it contains a ton of pre-built
111:35 - classes for us to handle all of these
111:37 - common things
111:39 - so here i'm looking at the ui kit
111:41 - reference guide
111:43 - which contains a list of all of the ui
111:45 - kit classes that are available for us to
111:48 - use i'll link to it in the description
111:50 - below the video but if you want to look
111:52 - for it yourself
111:53 - just go into google and type in apple
111:55 - space ui kit don't just type in ui kit
111:58 - because
111:59 - the first few results for that query
112:02 - isn't the apple ui kit so just type in
112:04 - apple space ui kit to find the
112:07 - correct one in the first result
112:10 - it was also essential to learn about
112:13 - inheritance before i told you about ui
112:15 - kit because many of these classes
112:17 - inherit from each other they build off
112:19 - of each other
112:21 - so they don't redefine things and
112:24 - this reference guide used to be kind of
112:27 - organized in a hierarchy so you could
112:29 - see which classes inherited from other
112:32 - classes but since they've
112:34 - changed it and they've made it kind of a
112:36 - listing so you don't get that but i did
112:37 - a google search and i found
112:40 - an image that i'm sure this is not the
112:43 - complete
112:44 - ui kit because this image was from 2012
112:48 - i think
112:49 - yeah you can see here in the url it's
112:51 - from 2012 but it does
112:54 - give you an idea of how the classes are
112:56 - organized so you can see at the very
113:00 - top of this tree if you can imagine
113:04 - this left side being kind of at the top
113:06 - of the tree
113:07 - and this right side being the bottom of
113:09 - it if you take for instance this ui
113:12 - button class which represents a button
113:14 - that the user can tap on the screen ui
113:17 - button inherits from ui control which
113:20 - inherits from ui view
113:23 - and if you just follow this line it
113:24 - inherits from ui responder and finally
113:27 - from ns object
113:29 - so that ui button class is a culmination
113:32 - of all of that functionality you know
113:35 - from that chain and
113:37 - let me just take a little moment to
113:39 - explain
113:40 - it to you so you can see how that ui
113:42 - button class is finally constructed so
113:44 - this ns object class is the root class
113:47 - of everything you can think of it as the
113:48 - big grandfather or granddaddy and what
113:51 - this ns object class does is it provides
113:54 - that basic functionality that allows you
113:56 - to create an object from a class
113:59 - definition so that's something we went
114:01 - through
114:02 - in part one of the classes lesson so
114:04 - this ns object class kind of gives you
114:07 - that functionality and if we take a look
114:09 - at what was the next one down the chain
114:12 - so the ui responder class so this ui
114:15 - responder class inherits from ns object
114:18 - means that it contains that foundation
114:20 - that's going to be needed by you know
114:23 - all of these ui elements or user
114:25 - interface elements
114:27 - okay so the next one down is a ui view
114:30 - so ui view inherits from ui responder
114:32 - which inherits from ns object so ui
114:34 - uiview gets all of that functionality
114:36 - and on top of that
114:38 - the ui view class provides functionality
114:41 - for displaying something onto a view so
114:45 - a ui view is
114:46 - something that you can show to the user
114:49 - so it contains all of that functionality
114:51 - and code and then next in that hierarchy
114:54 - down to the ui button we have ui control
114:56 - now ui control contains all of that
114:59 - functionality before it following this
115:01 - line here
115:03 - and on top of that contains
115:05 - basic code and functionality for a user
115:08 - element control
115:10 - so stuff that is specific for
115:13 - displaying onto a view
115:15 - handling user interaction and events
115:19 - and responding
115:20 - so then we have a specific type of ui
115:23 - control and that is the ui button which
115:26 - is pretty self-explanatory looks and
115:28 - behaves like a button with certain
115:31 - button events
115:32 - so that's just one example of you know
115:35 - the path you can see that there's a
115:37 - whole ton of classes and there's even
115:39 - more now so whenever you go and you know
115:42 - before you go and do something with your
115:44 - app
115:45 - chances are
115:46 - you can probably leverage something from
115:48 - ui kit to build off of rather than
115:51 - building something from scratch
115:53 - so in this video i just wanted to give
115:55 - you guys an introduction to ui kit
115:57 - because we're going to be using a lot of
115:59 - classes from here and every time i do i
116:02 - will try and remember to reference this
116:04 - guide or at least link to it so you can
116:07 - take a look at these classes
116:09 - it's very useful and handy to have at
116:12 - your fingertips
116:13 - because you can click into these classes
116:16 - and then you can find out for this ui
116:19 - button class what sorts of functions it
116:22 - has and properties it has that you can
116:24 - use and leverage and how you can perform
116:26 - specific things with the button or with
116:28 - that class
116:29 - and furthermore i might do another video
116:32 - series where we go over specifically
116:36 - different ui elements
116:39 - because i think that would be useful for
116:40 - beginners to understand how to use for
116:43 - example like a date picker or text field
116:45 - or slider or switch or something like
116:47 - that
116:48 - so that might be a separate series on
116:50 - just ui elements
116:52 - please give this video a thumbs up and
116:54 - subscribe to my channel to help channel
116:56 - grow
116:57 - hello welcome to learn swift for
116:59 - beginners lesson 12. in this video we're
117:02 - going to talk about initializer
117:04 - functions for classes
117:06 - these guys exist to make sure that when
117:08 - you create a new object from your class
117:11 - that that object is ready to be used
117:14 - plus you can customize these initializer
117:16 - functions to set up the object any way
117:18 - you want when you create a new instance
117:20 - of the class
117:22 - let's get started and see what that
117:23 - means
117:26 - [Music]
117:28 - so what i've got here is a playground
117:30 - and i wrote down a basic class here
117:33 - called person
117:35 - and this person class has got two
117:37 - properties right now it's got a name
117:39 - property which i've initialized to an
117:42 - empty string
117:43 - and also it's got an age property which
117:46 - i've set to zero and that is an integer
117:50 - now you learned about classes in a
117:52 - couple of lessons back and you learned
117:54 - about how we create objects from classes
117:57 - right
117:58 - and in order to create a new person
118:00 - object i would say something like
118:03 - var
118:04 - let's just use the variable
118:06 - a
118:07 - equals person
118:09 - like that and we open up and close
118:12 - brackets um beside the class name like
118:15 - that and here i've got a brand new
118:17 - person object
118:18 - and if i go a dot name
118:20 - you can see that it's an empty string
118:22 - and if i go a dot age you can see that
118:25 - it's zero
118:27 - so what's actually happening when you
118:29 - create a new person object here and you
118:31 - write these brackets don't these two
118:33 - brackets look like you're calling a
118:35 - function but actually what's happening
118:37 - is you're calling the initializer
118:39 - function of the person class but you
118:41 - might ask we don't have one defined in
118:43 - here what initializer function are you
118:45 - talking about let me write it out by
118:47 - default it exists
118:49 - and if you don't customize it you don't
118:51 - really have to touch it but that
118:53 - initialization function looks like this
118:55 - it just uses the keyword in it and it
118:57 - has these two brackets and then
119:01 - in here in between this just like a
119:03 - function you can define code
119:05 - in here
119:06 - to set up your object
119:11 - so what's happening
119:12 - when you
119:13 - create a new person object with this
119:16 - line of code here is you're actually
119:18 - calling this init function of the person
119:22 - class and inside here you can actually
119:24 - write code to customize things so for
119:27 - example i can say name equals chris
119:31 - and age equals
119:33 - i
119:34 - believe i'm 33 i think i've lost track
119:37 - but
119:38 - so what's going to happen here when i
119:40 - create a brand new person object is it's
119:44 - going to call this init function and
119:46 - it's going to set these two properties
119:47 - to these two values here so as you can
119:49 - see now
119:51 - name is chris and age is 33 when i
119:54 - create a brand new person object
119:57 - now remember how i said that you can
119:58 - actually customize the init function to
120:01 - set up the object the way you want it to
120:03 - be set up
120:04 - and we can do that simply by adding some
120:07 - parameters into this init function just
120:09 - like we would
120:11 - for any function that we set up so for
120:13 - example i can say
120:16 - i can say n
120:18 - is a string
120:19 - and a is an in
120:22 - so now i have to pass in these two
120:24 - values so let me just erase this part
120:26 - here
120:28 - and i'm going to create a new person
120:30 - object and now you can see that the
120:32 - autocomplete shows me this
120:35 - so for name i pass in chris
120:37 - and for the int i'll pass in 33 but
120:41 - instead of setting this stuff to the
120:43 - hard-coded values now i can set up to
120:45 - what is being passed in here
120:47 - so that's n
120:49 - and that's a
120:50 - right when i'm creating a new person
120:52 - object here i'm passing in these values
120:57 - that go in through this init function
120:58 - and then it sets the properties to those
121:01 - values which i pass in
121:03 - now remember if i don't want these
121:04 - parameter labels all i need to do
121:07 - is go like that and you we learned this
121:10 - through the functions lesson so you can
121:12 - review that
121:14 - if you forget
121:15 - why this is these are the argument
121:17 - labels by putting underscore there we're
121:19 - basically saying we don't need the
121:20 - argument labels
121:23 - now while we're on this topic of
121:25 - specifying these parameters here
121:28 - oftentimes and sometimes i catch myself
121:30 - doing this too is that when we're
121:34 - passing in these parameters the name and
121:36 - age and you're intending to set it to
121:39 - these properties here
121:40 - there's a tendency to name these
121:42 - parameters exactly like
121:45 - the property names because after all you
121:48 - name these property names to be
121:50 - descriptive right of what they represent
121:53 - so in the parameters you might be
121:55 - tempted also to name them the same thing
121:57 - well what happens is you get into this
122:00 - situation where you're trying to set
122:02 - this parameter
122:04 - into this property name but they're both
122:07 - named the same thing so it's a little
122:08 - bit ambiguous so that's where you can
122:11 - use this keyword called self
122:14 - and
122:15 - what how you would use it is you would
122:17 - say self.name
122:19 - equals name so self refers to the object
122:23 - that is being created so you're saying
122:26 - to set the name property
122:28 - of the object to
122:31 - this name parameter so that's how you
122:34 - distinguish between
122:36 - uh if the property name and the
122:38 - parameter name is the same
122:40 - so i would do the same thing here like
122:42 - that
122:43 - so then this age refers to that guy and
122:45 - self.age refers to the actual property
122:48 - there
122:50 - now another thing i want to point out is
122:51 - that
122:52 - i can no longer
122:54 - call
122:55 - person like that
122:58 - because there's no init method like that
123:00 - what i can do is i can actually
123:03 - have multiple
123:05 - initializer methods so if i do this
123:08 - let's let's say this is var b
123:10 - equals this person object well
123:12 - this b
123:14 - dot name
123:15 - is empty and b dot h is zero right
123:18 - because these guys haven't been set
123:20 - after all i'm calling this
123:22 - initializer function here that doesn't
123:24 - set anything
123:26 - whereas this guy this initializer
123:28 - function actually sets the name and age
123:31 - to whatever we pass in
123:33 - now there's one very important thing we
123:34 - haven't talked about yet regarding init
123:37 - functions
123:38 - i mentioned in the intro to this video
123:40 - that the init functions are there to
123:43 - make sure that the object is properly
123:46 - initialized and all of its values are
123:49 - set
123:50 - making the object ready to be used so in
123:52 - this case right here for the person
123:55 - class i've declared two properties and
123:57 - i've already preset them
124:00 - or
124:00 - initialized them to these values here so
124:04 - really the init function has nothing to
124:06 - do even if i did nothing as is
124:09 - in this case right here
124:11 - the object would be ready to use because
124:12 - these properties have values
124:15 - in the next lesson i'll show you how you
124:17 - can sometimes if you need to declare
124:20 - these properties
124:22 - without setting or initializing them to
124:24 - values so it would be something like
124:26 - this
124:28 - you wouldn't write it out like this but
124:29 - just as an example you wouldn't set it
124:31 - to anything so there would be no values
124:33 - in here
124:35 - in that case when you create a new
124:36 - person object
124:38 - the init function would be responsible
124:41 - for making sure that these guys do have
124:43 - a value because if not all of these
124:45 - properties are initialized to values
124:48 - then the object is not considered to be
124:50 - ready to be used so the init function is
124:52 - there to make sure
124:53 - that
124:54 - the values are set
124:56 - and like i said
124:58 - so far you haven't learned about how to
125:00 - declare these
125:01 - properties right here without sending
125:03 - them to values i've always have set them
125:05 - to something but in the next lesson
125:07 - you'll learn how to do that
125:09 - and then we'll dive a little deeper into
125:11 - initializer functions and talk about how
125:13 - there are two types called designated
125:16 - and convenience initializers and so on
125:18 - and so forth okay so thanks for watching
125:20 - remember to give the video a thumbs up
125:22 - and uh subscribe to the channel if you
125:24 - haven't already
125:26 - hello welcome to lesson 13 of the learn
125:29 - swift for beginners series
125:31 - in this video you're going to learn
125:32 - about optionals and it's probably one of
125:34 - the most confusing things for beginners
125:37 - if you've ever looked at swift code and
125:38 - you've noticed exclamation marks or
125:40 - question marks in the code then you've
125:42 - come across optionals so let's get
125:44 - started and find out what it's all about
125:48 - [Music]
125:50 - so right here i have a playground and i
125:52 - have declared a class blog post in fact
125:55 - if you've seen
125:57 - episode nine
125:58 - the first lesson on classes then this is
126:01 - going to look familiar because this is
126:03 - the example that we used for lesson nine
126:06 - when i first talked to you about classes
126:09 - now we declared a couple of properties
126:11 - up here
126:12 - for our blog post class
126:15 - and these properties they represent
126:17 - certain things about what a blog post
126:19 - might have so for example the title the
126:22 - body the author number of comments and
126:25 - you can actually safely ignore this
126:26 - function so i'm just going to remove it
126:28 - because we're going to focus on this
126:29 - stuff up here you'll notice that each
126:32 - time i declare a property right here i
126:34 - immediately initialize it to a value so
126:38 - title body author are all initialized
126:42 - to an empty string right when they're
126:45 - declared and comments is set to zero
126:48 - right
126:48 - right when it's declared
126:51 - now this is all fine and dandy but what
126:54 - if you actually want
126:56 - some of these properties to be empty
126:58 - for example what if i want to tell if
127:02 - the blog post has an author or it
127:05 - doesn't have any author
127:07 - you might argue that well i can just
127:09 - check if author is equal to an empty
127:12 - string and if it's equal to an empty
127:14 - string then maybe there's no author
127:16 - well what if the author isn't actually a
127:19 - string what if it's actually
127:22 - you know we have another class here and
127:24 - we call it
127:25 - person and let's say that
127:27 - there's a name and we'll initialize the
127:29 - empty string but you know okay so in
127:31 - this case
127:33 - person
127:35 - is assigned to author so
127:37 - you know blog post has an as an author
127:41 - because it has this person object so how
127:43 - do we distinguish
127:44 - um there being no author for a blog post
127:47 - well
127:48 - you have to be able to declare an author
127:50 - property and leave it empty because some
127:53 - blog posts may not have an author so the
127:56 - way to do this is if you remember from
127:58 - way back then maybe
128:01 - lesson
128:03 - lesson 2 on data types i think
128:05 - you can actually specify for your
128:07 - variables the specific data type that it
128:10 - can store if you don't specify it
128:12 - basically the data type is inferred from
128:15 - what you assign into it okay so for
128:18 - example if i wanted the title
128:20 - to be able to be empty
128:23 - i would have to declare the type
128:26 - i'd get rid of this equals empty string
128:29 - because we don't want to sign in
128:30 - anything to it right we want to declare
128:32 - this property but leave it empty
128:35 - i would do it like that i would you know
128:37 - do the colon specify the specific type
128:39 - and then i would put question mark and
128:41 - that is an optional right there
128:44 - so
128:45 - when i declare this title is empty
128:48 - and this part basically tells us that
128:52 - the data type of title is string
128:55 - and this question mark
128:57 - attached to the string data type tells
128:59 - us that it could be
129:01 - nil which means nothing or empty it
129:05 - could be nil
129:06 - or it could actually contain a string
129:10 - so contrast this with the body property
129:13 - here this when it is declared is
129:16 - assigned this empty string so it's
129:18 - always going to have a value right
129:20 - whether it's empty string or maybe in
129:22 - the future we assign some text into it
129:25 - it's going to have some text
129:27 - but
129:28 - you know this title
129:30 - property could be empty in fact it is
129:33 - empty right now as we declare it
129:37 - so going back to this example with the
129:39 - author
129:40 - potentially some blog posts may not have
129:43 - an author so we can't just you know
129:46 - initialize the author property to a
129:48 - person object because that would mean
129:50 - all blog posts at least have a person
129:52 - attached to the author right we want to
129:54 - make this property able to be empty
129:57 - right so the way we do that
129:59 - again is we specify the specific data
130:02 - type
130:03 - put the question mark there next to the
130:05 - data type and we get rid of that part
130:07 - because we don't actually want to assign
130:08 - anything to it okay so in this way
130:12 - we have a blog post class
130:14 - which has
130:16 - an optional title property has body
130:18 - which is initialized to
130:20 - an empty string so it at least always
130:22 - has a value
130:23 - uh and it may or may not have a person
130:27 - you know could have nobody assigned as
130:29 - the author or it could actually have a
130:31 - person object assigned as the author and
130:33 - number of comments will always have a
130:35 - value and starting at zero
130:38 - so you're going to want to pay attention
130:39 - now because i'm going to tell you how
130:41 - you should think of these optional
130:43 - properties that we have here and this is
130:46 - sort of metaphor or visual that you can
130:48 - think of
130:49 - that i was taught when i was learning
130:51 - this stuff
130:53 - and that is to think of the title
130:55 - property
130:56 - this optional
130:58 - string it could optionally contain a
131:00 - value or not think of it like a box
131:04 - it's labeled string but you can't see
131:07 - what's inside the box you don't know if
131:08 - there's actually a string object inside
131:12 - or it could just be an empty box
131:14 - it could be an empty gift box if someone
131:17 - if you've been really bad and someone
131:18 - gives you an empty gift for christmas
131:21 - that's never happened to me but if it
131:22 - has to you let me know in the comment
131:24 - section below but anyways you can think
131:27 - of
131:28 - an optional property
131:30 - like a box
131:31 - that may contain the actual object or it
131:35 - may not
131:36 - so how can you find out if there's
131:38 - actually
131:39 - uh the string object inside or not well
131:41 - you have to unwrap that box right you
131:44 - have to unwrap that gift
131:45 - in order to look inside and see and get
131:48 - at the
131:49 - actual object
131:51 - and that's exactly what we have to do in
131:53 - code now with our optional properties so
131:56 - let me let me create a new blog post
131:58 - object here let me say
132:01 - post equals
132:03 - blog post like
132:04 - that and what we're going to do here is
132:08 - we're going to say hey print out
132:12 - post dot body
132:14 - plus
132:16 - i don't know plus hello something like
132:18 - that okay so it basically just prints
132:21 - out hello because body is empty but
132:23 - let's just assign it to something
132:25 - like that
132:27 - so then we have something like hey hello
132:29 - right that totally makes sense because
132:32 - body we've initialized it to hey
132:34 - right
132:35 - when we create
132:37 - uh the blog post object it's already set
132:39 - to hey and then we concatenate hello to
132:41 - it so when we print post dot body plus
132:44 - hello you know you're accessing that
132:46 - property and then you're pending hello
132:48 - anyways that makes sense so
132:50 - we can no longer do that with something
132:53 - like the title
132:54 - right because that's an optional it's
132:57 - it's wrapped up in a gift box and you
132:59 - don't know if it's empty inside or if
133:02 - there's actually a string object inside
133:04 - so you can't blindly use it you have to
133:06 - unwrap that gift box and and check if
133:08 - there's a value or not and then use it
133:10 - so now before we use title we have to
133:13 - check if there's actually a string
133:16 - object or if there's actually a value
133:17 - inside that optional and the way we do
133:19 - that is we do something called optional
133:22 - binding
133:24 - okay so
133:25 - it's kind of like an if statement so you
133:27 - say if
133:28 - but then you use the word let and if you
133:31 - remember
133:32 - using the keyword let is declaring a
133:34 - constant right
133:36 - in fact that's exactly what this is
133:38 - you're declaring a constant here
133:40 - if let
133:42 - actual title
133:44 - equals title
133:47 - and then you open up these curly
133:48 - brackets so
133:50 - what you're doing here is you're testing
133:52 - sorry not title i meant post dot title
133:55 - because this is the
133:56 - optional property here
133:58 - what you're doing here is you're saying
134:00 - that you're testing you're unwrapping
134:03 - this
134:04 - this title property this optional and
134:07 - you're saying if there is
134:10 - a value in there then assign it to this
134:12 - constant called actual title and then
134:15 - inside here um you can use actual title
134:18 - as the value but if there is
134:22 - nothing inside this optional and if you
134:24 - unwrap it and it's empty it's nil
134:27 - then don't execute this code inside so
134:30 - that's why it has an if statement
134:33 - here
134:36 - you're basically testing to see if
134:38 - there's a value inside this optional if
134:40 - there is you assign it to this constant
134:43 - and then you use this constant inside
134:45 - here
134:46 - uh if there isn't then it's just going
134:48 - to skip over this whole if statement so
134:50 - in here we can safely now we can say you
134:53 - know print actual title
134:56 - uh plus
134:58 - um
135:00 - i don't know salute
135:03 - so
135:04 - there is no value
135:06 - in title so it actually skips all this
135:08 - but let let's say for instance we say
135:11 - here post.title equals
135:14 - um yo
135:16 - like that
135:17 - so now you can see when it does this
135:20 - optional binding and it
135:22 - unwraps this title because we have
135:24 - assigned something into it here it finds
135:26 - that hey i unwrapped the optional there
135:29 - is a value i'm going to assign it to
135:31 - actual title so inside this if statement
135:33 - we can use
135:35 - actual title
135:37 - and do this
135:38 - but if i didn't have this line here
135:40 - let's comment this out you can see that
135:42 - it it completely skips this and it
135:44 - doesn't crash
135:46 - or do anything like that because we're
135:48 - safely you know checking if there's a
135:50 - value inside that optional first and
135:52 - then we're using it
135:55 - now there's always
135:56 - different ways of doing things so
136:00 - in the swift programming language
136:01 - there's actually a way to be a cowboy
136:05 - and skip all this if you don't want to
136:06 - check it
136:07 - and you just want to use the value you
136:09 - know you know there's something inside
136:13 - what you can do
136:15 - is you can use
136:18 - you know you're going to not check it
136:20 - you're just going to use it
136:22 - you can
136:24 - be that it would be post dot title
136:26 - and you put this exclamation mark and
136:29 - this is called force unwrapping so what
136:32 - you're telling xcode is you're saying
136:34 - that hey you know i know there's a value
136:36 - in here i don't need to check it i just
136:39 - want to unwrap it
136:41 - right away using this exclamation mark
136:43 - and i want to use whatever is inside of
136:45 - there
136:46 - right in this case it's yo
136:49 - so here we're you know we're accessing
136:52 - post dot title it's an optional property
136:55 - we don't care we're gonna force unwrap
136:57 - that
136:58 - and we're gonna take out that value and
136:59 - use it you know
137:01 - and so if you know there is a value
137:03 - inside you can do that but it gets a
137:05 - little dangerous because for example if
137:08 - there happens to not be a value in there
137:11 - and you're force unwrapping it and
137:13 - you're trying to you know use the value
137:16 - well there's an error because
137:18 - and this is the error you get fatal
137:20 - error unexpectedly
137:22 - right because when you use this
137:24 - exclamation mark you're expecting that
137:26 - there is a value
137:27 - unexpectedly found nil when
137:30 - unwrapping an optional value
137:33 - right that is exactly what i was telling
137:35 - you you're forced unwrapping the title
137:38 - and you're trying to use it but it was
137:40 - actually nil so you actually get a crash
137:42 - and in your career of building apps you
137:44 - probably will see this error
137:47 - unexpectedly found nil so now you know
137:49 - why
137:50 - so the safer way to go would be actually
137:53 - to use optional binding so i'm going to
137:55 - press command z now
137:57 - command z for the americans
138:00 - i'm going to undo
138:01 - undo all right
138:04 - do something like that and this is
138:05 - optional binding so
138:07 - another way
138:08 - where you can test before using is just
138:12 - oops
138:14 - it's just with good old-fashioned if
138:16 - statement and testing if it's nil so you
138:19 - can say something like
138:21 - testing for nil you can say if
138:24 - post dot title
138:26 - is not equal nil
138:29 - then print
138:30 - post dot title and because you have
138:33 - tested it that it's not nil in this if
138:35 - statement you can go ahead and force
138:37 - unwrap that
138:38 - and use it
138:41 - right so that works you can safely
138:44 - use force unwrapping because in this if
138:46 - statement you've just tested that it's
138:47 - not nil
138:49 - okay
138:51 - now the reverse if you want to check
138:53 - that it is nil
138:54 - is post dot title equals equals nil okay
138:57 - it's not equals nil
138:59 - a lot of beginners make this mistake and
139:01 - they use one equal sign but one equal
139:04 - sign is for assignment remember that so
139:06 - if we're going to test for nil you're
139:08 - going to use two equal signs like that
139:10 - and this is like
139:12 - optional
139:14 - contains no value
139:17 - okay
139:18 - optional contains value and in here
139:22 - for optional binding
139:24 - optional
139:26 - contains a value
139:29 - so as with all of the other things we're
139:31 - learning with swift
139:33 - we can go deeper there's additional
139:35 - things to learn about optionals like
139:37 - optional chaining and other ways of
139:39 - using optionals but this is your
139:41 - introduction i wanted
139:43 - to tell you about what the question mark
139:45 - means and what the exclamation mark
139:47 - force unwrapping and how to check an
139:49 - optional before using it
139:51 - i wanted to introduce you to these kind
139:53 - of high level concepts and practically
139:56 - speaking you'll be using them most of
139:58 - the time like this
140:00 - and then in the future we'll touch upon
140:01 - the more complex things about optionals
140:04 - also you might be wondering
140:06 - why why and when you would ever use
140:08 - optionals but let me tell you you
140:10 - definitely will use it when you're
140:12 - building apps and when we do build our
140:14 - apps together you'll know what they are
140:16 - and you'll know
140:17 - how to declare optionals and how to
140:19 - unwrap them and how to check if they're
140:21 - no because you've watched this lesson
140:24 - okay so thanks for watching
140:26 - and please subscribe and thumbs up and
140:28 - share the video with other people you
140:30 - know who want to learn swift as well
140:33 - hello welcome to lesson 14 of the learn
140:36 - swift for beginners series in this video
140:38 - you're going to learn about properties
140:39 - which is something that we have been
140:41 - using already together
140:43 - since the classes lesson but we haven't
140:46 - formally introduced them yet so this
140:48 - video is for that
140:50 - in addition to that i'm going to show
140:52 - you some other cool things you can do
140:54 - with properties that you can't do with
140:55 - variables
140:57 - okay so let's get started
141:01 - [Music]
141:03 - so here i have a playground which
141:05 - defines two classes blog post and person
141:08 - you might recognize this from previous
141:10 - lessons
141:11 - and in both of these classes we've
141:14 - defined some variables here well
141:16 - properties are nothing more than
141:18 - variables that are associated with a
141:21 - class like this
141:23 - so for example in this blog post class i
141:27 - have a title property body author and
141:29 - number of comments and if i create a
141:32 - brand new blog post object from this
141:35 - class let's say
141:37 - let
141:38 - my post equals new blog post like that
141:42 - and then in order to access this title
141:46 - property
141:48 - i would use the dot notation
141:50 - i would say my post dot title and i'm
141:53 - going to assign something to this
141:55 - property and let's just call it title of
141:59 - post like that
142:00 - and in order to retrieve that value from
142:03 - that property i would just
142:06 - use dot notation again
142:08 - and this would return
142:10 - the value inside that property
142:13 - so you can see that property is just
142:16 - like a variable where it stores a value
142:18 - and you can retrieve it but i don't know
142:20 - if i mentioned this before and that is
142:23 - that
142:24 - properties are independent
142:26 - between objects so remember
142:29 - we have defined this blog post class
142:31 - right here and from this class
142:33 - we can create many blog post objects
142:36 - for instance here i've created a blog
142:39 - post object and i've assigned it to my
142:41 - post now let me create a second blog
142:44 - post object
142:45 - i'm going to call this my post
142:48 - 2. and i'm going to create a brand new
142:51 - blog post object from there
142:54 - so i have assigned title of post to the
142:57 - title property of this guy right here
143:00 - right
143:01 - that
143:02 - doesn't affect my new blog post object
143:05 - so
143:06 - i can assign my post to dot title equals
143:12 - another
143:13 - title
143:14 - like that
143:15 - and if i display this title
143:19 - you can see that it shows another title
143:21 - so
143:22 - the
143:23 - properties are really variables that are
143:25 - attached to
143:26 - the blog post objects that i create and
143:29 - although each blog post object has a
143:32 - title property
143:33 - the values that they store are
143:35 - independent of one another
143:38 - okay so the second thing i wanted to
143:39 - point out with properties is that when
143:42 - you're working inside your class so
143:44 - let's say we're working on this blog
143:46 - post class and we create some
143:48 - functions here
143:50 - let's say add comment
143:53 - you know we're going to create a
143:54 - function
143:55 - like that
143:57 - and we're going to create another
143:58 - function maybe called
144:01 - share
144:04 - share article okay these don't really
144:06 - have to do anything i'm just i just need
144:08 - to create two functions for the sake of
144:10 - creating two functions to demonstrate
144:12 - this purpose okay so
144:15 - just disregard what what i'm calling
144:17 - them because they're not really going to
144:18 - do that function
144:21 - okay so what i wanted to point out is
144:23 - that
144:24 - these properties that you define inside
144:26 - the class
144:27 - they can be accessed
144:29 - inside any of the functions inside that
144:32 - class so inside add comment
144:35 - you know i might be performing some code
144:37 - to add a comment
144:39 - and i would be able to access let's say
144:43 - um
144:44 - you know i can print
144:46 - title or something like that right that
144:48 - would access this guy well actually
144:50 - that's an optional so
144:53 - using what we learned let me just force
144:54 - unwrap it
144:57 - but my point is is that i can access
145:00 - these properties here you know or i can
145:02 - print
145:04 - let's say body for example
145:07 - you know and here likewise i can also
145:11 - print body
145:13 - within all of the functions inside this
145:16 - class i can access
145:18 - any of these properties up here and i
145:19 - can set them to from within any of these
145:21 - functions however
145:23 - if you declare a variable inside of a
145:26 - function that is what's called a local
145:29 - variable and the existence of that
145:32 - variable is limited to the scope of that
145:34 - function so what that means in plain
145:36 - english is if i declare a variable here
145:40 - let's say var
145:43 - my comment
145:45 - equals
145:47 - you know some comment like that
145:51 - i would not be able to access this
145:53 - variable
145:54 - inside this function here so if i try to
145:57 - you know print
145:59 - my comment
146:03 - you're going to see it
146:05 - throw an error here
146:07 - saying that
146:09 - my comment was never used oh wait that's
146:12 - regarding this guy right here so this is
146:14 - just an optimization xcode this yellow
146:17 - little triangle means
146:18 - that
146:19 - it's a warning it's not really an error
146:21 - so it's fine xcode is just
146:23 - warning you that you declared this my
146:26 - comment variable and you assigned it
146:27 - something but you never used it so
146:29 - consider
146:31 - consider changing its name to
146:34 - an underscore
146:36 - which
146:38 - which is an optimization but we are
146:40 - going to use it the xcode is just
146:42 - proactive because every time you're
146:44 - typing code it just scans your code and
146:45 - it tries to tell you about these
146:47 - optimizations that you can do okay so
146:49 - that's kind of a side note
146:52 - back to the main point i was trying to
146:53 - make and that is if you look at this
146:55 - error here
146:57 - on use of unresolved identifier my
147:00 - comment that means that xcode doesn't
147:02 - know what you're referring to when you
147:04 - try to print my comment here so even
147:06 - though we declared it here and we
147:08 - assigned it inside this function
147:11 - this variable because you declared it
147:13 - inside here
147:14 - is the scope of this variable
147:17 - or its existence is limited to whatever
147:20 - is
147:21 - inside
147:22 - these two curly brackets you know it's
147:24 - limited to the code inside this function
147:27 - now if i wanted it to be accessible
147:29 - everywhere you know i would
147:32 - create a property
147:34 - and i would use that instead so that's
147:37 - probably something you're going to get
147:38 - used to as you're
147:39 - doing more coding is the scope of where
147:42 - you declare things so this is called the
147:44 - local variable because we're declaring
147:45 - it inside a function and these
147:48 - properties that we declare up here to
147:50 - hold values are accessible
147:52 - inside the whole class
147:54 - so what that means is that let me just
147:57 - delete these two functions for now so
147:59 - what that means is that if you have a
148:01 - function that
148:02 - let's say calculates a result or
148:04 - performs some sort of calculation like
148:07 - for example
148:08 - um
148:09 - add
148:10 - up comment
148:13 - total or comment counts or something
148:15 - like that and the point of this function
148:18 - is to maybe sum up the number of
148:20 - comments that this blog post has
148:23 - and then at the end of the
148:25 - whatever you know you're performing
148:26 - calculations here
148:28 - um do
148:29 - some calculations
148:33 - and come up with as a result
148:35 - arrive at a result
148:38 - now what do you do with that result
148:40 - right
148:41 - um you can either
148:43 - and you learn this in the functions
148:45 - lesson is that you can specify a return
148:48 - value so
148:49 - this um this specifies that when you
148:52 - call add up common counts
148:54 - it's going to return a number for you
148:57 - so now you can say you know return
148:59 - whatever the result is whatever variable
149:02 - it's stored in right you can return it
149:04 - to the caller another thing that you can
149:06 - do to make it
149:08 - accessible later on because remember
149:12 - any variables that you declare inside
149:14 - here are local variables and they live
149:16 - and die
149:17 - inside this function here
149:19 - so if i didn't do the return value route
149:25 - and i arrived at some sort of calculated
149:27 - result and i wanted to save it for use
149:29 - for later on i would probably
149:32 - assign it to a property so i can say
149:35 - number of comments equals
149:37 - whatever result that i arrived at and by
149:40 - doing this when i call this function
149:42 - it's going to do some calculations
149:43 - calculate the result
149:45 - the total number of comments right and
149:46 - it's going to assign it into this
149:48 - property
149:49 - and now
149:51 - i can use the number of comments in
149:53 - other functions or later on
149:56 - if i left it as a local variable
150:00 - it would again when this function
150:02 - finishes that would be lost
150:05 - okay so that's the difference between
150:08 - the lifetime or the scope of property
150:11 - versus local variables
150:14 - and now for the third thing that i want
150:16 - to show you in this lesson is something
150:18 - called computed properties and it's one
150:20 - of those things that makes properties a
150:22 - little more special than just plain old
150:24 - variables here
150:26 - so let me
150:27 - let me get rid of these two here so that
150:29 - we kind of start fresh and we're back to
150:32 - where we started in this lesson
150:35 - you can do what's called a computed
150:37 - property and what that is is it just
150:40 - returns
150:43 - and what that is is it lets you do some
150:46 - calculation and return a result when you
150:48 - call a property so let me demonstrate
150:50 - here so let's say that we have
150:55 - let author equals
150:57 - person
150:58 - right so there is our author and let's
151:00 - set
151:01 - the author's name
151:03 - to
151:04 - chris ching which is my name
151:07 - and now let's create a blog post my post
151:10 - equals blog post
151:13 - okay and
151:15 - now let's assign the author
151:21 - property of the post right let's assign
151:25 - author into it
151:27 - now author right here is
151:30 - this person
151:31 - right this person object that i created
151:35 - and
151:36 - finally let's set the title
151:41 - to let's say
151:44 - learn
151:45 - swift for
151:47 - beginners
151:49 - okay so what do we have here we have an
151:51 - author object which has the name set to
151:53 - chris ching we have a blog post object
151:56 - uh
151:57 - with the author set to this person
152:00 - object that i created and i also set the
152:02 - title to learn swift for beginners
152:04 - now
152:05 - what i wanted to show you is
152:08 - i'm going to create a computed property
152:11 - up here
152:12 - i'm just going to add a comment so that
152:15 - just to make it stand out a little bit
152:18 - so i can say var
152:19 - full title
152:22 - is a string and i'm going to open up a
152:25 - set of curly brackets right
152:28 - uh right after it
152:30 - and what i'm going to say
152:32 - is
152:35 - check if title and author
152:39 - aren't not nil
152:45 - check
152:46 - that title and author are not nil
152:48 - because
152:49 - title is an optional right an author is
152:52 - also an optional and you learned about
152:55 - these in the previous lesson
152:57 - so you know what they mean they could
152:59 - return nil which is nothing right when
153:02 - you unwrap it
153:03 - so i'm going to use an if statement just
153:05 - to check
153:06 - so if
153:07 - title
153:08 - is not equal to nil
153:10 - and
153:12 - and that's the double ampersand which
153:15 - represents an end condition
153:18 - so if title is not nil
153:22 - and author is also not nil both of these
153:25 - conditions have to be true
153:26 - then i'm going to run this code inside
153:29 - then
153:30 - return
153:32 - title and remember because title is
153:35 - an optional
153:37 - string right that means i have to unwrap
153:39 - it to get the value inside and i'm going
153:42 - to use the exclamation mark to force
153:44 - unwrap it that means i'm going to tell
153:46 - xcode i'm just going to unwrap that
153:48 - optional and use whatever is inside
153:50 - whether it's a value or it's or whether
153:52 - it's nil
153:53 - and i know for a fact that it's not nil
153:55 - because i just checked it up here right
153:57 - so i can safely and confidently do this
154:00 - so i'm going to say
154:02 - bye
154:04 - and then plus
154:06 - and i'm going to do the same thing with
154:08 - author i'm just going to force unwrap it
154:10 - and use it
154:11 - okay so let's see what it's saying here
154:15 - cannot be applied to string
154:18 - and person that's right okay so author
154:20 - is a person right so i can't
154:23 - i can't append a person object
154:26 - to the string what i'm meant to do
154:28 - actually
154:29 - is
154:30 - i meant to unwrap the author right to
154:32 - get the person object and then call its
154:35 - name property so that's what i actually
154:37 - wanted to do
154:40 - okay so
154:41 - right here xcode is complaining that
154:43 - missing return in a function expected to
154:46 - return a string
154:47 - so this computed property here when it
154:50 - gets called full title
154:52 - it's supposed to return a string
154:54 - and if title is not nil an author is not
154:57 - nil it is going to return a string
155:00 - but what if one of these things
155:02 - are nil
155:03 - either or
155:05 - um in that case i'm just going to use
155:08 - the else branch here
155:09 - i'm just going to return
155:12 - let's say
155:14 - let's do another check else if title is
155:17 - not nil
155:19 - oops not equals nil
155:23 - then return just the title
155:26 - oops force and wrap that
155:28 - finally if the title is nil then i don't
155:32 - know what we can do other than
155:34 - return an empty string
155:37 - or let's say no title
155:41 - let's do that okay
155:43 - so this is awesome now this is a
155:45 - computer property and
155:47 - i hope you can see that from this
155:49 - demonstration what that means
155:51 - it's a property where basically you can
155:54 - perform some code you can do some
155:56 - calculation you can combine a bunch of
155:57 - things
155:59 - and return
156:01 - a result return something so
156:04 - if i say
156:06 - down here
156:08 - if i say my post
156:10 - dot
156:11 - full title what do you think it's going
156:13 - to display
156:18 - let me print it out because it's kind of
156:20 - truncated over here
156:22 - let me use the print so it prints down
156:25 - in the console
156:27 - it's learn swift for beginners by chris
156:29 - ching
156:31 - and i didn't have to set that right
156:33 - because this is a computed property this
156:36 - full title property is calculated by
156:39 - grabbing the title
156:41 - and appending by and then appending the
156:44 - author name
156:45 - and if we didn't have an author so let
156:47 - me just
156:49 - let me just get rid of this line here
156:51 - for setting the author if we didn't have
156:54 - an author it would just print out the
156:55 - title
156:56 - and if i get rid of the title and it
156:59 - doesn't have a title then it's going to
157:01 - print no title and that's all of this
157:03 - logic here in my computed property
157:07 - okay so that's computer properties
157:09 - there's also
157:10 - additional things which we won't cover
157:12 - in this lesson we'll probably do another
157:14 - video on properties and that is getters
157:17 - and setters and property observers but
157:21 - this is a really great start to taking a
157:23 - look at properties so thanks for
157:25 - watching please like the video and
157:27 - please subscribe
157:29 - hello welcome to lesson 15 of the learn
157:32 - swift for beginners series in this video
157:34 - we're going to revisit initializers and
157:37 - i'm going to tell you about designated
157:39 - initializers and convenience
157:41 - initializers okay well let's get started
157:46 - [Music]
157:47 - so right here i'm starting off again
157:50 - with the blog post class and the person
157:52 - class
157:53 - and of these properties here in the blog
157:56 - post class
157:58 - i'm actually going to uninitialize some
158:00 - of these properties so i can demonstrate
158:02 - for you
158:04 - what we need to do in the initializer
158:06 - because i mentioned before that one of
158:07 - the jobs of the initializer is to make
158:10 - sure that all these properties are
158:13 - initialized and ready to go so even if
158:15 - it is an optional that is considered
158:18 - okay
158:20 - when you're declaring your properties
158:21 - inside your class there are basically
158:23 - three different ways of doing it so
158:25 - number one is this one where you
158:28 - declare the property and you initialize
158:30 - it to some sort of value right away so
158:32 - that's this body property right here and
158:34 - this number of comments property is
158:37 - equal to zero
158:38 - the next thing you can do is you can
158:41 - declare a property and set it to
158:42 - optional so you're specifying that it
158:45 - could be nil or it could contain a value
158:47 - but either way
158:49 - you have to unwrap the value and you
158:51 - have to check if it's nil before using
158:53 - it
158:54 - now the third way is probably the most
158:56 - dangerous way and that is using the
158:58 - force unwrap operator
159:00 - so let me show you what that means
159:02 - if i
159:04 - get rid of that question mark and i put
159:06 - an exclamation mark there and let's also
159:08 - do it beside author so what you're
159:10 - saying here is you're saying that title
159:12 - basically is an optional it could be nil
159:15 - or it could contain a value but you're
159:17 - going to leave it unwrapped
159:20 - so when i access the title property down
159:23 - here and i say post.title
159:26 - xcode is not going to
159:28 - have that sort of safe
159:30 - checking or warning us
159:33 - that it could be nil it's not going to
159:34 - provide any of those safety mechanisms
159:36 - and it's just going to let us use it as
159:38 - is
159:39 - so we can assign nil into title as you
159:41 - can see here it's nil
159:44 - and we can use it like a normal property
159:46 - right we don't have to
159:47 - check if it's nil or not or rather it is
159:50 - up to us whether we want to do it or not
159:52 - but however if
159:54 - you know the difference
159:56 - the flip side
159:58 - being that we make this an optional
160:01 - now there are some safety mechanisms in
160:03 - place if i just try to use this as is
160:05 - xcode is going to warn us that hey you
160:07 - know this is an optional you have to
160:10 - check that it's not nil or you have to
160:11 - unwrap it
160:13 - first before you can use it so i might
160:14 - have to say if let
160:17 - you know actual title equals and this is
160:20 - using optional binding so basically
160:22 - we're checking
160:25 - if there's a value inside the optional
160:29 - first
160:30 - you know if something could potentially
160:32 - be nil it's probably safer to use an
160:34 - optional value so that it forces the
160:36 - programmer to actually check things
160:38 - before using it now if you set your
160:40 - properties like
160:43 - that
160:44 - then it could still be nil or could
160:46 - contain a value but you can sort of
160:48 - remove that safety checking that
160:49 - optionals provide
160:51 - so those are three different ways that
160:52 - you can
160:54 - set up your properties
160:56 - what you cannot do however
160:59 - is you can't
161:01 - do something like that where you declare
161:03 - a property
161:05 - you don't set it to anything
161:07 - you don't specify that it's an optional
161:09 - or you don't specify that it's unwrapped
161:12 - and you just leave it like that in that
161:14 - case xcode is going to assume
161:17 - that the initializer is going to set
161:19 - those to some values
161:21 - so let's declare our initializer here
161:25 - like you've learned in the past
161:26 - and inside here you can see that xcode
161:29 - is still showing errors but if i
161:32 - actually initialize these things
161:36 - inside the initializer
161:39 - let's say author is equal to person like
161:41 - that
161:42 - then xcode is going to stop complaining
161:44 - because
161:45 - remember when we create a new blog post
161:47 - like this it's actually calling the
161:49 - initializer so even though these
161:51 - properties right here title and author
161:53 - they're not set to anything they're not
161:55 - optional they're not
161:56 - unwrapped this initializer is going to
161:59 - be called for sure when we create a new
162:01 - blog post object and inside here
162:03 - those properties get
162:05 - set to some value they get initialized
162:07 - and so at the end of the day this blog
162:09 - post object is going to be ready to be
162:12 - used
162:13 - now this initializer right here this is
162:15 - what is called the designated
162:18 - initializer and what that means is that
162:21 - this initializer function is guaranteed
162:24 - to
162:25 - fulfill those obligations of
162:28 - making sure that all of the properties
162:30 - are initialized before use
162:33 - in contrast we can have something that's
162:35 - called a convenience initializer and
162:37 - what that is is you use the convenience
162:40 - keyword followed by your initializer
162:45 - method signature so i might have
162:48 - something like this where inside this
162:50 - initializer i only want to
162:53 - provide a custom title
162:59 - well you might ask if i call this
163:01 - convenience initializer
163:03 - how is
163:04 - author going to get initialized
163:07 - right so what happens is inside the
163:10 - convenience initializer i call the
163:13 - designated
163:15 - initializer using the self keyword like
163:17 - this
163:19 - so now
163:20 - and inside here let's set title equals
163:23 - custom title
163:26 - so now when i declare a new
163:29 - blog post object and let's say i use my
163:31 - convenience initializer like this
163:34 - and i pass in a custom title like this
163:38 - it's calling this
163:41 - convenience initializer
163:43 - but this convenience initializer is also
163:46 - calling the designated one which makes
163:49 - sure that at the end of the day you know
163:52 - the uninitialized properties will be
163:54 - initialized
163:56 - and then after calling
163:58 - that designated initializer then we set
164:01 - title to custom title so whether i call
164:05 - this designated initializer or the
164:07 - convenience initializer
164:10 - the title and the author properties will
164:11 - be guaranteed to be initialized
164:14 - and so the role of the convenience
164:15 - initializer is simply for convenience
164:19 - so that's the difference between a
164:21 - designated initializer versus a
164:23 - convenience initializer
164:26 - hello welcome to learn swift for
164:28 - beginners lesson 16. today you're going
164:30 - to learn about how to manage a
164:32 - collection of data in what's called an
164:34 - array
164:36 - if you're working with many pieces of
164:38 - data it would be hard to manage them
164:40 - with simply constants and variables so
164:43 - let's take a look at how arrays can make
164:44 - our life easier alright let's get
164:47 - started
164:49 - [Music]
164:52 - now arrays are one of three collection
164:54 - types that are available in the swift
164:56 - programming language for us to use and
164:58 - manage our data in this language guide
165:01 - you can see a diagram of this
165:04 - array on the far left side we're going
165:07 - to come back to this diagram in a second
165:09 - but first a definition
165:10 - so you can think of an array as a
165:14 - collection of data that is ordered by
165:17 - indexes
165:18 - now if that doesn't tell you too much
165:19 - let's jump right into a swift playground
165:23 - and i'll show you exactly how beneficial
165:25 - they are and also how to declare them
165:28 - and how to use them
165:29 - so first i'm going to delete this
165:31 - default variable here and we're going to
165:34 - create a couple of
165:35 - variables ourselves so let's say var a
165:38 - equals dog
165:40 - var b equals cat
165:43 - var c
165:44 - equals
165:46 - bird
165:48 - and now let's say i wanted to
165:51 - concatenate or add the word my in front
165:54 - of each of those values there so that i
165:57 - would have my dog my cat and my bird
166:00 - so i would have to do something like
166:01 - this i would have to go a equals
166:04 - my space
166:06 - plus a
166:08 - and this would result in a being my dog
166:12 - because
166:13 - we're adding the word my with space to
166:16 - a and a is dog and then we're
166:19 - reassigning that result into a again
166:22 - thereby overwriting what was there
166:24 - before so now a is actually my dog
166:27 - i would have to repeat this for cat and
166:28 - i'd have to repeat this with bird i
166:31 - can't even use what we learned in the
166:33 - previous lessons in regards to loops to
166:36 - make my life easier i'd have to write
166:38 - this out three times for each of the
166:40 - variables
166:41 - so here's the perfect chance to use an
166:43 - array to organize this collection of
166:45 - data
166:46 - so in order to create an array with the
166:48 - data already in it we're going to open
166:50 - up two angle brackets or square brackets
166:53 - if you'd prefer
166:54 - and inside these two square brackets we
166:58 - put each piece of data separated by a
167:00 - comma
167:01 - so we have dog
167:03 - we have cats
167:05 - and we have bird
167:08 - so just like that we have an array with
167:10 - three pieces of data
167:12 - and if you remember what i said in the
167:14 - definition
167:16 - that arrays are a collection of data
167:18 - organized by indexes what do i mean by
167:21 - that well you can see that there are
167:23 - three pieces of data here so there's
167:25 - three distinct spots you can think of it
167:28 - the left most spot here the beginning
167:31 - is index zero or spot 0 if you'd prefer
167:34 - to think of it like that the next one is
167:36 - index 1 and the last one is index 2. so
167:40 - arrays start at 0
167:43 - and because there are 3 items here the
167:45 - indexes go from 0 1 to 2.
167:49 - and now if i quickly bring up that
167:50 - language guide again you can see in this
167:52 - diagram that in this array there are
167:55 - five items and so the indexes for six
167:58 - eggs is zero index for milk is one and
168:01 - so on until it reaches four even though
168:03 - there are five items because it's zero
168:05 - based okay
168:08 - so let's go back down here
168:10 - so this is great that we have an array
168:12 - here but we need some way to reference
168:14 - that array so actually what we do
168:16 - is we can create a variable let's call
168:19 - it d
168:20 - and we assign this array or this
168:22 - collection of data into the variable d
168:26 - so now if i wanted to access dog for
168:28 - example i would write d
168:30 - and then i would write square brackets
168:33 - like that and in between the square
168:35 - brackets i would put an integer
168:37 - representing the index of the item that
168:39 - i want so let's say i want dog i would
168:41 - put 0.
168:43 - so you can see here i would get dog all
168:45 - right and so we can
168:47 - print that out
168:49 - and that would print
168:50 - dog down here now if i change the index
168:53 - to 1
168:54 - then i would get cat instead
168:57 - now let's do an example where we have
169:00 - something like this
169:02 - just to duplicate that i would say
169:05 - let's say a equals
169:08 - my
169:09 - plus
169:11 - d
169:12 - zero
169:14 - like that i can do b equals
169:17 - my
169:21 - that's my cat
169:22 - and finally
169:27 - i would get my bird but then i mentioned
169:30 - that there was a better way to do it if
169:31 - we leverage what we learned in the
169:33 - previous lesson on loops well we can
169:36 - let's take a look at using for loops and
169:38 - simplifying our work here so remember
169:41 - for loops will loop a piece of code for
169:44 - a specified number of times and you can
169:46 - see here that i'm working with index 0
169:49 - and x1 index 2 so this becomes really
169:52 - easy i can say four remember the next um
169:56 - the next piece of the for loop is a
169:59 - counter
170:00 - so
170:01 - you know it's my variable to hold the
170:03 - current index
170:05 - and then you write in and then you write
170:07 - your range so i can write 0 0
170:10 - sorry i mean 0.2
170:13 - and this is going to loop from 0 to 2.
170:15 - so you i think you can kind of see where
170:18 - i'm getting at what i'm going to do is
170:20 - print
170:23 - my
170:25 - plus d
170:26 - and inside
170:28 - here where i put the index usually i'm
170:30 - going to put counter
170:36 - and you can see here it took the
170:38 - playground a little second but
170:40 - that's exactly what i expected to do
170:42 - here
170:44 - so in the first iteration of this for
170:46 - loop counter is zero right that's the
170:48 - starting range so zero gets passed into
170:51 - here and i would get this printed out
170:53 - this is dog d at index zero right is dog
170:58 - in the next iteration of the loop
170:59 - counter is one and so i'm actually
171:02 - accessing index 1 of my array d
171:06 - so that's why i get cat
171:07 - and then finally it loops again and
171:09 - counters 2 and i would access this bird
171:12 - index here
171:14 - i want to show you another way
171:16 - to use your for loop with an array and
171:19 - that's simply to say
171:22 - for
171:23 - item
171:24 - in d
171:26 - so what this is going to do
171:28 - is it's going to loop through all of the
171:30 - items in the array d
171:33 - and in each iteration of the loop it's
171:36 - going to take that
171:38 - item
171:39 - or that piece of data
171:40 - and it's going to assign it to item so
171:44 - i can simply go like
171:49 - this
171:52 - so you can see that it gets printed out
171:55 - again
171:58 - right in the first iteration item is dog
172:00 - in the second iteration it's cat and the
172:02 - third it's bird so this is a pretty
172:06 - simple way to write it and you can see
172:07 - that it saves a lot of work from doing
172:10 - it kind of one by one like this and one
172:12 - by one like this
172:15 - arrays in conjunction with loops really
172:18 - powerful stuff
172:19 - now with arrays there's other cool
172:21 - things you can do let me just
172:24 - make some space here maybe i should
172:27 - delete this stuff
172:31 - you can actually declare an empty array
172:34 - so it's an array that would contain no
172:36 - data at first and the way you do that is
172:40 - just like storing things into a variable
172:42 - or a constant arrays can only store data
172:45 - of a certain data type that you specify
172:48 - so since it's an empty array how you
172:51 - would do it is you open up two square
172:53 - brackets you put the data type inside
172:56 - the two square brackets and that data
172:59 - type represents the type of the data
173:01 - that the array is going to store so i'm
173:04 - just going to put string here
173:07 - and then you end off with two round
173:10 - brackets like that and just like that
173:12 - now e refers to an array that is empty
173:16 - right now doesn't contain any data with
173:19 - the intention of storing string type
173:21 - data in this array
173:24 - now if you're going to create an empty
173:26 - array like this you better be able to
173:28 - add data to that array right so what
173:32 - makes arrays really useful is that you
173:34 - can add and remove data from that
173:36 - collection so i can add or remove from
173:40 - this collection right here i can add or
173:42 - remove from this collection here let me
173:45 - just show you how to do that there are a
173:46 - couple of different ways
173:49 - i can do something like this d plus
173:52 - equals
173:54 - two angle brackets like that again and
173:55 - let's say i wanted to add
173:58 - mouse
174:00 - and now my d array would contain four
174:03 - items as you can see here dog cat bird
174:05 - and mouse in fact i can even add two
174:08 - pieces of data at once comma
174:11 - and then here
174:12 - i could put owl for example so it would
174:15 - add mouse and owl to that array so now
174:18 - my array has
174:19 - five items from zero to four
174:22 - right starts at zero one two three four
174:26 - make sure that you don't forget that
174:28 - plus sign right here because
174:30 - if you do that
174:32 - then essentially you're creating a brand
174:34 - new array with these two items and
174:35 - you're assigning it to d and you've just
174:37 - lost this data here
174:39 - so plus equal
174:41 - is for adding items
174:45 - now seeing this plus equals you might be
174:47 - tempted
174:48 - to use minus equals
174:52 - to remove items
174:54 - like this
174:55 - but that actually doesn't work
174:57 - unfortunately you can't remove items
174:59 - from the array like that what you have
175:01 - to do is the array actually has
175:03 - functions that you can call on it to
175:05 - remove items so you would say d and then
175:08 - you would press dot on your keyboard or
175:11 - the period key
175:12 - and out pops a list of functions that
175:15 - you can call on this array
175:17 - and using the append function is going
175:19 - to do exactly like this plus equal is
175:22 - it's going to add items into that array
175:24 - but
175:25 - let's look at the remove functions so
175:27 - you have remove all
175:29 - which is going to remove all the items
175:31 - in an array
175:32 - but you can
175:34 - use this one here remove at and you can
175:36 - specify the index of the item you want
175:39 - to remove so if i put 0 like that that's
175:42 - going to remove dog from my array so now
175:46 - it's only going to contain cat bird
175:48 - mouse and owl
175:50 - now what if i don't want to completely
175:52 - remove dog but i just wanted to change
175:55 - that element right there at index 0. so
175:58 - let me get rid of this remove line
176:01 - you saw that you can access items in the
176:04 - array by doing that right putting in the
176:06 - index there well you can actually change
176:09 - the item you can change what is assigned
176:11 - at that index
176:13 - by typing d
176:15 - square brackets put in the index you
176:17 - want to change
176:18 - and using the equal sign to assign
176:21 - something new into that spot
176:24 - so here let's say turtle
176:27 - and that is going to now change your
176:30 - array
176:31 - if i
176:32 - print d
176:34 - oops zero
176:37 - i'm going to get turtle instead of dog
176:39 - because i just changed it up here
176:43 - the last thing i want to point out is
176:45 - that
176:46 - arrays also
176:48 - you can check how many items are in
176:50 - there if you look at the count and
176:53 - that's going to return
176:54 - the number of items in your array that
176:57 - is sometimes useful when you want to use
176:59 - a for loop with a range and you don't
177:01 - know how many items are in the array you
177:03 - can use this
177:05 - array.count and get this number here but
177:08 - just keep in mind that
177:10 - although d has five items right here
177:13 - the index of the last item is actually
177:16 - only four because the first item is zero
177:19 - it goes from zero one two three four
177:21 - right even though there are five items
177:23 - so just keep that in mind if you're
177:24 - going to use this
177:26 - array.count in conjunction with a for
177:29 - loop or something like that
177:31 - okay so that's where we're going to end
177:33 - with arrays as you can see when you type
177:36 - array dot there are a lot of different
177:38 - functions
177:40 - with arrays that you can do
177:43 - what i've covered here in this lesson is
177:45 - enough for you to use arrays and
177:47 - leverage some of the main benefits of
177:49 - arrays
177:50 - as we go on and we're building apps
177:52 - together you're going to be learning new
177:54 - ways to use arrays but for now these are
177:56 - the main things you need to know about
177:58 - arrays in order to start using them
178:01 - if you like this video please give this
178:03 - video a thumbs up please subscribe for
178:05 - more
178:06 - hello welcome to lesson 17 of the learn
178:08 - swift for beginners series
178:11 - in this video we're going to go through
178:12 - another collection type called the
178:14 - dictionary
178:17 - [Music]
178:20 - in the previous lesson we went through
178:22 - the array you can see here on the left
178:24 - hand side and with an array we had a
178:27 - collection of items where the order
178:29 - mattered so you can see in this example
178:31 - here in the swift programming language
178:33 - guide six eggs is in spot number zero
178:37 - whereas bananas is in index four
178:40 - all right well a dictionary on this
178:42 - right hand side here
178:44 - is a collection type where order does
178:47 - not matter
178:48 - so in arrays we retrieve the item by
178:51 - this index here and with the dictionary
178:54 - because order doesn't matter we retrieve
178:56 - these values using a key
178:59 - so each value has an associated key when
179:02 - you put it into the dictionary and you
179:04 - need to pass it that same key and it's
179:07 - going to return for you the value
179:10 - now which collection type you use to
179:13 - organize your data is going to depend on
179:16 - obviously what sort of data you're
179:18 - storing does order matter if it does
179:21 - then the easy answer is to use an array
179:23 - if it doesn't then maybe consider using
179:25 - a dictionary so this is a good example
179:28 - airports have these airport codes right
179:31 - so each airport has an associated key
179:35 - and that's a good point the keys should
179:37 - actually be unique for each
179:39 - value that you put in
179:42 - another great example of when to use a
179:43 - dictionary and this is the example that
179:46 - i'm going to use in this video is
179:48 - license plates so for example each
179:50 - license plate is tied to a car
179:53 - and each license plate is unique so the
179:55 - key can be the license plate and the
179:57 - value can be maybe a description of the
180:00 - car or something like that
180:02 - let's jump into xcode
180:04 - in this new playground that i have here
180:06 - and let me show you how to declare a new
180:08 - dictionary and how to work with it
180:12 - so why don't we declare
180:15 - a variable here and let's call it car db
180:19 - to represent car database
180:21 - and let's looks like my playground has
180:24 - crashed okay
180:26 - and
180:27 - what we're going to do here
180:29 - is to declare a new dictionary so we use
180:33 - the keyword dictionary and followed by
180:36 - that we have these angle brackets where
180:38 - inside we specify the data type of the
180:40 - key followed by the data type of the
180:43 - value so
180:44 - for example let's pull
180:46 - up that example again in here in this
180:49 - dictionary the key would be a string
180:52 - and the value would also be a string and
180:54 - so
180:55 - in between these two angle brackets we
180:57 - would just put string comma string
180:59 - and in order to create a
181:02 - a new dictionary object we would just
181:05 - end off with those two brackets and like
181:07 - that we have an empty dictionary which
181:10 - stores
181:12 - key value pairs
181:13 - and a key value pair is just a fancy
181:15 - name for
181:17 - one of these pairs of data
181:19 - you know a key and a value
181:23 - this dictionary stores key value pairs
181:25 - where the key is a string and the value
181:27 - is a string as well
181:29 - now there is an easier way to write this
181:32 - out without having to write so much
181:35 - let me show you that second way
181:37 - var
181:38 - car db uh let's just say db2 is equal to
181:43 - use the square brackets and then you
181:45 - specify the data type of the key
181:47 - followed by colon
181:49 - and then the data type of the value and
181:51 - again we have these two brackets here to
181:54 - create a new
181:55 - instance of that dictionary or new
181:57 - dictionary object
181:59 - and that's equivalent these two are the
182:01 - same thing
182:03 - doesn't this look very similar to
182:05 - declaring a brand new array don't get
182:07 - confused so for example
182:10 - declaring a new string array would look
182:12 - like
182:15 - this would be my empty array
182:17 - that is expecting to contain string
182:20 - objects and this is an empty dictionary
182:23 - that is expecting to contain key value
182:26 - pairs where the key is string and value
182:29 - a string as well
182:30 - okay so we're going to stick with this
182:33 - sort of declaration here so i'm just
182:35 - going to go ahead delete this array
182:37 - example that was just for demonstration
182:39 - and delete that so now we just have card
182:41 - db is an empty dictionary now how do i
182:44 - assign something into the car database
182:47 - dictionary well i would do car db
182:51 - and then i would use these two
182:53 - square brackets here and i would pass in
182:56 - a key or i would specify a key rather
183:00 - and this key would be a license plate
183:02 - right so
183:03 - you know this is going to be different
183:04 - depending where you are in the world
183:07 - but
183:08 - let's just say it's like that
183:11 - and then you assign the value into
183:14 - the dictionary for that key so this
183:16 - would be let's say
183:18 - a blue
183:20 - ferrari
183:23 - now
183:24 - this value blue ferrari is tied to
183:28 - this key jsd238
183:31 - how do i retrieve the value well
183:34 - it's very simple i just give it the key
183:38 - so if someone were to look up this
183:40 - license plate let's say i print this out
183:45 - like that
183:47 - it would print out blue ferrari but
183:50 - notice that it's wrapped in an optional
183:53 - tag because
183:55 - for example
183:56 - if i passed in a key that doesn't exist
184:00 - right let's pass in like asd 238 then
184:04 - you can see there is no value for that
184:06 - key all right so that's why it returns
184:08 - nil so that's why when you access a
184:11 - dictionary and you pass in a key it
184:13 - returns to an optional
184:16 - whatever data type that your value is
184:19 - so when you pass in a key into your
184:21 - dictionary to retrieve a value
184:23 - just expect that it is an optional and
184:25 - you may need to unwrap it and check if
184:28 - it's nil before using it
184:32 - okay so what if i wanted to
184:35 - let's let's label this so
184:38 - before we continue on this is declaring
184:41 - a new
184:42 - dictionary this is
184:46 - adding
184:48 - key value pairs
184:51 - and this is
184:53 - retrieving
184:55 - data
184:58 - and how do we update a value for a key
185:03 - well it looks exactly like this
185:06 - up here
185:07 - so
185:08 - you specify the key that you want to
185:11 - update the value for
185:15 - and here we can say that this guy now is
185:19 - a red ferrari maybe it got a paint job
185:21 - or something so
185:22 - when you pass in this key from now on
185:24 - you're going to get this new value
185:26 - because this basically overwrote
185:28 - whatever was there
185:30 - before and in order to remove a value
185:35 - remove a key value pair let's say
185:39 - you can do something like this
185:41 - you pass in the key
185:45 - two three eight
185:47 - and you assign it nil and actually that
185:50 - is going to remove the key value pair
185:52 - from your dictionary
185:55 - now i'm going to show you how to iterate
185:58 - over all of the key value pairs in your
186:00 - dictionary so why don't we just add a
186:02 - second key value pair in here
186:05 - so that we have more than one item to
186:07 - display
186:14 - okay and this one can be a green
186:18 - uh lamborghini
186:21 - i think that's how you spell it i don't
186:22 - have one so
186:24 - i don't know for sure
186:27 - and now let's iterate over it
186:30 - wish i had one though
186:32 - iterate over it we use a for loop
186:36 - so we can say for
186:39 - essentially for each key value pair
186:41 - inside the dictionary do something
186:44 - and the way you specify
186:46 - this is you pass in
186:50 - um we use what's basically called a
186:52 - tuple okay and so you can think of a
186:54 - tuple as a set of variables or a bunch
186:58 - of variables so
186:59 - we'll we're going to say
187:01 - license
187:03 - car
187:05 - in
187:07 - car db now the in keyword shouldn't be
187:10 - new to you because you guys learned
187:12 - about the for loop in a previous swift
187:15 - lesson
187:16 - so
187:17 - um basically what should be new to you
187:19 - though is this this is a tuple
187:22 - so for each
187:24 - tuple in
187:26 - this dictionary we can do something
187:29 - what's going to happen is it's going to
187:32 - grab
187:33 - each key value pair and the key is going
187:36 - to be inside license
187:38 - and the value is going to be car like
187:40 - that so
187:42 - now inside this for loop it's going to
187:43 - iterate twice
187:45 - and i'm going to find this key
187:49 - or this license
187:50 - inside this license variable and i'm
187:52 - going to find the car
187:55 - this string here blue ferrari or green
187:57 - lamborghini inside this car variable
188:00 - and it knows
188:02 - even though there's no data type
188:04 - associated with this tuple
188:06 - because my dictionary is
188:08 - string string for the key and the value
188:11 - i'm going to simply print car
188:15 - like that and you can see that
188:19 - hmm it's just it's printing one
188:21 - key value pair here it's printing one
188:23 - car but i have two items
188:26 - and the reason is because we've actually
188:29 - removed
188:30 - a key value pair with this statement
188:32 - here so if i just comment this guy out
188:36 - we have our two cars
188:38 - and
188:39 - it's red ferrari because we changed it
188:41 - up here
188:43 - now i can also print out the license i
188:45 - can say
188:46 - you know license
188:49 - um
188:51 - you know i can say something like
189:00 - car
189:01 - has a
189:02 - license
189:08 - like that
189:12 - has a license
189:16 - so that pretty much wraps up using a
189:18 - dictionary and you're going to find that
189:20 - it will come in handy along side arrays
189:23 - in organizing your data so thanks for
189:25 - watching if you like this video please
189:27 - give it a thumbs up and please share it
189:29 - with anyone you know who's also
189:30 - interested in swift thanks for watching
189:33 - i'll see you guys next time hey did you
189:35 - join my free facebook community yet
189:37 - that's where i hang out along with a ton
189:39 - of other people learning ios just like
189:41 - yourself i also post early access to all
189:44 - of my videos inside that group before i
189:46 - put them on youtube you can also get
189:48 - help with any questions you're having
189:50 - visit the link below click on the join
189:52 - group button and i'll approve your
189:54 - request right away alright so i'll see
189:56 - you in there talk soon