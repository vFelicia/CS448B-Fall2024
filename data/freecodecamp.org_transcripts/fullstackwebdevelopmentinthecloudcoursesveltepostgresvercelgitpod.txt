00:00 - - Learn how to create and deploy
00:01 - a full stack web application
00:03 - using Svelte, Vercel, and Postgres,
00:05 - and they'll do it all on your browser.
00:08 - - Hello and welcome to the
Full Stack Development Course.
00:11 - My name is Mike Nikles.
00:12 - I am your instructor for this course,
00:15 - and I will talk about
myself and my background
00:18 - in just a little bit.
00:19 - Before we get to that,
00:21 - I want to introduce you to the
course, the technology stack,
00:25 - and a little bit of how we are
going to be developing this.
00:29 - Now, why do we do a full
stack web development course?
00:33 - I've been in the industry
for a couple of years.
00:36 - And one thing I noticed is that
there's a lot of information
00:39 - online about web development,
different frameworks,
00:43 - different technology stacks.
00:46 - There's a lot of information
about backend development,
00:48 - and there's a lot of
information about how to build
00:51 - and model your database
and your backend systems.
00:56 - Now, what I think has been
missing is this entire end-to-end
01:01 - full stack web development, like what,
01:04 - how do you connect the
website to the backend?
01:07 - Like of course there's
REST APIs, there's GraphQL.
01:11 - There's different ways of communicating
01:15 - between the frontend and the backend,
01:17 - you can find that information online.
01:18 - It's again, like anything
else, a lot of stuff out there,
01:22 - but how do you really connect
the front end to the backend?
01:25 - What are some of the best practices,
01:27 - some gotchas to watch out for?
01:29 - And the same is true for
the connection between
01:34 - the server side or the backend
and your database, right?
01:38 - You could use raw SQL queries,
you could use an object
01:43 - relational mapping, an ORM,
you could use a NoSQL database
01:49 - where you persist JSON-like
data or documents.
01:53 - But again, how exactly
are you going to do that?
01:56 - And in this course,
01:57 - I am going to teach
you the full end to end
02:01 - from building the web application,
connecting it to an API,
02:05 - and then persisting data in
the backend in a database.
02:08 - We will be talking about the entire thing,
02:11 - we will also be deploying that
02:13 - into a production-like environment,
02:15 - so that at the end of the course,
02:18 - you have what it really takes
to start your next project.
02:21 - Whatever you are going to
build by the end of this course
02:24 - will be the starting point
for your next project.
02:27 - So you don't have to build all this,
02:30 - gluing together by yourself.
02:32 - Let's talk about where we
are going to develop that.
02:36 - Most of you are very familiar
02:37 - with your local development environment,
02:40 - where you have a bunch of
tools installed, a terminal,
02:44 - probably, some kind of
command line interface,
02:47 - and probably some editor
of one sort or another.
02:52 - In this course,
02:53 - I'm going to be using
something called Gitpod.io,
02:57 - Gitpod is providing developer environments
03:01 - in the cloud for each task
that we're going to work on.
03:05 - So imagine instead of, you know,
03:08 - curating and maintaining
our local environment,
03:11 - where we install certain versions
03:12 - of Node or Java, what we
get is a new environment,
03:18 - always cleaned from scratch,
03:19 - automatically set up for each
task we're going to work on.
03:22 - We will get into that in
more detail as the course
03:25 - progresses, and I will
introduce this as we go.
03:29 - One thing to keep in
mind is if you do prefer
03:31 - your local environment,
that's perfectly fine.
03:34 - You can follow along with everything we do
03:37 - by using your local environment.
03:40 - There's no problem with that.
03:42 - Let's talk about the technologies.
03:44 - You can see on the screen, on the website,
03:47 - we will be using a
framework called Svelte.
03:49 - Svelte is currently in version three.
03:52 - It's been stable for a while,
and it's used in production
03:54 - by a number of big companies,
the API slash backend,
04:00 - and also the hosting a
framework for Svelte itself
04:03 - will be SvelteKit.
04:06 - SvelteKit as you can tell by the name
04:08 - is developed by the same team.
04:10 - And very recently, the
founder and creator of Svelte,
04:14 - Rich Harris announced that he
is joining Vercel full-time
04:19 - so Svelte is now backed by a
large player in the industry
04:24 - who really cares about
making the web faster.
04:29 - Lastly, we need some kind of database.
04:31 - In this course, we're
going to use Postgres.
04:34 - We will be talking about other
databases at the very end
04:37 - when we talk about next
steps, and you know,
04:41 - this is a stack that I chose
04:42 - because I'm very familiar with it,
04:44 - and I think it is future proof in terms
04:46 - of what you learned and what
you can apply at your work
04:50 - or in your next, you
know, free time project.
04:53 - over the next few years.
04:57 - Lastly, we will be using
two deployment platforms,
05:00 - one is Vercel, we will deploy
the SvelteKit application
05:05 - to ourself and serve our
web application from there,
05:09 - and secondly, we really use
something called Railway,
05:12 - a hosting provider where
we will be hosting Postgres
05:16 - and you'll see how easy it is
to set up a Postgres database
05:20 - on Railway connect with
SvelteKit in Vercel
05:24 - and get everything up and running.
05:27 - That is a very high level
overview of what are we going to
05:30 - be talking about and how are
we going to be developing this.
05:34 - Let me also give you a
little bit of background
05:37 - about myself so that you have an idea
05:39 - of what I'm talking about
05:41 - and why I do have the
experience to teach this course
05:44 - and help you with your next
full-stack application.
05:48 - So I have been a web developer since 2000,
05:52 - so it's been a couple of
years and the web has gone
05:54 - through a number of transitions.
05:57 - You know, things like jQuery.
05:59 - Well, first of all, PHP
and jQuery came out,
06:00 - a whole bunch of different
things happened since then.
06:04 - React is very big, lots
of people using that.
06:08 - And then I started using Svelte
06:10 - about two and a half years ago
when it was at version two.
06:13 - And I've advocated for it
ever since, and, you know,
06:16 - with the recent announcement
of Vercel backing Svelte,
06:20 - I think this is a really strong framework
06:22 - to use for a course like that.
06:25 - Now at the moment, I'm a
developer advocate at Gitpod,
06:29 - and that's obviously why
we will be using Gitpod
06:33 - for this course, and I will
be introducing the concept,
06:35 - as I mentioned before, it's not mandatory
06:37 - to use it, but it is
there to give you an idea
06:40 - of what the future of
development looks like.
06:43 - You can find me on my
blog at mikeNikles.com.
06:48 - This is where I share, you know,
06:50 - any of the open source
project I launch or release.
06:54 - You can go there and have a look.
06:55 - There's a bunch of Svelte related content.
06:58 - There is React related
content from the past.
07:01 - So go check that out
07:03 - if you're curious about what I talk.
07:06 - Next, you can find me
on Twitter @MikeNikles,
07:10 - same handle as my website URL.
07:12 - And this is where you get
to see my daily thoughts.
07:16 - It's usually about full stack development.
07:19 - It's about mentoring.
07:21 - I talk a lot about career growth.
07:24 - I wrote a book about that as well,
07:26 - giving you tips and tricks
on how to manage your career
07:29 - in the software industry, so yeah,
07:31 - do check it out on Twitter,
definitely lots to share there.
07:35 - And a couple notes on my previous life
07:38 - before I joined Gitpod,
07:40 - I spent a few years at
Google where I helped
07:43 - enterprise customers
migrate their workloads
07:47 - from on-premise to the
cloud and, you know,
07:51 - kind of help them with the
migration and digital innovation
07:55 - as we went through that,
07:57 - I spent a few years at Mobify,
07:58 - a company now acquired by Salesforce,
08:01 - where we built mobile
friendly e-commerce sites
08:04 - on top of a desktop application.
08:06 - So imagine the desktop site
08:08 - that wasn't mobile friendly
Mobify would kick in
08:11 - at run time and convert
that entire website
08:13 - into a mobile friendly UI and
learned a lot about, you know,
08:19 - monkey patching, all sorts of
things when I was at Mobify.
08:22 - Prior to that, I did a couple of years
08:24 - at Layer 7, that was an APA
gateway security company.
08:29 - My role there was to train
and teach the product
08:35 - to customers of Layer 7.
08:37 - So as you can see, I've
been around for awhile.
08:38 - I've had different hats around
my own business for awhile,
08:42 - and now I'm here teaching
08:44 - the full stack web development course.
08:46 - And with that, let's get started.
08:52 - All right let's have a look at
08:53 - what you will learn in this course.
08:56 - A couple of things I
already talked about, Svelte
08:59 - on the front end,
SvelteKit to build the API
09:01 - and host the web application,
09:03 - Postgres for the database
09:08 - Vercel to serve the website and the API
09:11 - and the Railway to host
the Postgres database.
09:13 - I talked about that before
so no change on that.
09:17 - In addition to all that,
we will look at TypeScript.
09:22 - So the reason that we're
going to use TypeScript
09:24 - is because I want to show
you a fully typed environment
09:29 - where we actually can use TypeScript
09:32 - and autocomplete for our database model.
09:36 - So if we have a database
model called todo-item,
09:42 - and that has a number of columns,
09:45 - we can then use that
autocomplete in TypeScript
09:49 - to access the values in these calls.
09:52 - This is all possible because
of Prisma, a tool that we are
09:56 - going to use in order
to generate these types
10:00 - based on a database schema.
10:01 - Now, Prisma will also help
us to run all the SQL queries
10:07 - and abstract all that from us.
10:09 - So even though we are using
SQL database, Postgres,
10:14 - we have not actually going
to write any SQL queries.
10:18 - It's really beautiful, you're
gonna absolutely love it,
10:21 - I can promise you.
10:22 - There will be an interface generated
10:24 - or a client generated by Prisma,
10:26 - where we can just use it with TypeScript,
10:29 - call functions on it,
and it will fetch data
10:31 - from the database, do all the SQL queries,
10:34 - conversions and all for us.
10:36 - The last thing we're going
to dive in is NPM scripts.
10:40 - You may have heard of tooling like gulp
10:43 - or other tools that help you glue together
10:48 - your development environment
and start, you know,
10:51 - dev servers and watch for file
changes and things like that.
10:56 - We will simplify that
in my personal opinion,
11:00 - by using NPM scripts and
basically have all the scripts
11:05 - that we need in order
11:06 - to test, deploy and
develop the application.
11:11 - This will all be part of
NPM scripts inside package,
11:15 - JSON file at the root of our project.
11:19 - This is at the high level,
what are we going to learn.
11:21 - You do not have to be an expert
11:23 - or even the beginning any of that,
11:25 - all you need to know is
basic JavaScript skills.
11:28 - The rest I will teach you as we go through
11:31 - and as it becomes necessary.
11:33 - So don't expect to be a TypeScript expert
11:36 - by the end of this course, however,
11:38 - if you have never heard of
TypeScript or have never used it,
11:41 - you will be just fine
going through this course.
11:44 - And I will guide you and
teach you everything you need
11:47 - to know in order to develop this project.
11:50 - The same is true for
11:52 - any of the other technologies
that we are going to be using.
11:55 - Fantastic, with that, this
gives you a good overview
11:57 - of what we're going to be learning.
11:59 - Now let's move on and look at
12:02 - how we're going to build
our developer environment.
12:08 - There's one more thing
I want to talk about.
12:10 - And you also noticed that
I have slowly disappeared
12:13 - from the screen.
12:14 - That's just so that we get
the full real estate here
12:18 - to focus on the course.
12:20 - And I will be back later to
show you a few more things.
12:25 - Now, what I want to talk about
is one more thing that we are
12:28 - going to learn that is called
Gitpod, now with Gitpod,
12:33 - you can spin up fresh
automated developer environment
12:37 - for each task in the cloud in seconds.
12:41 - Now that's a fancy way of saying
12:42 - that instead of using your
local development environment,
12:46 - what you get is a new
developer environment,
12:49 - fully automated for
every task we are going
12:52 - to be working on.
12:53 - You will see how this works
12:54 - as soon as we start coding very shortly.
12:57 - But for now, I just want
you to be aware of this.
13:00 - And as I mentioned just a little
13:01 - while ago, you don't need to use it,
13:04 - but if you do want to
see what it looks like
13:07 - and how it works, definitely give it a go.
13:09 - You get 50 hours for free per month.
13:12 - So plenty of free time
to actually get through
13:16 - that entire course together with me here.
13:20 - So with that in mind, check out
Gitpod.io if you're curious,
13:23 - otherwise let's quickly move on and get
13:26 - into the project overview and discuss
13:29 - what application we are
actually going to develop.
13:34 - Okay, now, today we talked
about what do we will learn,
13:37 - let's have a look at the UI of the project
13:40 - that we are going to develop.
13:43 - You can see where you're going
to build a todo application,
13:46 - and I'll explain in just
a second why we focus on
13:50 - the todo application.
13:53 - The UI you see here is developed
13:56 - by the Svelte team, and
you get that out of the box
14:00 - if you create a new Svelte application
14:03 - that uses the default template.
14:06 - Now, why are we copying
something that already exists?
14:09 - Because this course is about
full stack web development.
14:13 - So I don't want to spend
time building the UI,
14:16 - and instead we will use something existing
14:19 - and we'll spend the time
in the course, focusing
14:22 - on deploying, gluing the things together,
14:26 - writing scripts and automating
a lot of the process
14:30 - for the deployment of the
full stack application.
14:33 - What did you want to talk about
14:35 - though focusing on the why
we chose a todo application.
14:38 - And the reason for that is very simple.
14:42 - A todo application gives
us everything you need
14:46 - in order to build your own project
14:48 - once you're done with this course.
14:51 - To get started, we have
to create todo-items.
14:55 - So we can tap here to add a new item.
14:58 - They will teach us how to
send new data to the backend
15:03 - from where we will persist
it in the database.
15:05 - You'll always need that functionality,
15:07 - no matter what application you build.
15:10 - Secondly we will learn how to read
15:12 - the items that we created.
15:15 - So that teaches kind of the opposite way.
15:18 - We're going to go to the database
15:20 - and ask for information that
will be sent to the backend,
15:23 - and from there to our
front end application.
15:27 - Next, we will learn how
to update an existing item
15:31 - by checking it off or marking it as done.
15:34 - That will teach us how to
15:36 - go to the database and edit
or update an existing item
15:39 - that's already persisted.
15:41 - And lastly, we will learn over here,
15:44 - how we delete an item from the database.
15:48 - If you take the initial letters
15:49 - of create, read, update, and delete.
15:52 - You, get the acronym CRUD
that you may have heard of
15:55 - or read about before CRUD is
the foundation that you need
15:59 - for any project that you
will be working on in future.
16:02 - So if you know how to do that as part
16:05 - of a very simple todo application,
16:07 - you can apply that exact same concept to
16:10 - your next billion dollar idea
that you will be developing.
16:15 - With that out of the way,
16:17 - I want to move on and
give you an introduction
16:21 - to the architecture of the
entire end-to-end stack
16:25 - so that we can see how the front end,
16:28 - the API and the database all
communicate with each other.
16:34 - Now that we've seen the UI
of the todo application,
16:38 - I want to talk about the
end-to-end architecture.
16:41 - What is this going to look
like once it's all deployed
16:45 - onto Vercel and Railway?
16:47 - The very first thing we will be working
16:50 - on is the front end, we
were going to build that UI.
16:53 - It will not do anything when
we click on any buttons,
16:56 - but at least we will
build the user interface
16:59 - with all the different
states and all that,
17:01 - so that the real focus after
that can be on the rest of
17:06 - the architecture, all the stuff
that's white at the moment.
17:09 - So let's have a look at
what we are going to build.
17:12 - As I mentioned, we will be using Svelte
17:15 - for the front end to develop
that web application.
17:18 - Now, in order to serve the web application
17:23 - to our users, we have
to host it somewhere.
17:25 - And the hosting for the
web application will happen
17:29 - on Vercel and we will be using SvelteKit.
17:32 - They have to same logo, but
Svelte on the front end,
17:36 - SvelteKit on Vercel to
host the application.
17:41 - Also in Vercel, in SvelteKit on Vercel,
17:45 - we will have the APIs
exposed for the front end.
17:50 - So if we look at that,
17:52 - we will have the frontend make
API requests to a REST API
17:59 - hosted on Vercel, in
SvelteKit for example,
18:02 - to fetch all todos.
18:06 - So a get request slash todos
18:08 - and then the SvelteKit API
will return a JSON object
18:13 - with the list of the todo-items
that you can see in the UI.
18:17 - We saw that just a few minutes ago.
18:21 - In order for SvelteKit
to return that JSON,
18:24 - we need to fetch it from the database.
18:27 - So let's have a look
at how this looks like.
18:30 - Somewhere we'll have to
write select star from todos,
18:35 - sent that query to the Postgres database
18:38 - that is deployed on Railway.
18:41 - The Postgres database will
return the SQL response
18:46 - that contains the rows from the database
18:49 - for all these items that are persisted.
18:52 - And then it will be sent to SvelteKit
18:56 - and returned to the Svelte application
18:58 - in the browser, from
where we can then render
19:02 - the JSON and display this beautiful list.
19:04 - You notice there's a missing piece.
19:07 - And that missing piece is Prisma,
19:11 - a library we are going to be using
19:14 - that helps us translate from the requests
19:19 - that we get in get todos,
19:21 - we will be able to just
call a few functions,
19:25 - telling Prisma to go get our todos
19:28 - and Prisma will take
care of writing the SQL
19:30 - or generating the SQL that
will be sent to Postgres.
19:36 - Equally, when the response
19:38 - from Postgres comes back onto Vercel,
19:41 - Prisma will be the first point of contact
19:44 - to take that raw SQL response,
19:47 - convert it into JavaScript objects
19:50 - that we can then turn into JSON responses
19:54 - that are being sent back to the browser.
19:57 - So Svelte on the front end,
19:59 - sending an API request to
SvelteKit from where we use
20:04 - Prisma in order to send a
request to the Postgres database.
20:08 - On the way back when
the response comes back,
20:11 - Prisma converts the SQL
response to JavaScript objects,
20:15 - SvelteKit creates the response
20:17 - for the browser, sends it back,
20:20 - and the browser displays the
todo-items that we fetched
20:24 - in the first place, a very
standard three tier application.
20:29 - And this is exactly what we're
going to build as part of
20:33 - this course, so let's move on
and get started with coding.
20:41 - Okay, let's get started
20:44 - with the initialization
of our application.
20:47 - First things first,
20:48 - we need to create a Git repository
somewhere so we can host
20:53 - to code start creating pull requests.
20:55 - You can do that on
Bitbucket, Gitlab or GitHub.
20:59 - I choose GitHub here,
21:01 - but this works with any other
hosting provider as well.
21:05 - So at the top right,
21:06 - I'll start by clicking
the plus new repository.
21:11 - I want this to be part of Gitpod-IO,
21:15 - full-stack-web-development,
that's the repository name.
21:20 - I want to make it public, so
you all have access to it.
21:23 - And you can look at the source
code and follow along as well
21:27 - as I want to add a read me
file just so that we have some
21:32 - content in the repository
when we get started.
21:36 - Let's create a repository
21:38 - and that only takes a couple seconds.
21:41 - Now we've got this all
set up and we are ready
21:45 - to initialize our SvelteKit
application so that we can
21:50 - then build the front end
and eventually deploy
21:54 - that application to Vercel.
21:57 - The first thing you notice on my screen
22:00 - is that I have a green Gitpod button
22:05 - that I added here as a browser extension.
22:08 - If you're interested in following along,
22:10 - and I recommend you to just
experience what it is like
22:15 - to develop your application in the cloud
22:18 - and access it through a
browser, you can install that
22:21 - Gitpod button by opening a
new tab and Gitpod.io/docs
22:27 - and search for browser extension
22:31 - and the References browser extension.
22:34 - You can click the Chrome link
if you're on a Chromium based
22:37 - browser or Firefox if you use Firefox,
22:41 - I believe there's a safari extension
22:43 - as well that you can find as well.
22:46 - So once installed, then you
will see that green button,
22:49 - if you don't want to install
that for some reason,
22:54 - you can achieve the same
behavior as the button does
22:58 - by going to your URL in the address bar
23:01 - and prefix the URL with Gitpod.io/hash
23:06 - that's Gitpod.io/hash,
23:09 - that works for GitHub, Gitlab
or Bitbucket repository URLs.
23:15 - When you hit enter, that
will start a Gitpod workspace
23:20 - for that specific URL that you provide.
23:24 - The only difference between
23:26 - using the URL and using the button,
23:28 - is that the URL navigates away
from your repository page.
23:33 - Whereas the button over here
create a new environment
23:38 - and opens a new browser tab
23:40 - and then starts to workspace there.
23:43 - So I prefer the button
just many for that reason.
23:46 - And also it's easier
than changing the URL.
23:49 - Before we do any work,
23:51 - we don't want to work on the main branch.
23:55 - So let's quickly create an issue
23:57 - so that we can do our work
in the feature branch,
24:00 - and then merge that branch
back into the main branch
24:03 - when we are ready for that.
24:05 - Let's call it initialize the application.
24:11 - We submit that.
24:13 - And now we are looking at
an issue and we still have
24:17 - to GitPod button, so at
the same concept applies
24:21 - prefix the URL Gitpod.io/hash
24:24 - or install the browser extension.
24:27 - We're going to click the button here.
24:29 - You see it opens a new tab.
24:31 - It creates a developer
environment from scratch,
24:36 - and that's every time we
do any work on an issue,
24:39 - we use a brand new environment
and we will later automate
24:43 - this so that it will
download dependencies,
24:46 - start the dev server, start the database,
24:48 - it will all do all that for us.
24:51 - So we don't have to do
any of that manually.
24:54 - So that's a pretty good start.
24:57 - What we're looking at here is VS Code
25:02 - accessed through a browser,
25:04 - but also we have access to the terminal.
25:08 - So if we go to the hamburger menu,
25:09 - terminal, and new terminal,
25:13 - what do you see down here is just
25:16 - a Ubuntu based operating system
where we can run commands
25:20 - that you can run locally as well.
25:22 - And we can use to have just
as a local environment.
25:27 - By the way, if you prefer to
work on your local computer,
25:33 - then you can certainly
clone the repository
25:36 - and follow along locally.
25:38 - The alternative is that
you could still leverage
25:41 - the high powered computers that you get
25:44 - through Gitpod, but use your
local VS Code, so again,
25:49 - through the menu at the
bottom here, you could say,
25:53 - GitPod open in VS Code or
GitPod opening VS Code insiders,
25:58 - depending on which version
of VS Code you have installed
26:01 - on your local computer.
26:03 - What that does is it will
basically start up VS Code
26:08 - on your local computer and
connect to the GitPod environment
26:12 - in the cloud.
26:13 - So you would leverage CPU and
memory and hard disk space
26:17 - provided by Gitpod,
26:19 - but access it through your
local VS Code instance
26:22 - if you prefer to do that.
26:24 - In my case, I prefer the
browser because you know,
26:28 - it's simply opening a tab,
26:30 - but you can use any of
these ways to follow along
26:34 - with the tutorial, there's
no much difference.
26:37 - All right, we have a
repository with a read me file
26:42 - that has no content basically.
26:44 - What we want to do next is create
26:46 - the SvelteKit application
26:48 - so that we can initialize
that application,
26:52 - commit and close that issue.
26:56 - In order to do that, let's go over
26:58 - to the documentation for SvelteKit.
27:00 - So kit.Svelte.dev
27:06 - that's kit.Svelte.dev, hit enter.
27:09 - And on that page, there's a
bunch of good information.
27:12 - The docs are very valuable,
27:14 - but what we care about at the
moment is how to get started.
27:18 - NPM init, Svelte dot next
27:23 - and the name of our application.
27:27 - In our case, we already
have an application created
27:29 - when we created the Git repository.
27:32 - So let's just copy the first
part npm_init_svelt@next,
27:35 - we copied that part, and in our terminal,
27:44 - in the terminal, we can paste that.
27:46 - And then we can just instruct
the command line interface
27:49 - to use the current directory
27:51 - instead of giving it a application name.
27:55 - If we give it a name, it would
create a directory for that.
27:58 - But we are already
27:59 - in the full stack web
development directory.
28:02 - So npm init svelte@next .
28:07 - It's asking if we want to
install that package, we say yes,
28:13 - that was a very quick,
downloaded a few things.
28:16 - And now it is telling us
that this is beta software,
28:22 - expect bugs and missing features,
28:24 - that's just a warning as well.
28:26 - SvelteKit is used in production
at numerous companies,
28:29 - including Gitpod's marketing website.
28:32 - So this is not really a concern.
28:36 - Just something to be aware
of that there may be breaking
28:39 - changes, but the documentation
is extremely well done.
28:43 - And it tells you how to migrate
28:45 - if there's something breaking.
28:48 - The next thing we noticed is
that the directory is not empty
28:52 - that's because we already
have a read me file.
28:55 - In our case, we can safely say yes,
28:58 - that we want to continue,
so we press the Y.
29:02 - And now it's asking us
which Svelte app template.
29:06 - You have two choices here.
29:08 - We can choose the SvelteKit demo app,
29:11 - which gives you three pages.
29:14 - And one of the pages is
29:16 - the todo application that
we are going to build.
29:19 - The other alternative is skeleton project.
29:22 - That's what we are going to use
because the skeleton project
29:26 - gives you a very bare minimum foundation,
29:31 - very little configuration,
very little code exists.
29:34 - And that's really the best
way for us to go through
29:38 - the entire full stack web
development from the beginning,
29:42 - building the web
application and documenting
29:45 - or talking about every single line of code
29:48 - that we we're going to write.
29:49 - So by the end of it,
29:51 - you fully understand
why the code is there,
29:54 - what it does, and what its impact is
29:56 - to the overall application.
29:59 - So which Svelte app template?
30:01 - Let's choose skeleton
project for this question.
30:06 - The next question is, do
we want to use TypeScript?
30:09 - The answer is yes,
30:11 - that will help us when we
start to introduce Prisma
30:14 - as well as when we work with
the code in our application.
30:17 - So let's say yes for the question,
whether to use TypeScript
30:23 - and then yes lint for code linting.
30:27 - We're going to say no, that's,
you know, either way works,
30:30 - but for the purpose of this
course, we're going to say no.
30:34 - And Prettier for code formatting.
30:36 - I highly recommend you
do that in your project.
30:39 - Once you went through the
course and do more familiar
30:42 - with the full stack web
application development,
30:45 - in the case here,
30:46 - we are not going to configure
this as part of the course.
30:50 - So we are going to say, add
Prettier for code formatting.
30:52 - No.
30:56 - There we go, a updated read me file.
30:58 - So we can close that tab.
31:01 - The other thing we notice
31:03 - is that it gives us some next steps.
31:06 - The first is NPM install
to get all the dependencies
31:11 - and run all the scripts, so let's do that.
31:15 - NPM install in the command line
31:20 - that downloads a few
necessary dependencies,
31:24 - such as Svelte and SvelteKit,
31:27 - and the other step was to git init.
31:32 - We don't need to do that
because we already have
31:34 - a git repository and
git add, and git commit,
31:37 - we will do later in a
slightly different way
31:40 - than using the command line interface.
31:43 - What we do want to do too is NPM run dev,
31:46 - that will start our development server,
31:49 - and we can have a quick look
at what we get to start with.
31:54 - So let's run that, NPM run dev
32:00 - it starts the server on
localhost port 3000 and GitPod,
32:05 - notice that there's no
service running on that port,
32:09 - so it prompts us to open a
preview or open a browser.
32:12 - If I click open a preview,
32:15 - you can see that the
simple browser pops up
32:18 - right within my editor so
that I can review the code
32:22 - of my application right here.
32:25 - The alternative is if we go to the footer
32:29 - and we click on port 3000,
32:32 - you can see it switched
to the remote explorer tab
32:35 - on the left side.
32:37 - Port 3000 has an option
in the middle to open
32:41 - the preview again, same as before,
32:45 - or on the right side,
If we press the globe,
32:48 - we can open a browser
which opens a new tab.
32:52 - And now we can inspect
that web application
32:56 - just the way we would do
an old local computer.
33:00 - Okay, that's a pretty good start.
33:03 - I think we satisfied the
requirement of the first issue,
33:08 - which was to initialize the application.
33:11 - What are we going to do
now is commit these changes
33:14 - merge it into the main branch.
33:16 - And then we will follow up
and go through the folders and
33:21 - directories that exist in here
created by the init script
33:27 - when we created the application earlier,
33:29 - so that you understand all
these files and what they do.
33:33 - All right, in order to commit
and push these changes,
33:38 - we can use the source
control tab on the left.
33:40 - If you're familiar with
the command line interface,
33:43 - we can control C in the
terminal, cancel the server,
33:47 - and you can use the git
commands right here.
33:50 - That works as well.
33:52 - Let's use the UI for now.
33:54 - So we have to give it a commit message.
33:57 - We're going to call this
initialize the application,
34:02 - and we can click the button
34:05 - with the check mark up here to commit.
34:09 - Alternatively, with
the text field focused,
34:12 - you could do command enter
34:14 - or control enter depending
on your operating system
34:17 - and get the same result, but
click the button for now.
34:22 - It is asking us that or telling
us that there are no stage
34:26 - changes, that's because we
didn't stage any of that.
34:30 - And it offers us to
automatically do that for us,
34:33 - and then commit the files in
this case, we're going to say,
34:36 - yes, that's what we want.
34:38 - Take all these files and commit them.
34:42 - Wonderful.
34:45 - We have it committed, we have
not pushed it to GitHub yet,
34:49 - so we could press the publish
changes button right here.
34:53 - And then we can go to GitHub,
create the new pull request,
34:58 - and merge that into the main branch.
35:00 - The alternative and I believe faster way
35:04 - is to use that icon next
to the commit, the one here
35:08 - that says create pull request.
35:11 - If we do that, you can see that
35:14 - it automatically creates
a pull request for us.
35:18 - One thing we want to do is update the name
35:21 - of the title that defaults
to the name of my branch,
35:25 - and that we'll talk about
the branch in just a second
35:28 - for now, let's change the title
to something more readable
35:34 - I need a description,
35:36 - I like to say which issue we are closing.
35:39 - In this case, it's number one.
35:42 - If you don't remember which
issue you're working on,
35:45 - you can always look in the footer
35:47 - where you have a branch
name with your user name
35:50 - slash the name of the issue
dash the number of the issue.
35:57 - So if we look at the issue
here, it is initialized
35:59 - the application number one,
the branch name is the same.
36:05 - Now you remember,
36:07 - I never actually created a new Git branch.
36:11 - All I did was I started to
Gitpod developer environment
36:15 - from that issue by
clicking the Gitpod button.
36:19 - So Gitpod is all about
automating your developer
36:21 - environment and making
you more productive.
36:25 - Now it knows that in 99% of the time,
36:28 - when you open a Gitpod developer
environment from an issue,
36:33 - you're probably going
to work on that feature
36:36 - and you want to eventually
create a pull request
36:39 - to merge back into the main branch.
36:41 - So GitPod is smart enough to just create
36:44 - that branch for you with a
sensible default, in this case,
36:48 - it's user name slash issue
dot title dash a number.
36:53 - We don't have to do that
any time by ourselves.
36:55 - It's just done for us.
36:57 - So if you don't remember
36:58 - what issue number you're
working on, check the footer.
37:02 - Next up, we can create the pull request.
37:07 - And it's telling us that
there's no upstream branch
37:10 - for that name, that's fine.
37:13 - Please publish it for us automatically.
37:16 - We can say publish branch
that pushes the branch,
37:20 - creates a pull request in GitHub.
37:23 - And you can see now we have a preview here
37:26 - of what that PR looks like,
37:28 - and we could even merge
it right away from here.
37:32 - What I want to do instead is go back
37:34 - to GitHub and show you what it did for us.
37:37 - It created a pull request,
it linked it to our issue
37:39 - number one, because I said
close issue number one.
37:43 - If you go to the PR, see
this closed issue number one.
37:47 - That's how GitHub knew
that they are connected.
37:52 - And usually we would ask a
colleague to go and review that.
37:56 - We will do that by ourselves
in just a little bit.
37:59 - For now, we can safely go in here and say
38:02 - that we would like to
merge that pull request.
38:06 - So we say merge, and we confirm.
38:10 - Now that merged the PR,
you can see it's merged.
38:16 - We don't need the branch anymore.
38:18 - And if we go back to
issues our issue got closed
38:21 - because the application
is now initialized.
38:28 - We still have that
environment running here.
38:30 - And what do we want to do with that?
38:33 - If you work locally, then you
would keep that environment,
38:37 - you would switch back to the main branch,
38:39 - pull down the latest
changes we just merged.
38:43 - And then when you work on the next issue,
38:45 - you would create a new
issue, create a new branch.
38:49 - You know, start working
and do that over again.
38:50 - With Gitpod because we
get a new environment
38:54 - for every task we work on,
38:56 - we can either just close the browser tab
38:59 - and that environment will
automatically shut down
39:02 - a few minutes later.
39:04 - Or we can explicitly go
to the hamburger menu
39:08 - and say, Gitpod, stop workspace.
39:12 - And then it starts to shut down
39:14 - and it will eventually disappear.
39:16 - We no longer need that, we
never have to come back to it.
39:20 - If for some reason you
39:23 - do want to get back to an old environment,
39:26 - you can always go to Gitpod.io/workspaces,
39:30 - and you will get access to
that or click open workspace
39:35 - from this tab, which would
open it again if you needed to.
39:38 - The dashboard will show you a
list of existing workspaces.
39:42 - As I said, there's very few reasons
39:45 - where you really want to go back.
39:48 - We are done with that, so
we close the browser tab.
39:51 - We don't need the documentation either.
39:53 - Goodbye.
39:55 - All right, back to the main page,
39:59 - we now have our application initialized.
40:02 - So let's dive in and learn
about each of these files,
40:06 - what's important and how
we can work with these
40:10 - files to build our application.
40:15 - Fantastic work.
40:16 - We already merged our
very first pull request.
40:21 - There's a few more to go
until we have a end-to-end
40:24 - full-stack web application.
40:26 - Before we do any more coding though,
40:29 - I want to go through and make
sure you fully understand
40:32 - what the different files
and directories are
40:36 - within our project.
40:37 - If you are already familiar
40:39 - with a SvelteKit application,
40:41 - then feel free to fast
forward 10, 15 minutes or so
40:46 - to go to the next section
40:48 - where we will continue with the coding.
40:51 - If this is the first time you hear
40:52 - about SvelteKit, I highly
recommend you follow along
40:57 - and learn about the configuration
files, the NPM script,
41:00 - and the source code so
that you later understand
41:04 - where each file is and what they do,
41:08 - and what's their purpose.
41:09 - So we could review the
files and code right here.
41:16 - I think a VS Code environment
is a bit more familiar
41:20 - for most people, so let
me start a new workspace
41:23 - on Gitpod, straight on the main branch.
41:27 - And use to walk you through
41:30 - and explain the different
files and directories.
41:35 - Okay, that should only
take another second.
41:40 - We don't need to get started
page, let's have a look, so
41:47 - the arguably most important
file in this entire application
41:52 - is the package.JSON file.
41:55 - If we open that up,
41:57 - you can see that it has a name of version
42:02 - and that's a good start,
42:04 - you can start tweaking that as you go.
42:07 - Now, the other thing to
look at is the dependencies.
42:10 - The first thing you notice is that
42:12 - it only has a dev dependencies.
42:16 - So when you build a Svelte application
42:20 - or in this case SvelteKit application,
42:23 - then Svelte itself is
not really a framework
42:29 - that needs to be part of
your production dependencies.
42:32 - In fact svelte is a compiler
42:36 - that converts or compiles our Svelte files
42:40 - into pure JavaScript that can be deployed
42:44 - to the browser where the
browser then just parses that.
42:48 - So it's very little overhead.
42:51 - And the performance
therefore is quite good
42:56 - on the browser side,
42:59 - because there's a lot
less code to download,
43:01 - a lot less JavaScript
to parse and execute.
43:04 - So because of that, you notice
that the Svelte dependency,
43:11 - as well as the Svelte JS
slash kit dependency for our
43:15 - application framework, they
are both dev dependencies.
43:21 - The other dev dependencies
you notice is Svelte-check
43:25 - pre-process, we'll look at all that later.
43:29 - What we also want to
look at is the scripts.
43:31 - There are a number of interesting scripts
43:34 - that need to be talked
about, the first one is dev.
43:37 - If you're going to run that
out would be NPM run dev,
43:40 - we saw that a few minutes ago,
43:42 - it uses a binary called SvelteKit
43:45 - that's provided by our
SvelteJS/Kit dependency.
43:50 - SvelteKit takes a number of arguments.
43:53 - If you pass in dev,
43:55 - it starts a local development server
43:58 - that also provides hot module reloading.
44:01 - So we can make code changes
44:03 - and we see the changes in the browser
44:05 - without the need to
refresh the application.
44:10 - The next script that's defined is build.
44:16 - Because Svelte is a compiler,
44:17 - before we can deploy the application.
44:19 - We have to run the build script,
44:22 - which goes through our entire application,
44:25 - compiles all the files
44:27 - and generates an output into
a directory here as well,
44:34 - the root, we will see that later.
44:37 - That directory will then
be consumed by adapters.,
44:41 - we will talk about that
when we get to deploy
44:43 - the application, but basically
it's an intermediary format
44:48 - of JavaScript files and
other files needed to deploy.
44:55 - So the build step
compiles the application,
44:56 - creates that output,
and then we'll skip on,
45:00 - and we look at preview.
45:04 - Preview allows us to start a local preview
45:07 - based on the generated
output from the build script.
45:10 - So if you run NPM run build,
and then NPM run preview,
45:16 - you get a preview of your
application the way it will look
45:20 - in production, so no hot module reloading,
45:24 - no development server running.
45:27 - This is really much
more closely reflecting
45:31 - what the production environment
is going to look like.
45:35 - There's two more scripts I
want to quickly talk about,
45:37 - this is check.
45:39 - So check allows us to use a package
45:42 - or a binary called Svelte-check.
45:45 - This is very handy because
it's kind of like ESLingt,
45:49 - which checks your JavaScript
code, Svelte-check
45:54 - reviews your Svelte files and
gives you a warning or hints
45:58 - if certain things are missing.
46:00 - For example, if you have
accessibility issues
46:04 - in your website, such
as missing attributes
46:08 - for accessibility on
your images or buttons,
46:12 - the Svelte-check binary
will tell us about that
46:16 - and give us the output in the console
46:19 - so we can then address
it and make sure that the
46:21 - applications we build are
of the highest quality.
46:26 - Check:watch is basically the same thing,
46:28 - but it runs continuously.
46:30 - So while we're making code changes,
46:33 - if we run that in the terminal,
46:34 - it will continue to output
any potential errors,
46:38 - and we can fix that while we're
working on the application.
46:44 - The package script that we
skipped so far is really
46:50 - something more advanced
that we don't really need
46:52 - to worry about right now.
46:53 - But if you were to develop a library
46:56 - that you want to publish to NPM,
46:58 - you could use to packet script
47:00 - to help you with that process.
47:03 - For the time being, we can
safely ignore that and move on.
47:09 - So that makes up the
content of the package JSON.
47:12 - The next thing that's important
is the Svelte config file.
47:19 - If we look at that,
47:21 - you can see that there's a
couple of things going on.
47:24 - The first is the config
options that we export
47:31 - contain a pre-process property.
47:36 - And this basically just informs
47:41 - the Svelte compiler how
to prepare the code.
47:45 - So if we were to use SASS
47:51 - or other features in our CSS, for example,
47:53 - we could configure that here
and the Svelte compiler would
47:57 - take that into account
when it processes the code.
48:03 - The other important property is kit.
48:06 - And one thing you notice
is there's an adapter
48:09 - defined at the moment.
48:11 - This is using an auto
adapter provided by SvelteJS.
48:15 - So later we will replace
that with a Vercel adapter
48:21 - so that we can deploy to Vercel.
48:23 - If we were to deploy to
Netlify or CloudFlare workers,
48:27 - we could install the appropriate adapter,
48:31 - replace that line, and
we would be good to go.
48:34 - We will do that later in the course.
48:38 - The next thing is a target.
48:42 - And you can see the comment.
48:44 - This is telling the application
48:48 - where to render the Svelte app.
48:52 - It's similar to what you
might be might have seen
48:54 - in other application frameworks,
48:55 - where you have a difficult
root, with an id root.
49:00 - So it is under source app HTML.
49:03 - There is a if with an ID Svelte,
49:06 - this is where the content
of our Svelte files
49:09 - will be rendered into.
49:11 - Let's have a look at
that src/app.html next.
49:16 - So source, app.html.
49:20 - This is the entry point
where we can specify HTML,
49:26 - all the attributes we need there.
49:28 - We can specify the head, the body,
49:30 - anything that is shared
across the entire application.
49:35 - It's a good place to
define common meta tags
49:39 - that do not change like, you know,
49:43 - the charset put in the favicon,
viewport things, all that.
49:48 - Later, we will learn how
we can populate the head
49:52 - with additional information,
for example, the page title,
49:55 - which changes depending
on the page we are on.
49:58 - And also down here,
49:59 - we see that div with id Svelte
where eventually the Svelte
50:04 - application will be rendered
into either server side,
50:08 - if we do a server side
rendering or on the client,
50:12 - when somebody navigates
from one page to another.
50:18 - Okay, the next important directory
50:23 - is under source and it's called routes.
50:26 - And within that,
50:27 - we have a file currently
called index.Svelte.
50:31 - If we open that up,
50:33 - you can see there's an H1 element
50:36 - with a welcome to SvelteKit
content, as well as a paragraph
50:42 - that says, visit some link
to read the documentation.
50:48 - That code is what's eventually added
50:53 - into that Svelte body here.
50:57 - So if we were to quickly
go to the hamburger menu,
51:00 - terminal open a new terminal.
51:04 - And we run NPM run dev,
51:06 - remember that starts
our development server.
51:10 - And oh, of course, that doesn't work.
51:12 - We have to first NPM install.
51:14 - We didn't have any dependencies installed.
51:20 - And with the dependencies installed,
51:23 - now we can run NPM run dev.
51:28 - And that spins up port 3000
Gitpod tells us about that.
51:32 - We can preview, see, this is
51:36 - the code I was talking
about in the routes.
51:39 - So if we make this,
51:44 - we can see there's a div
ID Svelte H1 in paragraph,
51:49 - which maps to, what we have
here, H1 and paragraph.
51:56 - Alright, we will add some
syntax highlighting to that file
52:00 - very shortly, for the time
being, the VS Code that we are
52:04 - using here, doesn't have the
Svelte extension installed,
52:09 - and that's why we don't see anything yet,
52:12 - but that's an easy fix
we'll do in a few minutes.
52:16 - Good, so let's get rid of this
52:19 - and close all these terminals.
52:24 - Good.
52:25 - The other thing I want to briefly touch on
52:29 - is the tsconfig.json.
52:32 - Because we select the
TypeScript as a framework
52:37 - that we're going to use
to build this application,
52:40 - SvelteKit automatically created
52:42 - that configuration file for us,
52:45 - and it has all the things we
need for this application.
52:49 - So there's no need to understand
each of these properties
52:55 - and configuration values,
if you are curious,
52:58 - the TypeScript documentation
contains notes about
53:02 - each one of those you can
mouse over and then just click
53:06 - the link to the docs, but as I said,
53:09 - there is no need to understand
what is going on here.
53:13 - It is safe to assume that
the Svelte developer team
53:19 - made a good decision here on the defaults.
53:21 - So we can trust them,
53:23 - that they did the right thing for us.
53:26 - Good, that concludes the
introduction to the files.
53:32 - So you know, it's very basic for now.
53:34 - Really, all we need to know at
the moment is source routes,
53:37 - index is our index page in the URL.
53:41 - If we were to create a about us page
53:47 - or any other route, then Svelte
uses a file based routing.
53:51 - So if we do routes new file,
53:54 - and we say about-us.Svelte,
53:57 - and then here, we would
have an H1 called about us.
54:03 - And if we were to go and
start to dev server again
54:06 - through the terminal and NPM run dev,
54:15 - if we go back to the tab that
we had opened previously,
54:19 - we can now go to the URL
and do slash about-us.
54:24 - And then we see the content
of the about us page.
54:28 - So this is how you can
create multiple pages.
54:32 - In our case, all we're going to do is use
54:35 - that index page to build our application,
54:37 - but it's good to know how you
can extend your application
54:39 - to add additional content.
54:43 - Fantastic, so this is
all we want to talk about
54:46 - for the time being.
54:48 - Let's now go on and
continue with the setup
54:53 - of our developer environment
and this environment here,
54:56 - we just use that for a showcase purposes.
54:59 - So even though I have changed
files here, I can just say,
55:03 - go to the menu here and
say, Gitpod, stop workspace.
55:08 - And I don't have to worry
about these changes.
55:10 - They will never interfere with
my new environment that I'm
55:14 - going to create to work on
as my part of the next task.
55:18 - So we did that, we can close the tab.
55:21 - We also don't need this anymore.
55:23 - And we are back to the GitHub repository.
55:27 - So with that, let's swiftly move on.
55:33 - The next section of this course
55:37 - is only for people who follow along
55:39 - using Gitpod, the automated
developer environment.
55:43 - So if you prefer to work
on your local computer
55:47 - and don't want to experience
the way it works on Gitpod,
55:51 - then feel free to jump
down to the description and
55:55 - click ahead to the next section.
55:58 - For anybody who does
want to work on Gitpod
56:01 - and do remember you get 50
hours for free every month.
56:05 - So that's a good
opportunity to play around,
56:08 - get an idea of how this
way of working helps you
56:11 - and makes you more productive.
56:14 - What are we going to do now
is configure Gitpod so that
56:19 - when we start a new developer
environment for this project,
56:24 - we want to Gitpod to run certain commands
56:27 - automatically for us.
56:29 - We also want to configure the
VS Code in order to make sure
56:35 - everybody who works on this project
56:38 - has the same VS Code extension,
56:40 - so everybody gets a great
experience out of the box
56:44 - and if they want to, they
can install other extensions
56:47 - that they personally prefer.
56:49 - But at least there's a
base set up that makes
56:53 - for a great experience for
everybody who uses that project.
56:57 - So let's go ahead and configure
the Gitpod environment.
57:04 - We have an issue created already
57:08 - called configure Gitpod.
57:10 - If we open that up and
as we did before we click
57:14 - the Gitpod button to spin
up a new environment.
57:19 - That takes a couple
seconds just to pull down
57:24 - the necessary container
image and start the IDE.
57:36 - There we go.
57:38 - Now in order to configure
Gitpod, we have two options.
57:43 - One, we can go to Gitpod.io/new.
57:51 - If we go there, we can
create a new project.
57:54 - We can select the organization
57:56 - or account, and then our repository,
58:00 - and then follow along the instructions
58:04 - on the screen to configure the project.
58:08 - Now I prefer to add a configuration file
58:14 - to my source code so
that the configuration
58:19 - of the developer environment
58:20 - is also part of the revision history
58:24 - so we can see what changed
and when did it change
58:28 - and maybe also the reasons
behind some of the changes.
58:32 - So the way we can do that
58:33 - is we can create a new
file at the project route.
58:38 - So if we right click into
the black area around here,
58:41 - we say new file.
58:43 - The file name we want
to create is .Gitpod.yml
58:48 - which stands for YAML, GitPod.yml
58:52 - And within the file here,
58:55 - we have certain properties
that we have to define
58:59 - in order for Gitpod to pick that up.
59:03 - What we can do is we can do autocomplete
59:05 - with control space,
59:07 - and it gives us a number
of top level properties
59:11 - that we can specify.
59:13 - Now, if we don't know what
they do, the easiest way
59:16 - to learn about that is to jump over
59:19 - to the docs on Gitpod.io/docs.
59:23 - And on the left side,
if we go to references,
59:29 - they say .Gitpod.yml reference,
59:32 - and you can see that all the options,
59:35 - including sub properties are defined
59:39 - and well-documented in here.
59:41 - So if you get stuck or if you're
not sure what to configure,
59:46 - this is your go-to place
for the configuration file.
59:53 - Now for us,
59:55 - I'll walk you through the key things
59:57 - that we need to make sure are configured.
60:01 - When we start a new workspace,
60:03 - you saw it a few minutes ago,
we have to run NPM install,
60:08 - and then we have to run NPM run dev,
60:10 - and we have to do that every time we start
60:13 - a new workspace just like
in your local environment,
60:16 - you have to start a dev server
60:19 - every time you work on your project.
60:21 - Now with Gitpod, we can automate that.
60:24 - So there's something
called a tasks property.
60:29 - And as you saw, if I use
auto complete for that,
60:35 - tasks, it automatically gives me a dash.
60:39 - And then it lets me type something here.
60:42 - So again, if we use auto-complete
60:44 - at that level, it gives me a few options.
60:48 - So what do we want to do for now,
60:50 - we'll look at other ones later,
60:52 - but for now we need an init
task, so we can say init.
60:58 - And init is something that runs every time
61:02 - somebody pushes code to
the GitHub repository.
61:07 - Imagine your colleague,
they merge a pull request
61:10 - into domain branch, and
as soon as that happens,
61:15 - something called GitPod prebuild kicks in.
61:19 - So GitHub notifies
Gitpod about the change,
61:23 - and then Gitpod kicks off
a prebuild where it looks
61:28 - for to GitPod YAML file and
automatically execute whatever
61:32 - commands we specify within the init tasks.
61:37 - So in our case,
61:38 - we want to always download
and install to dependencies
61:42 - for our project, as soon
as somebody changes code.
61:46 - So we can see NPM install
for the init task.
61:51 - Now there's one more thing we
want to add to that same task.
61:55 - So remember one dash equals to one task.
61:59 - The other thing we want to
add is a command right here,
62:04 - the command executes when
somebody starts a workspace.
62:09 - So at this time,
62:10 - NPR install already executed
on the Gitpod server
62:14 - at some point before
somebody starts to workspace.
62:19 - So what do we want to do
62:19 - every time somebody opens
one of these workspaces?
62:23 - We want to start the
development server, NPM run dev.
62:29 - So with that, we can
now open the workspace.
62:35 - Anytime we open a new workspace,
62:36 - the server will already be started for us,
62:39 - and we are ready to
start writing some code.
62:44 - And before we go any further,
62:47 - let's validate that these changes
62:49 - do what we expect them to do.
62:51 - The way to test that is to
62:57 - keep this developer environment,
so if we look at the URL,
63:00 - we are currently on an
environment called copper-thrush,
63:06 - we want to keep that,
63:08 - and we want to start a second environment
63:11 - where we are going to test these changes.
63:14 - So the way we can do that
is in source control,
63:19 - we can add a comment here
63:22 - to commit the tasks that we configured.
63:26 - So add init and command tasks.
63:32 - We can commit, then we say, yeah,
63:35 - please do a stage and commit that.
63:38 - And we create a pull
request remember, right next
63:41 - to the check mark, we can
say create pull request,
63:46 - and that's eventually we will want to call
63:53 - this pull request, add
Gitpod configuration.
63:59 - And we want to close issue number three.
64:06 - Remember down at the bottom,
64:07 - you can see in the branch name,
64:09 - which issue number we're working on.
64:12 - For now, we are not done
with that pull request,
64:14 - we want to do more work,
64:16 - but we want to just test these
two tasks, these two lines.
64:21 - So let's make it a draft so
that everybody else on the team
64:24 - knows we're working on it.
64:27 - Yep, same message.
64:29 - We don't have an upstream branch,
64:30 - please publish that for us.
64:35 - All right, we don't want
to run that, all good.
64:39 - Ignore that error, that's not relevant.
64:42 - Okay, now going back here, we
do have a new pull request.
64:47 - Add Gitpod configuration.
64:49 - Here, we can see that
we added these two tasks
64:52 - to the GitPod YAML file.
64:55 - Now in order to test that new file
64:59 - that we created, we can go
to the conversation tab.
65:05 - And what we can do is start
a second Gitpod workspace.
65:10 - Again, remember the
URL starts with copper,
65:14 - and if we open a new one,
it is now ember-dragonfly.
65:21 - That developer environment
here is completely separate
65:26 - from the one we have in
the other browser tab.
65:29 - The differences that the
amber-dragonfly Gitpod environment
65:35 - uses the new configuration file
65:39 - that we added to the branch.
65:43 - So look at that, there's
some stuff from VS Code.
65:47 - We see that a service is
available on port 3000
65:51 - and in the terminal we
noticed that our application
65:54 - is already running on port 3000.
65:58 - That is pretty incredible
because we didn't actually
66:01 - do anything, we just automated at once,
66:04 - and now everybody who uses this project
66:07 - in a Gitpod environment gets
all of that automatically.
66:11 - So what is the next thing
every developer is going
66:16 - to do when they work on this project?
66:19 - Everyone who works on that and
wants to make a code change
66:21 - wants to validate their changes.
66:23 - So the very next step
literally everybody would do
66:28 - is open that preview URL of
our development environment.
66:33 - So wouldn't it be nice if we
could automate that as well?
66:37 - Yeah, you guessed, right,
we can definitely do that.
66:39 - The way we do it is that the
environment we just tested,
66:44 - whether the application
starts up, amber-dragonfly,
66:49 - we can close that we no longer need it
66:51 - because we already tested
66:52 - and validated the changes
to the Gitpod YAML file.
66:56 - So hamburger menu, Gitpod stop workspace.
67:01 - We're going to throw that
away, never needed again.
67:04 - Now back here in the copper
environment or our developer
67:09 - environment where you can
clean some stuff up and back in
67:12 - the tasks, we can now add
something else at the top level,
67:18 - which is called ports.
67:21 - And we know that our server
starts on port 3000 right,
67:26 - in order to preview the web application.
67:29 - So we can say, Hey, Gitpod,
67:32 - if you see a service
listening on port 3000,
67:37 - then do something for
us, now we don't need
67:40 - the visibility private
that's the default behavior
67:43 - if we don't configure it,
so it will leave that out.
67:48 - But what we do want is control space.,
67:51 - and then we want to configure the onopen.
67:56 - Onopen, you can mouse over and
get more details about that.
67:59 - But this is basically
when Gitpod recognizes
68:03 - a service listening on
the configured port,
68:07 - and then it will do something for us.
68:09 - So we have a few options here.
68:11 - We can ignore it, this
is helpful for, you know,
68:14 - a database service or something that runs
68:18 - to use a hot module, reloading.
68:21 - Ports like that we don't care about,
68:24 - we can simply ignore them.
68:26 - Notify is the default
behavior that pops up
68:30 - that little box at the
bottom here we saw before,
68:33 - where we can open in
preview or open in browser.
68:36 - And we have these two options
as a default here as well.
68:40 - So in our case,
68:41 - we want to open a browser
window automatically
68:44 - so that we don't have to click that link
68:47 - in the terminal, let's do that.
68:50 - There we go.
68:51 - That is now going to
open a new browser tab
68:54 - with the preview automatically.
68:58 - So let's have a look.
69:01 - We're going to go back
to our source control.
69:04 - Quickly double-check, we
added a ports, all right,
69:07 - so let's commit that saying
configure port 3000 behavior.
69:15 - Yep.
69:17 - Same thing.
69:18 - This time around, we
already have a pull request,
69:20 - so we don't have to create another one.
69:22 - All we can do is just use these three dots
69:27 - or click the sync changes, either way.
69:29 - Three dots and push or sync changes.
69:33 - And this will say, yup,
69:35 - yup, it will pull and
push all the changes.
69:38 - Go for it.
69:40 - Fabulous.
69:42 - We're moving back to the pull
request where we now have
69:46 - that configure port 3000
behavior as a new commit message.
69:53 - In order to test that and make sure
69:56 - that the developer environment
does open a new tab,
70:00 - same as before, we
click the Gitpod button,
70:04 - open a new environment,
70:06 - and you can see there's
a prebuild in progress.
70:09 - That is because my environment
is already configured.
70:13 - So prebuild means it is
running the init script
70:17 - that we configured into GitPod YAML file.
70:20 - That happens only once,
we were just too quick,
70:23 - that hasn't finished, that's
why we saw it in the URL
70:26 - on the UI, but there we go,
70:28 - now it starts coral-llama environment.
70:32 - Again that's the third
developer environment
70:34 - and it also opens a tab for our preview.
70:39 - That's pretty cool, it
doesn't ask us anymore
70:42 - whether we want to open a
preview or open a browser
70:44 - for this port.
70:46 - That's the VS Code pop
up, we can just say no.
70:53 - Get rid of that.
70:54 - Okay.
70:56 - That's pretty cool, now let's have a look.
70:59 - If we go to the preview
environment and we inspect
71:04 - the website, you can
see vite connecting...
71:10 - And if we wait a couple of seconds,
71:12 - it will try to reconnect again.
71:15 - What's happening here is
that SvelteKit under the hood
71:19 - uses what's called vite.
71:22 - And that provides a hot
module reloading functionality
71:26 - that we want to leverage.
71:30 - Now, unfortunately by default,
71:35 - the vite server runs on
port 3000, localhost:3000.
71:43 - The problem we have is
that our web address
71:48 - is a public URL on a Gitpod.io subdomain.
71:52 - So you noticed that was a reload
71:55 - and it didn't actually
successfully connect.
71:59 - That's not a big deal.
72:01 - We can configure vite in
order to do the right thing,
72:04 - it keeps doing that reloading
here until we configure it.
72:09 - So we are running on an HTTPS URL
72:14 - that is this super long URL here
72:18 - and no port, which means
HTTPS default port is 443.
72:23 - So what we need to do is we need
72:27 - to somehow configure
SvelteKit to use this URL,
72:32 - to connect to the hot
module reloading server,
72:36 - instead of using
localhost 3000 by default.
72:40 - Let's have a look and how we can do that.
72:45 - First we are going to stop the server
72:48 - and what are we going to do next
72:50 - is we're going to close
or actually keep the same
72:55 - environment here, remember
the old one we had,
72:58 - where we configured the tasks
73:00 - and then we pushed it to GitHub?
73:03 - That environment is something
we could keep working on,
73:09 - but it doesn't really make much
sense because it's outdated
73:13 - by now, we started up
the new environment based
73:16 - on the new configuration.
73:18 - So we can basically just stop this,
73:21 - stop this environment now
and no longer worry about it.
73:27 - We'll shut that down.
Close the browser tab.
73:32 - Now we are working on that
pull request that we opened up.
73:39 - Okay, so we stopped the server down here.
73:42 - And the next thing is in
the Svelte config file,
73:45 - we can come in here and down in the,
73:52 - in the kit configuration,
we can add a new value.
73:58 - So what do we want to do here is vite
74:03 - and then it's called server, you can see,
74:05 - we get nice autocomplete for everything.
74:08 - And then the property is HMR
for hot module reloading.
74:13 - There's two properties we want to set.
74:16 - The first is client port, as I mentioned,
74:18 - the default is 3000 and the
other one we want to set
74:24 - is the host.
74:26 - And again, by default, this is localhost.
74:32 - The question is, how do we
change this port to 443,
74:39 - and this host to whatever
URL we have here?
74:43 - That URL changes for each environment,
74:46 - so we need to find a
way to dynamically load
74:50 - the URL and configure
the Svelte environment.
74:56 - So luckily the Gitpod environment provides
75:01 - a command line interface that's called GP.
75:06 - So if we open the terminal
a bit bigger here,
75:09 - I can show you how this looks.
75:11 - Let's clear this.
75:12 - If we type gp url, that gives us the URL
75:19 - of our environment, matches
the URL up here, right?
75:24 - However, our URL has the port in front.
75:28 - So gp url accepts an argument,
75:33 - if we pass the port number at the end
75:35 - and we hit enter again,
75:38 - it gives us the preview URL of
that port that we specified.
75:44 - And this is the URL that we
want to specify for the host,
75:49 - and then port 443.
75:53 - We could somehow try to hard-code that,
75:56 - but not everybody uses Gitpod yet.
75:59 - So we have to also make sure
localhosts 3000 is configured
76:03 - for people who work on
their local computer still.
76:07 - Let's have a look, how we can do that.
76:09 - The easiest way is to use
an environment variable
76:14 - where we specify whether
we run on Gitpod or not.
76:19 - So the place to do that is
in the Gitpod YAML file,
76:25 - what we can do here is in the command.
76:29 - So when the new development
environment starts up,
76:35 - we want to run that gp url 3000 command
76:42 - and save the results, that URL
in an environment variable.
76:47 - That means if somebody
starts the environment
76:50 - in their local computer,
76:52 - none of the code in the
Gitpod YAML executes
76:55 - because they use a local environment,
76:57 - they don't get the benefits
of this automation,
77:00 - which then means the environment
variable that we're about
77:03 - to set does not exist on the
localhost, let's have a look
77:07 - how this looks like.
77:10 - So here we want to do export,
let's call it HMR_HOST
77:15 - and that equals, and then
two back ticks, gp url 3000.
77:22 - And then start the dev server.
77:27 - Now, HMR host after this line
77:31 - looks equals to this entire URL, HTTPS,
77:35 - blah, blah, blah.
77:37 - So let's have a look.
77:38 - We can take that HMR host
and in the Svelte config,
77:45 - since this is just a regular
JavaScript that executes,
77:49 - we can use the process.env for
all the environment variables
77:57 - and have a look at
whether HMR host exists.
78:04 - So we can just do a shorthand,
78:07 - which means if that URL exists
78:13 - then process env host,
otherwise localhost.
78:19 - So that means we can now run
this script either locally
78:25 - without Gitpod or on Gitpod.
78:27 - And the host is always set correctly.
78:30 - One small tweak we need
to do is that the HMR host
78:35 - is including the HTTPS
or the protocol as well.
78:40 - vite doesn't like that.
78:41 - It just wants to host
because it uses web sockets.
78:45 - So it will then change HTTPS
to web socket protocol.
78:51 - So we can use JavaScript here
78:53 - to basically just substring the HTTPS://
79:01 - So we'll do sub string
and HTTPS:// .length.
79:09 - This will get rid of that of that part.
79:16 - What I mean is .length in here,
79:19 - so that it counts the character here,
79:22 - and then start from the
beginning of that URL gets starts
79:26 - at this point here, and it
takes 3000 and the rest.
79:29 - The other thing we want to
do is if we have the HMR host
79:33 - variable set right here,
then the port is 443.
79:40 - Otherwise the port is 3000.
79:45 - So this work around here
in the Svelte config,
79:49 - let's make this a bit
bigger, get rid of that.
79:54 - The few lines here that'd
be added as a workaround
79:58 - allow us to run the HMR hot
module reloading on Gitpod,
80:07 - and also make sure that people
can still run the project
80:10 - locally and also get the
benefits of hot module reloading.
80:16 - So there's quite a few changes.
80:18 - It's definitely a good time to go
80:20 - and test that in a new
environment, before we do that,
80:26 - you can imagine that if we have more
80:29 - than two commands, like
even now we have this one
80:32 - and this one, if we had two
or three other commands,
80:36 - this will start to get
really hard to read.
80:39 - So there's a little bit of
a better way to write that.
80:42 - If we add a pipe here and
we moved that to a new line
80:46 - with two spaces indented,
remove the end, make a new line,
80:52 - we can now add as many commands here.
80:57 - Starting dev server.
81:01 - So we can add as many, and they
all run one after the other.
81:05 - So it's a bit easier to read
81:07 - and definitely easier to
maintain as we go forward.
81:10 - We don't need the echo, so
we can get rid of that line.
81:13 - But now we want to go and test
this in a new environment.
81:18 - So let's go to the source
control and commit these changes,
81:27 - configure HMR, oops
81:31 - on Gitpod and localhost.
81:37 - Alright, commit these changes.
81:41 - We can close that preview.
81:42 - We no longer need this or
browser tab, get rid of that.
81:46 - And we want to sync the changes.
81:50 - Here, we'll push, all right, go for it.
81:53 - I can probably stop showing
that from popping up.
81:57 - Nice.
81:58 - Heading back to the pull request.
82:01 - We have a new entry.
82:03 - That's the changes we just made
82:05 - in order to spin up an
environment on these changes.
82:08 - You know how this works by
now, click the GitPod button.
82:12 - It spins up a new developer environment
82:16 - that now contains that HMR
host environment variable.
82:22 - So let's have a look at what happens.
82:24 - It's good practice that you always keep
82:27 - at least one environment
running here in case, you know,
82:30 - something went wrong
with your configuration,
82:33 - or you run into some issues
with the changes you made,
82:37 - but just good practice
to keep that around.
82:40 - There we go, look at that,
we got the new browser tab.
82:44 - We saw that before, if
we inspect this now,
82:48 - then we can see that vite is now connected
82:51 - to the development server.
82:54 - So once we go back and we
start making code changes
82:58 - to that Svelte file, as
soon as we save to changes,
83:03 - that page will reload and
display the updated code.
83:08 - So that's nice, now we know
that our new environment,
83:12 - which is now beige-condor,
83:14 - we know this works and the configuration
83:16 - that we made in the
previous one was correct.
83:20 - So at this point,
83:21 - it is safe to come in here
and close that environment.
83:26 - So hamburger menu, Gitpod stop workspace.
83:30 - That's going to shut down, eventually.
83:33 - There we go, and we close it.
83:36 - Okay, very nice.
83:37 - So we now have HMR running,
hot module reloading works.
83:42 - We have a bunch of automation
to install dependency,
83:45 - start a dev server.
83:47 - And what do we want to do next
is, let's look at the source
83:54 - roots, index.Svelte.
83:59 - This is not ideal.
84:02 - Not having any syntax
highlighting makes it really hard
84:06 - to move along and start writing code.
84:10 - The solution for that is to install
84:11 - the Svelte VS Code extension,
84:14 - which is going to help
us with autocomplete,
84:17 - it's going to help by the way that syntax
84:19 - and all that kind of stuff.
84:22 - The way to do it is just
like you're used to,
84:24 - extensions over here.
84:27 - And then we can look at the recommended
84:31 - it already suggests that we
install Svelte for VS Code.
84:35 - So if we click on that,
84:37 - usually you would click
the install button,
84:40 - but that installs it only for yourself,
84:44 - and if you have other team members,
84:48 - you want them to have the
same experience and you want
84:52 - the extension to be
installed for them as well.
84:56 - So the way you can do that is if you look
84:58 - at that page on Gitpod,
85:01 - click the little settings icon
here to manage the extension.
85:06 - And then there's a menu item called
85:08 - add to Gitpod YAML file.
85:11 - And we click that.
85:13 - Then we can close the extension view here,
85:18 - switch back to the files, or the explorer.
85:22 - And now we can see that the file changed.
85:26 - So let's look at that
and see what we find.
85:31 - There is a new section that it
was added, VS Code extensions
85:37 - and then the ID of the
VS Code Svelte extension
85:43 - that basically just tells
Gitpod that every time somebody
85:46 - starts a workspace, to also install
85:49 - whatever extensions are listed here,
85:51 - you could add another dash
below and add additional
85:54 - extensions that are
needed for your project.
85:58 - One thing we do notice
is that it's underlined.
86:01 - So there's something wrong with it.
86:03 - And that's expected
because if we mouse over,
86:07 - you can see that the
extension is not installed.
86:11 - We only added it to that file
86:13 - so that the next time
we start the workspace,
86:16 - the extension will be
automatically installed.
86:18 - Now we have an option here
86:20 - to say quick fix and fix that for us.
86:25 - So if we do what we can say,
install the Svelte extension,
86:29 - or we could start another workspace.
86:31 - And then the Svelte extension
86:33 - will be automatically installed for us.
86:36 - So for now I'm going to opt out
86:38 - to just ignore that morning.
86:40 - And then when you start
the next workspace,
86:42 - you will see how the extension
is automatically added
86:45 - for us, and we don't have to do anything.
86:49 - Now there's one more thing I want
86:51 - to configure while we're here.
86:54 - But before we do that, let's
quickly make a commit here
86:58 - at the Svelte VS Code extension.
87:06 - Okay.
87:07 - Quickly commit that because
it's a unique change we made.
87:11 - So the last thing we want to configure
87:13 - in the Gitpod.yml file at
the route is the prebuild.
87:18 - So let me show you for GitHub,
87:22 - we can say that GitHub prebuild
87:27 - and we can give it a couple of settings.
87:30 - So the first thing we want to do
87:33 - is every time our main branch changes,
87:38 - we want to automatically
run the init script.
87:43 - So in order to do that we use master
87:48 - and then the value for that is true.
87:52 - The other thing we want to run a prebuild
87:55 - is every time somebody creates a branch,
87:58 - irregardless of whether there
is a pull request or not,
88:01 - but we basically want to
also run the init script
88:05 - on branches so that if somebody
was to preview a branch
88:09 - without having a pull request,
88:10 - they would get the same benefits
88:12 - of having NPM install already executed.
88:16 - So the way we do that is we
can just say branches true.
88:21 - And lastly, we want the same
experience for pull requests.
88:26 - So pull requests, true.
88:29 - Again, if you want to see what
other options are available,
88:34 - head over to Gitpod.io/docs,
references, Gitpod YAML
88:41 - and then you can jump down here
88:43 - to the prebuild and see
what else is available.
88:46 - So let me just add that to the top here.
88:54 - Hold on.
89:01 - See this URL.
89:05 - Let me just see, I think my
syntax is wrong for comments
89:12 - in YAML, there we go.
89:14 - It's a hash, not slash slash.
89:16 - So comment easily to find
that, we know about that, good.
89:22 - So this is a good place
to check that in as well.
89:26 - And now Gitpod that will
automatically run a init script.
89:32 - If for some reason, you know,
89:35 - you don't configure that prebuild setup,
89:38 - then what happens is when somebody starts
89:41 - workspace they would have to wait
89:43 - for the init script to complete.
89:46 - So it would just run as part
of each workspace startup,
89:50 - but you definitely want to enable prebuild
89:53 - because they will then
automatically run, you know,
89:55 - well before somebody
starts a Gitpod workspace.
89:59 - And it will run every time
the code changes on GitHub.
90:04 - Okay, configure Gitpod prebuilds,
90:10 - gonna push that as well.
90:16 - And we have two commits, we
want to push that to GitHub
90:23 - and make sure everything's
showing up, yep, it's right here.
90:28 - So with that, we could quickly
go and have a review refresh,
90:33 - see our latest changes.
90:36 - So we configured in init
task that runs NPM install,
90:39 - that happens automatically
every time somebody pushes code
90:42 - to GitHub, the command
exports the dynamic URL
90:46 - for our development environment URL.
90:50 - And then we start the server.
90:52 - If we see something on port 3000,
90:54 - which is our web application,
then open a browser.
90:57 - We also install the Svelte extension
91:00 - for better syntax support
in these Svelte files,
91:04 - as well as we configure prebuild
so that they run whenever
91:08 - there is new branches or pull requests
91:10 - or changes to the main branch.
91:12 - Lastly, we updated the Svelte config.
91:15 - We created a vite configuration
where we specified a client
91:20 - port and host for hot module reloading
91:24 - so that this works on Gitpod,
as well as on localhost.
91:29 - This looks pretty good.
91:31 - We can now go and ready for review,
91:35 - ask somebody to review that for us,
91:38 - and then go ahead and
merge the pull request.
91:42 - We don't need to branch,
91:43 - and we also don't need that
environment any longer.
91:46 - So we can close that and
close to preview as well
91:50 - And the docs.
91:53 - Good with that, we now
have a fully configured
91:57 - Gitpod developer environment
91:59 - that installs everything we need,
92:00 - runs all the scripts we need as well.
92:02 - And we can move on with
the next few tasks.
92:07 - And we want to do next is
92:12 - build the HTML structure
of the application.
92:15 - So we've got an issue open already
92:18 - called develop HTML structure,
before we get to that,
92:22 - let's have a quick look again at the UI.
92:25 - So what are we going to
build is just heading
92:29 - the form fields, the lines for
the individual items, no CSS,
92:35 - no functionality, we'll do
everything at one step at a time.
92:42 - So stay tuned for more afterwards,
92:46 - but for now, just the
bare bones HTML structure.
92:52 - In order to do that, we got an issue.
92:55 - So we're going to start working on that.
92:58 - And we learn about Svelte,
we learn about different ways
93:04 - of using Svelte's functionality,
93:06 - so that if you're familiar with
another framework, you can,
93:10 - maybe map the concepts between
the two frameworks you know
93:16 - Svelte and whatever you're
familiar with already.
93:21 - Okay, we have everything
set up, that looks good.
93:25 - Our environment looks okay.
93:28 - And the first things first,
93:33 - that page here is our index page.
93:35 - We want to change the title
so that it says todos,
93:40 - and start adding the HTML structure.
93:45 - Under source roots, we
have the index Svelte file.
93:49 - And you can see now that we
have syntax highlighting, that's
93:54 - because we configured that
in the Gitpod YAML file.
93:58 - We said, please automatically
install the Svelte extension.
94:03 - So back in the index file,
94:06 - we don't need the paragraph,
that is not needed.
94:09 - The H1 is just saying todos for now,
94:14 - so that it maps the todos we have here.
94:19 - Now below the todos,
94:23 - what do we want to do is create
that + tap to add a todo.
94:30 - That's really a input field of type text
94:35 - that's wrapped in an HTML
form so that we can submit
94:39 - that eventually to a backend where we can
94:42 - then process it and
persist in the database.
94:46 - So in terms of HTML structure
94:48 - for that first part of the user interface,
94:52 - we really just want to add a form,
94:58 - so we can use the form autocomplete here.
95:02 - It asks us to provide an action.
95:04 - We'll leave that empty for now.
95:06 - We also leave the method
empty that you can see us
95:10 - has some options, we'll
work on that when we start
95:13 - to build the functionality
of the application
95:19 - to actually add and update items.
95:22 - So it's a form, and within the form,
95:24 - we want to add an input field
95:27 - of type text, because we will be adding
95:31 - the text of our todo into that field.
95:35 - We also want to give it a name,
95:36 - we'll need that in order to identify
95:40 - that text input in the request
later when we submit it.
95:44 - So let's stick to text, we
could name that anything,
95:47 - that's up to you, text
for now does the job.
95:53 - We also want to add an aria label
95:58 - so that screen readers announced
this input field and people
96:03 - who use a screen reader
understand what this is for.
96:07 - So in this case, it's add a todo.
96:14 - And lastly, we want to add a placeholder.
96:16 - And if we look at the mock-ups,
96:19 - the placeholder we want to add is that
96:22 - + tap to add a todo.
96:25 - So we'll do that, + type to add a todo
96:33 - And we close that.
96:35 - So that's, you know, basically
giving us the initial setup.
96:41 - If we look at the preview, you can see
96:43 - we have an input field
with the placeholder.
96:46 - It doesn't quite look
like the mock-up yet,
96:48 - but we'll get to that a little bit later
96:51 - when we apply CSS to the application.
96:55 - Let's have a look at
the mock-up what's next.
96:58 - We're going to have a
dynamic number of todo-items.
97:03 - We don't really know how many,
97:04 - and that obviously changes when
we add and delete the items.
97:08 - So we'll have to somehow find a way to
97:11 - show this list dynamically.
97:15 - For now, as I said, we
care about the structure,
97:17 - so there needs to be some
kind of check mark here,
97:22 - some kind of text, now, also,
97:24 - when you click on one of those texts,
97:26 - we want to convert it into a text field
97:29 - so that we can type and
update, the element, todo-item,
97:36 - and also some button
here to remove the item.
97:41 - So that sounds to me like
123 different HTML forms
97:47 - so that, you know, when you click this,
97:50 - we can submit the request to the backend
97:52 - and check if that's done,
same for the delete button,
97:56 - remove it, let's start, have
a look at what it looks like.
98:00 - The elements are below
the create a todo form.
98:06 - So we could come here and start
writing the HTML structure.
98:11 - Instead, I think this is a
good time to introduce you
98:15 - to Svelte components, just
like any other framework,
98:19 - you can organize your code by
writing multiple components.
98:24 - The way it works in Svelte,
98:26 - and especially in
conjunction with a SvelteKit,
98:31 - is that under source,
98:33 - we can create a new directory
and let's call this lib
98:38 - a new folder, lib, and within
lib, we create a new file
98:46 - and we call this todo-item.Svelte.
98:54 - And here we are going to
focus on one line item.
98:59 - And then once we built that,
99:00 - I will show you how we
can include it in the UI.
99:06 - Very straightforward.
99:07 - The first thing we'd like to do is
99:11 - most likely at some
point we'll have to style
99:14 - that entire row, so for
example, when it's checked off,
99:17 - you can see there some
opacity happening here
99:20 - on the entire element.
99:22 - So it's probably a good
start to just wrap everything
99:25 - in a div here.
99:27 - And then the first thing
is that a check mark here.
99:32 - So that's a form with some value inside.
99:36 - We can then submit later,
so let's add a form,
99:40 - no action for now, no
method for now, either.
99:45 - And then we'll add an input.
99:49 - The input will contain the
value of the todo-item,
99:57 - whether it's marked as done or not,
100:00 - but we don't really want to
show an input field for that.
100:04 - We could use a checkbox potentially,
100:08 - and you know, style that
to make it look like a,
100:12 - make it look like a circle.
100:14 - For now, what we can do is
just make a hidden input field.
100:18 - We can say type hidden and
give that a name as well.
100:23 - In this case, we call it
done and then a value.
100:27 - For now, we don't know
whether it's checked or not.
100:30 - So we'll just leave it empty until we get
100:33 - to the point where we start
to style the application.
100:38 - The next thing is we need a button
100:43 - for that circle with a check box.
100:46 - So let's add a button here,
100:53 - the value for the button
for the time being anyway
100:57 - is that we can just call it Done/NotDone.
101:02 - Eventually we'll change
that and use some CSS
101:05 - to make this better, but
that does the job for now.
101:10 - We also want to make sure
the screen readers announce
101:13 - this button properly, so
we say mark done/not done.
101:20 - Then people know what's going on.
101:22 - Once we start adding
functionality and we know
101:26 - which todo-item in particular,
that we are entering,
101:29 - we will be able to
dynamically update this text
101:34 - to show the correct aria label,
101:36 - whether to mark an item
as done or not done.
101:39 - For now, we don't know that,
so we'll make it more generic,
101:44 - and also that reminds us later
that we have to update this.
101:49 - Okay, that is the form for this check box.
101:54 - Next we need to work on
that text that's shown here.
102:00 - That's exactly the same
concept so we can type form.
102:06 - We don't know the action yet,
102:07 - we don't know the method yet either.
102:10 - What we do know is that we want
an input field of type text,
102:16 - and we don't know the value at
this point, so just add that.
102:20 - And the other thing we want
to do is, you don't see it
102:24 - in the mock-ups, but when
we click on that to edit it,
102:27 - we want to show a little save icon
102:29 - right here next to the delete.
102:32 - This will help visually tell people
102:35 - that they have to click
that button or hit enter,
102:38 - but it's not obvious that
enter is going to save it.
102:41 - So we'll show a little icon here.
102:45 - For now, we'll add a button to
just have a placeholder there
102:48 - and then deal with that later.
102:50 - So the button will
eventually be the save button
102:55 - and as well here, we want an
aria label called save todo
103:03 - that marks the second form
and the last form over here
103:10 - is the one to delete an item.
103:14 - Same concept, again, we can probably start
103:16 - copy pasting some stuff here.
103:18 - So well, one day form, and
we want to close that again.
103:23 - Action method, we don't know.
103:26 - What we do know is that
we'll want the button here.
103:31 - That again for now, just says Delete.
103:34 - Once we use CSS,
103:35 - it will be a nice trashcan
and aria label to tell the
103:42 - screen readers that this
is to delete a todo.
103:47 - Very good, that gives us the
forms we need for that element.
103:54 - Now in the UI, we don't
see any of that yet.
103:57 - So what we have to do is
104:01 - switch over back to our
source, routes, index.Svelte.
104:05 - And we have to import that component,
104:07 - that todo-item component we created,
104:11 - the way to do that in
Svelte is very interesting
104:15 - and also extremely handy.
104:18 - So what do you see right now is pure HTML,
104:23 - this is no JSX, no, you know,
104:27 - library on top of HTML
or anything like that.
104:29 - It's just HTML the way to
browse that or understands HTML.
104:35 - In order to import a component in Svelte,
104:40 - you can add your scripts
that are needed on this route
104:45 - or in this component particular
right to the same file.
104:49 - So at the top, it doesn't have
to be at the top, by the way,
104:52 - it could be below as well,
but I prefer it at the top.
104:55 - You can add a script tag, that's
a regular HTML script tag.
105:02 - And within that, we can
say import todo-items.
105:09 - This is going to be the name
of our todo-item component.
105:13 - And where do we want to input it from?
105:16 - One directory up, we are in routes,
105:20 - so one up and then lib, todo-item.
105:24 - That imports the todo-item,
now it's not used,
105:27 - so it get a little notification here,
105:31 - but we can come down here
105:36 - and say todo-item, render one of them.
105:40 - We go back, you can now see that
105:44 - besides the input field to add a new one,
105:48 - we also have the Done/NotDone button,
105:52 - the input field to edit one,
save and delete, not pretty,
105:57 - but it's all the HTML that we need
106:00 - in order to render an item.
106:03 - As you can imagine, adding three of them
106:07 - renders three todo-item lines.
106:14 - So I'm going to show you one more thing.
106:17 - If we were to move things around,
106:21 - such as let's say, we
moved out todo application
106:25 - into like sub folders
or change things around.
106:30 - What we would have to do is go
and update the relative path
106:36 - that is used in our input statement here.
106:39 - So in SvelteKit,
106:41 - there is a convention where
106:44 - if we want to access anything
in the lib directory,
106:48 - we can just remove the relative path
106:51 - and use the dollar sign.
106:54 - So a $lib, that automatically points
107:00 - to the source lib, you can see
that up here in the tool tip.
107:02 - It points to the source
lib todo-item as well.
107:08 - So it automatically replaces that.
107:11 - Now we can move that input
statement anywhere in our code,
107:15 - and it will automatically
resolve to the correct endpoint
107:20 - or directory here in the file system.
107:23 - So that's a neat little trick to help us
107:28 - load that todo-item.
107:32 - There's one more thing we want to do
107:33 - while we're working on the HTML structure.
107:35 - It's setting a title for the application.
107:40 - At the moment, if we inspect
that and we go to the head,
107:46 - you can see that there
there's some meta tags.
107:49 - They come from our source/app.html.
107:53 - There's some scripts, some
styles, but there's no title.
107:59 - So remember if we go to src/app.html
108:06 - there's the meta tags I just showed you.
108:09 - There's no title, we could add one here,
108:11 - but then it would be the same title
108:12 - for the entire application.
108:15 - So in order to populate
108:16 - that dynamically created Svelte head,
108:20 - what we can do in our index
file somewhere up here is
108:27 - use a special component
called Svelte colon,
108:30 - and you can see there's a few of them.
108:32 - The one we care about right
now is head, we use that.
108:37 - We can now put any HTML
elements that are valid
108:41 - within the head inside of here and Svelte
108:45 - will dynamically populate that
108:47 - when the different pages load.
108:50 - So the element we want to add is title,
108:53 - and we want to call it todos.
108:56 - Now you notice that it already reloaded,
108:58 - hot module reloading kicked in,
109:00 - and the title now says todos.
109:03 - And if we update that and we save,
109:06 - then it immediately updates as well.
109:10 - So that's nice,
109:11 - but let's make an agreement that the title
109:16 - should always reflect whatever
the H1 element is here.
109:21 - Okay, so that the H1 on the page
109:24 - maps to the title in the browser window,
109:28 - that's happening right now
because we wrote todos twice.
109:31 - Fair enough, but if we were
109:32 - to change that todos title here,
109:35 - we would have to remember
to also change it here.
109:38 - So I'll show you how you
can use the variables
109:41 - in Svelte and reference
them within the HTML.
109:44 - Let's create a variable called title.
109:47 - And the name for that
is order value is todo
109:53 - by the way that name, variable
name could be anything.
109:56 - It could be page, title
whatever you want it to be.
110:01 - In order to use it in your HTML,
110:04 - we can select these two
with command D or control D
110:09 - to have multiple cursors, so
we delete the hard-coded texts.
110:14 - We use opening curly
brackets, variable name,
110:18 - closing curly brackets.
110:20 - And now you can see
the todo here and here,
110:24 - is still the same.
110:26 - If we were to make a change,
then the browser updates,
110:31 - as well as the todo-item here.
110:34 - So this is how you can use variables
110:38 - within your HTML in a Svelte component.
110:44 - So we'll keep it like that,
that's probably a good start.
110:47 - And it's a good reference as well
110:49 - if you want to update that later.
110:53 - Excellent, I think this is a good spot
110:58 - to declare that issue as complete.
110:59 - We did develop the HTML
structure, that is all in place.
111:04 - Now this goes back to todo,
111:08 - and we can go ahead and
commit these changes.
111:11 - I personally like to
do a quick self review
111:14 - before I commit it so that, you know,
111:16 - at least I had another look
at my code before I push it,
111:21 - make sure there's nothing obviously wrong
111:23 - that would just stand out.
111:25 - And then here, we want to call this,
111:27 - use the same develop HTML structure,
111:34 - commit that, yep.
111:36 - And we can go ahead and write
111:38 - from here, create a pull request.
111:42 - We don't need, quick update that a bit,
111:49 - structure, and we want to
close issue number five,
111:55 - and we don't need to make it
a draft, we are ready to go.
111:58 - So create published branch
112:03 - that will do the work for us, there we go.
112:08 - We are ready for somebody
to review that for us.
112:13 - What we did was we updated the index file
112:17 - by setting a title,
112:19 - using the Svelte head to modify the HTML
112:23 - used within the head tag.
112:26 - And then we created a form
112:28 - for the creation of new todo-items.
112:32 - And we render a Svelte component
called todo-item that we
112:36 - import from the $lib slash todo-item
112:39 - $lib is a naming convention
that's configured
112:43 - within SvelteKit to
automatically point to src/lib.
112:48 - This is our Svelte component
for a todo-item, three forms.
112:52 - First one to mark an
items done and not done,
112:56 - save todo and delete.
112:58 - So this looks very good.
112:59 - We can commit that and then
move on and start to apply
113:06 - just a bit of CSS to make
it more look like this
113:09 - so that this is a bit easier to work with
113:12 - as we progress and start
to add functionality.
113:16 - All right, we go and merge
113:18 - that pull request and delete the branch.
113:23 - And as we were used to,
we don't need our preview,
113:28 - we can close that.
113:30 - The same is true for our
developer environment.
113:32 - We don't need that either, we
are done so we throw it away.
113:36 - There we go.
113:37 - And that's merged.
113:39 - Issues are gone and we are ready to go
113:44 - and work on the next step.
113:50 - Okay, with all the HTML elements
113:53 - in place, we are now going to add CSS
113:57 - so that the web application
looks like the mock-ups.
114:02 - If you remember,
114:03 - this is the end result of
what we want to achieve
114:08 - and let's get started with that.
114:11 - So we have an issue, apply CSS styles,
114:13 - where we can start a developer environment
114:17 - and continue with our work.
114:22 - What are we going to learn here is
114:25 - how to apply styles in Svelte components.
114:29 - There's a few options, different ways.
114:32 - We'll talk about that.
114:33 - And basically the end result is we want
114:36 - to turn what do we currently have here,
114:39 - the unstyled todo application,
114:42 - we want to turn that into what we see
114:47 - right here in the mock-up.
114:50 - Okay, switching over to
our developer environment.
114:55 - We don't need any of these
things at the moment, the server
114:58 - is already running, so we'll
just keep that up and running.
115:02 - Maybe the first thing we can do is inspect
115:05 - the web application so that
we can then look at CSS,
115:11 - different styles and keep
an eye on what's happening.
115:17 - So with that,
115:19 - let's get started and apply
CSS to this application.
115:27 - The first thing I want to
show you is how we can use
115:33 - regular CSS files to style the application
115:38 - and use the styles that we add
115:41 - across the entire application
so that we can put
115:44 - certain default behavior in
place that applies to the entire
115:49 - application where like we
define style attributes
115:55 - such as the font family or primary colors
115:58 - and things like that.
115:59 - So we want to do this by
creating a CSS file under source.
116:07 - So let's say source and then new file,
116:10 - and we'll call this app.CSS.
116:15 - Okay, this is a regular CSS,
116:17 - there's nothing fancy about this.
116:21 - The first thing we can do is
turn that white background
116:26 - that we currently have into
more of this gradient approach
116:32 - that you see in the mock-up.
116:36 - The way to do that is
116:39 - we target the body element
of the web application.
116:44 - And for now we can just say
the background color equals to
116:53 - a hash value is so B9C6D2,
that could be, you know,
116:59 - whatever you need for
your environment later.
117:04 - So with that,
117:06 - it's still white because we
haven't actually loaded that CSS
117:09 - file, the app.css is an
arbitrary name that I chose.
117:14 - You could name this
file anything you like.
117:18 - So before we go any further,
117:19 - let's just make sure the changes we apply
117:22 - are actually visible in
the developer environment.
117:25 - So in our case, we have a
source roots index file.
117:31 - And in this file,
117:34 - what we can do is import the
CSS file that we just created
117:39 - a little while ago, so
if we go to the script,
117:43 - this is where we import the todo component
117:46 - as you remember, we can
also import the CSS file,
117:53 - which lives two directories up.
117:56 - And there is the, oops, my apologies,
118:00 - it's one directory up and app.CSS.
118:05 - So with that, if we switch
back to the todo application,
118:09 - we now have the grayish background.
118:14 - So that's one way to load the CSS file,
118:18 - now, one thing I want to show you is
118:22 - if we were to add a second route,
118:23 - so under source routes, new file,
118:26 - we call this about us just as a test
118:33 - and within the about us file, we create
118:36 - the header for now that we
see, we changed the URL.
118:40 - If I were to switch to about us,
118:45 - it did not apply that change
to the CSS background here.
118:49 - And that's because as you
can guess in the index file,
118:52 - we import a file, we
don't do that in about us.
118:56 - I could create a script
tag and import the CSS file
118:59 - as well, but that would
not be very scalable.
119:02 - So instead there is a
special file we can create
119:07 - at any level within the roots tree.
119:10 - So if there were subdirectories,
119:11 - we could create more of these files
119:14 - and the file is called __layout
119:18 - So we within SRC/roots, __layout
119:23 - that Svelte this file
contains code that applies
119:30 - to all the routes within the
directory where it's defined
119:33 - as well as all sub-directories below that.
119:38 - So what we can do here is we can
119:44 - import that CSS file at the layout level,
119:47 - which then applies to about
us and index and anything else
119:51 - within that directory
or its sub-directories.
119:55 - So going back here,
119:57 - let's remove the CSS
import from the index file.
120:02 - And in the layout,
120:05 - we are going to create a script tag
120:09 - and import that CSS from here.
120:13 - If we go back to the user interface,
120:16 - we noticed that the about us
page now shows the background,
120:20 - but it doesn't show the title anymore.
120:24 - And the same is true on the
index page, completely empty,
120:28 - but the background is there.
120:30 - So we need to render the content
120:36 - of whichever page we are on,
120:38 - whether we were on the route page
120:40 - or on the about us page.
120:42 - We need to tell Svelte to
render the content dynamically
120:46 - depending on the URL.
120:48 - And the way we can do that
in the layout component
120:51 - is by using what is called a slot.
120:54 - So S-L-O-T as a component
120:57 - and now Svelte dynamically
replaces line number five
121:01 - with the content of either the index file
121:05 - or the about us page,
depending on the URL we are on.
121:09 - If we switched back, we
have our style todos back
121:15 - and on the about us
page, we have the title.
121:20 - All right, that is a
good place to keep that.
121:24 - If we wanted to add additional
HTML into the layout file
121:31 - that applies to the other
files in the routes,
121:34 - we could do things like
wrap the slot in the main
121:40 - HTML element, and maybe
below we could add a footer
121:44 - where we say copyright,
something like that.
121:48 - And then in the UI, the, if we were to,
121:55 - if we were to save that
and then go back to the UI,
122:00 - we would now have the
copyright here, the footer,
122:03 - as well as on the index
page copyright as well.
122:08 - Okay, that gives you a good
idea of how you can extend the
122:12 - application and share some
code across multiple routes.
122:18 - As always the Svelte
documentation at Svelte.dev c
122:22 - ontains a lot more information
about the feature of slots
122:26 - and how you can use them
in your own components
122:29 - to nest certain functionality,
122:32 - as well as how you pass prompts
from the parent component
122:36 - to the slot and vice versa.
122:39 - For the time being we
don't really have a footer,
122:41 - so let's get rid of that.
122:44 - We also don't have an about us page,
122:46 - so we will drop that as well,
122:49 - but we will keep the main and
the slots so that we can use
122:52 - our CSS file back on the index page.
122:58 - Good, so we know we no longer need that
123:00 - and we don't need this index
file at the moment either.
123:05 - Good, so this is a good place to be,
123:09 - to understand how we can load the CSS.
123:12 - Now, what do we want to do
is apply a few more things
123:18 - to the website in terms of
styling, we're not quite done.
123:23 - We are actually far from
done, so back in the CSS file,
123:29 - what we can do is first
123:30 - of all, this color is our primary color
123:35 - that we want to use
across the application.
123:38 - So in order to not have
to repeat that hex value,
123:43 - we can use is pseudo element route.
123:47 - And then we can specify
123:49 - a CSS property here called --primary-color
123:58 - and use that hex value
that we have down here
124:02 - to define the primary color value.
124:06 - And now anywhere in our CSS, we can,
124:11 - instead of copying that hex
124:12 - we can just use the
primary color variable.
124:16 - So we'll do var and we use primary color,
124:20 - autocomplete makes that super easy.
124:24 - So in order to create the
gradient that you see here,
124:30 - we need at least one more
color so that we can specify
124:35 - the gradient from this point to this point
124:38 - in terms of the colors.
124:40 - But we are going to add two more,
124:42 - just so that we have three
colors, so secondary color,
124:48 - and the value for that is D0DDE9.
124:54 - Again, these are just values
I took from the example,
124:57 - but you can use your own brand colors.
125:00 - And lastly, the third one, tertiary color,
125:05 - and for that, we used
the hash EDF0F8, nice.
125:14 - So this is not really a CSS tutorial,
125:17 - but just make sure the
application looks all right,
125:21 - we'll apply a background and
we can use the linear gradient
125:28 - for that, and just add a few values here.
125:34 - So we wanna rotate by 180 degrees
125:38 - and then use the three
colors that we defined
125:41 - to specify how will we are styling this.
125:47 - So let's have a look here, and secondary.
125:56 - And the last one, there we go.
126:01 - Now, if we go back,
126:02 - we have the gradient that you can see.
126:07 - The problem is that it happens
126:09 - kind of three times, two and a half times.
126:13 - And the reason for that is that our body
126:19 - is not really spanning the
entire height of the window.
126:23 - So we can fix that fairly
easily by updating our body
126:28 - definition and add a min height
of 100 view point height.
126:37 - And now if we look at
that we get that gradient
126:40 - across the three colors, nicely applied.
126:44 - The other thing I want to do is see
126:45 - that marching on the left here?
126:47 - I want to take full control over that
126:49 - and not let the browser interfere.
126:52 - So one workaround for that is
to just basically set a margin
126:56 - of zero at this level so that we can use
127:03 - our own margins eventually to apply here.
127:05 - Now you see there's aligned
all the way to the left.
127:10 - Good, so this app.css file
is a good place to define
127:15 - all sorts of global CSS properties.
127:21 - One more thing we could do is,
127:24 - all of that doesn't make
too much of a difference,
127:26 - but just want to show you
in case you have your own
127:29 - custom fonts, so we could
specify the font family here,
127:34 - and I don't know, pick
one or use your own.
127:38 - If you have your own font that applies
127:41 - as well to everything.
127:45 - Good, one other thing we
want to do if we look at
127:50 - this page versus the mock-up,
the todo text is centered,
127:58 - and we can just agree now
that this is a design decision
128:03 - that we want to apply
to all the H1 elements
128:08 - across the entire project,
128:10 - once we add more pages,
we want the same behavior.
128:13 - So again the app CSS is a
fantastic place to configure that.
128:20 - We can say H1 and text align
and then make this center
128:27 - as well as just specify a
font size of, let's say 2rem.
128:34 - This then applies a cross the board
128:39 - and makes all our pages
look the same, exactly same.
128:45 - And just because we are here,
128:48 - if you wanted to apply a
media query or really any CSS,
128:54 - because that's just a regular CSS file,
128:56 - there's no special use case or anything.
129:01 - We can use media queries as well,
129:04 - if we were inclined to do so.
129:07 - For example, we can change,
if we had a min width of,
129:11 - let's say 720 pixels,
129:14 - we can apply a different
font size, for example,
129:19 - for the H1, as you know,
something for you to work with.
129:25 - So anything you can do
in CSS, you can do here.
129:29 - It applies to the todo-item depending
129:32 - on the media query that applies.
129:39 - Okay with that, we learned
how we can apply CSS
129:41 - across the board.
129:45 - Now for the styling of
the actual todo app here,
129:49 - so the different rows,
129:51 - the opacity here, the
margins, all these things.
129:57 - That is CSS that we don't want to apply
130:00 - to all the pages, right?
130:02 - The todo application may live on one URL
130:08 - maybe slash todo or something like that,
130:10 - and we only want this CSS to
impact that one component,
130:17 - which also means that
the browser doesn't have
130:21 - to download that CSS for every
page the user navigates to.
130:26 - We only want the browser to download
130:29 - that check mark, for example,
when a user actually looks
130:32 - at the todo application, so with Svelte,
130:36 - the way we can do that is
straight in a Svelte component,
130:40 - we can write CSS and make sure
that this applies only there.
130:47 - So let's have a look at the
index file under source route.
130:53 - So we don't need the
global CSS file anymore,
130:56 - but under source, roots,
index.Svelte, we can,
131:04 - besides the script and the
HTML, we can add one more thing.
131:08 - And that is a style tag.
131:12 - So a regular HTML style element,
131:18 - and within this, we can use CSS to target
131:23 - our element within that component.
131:26 - For example, if I were to
target a form like this
131:35 - in regular CSS, if it's
in the app.CSS file,
131:40 - anything I put in here into
that definition would apply
131:43 - across the board, across
the entire application.
131:47 - Because I'm specifying this style element
131:50 - within my component or my route
here, anything I put here,
131:55 - even though I use form
like this as an element,
131:59 - it only applies to that
form within the component.
132:03 - So any CSS is locally
scoped to the component,
132:07 - which makes it very easy to
reason about what happens
132:11 - if I change anything in
this form definition,
132:14 - it will not impact anything
outside the component.
132:17 - Super easy to make changes down the road
132:19 - without worrying that, you know,
132:21 - you accidentally may have
broken the form layout
132:25 - on a different page or a
different part of the application.
132:30 - Now we are not gonna
target the form like this,
132:32 - but I wanted to show you how this works.
132:35 - What we are going to do
though is basically wrapped
132:39 - the entire application in a div
132:43 - just so that we can target
it and apply things like
132:47 - centering of the element
and things like that.
132:50 - So let's first create that div here
132:57 - and then move our entire
application inside of that div
133:04 - so same code as before, but
wrapped in a div element.
133:08 - Now let's give that a
class, so class todos.
133:14 - And now within the style
element that we defined here,
133:18 - we can target that
todos div and apply CSS.
133:27 - The few things we want
to do here is we want
133:30 - to specify a with of 100%.
133:36 - We also want to limit the maximum width
133:40 - in case somebody has
an ultra wide monitor.
133:43 - We don't want this to stretch all the way
133:45 - from the left to the right.
133:47 - So let's set a max with of 42rem
133:52 - because you know why not 42?
133:55 - And let's put a margin around of
134:00 - something like that to center it.
134:03 - And with that we can switch back
134:05 - and you can now see that
there's a much bigger margin.
134:10 - And if we inspect that
part of the application
134:14 - where we have our todos,
134:17 - you notice that there's no
margin at the top left and right.
134:21 - And if I was to change the size,
134:25 - this moves along and the
margin adjusts accordingly.
134:32 - Okay.
134:34 - One thing you do notice
is that Svelte created
134:39 - its own S dash class name.
134:42 - This is just so that we
Svelte can uniquely target
134:45 - that element with CSS so that
nothing we have to worry about
134:51 - it just happens under the hood for us.
134:56 - All right, the next thing we
want to do while we're here
135:02 - is we want to target that
new input field here.
135:09 - And as you see in the mock-up,
135:11 - it doesn't really have a background, so,
135:15 - or a border or things like that.
135:17 - So let's go back and
define the dot new class.
135:24 - And right now, Svelte is telling us that
135:28 - there's an unused CSS selector.
135:30 - And that's because we
specified a dot new class here,
135:37 - but we actually didn't use
it anywhere in the HTML.
135:41 - There's no new class anywhere applied.
135:44 - So this is a nice feature
of the Svelte compiler
135:47 - telling us that, Hey, you
have this element here,
135:50 - but it's not used so you
may as well delete it
135:54 - and save the browser from
downloading a few bytes
135:58 - by not having this definition.
136:01 - So that will come in handy,
you'll see the benefits of that
136:03 - once you start refactoring
your application,
136:08 - you may move, let's say
that form somewhere else
136:12 - and forget to include the CSS.
136:14 - Then you will get that warning
and you can move to CSS along
136:17 - with the form so that everything
continues to look the way
136:21 - you want it to look.
136:24 - So what do we want to do
for the input field here
136:29 - is first of all, just add
a bit of a margin here.
136:31 - They are a bit too close together,
136:34 - and that's easily done by first of all,
136:37 - going to our input field
for the new todo-item.
136:44 - And we have that wrapped within a form.
136:48 - So we can target that form
either with just form,
136:51 - or I like to be a bit more specific
136:54 - and do use a class name, and call it new.
136:57 - And now we still have an error,
136:58 - but it's only telling
us that please don't use
137:00 - empty rule sets, it recognized
that we have a class with new
137:04 - so that warning is gone.
137:07 - And then what we want to
say is just margin here,
137:11 - tiny a bit of margin at the bottom
137:15 - that applies nicely right there.
137:20 - Good.
137:22 - The other thing for the element,
the input element itself,
137:27 - we can target that as well
by creating another class
137:33 - so dot new, and then within that new form,
137:37 - we target the input element like this
137:43 - and that then applies CSS
for that specific element.
137:47 - What we want to do is a
couple things, first of all,
137:49 - it's a little bit bigger than the rest.
137:51 - So let's say font size 28 pixels,
137:56 - and then we want to stretch it,
138:01 - stretch it all the way and
give it some padding, such as,
138:10 - oops, sorry, 1em, 0.3,
138:17 - this is, the values here, you
know, I'm not making it up,
138:20 - that stuff that's in the default template.
138:22 - So since we're not really
focusing on the styling part,
138:28 - we can freely copy that and apply,
138:30 - so basically let me
add all that in one go.
138:34 - It's a bunch of things that apply only
138:37 - to that input field within the new class.
138:41 - So now this looks a lot closer
to what we eventually want it
138:45 - to look like, but we do notice
it has this border around it.
138:50 - And so do all the other
elements when you select them.
138:55 - We want to get rid of that,
138:59 - and we want to get rid of
that everywhere in this form.
139:03 - We could add the CSS to remove
139:06 - that border to the app.CSS file,
139:08 - and then it applies to
all the input fields
139:12 - across the entire application.
139:14 - For the purpose of this course,
139:16 - I want to introduce
you a concept in Svelte
139:21 - where we can target all the input fields
139:26 - in the current component and its children.
139:31 - So let's look at this
structure real quick.
139:34 - We have an input element here,
139:37 - and then we have input
elements within the todo-item.
139:40 - Remember under source, lib, todo-item.
139:43 - We have additional input fields.
139:46 - So if I were to come here
and let's say up here,
139:53 - well actually after the
new makes probably a sense.
139:56 - If I came here and I would just say, input
140:03 - the styling of that input class
140:05 - would only apply to this
input not the children
140:08 - because of the local scope
that I explained earlier.
140:12 - However, Svelte does allow us
to target this one input here
140:18 - and the ones in the components used.
140:22 - The way we do that is
140:24 - we limit it to that todos
class or that element here.
140:30 - So we say dot todos.
140:33 - And then instead of just input,
140:34 - we have to use a Svelte
specific configuration,
140:40 - so global input.
140:46 - Now that means target the dot todos class.
140:52 - So this element on line 35
140:56 - and then globally within
that, all the input fields,
141:00 - that's how we can apply styling
141:03 - to that input and to the
todo-item inputs inside.
141:06 - What do we want to do for these
items is remove that border.
141:10 - So border 1px solid, but
we make it transparent.
141:16 - And if we go to look at that,
that border disappeared,
141:21 - and if we click, we still get
the blue border around it.
141:25 - Same here, same here, but
the other border disappeared,
141:29 - we can fix that in the
same way as we did here,
141:32 - just that we have to use a pseudo element
141:38 - saying that target that
element when it's focused.
141:41 - So same thing to start with,
141:46 - but instead of targeting the input only,
141:49 - we want to target its focus visible state,
141:53 - and then the values we need there again,
141:57 - no need to type all that.
141:59 - This is not the main
purpose of the course.
142:02 - We'll add a bulk shadow,
142:04 - bit of border in red and outline none.
142:08 - If we look at that in the user interface,
142:11 - we now get this red border.
142:13 - So we know that's the element
we are currently typing in
142:17 - same here, automatically
applied to all these fields.
142:24 - With that, we styled everything we can
142:28 - in terms of the new input field.
142:32 - It's now time to move on and
style each individual item
142:37 - so that instead of having
these buttons and all that,
142:40 - it turns into this nice one row
142:44 - with the important stuff
that you see in the UI.
142:50 - For that, we switch to
source, lib, todo-item.
142:54 - And over here,
142:56 - this is where we can start
applying the exact same concept
143:01 - as we did in the index file,
143:04 - where we create a style element.
143:10 - And within the style element,
143:12 - we can create definitions and target
143:15 - the different elements that we have.
143:18 - So one note here,
143:21 - even though we define the
style element at the top,
143:25 - we could define it at the bottom
143:27 - if you prefer that,
there's no order required.
143:31 - Script, style, and HTML,
143:33 - you can order these three
within a Svelte component
143:37 - in whatever way you are
most comfortable with.
143:41 - Good.
143:42 - Let's do a couple of things
before we apply the styles.
143:48 - First of all,
143:50 - let's use some class names
143:52 - so that we can target individual elements.
143:56 - First things first, the wrapper div
143:58 - for an individual line
item, let's call this todo,
144:03 - and then we need to target that button
144:07 - so that we can turn this
Done/NotDone button here
144:11 - into a circle with a checkbox.
144:14 - So this is the button here,
144:17 - and we want to target that with a class.
144:20 - Let's call it toggle.
144:23 - Next thing we want to target the form
144:26 - that allows us to edit
a todo item and save it.
144:30 - So we can call this class,
stick to the same name
144:34 - as we already used for
other purposes, so text.
144:39 - And we also want to target the button,
144:41 - which will turn into a little save icon
144:44 - when somebody clicks in here.
144:49 - By default, if nobody
clicks, you see nothing.
144:52 - If somebody clicks on the text,
144:54 - then that save button
turns into a little icon.
144:58 - So we have to target that,
and the way we do that,
145:00 - as we add a class name
here and we call it save.
145:06 - Lastly, we need to
target the delete button.
145:09 - Let's give that a name, delete,
145:13 - and then let's start
adding the CSS required
145:18 - to turn this all into a nice line.
145:22 - All right, first things first,
145:24 - starting with the todo wrapper, so todo.
145:31 - For that, we use grid,
145:33 - but we could just equally use flex
145:37 - if you're more familiar with that,
145:39 - I'm going to paste all the CSS in here.
145:41 - Again, no need to go through
and describe all that.
145:45 - But it's basically just
applying a few styles
145:50 - so that things look like the
way they do in the mock-up.
145:53 - But there's great CSS courses out there
145:56 - that dive into a lot of
more detail around this.
146:01 - So have a look what we got,
everything is now aligned
146:04 - on the single line, so
that's a good first step.
146:08 - Next thing you want to do is focus
146:12 - on that button over here,
146:14 - and actually all of the
buttons, because we can,
146:19 - we can apply since they're the same styles
146:21 - to all of these three.
146:23 - So the way we can do that
is target the todo wrapper
146:29 - and then all buttons
went in, so all three.
146:35 - And for all these three,
146:38 - we want to specify just a couple of things
146:45 - width and hide the same
number so that we can apply
146:50 - a background position, 50
50%, which makes it a circle,
146:55 - remove some colors and make sure
146:57 - we don't repeat any of the background.
147:00 - If we have a look, that gray
background that the default
147:04 - button had is gone, we
still have the text.
147:06 - We'll drop that as soon as
we have the icons ready,
147:09 - and that will start to look a lot better.
147:13 - Buttons look good.
147:14 - The next thing we want to style are
147:16 - the input fields, so input.
147:23 - And for that,
147:25 - we only have really one input in this case
147:30 - that's visible, this one,
oops, the input here is hidden,
147:36 - but this input is visible,
so for that we use flex.
147:43 - And then we'll see why that is
as soon as we add the image.
147:50 - Not much changed here until I click,
147:52 - you can see that edit field eventually.
147:57 - Next up, let's go and
focus on the toggle button.
148:03 - So two ways I could say dot toggle,
148:10 - that would target that specific button.
148:13 - Alternatively, I can say,
148:15 - I want to target the button
with the class toggle,
148:18 - really up to you.
148:20 - We can do that and
148:25 - give that some CSS here.
148:29 - Oops, in here.
148:31 - Now, if we look at that,
148:34 - you can see not much changed yet
148:36 - because we don't have the image yet.
148:38 - We'll do that very shortly.
148:42 - Next thing we want to do is
target the text down here.
148:51 - So let's have a look.
148:56 - Oops, there we go.
148:58 - I want to say dot text
and the values for that,
149:08 - paste them here.
149:14 - Okay, now this is giving
us a lot more space
149:18 - because we are applying that
display flex and flex one.
149:24 - We now have a lot of space
149:26 - to type and edit our todo-item eventually.
149:29 - Good.
149:30 - Next up is the button
for the save element.
149:37 - So the right here, save button
let's replace that text.
149:44 - So for that, we remember
we have a safe class,
149:47 - so we can target it with
a definition like this.
149:54 - And the content, we can paste.
150:03 - I'll talk about it in a second here.
150:07 - So what do you see is that
opacity is zero by default,
150:11 - which means we don't see anything at the,
150:15 - by loading the page, and the
background image is just a SVG
150:20 - that is inlined within that component.
150:23 - The reason for that is that
this is such a small SVG
150:26 - with so very so few characters.
150:30 - It is probably more performant
to include that here rather
150:33 - than downloading an external
SVG file to display.
150:38 - So if we look at the page,
150:41 - you can see that we don't
see that save button anymore.
150:45 - If we inspected, it is
still here, dot save
150:51 - capacity is zero,
150:55 - so if we get it back, we see the icon.
150:58 - We also see the safe text
that's because we had
151:01 - a placeholder there,
we no longer need that.
151:03 - So we can delete the text of that button.
151:08 - So now if we inspect that one more time,
151:11 - we can uncheck the opacity
and we see the icon.
151:16 - So what do we want to do
next is when the input here
151:22 - is focused, we want to
show that icon like this,
151:28 - but only when we have to
focus on that input field,
151:31 - if we don't have to focus, then
we don't want to show that.
151:34 - So CSS allows us to do
that in a fairly easy way.
151:39 - And basically what we say here is that
151:46 - we want the, we can, we can do this.
151:51 - So to do within that element input, focus,
152:00 - then target that.
152:03 - And what do we want to do is
a little bit of a transition
152:09 - so that is a bit smoother, let
me say opacity 0.2 seconds.
152:16 - And the other thing we want to do here is
152:20 - the opacity itself, we
want to set it to one.
152:24 - Now let's have a look.
152:27 - If we click on it,
152:28 - you can see that this slowly appears,
152:31 - well, it's not very slowly,
152:32 - but you can see that the icon
appears with a slight delay,
152:36 - same here and here.
152:40 - Now there's one more thing we want to do.
152:42 - If somebody manages the
application with their keyboard
152:47 - or uses the web app with their keyboard,
152:49 - when they load the page and they hit tab,
152:54 - it goes into the input
field to create an item.
152:57 - If we hit tab again, we
go to the done button.
153:01 - One more time, we focus on the input.
153:06 - And you can see the input focus
is what we just specified.
153:12 - Now the problem is if we tab again,
153:16 - the focus now is on the element
153:18 - to edit, but because the focus
is lost on the input field,
153:23 - we also lost our edit icon.
153:25 - So we can easily fix that
by just adding a second
153:29 - definition here, which is if
the save button has focus,
153:34 - then also show the save button.
153:37 - So now if we do that again,
we come from here, tab, tab,
153:42 - and one more time,
153:44 - now we still see our icon.
153:47 - So people can use the keyboard
to navigate this application,
153:51 - which is extremely important
to make sure this works.
153:57 - All right, lastly, let's
go and focus on the delete.
154:04 - So the delete icon is a image,
154:11 - just an SVG, again,
154:12 - we're going to inline it
like we did for the save icon
154:16 - and we it an opacity
so it's not too strong.
154:20 - If we look at that, you can
now see the delete icon.
154:24 - It is a little bit, almost invisible.
154:29 - What we want to do is
remove that delete text.
154:32 - We no longer really need the placeholder
154:35 - because we have the icon.
154:37 - We do this, looks better.
154:38 - And now a nice touch here
is that if we mouse over the
154:45 - button, we want to kind of pop
it and show it highlighted.
154:50 - We don't see it in the mock-ups.
154:52 - And just so people visually can see
154:56 - that the trash bin can be clicked.
154:59 - And the way we can do
that is we can focus,
155:03 - create that delete and on hover and again,
155:08 - thinking about people using the keyboard.
155:12 - Also when it is focused,
155:15 - then same transition as
we used for the edit icon
155:21 - opacity, 0.2 seconds.
155:24 - And we want to show it
at its full opacity.
155:29 - So with that, if we mouse over,
that becomes fully visible.
155:35 - If we use the keyboard and we
go and select the trash icon
155:40 - or focus on the trash icon, it
also becomes a capacity one.
155:46 - So the only thing that's left
is the done, not done button.
155:51 - And let's add that last.
155:53 - The reason it's last is
because until we actually know
155:57 - whether an item is marked as done or not,
156:00 - we don't really know if we
should show the checkbox
156:03 - or just an empty circle.
156:05 - So let's add the CSS and
then we will comment it out
156:08 - until we have the functionality
to make this work.
156:13 - All right, at the bottom,
targeting that Done/NotDone item
156:21 - the way we do it is we have a,
156:28 - we have a sorry, class called toggle here.
156:33 - This is how we can target
that specific element.
156:38 - Let's go to done toggle to
target that specific one.
156:47 - And let me copy the background
image for that checkbox,
156:56 - just so that we can have a look.
156:57 - Again, we don't need to
text, since we now have
157:03 - an item or an inline SVG.
157:06 - Now, one thing you see is
I used to classical done,
157:09 - so let's just drop that for a second
157:13 - and just start with toggle.
157:16 - Assuming that every item
is toggled by default.
157:20 - We now have the check mark for that.
157:25 - Now, whether or not the
toggle is on or off,
157:31 - we don't know as I mentioned,
157:33 - but eventually we want to
show that when it's checked,.
157:39 - So at some point when we
have the functionality,
157:43 - we will basically just add a
dynamic class here called done.
157:48 - We will do that
programmatically when we know
157:51 - which item we render, and
then when it's available,
157:56 - then we want to do certain
things versus others.
158:00 - So for example, that checkbox, the total.
158:03 - We only want to see it
when that class name
158:06 - eventually gets added here,
so for now let's rename
158:09 - that to dot done, and it's still here.
158:14 - But if we render the UI and the done item
158:21 - is not set, so if it's not checked,
158:23 - then we don't want to show the checkbox.
158:29 - All right, the other
thing we want to do The
158:31 - if you look at the
mock-up, that entire row,
158:36 - we want that to be with
an opacity of, you know,
158:42 - almost zero, so that it's
kind of like blurred out.
158:46 - The way we can do that
is we can just target
158:48 - that done element, so if we
do done for that entire row
158:56 - in here, we can say,
159:01 - oops, we don't want to transform.
159:06 - And we want an opacity of let's say 0.4
159:12 - and we'll give it a little
bit of a drop shadow
159:15 - to just match the mock-up.
159:19 - And then again, if we add this done back,
159:23 - what we have now is
you can see the little,
159:28 - how do you call it, opacity, 0.4,
159:33 - blurring that out.
159:34 - The last thing we want to
do is I noticed we forgot
159:37 - the circle, so let me have a
look at what are we missing
159:44 - to get the circle to show up.
159:51 - I think we added the,
159:57 - where was it?
159:58 - We did add the toggle here.
160:04 - I think that doesn't
get applied, one second.
160:07 - I'll do some live debugging here.
160:18 - Order none, uh-huh, okay.
160:25 - Let's just hang on, we'll figure this out.
160:29 - There's certainly something missing.
160:31 - It does have a border one pixel
160:37 - that shouldn't matter, oh, there we go.
160:39 - All right, we got that.
160:41 - We got that back by being
more specific about that.
160:44 - All right, all good.
160:46 - So with that we have everything in place
160:50 - to either mark this as done, not done,
160:53 - but for the time being until
we know when an item is done,
160:58 - let's remove that.
161:00 - And because we don't have to done,
161:01 - the compilers telling us that
these classes are unused.
161:06 - So we will comment this out
just for the time being,
161:10 - and also leave a comment here
161:13 - so that we don't forget
to bring that back.
161:17 - once we have the API
endpoint to tell us whether
161:20 - an item is done or not.
161:25 - So todo uncomment when the
API endpoints are available.
161:34 - Good.
161:35 - So we're back.
161:36 - Everything looks as if it
was not marked as done.
161:40 - We can start adding text.
161:44 - So with that, we looked
at two ways of using CSS,
161:49 - whether it's through
an app.CSS file at the,
161:53 - at the root that applies to
the entire application or
161:56 - whether it is within a style
tag right here in the component
162:02 - where it is scoped to
that specific component.
162:07 - And with that, we can go
ahead and make the change,
162:11 - we can commit these changes.
162:13 - So set a quick review, todo-item,
162:19 - we did a bunch of stuff here
to make this all look good,
162:22 - added some class names, the layout,
162:25 - and remember that a wrapper
around all the routes
162:29 - within the directory,
where a file is specified.
162:32 - And we import the app CSS file here.
162:36 - And lastly we added some
styles to the main file
162:41 - so that we can style the UI.
162:43 - So that looks okay.
162:45 - We seem to have the
functionality in the UI for that.
162:50 - Go ahead and commit that
by saying apply CSS styles.
162:56 - We committed, yes.
163:02 - That looks good.
163:04 - Now let's have a look up
here, we have the issue.
163:09 - We don't have a pull request
yet, so let's have a look
163:12 - what is going on here, if
we publish the changes.
163:19 - Nope, we don't want to do that.
163:23 - If we go to pull requests,
163:25 - we'll go through this UI for this time.
163:28 - We don't need any of this.
163:31 - Close issue number seven,
163:36 - just double check, yep, looks good.
163:40 - And we see create pull request.
163:46 - And with that, we have the
application fully styled.
163:51 - All the code is here, we remove the text
163:53 - we no longer need, looks good.
163:56 - We can go ahead, and
you know, in real world,
163:59 - we would ask a colleague to review.
164:01 - We go ahead and merge this confirm.
164:05 - We no longer need the branch.
164:07 - We also don't need our preview environment
164:10 - as well as the developer environment.
164:13 - That is a thing of the
past, stop workspace
164:19 - and get rid of it.
164:24 - That's a pretty good spot to be in.
164:26 - So we're going to move on
164:28 - and look at what are
we going to build next.
164:33 - We now have a web application
that looks pretty good,
164:37 - but it still doesn't do much.
164:40 - It has no interactivity
164:42 - in terms of adding or
updating any of the items.
164:47 - Before we add that,
let's have a quick look
164:49 - at the architecture to remind
ourselves where we are.
164:54 - We have to developed the
front end UI with Svelte
164:59 - and we leveraged SvelteKit
to run the dev server
165:03 - and help us parse the URL
and load the correct content.
165:08 - What are we going to do
next is develop the API
165:12 - so that we can send
requests to the backend,
165:16 - parse the data and persist an
item, for now, just in memory,
165:21 - but at least we can then play
around with the user interface
165:25 - and see all these things
working together quite nicely.
165:31 - As always we have an issue created,
165:34 - it's called develop CRUD endpoints
165:37 - and watch I've defined
here are four sub tasks
165:43 - in order to satisfy this issue,
165:46 - so we will need a post endpoint.
165:50 - So HTTP method of post on the
slash todos.JSON endpoint.
165:56 - This allows us to create an item,
166:00 - a get endpoint at the same URL
166:05 - to load all the items that
exist in the array for now.
166:11 - And then we want to delete an item.
166:13 - The path for that is todo
slash the random user ID
166:18 - of the given todo-item dot JSON,
166:22 - as well as a patch endpoint.
166:24 - We will need that to mark an item as done,
166:28 - as well as to update the todo-item's text.
166:33 - So with all that in place,
166:36 - let's start with the post endpoint
166:40 - so that we can then go
to the user interface
166:43 - and create a new item as a first step.
166:49 - So we're firing up a Gitpod workspace
166:54 - for that specific issue.
166:58 - And then we will learn about API endpoints
167:02 - that are provided to us by SvelteKit.
167:09 - There we go, we have our
newly styled web application.
167:13 - Let's inspect it so that we can start
167:15 - do some debugging there.
167:17 - We are not going to use much
of the elements inspector
167:22 - today, so we'll switch
over to the network tab,
167:26 - which is what we are going
to be using a lot more
167:30 - to see what's going over the wire
167:32 - from the browser to our backend.
167:36 - Back in the editor,
167:38 - we can start by having
a local where we have
167:43 - to put our files in order
for all that to work.
167:48 - As always, I want to quickly show you
167:52 - under kit.Svelte.dev/docs.
167:55 - If you want to dive deeper
167:56 - into the topic, you can see under rooting,
167:58 - there's an endpoint chapter,
clicking that gives you all
168:04 - the details you need to know
in order to build an endpoint.
168:09 - The most important aspect
of that is that each file
168:16 - that is used as an endpoint
will have to export certain
168:20 - functions, that map to the HTTP
methods that we want to use.
168:26 - So in this case, this is a get endpoint.
168:29 - We can explore other ones as
well to do post, patch, delete.
168:34 - We'll see that as we go through,
168:35 - but if you want to dive deeper,
168:37 - this is definitely a fantastic
piece of documentation here
168:41 - to go read about that,
168:43 - as well as the chapter about body parsing,
168:46 - which I will talk to you
when we start to use it.
168:51 - Okay, so,
168:56 - first we need to understand
what endpoints are.
169:00 - At the moment we have the source directory
169:04 - and then routes, in here,
we have Svelte files,
169:08 - so index for now,
169:09 - we previously had a file
called about us dot Svelte.
169:14 - Whenever SvelteKit sees a
file in the root directory
169:20 - or its sub-directories that
ends in Svelte, it becomes
169:24 - an endpoint, which it becomes
a URL that renders a page.
169:30 - So in our case, this is the
route page, maps to this file.
169:35 - If we want to expose an API,
169:39 - we can do so by creating
files also within the routes
169:43 - directory that end in
dot TS for TypeScript
169:48 - or dot JS if you use JavaScript.
169:52 - Now SvelteKit is then smart enough
169:56 - to determine the file ending
and parse the file differently
170:01 - and the behavior of that
will be different too,
170:04 - but it does use the roots
and the file system here
170:09 - to determine the path of our API.
170:12 - Now, if you recall, in our issue,
170:16 - we specified that we want
a todo slash JSON endpoint
170:21 - to post our item.
170:25 - We can copy that todos.JSON,
170:29 - and under routes,
170:33 - we want to create a new
directory called todos.
170:37 - We could call this API slash todos.
170:41 - We could call it whatever we want.
170:42 - Let's just pick todos for the time being.
170:45 - And within that, we want an index file
170:50 - because we want a todo.JSON
170:53 - so we can do right click, new file,
170:58 - index.JSON.TS for TypeScript.
171:03 - And within that file,
171:06 - we can now create an endpoint
171:11 - that replies or response to a get request.
171:15 - So bear with me, let's create that.
171:17 - And then I'll show you what we did.
171:19 - So we can say export const,
get for an HTTP get request.
171:28 - That's a function.
171:31 - And for now we'll keep it very simple.
171:36 - What we have to return from this function
171:42 - that's defined in the
documentation is basically
171:46 - an object that contains a status code.
171:48 - So let's call it 200
because we want to show
171:51 - whenever it goes, okay,
as well as say body,
171:54 - in this case, we can
say hello from the API.
172:01 - So let's go have a look.
172:04 - If we go the URL and we
go to slash todos.JSON.
172:11 - Todos.JSON exists because
we created a todos directory
172:15 - with an index file.
172:17 - So SvelteKit automatically
creates a todos.JSON URL.
172:21 - If we hit enter,
172:23 - we can see that the response
is hello from the API.
172:27 - And if we look at that in the
172:34 - network tab on the right
side here, let's have a look.
172:39 - We can see that the
headers or a get request
172:45 - and the status code was 200.
172:47 - That's what we specified in our code.
172:52 - So that is the simplest
endpoint that you can imagine.
172:58 - It doesn't do anything as you can see,
173:00 - it just returned some texts,
173:02 - but this is what we
eventually need in order
173:05 - to return all our todo-items,
173:10 - as well as to add new ones.
173:12 - So in order to do that,
173:13 - let's start by first
learning about TypeScript
173:20 - and how this can benefit
us in this situation here.
173:24 - So the first thing you
noticed when I created that is
173:27 - I had to type all that by myself.
173:30 - It didn't actually do
any autocomplete for me.
173:34 - So let's for now just add
a line at the top here,
173:40 - and I'll explain what this line does.
173:42 - So if we say import
type and request handler
173:49 - from SvelteJS/kit,
173:57 - this is importing a type,
174:00 - a TypeScript type called request handler.
174:03 - Now what that request
handler does is it contains
174:08 - a lot of information about that function,
174:11 - what parameters it gets,
174:13 - what returned valued,
expects, and all that.
174:17 - So we can come here and
this is now TypeScript,
174:20 - so if you have a JS file,
then that will not work.
174:24 - What we can say that get function.
174:30 - I want to annotate it
as a request handler.
174:34 - And now if we remove these two items,
174:39 - copy this because I'll need it again.
174:45 - If we do that and I use
autocomplete control space,
174:50 - it is now offering me the properties
174:55 - that are allowed in this return object.
174:58 - So this makes developing a lot easier
175:01 - because now I can just say, all right,
175:03 - I know I need a status
and I want this to be 200.
175:07 - What else do I have, a body,
175:12 - hello from the API.
175:15 - So TypeScript really just
gives us some pointers
175:20 - and suggestions and helps
us write more robust code
175:25 - that follows the specification.
175:29 - So we'll do a little bit more
of type of the TypeScript
175:31 - definitions for our
own code in just a bit.
175:34 - But I wanted to give you an idea
175:35 - of some of the benefits
of using TypeScript.
175:39 - Again, if you don't use
TypeScript in your project,
175:43 - just drop this and the import
and everything else works
175:47 - exactly the same way.
175:50 - All right, so we're going
to leave this for now,
175:53 - but if we look at the issue,
175:55 - we agreed to work on
the post request first.
175:59 - So let's do that.
176:00 - We can create the post endpoint
176:05 - just exactly the same way we did the get.
176:08 - So we can say export const post,
176:14 - and that's also request handler.
176:17 - It's a function and it eventually
will return some stuff.
176:25 - We'll work on that in a second.
176:29 - Okay.
176:31 - Now there is one more thing we can do,
176:36 - and that is a parameter
that's being passed in here
176:41 - to our endpoint, one of
them is called request.
176:47 - If we specify that,
176:49 - then we can leverage TypeScript again
176:52 - to give us some information.
176:53 - So let's talk about what we want to do.
176:57 - When we are on the index page,
177:02 - let's go back to look at our application.
177:07 - We want to type something
177:08 - in here, like first
issue, or first todo-item.
177:12 - And then we want to hit enter
177:15 - and send that data to our backend API
177:20 - and then read it from the
request and persist it, okay.
177:26 - So what we can do is the request handler,
177:30 - which gives us information
about what's coming in
177:33 - the request and what we have to return
177:36 - comes in handy here again,
177:38 - because let's say we want to
print just so that we can test
177:43 - this before we do any
more work, the request,
177:48 - and you can see it gives
us some suggestions,
177:50 - what the request provides, there's a body,
177:53 - there's a bunch of other things,
we currently care about the
177:56 - body, which will be the
content of our todo-item here,
178:03 - whatever we type we want
to read from the body.
178:06 - So request.body.,
178:10 - and then we don't have
any more details here.
178:14 - Now there's one more trick
we can do with TypeScript.
178:18 - And that is the request handler.
178:22 - We can use a few more details.
178:24 - So this is getting a little
bit into the nitty gritty
178:28 - of TypeScript, but basically bear with me.
178:32 - We can use the less than
and greater than symbols.
178:39 - And what we can do here is
not worry about the first
178:43 - argument, so ignore that,
just an empty object.
178:46 - But then here, we can say FormData,
178:50 - and I'll show you in a
second where that comes from.
178:53 - But now if we, if we do a dot here,
178:58 - we basically taught the TypeScript
179:02 - with the second parameter here,
179:04 - what is the type of the body
that we're dealing with.
179:09 - And it's saying FormData.
179:10 - Now it gives us different
functions so we can call here.
179:14 - One of them is get
179:15 - that we're going to be most interested in.
179:19 - And if we open that, you can
see that it expects a key.
179:24 - So let's have a quick
look at mdn FormData.
179:29 - If you search for that, you
will eventually end up here.
179:34 - And the FormData interface
provides a way to easily
179:37 - construct a set of key value
pairs representing form fields
179:42 - and their values, interesting,
form fields and their values.
179:50 - Let's have a look, in our index file,
179:55 - we have a form for the new
item and we have fields
180:00 - in here and remember
that name equals text.
180:06 - So what that means is
if we submit that form
180:10 - to the post endpoint that we defined,
180:13 - we will be able to access
that text property here.
180:19 - So from the body, we want to get the text.
180:26 - That text maps to that text,
180:28 - if I rename this to
item name, for example,
180:34 - I would have to map this one here as well.
180:38 - For now, we'll stick to text.
180:41 - We'll read that text and we
eventually will return it, so
180:48 - oops, I don't know where that comes from.
180:50 - Nevermind.
180:52 - Maybe if we close it reopen.
180:56 - All right.
180:58 - So let's see, we have a post endpoint.
181:00 - How do we send data to the post endpoint?
181:03 - With the get endpoint, it was easy,
181:05 - we could just use the
browser to access the URL
181:08 - because the browser sends
a get requests by default.
181:11 - For the post request,
181:14 - well, we can use the regular HTML form,
181:18 - which is right here, interestingly
enough, we have a form.
181:24 - The action attribute here is
the URL that we want to target.
181:29 - So in our case, it is todos.JSON.
181:35 - As you remember todos.JSON is this file.
181:40 - Now we want to target the post endpoint.
181:43 - So we can say the method,
181:44 - which refers to the HTTP
method that is being used,
181:48 - we want this to be post.
181:54 - There's a lot going on,
so let's have a look.
181:57 - We'll clear up some stuff here.
182:00 - And we come here and we submit that form.
182:05 - So if we hit enter, it gives us a 404.
182:11 - Now let's have a look
why this is happening.
182:14 - We are calling a post endpoint todos.JSON.
182:19 - Say, if we look at the request itself,
182:24 - it's getting a little bit small,
182:27 - but you can see that endpoint todos.JSON
182:32 - post endpoint 404.
182:35 - And if we go to the bottom, we have,
182:43 - see if I can find it, oh,
182:44 - it didn't work because we have a 404,
182:46 - okay, let's fix that first.
182:48 - So 404 happens because we did not return
182:55 - any object from here,
remember here, we had a 200.
182:59 - So for now, let's say we
want to return a status 200
183:07 - in a body that maps to
whatever we send in.
183:12 - So let's copy that and paste it here.
183:18 - So whatever item name,
or item value we put,
183:22 - we'll just return.
183:24 - If we go back and go to the
index page and one more time,
183:29 - say first we submit, you
can see that we ended up
183:33 - on the todos.JSON URL and
the server returned first.
183:41 - If we go back and we say, second,
183:48 - now it says second.
183:51 - So we know that we can
send a value in here
183:54 - read it from there and
do something with it.
184:01 - Another one to remember
is if we don't return
184:04 - an object from here, the
default is 404, not found.
184:08 - So always make sure you have a return
184:11 - with the correct status code.
184:15 - Good.
184:17 - One thing that I don't
like is the fact that
184:23 - we end up on this todos.JSON endpoint URL.
184:28 - That's really not user-friendly
because we don't want
184:31 - to navigate back to add another todo-item.
184:34 - So what we can do is deal with that.
184:37 - The reason this happens is because that's
184:41 - the default behavior, when
you submit an HTML form,.
184:45 - In our case, we can deal
with that quite easily,
184:48 - so instead of doing 200 return
184:53 - or response code, we can
use something called 303.
184:58 - This is a special HTTP code
used to tell the browser
185:03 - that we want to redirect
after submitting a form
185:07 - and what we have to do,
185:09 - we don't have to return a body
185:10 - because the browser doesn't
care what was submitted,
185:14 - but we can return a headers
object and within that,
185:20 - because it's a 300
redirect, response code.
185:27 - We can say location, back to our page.
185:33 - In this case, we want to
go back to the root page.
185:36 - Let's see what that does
to our user experience.
185:40 - We start at the root,
we add our first item.
185:44 - We hit enter and we're back here.
185:48 - We didn't even see the other
page because that other page
185:52 - never loaded because we
gave it 303 return code.
185:56 - That brought us back to here.
185:59 - So that's nice.
186:00 - Now the problem is we don't see the item
186:05 - and that's obviously because
we didn't do anything.
186:07 - We just locked it in the console.
186:10 - So if we scroll down in the terminal here,
186:14 - you can see that printed here.
186:16 - So the server side console log
186:18 - shows up in the terminal here,
186:21 - and we need to do something with it
186:23 - for now because we don't
have a database yet,
186:28 - let's create an array of todo-items
186:36 - and we make this in array, voila.
186:40 - And also we don't really
want to keep that,
186:42 - so let's say todo, persist in database.
186:48 - Once we have a database,
186:49 - we will come and replace all
that to persist it over there.
186:54 - So in here we can now say
187:02 - todos, push and use,
187:06 - oops, let me just copy
that, that'd be quicker.
187:09 - Requests body get text,
187:11 - that's the value of the todo we create.
187:14 - So todos push that text.
187:19 - And now that means every
time we create an item,
187:24 - we add the text of that
item to the todos array.
187:30 - With that, we can know the
change our get endpoint,
187:33 - instead of returning
the hello from the API,
187:36 - what we can return is all our todo-items.
187:42 - Very nice.
187:43 - If we go back and we add first
187:49 - and we add second,
187:53 - and now we go to the
slash todos.JSON endpoint.
187:58 - You can see we get an
array first and second.
188:04 - All we need to do is when
we load the index page,
188:11 - before we rendered a component
and before we even returned
188:15 - anything from the server,
188:17 - the server has to call
that todos endpoint,
188:19 - to fetch the existing elements,
188:22 - and then render one line per todo-item
188:27 - and then return all the HTML to the client
188:29 - so that the client doesn't have
188:31 - to make another HTTP
request to fetch the items.
188:35 - This is called server-side rendering
188:37 - and SvelteKit makes this super easy.
188:41 - Now, before we do that,
188:43 - we probably need to persist
more than just the string.
188:48 - Somehow we also need to know
whether the item is checked,
188:53 - so mark this done,
188:54 - and we also want to
probably keep some kind
188:57 - of date as to when it was created.
189:00 - So let's make this change first,
189:02 - and instead of persisting,
just a string here,
189:07 - we want a persistent
object or a todo item.
189:12 - Now, remember how we use
TypeScript here to help us navigate
189:18 - that code and implement autocomplete?
189:22 - Right now the todos array
can persist a string,
189:28 - but I could also, let me
just show you that real quick
189:33 - persist an object with a property text,
189:38 - that would work just fine.
189:40 - So this is okay, but we can do better.
189:44 - We can use TypeScript
to help us and ensure
189:49 - that we only persist the
correct type into this array.
189:55 - How does this work?
189:56 - Just like we used a request handler,
189:58 - we can create our own type for TypeScript,
190:03 - and then say that in this
array, we only want todo-items.
190:08 - So how do we do that in SvelteKit?
190:11 - You notice there's a file
190:13 - under source, SRC, global.d.ts
190:19 - If we open that up,
190:21 - we can define our to do type right here
190:26 - and it will be available to us
190:29 - across the entire application,
hence global.d.ts.
190:35 - D stands for the TypeScript Hence
190:37 - so what do we want to
do is we can say type,
190:42 - it will be a todo type equals,
190:46 - and don't get confused by these brackets.
190:50 - This is not a regular JavaScript object,
190:53 - it's a TypeScript type definition,
so we want a created at,
191:00 - and that will be a date.
191:04 - And we want a text, which is a string
191:10 - as well as a done,
which will be a Boolean.
191:15 - This is probably a good
start to kick things off
191:19 - and allow us to specify what
kind of type we want to store.
191:26 - So now, if I say that the array of todos,
191:31 - we can use to type here and say that, Hey,
191:34 - I only wanted todo-items
persisted in here,
191:37 - and this is an array of those.
191:41 - If we mouse over,
191:43 - you can see that this is
an array of todo types.
191:48 - Okay?
191:50 - So that's good, and you immediately notice
191:54 - at the bottom, it is complaining now.
191:59 - And if we mouse over that error,
192:02 - you can see that type text string,
192:06 - which is our text request
body get texts, this line.
192:12 - So that type is missing
the following properties
192:14 - from the type todo, created at and done.
192:18 - Interesting, let's have a look.
192:21 - If we were to use
autocomplete, huh, that's cool.
192:26 - It is telling us that
there's two more properties
192:29 - that we need to specify.
192:31 - One is created at, and that's
just a new date right now.
192:37 - And then I think there was another one.
192:40 - Let's do that again,
192:41 - yeah, there's done as well and done,
192:45 - when we create the new todo-item,
192:47 - then done is false to start with.
192:54 - Now TypeScript is satisfied
192:56 - because we are now
creating a proper todo-item
193:00 - with a created at, a text and a done,
193:03 - it's no longer complaining
193:05 - that we cannot push that
into the produce array.
193:08 - So this is pretty good.
193:10 - Now we know whatever element
is in this todos array
193:13 - is of type todo, and it has
three properties defined.
193:18 - We're making good progress.
193:21 - What's still missing though is
193:26 - the fact that it's not
actually showing our items.
193:29 - So as I said, we need to load
all the existing todo-items
193:34 - when we request that page from the server.
193:38 - We can do that in the index.Svelte file.
193:46 - What we have to do is,
193:47 - and that's well documented
in the SvelteKit docs,
193:50 - but besides the script tag that we have,
193:56 - we have to create another
tag, another element.
194:01 - It's also a script,
194:03 - but it is a little bit
more special than that
194:06 - because it has context equals module.
194:12 - So this is how you can
differentiate the two.
194:18 - Every time a component gets rendered,
194:21 - this script gets executed
and the script module
194:26 - only gets executed once
across all the instances,
194:31 - but this is the place where
194:32 - if you're familiar with
like Next.js or others,
194:36 - where you would call,
194:37 - like get the initial
props or places like that,
194:42 - where you can fetch data
from the server before
194:44 - the component is rendered,
this is what we want to do,
194:48 - and because we're using TypeScript,
194:52 - we can tell that script that
we will use TypeScript within.
194:57 - So we can say language is TypeScript.
195:02 - The convention here is
that we need to export
195:07 - a function called load
195:09 - that SvelteKit will automatically call
195:12 - as part of the server side rendering.
195:15 - So let's export that function,
195:19 - const load a regular function.
195:26 - It's a good start.
195:27 - And we want to leverage
TypeScript here as well
195:30 - to help us with the parameters
that are being passed in
195:35 - and kind of the return values we have
195:38 - to specify from this function.
195:40 - So at the top here,
195:42 - we can import a type
and it is called load.
195:46 - We grabbed that from
the SvelteKit package,
195:53 - and then we can annotate this
load function by saying load
195:58 - and just like that, we can now
see what we need to return.
196:03 - So if we say return and
we use autocomplete,
196:09 - there's some error,
196:10 - maxage, props, other stuff in here.
196:14 - So eventually we'll specify
the right things here,
196:19 - but thanks to this TypeScript
type that we specified,
196:24 - we are not able to see
these autocomplete items.
196:29 - So one other thing we want
196:30 - is at this point, this is
where we want to fetch the data
196:36 - from the backend API, right?
196:38 - Remember from the slash todos.JSON,
196:45 - it's empty now because we
restarted the server automatically
196:48 - when we made code changes
there and our array got erased
196:52 - from memory, but we want
to call that endpoint,
196:55 - get that array, and then
render each array item in here.
197:01 - Okay, the way we do that is we
get an object as a parameter.
197:07 - And one of the values
197:09 - in there, or one of the
properties is called fetch.
197:12 - If we use that fetch, not to confuse
197:14 - that with the regular fetch
that you get in the browser,
197:18 - this is a special fetch
that's provided by SvelteKit.
197:22 - So always make sure you use that.
197:26 - This is where we can now
call that endpoint to get
197:29 - and fetch our todos, so
fetch slash todos.JSON.
197:37 - And this is an async call,
so it's returning a promise.
197:42 - So let's change our function
197:47 - to async and then leverage a wait here.
197:50 - So the response is a wait fetch.
197:57 - Now, if the response is okay, again,
198:02 - you can see TypeScript
helping us here, if it's okay,
198:06 - then where you want to
convert the response
198:10 - and get these todo-items out of it,
198:15 - so todos equals await,
JSON response there.
198:19 - Now that array contains the
same elements as that array
198:24 - because we return it as part
of the party in this get
198:28 - request, which we call with
the fetch function here.
198:33 - All right.
198:35 - Having these todo-items,
198:37 - we need to pass them to our component,
198:39 - so that down here, instead
of rendering three static
198:43 - todo-items, we want to render
X amount of todo-items,
198:47 - depending on how many have
been added to the array.
198:52 - So if we use TypeScript autocomplete here,
198:57 - you see one property is called props,
199:01 - and that's exactly what we want to do.
199:02 - We want to use the props
199:04 - to be passed into that component here.
199:08 - So props is an object and we
just want to pass in the todos
199:14 - which creates a todos property
199:19 - that is being passed into the script.
199:22 - So we can come here and I'll teach you
199:25 - how to do props in Svelte.
199:29 - The way it works is the syntax for that
199:32 - is export let todos.
199:37 - That gives us a prop called todo
199:41 - that's exported from this component
199:43 - so here is where we specify the props
199:48 - we want to pass in down here.
199:51 - You can see that it's complaining
199:53 - that we don't have type defined.
199:55 - So we actually have the to do type right,
199:59 - that we created in global.TS.
200:03 - So we know that this property is going
200:05 - to be of type todo, so we can say,
200:09 - this will be an array of todo-items.
200:12 - And because we know using TypeScript,
200:15 - we have to let the script
know that we use TypeScript.
200:21 - All right, that was a lot,
200:24 - but basically we exported a
load function that executes
200:29 - on the server when we
do a full page refresh,
200:31 - which is currently the case.
200:33 - If we were to navigate
200:35 - from one page to another,
then the client side would,
200:40 - the browser would call this load function
200:42 - and do a client side fetch.
200:44 - But in our case, because we
always refresh that page,
200:48 - ignore that error, because
we all just reload the page,
200:52 - that fetch actually
executes on the server,
200:55 - the load function, and then calling fetch.
200:58 - So we go grab that and we
return if everything is okay.
201:06 - We passed the todos array into here,
201:09 - and then we currently
not using it anywhere.
201:13 - So it's giving us a little warning.
201:15 - We will do that in a second,
but before we move on,
201:18 - let's deal with the error case
in case something goes wrong
201:22 - with our fetch, what we can say is
201:26 - if the response is okay,
we return, so that means
201:29 - that down here on line 13,
the response was not okay.
201:33 - So what we can do is we
can fetch the message
201:39 - and we do that from
await response, dot text.
201:50 - So basically, oops, that should be JSON.
201:55 - So basically whatever we
get back from the server,
201:58 - it will contain a message
object, we haven't built
202:01 - that yet, but that's just
preparing us for later.
202:05 - And then what we want
to do is we don't want
202:08 - to return props because
if we return props,
202:11 - we indicate that everything was okay,
202:15 - so we can return an error.
202:19 - And that's just a new error
202:22 - with the message that we receive.
202:25 - The nice thing about
that is that if we return
202:27 - an error then the SvelteKit
will automatically render
202:30 - an error page instead of our component.
202:34 - Alrighty.
202:37 - We now have the todos array
that contains whatever elements
202:42 - are in the array on the server side.
202:46 - Now we have to use that
202:47 - to render todo-items
depending on how many we have.
202:54 - So basically we need a for loop
203:00 - or in Svelte's case, an each loop.
203:03 - This index for that is that you
use the open curly brackets,
203:07 - hashtag each,
203:10 - and then you specify which
array we are iterating over.
203:14 - So that's our todos array.
203:16 - And then what's the variable name
203:20 - of the individual todo-item of this array,
203:23 - so as todo allows us to
access to individual item
203:28 - from the array, with the
variable to do, and then
203:33 - to close it, curly brackets
slash each closes the loop.
203:38 - Now it's telling us this
is an empty each block,
203:41 - please don't do that,
203:43 - that's fine we can have
that todo-item render
203:47 - and we do not need these
other two items we have there.
203:53 - Let's have a look.
203:56 - Nothing rendered because
we have nothing added yet.
204:00 - We go to first.
204:04 - And we now have one item in the array.
204:08 - It doesn't show anything,
204:10 - and I'll show you that in
a minute, how we fix it,
204:13 - let's do another one.
204:16 - Two items, nice.
204:18 - It doesn't show any texts or anything
204:21 - because we still just render a todo item
204:24 - that if we look at the details
under source lib todo-item
204:30 - in the HTML, it doesn't
literally do anything,
204:33 - it's all empty, that's why we
just see two empty elements.
204:38 - So first things first,
204:39 - we need to pass this
todo-item into the component.
204:46 - And remember in Svelte, export let
204:50 - is how you specify a prop
204:55 - so we can do the same for the todo-item.
205:00 - So up at the top, we
don't have a script yet,
205:03 - we add script.
205:09 - We also want to use the TypeScript here.
205:12 - So language TS, and we say export let
205:19 - a single todo of type todo.
205:25 - And we get a warning because
we're not using it yet.
205:28 - That is changing right now.
205:30 - The only thing we have for
now is the text property,
205:32 - remember in the API post,
we set the created at,
205:37 - which we don't display in
the UI, where you set a text,
205:41 - which is the value we entered
and had done, that's false,
205:45 - in the todo-item.
205:47 - We can now go down to this section here
205:50 - where we have a text input field,
205:55 - and now we can say value equals
205:58 - and then just like in the index
where we used curly brackets
206:04 - to access a variable, we
can do the same here and say
206:12 - todo and dot text because it's a string.
206:18 - With that, we can go back
and in the index file,
206:22 - we now see that this
is complaining, saying
206:26 - that todo-item, and that's
because we use TypeScript.
206:30 - It's telling us that
it's missing a todo-item.
206:34 - So we can just come
here and say to do prop
206:40 - is this specific todo-item here in Svelte.
206:46 - Since the name of the variable
206:49 - and the name of the prop are the same,
206:51 - we can use a shortcut and
just basically drop this
206:55 - and say curly brackets todo.
206:58 - That will pass in that specific variable.
207:03 - And now you can see, we have first second.
207:07 - If we were to add third, we
would get third it as well.
207:13 - Now, keep in mind.
207:15 - The way this currently works is that
207:17 - every time we add an item and hit enter,
207:24 - you can see that there's
a lot of requests.
207:26 - That's because we first sent the request
207:29 - to the todos endpoint
207:32 - where we get a redirect to the homepage,
207:34 - and then the browser
reloads the entire page
207:36 - and all the development stuff,
207:38 - hot reloading loading everything.
207:41 - What that also means is
that what we just built
207:47 - works even if we disabled JavaScript,
207:50 - let's have a look.
207:51 - In our developer tools, we go to settings,
207:55 - we scroll down to the debugger section
208:00 - and we say disable JavaScript.
208:05 - And if we come here, we reload the page
208:11 - and we add a fifth item.
208:16 - That's still a works
because all we're doing
208:19 - is we're using HTML forms
and a post submission.
208:23 - So there's no JavaScript involved at all.
208:26 - We will later improve this
208:29 - so that if somebody
has JavaScript enabled,
208:33 - we will just send an Ajax request
208:36 - and not reload entire page.
208:38 - But for now it's really
interesting to know
208:40 - that the application works
even with JavaScript disabled.
208:47 - Alright, we built a lot and
there's a lot more to do,
208:52 - but I think this is a good
point to commit the changes,
208:57 - because if we look at our issue,
208:59 - we already created the post endpoint
209:02 - as well as to get endpoint, they are done,
209:05 - so it's probably a good
time to commit that
209:08 - so we can check these two off
209:10 - before we move on to building
the delete functionality
209:13 - and then the patch to update the items.
209:18 - Okay.
209:21 - So quick review, we created
the new type called todo
209:25 - that has three properties in the API.
209:29 - We created a new index of JSON.TS files
209:33 - under source, routes, todos.
209:36 - This is where we have a
get endpoint that returns
209:40 - whatever array elements we
have in that todo array.
209:45 - We also have a post
endpoint where we create
209:49 - a new todo item every time
somebody sends a post request,
209:53 - we read the text value from the body,
209:57 - and then we redirect back to the homepage
210:00 - to get that experience of adding an item
210:03 - and then seeing it displayed in the UI.
210:07 - Okay, that's a good start.
210:10 - What are we going to do next
is in the commit message,
210:16 - we can say that we add
get and post endpoints.
210:24 - We can go ahead and commit these changes
210:29 - and create a pull request
that, let's use a better title,
210:36 - develop CRUD endpoints.
210:42 - And here we say, we want
to close issue number nine.
210:46 - We are not done yet,
so we make it a draft.
210:50 - There's two more endpoints we have
210:52 - to implement, but this
is a good start, publish,
210:56 - and with that, it will have
added that CRUD endpoint.
211:02 - So let's check this off.
211:03 - So our team members
know what's the status.
211:07 - We can switch here and we
now see the files we changed.
211:14 - Good, so with that,
211:16 - we could continue to
work on that environment,
211:20 - but I think it's a good
time to take a break,
211:23 - go grab some food or drink some water.
211:26 - So what we'll do instead is we just
211:28 - shut down this environment
here, we'll stop it.
211:32 - We'll get rid of it, preview done.
211:35 - And we will come back
211:37 - and then continue with
the new environment,
211:39 - just so that you see that
it doesn't really matter
211:42 - how many environments you start.
211:44 - Each one is completely independent.
211:47 - All right, so continuing on
211:50 - with the other patch
and delete requests now.
211:56 - Let's have a quick look at our
issue to check what's next.
212:02 - So we've done post get,
212:04 - now we're going to work
on a delete endpoint.
212:07 - And as we specified, we want this endpoint
212:11 - to live at a /todos/uid.JSON endpoint,
212:18 - where you currently see the colon UID,
212:21 - this will have to be a dynamic part
212:25 - of the path in the URL, where
depending on the todo-item,
212:30 - where we want to delete that part,
212:33 - we'll update as we click
the delete button in the UI.
212:38 - So we'll see how we can
do that in SvelteKit.
212:41 - And also we will have to
create a unique identifier
212:45 - for each todo-item.
212:47 - So with that,
212:48 - let's switch back to the
pull requests that we already
212:50 - started and start a new
environment so that we can go ahead
212:56 - and develop that delete endpoint
213:00 - at that specific URL that
we specified in the issue.
213:13 - Here's our new developer environment.
213:16 - It also opens up the application preview,
213:20 - which is exactly what we want.
213:23 - We inspect that and select our network tab
213:28 - so we can keep an eye
on what is being sent
213:32 - between the client and the browser.
213:37 - Okay, now we can,
213:41 - first of all, start by
creating the new endpoint file.
213:45 - So let's have a look
under source routes todos.
213:50 - We already have an index.JSON.TS file,
213:54 - which we created previously,
213:57 - where this file contains
our post and get endpoints.
214:03 - Now, in order to create the
endpoint with the dynamic UID,
214:08 - what we can do is under the
todos directory as well,
214:13 - we can create a new file
and we can call this
214:19 - [UID].JSON.TS
214:26 - that naming convention
with the square brackets
214:29 - tells SvelteKit that this part of the path
214:36 - is going to be dynamic.
214:38 - And it will change depending
on what ID we send.
214:43 - So let's create a file.
214:45 - And then just to test real
quick, what is going on here,
214:50 - let's create an get endpoint
214:52 - so we can use the browser for testing,
214:54 - so as you recall from the
previous endpoint we created
214:59 - export const get,
215:02 - and that's a function,
215:05 - and we'll just do this very
quickly without any TypeScript
215:10 - definitions, but basically
we get a request here.
215:14 - And what we have to return is the,
215:19 - an object that contains the
status of 200 and a body.
215:25 - And for the body,
215:27 - what we want to do is we want
to use request.params.UID.
215:37 - So, oops,
215:39 - so what we have is the params object
215:44 - refers to any path,
215:49 - any part of the path where
we have square brackets.
215:51 - So in this case, UID that's
wrapped into brackets,
215:55 - turns into a property
on that params object.
215:59 - And we can access that by simply
216:03 - calling a request.params.UID.
216:06 - So what we can do now is if we go back
216:09 - to the browser where we have
our application running,
216:12 - we can go to slash todos
slash and then a dynamic part
216:19 - of the URL, so that's our
UID, let's say ABC.JSON.
216:25 - And if we load this page,
216:28 - you can see that the response is ABC,
216:31 - that's because as I said,
we just read that params UID
216:36 - and return it as a 200 response.
216:39 - If the todo-item UID was 123.
216:44 - You can imagine if we change this to 123,
216:47 - then the return value is 123.
216:52 - So this is great.
216:53 - We can then dynamically
generate this URL when we are
216:58 - in the user interface and
click on the delete icon
217:02 - next to a todo-item.
217:05 - Now, before we do the UI part,
217:07 - let's first complete the
API for that endpoint here,
217:14 - so that when we built the UI,
we can immediately test it.
217:19 - Okay, so what do we
have to do in this file,
217:22 - first of all, let's import the types
217:29 - for the endpoints here.
217:32 - So same as we did in the index.JSON file,
217:34 - where we have that request handler,
217:36 - we'll grab the same type and
we import it here as well.
217:43 - Now we can say that endpoint
217:47 - is of this request handler type.
217:51 - And the other thing we can do is we want
217:53 - to change that get endpoint
to a delete endpoint.
217:57 - Now delete is a keyword in
JavaScript that we can not use,
218:00 - so the actual name is
just D-E-L for delete.
218:06 - And now if we use the request
dot, we get this autocomplete,
218:12 - because we have the
request handler defined.
218:16 - So TypeScript knows what's going on here.
218:20 - Now we have a bit of a challenge here,
218:24 - first of all, let's get rid
of this just for a second.
218:28 - The challenge we have is, even
though we can access that UID
218:34 - we need to somehow remove the correct item
218:39 - from this todos array right here.
218:44 - Unfortunately, we don't
have access to this array
218:47 - because it's in a different endpoint.
218:50 - And from this file,
218:51 - there's no easy way for us
to go and access that array.
218:57 - So what we're going to do instead is
219:01 - we will refactor that code a little bit,
219:02 - so that anything related
219:06 - to actually creating or
adding a todo or updating
219:10 - or deleting, we will move
that into a separate file
219:14 - and the index.JSON.TS
and the [UID].JSON.TS,
219:19 - both of these endpoints will then leverage
219:23 - that new file to interact
with the todo-item.
219:27 - This also makes it
easier a little bit later
219:30 - when we switch from an array
219:33 - that we persist in memory
to accessing the database,
219:38 - we will have just one
place in the source code
219:41 - where we have to make that modification.
219:43 - So doing that refactoring now
219:46 - is a good point to bring us
into good shape for later.
219:53 - So one thing I can teach you now is that,
219:57 - as I said, any file within
the roots becomes an endpoint
220:01 - if it ends in dot TS or JS,
220:04 - or a page if it ends in dot Svelte.
220:07 - Sometimes just like we do
what we want right now,
220:10 - we want to create additional
helper files that we can use,
220:16 - like in this case to consolidate
certain functionality.
220:21 - We could, if we wanted
to move that into lib,
220:24 - but that really starts to
convolute the lib directory
220:28 - and add a lot of stuff in
there that isn't really used
220:31 - across the entire app, but
only in certain places.
220:35 - So there's another
convention in SvelteKit,
220:38 - and that is if a file in
the roots directory starts
220:42 - with an underscore,
220:44 - the SvelteKit router ignores it
220:47 - and does not create a path for that file.
220:50 - So we can leverage that
knowledge and under source routes
220:54 - todos, we can create a
new file called _api.TS.
221:03 - And this is going to be
our file that we can access
221:07 - from both of the other
endpoints that we created.
221:12 - All right, the first thing
we want to move in here
221:16 - is that array of todo-items.
221:19 - So we'll grab that, remove it from here
221:24 - and add it to our API.
221:30 - So with that thing moved over here,
221:35 - we know, we can ignore
this warning for now,
221:41 - that'll fix itself in just a second,
221:45 - what do we want to do now is
we want to export a function
221:49 - here that we can then call
from the different places
221:55 - such as the get and to
post endpoints here.
221:59 - And we will do all the behavior
related todos in there.
222:04 - So let's create that
function export const API.
222:10 - For now, it doesn't have any parameters.
222:14 - There we go.
222:16 - So now what we want to do in here is
222:21 - depending on whether we want
to create or delete or update
222:27 - an item, we want to execute
different functionality.
222:34 - So if you recall,
222:35 - let's have a quick look
back in the index file.
222:40 - When we look at the form
where we create a new item,
222:44 - you see that we specified the
HTTP method as being post.
222:49 - And we also know that
when we load index page,
222:53 - the server receives a get
request from our fetch here.
223:00 - So that fetch slash todos
223:03 - by default is an HTTP get request.
223:06 - So we want to kind of like an
if else situation in our API,
223:11 - where we say that if
the HTTP method is get,
223:17 - then please return the array,
if the HTTP method is post,
223:23 - then please create an
item for us in the array.
223:27 - So what do we need in
order to determine that
223:31 - is we need the request
object because we need
223:34 - to access that HTTP method.
223:36 - So I'll show you how we can do that.
223:38 - First things first,
223:39 - let's go grab that import statement again
223:44 - for the, oh, sorry, not
the request handler.
223:48 - What we can do is in the
API, you want to say,
223:51 - we want to request and
the type of data request,
223:57 - we can fetch that from
the SvelteKit packet.
224:01 - So import type request from SvelteKit.
224:10 - Now, if we go to the API and we say
224:13 - the request is of type request,
224:16 - we will get all the autocomplete
functionality that we need.
224:22 - Now, if we have a look in both cases here,
224:27 - we eventually return that object.
224:31 - So that depends, the value of that object,
224:34 - the return object depends on
whether we do a post or a get.
224:38 - So I suggest we will move that code also
224:41 - into the API so that in this file here,
224:46 - we can just make a call to
the API and return the result.
224:50 - So we don't have to do
any more code in here.
224:55 - Let's start by running a switch statement.
225:01 - So switch and the value we want to check,
225:05 - as I mentioned is request.method,
225:09 - which is going to be either
post or get or patch,
225:13 - things like that, as we go through.
225:17 - Now, let's also make this uppercase
225:22 - just to be sure in case it
is being sent by clients
225:25 - in different format, lowercase
or uppercase mixed maybe.
225:29 - Now the value we want
to look for here is get.
225:36 - In the get case, we want to
return all these todo-items.
225:40 - And in order to do that, remember here,
225:44 - we had a body and a status
of 200 and the todo-items.
225:51 - So what we can do in here in our API,
225:52 - above the switch statement,
225:55 - we can specify a body and
that's by default empty.
226:01 - And we can specify a status
that is by default 500.
226:06 - Now we set this to 500,
226:07 - which represents an internal server error,
226:10 - just so that if somebody sends a request
226:15 - with a method that we did not
add to our switch statement,
226:19 - the default behavior will be a 500 error,
226:22 - which indicates that
whatever the clients try
226:25 - to do with their method
here is not implemented yet,
226:28 - so right now, if somebody
were to send a post request,
226:32 - they would get a 500 error,
as soon as we returned that.
226:37 - Now, in the case of get,
226:40 - we know that the body has
to be the array of elements.
226:47 - We had that over here previously.
226:50 - Now we no longer have
the array here, however,
226:52 - we do have it here in our API.
226:55 - So we can say body equals todos
227:01 - and status equals 200.
227:04 - With that we rebuild the functionality
227:07 - that we had in the index.JSON.TS file.
227:11 - Lastly what we want to do
227:14 - after the switch statement
227:18 - is we want to return
that status and the body
227:27 - so that whatever we set
in the switch statement
227:30 - will get returned down here.
227:37 - Now, for the post request.
227:40 - So first of all, before
we get to the post,
227:42 - let's clean up the get request.
227:44 - And the way we do that is by
importing the API we created.
227:51 - So we can say import API
227:57 - from the API file.
228:01 - And then the fix down here,
228:04 - the code change is that
instead of just returning
228:08 - that object, we can remove that
228:13 - and we do need to get the request
228:17 - because our API expects that.
228:19 - And then we can say return
API and pass the request.
228:25 - Now this just becomes a
one-line function here
228:29 - where we call that API
that we specified here,
228:33 - then the switch statement
will fall into the get case
228:38 - where we set the body and the status,
228:41 - and down here, we return
body and status back,
228:46 - which then gets returned
from this function,
228:48 - and we are back to the
behavior we had previously.
228:54 - The benefit now is that
everything is consolidated
228:56 - in that API script.
228:58 - Let's do the same with the post endpoint.
229:02 - So in the switch statement,
let's add a case for post.
229:14 - So don't forget the break statement,
229:18 - otherwise we'll run into the next case
229:20 - and that will have
unexpected consequences.
229:26 - Okay, in the post case,
229:28 - let's see what we have to do.
229:30 - We need to push a new
item into the todos array,
229:37 - just like we did here.
229:39 - So we could potentially create that
229:46 - item inside of our API right here,
229:50 - by reading the values from the request.
229:54 - Another way to do that
229:57 - is to add a parameter to the API,
230:02 - which is a todo-item.
230:05 - And that will then basically
230:09 - help us create the item for the array.
230:13 - So either way it works.
230:15 - I think for now, what
we can do is right here,
230:19 - we'll create the item and then
we will pass it into the API.
230:24 - So let's say that our API
also requires a todo-item.
230:31 - And the type of that is
to do remember we created
230:33 - that in the global.d.ts,
there's our todo type,
230:38 - so we can tell what properties we expect.
230:44 - Now in the post scenario, we want to add,
230:50 - so push the todo-item into that array
230:55 - and then the body and status,
230:59 - in the post case, we can
go grab that from here,
231:04 - you'll see it was status 303
and headers and location.
231:10 - So this is interesting because
231:17 - that return object is different
231:19 - from the return object
that we had down here.
231:24 - Now for the time being,
231:28 - let's just take that return here.
231:34 - And because we're working
231:36 - on a post, we can come here and exit early
231:41 - to return that status 303
231:44 - because we don't really
want to return the body
231:46 - that we don't have, also
we need the headers object
231:51 - for the post request.
231:53 - So we don't want to, you know,
231:55 - deal with that down here
where sometimes the headers
231:58 - is available, sometimes it's not,
232:00 - we'll just move it in
here for the time being.
232:05 - All right, now, if we go
back to that index file,
232:10 - what do we want to do now, here
is basically call that API.
232:17 - So same as we did above,
232:18 - and we'll fix that
error there in a second.
232:20 - So again, we want to return API.
232:24 - The first parameter is a
request and the second one
232:29 - is the object that
represents our todo-item.
232:37 - And then we don't need
any of this anymore.
232:41 - So that's good.
232:44 - Now we noticed that the
return statement up here,
232:47 - where we call the API and to get request
232:50 - is now red underlined.
232:53 - And if we do that it says
that it expected two arguments
232:56 - but it got one, that's because we added
232:59 - that todo-item for the post requests,
233:02 - but when we have a get
request or maybe later
233:06 - delete request, we don't
really have a todo-item.
233:10 - So what we can do in TypeScript
is after the parameter name,
233:15 - we can add a question mark
233:18 - to mark this specific
parameter as optional.
233:22 - And now the API accepts a request
233:26 - or a request with a new todo-item.
233:31 - So so far we have refactored the code
233:35 - that we had previously,
the get and the post,
233:38 - and because we have return statement here,
233:40 - we don't really need the break,
we can remove that for now.
233:44 - Now we did all that work
233:47 - because we wanted to
add a delete endpoint.
233:50 - So we have the wrapper here
233:53 - and now what we can do
in that specific file,
233:57 - we can leverage what we
already built in the API file.
234:02 - So if we import the API here
234:06 - and that lives in that API file,
234:10 - we want this to be a return API request.
234:16 - And then we want the API file
234:18 - to worry about the details
of how to implement that.
234:24 - The way we do that is when
we have a delete request,
234:28 - we expect the HTTP method
to be delete, right?
234:34 - So we have get, post,
234:38 - and now we want a case
234:45 - for the delete endpoint.
234:49 - And I want a break from that.
234:54 - The response status for a delete request
235:00 - is going to be 200, so status 200.
235:04 - We do not have to specify
a body for a delete request
235:09 - because the item gets
removed and doesn't exist.
235:12 - So we'll keep the default, which
235:15 - is an empty object, but
we have to remove the item
235:21 - based on the UID from the
array that we have up here.
235:27 - Eventually when we have a
database, that will be super easy,
235:30 - we just say, you know, delete
from the database with that ID
235:35 - for now, because we just persist
that todos array in memory,
235:40 - we have to manually just go
in and filter the existing
235:44 - array, but not include the
element that we want to delete.
235:49 - So the way we do that
235:50 - is todos, we set a new value for that.
235:54 - And then we basically filter,
236:00 - we filter that and we say that we want
236:04 - the todo.UID not equals to
236:10 - remember request.params.UID
gives us the unique ID.
236:17 - And what we notice is that
an individual todo-item
236:21 - does not have a UID because at the moment,
236:25 - if we look at that global.d.ts file,
236:28 - there is no UID specified.
236:31 - However, because we need that
UID now to identify an item,
236:39 - we have to extend our todo
type by adding a UID property.
236:44 - And that will just be a string.
236:47 - So UID now exists and our
API no longer complains
236:52 - about the UID not being present.
236:56 - However, if we look at
the index JSON file,
237:01 - we know we're getting an
error here because we create
237:03 - a todo-item that does not
include a UID property.
237:08 - Now this is again, the beauty
237:10 - of TypeScript, really to help us identify
237:15 - these kind of box before
we even go to production.
237:20 - So what do we do?
237:21 - There's a good way, and a
temporary way to do that.
237:27 - The good way would be
to import a UUID package
237:32 - and create an actual UUID, or
we can do a little workaround,
237:38 - which is fine for now,
237:40 - but eventually that UID
will be generated for us
237:44 - by the database, so we really just
237:46 - add a temporary UID for now.
237:48 - And what we can do is UID
equals, it has to be a string.
237:53 - We specified it as a string type.
237:56 - So we can use string literals
here and say Date.now,
238:01 - which gives us the milliseconds
238:03 - when this item gets created.
238:05 - Again, don't do that in production,
238:08 - definitely don't do that
238:09 - if you have two requests
coming in at the same time,
238:12 - you will have a conflict of
two items with the same UID.
238:17 - So do not do that.
238:20 - Todo replace with UID from database.
238:32 - This is something that we will
fix once the database exists
238:36 - and we can create the item in the DB,
238:41 - but for now, at least we get a UID.
238:44 - And when we delete the item,
238:46 - we have access to that
and we can remove it.
238:51 - So this is a pretty good start.
238:56 - Now, what do we want to do next is
238:59 - go have a look at what
do we have to change
239:02 - in the UI in order to
call this delete endpoint.
239:09 - The place where we click the delete icon
239:13 - is under lib todo-item.
239:17 - In here, you know,
239:18 - that we have a prop
for our individual todo
239:21 - and down in the forms, you can see here,
239:25 - we have the delete todo button.
239:30 - Now the action is the
endpoint that we just created.
239:35 - So that endpoint lives
at slash todos slash
239:40 - let's just make UID.JSON.
239:44 - The UID has to be dynamic
depending on the item we render.
239:48 - So if you recall with the curly brackets,
239:51 - we can access the variables.
239:53 - So we can remove that and
just say curly brackets
239:58 - and todo.UID again, thanks to TypeScript,
240:02 - we have that autocomplete
of the new field available.
240:07 - And as we set the method
that we want to use,
240:12 - we'll look at the API, deleting
something in a REST API
240:17 - is an HTTP request with
a method of delete.
240:21 - So in our todo-item method,
240:24 - we want to say delete so that
the API knows what to do.
240:32 - Now, let's have a look
at the user interface.
240:36 - So we'd go back to the index
and there seems to be a bug
240:42 - somewhere, let's have a look okay.
240:45 - Just temporarily because
of the changes we made.
240:50 - Okay, let's clear this, clear console
240:54 - and let's add an item.
240:58 - So that worked.
241:00 - And now if we inspect
the button real quick,
241:05 - you can see that the form now
points to slash todos slash
241:11 - the unique ID that we created
241:13 - based on the date dot
now function dot JSON.
241:16 - So this is just like before,
241:18 - when we did slash todos slash ABC or 123,
241:22 - we have a delete method,
so that should all be good.
241:25 - Now let's see what happens
when we send that request.
241:30 - So we go to network, clear this,
241:32 - clear the console, and we delete the item.
241:37 - Interesting, we get a 404,
it says not found slash todos
241:43 - blah blah blah dot JSON.
241:45 - What is going on?
241:47 - Let's have a look.
241:50 - There's our requests
that ended up in a 404,
241:53 - but clearly we know that exists
because we just created it.
241:57 - And if we click on it,
242:00 - we notice that the
request method was "get".
242:07 - Now, why would it be "get"
when we specified "delete"
242:12 - in our method here?
242:14 - So unfortunately I have some
bad news and the bad news
242:18 - is that an HTML form only
supports get method or post.
242:25 - Very unfortunate for us
because we can not use delete.
242:31 - However we don't want to change our API
242:35 - and put all our code to
delete and update items
242:38 - into the post handler.
242:41 - Because if somebody were to build,
242:43 - let's say a mobile
application for our todo app,
242:47 - they would expect the REST API
to provide a delete endpoint.
242:52 - So this is really on us to
find a workaround for our web
242:57 - application so that we
can still make this work,
243:02 - but rely on the delete
endpoints, even though HTML forms
243:06 - don't actually support it.
243:09 - The way we can do that in SvelteKit
243:13 - is back in our todo-item.
243:16 - We have to conform to the post endpoint
243:21 - or post method because that's
the only thing we can do.
243:25 - So we'll change this to post,
243:28 - but we use a query parameter here,
243:33 - and that's just something
that we agree on.
243:36 - There's different ways
we could solve that.
243:38 - This is one way to do it.
243:40 - So what we say is that let's append
243:43 - an _method parameter,
and we call it delete.
243:51 - Okay so we are in the request object
243:53 - that our API eventually gets.
243:56 - There will be a created parameter
243:58 - called _method equals delete.
244:01 - So that will help us identify
244:03 - where do we want to do a delete.
244:06 - Even though we are actually
sending a post request
244:08 - over the wire.
244:10 - Now we could go into the
API and here where we say,
244:15 - switch request.method.
244:18 - I could show you that request.query.
244:25 - We could go and fetch
that _method parameter,
244:35 - and then we could check if that is delete,
244:37 - then do something, but again,
244:40 - we don't want people who want
244:42 - to build on top of our application,
244:43 - but using our APIs to create
URLs that contain this created
244:50 - parameter, they can just
send an HTTP delete request,
244:54 - and that should work, so we
have a little feature here
244:58 - that we can use in SvelteKit.
245:01 - Basically when that request is sent
245:04 - from the browser to the
SvelteKit application,
245:07 - we can intercept the request
before it reaches our API
245:13 - and the place to do that is a file
245:16 - that lives in the source
directory, new file,
245:20 - and the file is called hooks.TS.
245:26 - Not to be confused with hooks
245:29 - from other frameworks that
you might be familiar with,
245:31 - completely unrelated things,
same name, different ideas.
245:38 - So definition of the hooks file, again,
245:41 - it's documented in the SvelteKit docs,
245:43 - but what we need to know is
245:46 - if we export a function
from here called handle,
245:49 - we can do things there
245:52 - before the request is sent to our API.
245:56 - So let's do this export
const a handle function.
246:04 - And if we want to make our life easier
246:09 - to see what we have to do,
what the parameters are,
246:13 - there is a TypeScript definition for that.
246:15 - So if we import type
handle from the SvelteKit,
246:24 - we can then annotate our
handle function with that.
246:29 - And right away, it's
telling us that, you know,
246:32 - type void is not assignable,
246:34 - which means our function
currently doesn't return anything.
246:38 - So we do have to return
something here, but first of all,
246:41 - we also get some parameters
that are important to us here.
246:46 - And if we inspect that one thing we get is
246:50 - the request object and a result function.
246:56 - So in order to return
the right value here,
247:02 - we have to call the resolve function
247:07 - and pass in the request object
247:10 - and all this happens asynchronously.
247:13 - So we have to make this
an it async function
247:17 - and here return,
247:22 - await resolve request.
247:26 - There we go.
247:27 - Or to make this a bit more clear in terms
247:29 - of what's going on, we
can const response equals
247:35 - this and then return response.
247:42 - All right, let me explain.
247:44 - So all we're doing here is we call
247:46 - that resolve function
and we await the result.
247:50 - The request is a parameter we pass in.
247:53 - And then when this is all done,
247:54 - we get a response object
that we have to return.
247:57 - So this is the default implementation
247:59 - of that handle function.
248:01 - So where do we do this?
248:03 - Or completely comment this
out and remove the file.
248:07 - We get the exact same behavior, however,
248:11 - in line number four here,
where we say await resolve,
248:14 - this is when SvelteKit
248:17 - actually executes the code in our API.
248:21 - What we can do is before
we do that resolve call,
248:26 - we can intercept and
modify that request object.
248:29 - So what we want to do is we want
248:32 - to check if the query
parameter _method exists.
248:37 - So if this _method exists,
248:40 - we want to take the value
and set that value as the
248:45 - request method so that
when we get to the API,
248:49 - request.method is equal to delete.
248:54 - Okay, now let's see how we can do that.
248:58 - First, right above that, we can use
249:01 - an if statement to
inspect the request.query.
249:07 - And if it has that _method endpoint,
249:14 - then we want to change the request method.
249:19 - And we want to set it to the
value from the request query,
249:25 - get method, and then let's
just also make it uppercase.
249:32 - You don't have to,
249:33 - but it's probably a good practice
to keep this as uppercase,
249:39 - okay, so now if we have that parameter,
249:42 - we override the request method
and set the value to whatever
249:47 - we pass in into URL.
249:50 - With that we now can go back
249:53 - to the UI and this all failed
horribly in the meantime,
250:00 - which is okay, we'll go
back to the index page,
250:04 - clear this up.
250:05 - We add our first todo-item, okay.
250:10 - We reloaded the page, that worked well,
250:13 - and now if we click the delete button,
250:16 - what happened is that
we got a status code 200
250:21 - and our endpoint was still
a post request, fine.
250:26 - That's nothing we can do about
250:27 - because of the HTML specification,
250:30 - but we ended up on the endpoint URL
250:37 - and we got an empty object.
250:40 - The empty object comes from the API file,
250:42 - as I said, the body's an empty object.
250:44 - In the case of delete,
250:46 - we remove that todo-item and
we returned status code 200.
250:51 - But just like with the post request
250:54 - where we had to do a redirect
back to the index page,
250:58 - we need to do the same
for our delete request.
251:01 - Now, just to show you what happened
251:03 - to the server, because
we executed this line,
251:08 - but we never saw the result
of that item being removed.
251:12 - If we go back to the index page,
251:16 - you can see that the item is gone.
251:18 - So the API actually works,
251:20 - just the redirect didn't
happen back to the index page.
251:24 - So one way to fix that
is to copy that return
251:30 - down to the delete as well,
251:33 - or really the pattern that
starts to emerge when we look
251:38 - at that, is that if the
request.method is not get,
251:44 - then we want to redirect
back to the homepage.
251:47 - So we can do that down here,
that will be a lot easier
251:50 - to read, so if the request.method
251:59 - to uppercase, is not equals
to get, in that case,
252:05 - we want to do that redirect 303.
252:09 - So we can take that code and
replace that with a break
252:15 - and then move it down here.
252:17 - So now in the case of post
252:19 - or delete, it will automatically
252:25 - redirect back to the index
page as a 303 redirect.
252:30 - So now there's one more thing we need
252:32 - to do to satisfy the
REST API specification,
252:36 - and that is when we do a post request.
252:40 - When we add an item,
252:43 - the return value of that API call
252:46 - has to be the newly created item.
252:49 - So after we do a todos.push
and add it to our array,
252:55 - we need to set the body
equals to that new todo-item.
253:01 - And the status code is 201,
253:04 - which is the HTTP created status code.
253:11 - That is basically a good point
to go back and see if that
253:16 - if statement here worked and
let's have a look at that.
253:20 - So we add an item and when we
click on the delete button,
253:27 - it reloaded the page and
the item disappeared.
253:33 - This is basically all we need
253:37 - in order for the delete
endpoint to work at the moment.
253:42 - So we did a lot of changes.
253:44 - I think it's a good point
in time to commit that
253:48 - because if we look at the
issue and we were working on,
253:53 - the delete endpoint is now implemented,
253:57 - so let's go have a look at the changes.
254:02 - First of all, we created
a new UID JSON endpoint
254:06 - with our delete request.
254:08 - We consolidated a whole bunch
of code into an API file
254:13 - where we now have a switch statement.
254:17 - And depending on the HTTP method,
254:19 - we process the request
and do certain things.
254:25 - So we returned the elements,
254:27 - or we create a new item in the array,
254:30 - or we delete the item that we
specified in the request URL.
254:37 - And then if it's not a get request,
254:38 - we want to redirect back to
the homepage, so that people
254:44 - don't end up on that empty
page of the endpoint.
254:48 - And in any other case,
254:49 - we just returned status and body.
254:54 - Fantastic, this is a good
place to be at this point.
255:01 - One more thing we want
to quickly review is
255:06 - HTML forms only support
get and post methods.
255:09 - So even though we would
like this to be delete,
255:13 - we worked around it by using
a query parameter _method
255:17 - where we specify what HTTP method
255:20 - we really want it to be.
255:22 - And thanks to the hooks file
in the source directory,
255:26 - we can intercept that request
and overwrite the method
255:31 - based on the query
parameter that we specified.
255:34 - And then our way to
resolve here calls our API
255:38 - and the request method is
now correctly set to delete.
255:44 - Okay, let's go in and make some change,
255:48 - make commit of all of that,
255:50 - push it to our existing pull request
255:55 - and then move on to updating an item.
255:59 - So we see add delete endpoint.
256:07 - And we sync the changes
256:11 - and back to the pull request,
256:14 - we have the delete endpoint here.
256:18 - So here we can close all that again,
256:20 - the environment we don't
need any more, drop that.
256:25 - And with that,
256:26 - we have the issue here and what is left,
256:32 - delete is done, it's
now the patch endpoint,
256:36 - which you can see based on the URL,
256:38 - follows a very similar pattern
256:41 - in order to also implement
that, so let's do this now.
256:47 - We're making great
progress with our issue.
256:50 - We've done three tasks
already, we have one left,
256:54 - which is updating a todo-item.
256:57 - It lifts at the same
URL where we need a UID
257:00 - to specify which item we're updating.
257:03 - And if we look at the
user interface real quick,
257:06 - there are two things we need to implement.
257:09 - One is the checkbox.
257:13 - So marking an item as done
257:16 - as well as somebody can edit a todo-item
257:19 - by clicking on that text
and changing what's in it,
257:22 - and then use the save icon
to persist these changes.
257:28 - We will split that up into two parts.
257:31 - So the first thing is we're
going to work on that editing
257:33 - text, and then we will work on
editing the check mark last.
257:39 - So edit text, let's implement that now.
257:42 - And then we should be in good shape,
257:45 - so develop CRUD endpoints,
257:47 - this is our pull request,
still in draft and we spin up
257:52 - a new developer environment so
we can work on that endpoint.
258:02 - Should be fairly quick, and there we go.
258:12 - Lots of stuff getting
up and running, cool.
258:14 - So why do we want to do is...
258:18 - We don't need this.
258:21 - Over in source, routes, todos,
we created already a file
258:27 - that has a dynamic UID where
we have the delete endpoint.
258:32 - So right next to this, we want
to export the patch endpoint.
258:38 - So that we can update the item,
258:42 - same concept, export const patch,
258:45 - and we use TypeScript
annotation in just a second.
258:52 - For now, we just specify the function.
258:58 - All right.
259:00 - Now, a quick look at the post endpoint.
259:06 - Remember when we get an HTTP
body that is being sent to us.
259:12 - So in the patch request,
259:14 - what will happen is the request
will contain the new text
259:18 - that we want to add.
259:21 - So we need to use the same
annotation as we had here
259:27 - so that our body,
259:30 - we will get the autocomplete
for the get functions
259:35 - based on the FormData
that will be passed to us.
259:37 - So we can copy that from the index file.
259:41 - It's the same concept here
as well for the patch.
259:47 - All right, now, looking
at an index file again.
259:50 - Remember when we have a post endpoint,
259:53 - we create an entire todo-item like this
259:58 - with all the properties that
are required for a todo-item.
260:04 - Now in the case of a patch,
we only get a text property.
260:10 - So all we get is going to
be a request.body get text,
260:16 - so let's have a look what happens.
260:18 - We want to do the same as
with all the other endpoints.
260:22 - So return API, and then we
want to pass in the request,
260:28 - but we don't have a full todo-item.
260:31 - So we want to just pass in a partial item,
260:34 - and in this case, all we
have is a text, so request
260:41 - request, yeah, it's all red at the moment.
260:46 - That's okay, we'll figure
that out in just a sec
260:51 - body get, and then the text.
260:53 - This is the same as we had here.
260:56 - So request body get text
and paste that here.
261:05 - It says it cannot find a
request that's because we need
261:07 - to specify it as a parameter
that we get passed in,
261:11 - same as a delete request.
261:13 - But now it's saying that
it's missing properties.
261:18 - So UID created that.
261:20 - That's because if you recall
the API file over here,
261:25 - it expects a todo-item that is passed in.
261:32 - It is optional, but if
we do pass a parameter,
261:35 - it has to be a complete todo-item.
261:40 - So we have two options.
261:42 - One, just like we specify this parameter
261:46 - to be optional with the question mark,
261:48 - we could go to the global.TS
and make all these optional,
261:54 - but then that kind of defeats
261:56 - the purpose of using TypeScript.
261:59 - So alternative here is that
we just change the type
262:03 - in our API file.
262:05 - And instead of a
todo-item being passed in,
262:09 - we can say that you can
send as an argument,
262:13 - you can pass any record or any object
262:18 - that contains a key value pair.
262:21 - And the way to do that
262:23 - with TypeScript is that we
replace that todo with a record
262:29 - of string and string for the time being.
262:34 - And what that does for us is,
262:39 - so we've got to close this.
262:41 - So we can now pass a
object that contains text,
262:47 - which you say a property and
the string has the value.
262:51 - And with that,
262:53 - this allows us to pass
in a partial todo-item.
262:56 - So now, to be fair, this
is no longer a todo-item.
263:00 - Really, this is more of a data parameter.
263:05 - So to just name that more appropriately,
263:07 - let's change it to data because
it's not a full todo-item.
263:13 - Now, what we have is TypeScript
is now telling us that, Hey,
263:17 - you have an array of
todo-items and you're trying
263:21 - to pass in something
that is not a todo-item.
263:27 - So even if you changed this to
data, which is our new name,
263:31 - it will still complain.
263:33 - Now we know as a fact
that the data we pass
263:39 - in the case of a post request
is indeed a proper todo-item
263:44 - because in our index file, right here,
263:49 - we specify that the object we pass
263:54 - is a proper todo-item.
263:58 - We'll look at that in a second,
but for now what we can do,
264:01 - we can tell TypeScript that, Hey, we are,
264:04 - we are sure, we know what we're doing.
264:06 - So we can say that this is a todo-item
264:10 - where we pass in that data.
264:13 - The reason it's still complaining
is because I said here
264:17 - that we want the record to
be of string and string.
264:22 - But if we look at the todo
definition in our global file,
264:27 - not everything is a
string, some are dates,
264:29 - some are Booleans.
264:31 - So the way to get around that
is we can say that we don't
264:33 - actually know what the value
is, it's unknown at this time.
264:38 - So we can say unknown.
264:40 - And with that TypeScript is now satisfied
264:43 - that here we explicitly
say data is a todo-item.
264:48 - And we can say that with
confidence because in the
264:52 - index file, in our API, we
know we created a todo-item.
264:57 - So with that, we go back
to our patch endpoint,
265:03 - and that now properly creates
this object that just contains
265:09 - the text, which is our new
item that we will create.
265:14 - Good, now, patch request
265:18 - we currently don't have a
handler here in our Svelte,
265:24 - sorry, in our switch statement,
let's change that right now.
265:28 - So what we do is after the delete,
265:31 - we're gonna add a new case
265:35 - for patch and eventually break from it.
265:39 - And the status in this case will be 200
265:46 - once that's all good.
265:49 - But just like we're
here in the delete case,
265:51 - delete an item.
265:52 - We now have to go find
the correct todo-item.
265:58 - So basically we're going
to loop through that array.
266:00 - We look at each item in the array.
266:03 - If we find the item that
has the correct UID,
266:09 - we will update the item's text,
266:12 - and that is some
JavaScript array work here.
266:19 - So todos.map, an individual todo-item
266:22 - we're going to look at,
266:27 - and what we do here is
that if the todo.UID
266:34 - maps to the request
params.UID we get passed in,
266:40 - then let's update that item's text
266:45 - equals the data.text
that is being passed in.
266:49 - And we notice it's a string
266:50 - in that case, because
in our patch request,
266:55 - we set the text property
to a string that we get
266:57 - from the request, so
we can tell TypeScript,
267:00 - Hey, trust me, I know what I'm doing.
267:03 - That data or text is of type string.
267:07 - So that's when we find that
item, we update that todo.
267:12 - And then in all the cases, we
want to return the todo-item
267:19 - from our map, and now at the end of this,
267:23 - we have an updated todos array
that contains the new text.
267:31 - The last thing we need to
do is under lib todo-item,
267:35 - we have our form at the bottom.
267:40 - We already added the delete endpoint.
267:45 - And the patch endpoint, as we know,
267:47 - is in the same URL, just a patch.
267:51 - So the safest thing to do
here is to copy that URL
267:56 - from the delete and move it up here,
268:00 - but it's not a delete
method, it's a patch method,
268:06 - and then again, limitations
in the HTML form
268:09 - is that we have to actually
send the post request,
268:13 - which as you recall,
268:14 - our hooks.JS file will revert or override
268:19 - the request method if that
query parameter is available.
268:23 - All right.
268:25 - One last thing is our input field
268:29 - doesn't have a name attribute yet.
268:32 - And as you see here, we
are using the text value.
268:36 - So let's go to our item and
specify a name equals text.
268:43 - Whatever you put here, it
doesn't have to be text,
268:47 - it could be anything you want,
268:48 - but it has to match what's in our endpoint
268:52 - that we read here.
268:53 - That's the only thing
you need to worry about.
268:56 - All right, let's have a look.
268:59 - Let's do some inspecting
and let's add an item first.
269:06 - Let's also add a second
item and then let's change
269:11 - the text of the first to "first item"
269:16 - and persist that item.
269:22 - Now we have first item, if
we were to reload the page,
269:25 - just to make sure first item
is still here, and with that,
269:29 - we implemented the edit
functionality of a todo-item.
269:35 - That was a lot less work
than the previous time
269:39 - when we had to delete endpoint,
269:41 - because we already reused
a bunch of functionality,
269:45 - like the _method hack we
did to work around some
269:49 - limitations we have with the
method we can use in the form.
269:54 - All right, let's have a quick
look at what's going on.
269:59 - We created a new patch
endpoint right here.
270:06 - What we do is we call the API
and we pass in a new object
270:10 - with just a text property
270:12 - that we read from the request body.
270:17 - The API, instead of expecting a todo-item,
270:20 - it now expects any object in here.
270:24 - And we used a little
bit of TypeScript magic
270:29 - to tell TypeScript that we know
for sure in a post request,
270:33 - we get a todo type data.
270:37 - And then we implemented a patch
270:39 - where we loop through all
the todo-items in the array.
270:42 - If we find the one that has matching UID
270:46 - with the request parameter, we
update the text, from there,
270:50 - we return all the items
and the 200 status code
270:54 - back to the browser.
270:57 - All right, this is all we need for now,
271:00 - so let's commit that,
271:02 - add patch endpoint update text.
271:11 - All right, yes.
271:14 - We're going to push that,
close all our views here.
271:19 - Don't need a developer
environment anymore, and now.
271:33 - I may have just closed
that a little too early.
271:35 - So I'll show you how you can
get your developer environment
271:38 - back, if you go to Gitpod.io/workspaces,
271:42 - and then you can see it here.
271:45 - That's the one that was 14 minutes ago.
271:50 - Yeah, it has unpushed commits,
271:52 - so I shut that down just
a little bit too early,
271:56 - not a big deal, we can
click the dots here,
271:58 - we can open that environment back up,
272:02 - and that is just going to take a second
272:06 - and give us our environment back.
272:11 - So as I mentioned, this is, you know,
272:13 - if you have enough patience and wait
272:17 - for the push to complete
and you don't have
272:20 - to do that, but since I
didn't wait long enough,
272:24 - we can just come back here
272:28 - and switch over here and then
click that sync changes again
272:32 - and wait until it gets properly pushed.
272:35 - There we go.
272:36 - And now we can go ahead
and shut that down again.
272:39 - So good lesson,
272:41 - if you do need to get an environment back
272:44 - for whatever reason, GitPod.IO/workspaces,
272:48 - and you will get access to this.
272:52 - Alrighty, with that in
place, we have one more patch
272:56 - to implement that is to
make the checkbox work.
273:01 - And then once we do that,
we are feature complete
273:05 - in terms of the API, we
can then add, read, update,
273:11 - and delete todo-items.
273:13 - Let's go build that
last piece and then have
273:17 - that application feature
complete in terms of the API.
273:25 - All right, let's move on,
273:27 - go and start a new workspace
273:31 - and then build that edit feature for the
273:35 - marking an item is done
part of the application.
273:39 - This one should be straightforward
because we already built
273:43 - an edit feature for the
text of a todo-item.
273:48 - So we can leverage that exact same code
273:53 - that we have in place already.
273:56 - Let's go have a look at how this works.
273:59 - All right.
274:00 - So starting out with the endpoint,
274:05 - we go to source, routes, todos
and the [UID].JSON.TS file.
274:12 - Now,
274:16 - at the moment, we only
deal with a text property
274:23 - that is being passed in by the web app.
274:28 - So if we add one here real
quick, when we edit this text
274:34 - and we submit it, then that
body has a text property.
274:40 - What happens though,
274:41 - when we click this button
and we submit a form
274:46 - to the same endpoint as
the edit endpoint here?
274:51 - So let's have a look in
source lib todo-item.Svelte.
274:55 - If we scroll down to the HTML,
275:01 - we have this input field
where we have a name done
275:09 - and the value doesn't exist at the moment.
275:13 - So the value we want to put in here is
275:19 - either nothing or true if we
want to mark an item as done.
275:27 - So let's have a look.
275:30 - Basically we can use the
curly brackets to access
275:37 - the todo item, and let's
do this first, todo.done.
275:44 - So if the item we are rendering
275:49 - is marked as done, then if
somebody clicks on the circle,
275:56 - the value we want to
set in this field here
276:01 - is an empty string.
276:03 - Otherwise we want to
add the value of true.
276:08 - So that then basically just toggles
276:09 - between true and an empty string,
276:12 - depending on whether the
item is toggled or not.
276:16 - Now with that, we also can
update that aria label here,
276:22 - because now we know whether
the item is done or not.
276:26 - So let's do that, so we
can say mark todo as,
276:35 - and then the string
here depends on whether
276:39 - the item is done or not, so if it's done,
276:42 - then we want to say not
done and otherwise done.
276:50 - So now this says that,
if the todo-item is done,
276:53 - then mark todo as not done, so flip it.
276:57 - Otherwise we mark it as done.
277:00 - Alrighty.
277:05 - In order to test that, we need to go back
277:07 - to our source, routes,
todos [UID].JSON.TS.
277:12 - And now because we have
a name equals done,
277:17 - we get an additional
parameter here potentially.
277:21 - So let's go in and also
specify the done property.
277:27 - And what we want to do is
277:29 - if the request body
contains that done value,
277:37 - then we want to make a
Boolean value out of it,
277:40 - so request.body get the done.
277:45 - And if we don't have the
done property available,
277:51 - then we just say undefined, all right,
277:55 - let's go have a look at the API
as well, so in our API file,
278:01 - _API in the patch section.
278:06 - Up to this point, we only
deal with the text value,
278:12 - but now we also have a
potential done value.
278:15 - So they will never be
set at the same time,
278:19 - it's either text or done
that will be available
278:22 - depending on whether we clicked the button
278:26 - on the left or whether
we updated the text.
278:29 - So we can deal with that
278:30 - in our API by just simply checking here.
278:34 - If the data dot text is available,
then we want to set that.
278:42 - And the other thing we want to check is
278:44 - that else, we can say we're
dealing with the done property
278:50 - so we can see data.done,
and we know this a Boolean,
278:54 - because we set it to a
Boolean or undefined.
278:59 - Now, if there were more
features or properties,
279:02 - then we could refactor that
slightly to make it more
279:06 - readable, but this does the
trick for the time being.
279:11 - And we can, you know, use
that as a good starting point.
279:16 - Going back to the
todo-item Svelte component,
279:21 - we need to provide the
action and the method.
279:26 - Now that's the exact same as
for the editing text, right,
279:30 - we are going to the same
endpoint so we can copy that
279:35 - URL action from here, paste it,
279:38 - and the method as always is post.
279:43 - And with that, let's have a
look at the user interface.
279:49 - Let's inspect, get the console back
279:53 - in case there's something
interesting there.
279:56 - So first we set that, let's
add a second one as well.
280:03 - Nice.
280:04 - Now let's check the second
one, mark this as done,
280:10 - and it didn't update the user interface.
280:13 - Hmm, why would that be?
280:15 - Let's see if we reload.
280:18 - Same thing, now, the reason for that is,
280:22 - remember when we styled
the web application,
280:26 - we commented out some of the work
280:29 - because we didn't have a
way to mark an item as done.
280:33 - So now remember here that
CSS, we set that a uncomment
280:38 - when the API endpoints out available.
280:42 - Now guess what, the NPI
endpoint are now available.
280:45 - So we now have a way to
say whether this todo-item
280:49 - is done or not, remember
the todo.done property,
280:55 - we have access to whether
an item is done or not.
281:00 - So let's first uncomment that code.
281:07 - Svelte immediately tells us that
281:09 - these are unused CSS
selectors, both of them.
281:12 - And that's because we need to dynamically
281:17 - add the done value here.
281:19 - So we could use the same
concept where we say todo, done,
281:24 - then at that, otherwise
don't add a class name.
281:29 - Now let's have a look, and just like that,
281:33 - the second item is now checked.
281:35 - And visually you can see
it is marked as done.
281:40 - If we uncheck it, it works,
281:43 - we can check this one,
uncheck, perfectly valid,
281:47 - but oh-my-God is this convoluted,
281:49 - look at all this code to
specify whether this item
281:55 - should have that class name or not.
281:57 - It seems to me like this
is a lot of code that
282:02 - it's also very fragile because
there's an empty string.
282:06 - There's a done here.
282:08 - So let's have a look at
what Svelte provides us
282:12 - to make this a little
bit more maintainable.
282:15 - Instead of doing some string
manipulations right here
282:18 - within the class attribute,
we can use a second attribute,
282:24 - which is a class and then colon.
282:28 - Now, what we add here,
282:30 - after the colon is the name of the class
282:34 - we want to add conditionally
282:36 - in our case, this is done value.
282:40 - And in order to specify whether or not
282:46 - we want to set that class,
we can use equals todo.done.
282:51 - Now Svelte conditionally adds or removes
282:54 - that class from that element depending on
282:57 - whether the value in the
curly brackets is true.
283:01 - Just to make sure this works,
let's go back and add an item.
283:09 - There we go, well, okay,
283:11 - it reloaded from the
server, so it's all good.
283:13 - We can drop it.
283:17 - All right, that works.
283:20 - If we had a variable in our script
283:27 - at the top that is called done,
283:30 - then we could drop that
entire part here as well..
283:35 - We don't have one called done,
283:36 - but if I were to go up here in the script
283:40 - and I would say, const done equals
283:48 - todo.done, and we now can do that.
283:55 - So if the variable exists
283:58 - that has the same name as the
class name we want to add,
284:02 - we can just say class and the name,
284:04 - and then Svelte will
automatically toggle that.
284:07 - Now I think this is one way to do it,
284:10 - I don't think it's necessary in this case,
284:11 - there's a lot of good use cases for that.
284:14 - In our case, I think this is fine enough
284:17 - to just read from the
todo object directly.
284:21 - But that gives us basically
the user interface
284:28 - where we can add items,
we can mark them as done.
284:32 - We can remove them all by
284:37 - using the user interface.
284:39 - Now I showed it once before.
284:41 - I think it's worth mentioning again,
284:43 - to just remind you, if we
go to the developer settings
284:48 - and we go to debugger
and disabled JavaScript,
284:53 - that website, I can reload
it just to make sure,
284:59 - I can still go ahead
and work with that API
285:04 - and the website exactly the
same way as we've always done.
285:10 - So there's no JavaScript
whatsoever being used right now
285:14 - to make this web application work.
285:17 - And this is something that I
think has been forgotten a bit
285:22 - recently that the web could
easily work without JavaScript.
285:27 - And it used to for a matter
of fact, many years ago.
285:30 - So I think it's very important
to keep that in mind,
285:33 - there is a lot of people
that have low powered devices
285:37 - to access the internet and
JavaScript is making this hard
285:43 - and slow for many people in the world.
285:46 - So if we do want to provide
285:49 - a slightly better user experience
285:53 - for people that have JavaScript enabled,
285:56 - then we can do that.
285:59 - We can enhance this application so that
286:02 - if JavaScript is available,
we are able to leverage it.
286:06 - And instead of, you know,
doing a full page refresh,
286:09 - if I delete an item,
that does a redirect back
286:13 - to the homepage and reloads
the entire page, all this code,
286:18 - we can speed that up
and we'll do that next.
286:21 - But for now, let's close this preview,
286:25 - have a quick look at what
we've changed in our code.
286:30 - First of all, we added a new done property
286:34 - when we call the API.
286:36 - The API is extended so
that our patch can deal
286:42 - with text and todo
286:46 - done text and done properties.
286:50 - And lastly, we have
286:55 - the todo-item updated where
we could finally uncomment
286:58 - our CSS when a item is
called, I will mark this done.
287:05 - And we then learned how we
can add a class dynamically
287:10 - to an item or an element here,
287:12 - depending on whether
an item is done or not.
287:16 - Alright, this is a good
place to commit all that.
287:20 - So we call this add the patch endpoint
287:28 - and the value for it is
mark as done, for example.
287:35 - Okay now sync the changes.
287:39 - Make sure you wait until that's all done.
287:43 - And we have that available here.
287:49 - So now it's a safe time to
shut down our workspace.
287:55 - That'll disappear, and
287:58 - with that, we can also
go back to our issue
288:02 - and we have that patch implemented.
288:07 - With that, our pull request
is no longer in draft,
288:10 - ready for review.
288:12 - Somebody on our team can
help us review the changes.
288:17 - And then we can go ahead
288:19 - and merge that PR, delete the branch.
288:24 - So with that, we have
fully functioning API
288:29 - ready to go, and the
application is nice and working.
288:32 - So we're going to look
at a few more things now
288:36 - and make good progress
throughout the course.
288:39 - So stay tuned, more to come.
288:43 - Okay, what do we want to do now
288:45 - is leverage a feature from Svelte
288:48 - called actions in order
to enhance the HTML forms
288:53 - for visitors of our application
288:56 - that have JavaScript enabled.
288:59 - So we've got a new issue
called enhanced HTML forms.
289:03 - We start a new Gitpod workspace
for that specific task.
289:07 - And what we're going to do
now is basically find all the
289:12 - HTML forms that we have and
use this new Svelte action
289:18 - that we are going to
create that will help us
289:23 - to make an AJAX request
instead of a full page refresh.
289:28 - I'll show you what I mean by that.
289:30 - If we come here and we add a
new item currently by hitting
289:34 - enter here, you remember
it reloads the entire page.
289:38 - It adds the item, and then
redirect back to the homepage,
289:42 - which means it downloads
all the CSS, the HTML,
289:46 - and all the code.
289:48 - We really want to just
make an AJAX request
289:52 - to the endpoint, add the
item to our array in the API,
289:58 - and then update the UI accordingly.
290:02 - So the way we can do that
is by using Svelte actions.
290:08 - And Svelte actions are very powerful tool.
290:12 - Well-documented at Svelte.dev
but I'll walk you through
290:17 - and teach you everything you need to know.
290:21 - The first thing we want to
do is create a new action
290:26 - and an action is really just a function.
290:28 - So I like to have them
290:29 - under source lib, and then
in the actions directory,
290:34 - and in our case, we're
going to call it form.TS.
290:40 - So in here we just have
to export a function
290:44 - and the name of that function
290:46 - will become the name of our action.
290:49 - So export const, let's call this enhance
290:53 - because we will enhance the HTML form
290:55 - with additional functionality
290:59 - in case JavaScript is enabled.
291:03 - So it's a function and
that's basically it.
291:09 - Now with actions,
291:11 - there is a parameter being
passed to us by Svelte
291:16 - that represents the HTML element
that we use the action on.
291:24 - So in our case,
291:25 - we will use that enhance
action for HTML forms.
291:29 - So Svelte automatically passes us a form.
291:33 - And with TypeScript, we know
this is an HTML form element,
291:41 - and this is passed into
us into this action.
291:45 - So before we go any further,
let's see how we can use
291:49 - that in the code of our Svelte component,
291:53 - we copy the name and we
go to source roots index.
291:59 - And here in the top,
292:02 - we want to first import our new function
292:05 - or action, same thing.
292:07 - So import enhance from,
292:14 - and remember the shortcut
to go to a source lib.
292:20 - We can use the dollar sign lib slash,
292:24 - now we can see our new actions directory,
292:27 - and within that, the form file.
292:32 - Alrighty, with that we can go down
292:36 - and we'll start by enhancing the form
292:39 - to create a new todo-item.
292:43 - So we can use an action by saying use,
292:47 - and then the name of our action.
292:51 - As I mentioned Svelte provides a reference
292:54 - to the element we use the action on.
292:56 - So this is on the form element
and that's why the parameter
293:00 - we get is a form
parameter into our action.
293:06 - So let me show you what happens.
293:08 - Before we go any further,
293:09 - let's just do console log
action executed for example.
293:18 - If we switch to the UI
and we clear the console
293:24 - and we reload that page.
293:28 - You can see that
293:30 - as soon as the HTML form
gets mounted to the DOM,
293:35 - we can see that the action got executed.
293:39 - Okay, so now this means at that point,
293:43 - we can start to interact with
the form using JavaScript
293:48 - in our action to intercept
the submit request.
293:54 - And then instead of
doing a full page reload,
293:57 - we can just send an Ajax
request before we get there.
294:01 - I'm going to show you one more thing
294:02 - that is extremely important to
know when you build actions.
294:08 - And in order to do that,
294:10 - I'm going to rename that
text form mounted to DOM.
294:16 - Now, anything you do
294:18 - in the enhance function
here or in your action,
294:23 - keep in mind that this
action gets executed
294:27 - every time the HTML element
gets added to the DOM.
294:32 - So if we navigate from one page
to another and we come back,
294:36 - that enhanced function is called again.
294:39 - Let me demonstrate that
294:40 - so that we can then see a few things.
294:44 - I'm going to under source routes,
294:45 - I create a new file
called about-us.Svelte.
294:49 - And for now this just contains
an H1 element, about us,
294:55 - and a link that brings us back
to the homepage like that.
295:01 - And that will just move us back.
295:05 - On the index page itself under the title,
295:10 - I'm adding an anchor that
brings us to about us
295:13 - so we can navigate between
the two pages easily.
295:18 - All right, do that, clear things.
295:22 - We reload the page
295:25 - and you can see that the
form is mounted to the DOM.
295:29 - And now, oh there we go,
295:32 - had to refresh, hot module
reloading kicked in.
295:37 - So it got mounted to the DOM.
295:38 - And now if we click the about
us, we load the about us page,
295:43 - and if we go back,
295:46 - you can see that the form
mounted to DOM appears again.
295:51 - This is extremely important to know,
295:53 - because anything we do in our action
295:59 - happens every time the HTML
element gets added to the DOM.
296:04 - So navigating between back and forth,
296:05 - we have to somehow clean up
everything we do in here.
296:09 - For example if we were to add
296:11 - an event listener or create something
296:14 - in memory or whatever,
we'll have to clean that up
296:18 - when the HTML form gets
removed from the DOM.
296:22 - So when we navigate away from the page or
296:25 - the element gets removed from
the DOM, for any other reason.
296:30 - To do that, the convention
is that we can return
296:32 - an object from our action that
contains a destroy function.
296:39 - And in that destroy function, we can
296:45 - print form removed from DOM.
296:51 - And now if we have a look at the console,
296:59 - when we load the page,
297:02 - you can see the form, mounted to the DOM.
297:05 - When we navigate away, the
form was removed from the DOM.
297:09 - And then when we come back,
the form is mounted again.
297:14 - So anything we do in the action,
297:17 - it is very important that we
undo, you know, in air quotes,
297:22 - everything we did so that
we have no memory leaks,
297:25 - and we don't accidentally add
multiple like event listeners.
297:30 - And then all of a sudden our
code executes multiple times,
297:33 - things like that.
297:35 - So with that knowledge in mind,
297:37 - let's have a look at
what we really want to do
297:40 - in order to make the user
experience a bit better
297:45 - for people with JavaScript enabled.
297:48 - When somebody actually,
before we do that, hold on,
297:52 - let's clean this up, we
don't need the about us page.
297:57 - And in our index file, we
no longer need the link.
298:00 - We've proven that this does
what it's supposed to do.
298:06 - So now when somebody submits this form,
298:11 - we currently send,
298:14 - or we let the browser
send an HTTP post request
298:17 - to the endpoint that we
specified in the form here.
298:22 - And then that redirects us back.
298:25 - So what we really want to do
is we don't want the browser
298:28 - to take care of that.
298:29 - If JavaScript is enabled, we
want to tell the browser, Hey,
298:33 - thank you for your service,
298:34 - but we don't really need your help here.
298:36 - We can take care of sending
the content of this text field,
298:42 - to the API, process the API response,
298:46 - and then we'll update UI automatically.
298:49 - So we don't need to
reload the entire page.
298:52 - The way we do that is in our action,
298:55 - under source, lib, actions, form,
298:59 - we have access to the HTML form.
299:03 - So what we can do is we're
going to drop these console logs
299:07 - because we know they do
what they're supposed to do.
299:12 - So here we can say form.addEventListener,
299:17 - and we can listen to
the form's submit event.
299:25 - That's when the browser usually kicks in
299:27 - and does its post request to the API,
299:31 - and we need to give it a function
or a listener that will be
299:36 - executed when that event
happens, so let's call this
299:40 - handleSubmit, and then let's
create a function here,
299:48 - handleSubmit, and
299:54 - as I said, anything we do in our action,
299:58 - we have to undo it in
the destroy function.
300:01 - So when we move away to another
page, we want to say form
300:06 - removeEventListener, submit,
300:11 - and the event listener we want to remove
300:13 - is our handleSubmit function.
300:15 - So with that,
300:17 - we have the basic structure
in place of our action,
300:22 - where we add event listener, when the DOM,
300:26 - the element, it gets added
to the DOM and we remove it
300:29 - when the element gets
removed from the DOM.
300:33 - So what do we want to do
when a form gets submitted?
300:40 - The very first thing is we
want to tell the browser
300:43 - to not do the default behavior.
300:47 - As I said, the default behavior
is to send a post request
300:49 - to the endpoint that is
specified in the HTML.
300:53 - So in this case,
300:55 - send in a post request to
that todos item endpoint.
301:01 - Let's not do that.
301:02 - Now, because this is a regular
event listener that we added,
301:07 - we get a parameter passed in
here, which is called an event.
301:11 - And that's just of type event
301:13 - if we wanted to use TypeScript here.
301:16 - And on that event,
301:18 - we have a function that's
called prevent default
301:25 - that tells the browser, Hey,
301:27 - don't do your default behavior.
301:30 - I will take care of it.
301:32 - So let's see what that
does to our user interface.
301:36 - Clear out, network, clear.
301:40 - Alright, we add a second
item and we submit,
301:47 - I think that did not load,
let's try it one more time.
301:50 - Clear, add a third item and submit it.
301:57 - If you hit enter, nothing happens.
302:01 - And that's exactly what we want.
302:02 - And that's also what we
said, don't do anything.
302:05 - However because we told the browser
302:07 - not to do its default behavior,
302:10 - it is now up to us to make this
HTTP request to the backend.
302:17 - So let's have a look.
302:19 - Whenever we deal with an HTTP request,
302:21 - it's probably a good idea
to wrap it up in a try-catch
302:24 - because things could go wrong,
the API could be unavailable.
302:27 - There could be any other
errors that may occur.
302:33 - So if that happens, if we do
get an error for some reason,
302:37 - let's just say console.error
for the time being
302:42 - fetch error and eventually
specify what is wrong.
302:48 - We'll do that in a second.
302:50 - Okay.
302:52 - How do we make an HTTP
request from a website?
302:57 - Well, the solution to that is using fetch
303:02 - and we have to go to some
kind of endpoint here
303:09 - endpoint, alright, now
fetch is asynchronous,
303:12 - so we have to await it and
we will then get a response.
303:18 - Since we use now await,
303:19 - we have to make the handler
asynchronous, we'll do async.
303:24 - All right.
303:27 - We'll figure it out, that
endpoint in just a second.
303:30 - But for now, we now have a response that
303:35 - if something does go wrong,
303:37 - then we can do something with it.
303:42 - So the let's change this here
to could not submit the form.
303:50 - And the error we get is
whatever error we have.
303:56 - All right, first things first,
303:59 - how do we figure out what's
the endpoint of our form?
304:04 - If we look at the index file, the endpoint
304:08 - we want to use this value
within the action property.
304:12 - Remember that our action we
are defining here is generic
304:17 - so that we can use it for
any form on the application.
304:22 - We don't want this to be very
specific to just one form.
304:26 - And the good thing is that if
we look at the form elements
304:31 - that we defined under
source lib todo-item,
304:36 - and we go down all these forms,
304:41 - they specify the action attribute
304:43 - that we want to use for our HTTP request.
304:47 - So the good news here is that
we do get a form passed in
304:50 - as an attribute here, or as a parameter.
304:55 - So let's have a look.
304:57 - What if we look at
what's inside that form,
305:02 - do we have, ah, we have
the action property.
305:08 - Okay, that's exactly what we want.
305:10 - We want to use that action
as the URL for our request.
305:14 - So this is a good start, now,
305:18 - if we don't specify any more
parameters for the fetch call,
305:21 - then the default request
method would be get.
305:26 - But as you know, we want
this to be post like here,
305:32 - so we can just like access
the action attribute,
305:36 - we can access the method as well.
305:38 - So we can pass in a second
argument to the fetch function
305:43 - and we call this method and the
value is whatever we specify
305:47 - in the form method attribute.
305:52 - Alrighty, there's one
more thing we need to do.
305:55 - So in the case of creating a todo-item
306:01 - or updating an item, we
need to send the fields,
306:06 - the input fields that we
specify within the form.
306:09 - And in order to do that,
306:12 - we can leverage a pretty nifty feature.
306:17 - So let's specify,
306:20 - let's say a body and
the way we can do this,
306:24 - we can use new FormData, pass in the form.
306:31 - Does this look familiar, FormData?
306:34 - In fact, I still have it open as a tab.
306:36 - We looked at that earlier on
the Mozilla developer page.
306:40 - And if we switch over to the roots todos,
306:44 - the UID or the index, so index.post here,
306:50 - remember we specified the FormData
306:53 - that is being sent as a body.
306:55 - This is exactly what we're doing here.
306:57 - We create the body as a new
instance of the FormData.
307:02 - And now in our request,
307:05 - we can specify a body attribute.
307:10 - And since it's the same
as the variable name,
307:13 - we can just leave it like
that instead of doing this
307:17 - short form is just using body.
307:20 - So now we are sending a request
307:24 - to the action with the
correct method and the body,
307:28 - but there's one more thing we can do
307:31 - that is, we can specify
307:37 - that we accept a JSON response.
307:41 - So let's have a look, we
can pass in headers as well.
307:46 - So headers, and what
do we say here is, Hey,
307:52 - we accept application/JSON,
307:59 - and this will come in handy
in just a second and I'll show
308:01 - you why, for now, let's just,
you know, make this request,
308:07 - we get a response, and then we want
308:09 - to do something with that response.
308:11 - So let's go here and say
that if the response is ok,
308:17 - then we want to console log API response.
308:28 - And for the time being, we just say await.
308:35 - So what is happening here?
308:38 - We basically just pick the
JSON response that we get
308:41 - from the server and what just
print it into the console.
308:47 - If something goes wrong, let's say else,
308:52 - we want console error, fetch error.
308:58 - And we will just take whatever
the response text attribute
309:03 - is like, if something happened there,
309:06 - then the response will
contain some information
309:09 - of what went wrong.
309:10 - And we can leverage that
309:12 - to display an error message
in the console for now.
309:18 - Okay, so we did a lot of stuff here.
309:23 - Now, what do we want to go check is
309:28 - what happens when we submit that request.
309:31 - Let's go back here and
let's reload the page.
309:38 - Clear all that.
309:40 - Let's go and create a third
item, and we submit it.
309:46 - Interesting, look at that.
309:49 - First of all, it didn't do any
redirect, which is, you know,
309:53 - kind of good news, however,
it tried to, see this?
310:01 - So a post request 303
is the response code.
310:07 - And it tried to redirect
back to that index page.
310:10 - So why is that, well, because
we configured it that way,
310:15 - obviously, there's a POST request.
310:17 - And if we go to our API
source routes todos API,
310:24 - you recall that we say that if
the request method is not get
310:30 - then redirect to the index
page, ha that's a problem.
310:37 - We only want to do that redirect
310:39 - when the browser submits
the form on its own,
310:44 - so when JavaScript is disabled.
310:47 - If JavaScript is enabled
and we submit the form
310:53 - through our action right
here, in that case,
310:56 - we don't want to do a redirect
and instead we just want
311:00 - to return the response
and then we parse it here
311:05 - and we print the value, right?
311:07 - All right so let's have a look
311:09 - at how we can go about that and make sure
311:12 - we can differentiate whether
the browser submitted
311:16 - the request or whether we did.
311:20 - Now, I already did a little
bit of work here upfront.
311:22 - I added a new header that
says accept application/json.
311:28 - The browser doesn't do that
when it submits the form,
311:32 - the value for that is
different in that case.
311:36 - But because we are
specifying application/json
311:40 - by ourselves, when JavaScript is enabled,
311:42 - we can leverage that in our
API file and enhance our
311:47 - if statement so that we are not
only looking for the request
311:52 - method, but it also checking
the header that we specified.
311:58 - So here we say and request headers accept,
312:05 - that's the one we specified
312:08 - is not equals to application/json.
312:14 - Probably a good time to move
that to a new line, okay,
312:20 - with that, we now have the check
312:25 - so they shouldn't do a redirect anymore
312:27 - when we sent the request,
let's see if that's the case.
312:31 - Because we changed our API
file, the server reloaded,
312:36 - and it cleared our items.
312:38 - That's okay, we'll just add them again.
312:41 - So we add a first,
312:44 - that, okay, hang on, let's
clear this, it will be easier.
312:47 - We'll do that again.
312:49 - We'll add a second.
312:54 - And now look at that,
we only have one request
312:59 - and if we move things around here a bit,
313:06 - you can see it's a post
request, the status code is 201,
313:11 - and you can see that the
payload was text second,
313:15 - that's what we created.
313:17 - And the response that we
got back from the server
313:23 - is a full todo-item,
including the created at,
313:27 - the UID, the text, done false.
313:30 - This is fascinating, this
is all we really need.
313:34 - And in fact, all we need to do now is
313:37 - update the user interface
to make sure we showed
313:41 - that item in the UI.
313:44 - At the moment, if I were
to refresh the page,
313:47 - you can see that our two items are here.
313:49 - That's because the GET request
313:51 - fetches everything from
the server and displays it.
313:54 - But we want to do that dynamically.
313:57 - And the way we can do that
313:58 - is because we're dealing with JavaScript,
314:01 - we also can modify that list
314:04 - and do so in a pretty dynamic way.
314:08 - Let's look at how we do that.
314:15 - At the moment, when we
have a successful result,
314:19 - we just print API response
out to the console.
314:23 - So if we look at that,
314:27 - I disappeared because I reloaded the page.
314:29 - We can do it again, if I add a third item,
314:32 - we can see the API response here.
314:35 - Now let's take that information
314:38 - and update the user interface.
314:42 - And the way we do that is,
instead of just printing,
314:47 - we have to update the user
interface in the index file.
314:53 - Let's have a look.
314:57 - In the index file, we
have that enhance action.
315:01 - So somehow when the request
is made to the server
315:08 - from our action, and we
get the response back,
315:11 - at this point right here,
315:13 - we need to update the user interface here.
315:18 - So the number of todos
that we have in this array,
315:21 - we need to push in our new item
315:23 - that the server sent back to us.
315:26 - With that, we can then
let Svelte to do the rest
315:30 - of the matching and
just rerender that array
315:33 - and display a new todo-item.
315:35 - But how do we access that
array that we get in as a prop?
315:44 - There's some good news.
315:46 - And the good news is that we
can pass additional parameters
315:52 - to our action.
315:53 - The form is given to us by Svelte,
315:55 - but we can add our own parameters as well.
316:00 - And that's exactly what
we're going to do, so
316:06 - in order to make this more
flexible going forward,
316:09 - let's add an object as
an additional parameter.
316:13 - And what we will pass in is a function
316:16 - that we named result.
316:21 - Why do we do that?
316:22 - Because this enhanced action will be used
316:25 - across multiple forms.
316:27 - The behavior of the success
case is going to be different.
316:32 - When we add an item, we
want to add it to a list.
316:34 - When we edit it, we
want to update an item.
316:38 - And when we delete a todo-item,
316:40 - we want to remove it
from our list in the UI.
316:43 - So because of that,
316:45 - we basically pass in that function,
316:47 - again, you could call
it whatever you want,
316:50 - but then instead of printing that text,
316:55 - what did we will do is
316:59 - we will call that result function here,
317:03 - and we will pass the response.
317:08 - We could pass the todo object or whatever.
317:12 - The fact that I'm passing
response allows us
317:16 - to be more flexible in the user interface,
317:19 - where we could read values
from the response such as
317:22 - the status or things like
that, if we wanted to, you know
317:27 - react to that in certain ways.
317:30 - This is, you know, up
to you how much you want
317:32 - to pass through here, in our case,
317:35 - we'll pass the response
and let the user interface
317:38 - deal with whatever it
wants to do with that.
317:41 - So that's good.
317:43 - Now, how do we get access to that?
317:48 - How can we pass that result in here?
317:51 - Very straightforward,
TypeScript already tells us that
317:55 - it expects two arguments,
but it got only one.
317:59 - So we're missing that object
with the result function.
318:03 - So here's how we can do that.
318:04 - Similar to how we defined
the conditional class.
318:08 - Previously, we can say, use:enhance,
318:10 - and then equals JavaScript,
318:16 - and then the object here.
318:20 - So what's going on,
318:22 - the inner brackets represent
the second parameter here.
318:30 - So that part, and the outer brackets,
318:35 - they are there just like
we used them down here
318:40 - to tell Svelte that we are
doing some dynamic work here.
318:43 - All right, so now what
we need to pass in here
318:46 - if we do control space, it
expects a result property.
318:51 - So let's do a new line result.
318:54 - And the result
318:57 - is a function we are going
to specify in our script
319:02 - where we push an item
into due todos array.
319:05 - So let's have a look.
319:06 - We'll just call that for
now, processNewToDoResult.
319:16 - And then let's go define
that function up here.
319:20 - So const equals, let's
make a function first,
319:26 - and then as you remember
from the enhance action,
319:32 - we call the result with an
argument called response.
319:39 - So that means that in our
index file, oops, sorry,
319:45 - process new todo result,
we get a response.
319:50 - Pass in parameter.
319:53 - We can use TypeScript to
specify what type that is.
319:58 - And what do we want to do here now is
320:03 - read the item that is
being sent back to us,
320:06 - just like we printed
it to the console here.
320:10 - We can use that await res JSON, grab it,
320:14 - make sure we remove that line
because you can only call
320:17 - that JSON function once on a response.
320:20 - So remove that.
320:22 - And in here, we can now
say const new todo equals
320:32 - await response JSON.
320:34 - And we have to mark this
320:37 - as an async function
because we're awaiting.
320:40 - Now, this is an object that
contains everything we need
320:44 - to know about the new todo-item.
320:46 - We saw that in the console
previously with the UID,
320:49 - created at, all that information.
320:53 - Excellent, now all that's
left to do is update the,
320:57 - todos array inject that new object.
321:02 - So you would be inclined
321:03 - to likely do, todos push new todo.
321:09 - Now in Svelte, that doesn't
quite work because in order
321:13 - for Reactivity to kick in,
and Svelte to rerender that
321:17 - todos array, what do we have
to do is reassign the array
321:21 - of that variable, which is not a big deal.
321:23 - We can change the code
here and say todos equals
321:29 - a new array with the old todo-items
321:33 - plus the new todo-item appended to it.
321:37 - And with that, we can now go
back to the user interface
321:43 - and reload that page, there
was a lot of code going on.
321:47 - And first, second, third,
321:50 - let's go clear some things
and add our fourth item.
321:55 - We hit enter, and you can see
one request to the backend.
322:01 - The fourth item shows up instantly
322:04 - in the UI, but it didn't
clear out our input field,
322:09 - that's a bit annoying.
322:11 - The user experience here is not great,
322:13 - so we can easily fix that back here
322:19 - at the end, once we updated
the list, it would be great
322:23 - if we could clear that form
322:27 - and reset it to its default values,
322:30 - which would be an empty
string for the input field.
322:36 - So luckily in our action,
where we call the result,
322:39 - we also have access to the
form that we are using.
322:43 - So we can just pass that in as a prop
322:46 - as a argument here, form.
322:50 - And then in the index file
where we have our function,
322:56 - we now also get a form which
is of type HTML form element
323:04 - with that, we can now say form.reset,
323:10 - and that will clear the form
back to its default values.
323:15 - Let's have a look.
323:17 - First of all, let's
delete a few things here.
323:22 - All right, clear that.
323:24 - So we'll add our third
item and we hit enter.
323:27 - It gets added and the form
gets immediately reset.
323:33 - Okay, this is a very nice, one request,
323:39 - if JavaScript is enabled,
323:41 - if we go here to the developer settings
323:44 - we disable JavaScript and
we were to add a fourth item
323:51 - and submit that form,
323:54 - you can see that now
the submission happened
323:58 - by the browser and it used
the 303 redirect to come back,
324:02 - but the functionality still works
324:05 - even if JavaScript is disabled
324:08 - we used that before, we saw it.
324:10 - But if it's enabled,
324:11 - we get that nice little performance boost
324:15 - by just sending a single request
324:17 - and then use JavaScript to
perform the addition to the UI.
324:23 - Nice.
324:25 - So we created the functionality
324:29 - to add a todo-item and
we have a very generic
324:36 - form action that we call enhance.
324:40 - Now let's go ahead and add
324:42 - that enhance function to
all our other forms as well.
324:46 - So marking an items done,
editing and deleting.
324:54 - The way we do that
324:55 - is we switch to the todo-item component,
324:59 - and at the top we import the action.
325:03 - So we can go to the index
file and grab it from here.
325:09 - Now, even though the index
file and the todo-item
325:14 - are in different places
in the file system,
325:17 - thanks to the $lib,
325:18 - we can just copy paste that import.
325:25 - And now we have our enhance function here.
325:29 - So the first thing we
want to do is let's start
325:31 - on the right side and do the
delete action, first, go down.
325:38 - This is our delete form
325:41 - with the delete todo functionality.
325:45 - So over here, use, enhance
and pass in a result.
325:57 - And then we call this, let's say, process,
326:04 - the deleted todo result.
326:10 - And we go and define that
function up in the script.
326:17 - So now we have a challenge,
326:20 - in order to delete that todo-item
326:24 - once it's removed from the server,
326:26 - that function will be called
326:28 - by our action, but we
don't really have access
326:34 - to the array of todo-items
326:36 - so that we can remove it from that array.
326:39 - The only thing we have access to
326:40 - is that item that no longer exists.
326:44 - So we have to find a way
326:47 - to access the todos
array in our index page,
326:53 - just like with the adding a new item,
326:55 - we can get the existing
items and add a new one.
326:59 - We need access to deleting
an element from this array.
327:06 - The good news is with Svelte
and Svelte components,
327:11 - we can just use a prop the same way that
327:16 - we pass in the todo-item.
327:19 - We can also expect a prop to be a function
327:24 - that we can use to delete that item.
327:27 - Let's see we can export, let our function,
327:33 - and just like we specified
todo-item to be a todo type.
327:40 - The prop here is going to be a function
327:43 - that receives a rest
parameter, which is a response,
327:49 - and it will have no
return value, so avoid.
327:54 - All right, now, all we need to
do is back in the index file,
327:58 - we now get an error saying
that the todo-item expects
328:05 - the additional property
that we just specified.
328:08 - And the way we can do that
328:14 - is we add it here just like the todo,
328:18 - we can pass in a new function
that doesn't exist yet,
328:22 - but it will in just a second,
328:25 - where right here, next to
the one, we create an item,
328:28 - we can say const equals
328:33 - and make this just a function.
328:37 - Alrighty.
328:39 - And then remember it receives
328:44 - a response, actually
let's do this differently.
328:48 - I'll show you another
trick, let's delete this.
328:51 - And instead what are we going to do
328:53 - is we're going to define the prop here,
328:59 - but instead of writing the code off,
329:03 - we'll write it right in line.
329:05 - The reason we do that is
because we need access to
329:07 - the existing todo-items so
that we can read its UID.
329:12 - So this is a regular function.
329:15 - We can just pass that in here.
329:17 - And we say todos equals,
and then we filter them.
329:23 - And we say that an individual todo,
329:26 - if the UID is not equals to the todo UID,
329:33 - then keep it, otherwise drop it.
329:37 - So now we'll remove the current todo,
329:42 - if the ID matches to the one
that we are filtering through.
329:46 - Let's see what that does
to the user interface.
329:50 - Let's just make sure we have
JavaScript set correctly.
329:54 - Yup, JavaScript is enabled.
329:57 - We clear console and we
delete the fourth item.
330:03 - Yeah, okay, we have to
refresh the page real quick.
330:06 - Let's try that one more time.
330:09 - And we do delete the third
item, that sent a request,
330:15 - if we look at the details,
was a post request,
330:20 - but it had the method delete
in the query parameter.
330:24 - That was our workaround for the form.
330:27 - And then what it did is remove
330:29 - that item from the UI and from the server.
330:34 - All right.
330:35 - So what's missing now is editing
330:39 - both marking as done and adding the text.
330:44 - This can be achieved the exact same way
330:48 - as we did for the delete
and the adding a new item.
330:52 - So let's follow that same pattern.
330:56 - In the todo-item itself,
330:59 - we already have a prop that we passed
331:01 - in here to delete the result.
331:04 - Let's add a new one process
updated todo result.
331:12 - And then in our forms, further down,
331:21 - here we go, we want to add
331:29 - new actions, so we used that
same enhance action enhance,
331:37 - and we want to pass in
the result being that.
331:42 - And the same is going to
apply to the first form
331:47 - where we check it off as done.
331:51 - So here, we may as well
just copy that entire thing.
331:57 - There we go, we can paste here.
332:01 - And with that,
332:04 - we now have to specify the
behavior of that function.
332:09 - And as we noticed, this passed
332:11 - in as a prop to our todo-item component.
332:14 - So in the index,
332:16 - it will expect that we define
that function here as well.
332:22 - So we don't really need to do much
332:28 - other than just passing that in
332:31 - and making sure everything is fine.
332:35 - So hold on, probably a good
time to clean this up a bit
332:42 - add the new properties on new lines.
332:46 - And then we also had the, oops.
332:55 - This new process updated todo,
332:59 - and in this case, what we
could do is define that
333:04 - up in the scripts, doesn't
have to be down there inline.
333:08 - So we can say const
333:14 - equals a function.
333:19 - And as always,
333:20 - what we get passed in here is
a response of type response.
333:25 - It will be async
333:28 - And what we do inside now is we do const,
333:32 - similar to how we fetched the new item,
333:35 - we say, give me the updated item.
333:39 - So const updated todo await
333:45 - JSON, and then the updated todo,
333:50 - we need to go through
the list of todo-items
333:55 - and update the array with the
new item that was updated.
334:01 - The way we do that is todo equals
334:04 - we map over all of them.
334:07 - And here we just say
that if the current item
334:14 - we are iterating over,
334:17 - if the UID equals to the updated items,
334:22 - updated to do the UID,
334:24 - then return our updated item and
334:29 - otherwise just return the one
we already had in the array
334:33 - and don't bother about it.
334:36 - All right, now,
334:39 - one thing we forgot to
do when we built the API
334:44 - is that you see that when we update
334:46 - an item, we expect the
server response to include
334:53 - a copy of the new item, just like we do
334:56 - when we create an item,
334:57 - the server replies with
the newly created element.
335:02 - We need to update our API to also include
335:06 - the updated todo item from that response.
335:09 - If we go back to the API and
we look at the patch case,
335:17 - you notice that we have a
status, but we have no body.
335:20 - And if we look at the post,
335:26 - we return the element that we received.
335:30 - So in the patch case,
335:31 - the element we want to
return is whichever element
335:36 - that was just updated as part
of this map function here.
335:39 - So we can specify this
by saying body equals,
335:44 - and then we'd just go
find that element in here.
335:47 - So if the element we are iterating over
335:51 - its UID maps to the request params UID.
335:57 - Then please, you know,
336:00 - give us that element and we'll
return it back into body,
336:03 - send it to the client where
we then update the UI.
336:09 - So let's have a look at
what's going on here.
336:14 - Let me clear all this.
336:16 - And we add a first item that
went ahead, added the item,
336:23 - it downloaded, you can see
the images here, inline SVGs,
336:27 - because it's the first time
we have that edit button.
336:30 - We can now rename that to first item
336:36 - that just sends a request to
that endpoint, nothing else.
336:41 - And then the UI gets updated
automatically and we can mark
336:45 - them as done as well, that's
the other feature we built.
336:48 - You see it's another
request marking is done
336:52 - and we can get rid of it too.
336:54 - So with that, we developed
a web application
337:00 - that works with JavaScript disabled.
337:04 - And if somebody has JavaScript enabled,
337:07 - we enhanced the forms to leverage
that and use Ajax requests
337:12 - instead of full HTML form submissions.
337:18 - This is a good point in time to commit,
337:22 - we did a lot of work here,
337:24 - but this was all necessary
to make sure our application
337:29 - behaves nicely for everybody
337:32 - depending on their preferences
337:34 - and settings of their browsers,
337:36 - whether JavaScript is enabled or not.
337:39 - Let's do a quick recap.
337:41 - The first thing is we made
a small change to our API
337:46 - so that the PATCH request now
returns the updated element.
337:52 - We also enhanced our function
here saying that we only want
337:55 - to do to redirect if the
browser submitted the HTML form.
338:00 - If the client accepts an HTTP
338:05 - or an application/json, then
we don't want to do that.
338:10 - Most importantly, we added
a new action called enhance.
338:16 - The action receives a form
338:20 - that represents the element
where we used the action
338:23 - and an object with a result function
338:27 - so that we can update the UI
when we get a response back.
338:32 - As an exercise for the viewer,
338:35 - you could go ahead and enhance
that second object to expect
338:41 - an error function as well, so
that if something goes wrong,
338:46 - you could call the error
function and update the user
338:49 - interface to show to the user
that something went wrong
338:52 - and they should retry again.
338:54 - I'll leave that up to the
viewers as an exercise,
338:58 - since we want to move on and, you know,
339:00 - focus on building the full,
all the backend stuff,
339:05 - the API that connects to the
database and persists the item
339:11 - instead of just using an array in memory.
339:14 - Okay, so this is a good place
to commit all these changes
339:20 - and close that PR that
we're about to open.
339:24 - So enhance HTML forms.
339:30 - We'll go ahead and push that
339:33 - and then create a new pull request
339:38 - that we want to slightly rename,
339:41 - make this a bit more readable.
339:44 - And here we say in the
description close issue number 11.
339:49 - And with that, we can
create a pull request.
339:55 - All right, give that a
second to do all this work.
339:59 - Now, if we look here, we have the new PR
340:04 - and we are ready to merge and move on
340:08 - so merge PR, delete the branch.
340:13 - Just as a reminder, never
review your own code.
340:16 - Always ask a colleague to do that.
340:19 - I don't have a colleague
available right now,
340:21 - so I'll do this myself and
then our developer environment
340:27 - on Gitpod, we can go and throw this away,
340:30 - no need for that anymore.
340:33 - And with that,
340:35 - we completed that part where
we enhance the HTML forms
340:40 - so that we can now leverage
Ajax requests where needed
340:46 - It is no time to move on
340:48 - and look at the rest of the architecture.
340:52 - So let's go ahead and start
working on the database.
340:58 - Okay, time to move on.
341:00 - Before we work on that database setup
341:04 - for our developer environment,
341:06 - let's quickly recap where
we are in the architecture.
341:10 - We've developed the frontend with Svelte.
341:13 - We developed an API using SvelteKit.
341:16 - We had our REST API in SvelteKit exposed
341:21 - so that we can communicate with
the frontend and vice versa.
341:25 - Now it's time to focus on the second part
341:30 - of the architecture,
341:32 - where we persist the todo-items
in the database instead of
341:37 - where they currently are, which
is in memory on the server.
341:40 - So having a look at
the final architecture,
341:44 - we're going to start
with a Postgres database
341:47 - in the developer environment
so that we can test
341:52 - the end-to-end flow from the
front end through the API
341:55 - via Prisma over to the
database and all the way back.
342:00 - We want to do all of that in
the local developer environment
342:03 - or in our case on a Gitpod workspace
342:08 - so that we know all the code is in place
342:10 - before we deploy the
application to production.
342:15 - If you follow along on
your local computer,
342:21 - this is the point where you have
342:23 - to go over to the Postgres website.
342:26 - And so PostgreSQL.org
342:29 - and click the download
button here in the banner
342:33 - or up in the header, there's
a download link as well.
342:37 - And depending on which operating
system you use locally,
342:41 - please select the appropriate
installation instructions here
342:45 - and follow along to set up
342:47 - that database on your local computer.
342:51 - If you follow along using Gitpod,
342:54 - then all we need to do is
just make a one-line change
342:58 - in our gitpod configuration
343:00 - in order to get access to Postgres.
343:03 - So that's what I will be focusing on
343:06 - in the next couple of minutes.
343:08 - So we have an issue to install
and start the dev database.
343:14 - We click the Gitpod button to
start a developer workspace
343:19 - for that particular issue.
343:23 - And that is pulling the
container image just like it's
343:26 - always done, it will also
start the development server.
343:31 - So we will see the preview
of the web application.
343:35 - At this point we don't need that
343:36 - because we are not
focusing on the frontend
343:39 - so we can close the tab.
343:41 - And we are now back on that
development environment.
343:47 - So the developer server
here, we can go work on.
343:52 - We don't need to get started
343:53 - and if we open the Gitpod
YAML file in the root
343:59 - at the moment we have not configured
344:04 - which image we want to use.
344:06 - So which Docker container
to use as our environment.
344:11 - That totally fine and Gitpod
just uses a default image
344:15 - that comes with a various languages
344:18 - and frameworks pre-installed.
344:20 - But now we have a special interest
344:24 - in getting Postgres installed,
so we have two options.
344:28 - One, we could specify a Docker
container in our source code
344:34 - and then tell Gitpod to
use that Docker container.
344:37 - So if we have special libraries
344:39 - or operating system dependencies,
344:42 - we have full control over
what the base image looks like
344:47 - for our developer environment.
344:49 - However, in our case all we care about
344:52 - is that we have Postgres
installed and started.
344:56 - So the way we can do it is
we can use the image property
345:02 - and we specify Gitpod/workspace-Postgres.
345:11 - So this is an image that Gitpod maintains
345:15 - and provides to people who
use the environment here.
345:18 - If you want to see what else is available,
345:22 - head over to
github.com/gitpod-io/workspace-images.
345:30 - And you will see a list of other images
345:34 - you can base your environment on.
345:36 - So if you work in Flutter or
with a Flutter application,
345:40 - you can use that as a default image.
345:42 - The same for PostGres, the
one we use MySQL, MongoDB,
345:47 - and a few others.
345:49 - As again, as I said, if you
want your own Docker image,
345:53 - that's an option too.
345:54 - And the Gitpod documentation
345:56 - explains how you can configure that.
345:59 - In our case, all we need
is the workspace-Postgres.
346:05 - And because we are now
starting a development server
346:08 - for this Postgres database,
346:12 - Gitpod will automatically realize
346:14 - that there's a new port available on 5432,
346:18 - which is the default port for Postgres.
346:21 - So if we do nothing else,
346:23 - other than adding this line for the image,
346:26 - every time we start a new
Gitpod developer environment,
346:30 - we will get a popup at
the bottom here saying
346:32 - that a service is listening on port 5432.
346:37 - We don't really want that
because we don't need to know.
346:40 - We know what the database
is installed and running,
346:43 - so we can add another port
definition to our ports array,
346:48 - where we just say port 5432.
346:52 - And when we open the workspace,
346:56 - we want to ignore that port,
347:01 - that just makes sure that nothing gets
347:05 - displayed at the bottom yet,
the port will be available
347:08 - so we can connect with a database client.
347:14 - That's all the changes there
are for this pull request.
347:19 - We literally just added one line here
347:21 - to base our development
environment on a new image
347:24 - that contains Postgres.
347:26 - And we said that let's ignore port 5432.
347:30 - Next step is we commit these changes
347:34 - and create a pull request.
347:36 - Now I already did that
off-camera so for the time being,
347:40 - I can just shut this
environment down and close it,
347:46 - and then you can see, I already
have a pull request here.
347:50 - If we look at that,
347:52 - then you can see that I
made the same changes,
347:55 - GitPod workspace Postgres and port 5432.
348:01 - If we start an environment
based on that new configuration
348:05 - file, so we click the
Gitpod button on the side,
348:09 - and now it's using that
new underlying Docker image
348:14 - that contains the database.
348:17 - So we're going to give
that a second to download
348:20 - all the dependencies and
spin up the environment.
348:23 - And then we can see
that port is available,
348:28 - and also, we now have a CLI
to connect to the Postgres
348:34 - environment, that database
that we started up.
348:39 - So let's just wait until things start up.
348:43 - There's the preview of our
app, we don't need that.
348:46 - And back here, we can
close to get started.
348:56 - If we're heading over
to the Remote Explorer,
348:58 - you can see now we have a
new port available 5432,
349:03 - that is our database.
349:05 - And if we open new terminal,
so on the right side up here,
349:10 - we can click the plus to
create a new terminal.
349:14 - And now if we type psql,
349:19 - then that connects us
to the Postgres database
349:24 - that is installed on our
computer in our environment here
349:28 - the GitPod environment.
349:30 - And now everybody who works
on this project using Gitpod,
349:35 - they will automatically
have Postgres installed
349:39 - and started up as soon as
the workspace is ready,
349:43 - and they don't have to
follow any instructions
349:45 - on how to download Postgres
onto their local laptop.
349:49 - This is all automatically
configured for them.
349:54 - This is a great point in time
to commit, we already did,
349:59 - we have a pull request and we validated
350:02 - that we can login to that database.
350:05 - So we are going to shut this down.
350:09 - And we know we satisfied that PR.
350:13 - So we installed and
started a dev database.
350:16 - We can now go ahead and merge
350:18 - that pull request, confirm
the merge, drop the branch.
350:24 - And with that, we are now
ready to start the integration
350:29 - with the database and the API.
350:36 - What an exciting part
to be working on next.
350:39 - We are finally going to find
a way to connect our API
350:44 - with the Postgres
database that we installed
350:48 - in our developer environment,
just minutes ago.
350:52 - As part of the architecture,
350:54 - we are going to work on that
Prisma part here, so the glue,
350:59 - if you wish between the API
and the Postgres database,
351:04 - it will help us interact with the database
351:07 - and the database's response,
depending on what we do.
351:11 - And we can just use
TypeScript or JavaScript
351:14 - in this case where we can
call methods to add items
351:20 - and fetch items and Prisma
will do all the hard work
351:25 - of converting between SQL
queries and JavaScript objects.
351:30 - If you've ever worked with an ORM before
351:33 - or have written your own raw SQL queries,
351:37 - Prisma will be an
absolute mindblowing tool
351:42 - and seriously increase
your developer experience.
351:45 - We will see that as we go
through the configuration,
351:49 - if you combine it with
Gitpod and automate a lot
351:52 - of the steps, then you'll
get the best of both worlds.
351:56 - Now, before we dive in, we
are working with prisma.io.
352:01 - So having a look at that,
lots of information here,
352:05 - fantastic documentation
that they've put together
352:09 - with all the details we need to know.
352:11 - I will walk you through everything we need
352:13 - in order to get this
application up and running.
352:16 - And if you need more
or want to learn more,
352:19 - then Prisma.io is the place to go.
352:24 - Okay, in GitHub, we have
an issue ready for us,
352:28 - use Prisma ORM.
352:30 - So we'll spin up a new
Gitpod developer environment.
352:34 - And once that's ready,
352:37 - we can start by installing
352:39 - the Prisma command line interface.
352:42 - That's a NPM package that
helps us integrate with Prisma
352:49 - and run certain commands to
make things easier for us.
352:55 - So giving Gitpod another second here
352:57 - to spin up the environment,
352:59 - and then we'll be off to the
races and can get started.
353:08 - Here's our editor.
353:12 - And in the second, we will
also see the terminal,
353:16 - our preview of the web application,
353:19 - which at the moment we don't need,
353:21 - this is a bit of a distraction.
353:23 - So we'll just close that browser tab
353:26 - and get rid of the get started section.
353:30 - We also don't really need
the development server
353:33 - to run so we can click
into the terminal control C
353:37 - to cancel that, what we
do want to do, clear,
353:42 - is we want to install that Prisma CLI.
353:45 - And the way we do that is
by typing npm install -D
353:49 - so that it gets saved as a dev dependency.
353:53 - And the package name is prisma.
353:59 - If we run that, it gets it all installed.
354:03 - And now we can access the
node_modules bin directory,
354:09 - where we have a Prisma executable.
354:13 - And this is how we access
that new package's CLI,
354:17 - that's a lot to type.
354:19 - So the alternative to
that path is to use npx
354:25 - and then the name of the
CLI that we want to call.
354:29 - Before we go any further,
354:32 - I want to show you what
Prisma Studio is all about.
354:37 - Prisma Studio is a web
application that connects
354:41 - to our database and we can
then inspect the tables
354:45 - and the rows and the
columns of our database.
354:48 - So we can validate that
the information we send
354:53 - from the API to the
database gets correctly
354:56 - persisted or updated, depending
on the action we perform.
354:59 - So in order to start the studio,
355:02 - we can see npx prisma studio
355:06 - and start that by hitting enter.
355:08 - At this time, this will
fail and we will see why.
355:13 - Error, could not find
a schema.prisma file.
355:17 - So the schema.prisma file
contains the necessary information
355:24 - for Prisma to understand
everything it needs
355:27 - to know about our database,
355:29 - such as what's the database provider,
355:32 - what's the URL to connect to it,
355:35 - and what does the database look
like in terms of its schema,
355:39 - what tables are available,
355:41 - what columns are within these tables,
355:44 - and what kind of types are these columns.
355:47 - So if we read the error message carefully,
355:51 - we noticed that at the bottom,
355:55 - it tells us that the
default location of the file
356:01 - is a Prisma directory slash schema.prisma.
356:04 - So if we take that path, we copy it.,
356:08 - and in our root, in the editor,
356:11 - we create a new file for
Prisma slash schema.prisma
356:17 - that generates the file that we need.
356:20 - And now we can go ahead
and start editing it.
356:24 - You saw I tried an
autocomplete, that didn't work.
356:28 - The reason for that is that
we don't have a VS Code
356:31 - extension installed that
understands this file.
356:36 - So we can head over to VS Code extensions
356:40 - and search for Prisma.
356:44 - There's an insider and a stable version.
356:46 - I prefer to stable
version, so we click on it.
356:49 - And over here, you remember
that from the Svelte extension
356:53 - that we installed earlier
356:55 - under manage, if you
say, add to Gitpod YAML,
356:58 - that will ensure that everybody
who opens this project
357:03 - on a gitpod workspace will have
357:06 - the Prisma extension installed by default.
357:10 - Just to show you it ended up over here
357:13 - under VS Code extensions
within the Gitpod YAML file.
357:18 - Currently, we don't have it installed,
357:19 - I just added it to the file.
357:21 - So we can either start a
new workspace with that new
357:24 - configuration file or easier way
357:27 - is to hit the quick fix link
357:30 - and say install prisma extension.
357:34 - That doesn't take very long
and once it's installed,
357:38 - then the line will disappear.
357:41 - And now if we go back to our schema file
357:44 - and we use autocomplete, control space,
357:47 - we now have access to the
properties that we need to define.
357:53 - One more thing I'd like to do
357:55 - for future us and our
colleagues, in a file like this,
358:00 - where it may not be obvious
358:02 - where we can find more
information about it.
358:05 - I'd like to just add a comment,
358:06 - learn more about this file in the docs
358:10 - and the URL for that is HTTPs
and pris.ly/d/prisma.schema,
358:22 - quickly double check that
there's no spelling mistakes.
358:27 - That looks good, all the
information you need in here.
358:30 - As I said, the Prisma team
358:31 - did a fantastic job
documenting everything.
358:34 - So we'll drop that.
358:36 - And what we can do now is
358:42 - define our datasource, datasource DB,
358:46 - and then the values inside,
lets use autocomplete,
358:49 - it asks for the provider
and the provider we want
358:54 - is in our case Postgres.
358:57 - So we have other options here as well.
358:59 - We already know we install
the Postgres database,
359:02 - so we'll choose Postgres
and still something missing,
359:06 - which is the URL.
359:11 - The URL is depending on your environment,
359:16 - so generally speaking,
359:18 - the format of a Postgres URL
359:24 - is Postgres colon slash slash,
359:29 - and then the username that
you created in your database.
359:33 - In our case, because we
use the Gitpod Docker image
359:37 - as our foundation for the
developer environment,
359:40 - I know the username is Gitpod,
and then @ the host name,
359:45 - so localhost in our case,
359:47 - slash the name of the
database we want to create.
359:51 - So this in theory works just fine
359:54 - in our local development
environment or here on Gitpod.
359:58 - But when we deploy to production,
360:00 - this is no longer going to
work because that path is going
360:04 - to be something completely different
360:06 - that we need to set dynamically.
360:08 - So luckily the Prisma
schema file allows us
360:13 - to use something called ENV.
360:16 - So this is a way for us to use
360:19 - an environment variable
instead of a hard-coded string.
360:23 - And what we want to do
here is DATABASE_URL.
360:31 - So with that, we now have
to set the DATABASE_URL
360:37 - in our development environment.
360:40 - One way to do that is as you
also see in the docs here,
360:44 - we could create a .env file at the root
360:48 - and configure the
environment variable there.
360:52 - Another way since we're
using Gitpod is we can go
360:57 - to the Gitpod YAML file, and in our tasks,
361:03 - we currently have one terminal
361:05 - indicated by the one dash here.
361:07 - So here we can just add env
and then say DATABASE_URL.
361:15 - And the value of that is
that Postgres localhost URL
361:20 - that we defined before.
361:22 - So now we know that when
we start a new workspace,
361:25 - the terminal with the server
361:28 - will have that DATABASE_URL available,
361:30 - so that's pretty neat,
361:32 - that's all we need for the time being.
361:36 - Let's go back to the Prisma schema,
361:39 - so the schema.prisma file,
361:42 - we have to configure a
few more things here.
361:44 - The next thing is we need a generator.
361:47 - As I mentioned briefly,
when I introduced Prisma,
361:51 - based on our database schema,
361:55 - Prisma will generate a JavaScript
slash TypeScript client
361:59 - that we can load into our API
362:03 - and then interact with the database.
362:05 - So what'd we do here, we specify
a few parameters for that.
362:10 - So we do generator client and
362:14 - bunch of things it's asking for,
362:16 - we'll start with the provider.
362:19 - And the value is, there's
only one prisma-client-js.
362:25 - The other thing we want to do
is specify the binaryTargets.
362:32 - And that is important because
as you see in the description,
362:36 - it specifies the operating system on which
362:39 - the Prisma client will run to
ensure binary compatibility
362:42 - of the query engine.
362:46 - A lot of text, what it
really means is, right now,
362:50 - the Gitpod developer environment uses
362:52 - a Ubuntu operating system.
362:55 - If you follow along in
your local computer,
362:57 - may you may use Windows,
362:59 - or you may use MacOS as your environment.
363:03 - What we're doing here
is we're just indicating
363:08 - that the binaryTargets we
want the client to generate
363:13 - is whatever, I'll show you,
363:16 - whatever the native environment is.
363:18 - That's all the documented,
but native means in this case,
363:23 - it will generate it for Ubuntu,
when we deploy to Vercel,
363:27 - it will generate it for
whatever operating system
363:29 - Vercel uses to run our API.
363:33 - So that gives us the peace of mind,
363:35 - we don't have to worry about anymore.
363:37 - Lastly, and arguably, most importantly,
363:41 - we have to define a database schema.
363:46 - And what that means is if we
look at the API just real quick
363:50 - source, routes, todos _API,
363:55 - remember that todos
array that we specified?
364:00 - And at the moment, this is just
364:02 - an array, a variable living in memory
364:05 - that needs to move to the
database, so in the database,
364:08 - we need a table that can
hold all the todo-items
364:12 - that we add to our web application.
364:16 - So we are lucky in so far that we have
364:21 - already a Todo TypeScript definition.
364:25 - So let's head over there
and look at what we defined.
364:29 - That definition is under src global.d.ts.
364:35 - And you can see, we have a
UID, created at, a text a done.
364:41 - So let's copy that
364:44 - so that we make sure we don't
forget any of the properties.
364:48 - And we move back to the schema.
364:50 - And then what we define
here is called a model
364:54 - and the name of the model,
364:56 - you can roughly think of that
as the table name as well.
365:00 - So that would be todo,
365:04 - and within that, we can
specify the properties.
365:07 - So for now, let's just paste
our TypeScript definitions.
365:13 - And now we just have to update the syntax
365:17 - to match the syntax used
within our schema Prisma file.
365:21 - That's pretty straightforward,
so we do it all in one go.
365:26 - We remove the colons,
365:30 - replace them with a space.
365:34 - And then the next thing is that
365:36 - String is a capital S, so is it here,
365:40 - so is Boolean and date is
actually more specific a DateTime
365:47 - and we also need to drop
all these semi-colons.
365:51 - And with that, we are almost ready to go.
365:55 - It's still complaining about an error.
366:00 - And it's saying that each
model must have at least one
366:04 - unique criteria that has only
required fields, blah, blah,
366:08 - either mark or field ID.
366:10 - Now, what that means
is remember in the API
366:17 - source, routes, todos, index.json.
366:20 - Remember we created that UID
366:23 - and we used Date.now, which
as I mentioned earlier,
366:25 - never ever do that in a
production environment.
366:29 - And we even left a note saying that,
366:32 - replace that with the
UID from the database,
366:35 - nice spelling mistake, okay, so
366:39 - at this point we have
access to the database.
366:43 - We are literally defining
the schema right now,
366:46 - so we can now drop this line.
366:49 - We no longer need to create it.
366:53 - And what we do instead is we remove that,
366:58 - and in our schema, we
can tell the database
367:01 - to use that UID field as the unique ID.
367:06 - And in Prisma, we can
use the @id for that,
367:10 - and also we want to
give it a default value.
367:15 - And the default value,
we can use a function
367:19 - to create that global unique identifier
367:21 - based on the cuid spec, so I'll use that.
367:25 - And with it,
367:27 - every time we create a todo
record in the database,
367:31 - the database will automatically
add a default value
367:34 - to our UID, and we will provide
367:37 - the created at, text, and done.
367:42 - Okay, that was a bit of
configuration here, now,
367:46 - the error we received in
the console before was that
367:49 - this file didn't exist, so
we couldn't start the server.
367:54 - Now there's one more thing we need to do.
367:59 - Remember in the Gitpod YAML
we specified the DATABASE_URL
368:04 - as Postgres localhost blah blah?
368:07 - If we were to commit these changes
368:09 - and start a new Gitpod workspace,
that would be available,
368:12 - but at the moment, if
we do echo DATABASE_URL,
368:19 - we actually, we have it because
I think I already ran it,
368:22 - but that, we have to make
sure this environment
368:26 - where it was to set, so we do have it,
368:28 - and now let's try to clear
this and run npx prisma studio.
368:35 - Give that a second.
368:38 - It is saying that services
available in port 5555.
368:43 - We can close that preview
here, but if we open a browser,
368:47 - it opens up the Prisma
Studio and you can see that
368:53 - it shows us all the models we defined,
368:55 - so in this case Todo model,
368:57 - that's the only one we defined
in our schema down here.
369:04 - So if we click on that,
369:07 - it gives an error, unable to run script.
369:11 - Let's have a look invalidate, blah, blah,
369:13 - and then here the table
369:15 - public todo does not exist
in the current database.
369:20 - That is true because we never
actually created that table.
369:26 - The only thing we did
was we defined the model,
369:30 - but we never told Prisma
369:33 - to create that table in the database.
369:37 - We could go to the database
and manually run a SQL query
369:42 - that, you know, create
table with these fields.
369:45 - But the whole point of using Prisma
369:47 - is that we can automate all that.
369:49 - So let's stop our studio with control C
369:55 - and I will show you how we can ensure
369:58 - that the database is always up to date.
370:02 - So the command we can
use to make this work is
370:08 - again, we use npx prisma migrate dev
370:15 - let's see what happens, basically migrate,
370:21 - is going to look at the Prisma file
370:23 - it's going to see that
there's a todo record.
370:28 - And when it sees that record,
370:31 - it will then go to the
database and check whether
370:34 - the database matches what's
configured in our schema.
370:38 - And let's see what happens
at the moment, just FYI,
370:41 - the database is empty.
370:43 - So there's going to be a
discrepancy between what we expect
370:47 - the database to look
like with the todo table
370:51 - and the empty environment in the database,
370:53 - let's run that command.
370:59 - Alright, so let's walk
through that together.
371:04 - Prisma schema loaded from
this file, excellent.
371:08 - Datasource db is Postgres, mhm very good.
371:12 - Schemas, public and localhosts, 5432,
371:16 - that looks all good.
371:18 - And now it's noticing that
371:21 - the database doesn't match the schema.
371:23 - So it is asking us to provide
a name for the migration.
371:28 - So at this point we really
just initialized the database.
371:33 - So let's call it init.
371:35 - We say init and hit enter.
371:39 - All right, let's give this a second,
371:41 - and then we're going to go back
371:43 - and review everything that
was going on here, it's a lot.
371:49 - We specified init as the
name of the migration.
371:53 - And then it says the
following immigrations
371:55 - have been created and applied
from the new schema changes.
371:58 - Something in a migrations
directory, blah, blah, blah.
372:02 - And then your database is
now in sync with your schema.
372:06 - Let's look at that file, look
at this, there's a SQL file.
372:09 - Prisma migrations.
372:12 - There's a directory here and a SQL file.
372:16 - If we look at that file,
372:20 - oh my, look at this,
372:22 - it generated the SQL that is necessary
372:27 - to run against the database
372:29 - in order to create that table
with the necessary columns,
372:34 - such as the text, the
Boolean, the done, the UID.
372:40 - It also created some constraints
372:43 - on the primary key being the UID field.
372:48 - That's incredible.
372:49 - All done for us, all we
had to do was just specify
372:53 - what we wanted to look like.
372:56 - Good, let's go back to the terminal
372:57 - and see what else went on here.
372:59 - And then it says that your database is now
373:02 - in sync with your schema.
373:04 - So not only did Prisma
generate the SQL file,
373:09 - it also ran it against the database.
373:12 - Very cool, we had literally
nothing to do here.
373:15 - It just did it all for us.
373:18 - And then it ran generate,
373:20 - and it did a bunch of npm stuff here,
373:24 - blah blah, blah blah, all good.
373:27 - And at the end it says,
373:29 - generated Prisma Client to
node modules @prisma/client
373:35 - That is something we're
going to look at afterwards.
373:39 - For now, just note that in this directory,
373:43 - we now have a client that
we can use in JavaScript
373:47 - that is fully aware of the
schema of our database.
373:52 - It knows about this todo-item.
373:54 - There are functions available
to us that we can leverage
373:57 - to find, update, and delete records.
374:00 - We'll get to that in a second.
374:05 - For now, I want to go back
and clear the terminal
374:11 - and then go back up and run
that Prisma Studio again.
374:18 - I'll take a second,
I'll close to a preview
374:21 - and we can ignore that because
we already have the tab open.
374:26 - And if we go back to
the, reload that page,
374:31 - let's have a look.
374:33 - We are now looking at the todo table
374:36 - and you can see there's
a UID, created at, text.
374:40 - We could add a record from here
374:43 - and go ahead, change the date, add a text,
374:46 - change the value of the done
374:49 - and commit that, we'll do that later,
374:51 - but for now, just know that Prisma Studio
374:54 - gives you a way to access your database
374:57 - through a web browser.
374:58 - So we'll discard the changes.
375:01 - One more thing I want to do.
375:04 - Anybody who works on this
application sooner or later
375:08 - is likely going to need access
to that Prisma Studio, but
375:14 - they may not know the
command npx prisma studio,
375:20 - and we want to make this so
easy for them that they don't
375:23 - even have to run the command,
again, we can automate it.
375:27 - Let's imagine we start a Gitpod workspace.
375:33 - And in one terminal, we run npm install
375:38 - and fire up the web application.
375:43 - In another terminal, we
automatically start Prisma Studio
375:48 - and then we open the preview
375:50 - in a new browser tab of Prisma Studio.
375:53 - Let's see how we can do that,
375:56 - just like we configured
the init task here.
376:00 - We can create another one
376:04 - and we don't have any init for that.
376:07 - We only have a command
and command is simply,
376:10 - npx prisma studio,
376:16 - and we also need to specify
the environment variable
376:20 - so that Prisma Studio knows
how to connect to our database
376:23 - using the DATABASE_URL
environment variable.
376:26 - And with that, it will
automatically open two terminals
376:30 - at start up of the workspace.
376:33 - And lastly, it will start
a new service on port 5555.
376:39 - So let's configure that port down here
376:46 - by saying four times 5, 5555
376:48 - and on open, we want to open a
browser window automatically.
376:55 - So we will have two browser
windows open one for
376:58 - the application and the other
one for the Prisma Studio.
377:05 - There's a lot going on in this file.
377:10 - Generally in this PR we
made a bunch of changes.
377:13 - I think at this point,
377:15 - we can go ahead and review and
then almost ready to commit
377:21 - and start working on the
integration with the API.
377:25 - I think the, let me
just have a quick look.
377:32 - Yep so there's one more
thing we need to do
377:35 - before we move on.
377:37 - Remember how we manually
created the migration,
377:43 - we ran Prisma migrate dev?
377:46 - We can automate a little bit more.
377:47 - Let's assume somebody starts
this developer environment.
377:55 - And at the very first time,
377:58 - their database is always going to be empty
378:01 - because every environment is
going to be built from scratch.
378:05 - So in order to make sure
the database is always
378:09 - in sync with our schema,
that we specify here,
378:14 - we want to make sure that
378:16 - that Prisma Migrate dev
command automatically runs
378:20 - before we start our SvelteKit application.
378:26 - So that's an easy fix.
378:28 - All we need to do is open
the package.json file.
378:31 - We already have a dev script.
378:34 - Now in order to run something
before the dev script,
378:39 - we can either come here and say,
378:43 - prisma migrate dev && Svelte-Kit dev.
378:47 - However if we want to run more commands
378:49 - before we start the dev server,
378:51 - this starts to get really
hard to understand.
378:54 - So here's a little
trick that NPM provides.
378:58 - We can take that and then
take the name of our command
379:05 - and create a new command
or a new script called pre
379:10 - and the name of this one
here, let me show you,
379:14 - in this case, we are talking
about, we want a dev script.
379:19 - We want to run something
before the dev script runs.
379:21 - So we can say predev,
379:24 - which means it runs before the dev script.
379:28 - And we wanna run prisma migrate dev.
379:32 - This is nothing, you know, no matching,
379:36 - that's just a regular NPM feature.
379:40 - And with that now every time
we start our dev server,
379:45 - if we came here and ran
NPM run dev, we hit editor,
379:50 - you can see that Prisma
Migrate dev runs first.
379:54 - And then it starts to development server
379:57 - and our application is up and running.
380:00 - So let's have a really
quick look at the output.
380:06 - Prisma Migrate dev
380:08 - same output as before it
loaded the schema file,
380:10 - connected to the database,
380:12 - but now it says already in sync,
380:14 - no schema change or pending
migration was found.
380:18 - That's because of the
migration we ran before.
380:24 - The schema, our model here
380:27 - is already available in the database.
380:28 - That's why it doesn't run anything.
380:32 - The next time we start
a workspace on Gitpod,
380:35 - this will not be the case,
the database will be empty.
380:38 - And Prisma will a automatically
run our migrations in order,
380:42 - based on the date that's
in the folder name here.
380:47 - So with that,
380:50 - we have a lot of code that
is ready to get committed.
380:53 - And that's exactly what
we're going to do next.
380:58 - Time to head over to the source
control and do a quick recap
381:04 - of what happened, make sure
we don't have any bugs.
381:11 - So we added a new terminal
that runs npx prisma studio.
381:16 - We have the new environment variables,
381:19 - and we also open a
browser for Prisma Studio.
381:22 - We added the VS Code extension
381:25 - so everybody gets the same
experience when they edit
381:28 - the schema.prisma file.
381:31 - We added a predev script,
so that our web application
381:36 - always has the database up and running.
381:39 - And the latest changes are applied
381:41 - before we start the dev server, so predev.
381:45 - We added to Prisma CLI
as a dev dependency,
381:51 - and you can see it also
automatically added a Prisma client
381:56 - dependency, that was added
automatically when we ran
381:59 - the migrate command the first time,
382:02 - so that we can then use @prisma/client
382:06 - in our code to access a generated client
382:10 - to connect to the database.
382:11 - We'll see that in a couple of minutes,
382:14 - the probably most important
file that we worked on
382:18 - as part of this part is
the schema.prisma file.
382:24 - We specified that we work
with a Postgres database,
382:27 - the URL is from an environment
variable and the provider
382:33 - for the JavaScript client
is prisma-client-js.
382:37 - And at the bottom we have the Todo model.
382:40 - And this is where we now
generate a UID automatically
382:46 - with a cuid specification.
382:50 - So it'll be a random generated ID
382:52 - that we'll see in just a second.
382:54 - Lastly we made a small tweak to the API
382:58 - and the tweak was that we removed
383:00 - our very bad workaround here
383:03 - to create a UID because now the
database will do that for us
383:08 - and we no longer have to do that manually.
383:11 - So with that, let's go ahead
and commit these changes.
383:15 - So add Prisma & init migration.
383:22 - We can commit this and
create a pull request here.
383:28 - Let's call this use Prisma ORM
383:37 - and we will close issue number 15.
383:41 - Now we only just configured
to Prisma Client,
383:45 - the CLI so far and set up the migrations.
383:48 - We have a little bit more
work to do to update the API
383:52 - and leverage all the
configuration we put in place.
383:56 - So we'll make this a draft and we go ahead
383:58 - and create the branch and the
pull request up on GitHub.
384:05 - That only takes a couple seconds.
384:09 - And then once it's ready,
384:12 - we can go ahead and close
the Prisma Studio here
384:16 - and let's go have a
look, see if that worked.
384:21 - It doesn't seem to have pushed that
384:27 - let's oh, it's pending, okay,
let's see what's going on.
384:36 - I think we can have a look.
384:45 - Review no matching.
384:50 - Okay, maybe what we can do,
384:53 - let's just give it a second,
384:56 - maybe there might be some hiccup here,
384:57 - it seems to be loading.
385:02 - Nope, maybe that was it.
385:06 - Not yet.
385:09 - Let's cancel that here in
the console and have a look
385:13 - what's going on.
385:18 - What if we push manually,
maybe we'll get it around.
385:23 - It could be some GitHub issues.
385:26 - We had something going
on yesterday as well.
385:29 - All right, that created the branch
385:32 - and we should be able to create
that pull request manually,
385:36 - that's no problem at all.
385:39 - Call this use Prisma ORM.
385:43 - You don't need any of that,
385:45 - just close issue number
15, I believe it was.
385:50 - And then create a pull request.
385:53 - There is many ways that lead us to Rome.
385:56 - So all good.
385:58 - We want to convert it to a draft
386:03 - and keep working on it before
we mark this ready for review.
386:09 - Good with that,
386:10 - we can go ahead and shut
this workspace down,
386:15 - close the tab, and from here,
386:18 - we'll now move on and start
to use that Prisma Client that
386:21 - got generated for us and use
it in the API so that we can
386:26 - then persistent read and
update items in the database.
386:35 - With the Prisma configured
in the environment
386:40 - and the studio automatically starting up,
386:42 - it's now time to update our
API in order to leverage
386:47 - all the work we just did.
386:49 - So firing up a new
workspace to get us going.
386:55 - And then we will also
see for the first time
386:59 - how the updates we've made
to the Gitpod YAML file
387:03 - will impact a startup of a new workspace.
387:07 - So it will start two new browser tabs,
387:12 - one for the application preview,
just like we've always had.
387:16 - And then a second one
that is going to show
387:21 - the Prisma Studio web application,
387:25 - where we have access to the database
387:27 - to look at tables and
the content of the table.
387:32 - So we can validate that
the API properly persists
387:36 - the changes that we made in the frontend.
387:43 - So this is a fairly
straightforward part of the course.
387:47 - All we will do is update the API file
387:51 - and replace that todos array
387:54 - that we've had so far with functions
387:58 - to interact with the database.
388:01 - Just giving Gitpod here
another couple of seconds
388:06 - to pull down our base Docker image.
388:10 - And then we should be off to the races.
388:14 - That sometimes takes a
couple seconds more than
388:18 - on average, but ultimately
it is still super convenient
388:23 - to have all that just automated
388:25 - so anybody who works on our
project gets the benefits
388:30 - of the work we did throughout this course
388:33 - without fully understanding
what needs to be installed
388:36 - and what needs to be done.
388:38 - All right, we got our two browser tabs.
388:42 - One is the application,
388:44 - one is Prisma Studio with the Todo model,
388:48 - that's currently empty nothing in here
388:52 - and we get all of this preview
data we can safely ignore.
388:56 - Good.
388:58 - Let's get going, so down
here in the terminal,
389:04 - you notice that on the right side,
389:07 - there are now two terminals.
389:09 - The second one that's
currently highlighted
389:12 - is the Prisma Studio.
389:14 - And the first one is the one
389:17 - that runs our web
application on port 3000.
389:21 - So you can navigate between the two
389:23 - if you want to start or
stop any of the services.
389:29 - Okay so the main file we're
going to work with today
389:33 - is source, routes, todos, _api.
389:37 - Now we moved all that code
into this file a while ago,
389:43 - and now we're going to actually
see some benefits of that
389:47 - because any interactions we've
had with that todos array
389:50 - is now consolidated into that one file.
389:54 - So now that we're going to replace that
389:56 - with the database table we created.
389:59 - We can just update to code below here
390:02 - to leverage calls to the database.
390:07 - So when we ran the migrate dev command
390:13 - from Prisma, so in the
package.json our predev script,
390:18 - prisma migrate dev, that
generated our Prisma Client.
390:24 - If you recall, in the terminal,
if we scroll up just a bit,
390:29 - it generated the,
390:31 - it used the migration and
applied it to the database
390:34 - because we started a new
workspace, the database was empty,
390:38 - and it also generated
390:39 - that Prisma client into
node_modules @prisma/client.
390:44 - Okay, now that client,
390:48 - we will see that in a second
390:49 - is fully aware of our database model.
390:52 - And we can import that because
it's in the node_modules
390:57 - directory, we can input it like
we would any other package.
391:01 - So at the root of our
file here at the very top,
391:06 - we can add a new line saying import
391:13 - Prisma from @prisma/client.
391:19 - And we can then use that
instead of, you know,
391:23 - todo.push, for example,
391:25 - we can use that new Prisma import.
391:30 - Now there is one gotcha.
391:32 - and that is related to
a temporary workaround
391:39 - we need to implement until
everybody moves to ES modules.
391:44 - So that line import
Prisma from Prisma client
391:50 - works well in our environment,
but once we deploy to Vercel,
391:56 - we'll need to import
this slightly different.
392:00 - Long story, there's
some information online,
392:02 - but we basically want to extract that
392:05 - for the time being into
separate file and allow us
392:10 - to deal with that workaround.
392:13 - So just bear with me as
we go to source, lib,
392:16 - and we create a new file
here called prisma.ts.
392:23 - And within that,
392:24 - we basically implement
the loading mechanism
392:28 - of both approaches,
392:30 - one that works on our
development environment
392:32 - and one that works on
Vercel, and then we will use
392:37 - that in our codes, in the API
file so that we don't have
392:41 - to deal with any if else
statements and whatnot over there.
392:44 - So the way we do that is we import Prisma,
392:49 - but also we import star as PrismaAll
392:56 - from the Prisma Client.
392:59 - So as I mentioned,
393:01 - depending on whether we
run on our environment here
393:05 - or in Vercel, this one,
393:07 - or this one will be
undefined, one of the two,
393:10 - and it's the opposite way,
393:11 - depending on the environment we're on.
393:13 - So all we need to do now is we
say the actual Prisma Client
393:18 - is either Prisma if it's available,
393:21 - so TypeScript, we can use question mark.
393:26 - So Prisma Client or alternatively,
393:34 - PrismaAll again, if it's
available, dot PrismaClient.
393:38 - And then we see export
default, the PrismaClient.
393:46 - And now with that, we don't
have to worry anywhere else
393:49 - in the code, whether this
approach loaded the correct client
393:53 - or this approach did with
the star as Prisma Client,
393:58 - all because in this line here,
394:00 - we basically just pick
either this or the other one
394:03 - and export to Prisma Client.
394:07 - With that in our API,
394:09 - we can simply say import the PrismaClient
394:17 - from remember the
shortcut with $lib/prisma.
394:23 - And now we can use that Prisma
client just like we would
394:27 - if we imported it regularly
according to the Prisma docs.
394:31 - A small little workaround
that we need to make this work
394:36 - on the local environment
or in Gitpod here,
394:39 - as well as on Vercel.
394:41 - Now, the probably most exciting part
394:44 - of this entire course is that
394:46 - we can finally get rid of this todos array
394:50 - and no longer the todo items in memory
394:54 - and lose them every time
we restart the server.
394:58 - So let's celebrate by dropping
this, hooray, is gone,
395:03 - we'll never have to worry about it again.
395:05 - Instead what are we going to do
395:08 - is we create a new instance
of that PrismaClient.
395:11 - Let's call it, Prisma
equals new PrismaClient.
395:17 - And now you'll see the power
of Prisma in just a second,
395:20 - if we take this and
395:25 - we start to go through all the places
395:27 - where we access currently
that array, and we replace it
395:30 - with a call to the database,
let's check this out.
395:33 - So here we want to
fetch all the todo-items
395:39 - that are persisted in the
database, so let's look at this.
395:42 - We use Prisma dot and now the autocomplete
395:50 - show us a todo property
395:57 - with that todo, we can then say find many.
396:02 - And you can see there's code
examples right in the docs.
396:06 - So that get all todos is
const todos equals await
396:11 - Prisma todo findMany.
396:13 - So we'll do findMany.
396:15 - We call that and this returns a promise.
396:21 - So we'll say await and we
make this an async function.
396:27 - Unbelievably cool.
396:29 - You can tell I'm really
excited about this.
396:32 - This is such a game changer
to how we've developed with
396:37 - or interacted with database
from JavaScript in the last 20
396:40 - years, Prisma really sets the
bar high with that approach.
396:45 - That's literally all we
need to do, and as you saw,
396:48 - we had full TypeScript
support for our todo-item.
396:53 - If we were to go into the Prisma schema
396:57 - and start to add more
models or update the model,
397:01 - every time we start a dev server,
397:04 - the new client will be generated
and we would have access
397:07 - to these new fields and functions
and everything immediately
397:11 - through TypeScript autocomplete here.
397:14 - Okay.
397:16 - The next thing is we want
to create a new todo-item.
397:22 - So far we just set todos.push,
397:25 - now, this is no longer the way to do it.
397:29 - The new way to do it is that
we say await prisma todo,
397:40 - and guess what, create, ah, so cool.
397:45 - And within that, we have autocomplete,
397:50 - which asks us to provide a data property.
397:55 - We will happily do that, and as part
397:58 - of that data property, you
can now see that it's asking
398:02 - for created at, done,
text and an optional UID.
398:06 - Again, fully autogenerated
because of our model.
398:10 - And we know what these values
are, so let's go ahead.
398:17 - Top to bottom, created at
is the data dot created,
398:23 - oops created, what did
we call it created at?
398:28 - And we know this is a date,
so we'll tell TypeScript that.
398:33 - And then we have done,
which comes from data.done,
398:38 - that's a Boolean.
398:42 - All right.
398:43 - And we have the text, which
is data.text as string.
398:51 - And with that,
398:52 - we now have a new item
created in the database.
398:56 - So that push is no longer needed.
399:01 - Now here's one thing we have to change.
399:04 - And the reason we need to change here is
399:08 - so far our post endpoint
added to UID right here.
399:14 - This is no longer the case,
399:16 - but when we add an item to the database,
399:18 - the response to the frontend
has to include the UID,
399:23 - or basically it has to
include the todo-item
399:27 - with the same data that
we have in the database.
399:31 - So we could, you know,
399:33 - use Prisma to go fetch the
newly created item somehow.
399:38 - But the better way is
that the create function
399:41 - actually returns the created item for us.
399:46 - So we can just say, body
equals and drop this part here.
399:53 - Now we create the item in the database
399:56 - and when that's complete,
399:58 - the response we get back from the database
400:00 - is newly created item
that contains the UID.
400:06 - Moving on, let's see how
we can delete an item.
400:09 - This doesn't exist, but we can say
400:16 - await Prisma.todo dot,
400:24 - let's see, do we have a delete?
400:25 - We have a delete right here.
400:27 - And what do we want to do?
400:30 - In the docs, It says that
it wants a where clause,
400:34 - where we can specify which
element we want to delete.
400:39 - All right, let's have a look.
400:40 - We'll pass in an object
with a where clause.
400:45 - And it's suggesting that we provide a UID.
400:49 - Let's do that.
400:51 - We know that the UID we want to delete
400:53 - is the one we get from
the request params.UID.
400:59 - And that will take care
of removing that element.
401:06 - We can apply whatever response
we get back to the body
401:10 - if we wanted to.
401:12 - That's all good.
401:14 - Lastly let's look at how we can patch
401:18 - an object in the database.
401:21 - So none of that is needed anymore.
401:25 - As well as the body, we
will do that in one line,
401:32 - body equals await prisma todo
401:37 - and then guess what,
there's an update function.
401:41 - And the update function wants an object,
401:44 - let's have a look data and where,
401:47 - okay, we are already
familiar with the where.
401:49 - So we can just use that.
401:51 - We know it wants a UID, which we have.
401:56 - And also it wants a data property,
401:59 - which presumably is going
to be the data we want
402:03 - to update for the given
todo-item we selected up here.
402:08 - So data, we have data,
text, and todo done.
402:13 - So let's say done, and the
value for that is data.done.
402:19 - And the other thing is the text.
402:26 - And that is data.text
that we want to put there.
402:33 - Okay, now we don't need
that code from before,
402:40 - we don't need that.
402:42 - That looks good.
402:44 - And what we can do now is go have a look
402:49 - at what this looks like
in the user interface.
402:53 - So first of all, let's go all
the way to the bottom here.
402:58 - This looks good, seems to compile.
403:01 - If we switch over to the application,
403:04 - let's inspect the network tab.
403:09 - So here we'll add a first item,
that seemed to have worked,
403:14 - something happened, at
least we show it in the UI.
403:17 - Let's look at the requests.
403:25 - Todos JSON, all right.
403:28 - We sent the text, and in
return, we got an item.
403:33 - There's our new UID
generated by the database.
403:36 - Definitely a lot more unique
403:39 - than our timestamp that we had before.
403:41 - Again, a reminder, do not use
Date.now as a UID, never ever.
403:49 - So very cool, let's look at
Prisma Studio to double check
403:53 - if that item actually got persisted.
403:56 - So heading over to the Prisma Studio tab,
403:58 - and there's a little refresh icon, voila,
404:03 - we have our very first todo-item
persisted in the database,
404:08 - which means that we could
now stop our server.
404:13 - Let's do that.
404:15 - Stop our frontend server
and start it back up,
404:21 - let all these scripts run
and do what they need to do.
404:29 - All right.
404:31 - There's a new preview, and guess what,
404:35 - it shows our item still
here because we fetched it
404:39 - from the database.
404:42 - Let's have a look at the done
column, it's currently false
404:47 - just to make sure updating
works as well, we check it.
404:50 - We come back and refresh,
and this now says true.
404:54 - And lastly, for good measure,
404:56 - first item persist in the Prisma Studio.
405:01 - First item is now persisted.
405:05 - What a wonderful time to be
a full stack web developer.
405:11 - So many tools that make life so easy.
405:14 - And we now have TypeScript
support basically
405:16 - from the database all
the way to the frontend.
405:20 - And if we were ever to change anything,
405:24 - TypeScript would yell at
us right away telling us
405:26 - to update our code and match
405:29 - the new code we want to implement.
405:33 - Okay, let's close the Prisma Studio,
405:36 - close out preview, and commit
the changes that we made.
405:42 - We finally were able to
drop that todos array
405:45 - that we now replace with
database calls, and you can see,
405:51 - we have the Prisma instance
of the Prisma client,
405:56 - and that now autocompletes
our todos and the functions
405:59 - we can call on that todo object.
406:04 - With that, let's go ahead and commit that.
406:11 - We're now using the Prisma client.
406:14 - All right, let's commit.
406:17 - Yes.
406:19 - And then since we already
have a pull request open,
406:23 - we can just sync our changes and let
406:29 - GitPod send that up to GitHub.
406:35 - And here we go, we now
got that code in here.
406:39 - And that marks the end
of that pull request.
406:45 - So ready for review, ask our
colleagues to have a look.
406:49 - They can go through,
406:50 - see all the changes we've
made to the different files
406:56 - as part of this pull request,
our migration autogenerated
407:01 - and our file here with the schema
407:04 - where we defined what
the table looks like.
407:07 - And then the update to the API,
407:10 - where we replaced the in memory array
407:13 - of todo-items with calls to the database
407:18 - to assist and update, all that.
407:24 - Wonderful and with that,
407:27 - we can go ahead and
merge that pull request,
407:31 - and then move on and start
to look at some more things
407:36 - in order to deploy this
application to production
407:41 - merge it and delete the branch.
407:45 - Good, that's all cleaned up.
407:47 - That environment is no
longer needed, we'll stop it,
407:51 - get rid of it.
407:52 - And that marks the end of
this issue that we worked on.
408:01 - What an exciting time.
408:03 - We now have our full stack application
408:08 - that is running perfectly fine
408:11 - in a local developer environment
408:13 - or in a Gitpod developer environment.
408:16 - We have a frontend API and the database,
408:19 - everything is connected,
408:21 - everything communicates and
what's missing in this course,
408:28 - and to wrap it up is in order
to use that application,
408:34 - we need to deploy it to production.
408:37 - So for that, we have
two tasks ahead of us.
408:41 - The first one is to deploy a
Postgres database to Railway.
408:47 - And the second task is to deploy the API
408:51 - and web app to Vercel.
408:54 - We will start with the database
408:56 - so that when we deploy the API,
408:58 - it will be able to connect
to the database right away.
409:04 - All right, first things
first, we had over to issues.
409:09 - We have two issues left.
409:11 - One is to deploy a database on Railway.
409:13 - That's the one we want to work on.
409:16 - So we fire up a new Gitpod
developer environment.
409:20 - And once that is ready,
409:23 - we will be able to make
a couple of changes
409:27 - just so that when we deploy
the application to Vercel,
409:31 - everything works and is in place
the way we expect it to be.
409:38 - So here is our developer
environment spinning up
409:45 - and it fires up Prisma Studio,
409:50 - which we don't need right now.
409:52 - And our web application preview,
we don't need that either.
409:56 - So all we really need here
is the package.json file
410:03 - where are we going to
make a couple of changes.
410:05 - So we can cancel that Prisma Studio,
410:08 - we can control C and switch
to the other terminal here.
410:13 - This is where our application runs.
410:16 - We'll cancel that as well for now.
410:19 - And what we now need to do
is in the package.json file,
410:28 - you remember, in development,
410:32 - before we start the dev server,
410:35 - we created a predev script
410:39 - where we run the prisma
migrate dev command.
410:44 - This helps ensure that
the Postgres database
410:48 - is always up to date with
the latest migrations
410:52 - that exists under Prisma migrations.
410:55 - Now this, as the command says
410:58 - is for development, but when
we deploy to production,
411:02 - there might be changes
to the database schema
411:06 - that we have to apply to the
production database as well.
411:09 - And in that case, we don't
want to run Prisma migrate dev.
411:15 - We want to run a production
level command for that.
411:21 - Now, when do we want to run that command?
411:24 - When we deploy to Vercel,
411:27 - the Vercel adapter for
SvelteKit will automatically
411:32 - execute the build script.
411:36 - So, or in other words,
411:38 - Vercel will actually
execute the build script
411:42 - and the SvelteKit command
line interface here,
411:46 - that will then execute the Vercel adapter
411:50 - and deploy the application.
411:52 - And we'll talk about
that when we deploy the
411:54 - web application, but the build
script is something where
412:02 - we want to run that command
412:06 - to update the database and migrate
412:10 - if there are any migrations.
412:13 - The problem is we could run
that build script in our
412:17 - local environment as well,
so this would be confusing.
412:22 - We wouldn't want to update the database
412:25 - by running the build script locally.
412:27 - So luckily there is a
script that we can leverage.
412:32 - So if we add a new script
to our package.json file,
412:35 - and we call it vercel-build.
412:40 - This script is only executed
when we deploy to Vercel.
412:45 - And at that time,
412:47 - this is the perfect place
to upgrade our database.
412:52 - The way we do it is we use Prisma,
412:56 - prisma migrate, just like
we did in the predev script,
413:01 - but instead of dev, we use deploy
413:07 - and then once that's done
and the database is updated,
413:14 - we can say && npm run build.
413:19 - So that Vercel then kicks in,
first deploys the database
413:23 - and then runs the build script
for the web application.
413:29 - So let's quickly run that build script.
413:33 - So the one we're going to
execute here npm run build,
413:37 - let's run that in our environment
413:40 - to see what actually happens
when we deploy to Vercel.
413:45 - So npm run build.
413:52 - And it is now telling us
that it could not detect
413:55 - a supported production environment.
413:58 - And that's because we are not
actually running on Vercel.
414:02 - So because in our Svelte config,
we use that adapter-auto,
414:08 - it tries to determine
where we are executing
414:12 - this command from.
414:14 - And because it doesn't see
this environment as being
414:19 - Vercel, it automatically
basically gives us that error.
414:25 - Now I spend a lot of time in
the SvelteKit source code,
414:28 - so I know that if we
temporary export a variable
414:33 - called Vercel, and we give
that, let's say a value of true.
414:37 - And then we run that and
NPM run build script again,
414:42 - it goes through the same steps
414:46 - and now it determined
that we are on Vercel.
414:50 - So we basically just, you
know, cheated a little bit,
414:54 - but this is only temporary because I want
414:57 - to show you what happens on Vercel.
415:01 - So the first thing we
noticed is that he created
415:03 - a new directory called
.vercel_build_output,
415:07 - and within that directory, we
have a functions sub-directory
415:16 - and then node, and then render.
415:19 - So that index file here
within the render directory,
415:24 - this is our generated
code, it's very long,
415:31 - but that's basically our
generated code for the application
415:35 - that we developed, our
service side application.
415:40 - Now, when we deploy to production
415:45 - in that directory here,
415:47 - we need to include our schema.prisma file,
415:56 - that needs to be available
so that when we run
415:59 - Prisma migrate deploy,
Prisma can find the schema,
416:04 - and in the schema, you'll remember,
416:06 - it has the information on how
to connect to the database,
416:10 - what database it is and
all the schema information.
416:14 - So because of that, we want
to run a script after we build
416:22 - that directory, so we can say
here in the package.json file,
416:29 - postbuild, so it just like we had a predev
416:34 - that runs before the dev
script, we have a build script
416:37 - and if we say post build,
416:40 - that script runs after
the build completes.
416:43 - So what we want to do here
416:46 - is copy our prisma/schema.prisma file.
416:52 - And we want to copy it
into that render directory
416:57 - that we have here, so let's right click
417:00 - and see copy relative path.
417:05 - And then in our copy
command, we'll paste that
417:10 - so that we go from
.vercel_build_output into here,
417:15 - functions, node, render,
add a slash at the end.
417:19 - So that copies the Prisma file.
417:21 - And there's one more thing we need to copy
417:25 - that are these binaryTargets.
417:28 - So they get generated
417:31 - by default into the node modules directory
417:36 - and within the node
modules, under the, @prisma,
417:43 - we have a directory here called engines
417:47 - and within the engines,
417:48 - you can see the lib query
engine debian open SSL
417:54 - something something, that
file or a similar name,
418:00 - depending on what environment Vercel runs
418:03 - needs to be copied into that
same functions directory.
418:08 - So that way we can do that is
418:11 - just like we copied that Prisma file.
418:14 - We can add another copy command,
418:18 - and this time let's go back
node modules, Prisma engines.
418:24 - We want to copy that relative path.
418:28 - So from that directory
under @prisma engines,
418:32 - we want to copy everything
that contains query
418:36 - and the place we want to copy it to
418:39 - is the same one here under
the Vercel build output
418:43 - functions, node, render, we'll
drop that at the end here.
418:49 - So that makes sure it
copies these query files,
418:55 - if there's more than one,
it would take all of them,
418:58 - put them in the right place.
419:01 - And the other thing we can do just in case
419:06 - we were to run that build script again,
419:09 - let's ignore the Vercel
build output because
419:15 - we don't really want to commit that
419:17 - that would be bit of a mistake.
419:20 - So in our gitignore file,
419:23 - we can say that we do not want
419:29 - that Vercel build output
committed to Git, so that's good.
419:37 - All right.
419:38 - Few things happened here.
419:39 - We basically just prepared the
application so that on Vercel
419:45 - it makes sure that it runs prisma migrate
419:50 - and then npm run build.
419:52 - And after the build in
the post build script,
419:55 - we copied the schema to
the function on Vercel
419:59 - and we also copied query
files to the same directory.
420:04 - Okay.
420:06 - Let's go and commit these changes.
420:10 - So configure,
420:16 - configure, Vercel build,
and post build scripts.
420:25 - Alright, and we'll commit that.
420:28 - Yes.
420:30 - And we can open a pull request.
420:35 - So let's call this deploy
database on Railway
420:43 - and this will close issue number 18.
420:50 - Alright.
420:52 - We'll say create, yes please publish.
420:57 - Let's give that a second to do its job.
421:01 - And we now have a pull request
421:05 - that contains these latest changes.
421:09 - So as part of the deploy
database on Railway,
421:14 - we also actually have to go
create that database on Railway.
421:20 - So the way we can do that
is we go to Railway.app.
421:24 - And even if you're not
logged in, we can just say
421:27 - start a new project and
provision Postgres database
421:33 - that runs for a few seconds.
421:39 - And now we have a
Postgres database running.
421:45 - You can see that this
is a temporary project
421:48 - and will be deleted in seven days.
421:50 - That is because I am an anonymous user.
421:54 - I will eventually claim
that so that the database
421:58 - stays online and you see
all this working in action.
422:03 - For now, this is all we need.
422:06 - One important aspect is if
you click on the Postgres
422:11 - link on the left here, we can
then eventually see some data.
422:16 - But for the time being,
if you click on connect,
422:20 - you can see our Postgres connection URL
422:24 - listed right here.
422:26 - This is something that we're going
422:27 - to need when we deploy to Vercel.
422:30 - So let's just keep this
browser tab open and we will
422:33 - come to that and copy it in a second.
422:37 - For now, though, we've done the work
422:40 - that is necessary to deploy to Vercel.
422:44 - And we have a few scripts
here that are needed
422:48 - to make sure the database
in production is up to date
422:52 - with the latest schema and we can deploy.
422:56 - So we are good to go and
can merge this pull request
423:02 - into the main branch, drop the branch,
423:07 - and go ahead and shut down our workspace.
423:16 - Alrighty, and we can now go back to issues
423:19 - where we have one left,
423:21 - that's deploying the application to Vercel
423:25 - and then configure it
so that it can connect
423:27 - to the database we just deployed,
let's go and do that now.
423:36 - Last step of this course,
423:39 - we have to go ahead and deploy the web app
423:43 - and the API onto Vercel,
423:47 - and if we compare to the architecture
423:50 - this is the piece right here,
423:53 - where we have to go and
deploy that and then make sure
423:57 - it can properly connect
from Prisma to the database
424:02 - we just deployed a little while ago.
424:06 - Okay.
424:07 - Here is the best news that
you can possibly imagine.
424:13 - When it comes to deploying
a SvelteKit application
424:19 - to, at the time of this recording,
424:23 - Vercel, Netlify, or CloudFlare,
424:25 - you don't have to do any code changes.
424:29 - The reason for that is that
in the Svelte config file,
424:36 - we have an adapter that is being imported
424:39 - that's called adapter-auto,
and that is used here.
424:44 - As you recall, from the very beginning,
424:45 - adapters are used by SvelteKit
to prepare the application
424:51 - for the different environments.
424:54 - So if you deploy to Netlify CloudFlare
424:57 - or Vercel at this point in time,
425:00 - then you don't have to
make any code changes.
425:04 - If you're curious what the
latest supported environments are
425:08 - head over to kit.svelte.dev/docs,
425:12 - scroll down in the navigation
425:16 - until you get to adapters
425:19 - where it says supported environment,
425:22 - and you have a list here
of supported environments.
425:27 - So the three are here, we
are deploying to Vercel.
425:31 - So we are in luck and we don't have
425:33 - to actually make any code changes.
425:36 - The only thing we have
to do is log into Vercel.
425:41 - So make sure we create an
account, pick the right team,
425:45 - and then you can say new project.
425:49 - And from the screen,
425:52 - you select the organization
or the account,
425:58 - and then the project you want to deploy,
426:00 - in my case, that's the full
stack web development project.
426:04 - So I can import it.
426:06 - You can see that it
automatically recognizes this
426:09 - as a SvelteKit project.
426:11 - So it analyzed my code in
Github and it saw that this
426:15 - is a SvelteKit app, no need
for me to make any changes.
426:20 - However, if we look at
the environment variables,
426:24 - there is one thing that
we want to configure,
426:27 - which is our DATABASE_URL
426:30 - that we configured locally or on Gitpod
426:35 - as part of the developer environment.
426:40 - In production, we also have
to specify a DATABASE_URL,
426:46 - so that Prisma knows how
to connect to the database.
426:50 - The value that we want to add here
426:54 - comes from the Railway.app,
426:57 - remember we created a
Postgres database here
427:02 - and it has a Postgres connection URL.
427:05 - So we want to copy that.
427:07 - And over in Vercel at
this as the DATABASE_URL,
427:13 - we say add, and with that,
427:16 - that environment variable is
available for Prisma to pick up
427:21 - and we then can say deploy.
427:25 - And you can see down here,
427:28 - it starts to build four seconds ago.
427:32 - It's running all the necessary scripts
427:36 - in order to build the
SvelteKit application.
427:40 - It will also run the post
build scripts that we specified
427:45 - so that the database
will be populated with
427:50 - the table that is needed as
well as all the other things
427:56 - that are necessary to make this work.
427:59 - Lots going on.
428:00 - We can see here that one
migration found in the migrations.
428:05 - So it applies that.
428:07 - This is happening because we specified
428:10 - that Vercel build script, which
runs Prisma migrate deploy.
428:16 - So this is why it said, Hey,
428:18 - I'm running this migration
and applied to the database.
428:23 - It does a bunch of other stuff.
428:24 - There's two warnings we can
safely ignore that's okay.
428:28 - And eventually we are
uploading the build cache
428:34 - to the server.
428:36 - And I have seen this page getting stuck
428:40 - at certain times, and it
looks like this is one
428:43 - of those days, so this has
been running for a minute,
428:49 - which is a bit longer than it
usually takes, which is fine.
428:53 - What we can do is instead of waiting here
428:57 - for that to never finish,
429:00 - we can just go back to the top
429:01 - and click the back button here.
429:05 - That brings us to that page
where we can input a project.
429:10 - So if we just click at
the top on our team,
429:14 - we can now see that we have
that project configured here.
429:19 - And if we open it up,
429:21 - we get a nice little preview
of our todo application.
429:25 - And over here, we have
the URL available to us.
429:29 - So if we click on that,
429:32 - you can see that
full-stack-web-development.vercel.app
429:37 - is our production environment.
429:39 - And if we come in here and
we add an item saying, first,
429:44 - we can enter this,
429:47 - hit enter and see what
happens in the database.
429:53 - Let's do that one more time.
429:56 - There we go.
429:57 - And now we have the first
item added to the database.
430:02 - If we head over to Railway
and we select the data tab
430:08 - in our Postgres database,
we can see that Prisma
430:12 - created a migrations table, that's okay.
430:16 - Prisma will manage that,
nothing for us to worry about.
430:19 - More importantly we can see the todo table
430:22 - that now contains our first todo item.
430:27 - If we were to go back to production,
430:30 - mark this as done, and
then head over here,
430:34 - you see that this done
column changed to true.
430:38 - And we could go ahead
and add a second item
430:43 - and even a third item.
430:45 - This works just like it did locally.
430:48 - And we could even go ahead
and remove certain items
430:52 - that would then reflect
what we see in the database.
430:57 - First and third, true and false,
431:00 - true, false, first and third.
431:03 - What an exciting time,
431:05 - truly how we deploy web applications
431:10 - as a full stack developer
has dramatically improved
431:13 - over the last couple of years,
thanks to amazing companies,
431:18 - such as Vercel and Railway development
431:22 - of these applications as well
is dramatically changing.
431:26 - Thanks to developer environments
431:29 - in the cloud by using Gitpod.io.
431:34 - With that, we can head back to our issue.
431:38 - And one thing we want to do here
431:43 - is take that URL and
leave a note saying that
431:50 - application deployed to this URL.
431:55 - We leave that comment and we can go ahead
432:00 - and close that issue.
432:04 - This complete the coding
part of this course.
432:08 - Amazing work, congratulations
432:10 - on making it all the way through.
432:13 - You now have a full stack web
application available here,
432:17 - built with Svelte, SvelteKit,
432:20 - using Prisma to connect
to a Postgres database.
432:24 - And all of that is deployed
to Vercel and Railway.
432:30 - Excellent, congratulations,
432:32 - you have developed a full
stack web application,
432:36 - deployed it to Vercel, deployed
the database to Railway.app
432:41 - and connected all these pieces together
432:44 - so that this is now a
really good foundation
432:48 - to build anything on top of it.
432:51 - Let's quickly recap what we've done
432:54 - and how you can move on and
do more features, development
432:58 - on that, or add other things
you might be interested in.
433:02 - First off we created a
user interface with Svelte
433:07 - that was really the basic foundation
433:11 - that we needed for the web app
433:13 - in order to create
todo-items, update them,
433:17 - delete them and display all of it.
433:19 - We then moved on and created
a SvelteKit backend API.
433:25 - There was a REST API with endpoints
433:27 - to create, read, update,
and delete todo-items.
433:32 - We used REST or HTTP to
connect to that backend
433:37 - and returned JSON data
to display in the UI.
433:42 - At the very beginning,
we started off building
433:44 - that application with JavaScript disabled.
433:49 - So we used the regular HTML form elements
433:52 - and post requests to submit the data.
433:56 - We then enhanced our
forms with Svelte actions,
434:01 - which allows us to intercept
the HTML form submission,
434:07 - and instead do an Ajax request.
434:10 - So we don't have to reload the entire page
434:12 - for every action that we do.
434:14 - So we now have a front end
that works with JavaScript.
434:17 - It also works with no JavaScript
enabled in the browser.
434:22 - In the second part of the course,
434:24 - we went ahead and used Prisma,
434:30 - an ORM to let us connect
to a Postgres database.
434:33 - This really simplified the
entire integration with
434:37 - the database, we did not write
a single line of SQL code.
434:43 - All we really did was
using generated TypeScript
434:48 - and JavaScript in order to
connect to the database,
434:51 - we were reading data,
434:53 - updating data all by simply
just calling functions
434:56 - within our JavaScript
and TypeScript files.
435:01 - Lastly when we had all this working
435:04 - in a developer environment,
435:06 - we then deployed the web
application to Vercel
435:10 - and we deployed the Postgres
database to Railway.app
435:14 - where it is now running
so that we can connect
435:18 - to it from our production environment.
435:21 - When we developed the project,
435:24 - we did all of that in a
Gitpod developer environment.
435:29 - So you notice that for every
task that we worked on,
435:33 - we started a new GitPod workspace.
435:36 - And this is the concept
435:38 - of what ephemeral developer
environments or are all about.
435:43 - You start in an environment,
it's fully automated,
435:45 - it started our developer
server, installed dependencies,
435:49 - and we then basically
could just write our code,
435:53 - stop the environment,
and for the next task,
435:56 - we opened a new environment to
do the work we wanted to do.
436:01 - Amazing achievement,
congratulations, once again,
436:04 - this is a full stack
application that you can use
436:08 - as a foundation to do further work
436:11 - and build your own projects.
436:16 - Let's spend a few minutes
talking about what's next.
436:20 - How can you further enhance
the application in order to
436:24 - deepen your knowledge about
the technologies that we used
436:28 - and the different
providers where we deployed
436:31 - the application as well as the database?
436:34 - The first thing I want to bring
up as a suggestion to look
436:37 - into is trying to deploy
the web application
436:41 - and the API endpoints to a
different hosting provider.
436:45 - As part of the course, we used
Vercel and I introduced you
436:49 - to the adaptor concept of SvelteKit.
436:52 - So an easy kind of next steps
would be to maybe deploy this
436:57 - entire application to Netlify
or CloudFlare or any other
437:02 - hosting provider that you
might be familiar with.
437:05 - So this would be a good next steps,
437:09 - minimal code changes in
order to get it resolved.
437:12 - So you would get some quick
success by looking into this.
437:18 - Another suggestion would be to play around
437:25 - and try to use a different database.
437:26 - Maybe you are not familiar with Postgres.
437:29 - Maybe you are more familiar with MySQL,
437:32 - try to change the database
to MySQL instead of Postgres.
437:40 - Read up about the Prisma configuration,
437:43 - how you can change that and, you know,
437:45 - try Railway or try Planet Scale
437:48 - or any other database provider.
437:50 - See if we can connect the
API to that database system
437:54 - and learn about that part
of the backend development
437:58 - in this entire stack.
438:01 - Lastly, a third suggestion
438:03 - to look into might be
to enhance the project.
438:08 - Right now, this is a very
simple todo application
438:12 - where everybody who is using it,
438:14 - they'll get the same list of todo-items.
438:18 - Now it would be more helpful if
438:20 - for example, there were people
you could assign items to,
438:25 - and of course, if you
just had your own lists,
438:26 - so add some kind of authentication
to the system where,
438:32 - you have to log in with
GitHub or maybe email address
438:34 - and password, and then
you could add due dates
438:38 - where you say that this
item is due by Friday.
438:42 - So try to learn how to
persist that in the database.
438:46 - And overall this could
really be an application
438:51 - that you can build out as
part of your learning journey
438:55 - for the full stack
application development.
438:59 - Alternatively, you could
take what we built,
439:03 - use the concepts and build
something completely different.
439:06 - I would love to hear what you come up with
439:08 - based on the course, so do
reach out and let me know.
439:13 - Otherwise let's wrap this
up with a few more words
439:19 - about the overall course.
439:23 - With that thank you so
much for taking your time
439:25 - and working through this course.
439:29 - It was a great pleasure
putting this together,
439:30 - and I hope this gives
you a good foundation
439:34 - for your next project
439:36 - when you want to build a
full stack web application
439:39 - with a frontend, API,
and the backend database.
439:43 - You can find me on Twitter @MikeNikles,
439:45 - I'm also available on my
website at mikenikles.com
439:49 - where I have blog posts,
439:51 - I have links to open source
projects that I work on.
439:55 - So do check these out and also
have a look at www.gitpod.io,
440:01 - the underlying developer
environment that we use throughout
440:05 - the course where we spin
up a fully automated
440:08 - developer environment for each given task.
440:11 - And we then shut it down when we're done
440:14 - and move on to a new one
440:16 - the next time we work on an issue.
440:18 - Do check out these links.
440:20 - Let me know if there's
anything I can help you with,
440:22 - I would love to hear from
you, if you have feedback,
440:24 - please let me know.
440:25 - I'd love to make a full up
course or maybe something else
440:29 - to help spread the knowledge
440:32 - and let people learn from
the experience that I have.