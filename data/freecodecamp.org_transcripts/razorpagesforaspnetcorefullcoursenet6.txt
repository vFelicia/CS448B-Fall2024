00:00 - razor pages can make it even 
simpler to create web apps using  
00:03 - dotnet core. Brueggen Patel is an 
experienced instructor and he will  
00:07 - teach you how to create web apps 
using dotnet core and razor pages.  
00:20 - Hi, guys, and welcome to dotnet Mastery, my name 
is broken and in this course we will explore the  
00:26 - basic foundation of dotnet core web applications 
with razor pages, we will be using dotnet six and  
00:35 - Visual Studio 2022. For the short course dotnet 
core has been a buzzword for a while. And most of  
00:43 - the new development in dotnet is built on dotnet 
core and the current version is dotnet six dotnet  
00:50 - core comes with great features and advantages 
as compared to the previous versions of dotnet.  
00:57 - But for starters, let's take a brief overview 
at topics we will cover in this course,  
01:03 - whenever we learn any programming language, 
the first thing is basic foundation. So,  
01:09 - we will start with the fundamentals of ASP dotnet 
core application. Then we will take a look at what  
01:16 - is new on what are the changes in dotnet six as 
compared to the previous version. Once we have a  
01:23 - solid foundation in dotnet core files and folder 
structure, then we will take a look at Entity  
01:29 - Framework core that is what we will be using to 
interact or create our database project. Using  
01:36 - Entity Framework core and dotnet core, we will 
perform CRUD operations on a particular model.  
01:43 - When we do that, we will understand the client 
side and server side validations in dotnet core.  
01:49 - And we will display alerts using temp data that 
will give you a good foundation in dotnet core.  
01:57 - But the main thing that I will also include this 
error solving, I will display you common errors  
02:03 - and how to resolve them. That way you will gain 
more confidence in what you will learn. Lastly,  
02:10 - the application that we will build, we will deploy 
that to Azure along with the SQL Server. So with  
02:17 - all of that you will have a good starting 
foundation in dotnet core using razor pages.  
02:25 - In this video, let's take a look at what we 
will build in this course. From the URL here  
02:32 - you can see that the application is live on 
Azure, we will host our application on Azure  
02:39 - along with SQL Server. Then in the top navigation, 
we have a homepage and a categories page.  
02:46 - If you click on categories, we do not have any 
categories right now. So we can first click on  
02:53 - Create a Category button. And on this page, if 
you click the Create button without populating  
03:00 - any fields, we get error messages. These are 
client side validations right out of the box,  
03:08 - we also have a button to go back to the list. Then 
if we go back on Create Page and FA populate the  
03:14 - details in the category with just the name, 
we still have validation with display order.  
03:22 - We also have a custom validation that if name 
and display order are same, then we will also  
03:28 - display a custom error message. The error that 
you see this time is a server side validation.  
03:36 - Then if we have values that passes all the 
validation, and if we hit the create button,  
03:42 - we have nice alert to display the confirmation. 
We will be using toaster js for these alerts.  
03:50 - Then we have all the categories that we 
will be displaying in the table here,  
03:54 - we can edit them. And once we update them, 
we again have our alerts confirmation.  
04:02 - Lastly, we also have the Delete 
functionality with the alerts.  
04:07 - And then for the theme that we are using 
for styling, we are using boots watch theme,  
04:12 - and we will deploy our application to Azure. So 
you can see there are quite a few things to learn  
04:19 - in this small project. Let's get started with 
all of them from the next video. Let's take a  
04:26 - look at all the tools that we will use in 
this course. We will be using dotnet six  
04:32 - for our application. So make sure to install 
the latest version after unsex. For the IDE  
04:40 - we will be using Visual Studio. The version 
that I will be using is Visual Studio 2022.  
04:47 - There are lots of advanced features in 2022 
as compared to 2019. So you can always install  
04:54 - the free version of Visual Studio 2022 For 
our database We will be using SQL Server.  
05:02 - So first you will have to install SQL Server. And 
then you should install SSMS, which has SQL Server  
05:09 - Management Studio. If you have older version 
of SSMS, that's completely okay. As long as  
05:16 - you're able to connect to SQL Server on your local 
machine, we will be using that connection string,  
05:22 - and everything will work. So once you've 
installed all three of these software's,  
05:28 - let's continue from the next video. This video, 
I want to walk you through the journey of  
05:36 - dotnet core dotnet core is probably the biggest 
change that the dotnet language has encountered.  
05:43 - In 2002, Microsoft introduced webforms, 
which was a revolution at that time  
05:50 - webforms has its drawbacks, and there 
was a need to overcome I love them.  
05:56 - Because of that the dotnet team came up with 
a new architecture, which was dotnet MVC. Now,  
06:03 - even though I love MVC, and I have built 
many applications in MVC, it had its flaws,  
06:11 - like it was created on top of the components for 
web forms. Because of that, it was tied to IIS,  
06:19 - and ultimately, Windows operating system. But with 
the evolution of app development, Microsoft had to  
06:27 - keep up with the changing technology. Finally, in 
June of 2016, Microsoft released ASP. NET Core,  
06:35 - and it was the first version dotnet core is built 
on top of the new dotnet core framework, it is  
06:42 - completely rewritten and it is a cross platform 
version. Hence it is not tied with Windows.  
06:50 - Also dotnet core was built with cloud in 
mind. So it is extremely robust with that.  
06:57 - Then in August of 2018, Microsoft released dotnet 
core two, and the team has been active with  
07:04 - releasing new versions, there was a big change 
from dotnet 2.1 to 2.2, because we had to update  
07:12 - quite a few class libraries. And there were a few 
challenges. But since then, dotnet core team has  
07:19 - been releasing new versions with three point one 
and dotnet five, which was released in November  
07:27 - of 2020. After that, that is done at six which 
will be released in November of 2021. We will be  
07:35 - using the Preview version, but whatever we learned 
will be the same once dotnet six is released.  
07:42 - So this is a small overview of all the dotnet 
frameworks and their evolution. That being said,  
07:49 - why should when you start NET Core as compared 
to the classic dotnet dotnet core comes with  
07:56 - many advantages. First one is ASP dotnet core 
is fast and open source. If you compare that  
08:03 - to the traditional dotnet applications, that have 
been quite a few benchmarks, and it is very fast.  
08:10 - When you compare that to web forms, or even 
dotnet MVC dotnet core is also cross platform,  
08:18 - the classic dotnet was tied to IIS and Windows. 
But since the dotnet core is rewritten, it has  
08:25 - removed that dependency with dotnet core. We also 
have a built in support for dependency injection,  
08:33 - which saves a lot of time and it is extremely 
helpful. Once you get used with using dependency  
08:40 - injection, you cannot imagine your application 
without that. With any programming language,  
08:46 - it is critical that the new updates or the 
new version that are released, they should be  
08:51 - easily upgradeable and that is one of the feature 
with dotnet core when a new version is released,  
08:58 - updating to that new version does not have 
groundbreaking changes. Because of that you can  
09:04 - always keep up with the new versions. dotnet core 
is also cloud friendly. When the dotnet core was  
09:12 - being written cloud architecture was kept in mind. 
And because of that it is completely compatible  
09:19 - with all of the cloud components. And lastly, 
when it comes to performance dotnet core exceeds  
09:26 - all of the previous versions, and even the new 
versions in dotnet code that are being released.  
09:32 - They supersede the previous version. The code 
actually gets more optimized that results  
09:39 - into improved performance. The ASP dotnet core 
compiler will eventually optimize the entire code  
09:47 - whenever the code is recomposed using 
dotnet core framework dotnet course  
09:53 - actual performance is multiple times than any 
of the frameworks previous implementation.  
10:00 - because after that it is clear that Microsoft 
has a long term plan with dotnet code technology.  
10:07 - So with that brief overview, let's 
continue our learning in the next video.  
10:15 - In this video, before we take a look at the other 
files, I will introduce you to a new concept,  
10:21 - which is dependency injection. ASP dotnet core 
implements a simple built in dependency injection.  
10:29 - Container Dependency injection is an integral 
part of the ASP dotnet core architecture.  
10:37 - dotnet core injects objects of dependency 
classes through constructor by using the  
10:43 - built in IOC container. Before I show you 
what advantages dependency injection brings,  
10:50 - let's see a scenario where there is no 
dependency injection. In a typical application,  
10:56 - let's say we have three pages right now. And we 
have some common functionality that we want to use  
11:03 - across all the three pages. Like let's say we want 
to send emails, and we want to access our database  
11:10 - in all the three pages that we have. Now, 
let's imagine that on these three pages,  
11:16 - we need to access the database first. So 
what we will do is we will create the object  
11:22 - for database classes on all the three pages, we 
will have to open that connection, we will have  
11:28 - to do the database operation. And then we will 
have to close the connection in all the places  
11:34 - to do the same and create object for email 
implementation that we have in all the three  
11:40 - pages. So you can see this is a lot of duplicate 
code. On top of that, what happens in future,  
11:48 - if you change the implementation of 
how you access the database, or email,  
11:53 - based on the current configuration, you might have 
to make that change in all of the three pages,  
12:00 - which is a big mess, because right now it's three 
pages down the line, it could be 30, or 300 pages.  
12:07 - Another issue here is that on each page, 
you will deal with creating the object,  
12:13 - managing them as well as disposing them. And 
that will be a time consuming effort when we  
12:20 - have to do that in all the pages. So that 
being said, what is the solution to avoid  
12:26 - all of this and get an optimal architecture. The 
answer to all of that is dependency injection.  
12:34 - First, let me show how this scenario would look 
like. Again, we will have the three pages. And we  
12:40 - will have email and database functionality. These 
are the common things that we had before as well.  
12:47 - But now we will have something special, which 
is dependency injection container. So as you  
12:54 - can see, we have got our dependency injection 
container that will have an ID email and an IDE  
13:01 - interface and its implementation. So inside our 
container, we have the implementation of the eye  
13:09 - email interface and the IDB interface. When any 
page will need access to these functionalities, it  
13:16 - will just ask the dependency injection container 
to create an object of this functionality and  
13:23 - directly give page an object to use. So inside 
the page, we will actually be using an interface.  
13:31 - And then dependency injection does audits magic of 
passing the object when the website needs it, that  
13:39 - we do not have to deal with creating the object 
disposing or managing that object inside our pages  
13:47 - or pages will look very clean with just the 
interface all the instance and implementation will  
13:54 - be done by dependency injection container. Now in 
future if you want to change or replace the email  
14:01 - class, you do not have to make any changes in 
the pages, all you have to do is just change the  
14:07 - implementation inside the email class. And since 
we are registering that in the container, next  
14:14 - time when we build the project, it will take the 
new implementation. So you can see we only have to  
14:21 - change in one place. Now. That is one of the main 
advantage that comes with dependency injection.  
14:28 - Now in order to use dependency injection, you 
can use many third party tools. But with dotnet  
14:34 - core we have a built in dependency injection 
container and that has its own advantages.  
14:42 - So I hope that you have a short overview 
of how Dependency injection is helpful.  
14:50 - First thing that we have to do is we need 
to create a new project. So I have opened  
14:56 - up Visual Studio 2022 which will be the editor 
for this cores. Here. On the left hand side,  
15:02 - I have my previous projects. And on the right 
hand side, we have the options to get started,  
15:09 - we will click on create a new project. And 
we have lots of templates that are available.  
15:15 - We want to create a web application. So we can 
select that. And we want to go back with razor  
15:21 - pages. So that is the first option that is being 
selected. But if the first option in your case is  
15:28 - something different, scroll down and look for ESP 
dotnet core web app. It should only be web app,  
15:35 - and not the web app with models view and 
controller that you see down here. We are  
15:40 - working with only razor page application. So 
select that, and we will hit the next button.  
15:48 - Next thing that we can give our project is a 
meaningful name, we will call that as Abby. Now  
15:55 - here you'll notice there is a project name and 
a solution name. A solution can have multiple  
16:01 - project. Let's say we are working on Abby work 
project. So we can call that Abby web. And then  
16:07 - we can just change the solution to be happy. So 
all the projects that are related to Abby will  
16:14 - be inside the same solution. Next, let me change 
the location to where I want to save the project.  
16:20 - And we will hit the next button. Here we will get 
some more options on what is the dotnet framework  
16:27 - that we want to use. I will select dotnet six 
here. And next we have the authentication type.  
16:35 - Now if we want, we can select the prebuilt 
templates that are available with authentication.  
16:40 - But we want to start from scratch, we will 
select none here, I do not want any darker.  
16:47 - And let's hit the create a button that will 
create our project. And we will see all the  
16:53 - files and folder structures on the left hand 
side inside the window of Solution Explorer  
16:59 - in Visual Studio. Now by chance, if 
you close the window, do not panic.  
17:05 - You can reload that by going to views. And 
the first one here is Solution Explorer.  
17:12 - So now that our project is created, 
let's continue in the next video.  
17:19 - Now that the project has been created, you can see 
there are quite a few files and folder structure  
17:25 - on the right hand side. If you expand 
the Pages folder that will display all  
17:30 - the pages in our application. Before I 
dive into all the files and folder here,  
17:37 - let me run the application by clicking on this 
play icon with the project name, which is epi web  
17:45 - that will build your project and it will open up 
the browser with our website. So perfect on the  
17:52 - default page. Here you can see in the navigation, 
we have home and privacy page. On the home page,  
17:59 - we have a welcome text and the link that takes 
us to the dotnet core website. Let's go back to  
18:06 - our application. And inside the Pages folder, 
we have a page with the name of index.cs. HTML.  
18:15 - This is the home page of our application. You 
can see we have the same welcome text here and  
18:21 - paragraph that is displaying inside the default 
page. Now do not worry about the linking routing  
18:29 - files and folders or this page model or anything 
on top right here. We will walk through all of  
18:37 - them as we proceed with the course. But before 
anything, I want to walk you through one example,  
18:45 - inside the welcome here. Let's see if you 
change some text here, save this file and  
18:50 - go back. You do not see that change right here. 
To see that you will have to refresh the page.  
18:57 - And then you see that change. But after that if 
you make any change in the files here, and if  
19:04 - you save it go back, you can see we do not have 
to refresh. Let me show that once again. So if I  
19:11 - make a change, and as soon as I save it, you will 
see the website reloads and display the change.  
19:18 - That is because with dotnet six, we 
have something called as hot reload.  
19:23 - And that is a great functionality. Because now 
if you're designing something you make change,  
19:29 - it is automatically reflected in the view. 
So if this feature is not a neighbor,  
19:34 - you can see the red icon here if you take your 
mouse there it displays hot reload, you click on  
19:41 - the arrow icon and make sure hot reload on File 
Save is enabled. As long as that is enabled,  
19:48 - only first time you will have to refresh the 
application. After that if you save the changes,  
19:54 - it will automatically reload the page. And 
again this feature has been added to dotnet sex.  
20:02 - So if you're working with previous version, 
this will not work. for previous versions,  
20:08 - what you have to do is if you right click on 
the project, select Manage NuGet packages.  
20:14 - Inside the Browse tab, we had to install a new get 
package. So if I search for runtime compilation,  
20:21 - we have a package for Microsoft dot ASP NET 
Core dot MVC dot razor dot runtime compilation,  
20:30 - we had to install this package. 
And once you install that package,  
20:34 - we had to make a change inside the program.cs 
class file. So once that package has been  
20:41 - installed, if you go to program.cs class file, 
where we are adding the razor pages here,  
20:48 - we also had to add the razor runtime compilation. 
Now do not worry about this file. I will explain  
20:56 - everything here. But if you're working with a 
version before dotnet FFI, this is the change  
21:02 - that was needed. Now even though I recorded this 
course, in dotnet, six, when I was recording,  
21:09 - this feature was not available. So in the later 
videos on the razor pages, I will be adding the  
21:15 - Add razor runtime compilation. But you do not 
have to do that, because now we have hot reload.  
21:23 - And that takes care of the runtime compilation. So 
that being said, let me close all the tabs here.  
21:30 - Let's not save anything. And let's analyze all 
the files and folder structure in our project.  
21:37 - I just wanted to give you a 
quick sneak peek on hot reload.  
21:43 - This video, I want to give you a brief overview of 
razor pages. Razor pages have been introduced in  
21:51 - ASP dotnet core from the version 2.0. Razor 
pages is a new feature of ASP dotnet core  
21:59 - that makes coding page focused scenarios easier 
and more productive. In MVC we have models, views  
22:07 - and controllers. But inside razor pages, we have 
page and page model. So everything for that page  
22:14 - is isolated and condensed in one single location. 
That being said razor pages is not just for simple  
22:22 - scenarios. Everything that you can do with MVC 
you can do by using razor pages, like routing  
22:30 - models, action result, tag helpers, and so on. 
That is just a brief overview about razor pages.  
22:38 - But we will explore everything with razor pages 
in the future videos. Now that our application  
22:45 - has been created, let's take a look at the first 
file which will be the Project File Project file,  
22:52 - you won't be able to see that directly inside the 
files here, you will have to right click and we  
22:59 - have added project file. When we click here, 
you will see few options that are configured.  
23:06 - The first one here is the Property Group. And that 
denotes what is the dotnet framework that we are  
23:12 - using using dotnet six here and it is displayed 
there. Next what we have is the item group,  
23:21 - item group will have all of the new get 
packages that we will be adding in our course.  
23:27 - Right now we just added the Razer runtime 
compilation when we created the project, but in  
23:34 - future we will be adding more packages for using 
SQL Server Entity Framework core and much more.  
23:42 - Once we add that a new entry will 
be made inside the item group.  
23:48 - So that looks good for our project file. 
With that, let's continue in the next video.  
23:56 - style that we want to take a look 
is inside the properties folder.  
24:00 - We have launch settings dot JSON. This is the file 
that confidence how the application will be run.  
24:07 - And you can see there are multiple profiles that 
are added by default. We have an IIS settings  
24:14 - on the top which says that if you are using IIS 
express to run the application, that application  
24:21 - URL will be this and the SSL port will be 44317. 
If we expand the profiles here, we have to profile  
24:31 - epi ramp and IAS Express. These are the same 
profiles that you can see if you hover on the  
24:38 - down arrow icon right here. We have add the ramp 
and IAS Express. In order to run the website,  
24:47 - we can just hit this play button after selecting 
the profile. If we select IIS Express here  
24:54 - and run our website, it will launch the default 
application inside the Windows directly with the  
25:01 - 44317 vote number. Great, you can see that 
it's working. Now we're finished up this  
25:10 - and change our profile to happy Web. Let's 
expand that. You can see here it is command name,  
25:17 - which is project dotnet run messages, and we have 
application URL. So this will run our application  
25:25 - from command prompt. And from that 
command prompt, it launches the processor.  
25:30 - This time it is running on port 5001. So these 
are two different ways of running the dotnet core  
25:38 - application. Inside the profiles, we can have 
environment variable, and other configuration.  
25:46 - These are just two ways to run your application. 
And we can modify them inside the launch  
25:52 - settings dot JSON. The next thing that we 
have here is www root folder. And in there,  
26:01 - we have CSS, js, and lib folders. www root folder 
will be the root directory of your application.  
26:11 - That will be the directory that contains all of 
your static files. So if you have CSS, JavaScript,  
26:18 - images, PDF, files, libraries, all of them will 
go inside the www root folder. Inside this www  
26:29 - root folder, there will not be any code behind 
file with the C sharp code. It will only have  
26:36 - static files that will be used from the pages. 
So make sure whenever you add any static files,  
26:44 - it will go inside this www root folder. Next, 
what we have here is the Pages folder. And that  
26:52 - contains all the coding pages that are there in 
the application. We will come back to that in the  
26:59 - upcoming video. But the last file that I want to 
discuss in this video is the app settings dot JSON  
27:07 - file. Now what happens is in an application, 
you are using many third party API's, and then  
27:14 - you have to store some secrets. You can also have 
connection strings that connects to the database,  
27:20 - and so on. So all of those secret keys are 
connection that you have, you will add them inside  
27:27 - this app settings dot JSON file. As the name 
suggests, it is a JSON file, which will have key  
27:34 - value pairs. If you expand this, you will notice 
that it's app settings dot development dot JSON.  
27:41 - So you can have different app settings for 
different environment. For production, you  
27:47 - will have app setting start production dot JSON, 
and so on, then based on the environment variable,  
27:54 - it will automatically configure and 
use that particular app settings file.  
27:59 - This is really helpful because devlopment can 
have a different connection string to database,  
28:05 - as compared to preview, production 
or staging. So it is already built  
28:11 - in. And we will be adding our connection 
string in this file in the upcoming videos.  
28:18 - So with that, we have a brief overview of all the 
files other than the Pages folder, and program.cs.  
28:26 - Let's continue in the next video. Next we 
have program.cs. This is the file that will  
28:34 - be responsible for running the application. Once 
we open program.cs You can see we have a variable  
28:42 - builder where the web application dot create 
builder is passed with the built in arguments.  
28:49 - When you run with the dotnet command, you 
can pass custom arguments here if you want.  
28:55 - With that it will configure the application and 
it will create the Web Application Builder object.  
29:02 - Now in the previous video, we saw that we can 
use dependency injection with dotnet core. When  
29:09 - we want to register anything with our dependency 
injection container. We will be doing that right  
29:15 - here. So let's say if we want to register our 
database or email or anything else, we will have  
29:23 - to do that between the builder. And before we call 
build on that builder object. So right here we are  
29:30 - just adding one service to the container. We're 
just builder dot services dot add razor pages.  
29:38 - We are adding the razor pages to our container 
because we are building the website here with  
29:43 - razor pages. So we have to add that if you were 
using MVC, then this would be add controllers  
29:51 - with views. Now in the future videos when 
we configure database in our project,  
29:57 - and we add that to dependency injection We will 
be adding a new service here in our container,  
30:04 - our DB context. If you are working with any 
version prior to dotnet, six, or even some of  
30:11 - the initial preview versions of dotnet, six, 
then this file was divided into a separate  
30:18 - startup.cs class file. And the services that we 
add to Container were inside a method configured  
30:25 - services. And everything from line nine onwards 
was inside a configure method. So what we have  
30:33 - on the top is we will be adding services 
to our container, then we need to configure  
30:39 - request pipeline. And that pipeline will be 
configured from the highlighted section of  
30:46 - you might be wondering, what is this pipeline, the 
pipeline specifies how application should respond  
30:53 - to a web request. When your application 
receives a request from the browser,  
30:59 - that request goes back and forth through the 
pipeline. Let me switch to the presentation here.  
31:05 - We have different browsers here. And then we have 
a pipeline. The pipeline specifies how application  
31:13 - should respond to a request that is received. 
When your application receives a request from the  
31:19 - browser, that request goes through the pipeline. 
In the pipeline, you can add items that you want,  
31:27 - pipeline is made up of different middlewares 
razor pages is a type of middleware itself.  
31:34 - So if we want to build our website to be 
built with razor pages, we will have to add  
31:39 - the map razor pages to our middleware at the 
example could be authentication, middleware,  
31:46 - authorization, middleware, and so on. What exactly 
happens is when your request will go through each  
31:54 - of the middleware, it gets modified by them, and 
eventually it is passed to the next middleware.  
32:01 - If that is the last middleware in the pipeline, 
the response is returned back to the server.  
32:07 - Let's take a look at the few middlewares that we 
have in our application. Let me switch back to the  
32:13 - code here. And you can see in the pipeline, first 
we are checking if it is development or not in the  
32:20 - environment. If it is, then we are adding the 
use developer exception page that will show you  
32:26 - user friendly exceptions, so that you can debug 
and solve them. But if it is not development,  
32:33 - then we are just redirecting them to an error 
page. The next middleware is HTTPS redirection.  
32:42 - And then we have a middleware to use our static 
files that are defined in www root folder.  
32:49 - We also have a routing middleware, and we 
have authorization middleware. And we add  
32:56 - authentication to our project, we will have to add 
a new middleware inside the program.cs as well.  
33:04 - Then we have app dot map razor pages, this 
will configure the routing of razor pages,  
33:11 - and how the mapping will work in the 
application. Based on this routing,  
33:17 - it will be able to map the URL request to the 
corresponding pages inside our Pages folder,  
33:25 - then you should always keep in mind that 
order of pipeline is extremely important.  
33:31 - The way you write middlewares in the pipeline, 
that is exactly how the request will be passed.  
33:37 - So first of all thing will be done, then it checks 
for authorization, and so on. So in this scenario,  
33:44 - if you want to use authentication to 
your pipeline, we have a middleware,  
33:48 - which is app dot use authentication. 
But if you do this, then it won't work.  
33:54 - Because authentication middleware should always 
come before you authorize a user. Because you  
34:00 - only authorized a user that is authenticated. 
That is the basic fundamentals of authentication  
34:07 - and authorization. So if you place the pipeline 
in some different order, that will break things.  
34:15 - So with that brief overview of program.cs 
class file, let's continue in the next video.  
34:24 - One of the top level considerations for the tablet 
part of a server side web application framework is  
34:32 - how to match the URLs to the resources on the 
server so that the correct one processes that  
34:39 - request. The most straightforward approach is 
that you map the URL to the physical files on  
34:46 - the disk. And this approach has been implemented 
by the ASP dotnet team for razor page framework.  
34:55 - So the routing in ASP dotnet razor pages, maps 
URL browse to the physical file on the disk.  
35:03 - Now there are some rules on how razor page 
framework matches the URLs to the files,  
35:10 - and how it can be customized to give different 
results if needed. The first rule is that razor  
35:17 - pages needs a root folder. By default, the folder 
has been named pages, and its location is inside  
35:26 - the root folder of the web application. Also in 
that folder, we will have a default document,  
35:33 - which will be index.cs. HTML. So let's 
go back to our application and see this  
35:40 - in action. So the root folder is the Pages folder 
that you can see here. And if we expand that,  
35:48 - we have index dot CSS, HTML. Let 
me run the application here and see  
35:55 - what happens. Inside here, we are navigated to 
the homepage. The home page that loads here is  
36:02 - the default index dot css html inside the 
Pages folder. If we click on privacy here,  
36:10 - you can see the URL changes to privacy. And that 
page is present directly inside the Pages folder.  
36:19 - So the mapping of the URL is directly with 
the location inside the Pages folder. Now,  
36:26 - if we stop the application, and let's say we add a 
new folder here, I will call that as test. And let  
36:34 - me move privacy inside test. Let's click OK here. 
And let's run the application one more time. This  
36:43 - time, if you click on privacy, nothing happens. 
The reason is the URL that has been configured  
36:50 - inside the master page, which is underscored 
layout, let me show that. Here the ASB page  
36:57 - is defined that you have to look for a page, 
which is privacy directly inside the folder.  
37:04 - But that does not exist, because now we have 
moved that to a test folder. So if we go back  
37:11 - in order to navigate to the new location, it is 
simple, we just need to find out the exact path  
37:18 - from the Pages folder. So inside pages, we have a 
folder of test. Inside there we have privacy. If  
37:26 - we press enter, you can see it loads the privacy 
page correctly. So you can see routing has direct  
37:33 - mapping on how the files are exactly stored inside 
the Pages folder. Let me stop the application,  
37:41 - close everything. And let me move the 
privacy page back to the Pages folder.  
37:49 - I will also delete the test folder that we added. 
Let's go back to our presentation. And here I  
37:56 - have given some examples of how the mapping 
works. So if the URL is just www.domain.com,  
38:05 - it will map to the Pages folder and 
the default page index.cs. HTML.  
38:12 - If the URL is domain.com forward slash index, then 
it will map to pages forward slash index.cs. HTML.  
38:23 - And if it is domain.com forward slash account, 
then by default, it will first look inside  
38:30 - the Pages folder for a page with the name of 
account.cs. HTML. And if that does not find it,  
38:37 - then it will look into the Pages folder for 
an account folder. And in there, it will see  
38:44 - if there is index dot css html, which is the 
default page. So routing in razor pages is pretty  
38:52 - straightforward, as compared to MVC routing, 
where we have models, views and controllers.  
38:58 - Here in razor pages, it is direct 
mapping to how the files are stored  
39:03 - in the physical disk. So with that brief overview 
of routing, let's continue in the next video.  
39:12 - In the last video, we saw how routing works 
in razor pages. In this video, let me walk  
39:19 - you through all of the default pages that we have. 
Inside our Pages folder, we have one shared folder  
39:28 - that has underscored layout, which is the 
default master page of the application.  
39:34 - Here we have a header, we have a body where 
we will be rendering all of the other pages.  
39:41 - So they will have a header as well as a footer. 
We will also have all the CSS and JavaScript  
39:48 - that we want to include throughout all the pages. 
We can include them in the master page directly.  
39:57 - So what happens is inside render body we will 
actually render any code that we have. Inside  
40:03 - the other pages. Like we have index and privacy 
pages, you can see we are displaying some text of  
40:10 - welcome. And inside the privacy, we have the 
header here that we are displaying with privacy  
40:17 - policy. So if we run the application, again, let's 
examine what is the homepage. So inside homepage,  
40:25 - you see we have the header, we have the footer, 
and whatever text we are displaying right here,  
40:31 - inside the index page is displayed between the 
header and footer, as we have defined inside the  
40:39 - underscore layout. So all of the code that we have 
here will actually go inside the render body right  
40:47 - here. That's how master pages work. So that is our 
underscored layout page. Next, we have underscore  
40:56 - validation scripts partial. When a name starts 
with underscore, that is usually a partial view  
41:03 - on a partial page. Partial pages are like user 
components. They cannot be accessed via a URL,  
41:12 - but they are being called inside some other pages. 
So it's like a table that you want in 10 pages,  
41:19 - you just add that table in a partial 
view. And then you call this partial  
41:23 - view in all of these 10 files. And that table will 
automatically be populated. In this partial view,  
41:32 - we just have to script for validation. So in 
future, in whichever page we want validation,  
41:39 - we will be including this partial view. Also, 
it is a good habit to name your partial views  
41:46 - with an underscore and inside the shared folder. 
So it's easy to find them when we have to.  
41:53 - The next page that we have is underscore view 
imports. Here you can define the common namespace  
42:00 - that you have in your website. So let's say in 
any of the pages if you have to add the USING  
42:07 - statement many times you can define them in this 
file and that will be like a global declaration.  
42:14 - So once it is declared here, it is automatically 
available in all the other files. One thing that  
42:21 - you see here is we have added tag helpers. So 
because of that, we will be able to use the  
42:28 - built in tag helpers that the dotnet core team 
has provided. If we go to the shared folder,  
42:34 - underscored layout. And if we expand headers for 
navigation, we are using the ASP page tag helpers.  
42:43 - You can see we are not using the h ref tag here. 
To navigate within razor pages, we have something  
42:50 - called as a JSP page. The tag helpers for 
ESP. We'll start with ESP, and then hyphen,  
42:57 - and then the name of the tag helper. We can 
obviously create custom tag helpers if we want.  
43:05 - But the dotnet core team has provided 
all of the default tag helpers  
43:10 - to make programming super simple. We will 
take a look at more tag helpers as we proceed  
43:16 - with the course. But here we have added that 
globally in our application in view inputs,  
43:23 - that's why it will be available whenever we want 
to use them. The next file is view start.cs. HTML.  
43:33 - In this file, we will define what is 
the master page of our application,  
43:38 - you saw that underscore layout is being used as 
the master page. But that is because we have that  
43:44 - defined here. That underscore layout should be 
the master page. Now what you can do is globally,  
43:51 - you can have underscore layout as a master 
page. But on the individual razor page,  
43:57 - you can still use the same razor syntax and define 
a new master page. If you want, you can define a  
44:04 - different master page. But we will leave that 
with underscored layout. The next view our page  
44:11 - that we have is an error page. And this is the 
page that is used to display the error messages  
44:17 - when you face them in production application. 
Next, what we have is the index page right here  
44:25 - where we are displaying the text. Now you might 
be wondering if you're coming from web forms,  
44:31 - that with the files there was a code behind 
file. If you are coming from an MVC background,  
44:36 - you will be thinking where is the 
controller? Where does the C sharp code goes  
44:42 - with razor pages. We have a.cs file if you expand 
that right here. Now this is not a code behind  
44:50 - file. It is just the naming convention. Inside 
here you will notice we have the index model  
44:56 - and it inherits or implements the page model. Here 
we have an on cat handler. And we will have an on  
45:05 - post handler that we can add if needed. So here, 
what we have to do is when this page is being  
45:12 - called on cat, if we want to do something, we will 
update that inside the on cat handlers. In MVC,  
45:20 - we had action methods, but inside razor pages, we 
call them as handlers. So we have on get handler,  
45:28 - and on post handler, all of the code resides in 
these two pages itself. cshtml has the page or UI  
45:38 - code on what we have to display and.cs will have 
the backend code, where if you want to retrieve  
45:45 - some data, and pass that to the view, or page, we 
can do that, when we are working with razor pages,  
45:54 - that will be accurate page directive 
at the top. And that will be a model  
45:59 - that will be added here. This model you can see 
it is indexed model. And if you go to the.cs html,  
46:07 - that is the exact class name, it is indexed 
model. Based on that it automatically binds  
46:14 - both of this file. And it knows that this index.cs 
html.cs is the page model on the index razor page.  
46:25 - If this seems too much complicated, do not worry. 
When we start coding the application, everything  
46:32 - which start making much more sense. And similar to 
index, we have a privacy page and a privacy page  
46:40 - model. So those are all of the default pages that 
are available inside the Pages folder. With that,  
46:49 - let me close all of these tabs. And let's 
take a look@program.cs file in the next video.  
46:57 - With that, let me close all of the tabs 
here. And let's continue in the next video.  
47:04 - In this video, let's take a look at tag helpers. 
Tag helpers are brand new to ASP. NET Core.  
47:12 - Microsoft looked at the success around libraries 
like Angular, React, and decided that implementing  
47:20 - an Angular directive like experience in the new 
ASP dotnet was so important to the adoption of  
47:28 - dotnet core that they decided to create tag 
helpers from crowns up. Even though there are  
47:34 - similarities between Angular directives and tag 
helpers, there is a major difference. Tag helpers  
47:42 - are for server side rendering, while the Angular 
JS directives are all about client side rendering.  
47:50 - If you have worked with older versions of dotnet 
core, we had something called as HTML helpers.  
47:56 - They are still around a tag helpers are being 
modern with the tag like approach. So it's much  
48:03 - user friendly. Tag helpers are very focused around 
the HTML element and are much more natural to us  
48:11 - as compared to HTML helpers. We will be working 
with Tag helpers many times in the application.  
48:19 - But to just give you a brief overview, you can see 
in the first tab here we have HTML helpers, and  
48:26 - tag helpers simplifies all of them, because we can 
use the existing label tag. And we will just add  
48:33 - a Tag Helper as before. And we will find that to a 
model. We have same Tag Helper right here as well.  
48:42 - Then in the last example, here I am displaying tag 
helpers where previously we were using HTML dot  
48:49 - begin form. And now within the same form tag, we 
have the tag helpers of where it should be posted.  
48:57 - So you can see things are getting much more 
simpler when we are using Tag helpers. That  
49:04 - being said, if you're coming to dotnet, brand 
new, and you have never worked with HTML helpers,  
49:09 - this is even better. You do not have to worry 
about the old syntax and what is different.  
49:16 - We will be working with Tag 
helpers in the upcoming videos.  
49:20 - But I just wanted to give you a brief snippet 
of what tag helpers are and how they look like  
49:27 - when we are using the same tags, which is to use 
the ASP hyphen, and then the Tag Helper name.  
49:34 - That being said, we will explore all of this 
in much more details in the upcoming videos.  
49:42 - When you will be working with a dotnet 
core application, you will see the return  
49:46 - type of action result. And it does not 
matter if you're using an MVC application  
49:52 - or a razor page application. In both the cases 
you can see we have eye Action Result In MVC,  
50:01 - we are returning back view in this 
example. And in razor PAGE PAGE handler,  
50:06 - we are returning back to the page. But 
the return type is I action result.  
50:13 - I action result is a generic type that implements 
all of the other return types. Now, if you want to  
50:20 - be explicit about the return type in both of these 
cases, then that would look something like this.  
50:27 - If the return type is view, you can write View 
Result. But in razor pages, when we return back  
50:33 - to page, you can write page result. So now what 
is the advantage of action result? So first,  
50:42 - let's understand some theory. So, action result 
is a pattern class for many of the derived classes  
50:50 - that have associated helpers. The I action 
result return type is appropriate when multiple  
50:57 - action results return type are possible in 
an action. Let's take a look at some of the  
51:04 - helpers and action wizard. So first, let's 
take a look at what is there in razor pages.  
51:11 - A razor page can return content file, not 
found page a partial result, and redirect to  
51:19 - different pages. For all of them, we have returned 
types like content result, file content result,  
51:26 - not found result, page result, partial result, and 
so on. If you are working with an MVC application,  
51:34 - we can return back views, partial views, we can 
redirect to action, return JSON and so on. So  
51:42 - if you are returning any one of these, then you 
can use the individual return types for a result  
51:49 - based on the helper method. But what if 
you were returning something like this?  
51:55 - Right here in MVC, you can see we are returning if 
true, let's imagine that was some condition here.  
52:02 - Based on that if that condition is 
true, you want to redirect to action,  
52:07 - else you want to return to view this time you 
cannot have two different return types. If you  
52:14 - use View Result here, return view is working, 
but redirect to action will throw an error.  
52:20 - Similarly, if you use redirect to action result, 
then redirect to action works. But return view  
52:28 - will give you better if you are working on 
razor pages and you have the same situation.  
52:34 - If you use page result, and return page will 
work. But redirect to page will fail. And if  
52:42 - you use redirect to page result, then return page 
will fail. So what is the solution to all of this,  
52:50 - the solution is to use I Action Result input 
the places because this is a parent class. So  
52:57 - it does not care which of its implementation 
has been returned, it will be able to handle  
53:02 - all of them. So that is a brief overview on how 
action result will help us with the return type  
53:11 - from action method in MVC application or 
page handlers in a razor page application.  
53:20 - When we are working with any 
project, we first need a database  
53:25 - and that is the heart of the application. In 
this case, also we will have to add a database  
53:31 - and we will be doing that using SQL Server. But 
for database I will be using Entity Framework core  
53:39 - code first. And in that we create a model. And 
based on that model, we create a database table.  
53:47 - So first, we will have to create a model in 
our project. So we will create a new folder,  
53:53 - call it as model inside there, we will create 
our first class file, which will be category.  
54:04 - Inside this class, we will have to create all 
the properties for all the columns that we want.  
54:10 - In the table. Let's say we want three columns, 
we want name of the category we want to display  
54:17 - order. And the last one will actually be the most 
important one. All the tables require a primary  
54:24 - key. So we will be adding an ID column which will 
be identity column in SQL Server. What I mean by  
54:32 - that is when we create any record, we do not have 
to pass that ID, it will automatically increment  
54:38 - by one every time a new record is created. And 
that will be unique. So for all the three columns,  
54:46 - we will have to create three properties. 
The first one should be the primary key  
54:51 - so far that we will type drop here, which 
is a snippet to create properties inside  
54:56 - Visual Studio. So we type prop And we press tab 
two times, it creates an integer by default,  
55:05 - that's fine, we want to call that as ID. The next 
property that we want is name of the category,  
55:12 - which will be a string. And we will call 
that as name. The last one will be an integer  
55:19 - of display order. So with this, we have created 
a class, which will be our table in the database,  
55:27 - and it will have three properties, all three 
columns. Now, before we magically create the  
55:33 - table, we need to do some more configuration. 
Let's take a look at that in the next video.  
55:42 - We will be using Entity Framework core to create 
the table and populate details inside there.  
55:49 - But when we create a table, we 
need to tell Entity Framework core  
55:53 - that this column will be an identity column, and 
it will be a primary key. Let's say we also want  
56:00 - to add a validation that this name should be 
required and not null property inside database.  
56:07 - So how can we add all of those validations and 
requirements, we have many attributes that are  
56:14 - available to define all of the requirements. And 
all of them are defined inside data annotations.  
56:22 - So before the property here, we can give that 
an attribute inside a square bracket. The  
56:28 - attribute to make this column a primary key is key 
itself, you will have to press Control dot here  
56:36 - to add the USING statement. And you will press 
enter. Now by default, if a property name is ID,  
56:44 - Entity Framework core automatically makes it a 
primary key. So this is optional. But if your  
56:51 - name was something different, like let's say 
you wanted to make display order a primary key,  
56:56 - then you will have to explicitly 
say that, but if it is an ID,  
57:01 - and if you have not defined any primary key, then 
it will automatically set that as a primary key.  
57:09 - That is good to know. But I always like to 
explicitly define so that when someone opens up  
57:15 - that model, they can directly say which one is the 
primary key. Next, we want name to be required.  
57:23 - And for that we have an attribute which is 
required. That will make sure that name is  
57:30 - a required property when the SQL statement is 
created to actually create this category table,  
57:36 - which we will see in the upcoming videos. Right 
now things are pretty simple. We created a class  
57:43 - file, it has few properties, and be added some 
easy looking data annotations for our requirement.  
57:52 - How will we actually create this table and 
database that is the main question that we  
57:58 - will have to do some configuration, like adding 
a connection string to our SQL Server, adding  
58:04 - some new get packages. So that we can use Entity 
Framework core and SQL server without project.  
58:12 - Don't be overwhelmed. Let's get started by 
adding the connection string in the next video.  
58:20 - In this video, we have to add a connection 
string. So before we do that, let me open up  
58:26 - SQL Server Management Studio. Here the first 
thing that you require is a server name.  
58:33 - Now many times a dot will work for 
localhost. But if that does not work,  
58:38 - you can try local DB MSSQL local DB, whichever 
server name works for you where you can connect,  
58:46 - that is the one that you will use. I'm going 
to use just a tad because that is working. And  
58:52 - that's how I have configured SQL Server. I don't 
want the long one. So I will just use the dunk.  
58:59 - Once you are able to connect here to SQL Server, 
we will go back to our project. And we will add  
59:06 - our connection string. Now where exactly will be 
at that connection string. All of the settings  
59:13 - like secrets that you have in the application, 
you should add that inside app settings dot JSON.  
59:20 - If you examine we also have development here. So 
if you have more versions like production staging  
59:26 - preview, for each one of them, we might have 
different settings. So you can add different  
59:32 - settings inside the individual file. And based 
on the environment name, it will automatically  
59:38 - use the correct settings. For at localhost, 
we will use App Settings dot JSON.  
59:46 - So inside app settings dot JSON if you examine we 
have some key value configuration. We have a blog.  
59:53 - Inside that we have another blog. And finally 
we have key value settings. When we are  
60:00 - Working with connection string, we can directly 
create a key value pair right here. But connection  
60:06 - string is something that is common across 
all the application. That's why dotnet core  
60:12 - team has provided a special plug that you 
can use for connection strings if you want.  
60:18 - Using that will make things a little simple. 
But if you want to go with a custom blog, that  
60:24 - will also work, you will just have to put some 
extra effort to retrieve the connection string,  
60:30 - we will use the default connection string blog 
that is provided with dotnet core. And that is  
60:36 - connection strings. Once you press enter, 
then you will notice the curly brackets,  
60:42 - this means it is a block in there, 
we can write our connection string,  
60:47 - you can give that any key name that you want, 
I'm going to call this default connection.  
60:54 - And after a colon in the double quotes, 
you will write your connection string.  
60:59 - The first parameter here will be the server name 
you will write equal to and then whatever server  
61:05 - you are able to connect in SQL Server, 
copy that and write that here. I'm using  
61:12 - a.so That is what I will use, then we will add 
a semicolon, and we will add the database name.  
61:20 - You can call your database whatever you want, 
I'm going to use abi. Finally, we will have  
61:27 - the security, which is trusted connection is 
equal to drill. That's all that we need for  
61:34 - connection string. That Crusher connection 
is because I'm using Windows authentication  
61:40 - to connect to my SQL Server. So with that we 
have added connection string in our project.  
61:47 - Back we need to configure our DB context. So 
we can use this connection string and configure  
61:53 - Entity Framework core in our application. It might 
seem daunting in the beginning, but do not worry.  
62:00 - Once we set everything up, it will all make 
sense. Let's continue in the next video.  
62:08 - We have our connection string, 
we have our category model,  
62:12 - how do we add this model to database. In order 
to do that, we will require Entity Framework core  
62:19 - in our project. So you will right click on your 
project and you can select Manage nougat packages.  
62:26 - Once you go there, we will have to install the 
package inside the Browse. We will search for  
62:32 - Entity Framework core, we have the first package 
here and I have enabled the include pre release,  
62:39 - because right now dot 10 Six is in preview. So 
we will install that package in our project.  
62:46 - Now while we are here, I know we will be using SQL 
Server and that requires its own package as well.  
62:53 - So make sure you search for SQL and we 
have Microsoft dot Entity Framework core  
62:59 - dot SQL Server. Now when you install nougat 
packages, if you are using the Preview version,  
63:05 - or even if you are using the older version, always 
make sure that all the packages in your project  
63:12 - must be of the same version. If you install one 
package in Preview seven and other in previous  
63:18 - six, it might not work or if you installed one 
package in dotnet five and other in dotnet six,  
63:25 - it still might not work so it has to be the same 
version or else you might face issues later on.  
63:33 - That being said I will install both the nougat 
packages, so that we can add the configuration  
63:39 - of Entity Framework core in our project perfect 
we will close the nougat package manager and  
63:46 - now we need to create a DB context so that we can 
interact with Entity Framework core for database.  
63:53 - So, inside the project, we will 
right click add a new folder for data  
64:01 - inside there we will have to create our 
class file for accessing the DB context  
64:07 - you can call this anything you want. I like to 
call that application DB context. Now this file  
64:14 - will implement the DB context or it will be like 
a data layer that will connect our application  
64:20 - with the database. So it must implement the DB 
context class inside Entity Framework core. So  
64:28 - we will add a colon here and we will write DB 
context. Now you will see the red squiggly lines  
64:35 - because it does not find or does not know what is 
this DB context. If you press Control dot here,  
64:42 - you will see the USING statement inside 
Microsoft dot Entity Framework core  
64:47 - and DB context is defined inside the Entity 
Framework core to access and manage the database.  
64:55 - When we are creating a DB context, we need to 
get the connection string As options, then once  
65:02 - you have configured this, inside this class, we 
will be creating DB set for all the tables that  
65:09 - we found in our database. So the first table that 
we want is the category model that we created.  
65:16 - So in order to create that table, you will have 
to create a DB set. So we will say public DB set,  
65:23 - we will write the model name, which is category, 
you will have to press control.to Add the USING  
65:29 - statement. And then here, whatever name you give 
will be the name of the actual database. I will  
65:37 - call it the same category. And we will have getter 
and setter. So here, if you named it category one,  
65:45 - your table name will be category one. So this 
is actually the name of the table that you want  
65:52 - inside your database, or application DB context 
looks good. But we need to do one thing,  
66:00 - we have a DB context in our project. And 
we have connection string inside our app  
66:06 - settings dot JSON, we need to configure this DB 
context to use our connection string. That way  
66:13 - it will know how it can connect to the database. 
Let's see how we can do that in the next video.  
66:22 - Now we need to add the connecting bridge 
between our DB context and connection string.  
66:28 - So we need to tell our application that, hey, 
you need to use this application DB context to  
66:34 - interact as a DB context. And you have to use 
the SQL Server with connection string that is  
66:41 - inside app settings dot JSON. So all of that 
mapping will be done inside program.cs where we  
66:49 - are adding services to the container. The reason 
we are adding that as a service here is once we  
66:56 - add it here, we can extract that and use it with 
dependency injection throughout the application.  
67:04 - So we will be adding DB context as a service in 
our application. Previously, in dotnet, five,  
67:12 - all of this was done inside startup.cs class file. 
But starting with dotnet, six, they have combined  
67:19 - with the startup and program.cs into one single 
file. So here we are adding all the services  
67:26 - to the container. And then we are configuring 
the request pipeline. So now we no longer need  
67:33 - multiple files, everything is much cleaner. 
So in order to add service to our container,  
67:40 - we will say builder dot services. And the 
service that we want to add is dB context.  
67:47 - So we want to configure the DB context, which 
expects a class name. So here we have to tell that  
67:54 - which class in our application is implementing 
DB context. That is application DB context.  
68:03 - Once you write that, you will press control.to 
Add the USING statement for ABI web dot data.  
68:11 - Then here, we have to pass the options. 
So we'll say options here goes to.  
68:17 - And we will say options.we have used SQL Server 
inside the Entity Framework core namespace. That  
68:27 - way, we are saying that for this DB context for 
database, we want to use SQL Server. And inside  
68:34 - here, we have to give the connection string. 
Now how can we extract our connection string  
68:40 - from App Settings dot JSON. I said before that 
connection string is a special block that is given  
68:47 - by the dotnet core team. So that's why they 
have given a special method to access all  
68:53 - the key values inside that special block. You 
can do that by using builder dot configuration  
69:00 - dot they have given a method get connection 
string that will look for a key name inside  
69:07 - app settings dot JSON. So inside connection 
strings, what is the key name we should look for?  
69:14 - We should look for a key with the name of default 
connection and we want its value. So we will copy  
69:21 - default connection and paste that in the key 
name. When we use get connection string that  
69:28 - will actually retrieve the connection 
string and configure our DB context.  
69:34 - Now here you can see that application DB context 
we are passing the options. So inside our class  
69:41 - where we have the application DB context, we 
should retrieve that options and pass that  
69:47 - to the base class of DB context. So here we will 
have constructor using the snippet CT or our TAB  
69:55 - TAB. And with this class, we will receive DB 
context options on application DB context.  
70:06 - We will call that as options. And all we want 
to do is pass that on to the base class of DB  
70:13 - context. Pretty simple and straightforward. But 
this line of code is very critical. If you do not  
70:21 - do that your connection will not work. Now, right 
now, it might seem that we are doing lots of magic  
70:28 - things with setting up application DB context, 
some code in program.cs. And we are retrieving  
70:35 - our connection string from the app settings. But 
this is very basic connection that you have to do  
70:42 - with all dotnet core applications, when you 
want to use and configure Entity Framework core.  
70:48 - So this can be treated as basic steps that you 
should remember and memorize. But what we are  
70:55 - doing inside program.cs, we are just adding 
items to the container, so that we can extract  
71:02 - and use with the help of dependency injection. As 
we proceed with the course dependency injection  
71:09 - will make much more sense. And you will 
see how easy it is by adding things to  
71:14 - dependency injection to extract when we want 
to use them. So with that basic configuration,  
71:22 - we are almost there. Next thing we have to 
do is we just need to create our database,  
71:28 - we have all the configuration that is ready. Let's 
see how we can accomplish that in the next video.  
71:37 - Now we need to add the connecting bridge between 
our DB context and connection string. So we need  
71:43 - to tell our application that, hey, you need 
to use this application DB context to interact  
71:49 - as a DB context. And you have to use the 
SQL Server with connection string that  
71:55 - is inside app settings dot JSON. So all of 
that mapping will be done inside program.cs,  
72:03 - where we are adding services to the container. 
The reason we are adding that as a service here is  
72:10 - once we add it here, we can extract that 
and use it with dependency injection  
72:16 - throughout the application. So we will be adding 
DB context as a service in our application.  
72:24 - Now previously, in dotnet, five, all of this was 
done inside startup.cs class file. But starting  
72:31 - with dotnet, six, they have combined both startup 
and program.cs into one single file. So here we  
72:39 - are adding all the services to the container. 
And then we are requesting or configuring.  
72:46 - And then we are configuring the request pipeline. 
So now we no longer need multiple files,  
72:52 - everything is much cleaner. So in 
order to add service to our container,  
72:58 - we will say builder dot services. And the 
service that we want to add is dB context.  
73:05 - So we want to configure the DB context, which 
expects a class name. So here we have to tell that  
73:13 - which class in our application is implementing 
DB context. That is application DB context. So  
73:22 - you will press control. Once you write that, you 
will press control.to Add the USING statements for  
73:33 - add the web dot data, then here, we have to pass 
the options. So we'll set options here goes to  
73:38 - and we will say options.we have used SQL 
Server inside the Entity Framework core  
73:46 - namespace. That way, we are saying 
that for this DB context for database,  
73:52 - we want to use SQL Server. And inside here, we 
have to give the connection string. Now how can we  
74:00 - extract our connection string from App 
Settings dot JSON. I said before that  
74:05 - connection string is a special block that 
is given by the dotnet core team. So that's  
74:11 - why they have given a special method to access 
all the key values inside that special block.  
74:18 - You can do that by using builder dot configuration 
dot they have given a method get connection string  
74:25 - that will retrieve all the that will look 
for a key name inside app settings dot JSON.  
74:32 - So inside connection strings, what is the key 
name we should look for? We should look for a  
74:38 - key with the name of default connection and 
we want its value. So we will copy default  
74:44 - connection and paste that in the key name. When 
we use get connection string. That will actually  
74:55 - that will actually that will actually retrieve the 
connection string and configure our DB context.  
75:02 - Now here you can see that application DB context, 
we are passing the options. So inside our class,  
75:10 - where we have the application DB context, we 
should retrieve that options, and pass that to the  
75:16 - base class of DB context. So here, we will have 
constructor using the snippet CT or our cap tab.  
75:28 - And with this class, we will receive DB 
context options on application DB context.  
75:38 - We'll call that as options. And all we want to do 
is pass that on to the base class of DB context.  
75:46 - Pretty simple and straightforward. But this line 
of code is very critical. If you do not do that  
75:53 - your connection will not work. Now, right now, it 
might seem that we are doing lots of magic things  
76:00 - with setting up application DB context, some 
code in program.cs. And we are retrieving our  
76:07 - connection string with apps from the App settings. 
But this is very basic connection that you have to  
76:14 - do with all dotnet core applications, when you 
want to use when you want to use and configure  
76:22 - Entity Framework core. So this can be treated as 
basic steps that you should remember and memorize.  
76:29 - But what we are doing inside program.cs, 
we are just adding items to the container,  
76:36 - so that we can extract and use with 
the help of dependency injection.  
76:42 - As we proceed with the course dependency injection 
will make much more sense. And you will see  
76:48 - how easy it is by adding things to dependency 
injection to extract when we want to use them.  
76:57 - So with that basic configuration, we are 
almost there. Next thing we have to do is we  
77:03 - just need to create our database, we have all the 
configuration that is ready. Let's see how we can  
77:10 - accomplish that from the next video. In the next 
video that all the configuration is done, let's  
77:19 - finally create our database. Let me switch back to 
SQL Server. And here if you examine the database,  
77:26 - we do not have any ABI database. So we have 
connection string and everything in place.  
77:33 - In order to make connection with Entity Framework 
and actually create SQL, we will be adding  
77:40 - migrations, what migrations will do is it 
will see that inside application DB context,  
77:47 - we have a DB set on category. So it will write a 
script to actually generate SQL that will create  
77:54 - this table it is pretty fancy and everything 
is optimized. Let me show you how we can run  
78:01 - migration first, and then it will make sense 
there are two commands that you should remember.  
78:08 - In order to run migration, we will go to Tools 
NuGet package manager and Package Manager console.  
78:16 - Inside here, we will have to write a 
command to actually create migration  
78:21 - and that command is add migration and we have 
to give our migration a meaningful name. So we  
78:28 - will call this Add category to dB that is what 
we are doing, we added just category inside  
78:35 - our application DB context. So let me press 
Enter. And let me show you what error we get.  
78:44 - We get the error the term add migration is 
not recognized. Now you remember we added  
78:50 - NuGet packages of Entity Framework core and SQL 
server one more NuGet package is needed for this,  
78:57 - I want you to search this error and 
find out what is the nougat package.  
79:03 - Okay, I hope you were able to 
do that. If you just copy this,  
79:09 - go to Google paste that the first one here if 
you scroll down, there should be the package name  
79:15 - right here. So, these are small things that 
you will run into when you are developing.  
79:21 - And you should always take Google as your 
first help station because it is possible  
79:27 - that someone else has faced this error and 
that will help you. So you will search for  
79:33 - that new get package. Make sure the version 
is same and you will install that for a  
79:42 - fact that is done. Let me close that. We will 
go to package manager console and run the same  
79:48 - command one more time. This time it will create a 
new folder of migration in your solution explorer  
79:56 - and load the migrations. Great You can see a 
new migration has been created. And there is  
80:03 - a new folder with the name of migration. So let's 
analyze on what we are doing inside the migration.  
80:13 - You can see we have an up method and a down 
method. Down method is basically rolling  
80:19 - back the changes that we are doing if something 
fails. So let's ignore that. Insert the up method,  
80:26 - we have migration builder, and we are saying 
that create a table with the name of category.  
80:33 - In that table, we want columns, the first 
column will be ID column of type integer  
80:39 - nullable is false. And make sure that it is a SQL 
Server identity column. You can see with the key  
80:47 - attribute, it is configuring everything for us. 
And the next column name it is saying that make  
80:53 - sure that is not a nullable column. That is what 
we added as required. The last column is display  
81:01 - order, that is also nullable. False, but the 
reason behind that is it is of type integer.  
81:08 - And then in the constraint, you can see we have a 
primary key on the ID column with the name of PK  
81:15 - underscore category. So here you can see it is 
doing everything that we wanted, you won't be able  
81:22 - to see the raw SQL that is being executed, but it 
is optimized. But in order to run this migration,  
81:30 - and see the table in database, we need to add 
one more command. So tools NuGet Package Manager  
81:38 - console, and the command is update database. Let's 
press enter. What it does first is it will check  
81:47 - at that connection string does that database 
exist. If it does, then it will just push the  
81:53 - migration that we added. If it does not, then 
it will create that database. And then it will  
81:59 - run the migration. So now the database should be 
created. And in there, we will have two tables.  
82:07 - We have our category table, which will 
have the three columns that we created.  
82:12 - Perfect. And we have a table which keeps track 
of all the migrations that have been applied.  
82:19 - So let's examine the EF migrations history. 
And you can see it has the migration ID,  
82:25 - which is name of the migration that you 
can see here, and the product version.  
82:30 - That way Entity framework code knows that this 
migration has already been applied. So next time,  
82:36 - when you run the command update database, it 
will not reapply this migration, pretty smart to  
82:42 - track everything that has been done with Entity 
Framework. So great with that our database has  
82:49 - been created successfully. Let me close everything 
here. And let's continue from the next video.  
82:58 - Now we have our category table that has been 
created inside the database. So what we want to do  
83:05 - is we want to create a new page where 
we can display all the categories. When  
83:11 - we are working with razor pages, it will be 
inside the Pages folder as compared to views  
83:17 - in MVC. So inside pages, we have the homepage, 
which is index.cs. HTML. We want to create  
83:26 - pages for listing all the categories, creating 
category, editing category and deleting category.  
83:33 - Rather than cluttering everything in one 
place, we will create a new folder inside  
83:38 - pages. I will name the folder as categories. 
And in there, we will create a new razor page.  
83:46 - The first page that we want to create will be 
used to display a list of all the categories.  
83:52 - So we can name that as index, we will select 
the razor page empty here, because we want  
83:59 - to start with a clean and empty page. Rather 
than working with a template. So select Empty,  
84:06 - and we will hit Add Button name of the razor 
page, we will keep that as index.cs html.  
84:14 - Let's add them. As soon as you add that you will 
notice two files were added. One is the CS file.  
84:22 - And we have the CS HTML the.cs file will 
be the file where we have page model  
84:29 - for our index page. You can see the model that 
is being referenced here is inside ABI web pages,  
84:36 - categories index model. And this particular 
namespace will be the namespace that you see on  
84:43 - top here. So that is how it is binding everything 
together. And we have our class index model.  
84:51 - Now we use Entity framework code to add 
migrations to create our category table,  
84:56 - which was inside model and our DB 
context. was application DB context,  
85:03 - inside program.cs. We've registered that service 
in our container. Since we have registered the  
85:10 - service, whenever we have to access database, we 
do not have to create a new object of application  
85:17 - DB context. What happens here is the service 
is already available in the container. So we  
85:24 - just need to tell our container that, hey, I 
need to use the DB context to access database.  
85:30 - So give me an implementation of this class. How do 
you do that, that will be done using constructor  
85:37 - inside the CS file, we need to create a read 
only application DB context. And we'll add  
85:44 - the USING statement. I will call that underscore 
TB. Now we want an implementation of this class  
85:52 - using dependency injection. That will be 
done inside constructor. So we'll type C  
85:58 - to our class tap twice. This is a snippet to 
create constructor quickly in Visual Studio.  
86:06 - Now, if you have registered anything inside 
the container and you want its implementation,  
86:11 - you simply tell here the implementation that 
you want. So we will write that we want an  
86:16 - implementation of application DB context and give 
that to us in a variable with the name of dB,  
86:24 - we will assign our private variable which is 
underscore dB, the value of dB. So now our  
86:30 - underscore DB will have an implementation 
that already connects to the database.  
86:36 - And we can use that inside the onCreate method, 
we need to retrieve list of all the categories.  
86:44 - In order to retrieve that, we need to create a 
property that will hold all the category list.  
86:51 - So on top here, we can create an IEnumerable on 
category. And let's call that categories. Next  
86:59 - thing that we have to do is we need to populate 
this Categories list. So this we need to populate  
87:05 - from the database. So we'll say underscore dB. 
And with Entity Framework core, when you write  
87:11 - dot here, it will display all of the tables or DB 
sets that we added. So if you scroll down here,  
87:19 - you should see the category DB set that we 
added. So we want to retrieve underscore DB  
87:25 - dot categories. This will retrieve all the list 
of categories. We did not have to write any fancy  
87:33 - SQL like select star from Categories table, we 
did not have to open a connection, we did not  
87:38 - have to close connection, no cleanup was needed. 
Entity framework code takes care of everything.  
87:45 - And we just access DB context. And then on 
category, we have multiple methods to create,  
87:52 - update, delete, and much more. But if 
you just say underscore DB dot category,  
87:57 - it will automatically retrieve all of the 
categories and store that in this way the table  
88:05 - I get method looks good inside the 
index page model for categories.  
88:11 - Now what I want to do is inside shared, we have 
underscored layout, we can navigate to two pages,  
88:18 - we have index and privacy. Rather than privacy, 
I want to navigate inside the categories folder,  
88:25 - we have the index page. Since we want to 
go in folder, we will not use the forward  
88:32 - slash we can directly say categories. And 
then forward slash what is the page name  
88:38 - that is index. So here we have to use the 
exact graph that we have in folder structure.  
88:45 - If you were using MVC, you have controllers 
and action method. But with razor pages,  
88:51 - everything is simple. The actual way in which the 
folders are organized will be the exact route.  
88:58 - So routing is pretty simple in razor pages, we 
will change the link here to display categories.  
89:06 - And let me save this run the application.  
89:12 - Right now it is running things using the ABI web 
profile. But we will change that to IIS express in  
89:19 - just a second. But if we go back, we have the 
Categories tab here. And you can see the URL  
89:25 - in the bottom left. It displays the categories. 
Let's hit this button and see what happens.  
89:33 - We see an index page here, but no data is 
displayed. We don't want to work with data  
89:39 - right now. Let's go to our code behind 
here. And let me add a debugging point.  
89:45 - Let's go back and let me just refresh the 
page. We hit our breakpoint. If I press F 10  
89:52 - It will take us to the next line. And then if 
we examine what got populated in our categories,  
89:59 - it will be empty, because we do not have 
any records. So it yielded no result. Let  
90:06 - me add a breakpoint on this line, remove the 
one before. And let me switch to SQL Server,  
90:12 - we can keep our application running. Actually, 
I can hit the Continue button to go back.  
90:18 - inside SQL Server, let me expand the database 
tables. Let's directly edit the top 200 rows.  
90:27 - Let me create a name, test and display order to. 
So we have one record in our database. Now, if we  
90:35 - go back to the application, and hit categories 
one more time, it hits our breakpoint again,  
90:41 - this time, we should see one record 
that is being retrieved. And perfect,  
90:46 - we see all the details populated. So with that, 
you can see we are successfully able to retrieve  
90:53 - all of the records four categories from database. 
In the next video, let's work on displaying these  
91:01 - categories inside the index page right here. Now 
that we have seen how to retrieve the categories  
91:09 - inside the get handler, we need to 
actually display that in the razor page.  
91:15 - So if we go back to index.cs, HTML, this is the 
index of categories and not off the main page.  
91:23 - So inside the index of categories, we want to 
display all of the categories. If you have only  
91:30 - worked with web forms, and never work with razor 
pages, inside razor pages, you can have HTML code  
91:36 - as well as C sharp code. So you can have if else 
you can create variables, assign them values,  
91:43 - as well as HTML directly at one place. So let 
me add a div here give it a class of container  
91:52 - and I will give it padding three. These are just 
bootstrap classes to creating a container. And  
91:58 - inside there we will create a row. So we will give 
it bootstrap class of row padding top of four.  
92:05 - This will be one row on the complete screen. Now 
that one row we want to divide into pieces. First,  
92:12 - on the left hand side, I want to display a title. 
Since bootstrap divides that row in 12 parts,  
92:19 - if we want to divide those 12 parts into two 
pieces. For the left hand side, we will have six  
92:24 - PS, and right hand side we will have six PS. So we 
will have div here, give it a class of column six.  
92:33 - To combine the first six pieces in one single 
element. Here we will display an h2 heading, and  
92:41 - we will give it a bootstrap class of text primary. 
We want to display here the heading which is  
92:48 - category list. That looks good. Here we will have 
the later part, which is div of class column sex.  
92:58 - And we will add buttons inside this div later on. 
This looks good. Let me add some space. So two br  
93:06 - tags. And then we want to add a table to display 
our categories. So we will use a table tag.  
93:13 - Inside this table, we will have a T head for 
header. Inside the head, we will have TR n th  
93:21 - tags. This is just HTML tags that we are 
working with. Inside the first heading,  
93:27 - we want to display the category name and 
inside the next year we want to display  
93:33 - the display order. Now that is good for 
the headings, we want to have a body where  
93:39 - we will be displaying the actual values. 
Now if we have 10 entries inside category,  
93:46 - inside T body, we will have a TR tag and TD 
just like we have the edge inside the heading.  
93:54 - Here we want to display the actual value of 
category name. And then we will have another  
94:00 - TD which will have value off display order. Now 
if we have 10 categories inside database, we want  
94:09 - this TR to repeat 10 times because we want to 
display all the category name and display order.  
94:16 - So if you were working with C sharp you would 
be using for each loop. We will do the same  
94:22 - right here. In order to use a C sharp code we 
need to add sign and then we can just write for  
94:29 - each statement. With for each we need an object to 
iterate. So we will say variable obj in and what  
94:37 - we want to iterate on will be inside our index 
model. This index model represents what we have  
94:45 - in the CS file. In order to show you if you right 
click here. And if you click go to definition,  
94:52 - it takes us here and you can see in here 
we have the variable four categories.  
94:58 - So we can access this cat categories. Since it 
is an IEnumerable, we will iterate through that.  
95:04 - Because inside the cat, we are already populating 
that categories. So we should be good. So back to  
95:11 - the UI, we want to iterate over that I enumerable 
of category. To access this model that we have  
95:19 - right here, inside the lowercase m, we will have 
to use a key word, which is model, but this time,  
95:26 - the M will be capital. So whatever we 
have inside the smaller case model here,  
95:32 - anywhere inside the view, or page, if you want 
to access that, you will use the capital M model.  
95:39 - So if you press model dot, you can see all the 
models that are available inside the CS file. So  
95:47 - we want to iterate over the model dot categories. 
And we will have a curly bracket here. So each  
95:54 - categories inside the model categories will have a 
temporary name of Obj. This is how for each works.  
96:02 - So for each one of the object, we want to display 
a TR tag, and we want to display the values to  
96:10 - display value, we need to access the obj variable 
right here. So again, we will use the Add sign  
96:17 - obj dot, and we will see all the properties that 
are available. We want to select name from there.  
96:25 - The next one that we have is display order. 
So we can say obj dot display order, we will  
96:33 - add some width on both the td tags. With that in 
place. Let me save this and run the application.  
96:43 - If we go to our categories, we 
have the category list heading.  
96:47 - And we have a table here. But I want 
to give it some bootstrap classes.  
96:52 - So we can go back and on the table tag right 
here, we can add class is equal to I will add  
97:00 - three bootstrap classes of Table Table bordered 
and table striped. Also, I will give it a style  
97:07 - of word 100%. Now when we are making changes 
inside CSS, or even anything inside the UI side  
97:16 - of cshtml, once we save it, we can go back and 
actually refresh, and it should make those changes  
97:23 - visible. But right now it is not working. We 
already added the razor runtime compilation  
97:30 - for this particular package. But the reason 
that is not working is right now there is a bug,  
97:36 - and you have to manually add a statement. So for 
that, we will have to go to program.cs where it  
97:44 - is adding the razor pages, you also have to add 
a command here, add razor runtime compilation,  
97:52 - they should have been done automatically, because 
we selected the razor pages. But I believe since  
97:58 - dotnet six is in preview, they will fix this down 
the road. But if this is not present, at that end,  
98:06 - let's run the project one more time. If you go 
to categories, now, you will see a nice table.  
98:14 - With this, you can see how we are able to display 
all of the categories inside our razor page that  
98:20 - we created. If you examine the URL, here it is 
only categories and not index. Because index is  
98:28 - there by default. If you write index manually and 
press enter, it will load the same page. Perfect.  
98:36 - With that, let's continue in the next 
video. But before that, let me change  
98:40 - the setting here to use IIS Express. That way, 
we don't have the command prompt every time.  
98:50 - Our index page is working as expected 
for categories. And inside the CSS file,  
98:56 - we have the get handler. Before I proceed 
on the next test to create a category,  
99:01 - let me switch back to database here. And we will 
write a query. So select top 1000. And let me just  
99:08 - delete the record. So we'll delete the category 
that was present. And now there is no categories.  
99:16 - And once we make that change, if we go back 
and run the application, perfect, everything is  
99:22 - clean. Now I want to add a button here to create 
a category. We have not added that page right now  
99:30 - that we do that. Let's go back to one index here. 
And we'll have to space inside the right hand side  
99:37 - of the category list. So we want an anchor 
tag. Now we want to go to a new page that  
99:44 - we will create inside the categories folder with 
the name of create so far that that tag helpers,  
99:52 - the tag helpers that we want to use here 
is ASP page. If you were working with MVC,  
99:58 - then you will use actually and controllers. But 
with Razer pages, everything will be ASP page,  
100:06 - we want to navigate to a new page with the 
name of create. Since this is inside the  
100:12 - same folder of categories, we do not have 
to explicitly mentioned here the categories  
100:18 - before create page, it will understand that by 
default, so we want to go to a new page of create.  
100:26 - And we want to give it a class of btn btn 
primary inside the anchor tag, we want to  
100:33 - display create row category. Now the application 
is running and we enable the laser runtime.  
100:41 - So if you do AVX, five at your display the button 
if you click here, nothing happens. This does  
100:48 - not mean that your link is broken. Nothing is 
happening here because that page does not exist.  
100:55 - If this was an MVC application, it will take you 
to a page not found. But with razor pages it has  
101:01 - different if the link is broken, it does not 
display or not found, it will just stay there.  
101:08 - So in the next video, let's create the 
new razor page to create a new category.  
101:16 - Just like we added the index page to list all 
the categories, we need to add a new razor page  
101:22 - inside the categories folder to create 
category. So with an add new razor page,  
101:28 - empty looks good. This time, you have to call this 
ask create. You can see here we are creating a  
101:36 - razor page and not a razor view. Razor views 
are used in MVC application and they do not  
101:43 - have a page model. We will create a razor page and 
let's hit the Add button. This time the model you  
101:51 - can see it is create model. And if you examine 
the.cs You will see the class is create model.  
101:58 - So that is how it links both of the file. Now 
right now we have the on get handler. Inside the  
102:05 - on get handler of index we are retrieving all 
of the categories to display inside the page.  
102:12 - When we are creating a category, we do not have to 
populate any information. Inside the Create Page,  
102:18 - we will just have an empty text box for user to 
enter the display order and name of the category  
102:25 - so that will be empty. Since we do not have to 
do anything inside the on cat. Let's work on  
102:32 - the view itself. Inside view we will have a form 
in which user will enter name and display order  
102:39 - and they will hit the submit button. So we will 
have a form tag here. This will be a method post.  
102:47 - Then we will add some bootstrap classes,  
102:50 - we will add a div give it a class of 
border padding three margin top of four.  
102:57 - Inside there, I will add another div give it a 
class of row and padding bottom of two. And I  
103:05 - will just add a heading h2 that will display 
create category and an HR for a horizontal  
103:12 - line. After this div, I will add another 
div give it a class of margin bottom three.  
103:21 - And in here we want to display the label which 
is name. And then we want an input field of type  
103:28 - text. I will copy this and paste it one more 
time. Next property that I want is display order  
103:37 - and type will be text. Of course in HTML, 
you remember we give that some named like  
103:43 - display order. The first one here, we 
can give it a name of category name.  
103:49 - After that, we will have a button of type submit. 
And we can give it some bootstrap classes of btn  
103:58 - btn primary and a constant width of 150 pixels. 
Let's call this button as create. So perfect.  
104:08 - Now we have a form to create our category. 
Let's run the project and take a look at that.  
104:16 - Click on categories and now if 
we select create new category,  
104:20 - we see our new form. Let's continue 
with the form in the next video.  
104:27 - Now in a typical web form, what happens so we have 
a name for this input field and display order. So  
104:34 - when we post that inside there, we will try to 
extract that based on the name and we will see  
104:39 - what value was appended. But with razor pages, we 
have something special we can bind this input text  
104:47 - directly to a category model and then we can use 
that model or rather have those values available  
104:54 - inside the post handler. So we will be binding 
this to a model In order to find a UI to a model,  
105:03 - we have to create that property or model inside 
the model of the UI, which is create model that  
105:10 - is inside the cshtml.cs. So just like inside 
index, we created an IEnumerable of category,  
105:19 - and then be binded. That right here to extract 
using model dot categories, we can do something  
105:25 - similar inside create.cs. HTML, we do not want an 
AI enumerable, we just want one single category.  
105:34 - So we will create a category property. And we 
can access this property inside our UI right  
105:42 - here. Inside the index dot css html, we saw the 
Tag Helper ASP page that is used to redirect.  
105:50 - Similarly, we have a Tag Helper that binds a 
property. And that is ASP four, here, we have to  
105:58 - write the name inside our model. To extract that 
we will need the Add sign we will say model dot  
106:05 - and that is inside category. Inside category, this 
is for name. And with that, we also do not have to  
106:15 - define any type or name, everything will be done 
automatically and all the bindings will be done,  
106:22 - we will just add some bootstrap classes for 
styling. Now this will create an input field.  
106:28 - Similarly, we have something for label. 
So if we have a label here, and if we use  
106:34 - ASP for, we can use accurate model here. But 
if you do not want to use the activate model,  
106:41 - when you are using ASP for, it is smart enough to 
automatically bind the models. So you can directly  
106:48 - say category if you want and dot name. That is 
pretty simple. But if you don't see that option,  
106:55 - you can always use at the model to access 
everything inside the model that is defined  
107:02 - right here. So we are just adding a label 
here with the Tag Helper off category name.  
107:10 - Let me copy these two lines and paste them or 
display order as well, we will just have to change  
107:16 - the property name to display order. With that, 
let me save the changes, go back and refresh. And  
107:24 - we see this error because we also modified the.cs 
file, we will actually have to rerun the project.  
107:33 - If it was just the cshtml or the UI, 
then we do not have to rerun our project.  
107:40 - So let's go to categories here. And 
if we hit create new categories,  
107:45 - we have name and display order. Let me 
press F 12. Here and inspect element.  
107:52 - You can see on this element, it automatically 
populates the ID and Name. And you can see name is  
107:58 - category dot name. So it does all of the binding 
along with the type equals to text automatically.  
108:07 - So you can see how life gets easy with Tag 
helpers. Now once we enter any of the details  
108:13 - here, and we hit the submit button, we want to 
fetch those details inside the post handler.  
108:20 - We only have a cat handler right now. So let's add 
a post handler and continue from the next video.  
108:30 - Now we need to create an on post handler. 
By default only cat handlers are created.  
108:37 - If you were working in an MVC and woman, 
then you would create an own post action  
108:42 - method. But in razor pages, we create handlers. So 
creating handlers is simple. We will call public  
108:51 - and then the return type, I want to make this an 
async method. So I will add async. And task of I  
108:58 - action result. I action result I'm using because 
I want to return to some page or redirect to a  
109:05 - view. So that will be the return type. And we will 
call this on post. When we have to name handlers,  
109:13 - it will always start with the keyword on and then 
we have the HTTP verb that this handler will do.  
109:21 - This handler will support the post action method. 
That's why we will call on post handler. Now if  
109:28 - you have multiple post handlers that you want 
in a razor page, you can give this a handler  
109:33 - name after the post. Like you can say on Post 
Create. And then you can have on post edit,  
109:40 - that can be to post handlers. But right now 
we just want to create one post handler to  
109:47 - fetch the details that user entered and 
create that category inside the database.  
109:54 - So here on post, we will receive a category 
object. Let me call that as category. And let's  
110:01 - create that inside our database. In order 
to work with database, we need dependency  
110:08 - injection with the application DB context. So 
first, let me create an application DB context,  
110:15 - we will do control.on The USING statement. And I 
will require a constructor. So C, D or R. And I  
110:24 - will get grief that from dependency injection 
and assign that to my local variable.  
110:31 - Then we want to create the category that we 
received right here. So far that we will be using  
110:37 - underscore dB. And we have to define our model 
which has category on there we have more methods,  
110:44 - we have methods to add, remove, update, and much 
more. The first thing that we want to do is add.  
110:52 - Now, you can use this ADD, but we have added 
the async method. So, let's use the async  
110:58 - implementation add a sink in that it expects a 
category entity that we have fetched with our  
111:05 - on post. So, we will add that now, when you are 
using a sink method, we will have to populate that  
111:13 - before we proceed further. When you write this 
one line, it is telling Entity Framework that hey,  
111:19 - this is the category object that you 
have to add inside the category table.  
111:25 - But it does not tell Entity Framework 
to go and do that right now.  
111:29 - In order to tell that there is a different 
statement, we will say await underscore DB  
111:35 - dot behalf SAVE CHANGES A sink. When you write the 
SAVE CHANGES async. At that time, it gets all of  
111:42 - the items that it has to change inside database 
and makes all of those changes. So if you forget  
111:49 - to write save changes, it knows that it has to do 
that. But it will not save them to the database  
111:55 - and when it redirects or something that will be 
lost. So always make sure to save the changes.  
112:02 - Once the changes are saved, we want to return 
back to the Index page. You see it displays  
112:08 - redirect to action. But that is not valid in our 
application. Because we are using razor pages. So  
112:16 - with razor pages, we have redirect to page. 
And we want to redirect to the Index page.  
112:23 - With that, let me save this at a debugging 
point. And let me restart the application.  
112:29 - Since we've made changes to the code 
behind. Let's go to our categories here.  
112:36 - We have create category, let me enter test 
and to display order, hit the Create button.  
112:43 - Now as soon as you do that, if you examine the 
category, you can see they are populated. Let's  
112:49 - hit continue here. And great that is created. 
So with this, we are able to create categories  
112:57 - inside our application. But I want to show you 
one more thing. Let me close the application.  
113:05 - And here we are fetching the category 
object. And we are adding that  
113:09 - we already have a model here for category. 
So it is something that is redundant.  
113:16 - To avoid that dotnet core team has provided 
a special attribute, which is bind property.  
113:23 - When you use bind property, you no longer have to 
write it here, it automatically does the binding  
113:30 - with the UI that we have on the screen. 
And that will be populated inside the  
113:35 - same object. So then we can use this category 
and add that like this. This will make things  
113:44 - much simpler. Let's run the application 
and try to create one more category.  
113:55 - So let's create test one this time. 
And great. It is working as expected.  
114:03 - Now this is not needed right now. But 
I'd like to show you something else.  
114:07 - Let's say you had three properties that you are 
binding here and inside the post. In that case,  
114:13 - you will have to write Pyne property on each one 
of them from dotnet core 2.1, they have added a  
114:20 - special property that you can apply directly 
at the class level that is bind properties.  
114:26 - What that will do is all the properties that 
you have here and you're using inside the UI,  
114:32 - it will bind all of them automatically so that you 
do not have to individually add bind property. So  
114:39 - with that, if we run the application or create 
should still work the same way. Even though we  
114:46 - just have one category, it's good to know that we 
have that option available if needed. Let's try  
114:53 - to create a new category attached to here. 
And great it's working So with this create  
115:01 - functionality is working as expected. Let's add 
some styling here and continue. On the next video.  
115:10 - I want to change the themes that we are using 
in our application. So if we go to Google, and  
115:16 - if we search for boots watch.com. This provides 
free themes for Bootstrap. If you scroll down,  
115:24 - there are other themes that are available. I 
will go with the sidebar theme for this course,  
115:31 - you can download the minified version or 
the bootstrap dot css. Let me download  
115:37 - the bootstrap dot css. I will copy everything 
that we have open here. Let me minimize this.  
115:44 - And we'll stop the application. Let me add a 
new CSS right here. This will be style sheet.  
115:54 - I will call this boot swatch sidebar. Let's add 
that. And I will paste it here. Let me close this.  
116:03 - And if you open site dot css, they have added 
some different color for btn primary, I will  
116:10 - remove those two. That looks good. Now if we go 
to underscored layout, we can modify the bootstrap  
116:18 - reference that we have here to the new CSS. So 
inside the CSS folder, we have bootsplash cyborg.  
116:27 - Let me scroll down where we are using the 
bootstrap je s bundle. Let's go back here  
116:33 - to bootstrap.com. And let's scroll down. We have 
the CDN for J S with popper. Let me copy this,  
116:42 - and we'll paste that right here. This will make 
sure that we are using the latest one for our  
116:50 - course. Lastly, if I go back with Bootstrap, 
we also have icons that are available to us,  
116:58 - you can see there are quite a few icons that 
we can use in our application. To get started,  
117:05 - let's go to the install tab. And we have the CDN 
that we can copy. Let me paste that with the style  
117:13 - sheets. So perfect. With that we'll be able to use 
icons that are available with Bootstrap. Now that  
117:21 - the CSS is updated, let's run the project 
and see what happens with the new theme.  
117:27 - Things will be a little different. Perfect, 
that looks good. But I want to change the  
117:33 - navigation here to be dark as well. So if you 
go back, and if you examine the theme details,  
117:40 - you will notice we have a dark navigation. 
Let's use that. In order to do that,  
117:45 - we will go back to underscored layout. Rather 
than nav bar light, this will be nav bar dark,  
117:52 - and the BG will also be dark. Let's go back 
and refresh. And this looks much better.  
118:01 - So you can see how easy it was to switch themes. 
Now I do not like the header and background both  
118:07 - the same color. So if we go back to boot 
swatch, let me find out some other themes.  
118:13 - We can use this darkly theme. And you can see 
the navigation is a little gray. Let me switch  
118:19 - that. I will download the bootstrap dot css, cut 
everything here. Let's go back to the application.  
118:28 - We can remove that and paste the new code. If we 
go back and refresh here. Great. This looks much  
118:36 - better. Let me remove the two borders here. And 
in underscored layout, we will search for border,  
118:43 - we will remove the border bottom. We have one 
more, right here. And perfect. Let's go back  
118:52 - and refresh. Great, the UI looks good. Inside 
the footer, I will say BG dark to get the little  
119:00 - gray shade. Great. This looks much better. The 
only thing that is missing is our headings here  
119:07 - are in black. So we'll have to go back there and 
remove the textile to give them the white color.  
119:17 - Let me save this and refresh. And great. 
Now the Create category looks much better.  
119:25 - Let me also align this on the right 
hand side. So we will go to what index  
119:30 - and while we have the button here, we can give 
it the class of text and with Bootstrap five.  
119:37 - Great. Now while we are here, let's also use 
the icons of Bootstrap. So inside the icons  
119:46 - if we go to the top, let me search for pencil. 
We have this pencil square. We can copy this,  
119:54 - go back to the Create New Category. Before 
that, let me add the icon and a space.  
120:03 - With that you can see adding icons is super easy.  
120:07 - So with that the design looks good. Now 
what I want to do is inside create category,  
120:13 - if you try to hit Create button, you will run into 
an exception. It says the SQL exception cannot  
120:20 - insert null values in name. That is because the 
column doesn't allow nodes, or Entity Framework  
120:27 - core was smart enough in migrations to add the 
NOT NULL based on the required property. But here  
120:33 - we need validations so that we do not see this 
ugly exception. Let's do that in the next video.  
120:42 - Now we want to add validations on the Create 
window. If we go back to our project, and if  
120:48 - we examine our model category, you can see for 
name, we added a required validation. So we want  
120:56 - to make sure that this basic validations that 
we have defined here should be applied when a  
121:02 - user is inputting those values. Checking for those 
validations is super easy with dotnet core. First,  
121:10 - let's take a look at server side validation. 
So that will be done inside the.cs file. When  
121:17 - a user is actually creating the category, we are 
using a model here to insert inside the database.  
121:25 - So we have something known as model state, that 
model state will get the bindings and it state and  
121:32 - in there we have an invalid flag. This will check 
if the model state dictionary is valid or not.  
121:40 - Model state dictionary will have a key value 
pair for each entity that is there in our model.  
121:46 - So inside category, it will have better than name 
is valid, or the display name is valid or not.  
121:52 - Because we are entering both of them inside the 
Create UI. So let's examine model state.is valid.  
122:01 - If that is valid only then we want to create. 
If that is not valid, we want to return back  
122:07 - to the page. And that is how it should 
be. But let's add a debugging point here.  
122:13 - And let's examine what actually happens, that may 
restart the application because we made a change  
122:20 - inside the page model. So with that, let's 
go to categories and try to create an empty  
122:27 - category, we do not hit our breakpoint. That is 
because the breakpoint will only be hit if the  
122:34 - model state is valid. Let me add a debugging 
point right there and hit the Create button.  
122:40 - If you hover on model state, you can examine 
all of the properties in there that is valid  
122:47 - is set to false, which means the model state 
is not valid. Now, why is it not valid,  
122:53 - that you can examine by going to the result view 
you can see there are two properties that it is  
122:59 - monitoring. And both of them are not worried the 
name is not valid because it is a required field.  
123:06 - And the display order is also not valid because 
it is an integer field. If you enter now in there,  
123:13 - that is not valid as well. That may hit 
continue here. And this time you don't see  
123:19 - the ugly screen. Because if the model state is 
not valid, we are returning back to the page.  
123:26 - This time, let me enter name and then hit create. 
The model state will still be not valid because of  
123:34 - our display order. This time the error count 
is one. And if you expand the result view,  
123:40 - you can see name property is now valid, 
but the display order is invalid.  
123:46 - So with that, we can easily check our model 
state and only if the model state is valid,  
123:52 - then we create elsewhere return back 
to the view. But that is not helpful,  
123:58 - we should display an error message saying what 
actually is invalid so that user can fix that.  
124:05 - Doing that is super simple with dotnet core. 
If you go to create.cs HTML, we have a special  
124:13 - tag helper to display the validation errors. So 
right after the property or wherever you want  
124:20 - to display, we will have to add a span tag and 
there is a Tag Helper ESP validation for here  
124:27 - we have to write the name of model property 
that we want to bind with this validation.  
124:33 - We want to check for validation category dot name. 
So if there are any errors with category dot name  
124:41 - that will be displayed in the span right here. 
And we will also add a class of text danger  
124:48 - for the red color. Let me copy this and paste it 
for display order so we can monitor both of them.  
124:57 - Once you save that, let me go back and refresh 
the page. Let me try to hit the create button,  
125:04 - it hits our breakpoint. And we get an 
error that may just stop the application.  
125:10 - I get that from time to time, even though 
I did not edit anything while the project  
125:15 - was running. So let me restart the application. 
And this time, we should see the error messages.  
125:23 - So let's hit the Create button. And great, 
you can see it displays a default message,  
125:29 - the name field is required, and the value empty 
is invalid. So with that, you can see how easy  
125:36 - it was to display validations from server side. 
Now, the way you can tell this a server side is  
125:43 - if you examine the tab here, every time we hit the 
button, it reloads. So it goes to the server, and  
125:50 - then it finds out that something is invalid, it 
returns back, and it displays the error message.  
125:58 - With that, let's continue in the next 
video. These are the default validations  
126:04 - that we have at the model level. But 
what if we want a custom validation?  
126:10 - Let's say we want a validation that the name and 
display order cannot be seen. How can we implement  
126:17 - that custom validation and display that message 
right here. So let me close the application. And  
126:24 - we will have to implement that validation at the 
server side. And we can see if category dot name  
126:33 - is equal equal to category dot display order, 
we will have to convert that to a string.  
126:40 - If these are the same, then we want to add an 
error message. So to manually add an error,  
126:46 - we can access the model state. And in 
there, we have a method ad model error.  
126:52 - Now this method requires two parameters. First 
is a key name. And next is the error message.  
126:59 - So you can name this key, anything that you 
want, you can even keep that string dot empty,  
127:05 - because we don't want to put anything in the key. 
But if you are adding more than one model errors,  
127:12 - then you cannot have string dot empty for both of 
them. Because this is a key value. So you can use  
127:19 - distinct key name, and then the error message, let 
me say that display order cannot exactly match the  
127:25 - name. So now we have added a custom error right 
here in our model state. As soon as you add this,  
127:33 - the model state even if it was valid before 
this execution will now no longer be valid.  
127:39 - And I will show that. But where will this error be 
displayed. Because if you go to create.cs, HTML,  
127:47 - we have the validation for individual properties 
that are displayed right here. But we have  
127:54 - something where we can display the summary of 
all the validation. So let's say right here, we  
128:00 - want to do that, then that will be inserted div, 
and we have a Tag Helper ASP Validation Summary,  
128:07 - we can keep that as all. In that case, it will 
display all the validation summary at the top,  
128:14 - as well as at the individual level. Let 
me save this and run the application.  
128:23 - If you go to categories here, and try to create 
an empty category, let me remove the debugger  
128:30 - and continue and great. You can see here we see 
the Validation Summary. And sim properties are  
128:37 - displayed right here. Now this time, let me enter 
a test and it is play order. I will actually add  
128:44 - the debug endpoint again on post. And let me hit 
the pattern. If you examine the model state right  
128:51 - now, you will notice that it is valid, we will 
add a debugging point and let's continue. It seems  
128:59 - like it went through. And of course it did because 
the name and display order were not the same.  
129:05 - Let's keep them same again continue continue again 
it is adding the model state error. Let me add  
129:13 - another debugging point, hit continue. And if you 
examine this time it is not valid because we added  
129:20 - a custom model error based on our requirement. So 
if we remove all debugging point and hit continue,  
129:28 - we see the custom error that display 
order cannot exactly match the name.  
129:34 - So this is how you can add custom validations  
129:40 - now I want to show you one more thing. You can 
see we have used the Tag Helper to display label.  
129:46 - If we go back we have to label 
for display order and name.  
129:51 - It is using the exact same name as property. But 
what if we want to display something else? What  
129:57 - if we want to display a space between display 
order, because inside the error messages also,  
130:03 - it displays the same format. To do that, we have 
lots of data annotations that are available to  
130:10 - help things. Let me go back to category and stop 
the application. Here, we have the required data  
130:18 - annotation. Similarly, we have a data annotation, 
which is display. And then we can provide a name  
130:26 - or whatever we wanted to display. So let's call 
that display space order. Once you do that,  
130:34 - if you save and run the application, now, wherever 
it has to display the name of the property,  
130:40 - it will use this display attribute and whatever 
name we have given. So if you go to categories  
130:48 - create new category, you see the space between 
display order. And if you right, same thing,  
130:54 - you have that in the custom validations. And 
my back, this will not change because we are  
131:00 - adding the custom string. So if you want 
that, you can always change that here. I  
131:06 - thought for a second it was retrieved from the 
property name, but that's not the case. But you  
131:12 - can see we can change the display attribute to 
display label wherever it is being displayed.  
131:19 - Next, we also have custom data annotations 
other than required display and key.  
131:25 - If you go back to the Microsoft documentation, you 
can see all of the annotations that are up level,  
131:32 - and there's quite a few of them. We have 
one here, that is range that checks if  
131:37 - the specified number is between a range of 
values. If you scroll up, we have the mainland  
131:43 - four number key attribute that is the one that 
we used. And we should have a display as well.  
131:50 - Let's see how we can use the range 
attribute. When we have the display order.  
131:55 - Let's say we want to make sure that display order 
should always be between one and 100. So here,  
132:02 - we can use the range attribute. And it expects 
two parameters. One is the minimum value, and  
132:09 - maximum will be 100. Along with that if you want 
to specify what error message should be displayed,  
132:15 - if that condition is not true, you can customize 
that if you do not like the default message.  
132:22 - So we will display our custom error 
message. And let's see this in action.  
132:31 - If we try to hit the create button, we have 
the invalid. But if we enter, let's say 222,  
132:38 - hit Create. Now we see our custom error message. 
So there are lots of data annotations that are  
132:44 - available that you can check out on 
the documentation. But we saw the use  
132:50 - of display as well as range data annotation. 
With that, let's continue from the next video.  
133:00 - The validations that we have seen 
so far are server side validation.  
133:04 - On each request, it goes back to the server and 
then displays the validation. What if you want to  
133:11 - use client side validation, the custom validations 
like name and display order should not be same  
133:18 - will be server side. In order to validate 
things on client side with the dotnet core  
133:24 - application. Inside the shared folder, we have 
a script, which is validation scripts partial.  
133:32 - Here we have the jQuery to do some validations 
on the client side. But this is not included  
133:38 - by default in all the pages. So in pages where you 
want to do client side validation, all you have to  
133:45 - do is include this partial view, partial views are 
meant for that purpose itself. They are created to  
133:53 - be used inside some other view. So let's go to 
our create. And how do we add a partial view?  
134:01 - Partial views are like user components if you 
come from the traditional dotnet application.  
134:08 - Since inside there, we only have script tags. So 
if you have to add any script tag, inside your  
134:14 - view, you have to create a new section. So we will 
create a section for scripts. And inside there, we  
134:22 - will use the razor code, we want to add a partial 
view. So for that we have a partial Tag Helper.  
134:30 - And we have named there where we need to write the 
exact name. Make sure you do not make any spelling  
134:36 - mistake there or else it won't work. So with 
that our partial view is added. If this partial  
134:45 - view did not have just a script, it had some code 
then you could have added that within your HTML  
134:51 - like this. But since it is scripts, we will add 
that inside the section of scripts if you have  
134:59 - any JavaScript code that you want that will also 
be added within this section itself. So on razor  
135:06 - page, you can add a section to handle all of the 
JavaScript. Once you do that, you do not need any  
135:13 - other changes, we just need to run the application 
and see client side validation in action. So  
135:21 - let's go to categories here. And let's hit the 
Create button. This time the page will not reload,  
135:29 - you can see all the validations are done on 
the client side. If you go to the page model,  
135:36 - and add a debug endpoint, and you hit Create, 
it does not hit the debugging point anymore.  
135:43 - But the custom validation that we have here 
is still done on server side. So if we add  
135:48 - one and one, hit Create button, it goes to the 
on post, and then it displays the validation.  
135:56 - So if you want to be fancy, you can do that 
validation in JavaScript as well. But by default,  
136:01 - the dotnet core does not display the custom 
validations on client side. And that also makes  
136:07 - sense. Now, before I end this video, what if we 
want to display this validation inside the name.  
136:15 - So basically, when we are doing this, you can see 
we have validation, that name field is required,  
136:21 - I want to display that validation for the 
name property. Doing that is super simple.  
136:27 - We stop the application. And the key here, 
we will have to change that to be category  
136:34 - dot name. Let's run this and see what happens. 
Let's hit continue. And great. You can see now  
136:49 - we are binding that directly. So if you want to 
bind some custom model state errors to a property,  
136:56 - you just need to provide that key name, and it 
will automatically do the binding. So with that,  
137:02 - let me remove the debugging point. 
And let's continue from the next video  
137:09 - that are created category is working as expected. 
Let's work on editing a category. So for that,  
137:16 - we will have to go back to the categories 
page. And when we click here, the navigation  
137:21 - doesn't seem to work. Let me go to underscore 
layout where we have the navigation here,  
137:28 - we will have to add a forward slash that may save 
that refresh. And perfect. That's much better,  
137:36 - we will always need a forward slash and 
then the complete path because we have the  
137:41 - pages as the root directory. So after that, 
how do you navigate to index so after pages  
137:48 - change the directory to categories. In there we 
have index. Now in the index page, we want to add  
137:55 - two buttons have edit and delete. Let me go back 
while the application is running. Inside index,  
138:02 - we have two th tags, I will add another th 
here. And inside the table row we will add a TD.  
138:11 - Inside this TD we want to add two links. The 
first one should take you to an ASP page using Tag  
138:19 - helpers, it should take us to edit page. And we 
will give some bootstrap classes btn btn primary  
138:29 - and margin x of two. Inside the anchor 
tag, we want to display an icon to edit  
138:36 - so we can go back set the bootstrap icons we used 
pencil, we can copy that and paste it for edit.  
138:44 - Next we want a link for delete. So let me copy 
this. Paste it one more time for delete. That will  
138:51 - be btn danger. Let's go back, we will search for 
a crash icon. Let's copy that and paste it here.  
139:02 - If we scroll up, we are using pencil for create 
deal. So let me change that to something else  
139:09 - like a plus sign. So we have 
the plus square. Let's use that.  
139:18 - Let me save this, go back to our application 
and refresh. Perfect. So we have all the icons.  
139:26 - Let me go back and add some styling. So right 
inside the TD, let me add a div give it a class  
139:34 - of width 75% btn group and row and we will close 
that. Let's refresh and this looks much better.  
139:45 - So if we go back, we will have to add two 
pages, one for edit and one for delete.  
139:52 - Now when we are editing any of the category here, 
we need to know that which category user selected  
139:59 - so we need to pass the ID, when a 
user clicks on any of these buttons,  
140:05 - we have a special tag helper for that. When 
a user clicks this link, we want to pass  
140:11 - something to the route. So we have ASB route, 
and then after hyphen, we can give it any name,  
140:18 - let's count that as ID. And then the value that we 
have to pass is inside this Obj. So we'll use the  
140:27 - razor@obj.id. That will pass a variable 
with the name of ID to the get handler  
140:33 - of this particular page. So let's create 
that page and work on that in the next video.  
140:42 - Now that we are passing the ASP route ID with 
the actual category ID to this edit page.  
140:48 - Let's create that page. If you want, you 
can create a new page inside categories.  
140:54 - What if we want to copy this create and reuse that 
the reason to reuse is because the view or the UI  
141:01 - will be exactly the same. It's just rather than 
displaying an empty page, we will have to display  
141:07 - all of the items that are loaded. So let me 
copy this create and paste it one more time.  
141:14 - Then to edit we will have to stop the application. 
Let's press f2 and change the name to edit.  
141:22 - If we expand this, we have added done cshtml. 
You think that is sufficient, right. But once  
141:29 - you make this change, let's try to run our 
application, we will have some error messages.  
141:35 - What is the reason behind that? I want you guys to 
pause the video and try to see if you can find out  
141:41 - what is the reason we just copied the Create. And 
we modified the name to edit, but it is failing.  
141:49 - I hope you guys were able to figure out the actual 
reason. Let's take a look at edit dot CSS, HTML  
141:56 - and create dot css html. If I toggle between them, 
you can see that the Create model is being used  
142:04 - for both of the pages that cannot happen. 
Each page will have its own unique model.  
142:11 - So what actually happened is when we copied and 
pasted inside the CSS, HTML, it is using the same  
142:17 - model for both create and edit, we have to change 
the name of this model. You can name it anything  
142:25 - that you want, I'll call this procaine model, 
we will have that constructor and inside it,  
142:32 - we will have to use the same with that if you run 
the application, everything will work as expected.  
142:40 - So that was the main culprit over there. But 
we should name this as meaningful as possible.  
142:47 - So let's call this as edit model. And we 
will change that in all the places. When  
142:54 - you were copying and pasting things 
inside MVC, this was not an issue,  
142:59 - because it would rename the class and everything 
would work when you're working with controller.  
143:05 - With view, they don't have a tight 
bind, because there is no.cs in MVC.  
143:11 - But when you work with razor pages, if you are 
copying and pasting, make sure to change the model  
143:16 - in both the page model as well as the UI page. 
So with that, we have added the added razor page.  
143:24 - Now one thing that will be different inside edit 
razor page is inside the arm cat, we will actually  
143:30 - have to retrieve the category. And we will have to 
pass that to the view or the UI that we have here.  
143:38 - Inside the view, it is already binding that 
to category dot name and display order.  
143:43 - So we just need to populate the category 
object right here. In order to find that  
143:50 - we will be receiving ID in the parameters here. 
So let's write that. As I said before, insert  
143:57 - the index dot css html and passing the route with 
the name of ID. So inside edit dot CSS html.cs,  
144:07 - we can fetch that directly here. And based on that 
ID, we will retrieve the category from database.  
144:15 - So underscore DB dot category dot now 
we want to find a category based on ID  
144:22 - that could be done in many ways. The first one 
here is find in find if you write it, it will  
144:30 - automatically find that and assign the category 
find will work on primary key of the table.  
144:37 - So the ID that you pass here must be the primary 
key of Category table and that is the case.  
144:44 - Because of that it will automatically find 
that record and assign that to our category.  
144:50 - Now similar to find I have few more 
methods that I want to show you.  
144:55 - The next method that we have is first our default. 
We have First, as well as first our default,  
145:03 - what will happen with first is we need a lambda 
expression here. And we will say you.id is equal  
145:10 - equal to the ID that is past year. Here 
we are saying that from category table,  
145:16 - find me the first record that matches the ID, 
which is equal to the ID that we are passing here.  
145:23 - Straightforward. Now the difference between first 
and first or default is that if it does not find  
145:30 - any record with that ID, first will throw an 
exception, first or default will just return now,  
145:37 - that is the difference between first and first 
our default. Another way of finding that is using  
145:44 - single and single or default, you can use single 
when you expect only one entity to be returned.  
145:52 - Because in single if more than one entities are 
returned, that will throw an exception as well.  
145:58 - Whereas in first, if more than one entities are 
returned, it will just ignore everything else, and  
146:03 - send you the first one. So single is more strict. 
When it comes to returning values. Inside single  
146:10 - or default. If nothing is found, it will return 
null inside single, that will throw an exception.  
146:17 - So similar to first and default. And then here 
again, you will need lambda expression. So you.id  
146:24 - is equal equal to the ID. Last but not the least, 
is not the favorite approach when we are working  
146:31 - with one entity. Here, you will have a rare 
condition, and you will say value goes to you.id  
146:39 - is equal equal to id. So it will retrieve 
all of the records where the ID matches.  
146:45 - With this statement, it can return 10 
records, it can return 20 records, wherever  
146:50 - the ID matches. So on that once you retrieve 
that, you will have to call first or default.  
146:57 - These are just multiple ways of doing the same 
thing. I prefer either find or first or default.  
147:04 - I'll just comment this out, so that you can play 
around with them. But that will retrieve the  
147:10 - category and assign that to our category object. 
And inside the post action method, what we are  
147:17 - doing is we are adding the category, we do not add 
the category. This time, we just want to update.  
147:24 - So on DB set of category, we have an update 
method. And since that is not a sink, we will  
147:30 - have to remove the await keyword. With that it 
will automatically update the properties that  
147:36 - are different based on the primary key. So you can 
see how easy it is to update any of the category.  
147:44 - Let's run our application and give this a try. Now 
before I run this, we'll just go back to the edit  
147:51 - view, I'll have to change this create to edit and 
where we have created button, we will just have  
147:58 - to change the text to update because it is anyways 
submitting back. So the form on post handler will  
148:05 - be triggered automatically. Let's go back to our 
application. And let's try to update a category.  
148:15 - Let's hit update. Now you might 
think here that update is working.  
148:20 - But actually it's not. Let's try to update this 
category and change the display order to five.  
148:27 - You can see it is not actually updating it is 
creating a new record with the updated entities.  
148:34 - And why is that? I want you guys to pause the 
video and analyze on why this is happening.  
148:43 - You guys were able to figure out the reason edit 
is not working, but it is rather creating a new  
148:49 - object. Let me show you how I debug to find out 
what is the issue. Let's try to add it this change  
148:56 - the display order to six year and we will switch 
back to the application where we have the edit.cs  
149:04 - html.cs we will add a debugging point on the on 
post. Let's go back and hit the update button.  
149:13 - This time let me examine the category and you will 
notice that ID is zero. Now if you pass an object  
149:20 - to update with an ID of zero, Entity Framework 
core will think that this is a new object.  
149:26 - I need to create that because of that it is 
creating a new category rather than updating.  
149:33 - But the main question here is why is it zero? Now 
the reason ID is zero is inside edit.cs. HTML,  
149:42 - we have find it the category name and 
display order, but we have not binded the ID.  
149:48 - So that's why there is no ID field right here. 
So if you want to do that, you can have an input  
149:55 - field which is hidden and we will use the ESP 
for tax helper, this will go to category.id.  
150:04 - With that hidden field, when the form is 
posted, it will have the ID populated.  
150:10 - Let's hit continue here, we get this error, 
we'll have to stop and restart the application.  
150:17 - And let me also remove the debugging point. Let's 
go back and try to edit any of the category now.  
150:25 - So we have this five, we will try to edit that 
and change that to six. And perfect this time,  
150:33 - it did not create a new category. So these are 
very small things that you have to debug in the  
150:40 - application. The best way is to add a debugging 
point and analyze what is the value that will give  
150:47 - you the exact idea of why that is not working. 
So with that, our added functionality is also  
150:54 - working as expected. Now for your assignment, I 
want you to implement the Delete functionality.  
151:01 - When you hit delete, it should open up the same 
page as edit, it should say delete category, and  
151:07 - this field should not be editable, so they should 
be disabled. And you will have the delete button  
151:13 - here. But before you do that, I'm going to add a 
button here to go back to the category lynched.  
151:20 - Also, inside create, let me add that button. So 
let me go back to the project. We'll open up the  
151:28 - Create, we will add an anchor tag with ASP page 
of index, some bootstrap classes. And within the  
151:35 - anchor tag, we will have back to list. Let me also 
copy this and we will paste that inside edit. Let  
151:44 - me save them go back and refresh. And perfect we 
have back to a vest that is working as expected.  
151:52 - Now here, we just wrote the page of index. So 
what happens is within the same directory, it  
151:58 - will try to find the page with the name of index. 
We already have that. So it automatically takes  
152:05 - us back there. But you might be thinking that 
what if I want to redirect to some other page,  
152:12 - let's say we want to redirect to this index 
page, which is the root page of the application  
152:18 - that is super simple. Before index, you will add 
double down and forward slash. So then it will  
152:24 - take you back to one level. And inside that 
folder, it will try to find the index page.  
152:31 - Let me show that we will save this inside edit. 
Let's go there. Back to list, we get back to the  
152:37 - home page and not the category list page. We 
will roll back, bring things back to normal.  
152:46 - Perfect if you have to route to some other 
folder inside pages, how to navigate there.  
152:53 - So perfect. Now in the next video, you 
have to implement the Delete functionality  
152:58 - of deleting a category. So good luck with 
that. And I'll show you that in the next video.  
153:06 - You guys were able to implement the Delete 
functionality, we will switch back to our  
153:12 - application. First we will open up the index 
page here. And we need to pass the ID to delete.  
153:19 - So we will paste that here. And then we can stop 
the application, copy what we have for edit and  
153:26 - paste it one more time, we will rename that 
to delete and we need to change the page model  
153:33 - make sure you're working on delete here, we'll 
change this to delete model copy that go back  
153:40 - to the cshtml and we will rename that as well. 
Now, when we are deleting on cat we will have  
153:47 - to find the category that we have to delete 
but inside post we can do something different  
153:54 - we will have the ID that will be populated 
inside the category. So we will have to find  
153:59 - the category object from database we do not need 
this if condition if the model state is valid,  
154:06 - we can create a variable category from db is equal 
to underscore DB dot category dot find find that  
154:17 - based on category.id So that will find the 
complete category object and populated right here.  
154:26 - Next we can check here if category from DB is 
not no. In that case, we will say underscore DB  
154:35 - dot category and we have the remove method 
which expects a category entity it does not  
154:42 - expect an IT it expects a category entity. So 
we will pass category from db to be deleted.  
154:51 - We will remove this and we will paste the 
save a sink inside the if condition. If the  
154:57 - model state is valid, we redirect back 
to index else, we go back to the page.  
155:03 - So the page model looks good. Let's make changes 
to the view. This will be delete category,  
155:10 - everything will be disabled, 
we do not need validations.  
155:14 - Let me add the disabled field. And we have to 
hit an ID that looks good. Change this to danger,  
155:24 - and delete. Or in fact, let's run 
the application and try this out.  
155:31 - Let's go to our categories and try to delete 
test and three, soon as we try to delete,  
155:39 - we get this validation the Validation Summary we 
should remove that, but something is not right.  
155:46 - The reason behind that is if we go back, it is 
returning back to the page. So the model state  
155:52 - is not valid. Now, obviously the model state will 
not be valid, because it will not have the name  
155:59 - and display order since they are disabled. 
So we do not want to add model state there.  
156:05 - Because we are just finding the ID based on that 
we are retrieving that from database and deleting  
156:11 - that, we will move to a redirect inside the if 
condition. With that we will have to restart our  
156:19 - project model state does not get populated for 
disabled field. So that is something that you  
156:26 - should keep in mind. Let's delete and perfect. 
You can see delete is also working as expected.  
156:35 - With that create, update and delete are 
working for our category. Let's continue  
156:42 - in the next video. I want to display an 
alert on the index page that shows that  
156:48 - what functionality has been done. And those 
alerts should go away if you refresh the page,  
156:55 - so they should not stay on the page once they have 
been displayed. For such special functionality,  
157:01 - we have something called as temp data with 
dotnet core. Temp data has one main feature,  
157:08 - it remains for only one request. 
And if you refresh the page,  
157:12 - it goes away. So that will work perfectly 
when we have to display a little notification.  
157:19 - So let's see how we can add something to our temp 
data. Let's go back to the application. And let's  
157:26 - work with create. Let's open up the.cs file inside 
the our post before we retire it. We want to set  
157:35 - something in temp data. So we have temp data that 
we will write here. And we need a key name. You  
157:42 - can call this anything that you want. I will call 
that success, because that is the success message.  
157:49 - So inside the key of success, we want to store a 
string, which is category created successfully.  
157:58 - We can copy this temp data. And we can add that 
in delete as well. Before we redirect, we can  
158:05 - say category deleted successfully. Inside edit 
before a redirect, we can say category updated  
158:14 - successfully. So we are setting our temp data 
on create, edit and delete. Now if you notice,  
158:21 - once we create them, it is redirecting to the 
Index page in all the places inside delete also,  
158:28 - that goes to the Index page. So what we will 
do is on index dot css html, inside the view  
158:36 - or the UI side, we need to retrieve that temp data 
and see if there is any string value inside there.  
158:44 - So right here on top of the page, we will use 
razor syntax. And we'll have the if statement.  
158:51 - We will say if temp data, you will have to use 
the exact key name. If you use something else,  
158:57 - it won't work. So if temp data of success 
is not now, what we want to do is an h2 tag,  
159:05 - I want to display the value. So in 
order to get the value from temp data,  
159:10 - it is pretty straightforward. We just write 
test temp data success. Let me save all of that.  
159:18 - And we will have to restart our application. 
This time, let's try to create a category.  
159:28 - As soon as we create, you see we got a 
notification in h2 tag. And if you refresh  
159:34 - the page that goes away, so that is perfect. 
This way it only stays there for one request.  
159:43 - If you delete a category, you can see we have our 
alert, which is category deleted successfully.  
159:50 - So this is great news and everything is working 
as expected. Now rather than displaying a  
159:56 - string on top, it's best if we use something See 
JavaScript code. Let's do that in the next video.  
160:06 - Right now we are just displaying an h2 tag. 
But we can add something fancy in our project.  
160:12 - And that is toaster J S notification. If you go 
to the toaster j s get repo, you will have a demo  
160:21 - where we can see how toaster notifications look. 
And these are much fancy. If we go back to the  
160:28 - GitHub, we have the CSS and JS files. Let me 
copy the CSS. Let's go back to our application.  
160:38 - Inside the underscore layout, we will add that the 
top here, Link, Arielle is equal to stylesheet.  
160:46 - And h ref will paste the URL. Next, what we have 
is the GS. So let me copy the GS file. And then  
160:56 - GS, we do not want to include an underscore layout 
here. Let me do that too badly in index.cs. HTML,  
161:05 - where we have temp data. One way I showed you 
how to use script is at the end, we can use the  
161:11 - script section. Another way is right here, 
we can use the script tag. And within here,  
161:18 - we will say type is equal to text, JavaScript. And 
we can use some custom GS right here. Before that,  
161:27 - we just want to include a script. So we'll say 
script src is equal to let me paste the URL.  
161:35 - Now when we are working with toaster at the 
same place, we will also need jQuery. So if you  
161:41 - go to underscore layout, we have jQuery script 
right here that is included with our project,  
161:48 - we can go back to the Index and paste that 
right here, we will remove the h2 element here.  
161:56 - And Perfect, let's clean this up. Now within the 
script tag, we want to call toaster and on there,  
162:04 - we have method of success. Let me go back and 
show that we will have the user ID someplace.  
162:11 - You see we have toaster dot success, we can copy 
that and paste it here. And inside the parameters,  
162:19 - we want to pass the temp data that should 
be done inside single quotes. Now we need  
162:25 - to access the result code. So we will use the 
Add sign temp data of success. That in place,  
162:34 - let me save this, go back. And let me refresh the 
application. Let's try to edit a category here.  
162:43 - Now we see the fancy toaster notification. If 
we delete a category, everything is working  
162:50 - as expected. But now we have a fancy notification. 
So similar to success, you can also implement an  
162:58 - if block here, that will be for error temp 
data. And if you set something inside error,  
163:06 - we will display that this will be error. So 
that way we can use toaster with our project.  
163:14 - I've added alerts to our project. 
And if we go back to the application,  
163:20 - this is some code that is common for alerts. 
If you want to display alerts in other pages,  
163:25 - you will have to copy this code every time. And 
what if in future, you change something here,  
163:32 - then you will have to go to all the files and 
update the same code. That is a bad approach. And  
163:38 - for that particular scenarios, we have partial 
views, we can move this code inside a partial  
163:45 - view. And then we can directly call that partial 
view here. That way In future, if you have to  
163:51 - change something, you will only change that in one 
places. And wherever that partial view is called,  
163:57 - you don't have to change anything in those files. 
So far that we will stop the application partial  
164:04 - views, we will always add inside the shared 
folder, we will right click add new razor page,  
164:12 - we will go with the razor page empty. And 
so far we have been selecting razor page.  
164:17 - But that creates a page with a page model. Partial 
views do not have a page model that you can see  
164:24 - inside underscored layout and the validation 
scripts partial. So that will be a razor view.  
164:32 - Razor view does not have a page model. And 
naming of partial view I always do with an  
164:39 - underscore that way by taking a look at the name 
itself. I can say that that is a partial view  
164:46 - name we want to give here this notification. Let's 
add this razor view. You can see there is no page  
164:54 - model with the partial views. Now here it says 
for enabling me See projects, just ignore that,  
165:02 - we will be using this as a partial view in the 
razor page. And that is completely normal. Let's  
165:10 - go back to our index. And that may cut the 
cord or toaster, go back to notification,  
165:16 - and we will paste it right here. We will 
save this, then we will go back to our index.  
165:23 - And we need to call our partial view 
with the name of underscore Notification.  
165:30 - Now when you have to use notification in some 
other page, you will just have to add this one  
165:35 - line of code. And also in future when you have 
to change something, you will just change that  
165:41 - directly in partial view. And you don't have 
to make that change across all the other files.  
165:48 - Let's run the project and make sure 
everything is still working the same.  
165:55 - Let's go to our categories. And we have an 
error. I believe there is some spelling mistake,  
166:01 - I'd forgotten I here. Let 
me save that. And refresh.  
166:08 - Let's try to delete this time. And perfect. 
Since these are magic strings, make sure that  
166:15 - the name is exactly the same audio will run into 
the error messages like we saw. So this is great.  
166:23 - But what if in your functionality, you wanted this 
partial view to be across all of the pages in your  
166:29 - application. If that is the requirement, indeed, 
then it doesn't make sense to add this one line  
166:35 - in all the pages. The alternative for that 
is we can cut that partial tag from here  
166:41 - and add it inside the underscored layout directly. 
Because this is rendered in all the pages.  
166:48 - So here just before render body, we can paste 
the partial tag and run the project. If we try  
166:56 - the categories one more time, it should work 
as expected. Perfect. But you should be careful  
167:03 - with this approach. Because you are adding a 
piece of code that will be present in all the  
167:08 - pages of your application. If that is something 
that your requirement demands, then for sure,  
167:14 - go ahead and do that. But do not add a bulky code 
here that is not used, it will just increase your  
167:21 - application overhead. So with that all of our 
CRUD functionalities are working as expected.  
167:30 - Now we have seen how we can add pages 
to our application, and how to modify  
167:35 - everything else so far. Let me show you one 
more thing here. Let me create a new folder  
167:42 - inside pages and call this category 10. In there, 
if we right click Add razor pages, you can see we  
167:50 - have options here to directly create razor pages 
using Entity Framework for all the crud operation.  
167:58 - What exactly will this do? Let me show you that. 
If you hit the Add button, first thing that you  
168:04 - have to do is you have to select a model, it 
will create all the pages for CRUD operations,  
168:11 - which stands for create, read, update and delete. 
So we have to select a model there. And we need  
168:18 - to select the DB context, because that way it 
can access the database and modify everything  
168:24 - for the CRUD operations. Once you add those two, 
this won't be a partial view, we want to use  
168:31 - our master page and record layout. So we will set 
that as blank. And let's add this. This will take  
168:39 - a while to scaffold everything. And then it will 
add all the pages inside the category temp folder.  
168:47 - Now that it's done, if you expand that, 
you can see it has added pages for create  
168:53 - delete details added an index everything by 
itself. Let's run the application and take a  
169:01 - look at them. In order to navigate there, we have 
to do the manual navigation. So here the name of  
169:08 - the folder is category temp. We can write index. 
But if we don't, it will find that by default.  
169:17 - And great. You can see there is the index page 
and we had one category, it is automatically  
169:22 - displaying that we can create a new category here. 
That's working. If we hit Create new, it also has  
169:32 - validations we have go back here, we can edit the 
category that's working, we can view the details  
169:41 - and we can delete the category. So all of the 
functionalities of a basic CRUD application  
169:48 - are done for us if we go with that route, but I 
did not want to go with that because I wanted to  
169:55 - teach you how to write all of this on your 
own. But if you examine In the code here,  
170:01 - it is doing the same things that we have done, 
nothing fancy. So that's just something for  
170:07 - you guys to play around. Let me remove that, 
because I do not want multiple code. So with  
170:15 - that our project is done. And in the next video, 
let me show you how we can deploy this to Azure.  
170:25 - And the final task is to deploy an application 
to Azure. So for that, you will have to create  
170:31 - an account on portal.azure.com, I already have an 
account, if you are signing up for the first time,  
170:39 - you will get $200 of Free credit that you can 
use. The first thing that we have to do in here  
170:46 - is we need to create a SQL Server and a database 
inside that. So we can create or search for SQL  
170:54 - databases. And let's hit the Add button. Usually, 
I like creating everything from Visual Studio,  
171:02 - but SQL Server I like to create here. That 
way, I can easily see all the configuration,  
171:08 - you will select the subscription that you have. 
And in there, we can create a resource group.  
171:15 - I will call this resource group as taught at 
mesh tree underscore course. And then let's  
171:21 - enter a database name, we will contact dotnet 
mastery underscore dB, we do not have a server.  
171:29 - So let's create a server. The server name will 
be unique. So I will use start at mastery server.  
171:37 - And then we need an admin login. We cannot use 
admin here, that won't work. So I will just use  
171:44 - admin SQL for password, you can use something 
secure, select your location, and hit OK.  
171:53 - Now next option is to be one to use elastic 
pool, we will say no there, and then the server  
172:00 - location that's not available. So let me select 
some other location HDLs too. And let's hit OK.  
172:09 - Then you need to select the compute plus 
storage, we will select Configure database there.  
172:15 - And I will use the lowest option which is basic 
here. And that is five usd per month. Let's apply.  
172:23 - I do not want to pay more for the subscription. 
So I'm going with the lowest option for redundancy  
172:30 - backup, that is perfectly fine with me. Let 
me hit review plus create. We're going to hit  
172:37 - Create here. And it will take a while to 
configure our database and set everything up.  
172:45 - And perfect our database has been created. If 
we click go to resource, it will take us to  
172:52 - SQL database. Now one thing that you will have 
to do is if you want to access this database,  
172:58 - from your local SQL Server, you will have to 
select the Set firewall settings and add your  
173:04 - client IP that will enable your client IP and 
you can access the database from SQL Server.  
173:13 - Let's hit the Save button to add your client IP 
there. Once that is done, let's go back to SQL  
173:20 - Server. And we need to connect to that server. 
So we will hit OK here. Go back to the resource.  
173:27 - And we have connection string. 
Let me copy the server name here.  
173:33 - Go back and paste it. And we will use SQL 
server authentication. We have admin SQL  
173:41 - and password. Let's press Connect. Great, 
we are able to connect to our SQL Server.  
173:49 - So with that in place, let's continue from the 
next video. Let me close the other tabs here.  
173:57 - Now that we have created our database in Azure, 
we can go back to Visual Studio, and let's publish  
174:04 - our application, we will have to create an 
app service plan and we will have to publish  
174:10 - we can do that directly from Visual Studio as 
well. So here we will right click on project  
174:17 - and select Publish. We will be selecting 
Azure and hit next here. And then for now,  
174:24 - we will be publishing to Windows App Service. 
Let's select Next. Then you will have to log  
174:31 - into the account where you want to publish. 
Once you sign in with the account, you will  
174:36 - select the subscription name here on the top and 
we will have to create an app service instance.  
174:43 - I will call that as as the web. So the final 
website or rather the temporary website will  
174:49 - be abi pap.as, your website's dotnet it is 
a free domain that is provided by Azure.  
174:57 - So we have subscription name. Next is the resource 
group, you can create a new resource group,  
175:03 - but I already have one after at mastery underscore 
course, that is what I will use resource group are  
175:10 - basically tax that you can add to combine things 
under one umbrella. Nothing fancy, just like a  
175:17 - folder structure. Next we have the hosting plan. 
My default an S one tier hosting plan is selected.  
175:25 - But I want to use the free hosting plan 
that Azure provides. So we will select that  
175:31 - and press OK. Let's hit the Create 
button to create our app service.  
175:38 - That creates our AP service. And we will hit the 
Finish button. The final step that we have is we  
175:45 - need to configure our SQL database. So you can see 
in the service dependencies, we can hit configure  
175:52 - here, and we can add an Azure SQL database, it is 
already displaying the database that we created  
176:00 - on our account. So we will select that and hit 
the next button. The Connection String name inside  
176:07 - our application, if you remember, inside the 
connection strings, that was default connection,  
176:14 - we just need to write our user ID, which is 
admin sequel and the password. Once you do that,  
176:22 - it automatically populates that in the connection 
string, then we do not want to save connection  
176:28 - strings in app settings or key word right 
now. But we can just copy the connection  
176:33 - string. Let me open up a notepad and paste it 
there. Let's go back and hit the Finish button.  
176:42 - Now that we have the connection string, let me 
click on any one of the settings that we have  
176:47 - here. Inside the database, we need to paste the 
connection string. So let's expand that. And our  
176:55 - connection string is valid, we will just select 
the Use this connection string at runtime. Then  
177:02 - inside the Entity Framework migration. Right now, 
there are no migrations that have been applied. We  
177:08 - already have the migrations in the folder. So we 
can select Apply this migrations on Publish, and  
177:15 - that will create the tables inside the database. 
Now right now we are working with dotnet six,  
177:22 - and it is not available in the App Service. So far 
that we will change the deployment mode to self  
177:29 - contained, and that should work with that chain. 
Let me save this and publish our application.  
177:38 - You can see the site name I said before will be 
Abbey web.as. your website's dotnet. And this is  
177:44 - a free subdomain that is provided by Azure it is 
retrying the add operation but that is failing.  
177:55 - Inside the logs here, you can see 
we have issue with the client IP.  
178:00 - Let me copy this error, paste that in Notepad. 
I believe we added the IP, we will copy this,  
178:08 - go back to Azure. In overview set firewall, we 
will add a new client IP. Let's save that. That  
178:18 - is the IP from the server. With that change. Let 
me publish it one more time, and it should work.  
178:27 - Once the deployment is complete, it will 
automatically load the website URL in a browser.  
178:35 - It is loading our website. Let's take a look.  
178:40 - And create. You can see everything is working. 
There will be a new category stable with no  
178:46 - category right now. We can add categories. We have 
our alerts. And we can edit, update, and delete.  
178:56 - So everything is working as expected. 
And our website is live on Azure.  
179:04 - Congratulations on completing the course. 
With this course you have a basic foundation  
179:09 - on razor pages, and how to perform CRUD 
operations using Entity Framework core.  
179:16 - This is just getting started with razor pages 
in dotnet core. There are many more topics that  
179:22 - I cover in my advanced course. Let me just give 
you some highlights of the topics that I cover  
179:28 - in that course. The project that we have 
built so far, we will define that project  
179:34 - in an anterior architecture, where we will 
have a separate data access layer. In that  
179:39 - data access layer. We will be using repository 
pattern and unit of four to access our database.  
179:47 - We have already seen temp Data In Action, so we 
will use that and we will see how we can add API  
179:53 - controllers with our razor pages project. That way 
we can use the API's that we build In data tables,  
180:01 - and we will see sweet alerts, as well as rich text 
editor. These are just some basic functionalities  
180:08 - in a typical application. Also in any real 
world application, we have authentication  
180:15 - and authorization. So for that, we will scaffold 
the built in identity razor class library that  
180:22 - the dotnet team provides. With authentication 
using identity class library. We will also see  
180:29 - roles and authorization in action. Once we add 
authentication and authorization to our project,  
180:36 - then we will use stripe for payment collection and 
we will also see how to issue refunds using Stripe  
180:43 - API's. We also have sessions in dotnet core. 
So we will see how to configure our application  
180:50 - and send emails using SMTP and SendGrid will also 
show how to use Facebook for social login. We also  
181:01 - have some advanced concepts like view component, 
and how to see database with the initial data  
181:08 - using a DB initializer class. Once we 
cover all of these advanced topics,  
181:14 - we will deploy our application to Azure and 
we will see how everything comes together.  
181:21 - So this will be a pretty lengthy course 
and we will go into building a real world  
181:25 - project with real requirements. So if you 
want you can check out this course and other  
181:32 - courses on dotnet mastery. And if you like this 
video, please like and subscribe to the channel.  
181:39 - So I hope to see you guys in some 
other course. Till then Happy Coding