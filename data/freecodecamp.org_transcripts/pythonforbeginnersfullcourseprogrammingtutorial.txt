00:00 - in this full course you will learn the
00:01 - basics of python programming
00:03 - i'm beau carnes with freecodecamp.org
00:06 - i've previously created one of the most
00:07 - popular javascript courses on youtube
00:10 - and i've created many python tutorials
00:13 - now i've created this complete python
00:15 - course for beginners you don't need any
00:17 - previous programming experience to
00:19 - follow along and all you need to code in
00:21 - python is a web browser in this course i
00:23 - will teach you all the core aspects of
00:25 - the python programming language and i
00:27 - will simplify the more complex topics
00:30 - python is considered one of the most
00:31 - popular programming languages in the
00:33 - world and it's only growing in
00:35 - popularity python excels in a wide
00:37 - variety of scenarios such as shell
00:39 - scripting task automation and web
00:42 - development and it's also the language
00:44 - of choice for data analysis and machine
00:46 - learning but it can also adapt to create
00:49 - games and work with embedded devices
00:52 - we're going to jump right into it so you
00:54 - can start coding your first python
00:55 - program as soon as possible to get
00:58 - started quickly we'll use a replit which
01:00 - is an online ide that allows users to
01:02 - code and run programs in a variety of
01:05 - different languages all in a web browser
01:08 - and later i'll show you how to get
01:09 - python set up on your local operating
01:11 - system after the first project i'll go
01:14 - into more detail about each of the main
01:16 - features of python the section is
01:18 - comprehensive and detailed and in the
01:20 - final section you will use what you've
01:22 - been learning to code a blackjack game
01:24 - with me guiding you every step of the
01:26 - way throughout the course there will be
01:28 - a little repetition of some of the key
01:30 - python programming concepts to make sure
01:32 - you have a deep understanding of the
01:33 - language so let's get started we're
01:36 - going to start by creating a simple rock
01:38 - paper scissors game and we'll start by
01:41 - going to replit.com replied provided a
01:44 - grant that made this course possible and
01:46 - replie is going to make it super easy to
01:48 - get up and running really quickly so you
01:50 - can either sign up or log in
01:53 - and create an account i'm just going to
01:54 - use my google account
01:56 - okay now that you're logged into replit
01:59 - you can either just click the create
02:01 - button or this plus button over here to
02:04 - create a new replit and i'll make sure
02:06 - to create a python replit but you can
02:10 - see you can also select all sorts of
02:12 - different programming languages oh these
02:14 - are just the ones that start with the
02:15 - word python but so there's there's tons
02:18 - of different programming languages you
02:19 - can select but in this case we are just
02:21 - going to use python and then i'll click
02:24 - create reple
02:29 - okay so let me just kind of show off
02:31 - replica a little bit
02:33 - this is where we're going to create our
02:34 - python code i'm going to zoom in just a
02:36 - little bit so we're going to write the
02:38 - code right here and then we can see some
02:40 - output over on the right side and then
02:42 - you can create different files over on
02:44 - the left side here
02:46 - and then there's some other things like
02:48 - you can connect to version control
02:50 - and
02:51 - if you have environment variables we're
02:52 - not even going to be discussing those in
02:54 - this course there's a debugger you can
02:56 - connect to a database and just some
02:58 - other things but we're mainly going to
03:00 - just be using this main.pi program to
03:02 - write our program and we're going to see
03:04 - the results in the console so i'm just
03:06 - going to close this files window so
03:09 - it's a little bigger here
03:11 - i'm going to start off by showing you
03:13 - how to create a variable with python so
03:17 - this is a rock paper scissors game and
03:19 - there's going to be a players a player
03:21 - is going to have a choice and a computer
03:23 - is going to have a choice so i'm going
03:25 - to create a variable called player
03:29 - choice
03:30 - and i'm going to set that equal to
03:33 - rock
03:34 - so let's look at a few components about
03:36 - this this is the variable name player
03:39 - choice
03:40 - and you can see
03:42 - if you
03:43 - we use an underscore that's just kind of
03:45 - the convention for python to use an
03:48 - underscore if you're going to have a
03:49 - space in the variable name and we're
03:51 - going to assign it that's what this
03:53 - equal sign this is the assign operator
03:55 - and we're going to assign it to a string
03:58 - a string is just a word or a collection
04:00 - of characters like rock and we're going
04:02 - to put quotation marks around it now we
04:04 - could have also used a single quotes
04:06 - instead of double quotes as long as you
04:08 - use the same quote on each side that's
04:10 - what's important so we've now created a
04:13 - variable
04:14 - called
04:15 - playerchoice and assigned it to rock and
04:18 - now we can reference this variable later
04:20 - and whenever we reference the variable
04:22 - called playerchoice it's going to
04:25 - the code is going to automatically
04:27 - replace that player choice with rock
04:31 - so this is going to be a very
04:33 - interactive project i hope you're
04:36 - following along i hope you have already
04:38 - got replit loaded up like this now
04:40 - throughout this project i'm going to
04:42 - tell you what the next thing to do is
04:45 - and i want you to try doing it yourself
04:48 - before you watch what i'm going to do so
04:52 - periodically you'll want to pause the
04:53 - video
04:55 - based on and what i say you and try to
04:57 - implement what i say
04:58 - before you come back to the video and
05:00 - watch me implement it and see if you've
05:02 - implemented the the same way
05:05 - so i'm just going to zoom in one more
05:06 - time and
05:08 - this is the first thing i want you to do
05:10 - see if you can make another variable on
05:13 - the next line so you're going to press
05:14 - return or enter to go to the next line
05:16 - and this variable should be called
05:18 - computer choice and you should set it to
05:21 - equal
05:22 - paper
05:24 - okay so you can pause the video and see
05:25 - if you can make a variable called
05:26 - computer choice and set it to equal
05:28 - paper
05:31 - so here it's pretty simple here it's
05:33 - going to start simple but it's going to
05:35 - get harder as we go so computer choice
05:38 - equals
05:40 - paper okay so like i said it's starting
05:42 - simple but it's going to get more
05:43 - complex as we go along
05:45 - if you've done that you've now written
05:47 - your first line of python code in this
05:49 - course
05:50 - okay now i'm going to talk about
05:52 - functions
05:53 - a function is a set of code which only
05:56 - runs when it is called
05:58 - so i'm going to show you how to put this
06:00 - code into a function
06:03 - now one thing about python is that
06:05 - indentation is very important
06:08 - so after we create a we define the name
06:11 - of a function any line of code that's
06:14 - indented the same amount is considered
06:16 - within that function
06:18 - so i'm going to create a new line of
06:21 - code at the top and i'm going to call it
06:24 - get
06:26 - choices
06:31 - okay so we define the function with def
06:35 - and get choices and i'm going to select
06:37 - all these these two lines of code at the
06:39 - same time and just press the tab key and
06:42 - that's going to indent all these the
06:44 - same amount
06:46 - and you can see sometimes they'll be
06:48 - squiggly lines and if you hover over
06:50 - some of the squiggly lines it will tell
06:52 - you something in this case it just says
06:54 - the local variable called player choice
06:56 - is assigned to but never used that's not
06:59 - necessarily bad it's just it's just
07:01 - telling us that usually if you create a
07:03 - variable you're going to want to use it
07:04 - later well we are going to use it later
07:06 - we just haven't gotten to it yet so
07:08 - sometimes the squiggly lines will
07:10 - indicate there's some sort of error in
07:12 - the code
07:13 - usually i think it's the color red will
07:16 - indicate an error but if it's a
07:17 - different color it just may mean that
07:19 - there's something maybe not quite right
07:21 - but
07:22 - it's not really that big of a deal so if
07:25 - you have a variable that's assigned to
07:27 - but never used that's not going to stop
07:29 - your program
07:30 - but it's just saying that it's not this
07:32 - variable isn't really being used for
07:34 - anything yet but we will change that
07:36 - this function i'm going to show you how
07:37 - to call a function later but we're
07:39 - creating a function called getchoices
07:41 - that assigns these two variables and
07:45 - it's also i'm going to put another line
07:46 - at the very end here and it's a return
07:49 - statement
07:51 - and i'm going to return player
07:55 - choice
07:56 - this will indicate what's returned when
07:58 - this function is called so later we'll
08:00 - call this function get choices and it
08:02 - will return
08:04 - something it will return the player
08:06 - choice which is right here we'll turn in
08:07 - this case rock that we can use somewhere
08:10 - else in our code
08:12 - and i did just happen to put an extra
08:14 - line here
08:16 - that's just that's optional i put a
08:18 - blank line here just to kind of
08:20 - make things easy to kind of organize the
08:22 - code a little bit so
08:24 - different sometimes i'll just put an
08:26 - extra line between different sections of
08:28 - code and it just makes it easier to
08:30 - identify the different sections when
08:32 - you're looking at the code
08:33 - for the computer those extra lines don't
08:36 - mean anything the indentation though
08:39 - definitely does mean something
08:41 - so as long as every line of code is
08:43 - indented the same amount as the previous
08:46 - line of code then it's all within the
08:48 - same function
08:49 - okay so this is what i want you to do
08:51 - see if you can change the return
08:53 - statement so instead of returning player
08:55 - choice it's returning the computer
08:58 - choice
09:02 - so that's pretty simple
09:04 - it's now returning the computer choice
09:06 - here
09:07 - now i'm going to create another function
09:08 - down here this is just going to be an
09:11 - example function just so i can
09:12 - demonstrate something to you and then
09:14 - we'll delete it it's not going to be
09:15 - part of our rock paper scissors game but
09:17 - i'm going to create a new function
09:19 - called greeting
09:20 - and then i am going to add what it's
09:23 - going to do oh yeah put the semicolon
09:25 - you also know a colon so a function
09:27 - always has to have a colon at the end of
09:29 - how we define it so i'm going to return
09:33 - a string and it's just going to say hi
09:36 - and one thing you'll notice is that
09:38 - there's no you don't have to put any
09:41 - anything at the end of each line some
09:42 - programming languages such as javascript
09:45 - you're going to put a semicolon at the
09:46 - line at the end of the line
09:48 - but in python it doesn't matter you
09:50 - don't put anything at the end of each
09:51 - line so now i'm going to call the
09:54 - function to call the function i just
09:55 - type the name and i put the parentheses
09:58 - at the end so it's going to say so
10:00 - greeting is now going to call it's going
10:03 - to call this function and that's going
10:04 - to return the string hi
10:06 - now it's not going to do anything with
10:08 - the string because our program doesn't
10:10 - do anything with the string that's been
10:12 - returned it's not going to go into the
10:14 - console or anything but let's add
10:16 - additional code so we will
10:20 - make this string hi go on to the console
10:23 - first let me create a variable that
10:26 - takes what this greeting function
10:28 - returns so i'm going to type in response
10:32 - equals greeting so now we set the the
10:35 - what greeting is being returned to this
10:37 - variable called response and now i can
10:40 - use the print function
10:42 - and i can print the response and this
10:45 - will print it to the console so now i
10:48 - can we have this green button here this
10:49 - runs the program i'll click this green
10:51 - button here and now we can see it's high
10:54 - so
10:55 - this response is getting this high from
10:57 - here and then we're printing it right
10:59 - there okay i'm actually going to delete
11:02 - all of this
11:04 - and what i want you to try to do now is
11:07 - to call the get choices function and
11:10 - store the response in a variable called
11:12 - choices and then print the value of
11:15 - choices to the console
11:17 - so you can pause and try that really
11:18 - quick and then i'm going to show you how
11:20 - okay so remember the variable is called
11:22 - choices
11:24 - and we're going to set that equal to
11:26 - the get choices variable now ins or the
11:29 - get choices function now instead of
11:31 - typing out get choices you can see that
11:34 - this code editor is actually giving us
11:37 - suggestions on what we want to put in
11:39 - here so i just typed in get and you can
11:42 - see it's now saying get choices right
11:44 - here so i can instead of typing out the
11:45 - whole thing i can either click there or
11:48 - i can just press the tab key and it's
11:50 - going to fill in the rest of that
11:51 - function name so that's just something
11:53 - little that makes it easier to write a
11:56 - program and you don't have to type out
11:57 - every single thing so if you've already
11:59 - created a function or a variable then
12:02 - the the code editor then reply will will
12:05 - suggest what you may want to fill in
12:07 - when you're typing and most other code
12:09 - editors do something similar it's called
12:12 - code completion so
12:14 - i'm going to but i still have to add
12:15 - parentheses at the end and now i'm going
12:18 - to print
12:20 - the choices
12:21 - [Music]
12:22 - okay so i'm gonna just click this play
12:25 - button to make sure it does what we're
12:27 - trying to do yep it clicked paper
12:30 - great
12:31 - now let's talk about dictionaries
12:33 - dictionaries in python are used to store
12:36 - data values in key value pairs so let me
12:40 - just show you an example
12:45 - okay so a dictionary is going to have
12:46 - these curly braces at the beginning and
12:48 - end and then here's a key value pair
12:51 - there's one it's separated by a comma
12:53 - and then here's another key value pair
12:55 - so we're setting name
12:58 - we're setting that to equal bow and
13:00 - we're saying the color
13:01 - to equal blue so here's the key here's
13:05 - the value here's the key
13:07 - here's the value
13:08 - and the key or the value in a dictionary
13:11 - can be a variable
13:12 - like the color we could set that we
13:15 - already created this variable here i'm
13:17 - just going to copy the word choices and
13:19 - we can put choices and you can see now
13:21 - it's not surrounded by the quotation
13:23 - marks so if you surrounded by quotation
13:26 - marks it's a string but if we don't
13:27 - surround it by quotation marks it's
13:30 - getting the the variable here choices so
13:32 - this would be set to
13:35 - paper because that's what choice is
13:37 - going to is going to equal so we're
13:38 - about to delete this line because that
13:40 - was just an example
13:41 - but now before the return statement in
13:44 - this function we're going to add a new
13:46 - line we're going to create a variable
13:48 - named choices and make it equal to a
13:50 - dictionary the first key should be
13:53 - player with a value of the player choice
13:56 - actually this variable here
13:58 - the second key should be computer with a
14:01 - value of computer choice
14:03 - and then we're going to update the
14:05 - return statement
14:07 - to return the the choices dictionary
14:10 - now i'm not going to keep telling you to
14:12 - pause and try it yourself so just the
14:14 - rest of this time whenever i say what
14:16 - we're going to do you'll know that after
14:18 - i get done explaining it you can pause
14:20 - it and try it yourself but that's what
14:22 - we're going to do now
14:26 - so i'm going to create choices
14:29 - and it's going to be a dictionary and
14:31 - then it's going to have
14:33 - a player
14:35 - that's the key and the value is going to
14:37 - be player
14:39 - choice and i was just able to press tab
14:40 - to fill that in and then we're going to
14:43 - have computer
14:44 - and it's going to be
14:46 - computer choice
14:49 - and you can see sometimes if it goes to
14:51 - the next line there just won't be a line
14:53 - number right here
14:54 - but i can
14:56 - move this over for now
14:59 - and then i am going to oh i forgot to
15:02 - put the equal sign that's what that red
15:04 - squiggly line means so because the red
15:06 - means there is a problem in the program
15:08 - so it's not going to run correctly now
15:09 - the orange just means that we haven't
15:11 - used choices yet which we will right now
15:14 - because we're going to return
15:15 - choices
15:17 - choices
15:21 - okay so now we don't have any squiggly
15:23 - lines because we're using every variable
15:25 - that we created and we're returning
15:26 - choices here
15:29 - so you may have noticed that player
15:31 - choice
15:32 - it does not actually get set to the
15:34 - player's actual choice
15:36 - so let's fix that
15:38 - the input function gets input from a
15:41 - user and will use it to get the player's
15:44 - choice
15:45 - so instead of having players choice
15:47 - equal rock we're going to make players
15:49 - choice input
15:53 - enter a choice
15:58 - rock
15:59 - paper
16:01 - scissors
16:04 - okay so this is how you get input from a
16:06 - user we use the input function and this
16:09 - is going to be something that's going to
16:10 - be printed
16:11 - we'll print to the console here
16:13 - and whatever the result of this input
16:16 - will be that the the player that the
16:18 - user entered will get stored to this
16:20 - variable which we then can use later in
16:22 - our program
16:24 - so let's just try that out i'll click
16:26 - run
16:27 - and
16:29 - enter
16:31 - let me just stop and run it again
16:33 - okay enter a choice rock paper scissors
16:35 - i'll just put rock
16:37 - and now you can see the player's choice
16:39 - we're still printing that and it's going
16:42 - to print as rock
16:44 - great now let's just clean up this code
16:47 - a little bit we still have this here we
16:49 - don't need that dictionary that's not
16:50 - going to be part of our final code
16:52 - and now we'll make it so the computer
16:54 - can actually make a choice
16:55 - so we're going to learn about importing
16:57 - libraries creating lists and calling
17:00 - methods
17:01 - python libraries are a set of useful
17:03 - functions so you don't have to write
17:04 - code from scratch when you import a
17:06 - library to your program you get access
17:09 - to more features without writing
17:10 - additional code
17:12 - with basic python it's challenging to
17:14 - get your program to do something
17:16 - randomly but it's easy to choose
17:18 - something randomly using the random
17:20 - library
17:21 - so let me show you how we can import the
17:24 - random library
17:26 - import statements are used to import
17:28 - libraries and they're usually put at the
17:29 - top of a program so i'm going to press
17:32 - enter a few times here to add some lines
17:34 - at the top and i'm going to do import
17:36 - random
17:38 - so now we are going we we've
17:40 - imported the random library
17:43 - so we're going to use that random
17:44 - library soon but now let's learn about
17:47 - lists
17:48 - a list in python is used to store
17:50 - multiple items in a single variable
17:53 - lists are surrounded by brackets and
17:54 - each item is separated by a comma so
17:56 - here's an example i could create a
17:58 - variable called food and set it to this
18:00 - list it's going to have three items
18:02 - pizza
18:06 - carrots
18:07 - and eggs
18:09 - [Music]
18:10 - so this is a list of strings
18:15 - and then you can also get a random item
18:17 - from the list
18:19 - using we're going to use now we've
18:21 - imported random we can get a random item
18:23 - by using that that random library so i'm
18:26 - going to put dinner
18:28 - [Music]
18:29 - equals
18:30 - random dot choice
18:33 - and then i'm going to pass in the the
18:36 - list here
18:37 - so using the random library we can call
18:40 - choice and then we can pass in
18:43 - a list and it's going to choose a random
18:45 - item from that list and
18:47 - and set it to equal this dinner variable
18:52 - so right now the computer choice always
18:54 - equals paper but we want it to be a
18:57 - random choice between rock scissors and
18:59 - paper
19:01 - so before the computer choice variable
19:02 - is created we'll create a new variable
19:05 - called options and assign it to a list
19:07 - of the possible options rock paper
19:10 - scissors then we'll set the computer
19:11 - choice variable to be a random choice of
19:14 - one of the items in the options list
19:18 - okay i hope you already tried this now
19:20 - but let me show you how that's going to
19:22 - work
19:24 - we'll create options
19:27 - and we'll set it equal to this list
19:29 - of
19:31 - rock
19:34 - [Music]
19:36 - paper scissors
19:39 - and you can see the code editor will
19:40 - often pop up these boxes with more
19:43 - information about what we're doing to
19:45 - give us some some help with what we're
19:48 - trying to do here so we're going to set
19:50 - this computer choice to be
19:52 - random
19:54 - dot choice
19:56 - food not food i was looking at the food
19:59 - down there that's gonna be options
20:02 - there we go
20:04 - and let's just um try running this
20:07 - program and seeing what happens so i'm
20:10 - going to put rock
20:12 - and then we see the computer chose
20:14 - scissor it should be scissors that's why
20:16 - we're testing it out i guess i
20:19 - spelled that wrong okay so scissors with
20:22 - an s so now let me try running it again
20:26 - and you can see it shows scissors but if
20:28 - we run it enough time it should now it's
20:30 - choosing paper because it's choosing it
20:32 - at random
20:33 - okay
20:34 - that's working
20:36 - okay so now let's just delete all this
20:39 - code after the get choices function we
20:41 - don't need to test that get choices
20:42 - function anymore and now
20:45 - let's create a new function called check
20:48 - when
20:50 - so you shouldn't know enough how to you
20:51 - should know enough about how to create a
20:53 - function
20:54 - so def
20:55 - check
20:58 - [Music]
20:59 - when
21:00 - so this is just an empty function with
21:02 - nothing inside it yet
21:04 - but before we add oh with the
21:07 - colon so before we add any code inside
21:10 - the function we're going to create some
21:12 - arguments
21:15 - function can re functions can receive
21:17 - data when they're called the data are
21:19 - called arguments so when creating a
21:20 - function you can specify arguments
21:22 - inside the parentheses so we've been
21:24 - using this empty parentheses but i can
21:26 - uh put in tooth i can put in things
21:29 - within these parentheses
21:31 - when this function is called we're going
21:33 - to give it two pieces of data we're
21:36 - going to pass two pieces of data into
21:38 - the function the first piece of data is
21:41 - going to be player the second piece of
21:43 - data is going to be computer
21:45 - so the you can basically call these
21:47 - anything you want uh these are just
21:50 - we're creating new variables but when we
21:53 - call these functions we'll pass in two
21:55 - pieces of information that will then be
21:57 - assigned to the variable names player
22:00 - and computer that we can use inside the
22:03 - function
22:04 - so for now let's
22:06 - finish off with to a for a complete
22:08 - function the function has to have some
22:10 - code within the function
22:11 - so let's just add a return statement
22:13 - that's just going to return a list
22:16 - containing the elements player and
22:18 - computer
22:22 - so this check when function shouldn't
22:23 - actually return this
22:25 - this is just to kind of get get it
22:27 - quickly created it should actually
22:29 - return different things depending on the
22:31 - player and computer arguments
22:34 - an if statement will allow a program to
22:36 - do different things depending on certain
22:38 - conditions
22:39 - so an if statement will first check a
22:41 - condition and if the condition is true
22:43 - then all the lines of code under the if
22:46 - statement that are indented the same
22:47 - amount will execute so as a quick
22:50 - example i can say
22:52 - a equals three
22:54 - b equals five
22:56 - and then we can create an if statement
22:58 - here
22:59 - if
23:00 - a is greater than
23:03 - b
23:04 - then we will do something like print
23:11 - yes
23:12 - or we can do if a is
23:14 - less than b or we can do if we want to
23:17 - check if a and b are equal we can do
23:20 - eq we we'll put two equal signs now this
23:23 - is very important you never want to use
23:24 - one equal sign because a single equal
23:27 - sign is the assignment operator that's
23:29 - how you assign what variables are equal
23:31 - to so if you use a single equal sign or
23:34 - like then if i put if a single equal
23:37 - sign b without a double equal sign that
23:40 - is going to
23:42 - set a to equal b which is not what we
23:44 - want the double equal sign
23:47 - is going to check if a and b are the
23:50 - same value basically it checks if two
23:52 - values values are equal now you can also
23:55 - do
23:55 - a not equal so if you use the
23:57 - exclamation point that's not equal or
24:00 - you can use
24:02 - less than or equal to or you can do more
24:05 - than or equal to
24:06 - so i'm just going to delete all this for
24:08 - now
24:09 - so now we're going to update this risk
24:11 - turn statement uh before the return
24:13 - statement we want to we're going to
24:15 - check if player if player equals
24:20 - computer
24:21 - and if so if true will return the string
24:25 - it's a tie
24:28 - so let's do that if player
24:31 - equals computer and this is something
24:33 - that maybe you figured out yourself
24:35 - before you before you're watching this
24:38 - will return a string and the string is
24:40 - going to be
24:42 - it's a tie
24:46 - okay so now it's only going to return so
24:50 - a function does not have to return
24:52 - something
24:53 - and for this function it's only going to
24:55 - return something
24:56 - if this is true if player equals
24:58 - computer
24:59 - if not it won't return anything and just
25:02 - to make make you notice this see
25:05 - this
25:06 - line is indented within the if statement
25:09 - which is indented within this function
25:13 - and just really quick thing to note
25:15 - for a return statement parentheses are
25:17 - optional so i could also
25:19 - add parentheses like that but you don't
25:22 - need them but for now i'm just gonna get
25:24 - rid of them
25:26 - [Music]
25:28 - so currently when there's a tie the
25:30 - program now returns it's a tie
25:32 - but how does the player know that's true
25:35 - now let's have the program print which
25:36 - options that the player and the computer
25:39 - chose
25:40 - you can concatenate strings with the
25:43 - plus operator
25:44 - that just means you can combine strings
25:47 - with other strings or strings with
25:49 - variables
25:50 - so let me show you how you can print
25:53 - which options were chosen so i'm going
25:56 - to print
26:00 - you chose
26:04 - and then i'll put player so you chose
26:07 - and then we have to add a space here
26:09 - because it's going to print a space and
26:10 - then it will choose it will print this
26:13 - so if the player chose rock we'll say
26:16 - you chose rock
26:18 - and then we can concave so we
26:20 - concatenated these together but we can
26:22 - add another plus sign
26:24 - and put another string here and it's
26:27 - going to say
26:28 - computer chose oh it's like being
26:30 - covered up here by everything computer
26:36 - computer chose
26:42 - now i'm just about to type it in but see
26:44 - if you can figure out what to add at the
26:46 - end here to put in what the computer
26:47 - chose
26:52 - so computer chose
26:53 - computer or the the value of this
26:55 - variable here
26:58 - so
26:59 - a lot of times when with programming
27:02 - there's a bunch of ways to do the same
27:05 - thing so this is one way to combine
27:08 - strings and variables together there's
27:10 - another way that's a little simpler
27:13 - called an f string
27:15 - so an f string will allow you to make
27:17 - strings with and with variables and
27:20 - other python code
27:21 - so to do that you just put a variable or
27:25 - you just put f at the beginning of a
27:26 - string so let me just give you an
27:29 - example so we do age equals 25 we're
27:32 - going to create a variable and then i'm
27:33 - going to make an f string we'll make it
27:35 - a print statement and i'm going to put a
27:37 - string in here but instead of starting
27:39 - with a quotation mark it's going to
27:40 - start with an f
27:41 - and then i'm going to put gem is and
27:44 - then whenever you want to put a variable
27:46 - or any kind of python code we're going
27:47 - to put some curly braces and i'm just
27:50 - going to put the variable within the
27:52 - curly braces
27:53 - so years old and i'll put the end of the
27:56 - string
27:57 - or let me put a
28:00 - period here
28:01 - okay so gem is
28:04 - age which is going to be 25 years old so
28:08 - the f string is just a slightly simpler
28:10 - way to combine the strings and the
28:13 - variables so what i want you to do see
28:16 - if you can figure out how to update this
28:17 - line right here so it uses an f string
28:20 - and it uses these curly braces instead
28:22 - of all these pluses up there
28:28 - so yeah we're going to put f and i can
28:30 - delete
28:32 - a lot of these
28:34 - things here
28:36 - [Music]
28:40 - and then i'm going to put some curly
28:41 - braces you chose player
28:47 - there we go okay you cho there was a
28:49 - comma here you chose player computer
28:51 - chose
28:53 - computer
28:56 - okay so now we've been able to put in
28:58 - the variable within this string with the
29:01 - f string
29:06 - so we're going to test this out uh so
29:09 - in a code
29:11 - the code in this function never gets run
29:14 - so when we press the run button it's not
29:17 - going to run any of the code within the
29:18 - function unless the function is called
29:21 - within the program
29:23 - so
29:24 - we're not going to test out this
29:25 - function all right now what i want you
29:27 - to do is see if you can add a line to
29:30 - call the check when function and then
29:32 - just call it with uh rock and paper
29:37 - so we're going to just do
29:38 - check when
29:41 - rock
29:42 - or actually we have to pass in strings
29:44 - here rock
29:47 - paper
29:48 - so
29:50 - this is going to it's going to call this
29:52 - function with rock in terms instead of
29:54 - player and paper instead of computer
29:57 - so let me try stride running this
29:59 - program
30:01 - you chose rock computer chose paper and
30:04 - just don't worry about these little
30:05 - icons sometimes they just block what's
30:08 - in there but it's still behind that
30:09 - little search icon so it's to see it's
30:12 - doing you chose rock computer chose
30:15 - paper
30:16 - now let's get back to checking the
30:18 - winner
30:19 - so far this function is only going to
30:21 - check if there's a tie
30:23 - now we'll start adding code to check
30:25 - different wing conditions
30:27 - so let's learn about else and elif
30:30 - statements
30:32 - okay so down here i'm just going to give
30:34 - you i'm just going to paste an example
30:36 - so so here's the if statement if age is
30:38 - greater than or equal to 18 it's going
30:40 - to print this else so anytime this is
30:43 - not true then it's going to print you
30:45 - are a child
30:47 - okay now here i've combined it with
30:50 - something else the ellis statement ls
30:52 - just stands for else if it combines else
30:55 - and if so you have to put a condition so
30:57 - if age is greater than or equal to 18
30:59 - print you're an adult else if now we're
31:02 - going to check if age is more than
31:04 - greater than 12 you were a teenager
31:07 - else if age is greater than 1 print you
31:10 - are a child
31:12 - or else if none of these other things
31:14 - are true we'll just print you or a baby
31:20 - so and it's it's only going to do one of
31:22 - these
31:23 - it's going to get to the for once it
31:24 - gets to the first one that's true then
31:27 - it's not going to check the rest it's
31:28 - just going to kind of go to the next
31:30 - line of code after all these statements
31:33 - so it's just going to choose one and
31:35 - once it gets the first one that's true
31:36 - then it's be done with this whole
31:38 - section of code
31:42 - you can also check for two conditions at
31:44 - once let me give you an example i'm just
31:46 - going to delete all this code and i'm
31:48 - going to create an alif statement here
31:52 - elif
31:53 - else if and we're going to check if
31:55 - player is equal to rock
32:00 - and i'm just going to type in the word
32:02 - and
32:02 - and computer
32:04 - is equal to
32:06 - scissors
32:07 - so now i'm checking if
32:09 - both these conditions have to be true so
32:11 - this condition and
32:13 - this condition have to be true before
32:15 - the following
32:16 - statement will happen which we're going
32:18 - to just put return
32:21 - rock smashes
32:24 - [Music]
32:26 - scissors you
32:29 - you when
32:31 - [Music]
32:32 - okay now
32:33 - the next thing we're going to do let's
32:34 - see if we can figure out how to do this
32:35 - we're going to add another lf statement
32:38 - and this time we'll check if players
32:40 - equal the rock and computer is equal to
32:43 - paper and if so we'll return paper
32:46 - covers rock
32:47 - you lose
32:51 - so we're going to make this kind of
32:52 - easier by just copying this code and
32:55 - then i'm just going to paste in this and
32:57 - then i'll just change this so players
33:00 - equal the rock and computer is equal to
33:03 - paper instead of scissors
33:06 - paper
33:07 - and it's going to say
33:12 - paper
33:14 - covers rock
33:17 - you lose
33:19 - and we won't even have an exclamation
33:21 - point anymore because it's not exciting
33:23 - to lose
33:27 - okay and you can kind of see there's a
33:28 - few we could add a few more elif
33:30 - statements to cover all the different
33:33 - situations
33:34 - but instead we're going to talk about
33:36 - refactoring
33:37 - refactoring is the process of
33:39 - restructuring code while keeping the
33:42 - original functionality when created pro
33:44 - when creating a program it's common to
33:46 - refactor code to make it simpler or more
33:48 - understandable
33:50 - so we are actually going to refactor
33:52 - this code that i've highlighted now
33:54 - and we are going to instead use a nested
33:57 - if statement
33:58 - a nested if statement will make the code
34:00 - more understandable at a quick glance
34:03 - like
34:03 - so you can put an if statement inside
34:07 - another if else or else statement
34:10 - so you'll notice here the first elf
34:12 - statement is if player equals rock and
34:13 - the second l of statement is if player
34:16 - equals rock so see if you can figure out
34:18 - how to refactor this
34:20 - to
34:21 - not have to use the and anymore we're
34:23 - just going to use one if statement and
34:25 - one else statement and then an if
34:27 - statement under that
34:29 - elif statement
34:30 - if that doesn't make sense you can just
34:32 - see what i do right now
34:34 - so i'm going to just
34:36 - move this down a little bit
34:39 - i'm going to actually copy and paste
34:40 - some of these items but we're going to
34:42 - start with l if player equals rock we're
34:44 - not going to have this
34:46 - i'm going to put this on a new line and
34:47 - say if computer equals scissors so first
34:51 - we're going to check if player equals
34:53 - rock
34:54 - and then if so we're then going to check
34:56 - it's going to be a nested if statement
34:58 - if computer equals scissors and if
35:01 - computer equals scissors then we're
35:04 - going to use this this return statement
35:06 - here
35:07 - so i have to make sure it's indented
35:09 - correctly it's going to re so this we
35:11 - have
35:12 - we have
35:13 - player if player equals rock then if
35:15 - computer equals scissors we'll return oh
35:17 - this needs to be indented one more time
35:19 - to be on inside that if statement
35:21 - and now we don't even need this elf
35:23 - statement this can just be an else
35:26 - statement else
35:27 - because if
35:29 - the computer equals scissors there's
35:31 - only one other option because we already
35:34 - know if player equals rock and computer
35:36 - equals rock will have already returned
35:38 - it's a tie
35:39 - and by the way once you return something
35:42 - the rest of the code in a function does
35:44 - not run so if we're returning it to tie
35:46 - nothing else after that is going to run
35:49 - so we know that computer can't equal the
35:52 - rock at this point so it's either going
35:53 - to be scissors or paper so i don't we
35:55 - don't even have to check if computer
35:57 - equals paper because at this point
35:59 - computer has to equals paper and then
36:01 - we'll just return this this line
36:04 - let's see
36:06 - there we go return paper covers rock
36:09 - you lose
36:11 - so now we just basically have to add two
36:13 - more sections similar to this so this
36:15 - one is if player equals rock
36:17 - then we have to have another section if
36:19 - player equals paper and then if player
36:22 - equals scissors
36:24 - and then we just have to have the the
36:26 - stuff inside is going to be pretty
36:28 - similar just corresponding to the
36:30 - different relationships between rock
36:32 - paper scissors
36:35 - so i'm just going to copy that
36:37 - and then i will paste it here and then
36:40 - one thing is important to make sure this
36:42 - elif statement
36:44 - lines up with this else statement
36:47 - and this is now going to be
36:49 - paper
36:50 - and then we are going to check if
36:52 - computer equals rock
36:54 - and a computer equals rock
36:56 - then we will say that
36:59 - paper covers rock
37:04 - you win
37:05 - or we'll say
37:08 - scissors
37:11 - cuts
37:12 - paper
37:14 - you lose and then the final one which at
37:16 - this point i'm sure you can figure out
37:18 - on your own we're going to add one more
37:20 - section
37:21 - and this if
37:22 - player equals scissors
37:26 - and then first we're going to check if
37:28 - computer equals paper
37:30 - if so
37:31 - we will do
37:32 - scissors
37:34 - cuts
37:35 - paper we're just making sure we're just
37:37 - making it so every time the first one is
37:39 - you win the second one is you lose but
37:42 - you could do it the other way around
37:44 - and then we will do
37:47 - rock
37:48 - smashes
37:50 - scissors
37:52 - you lose
37:55 - okay we're almost finished with this
37:57 - whole program
37:58 - so both
38:00 - the get choices function and the check
38:02 - win function they're both complete
38:05 - now let code to call the functions and
38:07 - play the game
38:08 - so first let's remove this
38:11 - this check when
38:13 - now we'll create a variable called
38:14 - choices and make it equal to the result
38:18 - of calling the get choices function
38:21 - and we just have to make sure it's not
38:22 - indented it's on the the first
38:24 - the first column i guess right here not
38:27 - ended at all so we'll do
38:30 - choices
38:32 - equals get
38:34 - choices
38:35 - [Music]
38:37 - and one thing about this is it's going
38:40 - to return a dictionary so if we look at
38:42 - the get choices
38:44 - so it's returning choices and it's going
38:45 - to be a dictionary like this now let me
38:48 - just copy this i'm going to show you
38:49 - something down here i'm going to just
38:51 - paste it down here and we'll just make
38:53 - an example of what it could look like it
38:55 - could look like rock and paper i always
38:58 - use rock and paper as examples because
39:00 - scissors is a
39:01 - little harder for me to spell
39:03 - so so that's a little easier so so let's
39:06 - one thing we haven't talked about is how
39:09 - to
39:10 - uh
39:11 - how to access a and specific element
39:14 - within a dictionary so this is a
39:16 - dictionary so let's say if i call this
39:19 - um
39:22 - well i'll just call it choices even
39:24 - because we're going to delete that and
39:26 - so we're only going to have this choices
39:27 - but if choices equals this and let's say
39:29 - i just want to get the the choice of the
39:32 - player
39:33 - let me show you how i would do that
39:36 - i'll just do
39:38 - p choice for player choice and i'm going
39:40 - to put equal choices and to get just the
39:44 - the value of the player i'm going to put
39:46 - brackets so the brackets look like that
39:49 - and then i have to
39:50 - put the the key that i want the value of
39:54 - so the key would be player
39:56 - so if i
39:58 - put the name of the dictionary which is
39:59 - this
40:00 - and then i put some brackets we're going
40:02 - to use brackets to identify what is the
40:05 - key that we want the value of so here's
40:06 - the key of the with the value of rock
40:08 - and here's a key with a value of paper
40:11 - so this is how we can get the player
40:13 - choice and i'm sure you can under see
40:16 - how you get the computer choices if
40:17 - instead if
40:19 - we take this computer word and put it
40:21 - right here
40:23 - uh computer
40:25 - okay i'm just going to get rid of all
40:27 - this here
40:29 - and we're going to we have the get
40:30 - choices here
40:32 - and now listen carefully to what we're
40:34 - going to do next
40:35 - we are going to create a variable called
40:38 - result and make it equal to the result
40:41 - of calling the check win function and
40:44 - when we call the check win function
40:46 - we're going to pass in the value of the
40:49 - player key
40:50 - and the computer key
40:52 - of the choices dictionary
40:56 - so let's do that so then you'll see what
40:58 - i mean a result
41:00 - is going to be
41:02 - we're going to call
41:03 - [Music]
41:05 - check
41:06 - when
41:08 - and then we are going to pass in
41:12 - we're going to pass in we have choices
41:15 - player
41:17 - and choices
41:23 - computer
41:25 - so because remember we had that we i
41:27 - showed the example that dictionary so
41:28 - we're getting the player key the value
41:30 - of the player key and the value of the
41:32 - computer key
41:34 - so now we know who wins
41:36 - we've now this result variable is going
41:39 - to be one of these strings have been
41:41 - returned either it's a tie rock space of
41:43 - scissors paper covered rocks and so on
41:46 - so now we just have to print the result
41:50 - we're going to
41:51 - print
41:53 - the result
41:55 - okay we can try out this game
41:58 - i'm going to click the run button
42:02 - okay this is why it's sometimes better
42:05 - to test a little earlier i just forgot
42:08 - the
42:09 - semicolon on some of these so um
42:12 - semicolon
42:14 - and see there's a red arrow i should
42:16 - have seen that semicolon
42:18 - and semicolon
42:20 - okay now let's try it i'm going to play
42:23 - the program into a choice
42:25 - i'm going to do
42:27 - rock and i just noticed something else i
42:28 - want to change so enter a choice here i
42:30 - started there's a parenthesis here
42:31 - there's no parentheses at the end so
42:33 - again i'm just going to change that
42:34 - really quick so enter a choice and we're
42:37 - going to put it in parentheses here
42:39 - and
42:42 - test again so rock okay you chose rock
42:45 - computer chose rock
42:46 - it's a tie okay i'm gonna play it again
42:49 - paper
42:50 - you chose paper computer chose scissors
42:53 - scissors cuts paper you lose
42:56 - okay we just created a python game
43:00 - so hopefully this gives you a better
43:02 - understanding of what it's like to
43:04 - program in python and you you now know
43:07 - about some of the basic concepts of
43:09 - python now there's a lot more to learn
43:12 - in python and we're going to be covering
43:14 - a lot more in this course i just wanted
43:16 - to start with a game and a full program
43:19 - so just right off the bat you could go
43:21 - to program
43:22 - so in the next section i'm going to
43:24 - start going over in detail all the most
43:28 - common features of python
43:30 - and we're going to cover some of the
43:32 - features that we've already used in this
43:34 - game plus a lot of additional features
43:38 - additional common features that were not
43:39 - used in this game
43:41 - and then in the final section of the
43:42 - course
43:44 - we're going to code a more complex game
43:47 - a blackjack game
43:49 - so let's get started with the next
43:51 - section
43:52 - one of the quickest and easiest ways to
43:54 - get started with python is by using
43:56 - replit.com but you may also want to get
43:58 - python running on your local computer so
44:01 - if you want to do that you can start by
44:03 - going on over to python.org
44:06 - and these go to the downloads menu
44:08 - and then you're going to just click
44:11 - what you want to download for it for so
44:13 - it's going to default to be for you the
44:15 - operating system you're on but you can
44:17 - also go to other platforms and make sure
44:20 - you can and then just find the platform
44:22 - that you want to download on and there's
44:24 - going to be instructions on here that's
44:26 - going to tell you how to go about
44:28 - getting installed on your specific
44:31 - computer
44:32 - so there's a few different ways to run a
44:34 - python programs and one of the ways is
44:37 - with an interactive prompt so after you
44:39 - get installed if you open up your
44:40 - terminal and type in python or sometimes
44:43 - it's going to be python 3 depending on
44:46 - how you got it installed you're going to
44:48 - see this interactive prompt and then you
44:50 - can just this is called a python rebel
44:53 - it's it's different from a rebel
44:55 - creating with created with replit but
44:57 - you can start coding in python right on
45:00 - here so i could say
45:02 - name equals bow
45:06 - and then you have to make sure you
45:08 - put the the quotation marks at the end
45:11 - and now i've gotten a variable stored as
45:13 - bow and then i can just type in the
45:16 - variable name name and it's going to
45:17 - show you show me the value of the
45:20 - variable and you can type in most
45:22 - different python commands right into
45:24 - this inactive prompt here
45:27 - and then i can just quit it when i'm
45:28 - ready to quit
45:30 - it's also common to run python using
45:33 - visual studio code so if you just search
45:35 - for visual studio code you can get to
45:37 - the the download page and then you can
45:39 - just download it for your system and
45:42 - there's also you can download for
45:44 - different systems and then once you open
45:47 - up visual studio code to get python
45:49 - working you're going to want to install
45:50 - the python extension so i'm going to
45:53 - click over here to extensions and you
45:55 - can search for python or it may just be
45:57 - listed here under popular extensions and
46:00 - i'm just going to click install
46:02 - and this is going to make it easier to
46:04 - work with python on visual studio code
46:09 - so now i can just kind of close some of
46:10 - this stuff here
46:14 - and i'm going to
46:16 - create a new file
46:19 - and i can just call the and i can just
46:21 - type in name
46:23 - equals
46:25 - bow
46:27 - print
46:29 - name
46:30 - and then if i save this
46:32 - as
46:34 - test.pi it's going to now it's going to
46:37 - add the colors that correspond to
46:40 - python
46:41 - and then i'm just going to click this
46:43 - play button here
46:44 - and it's going to play it's going to
46:46 - open up a terminal window here
46:48 - and it's going to run the program and
46:51 - it's going to print bow that's what my
46:54 - program did if i zoom out a little bit
46:55 - you'll be able to see the difference so
46:57 - well we just print the name and it and
46:58 - it runs the program just like that and
47:01 - then you can see on the terminal how the
47:04 - the command that was used to run that so
47:07 - we could use the same command on any
47:09 - terminal and instead of typing this
47:11 - whole thing for the location of python 3
47:13 - i can just do python
47:16 - 3 and then you this is where that file
47:19 - is located so just copy that
47:22 - and i can paste it in here and it's
47:24 - going to run that program
47:26 - in this section we'll learn about the
47:28 - core features of python i'll go into
47:30 - more detail about some of the things we
47:32 - learned in the first project and they'll
47:34 - be covering a lot more concepts this
47:36 - section was heavily inspired by the
47:38 - python handbook by flavio copes and you
47:41 - can check that out on freecodecamp news
47:43 - and like the first part of the course
47:45 - i'll be running python in replit so once
47:47 - you get logged into replit just like i
47:49 - already showed you before you can hit
47:50 - the plus button here or the create
47:52 - button to create a new replit and then
47:55 - you can search for the programming
47:56 - language or you can just click it down
47:58 - here python we'll just create a python
48:01 - repel
48:02 - and then we can instantly start creating
48:05 - writing python code in replit
48:08 - so like i showed before we got our
48:10 - different files here we're just going to
48:12 - start by using one file here and this
48:14 - we're going to encode and this is where
48:16 - it's going to
48:17 - appear if we we run the code so i'm
48:19 - going to
48:20 - close off the list of files here
48:22 - and let's just start at the beginning
48:25 - again so you've gotten used to coding in
48:27 - python through creating a rock paper
48:29 - scissors game
48:30 - but now we're going to
48:32 - kind of do a deep dive into all the
48:35 - basic commands of python so there's
48:37 - going to be some review but we're going
48:39 - to be going into more detail about each
48:42 - of the elements and the first thing
48:44 - we're going to talk about is variables
48:47 - so we can create a new python variable
48:49 - by assigning a value to a label using
48:52 - the equal sign or the assignment
48:54 - operator so let me give you an example
48:56 - just like i was showing you before just
48:58 - name equals bo
49:00 - so let me just zoom in a little bit more
49:02 - here and so now our variable name is
49:05 - name and we've assigned it the value of
49:08 - bo
49:09 - and then we can also uh create we can
49:12 - create a variable with a number so i
49:14 - could do age
49:15 - equals
49:17 - 39. so a variable name can be composed
49:20 - of characters numbers and an underscore
49:23 - character but and it cannot start with
49:26 - the number
49:27 - so it could be anything like name one
49:30 - it could be all capital letters
49:34 - it could
49:35 - be it could have an underscore it can
49:37 - start with an underscore like i said
49:39 - like that
49:40 - and
49:41 - you can see that these are all it's
49:44 - putting these
49:45 - red squiggly lines because it's showing
49:47 - that that's not
49:49 - actual python code if you're going to
49:50 - create a variable you should be
49:51 - assigning it to a value or you should be
49:55 - using a variable that already exists but
49:58 - i'm just showing you some different
49:59 - examples of different variables now so
50:01 - here's an example of an invalid variable
50:04 - name if you just start with a number
50:07 - like that that can't be a variable
50:08 - because you can't start with a number
50:10 - and i couldn't put something like test
50:12 - exclamation point you can't use
50:14 - exclamation points you can't use percent
50:16 - signs
50:17 - and other than that anything is valid
50:20 - unless it's a python keyword so there
50:23 - are some keywords a keyword is something
50:25 - that's used to to write python like for
50:29 - if
50:31 - while
50:32 - import these are all words that have
50:34 - very specific meanings within python so
50:36 - you cannot use them for a variable name
50:39 - now there's no need to memorize them as
50:42 - the python editor here will alert you if
50:44 - you use one of those as a variable
50:47 - so that was just like
50:48 - if i say if equals
50:52 - hi
50:53 - and then you can see it's going to show
50:54 - you right here with these squiggly lines
50:56 - that we've done something wrong
50:59 - invalid syntax because and then also you
51:03 - can see that
51:04 - it turns blue this word turns blue
51:06 - because it's a keyword you can't use it
51:09 - as a variable name
51:12 - so like i said it's going to alert you
51:14 - if you if you use a keyword as a
51:15 - variable and you'll start to gradually
51:17 - recognize them as part of the python
51:19 - programming language syntax
51:21 - now let's talk about talk about
51:23 - expressions and statements in python so
51:26 - an expression is any sort of code that
51:29 - returns a value like for instance if you
51:31 - do one plus one or if you just do a
51:35 - string like
51:36 - bow this is going to like this is going
51:38 - to return to this is going to return the
51:41 - string bow so a statement on the other
51:44 - hand is an operation on a value
51:47 - so for example these are this is a
51:49 - statement here because we have an
51:51 - operation we're assigning this to the
51:53 - variable and then another statement
51:56 - would be like this print
51:58 - name
51:59 - so that's going to
52:01 - be a statement because it's doing
52:03 - something to the value now a program is
52:06 - formed by a series of statements and
52:09 - each statement is put on its own line
52:11 - like we have these two lines here but
52:13 - you can use a semicolon to have more
52:15 - than one statement on a single line so i
52:17 - i could put a semicolon here
52:20 - and then if i run the program it's still
52:22 - going to print the name and let's just
52:24 - do that we already learned how to run a
52:25 - program in replica click this button
52:27 - right here but we can see it's going to
52:30 - print bow and if i put these on two
52:32 - different lines it's going to do the
52:34 - same thing if i run the program it's
52:36 - going to still do the same thing here
52:38 - now let's talk about comments this is
52:40 - something we haven't talked about in
52:42 - this course yet so in the python program
52:45 - everything after a hash mark is ignored
52:48 - so if i put a hash mark i can say this
52:51 - is a commented line and when we run the
52:55 - program this line is going to be
52:57 - completely ignored and then we can also
53:00 - put in inline comment if i just put the
53:03 - hash mark here this is an inline comment
53:07 - and the cool thing about most code
53:09 - editors including replit is it's going
53:11 - to put comments going to make them gray
53:14 - so you know that this isn't really part
53:16 - of the program this is just some sort of
53:18 - special note that the programmer wants
53:21 - to put as part of the program
53:23 - so i want to emphasize again how
53:25 - important indentation is so it's very
53:28 - meaningful in python so you can't
53:31 - randomly indent things like you can't
53:33 - just press tab here to indent here and
53:35 - how this is kind of lined up here this
53:37 - line up here you can see this red
53:40 - squiggly line says unexpected expected
53:43 - indent
53:44 - so some other languages do not have
53:46 - meaningful white space an indentation
53:49 - doesn't matter but in python indentation
53:52 - matters
53:53 - so in this case if you try to run this
53:55 - program we can run this and you'll see
53:57 - an error right here showing up in red
54:00 - here it says indentation error
54:02 - unexpected
54:04 - indent
54:05 - because indentation has a special
54:07 - meaning so i can just unindent that here
54:10 - everything indented belongs to a block
54:14 - like a control statement or a
54:15 - conditional block or a function or a
54:17 - class body and we'll be talking more
54:20 - about those different blocks
54:23 - now let's talk about data types python
54:26 - has several built-in types
54:29 - so for instance this is a string so
54:32 - anything surrounded by quotation marks
54:35 - is a string that's one data type and you
54:38 - can check the type of a variable by
54:40 - using the type function so i could say
54:43 - type
54:44 - and then i'll put name and to make sure
54:47 - to be able to see in the console i'm
54:49 - going to print what the type is here
54:52 - and if i press if i run the program
54:55 - we'll see that the type is the class of
54:58 - str which stands for string
55:02 - and then we can test to see if something
55:04 - is a string by comparing it to str so i
55:08 - could do equals equals str
55:12 - and then if i run that it's going to say
55:15 - true because the type of name does equal
55:20 - a string
55:22 - and then we can also use is
55:24 - instance so
55:26 - i'm going to
55:28 - uh so if we instead of doing type we do
55:31 - is
55:32 - instance and then we
55:35 - have to pass it two things so
55:38 - the first thing we're going to pass it
55:40 - so we have the is instance we're passing
55:42 - it the name that's this variable and str
55:44 - we're trying to see if name is an
55:46 - instance of a string and if i run that
55:49 - it should say true again
55:52 - so we've been testing against the str
55:55 - class the string class but it works the
55:57 - same for other data types so so there
56:00 - are some data types around numbers
56:03 - so an integer number integer numbers are
56:05 - represented using the int class or the
56:08 - int class and floating point numbers or
56:11 - fractions are a type of are the type
56:14 - float so i can say age
56:17 - equals
56:19 - 2
56:20 - and then we can just check
56:22 - is instance
56:26 - and i can pass in the age and then i can
56:30 - pass in an int
56:31 - so if i run that
56:33 - we're going to see that i've done
56:35 - something wrong
56:36 - oh i spelled that wrong there we go okay
56:40 - now i'm going to try this and we'll see
56:41 - true true and i can also type in float
56:48 - true false it's not a false or it's not
56:50 - a float because it doesn't have a
56:53 - decimal point if i
56:55 - did 2.9
56:57 - then it should show that it is a float
56:59 - because it has a decimal so python
57:02 - automatically detects the type
57:04 - from the value type so it automatically
57:07 - knows this is a string it automatically
57:08 - knows this is a float but you can also
57:12 - create a variable of a specific type by
57:15 - using the class constructor passing a
57:17 - value literal or a variable name like
57:20 - for instance we have this and we check
57:23 - to see if this is a float and it's
57:25 - saying false but i can make it a float
57:28 - by typing in
57:30 - float
57:31 - and just p putting the value
57:34 - into the flow here so we're going to
57:36 - make it a float so now it's true true
57:39 - and you can do the same thing with
57:41 - strings or integers or other data types
57:45 - and you can also convert from one data
57:48 - type to another by using the class
57:51 - constructor so so that's basically what
57:53 - we did we just converted this from an
57:54 - integer to a float but i can also do
57:58 - something else i can convert something
57:59 - from
58:00 - a string
58:02 - to an integer so for instance i'm going
58:05 - to we'll just get rid of this one
58:07 - completely here and we'll just use this
58:09 - one so
58:10 - a string is anything in quotation marks
58:13 - so if i do
58:15 - 20 age 20 and i test if this is a an int
58:21 - it's going to say
58:24 - false it's not an n so i'm printing
58:26 - whether it's an instance of an int but i
58:28 - can convert this string
58:31 - into an integer by just doing integer
58:35 - and this let me run the program and it
58:37 - says true
58:39 - another thing about this is you don't
58:40 - just have to pass in the actual data or
58:43 - the actual string i can pass in a
58:45 - variable so i can say number
58:49 - equals and now i'm going to make it a an
58:52 - x it says number but it's actually a
58:54 - string but i can pass in the number here
58:58 - and then it's going to set that to age
59:00 - and it's going to be true so we create
59:03 - the string we convert the string to an
59:05 - integer and we tested that that age is
59:09 - an integer
59:11 - so when we do something like this this
59:13 - is called casting
59:15 - we are it's basically trying to extract
59:18 - an integer from this string
59:22 - of course the conversion might not
59:23 - always work depending on the value
59:25 - that's passed so for instance if we
59:28 - write test here in the string
59:31 - instead of the 20
59:34 - we may get an air so let me just run
59:35 - this and see now we have an error it
59:38 - says invalid literal for
59:40 - for int int with base 10 test so we
59:44 - can't convert the word we can't convert
59:46 - the string test to an integer so python
59:49 - does its best to do the conversion but
59:51 - it doesn't always work there are a few
59:54 - other types so let me see are some other
59:56 - common types of types so there's the
59:58 - type of complex for complex numbers bool
60:00 - for booleans list for list tuple for
60:03 - tuples range for ranges
60:05 - dict is our dictionaries and set
60:07 - is a type for sets
60:09 - and we'll explore all these soon we'll
60:12 - go into more detail about about all
60:14 - these different types of types well now
60:17 - let's talk about operators we've already
60:19 - seen one operator that's this one that's
60:21 - the assignment operator but there's also
60:24 - arithmetic operators comparison
60:26 - operators logical operators bitwise
60:28 - operators and plus some interesting ones
60:31 - like is and in so we're going to be
60:34 - going over a lot of those right now
60:36 - so we talked about the assignment
60:37 - operator which is used to assign a value
60:39 - to a variable or to assign a variable
60:42 - value to another variable now let's talk
60:45 - about arithmetic operators
60:47 - it's just what you use to do
60:49 - math mathematics
60:51 - so here are the different
60:53 - arithmetic operators so we have plus one
60:56 - plus one equals two then minus
60:58 - multiplication division
61:01 - we have
61:02 - remainder so four divided by three
61:05 - equals one but there's a remainder of
61:06 - one we have exponents four to the power
61:08 - of 2 is 16 and floor division
61:12 - so floor division does a
61:14 - division problem and then just
61:18 - basically rounds down
61:20 - so floor division does the division and
61:22 - rounds down to the nearest whole number
61:25 - so actually this would be better seen if
61:27 - we do four five divide by two five floor
61:30 - division divided by two is going to be
61:32 - two normally be 2.5 but floor division
61:35 - is rounding down to the nearest integer
61:37 - the nearest whole number
61:39 - and then also note that that
61:41 - the minus can also be a
61:44 - make something a negative number
61:47 - so i could do 4 plus
61:50 - negative or i mean 1 plus negative 1 and
61:53 - then that's just going to equal 0. and
61:55 - then the plus operator can also be used
61:58 - to concatenate string values that's
62:02 - something we talked about earlier but i
62:04 - could say
62:05 - scamp
62:06 - and then put a plus
62:10 - is a good dog
62:13 - and then like if i print this out
62:18 - i put the the parentheses around it i
62:21 - can
62:22 - and then we'll see the whole string here
62:24 - sk scamp is a good dog
62:27 - that was the name of my first dog when i
62:28 - was a kid so we can also combine these
62:32 - arithmetic operators with the assignment
62:35 - operator let me show you what i mean so
62:37 - let me just get rid of this here and i'm
62:39 - going to do age
62:41 - equals 8
62:42 - and age
62:44 - plus equals
62:46 - [Music]
62:47 - 8
62:48 - and i'll do print
62:50 - age
62:51 - so we've so all these different
62:54 - operators can be assigned with it can be
62:56 - combined with the assignment operator
63:00 - and now it's going to add
63:03 - 8
63:04 - to the age so if i
63:07 - run this it's 16. so this actually just
63:11 - means
63:13 - age
63:14 - equals age
63:17 - plus
63:20 - eight
63:21 - so this age plus equals eight is the
63:24 - same as saying age equals age plus eight
63:28 - so it's just going to add this number
63:31 - to the current age and set it equal to
63:34 - the age and you can do that with any of
63:36 - these like i could do
63:39 - times
63:41 - and that would be age equals age times 8
63:45 - and
63:47 - 64. and so on with any of these
63:50 - arithmetic operators
63:53 - okay now let's talk about comparison
63:55 - operators
63:57 - now we talked a little bit about them
63:59 - before
64:00 - but let's see some examples again so
64:03 - this is to compare if two things are
64:05 - equal
64:07 - and then we have not equal we're
64:08 - comparing them to see if they're not
64:10 - equal or count this is if a is
64:13 - greater than b
64:15 - or more than b and then this this is
64:18 - less than or equal to b
64:19 - now let me just tell you a trick of how
64:21 - i keep the keep track of which one is
64:23 - greater than and which one is less than
64:25 - if you see this less than one if you
64:28 - kind of tilt your head a little bit it
64:29 - kind of looks like an l see like l and
64:32 - this one doesn't look like as much of an
64:34 - l so this
64:36 - less than operator kind of in some ways
64:39 - looks like a capital l that's kind of
64:41 - just squished over and that's how i keep
64:43 - track of which one is less than which
64:45 - one is greater than
64:47 - and so these are all going to give
64:49 - either a false value or a true values
64:53 - speaking of true and false
64:55 - true and false are examples of boolean
64:59 - the boolean data type the boolean data
65:01 - type just means true false or true
65:04 - so a boolean is either going to be true
65:06 - or false there's only two options
65:08 - and there are a few boolean operators
65:14 - so let me show you what the boolean the
65:15 - boolean operators are either not
65:18 - and
65:18 - or or
65:22 - so when working with two or false
65:23 - attributes
65:25 - those work like logical and or and not
65:29 - so when you're using uh not
65:32 - it means it's not true you're checking
65:34 - you're checking to see something is not
65:35 - true and means they both have to be true
65:38 - and or means either this one has to be
65:40 - true or this one has to be true in order
65:43 - for the full thing to be evaluated as
65:46 - true
65:47 - and let me show you something about or
65:50 - now or using an expression returns the
65:54 - value of the first operator operand that
65:56 - is not a false value or a falsie value
66:00 - otherwise it returns the last operand so
66:04 - it's going to return
66:06 - the first operand that is not a false
66:08 - value but since this is a false value
66:10 - it's returning the second operand since
66:12 - this is a false value it returns the
66:14 - second one
66:15 - since this is not a false value it will
66:19 - return the first one
66:21 - and this is considered a false value if
66:24 - it's just an
66:25 - empty bracket that's false so it's going
66:27 - to return the second value which just
66:29 - happens to be false
66:31 - and since this is a false value it's
66:33 - going to return the second option which
66:35 - also happens to equal to false
66:39 - so
66:40 - one way to think about it for the word
66:41 - or is so the pi this is how the python
66:44 - docs describe it if x is false
66:48 - then why
66:49 - else x
66:50 - so this would be like x this would be y
66:53 - if else is false then why else x
66:57 - and then for and down here let's look at
66:59 - some examples for and and only evaluates
67:02 - the second argument if the first one is
67:05 - true so if the first argument is falsy
67:09 - such as false zero and empty string
67:11 - empty brackets it returns that argument
67:14 - otherwise it evaluates the second
67:17 - argument
67:18 - so the way the way the python docs
67:20 - describe it is if x is false then x
67:24 - else y
67:26 - okay let's quickly discuss bitwise
67:28 - operators they're very rarely used only
67:31 - in very specific situations but it's
67:34 - worth knowing what these bitwise
67:37 - operators are just in case you're in the
67:39 - very rare situation that you need to use
67:42 - them
67:43 - and then two other types of operators
67:45 - are is and in
67:48 - now is is called the identity operator
67:51 - it's used to compare two objects and
67:54 - returns true if both are the same
67:56 - objects if both are the same object and
68:00 - i'll be talking more about that later in
68:02 - the section on objects and then in is
68:06 - called the membership operator this is
68:08 - used to tell if a value is contained in
68:11 - a list or another sequence and we'll be
68:14 - talking more about the in operator when
68:16 - we're discussing lists and other
68:19 - sequences later in this course
68:21 - and the final thing i want to talk to
68:23 - you about is the ternary operator now
68:26 - the turn area operator in python allows
68:28 - you to quickly define a conditional
68:32 - so here will be like kind of the slow
68:34 - way to do it without a ternary operator
68:37 - so let's say you have a function that in
68:39 - this function is comparing age with 18
68:43 - and it's going to return true or false
68:45 - depending on the risk result
68:47 - so instead of writing like this
68:50 - we can implement it with a ternary
68:53 - operator so let's do death
68:58 - [Music]
68:59 - is
69:00 - adult i'll call it is adult 2 because
69:03 - it's the second way of doing it and this
69:06 - time we're going to use the ternary
69:08 - operator it's just going to be return
69:11 - true
69:13 - if age
69:15 - is greater than 18
69:18 - else
69:22 - false
69:24 - so you can see first we define the
69:27 - result if the condition is true
69:29 - then we evaluate the condition
69:32 - and then we define the result if the
69:34 - condition is false
69:36 - it's basically an if else statement all
69:38 - on a single line
69:40 - okay let's talk more about strings in
69:44 - python so a string in python is a series
69:46 - of characters enclosed in quotes in
69:49 - double quotes or it could be
69:52 - single quotes
69:54 - as long as the type of quote is the same
69:57 - on both sides and we already talked
69:59 - about how you can assign a string to a
70:03 - variable
70:04 - [Music]
70:06 - and we already talked about how you can
70:08 - concatenate two strings using the plus
70:10 - operator like phrase
70:14 - equals bo and then you can concatenate
70:17 - with the plus operator
70:19 - is my
70:21 - name
70:21 - [Music]
70:25 - and then
70:26 - also instead of putting a string here
70:29 - you can put the variable so i could put
70:31 - name is my name and we already have the
70:34 - variable here to equal bo so when you
70:36 - concatenate you can concatenate the
70:38 - strings or the variables
70:40 - you can also append to a string using
70:43 - the plus equal operator so let's say i
70:45 - want to add to this name and i'm so i'm
70:48 - going to say name
70:51 - plus equals
70:56 - is my name so we're adding is my name to
70:59 - the end of this so i can say
71:02 - print
71:05 - name
71:06 - and then we can see what it looks like
71:08 - when you use the plus equal operator
71:11 - so bo is my name
71:14 - and then we already talked about how you
71:16 - can convert a number to a string using
71:19 - the
71:20 - str class constructor like if we had age
71:24 - equals we could make this a string
71:28 - but we passed this integer it converts
71:30 - to a string and now it's going to be a
71:32 - string
71:33 - now here's something new a string can be
71:35 - a multi what can be multi-line when
71:38 - defined with a special syntax so if you
71:41 - enclose it if you enclose the string in
71:43 - a set of three
71:45 - quotes
71:46 - so let me show you an example get rid of
71:48 - all this
71:50 - and i'm going to
71:52 - print an entire
71:54 - string here
71:56 - so we're going to make this a multi-line
71:58 - string i'm going to put three quotation
72:01 - marks
72:02 - and then it's going to start with three
72:04 - quotation marks and end with three
72:06 - quotation marks and then i can make it
72:08 - multi-line so i can say bo is and then i
72:12 - can
72:13 - put some extra lines
72:15 - 39
72:17 - years old now if i print that
72:21 - and you can see it's going to print
72:23 - the different lines here so we just made
72:25 - a multi-line string
72:27 - and you can also instead of using the
72:29 - double quotes you can put a single quote
72:31 - as long as they're the same at the
72:34 - at the beginning and ending
72:36 - now a string also has a set of built-in
72:39 - methods let me show you an example so if
72:41 - i have this string
72:44 - bow but i'm going to put at the end of
72:46 - the string i'm going to put dot
72:49 - upper and i put parentheses at the end
72:52 - so if i run this now it's going to print
72:54 - it in all capital letters
72:57 - and the same thing you can use with
72:59 - lower so if it if i had a string that
73:02 - had a few capital letters
73:06 - okay now it's all
73:07 - lower now i can also type in a title
73:11 - and this is going to
73:13 - make each lut so i can say
73:16 - bow
73:17 - person
73:18 - uh and i do this so it's going to cat
73:21 - it's going to a title that's going to
73:23 - make the first letter of each string
73:26 - a capital letter
73:28 - i can also check things like i can say
73:32 - is lower and it's going to check if it's
73:35 - all lowercase letters false but if i
73:38 - make it so it is all lowercase letters
73:41 - it's going to say true so here's just a
73:45 - list of a few common ones
73:48 - [Music]
73:51 - you can do is alpha to check if it
73:53 - contains only characters
73:55 - is
73:56 - l num to
73:58 - check if a string contains characters or
74:00 - digits and is not empty is decimal
74:03 - lower to make it lower case is lower
74:06 - upper is upper title starts with to
74:08 - check if it starts with a specific
74:09 - substring to check if it ends with you
74:11 - can replace part of a string split a
74:14 - string you can strip the white space
74:17 - from a string you can append new letters
74:20 - to a string you can find the position of
74:22 - a substring spring string and there's a
74:25 - few more but these are some of the most
74:26 - common things you can do with a string
74:30 - and then one thing to know about these
74:32 - is that they they all return a new
74:36 - modified string they don't actually
74:39 - alter the original string so let me show
74:42 - you what i mean by that so let's say we
74:44 - have we'll do name equals bow again let
74:48 - me zoom in a little bit
74:50 - and we're going to
74:52 - print
74:54 - name dot lower
74:59 - now i'm going to print
75:01 - name
75:02 - so if i just run this
75:06 - and we first figure out what went wrong
75:09 - here it looks like there's a few extra
75:12 - parentheses
75:14 - [Music]
75:18 - okay let's run this and you can see it's
75:21 - going to make it all lowercase but then
75:24 - when i print the name again
75:26 - it's not still lowercase because this
75:29 - just returns a brand new modified string
75:32 - it doesn't actually change anything
75:34 - in the original string
75:38 - and then you can use some global
75:40 - functions with strings as well so one
75:43 - function we haven't discussed yet is the
75:45 - l e n function which stands for length
75:48 - it can give the length of a string so
75:51 - i'm going to type an l-e-n
75:53 - and then so there's just some global
75:55 - functions that work with a lot of
75:56 - different types of data and the length
76:00 - of this is four you can see
76:03 - and then you can use the in operator now
76:07 - i briefly mentioned the n operator
76:09 - earlier so
76:11 - let me show you one use case so we can
76:14 - use the in operator to check if a string
76:17 - contains a substring like for instance i
76:20 - can say
76:22 - a u
76:24 - in
76:25 - name so let's check if name
76:29 - contains the letters a u
76:32 - well true it does but if if if it if it
76:37 - if it didn't if i just add an extra
76:38 - string it's going to say
76:40 - false
76:41 - okay another thing with strings um
76:45 - escaping is a way to add special
76:48 - characters into a string
76:51 - for example let's say we wanted to add a
76:54 - double quote within the string how can i
76:57 - add a double quote into a string that's
76:59 - wrapped in double quotes if i put a
77:02 - double quote like that that's not going
77:04 - to work because this is going to be the
77:06 - string and then it's not going to the
77:08 - code editor is not going to know what to
77:09 - do with this last little bit here
77:12 - so
77:12 - the way to go is to escape the double
77:15 - quote inside the string with the
77:17 - backslash character so right before this
77:20 - quote i'm going to put the backslash
77:22 - character
77:23 - and then you can see it now all is all
77:26 - the same color as a string and if i
77:28 - print it it's going to it's not going to
77:31 - print the backslash character so putting
77:33 - a backslash is how you escape a
77:35 - character and that just means
77:38 - this
77:39 - the the backslash character means that
77:40 - the next character is not going to mean
77:42 - what it normally means
77:44 - it's going to actually just be the
77:47 - string of that character
77:49 - and you can do the same thing with so
77:52 - with in this particular example you may
77:55 - not need to do it because you can always
77:57 - just put a single quote at the beginning
78:00 - and ending
78:01 - and as long as you have a different type
78:04 - of quote at the beginning and ending
78:06 - then
78:08 - you can put a double quote in the middle
78:10 - but let's say you want a string that
78:13 - contains both a single quote and double
78:15 - quote within the string
78:16 - then you will have to backslash like if
78:18 - i just put a single quote there it's
78:19 - going to mess it up but if i put it
78:21 - backslash
78:22 - now it's going to have the single the
78:25 - double quote and the single quote right
78:27 - within the string
78:29 - and
78:30 - you can also use the escape character
78:32 - for
78:33 - special formatting characters like uh
78:37 - for instance what if i want there to be
78:39 - a new line between the first two and the
78:42 - last two letters of the string if i do
78:44 - slash n
78:46 - that is going to not actually just put a
78:48 - slash in let's see what happens when i
78:50 - put that this is means new line you can
78:53 - see it says be new line a you
78:56 - and then another way a reason why you
78:59 - may want to use an escape here like
79:01 - let's see what happens if i do this
79:03 - this
79:04 - that's not looking how i want to look
79:06 - because it's normally normally when
79:09 - the code is running if it sees this
79:12 - backslash it thinks it's an escape
79:14 - character so if you want to actually add
79:16 - a backslash to a string you have to
79:18 - escape the backslash so now it's be
79:21 - backslash au
79:24 - okay we're done talking about escape
79:26 - characters now i'm going to tell you how
79:28 - you can get a specific character in a
79:32 - string so given a string you can get its
79:35 - character using square brackets to get a
79:38 - specific item given its index starting
79:41 - from zero
79:42 - so
79:43 - one thing to know about programming is
79:46 - that
79:47 - whenever you're counting from in most
79:49 - programming languages you start counting
79:52 - starting at zero so this is going to get
79:55 - the letter at index one so this is index
79:59 - zero the b the e is at index one index
80:02 - two index three so if i run that we can
80:05 - see we are getting the e that's at index
80:09 - one if i want to get the b i just put a
80:12 - zero in the brackets and we get the b
80:15 - and then we can use a negative number to
80:18 - start counting at the end so if i put
80:21 - negative one it's going to start here
80:23 - zero
80:24 - one and that's going to be a oh you okay
80:27 - i guess when it's going backwards it's
80:29 - not going to start zero because there is
80:31 - no negative zero that makes sense so
80:33 - negative one is going to be the last
80:35 - character in the string so negative one
80:37 - negative two negative three and so on
80:40 - we can also use a range using what we
80:43 - call slicing so if i put 1 colon 2
80:47 - this is going to be every character
80:50 - starting at index 1
80:52 - and ending before index 2. so it starts
80:56 - at index 1 so it starts with that
80:58 - character and it ends before an x2 which
81:00 - is a so that's actually only going to
81:02 - return an e
81:05 - but if i put 3 here
81:08 - now we can return a u
81:11 - and if i put bo is cool we can put one
81:15 - further down i'm going to put 7
81:17 - and we can see
81:18 - it's going to return part of this string
81:24 - and then you can also start if you just
81:27 - put a blank before the colon then it's
81:30 - going to turn everything up to it's
81:32 - going to start at the beginning and
81:33 - return everything up to character seven
81:36 - and you can also do in the opposite
81:37 - direction so if i put a blank after the
81:40 - colon it's going to go to the end of the
81:42 - string so it's going to say is cool
81:45 - so let's talk about
81:46 - booleans well we already talked more
81:48 - about we already talked about booleans
81:50 - but we're going to talk a little bit
81:51 - more about boolean which is considered
81:54 - the bool type and this can have two
81:56 - values true or false so i can say done
82:01 - equals
82:03 - true
82:04 - or you can do done
82:06 - equals false now
82:09 - notice that it always has a capital t or
82:11 - a capital f so
82:13 - if you don't put a capital t or capital
82:15 - f it won't be considered the the true
82:17 - boolean value in python
82:19 - and booleans can be especially useful
82:22 - with the conditional co
82:24 - with conditional control structures like
82:26 - if statements
82:28 - well we already discussed if statements
82:30 - in the first part of the course and
82:31 - we'll be discussing them more in detail
82:34 - later but let me just show you an
82:35 - example so if done and i'm going to
82:38 - erase this done because we want to be
82:41 - true so if done
82:43 - and then we'll say print
82:48 - yes
82:50 - [Music]
82:53 - else
82:54 - print
83:00 - no
83:02 - okay so i can run that and it's going to
83:04 - print yes because done
83:06 - equals true but if done equals false
83:10 - [Music]
83:13 - then it's just going to say
83:15 - no
83:15 - so when evaluating a value for true or
83:18 - false if the value is not a bool or
83:22 - boolean like if it's not true or false
83:24 - we have some rules depending on the type
83:26 - we're checking so numbers are always
83:29 - true
83:30 - except for the number zero
83:33 - if i put 0 here it's going to evaluate
83:37 - to false but if i put any other number
83:40 - here it's going to be true even like
83:44 - negative 1 or anything like that it's
83:46 - going to be true oh i guess
83:49 - that i didn't put negative 1 i put
83:50 - equals 1. so if it's negative 1 that's
83:53 - going to be true
83:55 - so strings are always false
83:59 - oh
84:00 - strings are false only when empty
84:04 - so if i say
84:06 - bow here this is going to be true
84:08 - because it's not an empty string but if
84:10 - i make an empty string then it's going
84:12 - to be
84:13 - false
84:15 - lists tuples and sets and dictionaries
84:18 - which we'll talk about more later are
84:20 - false only when empty so it's going to
84:22 - be if a list double star dictionary is
84:25 - is filled with something that is true
84:28 - and then also you can
84:30 - check if a value is a boolean so if i
84:33 - say done equals true
84:36 - i can do
84:38 - print
84:41 - type we're going to check the type we're
84:44 - going to check if the type of done
84:47 - equals
84:49 - bool so let's check it does that equal
84:52 - boolean
84:53 - true it does now let's see let's
84:57 - change this to a different type and it's
85:00 - going to say false so it can still
85:02 - evaluate whether this is true or false
85:04 - but the type is not a boolean the type
85:07 - is a string
85:08 - and let me show you another example code
85:12 - so the global
85:14 - the any function it's a global function
85:17 - it's very useful when working with
85:18 - booleans
85:20 - it returns true if any of the values of
85:23 - the iterable such as a list if any of
85:26 - them are true it's going to return true
85:28 - for all of them so
85:30 - for instance book one read that's true
85:32 - but book two read that's false but this
85:35 - is going to return true because it's
85:38 - checking if any of them are true and
85:40 - then it's going to set this to true
85:44 - now the all function is is similar but
85:46 - returns true if
85:48 - all of the values are true so
85:52 - we see we have this value as true
85:55 - we have this value as false
85:58 - whereas any would have returned true
86:00 - this is going to return false because it
86:02 - only returns true if all of the values
86:05 - are true
86:08 - okay now let's talk about more
86:10 - number data ties we already talked about
86:12 - int an integer whole number we've
86:14 - already talked about float which is any
86:18 - number with a decimal point there's
86:20 - another type called complex
86:22 - complex numbers are an extension of the
86:25 - familiar real number system in which all
86:28 - numbers are expressed as a sum of a real
86:30 - part
86:31 - and an imaginary part
86:33 - imaginary numbers are real multiples of
86:35 - the imaginary unit which is the square
86:38 - root of negative one often written
86:40 - i in mathematics or j in engineering
86:44 - python is built in support for complex
86:46 - numbers which are written with
86:48 - the the j notation so the imaginary part
86:52 - is written with a s with a j suffix
86:55 - so you can combine it you can use a
86:58 - literal value like complex
87:02 - equals
87:03 - two plus
87:05 - three j so the the j means it's the
87:08 - imaginary part of the number or you can
87:11 - use the complex constructor so i can put
87:14 - num
87:15 - equals
87:17 - complex
87:18 - and then i can pass in
87:20 - two comma three so
87:23 - the three part is the imaginary part the
87:26 - two is the the real part the integer
87:29 - part
87:30 - and then once you have a complex number
87:34 - you can get it's real or imaginary part
87:37 - like this so i can say print
87:39 - [Music]
87:40 - num
87:41 - dot real
87:43 - or num
87:45 - dot match
87:47 - so this is going to be the 2 this is
87:50 - going to be the 3. so if i just
87:52 - uh
87:54 - let me
87:55 - i think the problem was
88:00 - num
88:00 - num one no so i'll do num one and num
88:03 - two and we're gonna do this as num two
88:06 - okay let's check this so
88:08 - this is the real part this is the
88:10 - imaginary part you can see they're being
88:12 - returned as floats
88:15 - and you can use the type function to
88:18 - check the type
88:20 - so now let's talk about some built-in
88:21 - functions that help with numbers so one
88:24 - of them is abs abs will return the
88:27 - absolute value of a number so if i say
88:31 - 5.5
88:33 - that's just going to be
88:35 - 5.5 but if i put negative 5.5 well
88:39 - it will be 5.5 so
88:42 - [Music]
88:44 - so if i print this see 5.5 basically it
88:47 - just makes it so it's not negative
88:49 - then you can also use
88:51 - round so if we do round
88:55 - let's make this just 5.5 round is going
88:59 - to round to the nearest integer so if i
89:01 - do this it's just gonna be six so point
89:04 - five is going to round up but if we did
89:06 - uh
89:07 - four nine
89:09 - it's going to go down to five
89:11 - you can also specify a second parameter
89:14 - to set the decimal points precision so
89:18 - i can
89:21 - go to if i do
89:23 - one here and i round it it's going to
89:26 - instead of rounding to the nearest
89:28 - integer it's now going to round to the
89:29 - nearest tenths place value or one
89:33 - decimal point
89:34 - there are several other math utility
89:36 - functions and constants that are
89:37 - provided by the math standard library
89:39 - like there's a math package a c math
89:41 - package decimal pages fractions package
89:44 - that makes it easier to work with
89:47 - different types of numbers we'll explore
89:49 - some of those more later on
89:50 - now let's talk about in nums and noms
89:53 - are readable names that are bound to a
89:55 - constant value so to use a noms we're
89:58 - going to have to import and numbs from
89:59 - the inum standard library module
90:02 - like this from enum import enum and now
90:06 - we'll be talking more about
90:08 - importing
90:10 - stuff from modules later but once you
90:13 - import it then we can initialize a new
90:15 - and nom in this way so do class
90:18 - state enum
90:23 - and so we can have inactive
90:27 - [Music]
90:28 - equals 0
90:30 - and active
90:31 - [Music]
90:32 - equals one
90:35 - so basically the the word state this can
90:37 - be anywhere any
90:39 - word we like so we're setting
90:42 - uh
90:44 - basically a variable called
90:45 - state.inactive
90:46 - which is going to equal 0 or
90:48 - state.active to equal 1.
90:50 - so
90:51 - you can reference this how you would
90:52 - reference it you can do print
90:55 - state
90:56 - dot
90:57 - active
90:59 - and then if i just run the program we'll
91:02 - see
91:03 - now you can see it's just going to
91:04 - return state to active instead of one
91:07 - so to actually get the value you use
91:09 - state to active dot value
91:11 - and then we run that and then we'll see
91:13 - one here
91:15 - if you we want to just return
91:16 - state.active that the sa that value can
91:19 - be reached by the number assigned in the
91:21 - num so state we can do
91:24 - one
91:25 - and if i print that it's now going to
91:27 - say state.active
91:29 - same for using the square brackets
91:31 - notation so i could do states
91:35 - i'll do see square brackets and put
91:38 - active
91:39 - if i print that it's going to print
91:42 - state that active so this is basically
91:46 - the only way to create constants in
91:49 - python
91:50 - python is no way to enforce the variable
91:53 - should be a constant so some people use
91:56 - enums to create a constant
91:59 - and then nobody can reassign the value
92:01 - so
92:02 - when we do
92:03 - state
92:05 - or state active dot
92:08 - value
92:10 - so this is it's not going to be able to
92:11 - be reassigned so basically there's two
92:14 - ways to do we can do this bracket
92:15 - notation or we can go back to the other
92:18 - way
92:19 - active
92:20 - now we can also list all the possible
92:22 - values for enum so
92:25 - our num is called state and we can now
92:27 - just print all the values oh i actually
92:30 - did that wrong it's supposed to be a
92:31 - list
92:33 - so this is going to list the values of
92:35 - the state
92:37 - and we can see we have inactive 0 and
92:40 - active is 1. and we can also count them
92:44 - using the length function so we're going
92:46 - to print the result of a length state
92:49 - and that's just going to give us 2.
92:51 - okay let's talk about more about user
92:53 - input now we already discussed a little
92:54 - bit in our first program
92:56 - but you can do get user input by using
93:00 - the input function so let's just get rid
93:02 - of all this
93:04 - and we'll do
93:06 - age
93:07 - equals input
93:10 - and we can say
93:12 - print
93:14 - your age is
93:18 - and then we just can concatenate that
93:20 - with the
93:22 - variable age and then also if you want
93:25 - to
93:26 - so let's just do a quick test and right
93:28 - now it's looking for the age right now i
93:30 - can put five your age is five so there's
93:33 - two ways to make it say what is your age
93:35 - we can do a print statement right before
93:37 - here
93:38 - and do what is
93:41 - your age
93:43 - and then
93:45 - now we can put four your age is four
93:48 - now you can also ins instead of
93:51 - putting the print statement right before
93:52 - here i'm going to copy this delete that
93:55 - and we can put it right in this input
93:58 - function
93:59 - and then i'll say it'll still say what
94:01 - is your age and i can
94:03 - put an age here
94:09 - so one thing to really realize about
94:11 - this is that it gets the input at
94:13 - runtime meaning the program will stop
94:16 - execution and will wait until the user
94:18 - types something and presses the enter
94:20 - key
94:21 - you can also do more complex input
94:23 - processing and accept input at program
94:26 - invocation time and we'll see how to do
94:28 - that later on
94:30 - if you want to get the input when the
94:32 - program is run that's going to work
94:33 - better for command line applications
94:35 - other kinds of applications will need a
94:37 - different way of accepting input
94:39 - let's look more at control statements
94:42 - this is another thing we've already
94:43 - discussed earlier but we're going to
94:46 - review it and and look at it in a little
94:48 - more detail so a control statement is
94:50 - like an if statement so if condition
94:52 - that's this variable here equals true
94:54 - then it's going to run everything in the
94:56 - block a block is
94:58 - the part that is indented one level
95:01 - usually it's going to be either four or
95:03 - two spaces in this case it's four spaces
95:05 - sometimes it's two spaces it doesn't
95:07 - matter it could even be one space as
95:08 - long as it's the same as long as every
95:11 - line of code is indented the same amount
95:13 - so if i just run that
95:15 - the condition was true the block can be
95:18 - formed by a single line or multiple
95:19 - lines and it ends whenever you move back
95:21 - to the previous indentation level
95:24 - so
95:25 - for instance if once we are not indented
95:28 - i can say print
95:30 - outside
95:32 - if
95:32 - so then
95:34 - that's always going to pres it's always
95:35 - going to print this because it's not in
95:37 - that if statement
95:39 - and then we have the if else statements
95:41 - where the else is if
95:43 - if this does not true then it's going to
95:45 - do whatever is in here so if i just
95:48 - change this to false
95:49 - then it's going to
95:51 - print whatever the condition was false
95:54 - and then we can have this series this is
95:56 - something that we showed in the per the
95:57 - program earlier but if and then elif
96:00 - combines else and if so
96:02 - if this is not true then i'll move on to
96:04 - this line and else
96:06 - if this is true then i'll do this else
96:08 - if this is true and it'll just keep
96:10 - going on and then it will always do the
96:13 - this is if none of the other ones were
96:14 - true it's going to do this
96:18 - so since
96:19 - it was testing this it's not even going
96:21 - to evaluate anything later but if we
96:25 - move this to false
96:27 - and we change this to bow
96:30 - then it's actually going to skip all the
96:32 - way down
96:33 - all the way to this else here
96:36 - and if we do flavio
96:39 - you can print that and then it's going
96:41 - to say hello flavio from right here
96:44 - okay that's all we're going to talk
96:45 - about for this for now since we've
96:46 - already covered it earlier in the course
96:48 - now i'm going to go into more detail
96:50 - about lists lists are an essential
96:53 - python data structure and so an example
96:57 - of a list would be let's create a list
96:58 - called dogs so we're going to create
97:02 - the dog names we have roger we have sid
97:06 - and this allows you to group together
97:08 - multiple values and reference them all
97:10 - with a common name so we have a list of
97:13 - dogs and this is just two strings so the
97:16 - list always going to have the opening
97:17 - closing brackets and each item in the
97:19 - list is going to be separated with a
97:21 - comma and a list can hold different
97:23 - types of values so these are all strings
97:26 - but we can
97:27 - have a string
97:28 - an integer a string a
97:31 - boolean
97:33 - and you can mix different types of data
97:36 - types
97:37 - in a single list
97:39 - and then you can check if an item is
97:41 - contained in a list with the in operator
97:45 - so we talked about the in operator
97:47 - earlier but let me show you how that
97:48 - works so we're going to print here's
97:50 - where we can use the in operator we're
97:53 - going to check if roger
97:55 - is
97:56 - in
97:57 - dogs
97:58 - so let's see
98:00 - so run that true but now let's check if
98:03 - bo is in dogs well
98:05 - false because it's checking
98:08 - so this is how you can check if an item
98:10 - is in a list
98:11 - you can also define a list as an empty
98:14 - string so i could actually just
98:16 - remove all this and now we just have an
98:19 - empty list and this is obviously still
98:21 - going to be false because there's
98:22 - nothing in that list
98:24 - but let's go back to when we had some
98:27 - items in the list
98:29 - and you can reference items in a list by
98:32 - their indexes starting with zero so i'm
98:36 - going to do dogs and then i can use
98:38 - these brackets so and now i'm going to
98:40 - put the so this is where we're going to
98:42 - reference the thing
98:43 - an item from the list and i'm going to
98:45 - type in 0 which will be this item right
98:48 - here roger or i could put 2 and it's
98:52 - going to do 0 1 2 and now we're going to
98:55 - have sid
98:57 - and the same
99:00 - and you can use this same notation to
99:04 - update an item
99:06 - in a list so i'm going to add another
99:08 - line of code here and put dogs 2 is
99:11 - going to equal
99:18 - bo
99:19 - and now i'm just going to print the
99:20 - entire list here and now
99:23 - instead of
99:25 - being roger 1 said true to roger 1 bow
99:28 - true
99:29 - because we've updated the item at index
99:32 - 2 to be bo instead of sid
99:38 - now you can also use the index method
99:42 - so
99:42 - um instead of
99:45 - like if i want to find the first item in
99:47 - the list i could do it like this
99:49 - so you can also use a negative number
99:52 - here
99:53 - just how we saw on the string so
99:55 - negative 2 is going to start with one
99:56 - two
99:58 - actually let's do negative one so it
100:00 - should return true here
100:02 - okay true so it starts with this one if
100:04 - you put a negative number
100:07 - you can also extract part of a list now
100:10 - this is very similar to what we showed
100:13 - using
100:14 - with the string let me just add another
100:16 - item here
100:17 - [Music]
100:21 - now i am going to
100:25 - use the colon to do part of a list so
100:27 - i'm going to 2
100:28 - 4
100:29 - and so this is a slice
100:32 - so it's going to start at the second or
100:35 - zero
100:36 - one
100:39 - two
100:40 - which is now bow because we change it to
100:42 - bow and it's going to go through four
100:45 - it's going to go through four but not
100:46 - over pat not including four so it's
100:49 - going to be 2
100:50 - 3
100:51 - and then not 4 so it's just sid and true
100:54 - or bow and true because we updated 2 to
100:56 - bow
100:57 - and you can also just leave this blank
100:59 - so it's going to go through the end of
101:00 - the list or if you
101:02 - leave the first number blank
101:05 - it's going to go it's going to start at
101:07 - the beginning of the list and we can go
101:09 - through for instance index three
101:12 - and so that's a way to slice the list
101:15 - you can also
101:17 - use the the length function so let's
101:20 - find out how many items are in the list
101:22 - i'll use the length the length of dogs
101:25 - is six or six items in the list we can
101:28 - also add items to the list by using the
101:31 - append method so i'm going to do dogs
101:35 - dot append
101:36 - and then i can
101:39 - add an item so i can say something like
101:42 - judah and now if we see the length
101:44 - there's now going to be 7 and if we just
101:47 - print
101:48 - the full list
101:50 - then we can see that we can see all the
101:52 - items including the one that was just
101:54 - added we can also use the extend method
101:58 - the extend is another way to add an item
102:02 - to a list so if i do instead of dogs
102:05 - append i can do dogs that extend
102:09 - and then i'm going to pass in
102:11 - instead of just passing in the string
102:13 - i'm gonna pass in
102:15 - the item as a list so i'm gonna and it's
102:19 - gonna add it just the same but now i can
102:21 - actually
102:23 - combine two lists together so i'm gonna
102:26 - put a five so if i do this we can see
102:29 - now we are taking this list and
102:32 - extending it by adding this list on the
102:35 - end this is a two item list and we have
102:37 - that six m list and now we have the
102:38 - eight item list
102:40 - you can also use the
102:42 - plus equals operator so
102:46 - to use the plus equals operator i'm
102:48 - going to do dogs it's the same it's
102:50 - going to do the same thing as extend
102:53 - so plus equals
102:55 - and then we have this list take this
102:58 - parentheses off here and it should look
103:00 - exactly the same see it's showing up the
103:02 - same thing up here
103:03 - so the plus equals is going to be the
103:06 - same thing as extend where it takes the
103:09 - list that's already exists and adds this
103:12 - other list to the end
103:15 - and when you're using the extend or the
103:17 - plus equals
103:19 - you don't want to forget the square
103:21 - brackets
103:22 - here so if you if you forget the square
103:25 - brackets and let's say i'm just going to
103:26 - add this iron to the list
103:29 - it's now actually going to put each
103:31 - letter individually here
103:33 - so if i you can kind of see it better if
103:35 - i move over here
103:39 - so it so that so you want to make sure
103:41 - you put the the brackets
103:44 - and another thing you can do is remove
103:47 - you can remove an item using the remove
103:50 - method so i'm gonna do
103:52 - dogs dot remove
103:55 - sid
103:57 - okay now i'm gonna play it here and
104:01 - it's saying
104:07 - what did i do wrong here
104:11 - oh obviously um i'm moving sid but we've
104:14 - already changed the element of sid to
104:16 - bow so let's remove
104:18 - quincy and let's try that
104:22 - okay so now there's no quincy
104:25 - so another common thing to do another
104:28 - common list method is pop so if i do
104:32 - dogs.pop
104:34 - it's going to remove and return a single
104:37 - item so first i'm going to
104:40 - [Music]
104:43 - do dot
104:44 - print dogs that pop and then i'm going
104:45 - to print dog so if i
104:47 - so first it's going to return 5 that was
104:50 - the last item that we added onto the
104:52 - list and now when i print the list that
104:54 - item's not in the list so pop is going
104:57 - to remove the last item from the list
105:00 - and it's going to return the last item
105:03 - it's going to return and remove the last
105:04 - item from the list and then it's not on
105:06 - the list anymore
105:09 - now let's make this
105:11 - let's let's simplify this just go back
105:13 - to the initial list and i'm going to
105:14 - change this to items
105:16 - now i'm going to show you how to add an
105:18 - item in the middle of the list at a
105:20 - specific index you can use the insert
105:23 - method so i'm going to do items dot
105:26 - insert
105:27 - i'm going to put the index which is
105:28 - going we're going to insert at the index
105:30 - number two and the item is going to be
105:32 - test
105:33 - and then i'm just going to print that
105:35 - print
105:37 - items
105:38 - and then i'll run that and then we can
105:40 - see it index number two we now see the
105:42 - item test
105:44 - now to add multiple items at a specific
105:47 - index you need to use slices so
105:50 - let me show you how you do that so we're
105:52 - going to do a slice
105:56 - and i'm going to set that equal to
105:59 - test
106:00 - 1
106:03 - test
106:06 - 2.
106:07 - we print that
106:08 - so now you can see we have test 1 and
106:10 - test 2 right here
106:12 - right behind this search thing here
106:14 - and we've inserted multiple items into
106:17 - the list starting at index 1.
106:21 - now you can also sort a list
106:24 - so if i do
106:26 - here we go um
106:28 - items dot sort
106:31 - it will sort the list
106:36 - but you have to make sure okay we have
106:38 - an error it's not supported between
106:40 - we have a combination of ins and strings
106:44 - so let's
106:45 - make it so it's all strings in the list
106:49 - and
106:51 - then it should
106:53 - be able to sort it
106:57 - okay
106:58 - now the
106:59 - strings are in alphabetical order and if
107:02 - we're using integers or floats and they
107:03 - would just be in numerical order
107:06 - now one thing that's interesting about
107:08 - that if i put change this to
107:11 - bow
107:13 - you'll see now we have this at the
107:15 - beginning and this at the end
107:18 - so
107:19 - a the sort method orders uppercase
107:21 - letters first and then lowercase letters
107:24 - so to fix that actually to make it
107:27 - make more sense we're going to change
107:28 - that to
107:29 - bob and to fix that
107:32 - within the sort i'm going to i'm going
107:34 - to put key equals str dot lower
107:40 - and now
107:42 - it's going to sort these correctly how
107:44 - you would imagine not caring about
107:46 - uppercase or lowercase letters
107:50 - sorting modifies the original list
107:52 - content so to avoid that you can copy
107:55 - the list content using
107:58 - so let me show you if we do
108:03 - items
108:06 - items
108:09 - copy
108:10 - equals
108:11 - items
108:12 - and then we make a slice
108:15 - with with nothing at the beginning and
108:16 - nothing at the end so it's going to
108:18 - start at the beginning of the list to
108:19 - the end of the list and now we can have
108:22 - a copy and i can print
108:26 - items copy
108:28 - so if i print that so now we see we have
108:30 - the sorted list that's that we ran the
108:33 - sort on but we also still have
108:36 - the original list
108:40 - so it with all the words in the original
108:42 - order
108:45 - and there is also a way to sort a list
108:48 - without returning a
108:51 - new list
108:53 - there is also a way to sort a list
108:56 - without modifying the original list so
108:59 - instead of copying a list
109:02 - um what i'm going to do
109:04 - is
109:06 - i items
109:08 - instead of doing items dot sort
109:11 - we are going to do
109:13 - we're going to use a global function
109:14 - called sorted
109:16 - so in the sorted function
109:19 - we are going to pass in two parameters
109:22 - so first is the list items
109:26 - and then the second is how we're sorting
109:28 - it so this just makes
109:30 - sure that the key the case of the
109:33 - letters don't matter and then i'm just
109:35 - going to print that
109:40 - now if i run this you can see we it
109:44 - we print printed the sorted list
109:46 - and now we're printing the list and it's
109:49 - not it's no longer sorted because this
109:51 - creates a new list without modifying the
109:55 - original list
109:58 - okay now let's learn about another data
110:00 - structure called
110:02 - couples
110:03 - so
110:04 - this time i'm going to put
110:06 - tuples
110:08 - so we're using a comment here so tuples
110:11 - are another fundamental python data
110:12 - structure they allow you to create
110:14 - immutable groups of objects this means
110:17 - that once a tuple is created it cannot
110:19 - be modified so we already saw that we
110:21 - could modify lists but tuple you can't
110:24 - even add or remove items
110:26 - they're created in a way similar to
110:28 - lists but using parentheses instead of
110:30 - square brackets so
110:33 - for instance i'm going to do names
110:35 - equals instead of using square brackets
110:36 - we're going to do parentheses roger
110:39 - and
110:42 - sid
110:43 - okay so a tuple's order like a list so
110:45 - you can get its values by referencing an
110:47 - index
110:49 - an index so i could say for instance
110:52 - names and if i do the bracket i could
110:54 - put a zero here to return
110:57 - roger
110:58 - and then you can also use the index
111:00 - method for instance names
111:03 - dot
111:05 - index
111:07 - and then i can
111:09 - pass in something like
111:11 - roger and then this is going to
111:14 - return 0
111:16 - because it's going to get the the index
111:18 - number of that so as with strings and
111:21 - lists using a negative index we'll start
111:23 - searching from the end so i could do
111:28 - that i can do negative one to start
111:31 - not negative zero negative one to start
111:33 - searching from the end here
111:35 - and you can count the items in a tuple
111:37 - with the length function so i could do
111:39 - if i do length and then do names it's if
111:43 - i printed that it would just print 2
111:45 - because there are two items in that
111:47 - tuple
111:48 - then you can also check if an item is
111:50 - contained in a tuple with the in
111:51 - operators very similar to a list so i
111:54 - can do this time i will print it i'll do
111:56 - print
111:57 - roger
111:59 - in
112:00 - names so if i print that and run it
112:02 - we'll see true because roger is in the
112:05 - names
112:06 - and then you can extract part of a tuple
112:08 - using slices
112:10 - just like we could do with with strings
112:12 - and lists so i could do names and then i
112:16 - could do
112:17 - 0 starting at the whoops
112:21 - 0
112:23 - 2
112:24 - so that's just going to start at the
112:26 - zero index and be done at the index 2
112:29 - and then
112:30 - and then you can use the so you can get
112:32 - a sorted version of the tuple using the
112:34 - sorted global function so
112:36 - remember when we were looking at lists
112:39 - when we used the sorted function it
112:42 - created a new a new list or so when
112:46 - we're creating using the sorted function
112:48 - for tuples it creates a new tuple so i
112:51 - can say sorted
112:53 - [Music]
112:54 - names
112:56 - and this would put them in alphabetical
112:58 - order they already in are in
112:59 - alphabetical order but say there is one
113:01 - more
113:02 - word in this list
113:04 - and then
113:05 - i can print this
113:07 - [Music]
113:09 - to print the sorted version but it's not
113:12 - actually going to modify the list
113:14 - because you cannot modify
113:16 - a tuple
113:18 - and then you can create a new tuple from
113:22 - existing tuples using the plus operator
113:24 - so i could say something like
113:26 - new tuple
113:27 - [Music]
113:29 - equals names and then i can use the plus
113:32 - operator
113:33 - and then i would say i would just say
113:36 - tina
113:37 - and
113:38 - quincy i could add a few i could add so
113:41 - these will combine two tuples into a new
113:43 - tuple but you can never like i said you
113:45 - can't actually modify the original tuple
113:50 - now let's learn about dictionaries
113:52 - dictionaries are another very important
113:55 - python data structure
113:56 - while lists allow you to create
113:58 - collections of values dictionaries allow
114:00 - you to create key value pairs we already
114:03 - discussed dictionaries a little bit but
114:05 - now we're going to discuss even more
114:06 - about dictionaries so let me give you an
114:09 - example of a dictionary with just one
114:11 - key value pair so dog equals and then
114:14 - we're going to use the curly braces to
114:16 - create the dictionary and i'll put name
114:19 - and then i will put
114:21 - roger and just like any type of strings
114:23 - we could make these single quotes or
114:25 - they could be double quotes and the
114:28 - spaces here are not very important but
114:31 - it's common to put spaces in between
114:33 - these things for better readability
114:36 - and the key can be any immutable
114:39 - value so this is the key this is the
114:41 - value and the key can be any immutable
114:44 - value
114:45 - such as a string a number or a tuple
114:48 - the value can be anything you want so a
114:50 - dictionary can contain multiple key
114:52 - value pairs so like for instance we got
114:55 - the name we can have
114:57 - age
114:59 - and that's going to be
115:02 - 8. and you can access individual key
115:06 - values using the notation like this so i
115:09 - can say
115:10 - dog
115:12 - so i'm using the bracket notation i can
115:14 - do name so if i print this it's just
115:17 - going to
115:19 - print roger
115:22 - and then again i can use the single
115:24 - quotes 2 if i want
115:27 - and it still prints roger
115:30 - and then you can use the same notation
115:32 - to change the value stored at a specific
115:35 - index
115:36 - so let's say i want to change the name
115:39 - so if i do dog
115:41 - and i'm going to say that the name
115:43 - is now going to equal
115:47 - sid
115:48 - now i'm just going to print the whole
115:50 - the whole thing
115:52 - and we can see the name is now sid
115:54 - instead of roger
115:56 - so another way to get a specific element
115:59 - is to use the get method so if i do a
116:03 - dog dot
116:05 - get
116:06 - and then i
116:08 - do name so i'm going to try to get the
116:10 - name here
116:12 - it's going to return roger so
116:14 - one good thing about this is that you
116:16 - can add a default value like let's say
116:19 - i'm going i'm searching for color
116:24 - and it's saying none it's giving it none
116:27 - because there is no color
116:28 - but what if i want a default value so
116:30 - i'm going to put comma and then i'll put
116:33 - brown
116:36 - so now if it cannot find the color in
116:39 - the dictionary it's going to return
116:41 - brown but if it can find the color like
116:44 - let's say
116:46 - color
116:48 - and this is a
116:50 - green dog
116:53 - okay we'll return
116:54 - green
116:55 - so with the bracket notation that was
116:57 - showing you earlier you cannot have a
116:59 - default value so that's one good thing
117:01 - about the get method
117:02 - now you can also use the pop method to
117:05 - retrieve the value of a key and delete
117:07 - the item from the dictionary we also
117:09 - showed the pop method for lists so for
117:13 - instance i can say
117:15 - get dot
117:17 - pop
117:18 - and then i will pass in
117:20 - name
117:21 - and then right after that i'm just going
117:23 - to print
117:26 - dog that the the whole dictionary so
117:28 - first we're going to get roger and then
117:30 - when i print the dictionary here it's
117:32 - not going to show roger anymore because
117:35 - we we deleted it pop will return the
117:37 - item and delete the item
117:40 - now you can also use a function a method
117:43 - called pop item the pop item method well
117:47 - let me show you that one pop item
117:49 - it's going to retrieve and remove the
117:51 - last key value pair inserted into the
117:54 - dictionary
117:56 - so
117:57 - in this case it should be color so if i
118:00 - run this
118:02 - it's going to return color green and now
118:05 - when i print out the dictionary it's not
118:07 - going to show color green because that
118:08 - was already removed it removed the last
118:10 - item
118:12 - you can also check if a key is contained
118:14 - in a dictionary by using the in operator
118:17 - so we're going to say we're going to try
118:20 - to find out if
118:23 - color
118:25 - is in
118:27 - dog if there's a key called color in dog
118:29 - we run that and it says
118:32 - true another thing we can do is get a
118:35 - list with the keys in the dictionary
118:37 - using the keys method so if i do dog dot
118:41 - keys
118:43 - and then we'll run that it's going to
118:45 - show the keys so the keys are name age
118:48 - and
118:49 - color
118:51 - we can see that it's inside the thing
118:53 - called dick keys but we can also pass
118:56 - this into list so we return an actual
118:59 - just the list part so now we can see
119:03 - it's just an actual list name age and
119:06 - color
119:07 - then we can do the same thing with
119:09 - values so
119:11 - instead of dog.keys let's do
119:15 - values
119:17 - print that
119:18 - and you can see we have roger 8 green we
119:21 - can pass it into a list
119:24 - to
119:25 - return the app just the list here
119:28 - roger 8 green
119:31 - and then finally if we just do items
119:34 - [Music]
119:35 - it's going to return all the items in
119:37 - the list or all the items in the
119:39 - dictionary
119:42 - and convert it into a list
119:46 - so you can see
119:48 - this is the first item in the list this
119:50 - is the second item and then we have the
119:53 - third item here so
119:55 - we can see each item of the list each
119:58 - item of the dictionary is now in a list
120:01 - and then like a lot of the other things
120:03 - we can use the length function and i'll
120:05 - just put dog
120:08 - and we can see that there are three
120:10 - items in dog now you can also add a new
120:14 - key value pair to the dictionary so
120:16 - let's say i want to do
120:19 - dog
120:23 - food
120:24 - or i it doesn't even have to be a single
120:26 - word i could put favorite
120:28 - food
120:30 - and i'm going to say
120:32 - meet
120:34 - and now we're going to print
120:37 - that
120:40 - let's see what do we oh
120:43 - this was supposed to i did that a little
120:45 - wrong
120:48 - there we go this is actually how you do
120:49 - it you put use the bracket notation
120:51 - equals and let's put what it equals
120:53 - there okay now you can see that we now
120:56 - have a new item on the list favorite
120:58 - food
120:59 - meet
121:00 - then you can also delete an item from a
121:03 - list or a delete a key value pair so i'm
121:06 - going to d e l means delete dog
121:09 - or
121:10 - dog there we go and this time i'm going
121:12 - to delete
121:14 - color and i'm just going to use single
121:16 - quotes instead of double quotes to show
121:17 - you that doesn't really matter the type
121:19 - of quote and now you can see we don't
121:21 - know what color
121:22 - this dog is it's no longer a green dog
121:25 - and then you can also copy a dictionary
121:28 - so if you want to make two copies of a
121:29 - dictionary you can do
121:32 - do like this dog copy that's the name of
121:34 - the new dictionary i'll do dog dot copy
121:38 - and that would be the new
121:40 - copied version of the dictionary
121:42 - okay now we are going to talk about a
121:45 - new thing called sets
121:47 - sets are another important python data
121:50 - structure
121:51 - sets kind of work like tuples but
121:53 - they're not ordered and they are
121:55 - immutable so you can change them
121:58 - you can also say that they kind of work
121:59 - like dictionaries but they don't have
122:01 - keys
122:02 - they're all they have an immutable
122:05 - version of a set called a frozen set so
122:08 - let me show you how you would create a
122:10 - set so let's do names
122:12 - and you we're going to use
122:14 - curly brackets just like that
122:16 - and
122:19 - just like that so we have two names so
122:21 - you can see the differences the a
122:24 - dictionary
122:25 - you use the curly brackets but there's
122:27 - going to be key value pairs but this
122:29 - doesn't have key value pairs in a list
122:31 - it's just going to be a
122:33 - item after item like this but there's
122:35 - going to be brackets instead of curly
122:37 - braces
122:38 - so
122:40 - one thing about the sets is that they
122:42 - are not ordered
122:44 - so sets work well when you think about
122:46 - them as mathematical sets
122:48 - so for instance let's have we're going
122:50 - to create a set 1
122:53 - with roger and sid and we're going to
122:55 - have a set
122:57 - 2
122:58 - which is just going to have
123:01 - roger
123:02 - and so you can intersect two sets so
123:06 - uh the inner intersect
123:10 - the intersection of these two sets will
123:12 - be set one
123:15 - and
123:16 - set
123:17 - two so if i just print that out print
123:22 - intersect
123:23 - and then we can just run that and we're
123:25 - gonna see what so it's just roger so the
123:27 - intersection of these two sets are just
123:29 - roger the all the items that they have
123:31 - in common you can also create a union of
123:34 - two sets so
123:36 - instead of just calling this union i'll
123:39 - put
123:40 - mod for modification and so i can show a
123:43 - few different things with the same
123:44 - variable name and the union symbol is
123:47 - just the
123:48 - straight line like this it's not an i
123:50 - it's just the
123:51 - straight line
123:53 - it's on the same key as a
123:55 - as the was it the forward slash
123:57 - backslash one of the slashes
123:59 - now we're going to get every single item
124:01 - in both sets which happens to in this
124:03 - case just happen to be the same as set
124:04 - one but if we change this one to the
124:07 - word luna it's just a different name and
124:10 - now we're going to get each item
124:12 - in both sets or said luna roger for the
124:15 - intersection and then we can also get
124:17 - the difference the difference between
124:19 - two sets so let me change this to back
124:21 - to roger and for the difference between
124:24 - two sets i'll use a the minus
124:27 - and
124:28 - the difference is just going to be sid
124:30 - that's the only thing that's different
124:31 - between the two sets
124:33 - you can also check if a set is a
124:35 - superset of another and if a set is a
124:38 - subset of another so how you would do
124:40 - that is
124:42 - so we're just saying like is this
124:44 - greater than that which means it has
124:46 - everything of the in the other set true
124:49 - now if we put the other direction
124:51 - is does this set have everything in this
124:53 - one no it doesn't
124:55 - you can also count items in a set with
124:58 - the length function that's pretty
125:00 - self-explanatory i won't even show it to
125:01 - you we've seen the link function so many
125:03 - times
125:04 - you can also get you can also get a list
125:06 - from the items in a set by passing the
125:08 - set to the list constructor so
125:12 - i'm just going to remove this
125:14 - and we will do
125:16 - list
125:18 - set
125:19 - one
125:20 - okay so now we have a list of the set
125:23 - and then you can check if an item is
125:25 - contained in a set with the in operator
125:27 - just like the
125:28 - list and the other way we the other
125:32 - places we use the in operator and then
125:34 - one more final thing about a set a set
125:37 - cannot have two of the same item so
125:40 - that's another thing that's useful about
125:42 - sets so if i type in rogers now we have
125:44 - roger sid roger if i play this we'll see
125:47 - it's only going to
125:49 - print sid roger it's not going to add
125:52 - the roger twice to the set
125:54 - so that's another
125:56 - useful thing about sets is that make
125:57 - sure there's only one of each item in
126:00 - the the set so if you have a list that
126:03 - has multiple items you can convert it to
126:05 - a set
126:06 - um and then i'll just make sure there's
126:07 - only one of each thing in that set
126:10 - now let's talk more about functions
126:14 - we already talked about functions in the
126:16 - last section but we're going to do a
126:17 - review and then go into even more detail
126:20 - about functions so a function lets us
126:23 - create a set of instructions that we can
126:25 - run when needed and i'm just going to
126:27 - paste in a function and again the
126:30 - indentation it can be either four spaces
126:33 - two spaces
126:36 - as long as it's indented the exact same
126:38 - amount
126:39 - so functions are essential in python and
126:41 - in many other programming languages they
126:43 - help us create meaningful programs
126:45 - because they allow us to decompose a
126:46 - program into manageable parts and they
126:49 - promote readability and code reuse
126:52 - so this one is a function called hello
126:55 - that just prints hello this is the
126:58 - function definition
126:59 - so there's a name called hello this is
127:02 - the name here and then the body of the
127:04 - function
127:06 - which is the the set of instructions
127:08 - and the body of the function is
127:10 - everything that's after the colon
127:12 - and everything that's indented one level
127:15 - on the right
127:16 - so to run this function we must call it
127:19 - so i can just type in hello
127:22 - hello
127:24 - and then this is the syntax to to call
127:27 - the function and i can call it multiple
127:29 - times so i can just copy this and paste
127:32 - it and now if i just run this program
127:34 - it's going to print hello
127:36 - three times
127:38 - the name of the function is very
127:40 - important so the name of the function is
127:43 - hello it should be the function name
127:46 - should be descriptive so anyone calling
127:47 - it can imagine what the function does
127:51 - a function can accept one or more
127:53 - parameters this is something else that
127:55 - we saw
127:56 - before
127:57 - but
127:58 - i can type in a parameter right here and
128:01 - this becomes a variable that we can use
128:03 - in the function so i can change this
128:06 - instead of printing hello
128:08 - it's going to print hello
128:11 - and then we'll just put name
128:14 - and now i can call the function with the
128:17 - name
128:19 - and i can actually um call it with
128:22 - different names so we'll do bow
128:25 - and we'll do
128:26 - quincy
128:27 - and then if i just play that we see
128:29 - hello bo
128:30 - hello quincy
128:32 - so
128:33 - as you can see we call the function by
128:36 - passing the argument
128:38 - and again you can use single quote or
128:41 - double quotes here it's better to be
128:44 - consistent just always use single quotes
128:47 - or always use double quotes
128:49 - but for teaching i like to switch it up
128:51 - to just to emphasize that you can use
128:54 - either so let me tell you about the
128:55 - difference between parameters and
128:58 - arguments
128:59 - these two words parameters and arguments
129:01 - are sometimes used interchangeably
129:04 - and it's common to get confused about
129:07 - the distinction
129:08 - we call
129:10 - parameters
129:11 - the values accepted by the function
129:14 - inside the function definition
129:16 - and arguments are the values we pass to
129:20 - the function when we call it also an
129:22 - argument can have a default value
129:25 - that's applied if the argument is not
129:28 - specified so let me show you how i would
129:30 - do that so we have it name so right now
129:34 - it always needs to be get a name well
129:36 - first let me show you what would happen
129:38 - if i called the function without passing
129:40 - the name
129:43 - i'm just going to run that and we can
129:45 - see we're going to get an error hello
129:47 - missing one required positional argument
129:50 - name but we can make it so you can call
129:53 - this function without passing in a name
129:54 - where it's optional you can't if you
129:56 - want so i'm going to put an equal sign
129:58 - and then i'm gonna type in my friend
130:02 - and just to make consistent make this
130:04 - consistent i'm gonna make this all
130:06 - double quotes
130:10 - okay so this is now an optional argument
130:15 - so it's it's you can pass in the name
130:17 - but if you don't pass a name it's going
130:19 - to default to my friend so i'll just run
130:21 - this again with that default
130:23 - value and now it's hello bow hill quincy
130:26 - hello my friend because we called this
130:28 - and we didn't specify any argument or
130:31 - parameter and then we can also accept
130:33 - multiple parameters so i'm just going to
130:35 - get rid of this default value and i'll
130:37 - put 8 so now we're accepting a name and
130:40 - an age so we can now use both parameters
130:44 - in our function so i can do plus
130:48 - hello
130:49 - name
130:51 - [Music]
130:53 - you are
130:57 - and we're going to add
130:58 - the age
131:01 - and now it's going to be passed in as a
131:03 - number but we're going to convert it to
131:05 - a string
131:06 - so you are
131:09 - [Music]
131:13 - years old
131:15 - and then we have to make sure we have to
131:17 - make sure to add a space in here so
131:19 - there'll be a space space after this
131:21 - word then the number then a space and
131:24 - then years old
131:26 - so i'm gonna now have to pass in the
131:29 - number
131:30 - and now i can run this function
131:34 - now showing the red
131:36 - squiggly lines
131:39 - i sometimes the the red squiggly lines
131:41 - will appear when it's
131:43 - actually correct
131:45 - so let me what am i am i doing something
131:47 - wrong here
131:48 - oh i need to put the parentheses
131:52 - if the red squiggly lines appears when
131:55 - it's actually correct they'll it they'll
131:57 - go away
131:58 - usually within a few seconds or if you
132:01 - hit enter
132:02 - so that actually was a problem i forgot
132:04 - the parentheses at the end um so
132:07 - you can see this is what the whole
132:08 - function looks like
132:11 - if it's all on one line but i'm just
132:13 - going to
132:14 - move that over so hello bo you are 39
132:18 - years old so we've used the name and the
132:20 - age
132:21 - so parameters are passed by reference
132:25 - all types in python are objects but some
132:28 - of them are immutable including integers
132:31 - booleans floats strings and tuples this
132:33 - means that if you pass them as
132:35 - parameters and you modify their value
132:38 - inside the function the new value is not
132:40 - reflected outside of the function
132:43 - let me just give you an example of that
132:45 - so if i just i'm just going to paste in
132:47 - some new code here and we can see we
132:49 - have this function called change and
132:52 - we're going to pass in this value if we
132:54 - pass in this this valve variable 1 to
132:57 - the change function and we set value to
133:00 - 2
133:01 - well then we're going to print the value
133:03 - and see what happens
133:05 - and you can see it's now just 1 here so
133:08 - so it didn't change the value
133:11 - the value so what we change inside the
133:14 - function doesn't affect anything from
133:16 - outside the function
133:18 - and then you can see we have these
133:20 - orange squiggly lines here local
133:22 - variable value is assigned but never
133:24 - used it's just showing that actually
133:25 - this isn't really doing anything once
133:27 - it's inside the function and we change
133:29 - it doesn't change anything outside the
133:31 - function
133:32 - so if you pass an object that's not
133:34 - immutable you do change one of its
133:36 - properties and the change will be
133:38 - reflected outside so this was
133:40 - mutable this is immutable an object that
133:43 - would be
133:44 - mutable would be like a dictionary so if
133:47 - i change this to a dictionary and i put
133:49 - name
133:52 - and i set it to bow
133:54 - but then inside the change i do value
133:57 - dot name or not i'll put the the
134:00 - brackets value name
134:03 - so the key of this dictionary and i set
134:07 - that to sid
134:09 - and i run this we'll see now the name
134:12 - has changed to sin so we changed we use
134:15 - the change function to change name to
134:17 - sid and now it actually is changed
134:19 - because a dictionary is mutable
134:22 - so a function can also return a value
134:26 - using the return statement
134:29 - so i'm going to update this whole thing
134:30 - and talk about return statements a
134:33 - function can return a value using the
134:35 - return statement so it's going to return
134:38 - this name that we then can continue to
134:40 - use in our in our program it doesn't
134:43 - have to return name it can return
134:44 - anything that happens inside the
134:46 - function
134:47 - and
134:48 - the when the function meets the return
134:51 - statement the function ends so you can
134:53 - have a return statement have code after
134:55 - it but it will just end like for
134:57 - instance if you have the return
134:58 - statement in a conditional like in an if
135:00 - statement we can also omit
135:03 - the return the return value
135:06 - so it's just going to end the function
135:08 - and not return anything so i had
135:11 - mentioned having the return statement in
135:13 - a conditional so that's a common way to
135:16 - end a function if the starting condition
135:18 - is not met
135:19 - like for instance if we update the
135:21 - function to
135:22 - this so if not name return this so if i
135:27 - mean if not name return
135:30 - or
135:30 - else
135:31 - you don't even need an else because this
135:33 - will just in the function and you don't
135:35 - even need an else this will happen if
135:37 - there is a name now we just said that
135:40 - you have to pass in something if you
135:42 - don't have a default value so the way to
135:44 - get to that would just be to call the
135:47 - function
135:48 - with false
135:51 - so if we call with false then it's just
135:53 - going to return it doesn't do anything
135:55 - but if we call it with
135:57 - bo
135:58 - then let's see
136:00 - hello bo so you can also return multiple
136:04 - values by using comma separated values
136:07 - so
136:08 - for instance i can i'm just going to
136:11 - take this part off here and then add a
136:13 - return statement
136:15 - return and then i can return the name i
136:19 - can return
136:21 - bo in case that's not the name i can
136:23 - return
136:24 - 8 and then i can call this and i'm just
136:27 - going to call this with sid
136:29 - and we can see what happens
136:31 - now
136:32 - oh
136:33 - it doesn't it's not it doesn't actually
136:34 - print what's been returned but if i
136:37 - print this
136:39 - here we go then we can really see what
136:40 - happens so
136:42 - in this function it's going to print
136:43 - this but now we're also going to print
136:46 - what's returned so let's see what that
136:49 - looks like so
136:50 - this is what when we print what was
136:52 - returned it looks like this so it's sid
136:55 - bo
136:56 - 8
136:57 - so one thing related to functions and
136:59 - also related to other parts of python is
137:03 - variable scope
137:05 - so let's look at this
137:07 - we've declared a variable up here and
137:10 - when you declare a variable that
137:12 - variable is visible in parts of your
137:14 - program depending on where you declare
137:16 - it
137:17 - so if you declare a variable outside of
137:20 - a function the variable is visible to
137:22 - any code running after the declare after
137:25 - the declaration including functions so
137:28 - we call this a global variable so we've
137:30 - declared this before the function so we
137:33 - can now access it inside a function and
137:35 - also outside the function so if i
137:39 - so we can see 8 and 8 and it shows right
137:42 - here what's going to
137:43 - show in the
137:44 - console here
137:46 - but if we declare a variable inside a
137:48 - function let me give you an example if
137:50 - we declare
137:51 - this variable
137:53 - inside the function i'm just going to
137:54 - move it down to here
137:56 - now it's a
137:58 - local variable and it's only visible
138:01 - inside the function so let me just
138:03 - delete with this because it's not
138:04 - actually going to be
138:06 - doing that so if i run this we're going
138:08 - to see there's there's an error
138:12 - name
138:12 - age is not defined we're trying to print
138:15 - the age here but since the age was
138:17 - declared inside the function it's not
138:19 - available outside the function it's only
138:21 - available
138:23 - inside the function
138:25 - so you just have to be aware sometimes
138:27 - there's local variables that only apply
138:29 - inside the function and there's global
138:31 - variables if you that can apply inside a
138:33 - function and outside a function
138:35 - okay now let's look at something else
138:36 - with functions and this is nested
138:39 - functions
138:41 - functions in python can be nested
138:44 - inside other functions
138:46 - a function defined inside a function is
138:49 - visible only inside that function this
138:51 - is useful to create utilities that are
138:53 - useful to a function but not useful
138:55 - outside of it so you might ask why
138:57 - should i be hiding this function if it
138:59 - does no harm
139:00 - well one because it's always best to
139:02 - hide functionality that's local to a
139:04 - function if it's not useful elsewhere
139:07 - also because we can make use of closures
139:10 - which we'll talk more about later so so
139:12 - look at this example so we have this
139:15 - function talk and inside the function we
139:18 - defined another function called say
139:22 - and then
139:23 - what we
139:24 - what we do is that we can call that say
139:27 - function
139:28 - inside the function and so the way this
139:31 - works is we pass in the phrase so here's
139:34 - the phrase and the phrase i'm going to
139:36 - buy the milk
139:37 - and here we do we we split it so split
139:41 - is a way to
139:43 - create a list
139:45 - of out of this string so we have this
139:47 - string but it's going to split it on
139:49 - every space so it's going to create a
139:51 - list of each word individually and then
139:54 - we're going to run this loop
139:57 - more on loops later
139:59 - and we're going to for every word in the
140:02 - the words list we're going to say
140:04 - the word we're going to say the word
140:06 - it's just going to print the word so if
140:07 - i just run that i am going to buy the
140:10 - milk and every time it prints it it
140:12 - prints it on a new line so this would
140:15 - just be an example because we're never
140:16 - going to want to use this save function
140:18 - outside the talk function so it's better
140:19 - just to put it inside the talk function
140:23 - and then i'll just paste in
140:25 - another example here if you want to
140:27 - access a variable defined in the outer
140:30 - function from the inner function
140:32 - you first need to declare it as
140:35 - non-local
140:36 - so
140:37 - we're using non-local here at non-local
140:40 - count and this allows us to access this
140:44 - variable that was declared inside the
140:47 - out so this is the outer function count
140:49 - and we have this variable called count
140:52 - and to be able to access that variable
140:53 - in the inner function we have to
140:56 - call non-local or we already talked
140:58 - about variable scope and if we didn't
141:02 - call
141:03 - call this non-local then we could not
141:04 - access the count variable from inside
141:07 - the function so like for instance i'm
141:09 - going to run this it's going to print
141:11 - the count which is just count plus 1 is
141:13 - just adding 1 to this number that's all
141:15 - the function does but if i take off this
141:18 - word non-local here and i run this we're
141:20 - going to get an error because it doesn't
141:23 - know what count is it doesn't know that
141:25 - we're referring to this count in the
141:26 - inner function so we'll just put that
141:28 - back on there and then it should work
141:31 - again
141:32 - this is especially useful with closures
141:35 - which we're just about to talk about
141:37 - so closure is a special way of doing a
141:39 - function in python if you return a
141:41 - nested function from a function that
141:44 - nested function has access to the
141:45 - variables defined in that function even
141:48 - if that function is not active anymore
141:51 - so let me show you an example i'm going
141:52 - to paste some code that'll be very
141:54 - similar to this code but just a a little
141:56 - different and then i'll explain it so
141:59 - now instead of count it's a counter so
142:02 - we're returning count from this nested
142:04 - function and from the outer function
142:07 - we're returning the nested function
142:10 - we're returning the increment function
142:12 - and then here instead of just calling
142:14 - the function directory the outer
142:16 - function we're assigning it to this
142:18 - variable and now we're going to print
142:22 - we're just going to call we're going to
142:23 - call this variable which is the returned
142:27 - inner function so we're basically
142:28 - calling the inner function and it's
142:30 - still going it's because we're calling
142:32 - the inner function it's not going to
142:35 - reset the count to zero every time and
142:38 - it can keep track of that value and we
142:40 - have this
142:42 - using a comment what it's going to
142:43 - return but we can also
142:45 - run the program and we can see one two
142:48 - three just like that so we return the
142:51 - increment inner function and that still
142:54 - has access to the state of the count
142:55 - variable even though the counter
142:57 - function has ended
142:59 - so let's move on to
143:02 - objects
143:04 - [Music]
143:06 - everything in python is an object
143:09 - even values of basic prim of types like
143:12 - integers strings floats are objects
143:14 - lists are objects as well as tuples
143:16 - dictionaries and pretty much everything
143:19 - so objects have attributes and methods
143:22 - that can be accessed using the dot
143:24 - syntax for example let's define a new
143:27 - variable of type int so i'm going to do
143:29 - age equals eight
143:32 - age now has access to the properties and
143:34 - methods defined for all int objects
143:38 - this includes for example access to the
143:40 - real and imaginary part of that number
143:42 - so i can do
143:44 - a print
143:46 - age dot real
143:48 - and then if i just run that
143:50 - the real part is eight i can also print
143:53 - the imaginary
143:55 - part of the number
143:57 - and manage
143:58 - and there is no imaginary part of the
144:01 - number so it just
144:02 - does zero i can also get the the bit
144:06 - length age dot
144:08 - bit
144:09 - length
144:13 - and if i run that
144:15 - we can see the bit length is four so the
144:18 - bit length method returns the number of
144:20 - bits necessary to represent this number
144:23 - in binary notation
144:25 - so there's just a lot of
144:27 - things that you can use for all int
144:29 - objects and these are just a few of them
144:32 - so a variable holding a list value has
144:35 - access to a different set of methods so
144:38 - i'm going to
144:40 - update this again we're going to do
144:41 - items
144:43 - equals and we're going to create a list
144:45 - one
144:46 - two
144:47 - so
144:48 - i can do
144:49 - items dot
144:51 - append
144:52 - i can append a three i can append
144:54 - another item i can do
144:56 - items dot pop
144:58 - which is going to
145:00 - remove and return the last item which is
145:03 - the three
145:04 - and the methods so so these are the
145:07 - methods of pin and pop and the methods
145:09 - available to an object depend on the
145:12 - type of value
145:14 - the id global function provided by
145:17 - python lets you inspect the location in
145:19 - memory for a particular object so for
145:22 - instance i could do a print and i'm
145:25 - going to do id what's the id of the
145:28 - items
145:29 - object
145:31 - and we can see this is the location in
145:33 - memory
145:35 - so some val some objects are mutable
145:37 - while others are immutable this is
145:39 - something that we already talked about a
145:41 - little bit that depends on the object
145:43 - itself if the object provides methods to
145:46 - change its content then it's mutable
145:48 - otherwise it's immutable
145:50 - most most types defined by python are
145:52 - immutable for example an int is
145:54 - immutable there are no methods to change
145:56 - its value so if you increment the value
145:59 - like with um
146:01 - age equals age
146:04 - plus
146:05 - one
146:06 - it's actually going to create an
146:08 - entirely
146:09 - new value
146:11 - so it it's not going to even be the same
146:13 - object at all because age you it has to
146:16 - create a whole new one to reassign it
146:18 - but something like a in in a dictionary
146:22 - it would actually be the same object but
146:24 - you could just change different parts of
146:25 - it now let's talk more about
146:28 - loops
146:30 - so this song we already discussed a
146:31 - little bit in the previous section but
146:34 - loops are
146:35 - one essential part of programming
146:37 - and in python we have two kinds of loops
146:41 - while loops and for loops
146:44 - so before i um show i'm going to paste
146:47 - in this code but i just want to show
146:49 - something really quick see how there's a
146:52 - line like dotted line here and a dotted
146:54 - line here this is showing the default
146:56 - indentation which we can change so i'm
146:59 - actually going to go and change
147:01 - that really quick let me wait i think
147:03 - i'm gonna have to yeah i'm gonna zoom
147:04 - out so i can get to this and i'm gonna
147:06 - change the indent to four and now it's
147:10 - not going to have a little line right in
147:11 - there so now i'm going to go back here
147:14 - and let's zoom in again
147:19 - okay so let's talk about
147:21 - while loops
147:22 - while loops are defined using the
147:25 - while
147:26 - keyword
147:27 - and they repeat their block until the
147:30 - the condition is evaluated as false so
147:33 - while condition equals true so
147:36 - this particular example is an infinite
147:40 - loop it never ends because this
147:43 - condition is always going to so if we
147:45 - run this program which i'm not going to
147:47 - do right now because it just goes on
147:49 - forever while this condition is true
147:52 - keep running the code inside the loop
147:55 - all the lines of code that are indented
147:57 - the same amount
147:58 - so let's halt the loop right after the
148:00 - first iteration i can do condition
148:05 - equals
148:06 - false
148:10 - [Music]
148:12 - so now if i run it it just runs the loop
148:16 - one time
148:17 - so in this case the first iteration is
148:19 - run as the condition is evaluated true
148:22 - and then at the second iteration the
148:24 - condition test evaluates to false so the
148:27 - control goes to the next instruction
148:30 - after the loop which in this case there
148:32 - is no next instruction after the loop
148:36 - it's common to have a counter to stop
148:37 - the iteration after some number of
148:40 - cycles
148:42 - so here's a while loop with a counter so
148:46 - you you start the counter at zero and
148:48 - then while count is less than 10.
148:52 - we're we're gonna print this count
148:54 - equals count plus one so it's going to
148:56 - increment the counter every time
148:58 - until we get to the end so it's gonna
149:01 - see it's gonna print this until
149:03 - eventually the count is
149:07 - greater than 10
149:09 - so or 10 or 10 or greater while count is
149:12 - less than 10. so once it gets to 10 the
149:14 - loop will stop um again another way to
149:18 - doing to do this we could have just done
149:20 - plus equals plus equals one so if i run
149:24 - that it's going to do the exact same
149:25 - thing
149:27 - and other type is the for loop so using
149:30 - for loops we can tell python to execute
149:32 - a block for a predetermined amount of
149:35 - times up front and without the need of a
149:37 - separate variable and conditional to
149:39 - check its value
149:41 - it's commonly used to iterate the items
149:44 - in a list so we have this list there's
149:47 - obviously four items here and then four
149:49 - item in items so items is this list and
149:51 - then for each item in the list we're
149:53 - going to print
149:54 - the item pretty straightforward and it
149:56 - prints each item in the list
149:59 - or you can iterate a specific amount of
150:01 - times using the range function so let's
150:04 - say we don't have we're not going to
150:06 - define this here we're just going to do
150:08 - 4 item in and then here i'm going to
150:11 - type in range
150:14 - and then i'm just going to type in a
150:15 - number how about
150:17 - 15
150:18 - so i'm using the range function that
150:21 - basically just returns a list and then
150:23 - if i do that we can see it's going from
150:26 - 0 to 14. so the range function is going
150:29 - to return a
150:31 - a list that goes from 0 to 14 so there's
150:33 - 15 items and it's going to print the
150:35 - items
150:36 - now if we just go back a few steps to
150:39 - when we had the list here
150:41 - we can i can show you how to get the
150:43 - index so right now it's just printing
150:47 - the items one two three four but what if
150:49 - we want the index of the list
150:52 - we can do that by using the by wrapping
150:55 - the sequence in the enumerate function
150:58 - so for items in and then
151:02 - i'm going to do
151:03 - enumerate
151:06 - i'm going to pass in
151:10 - so this is going to return
151:13 - each item and
151:15 - the index of the item and since there's
151:17 - going to be an item in an index
151:19 - but it's actually the index and then the
151:20 - item i'm going to type an index comma
151:24 - item so this enumerate is going to get
151:26 - the index and the item so now i can
151:29 - print the index and the item here and if
151:33 - i run that
151:35 - so index zero item one index one item
151:38 - two index two item three and so on and
151:41 - it doesn't even have to be numbers we
151:43 - can
151:46 - do names
151:48 - [Music]
151:52 - and if i just run that whoops not that
151:55 - one
151:57 - and then we can see the the index and
152:00 - the item then let me put in some more
152:02 - code here so i can talk about break and
152:05 - continue
152:07 - both while and for loops can be
152:09 - interrupted inside the block using
152:11 - either break or continue
152:13 - continue stops the current iteration and
152:15 - tells python to execute the next one
152:18 - and break stops the loop altogether and
152:21 - goes on with the next instruction after
152:23 - the loop ends so i'm going to just play
152:26 - this so here we're saying if item equals
152:28 - two continues that means it's going to
152:30 - skip that iteration so if i play this
152:32 - one three four so it's not going to it's
152:35 - not going to get to the print item
152:37 - because it's actually skipped that
152:38 - iteration it just
152:40 - doesn't run any code after the continue
152:43 - if this is true
152:45 - and so it doesn't print 2. so if we
152:47 - change this to break it will be very
152:49 - it'll be a little different here this
152:52 - time it's going to just print one
152:55 - because now it's breaking out of the
152:56 - loop
152:57 - entirely and it's not going to run any
152:59 - more iteration of the loop
153:02 - okay let's talk about another thing
153:04 - classes classes in python
153:08 - so in addition to using the python
153:11 - provided types we can declare our own
153:13 - classes
153:14 - and from the classes we can instantiate
153:17 - objects
153:19 - an object is an instance of a class
153:22 - a class is the type of an object so
153:25 - here's an example i'm going to create a
153:27 - class called
153:30 - dog
153:32 - so
153:33 - uh to create a class you just put the
153:35 - word class and then put the the class
153:37 - name
153:38 - and
153:39 - now
153:40 - i can i can
153:42 - add a method for the class so to define
153:45 - a method i'll just do define bark
153:48 - [Music]
153:50 - and i'm going to put the word self here
153:53 - and inside this i'll print
153:59 - [Music]
154:01 - woof
154:02 - [Music]
154:05 - okay so self as an argument of the
154:08 - method
154:10 - will point to the current object
154:12 - instance and must be specified when
154:14 - defining a method so when you're
154:17 - creating a method inside a class you're
154:18 - always going to start with self so we
154:21 - create an instance of a class
154:24 - which is an object
154:25 - like this
154:26 - so i'm just going to put
154:28 - roger
154:30 - equals
154:32 - dog
154:33 - okay so i've created a dog just like
154:36 - this
154:37 - and then i can
154:40 - print
154:42 - type
154:43 - roger so let's see what the type of this
154:46 - roger is we can see it's the class to
154:49 - dog class
154:51 - roger is a dog
154:54 - a special type of method
154:57 - called in there's a special type of
154:59 - method called init which is a
155:01 - constructor
155:03 - so let me show you how to create a
155:05 - constructor
155:07 - deaf
155:14 - so we can use this
155:16 - a constructor like this
155:18 - to initialize one more properties when
155:20 - we create a new object from that class
155:23 - so you can see we always have to add
155:25 - self but now these are the two
155:28 - variables we can pass in when we create
155:31 - a dog and that will associate be
155:34 - associated with that
155:36 - that
155:37 - object
155:38 - so down here i can call um i can call
155:42 - dog but i can pass in roger for the name
155:46 - and
155:47 - the age
155:48 - and now when we create this
155:51 - dog it's going to assign the name to
155:54 - self.name and it's going to assign the
155:56 - age to self.age and let me show you how
155:59 - you can access that information
156:02 - so i'm going to print instead of
156:04 - printing the type i'm going to do roger
156:07 - dot name
156:09 - and now it's going to when i do
156:11 - roger.name that's self.name so self is
156:14 - roger and we do self.name it's going to
156:17 - be the name that was passed in
156:19 - and then we can also
156:21 - do the age
156:23 - and then we can finally
156:25 - call the bark method so we have bark
156:28 - here now we can see what that does so
156:30 - i'm just going to run that
156:32 - and we have roger
156:35 - we have eight
156:36 - and then
156:38 - this is because i should have put
156:40 - parentheses here so let me put
156:42 - parentheses after bark
156:44 - and so we have wolf here so roger 8
156:48 - wolf and the reason why it says none
156:51 - here is because i didn't have to put the
156:54 - print see i i put pranks that was in
156:56 - this groove if you're playing print on
156:58 - everything but calling bark
157:00 - already prints wolf
157:02 - so when i do
157:04 - it when it's when it's printing it's
157:06 - printing because since
157:07 - roger.bark doesn't return anything
157:10 - there's no return statement that's why
157:12 - it printed none so there'd be two ways
157:15 - to fix that either instead of printing
157:17 - wolf i could return wolf
157:20 - or i could just not do the print here so
157:23 - let me just take that off
157:25 - okay roger 8
157:27 - wolf
157:28 - so one important feature of class is
157:30 - inheritance let me show you an example
157:33 - of inheritance i'm going to create a new
157:36 - class before the dog class and this is
157:39 - going to be
157:40 - a class
157:42 - called
157:43 - animal
157:45 - and the animal class i'm going to put a
157:47 - function called walk
157:50 - and i'm going to always pass in self
157:53 - and this is going to print
157:55 - [Music]
157:56 - walking
157:58 - [Music]
158:00 - and then we can make the dog class
158:03 - inherent inherit from the animal class
158:06 - so we have class dog but if i put
158:08 - parentheses here
158:09 - then i can type in animal
158:11 - and now the dog class is going to
158:14 - inherit from the animal class and now i
158:17 - can go down here and after roger.bark i
158:20 - can do roger.walk
158:23 - and if i run that
158:24 - okay so roger 8wolf but now it's going
158:27 - to be able to do walking and you can see
158:29 - the dog class doesn't actually have a
158:32 - walk method but it's getting it from
158:35 - the animal class it's inheriting this
158:37 - method
158:38 - and in that way you're able to i could
158:42 - create a class cat a class frog
158:46 - a class bird and each of them could
158:49 - inherit the walk
158:51 - method and then it would have
158:53 - walking
158:55 - and we'll be doing a little more with
158:56 - classes in the the final project
158:59 - in this course
159:01 - because we'll be going a little more
159:03 - over object oriented programming
159:06 - but right now let's talk about something
159:09 - new i'm going to just delete all this
159:11 - and we're going to be talking about
159:13 - modules
159:14 - so every python file is a module you can
159:18 - import a module from other files and
159:20 - that's the base of any program of
159:21 - moderate complexity as it promotes a
159:23 - sensible organization and code reuse so
159:26 - it's basically how you can create a
159:28 - software that has multiple python
159:30 - programs in the same piece of software
159:33 - so in the typical python program one
159:35 - file acts as the entry point and the
159:38 - other files are modules and exposed
159:40 - functions that we can call from
159:42 - other files so
159:44 - let me just show you an example i am
159:47 - going to
159:48 - open up this
159:50 - files tab and i'm going to create a new
159:52 - file and this is going to be called dog
159:54 - dot pi
159:55 - and now i have dog dot pi open i no
159:57 - longer have the main dot pi open and i'm
160:00 - going to define
160:02 - bark
160:03 - and what bark is going to do is just
160:07 - print
160:09 - woof
160:10 - [Music]
160:11 - okay now i'm going to it's just going to
160:14 - automatically save for me i'm going to
160:15 - go back to the the python file and now
160:18 - i'm going to
160:20 - import
160:22 - dog
160:24 - and let's see oh it's just saying it's
160:26 - unused i thought maybe this thing wrong
160:28 - but that just means i import dog and i
160:29 - haven't used it which i'm about to do
160:30 - right now so dog
160:32 - dot
160:33 - bark
160:35 - so now if i run this program
160:37 - it's going to say wolf but that's not
160:40 - from this file it's actually importing
160:44 - this function from from the dog file so
160:46 - that's a way you can
160:49 - break up your code into multiple files
160:52 - we can also use the from import syntax
160:56 - and call the function directly
160:58 - let me show you what i mean so instead
161:00 - of import dog i'm going to say
161:04 - from dog
161:06 - import
161:07 - bark
161:09 - and then instead of calling it dog.bark
161:12 - i can just call
161:13 - bark
161:14 - because we're only importing bark well
161:17 - we've imported bark directly instead of
161:18 - the whole dog so i can run that and it
161:21 - says
161:22 - wolf
161:23 - so
161:24 - the first strategy allows us to load
161:26 - everything defined in a file when i just
161:28 - said
161:29 - import dog that
161:31 - allows everything defined in a file so i
161:34 - could have a bunch of function like bark
161:36 - or walk
161:39 - name or there could be a bunch of
161:40 - functions if i just say import dog it
161:43 - imports all of them but the second
161:45 - strategy from dog import bark allows us
161:48 - to just pick the things we need so we're
161:50 - only going to import the specific
161:52 - functions that we need
161:54 - those modules are specific to your
161:56 - program and importing depends on the
161:58 - location of the file in the file system
162:02 - so
162:03 - suppose you put dog.pi in a
162:06 - subfolder for instance let's say i
162:09 - create a folder
162:11 - and i call it liv for library and let's
162:14 - say i put dog.pi in this subfolder like
162:18 - this
162:19 - now in this folder to make this work i'm
162:22 - going to have to create an empty file
162:24 - named init.pie so i'm going to add file
162:28 - and i'll do init dot or under underscore
162:31 - underscore init underscore underscore
162:33 - dot pi
162:34 - and this tells python that
162:37 - the folder contains modules
162:40 - now i'm going to go back to my main file
162:43 - and i can
162:45 - i can import dog from
162:47 - lib so i'm going to say from
162:50 - lib
162:51 - that's that subfolder import
162:54 - dog
162:56 - and then i can do
162:57 - dog
162:59 - dot bark so let's run that to make sure
163:01 - there's no errors it worked
163:03 - correctly so i was able to import this
163:06 - file from the subfolder
163:09 - or you can reference the dog module
163:12 - specific function by importing from
163:14 - lib.dog so i can do from
163:17 - lib.dog
163:18 - import
163:20 - bark and now instead of calling dog.bark
163:23 - i can just call
163:25 - bark
163:26 - and it says
163:27 - wolf
163:28 - so i'm going to close this here
163:30 - and
163:31 - now let's talk about the python standard
163:34 - library so basically there's all these
163:38 - pre-built modules you can
163:41 - you can load a lot of code from the
163:43 - standard library python exposes a lot of
163:46 - built-in functionality through its
163:47 - standard library
163:48 - the stand library is a huge collection
163:50 - of all sorts of utilities ranging from
163:52 - math utilities to debugging to creating
163:55 - graphical user interfaces
163:57 - so there's a bunch of them but here's
163:59 - some of the more common ones we have
164:01 - math for math utilities re regular
164:03 - expressions json to work with json date
164:06 - time sqlite 3 os for operating system
164:09 - utilities random for random number
164:11 - generations
164:13 - so
164:14 - statistics requests for http request
164:17 - http to create servers url lib to manage
164:20 - urls so you can import these modules
164:24 - that allow you to get extra
164:26 - functionality so
164:29 - we already looked at a little bit at the
164:31 - math one we already looked a little bit
164:33 - at random in the the first
164:35 - uh project that we did but let's just
164:38 - kind of look at a little more how you
164:40 - would do this so now we are going to use
164:42 - the the math one we're going to import
164:45 - math
164:47 - and
164:48 - so this is how you would introduce you
164:50 - would use a module of the standard
164:52 - library so we already saw how to import
164:55 - modules that we created it's very stan
164:57 - it's very similar with the standard
164:59 - library so now that i've imported math i
165:02 - can now use
165:04 - functions and methods from from the math
165:06 - module so i can do math dot
165:09 - square root and i can pass in 4 and then
165:12 - i can just
165:13 - print that so we can see what the result
165:15 - is
165:18 - okay 2.0
165:20 - or we can
165:23 - just like we shall
165:24 - we saw before instead of importing math
165:27 - i can say
165:29 - from math
165:32 - import
165:33 - square root and then instead of just
165:35 - doing math dot square root i can just
165:37 - call
165:38 - this
165:39 - square root method here and it's going
165:41 - to do the same thing so that's basically
165:44 - how it works for for all the modules in
165:46 - the standard library okay now we're
165:48 - going to start going over a few kind of
165:50 - miscellaneous
165:51 - slightly more advanced topics in python
165:54 - so we're going to talk about how to
165:57 - accept arguments from the command line
165:59 - in python
166:01 - well first of all let's see how to run a
166:03 - program from the command line
166:05 - in replit so let's say we have a program
166:08 - it just says print
166:11 - hello okay so we've been running it by
166:14 - just clicking this play button but
166:17 - there's another way to run a program in
166:19 - replit and i go over to the shell so
166:21 - this is the command line in replica we
166:25 - can clear this
166:26 - and now i'm just going to type in
166:29 - python main dot pi
166:32 - okay so what we call python to run the
166:34 - python program and then we just put the
166:37 - name of our file with main.pi
166:40 - so
166:41 - whether you're in replit or if you're
166:43 - running things locally
166:45 - you should be able to
166:46 - run a program in the same way
166:48 - depending on how you install the program
166:50 - locally instead of typing python you may
166:53 - type in python 3.
166:56 - sometimes the way people install python
166:59 - it will be python 3 because we're using
167:01 - version 3 of python
167:03 - so now let's see how you can
167:06 - call a python a program on the command
167:09 - line and pass in some arguments right
167:12 - when we run the program from the command
167:15 - line
167:17 - so
167:18 - a basic way to handle arguments is to
167:21 - use the sys module from the standard
167:24 - library so let me give you an example so
167:27 - first of all we're going to import sys
167:30 - now just so you know usually you're
167:33 - always going to have import statements
167:34 - on the first line i'm just putting this
167:36 - comment on the first line to remind us
167:38 - what we're working on right now so now
167:41 - i'm going to we're going to import the
167:43 - sys library
167:45 - now i'm going to
167:47 - print
167:48 - and i'm going to first i'm going to
167:52 - oh
167:54 - we're going to print the argument
167:55 - cis.arg
167:56 - the
167:58 - so this is how we can print all the
168:00 - arguments that were passed in
168:03 - when we called the program so so i'm
168:05 - going to see we have python main.pi and
168:08 - now i'm going to put
168:10 - bow
168:12 - 39
168:13 - okay so you can see it's printing the
168:16 - list of arguments so this is basically
168:19 - just a list the first item is the name
168:21 - of file
168:22 - then we have
168:24 - the the first word and then the second
168:26 - one and you can see they're both strings
168:28 - even though this is a number it's coming
168:31 - in
168:31 - as a string so then we could do
168:34 - something like this we could say name
168:37 - equals cis.arg v
168:41 - and then i would
168:44 - get the element at index 1 which is the
168:47 - name here and i could print
168:51 - [Music]
168:53 - hello
168:55 - and then we're going to do a name oh
168:58 - hello hello and then name so let's call
169:01 - this again
169:02 - and instead of i'm not going to do 39
169:04 - it's just going to be python main.pi bow
169:08 - hello bo so we've now been able to use
169:11 - the argument that was passed in
169:14 - now this is a simple way to do it but
169:16 - you
169:17 - really would have to do a lot of work
169:19 - using this method because you really
169:21 - should validate the arguments make sure
169:22 - the type is correct and you need to
169:24 - print feedback to the user if they're
169:26 - not using the program correctly
169:29 - so i got zoomed out a little bit and i'm
169:30 - going to show you this other method
169:33 - so python provides another package in
169:35 - the standard library to help you called
169:36 - arg parse so first you would insert
169:39 - import arg parse
169:41 - [Music]
169:43 - and then let me show you
169:45 - how you would use it
169:47 - so you call arc parse dot argument
169:50 - parser
169:51 - and then pass in the description of the
169:54 - program so the description of the
169:56 - program is this program prints the name
169:58 - of my dogs
169:59 - then
170:00 - you proceed to add arguments you want to
170:03 - accept
170:05 - so for this example program we are going
170:07 - to accept the c option or it can be
170:09 - slash
170:11 - c or dash that's color
170:13 - and we are going to
170:16 - be calling it color and then later we
170:18 - can we do
170:20 - parser.parse args
170:22 - and then we can access args
170:25 - dot color to get the color that was
170:28 - passed in and then you can specify
170:30 - whether it's required and what help is
170:33 - going to go along with that so let me
170:35 - show you how you would do that
170:37 - we're going to do python
170:39 - main dot pi i'm going to put dash c and
170:42 - then i'm just going to put red
170:44 - okay so
170:46 - you can see if i
170:48 - go this out a little more you can see
170:49 - this is the
170:51 - command i called this is the command i
170:53 - run i pass in red and then it just
170:55 - printed red that's what we have right
170:57 - here
170:58 - and so let me show you what would happen
171:00 - if we if we
171:02 - don't specify the argument so if i just
171:06 - run it without the red so it's now
171:09 - giving me
171:10 - some information usage well main.pi we
171:14 - need to put dash c and then we have to
171:16 - put a color and then it says the
171:19 - following
171:20 - arguments are required this dashi or
171:23 - dash sc so it's it's showing us that we
171:28 - need to
171:29 - if we we've called the program wrong and
171:31 - we're going to need to call it with the
171:33 - dash c
171:34 - you can also
171:36 - set this option
171:38 - we can set an option to have a specific
171:40 - set of values using choices so after
171:44 - required true after this comma i'm going
171:46 - to type in choices and i'm going to set
171:49 - this to equal
171:52 - see i have this empty
171:53 - dictionary
171:55 - but i'm just going to well not a
171:57 - dictionary but
171:58 - because it's not going to key value
171:59 - pairs i can do red
172:01 - and yellow
172:02 - so now it's it can only accept
172:06 - two options so i can
172:09 - call it here
172:11 - with
172:13 - red
172:15 - but if i call with blue
172:17 - it will say
172:19 - invalid choice blue i need to choose
172:21 - from red or yellow so
172:24 - using this arc parse makes it easier to
172:26 - deal with arguments and also makes it
172:29 - easier to
172:30 - communicate information back to the user
172:33 - about what we're trying to get
172:36 - so there are more options with this but
172:37 - those are those are the basics
172:40 - now let's talk about something
172:41 - completely different
172:43 - lambda
172:45 - lambda
172:46 - functions
172:49 - so let me just give you a quick example
172:51 - [Music]
172:55 - lambda num
172:57 - num
172:57 - [Music]
172:59 - times
173:00 - 2. so
173:02 - lambda functions
173:03 - also called anonymous functions are tiny
173:06 - functions they have no name and only
173:08 - have one expression as their body
173:11 - so they're defined using the lambda
173:12 - keyword and so
173:14 - this is going to be the argument
173:17 - and this is going to be the expression
173:20 - the body must be a single expression and
173:22 - it has to be an expression not a
173:23 - statement so this difference is
173:25 - important an expression returns a value
173:27 - a statement does not so it has to return
173:31 - a value so the value that's being
173:33 - returned is the number times two the
173:35 - number that was passed in going to
173:37 - multiply it by 2 in this example
173:39 - so this is basically the simplest
173:41 - example of a lambda function it just
173:43 - doubles the value of a number and lambda
173:46 - functions can accept more
173:49 - arguments so
173:50 - so for instance i could do
173:52 - [Music]
173:54 - lambda
173:56 - a comma b
173:57 - and then we can multiply a times b
174:02 - lambda functions cannot be invoked
174:04 - directly but you can't assign them to
174:06 - variables so for instance i can assign
174:10 - this to the variable called
174:12 - multiply so multiply is going to this
174:15 - function is going to be assigned to this
174:18 - variable here so then the way that i
174:20 - would use that i could print now i'll
174:23 - print the result of calling multiply
174:27 - and then i pass in
174:29 - two
174:30 - and four
174:31 - so if i just run that okay 2 times 4 is
174:34 - 8. we can see right in the console here
174:36 - and then i'm going to just
174:38 - zoom in just a little bit
174:40 - so the utility of lambda functions comes
174:42 - when combined with other python
174:44 - functionality for example in combination
174:47 - with map filter and reduce so speaking
174:50 - of map filter and reduce that's what
174:52 - we're going to talk about now map
174:55 - filter
174:56 - reduce
174:58 - so python provides three useful global
175:00 - functions we that we can use to work
175:02 - with collections so this is map filter
175:05 - reduce so first let's talk about
175:08 - map and since their functions are going
175:10 - to have the
175:12 - parentheses at the end so map is used to
175:15 - run a function
175:16 - upon each item in an iterable item like
175:19 - a list and create a new list with the
175:21 - same number of items but the values of
175:23 - each item can be changed so here's an
175:27 - example we have this list
175:29 - and then here's the function
175:32 - and then we are going to map through
175:35 - each item in the list
175:37 - and so here's the function we're going
175:38 - to run we're going to run this function
175:40 - on each item in the list
175:43 - and now we're going to get a new list so
175:45 - i can do print
175:47 - result now if we print that i'll just
175:50 - run that function and we can see
175:53 - okay we get a map object
175:58 - so then we can always just pass it into
176:01 - the
176:03 - list function
176:05 - and then we can
176:06 - run the program again two four six so
176:09 - one two three became two four
176:11 - so yeah whenever you want to do run a
176:13 - function on each item in a list you can
176:15 - use map
176:17 - and when the function is a one-liner
176:19 - it's common to use a lambda function so
176:22 - we just talked about lambda functions so
176:24 - now let me show you how you would do
176:26 - this as a lambda function so
176:29 - double
176:30 - is going this is going to be a variable
176:32 - and we're going to assign it to a lambda
176:33 - function
176:35 - and i'm going to
176:39 - so now this lambda function takes the
176:41 - number
176:42 - a
176:43 - and then does a times two so and this we
176:46 - just keep the same because now we're
176:48 - using a lambda function here and we're
176:50 - taking each number and passing it
176:52 - through this function where we have the
176:54 - the this is each number in the list and
176:55 - we multiply it so if i run this program
176:57 - it should look exactly the same
177:00 - and we can even simplify it even more so
177:03 - this is where lambda functions really
177:05 - shine instead of assign it assigning it
177:08 - to double first i can copy the whole
177:11 - function i can delete this completely
177:14 - and now i can just put it right in here
177:17 - so now we're mapping over this function
177:20 - and we don't even have to create the
177:22 - function in a different line and assign
177:24 - it to a variable first we can put the
177:25 - lambda function right in the same line
177:28 - right within the map and now i run this
177:30 - and it's going to give us the same
177:32 - result so remember we started with
177:34 - when i first showed you this example we
177:37 - had a much longer piece of code now
177:38 - we've simplified it with the
177:41 - lambda function
177:42 - so the original list the original list
177:46 - is left untouched in a new list with the
177:48 - updated values is returned by map
177:51 - the result is a map object which is an
177:53 - iterable so
177:54 - that's why we needed to cast it to list
177:57 - to print its content
177:59 - okay now let's talk about filter
178:03 - let me put in let me just update the
178:05 - code here it's kind of similar but now
178:07 - we're using filter filter takes an
178:09 - iterable and returns a filter object
178:13 - which is another iterable but without
178:15 - some of the original items so you can do
178:18 - so by returning true or false from the
178:21 - filtering
178:22 - the filtering function so here's the
178:25 - filtering function we are going to check
178:27 - if the item passed in is even so
178:31 - so here's the list here so
178:33 - you can see we're calling filter we pass
178:35 - in the function the filtering function
178:37 - and then the list
178:38 - and we're going to return true or false
178:41 - from this function so if it can be if
178:43 - it's divisible by if when you divide it
178:46 - by two we have zero remainder
178:49 - then it's even
178:51 - so
178:52 - that would return true so this line
178:54 - would return true
178:56 - and then if not it would return false if
178:58 - it's odd so now any even number is going
179:02 - to be added to the result and any odd
179:04 - number is not going to be added to the
179:06 - result so basically we're filtering the
179:07 - list based on this function and then
179:10 - here we just print
179:12 - we convert that result to a list and if
179:14 - we run that it's two and obviously if we
179:17 - can just put in
179:19 - uh more numbers here
179:21 - and run that again
179:22 - we have two four six
179:24 - and then we can just like before we can
179:26 - use a lambda function so
179:29 - i'm just going to
179:31 - copy this here we can just delete this
179:33 - whole thing and we are going to put a
179:35 - lambda function here so lamb
179:38 - duh
179:38 - [Music]
179:41 - so now you can see we're just putting
179:44 - the lambda function in the in line here
179:46 - and we are checking to see if it's this
179:49 - is going to turn true or false whether
179:50 - it's even or not
179:52 - and so i run the program and it's going
179:54 - to give me the exact same result here
179:56 - okay the final thing we're going to talk
179:58 - about is reduce
180:00 - reduce is used to calculate a value out
180:03 - of a sequence like a list so for example
180:06 - suppose we have this list of expenses
180:09 - stored as tuples
180:11 - and so so we had dinner 80 car repair
180:13 - 180 or 120 and we want to calculate the
180:18 - sum
180:18 - of this property
180:21 - in each tuple
180:22 - in this case the cost of the expense
180:25 - so here's kind of the long way of doing
180:28 - it without using reduce
180:31 - we basically take every expense in
180:34 - expenses and then we add to the sum here
180:37 - and we add expense one that's going to
180:39 - be the
180:41 - the item at index one and then we get
180:43 - the sum and we can print the sum so
180:45 - that's kind of like the long way of
180:47 - doing it without reduce but there's a
180:50 - quicker way so
180:52 - to use reduce reduce is a little
180:55 - different from map and filter where it's
180:57 - not available it's not it's not
181:00 - available automatically we have to
181:02 - import it from the standard library func
181:04 - tools so i'll do from
181:06 - funk
181:08 - tools or function tools
181:10 - import
181:11 - [Music]
181:14 - reduce
181:17 - and now i'm going to
181:22 - create a new i'm going to create a new
181:23 - variable called sum
181:25 - and we're going to set it to
181:28 - reduce we're going to use reduce and now
181:30 - i'm just going to
181:31 - pass in i'm going to go directly to the
181:33 - lambda function so
181:35 - lambda
181:41 - let me just kind of explain this for a
181:43 - little bit so reduce the first is going
181:45 - to take a function the reduction
181:47 - function
181:48 - and then
181:49 - the iterable here
181:51 - and the function has to take two
181:54 - arguments
181:55 - so this the first argument is the
181:57 - accumulated value and then the the right
182:00 - argument is
182:02 - the updated the update value from the
182:05 - iterable so we're going to
182:07 - continue adding
182:09 - these two item we're going to
182:11 - basically add every item together and
182:14 - reduce
182:16 - the
182:17 - i the numbers at the first index all
182:20 - into down to one value by adding them
182:24 - all together so i'll just
182:26 - pray here play here and then we get the
182:28 - same number 200 and you can see it's a
182:31 - lot it's a lot quicker just to use the
182:33 - reduce function compared to the other
182:36 - code we had previously
182:38 - okay next up we are going to talk about
182:40 - recursion
182:42 - in
182:42 - python not recursion error just
182:44 - recursion
182:46 - and a function in python can call itself
182:49 - that's what recursion is and it can be
182:52 - pretty useful in many scenarios a common
182:54 - way to explain recursion is by using the
182:56 - factorial calculation
182:58 - so let me show you how you would
182:59 - calculate factorial this isn't python
183:02 - code this is just an example here so a
183:04 - fact when you do 3 factorial that means
183:07 - you do 3
183:08 - you multiply every number between three
183:12 - between this number and one together so
183:14 - three times two times one equals six
183:16 - four factorial is four times three times
183:18 - two times one five factorial is you know
183:20 - five through one and so on and then
183:22 - every number you multiply every whole
183:24 - number down to one so using recursion we
183:28 - can write a function that calculates the
183:30 - factorial of any number so let me show
183:33 - you so here's the function you can see
183:35 - inside the function it's calling the
183:38 - same function so a recursive function
183:40 - it's always going to have a base case
183:42 - that's this
183:44 - and the recursive case so the base case
183:47 - is when we're going to leave the
183:50 - the recursive function so if n is equal
183:53 - to one we're going to return one and
183:56 - that's basically going to get out of the
183:58 - recursive function uh but if n is not
184:01 - going to equal one then we have the
184:03 - recursive the recursive case where we're
184:06 - going to call the function so you always
184:09 - need to have at least you always have
184:10 - need to have a base case so eventually
184:12 - the recursion can stop
184:15 - if the recursion doesn't ever stop
184:18 - then you're going to get a recursion
184:20 - error
184:21 - basically python by default will halt
184:23 - recursions at 1000 calls and that's when
184:25 - you get the recursion error so this is
184:28 - going to get the factorial three but
184:30 - let's just do this a few more times so
184:32 - you can see the difference so three
184:34 - four
184:34 - five and now we'll test this out
184:37 - 6 24
184:39 - 120.
184:40 - okay now let's talk about decorators
184:45 - so decorators in python are a way to
184:47 - change enhance or alter in any way how a
184:50 - function works decorators are defined
184:52 - with the at symbol followed by the
184:54 - decorator name just before the function
184:56 - definition
184:59 - so for instance let's say we have a
185:01 - function
185:02 - hello
185:03 - and it's just going to be the simplest
185:05 - function we're just going to print
185:10 - hello
185:11 - uh so
185:12 - to make that to add a decorator i'm
185:15 - going to put like this an at sign and
185:18 - then the decorator name in this
185:20 - case we're going to type in log time so
185:23 - the function has the log time decorator
185:27 - assigned so
185:29 - whenever we call the hello function the
185:32 - decorator is going to be called a
185:34 - decorator is a function that takes a
185:36 - function as a parameter wraps the
185:38 - function in an inner function that
185:40 - performs the job it has to do and
185:42 - returns that inner function
185:45 - so for instance i'm going to create
185:46 - another function here that's going to be
185:49 - the log time function
185:51 - and now we we can do something before
185:54 - and after the function like for instance
185:58 - we can say
186:00 - print
186:03 - before
186:04 - and then after
186:06 - we are going to print
186:08 - after
186:10 - now if i run this
186:14 - oh and we have to call the function
186:16 - that's always important
186:19 - now if i run this
186:21 - before hello after
186:24 - so you're going to often use decorator
186:26 - functions when you want to change the
186:27 - behavior of a function without modifying
186:30 - the function itself so a few good
186:32 - examples are when you want to add
186:33 - logging test performance perform caching
186:36 - verify permissions and so on
186:38 - you can also use one when you need to
186:41 - run the same code on multiple functions
186:44 - okay now let's talk about doc strings so
186:47 - doc strings
186:50 - [Music]
186:51 - documentation is hugely important not
186:54 - just to communicate to other people what
186:55 - the goal of a function or class or
186:57 - method or module is but it's also it
186:59 - also communicates to yourself when you
187:01 - come back to your code like many months
187:04 - from now you might not remember all the
187:05 - knowledge you were holding in your head
187:07 - when you wrote the code so at that point
187:09 - reading your code and understanding what
187:11 - it's supposed to do
187:13 - so that at that point reading your code
187:15 - and understanding what it's supposed to
187:17 - do will be a lot more difficult so a lot
187:19 - that's one of the reasons why people add
187:22 - comments so another way is to use a doc
187:26 - string so let me show you what a doc
187:29 - string looks like
187:30 - the utility of a doc strings is that
187:32 - they follow conventions
187:35 - so they can be processed automatically
187:37 - so this is how you would define a doc
187:39 - string for a function
187:41 - basically you're putting the three
187:42 - quotation marks here three quotation
187:44 - marks there and then this is a
187:47 - description of what the function is
187:50 - this is how you would define a doc
187:52 - string for a
187:54 - a class and a method so
187:56 - got the class this is what the class
187:58 - does is this is what the method does
188:02 - and then it's also common to
188:04 - add docs place a doc string at the top
188:07 - of the file so if you put a doc string
188:09 - at the top of the file it's going to
188:11 - look like this
188:13 - and it's going to explain what the file
188:16 - is all about
188:18 - and docs stock strings can also span
188:21 - multiple lines just like this is a
188:22 - multiple line docs string as long as it
188:25 - has the three quarts three quarters at
188:26 - the top three quarts at the bottom
188:30 - and then python will process the doc
188:33 - strings and you can use the help global
188:36 - function to get the documentation for a
188:39 - class a method a function or a module
188:41 - for example i'm going to go to the
188:42 - bottom of this and i'm going to say
188:45 - print
188:47 - help
188:48 - and then i'm just going to type in
188:50 - dog now i'll run this
188:55 - and let me just run it again
188:58 - so now you're going to get information
189:00 - about the dog we know that the dog has a
189:02 - name and age it's a class representing a
189:04 - dog and the has these specific
189:07 - methods
189:08 - and then it says more we can get more
189:10 - information data descriptors defined
189:12 - here we have
189:14 - and this is just going to give us all
189:15 - this information
189:16 - about
189:17 - the dog and we and so that's why it's
189:20 - good to use doc strings because there
189:23 - are specific standards and it makes it
189:27 - easier to get information using
189:29 - different helper methods
189:34 - and standards allow
189:37 - and standards allow us to have tools to
189:39 - extract doc strings and automatically
189:41 - generate documentation for your code so
189:44 - besides just this help functions there's
189:46 - a lot of other methods to pull out these
189:48 - docs strings and get information about
189:50 - your code and next we will learn about
189:54 - annotations
189:56 - python is dynamically typed so we do not
189:59 - have to specify the type of a variable
190:01 - or function parameter or a function
190:04 - return value
190:05 - annotations allow us to optionally do
190:09 - that so if we want to actually show what
190:11 - type we're expecting for different
190:14 - values so here's a function without
190:16 - annotations and then here's how we would
190:19 - make it have annotations so uh we want
190:22 - to make this function only accept an int
190:25 - so i'm going to put colon int
190:27 - and then after here
190:29 - i'm going to put
190:31 - actually before the colon here i'm going
190:33 - to put a little arrow here
190:36 - and then i'm going to put in int so now
190:38 - we're specifying that this function
190:41 - receives an int and then it's also going
190:44 - to
190:45 - return an end
190:46 - and you can do the same thing with
190:49 - variables so if we have a variable if i
190:52 - had a variable called count and was
190:54 - equal to zero i can add an annotation to
190:57 - make it be an int like that so now
191:01 - we're specifying that this variable is
191:03 - going to be an integer
191:06 - python will actually ignore these
191:07 - annotations a separate tool called mypi
191:10 - can be run standalone or integrated by
191:13 - ides to automatically check for type
191:15 - errors statically while you're coding
191:18 - it'll also help you catch tight
191:20 - mismatched bugs before even running the
191:22 - code
191:23 - a great help especially when your
191:25 - software becomes large and you need to
191:26 - refactor your code
191:28 - okay now we'll talk about exceptions
191:31 - [Music]
191:34 - it's important to have a way to handle
191:36 - errors and python gives us exception
191:39 - handling to do so so for exception
191:41 - handling you would wrap lines of code in
191:44 - a try block
191:47 - and then inside this block you'll put
191:48 - the lines of code and then if an error
191:51 - occurs
191:53 - python will alert you and you can
191:55 - determine which kind of error occurred
191:57 - using an accept block so
192:00 - we're we're trying some lines of code
192:02 - here and then we're checking for a
192:04 - specific error and then if that error
192:07 - happens we would handle that error but
192:09 - if a different error happens then we
192:11 - will handle the different error you can
192:15 - also catch
192:17 - all exceptions
192:18 - using an accept without an error type so
192:21 - at the very end you could just do accept
192:24 - and then if you don't have an error type
192:26 - then it's going to handle the rest of
192:28 - the exceptions and just to make this
192:31 - clear this is just an example where it
192:33 - says air one you have to put a specific
192:36 - error in that spot
192:39 - you can also put an else block at the
192:41 - end to handle that that will run if the
192:44 - no exceptions are found so if there are
192:46 - no errors in this code that's right up
192:48 - here we can have an else and then run
192:51 - specific code at the bottom that that
192:54 - runs if there's no errors
192:56 - and then we can have a finally block so
192:59 - anything
193:00 - in a finally block is going to just
193:03 - always run at the end whether or not
193:05 - there are exceptions or no exceptions
193:08 - the code in the final block is always
193:11 - going to run the specific error that's
193:13 - going to occur depends on the operation
193:15 - you're performing for example if you're
193:17 - reading a file you might get an eof
193:20 - error would just look like this eof
193:23 - error which means end of file
193:26 - if you divide a number by zero you'll
193:28 - get a zero division error if you have a
193:30 - type conversion issue you might get a
193:32 - type error so
193:34 - let's try this code
193:36 - so i'm going to just delete all this and
193:38 - we'll do result
193:40 - equals 2 divided by
193:43 - 0 which
193:45 - you cannot do
193:47 - so just print the result
193:49 - and if i run that
193:52 - we'll see this error over here
193:55 - zero division error division by zero so
193:59 - it's going to get an error when we run
194:00 - the code and then whenever there's an
194:02 - error anything after the error occurs
194:05 - will not happen so we're not going to
194:07 - print the result because there is
194:09 - because the this
194:10 - this line resulted in error so we're not
194:12 - going to run the following line of code
194:15 - so now let's try adding that operation
194:17 - in a
194:18 - try block
194:19 - so i'm just going to paste it all in
194:21 - here and so we're putting the operation
194:24 - in a try block and then we're expecting
194:27 - a zero division error
194:29 - where we'll print cannot divide by zero
194:32 - finally we will set the result to one
194:36 - and then print the results so let me
194:38 - just run that code see cannot divide by
194:40 - zero and then we print one we because we
194:43 - set it in the final block here
194:46 - so this try block lets us recover
194:48 - gracefully and move on with the program
194:50 - you can raise exceptions in your own
194:52 - code too using the raise statement so i
194:55 - could type in raise
194:58 - and then we can raise an exception
195:00 - intentionally
195:03 - and error
195:05 - so if i just run this
195:08 - it will say
195:09 - an error because that's what we typed in
195:11 - so you can make it say anything you want
195:12 - for your error
195:14 - and this raises a general exception and
195:17 - you can and you can intercept it
195:21 - just like this so i could say
195:22 - try
195:24 - and then we raise that exception
195:28 - and then we can do accept
195:31 - exception
195:32 - as error
195:35 - and then we can print
195:38 - the error
195:41 - okay if i run that
195:42 - so now instead of we don't see all that
195:45 - red anymore because it's not stopping
195:47 - our program because of the error but
195:49 - it's now printing the error message
195:51 - right here
195:52 - just like that
195:54 - you can also define your own exception
195:57 - class extending from exception so i
196:01 - could do class
196:03 - dog not
196:05 - found
196:06 - [Music]
196:07 - exception
196:09 - and then i will
196:11 - extend from exception
196:13 - [Music]
196:16 - and then i can just put
196:18 - pass for this one here let me adjust
196:21 - that
196:23 - so
196:23 - pass here just means nothing and we must
196:26 - use it when we define a class without
196:28 - methods or a function without code so if
196:31 - you're not going to put anything so this
196:33 - is just an example so i can just put
196:35 - pass to mean that we're not going to
196:37 - have any code in this
196:39 - so now we can try it out so i'll just
196:42 - paste that uh so we're going to raise
196:44 - dog not found exception and then if
196:47 - we're we're going to
196:49 - candle this exception and just print dog
196:51 - not found so let's try that yep dog nut
196:54 - bound because it raised this exception
196:56 - here we can also actually do something
197:00 - in the exception
197:01 - so if i can say print
197:03 - inside
197:04 - and then i'm going to run that
197:06 - and i'll do inside and dog not bound the
197:09 - with statement is very helpful to
197:11 - simplify working with exception handling
197:14 - for example when working with files each
197:16 - time we open a file we must remember to
197:18 - close it with makes the process more
197:21 - transparent so let me show you some
197:23 - example code without the with statement
197:27 - so
197:27 - we're not going to go into a lot of
197:29 - details about working with files here
197:31 - but i just want to kind of just give
197:33 - this one quick example so if we're going
197:36 - to be working with files in python so we
197:39 - can open the file and then we can read
197:42 - the file we can print the content from
197:44 - the file
197:45 - and we
197:46 - we're going to try that because there
197:48 - could be an exception and then finally
197:50 - we're always going to make sure to close
197:52 - the file
197:53 - but
197:54 - an alternate way to do it would be like
197:56 - this
197:57 - um so with
197:59 - we're going to open the file as file and
198:01 - then content file.read and then print
198:04 - the content and with using with it's
198:07 - going to make sure to automatically
198:09 - close the file at the end in other words
198:12 - we have built-in implicit exception
198:14 - handling as close will be called
198:17 - automatically for us
198:18 - and with can do a lot more stuff as well
198:21 - this example is just meant to introduce
198:23 - its capabilities
198:25 - now let's talk about third-party
198:27 - packages
198:28 - and we're going to talk about pip so
198:31 - let's learn how to install third-party
198:33 - packages in python using pip the python
198:36 - standard library contains a huge number
198:38 - of utilities that simplify our python
198:40 - development needs but nothing can
198:42 - satisfy everything
198:44 - that's why individuals and companies
198:45 - create packages and make them available
198:48 - as open source software for the entire
198:49 - community so the modules are all
198:52 - collected in a single place called the
198:55 - python package index which is available
198:58 - available at pipe.org that's
199:01 - pi
199:02 - pi.org
199:04 - and they can be installed on the system
199:07 - using
199:08 - pip there's over 270 000 packages freely
199:12 - available
199:13 - most computers are already going to have
199:15 - pip installed and it already has pip
199:17 - installed so let me show you how you
199:19 - would install a package we'd have to go
199:22 - over to the shell here if you're not on
199:25 - replit you can just do in your terminal
199:27 - and i'm going to clear this here
199:30 - and i'm just going to do pip
199:33 - install and then you can put the name of
199:36 - a package for instance one popular
199:38 - package is called the request package
199:41 - it's an http library so i can do
199:43 - requests
199:45 - and let me just
199:46 - so you can see i have to make sure i
199:48 - spelled that right
199:49 - [Music]
199:52 - and it's going to install that package
199:55 - right now so once the we install this
199:57 - package it's going to be available for
199:59 - all our python scripts because packages
200:02 - are installed globally and the exact
200:04 - location depends on the operating system
200:09 - you can also upgrade a package to its
200:11 - latest version by doing pip install
200:15 - dash u and then i will just put the
200:18 - package name so in this case we'll just
200:19 - do request again
200:23 - and then it's going to just update it to
200:26 - its
200:27 - latest version
200:28 - in this case
200:30 - it updated from
200:32 - 2.28.0 to 2.28.1
200:36 - you can also specify a specific
200:40 - version when you're installing
200:43 - and then you can also uninstall a
200:45 - package so i'll do pip
200:48 - uninstall
200:49 - requests
200:55 - and then i can say that yes i do want to
200:57 - uninstall that
200:58 - and then once when you have a package
201:00 - installed
201:02 - i'm just going to install request again
201:06 - and then you always have to make sure
201:07 - you spell it right
201:11 - so once you have it installed you can do
201:12 - pip show
201:14 - requests
201:16 - and then it's going to show some
201:17 - information about the package
201:20 - so see we can see the name the version
201:23 - uh the summary and then a bunch of the
201:25 - author and a bunch of other information
201:27 - about the package
201:30 - okay i'll just clear this
201:32 - now we're actually gonna backtrack a
201:34 - little bit we already talked about lists
201:35 - but i'm gonna talk about a more advanced
201:38 - way of using lists called
201:40 - list
201:41 - compression
201:43 - list compressions so list compressions
201:46 - are a way to create lists in a very
201:48 - concise way so suppose you have this
201:51 - list like this it's a list of numbers
201:54 - and we'll just do
201:55 - one
201:56 - two three
201:57 - four five
201:59 - so we can create a new list using a list
202:01 - compression
202:02 - composed by the numbers list elements to
202:06 - the power of 2.
202:08 - let me show you what i mean so let's get
202:10 - make a new list numbers
202:13 - power
202:14 - [Music]
202:16 - 2
202:17 - equals
202:18 - and let me just show you how you do this
202:20 - list compression
202:23 - so this is the list compression syntax
202:26 - and if i print this
202:30 - [Music]
202:31 - we can see that now we have every
202:33 - element in the list to the power of two
202:35 - list compressions are a syntax that's
202:38 - sometimes preferred over loops as it's
202:40 - more readable when the operation can be
202:42 - written on a single line
202:44 - so for instance this is how you would do
202:46 - it uh with a loop so what we do in a
202:49 - single line up here we take a few lines
202:52 - to do
202:53 - in the method with a loop so list
202:55 - compression just makes it
202:57 - simpler
202:58 - and then you can do the same thing with
203:00 - map as well
203:01 - but again it's just a little more
203:03 - complex sometimes it's just simpler to
203:06 - use a list compression using the syntax
203:08 - here
203:09 - now let's talk about a few more advanced
203:11 - topics in regards to functions
203:13 - polymorphism
203:15 - polymorphism generalizes a functionality
203:18 - so it can work on different types
203:20 - it's an important concept in object
203:22 - oriented programming so see in here
203:25 - we've defined the same method on
203:28 - different classes so the dog has eat and
203:31 - the cat also has an eat method
203:34 - then we can generate objects and we can
203:35 - call the eat method regardless of the
203:38 - class the object belongs to and will get
203:40 - different results so we create the two
203:43 - objects the dog and the cat here
203:45 - and we're calling the eat method on both
203:48 - objects and if we run this you can see
203:50 - what we're getting eating cat dog food
203:53 - eating cat food and so you could do a
203:56 - lot of things with this like maybe you
203:58 - have a list of different animals and
204:01 - then you can
204:02 - loop through that list and call the eat
204:04 - function or the eat method on each
204:06 - animal in that list and they don't have
204:08 - to be the exact same class to be able to
204:11 - still run the eat method
204:13 - so we build a generalized interface and
204:16 - now we do not need to know that an
204:18 - animal is a cat or dog we just need to
204:20 - know that we can call eat on it
204:23 - now let's talk about
204:24 - operator
204:26 - overloading
204:27 - [Music]
204:29 - operator overloading is an advanced
204:31 - technique we can use to make classes
204:33 - comparable and to make them work with
204:35 - python operators so let's take this
204:38 - class dog so here's a dog class and you
204:41 - can create a dog with a name and age
204:44 - then we'll create two dog objects we'll
204:47 - do roger equals dog
204:50 - and we can pass the name
204:54 - and eight
204:56 - [Music]
204:59 - and then i'll make another one
205:04 - we can use operator overloading to add a
205:08 - custom way to compare these two objects
205:11 - based on the age property
205:13 - so like how could you compare
205:16 - this dog and this dog well we can make
205:19 - it possible with operator overloading so
205:22 - let me just show you this example here
205:24 - so
205:25 - this
205:26 - function here gt
205:28 - is going to compare things as to figure
205:31 - out what what is greater than you can
205:33 - now we'll be able to compare
205:35 - two dog objects to see which one is
205:37 - greater than the other and this is how
205:39 - we're going to figure out which is
205:41 - greater than return true if self.age is
205:45 - greater than
205:46 - other dot age which is the other one
205:48 - you're comparing it to else false
205:52 - now we can
205:53 - do print
205:56 - roger
205:58 - is greater than sid so we're trying to
206:01 - figure out this is true or false if i
206:02 - run this it's going to say true roger is
206:06 - greater than sid because 8 is bigger
206:09 - than 7. but if we like put 9 here run
206:12 - that
206:13 - now it's going to be false
206:15 - so in the same way we define this
206:18 - underscore underscore gt underscore
206:20 - which means greater than we can also
206:22 - define methods for like less than
206:25 - lower or equal to greater equal to or
206:27 - not equal
206:29 - and then you can also create methods to
206:32 - go with different arithmetic operators
206:35 - so
206:36 - we can do add subtract multiply
206:38 - division floor division mod power so you
206:41 - can see all these different ones you can
206:43 - make it respond to the different
206:44 - operators so the example was just a
206:47 - greater than operator but we can
206:49 - make functions to show how it's going to
206:51 - respond to all these different
206:53 - operators there's even a few more
206:55 - methods to work with other operators but
206:57 - you get the idea we've learned a lot
206:59 - about python and now we're going to
207:01 - bring a lot of what we've learned
207:03 - together to code a blackjack card game
207:06 - and in the process we'll learn about
207:08 - object oriented programming in python so
207:10 - we'll start by creating a new python
207:13 - project on replit
207:17 - and i'm just going to close this tab
207:18 - here
207:19 - and i'll zoom in just a bit
207:23 - and just like our first project
207:26 - i'm going to
207:27 - say what i'm about to do and i want you
207:30 - to see if you can do it on your own
207:32 - before i show you how to do it
207:35 - and with all you've learned so far a lot
207:38 - of this you're probably going to be able
207:40 - to figure out on your own as i give you
207:42 - the instructions without even seeing how
207:45 - i how i do it but then you can come back
207:47 - to the video and see how i do it
207:50 - or i guess you can just watch and not
207:52 - even try to do it yourself but you're
207:53 - going to learn a lot more if you try to
207:55 - code this by yourself along with me as i
207:58 - do it but right before i do the
208:01 - different steps
208:02 - so the first thing we're going to do is
208:04 - create a
208:05 - variable called a suit
208:07 - and set it equal to hearts and then a
208:10 - variable called rank and set it to equal
208:14 - k for king
208:15 - and then a variable called value and set
208:18 - to equal
208:20 - 10.
208:21 - [Music]
208:22 - okay simple two variables equal to
208:24 - strings and one variable equal to an int
208:28 - so now we are going to add a print
208:30 - statement and print the the phrase your
208:34 - card is with a colon at the end
208:38 - and then we'll add another print
208:39 - statement and print the rank
208:42 - so now we're just printing the variable
208:45 - here
208:46 - and we're going to be doing a lot of
208:48 - refactoring as we create this program
208:50 - let's refactor this so it's just one
208:53 - print statement that's going to print
208:54 - your card is colon space and then the
208:57 - rank
209:00 - so we are going to be doing
209:03 - string concatenation
209:05 - [Music]
209:07 - just like that
209:09 - so
209:10 - you can concatenate as many strings and
209:12 - variables as you want so let's update
209:14 - the code so that the print function
209:16 - print prints your card as
209:18 - k
209:19 - of
209:20 - hearts
209:22 - so we just need to add
209:24 - of and we have to make sure we put
209:26 - spaces on each side of the word of
209:30 - and then
209:31 - suit
209:34 - and let me just
209:35 - adjust this here okay as you know you
209:37 - can use a list in python to store
209:38 - multiple values or items at a time so
209:41 - above the suit variable
209:43 - create a suits
209:45 - variable and assign it to a list of
209:46 - suits in this case spades clubs hearts
209:50 - diamonds
209:53 - we learned about how you can use the
209:54 - bracket operator to access a specific
209:57 - element in a list the number inside the
210:00 - bracket specifies the index of the list
210:02 - to access remember the indexes start at
210:04 - zero
210:06 - so you update the suit variable so that
210:08 - the value of hearts come from comes from
210:11 - the suits list
210:14 - now we'll practice a for loop so add a
210:17 - for loop to the end of the code that
210:19 - prints each suit
210:22 - and then we'll just test this out
210:24 - i really hope you actually are following
210:26 - along and trying it out right before i
210:28 - show it to you that's how you're going
210:30 - to learn the best here so spades clubs
210:32 - hearts diamonds
210:34 - now this next thing is is just to see if
210:37 - we can do it so it's not going to be
210:38 - part of our final code but right before
210:40 - the loop we just added see if you can
210:42 - add another item to the suits list
210:45 - that's the string snakes
210:52 - there's a few different ways to do it
210:53 - but we will use append snakes so this is
210:56 - just going to append the word snakes at
210:58 - the end
210:59 - of the list so if i run this we can now
211:02 - see snakes at the bottom
211:05 - okay now we're going to start the
211:06 - process of representing a full deck of
211:08 - cards with python code
211:10 - so we're going to actually get rid of a
211:12 - lot of this we're going to get rid of
211:13 - all this we're just going to have the
211:14 - suits and then we're going to have this
211:16 - for loop at the bottom we're going to do
211:18 - a lot of refactoring as we go mainly for
211:20 - educational purposes but also so we can
211:23 - get the a really good blackjack game so
211:25 - we have a list of suits after that we're
211:27 - going to create a list of ranks that's a
211:31 - 2 3 4 5 6 7 8 9 10 j q
211:34 - k
211:35 - [Music]
211:38 - now before the suits list
211:40 - create a new variable called cards and
211:43 - assign an empty list to the variable
211:50 - you can an empty list is just two
211:52 - brackets with nothing inside
211:55 - now in the cards list there should be an
211:57 - item for each card in the deck each item
211:59 - in the suits list should be combined
212:01 - with each item in the ranks list for a
212:03 - total of 52 items or cards
212:07 - let's work our way up to that so first
212:09 - we'll update the print statement in the
212:11 - for loop so that it prints a list with
212:14 - two elements the first element should be
212:16 - suit and the second should be the first
212:18 - element of the ranks lists so this
212:21 - should print
212:22 - an ace in every suit
212:27 - so i'm going to update this so it's
212:29 - going to be a list with
212:32 - suit
212:33 - and ranks
212:35 - the first item is going to be at index
212:38 - zero now let's print that out
212:42 - so we got them these four right here
212:45 - now instead of just printing an ace in
212:47 - every suit let's print every rank in
212:50 - every suit
212:51 - this can be done easily with a for loop
212:53 - nested within another for loop so inside
212:56 - the for loop add another for loop that
212:59 - loops through the ranks
213:01 - then update the print statement so that
213:03 - it's not just printing the first element
213:07 - in the ranks list but it's printing the
213:09 - rank from the for other for loop
213:14 - so let me show you what i mean
213:16 - we're going to do four
213:19 - for rank and ranks
213:22 - and then
213:24 - we have to make sure to indent this
213:26 - print statement so it's inside this
213:28 - other for loop
213:29 - and this is now just going to be
213:32 - rank so it's going to print the suit and
213:34 - rank and i'll just run that
213:37 - and now we with this nested for loop we
213:39 - have every card at every rank in every
213:42 - suit all 52 cards are printed as two
213:45 - item lists
213:47 - an element in a list can be another list
213:50 - so instead of printing 52
213:52 - two item lists
213:54 - let's append those 52 cards to the cards
213:57 - list
213:58 - so we already have the cards list here
214:00 - it's empty but i'm going to do
214:03 - cards
214:05 - dot
214:06 - append
214:08 - and so we're appending
214:10 - this item
214:12 - all these items to the cards list
214:15 - so let's check what the cards list looks
214:17 - like by printing out printing it out at
214:19 - the bottom remember make sure this is
214:21 - not indented at all and we'll do print
214:24 - cards
214:26 - and i'll run that
214:34 - and then here it is here so this is the
214:36 - list it's not
214:38 - one there's just a comma between each
214:40 - item in the list here
214:42 - you may notice that all the cards are in
214:44 - order in the cards lists
214:46 - for a game like this though the cards
214:48 - must be shuffled so to help with this
214:51 - import the random module at the top of
214:54 - your code so that's just we just do
214:58 - import
215:00 - random
215:01 - [Music]
215:03 - now we'll be able to use the the random
215:05 - module so this is going to import the
215:06 - random module which contains a variety
215:08 - of things related to random number
215:10 - generation
215:11 - and as you probably remember when you
215:12 - import a python module it allows you to
215:14 - use additional commands in your code
215:17 - specifically we're going to be using the
215:19 - random.shuffle function
215:21 - so right before at the end where it says
215:23 - print cards we're going to call
215:24 - random.shuffle and pass in the cards
215:28 - list to that function
215:31 - and then if i play this here or run the
215:34 - program we can see that these are not in
215:36 - order anymore see ace of spades
215:39 - three of spades king of diamonds jack of
215:42 - hearts so these are no longer in order
215:44 - because they've been shuffled now let's
215:46 - remove a single element from the cards
215:48 - list this is similar to dealing a card
215:51 - from a deck and this can be done with
215:53 - the pop method
215:55 - so after the cards are shuffled
215:58 - let's create another card variable and
216:00 - just
216:01 - pop off a card from the cards list and
216:04 - put it into that variable called card
216:06 - and just print that card
216:09 - so i'll do card
216:10 - equals cards dot pop
216:14 - and then instead of printing all the
216:16 - cards i'm just going to print a single
216:18 - card i'll run the program
216:20 - see every time i run the program you can
216:22 - see we're getting a different card we're
216:24 - dealing a different card because it's
216:26 - been shuffled
216:27 - so we've already learned all about
216:28 - functions and now we're going to create
216:30 - a function
216:32 - so create a
216:33 - function called shuffle that just has
216:36 - the single line that shuffles the cards
216:40 - so it's just def shuffle
216:43 - and then i just have to make sure this
216:44 - is indented so now when we call the
216:47 - shuffle function it will shuffle the
216:49 - cards
216:50 - so right before the print statement
216:52 - call the shuffle function and instead of
216:54 - just printing the single card print the
216:57 - cards
216:58 - so do shuffle
217:01 - and then i will print all the cards and
217:04 - let's just try out the program
217:06 - and we can see there was a problem it's
217:09 - because we didn't put the the colon here
217:12 - so that's an important part of creating
217:14 - a function is putting the colon there
217:16 - now we'll create another function called
217:18 - deal and we'll put this line inside the
217:21 - the deal function
217:23 - so we're going to define deal
217:26 - and i'll put the colon this time and
217:27 - make sure to
217:29 - indent that
217:30 - and we can see this has a orange
217:33 - squiggly line underneath it because
217:34 - variables can only be accessed in the
217:36 - context that they were created so the
217:38 - card variable will not be available
217:40 - outside of the deal function
217:42 - you can get a value out of a function by
217:44 - returning a result using the return
217:46 - statement so at the end we're going to
217:49 - return the card
217:52 - okay now we've taken care of that
217:54 - squiggly line there so after the shuffle
217:57 - function is called we'll call the deal
217:59 - function and assign the return value to
218:01 - a variable named card then we'll update
218:04 - the print function to print card instead
218:06 - of cards
218:08 - so card
218:09 - equals
218:11 - deal
218:12 - and then we'll just print
218:15 - the card
218:18 - and again we
218:20 - see a different card every time we run
218:22 - the program
218:24 - what if you want the deal function to
218:25 - deal more than one card well let's
218:28 - refactor the deal function to and accept
218:30 - to accept an argument so any number of
218:32 - arguments can appear inside the
218:34 - parentheses when a function is created
218:36 - separated by commas inside the function
218:39 - the arguments are assigned to variables
218:41 - called parameters so start by making it
218:44 - so we'll start by making it so the deal
218:45 - function takes an argument named number
218:48 - then we'll make sure when we call the
218:49 - function we use the new parameter
218:52 - by
218:53 - making it so we're gonna deal two
218:56 - so i'm just gonna put number here it's
218:58 - gonna it's gonna deal a number of cards
219:01 - we're gonna deal two and i just didn't
219:03 - say this before but now instead this is
219:05 - not one card anymore so we're going to
219:07 - update this to be cards dealt but
219:10 - there's a special shortcut you can
219:12 - either it's going to be
219:15 - command or control d
219:17 - and now i'm actually selecting the card
219:19 - two different times see i i now have
219:21 - multiple cursors here so basically i
219:24 - selected the word i double clicked to
219:26 - select the word then did command or
219:27 - control d now it's selecting two words
219:30 - and now i can type in
219:32 - cards
219:34 - delt
219:35 - so now i can type in two places at one
219:37 - time so that's a cool thing that you can
219:39 - do in replit and you can do it in many
219:41 - other code editors and i'll run the
219:43 - program but it should still only deal
219:45 - one card because even though we're
219:46 - passing this parameter into here we're
219:48 - not doing anything with it yet here so
219:51 - we want to update the deal function so
219:53 - it's going to return a list of cards
219:55 - instead of a single card
219:57 - in the first line of the function create
219:59 - an empty list named cards delt then
220:02 - update the last line of the function to
220:05 - return cards dealt instead of return
220:07 - card so let's do that really quick we're
220:10 - going to do
220:11 - cards
220:13 - dealt
220:14 - is going to equal an empty list and i'll
220:17 - just copy that and paste it
220:19 - right here
220:20 - now do you remember how to use a the
220:22 - range function with a for loop we talked
220:24 - about it earlier in the course we just
220:26 - briefly touched on it but let's create a
220:28 - for loop that's going to
220:31 - add a card from the deck
220:34 - for each
220:35 - card dealt
220:37 - so we can do that by creating a for loop
220:40 - for x and range
220:43 - number now this is a common thing you're
220:46 - going to be doing in python creating a
220:49 - for loop that's going to be in range
220:51 - number because now it's going to loop
220:54 - this many times it's going to loop this
220:56 - many times which is the number we passed
220:57 - in here and we're going to do a few
221:00 - things in this for loop
221:01 - first we are going to
221:04 - actually do this what we already have
221:05 - card equal cards dot pop and then we'll
221:08 - do cards
221:10 - delt
221:12 - dot append
221:15 - card
221:16 - so now just this card that we popped off
221:19 - the deck we are appending it to the
221:20 - card's delt and then we're returning the
221:23 - cards dealt here
221:26 - so down here in the code
221:28 - let's separate out a single card from
221:31 - the two cards dealt
221:33 - so let's create a variable called card
221:35 - and set it equal to the first item in
221:37 - the cards delt list
221:40 - and then we'll just print that card
221:41 - instead of cards dealt
221:43 - so we are going to do card
221:46 - equals cards
221:49 - delt and then we just use the brackets
221:52 - and put 0 to get the first item in that
221:56 - list
221:56 - and then we'll just print
221:58 - a card
222:00 - now i'm just going to test out the
222:01 - program we're still just seeing a single
222:03 - card here but it's doing a lot more
222:06 - behind the scenes now
222:08 - so now let's separate out the rank part
222:10 - of a single card so after we create the
222:13 - card there let's create a variable named
222:16 - rank and assign it the rank from the
222:18 - card
222:20 - so we'll do rank
222:22 - equals card
222:25 - and then i have to get index one because
222:28 - the rank is this that's the nine here
222:31 - the second item in this card is the rank
222:35 - so each rank has a different value in
222:37 - blackjack the value of an ace or an a in
222:40 - this in this program is 11
222:44 - or sometimes it can actually be one it's
222:45 - going to be 11 or 1 but we'll get to the
222:47 - one part later so jack j q and k which
222:52 - is jack queen and king have the value of
222:54 - 10 and then the numbers have the value
222:56 - of the number so we need to check what
222:58 - the rank is and set the value depending
223:01 - on the rank
223:02 - so this is the perfect time for a
223:05 - conditional statement specifically an if
223:07 - statement
223:09 - before the final print statement or
223:11 - program we're going to add an if
223:13 - statement to check if the rank equals a
223:17 - and if so we'll assign 11 to a variable
223:20 - named value
223:23 - so we'll do if
223:25 - rank and i hope you remember if you're
223:27 - flying along i hope you remember to use
223:28 - two equal signs instead of one equal
223:30 - sign here so if rank equals a
223:34 - then value is going to equal with a
223:37 - single equal sign is going to equal
223:40 - 11.
223:41 - now if rank does not equal a we'll want
223:43 - to check if it equals j q or k
223:47 - that can be done with an elif statement
223:50 - for now we'll just create an if
223:52 - statement to check if the rank equals j
223:54 - and then if so we will set the value to
223:57 - 10.
224:00 - so we talked about the three logical
224:01 - operators and or
224:04 - and not you can use these three
224:06 - operators in conditional statements to
224:08 - check multiple conditions at once so we
224:11 - want to check if
224:13 - rank is j or rank is q
224:16 - or rank is k so update the code with the
224:20 - the and with the ors
224:24 - now there can be any number of ls
224:25 - statements after an if statement but at
224:27 - the end there can only be a single else
224:29 - statement
224:30 - and like we discussed the else is just
224:32 - going to be if none of the other ones
224:34 - are true so let's add an else statement
224:37 - and inside we'll just assign rank to
224:39 - value because we've already gotten all
224:40 - the letters out of the way the rest are
224:42 - numbers and we can assign it directly to
224:44 - the value
224:48 - now we'll
224:49 - instead of printing the card at the end
224:52 - let's print the rank and the value
224:56 - so i can just type in rank comma value
224:59 - and
225:00 - when that multiple values in a print
225:02 - statement are listed with a comma
225:04 - separating them both values are printed
225:06 - with a space in between so let's test
225:08 - this out a few times q10 five five 6 6
225:12 - so we can see every time we press it
225:14 - it's going to be a random rank and value
225:17 - now we already talked about dictionaries
225:19 - in python it's like a list but more
225:21 - general you can think of a dictionary as
225:23 - a mapping between a set of indices which
225:25 - are called keys and values so key value
225:28 - pairs each key maps to a value so above
225:31 - the print statement let's create a
225:32 - variable called rank
225:34 - underscore dict for dictionary and
225:37 - create a dictionary with two items
225:40 - a key value pair for the rank and a key
225:43 - value pair for the value
225:50 - so we have the string rank here and then
225:52 - the actual rank variable string value
225:54 - and the actual value variable
225:57 - before we are
225:59 - printing the rank variable and the value
226:01 - variable but let's update this code so
226:04 - we're actually getting the rank and
226:05 - value from the rank dictionary right
226:07 - here
226:08 - so i'm going to copy that and then i
226:11 - just pasted that but now i'm going to
226:13 - use bracket notation
226:15 - and so i'll put two brackets but then i
226:17 - also have to surround this in quotation
226:20 - marks
226:21 - and then i'm gonna
226:23 - put the rank dictionary the brackets
226:26 - and then the quotation marks because
226:28 - we're accessing that key there
226:30 - and then i can just run the program and
226:33 - it's still doing the same thing as
226:34 - before just a lot more complicated as
226:37 - far as the code goes but it's going to
226:39 - be good to have more complicated code as
226:42 - our program is going to become more
226:44 - complicated as we go
226:46 - so when writing a program there are many
226:48 - ways to do almost everything
226:51 - now we're going to refactor the code to
226:53 - get the value of each rank without using
226:56 - an if statement
226:58 - instead we'll store both the rank name
227:00 - and value in the ranks list using
227:03 - dictionaries so let's delete all the
227:05 - code lines of code after where it says
227:08 - shuffle
227:09 - so
227:11 - here i know we typed in a lot of stuff
227:12 - there but it was just kind of to
227:15 - practice and now we're going to practice
227:16 - a different method of doing this
227:19 - so now let's create a new card variable
227:22 - a new variable called card at the end
227:24 - and let's assign to the card variable
227:27 - a a single card that will deal from the
227:29 - deck but we'll make sure that card is
227:31 - not
227:32 - in a list so this is a little tricky i'm
227:35 - gonna do deal and i'll deal one card
227:39 - but now i have to get
227:41 - the first item so this is going to deal
227:44 - one card but the one card is going to
227:47 - deal is going to be in a list so i want
227:50 - to get the first item in the list which
227:52 - is going to be the only item in the list
227:54 - so i had to put the zero in brackets
227:56 - here to get that card out of a list
227:59 - before it goes into the card variable
228:02 - now we're going to update the ranks list
228:04 - so here's the the ranks list each
228:07 - element the list should now be a
228:09 - dictionary when lists or list elements
228:11 - are long it's common to put each element
228:13 - on its own line so we're going to put
228:14 - each element on its own line and each
228:17 - element is going to have the rank and
228:18 - the value so for instance it will be
228:20 - rank a value 11
228:23 - rank 2 value 2.
228:27 - so it's going to look like
228:29 - this
228:31 - and i'm now i'm actually going to zoom
228:32 - out just a little bit and we have all
228:36 - these they're all these ranks and each
228:38 - one in this list
228:40 - is a dictionary each element in the list
228:42 - is a dictionary
228:43 - okay now that this is updated let's go
228:45 - down and just print a card so we can see
228:48 - now that we've updated that ranks list
228:50 - so print
228:52 - card
228:54 - okay so this is what it's going to look
228:56 - like coming from
228:58 - our list
228:59 - so we got the suit
229:01 - and then we have the rank that's also
229:03 - going to have the value here the rank
229:05 - and the value
229:07 - we can see every time we click it we get
229:09 - a random item
229:12 - now let's update the code so instead of
229:14 - printing the whole card we just
229:17 - print the value so in this example the
229:20 - value is two so we just want to print
229:23 - this to just that that value so how can
229:26 - we update this see if you can figure out
229:28 - how to update this line so only prints
229:31 - just the value number there
229:34 - so first of all we have to see that
229:36 - we're in a list and we need so this is
229:38 - the first element of the list this is
229:40 - the second element so wait to start by
229:42 - getting the second element of the list
229:45 - which is
229:46 - index one
229:48 - and then
229:49 - we have an object here or a dictionary i
229:52 - mean and we need to get
229:54 - so here we have this key value pair so
229:56 - we need the value at that key so to get
229:59 - the value of that key we are going to
230:00 - put more brackets and i'm going to put
230:02 - value the key of value so now with that
230:06 - should work let's try it
230:08 - okay nine
230:09 - seven see every time it's gonna just
230:11 - give us the value of the card
230:14 - now we'll start defining classes that
230:16 - will be used in order to separate out
230:18 - different aspects of the game
230:21 - so classes you may remember provide a
230:23 - way of bundling data and functionality
230:25 - together creating a new class creates a
230:27 - new type of object allowing new
230:29 - instances of that type to be made an
230:31 - object can contain a number of functions
230:34 - which we call methods as well as data
230:35 - that is used by those functions called
230:37 - attributes so
230:39 - we're going to use classes to model
230:41 - three parts of the game a card a deck
230:44 - and a hand so far we've mainly worked on
230:46 - the elements of the debt class
230:49 - so right after this import statement at
230:52 - the top
230:53 - we're going to
230:55 - make a class a class called
230:58 - dec and we're going to put everything
231:00 - that we've written so far in that class
231:04 - so we're just gonna do class
231:07 - deck
231:08 - colon
231:09 - okay now we just highlight
231:11 - everything here and then i'm gonna press
231:14 - tab
231:14 - to put everything in the class of deck
231:17 - because everything's
231:19 - indented a little bit
231:20 - and then these last few lines of code we
231:23 - don't need so i'll just delete those
231:25 - those are just for testing out
231:27 - a class is like a template you can use
231:30 - that class to create an instance of the
231:32 - class called an object
231:33 - then you can use the instance each
231:36 - instance keeps track of its own state so
231:38 - you can update an instance created from
231:39 - a class and it won't impact other
231:41 - objects created from the same class soon
231:44 - you'll see an example of all this to
231:45 - make it easier to understand
231:47 - but first let's prepare a class to
231:50 - create an instance from it
231:52 - when you create an instance of a class
231:54 - python automatically calls a function
231:56 - also called a method in the clast named
231:58 - init remember we already discussed this
232:01 - earlier in the course so the contents of
232:04 - this init method should be code that is
232:06 - run one time to initialize the instance
232:10 - so at the beginning of our class let's
232:13 - create this init function so we'll do
232:17 - def
232:18 - underscore underscore init
232:21 - underscore underscore and if you
232:22 - remember from before we always have to
232:24 - pass in
232:25 - self
232:26 - to all of these
232:28 - functions in a class because then it
232:30 - gets itself is referring to the instance
232:34 - of the class that we've developed now
232:36 - we're going to indent all the code
232:37 - that's not part of the shuffle or deal
232:39 - function so the code will be part of
232:41 - this new function so i'm just going to
232:43 - highlight
232:44 - all this here
232:46 - including
232:47 - the suits here and then just press
232:50 - tab
232:51 - so like i said we just added self in
232:53 - here you should always
232:54 - all the methods in a class or all the
232:56 - functions should have self
232:59 - anything inside the parentheses remember
233:01 - is called an argument their variables
233:03 - pass them from the color to the
233:04 - functions
233:05 - as i've said all functions in a class
233:07 - should receive self as an argument and
233:10 - self represents the instance of the
233:12 - class by using the self keyword the
233:14 - function can access the attributes and
233:16 - methods of the class
233:18 - so let's make sure to add self as the
233:21 - first item in the parentheses of the
233:23 - other functions
233:25 - so we are going to add self here
233:28 - and then see how we already have number
233:30 - here but we're going to hit self at the
233:31 - beginning
233:32 - and we so we can still
233:34 - call this function with just
233:36 - a single number but it's going to also
233:39 - get a reference to the instance here now
233:42 - i want you to notice that
233:44 - the cards here is underlying in
233:46 - red so before it wasn't when we were
233:49 - before we made this into a class we
233:51 - could just access
233:53 - this cards variable but now we cannot so
233:56 - let's fix that
233:58 - inside a class in order to access a
234:00 - variable in multiple functions also
234:03 - called methods the variable has to start
234:05 - with self dot
234:07 - so we're going to change all instances
234:10 - of cards in every function to self.card
234:14 - starting
234:15 - with this so self dot cards
234:19 - now this is going to make it so we can
234:20 - access it in other places and then we'll
234:22 - change this to self dot cards
234:26 - and then this is self
234:30 - dot cards
234:31 - and then self
234:33 - dot cards
234:36 - so now this will be a variable that's
234:39 - specifically associated with the
234:41 - instance of the deck that's created and
234:44 - then we can access it in all of these
234:47 - other methods
234:48 - okay we can now create an instance also
234:51 - called an object of the deck class so at
234:54 - the very end of the code
234:56 - let's create a variable called deck 1
234:59 - and make it an instance of the deck
235:01 - class
235:04 - so to make sure i'm not indented at all
235:06 - and i'll do deck
235:08 - 1
235:09 - equals
235:12 - deck there we go
235:15 - now since we created cards with
235:17 - self.cards
235:19 - we can access that we can access cards
235:23 - from the instance of the class so let's
235:25 - just print out the cards from our deck
235:29 - one so do print
235:32 - deck
235:33 - one dot cards
235:36 - and we can try that out now you can see
235:40 - the the list of all of these cards
235:43 - it has the suit
235:45 - and the rank and the value for each card
235:48 - so underneath where we created deck one
235:50 - let's create deck two we'll create
235:52 - another instance of another deck
235:54 - so
235:56 - [Music]
236:00 - so now we can call methods on these
236:03 - instances and you see some of the
236:06 - methods we have we have shuffle and deal
236:08 - so on deck 2 right after we create the
236:10 - deck 2 let's shuffle the deck so deck
236:15 - 2 dot shuffle
236:17 - and then i have to make sure to put the
236:19 - parentheses
236:21 - at the end here
236:23 - right if we print deck one let's print
236:24 - deck two or the cards of deck two so i'm
236:27 - gonna copy that and then we'll print
236:29 - deck two cards so now we should see that
236:31 - the deck one cards are not shuffled and
236:33 - the deck two cards are shuffled so let
236:35 - me move this over here i'm gonna run the
236:37 - program
236:38 - and let's see if we can see that where
236:40 - deck one so here's where here's deck one
236:43 - and we can see how it's all diamonds
236:46 - diamonds diamonds diamonds diamonds all
236:48 - the diamonds are in a row because
236:49 - unshuffled but then if we go into deck 2
236:52 - we can see we have diamonds clubs spades
236:55 - diamonds hearts so these are shuffled in
236:58 - deck 2 they are shuffled
237:01 - okay the deck works
237:04 - now let's add safeguards to prevent
237:06 - errors every time the deal function is
237:08 - called a card is removed from the cards
237:11 - list
237:12 - you can only remove a card if there are
237:15 - cards to remove
237:16 - so before the program tries to pop a
237:19 - card off self.cards is to check if the
237:23 - length of self.cards is greater than
237:25 - zero
237:26 - remember you can get the number of items
237:28 - in a list with length so see if you can
237:31 - figure that out on your own and then i'm
237:33 - about to show you how it's done
237:36 - so when it's going to deal here
237:38 - right as we're dealing we're going to
237:40 - add an if statement here so if
237:43 - the length
237:45 - of self dot cards
237:49 - is greater than zero
237:52 - and we do we don't need this parentheses
237:55 - here so if the length of self.cards is
237:58 - greater than zero
238:00 - then we will
238:03 - do this we'll pop up a card and add it
238:06 - to the cards dealt if not we just won't
238:09 - do anything and then we'll return cards
238:11 - dealt which could be an empty array if
238:14 - there were no cards on the deck
238:16 - now let's add something to the shuffle
238:19 - function a deck with only one card does
238:22 - not need to be shuffled so let's add the
238:24 - appropriate if statement to the shuffle
238:26 - function
238:28 - so we'll do
238:29 - if the length of self
238:32 - dot cards
238:33 - is
238:35 - greater than one
238:37 - then we will shuffle and then make sure
238:39 - i'll make sure to put the
238:41 - colon there
238:42 - okay
238:45 - since a card is a separate concept than
238:47 - a deck
238:48 - next we'll make a card class
238:51 - so let's create a card class with an
238:54 - init function and in that init function
238:57 - we'll set self.suit to equal hearts
239:03 - so hopefully you already tried this i'm
239:05 - going to do class
239:08 - card
239:10 - and then i will do def
239:13 - net
239:14 - [Music]
239:16 - and then after the suit will lose self
239:17 - dot rank and set it to a
239:21 - so currently anytime a card is created
239:23 - it will be an ace of hearts let's
239:26 - refactor the code so the suit and rank
239:28 - are specified when a card object is
239:31 - constructed so the init method can take
239:34 - additional parameters besides self that
239:36 - are passed into it as objects is
239:39 - constructed so we'll update it to take
239:41 - suit and rank
239:42 - [Music]
239:44 - now we'll create a special method
239:47 - that's underscore underscore str
239:50 - underscore underscore
239:53 - when a class has this specific method
239:56 - it's called when print is invoked on an
239:59 - object from the class
240:01 - so we want to make it so when we print
240:04 - an object from the card class it will
240:07 - print something like 10 of hearts or
240:10 - three of clubs or something like that
240:14 - so we don't do print here we do return
240:16 - it's going to return this to the print
240:18 - statement it's going to turn self dot
240:20 - rank
240:22 - and then we have to get
240:23 - the rank
240:25 - [Music]
240:28 - and we do plus
240:30 - and then of or to put a string there
240:33 - plus
240:35 - self dot suit
240:38 - so now it's going to return the rank
240:40 - which is like 2 or a of and then the
240:44 - suit which is one of these
240:46 - so let's just try it out real quick and
240:48 - we go to the bottom we don't need any of
240:49 - these to test because we're testing
240:51 - something completely different now let's
240:53 - do card one
240:55 - equals
240:56 - [Music]
240:57 - card i'm going to create a card and i
240:59 - have to pass in remember i have to first
241:01 - pass in the suit so how about hearts and
241:04 - then i have to pass in the rank but we
241:07 - want to make it look like these ranks so
241:09 - i'm just going to
241:10 - copy one of these here
241:15 - and then
241:16 - after we create the card i can just
241:18 - print
241:20 - card one
241:22 - let me clear this and then i'll just run
241:24 - that j of hearts
241:26 - oh see i got the j of hearts and feel
241:29 - free to add a few more cards like this
241:31 - and test out a few more if you want
241:33 - okay now we're going to refactor this
241:35 - slightly you remember way toward the
241:37 - beginning of this course we talked about
241:39 - f strings so f strings allow us to put
241:43 - variables right within a string do you
241:45 - remember how to do that let's see if you
241:47 - can update this to use enough string
241:49 - so first we're going to create a new
241:51 - string but we're going to start with the
241:52 - letter f
241:54 - and then
241:55 - inside this string we put curly braces
241:59 - around
242:00 - the
242:01 - python code and we don't need these
242:03 - other strings here so
242:06 - now we put another curly brace
242:11 - and then an
242:12 - ending string here
242:15 - okay it's still showing these um red
242:18 - squiggly lines because if i have a
242:20 - double quote around the strings and
242:22 - anytime other quotes are in the middle i
242:23 - have to put a different type of quote so
242:24 - we're going to use
242:26 - single quotes okay so now we can make
242:29 - this a whole a string but we use the
242:31 - brackets to put the variables right
242:34 - within the string so now we've updated
242:37 - that to use an f string
242:39 - so currently in the deck class the last
242:42 - line of this init method
242:47 - appends a list as an item to the cards
242:50 - list
242:52 - instead of appending
242:53 - suit
242:54 - comma rank
242:56 - we'll create and append an instance of
242:59 - the card class
243:01 - then afterwards when a deck is created
243:02 - it's filled with cards
243:04 - so it's just like this we're just going
243:06 - to delete that i'll put card
243:09 - and then i'll pass in a suit and they
243:11 - rank so now we're passing in
243:14 - card instances
243:16 - so we're done with the deck and card
243:18 - classes and we created them in such a
243:21 - way that they could basically be used
243:23 - for any card game
243:25 - now let's make a hand class
243:28 - this will represent a hand in the game
243:30 - of blackjack so create a hand class and
243:32 - add an inet method and initialize a
243:35 - variable called self.cards that is set
243:38 - to an empty list so let's go down here
243:41 - and we can also get rid of all this test
243:43 - code here
243:44 - so the new class is called hand
243:49 - and we'll also make the hand keep track
243:50 - of the value of the hands a self.value
243:53 - will start it at zero
243:56 - in this blackjack game there will be a
243:59 - human controlled player and a program
244:01 - controlled dealer so let's add a dealer
244:04 - parameter in the init constructor method
244:06 - of the hand class
244:08 - and then when the hand classes create a
244:09 - dealer should be set to true or false to
244:12 - keep track of what type of hand it is
244:14 - so i'll pass in the parameter dealer and
244:18 - then we just have to create a variable
244:20 - and call dealer and set it to dealer so
244:22 - self dot dealer
244:25 - equals dealer
244:26 - [Music]
244:27 - if you remember from before function
244:29 - parameters can have default values so we
244:31 - want to make it so the default value of
244:33 - dealer is false
244:35 - so then if
244:37 - we create a hand and we don't set the
244:39 - dealer value it will automatically be
244:41 - false
244:42 - and i'm just going to take out these
244:43 - spaces here to make it smaller here
244:46 - so now a hand can be created
244:49 - let's give it some functionality we'll
244:51 - add an add card method and the method
244:53 - should take a card list as a parameter
244:59 - and then we need to add that card list
245:02 - to the cards
245:04 - so we can use the extend function the
245:07 - extend method to append each item in
245:09 - card list onto the cards list so it's
245:12 - just going to look like this self dot
245:14 - cards dot append no extend i mean dot
245:18 - extend
245:20 - and then we pass in
245:22 - card list
245:23 - now let's just add some code to test out
245:26 - what we have so far so let's create a
245:28 - deck and then we will shuffle the deck
245:32 - deck.shuffle
245:34 - [Music]
245:37 - now we'll create a hand
245:40 - now we can add cards to the hand so hand
245:43 - dot
245:44 - add
245:46 - card
245:48 - and we will deck dot deal we'll deal two
245:52 - cards into the hand
245:54 - and then we'll just print
245:57 - hand cards
246:02 - okay so this is what how it printed out
246:04 - i was expecting this to look a little
246:06 - different
246:07 - because of this function it print it
246:10 - should print like that
246:12 - but i think the reason is
246:14 - because
246:15 - this is a list so it's printing a list
246:17 - not an individual card so let's change
246:20 - this to print an individual card i'll
246:22 - print the first card so put zero in
246:24 - there i'll try it again nine of diamonds
246:27 - and then we can also print the next card
246:31 - three of hearts
246:33 - and then we can also print both cards if
246:35 - we just copy that and do
246:38 - hand that cards
246:39 - zero
246:40 - handout cards
246:42 - one
246:44 - okay ace of hearts and nine of spades so
246:46 - those are the two cards that were dealt
246:47 - to the hand
246:48 - now we'll go back to the hand class and
246:51 - we'll add the ability to calculate the
246:53 - value of a hand so let's add a method
246:56 - called calculate value
246:58 - and inside the method we'll set
247:00 - self.value to zero
247:05 - now we'll take this one step at a time
247:07 - first let's let's make a for loop that's
247:09 - going to go through every single card
247:12 - and inside the for loop we'll just set
247:15 - the value
247:16 - of the card to a variable called card
247:19 - underscore value so i'll do four card
247:24 - and self.cards
247:28 - okay so we're not doing anything with
247:30 - that yet but we're going to in a second
247:32 - here
247:32 - now we want to make sure that this is an
247:35 - integer
247:36 - so let's convert that to an integer if
247:38 - you remember you just use int
247:40 - [Music]
247:43 - and then put it in print int and then
247:45 - inside the parentheses we put this value
247:48 - not just getting the card value for each
247:50 - card is not enough something must be
247:52 - done with the variable so let's add that
247:56 - value
247:57 - to
247:58 - self.value
248:01 - so we'll do self
248:03 - dot value
248:05 - and then if you remember from before we
248:06 - can use the plus equals to
248:09 - add that to the current value those will
248:11 - do a card
248:13 - value
248:15 - so as you may know in blackjack and ace
248:17 - can have the value of either 11 or 1
248:20 - depending on what is better for the
248:22 - player so there's a few ways to
248:24 - implement that in code so we're going to
248:26 - do one way that's relatively simple
248:29 - first we'll check if the hand has an ace
248:32 - so let's first create a variable that
248:33 - will store whether the
248:36 - hand has an a so just be called hand has
248:38 - underscore ace we'll set to false and
248:41 - we'll put it right under here
248:42 - so we'll do
248:44 - has ace and we'll set to false and since
248:48 - we're only going to be using has ace
248:50 - within
248:51 - this
248:52 - method we don't need to use self that
248:54 - has ace because we're only using it here
248:58 - and now when we're going through the the
249:00 - list of cards let's check if the the
249:03 - rank of a card is an ace and then set
249:05 - has aced equals true
249:07 - so i'll do it
249:09 - if
249:11 - card dot rank
249:14 - the rank is going to be equal double
249:16 - equal sign if it equals ace
249:20 - after this entire for loop
249:23 - we're going to check if the card has an
249:25 - ace
249:26 - and if the value is over 21
249:30 - if so then we'll just subtract 10 from
249:32 - the value
249:33 - because that'll be the same as setting
249:36 - the ace to equal one instead of 11.
249:39 - so we'll just do if has
249:41 - ace
249:44 - and
249:46 - self.value
249:50 - is greater than 21
249:54 - to self.value
249:56 - minus equals
249:59 - 10.
250:00 - okay and look at this this is something
250:02 - i don't think i've discussed yet
250:04 - you could say if has
250:07 - equals true and self.value is greater
250:10 - than 21.
250:11 - but you can also it's like a shorthand
250:14 - you don't have to say if has ace equals
250:16 - true
250:17 - if has a because has ace is just going
250:19 - to equal true or false you can just say
250:21 - if has ace so that's just the same as
250:23 - saying if true or if false
250:26 - and so we're seeing if both of these
250:29 - evaluate the true then we will subtract
250:32 - 10 from the value okay now we'll just
250:34 - add another method to get the value of a
250:37 - hand called getvalue and the function
250:40 - will just return self.value
250:42 - so we're going to make sure that we're
250:44 - not we're indented correctly and do def
250:47 - get
250:49 - value
250:52 - return
250:53 - self
250:54 - dot value
250:57 - and then i have to make sure i put the
250:58 - parentheses here
251:01 - and then i have to remember to put self
251:03 - since this is a self.value we could call
251:06 - down here like we could call
251:08 - hand
251:09 - value to get the value but it's
251:12 - generally better to make a function to
251:14 - return the value so i can do get
251:16 - value that way there may be some extra
251:20 - code you want to run in there like
251:22 - depending on different conditions
251:24 - you may want to modify the value before
251:27 - you return it
251:28 - so it's best practice to create a method
251:31 - that will get a value like this for you
251:37 - so currently this value that's returned
251:40 - could be incorrect
251:42 - because
251:44 - if someone's going to get the value the
251:46 - value has to be calculated correctly
251:49 - first and like checking for aces and and
251:51 - other things so let's call
251:54 - let's calculate the value before we
251:56 - return the value so i'm going to do self
251:59 - dot calculate value so
252:02 - this is something that i think is new
252:05 - where to call calculate value from
252:08 - within this we're going to have to call
252:10 - self.calculatevalue
252:12 - and self will refer to the instance that
252:15 - we're working with so we're calling the
252:16 - calculate value on the instance that's
252:20 - that is the the hand instance and we're
252:22 - getting the value and then we're
252:23 - returning the value
252:26 - okay let's create another method called
252:28 - is blackjack and it'll return true if
252:31 - there's a blackjack and false otherwise
252:34 - so it's a blackjack if the value is 21.
252:39 - so i'm gonna do
252:40 - def
252:41 - get or is
252:45 - oh and put self here
252:48 - okay so this is going to evaluate you to
252:50 - either true or false and return true or
252:53 - false depending on whether there's a
252:54 - blackjack
252:55 - now we'll create the final method in the
252:57 - hand class that will display information
252:59 - about the hand so let's create a method
253:01 - called display they'll
253:03 - to start with will just print your hand
253:06 - [Music]
253:08 - okay now let's do a quick refactor
253:10 - instead of saying your hand it should
253:12 - either say dealer's hand or your hand
253:17 - depending on whether
253:20 - self.dealer
253:21 - is
253:22 - true or not
253:23 - so we're going to you to to do this all
253:26 - in one line we're going to use a few
253:29 - things that we learned about earlier
253:32 - including
253:33 - ternary operators
253:35 - f strings and going between double
253:38 - quotes and single quotes and then one
253:41 - other new thing we are going to make
253:44 - this into an f string
253:47 - and then we are going to be using
253:50 - actually
253:51 - single quotes and double quotes within
253:54 - this f string so if you want to use
253:56 - single quotes and double quotes within a
253:59 - string
254:00 - then you can surround it with a triple
254:04 - single quote so i'm going to delete this
254:07 - quote and just do three single quotes
254:09 - and then delete this quote and do three
254:12 - single quotes and so
254:14 - we got the
254:16 - double quote
254:17 - single quote and now this is a triple
254:20 - quote so now we can use the double quote
254:22 - and single quotes within this string
254:25 - so i'm going to um i'm just going to
254:28 - delete your right here and we are going
254:31 - to
254:32 - put a ternary operator to see if it's
254:35 - going to say dealers or yours in the
254:37 - dealer's hand or your hand so
254:40 - to do some code i'm going to put these
254:42 - curly braces here
254:44 - and then to do this ternary operator
254:46 - we're going to put dealer
254:49 - and now here so here's the double quote
254:51 - and here's the single quote so dealers
254:54 - it will
254:55 - return dealers
254:56 - if
254:58 - self.dealer
255:01 - so basically if self.dealer equals true
255:04 - so return dealers if self.dealer
255:08 - else will return
255:10 - your
255:13 - okay that's the line so it's going to be
255:15 - the dealer's hand or your hand and next
255:18 - we will add a for loop that will print
255:21 - out each of the cards
255:24 - so
255:25 - for card and self.cards
255:29 - print
255:31 - card
255:32 - and then finally if the player is not
255:34 - the dealer it should print value
255:37 - and then a colon and then print the
255:39 - value of the cards so to do this we can
255:42 - actually use the the not operator so
255:44 - if not
255:46 - self.dealer
255:47 - [Music]
255:51 - then we will print
255:54 - and we'll print value
255:56 - value
255:59 - and then i can just put a comma to print
256:01 - two different items so the string and
256:02 - it'll print self dot get
256:05 - value
256:07 - and it's gonna when you put a comma and
256:09 - two different things it's gonna put a
256:10 - space in between
256:12 - and then finally we'll just add an empty
256:14 - a print statement that will print a
256:16 - blank line
256:18 - okay let's test this out by
256:21 - instead of printing this we are going to
256:24 - print
256:25 - hand
256:26 - dot display
256:28 - to see if this all works how we thought
256:31 - it was going to work
256:33 - so your hand k of spades two of spades
256:36 - value is 12. so it's actually
256:38 - calculating that correctly because
256:39 - that's 10 plus 2 is 12 and then it's
256:42 - going to print none which indicates that
256:44 - we did something wrong which is that we
256:46 - did not need to print this because hand
256:49 - display display already prints so now
256:52 - just call hand.display
256:54 - okay so now it doesn't put none or
256:57 - doesn't yeah it doesn't put none at the
256:58 - end so that looks right
257:01 - okay when you're playing blackjack you
257:03 - don't get to see
257:04 - everyone else's cards
257:06 - so
257:07 - we're going to update this so when the
257:09 - dealer's cards are printed during the
257:11 - game
257:12 - only the second one should display
257:15 - the first card should display as hidden
257:19 - so in this for loop
257:22 - when we're displaying the cards
257:25 - we're going to need to get access to the
257:27 - card index since that will determine
257:30 - which to display
257:32 - since we're only going to display the
257:33 - second card
257:34 - so let's start by updating this for loop
257:37 - so we can get access to both the card
257:40 - and the card index
257:42 - we briefly touched on this earlier in
257:44 - the course we're going to be using the
257:46 - enumerate function
257:47 - so
257:48 - when it's for card in
257:50 - and now i'm going to type in enumerate
257:53 - and i'm going to pass in self.cards
257:56 - and this is going to return the index
257:59 - and the card for each card so i'm going
258:01 - to type it index
258:03 - comma
258:04 - and so
258:07 - in we're getting the index and the card
258:10 - for all the items in self.cards
258:13 - and so now we just have to update what's
258:16 - in the for loop
258:17 - to print
258:19 - hidden
258:20 - if it's the first card and it's a dealer
258:23 - so we'll do
258:25 - if index
258:27 - equals zero and self.dealer
258:33 - then
258:34 - we will print
258:38 - hidden
258:41 - and then we can use an else
258:43 - any other time
258:45 - and let's make sure this lines up
258:46 - correctly any other time we will print
258:48 - the card
258:49 - so
258:51 - what we did wrong here is this should be
258:52 - double equal sign i did almost did the
258:56 - the main mistake you always have to
258:57 - watch out never use a single equal sign
259:00 - when you're checking equality
259:03 - because that's the single equal sign is
259:05 - the assignment operator so if index
259:07 - equals zero and self and we it is the
259:09 - dealer then we'll print hidden
259:11 - so in our version of the game at the end
259:13 - of the game
259:14 - that all the dealer's cards will be
259:17 - shown so you can see what the dealer had
259:20 - so to do that we're going to create a
259:23 - new parameter in this
259:25 - display method and it's going to be
259:27 - called show all dealer cards with
259:30 - underscores for spaces and we're going
259:32 - to set the default value to false
259:35 - show
259:36 - all
259:37 - dealer
259:39 - cards
259:40 - and when the default value is going to
259:42 - be false
259:43 - now we'll add it to this if statement
259:48 - so
259:49 - we'll add another
259:51 - and
259:52 - not
259:53 - show
259:55 - all
259:56 - dealer cards
259:58 - so
260:00 - it's going to be hidden if we're not
260:02 - showing all the dealer cards
260:04 - but if we are showing all the dealer
260:06 - cards then this whole if statement will
260:08 - be false so we'll just print the card
260:11 - and there's going to be one other
260:13 - scenario where we're not going to print
260:17 - hidden if there's a blackjack then the
260:19 - game is over the person with the
260:21 - blackjack is just going to win and then
260:23 - we'll just print all the cards so we're
260:26 - going to add that to this long if
260:28 - statement here so we'll say
260:30 - and not is
260:33 - black jack
260:35 - and it should be
260:37 - self dot is blackjack to be able to call
260:41 - this method here
260:43 - and since this is such a long line is
260:45 - always going to go to this next line we
260:47 - can do this special thing
260:50 - we can add a slash here
260:53 - and then just go to the next line
260:56 - so
260:57 - this slash or it's a backslash i mean
260:59 - this backslash will indicate that the
261:01 - line continues on the following line
261:05 - okay we're done creating the hand class
261:07 - so we'll delete
261:09 - everything that we were using for
261:10 - testing before
261:12 - okay it's time to code the final and
261:15 - longest class that runs the game so what
261:18 - i want you to do is create a class
261:20 - called game and inside the class create
261:22 - a method called play and inside the
261:25 - method create a variable called
261:27 - gamenumber with the underscore for the
261:30 - space
261:31 - and set that to zero so class game
261:36 - and then we'll create another variable
261:38 - games to play and set that to zero
261:41 - now we're going to set games to play
261:44 - to be whatever the user inputs
261:47 - after they're asked how many games do
261:49 - you want to play
261:51 - so you may remember how to do
261:53 - input from before
261:55 - so we just do input
261:58 - now we want to make sure the games to
262:00 - play is an end so we just need to
262:02 - convert this to an end
262:06 - [Music]
262:08 - okay now let's test things so far so at
262:11 - the end i will put g equals game i'm
262:13 - going to create a new game
262:15 - and then g dot play
262:20 - okay let's test this
262:25 - how many games you want to play
262:28 - five
262:29 - okay well it's not going to play the
262:30 - games yet we still have to create that
262:32 - so there is a potential for an error
262:35 - here if i do this again and i just put
262:37 - how many games i put you or some letter
262:39 - we're going to get an error
262:41 - so basically anytime someone puts
262:43 - something that's not a number is going
262:45 - to be an error
262:46 - so let's create a try accept block to
262:50 - handle the exception
262:52 - and
262:53 - if they put something that's not a
262:55 - number we'll
262:56 - print you must enter a number so let me
262:59 - arrange this and we've already learned a
263:01 - little bit about try except blocks i'm
263:03 - going to put try
263:05 - and it's going to try this
263:09 - and then if that doesn't work if there's
263:11 - an exception
263:13 - [Music]
263:14 - it will print
263:16 - [Music]
263:19 - you must enter a number
263:22 - so currently the user gets only one
263:25 - chance to input a correct value let's
263:27 - make the program keep asking the user
263:29 - for a value until the user enters a
263:31 - number this can be done with a while
263:33 - loop the while loop just keeps looping
263:35 - while something is true so keep looping
263:38 - until the user enters a number by
263:40 - putting the entire tri-catch block into
263:43 - a while loop that keeps looping while
263:45 - the game's a play is less than or equal
263:47 - to zero
263:49 - [Music]
263:51 - oh and i have to make sure i spell
263:54 - while correctly
263:56 - okay now let's create the main game loop
263:59 - this is a new loop that will loop one
264:01 - time per game played it should loop
264:04 - while game number is less than games to
264:07 - play and the first line of loop should
264:09 - increment the game number by one
264:14 - inside the loop we'll create a deck
264:16 - object in a deck variable and shuffle
264:19 - the deck
264:21 - now we'll create a variable called
264:23 - playerhand and set it to a hand object
264:27 - and then we'll create a variable called
264:28 - dealerhand and set it to a hand object
264:31 - but this time we'll make sure to specify
264:33 - that dealer equals true
264:36 - okay this next part will be a little
264:38 - more complicated we'll create a for loop
264:41 - that loops two times and each iteration
264:44 - should add a card to the player's hand
264:46 - that is dealt from the deck and add a
264:48 - card to the dealer's hand that is also
264:50 - dealt from the deck
264:52 - [Music]
264:55 - okay we just dealt two cards each player
264:58 - now information is going to be printed
265:00 - to the console for each game so let's
265:02 - start by printing an empty line
265:05 - now we'll print an asterisk 30 times to
265:08 - make a divider
265:10 - there's a trick to printing something a
265:12 - lot of times so i can put an asterisk
265:16 - in in quotation marks and then just do
265:18 - times 30.
265:21 - so it's going to print it 30 times now
265:23 - we'll print the current game number out
265:25 - of the total number of games
265:27 - so it'll be something like game 4 of 10
265:33 - and we'll use an f string
265:36 - and then we'll just print 30 more
265:38 - asterisks
265:42 - now we'll display the player's hand
265:46 - and then the dealer's hand
265:49 - at this point in the game someone could
265:50 - already have won if they got a blackjack
265:53 - the code should check if there's a
265:54 - winner let's put the code to check if
265:56 - there's a winner in a separate method of
265:58 - the game class so create a method called
266:00 - check winner for now the method should
266:03 - just return false
266:06 - and just make sure everything's indented
266:08 - correctly this should be less indented
266:10 - than the previous line here
266:12 - the check winner function should take
266:14 - the playerhand and dealer hand as
266:16 - arguments
266:20 - now before this return statement
266:23 - we're going to check if
266:24 - playerhand.getvalue is greater than 21.
266:27 - if so we'll print you busted dealer wins
266:30 - and then return true and remember once
266:32 - the program gets to a return statement
266:34 - none of the following statements in the
266:36 - block are run
266:38 - [Music]
266:44 - now we'll use a few lf statements to
266:46 - check for various other conditions so
266:49 - we'll add an lf statement to see if the
266:51 - dealer got over 21
266:54 - and then we'll print dealer busted you
266:55 - win and then return true
266:59 - [Music]
267:02 - oh and i just copied all this but this
267:03 - should be an l if not if
267:06 - and then we'll add an lf statement to
267:08 - check if both players have a blackjack
267:10 - and then we'll print both players have a
267:11 - blackjack tie
267:13 - and then return true
267:16 - [Music]
267:21 - and then we'll add an elf statement to
267:22 - check if player hand has a blackjack and
267:24 - then we'll print you have blackjack you
267:26 - win
267:27 - and then return true
267:32 - and then we'll check if the dealer hand
267:34 - has a blackjack and then say dealer has
267:36 - blackjack dealer wins
267:38 - and return true
267:41 - [Music]
267:42 - okay we're done with all the hand when
267:44 - conditions but the game can also end if
267:47 - both players choose not to get more
267:49 - cards so we're going to add a new
267:51 - argument to the check winner method with
267:53 - a default value it's going to be game
267:55 - over equals false
267:57 - so we'll add game
268:00 - over
268:02 - equals false
268:03 - if it's true that means both players
268:05 - have chosen not to get more cards now
268:08 - we'll use the new argument
268:10 - the string of if and lf statements
268:12 - should only be run
268:14 - if it's not a game over and we'll make
268:16 - sure the line returned false is not in
268:19 - the if statement
268:21 - so
268:23 - here we'll say
268:24 - if
268:26 - not game
268:28 - over
268:29 - and then i'll just select all these and
268:32 - put them
268:34 - in here
268:35 - so if game over is true we'll check if
268:37 - the player hand's value is more than the
268:40 - deal hands value and if so we'll print
268:42 - you in
268:43 - so we can do this with an else here
268:47 - else
268:50 - if player
268:52 - [Music]
268:55 - and then we'll do an lf for if it's a
268:57 - tie
269:00 - so this is an lf
269:02 - and we'll say if these are
269:04 - equal to each other
269:06 - and we'll print
269:08 - tie
269:11 - and then make sure we have the correct
269:12 - emoji for a tie
269:14 - [Music]
269:16 - and then else the dealer is one
269:18 - so we'll just do
269:20 - else
269:22 - [Music]
269:23 - and then at the exact same level of
269:25 - indentation as the else we just added
269:28 - we'll add return true this will make the
269:30 - method return true if game over equals
269:32 - true
269:34 - now let's go back to the play method
269:35 - inside the while loop
269:37 - and then we'll do an if statement and
269:39 - we'll do if and then we'll call the
269:41 - check winner function with the player
269:42 - hand and the dealer hand so let's go
269:45 - back up here
269:48 - if self dot check
269:53 - winner
269:54 - and then we'll enter the player hand and
269:56 - the dealer hand
269:58 - [Music]
269:59 - so if this is true that means we should
270:01 - go on to the next game
270:03 - to do that we do continue
270:07 - so continue is going to just go to the
270:09 - next iteration of the loop and the loop
270:11 - we're on is this loop so when we go to
270:14 - the next iteration we start a new game
270:17 - at this point in the game the player
270:19 - will be able to choose hit or stand
270:22 - so inside the while loop but not inside
270:24 - the if statement we just added we'll
270:26 - create a variable called choice and set
270:29 - it to be an empty string
270:32 - the player should be able to keep
270:34 - choosing until the value of their hand
270:35 - is over 21. so right under the choice
270:38 - variable we'll add a while loop that
270:41 - loops while player hand's value is less
270:43 - than 21 and inside the loop we'll add a
270:46 - line to get the choice
270:48 - that's either going to be hit or stand
270:53 - [Music]
270:57 - and then we'll just add this to convert
271:00 - whatever the answer is whatever the user
271:02 - put in we are going to convert it to
271:03 - lowercase
271:05 - the while loop we just added should also
271:07 - stop if the user's choice is stand or or
271:10 - s so we'll update the line that starts
271:12 - the while loop to also stop if the
271:15 - choice isn't s or stand so just do and
271:20 - choice
271:21 - not in
271:22 - and this is there's a few ways to do it
271:24 - but this is kind of a new way that i'm
271:27 - just showing you here
271:28 - [Music]
271:31 - so we are checking if choice is not in
271:35 - this list and inside the list we have
271:37 - two elements s or stand so if choice is
271:40 - not in that if the choice is not s or
271:43 - stand then we'll continue the loop
271:45 - and then after the input we'll print an
271:47 - empty line
271:50 - also we want the program to keep asking
271:52 - the user for a choice until the user
271:54 - enters a valid choice
271:56 - the valid choices are hs hit and stand
272:00 - so right after the last print statement
272:02 - at the same indentation we'll add a
272:04 - while loop that will keep looping until
272:06 - the user enters a valid choice
272:09 - and inside that while loop we'll ask for
272:11 - input again
272:13 - but we'll specify it can be h or s as
272:15 - well
272:18 - [Music]
272:25 - so this is going to look very similar to
272:26 - this line but it's going to kind of
272:28 - clarify things just a little bit
272:30 - and then we'll print another empty line
272:35 - the last while loop we checked if choice
272:38 - was not in a list
272:39 - outside of the recently added a while
272:41 - loop but inside the loop we just added
272:43 - before that one we'll add an if
272:45 - statement to check if choice is in the
272:47 - list hit or h and if so we'll add a card
272:50 - to the player's hand that is dealt from
272:52 - the deck
272:56 - and then right below that will display
272:58 - the player's hand
273:01 - outside all the while loops about the
273:03 - player making a choice we'll check for a
273:05 - winner we'll use the same if statement
273:07 - and continue statement that we use last
273:09 - time we checked for winner so i'll just
273:11 - copy this
273:14 - and then
273:15 - we have to make sure it's lined up
273:17 - correctly
273:18 - okay so this is outside of this while
273:20 - loop so after this all is all done we
273:23 - check for a winner let's just add an
273:25 - empty line there to
273:26 - make it more clear that the while loop
273:28 - is over
273:29 - now we'll store the value of the
273:30 - player's hand in a variable named player
273:33 - hand value with underscores for spaces
273:38 - [Music]
273:39 - and we'll do the same thing with the
273:41 - dealer's hand
273:44 - [Music]
273:50 - remember i could use the command d or
273:53 - control d to select two words at once
273:55 - and change them both at the same time
273:58 - okay the dealer should keep drawing
274:00 - cards until dealer hand value is more
274:03 - than 17 so we'll make this happen with a
274:06 - while loop
274:08 - and inside the loop we'll make sure the
274:09 - dealer is dealt a card from the deck and
274:11 - that dealer hand value is updated
274:15 - so you can try that yourself but i'm
274:17 - going to show you right now while
274:19 - dealer
274:20 - hand value
274:22 - is less than 17.
274:26 - then we will do dealer
274:28 - hand dot
274:30 - add card
274:34 - okay and after this while loop will
274:37 - display the dealer's hand and when we
274:39 - call the display method we'll make sure
274:41 - to set show all dealer cards to true
274:47 - [Music]
274:48 - and since it's the end of the game
274:50 - that's why we're just showing all the
274:51 - cards
274:53 - now we'll check for a winner just like
274:54 - before
274:58 - then we'll print final results
275:03 - then we'll print your hand colon and
275:05 - then the player hand value
275:08 - [Music]
275:09 - and then the dealer's hand
275:14 - now we'll call the check winner function
275:17 - one final time
275:18 - but this time it should not be an if
275:20 - statement and we'll pass in the hands
275:22 - like before but this time we'll add a
275:24 - third argument of true to indicate that
275:27 - the game is over
275:32 - and at this point in the code the game
275:34 - is over
275:35 - so outside the outer while loop and in
275:38 - the play method we'll add the final line
275:40 - of saying
275:42 - thanks for playing
275:47 - so it's going to be outside that while
275:49 - loop and we'll put print
275:54 - and just to demonstrate it i use an
275:57 - escape character to add a new line so
276:00 - this slash in is going to add a new line
276:03 - and then do thanks for playing and when
276:05 - i line this up for with the while loop i
276:08 - realize that this entire function should
276:10 - not be lined up with the while loop
276:12 - sometimes it gets tricky with um
276:16 - figuring out the exact right indentation
276:18 - so if i
276:19 - kind of go up straight up here
276:22 - i should say see that this should be
276:23 - lined up with this play function
276:26 - so i'm going to come back down to this
276:29 - function
276:30 - i'm going to
276:31 - copy this all
276:33 - and i'm just going to do shift tab
276:36 - to indent it all one less
276:40 - this happens sometimes when running
276:42 - python code sometimes the indentation
276:44 - can get all mixed up but that should be
276:47 - correct now and i think the red squiggly
276:50 - lines here on the return true are not a
276:52 - mistake in the code but a mistake in the
276:55 - error checking because it comes after
276:58 - that emoji and it doesn't know how to
276:59 - handle the emoji but it's perfectly fine
277:02 - for code to have emojis okay let's run
277:05 - the program and try it out so i'll press
277:09 - play how many games i want to play i'll
277:10 - do three
277:11 - so game of one of three so i can see i
277:14 - have 17 i don't know what the dealer has
277:16 - but i'm going to s for stand
277:20 - okay it's always good to test so it says
277:23 - deal is missing one required positional
277:26 - argument so let's go up to
277:29 - it says line 139 so this can kind of
277:31 - help us know where to go so let's go up
277:34 - to 139
277:38 - and yeah i want to deal a single card so
277:42 - i'm going to deal one card here
277:44 - and
277:45 - were there any other times i did use
277:47 - deal
277:50 - i want to
277:51 - deal one card here
277:55 - and
277:56 - yeah i got the deal one up here so i
277:58 - just think i just forgot the deal one in
278:00 - those places
278:02 - so uh thanks to these error messages
278:05 - whenever you have a problem make sure to
278:07 - read the error messages and it can often
278:10 - give you a very good idea of what you
278:12 - need to do wrong because even says deal
278:15 - is missing one required positional
278:16 - argument the number so that can really
278:19 - help figure out what's wrong with your
278:20 - code so let's try that again we'll do
278:23 - three games
278:25 - and then this time i will hit
278:28 - and i'm going to stand
278:30 - okay so now we have another error
278:33 - so it says 173
278:36 - and oh this i can already see this is
278:38 - spelled wrong so let's go to
278:41 - 173
278:45 - and
278:47 - make sure i spell that correctly
278:51 - and make sure i spell that correctly
278:53 - okay let's try again
278:56 - how many games you want to play three
278:58 - i'm going to hit
279:01 - and hit
279:03 - okay so the first game
279:06 - you busted dealer wins and now we're on
279:09 - game number two i'll hit
279:12 - and this time i will stand
279:15 - okay dealer busted you win now we're on
279:18 - game three of three
279:20 - and i will hit
279:22 - and i will stand
279:24 - and final results your hand 20 dealer's
279:27 - hand 19
279:28 - you win
279:29 - thanks for playing
279:32 - we just completed this whole game
279:36 - okay we've reached the end of the course
279:38 - so you've learned the basics of python
279:41 - and if you've been coding along you've
279:43 - written two python programs good luck on
279:45 - your programming journey thanks for
279:48 - watching and remember use your code for
279:51 - good bye bye bye
279:54 - bye bye
279:58 - okay