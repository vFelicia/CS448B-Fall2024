00:00 - Hey, what's up everybody?
00:02 - So for those of you who do not know me, my
name is Caleb, from Caleb the video maker,
00:07 - too. And kill crate comm so I did a a design
series A while ago is my first video series
00:14 - here on YouTube, about 25 videos long. And
then I went on to make a 67 part video series
00:22 - over MySQL. And I did a couple other ones,
I have over 100 databasing videos, and I wanted
00:27 - to, I wanted to try to tackle this, again,
to try to make you better explain things better,
00:33 - and also bring you to a new level of skill.
So what what level of difficulty is this course
00:38 - going to be? It's going to be for beginners.
So why do you want to use a series you most
00:44 - platforms, programs, applications rely on
a back end database. That's how we store information
00:53 - in this world, everything we do is powered
by a database. So it's important that you
00:57 - know how to properly implement database concepts
designs, to know how to properly structure
01:05 - data. So that way, you get the best optimized
database that will set you apart from the
01:10 - rest of the IT team or the rest of your classmates,
it will give you the skills needed to get
01:17 - that job or whatever you want to do with it.
Also, if you're just a business person, or
01:21 - you have your own project, and you need to
learn how to build a website, or you need
01:26 - a database to store all the information you're
using, this series will be helpful. Basically,
01:32 - database design is the fundamentals of databases,
you should know how to properly structure
01:38 - data, this series is not going to be very
specific on a specimen a certain database
01:46 - management system. So this isn't like MySQL
database design. This isn't like Oracle, this
01:51 - isn't SQL Server, this isn't whatever else
you use, this is going to be general database
01:57 - design. So then you can take these skills
and apply them to any of the databases that
02:02 - you are working on that are relational, which
I mean through this series, you will you'll
02:06 - really understand what that means you don't
get that. So the first part is going to be
02:10 - a lot of the concepts on the chalkboard, and
I'm not going to like write tons of scripts
02:15 - on here. So don't worry, it's not going to
be confusing to where you can't see the code
02:19 - on a screen. Because in reality, a lot of
database design is not done on a computer
02:25 - first, first, you have to think about it.
And then you kind of just draw your plans,
02:30 - whether it be in your head or on a document.
Or if you use a database design program. I
02:35 - use a chalkboard because I can easily draw
concepts, thoughts, way the way data is connected,
02:44 - and all that. So a lot of these databasing
videos, they're going to be on this chalkboard
02:51 - because that's all you really need. We're
not we're not programming a database, we're
02:56 - designing a database. And designing is art,
you draw it, you design it. So a lot of the
03:04 - concepts from this video will be useful no
matter what you will be using for your database.
03:15 - So database design. Before we talk about database
design, let's first talk about a database
03:24 - because we can't design a database if we don't
know what a database is, that doesn't even
03:28 - make sense. So what is a database? And that's
a really good question. I'm glad you asked.
03:34 - Well, I can actually tell you what a database
is. And that's what this video is about. So
03:39 - a database is something that stores data.
Alright, another vague term data. And I want
03:48 - you to guys, I want all of you to think about
data, very broadly, don't think too specific.
03:54 - Think of data as anything we can store. In
a database or anything we can write down.
04:02 - Anything that has a value can be anything.
data can be the list of every single customer
04:09 - of your store since 1995. Or it can be a list
of every single transaction in a online shopping
04:18 - center. Or it can be a list of every user
and their username. Or it can be a list of
04:24 - every single weather event. Since 1927 can
be pretty much anything. It doesn't
04:30 - have to do with
04:31 - specific people data is so broad. So database
is obviously broad too, because the database
04:38 - stores data. So yeah, just think of it like
this. Here we have a database of bases where
04:45 - we store
04:46 - data. Pretty simple.
04:48 - Alright, so now, that's pretty vague, and
I'm not sure if that was very helpful. So
04:54 - now let's break it down to where we see it
from a technical standpoint. Everything in
05:01 - this world, not everything, but almost everything
is ran from a back end database. It's what
05:08 - stores all of our information. So for example,
I like to use websites, very examples, because
05:15 - they're very clear. And they're very easy
to understand the concept of this. When you
05:19 - go to a website, and you sign up, you, you
give them a username, you give them a password,
05:25 - and you give them an email, all of that, when
you sign in the next time, it allows you to
05:31 - sign in, well, how did that website remember
what your username, email and password was?
05:36 - That's because all of this information that
you put in, when you registered, all of these
05:42 - values are given to a database. So here you
can say is our database. Sorry for my craptastic
05:54 - handwriting, but don't don't even worry about
it. This is what's said to be the front end.
05:59 - This is said to be the back end. That's because
we don't necessarily see what's going on back
06:04 - here, we can put in our email, our username
and our password, and they can get stored
06:09 - in this database. That way, when we come back
again, and we log in, we give them a username
06:14 - and a password, it takes that value, it checks
it with the database to allow you to get into
06:21 - the account. That is a perfect example of
a database. So the database can store that
06:28 - information. But it's not limited to only
registration, you can use this to store all
06:32 - of your records of sales in a store. And also
for that just goes on. Don't think of it as
06:40 - a limited thing, because there's so many things
you can do with the database. So many things.
06:46 - Next question you may be asking is how does
it differ from, like a spreadsheet, for example,
06:54 - so a spreadsheet,
06:55 - basically, if you don't really know much about
spreadsheets, it's basically where you have
06:58 - columns. And then we have rows, and we can
store information about like, we can enter
07:05 - the values for each column.
07:08 - spreadsheets are
07:09 - good, if that's what you need for your very
small company sees me. But if you want to
07:14 - get to any complexity, where you can, like,
imagine if we wanted to select, let's say
07:19 - this was a spreadsheet for all of my employees,
I own a huge business with 100 employees.
07:26 - And I want to select every single employee
who has missed less than three days and have
07:33 - been a an employee for at least three years,
and I want to give them a $100 bonus, well,
07:41 - that's something if I had a spreadsheet, I'd
have to manually go through that check every
07:45 - single value, that's not gonna work, because
time is money in business. But anyways, with
07:52 - a database, we can run queries to get those
kind of values to figure out which employees
07:59 - have been a member, a employee for three years
and volumous, three days or less. So that's
08:04 - how it differs from a spreadsheet, basically,
what you can do with it, if you have a spreadsheet
08:09 - with 10 employees, or like I'm sorry, with
10 values, and that's like you can figure
08:14 - out all of your information in a couple of
seconds, well, then you might not need a database,
08:19 - that's up to you. The other thing is with
with spreadsheets, it's it's a it's either
08:26 - like all data or no data. Let's say I just
this stored every single detail about every
08:32 - single employee that I had, and all I wanted
was their name and their address. Well, we
08:38 - can't really do that easily with the spreadsheet.
Unless we take all those columns and like
08:43 - copy and paste and all this extra garbage
or find some algorithm to do things fancy
08:48 - Lee, if you know what you're doing, you can
probably do it with a database, we can selectively
08:53 - choose which color. So we can say only these
two columns Do we want returned, and we can
08:58 - ignore the rest. On top of that, we can allow
different users to access different information.
09:06 - Back to the website example. We have Users
page, and then we had a database. When here
09:13 - you put your username, email and password
that's stored on a database. But that's not
09:19 - necessarily the only thing that's stored on
a database. A user might only get to access
09:24 - that but a database administrator might get
to access when they registered, the transactions
09:30 - they've made on your shopping website or what
they've watched what what they viewed, the
09:36 - comments they've made,
09:38 - how often
09:39 - they visit the web page, it's pretty much
limitless to what you want to do with the
09:43 - database. So we can see that two different
users, this person only gets to view some
09:50 - things at the database. This person can only
can view pretty much anything with a spreadsheet.
09:55 - It's kind of all or nothing. Do you have access
to the spreadsheet? Yes, I do. Well, here
09:59 - it is. If you don't have access, well, then
too bad, you don't get any of it. So that
10:04 - that's awesome. That's a security feature
as well, because you don't want this person
10:08 - to get all of the hidden information that's
stored within this database. So hopefully
10:14 - that makes things pretty darn clear. The next
video, I'll kind of be talking about how data
10:20 - is stored in a database. Because I didn't
I was going to get into that in this video,
10:24 - but I kind of ran out of time. But for the
sake of just your understanding, if you decide
10:30 - not to watch the second video, which you will
watch the second video for I relations, that's
10:38 - a term where we get the term relational database.
So this series is for what's known as a relational
10:50 - database.
10:54 - That is a specific kind of database. And that's
going to be most of the relation that's going
10:58 - to be most of the databases that you work
with. If you're working with database design.
11:08 - We're going to be talking about the relation,
very basic. Don't freak out, but it is math,
11:15 - we're not going to go super in depth with
math, if you want to know more about the math,
11:18 - I have blogs on my website about that. Caleb
curry.com, forward slash blocks, advertising,
11:24 - not blogs, advertising house advertising,
anyways, basically, a relation is just a connection
11:31 - between data. So let's just think of silly
example, if we have the two sets of numbers,
11:38 - two, four, and then the other set was six,
eight, and then we kind of combined these
11:44 - sets. So we've kind of like crossed here,
and then we cross down here. And where are
11:50 - these cross is our new set. So we have the
combined set of six, two, and then we have
11:56 - the combined set of six, four, and then we
have the combined set of eight, two, and then
12:02 - a combined set of a four. And like you're
probably wondering, like, what
12:07 - the heck does
12:08 - that have to do with database design? Well,
somewhat, we kind of do the same thing with
12:14 - database design relation in relational database
comes from this mathematical concept. But
12:21 - rather than combining sets of numbers, we're
combining attributes of real world things.
12:28 - So let's apply this to the database.
12:32 - First, you need
12:34 - to know two terms. The first one is an entity.
The second one is an attribute. So an entity
12:50 - is anything we store data about attribute
or the things that we store. So if an entity
12:56 - is a person, an attribute would be their name,
their username, their password, their hair
13:02 - color, their address, their phone number,
their relationship status, the person they're
13:06 - in a relationship with the orders that they've
made, or whatever, whatever it is, it's depends
13:11 - on what you need to store for that specific
application. So entity is what we store the
13:18 - data about. attribute is what we store. When
we apply this to this, this connection with
13:25 - the the the relation, we have the attribute
types and the attribute values. So let's say
13:34 - we have this person over here. And we'll name
him Caleb, because it's an awesome name. All
13:43 - right. And then we will also give him a username
Caleb curry with no spaces. And we'll give
13:53 - him a password. Pi 123. And then over here,
we have the set of attributes for a table
14:00 - we have name, username, and password. We can
make this connection of data so the name is
14:14 - Caleb the username Caleb curry passwords,
pi 123.
14:20 - That makes sense,
14:21 - although graphically It looks like a mess.
So we store these in tables, which is exactly
14:26 - what we were doing with the relations. So
we have up here in our columns we have we
14:35 - have the name and then we have the username
and then the password. Don't worry if you
14:46 - can't read my handwriting you get it. We store
this in a table.
14:53 - Right? So these
14:56 - are the things we need to connect with this
person over here. We named Caleb and I accidentally
15:02 - erased them,
15:03 - whatever.
15:04 - We'll just leave it at that. So that's Caleb.
And we want to store this information in this
15:08 - table, which is a graphical way to, to illustrate
how we're storing data in a database. So we
15:16 - take his name, Caleb, we take his username,
Caleb curry, we take his password, pi 123.
15:30 - We kind of get this, this table concept, it
almost looks like a spreadsheet that we talked
15:35 - about in the last video. Although it is slightly
different, and we'll be talking about that
15:40 - as time goes on. This guy is the entity that
we're storing information about. These are
15:50 - the attributes that we need to store about
this person, or any other person. So we enter
15:58 - specific values for each one of these attributes
to make the relation between the attributes,
16:07 - and the entity. Hopefully, that makes somewhat
sense. And if it doesn't, don't freak out
16:13 - this all kind of I mean, this is complex thought.
And you don't necessarily need to understand
16:18 - every single detail to design a database.
So I'm just trying to explain things. And
16:23 - we'll get through. These are the attributes
of this person, this entity, an entity is
16:31 - basically just anything we store data about
it's something can be a person in this case,
16:37 - but it can also be an order, it can be a customer
can be a client, it can be a employee, an
16:45 - employer, whatever it is, it doesn't even
have to be a person. So now, the relation
16:51 - idea, you kind of understand that we're just
making the connection between the attributes,
16:57 - and the entity, the value that the entity
attributes, we're entering that in the database.
17:04 - That's, that's kind of a weak explanation.
But honestly, it doesn't really matter that
17:09 - much for getting into basic database design.
So if you want to learn more about that, just
17:13 - look up relational database design, you'll
figure it out. So now, we have the entity
17:19 - over here. And then we have the attributes.
So in table terms, you probably know, rows
17:35 - and columns, you might not know specifically
what they are. And I'm going to tell you this
17:41 - right here is a rough. You see that might
be run out of space here. I think we're good.
17:50 - Yeah, we're good. So this, all of these values
are a row. So a row is all of the attribute
17:57 - values for a specific entity. So this row
would be easier just to go like this, this
18:05 - row, points to that entity, that person. Pretty
simple. A column are all of the values for
18:15 - a specific attribute type. So the attribute
type is username, we can have another person
18:21 - Billy Joe, and his name, his password can
be within you, and his name can be bill.
18:35 - This
18:36 - is another person in our table. So this is
talking about a different person, we have
18:41 - this person over here. pretty chill, or this
row is talking about this entity. The username
18:55 - is a column where we have all of the attribute
types username, So Caleb curry, Billy Joe,
19:04 - and whatever more if we put more values into
the table. Okay, so it's again, a little messy,
19:12 - so I'm just going to clean it up a bit.
19:19 - Erase.
19:20 - So just to summarize a bit, we have very first
thing we have an entity type. That's that's
19:30 - the word you want to know entity type, which
talks about entities I'll just I'll just tell
19:34 - you what an entity type is in just a sec,
entity type. And then we have the attribute
19:41 - type. So basically, the type means it's a
category. So the person was a specific entity,
19:53 - the case the guys named Caleb, that was an
entity, it was the person then we also had
19:57 - the entity, Joe or Billy or whatever his name
was. Those are two separate people to separate
20:02 - entities, although you could tell that they
were somewhat similar. They're both in the
20:06 - same table, they were both talking about the
username, password, and so forth. So the entity
20:14 - type is user, a specific entity would be Caleb,
or bill, or Jamie, or Jake, or whoever it
20:27 - is. So the entity type is basically the category
of the entities that we're storing. The category
20:34 - is a user and all the all the entities within
it should be a user. So my camera stopped
20:39 - recording by itself for some reason, which
is super annoying. But anyways, our entity
20:44 - type is the category of entities such as user,
every single entity should be a user. Caleb
20:52 - was a user, Billy was a user, we could have
Jimmy john, we could have got Katherine, we
20:58 - could have Caitlin, we could have Cassandra,
we could have, you get the point. The attribute
21:04 - type is basically the categories of attributes.
So we had the username, we had the name, we
21:11 - had the password. These are attribute types,
because we don't actually have a specific
21:18 - value. If like, no one's name, his name. When
we actually give these specific values, they
21:24 - no longer become types, and they become specific
examples. So this guy over here, here's our
21:30 - entity, we can store. So basically, here's
our entity, we can store attributes about
21:38 - this entity, the username can be Caleb curry.
21:43 - The name can be Caleb. And the password can
be
21:46 - pi 123.
21:50 - So these are specific attributes about that
guy. Now all these are all like complex terms,
21:59 - and blah, blah, blah, blah, who really cares?
What really matters is can you put this into
22:06 - a table for people to understand who really
cares if you know the terms, but I mean, I'm
22:12 - sure your professor care. So making that anyways.
22:18 - Table,
22:20 - the columns or the attributes, so we could
have, for example, an ID, a password, a user
22:26 - name, and email, we could keep going address,
phone number, and whatever else.
22:32 - And then a row
22:33 - is where we give a value for every single
one of these attributes, all talking about
22:39 - one entity. So like this guy, this guy right
here? Well, his ID, for example, 72, his username
22:48 - is Caleb curry, his email is cool, guy@hotmail.com
22:52 - blah, blah, blah, blah, blah, all of this
row talks about this guy. So basically, just
23:00 - think attributes are columns. entities are
individual rows. Sweet, then this whole thing
23:07 - right here. This is the table, and that is
the entity type. So the entity type would
23:13 - be user because every single row within this
table should be a user. Oh, another thing
23:19 - I would like to mention real quick, another
name in mathematics
23:23 - for a row
23:25 - is a tupple, or tuple. I think it's terrible.
I don't really know. But that is another term
23:30 - you'll hear. So yeah, tupple is a row. Thank
you. See ya, sorry for like yelling and getting
23:42 - all intense, but
23:44 - fun. Alright.
23:46 - This will be about database management systems.
And because this series is over relational
23:50 - database design, it will be specifically relational
database management systems. And we'll talk
23:56 - about the difference. So first, let's just
talk about in general, what is a database
24:01 - management system. So this is often shortened
to B dB, and S for database management system.
24:12 - And relational database management system
is the same thing except it starts with an
24:15 - R. So the our DBMS, so I'm just gonna write
that because it's easier.
24:20 - Alright, so
24:21 - where we left off in the last video, we learned?
Well, actually, like both of the videos, we
24:26 - learned that a database can be used to store
a ton of information. So we have this database,
24:32 - just think of it like a barrel with a ton
of information just piled in there. So like
24:37 - usernames, and like passwords and junk, and
transactions. And all this stuff is listed
24:48 - in here. And as you saw on the last video,
it looked very similar to a spreadsheet. So
24:54 - what makes it different, we have all this
data. Now what do we do? What do we do? Just
24:58 - look at it? No, don't be knew, obviously we
do cool things with it. Obviously, I don't
25:03 - even know what that was about. So what we
can do is we can run what's known as a query.
25:13 - So a query, just sort of like searching our
data, doing something with it, and giving
25:19 - us cool results. So a database management
system, uses our data in manages it, allowing
25:26 - us to view it in a human friendly way, and
do cool things such as search for values,
25:34 - change the appearance of data, changed the
way data is stored, and so forth. So for example,
25:42 - we have 6 billion users, okay, just for just
for an example. And we want to delete anyone
25:50 - who hasn't been active in a year. Well, without
a database management system, all we have
25:58 - is a bunch of data. And we'd still have to
go manually do all that and delete all that.
26:02 - So the database management system, is what
allows us to easily run a query, alright,
26:08 - select everyone who hasn't been online in
a year. And then we can delete everyone who
26:15 - basically, basically just delete everyone
who hasn't been x active in a year. Basically,
26:21 - a relational database management system is
just a sub category of a database management
26:26 - system, a specific kind that is designed to
work with relational databases. So yeah, not
26:34 - much of a difference there. So just some of
the things that these database management
26:39 - systems can do. The first one is obviously
run fancy queries to give us specific results,
26:46 - such as give us all of the transactions that
were processed before 2011, June 10. That's
26:57 - something fancy we can do with a database
management system. It also allows us to change
27:03 - the way our data is presented. That's something
known as a view mechanism.
27:10 - So basically, if you mechanism allows us to
change the surface appearance of our data.
27:25 - So when we store our values in our database,
we might have it to where it's, we're going
27:32 - to store an ID, we're going to store a username,
I'm just going to shorten these up to make
27:38 - it easy. We're going to store username, we're
going to store a password, we're going to
27:43 - store an email. And then we're going to store
street address, state, city, so forth. But
27:51 - let's just say this is how it is for now.
Here is the actual table structure
27:58 - for the
27:59 - user table. So here are all of our attributes
for a user. Get rid of this. So it's clear?
28:09 - Well, with a view mechanism, we're able to
get different views of this data at the surface
28:16 - level. So for example, if we had two people
accessing this data, one, what's his name
28:22 - him, Jim, and the other one? Let's name her,
Jane, ie, Jamie, Jim and Jamie.
28:29 - Let's say Jim,
28:30 - he doesn't really care about the emails, because
all he's working on is to find out information
28:37 - about usernames and passwords. So what he
might do is he might create a new view of
28:43 - just the username and the password. Once again,
I'm just shortening these, just to make things
28:52 - simple for illustration, I probably wouldn't
put them in the database like that, unless
28:57 - you wanted to, but whatever.
29:01 - So this
29:02 - is a specific view, we can select the username
and the password.
29:06 - But
29:07 - the internal structure of the data has not
changed. This is still how it's stored within
29:11 - the database. Jamie, on the other hand, she
cares about the ID and the email. So she creates
29:20 - a new view.
29:22 - Just like that. So this,
29:28 - these are both called views. So the view mechanism
allows us to create different views. This
29:35 - can be used for database administrators, as
well as for other applications, such as when
29:40 - we have a web page, we may want. We may only
want users to be able to access their username,
29:45 - password, and email. But stuff such as the
date they registered, that might be all private
29:53 - on the database. So then we can just create
a view giving them the information that they
29:58 - have access to and that is a layer of security.
So basically, if we have a huge database for
30:03 - a business, well, the database admin administrator
is going to have access to it all. The president
30:11 - of the company will probably have access to
it all. But the people who are advertisers,
30:17 - they probably only need to know information
about advertising, the the people who monitor
30:26 - comments on your website, they are not going
to need access to the sales and the transactions,
30:31 - they're going to need access to the the table
for comments. That's a security feature that
30:39 - a view mechanism allows us to do by giving
different views. So not every single person
30:46 - who uses the database has the privilege of
creating a new view, just because you can
30:52 - access the database does not mean you can
do things such as update data, change the
30:58 - way it's structured, and so forth, that is
probably something only the administrator
31:03 - or the owner of the business is going to be
able to do. That means we can allow users
31:11 - on websites, they can only ask, they can only
access their specific username and password,
31:19 - they can't access everybody's username and
password only theirs. But if this guy, Jim,
31:25 - who is hired at the company, he can access
the username and password of every single
31:31 - user. That's a security difference difference
between the two people, not allowing the user
31:38 - of the website to get too much information.
And at the same time, not limiting Jim too
31:44 - few too little information. So that is a really
good security feature.
31:53 - So
31:55 - what else
31:58 - a relational database management system allows
us to do transactions, which we'll be talking
32:03 - about as the time comes, basically a transaction
is what it sounds like, it's when we do something
32:08 - with the data that for the technical terms,
basically, it is either complete all the way
32:14 - or it doesn't work at all, if we have a multiple
step thing, such as transferring money to
32:19 - an account, deducting that much money from
the other person's account, so forth, updating
32:24 - the data boom saved. If at any time the power
goes out, and the server crashes and it doesn't
32:30 - complete, well, then the transaction is canceled,
nothing is saved. That's something you can
32:35 - do with a relational database management system.
So that's pretty much the basics of relational
32:40 - database management system, just in case you're
not really sure, like the terms and stuff,
32:47 - examples of relational database management
systems or just database management systems.
32:52 - MySQL is one. It allows us to build and run
a database. SQL Server is basically like the
33:07 - Microsoft, if you like Microsoft, it's run
on the server, and then you access it. So
33:13 - you have Microsoft server, we have Oracle
database we have, I don't even know how to
33:20 - pronounce that I post gray SQL or something,
and so forth, the list goes on. But basically
33:24 - all of the big terms that you hear in databasing,
they're referring to the relational database
33:30 - management system, or the database management
system, if it's not relational database, don't
33:37 - really don't really think of the database
and the relational database as two separate
33:43 - things. They are what they're used as one.
But if you do want to be like conceptual,
33:50 - well things, we have the database, which stores
the information, and then the relational database
33:57 - management system, which allows us to manipulate
that data. When we have something such as
34:02 - MySQL. We don't really have a difference between
these two. And everything's just kind of like,
34:10 - okay, we use MySQL to create the data. It's
stored. My SQL is kind of like all we do the
34:17 - actual files, they're stored on hard drives
on a server or your home computer wherever
34:24 - you're running your database from. And the
relational database management takes the data
34:31 - on the hard drive and puts that into presentable
tables for people to like the administrator
34:40 - to view because if we have like a hard drive
disk, let's just say this is a hard drive
34:47 - disk. And some of the data is going to be
stored like right here. Other parts of data
34:52 - that's going to be stored like right here,
and some right here.
34:54 - Well, if this is a table
34:58 - the relational database management system
is going Want to be able to take that and
35:02 - put that in the appropriate location to make
it presentable, so don't really think of it
35:10 - like, Oh, we have a database, and then a relational
database management system, it's kind of think
35:15 - of them as one and all in themselves. So with
stuff like MySQL. The other thing, finally,
35:21 - I know, I'm kind of running long on this video.
The other thing a relational database management
35:26 - system is going to do is it's going to create
consistency. In bigger piece of chalk here,
35:34 - consistently, it's going to make consistency
behind for the front end. So on a website,
35:43 - we could have someone put their full name
in one box, and that can be stored on a database
35:50 - as two separate columns. first name last name.
Well, let's say if we updated this, and we
35:58 - decided to make it one column for some reason,
which I don't recommend, well, the front end
36:04 - didn't change, because the only thing that
changed is the back end. With a database,
36:09 - we can have consistency on our front end to
make our users happy, never having to worry
36:14 - about things changing. On the back end, the
things can change. For example, the way we
36:20 - store dates or our time zones or our character
sets, well, that's generally, that's not going
36:27 - to affect the front end, unless the data on
here is directly affects the front end. For
36:34 - example, if this is a username column, and
we delete the username column, well, that's
36:40 - going to cause issues, because it's not a
column on the database. But basically, when
36:47 - we have a database, the front end is generally
consistent, as well as we have server side
36:53 - scripting languages, such as PHP, or whatever
else. Well, that is going to hide our database
37:00 - and even even step farther. So basically,
rather than saying, oh, there's no username
37:05 - column, it'll say something like error, try
again, later, something very vague, so people
37:11 - don't understand like, Oh, crap, I can pack
this guy because I know his database structure,
37:16 - I can figure out how to mess up his website
or his business or whatever. So yeah, that
37:22 - was a server side scripting language. I'm
not gonna write that out, because it's huge.
37:26 - Yeah, that is the basics of relational database
management system.
37:30 - Hopefully, that was helpful. In
37:35 - this video, we'll be talking about SQL. So
s q, l. Alright, so what is SQL? SQL is a
37:47 - programming language used to communicate to
a database. Basically, we speak English databases
37:55 - do not so SQL is kind of like the mediator
between computer database and human English,
38:03 - think of it like that. It's almost English,
it's very simple. And in this series, we're
38:07 - not actually going to be programming any databases,
although we will be talking about general
38:13 - SQL concepts. So it's important that you know
about SQL. So SQL is not like a specific relational
38:22 - database management system. programming language,
it is a general language used for every single
38:29 - relational database management system. From
vendor to vendor, such as MySQL to SQL server
38:37 - or something else, it might vary a little
38:39 - bit,
38:40 - but the general concepts of SQL stay the same.
So this is this is going to be a general concept
38:46 - that you should know. So SQL first is used
to define the database structure. And then
38:59 - it manipulates the data within. So basically,
we can kind of think of SQL as two categories
39:12 - here. One, it defines the structure and then
to manipulates by that it means we insert
39:20 - data, and then we can search it or delete
it or update it. These are the two subcategories
39:28 - of SQL. We actually for some reason, name
these their own languages. So this is data
39:35 - Definition Language for DDL and this is data
manipulation language,
39:42 - or
39:43 - DML. Some people may say there's more categories,
but I mean this is pretty much the domain
39:50 - to so think of it like this. I'm just going
to erase this here. Now that we have this.
39:59 - We have
40:00 - DDL
40:01 - DML when we have like a table, for example,
I'm just gonna write this down here. And we
40:07 - have the columns. So we have like ID user
name, password. Well, that's data Definition
40:16 - Language. data manipulation language is what
we would use to insert a new value, such as
40:23 - the ID of 72, the username of Caleb curry,
the password of pi 123. That's data manipulation,
40:30 - language. So when you think of a table, and
if, obviously, if you have a big database,
40:36 - you'd have multiple tables. Well, all of this
structure and the connection between tables,
40:43 - that's all data Definition Language. So it
gets all of the main
40:46 - structure
40:48 - of the database. And then the, the data within
the database is data manipulation language.
40:56 - So those are the two main categories.
40:58 - Just I just want to talk about some of the
features of both of these languages. So basically,
41:08 - when we define tables, we have a create statement.
So basically, all SQL I write in all capital
41:17 - letters. That's just a pattern that I've chosen.
So create is an example of an SQL command
41:23 - used to create tables. And we can create a
database this way. That is data Definition
41:30 - Language, because we're defining the structure
of our database, a command such as update,
41:35 - or, yeah, I guess, update if we're updating
the actual values within columns. Well, this
41:44 - is manipulation. language, because we're not
changing the structure, the columns stays
41:49 - the same, just a specific attribute of an
entity changes. we're updating Caleb Curry's
41:56 - username to Caleb curry 123. Well, that's
a data manipulation language. Another thing
42:05 - that SQL can do is what's known as a join.
And joins are very important, very important
42:13 - with a relational database management system.
Because with a relational database management
42:17 - system, we break things up into separate tables,
for simplicity sake, for one, sorry, I was
42:23 - I added the scene there, I think I was whatever.
Rather than having a spreadsheet with like
42:29 - tons of information, we break it off by entity.
So here's a table about the user, here's the
42:35 - table about the orders, here's a table about
the customers, then we can join those values
42:43 - to get a new, larger table, a new view, that
looks like a huge organized table. I mean,
42:52 - basically, it looks, it doesn't look like
we broke it up into multiple tables. So if
42:58 - we have a table here, and then we have a table
here. And let's just say we have, this is
43:05 - a sale table. And this is a user table. Within
the sale table, we have a sale ID, we have
43:14 - a user ID the person who bought the stuff.
And then we have the objects that they bought.
43:21 - And I mean, this is this this silly example
just for you to understand the concept of
43:24 - a join. And then within the users table, we
have the the name, the user ID, and so forth,
43:30 - we can do a join here, we could take the objects
that they bought, the person the objects that
43:38 - the person bought, as well as the name of
the person who bought it, connected by the
43:46 - user ID, which will we'll talk about this
more, then we can get a new view, which has
43:52 - the name and the items that that name, but
it's all talking about the same entity, this
44:02 - user. So a naming convention is just a pattern
that people do or that you do to keep things
44:10 - consistent. So not only will this naming convention
help keep my database consistent across different
44:18 - tables and columns. But this naming convention
is not only mine, other people use this naming
44:25 - convention. That means when I go to a different
person to review my database, they already
44:32 - understand what's going on. Now, obviously,
there's multiple different naming conventions,
44:38 - there's not one way to do everything, and
it's not required. This is just how I decided
44:44 - to do it. And this is because most people
who use my SQL, which is what I learned first
44:50 - use this, but for different relational database
management systems, you may have different
44:57 - systems of naming things. So I'm just going
to get Explain what I'm going to do. Anytime
45:02 - I write SQL, I put it in all capital letters.
So select is an example. Fortunately, we're
45:11 - not going to be doing much SQL. So I'm not
going to have to write in all capitals on
45:15 - a chalkboard because it's, it's quite complicated.
But when we're talking about anything I named
45:23 - myself, I use all lowercase letters, I just
use all lowercase letters, because I just
45:28 - think it makes it more simple. So when we
have a table,
45:35 - such as a user table, I don't capitalize the
EU. And then when I have an ID, I just put
45:43 - user ID or just ID whatever, but I don't capitalize,
Id I just keep it lowercase. And for spaces,
45:50 - I just use an underscore, so I don't use any
spaces. So basically, that's my naming convention
45:56 - that I use, and yours will vary. And we haven't
really got to this yet. So you might not understand
46:02 - this. But if I have a foreign key, basically,
if I have a copy a connection over here, to
46:10 - where we have the same column over here, I
just make sure their name both the same thing.
46:17 - So I know what they're talking about.
46:19 - So yeah,
46:20 - I, some people will do things such as put
like user table, or they capitalized certain
46:26 - words. And if you want to look at other naming
conventions for your specific relational database
46:31 - management system, go right ahead. In fact,
I'd encourage it. But just so you understand
46:36 - what I'm doing here, I will be doing another
thing, when we're talking
46:41 - about
46:43 - stuff in the real world. Sometimes I don't
necessarily use that naming convention. Because
46:50 - if I'm writing everything I need to store
about a user, well, I might just put, we need
46:55 - to store the user's address, I'm not going
to put the underscore users underscore address,
47:01 - I might just put the user's address with space
in English. And then when I convert when I
47:07 - start making this into a database, structure,
schema, whatever you want to call it, then
47:13 - I'm going to convert that to just address
lowercase. We're going to be talking about
47:21 - Okay, what is database design? And when we
talk about what's a database, we never really
47:26 - talked about database design. Why do we have
to design a database? What What's so special
47:33 - about it, it needs to design it's not like
we're building a house or something? Well,
47:37 - in a way, it's it's kind of like that it's
we're building schematics to build the best
47:42 - database. How do you measure whether a database
is good or bad? Well, it has to do with data
47:48 - integrity, which we'll talk about that in
more depth in an upcoming video.
47:59 - So data integrity is basically where all of
your data is correct, it's up to date, there's
48:04 - no disconnected data. For example, if we have
two tables. And for some reason, these tables
48:11 - are connected in some way. Well, if if for
some reason this link breaks, well, then when
48:17 - this table updates, this table gets left behind,
and then the data becomes incorrect. That's
48:23 - a data integrity problem, because the data
is not managed properly. So with a good designed
48:30 - database, we prevent data integrity issues.
So all of our data is up to date. We don't
48:38 - have, we don't have repeating data, we don't
have old data that should not be in there.
48:45 - Which, if for example, if you have a database,
you can store lots of information from like
48:51 - long ago, and that's fine. But you don't want
data that has recently changed, and it hasn't
48:58 - changed in the update. So you want the database
to always be up to date. Unless for some reason
49:03 - you're storing like an archives, let's say
you have a store, and you want to store an
49:08 - archive of every single order you've ever
made or sold or whatever, well, then you can
49:13 - store all that in a database. And that doesn't
really need updated because it's an archive.
49:17 - But if you have, if you have a customer in
your database, and the address is out of date
49:23 - and doesn't update, well then you have a problem.
Another example is if the person up has four
49:33 - so if your database is designed badly and
you have repeating data, well then one example
49:38 - of the data can update and the other ones
left behind. So now you have like two addresses
49:43 - for one person, which should just be one address.
That's another example of a data integrity
49:49 - problem. So we'll be getting into like specific
cases of data integrity problems
49:55 - as we go on.
49:56 - But when we talk about data design, database
design has Whole, people usually break it
50:02 - up into three sections, two or three, it just
kind of depends on, like, what people mean
50:08 - it, it varies from person to person. So okay,
first, we have
50:15 - the conceptual.
50:18 - And then we have the logical. And then we
have the physical. Alright, these are all
50:28 - known as schemas of schemas, whatever you
however you want to pronounce it, but that's
50:34 - this. Alright, so we have the conceptual schema,
the logical schema and the physical schema.
50:46 - A schema or us just think of a schematic,
like when you're building something, it just
50:53 - tells you the way the data is structured.
The conceptual, this up here is when we're
51:00 - just kind of thinking about things, how things
are related. We don't think of limitations
51:06 - as an Oh, we're not going to be able to do
that, because we only have this much availability
51:11 - or something. This is kind of like unlimited
brainstorming phase. And as we move down,
51:16 - this is more specific to where we say, Okay,
this is how we're going to program our database.
51:22 - So up here, this up here is more general.
This down here is more specific. Once you
51:36 - get down here, you have to start worrying
about, alright, what kind of relational database
51:41 - management system Am I going to use. But when
you're up here, you can just kind of think
51:44 - of general concepts how data is related. So
the farther you go down to the physical, the
51:51 - more specific things get. I mean, that's pretty
obvious. So rather, rather than thinking of
51:56 - it like three steps, I kind of think of it
as a continuum, we are taking our general
52:02 - ideas and moving them to specific implementations.
Hopefully that makes sense. But basically,
52:08 - when we talk about these individually, the
conceptual just talks about how data is related.
52:15 - Because in a relational database management
system, we have relationships between tables,
52:22 - if you think of, we have a users table. And
then we have a sales table. And these users
52:32 - can go to this website, and buy products.
That's our example. Here. It can be anything
52:39 - but this is just an example. Well, every single
sale has to be bought by someone, specifically
52:45 - one user. So that means there's a connection
between the user and the sale. So we have
52:51 - this connection here. That is part of the
conceptual design, we say, this table, the
52:58 - sales depends on the user. So that's, that's
because with without a user, we can't have
53:09 - a sale, because there's no one to buy the
stuff. And a user doesn't doesn't necessarily
53:14 - have to have a sale. So it's dependent this
way. That would be the parent, that would
53:19 - be the child. Hopefully that makes sense.
When we get to the logical, we start planning
53:24 - out our table
53:25 - structure.
53:26 - So we have all these relationships between
data, well, then we can realize all right,
53:31 - we have specifically a user's table, and we
have X number of columns, the username, the
53:39 - password, the ID, the address, the phone number,
the credit card information, if that's something
53:44 - you need to store, anything like that. Then
we have another table. And is the the sales
53:52 - so we have the sales table. So we have user,
use a table, and then we have the sale table.
53:58 - And then this, this is connected in some way.
So we have user can have multiple sales, and
54:07 - a sale can only have one user. That's a logical
database design, because we're actually structuring
54:13 - our columns are data types, our relationship
for drawing those out, so we have this logical
54:20 - drawing or schema, the physical, that is when
we start actually implementing that into a
54:30 - database. So when we're talking about just
designing and we're not actually creating
54:35 - the database, the physical design would be
figuring out what relational database management
54:41 - system will work best. What are our table
types? What what server Are we going to store
54:48 - this on? How are people going to access this?
Is it going to be over the internet, it's
54:53 - going to be over computers programs. So usually
database will be on a server, and this will
55:03 - be accessed by multiple different people.
That's because the database is like the core
55:10 - of all data. For example, if we only had this
one person using the data, well, then we wouldn't
55:16 - need this huge database, we can just store
that information on their computer, because
55:20 - they're the only one on there. It doesn't
even make sense. So typically, everything's
55:25 - kind of accessed on a server. So the physical
would be okay, what kind of server we're using?
55:31 - How are people going to access our data? Is
it going to use a webform? Do Is that something
55:36 - we need to program? And then when you physically
implement that is that that's when you actually
55:42 - program the database, build the webform, or
whatever you are doing, installing the server
55:49 - and testing, building the users who who's
going to access it, the views? What are the
55:54 - different views going to be? What data is
going to be returned, and so forth. This is
55:59 - also when you really focus on security. Because
logically, when we're in the logical phase,
56:06 - we're still kind of thinking, Okay, no one's
going to try and break it, no, everyone's
56:11 - going to use the database correctly. But in
the real world, that doesn't work out that
56:15 - way, people, either they try to break things,
or they just don't know what they're doing.
56:20 - Or there's errors or there's incorrect data.
Well, that's when somewhere along this continuum
56:26 - right here is when we need to start worrying
about security. We don't want people breaking
56:32 - into our database. And we don't want our database
to fall apart and have data integrity issues.
56:40 - So hopefully, that clears some things up.
So the database design, something's up real
56:48 - quick.
56:54 - database design,
56:56 - is using skills that you know, to build a
database that is not going to have data integrity
57:04 - issues, update anomalies, we'll talk about
those two, but that's basically when if for
57:09 - some reason you're storing two of the same
data, like if my address is on in the database
57:15 - twice, well, that's a problem. Because when
I update my address, only one may update,
57:21 - for example. And now the address says I live
in two different places. That's, that's wrong.
57:27 - So a database design is a method to separate
information over multiple tables, rather than
57:36 - having one huge table like this, where I store
my address, we store our sales, we store our,
57:42 - our customers, we store our our favorite video
games we store our relationships with. Yeah,
57:52 - you get. So basically,
57:54 - this is
57:55 - a bad design, because it's all in one table.
And when when I have to update it, so we have,
58:00 - let's just say this is a row, right? And I
have the columns are ID, and username. And
58:12 - then we have us again need to be a little
bigger. And then we have username, we have
58:17 - address, let's go phone number. It's easier
phone. And then we have favorite color. When
58:28 - we store like this, well if we need to put
a new favorite color, we have the ID seven.
58:33 - That's me, we have the username Caleb curry,
we have the phone number one 800. Favorite
58:44 - color cammo. And then if I want to put a new
favorite color in, well, we can't because
58:52 - we don't want to we already put one in there.
So we need to create a new route, say seven
58:56 - Caleb curry one 100 dot dot dot. And then
favorite color.
59:04 - Green.
59:06 - Right?
59:07 - Well, now we have all those duplicate data,
we have this in here twice, do this in here
59:14 - twice, we have this in here twice. And we
have, we have to have two rows for favorite
59:17 - color. So your you have to find a solution
to this problem.
59:22 - But now
59:23 - if I decided to update my phone number because
I got a new phone number, well now I'll update
59:27 - it and I'll change it to 1234567 whatever
it is, well now I updated my phone number
59:36 - but for some reason, we have a data integrity
issue, because my phone number is in here,
59:42 - two different ways that that's a bad database
design. And in this series, we're going to
59:48 - be talking about fixing problems like that.
And the best way to do this would be to like
59:54 - separate it into multiple tables. Plus, you
probably don't need to store your favorite
60:00 - color. Unless you're running some kind of
like art website or build a business, so it's
60:06 - possible. But we can do the same thing with,
like orders how many orders if I had to put
60:13 - my orders in that table, which is another
bad idea, we have the same data integrity
60:17 - issues. So this series is going to talk you
through getting rid of those data integrity
60:21 - issues, so you have the best database design,
for best performance. We're going to be talking
60:30 - about data integrity. Alright, so what is
data integrity, we talked about it a little
60:36 - bit in the last video, but this video is going
to be going over in more depth. data integrity
60:41 - is just having correct data in your database.
So when you're when we're databasing, we don't
60:47 - want repeating values, we don't want incorrect
values. And we don't want broken relationships
60:54 - between tables. For example, in the last video,
I gave the example, you have a table here.
61:01 - And this is the user table. This is weird,
right? And like this, and then we have a table
61:07 - over here. And that is the sale table, which
is where you sell products. For example, this
61:14 - is just an example. You can you can implement
other examples. But this is just to illustrate
61:20 - my point. A sale is when a user buys product,
that means a sale needs a user as the buyer.
61:32 - Otherwise there's no sale, we can't have a
sale, if no one bought it. Does that make
61:36 - sense? That means the sale is dependent on
the user. And we have a relationship the user
61:44 - buys stuff, stuff is bought by a user, this
is a known as a Can you see this is known
61:53 - as a relay ship on ship. Now, do keep in mind
that the term relational database does not
62:05 - come from the word relationship. It comes
from relations, which is the mathematical
62:13 - connection of sets, which we talked about
that in the earlier video. But just don't
62:19 - get that confused. But relational database
does have relationships between tables. So
62:26 - this if for some reason this was broken. And
now we have a sale that was bought by a user
62:33 - or no user. So for example, let's say this
sale was bought by user with the ID of seven,
62:41 - okay. And then we have a user of ID of seven.
So there's a connection, the sale was bought
62:48 - by the user by ID of seven, which points back
to the user. Make sense? That's data integrity.
62:54 - But if this relationship is broken, and it
says the sale was bought by the user with
62:59 - the ID of seven, and then this person is removed
from the database. Well, now this sale points
63:08 - to a table or a user that doesn't exist. And
that might be that might be practical, in
63:14 - some sense to say that sale was bought by
that user one he did exist. But for things
63:20 - that need to update consistently, we don't
want that to happen. So that's example of
63:26 - integrity issues. So you want to keep that
relationship to say, Okay, well, we got rid
63:31 - of the user, we need to update the sales to
say, well, either the person is deleted, or
63:37 - also do something with the sales. So yeah,
sorry, if sounds a little confusing. Okay,
63:48 - so the three main types of data integrity.
First one is entity integrity. We talked about
63:54 - entities in like one of the first few videos,
an entity is anything we store data about.
63:59 - So we had the user to begin with. This is
an entity.
64:05 - What it means by entity integrity is basically
unique entities. When we have a user, we often
64:13 - give them IDs This is known as a key. So an
ID is used to enforce uniqueness among the
64:24 - entities. Like for example, if we had a table
for users,
64:33 - and we store the the name of the person and
then we store their address. Now let's just
64:46 - go to phone number. Because when we talk about
addresses, it's best to break it up into like
64:50 - street state, and I don't want to go through
all that. So we could potentially have a person
64:57 - with a repeating name. So let's To say his
name's Caleb, and his phone number is one
65:03 - 800.
65:04 - You wish?
65:06 - All right? Well, if we had another person,
if they both lived in the same house, for
65:13 - example, and this was their house phone, well,
sometimes people name their children the same
65:18 - name as them. So now we have two people with
the same phone number. And you look at this
65:28 - and say, Okay, well, either either we have
two people with the same phone number, or
65:33 - we have two rows talking about the same person.
And we don't know, because we don't have proper
65:39 - data integrity. So a way to solve this is
to either add more columns to where the row
65:46 - would be unique, such as a social security
number, or we could add an ID
65:53 - on.
65:55 - And this would be like six, and seven. So
now we're talking about two separate entities,
66:01 - this is talking about this guy, because his
ID is seven. This one is talking about this
66:08 - guy. Because this ID is six, they're two separate
entities, that's entity integrity, having
66:15 - uniqueness among your entities, we have uniqueness
with the rows, and we also have only one user
66:23 - table, we're not going to have another user
table, because that information should go
66:28 - in the original user table. Onto referential
integrity. This is the one we talked about
66:34 - earlier, is when we reference the ID of a
table and another table. If we had a comments
66:45 - table on the website, right, and we say who
the comment is by, we have a user ID, which
66:55 - points back to this ID over here. That's because
the comment has to be posted by a user. Otherwise,
67:05 - we have a comment that didn't have someone
who posted it, which doesn't make sense in
67:11 - the practical world. So we always have to
have referential integrity, which basically
67:16 - says, Every time there's a comment, there
needs to be a person who posted that comment.
67:22 - And that connection needs to remain it needs
to stay. If for some reason this is disconnected.
67:28 - And then this user is removed for this table
was changed, well, then this could change.
67:33 - I mean, this stays the same. And then there's
a disconnection to where this is changed.
67:39 - And this is old, outdated data, where either
the user no longer exists. And the comment
67:46 - still says he does, or something else like
that. That's referential integrity. And that'll
67:53 - make more sense once we start designing and
stuff. But yeah, domain integrity, that brings
68:02 - up a new word domain. domain is basically
just the acceptable values for a column for
68:13 - say, it's what we are storing the range of
what we are storing within a database. So
68:20 - when we're talking about tables, we have columns.
So these columns up here, let's say we have
68:25 - a phone number. Well, that means we should
have a certain number of digits, we have the
68:33 - area code, and then the three digits and then
the four digits. And that's at least us in
68:40 - my change other places, but that is 10 digits.
So we know that the phone number should be
68:47 - 10 digits, and it should be numbers. So if
for some reason I put the word cake in the
68:56 - phone number column, Well, for one, this is
going to cause an error if we have domain
69:03 - integrity, because it's not a 10 digit number.
It's just a word. That's not the proper domain.
69:11 - It's not a digit is not numbers, and it's
not tenable. So we know that's going to cause
69:18 - an error. So that's the basics of data integrity.
When we don't have data integrity, we have
69:25 - errors. When we have data integrity, we do
something to correct those errors, such as
69:32 - saying, all these all need to be numbers.
That's how we implement data integrity by
69:39 - setting database rules and how you do that
with the database. Well, that kind of varies
69:45 - upon the relational database management system
that you use. Some relational database management
69:51 - systems allow for general rules, saying okay,
this has to be a range of this numbers. Some
70:00 - are more vague where they, where they only
allow you to implement data types, data types
70:06 - would be like, integer 10 digits. So when
we talk about practically implementing data
70:12 - integrity, different relational database management
systems have different things you can do almost
70:19 - every single
70:20 - relational database system that I have, I'm
pretty sure all of them, but
70:24 - who knows.
70:25 - They allow for data types. So a data type
is pretty, pretty self explanatory. It's the
70:35 - type of data.
70:41 - So in database, we classify things as generally,
integer, or text, or date. So we either have
70:52 - numbers, text, or dates, that's like three
general categories, which we'll be talking
70:58 - about that more in a future video. But the
data type can put limits on what we're allowed
71:04 - to store. For example, we can say, okay, we
only want a character column with the maximum
71:14 - of 20 characters. That means we can put a
string in the column that says,
71:36 - I like
71:37 - p
71:38 - 1-234-567-8910 1112 1314 1516 17,
71:40 - that'll fit.
71:41 - But if I wanted to change this pizza to lasagna,
well, then I just added a couple extra characters
71:48 - that might cut it off, I'm not sure 1-234-567-8910
1112 1314 1516 1718 1920. So that's the maximum
72:01 - we could put in that data. It's like, that's
an example of implementing that data integrity
72:06 - for the
72:07 - characters.
72:11 - So this, this will be for the domain integrity,
we can also have referential integrity with
72:15 - what's known as foreign key constraints, which
allows us to connect to tables, because when
72:22 - we drop tables, we could say that they're
connected in some way. But how do we enforce
72:28 - that in a database, we use foreign key constraints.
For example, we can say if this is the parent,
72:37 - let's say this is the users. And this is the
comments. The user places a comment, so this
72:49 - is the parent This is the child, because the
child can't exist without the parent, you
72:54 - can't have a comment without a commenter.
Well, using foreign key constraints, we can
72:58 - say, Alright, if this user gets removed, also
remove all of the comments by this user. That's
73:07 - an example of foreign key constraint. As for
the non repeating data, that is done with
73:17 - just designing your database in the best way.
So yeah, I know that video was kind of jump
73:24 - back and forth from concept to concept and
maybe a little confusing, but I'm sure you
73:28 - will get it as time goes on. I just want to
do a little bit of review, as well as go over
73:37 - the vocabulary that we've learned. So if you
don't really want to know, we're going to
73:42 - go over some new ones too. But if you don't
want to review, then feel free to skip this
73:47 - video in the next one. So this video will
be about data and database design terms. So
73:53 - the very first term we learned was data. Data
is pretty much anything we store in a database,
74:02 - you pretty much know what that is sounds pretty
good database. That is what we store our data
74:09 - in. And then we have a specific kind of database,
which is a relational database.
74:22 - And what's special about a relational database
is that it stores things in tables. We have
74:29 - a database management system, or database
managed DBMS for short. That is how we manage
74:38 - a database using code. That's how we control
our database. We have a specific kind of database
74:45 - management system called a relational database
management system, which is just used to control
74:54 - our tables and the values within our tables
of a relational database. Pretty Simple. Now
75:01 - we're going to introduce a new word to you,
which is no or no, however you want to pronounce
75:10 - it. I've been told I pronounce it wrong, but
I don't really care. Anyways, this is when
75:17 - someone does not enter a value within a column
on a table. So if we have a table, and we
75:25 - have something such as fax number,
75:30 - well,
75:32 - not everyone is going to have a fax number.
So when we have a guy will say we have an
75:37 - ID here, we have an AI guy with the ID of
seven. And we don't have a fax number, this
75:44 - emptiness is said to be no. So basically,
you'll hear empty value, although, by definition,
75:55 - No means no value. So it's kind of a bad definition.
But who cares? No, basically means there is
76:04 - no data in that specific field. And we'll
be getting into more terms like that in a
76:12 - second. So that is what normal means. That's
one you will need to know. Another one is
76:17 - an anomaly, or anomalies.
76:22 - So, anomalies are basically errors within
our data in our data integrity. So when we
76:34 - have an anomaly, it's something that goes
away from what we expect or from the normal.
76:41 - When we update something, for example, and
instead of updating one column, it updates
76:45 - 10. And it wasn't supposed to. That's an anomaly.
So yeah, you'll need to know that as well.
76:51 - The other one is integrity. We implement database
integrity, to protect against anomalies. So
77:03 - we went over three different kinds of integrity.
We went over entity integrity, over referential
77:14 - and we went over domain. Real quick what these
are, entity integrity is saying uniqueness
77:21 - among the table, referential keeps the connections,
the keys, foreign keys, primary keys, they
77:28 - keep them connected across multiple tables.
So we could say these two tables have some
77:33 - kind of connection. And then domain is basically
saying a column within a table has all of
77:42 - the expected values. So we have a phone number,
we would expect numbers, not text or not a
77:51 - date, that is domain
77:53 - integrity.
77:55 - And the word domain is basically the range
of values that are acceptable to store within
78:01 - a column. So these are our data, vocabulary
that you should know. Now we're going to move
78:08 - on into the design term. So designing is what
we're here for. So
78:17 - this is fun.
78:18 - Very first thing you need to know is an entity.
Which is anything we store data about a user
78:28 - a, a mortgage, a transaction, a credit card
information, anything the comments a comment,
78:38 - they're all entities, that's what we're storing.
data about, then we have attributes. attributes
78:49 - are the things we store about the entity a
comment, a, an attribute of a comment would
78:56 - be the date that it was made the link, how
many characters is it? who posted, that's
79:03 - an example of an attribute a relation.
79:08 - We're talking about
79:09 - mathematics, it's a connection between two
sets of data. When we're talking about databasing.
79:16 - Put very simply, it's just a table. So a relation
is another name for a table
79:21 - where we have
79:22 - data within our database. So we could have
a structure of different tables. So these
79:30 - can be connected.
79:31 - Just I don't know however
79:34 - you want to connect them. This can be our
database, where each one of these different
79:42 - sets of different sets of information or data
is known as a relation is a table.
79:55 - next term is a tupple however you want to
pass that to winging it here. That's another
80:02 - thing for a row. It's a, it's all of the attributes
about a specific entity. So if we have this
80:09 - guy, we can say, his name is Caleb, his phone
number is blah, blah, blah, blah, blah, his
80:21 - address, his age, his or his birthday would
probably be better how long he's been a member
80:26 - of this website, or whatever it is, this all
of these values about this entity. That's
80:33 - what that is. That would also be a row on
a table, because we physically represent relations
80:42 - with a table. So when we have a table, we
have the columns, so we have name, phone number,
80:49 - address, social security number. And then
when we enter all of those, for a specific
80:54 - person has the ID of seven, the name Caleb,
the phone number, blah, blah, blah, the address,
81:00 - blah, blah, blah, that is known as a tupple,
or a row. Another term is table, which we
81:11 - just talked about that which is just a physical
represent representation of a relation. Tables
81:19 - are what we store in a database to organize
a my like cutting my head off there. To organize
81:28 - our data. Within a table, we have rows and
we have columns.
81:38 - The rows would be a specific individual entry
within our table. So like that guy we just
81:44 - drew all of his values would be his row, the
columns are that specific, is a specific attribute
81:53 - of that person, such as a name. This is the
column where we would put the value, Caleb.
82:05 - All right. Now we also have another three,
three more terms that we haven't learned yet,
82:13 - which you will possibly hear. They're kind
of older terms, but they they're just talking
82:18 - about the same thing. You may hear the terms,
82:23 - file,
82:25 - record.
82:27 - And then fields. So what are these talking
about? Well file is just another name for
82:36 - a table, a record is another name for a row,
and a field is another term for a call. So
82:47 - other than that we have the words is value.
A value is the information that we put in
82:55 - to a specific column. So here is a value
82:58 - Kayla, or
83:01 - subscribe, or get rid of,
83:08 - or 700 or June 16, whatever it is, those are
all values.
83:15 - All right. Oh,
83:17 - man, it's already 10 minutes. All right, then
we have an entry, you may hear the term entry,
83:25 - which I like to use this for the like the
it's almost like a verb, the when you enter
83:31 - data, you get an entry. So basically, an entry
is just another name for a row. So um, there's
83:36 - obviously a lot of similar names. And we'll
be making a table saying what we're just just
83:42 - getting database design. The process of designing
your table to remove anomalies and have data
83:53 - integrity. game or schema, however you want
to pronounce that, that is just a physical,
84:01 - that's just a drawn out structure of our,
our database, then we have a new term here.
84:09 - It's called
84:10 - normalize,
84:11 - or normalization. normalization is basically
just a bunch of steps that we're going to
84:17 - follow to help us get the best database design.
So that's just that's part of database design,
84:26 - when we go through these normal forms, to
get the best database design, we'll talk about
84:31 - that more in an upcoming video. But just I
want you to know that the term normalization
84:36 - is the process of building the best database
design. The other one and naming conventions.
84:45 - And naming convention is just a consistency
used to make things consistent. So we named
84:55 - tables a certain way we named columns a certain
way. we name our database a certain way We
85:00 - draw our database schema a certain way. So
basically, convention is anything that is
85:07 - done repeatedly to create consistency. And
the last one here is keys, which I'm not sure
85:13 - if I talked about this or not yet, I think
a little bit, but not much. But key is something
85:20 - to make everything unique within a table.
This is how we make connections among tables,
85:26 - we connect IDs, we may say, Oh, this comment
was posted by the user with the ID of seven.
85:33 - Well, that points back to the user table.
We do all that with keys. And we'll learn
85:38 - more about those as time goes on. Alright,
so you see, we have a lot of terms and a lot
85:44 - of them are repeats for this meaning the same
thing for example, we have relation. And then
85:52 - we have table. And then we have file. So relation
table and file are all talking about the physical
86:03 - structure, a table pretty much record with
circle diesel's record would be a row, so
86:12 - we have a row. And then we have a sub, these
are all talking about rows within a table.
86:19 - And then we have, how should I do this? Let's
just cross them out columns. And then we have
86:28 - attributes. And then we have a field, those
are all talking about a column in a table.
86:35 - And also entry, you can kind of think of that
as a, a row, because you put like, you enter
86:42 - data into the table and you get a new row.
The value is just a specific, you can think
86:49 - of it like we read some of this. We have this
table, and we break it up into columns. So
86:58 - we have ID, name, and then phone number, for
example. Those are a column headers, and then
87:08 - we have specific dice,
87:10 - seven,
87:11 - Halo.
87:12 - And then we have another guy eight. Well,
if we separate this into cells, which is another
87:20 - term, we have a specific value that we've
put in here, such as john, that is a value.
87:32 - No entity, that's the only one that's so we
just just went over value entity is what's
87:41 - left that's not circled or crossed out or
squared, or some entity is I don't like to
87:47 - really assign this to like a row or a table
or anything because an entity is just something
87:51 - we're storing data about. So that could be
an individual row, or it could be the table
87:57 - type. So for example, we have a table for
users while the user is the entity, but a
88:05 - specific, a specific entity would be a row
within this table. Because we'd have the entity
88:12 - for this
88:14 - guy over here. And then
88:15 - we'd have one for this guy down here or for
this check over here. Or lady I should say.
88:24 - So these all get their own rows to see. So
an entity that's is something we store data
88:30 - about. This video will be just some more vocabulary,
there's not as many we're broken up into two
88:38 - categories. This one first one is SQL. So
first we learned about SQL, which obviously
88:45 - is program language to use to binary mention
this I'm horrible. Structured Query Language
88:52 - is what SQL means. What does that sort of
stands for, it's used to connect to your database.
88:59 - Hi, sorry, I just got distracted. I was waving
this paper. And like my lens is like flashing
89:05 - for some reason.
89:07 - Anyways,
89:08 - the next part was data Definition Language,
which is used to define it's part of SQL.
89:16 - So SQL has data Definition Language, and D
and L, data manipulation language DDL is used
89:24 - to define the structure of our database. data
manipulation language is used to insert values
89:31 - in our database, as well as update them, delete
values and search values and so forth. Oh,
89:41 - the other thing was, I never really mentioned
this, but I do want to mention it here, SQL
89:47 - keywords.
89:48 - So anytime we have the word
89:50 - keywords in a programming language, it's talking
about something that is reserved that you're
89:55 - not supposed to use for your user defined
data. So for example, Select in SQL, this
90:05 - is a word that your database is going to recognize,
as Okay, we want you to do something, we want
90:12 - you to select data. It's a keyword, because
it's already defined. So I want to I don't
90:17 - want to name my tables or my columns, any
keywords because it can cause errors or confusion,
90:25 - or just make things complicated. I always
put SQL keywords in capital letters. Right.
90:33 - So that's pretty much all for the SQL.
90:37 - Here's my race.
90:41 - Go America,
90:44 - and every other country, oh, bright presentation.
So the very first thing is we have the front
90:58 - end of an application. The so the front end
is what the user sees. The back end is what's
91:07 - going on behind the scene. When we have a
website, we don't just have what the website
91:15 - looks like, we have code that gives us that
look, when we put in data to forms, we have
91:22 - languages that communicate with databases,
to create a easy to follow non confusing front
91:31 - end. But the back end is complicated as heck.
So that's the difference between front end
91:37 - and back end front end is what the end user
at a particular time will see, the back end
91:42 - is what's going on behind the scenes. So often,
when we're working with databases, we will
91:48 - program a front end because we don't want
everyone accessing our server, it's insecure.
91:55 - And it's just not a good idea. So we often
create a front end application to access our
92:02 - database, most commonly a website, although
there's other forms, but whatever. So here's
92:08 - our database. Rather than people signing into
the server and using SQL code to get information,
92:15 - we often program front ends for people to
access this data in a different way. So each
92:24 - one of these front ends would be like a website
page, for example. So here would be your registration
92:30 - page here would be your users page, here would
be your profile,
92:34 - your homepage here would be if you like you
can even have different tier systems. So this
92:40 - could be a page where the website administrator
can add or delete users, they have that extra
92:48 - privilege. This is also the view system, which
we will talk about in a second. Well, the
92:52 - front end doesn't allow us to directly type
in our own SQL, it only allows us to use what
93:00 - the front end gives us, which is then communicated
to the database. So that's what a front end
93:06 - end is, the back end would be the server side
code used to communicate with the database.
93:13 - So when we when we're talking about clients
and servers, we have those two terms, we have
93:17 - client, and then we have server. So very first
thing is client. client is think of it if
93:27 - we have this wall here. Over here, we have
a computer. And then over here, we have the
93:39 - database. This is the client side, because
we're accessing the database over here is
93:49 - the server side.
93:53 - So client, client side and server side, I
don't really have room to write that. But
94:03 - the server serves instances of this database
to the client where they can access the data
94:10 - in some way depends on how we the privileges
we
94:13 - give them.
94:16 - So when we talk about
94:20 - different privileges for different people,
we use what's known as a view. So personally,
94:24 - I finish this client side and server side.
And we communicate from the client side to
94:32 - the server side by a server
94:37 - side
94:39 - scripting or programming language. It's huge.
Well, my hands tired. We can give custom views.
94:53 - So a view is just taking the data from the
database and illustrating in a different way
94:59 - than how it's actually be stored. For example,
a user on a website can visit, let's say,
95:04 - we're on like a social network and I visit
my friends page. It'll tell me their their
95:10 - name, possibly their username, if that's what
they use, their date of registration, their
95:16 - phone number, if that's public, for example,
anything like that their relationship status,
95:21 - although information that is private may only
be accessible to the user who owns it, for
95:29 - example, their password or their email, or
their friends lists, that might be a different
95:37 - view, depending on what page you are on what
page you are on, and the user that
95:43 - you are.
95:44 - So I may be able to access my own password
and email. But that might be private to other
95:49 - people. That's the view. Views often use joins,
which basically Connect data from multiple
95:58 - tables to create a new table. We have two
tables here. users table, comments table.
96:08 - Can you see that? Can you see it? You better
be able to see it? Well, a comment is always
96:19 - given by a user. And we connect it using the
ID. It's called a foreign key connection.
96:26 - Well, this ID, let's say it's the ID of 25.
Right? Well, instead of having, okay, this
96:35 - column, and it was by the person with the
name, with the user with the user ID of 25,
96:40 - we want to say, Caleb curry. So we have a
join, taking the name from the user table,
96:49 - and a plot and connecting it with the comment
of the comments table to get this new generated.
96:57 - Table. This is just a view. It's not actually
stored in the database like this, we're just
97:03 - creating a new illustration of how the data
really is stored. And then we can have the
97:07 - name of the person followed by the comments,
or comments of that person. You may be asking,
97:15 - why don't you just use the name as a reference?
Well, that's because many multiple people
97:20 - can have the same name, for example. So we
always need something that's unique for this
97:25 - connection. Whether if you don't want to use
an ID, you could use something like a natural
97:31 - key. Use your name, for example, but I often
use IDs. And we'll be talking about that more
97:37 - in upcoming videos. So yeah, that is all of
the vocabulary that we have gone over so far,
97:43 - pretty much. If you have any questions about
any of those, just leave a comment, I recommend
97:48 - that you write all those down, I should have
told you that at the beginning. But anyways,
97:52 - I recommend you write those down, as well
as the definitions, study those, learn them.
97:56 - And especially study from the previous video
study all these different terms that mean
98:01 - the same thing. Because after a while, you
get kind of used to those terms. But if you're
98:09 - just learning and you don't know that these
are talking about the same things, well, then
98:15 - you can get confused very easily. So I recommend
you study. Alright. A row is also called a
98:21 - tumble and is also called it whatever, blah,
blah, blah, that will help you that way. When
98:26 - I say whatever word it is, you know what I'm
talking about. And you don't have to like,
98:31 - check your charts or whatever, or go watch
other videos. So that's something I definitely
98:36 - recommend that you memorize, as well. For
the SQL stuff. It's not as important, like
98:42 - the DML DDL. But I do recommend that you memorize
all of these terms as well. We'll be talking
98:53 - about atomic values.
98:56 - So
98:58 - atomic values, basically just mean that means
that the value stores one thing.
99:14 - Everything we store in a database should be
one thing. When we have columns, they are
99:22 - about one thing. All of the values within
that column are one thing. We have a column
99:29 - named. Well, what does a name consist of,
you can have a first name, middle name and
99:35 - last name.
99:38 - Well, this,
99:43 - although we're talking about one thing and
name, it's not really necessarily atomic,
99:48 - because we're storing three names within one
name. So if we wanted to make this atomic,
99:56 - the best thing to do for database design would
be to break this up into first name, middle
100:03 - name, and last name. So now I have Caleb,
Daniel, through three separate names, right?
100:14 - Alright, so
100:15 - when we do store things and database we want
to go, we want to try and make them atomic.
100:25 - Now we don't want to go to the extreme, where
we break everything apart to where it doesn't
100:30 - even make any sense. But I just think of like,
atom, an atom atomic, when this word came
100:38 - about, we never really split an atom. So we
thought of an atom as the smallest, indivisible,
100:43 - into visible, I thinks the word piece of information
in this world. Now we can split it, but whatever,
100:53 - just so sometimes, you may think, Oh, this
isn't really a good term, but everyone will
100:58 - still use this term. So just think of atomic
as the smallest one, one individual thing
101:04 - stored. Now we don't want to go to the extreme.
For example, if we have the word, subscribe.
101:14 - This is a word, it's one word, don't go to
the extreme, where we separate it into like
101:20 - word like individual letters. because it'd
be ridiculous. It's like, Alright, we store
101:27 - in a table. Instead of having first name,
last name, we have first letter of the first
101:32 - name, second letter of this lab, first name,
third letter, the first name for further than
101:37 - first name. That doesn't make sense. We want
to break it down into we can treat it as one
101:44 - thing, for example, an error, a phone number,
it often has an area code. Well, we don't
101:51 - want to break a phone number up into multiple
portions, I often just store phone numbers
101:58 - as one, because you treat it as one thing.
When we come when it comes to addresses, one
102:05 - address consists of like multiple, we have
we have a street address,
102:15 - we have a city.
102:19 - And then we have a state, we have an area
code
102:23 - for a zip code I mean. So addresses, I often
break this up into multiple columns, rather
102:32 - than storing one address with 123. Epic lane.
legit California 73821. Rather than storing
102:52 - all of that, in one column, I break this up
into street address, city state
103:01 - area code.
103:04 - And then that allows us to run more complex
queries on our data because we can select
103:09 - all of the users from the state of California,
or we can select all of the users who live
103:17 - in this in this city, or pretty much anything
like that. So this is part of one of the normal
103:24 - forms, which we will be talking about in future.
But as for now, just think of storing everything
103:30 - as one. So not only do we want the column
to be about one thing, like an address is
103:39 - just an address, or a phone numbers, just
a phone number. But we want the values within
103:45 - that to be singular as well. For example,
we could have a column favorite movies. This
103:55 - isn't going to work, because within that column,
we could store unlimited movies. And that
104:02 - is also improper. So that's not going to work
as well, every single column header should
104:08 - be singular favorite movie. And you may be
asking, Well, how would you store multiple
104:15 - movies? Well, that has to do with more complex
relationships. And that is something we'll
104:21 - be talking about very shortly. But the solution
is not to store multiple things within a column.
104:33 - This video will be about relationships. And
I don't mean relationships as dating advice,
104:38 - because I probably couldn't give any of that.
104:41 - But
104:42 - besides that, we're going over database relationships.
So what is a relationship? Well, in a database,
104:50 - everything is connected. It's Think of it
like a giant web, somehow something is connected
104:54 - to something else rather than storing everything
in a giant table. Sorry, my what my boards
105:03 - kind of wet, it's not really writing very
well, we split that. And then we have two
105:09 - smaller tables for manageable data simplicity,
as well as data integrity reasons. So now,
105:19 - we still have to maintain the connection between
data. So we take one huge table, break it
105:25 - into two tables, and then we have what's known
as a relationship.
105:35 - There are multiple kinds of relationships.
And we'll be talking about that in the next
105:39 - video. But for this video, we'll be talking
about the general concept of relationships.
105:45 - So relationships, talk about entities, an
entity is anything we store data about. So
105:51 - this is an entity. And this is an entity.
And they are related in some way they're connected.
106:00 - There's a relationship between them. This
erasers scrap
106:08 - There we go. Okay,
106:13 - there we go. So now my chalkboards. Alright,
so I have to worry about entities. There's
106:29 - two terms that we talked about earlier. entities
and attributes, entities or anything we store
106:34 - data about. attributes are the things we store
about the data, well, when it comes to entities,
106:41 - when that attributes are what we store about
the entities, so basically, we have entities.
106:52 - And then we have the attributes for the entity,
right, and then we have a different entity
107:03 - so that as part of our database design, we
figure out all of the things we're storing
107:08 - data about, think of like a college, we could
store information about the student, the professor,
107:14 - the classes, the faculty, the whatever else.
So we're gonna have multiple entities, and
107:23 - then multiple attributes
107:25 - about
107:27 - that entity.
107:28 - And then we can have a third entity. So just
think club, student, Professor class. This
107:42 - is all part of our database, our database.
So our database structure consists of three
107:51 - entities and attributes about each one of
those entities. What's an example of an attribute?
107:56 - Well, it can be the student's name, the student's
address, the classes, they're taking, the,
108:04 - what, there, whatever, it doesn't really matter.
They're a major, that's another entity, we
108:08 - could have an entity about the the majors,
such as science, or whatever else. And then
108:13 - we can have attributes for that, like the
classes that are required to get that major,
108:20 - how long it takes, and so forth. That will
become part of our database
108:25 - structure. Well, these
108:27 - are still related in some way. Because we
have a student is a student is going to school
108:35 - for a major. So there's a connection from
this entity down to the major. So let's just
108:41 - replace these with like, here's student. And
then Okay, that looks like crap. I could have
108:54 - put some specific examples in here. We could
have a student we could have a professor sample
109:04 - proof, then we can have class. And then we
can have major. Well, a student goes to school
109:13 - to get a major, a student takes classes. The
classes are taught by a professor, the professor's
109:21 - typically have a specific area that they teach.
So they might be part of the major like the
109:30 - major league to teachers for that major. Whatever.
Students Yeah, you get the point, everything's
109:37 - connected. So when we design relationships,
that tells us how we want to structure our
109:42 - tables. That's going to make a lot more sense
in the next video. So I just wanted to introduce
109:48 - the idea of relationships in this video. The
next video we'll be talking about a specific
109:54 - kind of relationship.
109:59 - So,
110:02 - one
110:06 - to
110:07 - one, that is a type of relationship, there
are two other ones, one, to many, and many
110:22 - to many. Here are three types of relationships.
And we will be talking about each one of these
110:32 - individually, in the next three videos. This
one will be over one to one relationships.
110:46 - So I wonder one relationship
110:49 - basically just means that one entity has a
connection with one other entity. And that's
110:56 - all they can have. I like to think of a marriage.
So we have a husband and wife.
111:13 - This is a one to one relationship, because
a husband can have one wife, and that wife
111:19 - can have one husband, the husband can't have
multiple wives, and the why the wife can't
111:29 - have multiple husbands, it's one to one, because
one entity is limited to one other entity.
111:36 - This entity is also limited to one other entity,
if they want to one relationship. So another
111:43 - example of a one to one relationship would
be a social security number. Alright, so a
111:50 - social security number in America is basically
just a unique number every citizen is given.
111:56 - There are, I think there's occasional repeats,
although generally, you think of a social
112:02 - security number as being unique to one person.
So we define it as a one to one relationship.
112:10 - Even if there's possibilities of being repeated
data.
112:16 - One
112:17 - person only has one social security number.
Generally, that social security number is
112:22 - only supposed to have one person. So we have
a a person. And then we have a social security
112:31 - number. One person has one social security
number one social security number is assigned
112:38 - to one person, if you want to draw out your
relationships, you can say person as one social
112:48 - security number, social security number.
112:51 - assigned.
112:52 - I'm sorry, yeah. Okay, so assigned to one
person. So a person is assigned a social security
113:06 - number, social security number is assigned
to one person, we would not even though there's
113:11 - a possibility that the social security number
might be repeated. We want to design it this
113:16 - way. Because that's like saying, the social
security number is supposed to be assigned
113:23 - assigned to multiple people. It's not supposed
to it's supposed to be unique for the person.
113:28 - So we designed as a one to one relationship.
We're going to be talking about a one to many
113:35 - relationship in the next video and then a
many to many relationship. And after that,
113:39 - we'll be talking about how we design this
within a database. How do we structure our
113:43 - tables. So in the previous video, we talked
about a one to one relationship, that is one
113:54 - of the three kinds of relationships that we
can have. The other one is one too many. What
114:02 - that means is that one entity can have a relationship
with multiple other entities, but a specific
114:10 - entity can only be related back to one other
entity. I know that sounds a little confusing
114:17 - when confusing when we're talking about entities
and all this conceptual, high level thinking.
114:24 - But think of think of it like comment on a
website. When you go on to YouTube or whatever
114:33 - and you go below, you can leave a comment
on my videos. That comment is only owned by
114:42 - you. It has your has your name. That is a
one to many relationship. The reason for that
114:49 - is you can make many comments, but an individual
comment is only owned by one person. So to
114:58 - draw that out, you have I have a user. And
we have multiple comments. You can see that
115:24 - the user is able to make multiple comments.
But each individual comment, like this one,
115:30 - for example, is only owned by one user, that
is a one to many relationship, or
115:41 - one coin, many.
115:42 - Can you see that? Yeah, I think you can. So
this is how a one to many relationship works.
115:49 - If you want to think of, again, like the marriage
thing. Think of a king, what his name him
115:57 - king, Sam. And Sam demands to have multiple
wives, and he's super controlling of his wives.
116:07 - So Sam has multiple wives, right. So I'm just
kind of dry on a chalkboard here. We have
116:14 - Sam the king over here.
116:16 - Give him a crown,
116:20 - give him a big smile. And he is royal and
famous among the lions. And he's really selfish
116:29 - with this woman, he demands to have 500 wives,
or however many wives he desires. So we have
116:40 - all of his wives over here.
116:49 - So he has these two wives, and then he has
this wife over here. She's not so good looking.
117:00 - But anyways, he is married to these three
wives. Although he's very, he's very protective
117:07 - and very selfish with his women. And he does
not want these wives to marry other men. He
117:14 - they're strictly married to the king. So the
king can marry multiple women. But each woman
117:25 - can only marry one person. Oops, I kind of
already have the line drawn, drawn. So they
117:31 - can only marry one person, they're not able
to go marry another guy, that would be a whole
117:39 - nother way that ain't gonna happen off with
their heads. See what I'm saying? It's not
117:43 - going to work. So that is a one to many relationship.
In the last video, we talked about one to
117:54 - many relationships, the video about that we
talked about one to one relationships. Well,
117:59 - now we're talking about the third possibility
of relationships. And that is many to many
118:04 - relationships. So when I think of many to
many relationships, I like to think of a polygamous
118:10 - marriage, where multiple husbands can have
multiple wives. And multiple wives can have
118:16 - multiple husbands. I just draw this out. So
you can kind of understand what this would
118:21 - be like. We have the king right here, right?
So let's say he's a king, and he decides to
118:33 - marry three women.
118:35 - Let's kind of make up real quick.
118:42 - This guy's
118:43 - Why do you need three wives? Come on?
118:47 - There we go.
118:49 - So this guy is married to these three women,
right? And then he is very protective. But
118:55 - then he decides Oh, what the heck, they can
marry different men if they want. who really
118:59 - cares. So this girl marries this other guy,
right? So now she's married to two people.
119:06 - Right? What's wrong, sir?
119:11 - Only the king can do that. Well, not now.
Because it's a one to many relationship. One
119:16 - King can marry multiple women. And one woman
can marry multiple men. So this guy is married
119:25 - to this girl. And this girl is married to
this guy over here. And this guy's married
119:30 - to this girl over here. So Sally is married
to Jim, who is also married to this girl
119:38 - over here.
119:39 - See my hand drawn here.
119:42 - And this girl, surprisingly, is married to
this guy. She's married to Kathy who is also
119:53 - married to Jim. And by the way, Jim is married
to the second wife of the king, who the king
119:59 - is Mary did this girl over here. And you see,
well, it gets very complex very quickly. And
120:05 - that is an example of a many to many relationship.
120:09 - Now, obviously, you're
120:10 - not going to be storing, like, stuff like
this in a database. So let me think of a practical
120:17 - example real quick. I can think of a college,
specifically a class, and an instructor. Alright.
120:28 - So that's it, let's think of a class and a
student. So here's a class. And here is a
120:37 - student.
120:39 - Okay.
120:40 - Now, one class, how many students can be in
a class multiple, you know that. So we can
120:50 - have multiple students in this class. Let's
draw boxes for quicker. So let's say all these
120:56 - boxes are students. A class can have multiple
students. Well, not only that, but a student
121:06 - can take multiple classes. So this student
can take this class. And this class can be
121:12 - taken also by that student, and this student
over here. And this student can take another
121:18 - class, which can have this guy in it, and
this guy, and this guy can be in this class
121:25 - as well. And by the way, he is also a drama
jock. He is also taking another class, if
121:31 - he's in that class, which has that student
and that student, and it just gets very complex.
121:36 - So you can see this might be very, very difficult
to store within a relational database. And
121:40 - there are reasons we actually can't store
this in a relational database. You might be
121:46 - thinking, well, what if you need to store
the classes that a student is taking in this
121:51 - students within a class, we will be talking
about in the up that in the upcoming videos,
121:56 - with solving many to many problems, many to
many relationships do not work in a relational
122:03 - database, the only two that will work is a
one to one and a one to many relationship.
122:09 - But this is just the concept, you think of
a concept of a many to many relationship,
122:14 - think of a class and a student class can take
many can have many students and a student
122:20 - can take many classes. In the last three videos,
we talked about one to one relationships,
122:30 - one to many relationships, and one to many
to many relationships. This video, I wanted
122:36 - to talk about how we design these relationships,
I decided I was going to break them up into
122:43 - three videos. So first, we'll be talking about
designing one to one relationships, and then
122:48 - one to many, and then many to many. So this
video will be about designing one to one relationships
122:56 - in a database. Alright, let's begin. So the
first thing we need to realize is that when
123:04 - we have a one to one relationship, the the
attribute side, so we have an entity. So let's
123:13 - say let's just say we have a connection between
a person and their, their username. Alright.
123:22 - So we have this, we have this guy here, let
me get rid of these boxes. I don't mean this.
123:27 - We have this guy. And he has a username on
a website, we'll just say it's Caleb curry,
123:35 - because that's usually my username for things.
And we'll just name this guy. Right? Well,
123:40 - that username, the only person who's going
to have that username is him. And he is only
123:46 - going to have one username, that account is
only going to have one username. That's a
123:53 - one to one relationship. So we need to realize
that this is exclusive to this person. It's
124:01 - all hits, no one else owns it, no one else
is connected to it. It's only hits. So that
124:07 - means we can often store one to one relationships
as attributes rather than entities. So rather
124:16 - than his username being an entity, it's an
attribute. If you don't really know what that
124:23 - means, don't worry, I'll be explaining in
just a second. But just think of it as it's
124:28 - exclusively his so that is part it describes
him. What is this guy's username? It's Caleb
124:37 - curry. It's an attribute of that person. When
we're talking about one to many relationships,
124:44 - though, are many too many. We think of like
a class. The students of the class are not
124:51 - exclusive to that class. They can take other
classes. Therefore it wouldn't really make
124:56 - sense to store them as attributes because
it's not Really, it just doesn't make much
125:03 - sense. And I know, it'll, it'll be clear,
so just Just wait a second. So we can actually
125:09 - have a table. The relationship between the
account and the username of the account can
125:20 - be stored just as a column within the table.
So we have an ID. And then we have a name,
125:27 - for example. And then a username. This username
is exclusive to this ID of this person. So
125:41 - like six,
125:43 - Caleb,
125:44 - Caleb curry, that is how we would design a
one to one relationship, we would put it within
125:53 - the same table. If we have a new row, within
our table, we now have a new person, this
126:03 - person can't have another username that Caleb
curry, they have to have a different one.
126:07 - So we can make it john 123.
126:12 - This name is exclusive to that person. So
we just store it as a column within our table.
126:20 - Make sense? So here are our individual rows.
This points to this ID, it's an individual
126:30 - entity. So the entity is the the account,
the user name is an attribute to that an account,
126:37 - there will be occasional times when we store
a one to one relationship over multiple tables.
126:44 - And I will explain now when that would be
the case, let's just think of an example of
126:49 - a database for a credit card company, we have
a relationship between the card holder and
126:56 - the card. By card holder, I just mean the
person who who gets the card and can use it
127:08 - to buy things, the person who owns it pretty
much. And then we have the card. All right.
127:16 - Now let's just say this, this company only
allows you to have one credit card. So this
127:23 - card holder can only have one card, and this
card can only be owned by one card holder.
127:32 - That means we have a one to one relationship,
one to one, how would we store this in a database?
127:38 - Well, if we just went with the attribute thing
that we talked about earlier, here's what
127:43 - it would look like. Here's our table. And
I'm just going to list the columns. So we
127:48 - have the cardholder table. First thing is
we'd have like a an ID for the card holder,
127:58 - we would have probably card holders first
name, the card holders last name, and then
128:05 - we would have the card. So we could say, well,
that's their card, we could let's say we could
128:12 - assign every card and ID or a card number.
So we can say card number. If they have a
128:23 - card, we can give it a value if if they don't
have a card, we can leave it No. Well, that
128:30 - can be considered an attribute of the card
holder. Because all these points back to the
128:37 - cardboard. Now, if we want to store more information
about the card, such as the the issue date
128:48 - when the card was given to the person, so
we could say, card issue. date. Well, now
128:58 - we can see that this is relying on the card,
not the cardholder. So if we want to store
129:05 - extra attributes, about the attribute in the
one to one relationship, we can move that
129:12 - to a new table. And we can make it a card
table, give it an ID. And then we can say
129:20 - card number
129:27 - and then issue date.
129:30 - Now we can store as much information about
this card. So if we want to store the maximum
129:35 - out, be a late fee. Pretty much anything we
want to store about this card can be stored
129:43 - in this table. And we can replace this card
number with a reference. So I'm going to card
129:52 - ID and that points back to this ID. You see
what I'm saying? This is a one to one relationship
130:01 - over multiple people, just like this card
has a connection to the card
130:07 - holder.
130:09 - There's a one to one connection over multiple
tables. The reason we did this is so it could
130:15 - store more information about the card. Because
if we stored it all in one table, we would
130:21 - have bad database design. And I'll show you
why. in just a sec.
130:31 - Alright, so
130:36 - here's our table.
130:37 - Can you see that, all right, we have the ID
and then the name of the person. And then
130:44 - we have the card number, and then the max
amount, and so forth. Well, you can see that
130:55 - this table is really about two things, it's
no longer about one thing, we would have to
131:01 - say this is a user and card table, which is
not proper, because we're not following the
131:09 - rule of one where a table should be about
one entity. And a row should be about one
131:15 - entity. Because now we have the user side,
and then we have the cards, it's like trying
131:23 - to store two tables. In one, the only time
it's acceptable to have the card number in
131:32 - the users table is when we don't store more
information about it. Because now all we have
131:38 - is a card number. The card number is about
the user and points to the user. But the max
131:47 - amount of the card has nothing to do with
the user, therefore, it's reliant, dependent
131:54 - upon the card. So I wonder one relationship,
in conclusion, one, a one to one relationship.
132:10 - The way it is stored is either
132:17 - an attribute
132:22 - within the table, or if you need to store
more information about the entity, then we
132:27 - can have another table and then just use foreign
keys to connect them which that's something
132:35 - we'll be talking about in an upcoming video.
Almost always though, you will be seeing a
132:45 - one to one relationship, used as an attribute.
So when you think if you have a one to one
132:51 - relationship between something, you have a
connection, let's say it's a dating website,
132:56 - the user is in a relationship with another
user, that that's a one to one relationship,
133:03 - we could just have that as a column within
our user table.
133:10 - So we could have
133:13 - the user table, we could have the user ID,
and the name, first name, last name, a phone
133:23 - number, whatever else. And then we can say,
relationship. That's a one to one relationship,
133:33 - we could just have that have that be an ID
of another person. And we don't have to worry
133:38 - about having another table for that. This
video, we're talking about designing one to
133:46 - many relationships. First, I want to bring
back an example from the last video into this
133:52 - video. So we can kind of explain the differences
between one to one and one to many. So in
133:58 - the last example, we had a credit card company
where a person is allowed to have only one
134:05 - card and a one card can only be owned by one
person. Let's draw that out. We'll just draw
134:14 - the table and the columns within that table.
So two tables here, we have the user table.
134:23 - And then we have the card table. This is when
we store a one to one relationship over multiple
134:30 - tables. Otherwise, we could just store it
as a column because I mean, we're only storing
134:35 - one thing. We have the user ID. And then we
have a card ID. And then to connect these
134:49 - as a one to one relationship. We have a foreign
key. So we put a connection card ID in the
134:56 - user table, the user ID in the card table.
So Alright, ID, user ID, that means that what
135:07 - that does is it connects these tables. So
user ID to this user ID, card ID to this card
135:12 - ID, that is how we would make a one to one
relationship over to tables. And then we can
135:18 - store other stuff about the user in this table,
other stuff about the card in this table.
135:24 - Now, to convert this to a one to many,
135:29 - we can change this to something very small.
And one to many relationship would be saying,
135:35 - one user can have many cards, but a card specific
card can only be owned by one user. So there's
135:45 - no card can't be owned, or co signed or owned
by two people. Now, the way we do this, is
135:53 - let me just erase these columns real quick.
135:57 - As a start from scratch.
136:04 - So we have a user table, and then we have
a court ID. Once again, we need IDs for both
136:08 - of them. So we have a user ID, and then a
card by the user owns multiple cards. And
136:20 - we don't know how many they own there, they
can have one, they can have two, they could
136:23 - have three, they could have four, they could
have five, so it wouldn't make sense to put
136:28 - the card ID in here as multiple columns. Because
I would put five columns for card ID, well,
136:33 - then what if someone had six cards? What are
they going to do? They're not, they're not
136:37 - going to have a sixth one. So what we do is
we put the user ID in the card table, which
136:49 - points back to the user, I d in this table.
So now, if we made specific examples of this,
136:57 - let's say we had this guy here,
137:00 - giving a talk. Right.
137:05 - So we've got this guy right here. And his
user ID is 63, just a random generated number
137:16 - by the database. Well, we also have cards
over here. So we have this credit card, we
137:24 - have this credit card, we're actually drawing
card cards here. So we had the barcode and
137:30 - the name and the codes and all that crap.
And then we have this card over here.
137:34 - We make a connection,
137:37 - we want all of these to point back to this
guy. So we give a user ID, we could say the
137:44 - user id 6363 63. So now we know that each
card is owned by the user with the ID of 63,
137:55 - which we can figure out is this guy, whatever
his name is, we can join that. So now we store
138:01 - a one to many relationship into tables, where
the many side gets a foreign key to the single
138:13 - the one side. And if you don't know about
foreign keys, that's fine, basically, in simple
138:18 - terms of foreign key is just that that Id
connection is user ID is a foreign key that
138:26 - points to the user ID in the main table, foreign
key points to the primary key and the primary
138:35 - table. This is also said to be a child. I'm
sorry, a parent child relationship. This will
138:44 - be the parent because every single child has
to point back to the parent. That is how we
138:50 - store a one to many relationship in a database.
So how would we know if we had this example?
139:04 - We had comments, the comments section on a
shopping website. So you're allowed to leave
139:10 - a review there. Let's say you can leave a
review. And we had this table these this table
139:15 - setup. We had the users. And then we had the
reviews. And we had a an ID user ID. And then
139:29 - we had a review ID. I just give that to every
single table. Every day I give every table
139:34 - an ID. Then we have the username. And then
we have the actual review. So the user has
139:49 - a username, the review has the actual comment.
And we could also say we could say we have
139:55 - a review title. So we can say like oh This
review is this Product sucks, or this product
140:01 - is really awesome. And then we can have a
paragraph saying, why that products awesome,
140:06 - for example.
140:08 - Right now,
140:09 - this is not properly designed, because there's
no connection between the user and the review.
140:15 - Because if we look at the review table, who
put who posted the review, it doesn't say
140:21 - all we have is the review ID, the review and
the review title. It doesn't say who posted
140:28 - it. So if we put a key foreign key that points
back to the user table, that would say that
140:35 - is the parent, the person who posted that
review. So we can have a user ID, which points
140:44 - back to the user ID in the primary table?
Is this a one to one relationship? Or is this
140:52 - a one to many relationship? Well, this, we
could have multiple reviews, and each one
140:59 - would point back. So we could have a another
review by and we can have the same ID. Let's
141:06 - just think of some examples. Let's say we
have the review ID of six. And then the review
141:13 - is awesome, are
141:15 - good.
141:16 - And it's by the user ID of 62. Well, then
we could have another one with a review ID
141:26 - of seven. And it could say, Great. And then
we can add it from the user, Id 62. Well,
141:36 - these are both from the user id 62. So we
can say this is a one to many relationship,
141:41 - because multiple reviews going back to one
user, if we want to wanted it. So a user can
141:47 - only post one review, well, then we need to
put the review ID in the user table. So now
141:59 - we have this sort of like this double connection
142:01 - thing here.
142:08 - Because this review ID connects it. So it's
saying only one review ID can be from the
142:17 - user. And honestly, this, this can probably
be improved, because the review is not necessarily
142:27 - connected to the user that directly. For example,
if the website is solely forgiving, one review,
142:36 - well, then we could give it a review ID. But
that might not be the best example, simply
142:43 - because the user might buy multiple products.
And each review could have a product ID easy.
142:56 - So I mean, it kind of gets complex and just
kind of have to study. But the review, it
143:03 - would probably be best to make it a one to
many relationship, because it wouldn't really
143:10 - make sense to have it as a one to one relationship.
We want it as a one to many, because multiple
143:16 - reviews for multiple products can be given.
So this points to a product, this points to
143:25 - a product, this points to a product, and they're
all by a specific user. Alright, so yeah,
143:33 - that's just some basic design concepts that
you will need to understand. When you have
143:38 - a one to many relationship, just store over
two tables, and give a foreign key to the
143:46 - many side pointing back to the one side. Before
we start the many to many relationship design,
143:56 - I wanted to talk about Parent Child relationships.
So we have when we design these relationships,
144:04 - a table is always the parent and a table is
always the child. And when we're talking about
144:11 - keys, keys keep things unique. And they always
they're they're used to connect tables that
144:18 - are related. So every t table has a key that
keeps it unique. When we create a foreign
144:25 - key, it references that primary key in a another
table. So the primary key is the parent. The
144:38 - foreign key is the child. The child points
back to the parent inherits the values from
144:51 - the parent. For example, the parents ID is
a six then the foreign key pointing back to
145:00 - The parent is at six, the job. So in a one
in a one to one relationship, where we just
145:07 - store everything in one table, which is the
most practical
145:09 - way to do things, we don't
145:11 - have to worry about primary keys or foreign
keys, we just have one table. And that's all
145:16 - we have, they only have columns within this
table. So we have the user ID, the password,
145:23 - the username, the whatever else. All those
are just columns within a table, we don't
145:28 - have to worry about a parent or child, because
they're not making any relationships across
145:35 - multiple tables. But when we get to one to
many, that's when we have this table pointing.
145:42 - Or has many children. So you would say this
is the one side it's the parents. Then we
145:55 - have each of the parents children. These all
point back to the parent with a
146:05 - foreign key.
146:10 - So if you think of like comments on a YouTube
video, every comment has a poster or a user
146:18 - account of a person who clicked post a comment.
That means that the commenter is the parent,
146:29 - and the comment is the child. Another way
to think about that is if you if you were
146:38 - given a comment on YouTube, you can figure
out who posted that comment. That's because
146:45 - the child always points back to the parent.
Now, if you look at a user account on YouTube,
146:53 - such as Caleb, the video maker to awesome
channel, check it out, and be sure to subscribe.
146:57 - Well, you don't necessarily know every single
comment that that parent has given, there
147:04 - might be a feed in there that says recent
comments.
147:08 - But
147:09 - when we look at the
147:10 - child, we always know the parent because it
inherits
147:13 - the values.
147:14 - But the parent doesn't inherit anything from
the child. Think of like in real life, you
147:22 - can see a married couple,
147:25 - and
147:26 - you don't know if they have children or not.
But if you see a little baby, we think, all
147:33 - right, that baby has a parent or parents.
That's the similar idea with database design.
147:42 - Think of this wall here between the parent
and the children.
147:49 - The children
147:50 - inherit values from the parent such as the
foreign key, a seven, that tells us who the
147:58 - parent is. That is important. I know, it seems
like okay, who really cares, who's the parent
148:05 - or child, just get on with the database design,
you knew, I'm going to unsubscribe? Well,
148:10 - this is important, because when we get to
understanding how to design each relationship,
148:16 - we need to understand where we put the foreign
key, which table does the foreign key go into.
148:24 - that is decided by the child because the child
always has the foreign key that points back
148:30 - to the primary key. So user ID, primary key,
user ID, foreign key points back to the primary
148:40 - key user ID. So foreign keys always go in
the children, primary keys go in the parent.
148:47 - When it comes to many, to many relationships,
we have problems with Parent Child relationships.
148:54 - And that is why we can't store many to many
relationships in a database. And that's what
149:00 - we're going to talk about in the next video
when we talk about many to many relationships,
149:05 - specifically. But just know that when we have
an entity, think I want you to think of whether
149:13 - or not it would have a parent, a lot of the
times it would but other times not so much.
149:19 - But if you think of think of an order for
a store, an order needs a parent, because
149:29 - an order is when you buy product who is buying
it, someone has to buy it. Otherwise it wouldn't.
149:39 - It wouldn't exist, the child would not exist
without the order. So let's let's relook at
149:45 - this.
149:46 - This
149:47 - is the user and this is the orders. We can't
have a child without a parent logically, it
149:53 - just doesn't make sense. So if there's no
parent of the order, the order cannot exist.
150:00 - First, we need to keep that connection. And
order needs someone who bought that order.
150:08 - Hopefully, that's kind of making sense. So
just keep in mind, parent child relationships.
150:15 - I'm not trying to repeat myself, but I'm trying
to repeat myself. So you get destroyed in
150:19 - your brain, foreign key goes on the child,
primary key goes on the parent. And soon we'll
150:25 - be talking more in depth about keys. So just
for now, memorize primary key and foreign
150:30 - key primary is the user ID. The foreign key
is a reference to that user ID. It's in a
150:39 - foreign table, and it points back to the original
table. This video will be about many to many
150:49 - relationships. Oh, and we're talking about
designing many to many relationships. So I
150:57 - said a couple of weeks ago, videos ago that
we have problems when we design many to many
151:03 - relationships. They don't work out, right?
They don't. And I mean, I never really explained
151:08 - why. Well, this video, I'm going to explain
why. Think of, let's think of a good example,
151:16 - a college class can have many students and
a student can have many classes. So we have
151:22 - two entities we have to worry about.
151:24 - We have a
151:27 - class.
151:28 - Let's just pluralize it because it makes more
sense, the classes, and then the
151:34 - students.
151:39 - So let's just think of an example of a way
we would try to treat we would try to design
151:46 - this, and it's not gonna work out, right,
but we'll just we'll just try. Here we have
151:53 - classes table, and we have a specific class
such as math, math, 101, whatever, really.
152:06 - So we have Matt, we can't even read that my
handwriting is so bad. So we have math one
152:11 - on one. And then we list all of the people
within this class. So we have student number
152:17 - one. And then student number two. And then
student number three. All right, well, we
152:26 - can try that. Except, what if a student drops
out? Well, then we have a null value, which
152:34 - we don't want to have those if possible. And
what if we need four students? Well, that's
152:39 - not going to work because we only have three
columns. So how else can we do it? Well, we
152:45 - can try just having students. Well, then every
single column could have like 100 students,
152:52 - and we already learned about the atomic rule,
we only want one column to store one value
152:58 - one student. So what do we do? Well, okay,
that's not gonna work. Let's try over here.
153:04 - Let's try it on the student side. We have
a table for students. So we have Jimmy, and
153:13 - he's taking his first. Alright, let's let's
list the columns. So we have the name. And
153:20 - then we have class number one. And then we
have class number two. And then we have class
153:26 - number three. Well, that's cool. What if he
wants to take four classes, though? Well,
153:31 - then we have to add a new column. And let's
say someone psycho crazy guy takes like 20
153:36 - classes. So now we have all the way down to
class 20. And then a new person comes to the
153:43 - school. And he only takes one class. So now
his first class is like math. And then there's
153:49 - 19 columns for that guy who are empty, because
we have to half the columns for every single
153:55 - person. We think of it like this, we drew
that out. So where you can see it better,
154:00 - we would have a table. And then we'd have
the ID of the person. And then the classes.
154:07 - So once puts like class one, class two, class
three, class four plus five, six. Let's just
154:14 - leave it at that. And we'll just kind of make
rows for these. We have new guys sign up.
154:22 - So we have a guy with the ID of six. And his
first class is math. Right? And then his second
154:30 - classes, geology and then Spanish, and then
fashion.
154:36 - And then
154:40 - biology and then chemistry. And then we have
a new guy come and he his IDs, eight, and
154:49 - he only takes science right? Well now we have
no No, no empty nothing. We wasted all of
155:02 - this space. And you can assume that's going
to keep happening. So that's wasted space
155:08 - in our database, bad design. So how do we
possibly do? Well, the trick is, because because
155:19 - we think of if we try to think of like parent
children, who's the parent in this situation?
155:25 - Well, a class has multiple students. So that
would make the class the parent and the students,
155:31 - the children, but a student can have multiple
classes. So that would make the student the
155:38 - parent and the classes the children. So how
is it that this is the parent, and this is
155:43 - the parent at the same time,
155:46 - that means
155:47 - this points to a child. And this points to
a child. So this parent is the parent of this
155:52 - parent who is also the child of this child,
which that just like blew my mind, I don't
155:58 - even know what's going on. So the way we do
this, is we break it up into two, one to many
156:06 - relationships. So this many to many, is going
to become a one to many. And then a second,
156:17 - I think, I guess all right. Okay, just for
you guys, as information, these these colon
156:27 - things, I think the correct way to do that
is many two, and four, like the like the end
156:35 - keep going on. Just don't don't worry about
that. We'll talk about that. in upcoming videos,
156:41 - I'll just write that for my sake. So we're
going to break this up into one many. And
156:49 - then another one too many. But the other way.
So that is how we fix that problem. All right.
157:00 - So let's implement that with classes. And
students. What we need is what's known as
157:10 - an intermediary table, or a junction
157:13 - table,
157:14 - they're both the same thing. I'll write that
out. So you can hear me enter mediary or a
157:25 - junction. There's also like 50, other names
for this table, but I mean, just intermediary
157:31 - table will work fine. So I n t e r m e d ay
ay ay ay er y. And what that is, that is how
157:40 - we connect our tables. So we break this up
into a total of three tables. So we have the
157:50 - intermediary table, which is the one I just
talked about. And then we have the students
157:55 - table. And then we have the class table. So
class, student, this is the intermediary table.
158:05 - So we have a one to many relationship going
this way. And then we have a one to many relationship
158:11 - going this way. So one,
158:13 - many,
158:14 - one, to many. I know that seems a little confusing
at first, but trust me, it'll make sense.
158:24 - Once we start explaining things more. So we
have one to many, one to many. And this is
158:31 - the intermediary table. So let's just draw
this connection. So we kind of make can visualize
158:42 - this a little more. And kind of, like split
this to see how it works. So we're storing
158:49 - the many side of both relationships in one
table. That's because we know that a one to
158:54 - many relationship is spread out over two tables.
So one, to one, to the to, it's being shared.
159:06 - So what would we name is, we would say like,
we can name it. class students, for example.
159:14 - And 
these are going to have foreign keys that
159:23 - point back to the class and the students.
So now that we kind of understand what it
159:28 - looks like when we draw it, let's give specific
examples to illustrate this. Actually, like
159:36 - what it would work like look like whatever.
Alright, so let's say we have our classes
159:44 - over here. And our students over here, okay,
so
159:53 - first things first.
159:56 - We have metaphor, just keep it simple math.
Science, I mean, obviously, the more in depth
160:02 - like math 101, math, two of
160:04 - five, or
160:05 - 1200, or whatever. And then we have English.
But just for simplicity sake, let's say these
160:12 - are the only three classes in the college.
Alright? Then we have all of our, our students,
160:18 - we have Caleb, we have celeb, we have calib.
And then we have, man, I'm so conceited, all
160:30 - I ever talked about is myself. Alright,
160:32 - let's get rid of my name.
160:34 - Let's go with
160:36 - Johnny, and Jake, and Sally,
160:39 - and Claire, Claire.
160:41 - Alright, so here are all of our students for
our class.
160:53 - classes,
160:55 - students,
160:58 - we connect these in the middle. So first things
first, we give them all an ID, because that
161:04 - will be our primary key. So we'll just give
these random Assigned Numbers, which is pretty
161:09 - much what a primary key is a surrogate primary
key. So we'll get this 163, this is something
161:16 - our database would do for us. This one will
be 75. And this one will be
161:21 - 89.
161:22 - So you guys can see that clearly, we'll do
the same thing over here. So john will have
161:28 - the ID of eight. Jake, the id 17. Sally, the
ID of 16. And Claire, the ID for just getting
161:38 - 666. Because she's 666. I'm just kidding,
we'll just we'll just go with
161:46 - six.
161:47 - Now we use the intermediary table to connect
these IDs. So we have this table here. We
161:57 - have two columns. We have the class ID. And
then we have the user ID. And then if you
162:11 - wanted to title these tables, we can make
it classes, class students and students, the
162:18 - intermediary table, what an intermediary is,
it's something that connects two things, it's
162:25 - like, it allows this table to talk to that
table. So it's a connection between these
162:33 - two tables. We put the ID of the user with
the class that they're taking. So let's say
162:40 - john is taking English in science, we would
have 875 889, right really big, I'm going
162:50 - to run out of room really quickly. And what
this does, is using this intermediary table,
162:58 - we can figure out that all of these user IDs
point back to a specific person. And these
163:08 - IDs point back to a specific class. We are
not repeating data, because we need to know
163:18 - the user have this class ID This is a foreign
key pointing back to one specific value. So
163:26 - that means if john decided to drop out, well,
then we have foreign key constraints to get
163:33 - rid of these. That way, we don't have to worry
about incorrect data or users. I guess, I'm
163:40 - sorry, this should be like students, sorry.
But we don't have to worry about students
163:49 - who
163:50 - we don't have to worry about students being
enrolled who don't exist. So that is the solution
163:56 - to in many to many relationship. This video
is getting really long. So Sally could do
164:01 - the same thing. We could say 16. And then
75. She's taken science, Claire, she's taken
164:09 - a she's taken math. We keep going on if we
really wanted to, like can make this table
164:17 - as big as we wanted. And basically this is
the easiest, best way to use as much databasing
164:25 - resources storage as possible, as well is
now we solved the many, I'm sorry, the parent
164:33 - child relationships. That's because we have
the parent over here. We also have the parent
164:40 - over here. They point to the child table.
So this child table becomes the child of both
164:50 - of these parents. Sort of how in real life
every single person is two
164:55 - parents and
164:58 - the person is this in Tire the row mean, okay?
applying that to this, the parent is the class
165:08 - and the student of the class, and the child
is a row where we have both the class and
165:15 - the student, this right here needs to be unique.
It's an individual child, we can't have 663.
165:24 - Again, because that's saying, Claire is taking
science and Claire,
165:30 - I'm sorry, math,
165:32 - Claire's, taking math, and player is taking
math, that doesn't make sense. So this right
165:38 - here is unique 63 to six, you can have it
in there twice. So the child is an individual
165:46 - connection between the parent and the other
parent. So that is how you properly store
165:52 - many to many relationships. And I know the
all these relationships are kind of complex,
165:57 - and you don't really understand with like
a stupid chalkboard. But like I said, we will
166:01 - be getting into on screen computer videos
and the introduction. I mean, I said that
166:08 - in the introduction, we're not going to do
that introduction, because that wouldn't make
166:11 - sense. So yeah, we will be explaining these
concepts. And then we will be applying these
166:17 - concepts to actual databases. Once we get
through all of the database concepts. This
166:27 - video will be a summary of all of the relationship
garbage that we learned. And basically, this
166:32 - video is going to be like, all of it in one,
and it's going to be awesome. And it's going
166:37 - to make a whole lot more sense after this.
So the very first thing that you need to realize
166:42 - when it comes to relationships, is that there's
not always a defined relationship for every
166:49 - circumstance. And it's sometimes you have,
it's something that you have to decide on
166:56 - your own. So my old database design series,
which if you want to check that out, just
167:00 - go to my YouTube channel. A lot of people
were confused about, okay, is a student to
167:07 - class? Is that a one to one or one to many
or a many to many relationship? Well, that's
167:12 - something that you're actually gonna have
to decide on your own. Sometimes you have
167:16 - to think logically about the application of
the relationship. So let's think of the example
167:25 - of a class and a professor. What kind of relationship
is that? I don't know. Let's try to find out.
167:33 - So we have the class. And then we have the
professor. People would ask me, like, Okay,
167:43 - what kind of relationship is this? Well, it
depends on the application. If it's me, it
167:49 - can literally be all three, it just depends
on what you need for your application. If
167:55 - it's a one to one relationship, that means
a class can be taught by one professor, and
168:01 - a professor can teach one class. If it's a
one to many relationship. That means either
168:07 - a class can be taught by one professor, and
a professor can teach many classes, or the
168:13 - opposite of class can be taught by many professors.
But a professor can teach only one class.
168:20 - Or it can be many to many relationship, a
professor can teach multiple classes that
168:24 - can be taught by multiple professors. So it
depends on the college because some colleges
168:30 - are going to allow the class to be taught
by multiple professors, other colleges are
168:35 - not going to allow that. So that depends on
the application of the database. If I'm building
168:41 - a database for a college that does allow multiple
professors for a class, that means it's a
168:47 - many to many relationship, because many professors
teach many classes. Many classes are taught
168:53 - by many professors. Right? So when it comes
to designing one to one, one, to many, and
169:00 - many to many, I'll show you how to do all
three of those for a class to Professor. So
169:06 - if we have one to one we could have, for example,
we could have the professor
169:13 - right. We're
169:14 - gonna have a professor table only know how
to spell it. But prof is I don't know if there's
169:21 - two F's, who cares, Professor table, right?
If it's a one to one relationship, we can
169:27 - have the professor ID, the name of the professor.
And then we can have a class. That's the class
169:36 - that they teach. And it's the only class that
they teach. That class is only taught by the
169:40 - head professor. That was, that's how you store
one to one relationship. And typically, you're
169:45 - not going to do that with another entity.
When it's when it comes to like a name. You
169:50 - typically will do that because the name is
just assigned to that person. A class can
169:56 - generally I mean, typically professors can
teach multiple classes unless you're some
169:59 - Kind of adjunct teacher, but class, in this
case is a one to one relationship. If we wanted
170:08 - to make it a one to many relationship, or
then we would break off class here, get a
170:15 - new table class, we have a class ID. and here
we can put more information about the class
170:23 - and we'd have the class name. This is the
most common way of storing information on
170:29 - two tables. You rarely very rarely store a
one to one relationship over multiple tables,
170:35 - but it is possible we talked about that earlier,
we'd have class name, and then we can have
170:39 - more information about the class. And then
we have a foreign key class ID, that would
170:48 - make this the parent because class ID points
to class ID, if you wanted this to be the
170:57 - parent, well, then we would switch that we
would make
171:02 - Professor
171:04 - ID,
171:06 - which was probably the most logical way to
do that. But you have to keep that in mind
171:11 - because it can be a one to many directions,
a one to many this direction, or can be a
171:18 - one to many this direction. And obviously,
typically, the class is going to be the many
171:28 - side because a class can be taught by multiple,
I mean a professor teach multiple classes.
171:35 - That means that professors on the one side
that many is the class, which means we need
171:40 - to give the professor ID on this side. So
the proof ID is a foreign key, referencing
171:50 - the proof ID in the professor's table. That
is how you draw a one to many relationship.
171:59 - This direction one to me, parent child. Now
if we wanted to make that in many to many
172:04 - relationship, we'd actually had to break this
up even farther into three tables. So now
172:11 - we have the professor's table. And then we
have the class table. And then we have the
172:20 - probably class professors table, which is
the intermediate intermediary table.
172:27 - So we have
172:28 - this table here. This table here, this table
here, this, these all, this will have an ID,
172:38 - Professor ID, and this will have an ID, class
ID. Then you reference this in this intermediary
172:48 - table, where we'd have Professor ID of like
six with the class of seven, Professor ID
172:54 - of six, with the class of eight, which is
basically saying this professor with the ID
172:59 - of six is teaching two classes. Now, when
it comes to IDs for this table, this whole
173:07 - thing can be an ID in itself. Or if you want,
you can give it a new ID to say class Professor
173:14 - ID. And that's kind of unrelated. So that's
pretty much we'll get into that later. But
173:21 - that is pretty much the song of designing
relationships. One to One is typically in
173:28 - one table, one to many, it's two tables with
the child having a foreign key pointing to
173:32 - the parent, and then a many to many has to
parents, with the intermediary being the child
173:41 - pointing back to both of the parents. Hopefully,
that is all crystal clear. And awesome. Because
173:48 - now you literally know how to design every
binary relationship and database design. And
173:56 - by binary, I mean a relationship between two
tables. So you can have a binary relationship
174:05 - which we talked about, there's one to one
over two tables, there's one to many over
174:08 - two tables, and there's many to many over
two tables logically, but then we have to
174:13 - break those up into the best way to store
those to store those in a database. But this
174:20 - is basically binary because we're talking
about two entities. A class and a professor,
174:29 - a student and a class. You can have relationships
between multiple tables, but that is something
174:36 - I'm sorry multiple entities, but that is something
we will have to address in a future video.
174:43 - Whoa, didn't see you there goodness. Anyways,
In this video, we're going to be talking about
175:03 - key words.
175:05 - So, a key is not something you use to unlock
a door. keys in database are something else.
175:14 - A key keeps everything unique. Basically,
that's that's the easiest way to remember
175:20 - what a key is. So when you think in a database,
we kind of structure things in tables. And
175:25 - we want to kind of do that we do we do that.
We do do that haha. Anyways, if we have a
175:34 - table here, we have the columns, which are
the attributes of each thing. So like, let's
175:42 - make it a user account table, because that's
always the easiest example. So yeah. Okay,
175:48 - user. So that's the title of the table. Now,
each individual row within this table is going
175:54 - to be a new user, each column is going to
be a thing a bout the users. So the columns
176:01 - can be username, first name, last name, password,
and email. As an example, I mean, you can
176:14 - really put whatever you really want in there.
Well, a key is something that is going to
176:19 - separate this row from the rest of the rows.
So in this example, think of the things that
176:28 - can be duplicated, think of all the possible
values that you could put within one of these
176:33 - columns. And think, is it possible to duplicate
it in your application? I mean, yeah, it's
176:39 - possible to duplicate it if you allow it to
be duplicated. But what naturally should not
176:43 - be duplicated. So typically, when you sign
up for a website, or a, a game or something,
176:49 - they'll ask for your email. Right? Now, when
you sign up, you put your email and you typically
176:56 - have to go to your email, and click like confirmation
or something to register your email. So they
177:03 - know that it's a genuine email account. Basically,
just so they can have your email and they
177:07 - can send you emails and stuff. But yeah, that
is an example of what we could use as a key.
177:16 - That's because every single row within this
table should have a separate email, some websites
177:25 - allow you to use the same email more than
once. If that's the case, then this would
177:29 - not be a good key. This kind of key is known
as a natural key. Because it's naturally already
177:37 - in our at our table, we don't have to define
a new column just for the sake of a key. And
177:42 - we'll be getting into more of that in upcoming
videos because doing a whole bunch of videos
177:46 - of Ricky's so you get them like really good.
All, like I'm gonna go over pretty much everything.
177:50 - But anyways, even if you make it to where
only one person can hit us a certain email,
177:56 - and that email can only be used by one person.
Or that could be used as the key. The way
178:04 - that works, is it basically let's say we have
emails 123 at blah, blah, blah, a VC, blah,
178:13 - blah, blah, x, y, z, blah, blah. And these
are three separate rows. Well, this is going
178:24 - to let us know which person we're talking
about. And, like now, if someone has the first
178:31 - name, first name and last name by chance,
let's say we have two Caleb Curry's Caleb
178:35 - curry, Caleb curry, we can't use the name
as a key because two people had and it's,
178:42 - it's going to confuse us because Okay, do
we have two people with a name Caleb curry,
178:47 - or one person Caleb curry in the database
twice? Is that an error on our part or what?
178:54 - So we can't have the key. Be in there more
than once. So it's never there's it's always
179:03 - unique. So the key is always unique. He said,
179:08 - he said, he said,
179:11 - Alright, so what is another example of a key
that we can use in this table? Let's get rid
179:16 - of this email. Let's say we're not using the
email anymore. And let's say the website allows
179:22 - multiple emails from different people. So
like if my mom signed up, and then I wanted
179:29 - to sign up, I can use my mom's email. So we
have two people from the same email. That's
179:34 - an example of some websites that allow you
to do that, but not tons of websites do that,
179:39 - but it is a possibility. It all just depends
on what you want to do. It's up to you because
179:43 - I guess it's up to the if you're making a
database for yourself with it's up to you,
179:47 - but if you're making it for someone else,
then you get your their rules and you follow
179:52 - them. Let's think of some other ones. Alright,
well email, let's just say it's knowing your
179:58 - password.
179:59 - Well that's really a bad one. Because passwords,
they're not necessarily unique because two
180:06 - different accounts can have the same password.
And if if you didn't allow that to where they
180:12 - could have the same password, you try to put
in a password for your new account. And it'd
180:16 - be like, Oh, this password is already in use.
And then you're like, Oh, so then you can
180:22 - try that password on other accounts and try
to hack into people. So that would not be
180:26 - a good database design, obviously. So password,
that ain't gonna work because not every password
180:31 - is unique. First Name, Last Name, it could
possibly work. But it's really bad. Maybe
180:40 - first name, last name, and middle initial
or middle name. But even that there's, there's
180:45 - people with the same first name, last name
and middle name. So that's first name won't
180:50 - work, last name won't work. And the combination
of first name and last name will work. And
180:55 - yes, keys can be a combination of two columns.
We'll be getting into that too. What we have
181:01 - left is user name. Well, user name is generated
word that is used to represent your account.
181:09 - It's typically not a name or an email. It's
something like Caleb 123, or whatever, you
181:17 - know what I'm saying. So then, when people
will talk to you, they're talking to Kayla
181:20 - 123, rather than Caleb curry, or they can
put the name there. But some websites use
181:26 - usernames, or some games use usernames or
programs use username, so you have a username
181:31 - and a password. Well, username is always unique.
Because if you have two people with the same
181:36 - username, when you try to sign in, how is
the database going to know which one you're
181:43 - trying to sign into, you know, they're you
they have to be unique. Some of that kind
181:50 - of makes sense. That can be used as a key
because we could have the username, cave of
181:56 - food. And then we can have doors 123 and then
pop. These are three different people, all
182:07 - the other stuff, first name, last name, password,
email, they point to that key. So we have
182:13 - a first name, and a last name, and password,
and an email
182:19 - for
182:20 - the user with the username, Caleb, see, that's
how the key works. We have a first name, last
182:27 - name, password, and an email for the person
with the with the user, I'm sorry, we have
182:33 - first name, last name, pass email for the
user with the name, dog 123. And then we have
182:39 - a first name, last name, password and email
for the user with the username, pi, that's
182:46 - kind of how the key works. The other thing
is that the key should never be changing.
182:59 - So the second thing,
183:05 - never changing.
183:08 - Now, why is this? Well, that's because when
we create keys, we use them to kind of structure
183:16 - our entire database, everything points towards
the key. And the last example we had, I'll
183:22 - just draw key for representation. Let's say
this is the key and we'll just say it's the
183:30 - username. Right? Well, every other column
is part is points back to that key. So we
183:37 - have the name of the person, we have the password.
And we know that these are pointing to this
183:45 - specific person, if we got rid of this key
and that we have two people with the name
183:51 - Caleb with the password, pi.
183:55 - Well, now,
183:58 - are we talking about the same person? Are
we talking about two separate people? Or what
184:02 - we don't really know? But now if we give it
keys and key let me get get that key back.
184:08 - So this
184:09 - let me see if I draw key right?
184:17 - Probably not.
184:18 - Close enough. All right. Here's our key. Now
we know that this Caleb points to this specific
184:22 - person we can have the the username, or you
might often see numbers like 72 the ID, which
184:28 - we'll talk about that too soon. Now, if we
have a separate key
184:32 - like this,
184:35 - well then that is a different person so we
can have this guy have the username. Caleb
184:43 - is awesome. 72 this got me like sexy chicks.
74. See what I'm saying? So that's kind of
184:50 - how the keys work. We never want them to change
because then it's kind of it's confusing because
184:58 - all of these things objects are part of this
key. Basically, this key is used to define
185:05 - uniqueness. Well, if we can change it, it
questions the integrity of our database. Because
185:11 - between tables, we connect things by keys.
So let's say this is a user table, this is
185:19 - a common table. If we have it to where we
can change the key, well, then this connection
185:26 - is, you're gonna have to update this connection
all the time. Now, if we have 50 tables connected
185:34 - to this user table, I'm just going to draw
out for snakes like well, I won't draw all
185:39 - 50. Well, now when we update this key, this
key connection. So we have a comments by a
185:46 - user, we have sales, we have friends, we have
messages, whatever, it doesn't really matter,
185:52 - well, then we change this key, well, that
means every single one of these connections
185:56 - are going to have to update that requires
a lot of work from the server. Makes sense.
186:05 - So we don't want them to change, because we
don't want to have to have that extra work
186:11 - from our database. So that's one thing, unique,
never changing. The other thing. These are
186:19 - just three general roles, there's some other
suggestions and stuff, but I'll get into that
186:24 - soon. But the other thing is never know. That
means empty VAT or no value. So when we have
186:36 - a table, and we have a key value, let's say
we have a user ID, this guy six, this guy's
186:44 - five, discuss for this guy's 30, it doesn't
really matter the order. And then we have
186:48 - their name, whatever, blah, blah, blah, well,
we don't want it to where we can have a blank
186:55 - ID and still have information. Like, Sally.
This Sally doesn't have a key, that is another
187:05 - thing we do not want to do with our keys.
So here are the three main rules. And we'll
187:11 - get into more in upcoming videos. But the
key should always be unique. Never be changing,
187:19 - and it should never be empty. You should not
allow a row without a key. This video, I wanted
187:29 - to talk a little bit more about introduction
to keys, although I'm going to go out just
187:34 - a bit off topic. And I'm going to talk about
indexes. So I don't think we talked much about
187:39 - these in this series yet. But we are going
to be talking about an index. Alright, so
187:46 - what's an index? I'm not going to be explaining
every single detail of indexes, because we're
187:50 - not really talking about indexes. In this
video, we're talking about keys. So I'm just
187:54 - explaining enough so you understand how this
relates to keys. So think of an index, best
188:00 - example I have is a book. So if I have a really
awesome book, like, like physics or something,
188:05 - what I can do isn't like, Oh, I want to know
about this. I can flip open to the back, right.
188:11 - And I can travel to the end.
188:13 - And I be like,
188:17 - Oh, that looks nice page 7832. And I can read
about that. Well, that's a lot quicker than
188:26 - being like, Oh, I want to know about this.
page one, not on their page two? Nope, not
188:36 - they're not not there. Oh, no, not there.
Huh. Keep going through the entire book until
188:45 - you find it. That will take forever. Another
good example is a phonebook. When you go through
188:51 - a phonebook you have, everything's alphabetic,
and it has the data right there. So when you
188:56 - think of an index in a book, it points you
to the data. Whereas a phone book, it just
189:01 - has the data there, you can be like, Oh, I'm
gonna go to the letter G, find grandma in
189:07 - color. Right? That's kind of how an index
works. And it's very similar for a database.
189:14 - We add a table, and it's like a user table.
And let's say we have 6 billion rows in this
189:25 - great, crazy number. And we want to find everybody
with the name Caleb just came. We want to
189:33 - find everyone with the name Caleb. Well, without
indexes. Basically the database is going to
189:38 - go row one. Does it have the name Caleb? No,
it does. row two doesn't have a name. Caleb
189:45 - no row three. Yes, it does. We'll put that
we'll put that back in the return statement.
189:51 - And then it goes through every single thing
every single row within the entire table,
189:55 - which can take ages. So if we're given an
index and we saw We order that data in a way
190:01 - that the database knows how to find certain,
like it could know exactly where the C's are,
190:07 - well, then it can go straight to the C's,
grab all the Caleb's and boom, it's done.
190:12 - It's like, super fast. That's kind of how
an index works. Well, what's not to do with
190:18 - keys, when when we define a key, it's actually
a type of index. That's because keys and indexes
190:28 - are used for SELECT statements, where clauses
and joins. So I could do something like
190:35 - select
190:40 - everything
190:41 - from
190:42 - users, for example. There's just like a SQL
example. I mean, it'll vary from whatever
190:51 - programming like relational database management
system, you use this as a general example.
190:57 - And then I could say, where now this is where
I specify. Sorry, drop the wait. Hold my books
191:12 - anyways. I'm selecting all of the columns.
And then I want to select every column where
191:19 - first name has the value Caleb, for example.
Well, that's how we would do it. So this right
191:28 - here, this little where thing? Well, it's
best to have an index for that. Another thing
191:33 - we commonly do are joins, which is basically
combining two tables. And I'm not going to
191:39 - go into all the syntax for all that. Basically,
we have a table over here, users, and then
191:44 - a table over here, comments. And we want to
make a generate a new view, where we have
191:51 - all of the comments from a user and all of
the information about that user, we could
191:57 - have a new generated view. But we can join
these statements. And how does it know how
192:02 - to join it, it uses the I uses the key, right?
So if you have a primary key, and let's say
192:10 - we use username,
192:11 - so the key
192:12 - on drala key here. The key is username. Well,
how would we join it, we would say, I want
192:27 - you to take this table, and this table, and
then combine all of the rows, where the username
192:35 - is Caleb curry over here. And the username
is Caleb curry over here. So that way it knows
192:40 - all of these comments are from Caleb curry,
which we can assign to that user with the
192:46 - name Caleb curry, or you might often see it
with like an ID number. So it could be like
192:54 - ID six, take all the comments from the user
with the ID of six, join it with the SEC,
193:03 - take all the rows with the user with the ID
of six, join it with all of the rows with
193:08 - the user of ID six, and it combines them individual
rows for each ID. Within when we make a primary
193:18 - key, or just a key for now, we're defining
an index. So the database can easily access
193:27 - the order of our data and combine things.
So that is how kind of indexes relate to keys.
193:33 - Key is a type of index. There are all kinds
of types of index.
193:46 - Look up tables. So what is a lookup table.
Let me I have to kind of explain something
193:55 - else first before we're going to get into
this. So just kind of relax and take. Take
194:00 - a good look. I'm going to erase this so I
can have some room. So let's say we have a
194:06 - membership table or membership database, and
we have a user table or members table. And
194:12 - within that we have like a membership status.
Okay. And let's say there's like 10 options,
194:19 - I guess. So you could have like, bronze, silver,
gold, platinum, titanium, and then like not
194:29 - a member or like a trial member or
194:37 - partner or
194:40 - special member or member above all members.
I don't know I'm just kind of making stuff
194:46 - up. Anyways, some people will create what's
known as a lookup table, so they'll have a
194:52 - table over here with every single option for
the membership So we could have the memberships.
195:06 - And then within here, we would have, each
individual row is one of the membership statuses,
195:15 - right. So we have like 123456789, I'm just
gonna go at nine because can't fit anymore,
195:24 - nine individual rows. And then we so that's
one column, the ID, for example, which will
195:33 - mean we could use a different key if we needed.
But for this, we'll just use an ID. And then
195:39 - we have a column to say what the membership
status is. So we're gonna have like, gold,
195:51 - silver,
195:52 - bronze,
195:53 - platinum, and so forth. Now, we can have a
members table.
196:07 - And then a column
196:10 - within this member table, can reference the
key of the membership. So remember, like one
196:18 - or two videos ago, I talked about how keys
make connections between tables? Well, this
196:23 - is how that's done. Here's an example of a
connection using a key, what we would do is
196:30 - we would have like the member, the members,
user member name, or their ID, for example.
196:36 - And then we have their first name, last name,
address, phone number, billing type, whatever
196:43 - it is, and then we would have a column membership,
you see. And within here, let's just say for
196:53 - example, we didn't have this table, this was
gone, we just had this member table. Well,
196:58 - when we have 6000 rows within here, the membership
type would get repeated. Lots and lots of
197:07 - times, we would have like gold, gold, gold,
gold, bronze, platinum, platinum, platinum,
197:12 - bronze, glow, platinum, bronze, and go on
go on for all of the rows. And that would
197:19 - work. That's that that is a possibility for
your database. I'm not saying it's going to
197:24 - cause your database to explode, or you'll
get fired or anything. Well, unless you're
197:29 - told not to do that you might get fired. That's
a possibility for the database design. Now
197:37 - let's think what kind of relationship is this?
One member can have one membership, and a
197:46 - membership can have multiple people having
a membership. So it's a one to many relationship.
197:53 - The one side is the membership, you'd have
one of these, and then you have many people
198:05 - using that. So that means if we if you remember
from the relationships, we need to take the
198:12 - key from this one, and put it over into this
table. And now if we add this new relationship
198:19 - in, we don't have all of that repeating data
because all we do is reference one individual
198:25 - row. And there's some other benefits to that,
which I'll explain in a second. So now we
198:30 - can be like rather than gold, gold, gold,
silver, bronze, platinum, we have 111234 for
198:41 - all of our rows. And we still have individual
information like Caleb, Jimmy, Jake, Sally's
198:48 - Sammy, and Sarah. Well, when we do this little
connection thing, we have a new connection
198:55 - between these tables. We're taking the key
of the membership, which is this column right
199:02 - here. So here's our key. And we are taking
that key, and we are moving it over into the
199:12 - member table. So now this column right here,
within the member table, points back to the
199:22 - key of the membership table. This is known
as a foreign key. Now this will help protect
199:29 - the integrity of our database. That's because
there's only nine possibilities for the membership
199:36 - and if someone puts something else we could
flag an error. The other thing is we can have
199:42 - it to where it will not accept an empty value.
And then if for some reason we decide to change
199:51 - our like let's say we wanted to change silver
to like I don't know diamond well Then we
200:00 - can change it here. And because this value
is not over here, it's only a reference,
200:11 - it will automatically figure it out. Because
you see the key never changed. The key is
200:15 - still one. So one still points using one.
So this connection is still here, the value
200:22 - or I'm sorry, I guess it should have been
two. Whatever you get my point up, we can
200:28 - change the name of gold, we can make it epic.
If you want epic membership, well, now, we
200:36 - didn't have to change 6000 rows within our
member table, we only had to change one row
200:42 - within our membership table. And all these
connections stay the same. So the IDS helped
200:48 - create better connections between tables requiring
less maintenance for our database. And it
200:54 - also protects our integrity, because we don't
have to worry about incorrect values within
201:00 - the membership. Because it's all connected
back to the membership table, which we change
201:06 - from here. So we update epic, it updates every
single instance of epic within our entire
201:11 - database, or it gives us an error or something,
we can set it using what's known as foreign
201:17 - key constraints. That key foreign key constraint.
So because we're using what's known as a relational
201:34 - database, which is the type of designing we're
doing right now, we have relations tables,
201:40 - and everything is connected across the database.
It's not all stored in one individual table.
201:48 - But to protect our integrity of our database.
We create connections between keys. That way,
201:56 - we don't have to worry about incorrect data.
So what do keys oops, and don't match? What
202:03 - do keys do for us? Let's write that out. Well,
first thing, they protect our integrity, I
202:15 - made a video over integrity. So if you want
to check that out, be sure to do that. So
202:22 - they protect our integrity. How do they do
that? Well, we don't have to worry about only
202:27 - some values updating. If you remember, we
had the members table. And when we updated
202:31 - gold, and we named epic, it updated every
single row within the member table. So it
202:38 - protects all of our values. So updates, less
maintenance for us less incorrect data. What
202:46 - else is the key deal keeps everything unique.
And you might have saw that in the member
202:55 - table, we use the the key number one, multiple
times, we had three people with the member
203:04 - ID, I'm sorry, the membership ID one. So three
people had gold, for example. Well, it's still
203:13 - unique, because they're still only talking
about one individual gold. Over here in our
203:20 - membership we had gold was one of the options,
we could have three people. Alright, you see
203:37 - up for her arms, these three people can all
have
203:41 - a gold membership.
203:43 - And it's still unique because we're only talking
about one individual value with three references
203:51 - to that value if we got rid of these foreign
keys, and we just had to say what membership
203:57 - status they had. Well, now, this guy's going
to be gold. This guy's going to be gold, this
204:05 - gal is going to be gold. So now I have 123
204:11 - times that gets rid of the uniqueness from
the key. So it protects our uniqueness improves
204:24 - our speed. So basically, improved functionality
of our database. Function I'm running out
204:37 - of room and it does a whole bunch of other
things. Basically, it makes updating easier,
204:44 - so less work for us. Because we don't have
to go through manually and check every value,
204:49 - we can just update that individual value.
You know. The other thing is that allows for
204:56 - added complexity. Long, hands getting tired.
Okay. Now you can even see all that. Okay,
205:14 - so here's some examples. I'll see, I'll show
you how we could say it allows for added complexity.
205:19 - Let's see. I'm going to redraw the example
we had, but I'm not going to draw super in
205:26 - depth. So don't, don't wait. Don't mean, don't
worry, it won't take that. We had a members,
205:31 - and then we had the membership. All right.
Now let's focus on this membership table.
205:38 - Let's make it a little bigger. Actually. What
we had earlier it was we had an ID, we had
205:46 - 1234, and so forth. And then we had the title
of whatever they are. So if you wanted to
205:51 - draw this better, you could put the column
headers, so we could have, like ID. And then
205:57 - we could say, name of the membership. And
then we could title the table, we could have
206:03 - it membership, membership. Yes. Well, what
we can do, we can have added complexity, because
206:09 - now we can add a new column.
206:12 - And we could say more about the gold membership.
So we could say,
206:17 - price.
206:18 - And we can have a monthly price of $60.
206:21 - For example,
206:23 - if we didn't do this whole lookup table thing.
And we put it all within our members table.
206:28 - Let's see how that would look.
206:34 - Let's try it.
206:35 - All right, let's have the members table. And
let's not even have a membership table. Well,
206:39 - now we have the guy with the ID, 789, and
three, and we'll have their names be Caleb.
206:48 - Tom Tommie
206:52 - trace.
206:54 - So those are the three people I was talking
about with the gold memberships. Well, what
206:58 - what membership to the heck, okay, gold, gold,
and gold. Now, how much does that cost them
207:05 - 6060 and 60. Just with this little example
of three people, we already have four unnecessary
207:18 - values. Because we have repeating data, we
have G and G twice more, we have 6060, twice
207:24 - more that eliminates the functionality of
our database, because we're having tons of
207:32 - repeating data. So you might think the best
way to do is is get rid of this price. Well,
207:38 - now we get rid of the complexity of our database.
And sometimes complexity is a good thing because
207:44 - it allows us to store more information. When
we use the common or when we I'm sorry, when
207:49 - we use the lookup table. We can just have
that as another column. And we can put more
207:54 - things we could have another column saying,
how long does this membership last? We have
208:00 - another column saying? I don't have a special
purpose, or what can use within our gym? Or
208:05 - what can we use? And are we allowed to bring
friends? What's the price for friends, we
208:11 - can do all that kind of stuff within this
table and just reference that within the other
208:16 - table. It's only a set number of options.
So we reduce the repeating data. If we wanted
208:23 - to do at all Well, we'd have to put each individual
comp column and we'd get tons of repeating
208:28 - data. You know what I mean? Yeah, so that
is an example of how because that would take
209:17 - forever. So that's very common. It's common
for things with a set number of options. So
209:23 - like membership type, there's only so many
options. You can have states, sometimes sometimes
209:28 - people do it for sex, male or female. Some
people do it for I can't think of anything
209:36 - else right off the top of my head. But anytime
there's a set number of options, they will
209:41 - often put a lookup table with the ID, the
name of that option or what that option is
209:46 - like gold, silver, bronze, or male female
or California, all the other states, Wyoming,
209:59 - Texas
210:00 - Russia,
210:02 - well, then
210:05 - we only have a set number of options. So that's
that's the, then we can put more information
210:09 - about it, we could say, male, and then, like
what the male is allowed to do on the website,
210:15 - or anything that allows for extra complexity
for our database. In the last couple of videos,
210:24 - we've talked about all of the characteristics
of keys in general, we talked about the word
210:31 - key, and databasing. Keys are the key to success.
Anyway, anyways, this video, we're going to
210:39 - be talking about specific kind of keys, because
all of the last videos were kind of concepts.
210:46 - But now we're going to be talking, how do
we actually implement that into a database,
210:51 - I understand that we want keys and we want
references from table to table, and we want
210:56 - it all to be connected. But how do I do that?
Well, the main two types of keys that you're
211:03 - going to hear are known as
211:07 - primary
211:10 - and foreign. Actually, we're not going to
be talking about these two kinds of keys.
211:18 - In this video surprise, we're going to be
going a little bit broad,
211:22 - more a little bit more broad.
211:23 - So when you're like a beginner and you're
learning database design, you'll probably
211:26 - learn that these are the two kinds of keys,
when, when you're want to learn more advanced
211:32 - database design, you'll learn about different
categories of keys. So before we get into
211:39 - these two,
211:40 - which
211:41 - if you guys haven't heard of those just hold
up, if you ever have those keep holding up.
211:46 - We're going to be learning about what's known
as a super key. Now,
211:53 - for some reason,
211:54 - I think this is one word with no space. And
I don't know why there's no space there. So
211:59 - if someone knows if like, what do you guys
want to know,
212:02 - let me know.
212:03 - Because I really want to know, it's driving
me crazy. The other one that we're going to
212:09 - be learning is candidate key. Alright, so
before, before we learn about the candidate
212:16 - key, let's just focus on the super key. So
I'm just going to erase this. Alright, so
212:23 - what is a super key? Well, a super key is
any number of columns, that forces every row
212:31 - to be unique. Now, if for some reason your
table is structured to where you can't have
212:39 - every single row be unique, you need to consider
adding some kind of column to enforce uniqueness,
212:49 - such as an ID, or some, you need to make sure
that everyone using the database understands
212:57 - how that table works, if it's a special case,
but generally every table, you will be able
213:02 - to make unique. Now, when you work with databases,
you'll often see IDs, so like user ID, this
213:13 - is a type of key, then you also sometimes
find keys such as like username. The difference
213:23 - between these is that this one's kind of just
made up for the sake of the database, user
213:27 - ID of 748. What does that mean? Absolutely
nothing. It's just a number. username actually
213:32 - has some real world connection. We'll be getting
into the difference between these in an upcoming
213:38 - video. And which one will be best to use or
which situations. But as for now, we'll just
213:45 - be using kind of natural practical columns
that are already in the database rather than
213:50 - IDs. But
213:51 - the same thing can apply
213:52 - with just like an ID field or a call. So let's
learn about the super key. Super key, like
214:01 - Superman, but it's a key, just like a giant
key that just goes and breaks through doors
214:07 - doesn't even use the handle. It just breaks
through doors.
214:12 - Anyways,
214:13 - let's learn. Okay, let's say we have a table
here.
214:16 - Big table right.
214:18 - Now I'm going to put some columns in this
table. That's not straight enough for me.
214:24 - Close enough now it just looks worse, whatever.
Let's say we have a user table because I always
214:32 - think that's the absolute easiest thing to
use. And we're going to have a
214:36 - username,
214:37 - email,
214:39 - password.
214:40 - Then we're going to have first name, middle
name, last name and then we'll have
214:54 - birthday
214:58 - so every single row Within this table is going
to need a value
215:04 - for each one of these columns. I know this
is really bad handwriting, but it doesn't
215:11 - really matter how it looks just understand
the concept. There now looks a lot better
215:16 - now.
215:17 - You're welcome.
215:18 - Now you can actually understand what's going
on. Okay? some instances, for databases, you
215:25 - will allow people to put in blank values.
So for example, if someone doesn't have an
215:32 - email, for example, we could make it optional.
That way, some people have no or no value
215:38 - at all other people have values. But for this
this case, I'm going to say everything is
215:43 - required. Because let's say you use your email
to sign in, or to verify your account.
215:54 - How do we make sure that every single row
is talking about one entity, and every single
216:00 - entity only has one row, everything is unique?
If we have a person
216:05 - and draw a little guy over here, right? And
he wants to sign up for this website. So you
216:15 - guys this website, here's his
216:16 - website, you put this information in, and
the information goes into a table. Right?
216:21 - he does, he probably won't actually have access
to the SQL, because it's just some random
216:27 - user on your website has access to your database.
Can I got some security problems, but anyways,
216:33 - what's going to happen is he will be entered
into this and all of his values will be put
216:38 - into these values box. So we have username,
like it, fi, email, DC at blah, blah, blah,
216:46 - calm pass, it's pi. First name is Caleb, real
name Daniel. Last name, curry birthday, oh,
216:58 - to 1390. So this guy, inserted all that information
within this database. If you can't read, it
217:08 - doesn't really matter. Now, when another guy
comes, or let's say gal, so this lady comes,
217:15 - and she's like, Oh, I want to sign up for
this website. So she signs up this website.
217:22 - And she puts her information in. And this
also goes in the database as a new row. So
217:26 - this is just the column headers. This is separate
from the actual data. The rows, though, they
217:32 - have individual values, she can put her values
in, I'm not going to write them all out, because
217:36 - you guys get the point. How do we know that
each individual row is unique? And that talks
217:43 - about one individual entity, in this case,
a user? Typically, whatever the entity is,
217:50 - is what the table was titled. So the entity
will be the user. How do we know that every
217:55 - single row is talking about only one user,
and every user only has one row the rule of
218:01 - one. We don't want Caleb to be able to come
in here, create a new account and make his
218:06 - username, cc and all the same stuff again.
Now, in some instances, we may be able to
218:12 - allow them to make more than one account.
Like I could make an extra YouTube account
218:16 - if I really wanted to. That would be okay.
So I could have the same different username,
218:22 - different email, same password, same first
name, same middle name, same last name, the
218:28 - same birthday, the only thing that changed
is a username and email. Now, the default,
218:34 - like what the table is trying to define has
kind of changed. We're no longer trying to
218:39 - define the person. We're trying to define
the user
218:42 - account.
218:45 - Because now there's two accounts and they're
completely separate entities over that kind
218:49 - of makes sense. But you don't really need
to worry about all the specifics. I'm getting
218:52 - completely off topic. So what were we talking
about 10 minutes ago, I think we're talking
218:57 - about super keys. It's any number of columns
that forces every single row to be unique.
219:06 - If you take all this information and compare
it with another let's let's create a new row.
219:16 - Let's say this lady here actually ended up
putting your information in her username is
219:21 - a her emails B passwords seat. First Name
is Hi, middle name is yo. And her last name
219:30 - is Hello. And she was born. Oh 316 72. That
is her birthday. Well, now, if you compare
219:41 - these values it is in is there they're different.
Not every single individual value has to be
219:49 - different. For example, this girl's last name
could be curry and that'd be perfectly okay.
219:55 - But all of the values as a whole have to be
different. So as for example, if someone came
220:01 - in here and put all of this information up
here, down here, cc ccof, blah, blah, blah,
220:06 - pi, Caleb Daniel Curie Oh to 1390, that is
not a unique row, and it would cause an error.
220:14 - So the super key could be all of these columns
right here. Now, super keys are usually not
220:22 - defined within the database. That's because
they're so broad, you have all this information.
220:26 - Of course, it's going to be unique, simply
because you can only use a username one time,
220:33 - typically the emails only one time. So if
someone comes down here and tries to use an
220:37 - MCC, well, then you already got an error,
it's not going to work. So all this extra
220:42 - columns are here. Kind of unnecessary, because
we can simply do that same thing with just
220:48 - the username. So a super key is any number
of columns, that creates a unique row, unique
220:56 - rows. A candidate key is the least number
of columns. That Can you see how new is a
221:07 - candidate? I'll explain why it's called a
candidate. And second, or in the next video
221:12 - or something. The candidate key is the least
number of columns. So for this example, we're
221:19 - not going to allow two people to have the
same username. We may allow them to have the
221:23 - same email, we may allow them that same password
first name, middle name, last name, and birthday,
221:27 - but not the same username, because then how
do you tell them apart? You can't because
221:32 - all of their information is the same. They're
exact clones to the database. And we do not
221:37 - ever want that within our database. Typically,
I can't really think of any examples where
221:43 - you would want duplicate data. But okay, anyways,
the candidate key is the least number of columns
221:53 - needed to force every row to be unique. In
this example, the username is enough to make
222:00 - it unique. So we can take the candidate key
and have it to be just the username, or I
222:06 - guess we could certainly call because all
throughout the, the rows are going to be unique.
222:13 - So the can the candidate is least, and super
key is any
222:19 - x.
222:20 - Now when it comes to database programming,
let me clear this up. So your brain doesn't
222:27 - explode anymore.
222:29 - It takes forever.
222:31 - I want to tell you guys,
222:39 - stop watch. Alright. And I just got my chalkboard
to listen to me and
222:43 - erase that stuff.
222:45 - When we're talking about database programming,
there's not really a time where we're ever
222:51 - going to tell your database that this is a
super key, because super keys are not practical.
222:59 - They are for designing your database. Only.
When I looked at that column, first thing
223:06 - I do is I think super key. Yes, every single
row can be unique. That's the first check.
223:13 - So you ask,
223:15 - can it
223:18 - can each row the unique?
223:22 - That's the question.
223:25 - That's the Define. That's what super key is
questioning, can each row be unique? And even
223:32 - better word? Can every row be unique, because
every single row within a table has to be
223:39 - unique. That's what the super key is asking.
Once we figured that out, if it can be unique,
223:48 - then we move on to figuring out the candidate
key. So now we ask
223:55 - how many
223:58 - columns
224:00 - are needed?
224:04 - Can you read that? Hopefully? So the first
question, can every row being be unique? Yes,
224:11 - that means we have super key. That's all we
have to worry about. We have to have to figure
224:14 - out which columns or anything like that, can
every row be unique? Always think about all
224:20 - the possible values. Is it possible for a
duplicate? If it is you got to figure something
224:28 - out? If it's not good, so every row can be
unique.
224:33 - Yes, check move on,
224:35 - how many columns are needed. Now you figure
out the least number of columns needed in
224:41 - order to create unlimited uniqueness forever
so no possibility of uniqueness and we are
224:49 - allowed to put some kind of like limitations.
We can put a unique we can use. It might be
224:56 - different from for different relational databases.
But if we use a unique index, for example,
225:02 - every single column, I'm sorry, every single
value within a column has to be unique. And
225:10 - that's, that's a requirement for people to
put in. So if it's not unique, we give it
225:15 - an error. That's how we force values to be
unique. So how many columns are needed? Once
225:23 - they figure that out, we have what's known
as a candidate key. So in the last, the last
225:30 - example, it was just one because we could
use the username. Now, the next thing I like
225:38 - to figure out is, how many candidate keys
do I have?
225:43 - I'm just going to use
225:46 - ck for candidate keys. How many ck do I have?
What does this mean? Well, we can actually
225:57 - have more than one candidate key. And the
last example, we had a username, we also had
226:09 - an email. Okay, well, email could also work
as a candidate key, because you could put
226:19 - a requirement that every account has a unique
email, some websites are cool with people
226:25 - using the same email more than once. Some
websites aren't usually they're not. So there
226:31 - might be a chance where we have more than
one candidate key. Or if rather than using
226:37 - the username, you want to use something else,
you could have it to where we can have, let's
226:43 - say, you can use your email one once, we could
have first name, plus, last name, plus middle
226:51 - name, or middle initial. So that eliminates
most possibilities of uniqueness. But there's
226:59 - still possibility that people have the same
name. So then you add,
227:03 - birthday.
227:05 - So now you have to find someone with the same
first name, last name, middle name, and the
227:10 - birthday.
227:11 - Very rare,
227:12 - still possible. So then we could add a third.
I guess one to a fifth column, we could make
227:19 - it. email, or we could do something such as
a dress. Alright, let's see, let's go with
227:27 - a dress. This could be a candidate key. Because
we have first name, last name, middle name,
227:33 - birthday,
227:34 - and address, they all have to be unique as
a whole. What are the what are the chances
227:39 - of a person living at a certain location born
on a certain day? Also, the UK what are the
227:49 - chances of two people having the same name
same birthday and living at the same place?
227:54 - Unless you had twins, and you named them the
same thing? If that's the case, shame on you.
227:59 - It's gonna confuse people. That could be a
candidate key now isn't the best candidate
228:04 - key?
228:05 - Probably not because
228:06 - we're using five columns. And it's still technically
possible to have a duplicate, but very, very,
228:13 - very rare. Right, so how many candidate keys
do I have? You figure them out, I like to
228:19 - write out the possible candidate keys. And
then we move on to the next step, which is
228:24 - defining the key that we will use for our
table. Once we have the candidate keys, we
228:30 - can choose one of them. They're called candidate.
228:34 - Because there's
228:35 - there's an options like you could have, you
could have your first candidate, you could
228:38 - have candidate key one, candidate key two,
and you've got candidate key three, this could
228:43 - be the username, this could be the email.
This could be that long, first name, last
228:48 - name, password, blah, blah,
228:51 - whatever you want it to be.
228:53 - Now, you have to decide which one will be
your primary key. We're going to be picking
229:02 - up from where we stopped last video, which
we were talking about candidate keys. So this
229:08 - video, we're going to be talking about primary
keys, which is the next step. So what is a
229:16 - primary key? Well, in the last video, we we
define some possibilities for candidate keys,
229:25 - something we could use as the main key it's
a candidate because you have to pick it to
229:29 - be our primary key.
229:30 - So we have a list of possibilities. One of
them was a username. Another was an email
229:38 - and then if you don't have something simple
229:40 - like this, you could do something like your
full name, which that would be like first
229:45 - name, last name, middle name, and then plus
an address. Which address would probably be
229:53 - broken up into like, Street, city. You know.
Like all the parts have an address, and then
230:01 - possibly your birthday.
230:04 - Or just
230:07 - dog.
230:08 - So here are just some possibilities for candidate
keys, we could have username, email, first
230:12 - name and last name. Well, now, once you have
all your possible candidate keys, you want
230:17 - to pick one to be your primary key. So how
do you do that? Well, once again,
230:22 - you got to make sure we look
230:23 - at the the
230:24 - rules or suggestions for keys. This is specifically
talking about
230:28 - primary keys.
230:29 - We want our primary key a unique, never changing
and never know. So username is never going
230:37 - to change, right. So that's pretty good. You
always need a username when you sign up for
230:44 - an account. So it's never know. And it has
to be unique because two people can't have
230:47 - the same username. So this would be a good
primary key, check out email. Well, it's you
230:53 - can make it unique, you can require people
to only have like, you can prevent multiple
230:58 - emails. So when you create an account, you
can only use an email that has not been used,
231:03 - that's an option. So that's possible, never
changing it Well, it depends depends on if
231:10 - it if your use your email, like a user account
username, that you sign in with your email
231:16 - and you have a password to well, then the
chances are, you're not going to be able to
231:19 - change it. Although now, you can probably
update your email and stuff. So it's possible
231:28 - to be never changing if you prevent people
from updating their main email. So possible,
231:35 - possible and never know you can require someone
to have an email. So that's possible, all
231:40 - three of these are possible. So this is a
possible loss for a dash, first name, last
231:47 - name, middle name, address, date of birth,
well, probably the whole group, as a whole
231:53 - will be unique, the chances of finding someone
with your same name, living at the same place
231:58 - as you with the same date of birth is almost
impossible. so unique, practically Yes, but
232:10 - possible, you can possibly have a duplicate.
So possible, never changing. Oh, well, people
232:19 - can get married, so their last name can change.
First Name can even change your middle name
232:23 - can even change, you can move, you can't be
born a different date, you can't be born again,
232:30 - like unless you become a Christian. But anyways,
never know, well, some people might not have
232:36 - an address. Either that, or they might not
have a middle name, or something like that.
232:42 - So this is probably not the best primary key.
So in this example, I'd probably go with the
232:50 - user name. And then you define that as your
primary key. And then you can use that to
232:59 - make connections between tables. So you have
a comment by a username, that's the connection.
233:06 - That is a natural key. And we'll be talking
about surrogate keys in the next video, if
233:10 - you know anything about that. But basically,
you can use your username as an Id rather
233:14 - like as a primary key. So you could have,
let's say, this is my username. This can be
233:21 - the connection for all of my rows by me. So
if I have a table for comments, table for
233:28 - users, a table for sales, will if I buy something,
Caleb curry connection. If I post, if I'm
233:37 - a user will connection, if I post a comment,
connection, it all kind of points back to
233:43 - the user table, because that's going to be
the parent of the
233:47 - relationship here.
233:50 - So this could be a primary key. So that's
a primary key. Now, this will also be indexed,
233:56 - because primary key is a source of is a type
of index. So you can do SELECT statements
234:02 - really easily with that and everything like
that. So that's going to be how you connect
234:06 - most of your data. Now, the other candidate
keys that we did not choose, they're known
234:14 - as alternate keys. An alternate key. It works.
I mean, it can be it can be it could be the
234:27 - primary key. But basically, it's all the candidate
keys that were not selected as the primary
234:31 - key. You do not you're not required to define
all of your alternate keys in your database.
234:37 - In fact, you don't even need any alternate
keys. But you may want to because oftentimes
234:44 - they will be something you're doing searches
for, or connecting tables or whatever it is.
234:52 - Alternate keys might be useful so you can
create an index on the alternate key. So I
234:57 - could create an index on the email
234:59 - For example, because I said that was a possibility.
Well, now, that can, that'll be an index,
235:06 - and it will probably be used because you might
want to do data by the emails like selecting
235:13 - everyone by their email, you know what I mean?
Maybe possible, basically, you can, you can
235:21 - do a select. And then you can choose the columns
you want to choose and then the table. And
235:27 - then you can say, where. And then you could
say, like, email, has the value, legit at
235:38 - awesome calm, because you have an index on
that it's going to work better. So if you
235:43 - have a really good alternate key, I recommend
you index it simply for good design. And it
235:49 - will help your database run faster. But if
you don't really want to index on it, then
235:53 - don't do it. Because that's just another thing
your database is going to have to maintain,
235:58 - it's going to have to update the index as
well as book sort of how if I have a book
236:04 - here, and I change the insides of the book,
well, then the index in the back is gonna
236:09 - change too.
236:11 - So alternate keys, you can set them as an
index, if they are good and useful if you
236:16 - will be searching for that kind of information.
So that is introduction to primary keys and
236:23 - alternate keys.
236:25 - Sir, I
236:29 - think I'm falling sorry, by the way, sir,
good. And then we have a natural.
236:38 - Alright.
236:39 - So we talked about primary keys in the last
video. That's as far as we'll get for defining
236:47 - a key. These are categories of primary keys.
So we define a primary key. And this is kind
236:55 - of like a descriptive term, we don't have
to define in our database surrogate primary
236:59 - key or natural primary key, this is more for
database design. To know like the difference
237:07 - between types of keys, hopefully that makes
clear sense. And if not, just stick with me.
237:13 - Okay, so Up, up to like all these key videos
I've been doing, I've been using natural keys,
237:20 - let's define a natural key first, it's very
natural definition. It's something that's
237:27 - naturally in the table, something you naturally
want to store. When you have a user's table,
237:33 - you naturally want to store the user name
and the email, those can be used as natural
237:39 - keys, because they fit all the requirements
for a primary key. And it's already in there,
237:47 - you don't have to make up something, you don't
have to think of a column to add just for
237:50 - the sake of having a key, we want to be able
to have a key for every single table.
237:56 - But
237:57 - sometimes, the natural keys not very obvious
or not so natural. So we want to try find
238:05 - a natural key when we're using natural keys.
Generally, when you create a database, so
238:11 - let's say this huge box is our database. Within
this database, we have a bunch of tables.
238:17 - And then within each table, we have a bunch
of columns and rows. See, I'm saying these
238:24 - are all connected in some funky way, with
relationships? Well, when we define a database,
238:30 - typically, I mean, maybe not always, we want
to try to either always use natural keys,
238:36 - or always use surrogate keys, which are just
made up keys. We don't want to kind of flip
238:42 - flop switching, I can't think of any other
words. Because we want to try keep it consistent.
238:47 - Otherwise, people using the database, they're
gonna be confused. Is this a natural key?
238:52 - Or is this a surrogate key? Is this something
that actually has real world value? Or is
238:56 - it just a made up number? So let's say we
are using natural keys, there are a couple
239:05 - problems with natural keys. And this video
will be explaining the difference between
239:09 - these two. And the next video, we'll be talking
about pros and cons of each
239:12 - basically.
239:15 - So natural keys are what's naturally already
in the table, something we wanted to store
239:21 - to begin with, right? The thing is they have
real world value. So your database might adapt,
239:28 - and the meaning of your keys kind of adapt
to which, once again, I'll explain that on
239:33 - the next video surrogate keys. They are a
column that's just added to your database,
239:39 - no matter what even if you have a good natural
key because remember, you want to either use
239:43 - all natural or all surrogate usually. So if
I decide to use surrogate keys, I'm going
239:49 - to give an ID to every single row within every
single table. So we have let's say we have
239:54 - a user table and then we have a sale
239:58 - table.
240:00 - Then we have a
240:01 - common table, all we do is we give every single
table, an ID column. So we have a user ID
240:11 - column and the say in the user table, we have
a sale ID column and the sale table, we have
240:16 - a comment ID in the comment table. So now
when we have like, let's look at the comment
240:21 - table in the comments, we're going to have
a column, we're gonna have a column for the
240:29 - comments ID. And then we'll need a reference
to the user that posted the comments. So we'll
240:37 - have the user ID as a foreign key, which points
back to the user table. So that's kind of
240:45 - how that works. Now we just have random numbers,
the ID is just a big number that has a feature
240:52 - known as auto increment. means every single
time you make a new row within this table,
240:58 - it's going to raise the ID by one, then when
you like, delete columns or something and
241:04 - you have gaps within your numbers, it doesn't
really matter because the number has no real
241:10 - world significance. Typically, surrogate keys
are kept completely private. No one knows
241:21 - the surrogate key, except for the people working
with the database, you're not told your surrogate
241:27 - key. So if I created an account on a website,
and then I put my username and my password,
241:34 - and then I go to like, I sign up, register
and do my email junk, and then I sign in and
241:40 - go to my user settings, it's not going to
be like user ID equals 45, or whatever, it's
241:49 - going to be private. The reason for that is,
is because the world doesn't have I mean,
241:54 - the, the number doesn't have real world, meaning,
therefore, it's private to the database only,
242:00 - if I started giving that number out to everybody
who has one of these IDs, or, or something
242:06 - like that, or if I started putting it on sales
reports, well, then I'm giving that number
242:11 - real meaning in the world, and it's starting
to become a natural key. So hopefully, that
242:18 - kind of makes sense. Natural is something
that's already in the database. surrogate
242:23 - is something we just add. The thing that's
kind of cool about surrogate is if you're
242:27 - struggling to find a really good natural key,
you can always use a surrogate key. The problem
242:33 - with that is you always want to try to be
able to naturally make everything unique.
242:38 - Like any user table, we have a username, that's
going to keep things unique. So even if we
242:45 - use a surrogate key, we can still index this
username. And that can be used. Sorta as if
242:53 - we assign it as a natural key. The only thing
is we're making connections between tables
242:57 - using the surrogate key. So for this table,
we could have a user ID, and then we could
243:04 - have a user name. For just an example. The
user ID would be the surrogate key. This would
243:11 - not be the natural key because we can only
have one primary key. And the primary key
243:18 - is going to be the type surrogate. So the
user ID is a surrogate key random number generator
243:26 - number, the username, we can index it and
use it like a natural key with when we search
243:33 - the database and everything. But we're not
going to use it to make connections between
243:37 - tables and references with foreign keys. So
hopefully that makes things
243:41 - pretty clear.
243:44 - In this video, I wanted to talk about all
the pros and cons of surrogate or natural
243:52 - keys. So basically, we're going to compare
and contrast them here. So over here on the
243:57 - left side, we got surrogate and then over
here on the right side, we got natural All
244:09 - right, we're gonna have a little battle here
and we're going to figure out which one's
244:13 - the best. Me as boxes to keep this up.
244:17 - Here. Alright, so
244:19 - what are some good things about natural keys?
Alright, well, first one of the first good
244:24 - things about what's really weak. One of the
first good things about natural keys is that
244:29 - you don't have to define any new data. If
you don't remember from the last video, let
244:33 - me just redefine them here. Natural keys are
used, or columns used as your key that are
244:39 - already defined within your table. They're
natural to what you want to store. surrogate
244:43 - keys are just kind of added like a user ID
or a car ID or a credit card ID or a comment
244:53 - ID, their surrogate. They have no real world
meaning so natural, not natural. Cool. So
245:02 - some good things on naturals, you don't actually
have to define a new data, any new data, I
245:06 - don't know if you could hear me, they're not
kind of stuttered on that. But anyways, you
245:10 - don't really have to define any new data because
it's already within your table. And you can
245:15 - use that as your natural key. So you're required
to store less information in your database.
245:20 - So you get smaller data, you get it, you have
a smaller database. Right? So that's one good
245:24 - thing. So what's the downside to natural keys?
Well, the downside is that sometimes you're
245:31 - not going to be able to find a really good
natural key. Because if you look over here,
245:36 - we want our keys to be unique, never changing
and never empty. Or No. Well, if we have a
245:43 - natural key, we have to find one that fits
all three of these. And it has to be a good
245:50 - one that would make sense to use as a as a
natural key, like, you might not want to use
245:54 - a combination of 20 columns to make natural
key. But that's one of the downsides to natural
246:01 - keys, you have to figure out what natural
key to use, and there's not always a great
246:06 - option. Now, optimally, you should have a
natural key, or at least something that can
246:14 - be used as a natural key within every table,
to best had to have the best design to ensure
246:20 - uniqueness, not just by a surrogate key if
you use one, but by naturally what's being
246:26 - stored. So like this example, if we have a
comments table, we could have a comment by
246:32 - a certain user on a certain web page or whatever.
And what what forces it to be unique? Well,
246:39 - the combination of that as well as the date
it's posted, or the time it's posted, that's
246:45 - going to be unique, because you can't have
two comments from the same user at the same
246:50 - time, on the same web page. It's not possible,
right? I mean, unless you like glitch the
246:55 - system somehow, which shouldn't happen. Well,
that's an example of using natural keys. The
247:03 - downside? Like I said, you might not always
be able to figure out what to use for your
247:07 - natural key. That one was a good example.
Because naturally, we could figure out a natural
247:12 - key, right? Follow me. The other thing is,
natural keys have real world values real world
247:19 - meaning, right. So you have connections to
real world, meaning. So for example, in the
247:26 - comments, the actual comment in combination
with the user who posted it in combination
247:31 - with the time it was posted, and the page
it was posted on, or any of those four columns
247:38 - to be used as a natural key, well, those have
real world meaning. And as your database develops
247:43 - over time, the database application might
change or be updated, or new meaning is given
247:50 - to the database and what it's supposed to
do. That means that your natural keys could
247:55 - change over time and have new, new meaning.
Or the actual values could change in some
248:03 - instances. And we do not want that, obviously,
because it has to be unique, never changing
248:07 - and never know. If for example, we make it
to where we do have to change the natural
248:12 - keys. Well, that would kind of be like crossing
this one out. And that's possible, like we
248:16 - could update the values of all the keys. But
that's going to require us to update all connections
248:21 - between tables.
248:23 - And that's going to require a lot of resources
from our server. And that's just a bad design
248:29 - in general. So those are most of the cons
of natural keys. So yeah, let's move on to
248:38 - surrogate right. So surrogate keys, well,
obviously, the first downside is you have
248:43 - to add a column to your table, no matter what
even if you have a a, for example, if it's
248:50 - naturally unique. Well, you might like if
you have a comment from a username, well,
248:55 - that username is gonna help ensure uniqueness.
And you still add a surrogate key when you're
249:01 - adding unnecessary data, because you're adding
a new column and you have to store all these
249:04 - numbers. One of the pros of surrogate keys
or is that they're typically numbers were
249:09 - oftentimes natural keys can be words or anything
like that. That's good, because typically,
249:15 - numbers are easy to work with, but not always.
Now, a couple other things. Besides the fact
249:21 - that you have to add a new data new column,
which requires you to store more data. It's
249:28 - that it can be confusing sometimes when all
you're working with is just combinations of
249:33 - numbers. And I have like, we have a column
let's say like komentar for a comments table,
249:42 - and we just have an eye we have the value
like 700 407,462. Well, this kind of clear,
249:51 - it's talking about the user with the ID of
747,462. Sometimes columns won't be very descriptive
249:59 - though. And that would be full into designers.
So make sure you name your columns, right.
250:04 - But when working with other people, you can
sometimes get confused exactly what References
250:08 - What, and you have to do a little bit more
thinking and check the actual database structure
250:13 - the way it's programmed, or however else like
that. So that's a couple things that are confusing.
250:19 - Okay, so now you're probably wondering, okay,
so which 1am I supposed to use? Well, actually,
250:26 - it just depends on what you want to do if
you prefer to use natural or surrogate keys.
250:31 - But typically, you'll want to pick one and
use that throughout all of the database. As
250:37 - a database really weird. There's like database,
data base rather than database. So it's like
250:45 - database anyways. So like, set that aside
to use surrogate keys, well, that means every
250:51 - column should get a ID, or at least a combination
of IDs. Natural if I decide to use natural
251:00 - ones, every column should try to be used as
a natural key, because if we mix and match,
251:05 - sometimes we're gonna have a surrogate key,
sometimes we're gonna have a natural key,
251:07 - and it's going to be super confusing, and
we're not going to know what's going on. So
251:10 - typically, you want to kind of keep one or
the other. The other thing is, I don't know
251:15 - what the other thing was. But yeah, typically
one or the other. Now, for my sake, I personally
251:23 - am going to use surrogate keys, although that's
not saying that they're better in any way.
251:28 - I just prefer surrogate keys, because it's
simple for me, because every time I make a
251:33 - table, I all I got to do is make an ID with
it. Like if it's a user table, all I got to
251:40 - do is make a column user ID, and boom, we're
done. That's all I got to worry about. And
251:46 - I don't really have to worry about ever changing
or ever becoming something different or anything,
251:52 - it's just a random numbers 7254. Well, that
has no real world meaning. Now keep in mind,
252:00 - though, that if you do use surrogate keys,
you shouldn't, you shouldn't
252:03 - have them
252:04 - have any real world value. So for example,
a student ID if we give these student IDs
252:09 - out to the students, that's not really a good
idea to use as the surrogate key, because
252:15 - it's actually an actual key, it has real world
meaning. So those are just some things and
252:19 - you can find tons and tons of stuff on the
internet about natural or surrogate keys.
252:24 - It's basically like a war between two database
sides. Were the natural keys. Oh, were
252:31 - the surrogate keys.
252:32 - You know what I mean? So yeah,
252:38 - don't freak out. Just figure out what works
best for you. There's some minor performance
252:42 - differences. But I mean, I don't really know
all of them. So yeah, believe it or not, I
252:51 - don't know something. I'm kidding. But anyways,
try them both out, if you want, look up stuff,
252:57 - look up, which one performs better, or which
one will work best for your application, or
253:04 - your database, because that's really what
matters. So this is a big subject. And there's
253:13 - a lot of important things. So I'm going to
be separating a lot of these concepts up into
253:18 - separate videos. So the next two or three
videos, this video and two others I think
253:22 - will be over foreign keys, and a lot of things
that have to do with foreign keys. Sorry,
253:30 - anyways, this video we'll be talking about
introduction to foreign keys, and exactly
253:36 - what exactly they do. Alright, so foreign
key is a reference. And what does it reference?
253:47 - It references a primary key. So that's it.
That's the most basic definition of a foreign
253:57 - key. Now, this can be a primary key in the
same table or a primary key in a separate
254:03 - table. So let's kind of see how this would
play out. If we do do some drawing, right?
254:11 - Let's, let's think of a class for a college
database. So this database has call has all
254:17 - the information for a specific college or
multiple colleges. And one table is for classes.
254:22 - We also have a table for instructors and for
users and anything else that's obvious. That's
254:29 - an obvious entity. So let's, let's look at
the class table. So we have a class table
254:35 - with this, draw it out here. Within here,
we could have a class ID which, like I said,
254:42 - we're just going to be using surrogate keys
for most of this. You can do the same thing
254:46 - with natural keys. And if you have no idea
what I'm talking about, just don't pretend
254:50 - I never say anything.
254:51 - So yeah,
254:52 - we have a class ID. That's an example of a
surrogate primary key We can also have a an
255:02 - instructor. You see, so we can have an instructor
ID,
255:13 - right.
255:15 - And we could have, let's say a room number,
because we could have, we could have a table
255:20 - for every single room, which talks about more
information about the room, or I don't know
255:25 - if that's a really good example. Or if they
would say we have a bigger building, or a
255:31 - bigger college, and we have a table for each
building. So that's probably that's probably
255:35 - a better example. So we can say building ID
to say which, which building is in. Alright,
255:43 - so here, here are three IDs. So you can assume
that they're all keys because almost all IDs
255:51 - are going to be keys of some sort. Which one
is the primary key? Well, this one right here,
255:56 - the class ID, this is the primary key because
it's the class table, every single row within
256:02 - this table is going to have a class ID, whether
it be 1234 712-800-4364, whatever it is, it's
256:09 - going to have a class ID every single row.
So every single class is going to have its
256:14 - own ID. We also have an instructor ID and
we also have a building ID. Well, since these
256:20 - are kind of unrelated to the class, you can
assume that they're foreign keys in this example,
256:25 - because we're not going to have an instructor
ID for a class necessarily by itself. This
256:31 - is going to be an instructor ID for an instructor.
256:36 - So that means we have another table for instructor.
So this is our instructors table. I think
256:44 - I'm spelling instructor right. And we have
an instructor in here. Instructor ID.
256:52 - Well, this you can tell
256:55 - these are a reference here, we can also have
a building ID. So this references another
256:59 - table. And that would be the building.
257:06 - And then we have a building ID.
257:08 - So I'm taking forever to write and I can't
even write nice. But that says building ID
257:17 - right there. And this references that there.
So you can see there's a connection between
257:22 - these tables. Now we'll get more into drawing
relationships better like rather than just
257:28 - using wines, we'll talk about more of that
in the future. But for now, we can see that
257:33 - these reference these columns, so the columns
point to each other. And also each individual
257:41 - row is going to point to each other. So let
me explain that a little bit more. When we
257:45 - have a row within our class table, let's draw
this table a little bit better. So I can kind
257:49 - of see how it would work. So let's say this
is an actual example of the values. Within
257:55 - this table, we have a class ID. And instructor
I'm just going to put I and then the building
258:05 - Id just
258:06 - for simplicity, heck, I don't know. Because
I don't feel like writing all that out. So
258:12 - we can have a class ID.
258:14 - And just just to make things more, just to
be more accurate to what a normal database
258:19 - would be, we could say like the name the name
of the class like biology. So we can have
258:26 - a class ID, we could have seven for value.
We could have the instructor ID could be 63,
258:34 - we could have the building ID of 16. And then
the name could be biology. Well, every single
258:45 - column is going to have column rules or requirements.
For example, these two columns here.
258:51 - Individually, this one is
258:54 - going to have a rule that says every single
value within this column. So as we go to the
259:00 - next row, the next value, every single one
is going to have to reference something from
259:07 - the instructor table because it's an instructor
ID. So that's one of the column rules. Now
259:15 - same for the building ID, we could say that
every single row has to reference a value
259:23 - within the building ID. All right, so that
means the row right here, let's say this row
259:31 - individually, so right here, the class ID
with seven biology references, the instructor
259:39 - with the ID of 63 and the building with the
ID of 16. So you can see that the column has
259:49 - a rule set to say that every single value
within this column, every single row is going
259:55 - to have to reference an instructor and a building
now Each individual row, we could say, Oh,
260:02 - this specific row references, the building
and 16, and the instructor 63.
260:08 - You see.
260:10 - So that's kind of how foreign keys work.
260:12 - Let me clear this out, kind of draw it out
a different way.
260:23 - Let's take a look at the, the building table.
260:26 - Okay, so let's just
260:28 - draw little squares to represent it. And let's
say within this table, we're not going to
260:33 - structure the columns or anything, we're just
going to say we have the building, 716, and
260:39 - 14. So these are three separate buildings.
And we could have names for the buildings
260:43 - and all kinds of other things. Now, we have
within the class, let's say this is the class
260:50 - table, right? And we have the class ID. So
the class ID would be like 6438 123, it doesn't
261:00 - really matter what number they are. And eight,
right. And now we're going to have a reference
261:07 - to the building ID. So let's say we have 777
14, right. So here's an example. So over here,
261:22 - we got the class ID.
261:23 - I got the
261:30 - building ID.
261:34 - And then we got the building ID. And then
we got more information about the building.
261:41 - Here, if we wanted, well, you can see that
there's a connection between every single
261:49 - value, every single row within this class
table has a connection with a building ID.
261:57 - So
261:58 - that the entire column building ID has the
rules that every single value within that
262:04 - column has to point to a value within the
building ID of the building table. Now, each
262:11 - individual row has a value that points to
a specific row, within the building ID. As
262:17 - you can see, these are all individual rows.
So let's get a little crowded here. We can
262:23 - see that three of these classes in this class
table, reference one building, and that's
262:29 - the building with the ID seven, and that can
be the room legit building 74, or whatever
262:35 - you want to call your building, it doesn't
really matter. So that's, that's an example
262:39 - of a relationship. Using foreign keys. foreign
keys are what keeps things connected.
262:44 - So let's say the name of building seven was
legit, because I really don't know what else
262:51 - to name it. Well, now we have the value legit
as its name. And we connect with the ID. So
262:58 - rather than putting legit, legit legit, and
having repeating data that could be easily
263:04 - messed up, for example, if legit, was changed
to legit with two T's or changes change the
263:09 - name completely? Well, now with this foreign
key, it's connected, so updates automatically.
263:17 - So
263:18 - yeah, that's kind of how foreign keys work.
Just keep in mind that every table has one
263:27 - primary key. Now that primary can primary
key can be a combination of multiple columns
263:33 - if you want, but it only is defined as one
primary key. For example, we can have the
263:40 - combination of first name plus last name,
this group could be the primary key. But we're
263:47 - not going to have the first name primary key.
And we're not going to have also the last
263:53 - name primary key,
263:54 - because that's
263:55 - to my two primary keys. And we can do that
we can have the combination of the two. But
264:00 - with foreign keys, you can have multiple columns
having foreign key relations to different
264:08 - tables. But keep in mind, each column can
only have one reference. So in the class example,
264:14 - we had a teacher ID, well that teacher ID,
here's the class table. And let's say the
264:20 - teacher ID is seven, six and five.
264:26 - Well,
264:28 - this can be a reference and we could also
have another foreign key we could have the
264:33 - building ID which can be 612, and eight. So
although we only have one primary key in a
264:42 - table, we can have multiple foreign keys,
referencing different tables, if we wanted
264:46 - it to be where the the, the instructor, I
think it's supposed to be an AI. So the instructor
264:55 - to where the class can have multiple instructors.
Well, that's a many to many relationship and
264:59 - we're going to have to design our tables with
an intermediary table. So hopefully that's
265:03 - kind of making sense, I just want you to realize
that the primary keys are what sort each individual
265:10 - tables, the foreign keys are what Connect
tables, and that you protect that integrity
265:16 - with foreign key constraints, which we'll
be talking about. In the upcoming next few
265:21 - videos. In this video, I wanted to talk a
little bit more about foreign keys, and a
265:28 - characteristic known as not null. Alright,
so this this keyword here might vary from
265:36 - relational database to relational database,
but it's probably something similar to this
265:41 - not know, which we learned about No, and we
talked about this over here, it's basically
265:45 - saying you, the database will not accept someone
not answering that column, for example. So
265:53 - if it's not know, you have to give that call
and the value every single row. So the rows
266:00 - are each individual entry within the table.
If you have the column characteristic of not
266:05 - know, for every row, it's going to be required
that it has a value. So think of like a fax
266:11 - number. Does everyone have a fax machine?
No, most people don't. So if I set it as not,
266:18 - no, and I didn't give it a fax number, then
it would throw an error and cause problems.
266:25 - That's, that's an example of how not all works.
Now, this is important when it comes to foreign
266:31 - keys. Because it has to do with what's known
as cardinality, which we'll talk about that
266:37 - when we start designing databases a little
more. But it's basically whether or not a
266:43 - relationship is required. So
266:50 - this is going to dictate what kind of values
we can put within our table back to the fax
266:56 - machine, if we have it to where it's
266:58 - not null.
267:01 - That means every single value, I mean, every
single row has to have a value. That also
267:07 - means that if someone doesn't have a value,
they might not be able to put any information
267:13 - in this table. So by putting this restriction,
you're eliminating all rows that aren't going
267:21 - to have a value, you're preventing them from
happening. You see what I mean? Yeah, so if
267:29 - the cases where you do want people who don't
have fax machine numbers to be able to enter
267:34 - data into your table, well, then you would
not want to use not no as a characteristic,
267:40 - because that's going to prevent them from
doing that. Now, this is important when it
267:44 - comes to foreign keys. Because if we require
a relationship, we said as not No. And that
267:50 - means every foreign key value for that column,
every single row is going to have to have
267:57 - a relationship for that. So one of the biggest
differences between primary keys and foreign
268:03 - keys is that primary keys are required all
the time, never changing. Never know. Right?
268:10 - Drop munchak, dang. Well, foreign keys are
a little different. Because we can have them
268:17 - to where they're not required, they can be
empty, because sometimes that relationship
268:21 - is not there. Or they could update like we
could, we could have a new relationship in
268:29 - this table, which we want. We don't we want
to eliminate as much possible updates as possible.
268:36 - But sometime that's required. And that's why
we use foreign keys to keep things connected.
268:40 - So when things are updated, they update across
the platform.
268:45 - Now,
268:47 - we don't want the primary key values to change.
But we could have the foreign key references
268:54 - change. For example, let's say we have a table
over here. And we'll just have it will be
269:01 - will have to be carbs, okay? Or whoops, have
the car,
269:04 - right. And we have
269:06 - two rows and have a car with the ID of six
and a car with the idea with the ID of 10.
269:12 - Right. And we have this guy over here. And
we have a table for him. What is making the
269:19 - user table and let's say for some reason,
we wanted to make a connection of what car
269:23 - he owned. Well, he might currently own six,
right? And we don't ever want the value of
269:31 - six to change and still be talking about the
same car. Let's say this car is this one over
269:36 - here. This is some flames. Right and this
one over here. We got a legit car. All right.
269:51 - So these are two separate cars. 10 talks about
this car six talks about this car. We don't
269:57 - ever want it to happen to where this number
gets up. Unit eight, or we change the primary
270:03 - key, and it's still referring to the same
exact car, because then we have a changing
270:07 - primary key. But with foreign keys, it can
change in the sense that, oh, I no longer
270:14 - own this car. Now, I own this car. So we didn't
have any primary keys updated. But the foreign
270:23 - keys, which would be this connection, right
here, did update. Alright. So that kind of
270:29 - is a little bit of a difference between primary
keys and foreign keys, primary key value should
270:35 - never change, foreign key values can change,
because references change. Hopefully, I didn't
270:42 - just lose my train of thought, I think I think
I'm going but kind of hit a blank here for
270:49 - a sec. Okay, so let me just illustrate this
in a college right. One of the important things
270:56 - between these tables that have a primary key
and a foreign key connection to that primary
271:01 - key is that they have to be the same data
type, which is the type of data whether it
271:05 - be int, or character or date. And basically,
it has to have all of the same characteristics
271:11 - like the collation or the character set or
the storage engine. Now, the only thing that
271:20 - can vary is the nominal characteristic. Because
if we have the primary key over here, well,
271:26 - we know that the primary key is never know.
So we always have not know, for the primary
271:33 - key, I'll just put an N for sure. The foreign
key on the other hand, it's not always required
271:40 - to have a connection. For example, in that
previous example, we had the person the user
271:45 - table and had this guy over here. And then
we have this car table of the cars that the
271:50 - user owned, right? He could have one car,
right? Well, he might not currently own a
271:55 - car, therefore, we don't have a connection
to this table. Therefore, this connection
272:00 - is optional.
272:04 - Or not required. Yeah, that doesn't even look
like English, but close enough.
272:16 - So let's think of a another example. If we
have a college, well, we might be in early
272:22 - in the semester where every single class before
people have registered, every single class
272:27 - doesn't have an instructor yet, and we're
still trying to find an instructor. Although
272:31 - we know that's the class that we want to have.
So that means we have an instructors table,
272:36 - we'll have the instructors over here, and
we have a class table. A class table is going
272:42 - to have a foreign key pointing to the instructor
for the instructor of that class. Unless the
272:48 - case of a many to many where multiple instructors
can teach multiple classes, then we would
272:53 - need an intermediary table. But that is not
the case here. You need to learn more about
272:58 - that check my relationships video. But for
now, we would have a class ID
273:06 - and an instructor ID. Right. And then over
here, we have an instructor at
273:15 - this it says ins instructor close enough right?
Now this is going to be a reference to this
273:22 - over here. Now what kind of values is this
going to accept? Let's give some examples.
273:30 - Let's say we have here's a row, we have the
class ID seven, the instructor ID at three,
273:36 - and we'll add a call and we'll make the name
of the class. We have a call minutes math.
273:42 - Right? And then we can have another value
within here. I think I'm off screen now. Then
273:50 - we can have an instructor over here. His name,
his ID could be seven. And his name could
274:01 - be
274:02 - shake. Right?
274:03 - So this class ID is seven yummy changes in
the gonna get confusing. Let's make this 16.
274:11 - Alright, so this class ID seven. And it's
by an instructor eight, which we don't actually
274:19 - have over here yet. So that means we either
have another row or we have an error which
274:23 - because we never want that to happen. So let's
say we have another class. Got any room. Okay,
274:28 - we have another class over here. And it's
it's numbers eight and it's taught by Caleb
274:33 - right? So now we have an instance of a class.
We got the class ID seven, the instructor
274:41 - ID eight, and the name math. So the instructor
ID points to this Walker, this instructor
274:49 - over here. This is the parent I'm sorry, this
is the parent This is the child because this
274:54 - is a foreign key reference to the parent.
So that means This relationship is a foreign
275:03 - key. Now, with the not normal thing, if we
made it to where it's not know, if we added
275:12 - the characteristic,
275:14 - not
275:15 - know, or that means this row is going to have
to have a value for the instructor ID, that
275:26 - means every single value for instructor ID
is required. What does that get rid of, that
275:35 - means it's impossible to put a class in this
table that does not have an instructor ID,
275:41 - that could cause a problem if you have a class
created, but you don't have an instructor
275:45 - yet, or if the instructor drops out, and you
have to find a new one. So this one might
275:50 - be a bad time use not know, if we got rid
of that. Well, now we could have a class with
275:57 - a primary key, but no foreign key connection.
Now we have a class with the idea seven and
276:04 - it's met. And the the current teacher, we
don't have one. And we still have this guy
276:10 - over here. He's not teaching that class, but
he's still in the system. Jake's still in
276:15 - the system, the class is still on the system.
That is a good example. So for this one, not
276:22 - an old might not be the best idea. Other examples,
having nano would be a good idea because it
276:27 - forces that relationship to be there. You
only think of another quick example. Real
276:32 - quick, quick example real quick. If we had
two, two entities, we had a card for a credit
276:41 - card company. So we had the card. And then
we had the person holding the card. So the
276:47 - person who bought the car or getting the card
from the bank, and he's using it to buy their
276:52 - groceries and their gas, and they're breaking
up 1000s of dollars in debt. Well, that person
276:58 - would have relationship with this card, because
he's the card holder. That's the car. Now,
277:04 - if if we had a table for this, we probably
have a card table, and we'd have a person
277:09 - ID, which would reference the person table,
right? If we set this to not know, that means
277:17 - every single value or every single row within
this card table is going to require a card
277:27 - owner. If we had if we got rid of this, that
means we could have cards in here that were
277:32 - outdated, that don't currently have an owner
because there's no connection, we broke that
277:36 - owner, or new cards that haven't been given
given out yet. So if you want this table to
277:42 - just be for cards that currently have an owner,
so we can have our own cards. Well, then we
277:51 - could have a a nominal column with the same
data type as person ID. Now every single value
278:02 - is going to have a person ID Does that make
sense? So that's kind of the introduction
278:08 - of not knowing how that works with foreign
keys and how sometimes you will want them
278:13 - to be not known. Other times you want them
to be nullable or not required. I got a bunch
278:22 - of writing on the board. But don't look at
it yet. Because I just want to talk to you
278:25 - guys for a minute. I just wrote it. So you
won't have to watch me write like 50 100 words
278:29 - is that to be boring. So instead, I'm just
going to talk instead. So much better, right?
278:35 - Anyways, last video throughout this series,
we've talked about foreign keys. And as we
278:39 - know, they keep connections between tables
in a database. So table one, table two, boom,
278:46 - foreign key, connect from this foreign key
references the primary key of this table over
278:52 - here, that's kind of how foreign keys work,
they protect the integrity of our database.
278:58 - They keep everything consistent. Think about
if if there was no foreign key constraints,
279:04 - which keeps keeps it updated and everything,
then we would have to manually update all
279:10 - connections between tables. And that'd be
a big waste of time. And it just be easier
279:15 - just to store everything in one giant table,
which both solutions. either manually doing
279:22 - it or storing everything in one giant table
is not going to work. So we need foreign key
279:27 - constraints to protect the integrity of our
database, right?
279:32 - It's called referential, referential integrity,
it's big words. Alright, so now this concepts
279:43 - these words might be specific to a certain
relational database management system. So
279:49 - these are from MySQL, but if you're using
a different relational database management
279:54 - system, yours might be a little bit different.
But in general, the concepts are pretty similar.
280:00 - So you're not wasting your time if you don't
use MySQL, because you need to understand
280:04 - how foreign key constraints work. All right,
cool. So first of all foreign key constraints,
280:11 - make sure that if you update the parent, the
children are going to update or cause an error
280:16 - or something like that, it's up to you, you
can make the decision. And it's also going
280:19 - to burn prevent you from creating children,
when there's not a parent that are that with
280:27 - that primary key. For example, if we have
five users with the user's ID, 2468, and 10.
280:34 - And then I make a comments table, and I add
a row that's like, from the user 745, well,
280:42 - that person doesn't even exist, so that's
not going to work. So that's why foreign key
280:48 - constraints are important, because they once
again, protect our database, and make it pretty
280:53 - much self managed, rather than us having to
manually update everything. So let's begin.
280:57 - Alright, let me get a piece of chalk. This
one looks nice, getting pretty low. This is
281:03 - the biggest piece of chalk I have left. Alright,
so we when we create SQL statement, we can
281:09 - add these two key keyword phrases here on
delete and on update. This refers to the foreign
281:17 - key constraint. So when we, but it's talking
about the parent, so when we update the parent,
281:24 - we want the kid we Superfly. When we update
the parent, we want the children to do something.
281:30 - When we delete the parent, we want the children
to do something, that is what these keywords
281:35 - mean. So these keywords, it's talking about
the foreign key constraint. And it refers
281:46 - to the parent.
281:52 - All right, so let's just draw some basic tables
just to kind of keep things I'm not going
282:00 - to give any specific examples yet, I'll just
kind of draw things out. So let's say we have
282:04 - a parent here.
282:11 - And as you learned in previous videos, the
parent is the primary key, right? And then
282:16 - let's reference this primary key with a child.
Let's not draw this line yet. And then we
282:25 - have a foreign key. This, this primary key
is a column within the parent. And every single
282:31 - row has a unique value, the foreign key is
a column within the parent, and it references
282:38 - the primary key. So the say the value 400
in a row could reference the value 400 in
282:44 - this row, and a row of this table, you get
I've explained it enough. Now let's just make
282:51 - another child table. So these are both foreign
keys that reference the same primary key.
282:59 - But they're two separate tables. So yeah,
we can have a user table and then we could
283:03 - have a, a comments table and an Orders table,
for example. They both are bought or commented
283:11 - by a user. So these foreign keys reference
primary keys, so every single value within
283:22 - the table of the children within the foreign
key column needs to be a value that reference
283:28 - that is present in the parent column. Now,
these these values right here, these options
283:37 - refer to the parent. So when we delete the
parent, or when we update the parent, we want
283:45 - the same thing to happen to the child or whatever
the options are, and we'll talk about the
283:50 - options in a second. So that's kind of how
these work now just to kind of clear things
283:54 - up I'm going to erase these words here just
because it's getting a little crowded you
283:58 - know, I want it to be peaceful. Okay, so this
is kind of how it's working foreign keys pulling
284:08 - back to the primary key these options refer
to that what what happens to the parent? Now
284:14 - these these options right here these refer
what happens refer to what happens to the
284:21 - child Okay, now it's getting real confusing.
There's arrows everywhere, like graphs and
284:28 - diagrams and but you'll get it Don't worry
restrict. You might also hear as no action
284:35 - is well at least for my SQL in different database
management systems. These might be different,
284:41 - but anyways, restrict is going to throw an
error. So if we try to like, we can give we
284:47 - can give one of these for each option. So
on delete, we can either give restrict, cascade
284:53 - or set no or No. on on delete, we can have
it restrict cascade or said no to To add more
285:00 - arrows, you know, but let's say we're working
with delete right now. And we wanted to, we
285:07 - want to use restrict. So within our SQL statement,
we could say on delete, restrict the on delete,
285:14 - restrict, and that is going to give us an
error whenever the parent is deleted. So if
285:19 - I tried to delete the user, with the ID, I
don't know I'm writing all that out, let's
285:25 - just say the ID of 504. And then this child
has a row that has 504, within the foreign
285:33 - key column, well, then it's going to throw
an error, and it's not going to happen, and
285:37 - the parent will not be deleted, not gonna
happen. So that's how cascade on Delete works.
285:43 - I'm sorry, restrict on delete, now restrict
on update if we updated that parent and change
285:49 - their primary key. So let's say we change
504. And these, these children both reference
285:56 - 504 with the foreign key, and then we change
this to 508. And it's not going to work. And
286:04 - it will go back to what it was originally.
Because we have it restrict, we're not going
286:10 - to let that happen. You see. All right, what
about the next option, cascade cascade, we'll
286:14 - do whatever we do to the parent to the child.
Let me clear this up a bit is confusing me.
286:25 - smearing chalk all around, you know, totally
helping. Alright, so now if we cascade on
286:31 - delete, that means if we delete the parent,
we're going to delete the child as well. So
286:35 - we delete 504. And both children are deleted,
boom, child deleted. So now 504 doesn't exist
286:42 - at all. So like, for example, if this was
a comments table, and we had a comment from
286:46 - the user with the user ID of 752, and we deleted
752, the user will then obviously, all of
286:53 - his comments by him should be deleted, too,
because we'd have a comment by user that doesn't
286:58 - exist, which does not, which isn't supposed
to happen. So cascade on Delete will do that
287:04 - on update is, if for some reason, we updated
the primary key, which obviously shouldn't
287:09 - happen, because primary key should be never
changing. But you still want that protection
287:14 - on your database. On update, if we have cascade,
if we change like 504, let's say these people
287:21 - exist again.
287:22 - Skinny, right? So it's because, okay,
287:24 - so these people exist, again, 500, for 500
for these references, 504. And if we update
287:32 - this to 508, well, that means all of the children
will update as well. So now, it connects within
287:40 - within different tables. Finally, we have
Sentinel. And what that'll do is it will basically
287:46 - just set the children as normal for that specific
value. So if we deleted the parent, that this
287:55 - is just going to get rid of the value, the
row should still exist. But the actual foreign
288:02 - key reference, it no longer references anything,
it's empty. So there's no it's not referencing
288:08 - anything. So the column for that row. So like
the, let's say, we have a comment. And it's
288:17 - a comment from Billy Bob with the ID of 504.
If we delete that, whenever we're going to
288:24 - have a comment, with no poster, or no comment,
or at all, it just no value. That's all said
288:31 - no one will do for us on delete an update,
same thing, if we change the ID of the parent
288:37 - changed it from 504 to 508. Well, all of the
children are going to be set to no value as
288:45 - well. All right, now there's one important
thing when he was set know that children have
288:50 - to have, they can't have I should say, the
not no characteristic. We talked about that
288:56 - in previous videos. I'm just gonna put an
end for sure. If this is not no, and we update,
289:05 - if we have on update set, no. And we update
504 to 508. Can you even I've ever gotten
289:13 - this off this whole time? reset five or four
or 508? I think you can see that one. You
289:21 - can we change five or four or five away? And
this is not No, it's gonna be like, No, we
289:26 - can't do it because we can't set it to No,
because it has the nominal characteristic,
289:31 - which means every single row has to have a
value for that attribute or that column. So
289:36 - I'll give an error. And I'll go back to how
it was. So that's an introduction of foreign
289:40 - key constraints. Sorry if I talk fast, but
yeah, cool stuff. It's important stuff. So
289:46 - learn it, study and learn it for your specific
relational database management system. In
289:55 - this video, we'll be talking about simple
and composite and compound keys. These are
290:00 - categories of keys. So like when you define
a database, you can say, this is a primary
290:05 - key, or you can say its foreign key. But you
don't have to say, Oh, this is a natural,
290:10 - simple. Primary Key, like those are just categories,
you have to define that within our database.
290:17 - So these these terms that we're learning or
more for design sake, so you know, the best
290:21 - design for your database, but you don't actually
have to define it, right? Like, for example,
290:28 - this piece of chalk right here, you can define
this as a white piece of chalk. Now, what
290:33 - kind of white piece of chalk? Is it? Well,
it's x brand or whatever, you don't have to
290:37 - define that when you're telling someone Oh,
here's a piece of chalk. That was the worst
290:42 - example ever. Moving on. Alright. Simple and
composite. Okay, so simple means that the
290:57 - key consists of one called composite means
it consists of two or more columns. This is
291:06 - most common with natural keys, because natural
keys can be a combination of multiple columns,
291:12 - whereas a surrogate key is just a random number
one column. So surrogate keys are simple composite
291:19 - keys or multiple columns. So for example,
we can have a first name plus last name, plus
291:26 - email. This could be an example of a composite
key because this whole group as a whole is
291:34 - the primary key. So we could have
291:36 - Jim,
291:39 - Jake, and
291:43 - legit
291:47 - are awesome at whatever's, blah, blah, blah.
And then we can have another another one with
291:52 - the same exact name, Jim, Jake. And we can
have a different email, these two are still
291:59 - separate, they're unique. Because the combination
of the three are unique, Jim and Jake, repeat,
292:05 - but the email is different. So these as a
whole, are different values for primary keys.
292:12 - So that's an example of a composite primary
key. The reason is, is because it consists
292:17 - of three columns 123. This is an example of
a composite key, a composite natural key to
292:28 - be specific, because we're just we're using
things that are already naturally being stored
292:32 - within our database. Now let's think of a
simple key, natural one, or username would
292:38 - be a good one is the neck username can be
something that can be used by itself as a
292:44 - key, it's simple, because it's only one column.
Pretty simple. I
292:49 - know. Alright,
292:50 - so I want to talk about another term you might
run into. And that is compound. Okay, now,
293:03 - I want to clarify that some people and some
relational database management systems don't
293:12 - clarify the difference between these two composite
and compound terms. And they just use them
293:18 - interchangeably as meaning a key with multiple
columns, some people go a step farther, and
293:24 - break these up into two separate terms. So
we're going to be defining both of the terms,
293:29 - but you might see them used interchangeably.
So don't be so super technical about the details.
293:35 - And there'll be like correcting people, Oh,
hold up, that ain't a composite key. That's
293:38 - a compound key, the because most people are
just gonna look at you like you're an idiot,
293:43 - and not really care. Alright, so anyways,
moving on. A compound key is basically,
293:51 - when
293:52 - it's a call, it's a key that has multiple
columns, and they're all keys themselves.
293:59 - So this is the most common example. This is
for intermediary tables. So think about like
294:06 - this. We have a table used to store information
about videos, we could say it's a video table.
294:14 - We could also have another table here, we
can have a user table. Actually, here, let's
294:20 - let's do it this way. We're gonna have a comment
state. Okay. And then within this comment
294:29 - state, we're gonna have a column of what video
they're commenting on. You see, well, this
294:34 - is a many to many relationship, right? So
this this might not work out well with database
294:42 - design, because one user can comment on multiple
videos. And then one video can have comments
294:53 - from multiple people. So the best way to do
this rather than having two separate tables
294:58 - like this We would create a video table. And
then we'd have an intermediary table. And
295:06 - this would be video comments, or user comments.
You see what I'm saying. So we get a connection
295:16 - between the user and the video to create an
intermediary table. And it's split up with
295:21 - two keys. So we have the user ID, and then
the video ID and then we could have another
295:22 - column for the message, or the date or whatever
else. Well, you can see, if you don't know
295:23 - what I'm talking about, go see my videos over
designing many to many relationships. But
295:24 - otherwise, if you know I'm talking about moving
on, you can see that the entire key itself,
295:25 - every user and video ID combination has to
be unique. That might, that might be a bad
295:26 - example, because a user could comment on the
same video more than once. So this is probably
295:27 - not the best example.
295:28 - Let me think of a good one.
295:29 - But anyways, this would be a an example of
a, we could add another column in here to
295:30 - make a unique, we could have the date and
the message. So the message has to be unique,
295:31 - and the user ID has
295:32 - to be unique. And the video ID has to be unique.
That'd be a composite key, a compound, a compound
295:33 - key, missing, for example, real quick. So
a good example of this would be for college,
295:34 - we could have user we can have a student,
student table. And we could have a class table,
295:35 - right? So this table holds information about
the student, this information table holds
295:36 - information about the class. Now, how do we
show enrollment, should we make columns for
295:37 - every student here now, because it's a many
to many relationship, that means we need an
295:38 - intermediary table between the two. So this
is a good example, sorry about my bad example
295:39 - in the last one, but that's a good example
of a composite key, because the two columns
295:40 - themselves wouldn't be enough. So we'd have
to add another one, which is not a key in
295:41 - itself. But for this one, we could have a
column, we'll name the table, student classes,
295:42 - or the student class, whatever you want to
call it, student classes. And within here,
295:43 - we could have the IDs, student ID, and class
ID. Now, this combination between student
295:44 - ID and class ID must be unique. So let's say
we have the value seven and four, seven and
295:45 - six, seven, and seven, that would work. But
if we had something like seven and four, again,
295:46 - we'd get an error, because that's already
in there. And that's not going to work out
295:47 - so well. So the combination has to be unique.
And these are also both foreign keys, which
295:48 - point to another table. So both of them are
keys. And the primary key is compounded. Because
295:49 - we have the student ID, and the class ID as
one giant ID or one giant key, I should say,
295:50 - because the combination has to be unique.
We can repeat seven on this side. And we can
295:51 - repeat like six on this side. But we can't
repeat the combination of seven and six, they
295:52 - have to be unique as a whole. So composite
keys. That's when you have at least one is
295:53 - a is not a key in itself. For compound, they
all have to be keys. So for the composite.
295:54 - Let's look back at the the example we gave
in the last one with the videos, the video
295:55 - comments, let's say this is the intermediary
table blown up just so we can see it real
295:56 - big. This is the user ID. And then we have
the video ID. Well, this isn't sufficient
295:57 - to make uniqueness because a user could comment
on the same video more than once. Thank you
295:58 - for replying to comments or something like
that. So we need another column, we could
295:59 - add the timestamp or we can just say the time
column. And this is going to keep a unique
296:00 - time because you can't comment on the same
video at exactly the same time twice. Right.
296:01 - So that would ensure uniqueness so we can
ensure these three as a whole are unique.
296:02 - That's an example of a composite key, because
at least one column is not a key in itself.
296:03 - This is a key because it points to a user's
table. This is a key because it points to
296:04 - a videos table. This is not a key because
it's just a column for That intermediary table.
296:05 - So that those are the three terms I want to
talk about in this video. One other thing
296:06 - I want to talk about real quick, I'm not going
to say what the best technique is. For this,
296:07 - I'm just going to say what some people do
with an intermediary table, some people will
296:08 - give it a surrogate key on top of the compound
key. So for example, with the college, keep
296:09 - switching back and forth between examples,
I'm probably confusing you, they might add
296:10 - something, such as enrollment ID.
296:11 - And then we have the student ID. And then
we have the class ID. These are both foreign
296:12 - keys. And they might use this enrollment ID
as a, just a surrogate key for this table.
296:13 - Although it's not a requirement. For certain
relational database management systems, some
296:14 - relational database management systems, or
frameworks or something, are not going to
296:15 - be able to work well with composite or compound
keys. So you might need to have a simple key
296:16 - which in that case, you could still have the
idea of a compound key. This group right here,
296:17 - the student in the class, didn't have that
index or whatever you want, or you can just
296:18 - enforce uniqueness with that. But then you
can use an enrollment ID, so you can have
296:19 - like seven. And then you could have student
six in the class four, and then you get eight,
296:20 - with the student four in class 12. And then
you can have nine, with the students 16 in
296:21 - class four, and then we could have 10, with
student 16, in class, 12, and so forth. That's
296:22 - just an example of what some people do. This
video is going to be a quick review, I'll
296:23 - actually be using my notes here just to make
sure I get the main everything because I'm
296:24 - not going to try to memorize like 10 videos
or content has this crazy, crazy eye. But
296:25 - anyways, first thing we started with was super
keys. So a super key was just any number of
296:26 - columns that make ensure uniqueness, but then
a table. So we have super key. Which I still
296:27 - don't know why that's only one word, which
just confuses the heck out of me. So someone
296:28 - please explain that, then we had a candidate
key. Now the difference between a super key
296:29 - and a candidate key key is that a candidate
key is the least number of columns used to
296:30 - enforce uniqueness. Now you cannot you can
have multiple candidate keys if you like a
296:31 - certain group. So if that's the case, you
have to pick one as your primary key. The
296:32 - primary key is the one you select as the the
main key for your table, all the other ones
296:33 - you can assign as alternate keys. Which, if
that's the case, they still can be unique,
296:34 - you can still enforce uniqueness upon those,
but they're not used as the main key within
296:35 - your table. What else? Alright, well, then
there's, that's pretty much the all the ideas
296:36 - with finding a primary key. And then when
you reference that in another table, you have
296:37 - what's known as a foreign key. foreign keys
reference, a primary key is a connection.
296:38 - That's how you make connections between tables.
If you have a user user table, and then you
296:39 - have a is a comments table. Well, the comment
is posted by a user, so you can reference
296:40 - that user in that comments table. And we talked
a lot about that. So I'm pretty sure you guys
296:41 - got that
296:42 - pretty well.
296:43 - Now, this is pretty much all you got to worry
about four primary keys and foreign keys,
296:44 - you just got to worry mainly about these two.
These ones are less important about finding
296:45 - and figuring out. These two are essential.
I'm not saying these aren't important, they're
296:46 - important. But really defining a super key
is kind of pointless when you know there's
296:47 - the candidate key you don't have to say, Okay,
well all of these define uniqueness. That's
296:48 - one. That's one super key. All of these define
uniqueness. That's another super key. Oh,
296:49 - finally, we're down to the correct size for
a candidate key. That's our candidate key.
296:50 - And then I'm check marketing By the way, just
so you know what that is. And then oh, okay,
296:51 - we got a total of 10 candidate keys, five
super keys. Now let's find a good primary
296:52 - key. Oh, this one looks nice. We'll use that
one we'll set the rest is alternate keys.
296:53 - That's just complexity that is unnecessary
when it's easier just to say, oh, there's
296:54 - a candidate key. It's already the smallest
that we need. We'll use that as our primary
296:55 - key. And now let's see if we have any other
alternate keys. We don't have any good ones
296:56 - aren't too bad. It's fine. who really cares?
Oh, we do have some good ones. Oh, yeah. Let's
296:57 - set those an index and make sure they're unique.
And we'll use this for some searching later
296:58 - on. That's an example of how you would find
a primary key. You don't have to make this
296:59 - manual labor for like 20 hours to figure out
which primary key to use. Alright? Then you
297:00 - reference that primary key in other tables
foreign key. So that's why these two are the
297:01 - most important foreign and primary, those
are the two you should focus on the most and
297:02 - memorize, okay, the alternate candidate super
key, and they're kind of important, but not
297:03 - as important. Alright, so let's take a look
at primary for. let's just, let's clear this
297:04 - out for a second. Alright,
297:05 - Rob Merritt.
297:06 - Now, there's some categories, dude, I dusted
now it's like I can breathe. There's some
297:07 - categories of keys that we can talk about.
So the first one was surrogate and natural.
297:08 - So surrogate natural keys. a surrogate key
is just a random number that has no real world
297:09 - value, or no real world meaning, just like
an ID, user ID, student ID, caller ID
297:10 - classroom ID,
297:11 - store ID, sale ID, record ID, song ID, picture,
ID, whatever you want it to be, I
297:12 - don't really care.
297:13 - So long as it's an ID, and it's a surrogate
key, then,
297:14 - yeah, yeah.
297:15 - I don't know what I just did there. But anyways,
natural something that's already naturally
297:16 - in the database. And you just define it as
your key. Now, typically, when you want to
297:17 - use keys in your database, which you will,
because it's your relational database, you
297:18 - will pick either surrogate or natural keys,
and you will use them for throughout the rest
297:19 - of the database, you're not going to switch
from surrogate and natural, you're not going
297:20 - to be like, Oh, this one has a natural key,
we'll use natural, but this one doesn't, and
297:21 - we'll make it surrogate. That's a bad design,
you should be able to enforce uniqueness by
297:22 - the columns that are already there. And then
you can add a surrogate key if that's what
297:23 - you want to do. And if by any chance, you
cannot possibly define uniqueness without
297:24 - a surrogate key, you're pretty much required
to use the surrogate key. But that situation
297:25 - should try to be avoided. But there's times
when you literally cannot find a natural key
297:26 - that will be sufficient. So you guys kind
of follow it. I mean, surrogate keys, random
297:27 - numbers, natural keys already in the table.
Cool. Simple. Speaking of simple, we'll talk
297:28 - about the simple key. Alright, so we got simple.
We got a composite
297:29 - compound.
297:30 - Okay, so simple is basically a one column
key, composite and compound, our multiple
297:31 - column keys. We talked about those in the
previous video, I believe. Yeah, so that's
297:32 - pretty much all the categories of keys. The
when you define your primary or foreign keys,
297:33 - you're not gonna have to specify if it's a
surrogate natural, simple composite or compound.
297:34 - This is for our sake, to design the best way,
because it's, for example, do you want to
297:35 - use composite keys? Or do you want to use
simple keys? That's a good question. If you
297:36 - decide you want to use simple keys, which
by the way, surrogate naturals kind of thing
297:37 - you do throughout your entire database, you
can kind of switch back and forth from simple
297:38 - and composite. For example, you could have
a user's table, and we could have a look,
297:39 - I sorry, students table, a class table, and
then we're gonna have a, an enrollment a with
297:40 - the students taking certain classes, we could
use a week, I guess we can use a compound
297:41 - for this table. And then we could use simple
for these tables. That's something you could
297:42 - do. But you should still use either surrogate
or natural, just pick one and use it throughout
297:43 - your database. Hopefully, I'm not talking
too fast, because I'm going pretty quickly.
297:44 - If I am just let me know as I see a column
A couple inches, come down a couple decibels,
297:45 - because kind of hyper, okay. Now, the other
thing we talked about was foreign keys and
297:46 - foreign key constraints. Well, the main kind
of foreign keys, the main kind of foreign
297:47 - key constraints, were on update, and on delete,
these protect our integrity of our database.
297:48 - You define these, whenever you make a table,
when you when you use the CREATE TABLE statement
297:49 - or create or whatever your relational database
management system does to create tables, the
297:50 - chances are, you're going to say that
297:51 - you have a foreign key. I'm just
297:52 - gonna put fk for short, and then you have
a constraint and you can usually name that
297:53 - constraint. So you can be like blah, blah,
blah, and name it whatever. And then we could
297:54 - say on update,
297:55 - or on delete, and the options were the ones
I thought you were do nothing or basically
297:56 - thrown air or we could update the children
or we could basically get rid of the value
297:57 - for the children. So that would be restrict
cascade and set. No. But your relational database
297:58 - management system might use something a little
bit different, which is fine. Yeah, that's,
297:59 - that's about it. Yeah. Yeah. That's pretty
much it.
298:00 - Cool. Cool.
298:01 - So yeah, that's a summary of keys. So yeah,
well, that was a
298:02 - ton of stuff.
298:03 - So there's a couple different names for this.
So basically, it's just a standard. It's a
298:04 - standard for drawing databases. And the couple
terms you might hear, or acronyms I guess,
298:05 - e AR, model, E, AR, D, or
298:06 - E AR model,
298:07 - or just database design, whichever one's easiest.
But basically, these are some terms used to
298:08 - refer to a method used to draw out your entire
database structure. These videos have been
298:09 - drawn tables and lines and drama, drawn tables
and lines and stuff, and all kinds of cool
298:10 - things like that, but actually haven't officially
designed any database. So what we're going
298:11 - to do now that we've learned most of the concepts,
the only thing we haven't really covered is
298:12 - normal forms, which we'll be getting into
those. But anyways, and I'll make them easy,
298:13 - don't worry. So what we're going to do is
we're going to learn the standard for drawing
298:14 - these databases, we're going to practice with
that. And then we're going to learn the normal
298:15 - forms. And then we're going to design databases
for a lot of stuff oriented. So we're going
298:16 - to be getting into the standards of drawing
databases. And obviously, the standards kind
298:17 - of rough. I mean, there's, there's not a specific
way, you have to do everything, because that's
298:18 - annoying and dumb. So what we're going to
do is we're going to be drawing pretty simple
298:19 - things. And I'll just be kind of illustrating
kind of how that works in this video. So what
298:20 - this means is enhanced Entity Relationship
model, enhance relationship diagram, enhanced
298:21 - relationship
298:22 - model.
298:23 - Yeah, I think that's what they stand for.
I don't think it stands for relation. I think
298:24 - it stands for relationship, which there's
a difference, as you should probably know,
298:25 - by now. A relation is a table, a relationship
is a connection between two tables. Yeah,
298:26 - so anyways, yeah, so we're gonna be talking
about these design techniques are probably
298:27 - this call and like, er, D er, er, er? Or,
who knows? But yeah, the way you do it is
298:28 - you define your database structure. So anything
that is DDL pretty much data Definition Language
298:29 - part of SQL, we talked about that a long time
ago. We're not going to define the actual
298:30 - values. For example, if we have a table for
users, we're not going to put in a row. Oh,
298:31 - Caleb curry with the password of sweet pie
is delicious. 24. And the email of Yeah, yeah,
298:32 - yeah, yeah. yeah.com and the telephone number
of 100 you wish or anything like that. We're
298:33 - not going to put anything like that in there.
We're just going to put the columns username,
298:34 - password, email, telephone, three d that is
so cool. Okay, anyways,
298:35 - let's get started.
298:36 - So to draw a table, database table, you just
draw square, it's like super easy, okay. Well,
298:37 - how he would evolve and so easy, right. And
obviously, doing this on a chalkboard is not
298:38 - very convenient, because for one, you're limited
in space. And for two, most of you guys don't
298:39 - have chalkboards. And for three, I don't know
a third reason. But most of this is actually
298:40 - done on a computer. And we will be doing that
hopefully soon. So stick with these concepts
298:41 - we'll be getting into on the computer design
for whatever reasons. And obviously, as I
298:42 - make new videos in the future, that's what
I'll be doing. So for now, we'll learn the
298:43 - concepts. And you can download Entity Relationship
design programs, such as MySQL Workbench,
298:44 - I made other ones like verta bello or something,
I don't remember what it's called. And a couple
298:45 - others, which you can design for any relational
database management system on that one. So
298:46 - go check out my other videos, or my playlist,
I think it's under reviews or something. But
298:47 - I don't know, look up database design on my
channel, see what I got. You can also just
298:48 - look up er, er, er D relationship, or design.
And you can get all kinds of apps and programs
298:49 - to help you design your databases. And then
some of them have what's known as engineering.
298:50 - So you could forward engineer your database
design, and it will basically just program
298:51 - your database for you. And it's super easy.
Yeah, but I'm getting way off topic. So let's
298:52 - get back on topic. Okay. So here's how we
draw a table. What we do is we give it a table
298:53 - name. So you put the table name either right
here in the in a complete column like that.
298:54 - or miss right above it. So let's put it up
above it right now. So this is a user table.
298:55 - And then what we can do within here is we
put the columns this way, vertically, when
298:56 - we write them horizontally, but we list them
this way, we're not putting them across here.
298:57 - Because if we put them across here, we will
assume that we're going to have row value,
298:58 - like Caleb, password, and his awesome email
is legit, or cool, and then the password already
298:59 - set password. But we're not doing that, we're
just going to put the columns. So the first
299:00 - column we can have is user ID, because we're
just going to use a surrogate primary key
299:01 - in this example. So we're gonna have user
ID. Now, when you get into it, you can also
299:02 - put other things like data types in here,
and any other restrictions you have, such
299:03 - as not normal if you wanted. But for now,
and for most of the design for design concepts,
299:04 - I'm not going to do that, because I'm going
to be writing the same thing over and over
299:05 - again. And you kind of only do that when you're
finalizing your database. So you can kind
299:06 - of worry about the data types later on. But
for now, we're just going to get the columns
299:07 - figure that out. Good.
299:08 - We'll go from there.
299:09 - So user ID, username,
299:10 - the password,
299:11 - and so forth. Hopefully, you guys can read
that. Probably not. And then when we do if
299:12 - we want to create another table, guess what
we do? We just draw another box, right? And
299:13 - we connect these with lines. And we can, there
are certain ways to draw lines that represent
299:14 - different linear relationships. Like that's
one way to do it. Or we're gonna have like,
299:15 - yeah, I mean, you get the point.
299:16 - Oh, I found a nice big piece of chalk. Cool.
299:17 - Alright, so that's how you do that. Now, that's
pretty much all the basics of entity relationship
299:18 - diagram drawing, just remember, we put these
in here, the columns. And what we can also
299:19 - do if we wanted, we could put indexes down
here, we could put like index types. And then
299:20 - we could also draw our relationship types
with different lines. And we can draw our
299:21 - foreign keys by either putting them down here
or doing some other kind of thing. Now, there's
299:22 - also other conventions you might have heard
of, or have used, like UML, and other design
299:23 - techniques. And I'm not saying those are bad,
I'm just saying this one super easy for beginners
299:24 - and for experts.
299:25 - We actually talked about this a little bit,
299:26 - but we haven't really designed it or anything,
because now we're talking about actually drawing
299:27 - out databases. cardinality is basically the
relationship type between a row of one table
299:28 - and rows or a row of another table. So I thought
of the the best example I have for this is
299:29 - a credit card database. So like, basically,
a credit card company
299:30 - has
299:31 - a table for credit cards, and then a table
for card holders or the people who order the
299:32 - credit cards and use them to buy things and
basically their cut the credit card companies
299:33 - customers, I guess. So I will draw those tables
out, just so you can see this, I'm not going
299:34 - to draw them or vague or anything. But just
so you see how the connection works. So we
299:35 - have a card holder. And then over here we
have the card. And there's some kind of relationship
299:36 - between here between these two tables. Now,
the only two possibilities for cardinality
299:37 - are one, or many. Obviously, for both sides,
you can have one too many, one, too many,
299:38 - or many, too many, those are the only three
possibilities. Now, another thing to think
299:39 - about when it comes to many to many, that
might even you might even consider that as
299:40 - not a possibility because you'd have to have
an intermediary table, which we talked about
299:41 - that when we talked about designing many to
many relationships, when when we're talking
299:42 - about many to many relationships here. It's
logical, which which What I mean by that is,
299:43 - we're we're drawing it as a just like this,
and we would say many,
299:44 - to many.
299:45 - And then when we actually implement that in
a database, we would have to have a cardholder
299:46 - card holding table and then the cards table
that would be how to draw a many to many relationship.
299:47 - So hopefully that kind of makes sense for
that. So in reality, when you're actually
299:48 - drawing out finalized products of databases,
the only possibilities are one to many, or
299:49 - one to many, because even if you have an intermediary
table this is good. Going to be a one to many
299:50 - relationship and then a one to many relationship.
And there's certain way to draw those out.
299:51 - That's what I'm going to be drawing right
now. So I wonder many, it's pretty simple.
299:52 - The one side, all you have is a straight up
and down line like this, the many side you
299:53 - have this, this thing that we're doing right
now is known as crows foot notation. Because
299:54 - it looks like crows foot, I think that's why
they call it that I don't really know. But
299:55 - this is a one, this isn't many. So when we're
drawing it, one, many, we could also have
299:56 - one to one, of course. So that's another possibility.
I
299:57 - forgot to mention one to one.
299:58 - Now, before we started drawing on both sides,
I think it's easy just to think about one
299:59 - side, like think of a cardholder relationship
to a card, we would have one
300:00 - card holder.
300:01 - Now that we have that side figured out we
got, we just think about the card holder,
300:02 - then we can add in the card, and we have many
cards, so one card holder can have many cards.
300:03 - And that's how you would design the line between
the tables. Like that. Now there's another
300:04 - thing we need to talk about known as modality,
which we'll talk about in the next video.
300:05 - But for this, we're just going to keep it
simple, just drawing these things here. But
300:06 - you might see also like circles, you might
see a circle here, for example. We'll talk
300:07 - about that in the next video. So now you know
how to draw a one to many relationship. So
300:08 - what does this exactly mean? That means one
row can be connected with many rows and this
300:09 - table. It's not necessarily the table but
the rows within the table. So we can think
300:10 - of a specific card holder, we can have a card
holder with the name jack, Id of two. And
300:11 - we can have many rows over here cards, we
can add a card with the ID of
300:12 - ID six,
300:13 - Id eight,
300:14 - Id 12. And you can see this guy has a lot
of credit cards. So all of these rows can
300:15 - be connected to an individual row within the
cardholder table. Now let's look at it the
300:16 - other way. We could have a many to one relationship,
or basically a one to many going the other
300:17 - direction. So we could add this. So now one
card can be connected to multiple people.
300:18 - But multiple people can be connected to one
card, I'm sorry, one card can be connected
300:19 - to multiple people. But one card holder can
only be connected to one card. So that means
300:20 - one person cannot own more than one card.
So now we think of it the other way around,
300:21 - we have a card. With the ID three, we have
a card with the ID for the ID of six doesn't
300:22 - really matter what the numbers are. And then
we have a card holder, we just got got a guy
300:23 - named jack, which ID is three. And then we
got bill
300:24 - ID two,
300:25 - well, we have we can have one card attached
to many people. So this card can be attached
300:26 - to many people, which means these people co
own a car, they're both the owner of one card.
300:27 - But now you have to realize an individual
cardholder can't be connected to multiple
300:28 - cards. So jack cannot own another car, that's
not going to work out. If you wanted that
300:29 - to work out, then you'd have to have an intermediary
table, which we talked about and designing
300:30 - many to many relationships. And this video
is less to be a review of relationships, but
300:31 - more of how to draw them. So you have to realize
the difference between all of these possibilities
300:32 - on one, one to many, or one to many, it just
depends on the actual application modality,
300:33 - it's basically whether or not the child is
a required child the relationship is required.
300:34 - We talked about that when we talked about
the column characteristic.
300:35 - Not No.
300:36 - So, think of it like this, we have a credit
card company, we have a table for the cardholder.
300:37 - And then we have a table for the card. Obviously,
the card holder, the ID for the card holder,
300:38 - the person who owns the card or or buys the
card from the credit card company, they're
300:39 - going to have an ID, and that's going to be
a not null column, meaning it has to have
300:40 - a value. That is obvious because it's going
to be the primary key surrogate primary key,
300:41 - and it has to have a value. So we have like
this guy, and he has an ID of seven, we have
300:42 - another guy with the ID of 12, and then 368,
and so forth. Those are ID cc
300:43 - card,
300:44 - that is going to have a column, which is a
foreign key, referencing the cardholder because
300:45 - the card is the child in this relationship.
So the cardholder has the primary key, you
300:46 - sat down there, if you can, card is going
to have a foreign key, which connects to these.
300:47 - So this is going to be a foreign key. Meaning,
these are the people that own certain cards.
300:48 - So we have a card with the ID of 12, we have
a card, a card with the ID of 48, I'm just
300:49 - making up numbers are here, in a card with
the idea of 98, we have a card of the ID of
300:50 - 112. Well, they each have an owner, you see
this is the owner. And this is a foreign key,
300:51 - which references the primary key. So seven,
this card is going to be owned by that person,
300:52 - seven, this card is going to be owned by that
person. Seven, this card is going to be owned
300:53 - by that person. So all of these three cards
are owned by that person 368, that's going
300:54 - to be owned by somebody else. Now, if we gave
this column right here, the foreign key the
300:55 - basically the cardholder column, because it's
a child, if we gave it the column characteristic,
300:56 - not know, it would be required that every
single row has an owner. That means we can't
300:57 - have a card in here that is either not activated
in doesn't have an owner, or we can't have
300:58 - a card in there that is not being currently
possessed by a cardholder. Because you think
300:59 - if you have a credit card, somebody owns that
credit card. But when you first make a credit
301:00 - card or something or if you like, if if you
get rid of the credit card or something, it
301:01 - might be a credit card that currently does
not have an owner. Does that make sense? So
301:02 - basically just a credit card that's not being
actively used, or is disabled or something
301:03 - like that, and does not have a cardholder?
Well, if we wanted us to if we wanted this
301:04 - database to be able to store cards that don't
have owners, we would not want the nominal
301:05 - characteristic, because that's going to prevent
it. So that's kind of how that works. So if
301:06 - we take that off, then we could add a card
down here with the ID of 101.
301:07 - That doesn't have a card. Well, I know we
already explained this all but now let's talk
301:08 - about designing. Let's just make this simple.
Pay attention to the Say, say one car, well,
301:09 - this obviously is going we're going to talk
about a a one to many relationship, meaning
301:10 - one card holder owns many cards. And we're
also going to be talking about a one to one
301:11 - relationship, meaning one card owner owns
one card for one too many too many. We just
301:12 - need an intermediary table, the same concept
kind of applies. But we don't necessarily
301:13 - have to go through that just break it into
a one to many, two to one to many relationships.
301:14 - Alright, so let's try this. So we have over
here we have the table. That's going to be
301:15 - the card owner. Over here, we have the table
for the cards. And there's a relationship
301:16 - between these two as a really big gap but
whatever. So let's start over here. We can
301:17 - say one card holder because that's what we're
just going to say one card holder for each
301:18 - time. Let me bring this in so they can actually
see.
301:19 - One card holder
301:20 - can have one card. So what we just did is
cardinality. We talked about this in the last
301:21 - video. Now let's do another example was the
same thing and you'll see why in a second.
301:22 - Let's do another example. And then finally,
one more example, run out of room here. So
301:23 - we have the basic relationships. Now we can
add one more thing to say if it's nullable
301:24 - or not nullable, basically, does the child.
This is the child. Which is the card. We're
301:25 - asking, does it does the foreign key column
have the nominal characteristic, that's so
301:26 - we have the possible relationships, one to
one, one to many. Now, what we're going to
301:27 - do is we're able to add the modality in and
the way we do that is we add either a little
301:28 - circle, or a little bash, or you can think
of it as a zero or a one, which actually will
301:29 - make sense. And we'll see why in a second,
zero,
301:30 - or one.
301:31 - So, over here, we have the cardholder, one
cardholder for all these examples. And then
301:32 - over here, we have the card. zero means the
column does not have the not null characteristic,
301:33 - meaning it accepts no value. So this is saying
it can accept no value. So we have a one to
301:34 - one relationship, that's the maximum, the
card holder can have up to one card, but it's
301:35 - not required. So zero or one cards, one or
one, cards, zero, at least zero cards, because
301:36 - you can have up to many, or at least one card.
So this means not No.
301:37 - Not No.
301:38 - Now when we design this, we're talking generally
from table to table. So we would have card
301:39 - holder, and then card. And why do I have to
say that, basically, because if we have, if
301:40 - we have zero here, that means there's not
necessarily going to be relationship between
301:41 - a certain row. So when we're talking about
rows, we might not actually draw a relationship
301:42 - between certain rows. When we draw relationships,
we talk from table to table, and those relationships,
301:43 - explain what rows can have relationships with
different rows. So in this example, let's
301:44 - just focus on the top one, just to make it
easier,
301:45 - we would draw this within our database application,
we would say we have the table cardholder.
301:46 - And then that has some kind of relationship
with the table card. Now we could say one
301:47 - card order can have zero up to one relationships
with one individual card. So we have a card
301:48 - holder with the ID of seven. And then we have
an ID card with the ID of 68 owned by the
301:49 - card holder seven, so that points back and
that's acceptable. We can also have a card
301:50 - we got a card 69. And we could have a person
eight, and we could say oh it doesn't have
301:51 - an owner, that's fine, we could have another
card 70 and it can have the owner eight, which
301:52 - points back to eight. And then we can have
another person which could be a seven, we're
301:53 - gonna have a card, we're gonna have a card
63 which the has the owner 87 and that points
301:54 - back to the owner 87. So that's how those
relationships work. Now, at first, this can
301:55 - be kind of confusing, so just practice. Make
sure you fully understand how each one works.
301:56 - Just review we could have, there's four possibilities
we could have.
301:57 - And if the down up there makes more sense.
One card holder can have zero or one card,
301:58 - one card holder can have one, only one card
because you can have one the least and then
301:59 - up to one and then you have one card holder
zero or more than one card holder one or more.
302:00 - These two are required, meaning every single
child has to have an owner. Or every single
302:01 - card has to have an owner, every single child
has to have a parent. So hopefully that all
302:02 - makes good sense. I just want to introduce
a topic. So in the next three or so videos,
302:03 - when we go over it, it's gonna be like kind
of not all new to you, you'll kind of have
302:04 - an idea of what's going on. So we're going
over what's known as normalization. So, normalization
302:05 - is a process where we go through our, our
database plan that we have, and we start correcting
302:06 - things that may cause data integrity problems,
or just repeating data, etc, etc, whatever
302:07 - you want to say. The normal forms are basically
like a checklist that you're going to follow.
302:08 - And when you get to the end, you will have
a pretty good design database. There's three
302:09 - main forms. And these are named, very conveniently,
I have to admit,
302:10 - first, normal form.
302:11 - Second,
302:12 - normal form.
302:13 - And guess what the third one is? You guessed
it. Third,
302:14 - normal frame.
302:15 - I'm kidding, it's form. That'd be weird, though.
Alright, so God,
302:16 - first of all, form second normal form. third
normal form.
302:17 - These are the three steps of normalization
for databases. Now, if you really, really,
302:18 - really want to get into database design, you
just like, man, I love this stuff a guy get
302:19 - more? Well, there's tons of more steps, you
can add and make things all complicated if
302:20 - you really want. But for our practical purposes,
these are the only three that you're going
302:21 - to really, really need. And I know there's
like a glare right here, because these lights,
302:22 - and I know, I'm just working on it. So give
me a couple videos, and I'll try to work on
302:23 - my lighting a bit. But for now, first of all
form second Normal Form
302:24 - third normal form.
302:25 - Why do we have these? Well, it's because we
want a systematic way to follow to produce
302:26 - a normalized or a good structure database.
302:27 - Alright,
302:28 - there's a couple things you should know when
it comes to normalization, we still have to
302:29 - talk about the idea of things being atomic,
we want everything to be atomic, you also
302:30 - have to kind of think about data depending
on other data. So if you think of like, let's
302:31 - say a primary key, yes, 608, just a number
that could refer to anything that could be
302:32 - a person, an order an event, whatever it is,
is just the primary key. And that also is
302:33 - going to have different columns in the table,
which have different attributes about whatever
302:34 - this thing is. So let's say it's a person.
And we have a column for the name. And let's
302:35 - say this dude's name is Caleb, what a dumb
name, right?
302:36 - This depends upon the primary key. So what
I mean by that is, if we change the primary
302:37 - key, we're going to also change the person,
right, so let's say we have six or nine, well,
302:38 - this is going to be a completely different
person, right? Because they're two separate
302:39 - entities,
302:40 - this one's referring to some
302:41 - guy over here. And this one is referring to
some guy over here, two separate entities.
302:42 - You can also think, oh, by the way, that that
process or that thing, this is called dependency.
302:43 - So the next three videos will be going over
the first normal form, second normal form.
302:44 - And the third normal form. The other main
thing is that these are kind of comprehensive,
302:45 - I guess, you could say. So what that means
is once you have first normal form, now you
302:46 - can go on to the second normal form, but you
can't go jump in right here, you have to have
302:47 - it in first normal form before you can get
into second normal form, same thing for second
302:48 - normal form into the third normal form. So
that means if you have a database that is
302:49 - in third normal form, it is also in second
normal form, and in first normal form. So
302:50 - I know I'm like getting all these technical
terms in junk. So if it's freaking me out,
302:51 - don't worry. It's really simple. Guy, get
my hair out of my face. Alright. But basically,
302:52 - it's, it's a list of steps. list of things
to do. And basically, you can do this step
302:53 - two until you do step one. So this year second
normal form, that's step two. Can't do this
302:54 - until you do that. So you got to go through
the process and then once you're at third
302:55 - normal form, things are good to go. This video
will be over the first normal form, which
302:56 - is the first step in database normalization
this normal form deals with data being atomic
302:57 - or atomicity. Alright, so let's begin. Let's
first look at three examples where there are
302:58 - problems. And then I'm going to explain a
solution. If we take a look at this first
302:59 - example, we have a user ID, first name, last
name, email, and address, I have some values
303:00 - in here. But those aren't really important.
In this example, the main thing you need to
303:01 - pay attention to is the address, because an
address if you think about actually consists
303:02 - of a street address, state, country, and so
forth. So this column is not atomic, we're
303:03 - asking for multiple things within one column.
So that is the problem in this example, the
303:04 - solution for this one would be to break it
up into multiple columns, you know, a state,
303:05 - and so forth. That way, we don't have a bunch
of things within one column as an individual
303:06 - value. This example, you can see, we have
one row with a user ID, first name, last name,
303:07 - and email. But if you look closely, we have
two emails, these emails were entered together
303:08 - as one individual value. So you can think
of maybe on a website or ask you for your
303:09 - email, imagine putting one email in and then
putting your second email in the same box
303:10 - and clicking Submit. Well, it's entered into
the database as a single value, maybe with
303:11 - the comma or something, but it's still entered
in as the email for this user. So two values
303:12 - within one, which is not atomic, in this example,
the actual values given for the email are
303:13 - atomic, because they're only one email, but
we put two entries within our database. So
303:14 - now we have this in here twice, this in here
twice, and it's in here twice, and the primary
303:15 - key should never be in there twice. The only
time you can see the primary key in there
303:16 - twice is if it's a reference as a foreign
key, because the foreign key can be put in
303:17 - there multiple times. But the primary key
of five should only be in there one time.
303:18 - So we have all that duplicate data. Now what
if this Caleb curry goes and gets a name change?
303:19 - Because that's such a dumb name right now.
Just kidding. That's, that's my name. And
303:20 - I actually like that
303:21 - name. But anyways,
303:22 - if he gets a name change, and he updates his
information, what if only this one's updated.
303:23 - So now we have conflicting data. And see that's
the problem with data integrity, we do make
303:24 - sure that doesn't happen. So in this example,
two column is the problem. And this example,
303:25 - the values for the row is the problem. And
in this example, the values for the row is
303:26 - the problem. So these basically have the same
problem. How do we figure out the solution?
303:27 - Let's take over here, let's take a look over
here. And as you can see, there is no solution.
303:28 - So yeah, guys, thanks for watching. I'm just
kidding, let's, let's do this, the best solution
303:29 - for this problem is to have a user table.
And I'm going to write the columns that are
303:30 - within this user table. So we would have a
user ID, then we are going to have a first
303:31 - name. And we're going to have a last name.
If you wanted the address in there, you could
303:32 - have street address, state country, all that
other good stuff, then we're also going to
303:33 - have an email table. So the solution is to
break off the problem column. You can see
303:34 - in this example, the email is the thing causing
the problem, the address that we had earlier,
303:35 - that's fixable, if it's a problem in the column,
we could just break it up into multiple columns.
303:36 - So we wouldn't have to make a new table for
that. But since this one, even though the
303:37 - columns correct, it's the values within it
that's causing the problem, we would need
303:38 - to create a new table for that. So that's
why we have this email table. And now within
303:39 - here, we're going to have an email id. And
then we're going to have a email, which is
303:40 - going to be the actual email address, which
in this case will be these. And then we're
303:41 - going to have a user ID. Now this is going
to be a foreign key. That references this
303:42 - user ID, the primary key of the user table.
Now if we wanted to put two individual emails,
303:43 - we could have rows within this email table,
let's let's spread out the email table and
303:44 - see what it might look like. Here's what the
email table might look like.
303:45 - We would have an email
303:46 - ID which is just a randomly generated number
for each email 600 dates fine. And then the
303:47 - email that's going to be the actual address
303:48 - of the email. So we could have this I try
to make it just as bad as handwriting.
303:49 - Perfect, then the user ID of who owns that,
which in this case would have been five, because
303:50 - five was the ID that was used for this user,
this will be your first row, then we're gonna
303:51 - have another row, and it'll be a new email.
So we'd have a new email id, it'd be a different
303:52 - email, we would use this one this time. And
I'm going to make that beautiful handwriting
303:53 - you guys love. There we go. And then the user
ID for that would also be five. Now this repeating
303:54 - value is okay. This, this repeat right here.
This is okay, because this is a foreign key.
303:55 - And multiple emails are allowed in this situation.
This email id, this is not not okay to repeat,
303:56 - because each individual number should be a
separate email because this is the primary
303:57 - key of the email table. Now, when we look
back at the user table, we don't have any
303:58 - repeating data, because we're only going to
have a user ID such as five first name, Caleb,
303:59 - and the last name, curry. And there's no need
to make a repeating row. Because we have all
304:00 - the information we need without having any
problems. If we change the name, we will just
304:01 - update this keep the same ID change this to
whatever we name our name ourselves, or whatever
304:02 - the person names themselves. So there you
go, everybody, that's first normal format.
304:03 - Now, second, normal form deals, deals with
what's known as a partial dependency, that's
304:04 - when a column only depends on part of the
primary key. So in order for it to depend
304:05 - on only part of it, you have to have a compound
or composite key. So basically, the primary
304:06 - key has to be multiple columns. Because if
you just have one column as the primary key,
304:07 - a column
304:08 - can partially depend on half of it. That kind
of makes sense. I don't know, maybe not. Let's
304:09 - say we just have a random table for people.
So we have you know, the person. So let's
304:10 - go with let's go. Let's just use a person
ID. And we have some attributes about this
304:11 - person, we have their name, you know, maybe
their phone, or their pH level, and maybe
304:12 - their email. Let's first talk about what a
dependency is, before we go and talk about
304:13 - partial dependencies. These columns depend
upon the primary key. So in this case, this
304:14 - is the primary key. And there's a dependency
here. Another way you can think about is if
304:15 - we have a another table about cars, we can
have a car ID, which is also a surrogate key.
304:16 - Now this person's name, it does not have a
dependency here, you can see this name is
304:17 - only dependent on the person ID not upon the
car. So this doesn't make any sense here.
304:18 - Another thing is that the person ID doesn't
have an unrelated entity or an unrelated attribute
304:19 - about the car ID so such as the
304:20 - car color.
304:21 - The car color has a dependency on the car,
not the person, this isn't going to make any
304:22 - sense. That's what a dependency is. Now, what
is a partial dependency. So let's see what
304:23 - a partial dependency looks like using surrogate
keys, you'll see this when you have a many
304:24 - to many relationship, broken up with an intermediary
table, which is the correct way to design
304:25 - a many to many relationship. So let's think
of the example of books and authors because
304:26 - if you think about it, one author can write
many books and one book can be written by
304:27 - many authors. So conceptually, it's a many
to many relationship, we're going to store
304:28 - that in the database is one to many relationship
on one side, and then one to many relationship
304:29 - on the other side. So we get this look
304:30 - at the table,
304:31 - intermediary table, and then a table. So over
here, let's put the author's so this is the
304:32 - author. Then over here we have the book. So
this is the book table. And then in between
304:33 - we have the intermediate intermediary table
of book authors, or book author.
304:34 - So this is the correct way to design it. Now
when it comes to attributes, all the attributes
304:35 - about The author are going to go over here,
all the attributes about the book are going
304:36 - to go over here, and all the attributes that
have to do with both the app, the book, and
304:37 - the author's connected, those will go in this
table. So first, let's give them some surrogate
304:38 - keys will give us one author ID,
304:39 - we'll give this one a book ID. And this one's
going to have two foreign keys of the author
304:40 - ID, and the book ID. And those foreign keys
together will be the key for this table.
304:41 - So that's kind of how you would set this up.
Now things about the author go over here.
304:42 - So you know, their first name, maybe their
last name, maybe their birth date. Whatever
304:43 - you want to put about the author, the book
would have stuff about, you know, the ISDN,
304:44 - which is, the ISDN is the code on the back
of a book, you can look up, it tries to uniquely
304:45 - define that book. So the exact addition and
everything else, so you can just use that
304:46 - to define it. You know, we will make maybe
have the page numbers or the publisher, the
304:47 - publisher could be a primary key or a foreign
key to another publisher table, or you could
304:48 - just have it in that table. If, if that's
how it worked, but likely to go to another
304:49 - table. But we're going off topic. Anyways,
it looks something like this. So author information
304:50 - goes over here, book information goes over
here. This is the correct way to design this
304:51 - table. Because when it comes to dependency,
the first name of the author has only to do
304:52 - with the author. And it has to do
304:53 - all about the author.
304:54 - Now let's look at things that have to do with
both the book and the author, we could have
304:55 - something such as the author position.
304:56 - Now what that is,
304:57 - when when you write books, often there's a
person who has like the first author position,
304:58 - which is what the big name is. And then you
have the second and the third, and the fourth,
304:59 - people often compete to try to get first author,
this has to do with both the book and the
305:00 - author. Because if you think about it, if
we put author position here, that's going
305:01 - to depend on what book we're talking about,
we can't just put author position one, and
305:02 - say he's first on every single book he ever
is going to write, that doesn't make sense.
305:03 - We can't just say author position one on the
book, because it doesn't say which author
305:04 - we're talking about which authors one, it
doesn't make sense. That's why we have to
305:05 - have it in this table, because it has to do
with the book and the author. So we could
305:06 - say book ID is 17. Author ID is 22. And the
author position is one. So that would say
305:07 - the book with the ID of 17. And the author
with the ID of 22 is in the second or the
305:08 - first position on that book. It's a little
complicated, but we combine that with joins
305:09 - to make it make more sense for the actual
viewing of the data. But anyways, this relies
305:10 - on the book and the author ID, that's why
it's in this table, this is correct. Now an
305:11 - incorrect thing would be something like the
ISDN. Because the ISDN has to do with the
305:12 - book only. So when you look at this, it relies
upon the book ID it has a dependency on the
305:13 - book ID, but it doesn't have a dependency
on the author ID. This is an example of a
305:14 - partial dependency. Now the correct way to
fix this, in this case would just to be take
305:15 - isbm and put it in the book table, which we
obviously already did, because I put that
305:16 - in there first when we started. But if we
didn't have this table and you're working
305:17 - with to say like one table, maybe well, then
the correct way to do it is to take the book
305:18 - ID the iasb and drag them to another table,
and then use a foreign key to connect to that
305:19 - table,
305:20 - which we already
305:21 - have it structured correctly because we understood
how to design that many to many relationship,
305:22 - which is why relationships are useful to understand
what if you don't have it already set up correctly,
305:23 - you'll have to take the partial dependency
and move it to another table and reference
305:24 - it with a foreign key for a second normal
form, you want to first be in first normal
305:25 - form. And second, remove all partial dependencies
by moving the columns as we did here we took
305:26 - that is being put in the correct table. Now
another thing you can think about is if you
305:27 - have a table where there's a primary key of
only one column, you're already in second
305:28 - normal form for that, like imagine it for
this. How can birthday be dependent on only
305:29 - part of the primary key which is author ID
because there's only one you can't you can't
305:30 - depend on only part of An individual column.
Thermal form in order to get there, you have
305:31 - to first do first normal form, and second
normal form. So it's kind of like a ladder,
305:32 - you can't just start a third normal form,
you have to work your way up there. So this
305:33 - one deals with what's known as a transitive
dependency, which is when a column depends
305:34 - upon a column, which depends upon the primary
key. So I know that's kind of like confusing.
305:35 - So let me just kind of draw it out on a table,
make a lot more sense. So here we have a review
305:36 - table. As you can see, I'm kidding, you can't
see it's just a square. So we could say, review.
305:37 - So like, this could be on a website, it could
be, you know, like a shopping website where
305:38 - you review a product, or it can be a review
on a video or anything really, it could be
305:39 - review on a book,
305:40 - most likely, it'll be on a shopping website,
where you buy something, whether it be a book
305:41 - or anything, or cars or whatever, it doesn't
matter. But in this, you would have something
305:42 - like a review ID, obviously, which will be
the primary key, you would also likely have
305:43 - what that review is, like in a text form.
So like a comment. So you would have the actual
305:44 - review. And then you would have maybe a star
rating, or multiple star ratings. So you could
305:45 - have a star rating, so maybe one through five,
one being the worst five being awesome. And
305:46 - then for maybe being like really sort of Okay,
you know, and then we might have something
305:47 - that has a star
305:48 - star, meaning.
305:49 - So that would be like a sort of okay, right.
And finally, we might have something like
305:50 - either a user
305:51 - or the poster, I'll just put the user because
likely, you will have some kind of user account
305:52 - on this website where you can post comments.
So this will likely be a user ID. And it will
305:53 - be a foreign key to a user table. But we're
not going to put that in here right now. Because
305:54 - that's unrelated to the actual point. So foreign
key primary key. Now, let's look at right
305:55 - here we have an issue. This is what's known
as a transitive dependency, because the star
305:56 - meaning depends upon the star. And a way you
can kind of try and figure out if it depends
305:57 - on it is, okay, well, if we change the star
is the star meaning going to change? Well,
305:58 - if we take the star, and we change it from
a four to a three, and might go for, it might
305:59 - go from really super okay to really average.
So the star meaning is going to change. So
306:00 - that's a dependency. But then the star actually
depends upon the actual review ID. Because
306:01 - if you change the actual review, that star
is able to change. So this is known as a transitive
306:02 - dependency, and it is bad. Now you can also
have a multiple transitive dependency, which
306:03 - I don't even know what those are called. But
that would be where I call them depends upon
306:04 - a column, which depends upon a column, which
depends upon a column, which depends upon
306:05 - the actual primary key, it can go on forever,
for as long as you want. But you don't want
306:06 - it because it's bad, which lever going to
remove. And so to remove this, you take the
306:07 - columns that are causing a problem, you move
them to a separate table, and then you create
306:08 - a foreign key and replace of them which references
the actual other column. So let's do this.
306:09 - So since these columns right here are the
ones causing the main problem, we take them,
306:10 - we put them in their own table, we have a
star table, within the star table, we're going
306:11 - to have a star I make. And then we're going
to have the actual star, whether it be 12345,
306:12 - or whatever kind of rating system you're using.
And then we're going to have the star meaning.
306:13 - And then over here, we're going to replace
these columns, let me make this a little prettier.
306:14 - And I just made it five times worse. But we're
gonna replace that with a star ID, which is
306:15 - going to reference this table over here. So
now we don't have that problem, because the
306:16 - only column over here is star ID, we don't
have the star meaning, which was the real
306:17 - column that was causing the problem. Now over
here, we could have if we drew out this table,
306:18 - we would have you know, we could have a star
ID of three. And that star could be a three
306:19 - star rating. And it could be meaning it could
mean Average. Now, we're likely to only have
306:20 - five individual rows in this table. So it's
kind of like a reference table. So over here,
306:21 - we can have a store ID of 12345, or 01234,
or 56789, it doesn't really matter what the
306:22 - ID is, because the ID is just a number used
by the database that has no real world value.
306:23 - So we'd have five rows in here, and then we
would reference them in the reviews table.
306:24 - So we could have, okay, this is too ugly,
let's let me just explain it, we can have
306:25 - one review with the star rating ID of five,
which could correlate to a certain rating
306:26 - from this ratings table. That's the main idea
of the third normal form, is to take those
306:27 - transitive dependencies, move them to a new
table, create a foreign key to reference that
306:28 - table. So under view, first normal form is
making everything atomic second normal form
306:29 - is removing any partial dependencies. And
then third normal form is removing any transitive
306:30 - dependencies.
306:31 - This video, we will be discussing indexes,
the best way to think about it is to take
306:32 - a book, look in the back, there is often an
index here, which basically has a huge list
306:33 - of topics. And it says what pages are on.
So you'd be like, oh, wow, that looks fun
306:34 - queries, go to page 2078.
306:35 - Wow,
306:36 - it's right there, I found it so fast, I have
to go search through the entire book to find
306:37 - it. That's an example of an index. It's basically
a list of where certain data points are another
306:38 - kind of indexes, you can think of a phonebook,
you go to a phonebook, and you search through
306:39 - the phonebook, you find someone's name, G,
we go to Grandma, and it'll have the phone
306:40 - number right there. That's another type of
index, it's where the data is sorted in a
306:41 - way that you can easily find it and the data
is right there, versus an index in the back,
306:42 - or it's a list of data pointing to where it's
at.
306:43 - The one
306:44 - we first discussed, is known as a non clustered
index. What that means is that the data is
306:45 - not actually where the index is, the index
is a separate thing. And it basically just
306:46 - sorts the data. And it's basically a point
that tells you how to get to the data. So
306:47 - the way it works in a book is you find the
topic, and it'll tell you where to go 365,
306:48 - for example, go to page 365. That's a non
clustered index. A clustered index is like
306:49 - the phonebook, where it actually reorganizes
the actual data in a way that's easy to use
306:50 - non clustered, points to the data clustered
organizes the actual data. So we can have
306:51 - multiple non clustered indexes. That's because
a non clustered index is basically just a
306:52 - list of references that point into the data.
So we could organize it in different ways.
306:53 - But as for the clustered index, we can only
have one of those. That's because it actually
306:54 - organizes the data that way. So think of a
phone book, it's organized a to z, or however,
306:55 - you go through there and you find it. That's
a clustered index, it organizes the data.
306:56 - Well, what if I wanted to put the data in
by the phone number, so the smallest phone
306:57 - number like 0000001, which would be an awful
way to organize a phonebook at the beginning,
306:58 - and then 99999989 at the end, that's an awful
way to design a phonebook, like I just said,
306:59 - but that is another example of a clustered
index. That's because it actually reorganizes
307:00 - the data. That's why you can only have one
of those because a phonebook can't be listed
307:01 - A to Z, and also, by the size of the phone
number, see what I mean. It's conflicting,
307:02 - you can have both at the same time, you can
only have, okay, you can only have, okay,
307:03 - this is sorted by name, or Oh, this is sorted
by phone number. You can't have both. Now,
307:04 - you could make the phone number size or whatever,
as a non clustered index, where it would be
307:05 - like this, to have the actual phone numbers
in the back, and it would point to where it's
307:06 - located. So at the beginning of the index,
it would be like, okay, the phone number that's
307:07 - 0000000001 would be on page 743. The phone
number with 0000000002 is on page 242. You
307:08 - see that the actual data isn't organized.
By the, the phone numbers, but you can use
307:09 - that non clustered index that sorts it that
way, and has a reference to the actual data
307:10 - where it's located. Now, you guys are probably
sick and tired of me rambling about this.
307:11 - So let me just explain how this makes sense
in databases. Well, when we're working, we're
307:12 - working with a database, often, we will use
a certain column for certain things. And that
307:13 - column will be used frequently. And we want
that to be like super fast. So we want the
307:14 - database to know how to use it the best way.
So we create an index, the database understands
307:15 - the index so that way, when you tell it to
do something, it can do it faster. Rather
307:16 - than having to go through all of the data,
which is called a table scan, when you're
307:17 - working with a database with millions of rows
that can take forever. If you have an index,
307:18 - it'll use an index seek, which will basically
know where to start searching for that data.
307:19 - That's awesome, because it makes our queries
tons faster, and saves a lot of resources.
307:20 - There's downsides to it, though, because when
you create an index, not only does the actual
307:21 - table have to update whenever you update it,
but you also have to update the indexes. Think
307:22 - of like a book, when you add something to
this book, or you change something within
307:23 - this book, not only does the actual book content
in the beginning of the book change, but also
307:24 - when you flip to the back, the index must
also be updated. Otherwise, all this index
307:25 - information is going to be out of date and
useless. So that's a downside to indexes is
307:26 - when you update your information, it might
take a little longer in a database query,
307:27 - we might say something like select the first
name, last name, and the phone number and
307:28 - the email of the user with the user ID of
72. For example, well, I kind of said that
307:29 - in English, but when you're actually working
with a database, it might be more like select
307:30 - first name, last name, email, phone number,
where user ID equals 72. That would be an
307:31 - example of a database query. Now the where
clause is using the primary key. So basically,
307:32 - the database is going to go through the table,
find the person with the user ID of 72, and
307:33 - then display their first name, last name,
phone number, an email. Well, that where is
307:34 - using a column that has an index, the primary
key is usually the one that's going to have
307:35 - the clustered index. So that's the way it
actually sorts the data. So now, it doesn't
307:36 - have to go through the entire entire entire
entire table to find the person with the ID
307:37 - of 72. Because imagine if, if it was just
random data thrown in there with no organization,
307:38 - you have 2 billion rows, right? And the database
has to go through and find the one individual
307:39 - row with the user ID of 72. Go to the first
one, nope, not 72. Second one, nope, not 72.
307:40 - There, nope, not 72. And keep going on, on
non non to finally found the person with the
307:41 - user ID of 72. Basically, that will take ever
with a clustered index, it knows well, 72
307:42 - is going to be in this part of the database,
it comes after 60 and comes for 80. Because
307:43 - that's the way it's sorted. So it's gonna
be like, boom, got done. That is how indexes
307:44 - kind of work. So clustered indexes are going
to be faster and better. But you can only
307:45 - have one, that's usually the primary key.
But it doesn't always have to be depending
307:46 - on the database, and what your goal for the
databases, the non clustered indexes, which
307:47 - are like the index and the back of a book,
those are still good. And they are recommended,
307:48 - if you're doing something where you're like,
where first name equals john. Now, it has
307:49 - a list of all the John's and where they're
located on the database are on the table,
307:50 - I guess, that's also a good thing. But you
don't want to have an index on something you're
307:51 - not going to be using a lot, because you'll
just have to have another thing updated. Another
307:52 - thing you don't often want to do where clauses,
which is where like where first name is Caleb,
307:53 - without that column that you're searching,
being a indexed column, because it can take
307:54 - forever. Another reason for indexes is to
increase the speed of joins. So the way the
307:55 - join works is it takes data from one table
and another table and combines it together
307:56 - by the primary key and foreign key connection.
So think of a users, users and comments. So
307:57 - a user post a comment. So you'd have a user
table. And you would have a comment table.
307:58 - And let's just draw a rose on here.
307:59 - So we have this guy I'm just gonna draw pictures.
This because it's funner. So we have three
308:00 - people over here, we have four comments on
a website or review, or it doesn't really
308:01 - matter. Well, this one comment is posted by
one person and one person can posts multiple
308:02 - comments, it's a one to many relationship.
Well, when we want to output this to where
308:03 - we can review the data, we want to use a join.
So it's not across multiple tables. Because
308:04 - if you're thinking like, this comment was
posted by the user with the user ID of 72,
308:05 - you're not going to know who that is right
off the top of your head, because that's a
308:06 - foreign key connection. So rather, you want
to replace that 72 with the actual name of
308:07 - that person or the username. That's a join.
And it's all done after the database is created.
308:08 - It's all for the query side. So basically,
this is what is defined in our database. And
308:09 - we want to output with a join a new table
that looks more prettier and easier to read.
308:10 - When we do this, we're going to do something
that says, the user ID of this call, the user
308:11 - ID of this table, is the same as the user
ID in this table. So if the use if a comment
308:12 - has the user ID of 72, we know that it's done
by the user with the user ID of 72. That's
308:13 - the foreign key connection with which we've
talked about like some tire series, so I'm
308:14 - not going to explain that anymore. But now
down here, in this table, it's going to say,
308:15 - Caleb curry, then oh, put the comment, you
know, join that. Well, this is also done with
308:16 - a where clause, in some cases, for different
databases of the terms might be a little different.
308:17 - But basically, that column that you're connecting
by, which in this case would be the primary
308:18 - key needs to be indexed to make it faster.
So whenever you're joining a certain column,
308:19 - the two tables, the column you're joining
should be indexed. You can also have something
308:20 - that's known as a composite index, which is
an index that is an index on two or more columns.
308:21 - So think of like a first name, and a last
name, or last name, first name. Now, the thing
308:22 - about these is when you use the indexes, so
let's say you select where first name equals
308:23 - this and last name equals that you have to
do them both, or it's not going to use that
308:24 - index. Now, there are exceptions to this,
think it for MySQL, actually, if you order
308:25 - them in a certain way, like like this, you
put an index on the last name, and then also
308:26 - the first name, you can, you can do a where
clause for both the last name and first name.
308:27 - So finding everybody with the last name, curry
and the first name, Caleb would be really
308:28 - fast. But the way this is set up, you can
also do the leftmost one, too. So you can
308:29 - say, find the person with the last name, Curry,
that's going to work. But in this case, you
308:30 - couldn't do it with the first name, because
it's not on the left, that's just the way
308:31 - MySQL is set up. So different database systems
might have it set up differently, where you
308:32 - can search with them individually, or you
can. But most likely, when you make a composite
308:33 - index, you should expect to always use that
index by itself, unless you have it set up
308:34 - to where you make a pretty awesome index that
can be optimized to do multiple different
308:35 - queries that you need to do like if I'm going
to make a ton of queries where I put the last
308:36 - name as the where, and then I'm going to make
a ton of queries where I put last name and
308:37 - first name for the where this will be a good
way to set that up. Because I'm making one
308:38 - index index for last name, first name that
can also be used for just last name. So yeah,
308:39 - that's just the basic introduction do indexes.
Yeah, I'm not going to be giving you tons
308:40 - of syntax actually making them because like,
you should know by now, this is a database
308:41 - design course, we're just trying to learn
how to design our indexes on our tables, so
308:42 - that our database works good. So that's something
you may have to learn more once you actually
308:43 - program a database, because you can test the
speed of the actual indexes to see this for
308:44 - speed optimization to make the database as
fast as possible. You can't really do that.
308:45 - If you're only designing a database, you can
only get so far when designing indexes with
308:46 - the database, but you can get pretty far because
I mean, obviously, you'll likely be using
308:47 - the primary key for where clauses and joins.
So that's something that's good do avid clustered
308:48 - index on. What a data type is, is when you
create a column, every single value in that
308:49 - column has to be of a certain data type. So
you need to tell that column when you create
308:50 - the database, what data type it is to be.
Also, when you're designing, you usually put
308:51 - the data types there as Well, so that way,
you have an idea of how your database is going
308:52 - to work. So there's three main categories
of data types. And the naming conventions,
308:53 - or the names of these data types from one
database management system to another database
308:54 - management system might vary a little bit.
But in general, they're organized into three
308:55 - main kinds. That's date, numeric, and string.
So basically, we're going to be going over
308:56 - these in a little bit of depth, we're not
going to go super in depth, because right
308:57 - now you just need to understand what these
are. And just understand that your database
308:58 - application might be slightly different from
others. Let's start from the bottom up just
308:59 - to make things fun string, a string is any
characters or like letters. So basically,
309:00 - you put these within quotes. So
309:01 - hey,
309:02 - this is an example of a string. Even a number
within quotes can be used as a string, in
309:03 - this case, this will be used as a string,
basically, the
309:04 - the three
309:05 - doesn't have any mathematical value unless
it's converted to numeric. Within string,
309:06 - you often have some subcategories, you will
have something that's either char or var char,
309:07 - which does this mean character or variable
character. What that means is, it's just like
309:08 - a list of characters, the character or chart,
usually is stuff that's set in length, so
309:09 - like a phone number, or a zip code, something
that doesn't change, size wise. So basically,
309:10 - with a char, you'll have something like, sharp
eight, and every single value within that
309:11 - char column is going to be stored as a individual
characters. Now even if you don't put eight
309:12 - characters, let's say you put six, then there's
going to be two blank characters in there.
309:13 - So they're all stored as eight. var. char,
on the other hand, is variable, basically,
309:14 - meaning that the size can change, you can
have anywhere from zero up to eight. There's
309:15 - also often the subcategory or sub data type
of text, which is often used for larger things
309:16 - such as comments, messages, and so forth.
That's basic summary of the string data types.
309:17 - As for numeric data types, these are numbers.
That's different than this. This is a string
309:18 - that has a number in it that's used differently
than the numeric data type. The numeric data
309:19 - type doesn't have quotes. It's just the numbers
that you're using. Just like string, there's
309:20 - often some subcategories of decimal, and then
floating point or double decimal works in
309:21 - base 10. Now, I know we haven't really gotten
much into basis. And I'm just gonna put date
309:22 - back up here. So we haven't got there yet.
309:23 - But I think
309:24 - it's really important to know and in fact,
I've made a lot of videos over binary, hexadecimal
309:25 - and stuff, basically different numbering systems
that use different bases. Well, decimal uses
309:26 - base 10 is the number system we're used to
counting, you know, 0123456789, and then it
309:27 - goes back to 10 1112 1314. It's base 10. That's
what deaths it means in decimal. Well, there's
309:28 - also binary. So we have decimal and then we
have binary decimals, base 10, binaries, and
309:29 - base two. So binary, we only have the options
of zero, and one. Now, you don't really need
309:30 - to understand how to like calculate in binary.
But if you want to know that I do have videos
309:31 - for that, but just know when we're working
with decimal is working with a base 10 system.
309:32 - When we're working with floating points. We're
working with binary, which is stored differently.
309:33 - It's stored in binary, and then you can have
it presented as decimal for math or whatever.
309:34 - So what's really the difference? Do you use
decimal or do you use floating points? It
309:35 - just kind of really depends. decimal generally
is more accurate on mathematics to a point.
309:36 - There are problems that can come up with decimal,
but you'll just have to research those. But
309:37 - basically, this one has some errors binary
it has problems with certain mathematical
309:38 - equations or numbers. For example,
309:39 - when we want to store
309:40 - 1/4, it's stored like this, we have 0.01 The
way this kind of works is we have anything
309:41 - after the point that divides the number, basically,
in half, so we would have half, but we don't
309:42 - have, so we have half of a half
309:43 - 1/4
309:44 - kind of makes sense. So the place values would
be, this one right here would be, we'd have
309:45 - half, this place value would be 1/4. And then
anything after that would be 1/8. And anything
309:46 - after that would be 116. So right now we're
where we have it, we would take one half,
309:47 - multiply it by zero, to get zero, because
we don't have anything there. We take 1/4,
309:48 - multiply it by one, since we have it there,
we'd get 1400. We add this up, we get 1/4.
309:49 - Basic adding and multiplying to understand
how it works. But when we have a number such
309:50 - as
309:51 - point one,
309:52 - and decimal, that is basically impossible
to store in binary, simply because we're working
309:53 - in a base two system. And we can't get to
point one very easily. Because 1/8, that doesn't
309:54 - quite cut it, you have to basically have a
combination of a bunch of different fractions
309:55 - to get as close as possible to point one,
but you can never really get there perfectly.
309:56 - So that's problem with the floating points.
So if you needed to source something like
309:57 - that, you would if it needs to have accuracy,
you would have to have it stored as a decimal,
309:58 - which stores it differently. Sorry, if it
completely overwhelmed you with that number
309:59 - stuff. And if it did, don't even worry about
it. That was a little too fast. You need it
310:00 - slower, please check out my introduction to
binary video. It's a super long video where
310:01 - I basically explain it step by step. So you
understand. And then I have a couple other
310:02 - videos adding and subtracting. And also fractions.
in binary, you will also have an integer type,
310:03 - which will only store numbers that don't have
any decimals after them. So only whole numbers
310:04 - like 512 28, negative 52, so forth with numbers,
we also have to worry about whether they are
310:05 - unsigned or signed. If they are unsigned numbers,
that means that they can't be negative. If
310:06 - they're signed, that means it can be positive
or negative. probably wondering why would
310:07 - you ever do that? Well, if you're working
with something that doesn't go negative, well,
310:08 - then you wouldn't need to have that negative.
When you have a signed number and it can be
310:09 - positive or negative, the range of potential
values stays the same. But since you include
310:10 - negatives, the maximum value is different.
It's not as high think about if you have a
310:11 - range from zero to 1000. But then you include
negatives, now you have from negative 500
310:12 - to 500. That is going to be told with the
data type. So you might say something like,
310:13 - double, unsigned, that would work as a number.
That's enough for numbers. I don't want to
310:14 - talk about this anymore. Let's talk about
dates, dates, well, there's a couple different
310:15 - things you need to know about dates, there's
date, then there's time, there's date, time,
310:16 - and then there's timestamp. So let's talk
about date time first, because it makes sense
310:17 - the best. It basically just stores a date
such as you know, oh two for February, then
310:18 - you might have a colon you might have 22 for
the date and 22nd and then a colon maybe 1998
310:19 - for 1998. And the year, then you have the
time, which could be whatever it could be
310:20 - 12 3022, which would be the seconds and you
might even be would have some milliseconds
310:21 - or microseconds. That's how you would store
date time. The way it actually looks might
310:22 - vary from database management system to database
management system. Some might have colons
310:23 - between the numbers, some some might have
hyphens or commas or whatever, doesn't really
310:24 - matter. I don't need to think about that.
Right now, I just want you to think about
310:25 - the date being a date. And the time being
310:26 - a time,
310:27 - date, time being the combination of a date
and a time. That's pretty much that for dates.
310:28 - The only other thing is the timestamp. The
timestamp is an exact moment in time that's
310:29 - recorded to establish when something was created
or done. It can be in milliseconds or it can
310:30 - be in the month, the day and then the second
hour and then the seconds and then the milliseconds.
310:31 - Or it can just be a number of seconds, so
forth. It varies. But anyways, that's going
310:32 - to give you a number when something was done.
It's usually for something like when an account
310:33 - was created. Either when a transaction was
done or when something happened, when you
310:34 - update a column, that timestamp will often
update. And that's going to keep it to like
310:35 - when that row was entered into the database.
So if you enter a new row, and one of the
310:36 - columns is a timestamp, it's going to give
you a value as soon as you submit that, and
310:37 - it's put into the database, and timestamps
created. And it says, Okay, this row was entered
310:38 - at this time. That's the main thing with timestamps.
So basically, we got three types of data types,
310:39 - we got string,
310:40 - snow, numeric, and then date. All of those
classifications have different data types
310:41 - for each one. But in general, as long as you
know, like, the gist of what is what, you'll
310:42 - be fine, you don't have to worry too much.
Because when you get an actually programming
310:43 - a database, you will have more specifics on
what data types to use. So this video, we'll
310:44 - be talking about joins. And in fact, the next
whole group of videos will be about joins.
310:45 - So it's going to be a lot. Now, joins are
a complex subject there, they can be confusing
310:46 - and tricky, and very syntactical, I don't
know if that's a word. But basically, the
310:47 - syntax from relational database management
to another relational database management
310:48 - system can be confusing and complex. But rather
than diving in and just learning all that
310:49 - stuff, we're going to be talking about the
concepts of what the types of joins are. And
310:50 - I know you might not even know what a join
is yet. So you're probably thinking, I don't
310:51 - know what you're talking about. Well, that's
what we're talking about today. So thank you
310:52 - for joining me, let's begin. So a join is
when you take something that's structured
310:53 - in a database in a confusing, non user friendly
way, and you're presenting it in a user friendly
310:54 - way. Now this is done so that way, we can
store our data in the database in a way that's
310:55 - the best structured, to where we protect our
data integrity, and it's normalized and separated
310:56 - across tables with the proper relationships
and data types and keys and indexes and everything.
310:57 - But when we actually want to present that
data, for example, on a webpage, or in a program,
310:58 - or to the analyzer person who goes in analyzes,
and does calculations on our data, or just
310:59 - views those calculations after the database
does all the work with the analyzation. Well,
311:00 - that end result is often in a way, it looks
in a way that is organized and structured,
311:01 - it makes sense to us. That's the purpose of
a join. So it takes a mess, and puts it out
311:02 - in a way that looks beautiful. And this can
be done over multiple tables. So for example,
311:03 - we're gonna have a table here,
311:04 - a table here,
311:05 - and a table here. And these could all be three
different tables, with relationships between
311:06 - the tables, we all get the specifics of what
kind of tables but basically, a join is going
311:07 - to take all of this.
311:08 - And it's going to present us with a generated
table, that is more pretty. It's more beautiful,
311:09 - and more structured. And it makes more sense.
311:10 - Now, the way this is done, is using foreign
key primary key connections. So when we have
311:11 - these relationships between these tables,
where I drew these arrows here, that represents
311:12 - a foreign key connection, that references
a primary key. So one of these tables is the
311:13 - parent and one of them's the child, and we
want the end result and combine them together
311:14 - into one. Now, when you do this, these columns
that are connected are going to be indexed
311:15 - to make it much faster. Now, when you join
tables, often you will replace names of things
311:16 - with more user friendly names. So for example,
we could have you know, let's say we had a
311:17 - comment on a website. And it says, Wow,
311:18 - then
311:19 - and then this is posted by Caleb. Well, you
can see that if you have a username here,
311:20 - it might actually be a user ID in a comment
table. So for example, we can say, This appears
311:21 - the comment table. This is the user table.
And there is a foreign key from the user ID
311:22 - referencing the user ID in the user table.
Well, we when we present that data on a database,
311:23 - we will want to replace that user ID with
the actual username. So rather than having
311:24 - you know we can have it to where it's like
User ID of 4582. And then you're like, Oh,
311:25 - I don't really know what that means. Well,
since this is all within the comments table,
311:26 - now we're going to take information from the
user table, and put that username instead
311:27 - of the user ID. That is how a join works conceptually.
That's another important thing. All this,
311:28 - think of it conceptually, these videos are
going to be helping you understand the concepts
311:29 - of the different kinds of joins. And throughout
it, I'll be giving you some examples of how
311:30 - you would type that in SQL, maybe, but I'm
not going to be getting into the specifics.
311:31 - That's because joins are done differently
from database management system to database
311:32 - management system. So you just need to know
is how the joins work, and the expected results.
311:33 - And then when you start working with MySQL,
or SQL Server, or Oracle database or whatever
311:34 - else, then you can just figure out how to
do their joins, you will already know what
311:35 - the results are going to be because you understand
the joints. And then you just type it out.
311:36 - And boom, you got to join there. Now there's
one other thing to know that's important,
311:37 - is all of this is data manipulation. Most
of what we've been talking about before is
311:38 - data definition. So that was in basically
DDL. But now we're going on to DML. So DDL
311:39 - data Definition Language, and data manipulation,
language, these are two parts of SQL, we all
311:40 - we all talked about this and the older videos,
but we're on like, way farther now. So you
311:41 - guys might have forgot this. But this is important
to know. Because now we already have the definition,
311:42 - the structure of the database, the database
might already be completely designed and structured
311:43 - with the columns and the rows. But now, we're
manipulating that data to look a certain way.
311:44 - So by doing joins, you're not actually changing
the structure of the database, you are changing
311:45 - the presentation of that database, that is
extremely important to know. And you may be
311:46 - wondering, why exactly do I need to know this,
because if I'm a database designer, or whatever,
311:47 - really, all I need to do is design the structure
of the database, and then the database administrator
311:48 - or the software engineer person, or whoever
can go in there and use my database that I
311:49 - designed and created. And they can do all
the data manipulation stuff to fit their application,
311:50 - right? Well, maybe, but not likely. That's
because the joins are also very important
311:51 - to understand. Because when you design your
database, you need to think of it in a user
311:52 - friendly way. And then normalize it, make
it confusing, and then present it in a user
311:53 - friendly way. It's kind of confusing, because
you start with let's say you are really bad
311:54 - at database design. And you're structuring
a table, and you have it to where it's like
311:55 - comments comment table. And within this, you
have a user name. And then you have the comment.
311:56 - And then maybe the blog post or video, whatever,
it doesn't really matter. You can have some
311:57 - IDs in there. Basically, you don't know what
you're doing. And you put the username, what
311:58 - is Caleb See?
311:59 - Comment lame.
312:00 - There got another one from Caleb See? Cool.
Caleb see off. When you look at this, and
312:01 - you show it to your grandma, she understands
it. She's like, okay, she might not understand
312:02 - it, but she gets if you explained it, she
312:03 - might. Caleb c
312:04 - posted the comment lane. Caleb c also posted
the comment cool. Caleb also posted the comment
312:05 - upscales. He also posted the comment, awesome.
But this isn't the best way to do this because
312:06 - we learned about data integrity, and also
repeating data because now we have this in
312:07 - here three times. So instead, we use a user
ID and get rid of Caleb C. And we get rid
312:08 - of the username.
312:09 - We have a user ID.
312:10 - And then in here we have the user ID six.
Let's not use that number 777. And then over
312:11 - here we have a user table with the user ID
column, which has all have our user IDs for
312:12 - each individual person. So we started off
with this friendly design. But in reality,
312:13 - it doesn't work because it's not normalized,
there's repeating data. But it looks pretty.
312:14 - Once we have that, then we can break it up
and normalize it. So that way, we have multiple
312:15 - tables. So we have this table. And then we
have this table over here. But that's not
312:16 - the only thing we do. The next thing we have
to do is you have to take up those pieces
312:17 - of the puzzle, and put them back together
in a join to get the final result. So we basically
312:18 - want to replicate the original table we had
here by using a join of our normalized database,
312:19 - and recreating it. So what we're going to
do is we're going to take the user ID column,
312:20 - and we're going to take the user ID, you guys
see that all all good, it's everything. This
312:21 - This will likely also have a username column,
so I kind of ran out of room here, but username.
312:22 - And that username, user ID seven will be connected
to Caleb See,
312:23 - using a join,
312:24 - we are going to connect these two tables by
basically using this foreign key which points
312:25 - to seven and finding the associated username
with that user ID. And our join will look
312:26 - like this.
312:27 - username,
312:28 - comment. And the name of the table can be
what mean whatever you want, it can be generated
312:29 - table. Or it doesn't even need a name, if
you're just putting it on a website or something.
312:30 - And then under the username column, it'll
be Caleb See, and then Caleb See,
312:31 - and then Caleb see.
312:32 - And then under the comment, you're going to
have lame and cool and awesome. But this wasn't
312:33 - just like this to begin with, we got the username
from this table. And we got the comment from
312:34 - this table. So not only do you have to design
the structure of the database, but you have
312:35 - to structure the joins, to basically put our
database back into simple language or grandma
312:36 - readable tables. Okay? That that's basically
what we want to do. So let's say you get a
312:37 - job, or you're working for a developer or
something, and they say, okay, on my website,
312:38 - I want a table on this Users page, where I
can sign in with my username, password, and
312:39 - I can see their username, their password,
their email, their date, they signed up and
312:40 - everything like that. And if I want, I can
go in there and edit it. That way. They don't
312:41 - have to go in and type SQL, you're you're
going to have that programmed in the in the
312:42 - actual application to send that SQL. But we
need to structure the tables, we need to make
312:43 - a join, that's going to be able to combine
those all to one pretty table, which that's
312:44 - the job of the database designer, likely.
I mean, if the applications or the database
312:45 - is huge, you might have someone who does the,
the designing, and then someone who does the
312:46 - implementation, and then someone who does
the joins and then someone who does this other
312:47 - junk. But I mean, if you're just working on
your own, and you got to do everything, you're
312:48 - also gonna have to design the joints.
312:49 - And I highly, highly, highly
312:50 - recommend you do that before you go in and
programming your application. And then you're
312:51 - like, Oh, crap, I don't want to do this, or
Oh, my database is structured wrong. I want
312:52 - to do this all beforehand. Don't rush into
things because then you're going to be like,
312:53 - dude, dawg, my application ain't working.
Right. And the reason is, because you didn't
312:54 - take the time to structure your database the
right way, and develop your
312:55 - joins.
312:56 - Okay, once you got that, you're good to go.
And yeah, so there are a couple different
312:57 - kinds of joins. There's Inner Joins, outer
joins, cross joins, unions, there's all kinds
312:58 - of different things that we're going to be
talking about. Okay, so, when energyne. The
312:59 - way an inner join works, is it's going to
take one table and another table. And then
313:00 - wherever there is rows from this table and
this table that are connected, it's going
313:01 - to present them in a new generated table.
So let's just break this down and see how
313:02 - it works. Let's go with an example. Because
you gotta use examples. We're gonna have a
313:03 - customer table We're also going to have a
card table. So think of like a bank, for example,
313:04 - you're going to have a customer table where
you're going to put all your customers in
313:05 - there. And then you have a card table where
you're going to put every single card that's
313:06 - been given out, or will be given out to people
who have credit cards, where you could make
313:07 - to where you can even include debit cards
in there, but we'll just worry about credit
313:08 - cards for now. So basically, we're going to
draw this out.
313:09 - And we're not
313:10 - going to have it required that a card has
a customer, a customer has a card. So neither
313:11 - of these columns are going to be labeled as
not null. So basically, the card does not
313:12 - need to have a customer. And a customer does
not need to have a card. So we'd have one
313:13 - table over here.
313:14 - And another table over here.
313:15 - And generally this will be designed as a one
to many relationship, because one person can
313:16 - have many cards. And usually one card is owned
by one person, you could design it as a many
313:17 - to many relationship where you can join a
card or multiple people can own a card. But
313:18 - yeah, you can modify the examples as needed.
So let's say this is the customer, customer.
313:19 - And this is the card table. Now we might have
something like of course, we have an ID for
313:20 - the customer. So we're gonna have the customer
ID, you know, their first name, last name,
313:21 - their address, their date of birth, all their
personal information that we need for their
313:22 - data for the bank. That's where that's going
to go. Over here, we're going to have a card
313:23 - ID. And then we're also going to have a customer
ID. And because this is a one to many relationship,
313:24 - we have the child and the parent. If this
is a one to one relationship, we could have
313:25 - it to where there is also a card ID and the
customer table if we wanted. But I'm not going
313:26 - to do that. And we can get into one to one
relationship design best practices in another
313:27 - video. But for now, the customer ID is going
to reference this customer ID. and here we
313:28 - can also have more information about the car,
we could have the the total amount or the
313:29 - limit max amount, I guess I can say, max amount,
you can have monthly bill. And because this
313:30 - is a really simplified example, we don't really
have to worry about other tables such as,
313:31 - you know, bills and invoices, I mean, and
all that other junk, we're just keeping it
313:32 - simple here. And let's say this is how we
structured our database. And we want to make
313:33 - it more user friendly with a join to where
we join information across the table. Because
313:34 - we don't want to have to have the customer
ID for the card. So we create a join. And
313:35 - we make this new generated table. I don't
know why I made that like circle, but and
313:36 - within here, we could say we could say it's
the card customer. For example, it doesn't
313:37 - really matter what we give the title of the
actual table. What we're going to do in here
313:38 - is what we decide which columns we want to
take. Well, the first thing we we always start
313:39 - with the ID because that's how things are
going to be joined. And we don't necessarily
313:40 - have to return that Id within our table. But
we need to think about it because that's how
313:41 - we connect the tables. So generally the the
ID is just for the databases sake, it's usually
313:42 - not something you use outside of the database,
it doesn't have any real world value. So we
313:43 - usually don't need to record it in the join
for a view the application or whatever we're
313:44 - using this for. Now, if you're the database
administrator and you want some more presentable
313:45 - tables like this, but you want to keep the
IDS in there, that's fine too. But we're not
313:46 - going to we're not going to return the customer
ID. There's no need to it's just a number.
313:47 - But since it's in both tables, if we did join
it down here, it would only be in one column.
313:48 - So we would have you know, cost a customer
ID. And that's going to take the combination
313:49 - of these. We're gonna have the customer id
like let's say 62 and then card. I Be like
313:50 - seven and then customer ID 62 and current
ID eight. So that's kind of how that would
313:51 - work. But we're not going to return those.
So what we're going to do is we're going to
313:52 - return just the first name, last name. And
we're also going to return the Let's add another
313:53 - column amount paid. So basically, it's saying
like how far they paid off their credit card
313:54 - bill, let's say you borrowed 10,000, and you
owe 6000, you've paid back 4000. So far, just
313:55 - to see how far people are getting to paying
off their bills. And like I said, this is
313:56 - very simplified example, you can make it to
where it gives a percentage. And you could
313:57 - have more tables for bills and invoices and
all that junk. But just so you guys understand
313:58 - the joint concept, it works the same for basically
any columns you use. So within here, we could
313:59 - have first name, last name, and the amount
paid. These are our columns within our table.
314:00 - I'm just gonna open this up, so we can write
some. And we could say that we have individual
314:01 - people we could say, okay, okay. And then
his amount paid on one of his cards is 2200.
314:02 - And we also have Caleb curry. And the amount
paid is 720. And, if you wanted, you could
314:03 - go in and edit the join adding maximum out.
So that's basically, or we could have a column
314:04 - on here such as
314:05 - amount owed.
314:06 - And we'd have the hat in here too. And that
would basically say, how much they paid out
314:07 - of how much so look like. Then here, we
314:08 - got amount of,
314:09 - like 3000, we're just basically saying 2200
out of 3000. If you wanted to do that, you
314:10 - could do that. But for simplicity sake, let's
keep it like this. And then we could have
314:11 - Jimmy john. And the amount paid could be 2800,
and so forth. You can make more rows if you
314:12 - wanted. Now you're wondering, okay, what's
an inner join, we talked about that earlier?
314:13 - Well, basically, an inner join is going to
take only the rows that either a card has
314:14 - a customer and a customer has a card where
they intersect. So this new table is joined
314:15 - table is going to eliminate any customers
that do not have a card. And it's also going
314:16 - to eliminate any cards
314:17 - that do not have a customer. So I'm going
to erase this, I'm just going to draw a little
314:18 - illustration
314:19 - to show you how this works. Now, you can find
more pictures like this online, which I'll
314:20 - link to in the description, if I can remember,
think of it like this, here is the left table,
314:21 - which was the customer. And here is the card
table. And this part in the middle. This is
314:22 - kind of like the join table or where they
intersect. So here are the customers that
314:23 - have a card. And here are the cards that have
a customer. So within here, this is going
314:24 - to contain all of the rows that have a customer
that also owns a card or a card and is owned
314:25 - by a customer. So if you have a card with
no customer, it will stay out of the end result.
314:26 - And if you have a customer with no card, it'll
stay out of the end result. So this is what
314:27 - you can think of it as all of these things
within this part of the Venn diagram or whatever,
314:28 - that's going to be returned. Now, there's
different kinds of joins where it'll only
314:29 - where it will only return, for example, this
side or this side. But that's where we're
314:30 - going to be getting in, in future videos.
So if you want to do a left join, if you want
314:31 - to a left join and go on here, right join
and go over here. But an inner join is just
314:32 - the intersection of both of the tables. I
have this habit of just like wiping it off
314:33 - with my hands and then my hands are like dark
green. So I'm trying to be a little more civilized,
314:34 - you know.
314:35 - So how do you do this? Well,
314:36 - it's done within a select statement because
remember we are in we're using data manipulation
314:37 - language which is done through selects. So
it would be something like this. Now to warn
314:38 - you, the syntax is going to vary a lot from
relational database management system from
314:39 - relational database management system, but
the concept stays the same. So you just got
314:40 - to replace a couple things, insert a couple
things, boom, Bada, bang, you got a new join.
314:41 - So we're going to say select. And then whatever
comes after the Select, I'm going to switch
314:42 - over. So everything that comes after the Select
is going to be the columns that we want in
314:43 - the joined, generated table. So in the last
example, we had first name, and then we also
314:44 - had the last name. And we also had, what was
it amount paid? I don't remember. But something
314:45 - like that. So that's going to be the columns
we want return, then we are going to say,
314:46 - what table are we getting these columns from?
So we do from? And then we say, Okay, well,
314:47 - you may be wondering, well, there's multiple
tables. So
314:48 - how do we know which one
314:49 - we're going to use, or we're going to put
the left one first, which, in our drawing,
314:50 - we had the user or the customer, and then
we had the card. So we're going to pull it
314:51 - from customer. And then you're going to do
a join and join the other table to the customer.
314:52 - So we're going to say, enter join. And then
you're going to say the other table, which
314:53 - was card. Now what you're going to do is say
how are these tables connected? So the way
314:54 - we have them connected, or the way we want
to join these tables, is by the foreign key
314:55 - connecting to the primary key. And the way
you signify that in syntax would be with this
314:56 - little statement here on which is basically
saying what are we joining it by. And you're
314:57 - going to say, customer dot customer ID, and
what that what that.is is basically saying
314:58 - the first part of this is the table. The second
part is the column. The reason we have to
314:59 - do that is because both tables have a customer
ID. And then you're just going to connect
315:00 - that to the other table by saying equals card
dot customer.
315:01 - Id.
315:02 - Now that's basically all you have to do for
this, it's going to connect, if you look at
315:03 - the syntax, it's going to connect and get
a different marker here. Colors makes things
315:04 - so useful for
315:05 - us.
315:06 - Okay, we've got the customer joined with the
card. Those are the tables. And then we're
315:07 - going to say what columns we want to return
and the new join. And that's first name, last
315:08 - name and amount paid. And then we have say
how they're related. That's the customer ID
315:09 - of the customer table is equal to the customer
ID
315:10 - of the card table. And that's how you get
your join results. So the end result would
315:11 - of course look like this. And you're going
to have first name, last name,
315:12 - and then mount
315:13 - paid.
315:14 - There you go.
315:15 - So that is how an inner join works. The next
thing we're going to be talking about is left
315:16 - joins and right joins and all the other cool
kinds of joins. Main thing though, don't worry
315:17 - too much about the syntax. If it's overwhelming,
just worry about the concept. Understand that
315:18 - if you do an inner join, it's going to exclude
all of the rows from either the left or the
315:19 - right table that are in both tables, it has
to be in both tables in order for it to work.
315:20 - That's the most important thing to understand
when it comes to these joints. Because if
315:21 - you understand that, all you got to do literally
is look up. Let's say you're using my SQL,
315:22 - just look up my SQL syntax, inner join.
315:23 - And then you're going to get a little syntax
code, replace the columns they gave you with
315:24 - the columns D one and the tables with the
tables that you want. It's really simple.
315:25 - So you don't really need to like yeah, obviously
you should learn this in the long run. But
315:26 - if you're new to this, don't worry about diving
in studying that for 20 years. Worry about
315:27 - the concepts because once you get the concepts,
it's easier to pick up on this junk. So in
315:28 - this video we'll be discussing Inner Joins
crossed multiple tables. So you're probably
315:29 - wondering, okay, what does that mean?
315:30 - Well,
315:31 - when we have a join, we join multiple tables.
But what if we want to join that join a multiple
315:32 - tables with more tables? So basically, we're
going to have a join over three or more tables
315:33 - trying to find the green marker. There it
is. Okay, how does this work? Well, let's
315:34 - just draw some boxes to kind of get an idea
of how this might look. Okay, so you might
315:35 - be like, okay, cool, we figured out the Inner
Joins and how those work. But how do they
315:36 - work when you have three tables? Let's, let's
find out. Here we have three tables. And when
315:37 - we do an inner join, let's say in the last
example, we join these two tables, we had
315:38 - some kind of join condition, which was something
like customer dot, customer ID equals card
315:39 - customer ID, you know, well, it doesn't always
have to be that it just depends on what you're
315:40 - doing with it. But basically, you're going
to have a join condition right here. And you're
315:41 - also going to have a join condition right
here, if
315:42 - you want to join in
315:43 - another table, these tables don't necessarily
have to be connected, like a many to many
315:44 - relationship, because when we design many
to many relationships, it looked like this
315:45 - with like the intermediary table, it's not
always the case, for example, this table could
315:46 - have relationship with this table. And this
table could have relationship with this table.
315:47 - But this table doesn't necessarily have to
have a relationship with this table. Think
315:48 - of it like this, when you do the join on these
two tables, you're going to get a result set.
315:49 - Right, then if you want to know what your
next results are going to be
315:50 - when you have this table and think of joining
these, and you're going to get a final result
315:51 - set. So if you do an inner join across multiple
tables,
315:52 - the end result set is going to be smaller
than this, because you think about it. If
315:53 - you join these two tables, you get a result
set. But now, you have to take all of these
315:54 - rows, and you're only going to display the
ones that meet the requirements of this join
315:55 - condition, which is going to decrease the
size, or the amount of rows in this table.
315:56 - And it's going to be shorter. Most cases.
Now,
315:57 - let's talk about this a little more.
315:58 - Let's go through the example we had before
with the cards and the customer. But we're
315:59 - going to add a new table, right. So we're
just going to draw a style. But this is the
316:00 - customer table. And we had a customer ID,
a first name, last name, you can also have
316:01 - any other junk you want to store about the
customer in there. Then we have a card table
316:02 - or the card, card ID and then the customer
ID and then the like maximum out or whatever
316:03 - else you want to store about the car, and
the bill or whatever the price or the interest
316:04 - rate. Now, let's throw in another table in
this equation, let's throw another table into
316:05 - this equation. It's going to be a card type
table. So you know when you get like a credit
316:06 - card, because all you college students are
like, yeah, I need pizza. Well, there's the
316:07 - card is a type such as Visa, MasterCard, or
whatever else American Express. Well, that's
316:08 - kind of like the card type. Generally, a bank
would just give out like one card type. But
316:09 - we could say that they can, like we could
just say what kind of card type the card in
316:10 - this table is. Now when you structure it that
way, how many different card types are there,
316:11 - four or five main ones, Visa, MasterCard,
American Express, maybe two other ones that
316:12 - are somewhat popular, there's not that many.
So if you were to store that in a column,
316:13 - and this one, you're going to get a lot of
repeating data. And then for example, with
316:14 - MasterCard decides to change their name or
they get bought out by somebody else. And
316:15 - all the cards now are named ultra card, then
that's going to cause problems because all
316:16 - of the you're gonna have, you're gonna have
a MasterCard and then ultra card, it's gonna
316:17 - be confusing. So what you can do is use a
lookup table which we discussed in a long
316:18 - video ago. And that's just going to be basically
a reference to another table with all the
316:19 - possible options. And that way if you need
to add a new option, you can do that easily
316:20 - and then just reference that or if you need
to update an option, or if you want to put
316:21 - extra information about that option. For example,
if MasterCard has a standard fee or something
316:22 - you could put that within the card type table,
rather than within the card table. Because
316:23 - if you have the card table, like, Look, if
you have card, ID, and then you have card
316:24 - type, and then you have something about that
card type. So card type interest or something.
316:25 - Well, this is a transitive dependency, which
is a violation of the normal forms, I believe,
316:26 - second normal form. Don't forget, third normal
form, I'm sorry. Anyways, that's not good.
316:27 - So we want to take these and put them in a
new table. So it lookup table is a defense
316:28 - against problems like that. And it also reduces
integrity problems. And it can also reduce
316:29 - repeating values. So now let's design this,
we're going to have a lookup table, because
316:30 - card type. And this is going to have a card
type ID, and then the card type, which is
316:31 - going to be like the name of it. And then
you could have any other rows about the card
316:32 - type in there.
316:33 - And then in the card,
316:34 - we're going to reference that with the foreign
key. So it says looking up the values through
316:35 - the through the lookup table. So we're going
to have card
316:36 - type
316:37 - ID, that is a foreign key. Now let's draw
these connections. Customer ID is a foreign
316:38 - key to the customer. And the card type ID
is a foreign key to the card type. So you
316:39 - can see we have all this information spread
out over three tables. And we want to add
316:40 - age, we want to join these and create a new
generated table that contains information
316:41 - from all three, we want it to be an inner
join in this case, but you can do the same
316:42 - thing with outer joins and other types of
joins. We'll be discussing those soon. But
316:43 - for this, we want it to look like this, this
is what we want our generated view or a new
316:44 - table to look like, we want to select stuff
about the customer, just add some columns
316:45 - in there just to put them in here, we can
have the first name, last name, email, phone,
316:46 - now paid. And then we could also have the
card type right here, it's more, because we're
316:47 - gonna do some cool while we're completely
off topic just for a second. I always like
316:48 - drew comics as a kid and I always like drew
a bubble around like either a thought or a
316:49 - talk. And then I tried to fit all the words
into that and never worked. And then my master
316:50 - drawing friend was like, dude, draw the words
first and then draw a bubble around, it was
316:51 - like the best idea ever. But I still don't
do it. I mean, I always have to erase the
316:52 - size of my database tables, fit more junk
in there should always write the words first
316:53 - and then draw a square around them. But this
work, these are all from this table. This
316:54 - is from this table, the card type is from
this table. It's a join across three tables.
316:55 - And you could of course add more. Now, the
join conditions, well, it would be for this,
316:56 - the customer ID is the same as the customer
ID. And the card type ID is the same as the
316:57 - card type ID. So this table versus going to
exclude here, I'll just write out what it's
316:58 - going to exclude. This isn't part of the table,
but I'm just putting it here, it's going to
316:59 - exclude customers with no card, or cards have
no customers, that's going to be the first
317:00 - joint condition, because we're going from
here.
317:01 - And then
317:02 - the second join condition, it's going to remove
cards with no card type. And also card types
317:03 - with no cards. And that means basically if
you have MasterCard as a card type, and you
317:04 - haven't created any card rows that also have
the foreign key that references MasterCard,
317:05 - or whatever I said, then that's not going
to be included because there would be nothing
317:06 - to put with it. And just say MasterCard, no
normal normal. That's because no cards have
317:07 - it and no people have cards that have it.
So that's the one INNER JOIN is going to do.
317:08 - It's going to do all this. So the end result
is going to basically get smaller and smaller
317:09 - and smaller and smaller for every single table
you add. Now, a couple other things to think
317:10 - about here. It has to do with things being
no or not No. Okay, let's talk about the way
317:11 - we have a set up is the customers. They can
have a card but they don't have have to have
317:12 - a cart. That's because there's no required
column in here that says you have to have
317:13 - a card ID. So you could have a customer that
has multiple cards, for example. We also have
317:14 - a card table. And well, the way we have set
up the card doesn't necessarily have to have
317:15 - a customer. If you want to change that, you
could take this customer ID right here. And
317:16 - you could make it not not, that is going to
change the end result. Because now, every
317:17 - single card is going to have to have a customer.
That means cards with no customers. Although,
317:18 - functionally, it's removing all the cards
with no customers, every single card has a
317:19 - customer. So the end result doesn't eliminate
cards with no customers. Functionally it does,
317:20 - though, because that's what the inner join
does. But since there's nothing to remove,
317:21 - it doesn't do anything. So you can kind of
think of it as not doing this, even though
317:22 - functionally does remember that it's the difference.
All right. Now, we also have it where the
317:23 - card, I would say should have a card ID or
a card type ID, I should say, because almost
317:24 - every card you're going to get ever is going
to have a card type, right? Unless for some
317:25 - reason they wouldn't, you'd likely have that
as not know. So functionally, this is going
317:26 - to remove cards without card types. But since
it's labeled as not null, every single card
317:27 - is going to have a card type. Therefore,
317:28 - in the end result,
317:29 - it doesn't really remove cards with no card
type. Because every card has a card type.
317:30 - So there's nothing to remove.
317:31 - Now card type,
317:32 - there might be a possibility, you're offering
a new card type such as, let's say, so I can't
317:33 - think of any cool names like legit card type
12. And like a new company comes out in there,
317:34 - you get a legit card type 12 card and all
through your new bank account. And that might
317:35 - you when you first get that there might not
be a card that has been issued that card type
317:36 - yet. So in the end result, you're only really
removing the customers with no cards. And
317:37 - I guess, the card types with no cards,
317:38 - I'm going to keep that. So that's going to
stay so these two are going to be removed.
317:39 - And this is the end result
317:40 - here. We're going to keep card types of no
cards and customers with no cards. That was
317:41 - a big one man with our hearts. We talked about
him last year, but never actually talked about
317:42 - the join conditions very much. So I'm going
to go over a new example in this video. Let's
317:43 - do this. So we're gonna have a user table,
not a customer table user table. And then
317:44 - we're going to have a comment table and a
video table. So think of like a video sharing
317:45 - website like that one called, starts with
the you
317:46 - know, but anyways, we have
317:47 - a table here, we also have a table here.
317:48 - We also have a table,
317:49 - right there. All right, these are all connected,
right? Boom, boom, boom, I'm just gonna write
317:50 - the name of the table. I'm not gonna really
write any comments in here, just low on space.
317:51 - So got the user got the comment. And then
we got the video. So the the only way the
317:52 - user has any connection with the video is
through the comment table because a user post
317:53 - a comment on a video. So it makes sense, hopefully
does. I don't even know ask you still, I'm
317:54 - trying to stop screaming crazy. What are the
joint conditions for this, if we want to do
317:55 - an inner join, let's discuss the conditions
and also the results we should expect. Okay,
317:56 - so let's just define the keys that are going
to connect these tables. So we have a user
317:57 - ID. And then we're gonna have a common ID,
and then a user ID, and then a video ID. And
317:58 - then this video ID will be referenced in this
table by a video ID. Okay, now, if you think
317:59 - of this as a many to many relationship between
user and the video, you could potentially
318:00 - get rid of the comment ID and just use the
combination of user ID and video ID. But that
318:01 - is not the best way to do it. One user could
post multiple comments on one video. So you
318:02 - see, like, if we had this common table, we
could have user ID and then we could have
318:03 - video ID and then we could have a Comment,
we have the user ID with seven video ID was
318:04 - 106. And the comment was lame, and then the
user ID of seven, video ID of 106 could be
318:05 - JK. So this is a bad idea, you wouldn't want
to use those combined. Unless you are working
318:06 - on some kind of thing where you can only leave
like one review on a product to say instead
318:07 - of just use a review product or user review,
whatever. In that case, you could use user
318:08 - ID combined with the product ID or the video
ID to allow that, but I'm going to use the
318:09 - comment ID in this. And this is going to be
a surrogate ID that's going to be used as
318:10 - the primary key. And these are only going
to be foreign keys, the user ID and the video
318:11 - ID, they're only going to be foreign keys,
and they're not going to be part of a compounds
318:12 - are a compound key in any sort of way, they
are just another column, that's a foreign
318:13 - key referencing a table to see you guys understand
the structure of how I set this up. Alright,
318:14 - now there's going to be a join condition right
here, which basically a joint condition is
318:15 - what columns are in both tables, right? You
don't always have to say user ID equals user
318:16 - ID, or customer ID equals customer ID or comment
equals common ID, you can do other stuff with
318:17 - like greater than less than and all those
fancy things, but we're just going to be using
318:18 - equals because it's the most common one and
the easiest to understand the one here, it's
318:19 - going to be the user ID. So we're gonna have
user dot user ID is equal to comment dot user
318:20 - ID. This is the first joint condition. Now
for this, we're gonna have a second join condition
318:21 - between these two. And the only thing we can
use is the video ID because it's the only
318:22 - thing in both tables. So we're basically going
to have
318:23 - comment,
318:24 - dot video ID equals video, dot video ID. We
got to say what table there and because they're
318:25 - in multiple tables, so we have to use the
dot syntax, table dot column equal to table.com.
318:26 - I know you guys probably can't read that I
wrote it so small, but it's okay. As long
318:27 - as you understand this is the john, this is
the joint condition for these two, and this
318:28 - is the joint condition for these two. When
you join these, you're going to join them
318:29 - by those columns. And now what about not knowing
no columns? What are they going to be returned
318:30 - as? Well, the way we have a structured user
can comment on as many videos as they want.
318:31 - So they can be in the comment table multiple
times, so got one too many there. Now, a comment
318:32 - can only be posted by one user, and can only
be posted on one video, because each individual
318:33 - comment is going to be a separate row in the
comment table. So for video ID, we're going
318:34 - to have that set to not know. And also for
a user ID, we're going to have that set to
318:35 - not know that's because there should never
be a comment that doesn't exist on a video,
318:36 - there should never be a comment on a video
that wasn't posted by a user. Right? Now for
318:37 - video. We don't necessarily have to have comments
on it. So there's nothing we need to worry
318:38 - about that. Just like a user, we don't have
to worry about having to have a comment. So
318:39 - the only time we need to put not know is on
these two columns. To make sure the comments
318:40 - exist with everything they need. You see,
the user ID would be not normal. That's because
318:41 - every user is a user and every video is a
video. But we don't have to say every user
318:42 - has to comment that would make it impractical.
So that's the setup for the nominal and the
318:43 - relationship types. So then when we do an
inner join, in this case, what are we going
318:44 - to get? Well, I just want to think about that
for a little so we can kind of understand
318:45 - what our end result is going to be. So what
do we want? Well, we want a table that looks
318:46 - like this up a little bit. We want a table
that looks like this. And that's because we
318:47 - wouldn't want it any other shape, right?
318:48 - Um, Steven, but basically,
318:49 - we're going to take
318:50 - the user with the user ID and likely we'll
have more information about them, such as
318:51 - their username. So if you wanted, you could
also include that in the table, which would
318:52 - likely be done from the beginning, because
you'll likely do your joins and stuff after
318:53 - that. Make sure you put your user name in
there. You don't have to add that in there
318:54 - because then half your users won't have a
username and half of them will which isn't
318:55 - good. So username from the beginning, likely
include your username, and then will likely
318:56 - include the comment. So we will need to include
the actual comment in the comment table. The
318:57 - reason I didn't put these in there earlier
because I just wanted to think about the keys
318:58 - for now. But now we can put those in there
that says we're designing this right. And
318:59 - then we also want the video title. Maybe a
link. But we'll just stick with the title
319:00 - for now. So these are the three columns that
we want to include. And we could have set
319:01 - it up in a table, and each individual row
is going to be a new comment. Well, let's
319:02 - see, let's think about what can be excluded
from this. So then we can decide which ones
319:03 - actually will be excluded? Well, let's just
ask questions, can a user be excluded? Well,
319:04 - if we're using an inner join, we're only going
to return users that posted a comment on a
319:05 - video. So yes, any user that did not post
a comment will not be included. Now, what
319:06 - about videos? Will videos be excluded? or
sensitive INNER JOIN, we're not going to include
319:07 - any
319:08 - videos that do not have a comment from a user.
319:09 - So yes,
319:10 - videos can be excluded. And they likely will.
So videos, where it's going to put x by to
319:11 - say that it can be excluded, users can be
excluded. Now, can comments be excluded? Well,
319:12 - let's think about each individual key, we
have the user or the foreign keys, user ID,
319:13 - which is labeled as not know. So that means
every single comment is going to have a user
319:14 - and also, the video ID is not. And also every
single comment is going to have a video. so
319:15 - in this situation, all of the comments will
be returned. So we can't remove those. So
319:16 - within here, every single comment is going
to be included. So if we had 10 comments,
319:17 - we're going to have them labeled one through
10, we're actually going to label them but
319:18 - we would have all 10 of them there. And then
only some users would show up here. And all
319:19 - their comments, all the comments would show
up in this column. So it'd be like, like,
319:20 - it'd be like, like, black and lame. And then
the video title, only some videos are gonna
319:21 - be included here.
319:22 - It's a
319:23 - scrap chance. That's how it's gonna work.
And let's just see how it goes. So yeah. Let's
319:24 - see this in action. Here I have some snapshots
of some tables I created. And I'll just be
319:25 - illustrating this and I'll be drawing on the
screen as needed, and have one of them walk
319:26 - them tablets. And if I am drawing all over
the place, it's because I haven't installed
319:27 - the software, not because I can't write better
than a kindergartener. Alright, so let's begin.
319:28 - Here we have what would be like a user table
or something. We have the user ID email username
319:29 - and the password, which is like just encrypted,
basically. And this is going to be joined
319:30 - with the comment table over here. I mean,
sorry, that's the video table here. Me. This
319:31 - is the comment table. Alright, so here, we
got each comment, and foreign keys to the
319:32 - user ID and the video ID as well as the actual
comment. And then we have the video table.
319:33 - Video table has the title of the video, and
also the description, which would go like
319:34 - under the video or on the side or appended
to the title, whatever you want to do for
319:35 - your website. And this is just what the video
is about, right. And as you can see, I'm advertising
319:36 - my database design course, which is pretty
awesome, right? And what we want to do is
319:37 - we just want to join these. So we have the
username, the title, and the comment, all
319:38 - from three different tables. So the username
comes from the user table right here. And
319:39 - then the title comes from the video title
right here. And then finally, the comment
319:40 - comes from the common table right here. So
let's go back to the join table. What we want
319:41 - to do is, is if we're using let's say the
comment table, we want to replace the user
319:42 - ID with the username and the video ID with
the title So let's look at the comment table,
319:43 - we want to replace all these numbers in the
user ID column with the username, which means
319:44 - we have to reference the user table. And then
the video ID, we want to replace with the
319:45 - video name, which means we'll have to reference
the video table. And then the comment ID,
319:46 - that's just the primary key for this table.
Alright, so let's just kind of look at how
319:47 - this works. So yeah, this is how it works,
the username from the user table, the title
319:48 - from the video table and the comment from
the comment table. Now let's go through how
319:49 - the join looks. I have all the tables here.
Now, it's kind of small. So sorry, if you
319:50 - can't see well, but we have the join table
right here. This is the joint table. That's
319:51 - the join. Then we have the comment, the user,
and we have the video. And we're going to
319:52 - basically just borrow some columns. So the
title that's going to come
319:53 - from
319:54 - the video, so I'm just going to go over here
to do to do, it's going to come from over
319:55 - here. And then the username is going to come
from appear. And then finally we have the
319:56 - comment. And the comment is going to come
from right over here. You can even see that
319:57 - probably not. Okay. So there's a couple things
though, not all of the columns of values are
319:58 - included. So not every single row. That's
because this is an inner join. Now, if you
319:59 - look at the username, we've got all guide
pizza, let's follow this user. So let's go
320:00 - to the user table. They got all sky pizza,
right there. Then we got if we keep going
320:01 - down this table, we got ha 12 which of course
is he's my mouse now right there. Then we
320:02 - got Pablo is all dot dot, which is Paulo was
awesome. Then we got milk and COO, which is
320:03 - milk and cookies. And then we got yellow swag,
which is yellow swag, hashtag
320:04 - yolo swag.
320:05 - And then we got that I don't even know what
that says cifs which is this person, right?
320:06 - Best. Best speller in the world. Okay, I made
these A while ago. So you can see these two
320:07 - people, though they're not included. That's
because it's an inner join, and they are not
320:08 - part of the end result. Now let's look at
the video. So we got the videos, we got database
320:09 - design 1234567. where's where's eight, though
I don't see an eight on here. Well, you can
320:10 - see eight. On the video side right here, it's
not included. So eight is not included. Basically,
320:11 - we're taking different columns from different
tables, but not every single row is included.
320:12 - That's because it's they don't meet the qualifications
for the inner join. So the syntax or something
320:13 - like this would be like this. Said the Select
and then the username, title and the comment.
320:14 - These are all from different three tables.
But it might vary on how it looks for your
320:15 - database management system. But it looks something
like this. And then from the user, comment
320:16 - in video table and we just do the inner join
inner join the comment by the user ID and
320:17 - the comment user ID and then the inner join
a video by the video video ID being the same
320:18 - as the comment video ID. So what's the difference
between an inner join and an outer join, that's
320:19 - what we will be discussing in this entire
video. It's going to be about 20 videos.
320:20 - So hold on a notch. It
320:21 - won't take too long. Once you understand what
an inner join is picking up outer joins and
320:22 - the other junk is like super easy. Okay, kind
of how like once you learn a one programming
320:23 - language, the second one is only somewhat
less hard. Right? See I have some junk written
320:24 - behind me. Let's look at it. Alright, so we
have what's known as a join condition. That
320:25 - is at the end of the joint statement. Do you
remember doing this? I can't hear you. I'm
320:26 - just kidding. Okay, so we got customer customer
ID and card customer ID. That means there's
320:27 - two tables, the customer table and the card
table. And then both of these have a column
320:28 - customer ID to basically just simple dot syntax
The table dot column. And this is making an
320:29 - association. This is saying that we want to
join two tables. And the rows that need to
320:30 - be connected, are connected by the column
of the customer ID
320:31 - and customer ID.
320:32 - So the two columns here, this is going to
make a connection. And our join is going to
320:33 - build is going to be built upon that so we
know where to connect things. So the way this
320:34 - will work with an inner join me to show Yeah,
we got, let me just redraw those two tables
320:35 - real quick, we have a customer. And then we
have the card. So this is like a bank, and
320:36 - people can get credit cards. And a person
doesn't necessarily have to have a credit
320:37 - card because they can go to that bank without
having a credit card. And also, a card doesn't
320:38 - necessarily have to have a current owner because
it could be a disabled card, or it could be
320:39 - a card that hasn't yet been activated, or
something else could happen to where a person
320:40 - doesn't own that card. So there's no required
columns for this. Now, when we join these,
320:41 - the join table is going to only include customers
who own a card, that's going to be the end
320:42 - result. That is with a inner join. So we have
the customer card, join table of card and
320:43 - the customer that is exclusive, pushing away
320:44 - all
320:45 - of the customers with no cards, and all of
the cards without an associated customer who
320:46 - owns that card. The Outer Join works a little
differently, in that it's still going to return
320:47 - all of the rows of from one of these tables,
you can decide which one whether or not, they
320:48 - have an associated entity on the other side.
So that joint statement comes in here, it's
320:49 - important. So we had it to where it was the
customer ID, I'm just going to put C for short.
320:50 - If we have it, where we have it what's known
as a left join, I'm just going to write it,
320:51 - it's going to basically ignore that statement.
And it's going to return all of the rows from
320:52 - the left table. The right one, though, is
still going to be a Bane that join statement.
320:53 - So the joint statement on the right out was
a cause customer. So with this left join,
320:54 - all of the rows are going to ignore this on
the left side. So it's going to return back
320:55 - every single row. On the right side, though,
it's going to only return. The ones that have
320:56 - a customer ID that has a customer ID have
the same value within the customer table.
320:57 - So for example, we could have a card with
the ID, the customer ID of
320:58 - seven. So
320:59 - that's customer ID not card ID. So that's
referring to the person who actually owns
321:00 - the car. All right, we can have that person
over here. And since if you basically insert
321:01 - this into the join condition, we have seven
equals seven, because this card customer ID
321:02 - has an equal value in this table, which means
this card is owned by that person. It's kind
321:03 - of how it works. But with an outer join, we
are going to ignore that. And basically say,
321:04 - we're going to return all of the rows for
either the left or right side. So there are
321:05 - made that are and there are three main classifications
of joins, outer joins, that are I'm going
321:06 - to write them all and then next video is we're
going to discuss them, there is a left outer
321:07 - join, Right Outer Join. And that seems to
be an outer OUTER JOIN. I'm so dumb. I meant
321:08 - to write. Full OUTER JOIN, excuse me. But
basically, we're going to be discussing these
321:09 - two right off hand and full, that can be a
little more
321:10 - complicated for some database management systems.
So we're gonna probably discuss that a little
321:11 - farther down the road, hopefully
321:12 - Now the right outer joins, we're basically
the same way as the left outer joins. But
321:13 - instead of the left table, it's going to be
the right table that keeps all of the rows.
321:14 - Now, if you don't know what I'm talking about,
please watch the last video or two, that's
321:15 - going to solidify your knowledge. And you'll
be like, ready to tackle this, because I'm
321:16 - not trying to get you to watch my other videos,
I'm trying to teach you something that's a
321:17 - requirement to understand this. And I don't
wanna have to reteach it all, for the sake
321:18 - of one little concept. So let's draw this
out a little bit. We have it to where we have
321:19 - two tables, a user, our customer table, and
a card table. So this would be like for a
321:20 - bank or something. And let's first see how
would a left join would do a left join would
321:21 - take all of these customers. And then it will
take only the cards that have an associated
321:22 - customer and return those. So we returned,
we basically connect the dots. And then we
321:23 - would get a joint view, which is going to
list all the customers, but only the cards
321:24 - that have a customer. So this is going to
be like customer listed card they have. And
321:25 - if they have another card is going to list
that customer again, list the card they have
321:26 - we discussed that in depth in the last video.
Well, for a right join, it's going to work
321:27 - the same way, except now it's going to do
it for the other team. So we're gonna have
321:28 - the same exact setup, we're gonna have a card,
I mean, a customer and card table.
321:29 - And
321:30 - now, if we set it up with a Right Outer Join,
it's going to take all of the cards, put them
321:31 - in the join table, so every single card, and
then it will list the associated owner of
321:32 - that card. So card, and then the customer.
Now there's something to consider with this,
321:33 - if we set it to where within the card table,
we have customer ID and we give that a column
321:34 - characteristic of not No, that's gonna, that
might confuse you a little bit because then
321:35 - every single card here is going to have an
associated customer, which kind of that's
321:36 - the whole point of the Right Outer Join, or
the left outer join for that sake, is to include
321:37 - the rows that don't have that association.
So if it's set to not know, it's going to
321:38 - return them all anyways, whether you use a
Right Outer Join, and so forth, you guys understand,
321:39 - because basically, if we use the Right Outer
Join for this, it's going to return them all.
321:40 - But it's going to return them all anyways,
because every single one has an associated
321:41 - card, we'll discuss that more in the future,
don't worry about it. Now there's something
321:42 - else to consider. This basically works the
same exact way as the left outer join, except
321:43 - is switched around. So when we discussed in
the last video, how you could say which table
321:44 - was the left,
321:45 - right
321:46 - where the froms the basically the form be
like select, maybe and then you'd have like
321:47 - the columns first name, last name, and card
amount, or you can have your card amount of
321:48 - us good. And then you have something that
says like from Well, the column that you put
321:49 - right here, the table you put right there
is considered left when we're talking about
321:50 - this design stuff. So in theory, you could
switch it around to where a left join works
321:51 - the same way as a right join, you're just
switching the direction of the tables. So
321:52 - in practice, most people don't even use right
joins, I'm only teaching you so you understand
321:53 - when you see one. Instead of using a right
join, they'll often use a left join. And then
321:54 - they'll just flip the column the tables I'm
sorry. So like this, you have your two tables.
321:55 - And I'll give you two possibilities that are
going to give the same result. You could have
321:56 - your customer and then the card. And you can
use a Right Outer Join. Or you could have
321:57 - it to where you have over here you have the
card and the customer with the same exact
321:58 - columns in same exact foreign keys. Nothing
changed except in design, you just switch
321:59 - the things and when you make the SQL statement,
you're going to switch the location of the
322:00 - call of the tables within that statement.
But overall the function works exactly the
322:01 - same. And now you're going to use a
322:02 - left outer join.
322:03 - These are going to return the same exact thing.
Because if you do this one it's going to return
322:04 - All these rows and the associated columns
with those rows, if you do this, it's going
322:05 - to return all of the rows, and all the associated
columns, those rows. So either way, you're
322:06 - getting all the cards in part of the customers
z. So in practice, a lot of people will only
322:07 - use left outer joins for consistency, and
clarity. So if someone else sees it, they
322:08 - already know it's the left outer join, they
don't have to worry about left or right, and
322:09 - then draw it out and get all confused. Most
people just use the left outer joins, but
322:10 - you can always use right outer joins, if you
really wish that is up to you. Well, I've
322:11 - been talking a little bit about not no columns,
basically columns that aren't allowed to have
322:12 - no value. And that can cause some confusion
when it comes to joins, because you might
322:13 - get results you don't expect. And I'm just
going to be explaining that just a tiny bit
322:14 - more, this video will be quick. So if you
already understand it, go ahead and skip it
322:15 - if that's what you wish. Alright, so I'm going
to be going over an example of a user comment
322:16 - system. So basically, you're going to have
a table with the users, and then you're going
322:17 - to have something such as a common table,
and you might have a table such as video,
322:18 - or blog, or whatever you're commenting on.
But that's out of the illustration for now,
322:19 - don't worry about that. Well, in this example,
we have some columns that are labeled not
322:20 - know. And what this means is that you're not
allowed to have them to where there's no value
322:21 - in that row for that column. So for example,
if in comment, we had comment ID, and then
322:22 - we had user ID. And we gave it a column characteristic
of nominal, well, what is that going to do?
322:23 - That's going to basically say that every single
row within this comment table has to have
322:24 - a user ID associated with that comment. And
that would be the person who posted that comment.
322:25 - Now, the user, on the other hand, doesn't
have to post a comment. It's a one to many
322:26 - relationship, and the user does not have to
post a comment. But a comment has to be owned
322:27 - by a user. That's important to know. So there's
three real possible options of joins that
322:28 - we can do on this table. The first is an inner
join, I'm gonna put these in caps, because
322:29 - it's probably better to do that. Now the inner
join does not matter which one is left or
322:30 - right, because it's going to take the middle
of both of them. So the positioning of your
322:31 - tables within your query of the select statement
does not really matter. All it matters is
322:32 - that you're using the inner join, what is
the inner join going to give you and the inner
322:33 - join will give you
322:34 - all of the users who have comments. That's
because if a user doesn't have a comment,
322:35 - it's not going to be in his ID won't be in
the comment table. And he'll be left out.
322:36 - There's a comment that doesn't
322:37 - have a user, well, then it would be left out
too. But that's not the case. Because it's
322:38 - not No. All right, the other option is a left
outer join. And I'm going to go into place
322:39 - places in a second left,
322:40 - outer
322:41 - join. And then we could put the comment on
the left. So if you need help position, if
322:42 - you need help thinking about that, in your
head, switch these two tables around. But
322:43 - I'm not going to do that, because that's part
of the illustration already. We're good. Right?
322:44 - The other option will actually let's talk
about what that's going to do first, left
322:45 - outer join is going to give you all of the
comments,
322:46 - and then give you the associated users who
have posted those comments. So every single
322:47 - comment will be included. So the return
322:48 - result will be all comments, and associated
users, okay? Now think about this, though,
322:49 - these things are actually going to give you
the same exact thing. That's because if you
322:50 - do an inner join, it's going to give you all
the users who have comments. Okay? So it's
322:51 - going to take you all of the users who have
a comment and put it in there. And then it's
322:52 - going to take all the comments that have a
user and put it in there, ensure that all
322:53 - the comments that have a user, all the comments
that have a user. So these are going to give
322:54 - you the same result. So just understand that.
The third option is to flip the left join
322:55 - the tables that is so got a left outer join
with the user table and left. Okay, now what
322:56 - is this going to do? It's going to give you
all of the users and the associated comments
322:57 - from those users. Now, let's talk about so
we're going to have it's either it either
322:58 - includes them all or exclude some of them.
So basically, if it includes With all of the
322:59 - users, I'm going to label it with a star.
If it only includes some users, I'm going
323:00 - to label it with an X. Same for the comments,
all the comments, it's going to be a star,
323:01 - some of the comments is going to be an X.
So users do have comments will only some users
323:02 - are going to post comments. So that's going
to be x on the user end.
323:03 - But
323:04 - all of the users who have comments, that's
going to include all of the comments, because
323:05 - all of the comments are labeled as not know.
So every user posts a comment has a row within
323:06 - the comment table. So it's going to return
them all. So it's going to turn them all on
323:07 - the user end.
323:08 - That's a star.
323:09 - Now, left outer join with the comments on
left returns, all comments and associated
323:10 - users. All the comments. So all on the comment
side, it's going to return them all. But the
323:11 - users, not all of them just part of them.
Now, left outer join is going to return all
323:12 - users and associated comments. So the first
one is some users all comments. The second
323:13 - one is some users all comments. The third
one is all users and all comments, this, that's
323:14 - what you kind of need to do when you're trying
to plan out which join you need to use, go
323:15 - through all the possibilities with that join
in is right amount. So you see that these
323:16 - two are actually the same, this one is just
a tiny bit different. And that includes all
323:17 - of the users. So you may be wondering, well,
which of these two should you use? Well, to
323:18 - be honest, it doesn't really matter. If if
you wanted to return all of the comments,
323:19 - don't worry about whether it's not normal
or not just use a left outer join with the
323:20 - comments on the left. And then you're guaranteed
to have that you don't have to worry about
323:21 - whether it's not normal or not. So that's
what I would do if you only want the users
323:22 - and the comments included. And you don't want
to include any comments that don't have a
323:23 - user, which is never going to happen, then
you do a
323:24 - inner join.
323:25 - So what you do is you just think pretend all
the comments, all the columns are knowable,
323:26 - or they don't have to have a value. And then
you plan your joints around that. And it can
323:27 - still work the same way. If that's what you'd
like to do. Otherwise, you just plan out like
323:28 - this. And realize you can use either one of
these, and it's going to work out fine for
323:29 - what you want to do. This video we will be
discussing using outer joins. When there are
323:30 - three or more tables, we will be discussing
the example using three tables. But you can
323:31 - basically apply it to any example as long
as you understand the concepts, I really recommend
323:32 - that you watch the video about using Inner
Joins when there are three or more tables,
323:33 - because the concepts are going to be basically
the same except different results will be
323:34 - returned. So for this, the best way to think
about it is let's say we have three tables,
323:35 - ignore these two right now, we have a user
comment and video table. So basically, it's
323:36 - a system where you can comment on videos,
each video that does get a comment will be
323:37 - in this table. And every user that post a
comment will also be in this table connected
323:38 - with that video, right? What I'm going to
do is I'm going to use a left outer join on
323:39 - this side and a Right Outer Join on this side.
And we will just see what those results are
323:40 - like. Alright, so first thing is first, let's
join the user and comment table. That's the
323:41 - best way to think about it is to imagine these
two tables being joined here to make a new
323:42 - temporary join table. And then imagine this
new temporary table being joined with the
323:43 - third table to give a final result join table.
So if we do a left outer join here, every
323:44 - single user is going to be brought down to
this table in this situation of a left outer
323:45 - join. It will only take the comments that
have users because there has to be an association
323:46 - of the user ID in both tables for that. But
it's likely that every comment is going to
323:47 - have an associated user because that that
user ID column will likely be set to not know
323:48 - that way you don't have comments that aren't
posted by anybody because that would be weird.
323:49 - So this will also return all comments. Great.
Now that we have that new table. You see we
323:50 - basically just took everything from up here.
Let's imagine taking this and joining it with
323:51 - the videos and we're going to use a Right
Outer Join. So this is going to be Right Outer
323:52 - Join for Outer Join, we're going to take all
of the videos and bring them down here. That's
323:53 - basically how right outer joins work, they
will automatically take every single row from
323:54 - the right table. And then we're going to take
any row in this table that has an association
323:55 - with the video table. So that means the comments
will have to have a video, which all of them
323:56 - will. Alright, so what what will be removed
here? Well, some of the users will be removed.
323:57 - The reason that is is because some of the
users aren't going to be in the comment table.
323:58 - And if they're not in the comment table, they
can't have an association with the video table.
323:59 - So think about the join statements here, we'll
likely have something where it's like, user
324:00 - ID over here is equal to the user ID over
here. And then we'll have it to where it's
324:01 - done, we'll have it to where it's a video
ID over here. And that's equal to a video
324:02 - ID over here. So when we grab all of these,
we have all the users and all the comments,
324:03 - because all the users will have a user ID.
And we don't have to have those users in the
324:04 - comment table. Because it's a left outer join,
which automatically takes all of the users,
324:05 - all of the comments will be returned, because
every comment will have an associated user.
324:06 - But once we get over here, it gets a little
different. Now it's about the video, not the
324:07 - user. So we're going to take all of the comments
that have the video ID, and all of the videos
324:08 - that have a video ID. Because it's a Right
Outer Join, we're going to take all the videos
324:09 - whether or not they have a video ID in the
comment table. So the first thing, take all
324:10 - the videos, we're also going to take all of
the comments are only going to take some users.
324:11 - The reason that is is because if a user, let's
give some example data, let's say we have
324:12 - a user over here with the ID of seven. And
he he doesn't leave a comment, but because
324:13 - we do a left outer join. He comes down here
anyway. So now he's in this new generated
324:14 - table. Well, he has a user ID. But does he
have a video ID in the comment table to be
324:15 - associated with the video ID in the video
table? No, he does not. So he wouldn't make
324:16 - it on past this stage. And he wouldn't be
in this final outer table as joined table.
324:17 - So the final result is going to be all videos,
all comments, and some users. That's just
324:18 - an example of using right and left outer joins
when there's three tables. Or you could do
324:19 - the same thing with inner join. So if you
did an inner join, it's only going to take
324:20 - the users you have comments. So I mean, you
can basically apply the same example to a
324:21 - lot of different situations to get the results
you want. As long as you understand how a
324:22 - left join works, how a right join works, and
how an inner join works, you can get essentially
324:23 - everything you really need to get. The only
one we haven't really discussed is the full
324:24 - OUTER JOIN, which you might need sometimes.
And that's a little different. So we'll be
324:25 - talking about that soon. In this video, we'll
be taking a quick break from joins that we've
324:26 - been discussing for the last eight or so videos.
And we will be discussing something that's
324:27 - a little unrelated, but kind of related, if
that makes sense. But anyways, we'll be discussing
324:28 - aliases. So an alias is when you rename something
and you give it kind of like a nickname or
324:29 - more of a user friendly name, or a name that
you are more used to seeing. And you can do
324:30 - this when you're writing SELECT statements
and SQL and you can do that to either make
324:31 - it easier to write or easier to read. So when
you want to give a table an alias, you will
324:32 - use the A S or as keyword. And that's going
to say anything that follows as we which is
324:33 - what we want to call the table. So let's say
we had that user table. And instead of using
324:34 - user you wanted to say a customer, well then
when you use the table and the rest of the
324:35 - query and you use your joins, rather than
using user, you can use the customer. And
324:36 - often you won't take a short name and make
it into something longer. You will do something
324:37 - like replace user with a U
324:38 - and then instead of you doing user dot user
ID, you would be you die user
324:39 - ID.
324:40 - That's an example of an alias. When you do
it on tables. It's often to make the select
324:41 - statement easier. But you can also do it for
columns. Now when you do it on a column, it's
324:42 - going to work a little differently. So when
I select
324:43 - statement, you put all your columns at the
top. So here's just an example of what you
324:44 - might say to a database, you're going to select
the email, first name, and last name. When
324:45 - you use an alias with columns, not only do
you change what the column is called, but
324:46 - it's going to change what it's presented as.
So when you get that new structured view,
324:47 - that generated table, and it looks something
like this, rather than saying email, first
324:48 - name or last name, you can make it say, email,
fn. Whoops, fn, Ln fOr first name, last name,
324:49 - or you can take out that underscore, and you
can replace it with you know, first space
324:50 - name.
324:51 - This works similar in the way that the other
alias works for the tables, except you put
324:52 - it right after the column. So you can say
select Email, as contact, comma, first name,
324:53 - as, and then you put in quotes got a quoted,
that's because you're telling it this is what
324:54 - you want it to be,
324:55 - you want to put it in quotes,
324:56 - so that way, it's understood to be a string.
You can see here, I put that space there.
324:57 - And without the quotes that can just cause
a problem. Comma, and then underscore last
324:58 - last
324:59 - name.
325:00 - Okay, see all that. That's basically how an
alias works, you can take the alias to make
325:01 - things easier to write easier to present.
And also, it can change the way the view looks.
325:02 - So it looks more pretty, right? In the next
video, we're going to be talking about joins,
325:03 - that you reference the same table or a self
join. And basically, you're going to take
325:04 - the table you have and basically tell them
last Do you want to make a copy of it essentially,
325:05 - and join these two tables which are the same.
And the only way that's going to work is if
325:06 - you give it an alias, so this table will be
called T one and this one V T two, for example.
325:07 - So that's an example of when you would use
an alias. Other than renaming your columns
325:08 - or your tables. The way a self join works
is you take a table, and you are essentially
325:09 - joining it with itself. And that's what kind
of makes self joins confusing. And a lot of
325:10 - people can't find practical purposes for them,
I'm going to be giving you a drop my marker,
325:11 - I just got white marker, all sub joints are
complicated. And a lot of people can't find
325:12 - practical purposes for them. In this video,
I'll be giving you at least one good reason
325:13 - for them. So hopefully, this video is helpful.
So when you have a self join, think of basically
325:14 - duplicating the table you have and making
an exact copy. And then joining those two
325:15 - tables together. That's a good way you can
think about it. So for this example, I'm going
325:16 - to be using a user account system on a website.
And you know how some websites have like a
325:17 - referral option. Basically, if you refer somebody
you get like 20% of their money and or their
325:18 - points or 10% of their money, so forth. That's
like referral marketing. And when you do that
325:19 - you are assigned a person who referred you,
right, and it can become a chain like this
325:20 - person or for this person or for this person
or for this person. So within a user table,
325:21 - you might have a user ID. And then on top
of that, you're going to have, you know, email,
325:22 - first name, last name, and the person who
referred you, I'm putting the person who referred
325:23 - you within a column known as referred by,
and this is actually a foreign key to the
325:24 - same table. So within here, you're going to
have numbers such as 12,
325:25 - which is going to point back to the user ID
of 12. So for example, the user ID 11 might
325:26 - be a person who was referred by the user with
the user ID of 12. Now, the only way you can
325:27 - make this really work for a join, is if you
use a self join. Basically, what we want to
325:28 - do is we want to replace referred by with
the ID, we want to use a join to replace this
325:29 - number with that user's email, which I also
forgot to put in here. So you know, just throw
325:30 - an email in there. So we'll take this, and
then our outputted result will look something
325:31 - like this. And this is the table that we're
going to have. And then we're going to insert
325:32 - data into that table. So you might have a
user such as Caleb curry, and his emails is
325:33 - going to be swag@yolo.com. And then it's referred
by that and we're going to replace that number
325:34 - with a user's email such as
325:35 - Howard South
325:36 - Yeah.
325:37 - dot org.
325:38 - So that's just an example of what we can do
with this self join. Now in order for this
325:39 - to work, we have to tell the database that
we're going to be using the same table in
325:40 - basically two different tables. And that can
kind of be confusing. And in order for that
325:41 - to work, you have to use what's known as an
alias. I talked about those in the last video,
325:42 - so be sure to check those on out. So to begin,
we just kind of think of a name of what we
325:43 - could call each table, we can have the first
table, which would also be the user table.
325:44 - And then the second table, which would be
another copy of the user table. Now we're
325:45 - not actually like copying the data. This is
just for illustration point, it's going to
325:46 - use that data that same table to withdraw
the data from, and we could say this one is
325:47 - v one and v two, for example. Those are our
aliases. And in order to define those, we
325:48 - put as after our data after our table and
put v1. So we can say, user as v1, and then
325:49 - join user as v2. This is something kind of
like what you would do. So now we have a user
325:50 - as v1. And then we're joining user as v2.
And it kind of gets the idea that oh, this
325:51 - person wants to use the same table for this
situation. Let's try to figure this out. Let's
325:52 - begin, we're going to put this within a select
statement. And I'm going to give you some
325:53 - specific syntax just so this can kind of make
sense. So we have a select statement.
325:54 - Then right after the select
325:55 - statement, we always put the columns we want
to take our data from. Now this can get kind
325:56 - of confusing, though, because we have two
basically two different tables that we're
325:57 - going to be taking data from. So we have to
think which table we want to take which columns
325:58 - from the way we had it set up before is we
have this table and this table. This was v
325:59 - one and this was v two. Well, that's kind
of in our imaginary brains, which we don't
326:00 - have, we're gonna say this table is for the
user. And this table is for the referrals.
326:01 - So we're going to take from this table, we'll
take the the user ID, maybe for the first
326:02 - name, the last name, and the email. And then
from this table, we're going to take the email
326:03 - of the person
326:04 - who referred you, so we'll take the
326:05 - referred by
326:06 - person's email. So the way this will work
is we're going to have the user IDs such as
326:07 - seven and Caleb curry, and then their email,
and then it'll have an ID of seven or something
326:08 - around eight, for the referred by, and then
that's going to go to the second table to
326:09 - get that person's email, you got to keep this
in mind. And you have to figure out what you're
326:10 - going to name your tables before you start
the Select. Because now that we are going
326:11 - to say the columns, we have to qualify those
columns by putting a dot before them and saying
326:12 - what table they're from. And we can just use
the Alias Name that we've had or made up.
326:13 - So we could say, select v one, period or dot.
And we could say first name, comma, and then
326:14 - we can say V one dot last name, comma
326:15 - v one
326:16 - dot email. Comma. Finally, we're going to
take v two and we're going to take that person's
326:17 - email or you can do their first name or last
name,
326:18 - whatever you want to put in that referred
by thing, if you wanted to say their first
326:19 - name, you can say v2 dot first name, if you
want to be their last name, it can be v2 dot
326:20 - last name. Or if you want a combination of
both, you can use a concatenation function
326:21 - or something. So we're just going to use the
email. So we're going to take the v two dot
326:22 - email. Now that we know what columns and what
tables that we want to take the data from,
326:23 - we actually have to put the from statement
still and say something like from and then
326:24 - put the table we're taking this data from.
This is where we are going to define our alias.
326:25 - So we could say, from user
326:26 - as
326:27 - v one
326:28 - that is going to basically tell the database
that the user table is known as v one. Now
326:29 - we can do a join.
326:30 - Join,
326:31 - this is going to default to an inner join.
If you just use join like that. We could say
326:32 - join user as the two that is going to basically
tell them that user is also going to be known
326:33 - as v2 but it's going to be considered a different
table in this situation. Then you're going
326:34 - to do the on which is going to say where we
are going To join these things. Now this is
326:35 - where it can get really confusing, because
there's so many possibilities that you can
326:36 - put right here. For this situation, we are
going to take v1, and we're going to take
326:37 - the referred by column, and that is going
to be the same as V to u user ID column. So
326:38 - if you can think about this, imagine literally
two tables with the same exact data. Here's
326:39 - the one, here's v2, and we have a user ID.
And then within here, we also have a referred
326:40 - to by or referred by guess that's going to
reference the user ID of the v2 table. So
326:41 - that means we need to basically make this
connection and say that if there's a six over
326:42 - here, and they're referred by table, it needs
to be the same as the user ID over here that
326:43 - has six. If you need more practical data under
to understand this, imagine, we have this
326:44 - guy over here. And his name is Samuel. And
we have this guy over here.
326:45 - And his name is.
326:46 - Yeah, that's his name. And also refer Samuel,
that means it's going to have the user ID
326:47 - of six, within this user row of the user ID
of let's say, 12. So Samuel has the ID of
326:48 - 12, when he was referred by the person with
the user ID of six, which is I've heard of,
326:49 - and then this other table, which is also the
same user table, it's going to refer to the
326:50 - person with the ID of six,
326:51 - which is this guy.
326:52 - Hopefully, that makes sense. But in reality,
you're not going to have two exact copies
326:53 - of the data, it's smart enough to understand
that these are all one table. So it's basically
326:54 - going to take that referred by, and then go
back to the user column, and join that into
326:55 - what would look like taking two tables and
putting them together. That's why I get kind
326:56 - of confusing. But when you take this query
as it is, and you put it in your database,
326:57 - you will get something that looks like a normal
join table, there'll be one really big table,
326:58 - and it will have the columns that we selected,
v1 dot fn. On top of this, we're also going
326:59 - to have the V one class name and the v1 email,
and the v2 email. Then if we were to put example
327:00 - data into this, it would look something like
Caleb, Curry, and email and then the v2 email
327:01 - would be like another guy's email. So such
as so
327:02 - calm,
327:03 - that's what it would look like. And it would
just give you all the rows for that. So yeah,
327:04 - you can mess around, do all kinds of cool
joins and all kinds of stuff. But there's
327:05 - one more thing that I want to tell you. And
that has to do with aliases. Well, you know,
327:06 - this might not be too pretty how you have
right now. And it might be confusing having
327:07 - an email and then right beside it another
email, like what is the what are those mean?
327:08 - Well, you might want to say that one column
is the user, and another is the person who
327:09 - referred them. So you can use an alias for
that, too. So for that you also use as, but
327:10 - instead of putting in the from, you're just
going to put it right after the column that
327:11 - you want to change. So you can put here, here,
here, and here. So if I wanted the table to
327:12 - email, or the person who referred, you could
make it say like, v two dot email, as referred
327:13 - by, and this you're going to want to put in
quotes to say you'll want that string as the
327:14 - title for that column. And then when you get
that new table, join, instead of saying email,
327:15 - it's going to say referred by, and then a
list of data. Yo, what's up my homie homies,
327:16 - this video are the section of the video, I
guess, we will just be discussing this in
327:17 - a little more depth by showing this real example
that I explained on the board. So you can
327:18 - see I have a user table. And within my user
table, you know, I got user ID pass email
327:19 - for first name, last name, and a referred
by this referred by is a foreign key referencing
327:20 - the user ID. It's kind of interesting how
that works. So you can see here is this guy
327:21 - allama swag at YOLO calm is referred by to,
which in this case would be Hi mom at low
327:22 - level calm, which he basically referred everybody
that's why has a zero here. And if you scroll
327:23 - down, we also have some people who are referred
by one. And basically what we want to do is
327:24 - we want to replace this referred by with the
person's email. And to do that we can use
327:25 - a self join. And who knows there might be
a way easier way to do this. So if there is
327:26 - just be sure to let me know. Alright, so here's
a query that would work to do that. So let
327:27 - me just refresh this. And here's what it's
going to do. It's going to select the first
327:28 - name, last name, email. Mail of the person
who was referred, was also going to take the
327:29 - email of the referral person, the person who
referred the other person, the person within
327:30 - this preferred by column. Okay, so you can
see we got first name, last name, email. That's
327:31 - one thing, and then the referred by email.
So how does this work, we can take the columns,
327:32 - and we also replaced the email of the referred
by and put referred by, that's why it shows
327:33 - up right here, which is what we want, that's
good. Then we say what table we're going to
327:34 - take the user table and call it v1, which
you can basically name it whatever, as long
327:35 - as you update right here, then it'll still
work. That's just the name I made up, I couldn't
327:36 - think of something cool. But base, basically,
a version one, you know, this inner join is
327:37 - taken our other version of the table and just
say, no, this inner is optional. So you can
327:38 - take that away, and it's gonna work exactly
the same way. Then we're going to say how
327:39 - it's related. So basically, this referred
by email, that needs to have an ID in that
327:40 - table that refers to a person. So the referred
by is going to have an ID, and that needs
327:41 - to match a user ID. So within the first table,
let's go back to the user table. This two,
327:42 - for example, that needs to reference an actual
person, it needs to be actual data within
327:43 - that second version of the user table. And
it's going to go to the second version of
327:44 - the user table, find that person with the
ID of two. And it's going to take that email
327:45 - and display it right here. So hopefully, that
makes sense, guys, and of course, you can
327:46 - mess this mess up the square, you can just
mess around with it and put your own stuff
327:47 - in it to get your own results. And you can
even change this statement right here to get
327:48 - even more crazy results. So yeah, guys, thanks
for watching peace on earth, and catch you
327:49 - in the next video. And subscribe, as well
as v one dot last name and V Ah, it's a one
327:50 - night now moron. For the aliases of the table.
We're going to tell my SQL ah crap nuggets.
327:51 - It's not my SQL databases.