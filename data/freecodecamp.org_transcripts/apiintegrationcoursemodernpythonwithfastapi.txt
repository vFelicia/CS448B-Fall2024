00:00 - learn modern web development with python
00:02 - and fast API by building five projects
00:05 - Zach is an experienced software engineer
00:07 - and in this course he'll teach you how
00:09 - to build apps using an event driven
00:12 - architecture that manages different
00:14 - tasks all implemented using fast API
00:17 - welcome to this modern python course we
00:21 - will be building web applications that
00:23 - utilize fast API and some other modern
00:26 - libraries that will help you build full
00:29 - stack development projects my name is
00:32 - Zach and I am a software engineer based
00:34 - in London I wanted to design a course
00:37 - that will demonstrate some of the modern
00:40 - usage of Python's web development
00:42 - Frameworks and I believe that with this
00:45 - type of project building you can really
00:47 - practice relevant portfolio skills that
00:50 - can help you progress your career in
00:53 - this particular industry before we dive
00:56 - in let's talk about what you need to
00:58 - know to get the most out of this course
01:00 - course you should have a basic
01:02 - understanding of Python Programming as
01:04 - well as some familiarity with some
01:06 - front-end Technologies like HTML CSS and
01:09 - basic JavaScript additionally a
01:11 - fundamental knowledge of HTTP networking
01:14 - is a requirement here as we don't really
01:17 - go into the details of how these certain
01:20 - protocols work we will review some of
01:23 - the key Concepts as they needed
01:25 - throughout the course since I wanted for
01:27 - this project to be useful for developers
01:30 - trying to learn their first job as a
01:33 - python backend engineer I implemented
01:35 - some of the more advanced topics like
01:38 - example of using multi-threading for
01:40 - dealing with asynchronous tasks when
01:42 - doing API Integrations if I could
01:44 - summarize the importance of this entire
01:46 - course in one sentence I would say that
01:48 - in a way you are building some kind of a
01:50 - event driven architecture and managing
01:53 - different tasks with in the
01:55 - implementation of fast API framework I
01:58 - did my best to to implement without too
02:01 - much redundancy things like database
02:03 - Integrations so that the coders here can
02:06 - get some hands-on experience with
02:08 - various apis and databases first we'll
02:11 - build a real-time translation service
02:13 - using fast API and gp4 this project will
02:16 - show you how to harness the power of
02:17 - language models to create an application
02:19 - that can translate text in real time for
02:21 - our second project you will learn how to
02:23 - create a tool that not only generates
02:25 - content but it also analyzes the
02:26 - sentiment the third project we use fast
02:29 - API and open AI where you will learn how
02:31 - to interact with external apis and
02:33 - process data to create a functional and
02:35 - useful web application in the fourth
02:37 - project we'll switch Gaz a bit and
02:39 - create an image to text web app with P
02:41 - Tesseract and flask you'll see how to
02:44 - integrate OCR technology into a web app
02:46 - to extract text from images and finally
02:49 - we'll wrap up with the KV app for
02:50 - downloading videos this project will
02:52 - introduce you to KV for building
02:54 - multitouch applications and you'll learn
02:55 - how to integrate it with virus apis to
02:57 - download video content I feel like these
02:59 - five projects will definitely help you
03:01 - use Python for some Modern application
03:04 - so let's get started and bring these
03:06 - projects to life we will build a
03:08 - translation service application it will
03:10 - be a web based tool designed to
03:12 - translate text into multiple languages
03:14 - for our backend we'll use fast API we'll
03:16 - have a database in postgress and for the
03:19 - translation we'll communicate with open
03:20 - AI CH GPT 4 model this is what the end
03:24 - result will be the user can input a
03:26 - desired text for the translation here
03:29 - and also in any number of languages that
03:31 - they want their text translated to they
03:33 - can hit translate and this will execute
03:35 - a post request to our API service and
03:37 - fast API will then try to communicate
03:40 - with ch GPT to provide a translation
03:43 - whilst this is happening we want to
03:45 - inform the user that we have received
03:48 - their request so it will return a 200
03:50 - whilst is asynchronously processing the
03:53 - translation and waiting for that to come
03:55 - back so once the results have landed
03:58 - back onto our fast API app we want to
04:01 - display them dynamically without the
04:03 - user having to click anything so we will
04:05 - be building this event driven
04:06 - architecture and this is in my opinion
04:08 - the most important aspect of the video
04:10 - we also added a search functionality
04:13 - here which will allow the user to query
04:15 - the database and check the status of any
04:18 - particular translation order also by
04:22 - querying the ID they'll be able to check
04:23 - the content so they can historically
04:25 - browse through any of the previous
04:28 - translations so this is what the project
04:30 - structure will look like and it's pretty
04:32 - straightforward so this is our web app
04:35 - so it's our fast API fast API izing
04:37 - conventional file structure this will be
04:40 - our front end and almic will handle all
04:43 - the database migrations this will be our
04:46 - configuration files and because we in
04:48 - the end we will also create a Docker
04:49 - image for easy deployment so we are
04:52 - moving to our vs code now and we will
04:54 - start coding the project so you want to
04:56 - create your main folder and inside you
04:58 - want to create another sub folder we'll
05:00 - call it app inside of that folder you
05:03 - want to create your main py and this
05:05 - will be our fast API client now we will
05:07 - make sure that we have our virtual
05:09 - environment running let me zoom in a bit
05:12 - here you want to make sure that you're
05:14 - in your main folder and we will create a
05:17 - new environment once this is completed
05:20 - you want to activate this environment so
05:23 - we can install our dependencies so I'm
05:25 - going to use Powershell for that so you
05:27 - want to navigate into your requirement
05:30 - scripts and I believe here should be
05:33 - your activate.
05:36 - PS1 and once you see this prefix it
05:38 - means you have activated your virtual
05:41 - environment so now we can install our
05:42 - dependencies that we'll be using for
05:44 - this project so for that we'll create a
05:47 - requirements text file and I'm just
05:49 - going to copy everything that I know we
05:52 - need here keep in mind very important we
05:56 - have to use a specific version of open
05:58 - AI for this to to work so it has to be
06:01 - open AI
06:03 - 028.0 we also need a limic and now we
06:07 - can install all of the dependencies so
06:10 - you want to navigate back to your main
06:12 - working directory and you can type in P
06:15 - install our requirements.txt once this
06:18 - is completed I came back too quick oh it
06:21 - wasn't saved so you want to type in PIP
06:23 - install all requirements and once this
06:26 - is completed we can start writing the
06:28 - code so it might take a minute we can
06:30 - start writing something in our main py
06:33 - file from Fast API import fast API this
06:37 - is something we will use later on but
06:38 - you might as well do it now background
06:40 - tasks HTTP exception request and Depends
06:43 - we'll also import HTML responses we will
06:46 - import cost middle bear and to be able
06:48 - to render an HTML page we will import
06:52 - Ginger to templates with that being said
06:55 - we'll say that fast API is in our app
06:57 - variable and we can create a templates
07:01 - folder inside of this app folder so you
07:05 - want to make sure that you're in the
07:06 - right place go see the app make sure
07:08 - that you're type in PWD which stands for
07:12 - print workking directory you want to see
07:14 - that you're in app and then type in make
07:16 - directory templates inside of the
07:19 - templates we'll create our index.html
07:21 - file and for now we can just put in an
07:23 - exclamation mark to generate an
07:25 - automatic HTML file and we'll just say
07:28 - hello so we can test that our app is
07:30 - running and rendering a page so we want
07:33 - to Define our first endpoint to do that
07:35 - we'll start the with The Decorator and
07:38 - we will call our first path index and
07:41 - the response class will be HTML response
07:44 - called the function index and you can
07:47 - take in a request which is going for the
07:49 - request fast API library and it will
07:52 - return the rended version of the index
07:54 - HTML file so we'll say return templates
07:58 - template response so template response
08:02 - and we want to name our file that we
08:04 - want rendered and we'll give it the
08:06 - request to be the request that was
08:08 - passed on to our main function here so
08:12 - you can see that it's showing me the S
08:13 - template template is not defined so we
08:15 - need to make sure our fast API app knows
08:19 - where to find this file so we will have
08:22 - to set this up set up for new templates
08:25 - so we will say that our templates is and
08:29 - then we will give it the directory file
08:30 - path and that will be templates so this
08:33 - now is looking for the template folder
08:36 - which we have just created so typ of
08:39 - there we need a colum so if we run this
08:42 - now we should be able to see our
08:44 - index.html file on a local host so if
08:47 - you go to your terminal and you make
08:50 - sure that you're in your app folder and
08:53 - you type in uvicorn main colon app
08:56 - reload it didn't save restarting and we
09:00 - can see that it's running if we go to
09:02 - the browser and we type in Local Host
09:05 - give it Port 8,000 and index we can see
09:09 - this is what our
09:11 - index.html file has so if I was to save
09:15 - this put all these exclamation marks
09:17 - refresh this you can see that it gets
09:18 - updated so this means our fast API web
09:20 - server is running so we will go back to
09:22 - our index.html file and start writing
09:25 - some front end code to create the basic
09:27 - structure of this web app so this is our
09:30 - translation service that will be the
09:32 - title we can delete this and I'm going
09:35 - to add a bootstrap Link in the head
09:38 - segment so you want to do the same just
09:41 - have this copy pasted other than looking
09:43 - at the video and having to type all of
09:45 - this in the link just go to my GitHub
09:47 - the link will be in description and on
09:49 - index HTML file you can just find this
09:51 - link this particular link and copy paste
09:53 - it and you should do the same for the
09:56 - style as well so we're not going to do
09:59 - to explain the basics of CSS in this
10:01 - video this video is more about API
10:03 - integration especially with the new
10:04 - services like the J gpts AP and uh and
10:07 - it's pretty self-explanatory if you just
10:09 - read through it you will immediately
10:11 - know what everything does here so we're
10:13 - just defining some of these aesthetic
10:14 - properties for our HTML elements that we
10:16 - will build right now so we will create
10:19 - some kind of a nav bar at the top these
10:22 - will be the properties and we can add
10:24 - some kind of a text we say with the
10:26 - class bar and the top of of it will be
10:31 - translation service this can be anything
10:34 - you want really so next we'll open a new
10:36 - container and inside of this div will
10:39 - open a form so this is where the
10:41 - important part in regards to the front
10:43 - end comes starting our form that we will
10:45 - submit to our fast API for translation
10:48 - so we'll give label here to be for text
10:52 - to translate so this later on we will
10:55 - write our JavaScript functions within
10:57 - this one index.html file file that will
11:00 - do all the front end processing towards
11:03 - the back end the fast API so that's in
11:06 - my opinion another positive aspect of
11:08 - this project that you will actually
11:09 - write some backend with python and still
11:12 - touch upon the front end aspects written
11:14 - in Java Script as well there's no need
11:16 - for D and we type in that this is the
11:19 - text to translate when this and will
11:22 - close the label this will be the text
11:24 - area and we will give it a class form
11:27 - control I will give it the ID that to
11:29 - translate you can have four rows and
11:32 - we'll give it this placeholder and close
11:34 - the so just make sure you close this
11:37 - text area tag after giving it the
11:39 - placeholder to be end the text here
11:41 - close the tag we move on we want to
11:43 - close this div or not the form yet just
11:46 - a div we can copy paste this and just
11:48 - slightly modify it to now include the
11:50 - input for the languages that the user
11:52 - wants the translation for so it's again
11:57 - form group oh I forgot to put that on
11:59 - the top top as well just a second we
12:00 - don't want to move on without including
12:02 - that so you want to go back Above This
12:06 - translation form and in here we will
12:10 - give the form ID that's a double one so
12:13 - just this line was missing we are
12:15 - opening a form group here so we're doing
12:18 - that again now to include the languages
12:19 - input and after you finish with the
12:22 - placeholder you can close the tag and
12:24 - close the div and underneath of this
12:27 - there will be a submit button so it's
12:29 - just a button type button but the
12:31 - important aspect now is to just identify
12:34 - this point that the on click for this
12:37 - button will be a JavaScript function
12:38 - that we will write pretty soon so
12:40 - that'll be at the bottom of our file
12:41 - here and this is our form so we can
12:44 - close the form here just make that
12:46 - consistent there so now we want to write
12:48 - the HTML element for displaying the
12:50 - translation results so we'll create some
12:52 - space here for
12:54 - readability so this particular div will
12:57 - be the HTML element that displays the
12:58 - result make sure that you have the ID in
13:02 - this particular syntax here so pre ID
13:05 - translation results this will be
13:07 - important for the event architecture
13:09 - make sure that div is closed and we're
13:11 - starting a new div so this will be the
13:14 - progress container so as we said earlier
13:16 - we want to make sure that the process of
13:18 - translation and display for the user is
13:21 - being transparent towards the user so in
13:24 - case they have a very long file that
13:26 - they want to translate they'll have to
13:28 - wait for it we want to make sure that
13:29 - the user is aware that that request has
13:31 - been accepted it's in progress so this
13:34 - particular div will be a display
13:36 - function for that and it will include
13:37 - some kind of a visual representation of
13:39 - the progress bar and now we want to
13:41 - include our search functionality but
13:43 - before that let's see how this or HTML
13:46 - file looks so if we go back to our
13:48 - browser and refresh this it looks a bit
13:53 - messy at the moment this will all fall
13:55 - into place as we build rest of the HTML
13:58 - elements but we can see that this is a
14:01 - part of the N Navar bar at the moment we
14:03 - didn't close the main div that we open
14:06 - so everything is being chucked into the
14:08 - single at the moment that will that'll
14:11 - be sorted in a minute but we can see
14:13 - that everything else is in place so
14:14 - we'll just continue with our work so now
14:16 - we want the search functionality so we
14:19 - will open a new div here and add the
14:21 - text of check translation by ID so we
14:24 - want to be able to query the database
14:26 - and then return the state so keep in
14:30 - mind in my opinion the only important
14:32 - thing to really take away from this is
14:34 - that inside of this particular input or
14:38 - the form will be interacting with our
14:41 - JavaScript so the onclick functions for
14:44 - our buttons are very important and this
14:47 - is why we write here on click equals and
14:49 - then these two particular functions that
14:51 - we'll write at the bottom of the page
14:52 - right now so make sure that div is
14:54 - closed and we'll open a new div and this
14:57 - will be the translation status so we
14:59 - want to display the actual text from the
15:02 - database that the translation is still
15:05 - in progress or if it's completed and
15:07 - then finally we want to display if user
15:09 - clicks this button so the second button
15:12 - which will call the function that
15:14 - queries the database for the content of
15:15 - the translation this will be the div
15:18 - that will display it so when it comes to
15:20 - our HTML elements that's it we just now
15:23 - need to write the functions the
15:24 - JavaScript functions and we have pretty
15:26 - much completed our front end so we will
15:28 - open a script tag here and this is where
15:30 - our JavaScript will go before that make
15:32 - sure you get the links for the bootstrap
15:35 - that we're using for this front end so
15:37 - once again it's important that you don't
15:39 - just try to type what you're about to
15:41 - see by looking this video rather go to
15:44 - my GitHub the first link you'll see in
15:46 - the description and locate this file you
15:49 - will see then at this particular line
15:51 - that will be this we can align that back
15:55 - so make sure that you copy paste this
15:57 - from the actual file right other than
15:59 - trying to write it but by all means if
16:01 - you feel like it you can just retype it
16:03 - from the video so now we want to start
16:04 - writing our JavaScript before we type
16:07 - some JavaScript let's see how does the
16:09 - updated front end look now so if we go
16:12 - back to our browser and we refresh this
16:14 - still looks like a mess so we want to go
16:16 - back and make sure we find where I made
16:18 - a mistake and fix it so going back to
16:21 - our code this was our CSS move on so as
16:26 - I said we haven't closed one of the
16:28 - elements so everything got bundled I
16:30 - briefly talked about it but forgot to
16:32 - type the text so we'll close the nav bar
16:35 - here and go back to our browser and see
16:39 - yep there we go so this is our front end
16:41 - finished now and as you can see inputs
16:44 - for the users are here the translate
16:46 - button is here and everything then will
16:47 - be displayed underneath the translate
16:49 - button so now we can write the logic in
16:53 - JavaScript that will take this data so
16:56 - if I want to translate this is what I
16:58 - want to translate and in here I type in
17:01 - engl so it's already in English German
17:04 - and French if I click the button I want
17:07 - the translation to appear here once it's
17:09 - done but keep in mind in case the text
17:12 - is long and we will test that version as
17:14 - well where we are trying to translate a
17:15 - huge amount of text and it will take
17:17 - time I don't want to just have nothing
17:20 - happening what I'm waiting we don't want
17:22 - the user having to click anything or
17:24 - refresh the page manually themselves so
17:27 - just to make sure if if you do search
17:30 - for axio JavaScript you'll be able to
17:31 - get more information about this and what
17:33 - it does but as you can see it's a
17:35 - promise based HTTP client so by using it
17:38 - we'll be able to do requests so we
17:41 - didn't have to install it in npm because
17:43 - we are we put this link in our script so
17:45 - we are able to use it through that
17:47 - through the link of the script so we'll
17:49 - go back to our codes and we'll finish
17:52 - off the front end officially with the
17:54 - JavaScript functions that we need so we
17:56 - will do a async function we'll call it
17:59 - submit translation and we'll give it
18:02 - text variable that will extract the
18:04 - user's text by using get element by ID
18:07 - and we will give it the ID text to
18:09 - translate. Value so this will grab this
18:13 - text so from this HTML element and it
18:15 - will store it in our text variable so we
18:19 - can copy paste this and we'll do the
18:21 - same to have our languages stored uh as
18:23 - an array in this variable called
18:25 - languages so the different ID will be
18:29 - languages like so and we want to format
18:31 - this to be an array of strings so in
18:35 - here you want to do do split and a map
18:37 - that will trim it so just have a look at
18:39 - this text and rewrite it yourself
18:41 - because this is just a simple logic to
18:43 - do some formatting to have a comma
18:45 - separated array of strings for our
18:48 - languages choice of the user I want to
18:51 - write some logic that will prevent the
18:53 - user from submitting an empty input we
18:55 - don't want to query the database or just
18:57 - to create this unnecessary Network
18:59 - traffic to chat GPT if the user is
19:01 - submitting an empty text empty array
19:04 - basically so we'll say if not text
19:07 - languages length be zero and languages
19:10 - to have to be empty and then we'll write
19:12 - just to return an alert in the browser
19:15 - that will say please provide both text
19:17 - and target language and we can just
19:20 - return so I want to implement the
19:22 - progress bar if the user has to wait for
19:24 - a significant amount of time it's just
19:25 - nice to have this more interactive
19:28 - experience in terms of the interface the
19:30 - user is working with so we will create
19:32 - this progress bar and keep in mind this
19:35 - is not just about the visual about
19:36 - implementing something new and nice to
19:39 - see visually we also need to write our
19:42 - own logic that will synchronize the
19:44 - progress bar with the actual backend
19:46 - process so this is where axios comes in
19:49 - so handy and we'll make sure that these
19:52 - events happen happen in the same time in
19:54 - real time for the user we'll create some
19:56 - space here and we'll will Define our
20:00 - progress bar and we will say that this
20:03 - is document can get it by ID the ID will
20:06 - be progress bar and we'll do the text on
20:10 - the progress bar be the same but here
20:12 - with the ID change it to progress text
20:14 - and we want to make sure that the
20:16 - progress bar can get restarted if the
20:18 - user gives a new request so we'll say
20:21 - progress bar plus list and remove if it
20:24 - was successful like so and we want to
20:27 - add this primary and this will be style
20:31 - would give it the style width style.
20:33 - width to be for the style of 0% and then
20:36 - we'll also have progress. text that we
20:39 - want displayed and it will be text cont
20:41 - content soorry this doesn't have a DOT
20:43 - so delete that so progress progress text
20:46 - content and this will say that the
20:49 - translation is in progress so now we'll
20:51 - write the xos function that will execute
20:54 - the post request with the payload so we
20:57 - will say try this will be con response
21:01 - and it will await post and here will be
21:03 - the link of our endpoint which we will
21:06 - we still haven't built that so this will
21:07 - be what we'll do on our fast API file so
21:10 - we will call this Endo uh translate so
21:14 - after giving the endpoint open the C
21:16 - braces so we can give it the payload and
21:19 - we will say that the text is the
21:20 - variable text and the languages are the
21:23 - variable languages so oh this is not
21:26 - capital I don't know why I did that and
21:28 - we will close this so I made a typo here
21:30 - you need to go back to where I provided
21:32 - the endpoint link and delete these
21:34 - parentheses here so that we can close
21:36 - them here hope you can see my cursor
21:39 - make sure you close them here all right
21:41 - moving on now we'll Define the task ID
21:43 - to be to go into the response object and
21:47 - get the parameter of task ID and we'll
21:50 - give it the alert that will say that the
21:52 - task ID is and give it dollar sizing
21:57 - it's the task ID so the reason why we
22:00 - have this here keep in mind we said
22:03 - it'll be important for the user to
22:04 - receive a confirmation that the request
22:07 - that they've sent we have received it
22:09 - and we are processing it this is to
22:11 - cover the case where the input is large
22:13 - and it will take time to translate all
22:15 - of this and return it back to the user
22:17 - so we want to instantiate some objects
22:20 - here so we'll change the display so this
22:22 - will be the part that dynamically
22:24 - changes the display so initially in this
22:27 - process at this stage we want to set all
22:29 - of this to none so feel free to either
22:31 - pause and rewrite this from the video or
22:34 - go to my GitHub and copy paste this
22:36 - particular bit and then from here we'll
22:38 - say that translation result is null and
22:41 - the progress is zero and we will say
22:43 - whil progress is zero is less than 100
22:47 - sorry and we'll write some logic saying
22:49 - await a new promise which will resolve
22:53 - through the timeout and we'll set time
22:55 - out at a th000 so by the way these are
22:57 - millisecond so this is 1 second so 1,000
23:01 - milliseconds so with this polling
23:03 - technology we want to make sure that
23:04 - this is constantly awaiting the the
23:07 - response from the back end and it will
23:09 - check for that every second and then we
23:12 - will say that constant result response
23:15 - will be the get request and again we'll
23:18 - give it the Local Host the end point of
23:21 - translate and use this syntax to make
23:24 - sure that it gets the exact ID of the
23:27 - entry oh May the typo here so this needs
23:30 - access so we want to declare that our
23:32 - translation result then is the result
23:35 - response of data and writing translation
23:38 - result status then being changed to
23:41 - completed this will also mean that our
23:44 - progress has reached 100 AKA 100% or
23:48 - else we'll give this the interval of 50%
23:50 - so our Progress power will do increments
23:53 - or either zero meaning nothing has
23:56 - started yet if something is in progress
23:59 - it'll be at 50% and then the third state
24:02 - will be a complete state which is
24:05 - 100% so we say that the width of the
24:07 - progress bar in this case would be 50%
24:12 - so now I just wanted to add some extra
24:14 - visual components to it so we want to
24:17 - change the color to green and text
24:18 - according to the events that
24:20 - happen so we'll Target progress bar and
24:24 - once it's successful we can dynamically
24:27 - update the text by saying translation
24:29 - complete oh you want to write another
24:32 - document get element by ID this one will
24:34 - Target translation results and we want
24:36 - to stringify the the the data there and
24:39 - we will do another document get element
24:41 - by ID this one will Target the results
24:45 - and we want to make sure that this
24:46 - display now is set at block and we can
24:49 - close the curly braces and write hatch
24:52 - error statement and we can display this
24:55 - in our console so this is just for
24:57 - debugging in case something goes wrong
24:59 - error submitting translation and we want
25:02 - to see that error so we can display it
25:04 - there and we'll also give an alert in
25:06 - the actual browser and we'll say an
25:08 - error but while translating let's try
25:11 - again C braces are closed and now we'll
25:15 - we'll use another two functions so we
25:17 - want to add search functionality
25:20 - component and with this we can do this
25:22 - later so we don't want to forget that
25:25 - but we will have two functions so I'm
25:27 - just going to open the structure for it
25:28 - and we'll return to
25:30 - this so this will be our check
25:33 - translation Styles and for now we'll
25:36 - give it is there a pass just something
25:38 - that won't cause an error and there will
25:40 - be another one that checks for Content
25:42 - so it'll be check translation content so
25:46 - we will return to this data so I believe
25:49 - that should be it so all of our front
25:51 - end is completed other than the last two
25:53 - functions where we want to add the
25:55 - search functionality and we can deal
25:57 - with that practically at the end so once
25:58 - we actually have everything up and
26:00 - running we'll add this ability to go
26:02 - through our database and historically
26:03 - retrieve any of the completed or not
26:07 - completed translations so with that
26:09 - being said we'll move on to our back end
26:11 - so this is where we left off we defined
26:13 - the endpoint that through a get request
26:15 - renders an index.html page so the first
26:18 - thing that we will do is set up our
26:21 - database so you want to create these
26:24 - files now you want to do database. py
26:27 - you want to do models py create crud py
26:31 - and create schemas py now a good point
26:35 - to discuss how does this process
26:37 - actually work with the front end
26:39 - communicating with backend and what are
26:41 - the roles of these individual files here
26:45 - so if we go back to to do some drawing
26:48 - we'll go down here so I'm going to
26:51 - create some some boxes here and we're
26:55 - going to say this is our front end this
26:57 - will be our our database and this will
27:00 - be our fast API service so this is our
27:03 - back end so as you saw there is a
27:06 - particular input that the user will give
27:09 - us in the front end so this is the input
27:13 - just for the sake of this wonderful
27:15 - diagram I'm going to call I'm going to
27:17 - refer to this as a payload so instead of
27:20 - I is going to be P which stands for
27:22 - payload we already know that this
27:24 - payload will be text and language
27:28 - so text that they wish to be translated
27:31 - into these languages so this will be our
27:34 - payload we'll send this as a Json we
27:38 - have this HTML that allows the user to
27:41 - input this text to create this payload
27:43 - and then with the axio code that we
27:46 - written to execute a post request this
27:48 - post request will go to our fast API
27:52 - endpoint so more specifically that's the
27:55 - translate endpoint then we want our fast
27:58 - API service to First make sure that it
28:01 - knows what to do with this data and that
28:03 - it also can receive this data so this is
28:06 - why we created this schemas py so what
28:10 - we're going to do in the schemas py is
28:13 - to make sure that the data is validated
28:15 - so that it lands on our fast API service
28:18 - in a format that we can work with it as
28:21 - you saw we want to implement this search
28:24 - functionality by using idid so we will
28:27 - then write some logic that will take the
28:29 - payload from this point and store it
28:33 - into our database so I'm just going to
28:35 - mark that this payload has initially
28:37 - been given to the front end with a post
28:40 - request this payload now has reached the
28:44 - back end and then the back end gives it
28:47 - to a database so it can receive a unique
28:51 - ID so now this payload here will have
28:54 - some kind of an ID so let's just give it
28:56 - a random numeric value let's say this is
28:58 - now number four P4 so payload with an ID
29:02 - 4 we will have some further logic that
29:04 - will send the payload to chat
29:08 - GPT so this will be our external API
29:12 - here so we will say open API for
29:16 - translation so our fast API service will
29:19 - will need some logic that does that once
29:21 - that is returned we will have our fast
29:24 - API stored in a database so this flow
29:28 - now has another line we can say that
29:31 - once it reaches that place it needs to
29:34 - go into the
29:35 - database so initially this part was just
29:39 - storing the payload and giving it so it
29:42 - was ID and payload which was text and
29:46 - languages but on the second entry as you
29:49 - can see this blue line this becomes the
29:52 - translated payload and it will just be
29:55 - the text and then once this event has
29:58 - been confirmed there has to be some
30:00 - logic that will inform the front end of
30:04 - data that you originally sent to me as a
30:07 - payload well I've done what you asked of
30:09 - me and it's ready for you to use and
30:11 - then in that case the back end will
30:14 - deliver the payload payload with the ID
30:18 - and with the translation of the text so
30:22 - I'm just going to put TT translated text
30:25 - so then all of this can be displayed on
30:28 - our front end so this ugly looking
30:31 - diagram is an explanation of this event
30:36 - architecture so first things first
30:38 - something that I like to get out of the
30:39 - way and it's pretty much the standard
30:41 - for me in the development process keep
30:44 - in mind for deployment this requires a
30:47 - little bit more talk based on specific
30:50 - circumstances of how you want to deploy
30:51 - your project but for now for this
30:53 - project we want to make sure that once
30:55 - we do run it locally if we want to
30:58 - thinker around with certain things I
30:59 - don't want errors to come up so I'm
31:01 - going to make course not a problem
31:03 - immediately by adding this middleware so
31:05 - we imported that in the beginning of the
31:07 - tutorial and we're going to use it like
31:09 - this not the most important aspect of
31:12 - this video so we will move on so
31:15 - remember I want to have my endpoints for
31:18 - handling data so we'll say app. post and
31:24 - this is our main translate end point
31:28 - and we'll give it a response class oh
31:31 - sorry response model and we will have a
31:33 - schema for this so this will be the
31:36 - moment where we write our validations
31:38 - with pantic so stop this for a second
31:41 - and open your schemas piy file and in
31:44 - here you want to import pantic space
31:47 - model and you want to get from typing
31:50 - list and dictionary and we will have
31:54 - three classes one will be translation
31:57 - request test and it will inherit from
32:00 - base model and this will be the string
32:03 - of the text that the user has given us
32:06 - for translation and then the list of
32:08 - languages this will be a list of strings
32:10 - next is the task response this will also
32:13 - inherit from no base base model not base
32:16 - exception and this will be the ID that
32:19 - we are returning to the front end as
32:21 - soon as the request has been made lastly
32:24 - we have translation Styles and this will
32:27 - also get base model I'll have task ID
32:31 - integer status string and translations
32:34 - should be dictionary of strings so these
32:36 - are our schemas and the purpose of them
32:38 - will be to valid the data to make sure
32:40 - that the data before getting processed
32:42 - before we assign it all sorts of work to
32:43 - do is in the format of how we want it to
32:46 - be so you can close your schemas pii
32:49 - that's all we're going to do with that
32:50 - I'm we think before we deal with the
32:52 - rest of the schema implementation you
32:54 - also want to create a file here called
32:57 - init oh in case then you want to have a
32:59 - different way of importing for example
33:02 - instead of saying here import schemas
33:03 - we'll be able to import from schemas and
33:06 - then give it the exact names of the
33:09 - requests so in order for that to work
33:11 - you would need this init file but even
33:13 - if you leave it just with import schemas
33:16 - all of the schemas would work that's up
33:19 - to you now for your
33:20 - preference so we want to make sure that
33:23 - the incoming data which is a part of our
33:25 - request variable here so that's our p Lo
33:28 - is validated by by our translation
33:30 - request
33:31 - schema and then what we returning is
33:35 - Task response schemas so if I open a
33:38 - second tab here just for you to have a
33:40 - quick look the incoming payload is going
33:44 - according to the request so the input
33:47 - from the user which is text and the
33:48 - languages they want translation in and
33:51 - the task response will just be the ID so
33:54 - all that will send back to the user is
33:56 - the ID keep keep in mind this goes along
33:59 - with what we decided to do that once the
34:01 - user has clicked translate this for me
34:04 - what they will receive immediately is a
34:05 - 20000 or this is your process it has an
34:08 - ID and once it's actually processed and
34:11 - the bar reaches 100% you will get a
34:13 - translation so that's the reason why we
34:15 - have this schema order so after we have
34:18 - defined the schemas we can move this we
34:20 - want to start modifying how the database
34:23 - will be set up and how this CR system
34:25 - operations will be done so the pseudo
34:28 - code for it would look like something
34:30 - like defining that within our task we
34:32 - will have a crud file that will hold all
34:34 - of our operations all of our methods for
34:37 - doing create read update delete
34:40 - operations and we will call this
34:42 - function we can call it create
34:44 - translation task so we don't have this
34:46 - yet but we will create it in a second
34:49 - and this function will have certain
34:50 - parameters so we can have two parameters
34:54 - three parameters because it will also
34:56 - have the languages XY z p then we will
34:59 - add it to the background tasks and this
35:02 - is something that I believe is
35:04 - fundamentally important to understand in
35:06 - order to proceed so we will go to the
35:08 - browser and read something about the
35:10 - documentation so I just want to make
35:12 - sure that you know where to look for to
35:14 - understand this particular technology so
35:16 - if you go on Google and type in fast API
35:20 - documentation and in the search bar you
35:22 - want to look for background tasks so
35:24 - this is where you'll be able to find all
35:25 - the documentation related to this
35:26 - particular concept
35:28 - can use it to schedule the execution of
35:30 - background tasks after the response is
35:32 - sent and you can pretty much see where
35:33 - where I'm going with this so I want to
35:35 - be able to have my web app process these
35:40 - asynchronous tasks so by all means if
35:42 - you need any further familiarization
35:44 - open this particular document and you
35:45 - can find all the details you need there
35:47 - in the meantime now we'll go back to our
35:49 - code so we want to now add once we are
35:52 - creating the translation so this is our
35:55 - create translation function which we
35:57 - still have not created will create it
35:58 - now we are going to add to the
36:00 - background tasks task we'll do perform
36:04 - translation askask ID and the request
36:08 - variables so request text and request
36:12 - languages and we'll pass the B again and
36:15 - we will return as we said the return
36:18 - schema as we said for what we decided to
36:21 - return to the user would just be the ID
36:24 - so now to create we don't need this so
36:27 - so now to create these methods so we
36:31 - want to go in our Crow file and create
36:33 - this method for creating translation
36:35 - task and then we're going to deal with
36:36 - our perform translation method for our
36:39 - background tasks so we can copy this and
36:42 - we'll go into our crowd file and from
36:45 - here you want to import Q Alchemy M at
36:48 - the session and we will import models
36:50 - because this is how we will fill out our
36:52 - tables but we'll build the database
36:54 - after this first let's define this
36:55 - method so you can copy paste the name
36:59 - and this will be this will have a
37:01 - connection to our database and it will
37:03 - take as we said it it three parameters
37:05 - database and then the payloads
37:08 - components so this will be languages
37:11 - which is a list and we want to say the
37:14 - task is a models translation task and
37:18 - languages are languages so after that we
37:22 - want to go into our DB session and use
37:26 - it to this to the base every time you do
37:29 - that you need to do commit and refresh
37:32 - so this is how SQL Alchemy this
37:34 - particular RM handles this this will be
37:37 - always a part of any CR operation but
37:40 - I'm going to pass the task here and say
37:43 - return task then the second method we
37:47 - want is the method that will fetch the
37:49 - translation task it will also able to go
37:52 - into the database and work with the ID
37:54 - that's an integer and it will just
37:56 - return the qu
37:58 - according to the ID that we pass it so
38:00 - it will go translation task and you want
38:03 - to pass this so models translation task
38:07 - ID so find the models that has the ID
38:11 - same as the ID that we passed in this
38:13 - parameter and return the first TCH and
38:16 - then the last thing we want in our croud
38:18 - operations methods will be to update the
38:20 - translation task so once again this part
38:24 - will be the same so I can copy paste
38:26 - this from above but this now Returns the
38:28 - translations as well so if you remember
38:31 - when we actually had our diagram I'm
38:33 - going to pull it up so you can see
38:34 - exactly where and this method where they
38:37 - appear on our diagram so take it in
38:41 - mental memory for now this is Method
38:43 - number one and this is Method number two
38:45 - so if you remember our not so
38:47 - good-looking diagram here we were
38:49 - talking about the backend processing
38:51 - this particular payload so the method
38:54 - number one is the payload that has the
38:57 - text and the languages as a parameter so
38:59 - they will still share the same ID the
39:01 - red text here and the blue text here
39:03 - representing two different aspects that
39:05 - work within the same table so this is
39:08 - all one table but on two different
39:10 - instances we are doing a either create
39:13 - or update request to it so in the red
39:17 - one which corresponds to our when I said
39:19 - red I'm referring to this line here it
39:22 - corresponds with our first method here
39:24 - create translation task and this line
39:27 - and so this particular secets of event
39:30 - here is just updating the translation so
39:33 - adding the translation so that's the
39:35 - update and it needs the ID parameter to
39:38 - know where to add that translation to
39:40 - because it's returning after so these
39:41 - are two separate events that are
39:43 - operating in the same table so as you
39:45 - can see we need to pass task ID so that
39:49 - it knows how to find the table where it
39:51 - will check in is the translation of this
39:54 - text here from the first function and in
39:56 - the Lang ages of the first function so I
39:59 - hope that's clear and that's quite
40:00 - important to understand for this
40:02 - particular type of system so we'll say
40:05 - that the task it can go and find
40:08 - according to the ID so it will filter
40:11 - models and it will be the same way of
40:13 - quering like the one above and then we
40:16 - want to say to translations and the
40:19 - status now changes to complet it and
40:21 - again after every CR operation you want
40:24 - to do commit and refresh and return task
40:27 - that's that's it for our crowd
40:27 - operations we won't have to open this
40:29 - anymore I believe now we want to create
40:31 - our database so we're going to talk
40:33 - about how to set up this database and
40:35 - create our table so first you want to go
40:37 - into your database. py then here you
40:40 - want to import OS you want to import
40:42 - create engine from SQL Alchemy session
40:44 - maker and in order to keep our varibles
40:47 - safe the ones that contain sensitive
40:49 - data that's important here you want to
40:52 - import EnV load. EnV so we will load
40:57 - this. EnV and what this means so what
41:01 - that means you want to go in the main
41:03 - directory so if you go print working
41:05 - directory inside here so you want to
41:08 - make sure you are in your main working
41:10 - directory so outside of the main app
41:12 - folder and we will do touch. EnV and in
41:16 - this file we will have our database URL
41:20 - and we will have our open AI key so for
41:23 - now you can leave this empty but this
41:25 - will this will be the file that we hold
41:27 - your sensitive information and then
41:29 - we're going to load this file with our
41:32 - dependency here EnV so that will allow
41:34 - us to say OS using the input OS Library
41:38 - get EnV and then particular variable
41:41 - called database URL which is which you
41:43 - can see corresponds with this here so
41:46 - this is the way you keep it safe then
41:48 - below that you want to say that the
41:49 - engine is create engine and we will pass
41:52 - the parameter of the previously defined
41:55 - connection string sensitive information
41:57 - that we stored in ourv file so it travel
41:59 - all the way through this in such Manner
42:02 - and lastly we want to add the session
42:04 - maker I'm not sure does this have to be
42:06 - here but for now let it remain I doubt
42:08 - that it can hurt so that's all we need
42:10 - for our database. py we'll move on to
42:13 - our models.py where we will be defining
42:15 - our table so you want to import these
42:18 - from SQL Alchemy so column integer
42:20 - string text and Json those will help us
42:22 - create different types of data types in
42:24 - our database and then after that you
42:26 - want to get
42:27 - Clarity base from this particular
42:30 - dependency also SQL Alchemy so here we
42:33 - will call Base Clarity base and now we
42:36 - will create our table so we'll say that
42:38 - the translation task creates a table
42:42 - called translation tasks and now we will
42:45 - actually Define all the the rows so
42:48 - we'll say that the ID is a column which
42:51 - will be an integer and a primary key
42:54 - true and we'll have text which is type
42:57 - text nullable false so it can't be empty
43:01 - and we'll do that for languages but
43:04 - languages will are a list so that will
43:06 - be adjacent here and there will be
43:09 - status which is a column string and the
43:11 - default is in progress so if you
43:15 - remember we only had to in our CR file
43:17 - we only had to have an alternative of
43:20 - can be change to completed now because
43:22 - here we can set the default to be in
43:24 - progress and then we are adding the
43:26 - translations finally
43:27 - that's a Json and the default is just an
43:30 - empty Json and that's our models py I
43:33 - don't think we will need to go back to
43:34 - this but I'll still leave this open
43:36 - because I might have to talk about it a
43:39 - bit later so now we can go to our
43:41 - main.py and write a cleaner version of
43:44 - this so you want to go to the top and
43:47 - import the CR file and now this function
43:51 - actually exists we just created it so we
43:53 - can pass the genuine parameters so this
43:56 - will be the database this will be the
43:58 - the text parameter of the request and
44:01 - this will be the languages parameter of
44:02 - the request so the only thing missing
44:05 - Within These parameters is our DB so you
44:07 - will go here above the course and we
44:10 - will Define this function actually we
44:12 - can Define this in our database file so
44:15 - we can say ITB I'm sure you can copy
44:17 - paste this just from the fast API
44:19 - documentation but I have it here in
44:22 - front of me as well and we can say try
44:24 - yield this DB so this now turns into a
44:27 - generator TB close and then we will
44:30 - import this so if we go back to main py
44:34 - we can say from database import now we
44:38 - should be able to use this if we say DB
44:41 - so now moving on to our background tasks
44:44 - so for this we'll have to write some
44:45 - utility functions so these are the
44:47 - functions that we want to give to our
44:49 - background tasks process to handle
44:51 - asynchronously oh we want to make sure
44:53 - that this is called the same is get DB
44:56 - so we want to create a new file here
44:58 - we'll call it utils.py and what we're
45:01 - going to do now is create this function
45:03 - that will perform the translation but
45:05 - before that there is one thing that I
45:06 - forgot we want to make sure that a
45:08 - database is created so if you go here
45:11 - above app you want to paste this part so
45:13 - you want to say models. base metadata
45:15 - create all and then bind the engine and
45:18 - we will import models and also from
45:20 - database we want to import the engine so
45:23 - now once we start the main file each
45:26 - time my fast API loads up the server it
45:29 - will make sure that a certain B database
45:32 - exists and that a table that's defined
45:36 - in our models
45:37 - exists if it doesn't it's going to
45:39 - create it so next thing we'll do is
45:42 - create our database in PG admin 4 I'm
45:45 - not going to insult your intelligence by
45:47 - showing you how to download PG and admin
45:48 - 4 from internet just Google it download
45:52 - it configure it you will get a username
45:54 - and a password once you configure it and
45:57 - then you will see in your server cluster
46:00 - you can create a database by clicking
46:02 - right click on databases create database
46:04 - and give it a name so I'm going to give
46:06 - it the name translation service you'll
46:09 - just click save and that's it you have
46:11 - your database if you go under schemas
46:14 - and tables if you click refresh here
46:16 - you'll see that there are no tables
46:18 - which is good we will create that from
46:21 - Python and this is the beauty of using
46:23 - an orm which is SQL Alchemy in this case
46:26 - so so what we have to do is Define it
46:28 - here and uh this particular table name
46:32 - with this name will be created once we
46:33 - load our
46:35 - server so in order now to connect your
46:37 - database to this particular project you
46:40 - want to go in your EnV and your username
46:43 - and password will go here this is the
46:46 - address and this is the name of the
46:48 - database so once again here you're
46:51 - defining what SQL here you are giving
46:54 - the username this is the password
46:57 - this is the address and obviously we're
46:59 - working locally so this is Local Host if
47:01 - you're deploying this project these are
47:02 - be these will be credentials of your
47:04 - actual provider and then the translation
47:07 - service is the database so this is the
47:09 - database name over there so this is
47:12 - pretty self-explanatory I have no doubts
47:15 - that you can configure this successfully
47:18 - once you have done that you will go back
47:20 - to your vs code we can delete this and
47:25 - now we are ready to launch our server
47:27 - and this should automatically create our
47:29 - table as well so if you go in the main
47:31 - folder and run this line one think
47:34 - before I move on we need to also make
47:37 - sure that we installed this so I've
47:39 - added I've added it in our
47:41 - requirements.txt but if you need to
47:43 - individually install it do pip install
47:46 - this particular Library the last one
47:48 - here so after You' done that you go your
47:50 - terminal working directory and you run
47:53 - your recall main app reload so
47:56 - everything is running and now if you go
47:57 - back to your PG admin 4 and refresh the
48:01 - tables you will see that the translation
48:03 - tasks table has appeared so now we know
48:05 - that our database is connected our
48:08 - server is running and we can finish the
48:10 - back end by writing the utility
48:13 - functions so just to remind you of where
48:15 - we are if you go into your main.py
48:18 - you'll remember that when we were
48:19 - writing our endpoint we Define this
48:21 - background tasks process and the task
48:24 - that we added was supposed to be a
48:26 - function called perform translation so
48:28 - now we're going to actually write that
48:29 - function that method in our utility. py
48:32 - so here you want to import open AI from
48:35 - SQL Alchemy RM you want to import
48:38 - session to be able to connect to the
48:39 - database from our croud file you want to
48:41 - import the updat ration task and from
48:44 - our environment you want to import load
48:47 - function and also OS here we will pass
48:51 - the API key for open AI we'll use OS to
48:56 - fetch the environment and we will say
48:58 - that this variable is called open AI API
49:01 - key to make sure this is connected you
49:03 - have to go in your EnV file and you have
49:05 - to put in a API key in a variable called
49:09 - open API key like
49:11 - such I'm going to do that off screen so
49:15 - you just copy paste your open API key
49:17 - here or any other llm you want to use
49:20 - but I'll be using open API so once you
49:22 - do that you click save and we move on so
49:25 - when you finish setting up your
49:26 - environment for sensitive data we can
49:28 - write our
49:29 - function so we'll say that perform
49:33 - translation exp parameter of task ID so
49:36 - the integer and the text is string and
49:39 - languages will be a list and we also
49:41 - want to get DB session we will say that
49:44 - translations are an empty dictionary and
49:48 - write a for Loops saying for each
49:50 - element in the languages list by giving
49:52 - in the response open AI chat completion
49:56 - and create model will be gp4 and the
50:00 - messages will be a list an F string that
50:04 - says this or a helpful assistant that
50:06 - translates text into and then the
50:09 - language of each language that'll work
50:11 - and underneath that we'll do roll user
50:14 - content and then the text we give a coma
50:17 - here and we'll say that the max tokens
50:19 - are a th000 but you can adjust this
50:21 - based on your own needs so then we will
50:24 - get the translated text and we will give
50:26 - it in the respond so that's a zero and
50:29 - here we'll write some formatting because
50:32 - we're dealing with a list and we'll give
50:34 - our translations then of each language
50:37 - to be translated text and we're going to
50:40 - we want to do some debugging as well oh
50:42 - in the meantime I forgot you want to go
50:44 - above and load the environment variable
50:46 - and here I made a typo so this is Max
50:48 - tokens like such and now we will write
50:52 - this exception so our exception will
50:55 - print that if there was an error we will
50:57 - get the error back so we can see and we
50:59 - can play around with this if we end up
51:01 - actually having some errors but for now
51:03 - just leave it as such and now we want to
51:06 - call this function the update
51:08 - translation task so if you click on the
51:10 - update translation task and click F12 it
51:12 - will take you back to your Crow file so
51:14 - you can remind yourself of what this
51:16 - actually does so we have already written
51:17 - this function we are just invoking it
51:19 - here now to perform that task so we will
51:21 - say update translation task it will have
51:24 - a parameter of DB to connect to the
51:26 - database and then update the database by
51:29 - finding the particular ID and inserting
51:32 - the translations into the table so we
51:35 - save this and we just now need to finish
51:38 - our end points and that'll be the end of
51:40 - our back end so I'm just going to clean
51:42 - this up a little bit we'll take the core
51:45 - stuff and just put it above our end
51:48 - points so I forgot to pass the
51:49 - background tasks as a parameter so in
51:53 - our translate function here we want to
51:56 - add the background tasks so I've
51:59 - inserted here between the schemas and
52:01 - the DB session so add the to be
52:04 - background tasks with the capital B and
52:06 - then we want to add the connection to
52:07 - the database so we will say that
52:10 - variable DB is session depends get DB
52:13 - and then we don't need this get DB
52:16 - variable so in this line 43 delete get
52:19 - DB and do the same for this line 42 in
52:23 - task first thing after parenthesis
52:25 - delete this as well and now we need to
52:27 - import session so if you go on top and
52:30 - we do from SQL Alchemy import session
52:33 - and that's sqlalchemy.orm import session
52:37 - so we will now write the utility
52:39 - functions for our search functionality
52:42 - and this will be fairly similar so it
52:46 - will be a get request so I copied the
52:49 - previous endpoint I'm just going to
52:50 - modify it so this one will go this get
52:53 - request will have a task I the parameter
52:57 - and the schema is not going to be task
52:59 - response delete that and put translation
53:01 - status delete all of these parameters
53:04 - other than DB and here we will pass in
53:08 - task ID to be an integer and then just
53:11 - have the connection with the database
53:13 - here in the task we'll go into our Crow
53:16 - file and we will get I feel like there's
53:18 - a typo here but we can still get the
53:20 - exact
53:21 - text so get the Translating task DB task
53:25 - ID this line of code we can delete and
53:28 - underneath the task we'll say if nothing
53:32 - returns in task or or better said if
53:34 - task returns empty so if task is null we
53:37 - want to raise an exception so we'll put
53:39 - in HTTP exception and we'll give it the
53:42 - status code of 404 with the detail of
53:44 - task not found but if task is not null
53:49 - then we want to return task ID and the
53:51 - status which is the task. status so it
53:54 - will access that parameter and return
53:56 - entry from the database and the
53:58 - translation will be the variable
54:00 - translation so again we'll access the
54:03 - task translations and then we want to do
54:06 - practically the same thing but for
54:07 - Content so this particular endpoint will
54:10 - correspond to let me show you exactly
54:12 - what so it will correspond exactly to
54:15 - check status button and then now we're
54:17 - going to write a function that will be
54:19 - an endpoint that gets executed once we
54:21 - click check content so we can copy this
54:24 - and we'll slightly modify we can change
54:27 - the endpoint address so we'll say that
54:29 - this is Content slask ID and I forgot
54:32 - one thing we want to change the name so
54:33 - it go back to the previous function for
54:35 - me that's line 60 and here we will just
54:37 - say get translate because they have to
54:40 - be called differently the first one is
54:42 - called translate the second one then
54:44 - should be called get translate and the
54:47 - third one can be called get
54:49 - translate content something like that as
54:52 - long as they have unique names it's fine
54:55 - and this will remain all the same the
54:57 - task line will also remain the same and
55:00 - this will remain same as well but when
55:02 - we return we do not need to return the
55:05 - ID we just want to return the task Al
55:08 - together and that should be it so I
55:11 - believe this is all we need for our back
55:12 - end to work but now we can go and try
55:14 - running this so if we save and give it
55:17 - the first test so we put some text here
55:20 - we will say hello there how are you and
55:24 - we will say that we want to translate
55:26 - this to to French German and Italian and
55:29 - we will click translate and we get error
55:31 - please provide both text and target
55:33 - language so this means there is some
55:35 - kind of a problem with the logic that's
55:37 - supposed to confirm that there actually
55:39 - is content here so to troubleshoot this
55:42 - I'm going to start from the beginning I
55:43 - need to check what's wrong with this
55:45 - button is this button actually picking
55:47 - up extracting the data from here so
55:50 - let's try opening the developer
55:52 - resources we'll go into console in the
55:54 - console I want to be able to see so if I
55:56 - do a console log of something I want to
55:58 - be able to see a particular result let
56:00 - me see can I zoom in on this make it a
56:03 - bit
56:03 - larger that should work for now at least
56:06 - hello pasting that's too much of text so
56:10 - we want to we'll say that constant text
56:13 - and we want to get element by D this
56:15 - particular text so now if I do console
56:18 - log text and I can see that it does
56:21 - extract the text from here so that's not
56:24 - an issue and if I do constant languages
56:28 - and the ID for this are languages and I
56:31 - do value and we put in languages here I
56:35 - get this so that's not an issue next I
56:38 - want to make sure that this button
56:40 - actually does what it's supposed to so
56:42 - what I'm going to try to do is go to my
56:45 - HTML file and find the code for the
56:48 - button so if we go into our app and
56:51 - we'll open templates HTML and we want to
56:54 - find a line that is the button for
56:57 - submit so in our line 46 on click is
57:01 - submit translation if I do an F12 on
57:04 - this it takes me to my function this is
57:07 - the code that we tested so we know that
57:09 - code worked so the console loging that
57:12 - we just did in the console and I think I
57:14 - can see a typo here so after this we
57:17 - need these
57:19 - two so I believe I just om missed these
57:22 - particular bit of characters so I've
57:24 - saved that we are rerunning our server
57:26 - and let's try it again and then I
57:29 - realized I made a silly typo with
57:31 - response. openai it should be response
57:33 - equals I'll go to network and I want to
57:36 - see what happens when I try to make this
57:39 - request and I can see nothing happens so
57:42 - the get requests here are fine but if I
57:44 - do hello to German and I want to do this
57:47 - nothing happens so my first idea how to
57:51 - troubleshoot this I just want to make
57:52 - sure that all of the back end now works
57:55 - properly so so I'm going to use Postman
57:57 - to just quickly test the back end so if
58:00 - you go into Postman and you provide the
58:03 - endpoint address so that's our 8,000
58:05 - ports SL translate and we give it this
58:08 - particular payload and we click Send we
58:11 - get 422 unprocessable entity so there is
58:14 - an error with our back end so we just
58:16 - catching some errors I realized that I
58:18 - forgot to pass the variable for the API
58:21 - key so if you go into your U tools. py
58:24 - underneath this we want to make sure
58:25 - that that we have given the API key
58:28 - properly so make sure this particular
58:30 - line the line number 10 is present also
58:33 - I made an error here so indentation
58:35 - error this function should be outside of
58:38 - this particular except so it is outside
58:42 - of this for Loop so make sure you align
58:44 - it with the for Loop all right we'll
58:47 - continue troubleshooting we'll make sure
58:49 - that languages is written properly so I
58:52 - misspelled it here it's written
58:55 - atrociously so make sure you fix that
58:58 - too if you go back to the models.py and
59:02 - instead of the forw written languages
59:04 - here make sure that this is written
59:05 - correctly so now in order to update this
59:08 - unfortunately uh this orm SQL Alchemy
59:11 - cannot do migrations dynamically like
59:13 - this so we will have to go to our
59:14 - postest database in PG admin 4 and
59:17 - manually delete the tables and restart
59:20 - everything so we will go to translation
59:22 - tasks delete click okay now when we go
59:25 - back to to our server and click save it
59:28 - should create a new one so if we refresh
59:32 - we see translation tasks and I want to
59:34 - open it to make sure that in my columns
59:37 - the languages is written correctly now
59:39 - and as you can see it is so to double
59:42 - check triple check actually from schemas
59:45 - to the main py we want to make sure that
59:47 - every time we have languages it's
59:49 - written correctly there are no typos or
59:51 - nothing like that and after that I need
59:54 - to check how did I write the names of
59:56 - the methods in case I'm misspelled when
60:00 - re-referencing them in other places so
60:02 - I'm going to open main.py and utils and
60:06 - crud next to each other and then we'll
60:08 - make sure that all of them are named the
60:10 - way they should be so in our utils this
60:13 - is perform translation that's fine but
60:16 - then in our main.py we want to make sure
60:19 - that in our first function that we are
60:21 - calling create translation task and if
60:24 - we click on it and press F12 it will
60:26 - lead us to a crow operation so that's
60:28 - fine in our Second Use method this is
60:32 - supposed to lead to the second quad
60:34 - operation and that's fine as well so you
60:37 - want to make sure that these are aligned
60:40 - and the third one should lead to again
60:44 - the second Crow operation as well so if
60:47 - that's all correct let's try running the
60:48 - server and see are there any further vxs
60:51 - that we need to fix so we are running
60:53 - the fast API server again so
60:56 - it looks like it is online let's check
60:59 - what happens when we try to send a
61:01 - request so I've tried sending this and
61:04 - we got an error which says that there
61:08 - was an error translating to French and
61:10 - German so this means that we did get
61:14 - payload delivered to our fast API web
61:16 - service but the followup with our
61:20 - background tasks did not manage to get a
61:23 - return from our translation service so
61:26 - now now we know where to go and
61:27 - troubleshoot how silly of me I forgot
61:30 - that we left two functions untouched and
61:32 - we need to finish that my plan was to do
61:34 - it at the end but I did end up
61:36 - forgetting to do them all together so
61:38 - let's go back to our front end and make
61:39 - sure that we have those functions
61:41 - written so if we open our
61:43 - index.html so in our first function that
61:46 - will check for the translation status so
61:48 - that will be our first button in our
61:49 - search functionality we want to add
61:51 - constant ID which will be document get
61:54 - element by ID and this will be the ID of
61:57 - search ID and we want to get the value
61:59 - of that stored inable ID so we'll do try
62:03 - we'll have constant response which will
62:06 - be our axios function that will execute
62:08 - a get to our Local Host let me just copy
62:13 - paste this particular link so you want
62:15 - to do the same brackets so this is your
62:18 - link this is our endpoint on our fast
62:20 - API after this we going to say that our
62:22 - translation result is uh data from
62:25 - response so whatever is received from
62:29 - this endpoint will be stored in response
62:31 - and we are access accessing that data
62:34 - after that we'll be using El ID for
62:37 - translation results so we want to get
62:39 - the text content of that are we going to
62:41 - stringify that then we want to also get
62:45 - element by ID of with ID results and the
62:48 - style display for that will be block
62:50 - after we want to display translation
62:53 - status and we'll do that again by using
62:55 - get element by ID and we'll Target the
62:58 - status result and with this the text
63:00 - content will change to status give it a
63:03 - dollar sign translation result status
63:07 - and we'll close this and again we want
63:09 - to change this one to block else we want
63:12 - to catch an error so we know that if we
63:15 - need to do debugging we can actually see
63:16 - what's going on what's going wrong so
63:18 - we'll do console error fetching
63:22 - translation status and we'll print the
63:24 - error so log the error and we can give
63:26 - an alert and says there was an error
63:29 - while fetching the translation status
63:30 - and try again so that's our first
63:33 - function and then we want to have the
63:35 - function for the second button so this
63:36 - will be the on click for the second
63:38 - button on our page when we actually want
63:40 - to display the entire content of a
63:43 - particular historic entry in our
63:45 - database so a translation we did before
63:47 - and again just like in the above
63:49 - function you can copy paste the host ID
63:52 - which will be get element by ID search
63:54 - ID so exact same line like in the F
63:56 - function above and we're going to use
63:58 - the same structure of saying uh try and
64:00 - defining the response to execute a get
64:03 - request but with the previous one
64:05 - endpoint was SL translate ID this one is
64:09 - Content ID so it corresponds exactly to
64:13 - this endpoint so the first function
64:16 - calls a get request to this endpoint
64:19 - this one will be called by our second
64:21 - function that we are writing right now
64:23 - so again we want to stringify this and
64:25 - with the second element we want to
64:27 - change the style to blocks I'm going to
64:28 - copy paste the code for that and if you
64:30 - need to you can pause and rewrite the
64:32 - code yourself or play around a bit to
64:34 - understand how we are accessing these
64:35 - elements with get element by ID typing
64:38 - in the actual ID of the HTML element dot
64:41 - text content and stringifying the Json
64:44 - just realized I don't need the return
64:45 - for this so if you go above to the first
64:47 - function you can delete the return same
64:48 - for the second function and we will just
64:51 - finish off writing the statement for our
64:52 - try and we can just add catch error just
64:56 - as we did uh in the previous function so
64:58 - you can copy paste this entire bit and
65:01 - if we save this we can check do we have
65:03 - any bugs after this so if you need to
65:06 - feel free to pause look at the code for
65:07 - these two functions this is the final
65:09 - version of them and this is all the are
65:11 - index HTML file needs in terms of
65:13 - JavaScript so feel free to pause and
65:15 - make sure your code is updated with all
65:17 - of this so another silly typo in our
65:21 - models. P you want to add the S so it's
65:24 - not translation its
65:26 - translations we'll save that and try
65:29 - running everything again and now we have
65:32 - the issue that comes with uh SQL Alchemy
65:35 - just working with an RM like SQL Alchemy
65:37 - so we not able to modify these tables
65:39 - dynamically we have to delete everything
65:41 - effectively and then restart recreate a
65:43 - new table again and then it will be
65:45 - updated to this new name for the column
65:48 - so if you open your PG Adin and you go
65:51 - into your tables translation task and if
65:54 - you delete this table and now if you
65:57 - rerun the whole thing you can go back
65:59 - into your tables and refresh this and
66:02 - there will be a brand new translation
66:03 - tasks table so if you query for the last
66:07 - all rows you can see that the table is
66:10 - empty so a brand new table has been
66:12 - created we'll go to crow. py and make
66:14 - sure that all of our methods here are
66:16 - named grammatically correct so you want
66:19 - to change the middle one I believe it
66:21 - had the missing which one was it so it
66:24 - was get translating so we can change all
66:26 - of that and just put get translation
66:29 - task for the middle one so feel free to
66:31 - pause and compare this CR py file to the
66:33 - current one you have make sure it's
66:35 - written exactly like you see here and we
66:37 - can move on so we need to go to our main
66:39 - py and make sure that just how we have
66:42 - everything written in cr. py the
66:44 - functions are written the exact same way
66:47 - in our main py so we can open them one
66:49 - next to another so if we open CR on the
66:52 - right hand side and we have main py on
66:54 - the left hand side
66:56 - so let's see now in our post request we
66:58 - are using Create translation task and
67:01 - that's correct here in our get endpoint
67:03 - for our task ID we are using get
67:05 - translating task so this is the one that
67:07 - we just changed so we will copy this
67:09 - name and here we will change into get
67:12 - translation task and the same thing goes
67:15 - for our third method here we want to put
67:18 - get translation task we'll save that I
67:21 - believe we also need to go to our inputs
67:23 - and make sure that from database we
67:25 - import session local next to engine we
67:29 - also want to import list from typing and
67:32 - we will import uu ID so just to make
67:35 - sure we don't get any errors in regards
67:37 - to that we'll move on now and in our F
67:40 - method we deleted so there's no need for
67:42 - this response model that's not going to
67:43 - give translation status so you want to
67:45 - do s so after we deleted that we also
67:48 - want to make sure that we return the
67:50 - task not as an object but as a variable
67:52 - here and that was the last of our errors
67:55 - I believe there was a good five to 10
67:57 - errors that we had to fix at the end
67:59 - some of them just being typos some of
68:00 - them being logical errors and we will go
68:03 - and test our app now so we want to go to
68:06 - our browser we will access our endpoint
68:08 - for rendering the main page and we will
68:11 - put some text here hello how are you
68:14 - today and let's say we want this in
68:16 - French German and Italian and if we
68:20 - click translate we are given an ID so
68:23 - it's an id6 we can see the translation
68:25 - is in progress we got the results so we
68:27 - see now progress bar in action
68:29 - transation is complete so now we want to
68:32 - maybe check let's first check did this
68:35 - land in our database so if we go into
68:37 - our PG admin and we refresh this by
68:40 - going into show me all rows you can see
68:43 - here at the bottom that we do have the
68:45 - the recent request the languages the
68:48 - status being complete and we have the
68:50 - translations here so what was the IDE
68:53 - for that it was number six so if we put
68:56 - enter translation ID 6 and check status
68:58 - we see that status is complete if we do
69:01 - check content we that we get the entire
69:03 - content of the translation request let's
69:05 - try doing something much bigger so I'm
69:07 - going to just try going to a random
69:10 - Wikipedia page or something like that so
69:12 - let's say I type in I don't know raldi
69:14 - and we'll try to take let's try to take
69:17 - a big chunk of ral's Page from Wikipedia
69:21 - and if we put weol this Wikipedia and
69:23 - request the translation into to French
69:25 - German Italian and Portuguese so this
69:29 - should take considerably longer so now
69:31 - we want to see this asynchronous nature
69:33 - of our web app in action so this is Task
69:36 - id7 so we got our confirmation that the
69:39 - progress has been received and as we as
69:42 - we wanted now we can see that
69:43 - asynchronously the background tasks from
69:46 - Fast API is running the second process
69:49 - of translating the task and we already
69:51 - have our 200 so even if we go back in
69:53 - our vs code we can see that we have our
69:55 - translate every one second going as a
69:58 - okay which is what we
70:00 - wanted so we are still waiting for this
70:03 - we are waiting for the open AI API to
70:06 - return the translation for us so let's
70:08 - see how long it takes so it's been two
70:10 - or 3 minutes and as you can see see we
70:12 - still didn't get our request back and if
70:15 - I go back to my vs code you can see that
70:18 - the polling that we defined to be 1,000
70:19 - milliseconds it's doing its job every 1
70:22 - second it's constantly refreshing and
70:24 - wanting to get that payload back so that
70:26 - it can display it to the user like we
70:28 - said we don't want the user to have to
70:30 - do anything on the page the page should
70:32 - dynamically update so the translation
70:34 - finally came back it took a good couple
70:36 - of minutes and we can see that
70:37 - everything is updated on our page if we
70:39 - want to check now the status of it and
70:42 - we put number seven check status we did
70:44 - see that the status is complete and same
70:46 - thing for Content we can retri it on our
70:47 - page and that's it that's our project I
70:49 - hope you enjoyed it you learned
70:50 - something and I'll see you next time so
70:53 - the next project we will do will be this
70:56 - AI powered content generator and
70:58 - analyzer and the idea behind this
71:00 - project is more to explain how the
71:03 - infrastructure of a similar project can
71:05 - be
71:06 - produced this particular content
71:08 - generator is not exactly what I consider
71:10 - to be some kind of high quality product
71:12 - output but it's there to teach you how
71:15 - to actually implement this type of a
71:17 - system and then you can easily create or
71:20 - modify a custom version of it for
71:23 - yourself if you're actually trying to
71:24 - build something like this is or if not
71:26 - this project itself will be sufficient
71:28 - to Just Master these Concepts so like
71:31 - before we will do an explanation of the
71:34 - project that we will build I'll use a
71:35 - diagram and also show you the project
71:38 - itself how it works so the important
71:41 - aspects that I wanted to include in this
71:44 - project was how to approach this
71:47 - situation where you have multiple tasks
71:49 - that you want your service to run and
71:51 - then utilizing Python's multi threading
71:54 - built-in Library liary and this is very
71:57 - very important where you actually want
71:58 - to build something more sophisticated so
72:00 - the first thing we will touch upon is
72:02 - Python's multi threading and semop fores
72:04 - which will help optimize the performance
72:06 - especially when dealing with this input
72:08 - output bound tasks like making API calls
72:11 - or database operations so by
72:13 - incorporating multi trending as semop
72:15 - you can optimize the performance of your
72:16 - application important to note this bit
72:19 - here this approach helps manage
72:20 - concurrent requests
72:22 - efficiently so you can imagine as you
72:24 - build a system system like this if
72:26 - you're dealing with what you will see
72:27 - here you're not really increasing the
72:30 - overall performance of it but as your
72:32 - system scales this becomes so so so
72:35 - efficient so you are improving the
72:38 - overall responsiveness of the system as
72:40 - it scales so there is much on multi-
72:42 - threading that can be discussed about
72:44 - and this video will be more about the
72:46 - implementation of it rather than just
72:48 - Theory but in a natural multi threading
72:51 - will allow multiple threads to run
72:53 - concurrently so lastly with semapo is a
72:57 - synchronization primitive that controls
72:59 - access to a common resource by multiple
73:01 - threats and in this project semop for is
73:04 - used to limit the number of concurrent
73:06 - API requests to the open API preventing
73:08 - overload and managing rate limits
73:11 - effectively so we will implement it in
73:14 - our. py file you saw at this point we
73:17 - kind of approach this file structure in
73:19 - a similar way for each project and we
73:21 - always have this U.P file where we
73:23 - include additional function aspect that
73:27 - is running our main.py file so this is
73:29 - where we will do our semop for
73:31 - initialization so for now we will do
73:33 - just five concurrent threads so what is
73:36 - it used for the sem for usage it block
73:39 - it shows that each thread acquires the
73:42 - semaphor before making an API call and
73:45 - this is the important part after a
73:47 - certain threshold additional threads
73:49 - will wait until one of the current
73:50 - threads releases the semaphor so we'll
73:53 - have these two functions that will use
73:55 - semop for in our made. py file we will
73:58 - have a threadpool executor and this
74:01 - manages the thread pool and executes the
74:03 - utility functions in separate
74:05 - threads I'm going to leave this
74:06 - explanation here pause it there's no
74:08 - need for me just to read it out loud
74:10 - just by all means pause the video and
74:12 - read this explanation for it moving on
74:15 - so before we analyze the diagram that
74:17 - will explain our project I'm going to go
74:19 - back to the actual project itself and
74:20 - show you how it works so the idea is
74:22 - that you can enter any topic so for
74:24 - example if I to enter right now Super
74:26 - Bowl and click generate content this is
74:29 - now making a request call to open Ai and
74:34 - we receive some generic text that
74:36 - explains Super Bowl and the idea is that
74:39 - by modifying this Additionally you can
74:41 - have this very quick one button
74:43 - generated content on a topic of your
74:46 - request so furthermore uh project here
74:49 - will have an ability to analyze the text
74:51 - and we have two parameters readability
74:53 - and sentiment as you can see since this
74:55 - is I generated the text coming back has
74:57 - quite a good reability
74:59 - score but what's more important here is
75:02 - that it can actually comment on the
75:04 - sentiment of the text so here I'm
75:07 - providing you the template of how you
75:08 - can utilize sentiment analysis for any
75:11 - particular purpose let's say you wanted
75:12 - to do Twitter post analysis if you were
75:15 - to query each individual feed post
75:18 - however you call it it will give you the
75:20 - sentiment analysis of that and you get
75:22 - like positive neutral negative so you
75:25 - can see this objective commentary on
75:27 - what Super Bowl is so it correctly
75:28 - states that the sentiment of the text is
75:30 - neutral if I was to go in a different
75:32 - direction let's say we go through for
75:35 - historic event W to casualties click
75:40 - generate content so now we have this
75:42 - text that speaks about the casualties in
75:44 - World War I and if I go now and copy
75:47 - paste this into the box for Content
75:49 - analysis and click analyze content now
75:52 - the sentiment of the text is negative so
75:54 - clearly because it is the casualties in
75:56 - in a war let's say I try to do something
75:58 - like successful operation so this is
76:00 - just some kind of like to create a
76:02 - successful operation and then some key
76:04 - factors and then because this is kind of
76:06 - positive uh advice on how to approach
76:09 - whatever long story short we can see
76:11 - that the sentiment of the text is
76:12 - positive so our app works like intended
76:15 - and we'll just break it down through
76:16 - this diagram of how things actually
76:18 - occur so as you saw we have this user
76:21 - interface which is our web app so this
76:24 - is our first SP here I will segment it
76:26 - like so and say this is number one and
76:28 - this is just our HTML elements as you
76:29 - see it's a simple HTML page there's just
76:32 - a little bit of bootstrap here to make
76:33 - the buttons look slightly more modern
76:36 - but nothing special I think I generated
76:38 - it with Char GPT so this triggers out
76:41 - JavaScript so if you go back to this
76:43 - page and we look into the source so if
76:46 - you look into the source and look at the
76:48 - JavaScript you'll see there's a little
76:49 - bit of JavaScript here which is
76:50 - basically just a couple of functions
76:52 - that will extract this text and forward
76:54 - it to our fast API app so that's the
76:57 - JavaScript that we use here so let's say
77:01 - this JavaScript kind of flower number
77:03 - two stage so now our data will land with
77:06 - our fast API back
77:08 - end so with our fast API back end we
77:11 - will include a schema validation so
77:14 - that's not written anywhere here but
77:16 - this definitely will start off stage
77:17 - three starts with schema validation that
77:19 - make sure the data that JavaScript fored
77:23 - with with f fetch method reaches our end
77:25 - points and we will have two end points
77:27 - so as you can see uh we have endpoint
77:30 - and analyze endpoint respectively
77:32 - representing two of the each input boxes
77:34 - one ging an option for Content
77:36 - generation and the otherwise the
77:37 - sentiment analysis so the important part
77:40 - which I segment maybe as number four is
77:43 - the calls to the threadpool executor So
77:45 - This Is Us controlling the processes and
77:47 - making sure that they run sequentially
77:49 - in a specific order and that the sixth
77:51 - one would not start before the semor
77:53 - actually allows it too so after that I
77:57 - would say that what we do have then is
78:00 - communicating with open ey
78:03 - open AI API to retrieve the sentiment
78:07 - analysis and then we can store it in a
78:09 - database this is just the addition to
78:11 - consistently practice incorporating this
78:13 - postest database aspect of uh all of
78:16 - these projects so we can store our
78:19 - content or sentiment analysis into a
78:21 - database this will be our postgress and
78:23 - then it return Returns the data data
78:25 - retrial for displays and then as you saw
78:28 - we get it back in our HTML page so just
78:32 - to briefly comment on when and where
78:34 - multi friending for are used because I
78:36 - believe this is effectively the reason
78:38 - why this project should be
78:41 - studied so the trigger user submits the
78:44 - form to generate content and where so
78:47 - this is the Endo so when we submit the
78:50 - payload to this particular endpoint the
78:52 - thread pool handles the request
78:53 - concurrently and use a semop for to
78:56 - limit the number of concurrent AP
78:58 - calls and so like I said this is our
79:02 - first part uh generate content and then
79:07 - put like one and then two here so the
79:10 - second one is when we do sentiment
79:12 - analysis and what four is submitting the
79:15 - analyze content function to the thread
79:16 - pool to handle the request concurrently
79:18 - just like with the previous one so we
79:19 - use it for the same purpose in these two
79:21 - end points by all means also read this
79:23 - summary it's just F information and like
79:26 - I've said it's very important that you
79:27 - are quite comfortable with dealing with
79:30 - multi API requests currently and making
79:34 - order with a very unorganized situation
79:37 - which could be a system that scales
79:40 - upwards so semaphor so that all being
79:43 - said we went through our diagrams some
79:46 - Theory and we can go and start writing
79:49 - some code so you want to go to this
79:51 - particular GitHub repo it will be the
79:53 - link the first link you see under the
79:55 - project and you want to go and clone the
79:59 - repo so you're going to copy URL and
80:02 - just go into your working directory and
80:04 - get clone this link so we start together
80:07 - with the same file structure that you
80:09 - can see on the left hand side in in this
80:12 - video so yeah after you have done the
80:15 - git clone you will have the app folder
80:19 - templates folder and env. G no.
80:23 - requirements.txt so first thing you want
80:25 - to do is create a virtual environment
80:28 - and activate the virtual environment pip
80:30 - install all of this so I already have
80:34 - the running in a different window but
80:35 - I'm just going to give you a quick
80:38 - introduction of how to do that in I
80:39 - believe in the previous two videos we
80:41 - have done that so you want to make sure
80:43 - that you're in the right folder so the
80:44 - working directory you will do Python and
80:48 - M VNV and then the name so once you have
80:51 - this you want to activate this
80:53 - particular enironment so in Pell I like
80:56 - to do it in Pell so that will be scripts
81:00 - PS1 like so and you can see the prefix
81:03 - VNV meaning that we have activated our
81:05 - virtual environment we want to install
81:07 - all of these libraries so what I'm going
81:09 - to do is PIP install our requirements.
81:14 - dxt so you just leave this to run and
81:17 - within a couple of minutes you will have
81:18 - all of the dependencies ready to be used
81:21 - so in your EnV you want to make sure
81:23 - that you have your sensitive data so we
81:26 - will not hard code any of the sensitive
81:28 - data in our app code rather we will use
81:32 - a particular dependency that allows us
81:34 - to use them in a safe way so you want to
81:36 - make sure that your open AI API key is
81:38 - copy pasted here and also with this
81:40 - project we will be doing a database
81:42 - implementation so you want to create a
81:44 - database with Fest and for that I use PG
81:48 - admin 4 so if you open PG admin 4 in
81:51 - databases here you want to create the
81:53 - database and as you can see I already
81:54 - created this AI gen database so you do
81:57 - the same and make sure that's then your
82:01 - EnV you write this particular variable
82:05 - database U database URL so we will say
82:08 - that we are using postgress and then you
82:10 - want to put username password the
82:13 - address which will be Local Host Port
82:16 - 5432 which is the B one and then the
82:19 - last slash is the name of the database
82:21 - you do the exact same format and like
82:24 - I've set above you just copy paste your
82:26 - API key from open AI dashboard so that's
82:29 - all you need for your EnV file right
82:31 - we're moving on so we can see that all
82:32 - of our dependencies have been
82:34 - successfully installed so we can start
82:36 - coding our app so the first thing we'll
82:38 - do is create our files so we will create
82:41 - a
82:43 - main.py we will have a cr. py database.
82:47 - py ility schemas and models so these are
82:51 - all the files that we'll need in our app
82:53 - folder and just before we start writing
82:55 - the back end logic I will quickly schim
82:56 - over the front end stuff front end stuff
82:59 - is not relevant for this project so you
83:01 - should just use it from the git clone
83:04 - provided with the description but just
83:06 - to briefly schem over what's going on
83:08 - here so the boost stop we're using we
83:10 - are using it through the link there is
83:12 - some CSS styling just to make this
83:15 - project work in the way we want it to
83:17 - work you have your standard HTML which
83:19 - gives us forms so we can take the input
83:21 - from the user and the submit form will
83:23 - then execute some Java script the
83:25 - JavaScript itself is nothing more than a
83:28 - fetch function that will take the
83:29 - payload to do a post request send it to
83:32 - a specific endpoint which in this case
83:34 - will be our fast API endpoint I believe
83:37 - that's sufficient in terms of how much
83:38 - we need to talk about the front end back
83:40 - to us coding our backend now
83:44 - so first things first I like to kind of
83:46 - get the generic stuff that we always do
83:49 - in the same way out of the way so what
83:51 - we'll do we'll go into database. py so
83:54 - we we will import what we need here so
83:57 - we are using SQL Alchemy so the
83:59 - dependency injections will be done with
84:02 - these particular variables and write
84:05 - these also use OS because we'll be
84:07 - working with files and what we said
84:09 - earlier we are using dnv to store our
84:10 - sensitive data so the dependency that
84:13 - will enable us to use that is EnV so
84:16 - make sure you import that we want to
84:18 - load this environment so we'll say load.
84:21 - TV and then we want to import our
84:24 - variables that store our sensitive data
84:26 - so we'll say that the database URL is
84:28 - and then we use the OS framework to
84:31 - actually access that file so get
84:32 - environment and the name of it is
84:34 - database URL so now we want to create
84:38 - the SQL Alchemy engine and we will say
84:40 - that the engine is just create engine
84:43 - and we are passing the database URL so
84:45 - creating a configured session class
84:48 - session local so we have session maker
84:50 - and we'll pass these three parameters
84:53 - and then at the end we'll say that the
84:54 - base equals declarative base so this is
84:57 - our database. py and we can close it
85:00 - we're not going to need to open this
85:02 - anymore so for our main.py now we'll go
85:06 - there and we'll first deal with the
85:09 - inputs so we want to use these three
85:11 - from Fast API to be able to render our
85:14 - HTML page we want to import this
85:16 - particular templates and we importing
85:20 - the our RM which is SQL Alchemy session
85:23 - and we we want to make sure that we can
85:25 - work with all of the files from our app
85:27 - folder so we are importing models CR
85:28 - database utility and schemas so these
85:30 - are the files in the folder respectively
85:33 - and we want to make sure that from
85:35 - database we import engine and session
85:37 - local and uh lastly from stet
85:39 - concurrency we import run in thread pool
85:42 - we'll write models. space. metadata
85:44 - create all to bind the engine and call
85:46 - our app which is the fast API so store
85:49 - it in app variable we want to make sure
85:51 - that this app knows where to look for
85:54 - our template files so to be able to
85:56 - render the HTML file the front end we
85:58 - want to say that go and look into the
86:00 - template folder so that's the directory
86:02 - where we will store our front end stuff
86:04 - which is if you look at the left hand
86:06 - side where the file structures are you
86:08 - can see where our HTML file is right
86:10 - there so to do dependency injection next
86:14 - we can use the same thing so I always
86:16 - copy paste this from the actual website
86:18 - to get our dependency injections we'll
86:20 - be using we'll just be passing this get
86:22 - DB parameter with our endpoint methods
86:25 - so lastly now we can actually write our
86:28 - endpoints so the main endpoint will just
86:31 - read our HTML page and render it so
86:36 - that's what what it does we'll name it
86:38 - accordingly read root it has a request
86:41 - and the return is just U template
86:44 - response giving the template that we
86:45 - have there now we want to so we said we
86:48 - we said we will have two end points that
86:50 - will effectively do all the work so that
86:52 - will be our post endpoint on/ generate
86:56 - so this is for generating content and we
86:59 - want to asynchronously Define this
87:01 - method we calling it generate content
87:04 - and we are making sure that the data
87:07 - that travels from the front end is
87:08 - validated by by our schemas so we still
87:11 - have not written this so now we will go
87:13 - into schemas and make sure that the
87:15 - quest body that comes gets validated by
87:18 - this particular parameter from schemas
87:21 - and stores in payload variable here so
87:23 - this is how we will access the data that
87:25 - goes onto this particular endpoint and
87:28 - then the second parameter is our
87:29 - dependency injection and as you saw we
87:31 - defined that here so this is what allows
87:33 - us to actually have the connection to
87:35 - the
87:36 - database but like we said we have our
87:38 - payload here and we need to make sure
87:40 - that it gets validated and I always like
87:42 - to just use pantic schemas for that so
87:45 - going into our schemas py we will import
87:47 - base model from pantic and we will have
87:50 - a bunch of classes now to validate our
87:52 - data
87:54 - so we have this one that takes the first
87:57 - input which will just be a string so it
87:59 - gives the topic that we want to generate
88:01 - content about and then the second one
88:03 - for sentiment analysis it's also a
88:05 - string so we're just making sure that
88:06 - whatever comes it's a particular one
88:08 - variable and uh type the data type is a
88:11 - string and if you think about it do we
88:13 - really need schemas at this point uh no
88:16 - not really but uh as this tutorial kind
88:18 - of aims to teach the basic architecture
88:22 - structure of uh web up the functions
88:25 - like this we try to establish it as a
88:27 - practice as a habit as a good practice
88:30 - of creating high standard of uh API
88:33 - systems so after we have our schemas
88:35 - we'll go back to our
88:39 - main.py and under generated text we will
88:42 - stall what this particular method
88:44 - returns so as we mentioned earlier we
88:47 - have importing This runin Thread pool
88:49 - from stall. concurrency and the
88:52 - parameters we're passing is a particular
88:54 - function from utility our dependency
88:57 - injection and the topic from the payload
89:00 - so this third parameter is what comes
89:02 - from the front end the input from the
89:04 - user the dependency injection is our
89:06 - connection to the database and the one
89:09 - that we still have not written is the
89:11 - generate content function from utility
89:14 - so that's what we'll do next so if we go
89:16 - into utility. py we want to make sure we
89:18 - import everything that we need so you
89:20 - want to import open AI OS just like with
89:23 - the other files we importing session and
89:25 - loading our sensitive data in load. tnv
89:28 - we're using crowed models files from our
89:30 - app file from our app folder we are
89:33 - importing threading and thread pool
89:35 - execut once again we want to establish
89:38 - the connection to our sensitive data we
89:40 - will be using the open AI key so this is
89:42 - how you're going to do that just like
89:44 - with the database URL we are
89:46 - establishing that here and what I
89:48 - consider to be the pivotal moment of
89:50 - this particular project is to explain
89:52 - that here is the moment we Define semor
89:54 - to limit the number of concurrent
89:55 - threads so just for this example we are
89:57 - doing a particular number five so we'll
89:59 - be running five threads and then if
90:02 - there is a sixth one it actually waits
90:03 - for one of these to finish so now we
90:06 - want to write out generate content
90:07 - function so what we'll do is have it
90:11 - with our dependency injection and the
90:13 - the topic the string that gets passed
90:15 - from the front end and the return will
90:17 - be a string as well so with semaphore
90:20 - we'll say that the search term is cr.
90:23 - get
90:24 - search term and this will have the two
90:26 - parameters of the dependency injection
90:28 - and the topic and as you can see we
90:30 - still have not touched our cr. py file
90:32 - so we need to make sure now we have this
90:34 - particular method written in our cr. py
90:37 - going to our cr. py we will just import
90:40 - these two particular lines and then
90:43 - we'll write our create search them
90:45 - method so it will have the same
90:48 - parameters and we're going to say that
90:51 - the TB search term is models search term
90:55 - term which is the term so as you can see
90:57 - now as we are creating this flow we are
90:59 - kind of jumping from a file to file but
91:01 - I believe it's important that you have
91:03 - an idea of how the thought process
91:05 - usually is when you are creating these
91:07 - end points and modifying specific
91:09 - utility adding functionality to it so
91:12 - now we'll go into our models and write
91:15 - our tables so going into models.py we
91:18 - want to import a couple of things so
91:20 - from SQL Alchemy we'll import this
91:22 - particular column integer string forign
91:24 - key and text we'll import relationship
91:26 - because we'll be using a relational
91:28 - concept when it comes to creating these
91:30 - tables and our first table will be our
91:33 - Search terms so we want to store that so
91:35 - we will say that the table name is
91:36 - Search terms and this is how I've
91:39 - generated this so it will have an ID the
91:42 - ID is the primary key the term which is
91:45 - what gets passed from the user and then
91:47 - we have the generated content that
91:48 - returns to be displayed in the front end
91:52 - aspect for the for the user and also we
91:55 - have sentiment analysis so this is what
91:56 - we're storing in our database called
91:58 - Search terms then our second table is
92:00 - called generated content and this takes
92:04 - from a particular line from the table we
92:07 - just created previously our Search terms
92:09 - table and it also has its own ID this
92:11 - the content and then we have the search
92:13 - term ID and the search term which has
92:15 - the relationship with the search ter
92:18 - table and our third table for sentiment
92:21 - analysis it also has ID ability
92:24 - sentiment so these are the outputs that
92:26 - you saw in our front end up our return
92:27 - to the user when they do sentiment
92:29 - analysis and we are also storing the ID
92:31 - and the search term in this table so
92:33 - that's our models.py if you need to
92:35 - again just pause and make sure that you
92:37 - have written this in the same way I'm
92:40 - going to make sure that everything is
92:43 - visible in a way that you can just pause
92:45 - and go over it so I believe now in the
92:48 - video If you pause everything is visible
92:51 - so going back to where we were so as you
92:55 - can see if you look at the files that
92:56 - open here main Crow utility schemas and
92:58 - models this was the workflow as we were
93:00 - trying to write this
93:02 - endpoint so we can effectively close
93:04 - them one by one and go where we were so
93:07 - the last one that we were working was
93:09 - utility. py and we will finish off
93:11 - writing our generate content function so
93:14 - if this is null we'll say that the
93:18 - search term sorry if this is not
93:21 - null CR create search term and this has
93:25 - the same two parameters so now we want
93:27 - to make sure that we can actually access
93:28 - the open AI Pi so in our response
93:32 - variable we will store open. chat
93:34 - completion and we will write these
93:37 - particular parameters so what's getting
93:39 - passed to open AI is your be my
93:41 - assistant and write a detail article
93:43 - about and we are passing the topic that
93:45 - the user has chosen we will store that
93:48 - in generated text and we will say is
93:52 - that generated test text
93:54 - text equals respond choices with index
93:57 - zero and the message content we'll use
94:00 - strip to do some formatting of the
94:02 - string and we want to access now in our
94:05 - CR create generated content and pass the
94:08 - dependency ejection generated text and
94:11 - search term. ID so this is now a method
94:14 - that we still have not created so we'll
94:16 - go to our cr. py and create this method
94:20 - so going back there we see that we still
94:22 - have not finished our create search
94:24 - method so what we just need to add here
94:27 - is this real lines which is the way how
94:29 - this particular orm SQL Alchemy will
94:32 - actually insert this data into the
94:34 - database it always needs a commit and
94:36 - refresh after that and we can just say
94:38 - return DB search term so that's our
94:41 - first method defined and very similarly
94:43 - now we are doing the create generated
94:45 - content method and with this one we will
94:47 - say that the DB generated content is
94:51 - models and from models we get generated
94:53 - content and we say that content is
94:55 - content we will also add that search
94:58 - them ID we will add the same three lines
95:00 - from above here which allows us to
95:02 - actually do the insertion of data into
95:04 - our database sorry wrong copy paste so
95:07 - the one with DB generated content and at
95:10 - this point we'll just return DB
95:12 - generated content so now we can go to
95:15 - our utility. py and as you can see we
95:16 - are accessing this method that we have
95:18 - just written create generated content
95:20 - lastly this will return generated text
95:23 - so we go back to our main.py and finish
95:26 - off defining our endpoint so after
95:28 - generated text we just want to return
95:30 - that our generated text is the variable
95:34 - of generated text so I believe we have
95:37 - everything we need to actually test this
95:38 - so this particular endpoint so if we go
95:41 - and run our fast API app so we'll go
95:45 - into folder app and we will write uicorn
95:49 - main app reload so our app is running so
95:53 - if we we go and open our end point for
95:57 - rendering our HTML and we enter some
95:59 - kind of a topic here so we'll just I'll
96:01 - just do something very random I'll say
96:03 - New York and click generate content and
96:06 - after approximately like 5 10 seconds we
96:08 - can see that we have our results
96:10 - returned so we have this information
96:11 - about New York so we still now have to
96:13 - do the second part which is make sure
96:15 - that this particular input will reach
96:18 - our second end point so we have to
96:20 - create that second end point all right
96:22 - then so quite similar to what we have
96:24 - already done so we'll just copy paste
96:26 - the previous post and modify what we
96:29 - need to modify so instead of endpoint
96:32 - generate it will be endpoint SL analyze
96:35 - instead of the function called generate
96:37 - content it'll be called analyze content
96:39 - the schemas you'll be using will be
96:42 - analyze payload and the dependency
96:45 - injection can remain exactly the same
96:48 - then instead of just creating generated
96:50 - text we are creating two variables and
96:52 - again we are using
96:54 - running thread pool but when we reach
96:56 - into utility file we'll be using analyze
96:59 - content variable so as you can see we do
97:01 - not have this method written yet so
97:03 - that's what we'll do next we'll go into
97:04 - utility. piy and now we'll create a
97:07 - function that can do content analysis so
97:10 - call it like that call it analyze
97:12 - content because that's what we written
97:13 - in our main pii endpoint and again we
97:16 - will be using semaphor so with semore
97:19 - we'll say that our search term is C.G
97:22 - search term so as you can see we do not
97:25 - have this method so we shall go in CR py
97:27 - and write it now so going there we will
97:31 - say that the method get search them
97:33 - takes two parameters and they are a
97:35 - database session and a string called
97:38 - term and it will just return from our
97:42 - database so we'll use SQL Alchemy here
97:44 - and we will query through our models a
97:47 - datab uh table called search term and we
97:50 - want to filter model search term do ter
97:53 - and it will be the exact term and we
97:56 - will return the first so we will save
97:58 - that and go back into our utility and
98:00 - see that this thing went green now from
98:02 - white to Green meaning that this method
98:04 - it can now be used next we will say if
98:07 - this is not null then we actually want
98:10 - to do a crow operation and create the
98:13 - search term so we entering that into our
98:15 - table and we want to say that
98:18 - readability is the output of the get
98:21 - readability score method which takes the
98:23 - content parameter so we do not have this
98:25 - function yet so we're going to Define it
98:27 - here so we're going to say that this
98:30 - takes content which is the string and it
98:32 - returns a string reability score which
98:35 - is good so this can be something you
98:37 - modify and play with yourself so you can
98:39 - see that within utility you can add any
98:41 - additional functionality so you would
98:43 - actually have to find a way to connect
98:45 - an API that can do a relability score so
98:48 - this will be your place for it so if
98:50 - available replace with Act ual
98:53 - readability I call the one that we will
98:57 - use with our open open a is the
98:59 - sentiment and we will do get sentiment
99:00 - analysis so just like we did with
99:02 - readability score we will create that
99:04 - here and we'll say that the get
99:07 - sentiment analysis takes content as a
99:09 - string and gives us a string put and in
99:12 - this response we will again use open ai
99:14 - ai so we using chat GPT 3.5 turbo and
99:18 - this is the message just saying be my
99:20 - assistant and analyze the sentiment of
99:21 - the following text and we are passing
99:23 - the content that we have just generated
99:25 - previously and you want to make sure you
99:27 - actually know how much tokens you're
99:29 - using with this you don't want to just
99:30 - burn through it so I'm limiting it to
99:32 - 10 after that we will return the
99:35 - response of choices and again with some
99:38 - formatting using strip oh this
99:40 - indentation is not right so you want to
99:42 - make sure the indentation is right so
99:43 - just have a quick check over you don't
99:45 - do the same mistake I just did a second
99:47 - ago so now we have a get sentiment
99:48 - analysis function so just to recap this
99:50 - is an actual function that works
99:52 - properly we the readability score you
99:54 - are free to improvise with this and play
99:56 - around implement the readability API
99:58 - here you will do it in the exact way how
100:00 - this is done with the sentiment analysis
100:02 - So within the response variable you will
100:05 - make an API call pass it certain
100:08 - parameters you can read API
100:09 - documentation of your
100:11 - readability and then return the response
100:13 - that it
100:14 - gives so going back to our analyze
100:17 - content function after we have done
100:18 - readability and sentiment analysis we
100:20 - will do some crowd operations so we want
100:22 - to store all of that and we are just
100:24 - saying create sentiment analysis this is
100:26 - the method that we will create right now
100:27 - and the parameters we're passing is our
100:29 - dependency injection and the readability
100:31 - sentiment files but also the ID because
100:34 - if you remember we are using a
100:36 - relational concept here when it comes to
100:37 - our tables so now we want to create the
100:39 - sentiment analysis method so going into
100:43 - crud we will do create sentiment
100:46 - analysis the parameters are the
100:47 - dependency injection readability string
100:49 - string and the ID which is an integer
100:52 - and here we want to say that our
100:54 - variable called sentiment analysis
100:56 - analysis basically just like the line
100:58 - from our create generated content
101:00 - functions this one here so it'll be very
101:03 - similar so I'm just going to do that it
101:06 - goes into models of sentiment analysis
101:08 - table and readability through ability
101:10 - and you can see where this is going just
101:12 - like with the previous one ending with
101:13 - adding the search term ID then we want
101:17 - to do our croud operation uh
101:19 - specifically create so we are going into
101:21 - the database we are adding this
101:22 - particular ular payload and you always
101:25 - have to do commit and refresh and then
101:27 - it's just returning the VAR variable
101:30 - that we created here so it will return
101:32 - DB sentiment analysis so we have
101:34 - everything we need in our Crow I believe
101:36 - now and we can close
101:38 - it to finish off our utility. piy we
101:41 - want to go back to where we were which
101:44 - is this line so we have just created
101:45 - this particular function and as you can
101:47 - see it went green so it means it's
101:49 - connected and we just want to return
101:51 - these two variables so if you remember
101:53 - we we have this readability and
101:54 - sentiment and we want to return those
101:55 - two so we'll say readability and
101:57 - sentiment so I believe with these four
101:59 - functions we have finished our utility.
102:02 - py file as well so 1 2 3 4 that's
102:05 - correct so we can close utility. py as
102:07 - well going back to our main py to finish
102:09 - off defining the second end point the
102:11 - post one we want to now return the data
102:14 - that we have produced with readability
102:16 - and sentiment so we will just say that
102:18 - readability is readability sentiment
102:21 - sentiment and this will be in for of a
102:23 - Json it's an object like so so what
102:27 - remains now is to test the second end
102:29 - point and if everything works then we
102:31 - will also just check does the crud
102:33 - operations do they operate properly and
102:36 - insert the data into our database and if
102:38 - all of that works that's our project
102:40 - finished so we are saving this our app
102:43 - is running so we will open our app and
102:46 - test it we will do for example London
102:49 - click generate content and wait so we
102:52 - have some information about and now we
102:53 - want to do sentiment analysis we expect
102:56 - it to be positive because this is all
102:58 - like superlative Des of London so if we
103:01 - copy paste that into our analyze content
103:04 - and click analyze content we see that it
103:07 - says that the sentiment of the text is
103:09 - positive so everything works here as we
103:11 - want it to now all we want to see is if
103:14 - we open our PG admin 4 and check into
103:17 - our database did this London information
103:19 - get accordingly stored in our database
103:22 - so doing that I'm going to refresh my
103:25 - database and going into my tables first
103:28 - I'll do Search terms so if I return all
103:30 - rows and I've been testing a lot of
103:32 - things as you can see but at the bottom
103:34 - you can see that there is London so
103:36 - everything works right here doing the
103:38 - same for our generated content and I do
103:41 - return all rows and we see that the
103:44 - content text expl in the vi city of
103:46 - London and now we want to make sure that
103:48 - the third analysis table also works
103:50 - properly and we can see that it gives us
103:53 - yet the last sentiment of the text
103:55 - dispositive which is consistent with
103:57 - what we just saw so everything in this
103:59 - project works as we intended I hope you
104:02 - enjoyed it and learned something and
104:04 - we'll see you in the next one we will
104:05 - create a web app that will combine the
104:09 - functional web application using audio
104:12 - processing and AI models and it'll
104:15 - create something kind of unique and this
104:18 - is the end result what we'll end up with
104:22 - so as you can see this is a Content
104:24 - aspect of it and it gives the user an
104:26 - option to upload any audio file they
104:28 - want for all intents and purposes I'm
104:30 - just going to choose a random song from
104:33 - my computer so I've chosen this song you
104:36 - can see what is here for this app I've
104:38 - included also Russian and Spanish so if
104:40 - you want to try doing songs that are in
104:42 - Russian or Spanish and you and Spanish
104:44 - and you want the lyrics this is the way
104:46 - to do it so after choosing all of that
104:49 - we click extract
104:51 - lyrics so after clicking extract lyrics
104:53 - We will have to wait for a minute or two
104:55 - because now in the background we will
104:57 - have the following processing happen
104:59 - with this song which is an MP3 file
105:01 - we'll get converted into a VA w a file
105:05 - then we'll have the lyrics extracted as
105:08 - you can see they just popped up here
105:10 - then we will communicate to open ai's
105:13 - API to have a summary of the transcribed
105:16 - text so it will Express the general
105:18 - meaning the sentiment of it and then the
105:21 - idea is that that this particular
105:24 - summary will be forwarded as a prompt to
105:27 - open ai's API to produce an image
105:30 - inspired by this particular summary so
105:34 - that is what the end product will look
105:36 - like and now we can explain high level
105:39 - what is going on in the background and
105:40 - how this project works so just initially
105:44 - I want to show that with the file
105:46 - structure what we'll be working with
105:47 - here is just the main py so we are doing
105:51 - the back end here everything else you
105:53 - will just get from my git repo I'll show
105:56 - you in a minute how to do that so the
105:57 - front end the index. HTML the static
106:01 - files these will all come from the git
106:03 - repo and then these two folders will
106:06 - just be there to manage all the files
106:08 - that we'll be working with so irrelevant
106:10 - to talk about now and you will also have
106:13 - to create your EnV to provide the open
106:17 - AI API key of yours and the conventional
106:20 - requirements.txt is just a file that I
106:22 - will will include in the git repo to
106:24 - make sure you have all the dependencies
106:26 - required for your project so like I said
106:29 - everything here is pretty much a
106:30 - relevant other than our
106:33 - main.py so all of this will come from
106:36 - the git repo and we will just call the
106:39 - main P py so on a high level what will
106:42 - happen is you saw with the front end the
106:44 - user has the option to use a file so
106:47 - this file user uploads an MP3 file once
106:51 - this particular event have happens so
106:54 - this is matched with this we initiate
106:56 - the conversion of an MP3 file into wav
107:00 - so this particular line here so that we
107:03 - will call let's say event number two so
107:05 - once that is completed we initiate our
107:07 - audio transcription So This Is Us
107:10 - extracting the lyrics and providing them
107:12 - back to the user so let's say this is
107:14 - our step number three here with number
107:16 - four you saw that in the summary of the
107:20 - transcribe text we will extract General
107:22 - meaning the sentiment and then provide
107:24 - that to the front end as well so our
107:26 - back end event number four is the text
107:29 - summarization and it provides this
107:31 - summarized text so as you can see that
107:34 - goes within our before here text
107:36 - summarization showing the summarization
107:38 - of the transcribe text into a concise
107:40 - sentence and then lastly the idea at
107:43 - least is that we will create some kind
107:45 - of an image that is inspired by the
107:48 - lyrics of the text so just for the sake
107:51 - of the project this tutorial is supposed
107:53 - to teach you about this backend
107:55 - architecture that's kind of event driven
107:57 - and it combines usage of different API
107:59 - so API integration for a specific
108:02 - purpose but you can modify this however
108:05 - you would like based on what you would
108:07 - like as an outcome here I just wanted to
108:09 - show you the way to do it so I thought
108:12 - all right the best way maybe would be to
108:14 - rather than just take the whole lyrics
108:15 - and try to create an image I'll create
108:18 - some kind of a text summary which we saw
108:20 - here with the step number four and then
108:23 - that will be the prompt to create image
108:25 - out of it once we prompt open AI with
108:29 - this summarized text that image will be
108:32 - generated and the result displayed back
108:34 - to the client so to reiterate the events
108:37 - we want to implement in our architecture
108:39 - is the following sequence so the user
108:41 - uploading the MP3 file through a web
108:44 - interface so in the back end then
108:47 - conversion to a different file type will
108:49 - happen so after this processing is
108:51 - complete we we will actually extract the
108:54 - text from the file that text through
108:58 - open AI API will be summarized in one
109:02 - concise
109:03 - sentence then we will use that to prompt
109:07 - open AI API to generate an image and
109:10 - that image will be displayed to the user
109:13 - and that's the end of the sequence of
109:15 - events for our back end so this is the
109:18 - high level overview of our project here
109:22 - with all of that that being said now we
109:23 - can go into implementation so the first
109:25 - thing you want to do is go to the GitHub
109:28 - link the following link that will be
109:30 - provided in the description and it will
109:32 - land you in this lyrics start repo and
109:35 - you want to copy this and go into your
109:38 - vs code so once you've done your git
109:40 - clone and you land with this exact file
109:43 - structure we'll be working with this
109:45 - main.py and build the rest of the app
109:48 - but first before we do that we'll go
109:50 - through what you get here so you're just
109:52 - familiar with what's happening with the
109:53 - front end and the remaining of the files
109:56 - and folders here so I'll go from like to
109:58 - bottom so this is for now an empt folder
110:01 - where we will store the converted files
110:03 - meaning that we will take a MP3 file
110:06 - convert it into a WAV file and story
110:09 - there with the media this is the place
110:13 - where the pictures like the images that
110:15 - are generated with our AI will be stored
110:19 - before they are displayed on the front
110:21 - end client uh static will just hold our
110:25 - CSS and maybe if we want to include logo
110:28 - for our front end in the templates we'll
110:31 - have a front end like the HTML uh file
110:34 - written and we'll go through each of the
110:36 - elements just to make sure even though
110:37 - this is this project is not meant to
110:39 - teach front end in any way shape or form
110:41 - but we will still go through it so that
110:43 - we can reference what goes where as we C
110:46 - the back end we want to understand why a
110:48 - particular function or logic from the
110:50 - back endend is influencing something in
110:52 - in the front
110:53 - end and then with the uploads I believe
110:56 - this will be the place where we store
110:58 - the initial chosen files so the MP3
111:01 - files so git ignore it's just here once
111:04 - I push this to get I don't want to push
111:06 - some of the stuff that's sensitive or
111:08 - that I just don't need in a
111:10 - repo and if you want to read more about
111:12 - the actual project the read me file here
111:14 - is exactly for that it actually explains
111:16 - all the features of the project and the
111:18 - specifications like the text stack used
111:21 - and it just gives um overall how it
111:23 - works so without further Ado we will
111:27 - actually get the link go back to our vs
111:30 - code you can create a new folder it
111:32 - doesn't matter but we will git clone
111:34 - this into your working directory so
111:36 - doing git clone and giving the link of
111:38 - the repo we have this folder now so
111:41 - we'll CD into it so the first thing you
111:43 - want to do is install everything from
111:45 - your requirements.txt so just like with
111:48 - the other projects we'll create a
111:49 - virtual environment so this is your
111:51 - command for it let me see maybe you
111:54 - can't see it over there so python mvnv
111:58 - VNV once you do that you will see a new
112:00 - folder in your working directory VNV so
112:03 - you want to go and activate that I
112:05 - prefer opening Powershell but it's
112:07 - really up to you which terminal you use
112:09 - to do that so you want to make sure that
112:11 - you're in the folder and you want to
112:13 - access it all the way into scripts and
112:16 - then activate PS1 and this is fine so
112:19 - now we have everything activated and we
112:21 - want to install all of our dependencies
112:23 - so you have the requirements.txt file
112:26 - here you just want to type in PIP
112:28 - install our
112:29 - requirements like this and just let this
112:32 - run so this will now install all the
112:34 - dependencies and whil this is happening
112:36 - we'll we can just start writing our back
112:38 - and code here so the first thing we will
112:41 - do is import everything that we need so
112:44 - I'm going to copy paste all of the stuff
112:46 - and just break it down quickly so this
112:48 - is everything from Fast API that we'll
112:50 - be using we'll be using pantic we are
112:54 - implementing this particular software
112:56 - templating this allows us to render the
112:58 - HTML page you don't want any issues with
113:01 - cost so we'll import cost middleware OS
113:03 - is to be able to manipulate files to
113:05 - work with files because as you saw we
113:08 - have to upload uh an audio file from our
113:10 - device then the remainder here will just
113:13 - help us work with the image that's
113:15 - displayed and the audio processing do
113:17 - EnV is important because we don't want
113:19 - to include any sensitive information by
113:22 - hard ining it in our code in something
113:24 - that you might push to repo or share
113:26 - with other people so this is dependency
113:28 - that will allow us to store it securely
113:31 - logging not the most important thing but
113:32 - I like to have it as I build this
113:34 - project if I encounter situations where
113:36 - I'm building something new and I want a
113:38 - troubleshoot logging helps a lot speech
113:40 - recognition will help us with audio
113:42 - processing and then finally we are using
113:44 - open Ai and requests to make this sub
113:47 - requests for HTML protocol requests and
113:49 - open AI to communicate with our open AI
113:52 - API so that's all of our dependencies at
113:56 - Imports if you want you can pause the
113:58 - video and just make sure you write this
114:00 - exact same thing so we move on we will
114:03 - create a EnV file so you want to make
114:06 - sure that it's in your working directory
114:08 - so you want to write this open API _ key
114:11 - equals and then you want to include your
114:13 - API so your API
114:16 - your API key from open AI so I'm going
114:20 - to do this offscreen and you can do
114:23 - exactly the same once you have done that
114:25 - now we can actually import that variable
114:28 - so we will write load. EnV we will say
114:31 - that our open API key is OS meaning the
114:35 - input that deals with files as you saw
114:37 - earlier in the line seven here this
114:39 - import OS so we accessing that and
114:41 - saying get environment variable and then
114:44 - we're giving the name of the variable so
114:46 - now we can use that securely we want to
114:49 - initialize our first API app so we will
114:52 - say fast API if need be here we will use
114:56 - loging so we can configure that later if
114:59 - we have to back and stay as it to do so
115:02 - we want to mount our static files so our
115:05 - fast API app needs to know where to look
115:07 - for our static files if you look on the
115:08 - left hand side we have our folder static
115:10 - and that's the place where we will
115:11 - direct our fast API to look so at the
115:14 - moment over there you have the CSS and
115:16 - I've just included this logo from my
115:18 - YouTube channel so all we have to do is
115:20 - say look for it in this particular f a
115:23 - folder and we will say that those are
115:25 - the static files called Static with name
115:28 - static now we want to be able to render
115:30 - our HTML page so we will do templates
115:35 - and say the directory of it is templates
115:38 - just as we have the directory static
115:40 - underneath we have templates and that's
115:41 - where our HTML file is so now is a good
115:44 - moment for us to open that front end and
115:47 - see what we have there as we said we
115:49 - will not be doing a tutorial on anything
115:51 - front end related but we want to make
115:53 - sure that you understand once you're
115:54 - writing the backend code what does it
115:56 - pertain in terms of the front end so in
115:59 - your templates index.html open that and
116:01 - we'll just quickly do a breakdown so
116:04 - that's not really relevant so this is
116:07 - just using the text of it it's a lyrics
116:09 - extractor so in our main we have a form
116:13 - which will allow a user to upload an MP3
116:15 - file so we are saying choose an MP3 file
116:18 - and then in the input type we specify
116:21 - that it is like the ID file so the type
116:23 - is file and it accepts MP3 then we allow
116:28 - these three so you have these three
116:29 - options if you remember it's a drop down
116:31 - between three languages English Russian
116:33 - and Spanish so then we have a button
116:35 - that submits this form once that button
116:38 - is submitted we have some JavaScript
116:40 - here in this script tag that does that
116:42 - work for us so once the submit button is
116:44 - clicked the extract lyrics this is the
116:46 - event that's triggered and we execute a
116:49 - post request to our endpoint that we
116:51 - will Define in our main.py file so
116:53 - that's something that we will do now
116:55 - that's not something that exists here
116:56 - but ahead we are referencing that in our
116:59 - JavaScript logic here so the Ajax code
117:03 - it is pretty much similar I believe in
117:05 - the previous tutorial we used Fetch and
117:08 - it's different but it works on the same
117:09 - principle where we are defining the
117:11 - endpoint address we are defining the
117:12 - type of the HTML request that we are
117:14 - doing then we doing this Json stringify
117:17 - to make sure that it's in adequate data
117:19 - form where we are expecting a response
117:23 - as well so that's the JavaScript there
117:25 - and as you can see there is not much to
117:27 - the front end other than just these
117:28 - couple of elements that will accordingly
117:30 - display the different content as it's
117:34 - generated so that's why we have these
117:37 - respective ml elements they're pretty
117:39 - self-explanatory I don't think we need
117:40 - to discuss this further more and we
117:42 - should focus on what matters more which
117:44 - is the front end so oh by the way I
117:47 - don't want to forget also in our static
117:48 - we have some CSS just to make this up a
117:50 - little bit more aesthetically pleasing
117:52 - but once again not the front end
117:54 - tutorial so if you feel like exploring
117:56 - it a bit studying it by all means do
117:58 - that and we will now Focus again on our
118:00 - back end so this is where we left off
118:03 - and this is something that I just copy
118:05 - paste from the documentation of fast API
118:08 - there's always always the same thing
118:10 - used for me just to make sure that there
118:11 - is no cause issues so for data
118:14 - validation I might use just a particular
118:18 - schema so I'm going to say that the
118:20 - lyrics payload inherit base model and
118:24 - it's just one variable which will be a
118:26 - string so to keep things a bit more
118:28 - organized we might as well create a file
118:31 - and we can call this schemas py and we
118:35 - will check this there so we want to make
118:38 - sure we import pantic for this then
118:41 - going back to our main we can go on the
118:44 - bottom here of the Imports and just say
118:46 - import now I can say from scheme as
118:49 - import payload though one thing when it
118:52 - comes to managing these different
118:53 - directories here where we will be
118:55 - storing content that's dynamically
118:56 - generated I like to include some code
118:59 - that helps the logic of it by making
119:01 - sure that certain directories exist
119:03 - before it executes logic where it's
119:04 - supposed to save something in that
119:06 - folder so just in case things get
119:08 - scrumbled later on if you're playing
119:10 - around thinking around with this project
119:12 - or any other project I like to include
119:14 - something like this so I say if this is
119:17 - null and I will give the name of our
119:20 - converted files folder we'll do OS make
119:24 - this so it will create a directory
119:26 - called this so now if I just run this
119:30 - python main.py you can see that it has
119:33 - created converted files folder so if it
119:36 - doesn't exist it creates it if it exists
119:39 - this becomes obsolete I like to have it
119:41 - so we can Define our endpoints now so we
119:43 - will have a get endpoint that will first
119:47 - render the HTML page so this will be the
119:49 - response class of HTML response and you
119:52 - can asynchronously call this method read
119:56 - root which will just render the HTML
119:58 - page from our templates so it will give
120:00 - return templates template response
120:03 - index.html and also request so leave
120:07 - that empty for now so with this we can
120:09 - already test this fronts as we needed to
120:12 - so if we go into our terminal and type
120:15 - in uicorn main reload we can see that
120:19 - it's running so if you open your browser
120:22 - uncheck Local Host a000 we can see that
120:25 - we have the front end rendered so
120:27 - nothing here will work because there is
120:29 - no back end that this can communicate
120:31 - with yet but we know that so far so good
120:34 - everything is working as intended so
120:35 - going back to our back end we can
120:38 - continue with our other endpoints so we
120:41 - just create something like we'll call it
120:43 - Roots so now what we want to do is
120:47 - create the endpoint where the button
120:50 - will go so so once the user clicks
120:53 - submit we want to upload that file so we
120:56 - can initiate the processing of the audio
120:59 - file so we'll say endpoint upload file
121:02 - and asynchronously called create upload
121:06 - file so this will Tak in file as a part
121:09 - of the request and also the language
121:12 - that we want the text to extract to into
121:16 - and this is a string so we want to make
121:18 - sure just like we previously made sure
121:19 - that we created a directory called ined
121:22 - files now we want to create a directory
121:24 - uploads where we will store all the
121:25 - files that the user chooses to upload so
121:28 - let me just copy paste this bit actually
121:30 - and this can be indented but there'll be
121:32 - a difference in the name of the actual
121:34 - file so it'll be called uploads well so
121:38 - as soon as the first time we actually
121:39 - try to communicate with this endpoint
121:42 - then this logic will be executed and it
121:44 - will create our uploads F uploads folder
121:47 - so next we want to store the file
121:50 - location so the actual
121:52 - actual path so as you can see in our
121:54 - file location variable here we are
121:55 - storing this as an F string and we will
121:57 - say with open and then give it the file
121:59 - location as file object and we want to
122:03 - write file file read like so so now
122:06 - we're going to be doing our audio
122:09 - processing so for this we'll say thatav
122:13 - location of the file is and then we'll
122:16 - do an F string and we'll basically give
122:18 - it the same half as the MP3 but with
122:21 - just replaced extension so it's not
122:24 - going to be MP3 it's going to be VAV
122:26 - remember this is not modifying a file
122:28 - this is just giving the location of
122:30 - where we want to save the processed file
122:33 - the converted file hence we are just
122:34 - effectively changing the name just
122:36 - changing the string and then now we want
122:38 - to call a function that will convert mp3
122:41 - to
122:43 - wav so to do that we will create a new
122:46 - file we'll call it utility byy and in
122:50 - here now we'll write some logic that
122:51 - will actually do the conversion of that
122:54 - so we will call this convert mp3 to wav
122:58 - so this will take a parameter of a path
123:01 - of MP3 and wav so I will say that audio
123:06 - is audio segment from MP3 and then the
123:10 - MP3 path audio export now we give the
123:13 - wav path and format wav and at this
123:18 - point I want to make sure this actually
123:20 - happened so successfully so I will go
123:23 - back and implement the logging that I
123:25 - was talking about so earlier remember I
123:27 - said if need be we can use logging here
123:30 - and I think it need be not just that
123:33 - it's necessary but I believe it's good
123:36 - practice and it will help me stay ahead
123:37 - of any potential problems that might
123:39 - might occur by telling me exactly where
123:42 - my problem is rather than me having to
123:43 - spend time on troubleshooting so we'll
123:45 - configure that by saying logging basic
123:48 - config level logging info so we'll
123:52 - create a similar put in our utility file
123:56 - so what we'll need is logging we will
124:00 - need this for audio processing I'll copy
124:03 - these as well so space recognition open
124:05 - AI requests OS and I believe that's all
124:08 - we need for now these two actually let
124:12 - me do all of these so if you want to
124:14 - pause and have a look at everything the
124:15 - output here so to make sure that you are
124:17 - on the same page at the moment it might
124:19 - be a bit redundant but I'm trying to be
124:21 - time efficient as well and just making
124:23 - sure that I get everything if there is
124:24 - an extra line here it's not really a
124:26 - major problem for me now as long as as
124:28 - long as I get everything working so back
124:30 - to our function after this has happened
124:32 - I want to get some kind of a message
124:34 - that will confirm this so for that I'm
124:36 - going to say login the info and then
124:38 - just inform converted MP3 to wav and
124:40 - give it a path of where it has happened
124:42 - this will also let me know of the
124:44 - location of my file if for whatever
124:46 - reason I need to see it at that moment
124:48 - we'll whilst we're here we'll do another
124:50 - function and this will be to segment the
124:53 - file so the reason why is only later I
124:55 - realized that open AI has a limit on the
124:58 - size of the file that you can give it to
125:00 - transcribe so the go around method for
125:03 - this the first thing I thought of and by
125:06 - the way there might be me better ways
125:07 - but I don't think it's necessary for the
125:09 - scope of this project so what I do I
125:11 - just split the audio in segmented Parts
125:13 - in small chunks and then transcri
125:15 - transcribe them one by one in smaller
125:17 - parts and once it finishes it comes up
125:19 - as text anyway it's very easy just to
125:21 - join
125:22 - display to the user so it works quite
125:24 - fine so you want to write function split
125:27 - audio and it will again take the path of
125:30 - our converted file and then we'll say
125:32 - the chunk chunk length can be this
125:35 - particular length of
125:37 - milliseconds so we are splitting the
125:39 - entire file divided by so if it's 5
125:42 - minutes it's going to be however many
125:44 - milliseconds in 5 minutes divided by
125:47 - 60,000 and we will say that the chunk
125:49 - path is ch index a no this is the wrong
125:53 - line going back on this we don't need
125:55 - the path we need to actually Define what
125:57 - our chunks are so quick re-edit and we
126:00 - say the chunks is audio and we want to
126:04 - Define that audio above actually so
126:06 - going one line above that we'll say that
126:08 - our audio is audio segment and then from
126:10 - wav and giving it the path of our WAV
126:14 - file now we're going to take this audio
126:15 - variable and do some slicing here so we
126:18 - will take the index plus chunk
126:22 - length for I in range of zero and give
126:25 - it the length of the audio and then pass
126:28 - chunk length Mill seconds and this will
126:30 - return so this will then play the audio
126:34 - physically into smaller segments and
126:36 - then we want to transcribe each
126:37 - individual audio segment so we will
126:39 - create a new function so this will be
126:42 - transcribe audio chunk and then this
126:44 - will take individual chunk and the chunk
126:47 - index and we will give it the path of
126:49 - each individual chunk so we will say
126:52 - that this is chunk and then the chunk
126:54 - index so finally exporting these
126:57 - individual chunks so and giving it the
127:00 - format UAV so with this we will say try
127:04 - open chunk path as audio file so now
127:07 - this needs to travel to our open AI API
127:11 - to get transcribed and we will be using
127:13 - the model called whisper one so I
127:17 - already prepared some code for this and
127:19 - we can just copy paste it if you need to
127:21 - ask after you see the copy paste you can
127:23 - pause the video and make sure you have
127:25 - the same thing so we'll write an
127:27 - exception store it as e and then we will
127:30 - again utilize logging to say that some
127:33 - kind of an error has occurred and then
127:35 - we can actually inform what particular
127:37 - chunk cause the problem by passing the
127:40 - chunk index as the error so we can give
127:43 - it the finally and we can remove all the
127:47 - chunk files so it's just a cleanup of
127:50 - after the processing has finished
127:51 - and we will return the text so we are
127:54 - still working on our transcribing
127:56 - methods so we have written the first two
127:59 - we can minimize them to make this a bit
128:01 - more readable and write our third one so
128:04 - this one will transcribe the wav to text
128:08 - so I can take the path and the
128:11 - chunks here will be the audio of the
128:15 - path of the file full text here it's
128:18 - just an empty variable an empty string
128:20 - as a placeholder and we will write a for
128:22 - Loop saying for I and Chunk in EN
128:26 - numerate so going through all the chunks
128:29 - we'll say that the chunk text and then
128:30 - we will call the previous function of
128:32 - transcribing audio chunk we'll pass
128:35 - chunk file and the chunk index so now we
128:38 - want to make sure that we join in our
128:41 - full text transcription from each
128:43 - individual chunk of the
128:45 - video so we will give chunk TT plus an
128:50 - empty space just a
128:52 - placeholder so after this we can do
128:54 - logging info and just inform what the
128:58 - outcome is so we'll actually see it for
129:00 - example in the terminal here and finally
129:03 - we just want to return the full text and
129:06 - we will use some string manipulation to
129:08 - strip so these are the three methods
129:10 - that we will need to successfully do
129:12 - transcribing of the audio files now we
129:15 - can move on to the last method that we
129:17 - will include in our utility. piy and
129:20 - this will be the one that will provide
129:21 - with the summary of the lyrics so if you
129:25 - remember in our front end we have the
129:27 - extracted lyrics that will display the
129:30 - entire transcription of the audio file
129:32 - and then below it's the summary of the
129:34 - transcribed text so what will provide
129:36 - that summary is what we will do right
129:39 - now so it will be another asynchronous
129:42 - method we'll give it an appropriate name
129:44 - this will take in the parameter of text
129:46 - which will be the entire lyrics or
129:48 - transcription of the audio file and we
129:50 - will take the similar approach like
129:52 - before we will have try and accept and
129:55 - the accept will perform the similar
129:57 - logic as before so you will just perform
130:00 - some error logging and this can just be
130:02 - text that says that some kind of an
130:03 - error has occurred just keeping us know
130:06 - that if there is a particular problem we
130:08 - don't need to do any troubleshooting it
130:09 - will tell us that it was during the text
130:11 - summarization and then this will return
130:13 - something just put summary generation
130:17 - failed that will suffice so in our try
130:20 - we will use something similar for from
130:22 - what we have done before and I'm just
130:25 - going to copy paste this particular
130:27 - response variable so we are
130:29 - communicating with open AI API so the
130:32 - model is chat GPT 3.5 turbo and the
130:36 - prompt is just asking the B API to do an
130:39 - assistant Return of summarizing the
130:42 - following text in one sentence and we
130:44 - are passing the variable of text which
130:45 - if you remember in the parameter of this
130:48 - function is our audio transcription
130:51 - after that in our summary we want to
130:53 - store the response and then just
130:54 - particularly Define choices with index
130:57 - of zero and with the message content and
131:00 - just we want to trip this to make sure
131:03 - that it formats it for us and then we
131:07 - can say loging for and then this can be
131:10 - the generated summary displayed here for
131:12 - us just another way of keeping this good
131:15 - practice and this returns summary so
131:18 - that's all that we need in our. py
131:22 - so with this we can now return to the
131:24 - main py and make sure that all this is
131:26 - imported so the first thing we'll do is
131:30 - write import utility do py sorry not py
131:33 - import utility so now we should be able
131:35 - to use all of the functions that we have
131:38 - defined oh no let me particularly name
131:41 - them so from utility we will import and
131:43 - then we can do all of these functions so
131:46 - it was summarize text transcribe another
131:50 - transcribe split audio and our last one
131:54 - convert mp3 so now we know that we'll
131:57 - have access to all of them and we can
132:00 - now focus on finishing all of our
132:02 - endpoints so if you remember where we
132:04 - left off with the post endpoint for
132:07 - uploading the file so what the user will
132:09 - do from the front end so we gave the
132:11 - location for the WAV file remember this
132:15 - is not some kind of logic that will do a
132:17 - conversion or processing it's just
132:19 - naming the new file and making sure that
132:22 - the extension is no longer MP3 so now we
132:25 - will actually use one of the functions
132:27 - from utility. py that will do the
132:29 - transcription sorry not Transcription
132:31 - conversion so now we can call this
132:34 - function convert mp3 to wav and we will
132:37 - give it the file
132:38 - location and we will now also give it
132:41 - the AV file location then after it's
132:44 - been successfully converted and stored
132:47 - in our converted files folder we want to
132:50 - extract the lyrics so we will use our
132:53 - transcribe function for that and give it
132:56 - the location of our newly converted file
132:59 - and there is no need for us to keep the
133:02 - MP3 file that user has uploaded so we
133:04 - can use OS to actually delete that file
133:07 - so for that we'll give it the file
133:08 - location to our o. remove command now we
133:12 - want to create our summary and for that
133:15 - we can use a weit and do summarize text
133:19 - so this doesn't run in a way that can
133:22 - break the logic so this will await for
133:23 - the previous functions to finish this
133:25 - might take a certain amount of time and
133:27 - there are factors different factors that
133:29 - can differentiate what takes longer or
133:32 - shorter time so for example obviously
133:35 - strer files will not take the same
133:37 - amount of time to create transcriptions
133:39 - so await will make sure that this these
133:42 - tasks are run in a sequential Manner and
133:45 - then lastly we can just return that our
133:48 - lyrics uh lyrics and the summary is
133:51 - variable summary so now we can go to our
133:54 - front end and test some of this
133:57 - functionality so I've just uploaded a
133:59 - random song and clicked the extract
134:01 - lyrics button to see what the output
134:03 - will be and if I go back to my vs code
134:08 - we can see that we successfully
134:11 - delivered this payload to our
134:13 - endpoint and our logging initiated all
134:17 - this information to be shown to us so
134:21 - the backend has successfully done the
134:24 - conversion from MP3 to wav and then you
134:27 - can also see that the backend has
134:28 - successfully executed the. py methods
134:31 - communicated with open ai's API to
134:34 - provide this transcribed text so these
134:36 - are the lyrics from the song that I've
134:38 - uploaded and then there was another call
134:42 - that done has done a prompt to open as
134:46 - API again to create a summary from the
134:47 - previous text and you can see that it's
134:49 - successfully done exact exactly that so
134:52 - now what we trying to do is make sure
134:54 - that we create an image that's inspired
134:57 - by this one sentence and just to make
134:59 - sure I can see that the back end has
135:02 - successfully done everything that I
135:03 - wanted but I want to see has it all been
135:05 - displayed accordingly to my front end
135:07 - and uh as you can see it has exactly how
135:10 - we expected it in the extracted lyrics
135:12 - box we see the lyrics from the song that
135:14 - I uploaded and then in the summary we
135:16 - see our sentence again so the final
135:19 - missing bit now is to create an image
135:21 - that's inspired by the summary of the
135:23 - transcribed text so for that we will
135:25 - create a new endpoint and this one will
135:28 - be generate image again it's a
135:31 - asynchronous method and we'll call it
135:34 - generate image and it will take the
135:37 - lyrics payload so again we will use the
135:40 - try and accept exception struct so first
135:45 - for how we will actually try to generate
135:47 - this image we need to use our API key so
135:50 - just just like previous we are using OS
135:53 - and getting the environment variable and
135:55 - this is called open I API and then just
136:00 - to make sure that we have some
136:02 - troubleshooting logic if something goes
136:04 - wrong as this is common and good
136:06 - practice we will write that in case our
136:10 - program is not able to access our API
136:12 - key or if the API key variable is null
136:15 - then we will say logging error Pi key
136:19 - not access able found not found and we
136:23 - can raise an HTTP exception with a
136:26 - status code 500 and give it the same um
136:30 - same detail so we can say just copy
136:33 - paste this wasn't found so now we can do
136:38 - the URL for the open AI image generation
136:42 - and uh I'm just going to copy paste this
136:44 - online you can Google this so once we
136:48 - have that link I want to take this
136:49 - approach in my headers I'm going to pass
136:51 - the API key and uh again I have this
136:55 - documentation written in front of me so
136:56 - I'm going to copy paste this part too so
137:00 - what's going on here is that we are
137:01 - passing the API key as a part of our
137:03 - header and that's the way open will
137:05 - verify that we have access to the API
137:08 - features so for the prompt we can do an
137:12 - F string and say that we want so keep in
137:16 - mind as well you can modify this you can
137:18 - write this the best way you think will
137:21 - fit your project or to be honest most
137:23 - likely you can Tinker around with this
137:25 - and create a better prompt than what I'm
137:27 - about to do because I've already tested
137:29 - this and the outputs are just very not
137:32 - artistic to say the least so I'm just
137:35 - going to WR create an image based on
137:37 - this summary of a song maybe something
137:42 - like that I don't know you try playing
137:44 - around with it a little bit more if you
137:46 - want a more quality product but we are
137:49 - here to demonstrate how an architecture
137:52 - like this is implemented so we want to
137:54 - make sure that we don't get any errors
137:56 - in terms of either are limits for open
137:59 - ai's API how they can process a certain
138:01 - amount of text so we will try to say
138:03 - that if the length of this prompt is
138:05 - greater than 1,000 characters then we
138:08 - will just truncate it and we will do
138:11 - prompt and then slice everything above
138:14 - above 1,000 so just to make sure that
138:17 - the image that arrives is within some
138:19 - acceptable menion parameter we'll say
138:23 - that is prompt the size of the image and
138:27 - this is relatively arbitrary but feel
138:29 - free to play around with these
138:31 - Dimensions If this means anything to you
138:33 - but I'm quite happy with these
138:35 - dimensions and we won't just one picture
138:38 - that suffice so again trying to keep up
138:40 - with the good practice of logging the
138:43 - information we can do an FST string and
138:46 - communicate to our server saying that we
138:48 - are sending the request to open AI my
138:51 - API with the following data we can
138:53 - include the data so we can see actually
138:55 - what we sent the prompt with and then we
138:58 - will store the response and say that
139:01 - it's the request post and then we'll
139:03 - pass the URL headers will be headers and
139:07 - the Json will be data so this is what we
139:10 - are creating our quest with these
139:13 - parameters and then storing the response
139:15 - that comes in the response variable
139:17 - again we want to do some logging and we
139:19 - will say that open AI API response
139:23 - status is and then we can pass the
139:26 - response. status code and we can also do
139:30 - logging info so more loging for response
139:34 - content so we will actually show all of
139:37 - that in the terminal here as the server
139:40 - is running and we'll do raise for status
139:44 - so the image we want to store it and say
139:47 - that it's response. Json so in our data
139:51 - list zero and we extract the URL so the
139:56 - Inon is URL here so we'll do a get
139:59 - request for that and again we'll do
140:02 - image response rates for status so then
140:05 - we want to now show that image as in l
140:08 - in our front end so we will say that
140:11 - image open and then we'll use bytes iio
140:15 - which response content and we want to
140:18 - use a similar approach before we did
140:20 - with creating that directories in case
140:22 - they're not there so we'll say that if
140:26 - this particular folder does not exist
140:29 - then we will use OS to actually make
140:32 - create that folder here and our image
140:34 - path being os. path join and we will use
140:38 - media and generated image PNG so this
140:42 - will be the name for our image you can
140:44 - if for whatever reason want this to be
140:46 - different change that and have it called
140:49 - whatever you want it really so we want
140:52 - to save the image as the image path and
140:55 - just to know that everything went fine
140:58 - here we can do some logging and say we
141:00 - do an F string that image was saved at
141:03 - and give it the file path and lastly we
141:06 - return an object that will say that the
141:08 - image path is and then the variable of
141:11 - image path I believe that's pretty
141:13 - self-explanatory then so we want to
141:16 - write some smart code so we'll do accept
141:19 - requests start exceptions Quest
141:22 - exception as error and then in our
141:25 - loging we can pass that and say that
141:27 - request exception was the variable e
141:30 - which will be which will call the error
141:33 - that has happened and we want to raise
141:35 - an HTTP exception and we'll give it the
141:38 - status code 500 the detail of error and
141:42 - we just want to make sure that it's a
141:43 - string so I had some issues before with
141:46 - this data being not the appropriate data
141:48 - type so just want to preemptively put
141:50 - that there and the last thing that we
141:52 - need to display our image I'm going to
141:55 - show you in our front end so as you can
141:58 - see the here this code with Ajax is
142:00 - going to do a post request to generate
142:03 - an image with the summary so as a prompt
142:06 - and then upon success what we want to do
142:09 - is then actually get fetch that image so
142:13 - in order to show it we need to
142:14 - communicate with our endpoint media
142:17 - generated image.png and that's something
142:19 - that does not exist yet so that'll be
142:21 - the last thing that we need to do is to
142:23 - create a new get end point and we'll
142:26 - call it generated. PNG and this will be
142:30 - another asynchronous method we'll call
142:32 - it give it an appropriate name and all
142:35 - that this will do is return the file
142:38 - which will be the image that we have
142:40 - just generated so this will go into the
142:42 - media folder and fetch the image and
142:46 - that should be all for our project so
142:50 - now we can do some unit testing so going
142:53 - to our front end I'm going to choose a
142:56 - completely random song from my computer
142:59 - I know it's in English language so we
143:01 - will do extract lyrics looking in my vs
143:05 - code we can see that our logging utility
143:07 - is working fine and giving us
143:09 - information that the conversion from MP3
143:12 - to wav has started and when I look into
143:16 - my converted files I can see that song
143:18 - is actually there so as you can see the
143:22 - back end has successfully transcribed
143:23 - the text and it looks exactly like the
143:26 - lyrics of this particular song and also
143:30 - then the second aspect of our back end
143:32 - has requested this summary this text
143:37 - describes a sense of determination
143:39 - resilience and strength in the face of
143:40 - challenges with a focus on survival and
143:43 - perseverance through difficult times I'm
143:45 - happy with that so now we want to create
143:47 - an image and we see that we got an error
143:50 - so so something is wrong with this
143:52 - particular aspect we do not have our
143:54 - image yet so we will do some
143:56 - troubleshooting and try to find why has
143:59 - this happened so I can see a typo if we
144:02 - go to our endpoint here it's not
144:04 - supposed to be generate image but rather
144:07 - generate underscore image so we'll save
144:12 - and try doing it again so I have the
144:15 - same song there I'm I'm just going to
144:17 - click extract lyrics so the same lyrics
144:19 - will show up here but what I'm expecting
144:21 - now is that with the generated image
144:23 - there will be some kind of an image
144:25 - produced by open AI charp that will be
144:29 - based on this particular summary and
144:31 - looking at the vs codes terminal I can
144:34 - see now that it actually has executed
144:36 - the post request successfully so as you
144:39 - can see here the logging command has
144:42 - given us this information that the
144:44 - prompt has included the summary and the
144:47 - other parameters that we defined so
144:49 - everything went fine here we have to
144:50 - status 200 and the content then being
144:53 - the link of the image so everything here
144:55 - looks fine so now when I go back to my
144:57 - front end I should be able to see this
144:59 - uh piece of artwork and U this is what
145:02 - he gave us I don't know how is this
145:03 - inspired by this particular summary that
145:06 - you see here this is bloody awful but
145:08 - hey it's not me it's the the current
145:11 - state of the art isn't it let's try and
145:14 - see maybe if we modify the prompt can we
145:16 - get something more consistent with the
145:18 - actual summary so previously The Prompt
145:21 - was generate an image based on the
145:22 - summary of a song and then we passed
145:25 - actual lyrics maybe we shouldn't do
145:27 - lyrics we should do the actual summary
145:29 - so let me try maybe writing a better
145:31 - prompt here so I'm going to write
145:33 - something like I have a song and I will
145:37 - summarize the lyrics from this song I
145:42 - want you to generate a beautiful art
145:47 - based on this summary here is my summary
145:51 - of the text so let's see does this
145:53 - change anything I'm not really an expert
145:56 - for this type of prompt engineering
145:58 - especially for creating something
145:59 - artistic that's probably the exact
146:01 - opposite of what I feel I have some kind
146:03 - of a talent for but nevertheless we
146:06 - shall try so I will try and use the
146:09 - exact same song just to be able to
146:12 - compare so this is our previous one and
146:15 - um let's see has our new prompt made any
146:18 - type of an improvement so once again
146:20 - just going back to our back end so you
146:22 - can see that all of the logging is doing
146:24 - its thing there so we can follow along
146:26 - how this process is sequentially
146:28 - happening wow this is even worse so my
146:32 - prompt has made it uh considerably worse
146:35 - so when it comes to Art this is
146:37 - definitely not producing the best
146:38 - results and just for fun I want to try
146:41 - and see how this same prompt will
146:44 - perform in ch gpt's new model so as a
146:48 - tangent to this project we will actually
146:51 - take the exact same prompt copy it and
146:54 - check it in that GPT so I think it'll be
146:57 - quite funny to see the massive
146:58 - difference between the model that we are
147:00 - using here so this definitely needs a
147:02 - much better model rather than this
147:07 - particular one that my API is
147:09 - communicating with here I leave that
147:11 - part up to you and just to demonstrate
147:14 - what kind of a difference it can make
147:16 - please have a look at the image that CH
147:19 - GP
147:20 - 40 has created from the exact same
147:24 - prompt I think this is actually
147:26 - hilarious so the difference is
147:28 - substantial from this I don't even know
147:32 - what to call this previous one but as
147:35 - you can see I did a direct copy paste of
147:37 - the exact same prompt and please read
147:40 - the summary and then look at the picture
147:43 - I feel like wow this actually did create
147:46 - a very fitting for the song So as you
147:48 - can see if you think around and
147:50 - Implement a better model for this
147:52 - particular part of this project you can
147:54 - get considerably better results I'll
147:56 - leave that autistic aspect up to you
147:58 - this particular tutorial you've seen how
148:01 - to implement this architecture and there
148:04 - is plenty of room for improvement upon
148:06 - your own personal preferences today we
148:08 - will build this particular web app
148:11 - you'll be able to upload any image that
148:13 - has text on it and have the text
148:15 - extracted from the image directly onto
148:18 - the page so it will be displayed here so
148:20 - we'll test the app right now I'm going
148:23 - to upload a picture we click extract so
148:26 - this was the picture that I uploaded
148:28 - this was just randomly Googled and as
148:31 - you can see the text is extracted and it
148:33 - appears for the user right above so
148:37 - without further Ado let's start building
148:39 - this
148:40 - app the first thing you want to do is
148:42 - navigate to my GitHub I'll leave the
148:45 - link in the description and you can find
148:50 - find this particular repo we will get
148:52 - the link for it and we can move on into
148:55 - our vs so we will open just open a brand
148:59 - new folder do kit clone paste that link
149:03 - and we can start building together from
149:06 - this exact file system so you can see a
149:09 - couple of files already there and we
149:12 - have to discuss a couple of things that
149:15 - you need before you can run this project
149:18 - so the first things first let's install
149:21 - everything that python needs to run this
149:23 - good practice is to create your own
149:25 - virtual environment so none of your
149:28 - dependencies Clash and we will do that
149:31 - so in this particular folder can
149:33 - navigate in our working folder we can
149:35 - create a new environment so we can say
149:37 - Python and this should create a new
149:40 - environment for
149:41 - us I'll navigate to power shell but you
149:45 - can activate this any way you really
149:48 - want the inash or power
149:50 - sh so going into to activate it we want
149:54 - to go a second to see we want to go into
149:57 - the script folder now we want to go into
150:00 - VNV first and then scripts so here if we
150:04 - type in activate. PS1 we can activate
150:08 - our environment and as you can see now
150:10 - there's this prefix with the exact name
150:11 - of my environment meaning that now we
150:13 - have activated our environment so just
150:16 - to reiterate for those of you that
150:18 - haven't done this before you type in
150:20 - this particular command to create a
150:23 - virtual environment so this is the
150:25 - command after you run this you navigate
150:27 - into the scripts folder and there you
150:29 - activate by typing in this do/ activate.
150:34 - PS1 so now we will install the
150:38 - pendencies that we need for our project
150:39 - and you can see in this requirements.txt
150:41 - you have everything listed here so you
150:44 - can just type in want to make sure that
150:45 - we are in the main folder again so we
150:48 - will go back and now we can type in PIP
150:51 - install our
150:53 - requirements.txt and this will install
150:56 - all the dependencies that we need for
150:57 - this project lastly we need to discuss
151:00 - how we will be implementing the AI
151:02 - aspect of this web app so we're going to
151:05 - be using p SCT and now we have installed
151:08 - the python wrapper for it but we also
151:10 - need to install the proprietary software
151:12 - and run it on on our
151:14 - machine and the way to do that if you're
151:17 - go into read me I've written some basic
151:19 - explanation
151:20 - on how to do that so we need to install
151:24 - this python rapper we have just done
151:26 - that so that was us installing with Pip
151:28 - but we also need to install this so
151:31 - navigate to this link and install
151:34 - Tesseract for Windows without this you
151:37 - won't be able to run the
151:39 - program I will include the link for this
151:41 - as well in the description but anyone
151:43 - can just Google Tesseract for Windows
151:46 - installation and it will give you the
151:47 - download option and as soon as it's
151:50 - installed that's it you're ready to go
151:52 - with all the requirements met you can
151:54 - start building this project next thing
151:56 - we want to do is to make sure that we
151:59 - can run our flask app so we will just
152:02 - prepare the layout for our web app and
152:05 - we can discuss then one by one what goes
152:07 - in which file you will see that as soon
152:09 - as you did git clone you already got
152:12 - this config.py I don't think there is
152:14 - much necessary to discuss here this is
152:16 - just the configuration file for our
152:18 - flask app and you can basically just use
152:20 - it the same way how you see it here here
152:23 - only thing you want want to do different
152:25 - is Define the
152:27 - upload folder the uploads file path for
152:30 - yourself so if you remember our app had
152:33 - an option to upload image that will then
152:37 - be giving the text extracted to the
152:40 - display so this will be the folder where
152:42 - those images get uploaded to so you can
152:45 - choose any folder in your documents it's
152:47 - entirely up to you other than that I
152:50 - don't think there's anything necessary
152:51 - to discuss in regards to the config.py
152:55 - page moving on we want to create a
153:00 - app.py and this will be the main file
153:03 - that actually runs our
153:06 - app and all it is all it's going to say
153:10 - from App import app so this will go into
153:13 - the app folder this one here where we
153:15 - will have all the files for our web app
153:18 - and it will just import that into our
153:20 - file here the one that runs back end and
153:24 - we'll say that if name isore main then
153:28 - we just want to run our app that's all
153:30 - we are going to do with this and we will
153:33 - create another file here where we will
153:36 - write the logic for the AI processing
153:40 - but we're going to leave this empty for
153:41 - now and then if you navigate into your
153:44 - app folder you'll see that you have
153:47 - another two you have two subfolders
153:50 - static and templates in the templates
153:53 - you will see
153:54 - index.html if you open that you will see
153:57 - that there is already pretty much
153:58 - everything done here the reason why most
154:01 - of this is already completed is that I
154:04 - didn't want to focus this particular
154:05 - tutorial on building front end even
154:08 - though we will discuss this front end so
154:11 - that you understand every L of code here
154:13 - so I will guide you through it but I
154:16 - didn't think it would be necessary uh it
154:18 - will be kind of waste of time time to
154:20 - discuss every single aspect of this
154:22 - especially talking about CSS and stuff
154:25 - it's not the purpose of this video and
154:27 - then in the static you will see that you
154:29 - have two subfolders images and uploads
154:32 - and this will just manage when we want
154:34 - to upload a picture one of them will go
154:37 - into this particular folder called
154:39 - uploads so as you saw earlier this was
154:41 - the picture that I use for test so it
154:43 - naturally end up being uploaded into
154:45 - this folder and in the images here I'm
154:49 - just using
154:50 - the logo from my channel this is
154:52 - something you can for the sake of just
154:54 - practicing and building the same app you
154:56 - can use this you don't have to can put
154:57 - anything you want here or you can ignore
154:59 - it entirely you can delete this one
155:01 - that's entirely up to you but that's the
155:03 - brief explanation of our folder
155:04 - structure and with that being said we
155:06 - can start building our app so what we're
155:10 - going to do first is we're going to do
155:13 - the backend logic of our AI processing
155:16 - of the image so we just installed the
155:18 - tesser ACT and we can start writing the
155:22 - code for that so this will be our AI
155:25 - model that will take an image as an
155:27 - input and give text as output this is
155:30 - just a brief explanation for it so we'll
155:33 - get an image as an input and the output
155:35 - coming out will be a string derived
155:37 - directly from the actual image so we
155:39 - want to start by importing our libraries
155:43 - but n as NP and to manage images we will
155:48 - import this and just change this back to
155:51 - import so we want to specify the path to
155:54 - the Tesseract
155:56 - executable so earlier I mentioned to you
155:59 - that you have to download the Tesseract
156:02 - software their proprietary
156:04 - software and the way to do that is by
156:07 - going onto the GitHub link when you find
156:10 - the installer the windows installer and
156:12 - once the installation is finished you
156:15 - want to get the path and copy it into
156:17 - this particular variable so most likely
156:21 - it'll be the same as you see it here if
156:24 - it's not you might have to do some
156:25 - tinkering and find this exact file so
156:29 - this is needed for the program to run
156:32 - you want to save this file path into
156:34 - this variable so we'll write a function
156:36 - that will extract the text parameter for
156:39 - it will be the file path of the image
156:42 - file and it will return a string so like
156:45 - we said the a model will take an image
156:47 - as an input so that's the image path and
156:51 - the output being a string type that's
156:53 - this bit here so we want to say that
156:56 - image will use the image library from p
157:01 - and it will open the image path so the
157:03 - variable p in our
157:05 - method and then TCT will do its magic
157:09 - and do image to string from image we
157:13 - want to remove symbols and split by
157:15 - lines for better display so this is just
157:19 - for read readability and I've actually
157:21 - produced this just by wearing chat GP
157:24 - what characters could kind of be
157:25 - problematic in that sense so to manage
157:30 - then this particular idea we want to
157:34 - write this line here moving on we're
157:37 - going to create some distance once again
157:40 - we are with these last last three lines
157:42 - of code we are just working on creating
157:45 - readability in our output and this will
157:48 - just split the lines with a break so if
157:50 - you remember from like python Basics
157:51 - this n character here will create it's
157:54 - like a space line to create some
157:56 - Division and then finally we want to
157:58 - just return text lines so this will be
158:01 - the string
158:03 - output so that's all this Library pretty
158:06 - much does everything for you and that's
158:08 - how simple the AI aspect of it is and we
158:11 - want to try and test this now and see if
158:13 - this runs properly so we're going to say
158:16 - test and run by saying image PA and we
158:19 - want to give the path of the image so I
158:22 - might just use the one that I had here
158:26 - again so I will go and copy let's try
158:29 - copying relative path so we will give it
158:32 - the path I believe I need to change
158:34 - these to forward sls2 just want to test
158:38 - this and make sure that I'm actually
158:41 - printing this so if we do python ml.
158:46 - Prime yes it gives me the correct path
158:48 - to the the image as we can see so it's
158:52 - always good to test these things before
158:53 - you actually run your program or
158:55 - something like that uh you catch errors
158:59 - before they become too much to handle so
159:02 - we will then that the extracted text is
159:05 - and then we want to run our function
159:06 - that we just defined here so we can just
159:09 - call the function and give it the
159:11 - parameter of our image path which was
159:15 - this so if we give it that and then we
159:19 - want to just show our extracted text so
159:22 - we can print this particular
159:25 - variable so the instructed text is and
159:30 - then we can just give it a variable so
159:32 - if we try running this now Arrow so I've
159:36 - just changed the way how the path is
159:38 - given so we want to delete this bit and
159:42 - we'll just give it a DOT to say from the
159:44 - current file from the current directory
159:47 - go into app and and I believe this is
159:50 - all we need to
159:51 - do so if we run now we see that we get
159:55 - the extracted text in this particular
159:59 - string so this works now and that's all
160:03 - we needed for our back we can comment
160:06 - this out and move
160:10 - on next thing we want to do is go into
160:13 - our app folder and we will open
160:17 - templates just to discuss the front end
160:20 - aspect so like we said we will not write
160:23 - this code from scratch I don't think
160:25 - it's necessary for this particular
160:27 - project we can just discuss that it's
160:30 - it's just a HTML page with some CSS and
160:33 - bootstrap that's all it is using this
160:35 - particular boost trrap there is some CSS
160:38 - that will just give some aesthetic
160:41 - aspects but nothing too complicated you
160:44 - can examine this on your own and play
160:47 - around with it if you choose though so
160:50 - closing the CSS aspect we can just talk
160:52 - about what's in the body of the HTML so
160:56 - we have our upload image button and upon
160:58 - submission there is some logic some
161:01 - templating templating that handles how
161:04 - once the image has been processed and we
161:07 - have our text in the form of a string
161:10 - this is just some templating that will
161:12 - handle how it's being displayed and
161:15 - that's pretty much all that it is so
161:17 - without talk if we open this by itself
161:21 - so if you open this by itself just as a
161:23 - file you can see how it looks like I
161:25 - said the upload image element with the
161:28 - browse option for selecting the image
161:30 - the button to extract and then once we
161:33 - receive the output when now backend
161:35 - processes the AI code we have just
161:37 - written it will be formatted here and we
161:40 - want to also display the image that we
161:42 - got the text from so with the front and
161:47 - being sorted like that we can now move
161:48 - on to building our flask app which I
161:51 - believe is the most important part of
161:52 - this video so as you saw the actual AI
161:55 - itself we have tesser doing all the work
161:57 - for us it's a very simple function it
162:00 - just does all the work we don't really
162:03 - have to do more than that so we want to
162:06 - now build our flask app so the first
162:08 - thing we do is we'll create two new
162:11 - files I'll call it views. pi and the
162:14 - other one called init with two
162:17 - underscores like such so in this init
162:20 - file we want to import flask and we want
162:23 - to say that our app is flask and then
162:26 - for the configure file we will use the
162:28 - file that you got just from the git repo
162:32 - so we'll say from object and then we
162:35 - will name this file config development
162:38 - config like such and we will also import
162:42 - views and that's it that's all you need
162:45 - so the last thing that we need to do to
162:47 - finish off our web app is is to write
162:50 - the backend logic in our view section so
162:53 - again we want to import plk an app and
162:56 - we want to request render template and
162:59 - URL 4 we also want to import OS to
163:02 - handle files I have this recommendation
163:05 - from chat GPT to use this particular
163:09 - Library as a method of dealing with
163:12 - files when changing or modifying file
163:15 - names so we will move on with that we
163:17 - also want to include your typical numpy
163:21 - SNP we again need p and image random
163:25 - string and we want to import our
163:30 - function that we built we want to add
163:33 - the path to config so we'll say that app
163:36 - config is initial file uploads and we
163:41 - will give it a path so for us that's in
163:44 - our static and we'll write our rout to
163:47 - the homepage the only page that we will
163:50 - be using for our web app and it will
163:53 - include methods both get and post so I
163:56 - am assuming that at this stage you are
163:59 - familiar to at least the basics of HTTP
164:03 - protocol and specifically the four
164:06 - requests that you can make get post
164:09 - delete so kind basics of your crowd
164:12 - systems we stand for create read update
164:17 - delete if this line here means
164:21 - absolutely nothing to you I would
164:24 - suggest finding a dedicated video for
164:27 - this particular reason if you want a
164:29 - good understanding of what we are doing
164:32 - here you would necessarily need to
164:34 - completely understand this just to
164:37 - finish off this web app finish off this
164:39 - project but I do highly recommend so
164:42 - that being said we're going to move on
164:45 - and write our index function and this
164:49 - this will now handle the flow of data so
164:53 - we'll say that the full file name is URL
164:55 - for static and the file name is in the
164:59 - images so that's where we'll be storing
165:02 - and then we want to say if image upload
165:05 - is not empty so we will say if request.
165:09 - method is post that's what we want to
165:12 - handle first then we want to define the
165:14 - image upload to be the request files of
165:19 - image
165:20 - upload so what we're doing here is
165:22 - saying that if there is a post request
165:25 - it expects a file in the payload of that
165:29 - post request and that file will then be
165:31 - stored in the variable image upload so
165:35 - if you go back to what our web app
165:38 - looked once the user clicks browse once
165:40 - they choose the image they want the text
165:42 - extracted from that image will go here
165:44 - into this image upload variable so we
165:47 - want to save the file now we're going to
165:49 - to use the secure file name and say that
165:51 - image upload. file name and then we want
165:54 - to define the file path using the OS
165:58 - join with app config initial file
166:01 - initial file uploads comma file name
166:04 - we'll say that image upload save in the
166:08 - file path so now we want to use the
166:11 - Tesseract app and we'll just use the
166:13 - method we created in our
166:17 - MLP so we want to call call this
166:20 - particular method now and pass it image
166:23 - that got uploaded so we will say that
166:25 - the extracted text is the function so we
166:29 - are calling this function right now if
166:31 - you remember earlier we wrote this line
166:34 - here and this line invokes the usage of
166:38 - this particular function from our ml. P
166:40 - file so we will pass the file path for
166:45 - the image and we want to have the image
166:47 - URL four static we'll give it the file
166:50 - name uploads plus file name and in our
166:55 - return we want to render the template
166:57 - that will be displayed so we want to
167:00 - render the template of our HTML file
167:02 - that earlier we were looking at so it's
167:05 - this particular HTML file and we'll say
167:09 - that the URL is image URL and the full
167:12 - file name is file path and the text is
167:16 - extracted extracted text
167:19 - so we need to pass this back onto our
167:22 - front end and this covers any post
167:26 - request coming towards this
167:28 - endpoint so we have defined this
167:30 - endpoint we mentioned that it will
167:34 - handle get and post requests and the
167:37 - first thing find in our conditional
167:39 - statement here is what happens if there
167:41 - is a post request coming this is the
167:45 - logic for the Post request and our
167:48 - return statement will finish uh
167:51 - processing of our post request but else
167:54 - we want to handle a get request and we
167:57 - will again give the HTML template we
167:59 - want to give file name is full file name
168:02 - and lastly this is just the standard for
168:05 - flask apps just going to copy paste this
168:08 - bit main function for our flask app and
168:12 - you want to write this if double uncore
168:14 - name double uncore is main app. run
168:16 - debug equals true and that's all we need
168:19 - to do so let's try running our app now
168:25 - so I'm going to type in me open this a
168:27 - bit more so we want to write Python
168:31 - app.py and we can see that our app is
168:34 - running live on our Local Host Port
168:39 - 5,000 so we will open our browser and we
168:42 - will type in Local Host give it a 5,000
168:45 - port and you can see that we have our
168:47 - front end but let's see does it work
168:50 - with the back end so I'm choosing again
168:54 - that image I'm clicking extract and the
168:57 - image is displayed with the text above
169:00 - so everything works as intended and this
169:02 - is our
169:03 - app I hope you enjoyed it and and that's
169:07 - all the first thing you want to do is
169:09 - navigate to my GitHub I'll leave the
169:12 - link in the description and you can find
169:17 - this particular repo
169:19 - we will get the link for it and we can
169:21 - move on into our vs so we will open just
169:26 - open a brand new folder do kit clone
169:29 - paste that link and we can start
169:31 - building together from this exact file
169:35 - system so you can see a couple of files
169:38 - already there and we have to discuss a
169:40 - couple of things that you need before
169:43 - you can run this project so the first
169:46 - things first let's install everything
169:48 - that python needs to run this good
169:50 - practice is to create your own virtual
169:53 - environment so none of your dependencies
169:56 - Clash and we will do that so in this
169:58 - particular folder we can navigate now
170:01 - working folder we can create a new
170:03 - environment so we can save Python and
170:06 - this should create a new environment for
170:08 - us I'll navigate to Powershell but you
170:11 - can activate this any way you really
170:14 - want the inash or Powers
170:16 - shell so going in to to activate it we
170:20 - want to go a second to see we want to go
170:23 - into the script folder now we want to go
170:26 - into VNV first and then scripts so here
170:30 - if we type in activate. PS1 we can
170:34 - activate our environment and as you can
170:35 - see now there's this prefix with the
170:37 - exact name of my environment meaning
170:39 - that now we have activated our
170:41 - environment so just to reiterate for
170:43 - those of you that haven't done this
170:44 - before you type in this particular
170:47 - command to create a virtual environment
170:51 - so this is the command after you run
170:53 - this you navigate into the scripts
170:54 - folder and there you activate by typing
170:58 - in this do/ activate.
171:01 - PS1 so now we will install the
171:04 - pendencies that we need for our project
171:06 - and you can see in this requirements.
171:08 - dxt you have everything listed here so
171:10 - you can just type in want to make sure
171:12 - that we are in the main folder again so
171:14 - we will go back and now we can type in
171:18 - pin
171:19 - our
171:20 - requirements.txt this will install all
171:22 - the dependencies that we need for this
171:24 - project lastly we need to discuss how we
171:27 - will be implementing the AI aspect of
171:30 - this web app so we're going to be using
171:32 - py SCT and now we have install the
171:35 - python wrapper for it but we also need
171:37 - to install the proprietary software and
171:39 - run it on on our
171:41 - machine and the way to do that if you're
171:43 - going to read me I've written some basic
171:46 - explanation on how to do that
171:49 - so we need to install this python
171:51 - wrapper we have just done that so that
171:53 - was us installing with Pip but we also
171:55 - need to install
171:57 - this so navigate to this link and
172:01 - install Tesseract for Windows without
172:04 - this you won't be able to run the
172:07 - program I will include the link for this
172:09 - as well in the description but anyone
172:11 - can just Google testera for Windows
172:13 - installation and it will give you the
172:15 - download option and as soon as it's
172:18 - installed that's it you're ready to go
172:19 - with all the requirements met you can
172:22 - start building this project the next
172:23 - thing we want to do is to make sure that
172:26 - we can run our flask app so we will just
172:29 - prepare the layout for our web app and
172:32 - we can discuss then one by one what goes
172:35 - in which file you will see that as soon
172:37 - as you did git clone you already got
172:39 - this config.py I don't think there is
172:41 - much necessary to discuss here this is
172:43 - just the configuration file for our
172:45 - flask app and you can basically just use
172:48 - it the same way how you see it here here
172:50 - only thing you might want to do
172:52 - different is Define the
172:54 - upload folder the upload file path for
172:57 - yourself so if you remember our app had
173:00 - an option to upload image that will then
173:03 - be giving the text extracted to the
173:07 - display so this will be the folder where
173:09 - those images get uploaded to so you can
173:11 - choose any folder in your documents it's
173:13 - entirely up to you other than that I
173:16 - don't think there's anything necessary
173:18 - to discuss in regards to the config.py
173:21 - page moving on we want to create a
173:26 - app.py and this will be the main file
173:29 - that actually runs our app and all it is
173:33 - all it's going to say from App import
173:36 - app so this will go into the app folder
173:39 - this one here where we will have all the
173:41 - files for our web app and it will just
173:43 - import that into our file here the one
173:46 - that runs backend and we'll say that if
173:49 - name is double uncore main then we just
173:53 - want to run our app that's all we are
173:55 - going to do with this and we will create
173:58 - another file here where we will write
174:01 - the logic for the AI processing but
174:05 - we're going to leave this empty for now
174:06 - and then if you navigate into your app
174:09 - folder you will see that you have
174:11 - another two you have two subfolders
174:14 - static and templates in the templates
174:17 - you'll see in
174:19 - index.html if you open that you will see
174:21 - that there is already pretty much
174:23 - everything done here the reason why most
174:25 - of this is already completed is that I
174:28 - didn't want to focus this particular
174:29 - tutorial on building front end even
174:32 - though we will discuss this front end so
174:35 - that you understand every line of code
174:37 - here so I will guide you through it but
174:40 - I didn't think it would be necessary uh
174:42 - it will be kind of waste of time to
174:44 - discuss every single aspect of this
174:46 - especially talking about CSS and stuff
174:49 - it's not the purpose of this video and
174:51 - then in the static you will see that you
174:53 - have two subfolders images and uploads
174:56 - and this will just manage when we want
174:58 - to upload a picture one of them will go
175:01 - into this particular folder called
175:03 - uploads so as you saw earlier this was
175:06 - the picture that I used for test so it
175:08 - naturally ended up being uploaded into
175:10 - this folder and in the images here I'm
175:14 - just using the logo from my channel this
175:17 - is some you can for the sake of just
175:19 - practicing and building the same app you
175:21 - can use this you don't have to can put
175:23 - anything you want here or you can ignore
175:24 - it entirely you can delete this one
175:26 - that's entirely up to you but that's the
175:28 - brief explanation of our folder
175:29 - structure and with that being said we
175:32 - can start building our app so what we're
175:35 - going to do first is we're going to do
175:38 - the backend logic of our AI processing
175:41 - of the image so we just installed the
175:44 - tesser act and we can start writing the
175:47 - code for for that so this will be our AI
175:50 - model that will take an image as an
175:52 - input and give text as output this is
175:56 - just a brief explanation for it so we'll
175:58 - get an image as an input and the output
176:00 - coming out will be a string derived
176:02 - directly from the actual image so we
176:04 - want to start by pting our libraries for
176:08 - n as NP and to manage images we will
176:13 - import this and just change this back to
176:15 - import so we want to specify the path to
176:18 - the Tesseract
176:20 - executable so earlier I mentioned to you
176:23 - that you have to download the Tesseract
176:27 - software their proprietary
176:29 - software and the way to do that is by
176:32 - going onto the GitHub link when you find
176:35 - the installer the windows installer and
176:37 - once the installation is finished you
176:39 - want to get the path and copy it into
176:42 - this particular variable so most likely
176:46 - it'll be the same as you see it here
176:48 - here if it's not you might have to do
176:50 - some tinkering and find this exact file
176:54 - so this is needed for the program to run
176:57 - you want to save this file path into
176:59 - this
177:00 - variable so we'll write a function that
177:02 - will extract the text parameter for it
177:05 - will be the file path of the image file
177:08 - and it will return a string so like we
177:10 - said the a model will take an image as
177:12 - an input so that's the image path and
177:16 - the output being a string type that's
177:18 - this bit here so we want to say that
177:21 - image we'll use the image library from p
177:25 - and it will open the image path so the
177:28 - variable past in our method and then TCT
177:33 - will do its magic and do image to string
177:36 - from image we want to remove symbols and
177:39 - split by lines for better display so
177:43 - this is just for readability and I've
177:45 - actually produced this just by wearing
177:48 - chat GPT what characters could kind of
177:51 - be problematic in that sense so to
177:55 - manage then this particular idea we want
177:59 - to write this line here moving on we're
178:03 - going to create some distance once again
178:06 - we are with these last last three lines
178:08 - of code we are just working on creating
178:10 - readability in our output and this will
178:13 - just split the lines with a break so if
178:15 - you remember from lithan Basics this
178:18 - character here will create it's like a
178:20 - space line to create some
178:22 - Division and then finally we want to
178:24 - just return text lines so this will be
178:27 - the string
178:29 - output so that's all this this Library
178:32 - pretty much does everything for you and
178:34 - that's how simple the AI aspect of it is
178:37 - and we want to try and test this now and
178:39 - see if this runs properly so we're going
178:41 - to say test and run by saying image path
178:46 - and we want to give the path of the
178:47 - image image so I might just use the one
178:51 - that I had here again so I will go and
178:55 - copy let's try copying relative path so
178:59 - we will give it the path I believe I
179:01 - need to change this to forward sles two
179:05 - just want to test this and make sure
179:07 - that I'm actually printing this so if we
179:11 - do python ml. Prime yes it gives me the
179:15 - correct path to the image as we can see
179:19 - so it's always good to test these things
179:21 - before you actually on your program or
179:22 - something like that uh you catch errors
179:26 - before they become too much to handle so
179:29 - we will then that the extracted text is
179:32 - and then we want to run our function
179:34 - that we just defined here so we can just
179:36 - call the function and give it the
179:38 - parameter of our image path which was
179:42 - this so if we give it that and then we
179:46 - want to just show our extracted text so
179:50 - we can print this particular
179:53 - variable so the extracted text is and
179:58 - then we can just give it a variable so
180:00 - if we try running this now go Arrow so
180:04 - I've just changed the way how the path
180:06 - is given so we want to delete this bit
180:09 - and we'll just give it a DOT to say from
180:12 - the current file from the current
180:14 - directory go into app and I believe this
180:17 - is all we need to
180:19 - do so if we run now we see that we get
180:23 - the extracted text in this particular
180:26 - string so this works now and that's all
180:30 - we needed for our back end we can
180:33 - comment this out and move
180:39 - on next thing we want to do is go into
180:42 - our app folder and we will open
180:45 - templates just to discuss the front end
180:48 - aspect so like we said we will not write
180:51 - this code from scratch I don't think
180:53 - it's necessary for this particular
180:55 - project we can just discuss that it's
180:58 - just a HTML page with some CSS and
181:00 - bootstrap that's all it is using this
181:03 - particular
181:04 - bootstrap there is some CSS that will
181:06 - just give some aesthetic aspects but
181:10 - nothing too complicated you can examine
181:12 - this on your own and play around with it
181:15 - if you choose so closing the CSS aspect
181:18 - we can just talk about what's in the
181:20 - body of the HTML so we have our upload
181:24 - image button and upon submission there
181:27 - is some logic some templating templating
181:30 - that handles how once the image has been
181:33 - processed and we have our text in the
181:35 - form of a string this is just some
181:38 - templating that will handle how it's
181:40 - being
181:41 - displayed and that's pretty much all
181:44 - that it is so without talk if we open
181:47 - this by itself so if you open this by
181:50 - itself just as a file you can see how it
181:52 - looks like I said the upload image
181:55 - element with the browse option for
181:57 - selecting the image the button to
181:59 - extract and then once we receive the
182:01 - output when our backend processes the AI
182:04 - code we have just written it will be
182:06 - formatted here and we want to also
182:08 - display the image that we got the text
182:11 - from so with the front and being sorted
182:15 - like that we can now move on to building
182:17 - our flask app which I believe is the
182:19 - most important part of this video so as
182:21 - you saw the actual AI itself we have
182:24 - tesak doing all the work for us it's a
182:26 - very simple function it just does all
182:29 - the work we don't really have to do more
182:32 - than that so we want to now build our
182:35 - flask app so the first thing we do is
182:37 - we'll create two new files I'll call it
182:40 - views.py and the other one called init
182:44 - with two underscores like such so in
182:48 - this init file you want to import flask
182:51 - and we want to say that our app is flask
182:53 - and then for the configure file we will
182:56 - use the file that you got just from the
182:59 - git repo so we'll say from object and
183:02 - then we will name this file config
183:05 - development like such and we will also
183:09 - import views and that's it that's all
183:11 - you need so the last thing that we need
183:14 - to do to finish off our web app is to
183:17 - write the backend logic in our view
183:19 - section so again we want to import flask
183:22 - an app and we want to request render
183:25 - template and URL 4 and we also want to
183:29 - import OS to handle files I have this
183:32 - recommendation from CH GPT to use this
183:36 - particular Library as a method of
183:39 - dealing with files when changing or
183:42 - modifying file names so we will move on
183:44 - with that we also want to include your
183:47 - typical numpy SNP we again need p and
183:51 - image random string and we want to
183:56 - import our function that we built we
184:00 - want to add the path to config so we say
184:03 - that app config is initial file uploads
184:09 - and we will give it a path so for us
184:11 - that's in our static and we'll write our
184:15 - rout to the homepage the only page that
184:18 - we will be using for our web app and it
184:21 - will include methods both get and post
184:24 - so I am assuming that at this stage you
184:27 - are familiar to at least the basics of
184:30 - HTTP protocol and specifically the four
184:34 - requests that you can make get post
184:37 - delete so the basics of your crowd
184:39 - systems we stand for create read update
184:45 - delete if this line here means
184:49 - absolutely nothing to you I would
184:51 - suggest finding a dedicated video for
184:55 - this particular reason if you want a
184:57 - good understanding of what we are doing
185:00 - here you would necessarily need to
185:02 - completely understand this just to
185:05 - finish off this web app finish off this
185:06 - project but I do highly recommend so
185:10 - that being said we're going to move on
185:13 - and write our index function and this
185:17 - will now handle the flow of data so
185:20 - we'll say that the full file name is URL
185:23 - for static and the file name is in the
185:26 - images so that's where we'll be storing
185:29 - and then we want to say if image upload
185:32 - is not empty so we will say if request.
185:37 - method is post that's what we want to
185:39 - handle first then we want to define the
185:42 - image upload to be the request files of
185:46 - image upload
185:48 - so what we're doing here is saying that
185:51 - if there is a post request it expects a
185:54 - file in the payload of that post request
185:58 - and that file will then be stored in the
186:00 - variable image upload so if you go back
186:04 - to what our web app looked once the user
186:07 - clicks browse once they choose the image
186:09 - they want the text extracted from that
186:11 - image will go here into this image
186:13 - upload variable so we want to save the
186:15 - file and now we're going to use the
186:17 - secur file name and say that image
186:19 - upload the file name and then we want to
186:23 - define the file path using the OS join
186:26 - with app config initial
186:30 - file initial file uploads coma file name
186:33 - we'll say the image upload do save in
186:37 - the file path so now we want to use the
186:40 - Tesseract app and we'll just use the
186:43 - method we created in our dopy so we want
186:47 - to call this particular method now and
186:50 - pass it the image that c
186:53 - uploaded so we will say that the
186:55 - extracted text is the function so we are
187:00 - calling this function right now if you
187:02 - remember earlier we wrote this line here
187:05 - and this line invokes the usage of this
187:08 - particular function from our ml. P file
187:12 - so we will pass the file path for the
187:15 - image and we want to have the image URL
187:18 - for for static we'll give it the uploads
187:21 - plus file name and in our return we want
187:25 - to render the template that will be
187:26 - displayed so we want to render the
187:29 - template of our HTML file that earlier
187:32 - we were looking at so it's this
187:35 - particular HTML file and we'll say that
187:39 - the URL is image URL and the full file
187:42 - name is file path and the text is
187:45 - extracted extracted text so we need to
187:49 - pass this back onto our front end and
187:53 - this covers any post request coming
187:56 - towards this
187:57 - endpoint so we have defined this
188:00 - endpoint we mentioned that it will
188:03 - handle get and post requests and the
188:06 - first thing find in our conditional
188:09 - statement here is what happens if there
188:10 - is a post request coming this is the
188:14 - logic for the Post request and our
188:16 - return statement will finish the
188:18 - processing of our post request but else
188:22 - we want to handle a get request and we
188:24 - will again give the HTML template and we
188:28 - want to give file name is full file name
188:31 - and lastly this is just the standard for
188:34 - flask apps just going to copy paste this
188:37 - bit our main function for our flask app
188:40 - and you want to write this if double
188:42 - uncore name double uncore is main app.
188:45 - run debug equals true and and that's all
188:48 - we need to do so let's try running our
188:52 - app now so I'm going to type in me open
188:55 - this a bit more so we want to write
188:57 - Python app.py and we can see that our
189:01 - app is running live on our local host
189:05 - for
189:06 - 5,000 so we will open our browser and we
189:09 - will type in Local Host give it a 5,000
189:12 - port and you can see that we have our
189:15 - front end but let's see those it work
189:17 - with the back end so I'm choosing again
189:21 - that image I'm clicking extract and the
189:25 - image is displayed with the text above
189:27 - so everything works as intended and this
189:30 - is our
189:31 - app I hope you enjoyed it and that's all
189:35 - so we will be building this app as you
189:38 - can see it's offering you to download
189:42 - videos and we'll be able to put a link
189:45 - from YouTube and and choosing whether
189:48 - you want a individual video individual
189:51 - audio and you can also download
189:54 - playlists so you can copy paste the link
189:57 - choose your path and you can just click
190:01 - download and it will work so without
190:04 - further Ado let's write some code and
190:06 - see how we build this exact
190:09 - app so let's try to describe how we are
190:13 - going to approach this app so this is
190:16 - some doodling app I've already done here
190:19 - and you can clearly see we have the
190:21 - distinction between back end and front
190:22 - end so we are doing a YouTube video
190:25 - downloader app and we want the app to
190:28 - download YouTube videos songs and
190:31 - playlist We want to have a simple but
190:34 - nice looking GUI that's user friendly so
190:37 - that will be the GUI that we will build
190:39 - with kiwi when I thought about what kind
190:41 - of design to use I'm just going to
190:43 - include some kind of a logo this will be
190:46 - like a Dropbox
190:48 - that will feature four options so to
190:50 - give the user the option to do one video
190:52 - playlist of videos one song or playlist
190:56 - of songs so clearly we want then to
190:59 - correspond each of these four options
191:02 - with these four functions in the back
191:05 - end I just do four of these so this
191:08 - particular Dropbox will include four
191:12 - options and then each of these options
191:14 - will correspond with downloading these
191:17 - one of these
191:18 - four and then we want a file path so
191:23 - it'll be some kind of a browse option
191:26 - will then give file path to where to
191:32 - back end so with this we only now need
191:37 - the link so we can say then that if we
191:41 - have another box here we can say that
191:44 - this will be the link input link for
191:48 - download so with this I know that I can
191:52 - have two inputs from the user one being
191:56 - where the user wants to store the file
191:58 - and the second one being the link of the
191:59 - YouTube video that they want to download
192:01 - or link of the playlist so then we can
192:06 - take this and give it this will go into
192:10 - one of our four functions as a parameter
192:12 - is this drawing yes it is so if you have
192:15 - b in a draw so we will have two
192:18 - parameters on all of the four functions
192:22 - where X will
192:24 - be in this case it's going to get a bit
192:27 - messy but you get the idea the X will
192:32 - correspond with the link and the Y will
192:35 - correspond with the file path so we will
192:39 - pass that on onto our backend functions
192:42 - and uh then we just want to click
192:44 - download and the download should execute
192:47 - the rest of the function so this will be
192:50 - our approach onto our design it's quite
192:53 - simplistic the front end is just a GUI
192:55 - that will give the user the option to
192:57 - choose where to store the file and which
192:59 - file to download and the back end will
193:02 - just have four functions that correspond
193:04 - with the option of the user of what they
193:06 - want out of the download link so with
193:09 - that being said we can move on and
193:12 - create this app in code so first things
193:15 - first we'll import the libraries that
193:17 - we'll be using so we'll use PBE to
193:20 - download YouTube videos I we say from
193:23 - PBE in port list and YouTube When We
193:28 - want to download audio songs we will
193:30 - actually have to convert them so part
193:33 - tube can only download videos from
193:35 - YouTube so if you want to end up with a
193:37 - song out of that video you have to
193:40 - convert it here in Python yourself and
193:42 - we will be using mov pie for that so
193:46 - we'll just import everything from there
193:49 - and we'll import OS to manage the file
193:53 - paths one thing that I like to do for
193:56 - every project is to install the
194:00 - dependencies into a virtual environment
194:02 - just to make sure that you have this
194:04 - project isolated from the rest of your
194:08 - dependencies so we will do that we'll
194:10 - open the terminal I prefer to use
194:14 - Powershell but it's entirely up to you
194:16 - how you do this part so all we want to
194:19 - do is create a virtual
194:21 - environment so we'll do python we do
194:24 - this command so then we will navigate
194:27 - into I believe it's the scripts so we
194:31 - want to navigate into this folder now
194:34 - and activate this
194:36 - environment so we'll do that and will'll
194:39 - do
194:41 - activate I believe yes so you can see we
194:45 - have activated our environment it tells
194:48 - tells us in this prefix that we are in
194:50 - this environment now so we want to start
194:53 - in we want to install the dependencies
194:56 - that we'll be using so the quickest way
194:59 - to do it is to use this requirements.txt
195:02 - and all that we will need is we don't
195:06 - need this for now all that we will need
195:08 - is these two libraries for the back end
195:10 - and we will build our front end with KV
195:12 - so just these three libraries so we'll
195:15 - say pep install this and now when we run
195:19 - this we should be able to see that the
195:22 - libraries are being installed all right
195:24 - until this finishes we can start writing
195:26 - our backend code so continuing this part
195:31 - we will start by defining our class call
195:33 - it YouTube downloader and this will
195:35 - include our four functions so I can just
195:38 - do a layout of our functions so we'll
195:41 - have four of these so we have four
195:45 - functions and
195:47 - will'll pass the self parameter as well
195:51 - as
195:52 - such I want to name these properly so
195:55 - they should be called something that
195:56 - makes sense and then we can just copy
195:59 - paste this we want to name these
196:01 - functions in a way that will make sense
196:03 - to us as well so this one will
196:06 - download a single video the meantime we
196:09 - can see that all of our libraries were
196:10 - installed so I can minimize this for now
196:13 - and continue naming our functions so
196:17 - then we can do one that downloads a
196:19 - playlist of videos we can do one that
196:22 - downloads video as audio so when you
196:25 - want to download a song in MP3 format so
196:28 - we can call this one download video as
196:31 - audio and then in case you want to
196:33 - download a playlist of videos but save
196:36 - them in MP3 format this one can take a
196:39 - link of a playlist and download all of
196:44 - them that's brilliant I think
196:47 - this will be the structure that we use
196:49 - to build our four functions if you
196:53 - remember this is what we had as a plan
196:56 - to have four functions that we will then
196:58 - connect to our front end
197:00 - later moving on we want to start writing
197:04 - our code for our functions so the track
197:08 - for this can be that we try to execute
197:12 - the logic of downloading and if it
197:15 - doesn't work we can pass an error so
197:19 - give it an
197:20 - exception and then print out that error
197:23 - so that we know what went wrong and then
197:26 - we can do this so this is just good
197:30 - practice to make sure that we attempt
197:34 - certain logic and if it doesn't work we
197:37 - get an explanation of what went wrong
197:40 - that being said let's write the download
197:44 - logic so the way this Library work works
197:47 - is that we need to instantiate this
197:49 - YouTube objects and we pass it the
197:51 - parameter of the url url the link of a
197:55 - YouTube video we want to download then
197:57 - we want to select the highest possible
198:00 - resolution if you want to play around
198:02 - with this you can examine the
198:03 - documentation just do some research but
198:06 - that there's no reason for me to go that
198:09 - deep into it at the point at this point
198:11 - I just wanted to download the best
198:13 - quality of Video
198:14 - available so
198:17 - we will Define the file tension here as
198:19 - well and then we can say to this get
198:23 - highest resolution so we want to make
198:26 - sure that we got the link that the link
198:28 - of the YouTube video we want has been
198:31 - passed on through our function so we can
198:33 - print that we can say that the video
198:36 - title is and then here do yt. tile and
198:41 - this will give us the full name then we
198:43 - want to set the save path and the file
198:48 - name so we'll say that in our file name
198:51 - variable we sto the name of the video
198:53 - but we want to make sure that no illegal
198:56 - characters pass on and cause a potential
198:59 - error so I've played around with this
199:01 - earlier and sometimes if you have a
199:05 - particular character written in the name
199:08 - of the YouTube video this program will
199:10 - know how to handle it and it throws an
199:12 - error so I went to chat GPT and I've
199:16 - asked it to think of any possible
199:19 - character that could throw an error and
199:22 - just replace it with an underscore so
199:25 - let me show you what that looks like
199:27 - when I copy paste this part so we are
199:29 - saying that we want to replace this
199:32 - character with that one and this goes on
199:36 - for all these examples you can see
199:39 - pretty much what the point of this is uh
199:42 - you can get this exact line of code or
199:45 - you can skip this part enti high but for
199:48 - me this has ended up working fine so for
199:50 - example there was a video with this
199:53 - character in in the name of it and it
199:56 - gave me an error so this L code will
199:58 - make sure that this character gets
200:00 - replaced with an
200:01 - underscore so you can get this line if
200:04 - you open my GitHub you can take the
200:05 - exact one I did or you can do your own
200:08 - it's completely up to you so now we want
200:12 - to write the logic for the download with
200:14 - this specified file name so we will say
200:16 - stream
200:17 - download and then we'll pass on the save
200:21 - path that we initially gave as a
200:23 - parameter in our function so we'll do
200:26 - output path and we'll say that this is
200:28 - the save path and the will be file name
200:32 - we want to print some context just saved
200:36 - as and we can just say something like
200:39 - save as then the file name and we can
200:42 - also say in the location save path so
200:47 - this is our first function and we can
200:49 - test it now so let's see how this works
200:52 - so I'll minimize this for now to try
200:56 - this function so I'm going to open here
200:59 - on the side just any video a first video
201:02 - that comes out and see if I copy paste
201:07 - the link you will see it in a second so
201:11 - if I if I say that XY Z is this
201:15 - particular link so this is just the
201:16 - YouTube
201:17 - video and I say that
201:20 - XY Z2 this will be my file path so I can
201:26 - try getting this from let's try doing it
201:28 - here so we will create a for here say
201:33 - create this folder test 313 and then we
201:37 - can get this path I believe I need to
201:39 - change this and we will give the name of
201:42 - our
201:43 - folder so now we can try to execute the
201:46 - logic of the first function so we will
201:50 - say download it's within our class so we
201:53 - need to access the class I will choose
201:56 - to download a single video and we'll
201:59 - pass these two parameters the link and
202:02 - the file
202:04 - path so let's see if this works now so
202:07 - if we try running oh so was a an eror so
202:12 - this should be Capital like such say
202:15 - that it's not defin mind oh there as
202:18 - well we should be good
202:20 - now so we run the script and there's
202:24 - another eror let's see why is that the
202:26 - case so this might be because we
202:29 - specified self let me try putting none
202:32 - here and running it now again let's try
202:36 - removing this for now which object has
202:39 - no attribute
202:41 - stream oh this should be streams plural
202:45 - and we can see now that it says it was
202:48 - completed successfully and if I check
202:53 - here we can see that we have this file
202:56 - so something that you can notice is that
202:58 - this file's extension is not defined so
203:02 - at the moment the type of this file is
203:05 - file and I don't want that I want this
203:08 - to be MP4 so we will write some logic
203:11 - now that will take care of that so let's
203:14 - redo this so as as I said we want to add
203:18 - the MP4 extension to the downloaded
203:22 - video the shortest way I thought about
203:25 - doing that is to just use some pure
203:28 - python string manipulation so I will say
203:31 - that the new tension is MP4 so I just
203:36 - want to add this to the end of my
203:40 - file and I already have the save path
203:43 - and the name was file name what was this
203:46 - so I already have the file name and the
203:49 - actual path of the file so I'm just
203:53 - going to say that my separator is the
203:56 - backs slash because I want to construct
203:58 - the file so I want to identify the file
204:03 - and save it in a variable so I'm going
204:06 - to say that the full path is the save
204:10 - path plus the separator plus the file
204:15 - name so this will just identify the
204:18 - downloaded file this particular file and
204:22 - take its path as a string and store it
204:26 - inside of this inside of the full path
204:28 - so we can then check we can write some
204:31 - logic to make sure that this works
204:32 - properly so and say if not o. path
204:37 - exists and then we give the string path
204:42 - of our downloaded file we W know that so
204:45 - we will say
204:47 - the file of file name does not exist
204:52 - simple as that so that's just to catch a
204:54 - potential error and then now we want the
204:58 - new name which will be the old name plus
205:01 - this new extension so we adding this MP4
205:04 - so we will just write that the new Full
205:07 - path is the old path plus the new
205:12 - extension like this um this might not be
205:15 - the best way way to do it but it works
205:18 - so now we want to actually rename the
205:20 - file and then we can pass the old and
205:24 - the new name that we want which we
205:27 - defined in these two variables and then
205:30 - I like to see that this work so we'll
205:33 - write our file was renamed to and then
205:36 - we can just pass the new Full path so
205:40 - now I'll rerun the exact same test code
205:45 - that we've written and I expect now this
205:49 - same file to be downloaded but this time
205:51 - to be in a MP4 format so we'll rerun the
205:57 - code and there we go it's been
206:00 - downloaded and now it's MP4 so that's
206:04 - really I'm happy with that this works
206:06 - and we can use practically the exact
206:08 - same approach to write the rest of our
206:11 - functions so now we want to do the same
206:14 - but we just want to download
206:17 - no we want to download the whole
206:18 - playlist so that's what we'll do now
206:20 - we'll write the logic for
206:21 - that so it's slightly different in a
206:25 - sense that we will just modify certain
206:29 - bit like here instead of starting with
206:33 - instantiating the YouTube object we need
206:35 - to let it know that we want to download
206:37 - a playlist so we will say download
206:41 - playlist and give it the URL the link
206:45 - that will be passed will be the link of
206:47 - the entire playlist and uh then we want
206:51 - to iterate through the YouTube playlist
206:54 - and just approach downloading each video
206:57 - individually so let me try doing that
206:59 - let me try writing a for Loop that will
207:03 - say for each video URL in the URL no in
207:10 - the playlist object cuz we store that in
207:13 - bable P Brant so in here
207:17 - we'll say let us what video is being
207:20 - downloaded at that moment so we can say
207:23 - just write the name of this and then we
207:26 - will just repeat the same process from
207:30 - earlier technically we could just pass
207:33 - this function now because in this for
207:37 - Loop we'll be doing the exact logic of
207:39 - this first function but for the sake of
207:44 - the video we might just write a l
207:47 - again but everything should be exactly
207:49 - the same let's try doing it that way
207:51 - first actually so we can say YouTube
207:54 - downloader then download single video
207:58 - and then we are passing the video
208:02 - URL and the save path so let's see if
208:08 - this will
208:10 - work once this for Loop iterates through
208:13 - the entire YouTube list we want want to
208:16 - know that it has finished all videos
208:20 - have been downloaded in mp format so
208:25 - let's try this now so as you can see our
208:27 - list downloading is working and we don't
208:29 - need to write the manual code for going
208:32 - through through for iterating through
208:34 - this list we can just use recursion here
208:38 - and we are just reusing this function of
208:40 - downloading a single video that worked
208:43 - fine and now with this we can very
208:47 - quickly write the logic for for the
208:50 - remaining two functions where we want to
208:52 - download a single video a single audio
208:54 - song let's say or a playlist of audios
208:58 - The Only Exception will be now that
209:00 - after downloading a video we will have
209:03 - to convert it ourselves to an audio
209:07 - file say that we want to instantiate
209:10 - this object give it a URL file sorry URL
209:14 - link and print that we are downloading
209:17 - that that particular from and we can say
209:21 - again it's just a title we want to
209:24 - select the best quality available so we
209:28 - can say that YouTube streams only audio
209:31 - is true and we want to pick the first in
209:37 - case that's not
209:39 - available we can print some some logic
209:42 - just to let us know and sorry this goes
209:46 - here so we want to define the output
209:49 - file and say that that's the audio
209:51 - stream which we want to download and we
209:54 - will pass the parameters to let it know
209:56 - where we want to save it which is our
209:58 - save path and we can do a print
210:03 - statement so that we know where the file
210:06 - went now we have to manually convert our
210:09 - file to an MP3 so first we can find the
210:14 - actual file and add it the MP3 tension
210:18 - so this is similar to what we did
210:19 - earlier where we added the MP4 because
210:24 - the p tube will just download type file
210:28 - so now we are manually adding the MP3
210:30 - extension and after that we can say that
210:34 - converting file to MP3 and our audio
210:39 - clip will be audio file clip of the
210:43 - output file and
210:46 - need to write some more Logic for it is
210:49 - the new file with a codec being
210:53 - MP3 and then we want to close this file
210:56 - C
210:57 - close and then we just want to remove
210:59 - the original that was not. MP3 so we can
211:05 - say OS remove the original file and
211:09 - print conversion complete and just some
211:13 - additional
211:14 - logic this this is our new
211:17 - file and then if something went wrong we
211:20 - have our error so we can try and test
211:24 - that again just creating a folder that
211:27 - can test this going back to YouTube just
211:30 - to copy paste a link for the first video
211:33 - that I see because this is just testing
211:36 - so I'm giving it some random song from
211:39 - YouTube and now we want to download a
211:43 - video as audio we passed the link we
211:46 - gave it the file path of test 313 this
211:50 - folder here so now when we run this we
211:53 - expect to see this downloaded in MP3 we
211:57 - get an error so there's a syntax error
211:59 - at line 51 believe this was or not audio
212:05 - stream yep I put that in the wrong place
212:08 - so that should work now again this being
212:12 - the
212:13 - problem testing now so eror has a so
212:17 - this is the error this should be only no
212:21 - sorry output putut path and it equals
212:25 - save path so now if we rerun This
212:29 - brilliant we see that this function
212:31 - works great so same logic now we will
212:35 - write the function to download a
212:37 - playlist and we can reuse a lot of the
212:40 - same logic from a function that download
212:43 - the playlist of videos so we will go
212:45 - into to that function and in the
212:48 - try again we're doing the same thing we
212:51 - saying to instantiate our playlist
212:54 - object passing the URL of the playlist
212:57 - and then we want to iterate through the
213:00 - YouTube list and the only difference
213:02 - will be that we are not going to run the
213:06 - function to download a single video
213:07 - we'll download the function to download
213:09 - video as audio so let's try doing that
213:13 - and then we can try passing YouTube
213:15 - download
213:16 - downloads video as audio and we will
213:19 - give it the video URL and save path
213:25 - parameters and then if everything goes
213:27 - well we want to say all
213:31 - files convert to
213:34 - MP3 so now we want to test this so you
213:39 - can go on YouTube and find any public
213:42 - playlist to try and test this so I want
213:46 - to run the function for it here so we
213:49 - want to download playlist as
213:51 - MP3 and we can see so far that this is
213:54 - working so everything is being
213:56 - downloaded here and I'm going to stop
214:00 - the code from running further because I
214:03 - can see that everything works as
214:04 - intended and this means that we have
214:07 - just successfully completed our backend
214:10 - so we can delete this one thing going
214:13 - further that I want to add is is the
214:17 - self parameter in all of our functions I
214:20 - deleted it whilst we were doing testing
214:22 - but when integrating with
214:25 - kiwi this might be necessary for me so
214:29 - return the self parameter
214:30 - first and we can close this and continue
214:34 - building our front
214:36 - end so let's do that now so we will be
214:40 - using K to build the guey for this so
214:45 - I'm going to copy paste all the inputs
214:48 - and uh I advise you to do the same if
214:51 - you open my GitHub you can see the full
214:54 - file for front end and just copy paste
214:56 - all the libraries and then we'll we'll
214:58 - continue manually building the code for
215:00 - the rest oh there is another thing that
215:02 - I want to copy paste and I got this
215:05 - directly from the documentation for kiwi
215:09 - so the custom styles using K's builder
215:11 - for around the corners of background
215:12 - Styles like some sort of equivalent of
215:14 - CSS for or kiwi just to give a bit more
215:18 - of a aesthetically pleasing look to the
215:22 - elements that we going to build so by
215:24 - all means please copy paste this
215:27 - yourself so we can start first by
215:30 - importing the backend file that we built
215:35 - so we can save from backend one port and
215:37 - then we can import our
215:39 - class want to import T
215:43 - in
215:44 - D from T we want to report file dialogue
215:48 - now we can choose the primary color for
215:52 - our window we'll just say to get color
215:55 - and this will be white we want to define
215:58 - the class for the styled button and this
216:02 - will inherit from button and now we will
216:05 - start building our G we give it this
216:08 - name it will inherit the from box layout
216:12 - will Define our init method you can take
216:16 - all the parameters and vered the init to
216:20 - all key arguments and we will choose the
216:23 - orientation to be
216:25 - vertical padding L and spacing 10 I've
216:30 - chosen to include a logo from my channel
216:33 - in this GOI it will just be this picture
216:37 - you don't have to do this you can skip
216:38 - this part for the logo but if you want
216:41 - to do something similar just include the
216:44 - name include the picture
216:46 - in your main folder and then we'll just
216:48 - use this name here so we'll say that
216:52 - self logo is the uh image we'll give it
216:56 - the source which is in our folder in our
216:59 - working folder and we'll just Define the
217:04 - dimensions and we'll keep the ratio true
217:08 - and allow stretch true now we will add
217:12 - this as a widget add self logo so we
217:16 - will continue building and we will do a
217:21 - self. spinner and call onto the spinner
217:25 - object and will say that the text
217:30 - is download type so I want to show you
217:33 - exactly what this part is now what we
217:36 - are building so if you remember if we go
217:39 - back to this drawing that I made we made
217:42 - the decision that this button here will
217:46 - be a
217:47 - Dropbox that will give four options each
217:51 - representing one of these functions
217:54 - respectively so we are building this
217:56 - Dropbox here right now and that's the
217:59 - spinner widget in KV so now when you
218:03 - know what it does logically I find it a
218:06 - bit easier to understand the code for it
218:10 - so the multi line will be false now we
218:13 - don't need the multi line we'll give it
218:16 - the values so our fun our four
218:20 - functions for to download a video to
218:25 - download a playlist of videos to
218:29 - download audio or download list of
218:32 - audios call it audios like this we'll
218:36 - give it the size H to be one and 01 and
218:40 - the backround color we can
218:44 - use so for got to add the coma and here
218:49 - and then the last bit will say that the
218:52 - back background normal is an empty
218:56 - string so now we want to add this widget
218:59 - just like we did with the logo so we're
219:01 - doing this but we are adding the URL
219:05 - input so now we want to do the path
219:07 - input with rounded Corners so this will
219:10 - be the box that allows the user to add
219:13 - the path where the file will be
219:15 - downloaded so we'll say that sub. input
219:19 - is text input and this object will have
219:22 - loads of
219:23 - parameters as well so the size hint
219:27 - being one and 05 multiline is false read
219:33 - only is true and the text for it will be
219:38 - enter where you want to download your
219:42 - files file for files doesn't matter
219:46 - and we'll say the background normal is
219:48 - again an empty string and the background
219:52 - color and uh we'll choose be six of
219:55 - these and foreground color will be all
220:00 - ones and lastly we want to add this
220:04 - widget again so we adding the silver
220:07 - path input so I forgot one thing here so
220:12 - this actually is adding the widget for
220:15 - our spinner and then to have our link
220:19 - input we'll do something similar to this
220:23 - we'll Define this to be a URL input this
220:28 - can be smaller this can be 02 and this
220:30 - can be enter the link of the file you
220:34 - want to download and then all of this
220:38 - will be the same and we just want to add
220:40 - this add widget self. URL input just
220:45 - there's no confusion I'm going to zoom
220:47 - out and talk about this for a second so
220:50 - in our class where we are building our
220:52 - gy The Constructor function The
220:55 - Constructor method in it is where you
220:58 - can build widgets and then add them so
221:01 - we start off by creating the putting the
221:03 - logo on top so that's a vidget this is
221:07 - the code for it and then this is the
221:08 - line of code that adds that fidget that
221:10 - we built we build it here we add it here
221:13 - so now that's how you approach it we are
221:15 - building the drop- down box with these
221:18 - options this is where we build it this
221:20 - is how we add it with the add widget
221:22 - line so then when we want to build the
221:25 - box to add the the ability for the user
221:28 - to choose to to put the link of the file
221:30 - they want to download this is how we
221:32 - built it again we are adding it with the
221:35 - add widget option so then we have
221:39 - choosing where the file will be
221:40 - downloaded same thing happens again so
221:44 - we want to add some styling for the for
221:48 - the path button and we'll do that here
221:53 - so zooming in a little bit again so you
221:55 - can see and we can write self PA button
222:00 - is the style
222:01 - button so this object will have the name
222:06 - for the button which is browse size hint
222:09 - will
222:11 - be101 the background color that's color
222:14 - from hex
222:15 - and Del button will bind this that when
222:19 - this button is pressed it opens the
222:23 - self. open file dialogue so this will be
222:26 - outside of this actually and then we are
222:29 - just going to add this fidget so PA
222:33 - button that's great now we want so we
222:35 - added the button that will allow the
222:37 - user to click this option adding the
222:41 - path input and then the button will open
222:44 - the typical a window where you can
222:46 - manually navigate and find the folder
222:49 - where you want to download your file so
222:52 - now we'll add the button for download
222:54 - and we can pretty much use we can reuse
222:57 - this code and we will just say that this
223:00 - is a download button now and instead of
223:05 - browse you'll say download and it will
223:08 - have the same size but we can choose a
223:12 - different color like green color or
223:14 - something like
223:15 - that so we'll remove this I think this
223:19 - is the hex code for for
223:22 - that and the difference now will be that
223:26 - when this is run we want to start
223:32 - download so instead of this we will say
223:36 - self. download button and then oness it
223:40 - will start the
223:41 - download and then we just want to add
223:43 - this widget so say download button like
223:47 - so
223:48 - brilliant so now we want to write the
223:52 - logic for displaying the messages so
223:55 - we'll say that the message is label
223:58 - object we'll give it the size staying
224:01 - consistent with what already we declared
224:04 - we give it color and it can be the same
224:08 - color and just like
224:11 - before We'll add the vidget that WID
224:15 - this built and say self message label
224:18 - now we want to write the function for
224:22 - opening the file and this is the way we
224:27 - choose we give the user the option to
224:28 - choose where to download the file but we
224:31 - want them to navigate through it like
224:34 - the same way how every single file
224:36 - opener works and this is just the code
224:41 - for that that's brilliant so we have
224:43 - this now we will want to write the
224:46 - function that will be attached to our
224:48 - download button the one we mentioned
224:51 - here have self and instance and we can
224:54 - give it some text here I will say that
224:57 - the download type is self spinner text
225:01 - so if you remember the drop down box
225:03 - that we built this is the download type
225:05 - for us and we are giving the the URL of
225:10 - strip and say path path input. text
225:15 - STP and we want to catch an error in
225:18 - case we don't have a URL similarly if we
225:21 - don't have a save file we want to couch
225:24 - that aror too so we don't want the user
225:27 - to be pressing this button the download
225:29 - button if they haven't successfully
225:31 - given a valid link and a valid file path
225:34 - because if you remember a backend
225:35 - featured those four functions of each
225:39 - having two parameters the URL and uh the
225:43 - path where the f will be downloaded so
225:46 - we want to see that downloader is the
225:49 - YouTube downloader and now the final
225:52 - logic is to try if the download type so
225:56 - if that drop down box the choice was to
226:00 - download video let me just see the text
226:02 - for the drop down box so download video
226:05 - playlist of videos so let me have these
226:08 - values handy here so I can just build
226:12 - this quickly like so so we'll do some
226:16 - copy pasting here to save time download
226:19 - audio download playlist of videos and we
226:23 - want to run our downloader object here
226:26 - so we can say and here as usual we want
226:29 - to catch an error and we want to push
226:31 - that error into our messaging and then
226:33 - we can print it here too so in here we
226:36 - can actually write the logic now for
226:39 - download single video with the
226:42 - parameters of URL and save path
226:45 - and we'll do some copy pasting again
226:48 - saving time but we'll choose different
226:51 - functions that correspond with what's
226:54 - chosen here so this will be downloading
226:58 - list of videos so download playlist this
227:02 - will be downloading a single audio and
227:05 - this will be downloading the whole
227:07 - playlist of audio that should be it and
227:11 - lastly we want to do we want to build
227:14 - self return downloader the class that we
227:18 - just
227:19 - defined and we're just adding the last
227:23 - line if this is main then we want to run
227:28 - our app so that should be it so let's
227:32 - try and give this a run so let's see how
227:36 - how our go looks front and py we get an
227:40 - error so troubleshooting another error
227:44 - is the iPhone got to give the correct
227:47 - method here so with the audio type we
227:51 - want to make sure that we choose video
227:54 - as
227:55 - audio the rest should be fine let's try
227:59 - running this error again I think I've
228:02 - identified some of the typos that I've
228:04 - done so the first one being when adding
228:09 - the widget for the path input so the
228:14 - first iPod I found was these two selves
228:18 - here so the delete I found the typo this
228:22 - is a dot it shouldn't be it's an
228:25 - underscore so now we have an error again
228:28 - another typo this is allow stretch but
228:33 - clearly I didn't type it correctly here
228:36 - we are now it actually runs properly so
228:39 - this is our app so let's test it now
228:45 - we can choose the download video we'll
228:48 - give it a link of first link that I
228:51 - found on
228:52 - YouTube we will choose to download it in
228:55 - my test folder
228:58 - so I am choosing that right now you
229:01 - can't see it but when you click browse
229:03 - it will just prompt you with a regular
229:06 - window that allows you to navigate
229:09 - exactly where you want this thing to be
229:11 - downloaded so now going here we press
229:16 - download and we can see that it has
229:19 - successfully
229:20 - downloaded that is wonderful so the app
229:24 - works and that's it I hope you enjoyed
229:28 - it and make sure to have a look at the
229:32 - new videos that will be coming after
229:34 - this one