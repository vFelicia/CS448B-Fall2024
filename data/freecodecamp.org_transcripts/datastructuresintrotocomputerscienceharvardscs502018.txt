00:00 - [MUSIC PLAYING]
00:50 - DAVID J. MALAN: All right, this is
CS50 and this is a lecture four.
00:54 - So we're here in beautiful
Lowell Lecture Hall
00:56 - and Sanders is in use today.
00:57 - And we're joined by some
friends that will soon
00:59 - be clear and present in just a moment.
01:02 - But before then, recall that last
time we took a look at CS50 IDE.
01:06 - This was a new web-based programming
environment similar in spirit
01:08 - to CS50 Sandbox and CS50 Lab,
but added a few features.
01:12 - For instance, what features
did it add to you--
01:16 - to your capabilities?
01:17 - Yeah?
01:18 - AUDIENCE: Debugger.
01:19 - DAVID J. MALAN: What's that?
01:19 - AUDIENCE: The debugger.
01:20 - DAVID J. MALAN: The debugger.
01:20 - So debug50, which opens
that side panel that
01:23 - allows you to step through your code,
step by step, and see variables.
01:26 - Yeah?
01:26 - AUDIENCE: Check50.
01:27 - DAVID J. MALAN: Sorry, say again?
01:28 - AUDIENCE: Check50.
01:28 - DAVID J. MALAN: Check50 as well,
which is a CS50 specific tool that
01:31 - allows you to check the
correctness of your code
01:33 - much like the teaching fellows
would when providing feedback on it.
01:36 - Running a series of tests
that pretty much are
01:38 - the same tests that a
lot of the homework's
01:40 - will encourage you
yourself to run manually,
01:42 - but it just automates the process.
01:43 - And anything else?
01:44 - AUDIENCE: [INAUDIBLE]
01:51 - DAVID J. MALAN: So that is true too.
01:52 - There's a little hidden Easter egg
that we don't use this semester,
01:55 - but yes indeed.
01:56 - If you look for a
small puzzle piece, you
01:58 - can actually convert your C code
back to Scratch like puzzle pieces
02:02 - and back and forth, and back to forth,
thanks to Kareem and some of the team.
02:06 - So that is there, but by
now, it's probably better
02:08 - to get comfortable with text as well.
02:09 - So there's a couple of
our other tools that we've
02:11 - used over time of course
besides check50 and debug50.
02:15 - We've of course used printf
and when is printf useful?
02:20 - Like when might you want to use it
beyond needing to just print something
02:24 - because the problem set tells you to.
02:25 - Yeah?
02:25 - AUDIENCE: To find where your bug is.
02:27 - DAVID J. MALAN: Yeah, so
to find where your bug is.
02:29 - If you just, kind of, want to print out
variables, value or some kind of text
02:32 - so you know what's going on
and you don't necessarily
02:35 - want to deploy debug50, you can do that.
02:37 - When else?
02:37 - AUDIENCE: If you have a long
formula for something [INAUDIBLE]
02:41 - and you want to see [INAUDIBLE].
02:43 - DAVID J. MALAN: Good.
02:44 - Yeah.
02:44 - AUDIENCE: How running-- like
going through debug50 50 times.
02:48 - DAVID J. MALAN: Indeed.
02:49 - Well, in real life-- so you
might want to use printf
02:51 - when you have maybe a nested loop, and
you want to put a printf inside loop
02:55 - so as to see when it kicks in.
02:57 - Of course, you could
use debug50, but you
02:59 - might end up running debug50 or clicking
next, next, next, next, next, next,
03:02 - next so many times that
gets a little tedious.
03:04 - But do keep in mind, you can just put
a breakpoint deeper into your code
03:08 - as well and perhaps remove an
earlier breakpoint as well.
03:10 - And honestly, all the time, whether
it's in C or other languages,
03:13 - do I find myself occasionally using
printf just to type out printf in here
03:18 - just so that I can literally see if
my code got to a certain point in here
03:22 - to see if something's printed.
03:23 - But the debugger you're
going to find now
03:25 - and hence forth so much more
powerful, so much more versatile.
03:28 - So if you haven't already gotten to
the habit of using debug50 by all
03:31 - means start and use those breakpoints
to actually walk through your code
03:34 - where you care to see what's going on.
03:36 - So style50, of course, checks the style
of your code much like the teaching
03:39 - fellows might, and it
shows you in red or green
03:41 - what spaces you might want to
delete, what spaces you might
03:44 - want to add just to pretty things up.
03:45 - So it's more readable
for you and others.
03:47 - And then what about help50?
03:49 - When should you instinctively
reach for help50?
03:52 - AUDIENCE: When you don't
understand an error message.
03:55 - DAVID J. MALAN: Exactly.
03:56 - Yeah, when you don't
understand an error message.
03:58 - So you're compiling something.
03:59 - You're running a command.
03:59 - It doesn't really quite work and
you're seeing a cryptic error message.
04:02 - Eventually, you'll get the muscle
memory and the sort of exposure
04:05 - to just know, oh, I
remember what that means.
04:07 - But until then, run help50 at the
beginning of that same command,
04:10 - and it's going to try to
detect what your error is
04:13 - and provide TF-like feedback on
how to actually work around that.
04:17 - You'll see two on the course's
website is a wonderful handout made
04:22 - by Emily Hong, one of
our own teaching fellows,
04:24 - that introduces all of
these tools, and a few more,
04:26 - and gets you into the habit
of thinking about things.
04:29 - It's kind of a flow chart.
04:30 - If I have this problem,
then do this or else
04:32 - if I have this problem
do this other thing.
04:34 - So to check that out as well.
04:36 - But today, let's introduce
really the last, certainly for C,
04:39 - of our command line tools
that's going to help
04:41 - you chase down problems in your code.
04:44 - Last week, recall that we had
talked about memory a lot.
04:47 - We talked about malloc,
allocating memory,
04:49 - and we talked about freeing
memory and the like.
04:51 - But it turns out, you
can do a lot of damage
04:53 - when you start playing with memory.
04:55 - In fact, probably by now, almost
everyone-- segmentation fault?
04:58 - [LAUGHTER]
04:59 - Yeah, so that's just one of the
errors that you might run into,
05:02 - and frankly, you might have
errors in your code now
05:06 - and hence forth that have bugs
but you don't even realize it
05:08 - because you're just getting lucky.
05:10 - And the program is just not
crashing or it's not freezing,
05:13 - but this can still happen.
05:14 - And so Valgrind is a command
line program that is probably
05:17 - looks the scariest of
the tools we've used,
05:19 - but you can also use
it with help50, that
05:21 - just tries to find what are called
memory leaks in your program.
05:24 - Recall that last week
we introduced malloc,
05:26 - and malloc lets you allocate memory.
05:28 - But if you don't free that memory, by
literally calling the free function,
05:32 - you're going to constantly ask your
operating system, MacOS, Linux,
05:35 - Windows, whatever, can
I have more memory?
05:37 - Can I have more memory?
05:38 - Can I have more memory?
05:39 - And if you never, literally, hand it
back by calling free your computer
05:42 - may very well slow down
or freeze or crash.
05:45 - And frankly, if you've ever had that
happen on your Mac or PC, very likely
05:49 - that's what some human accidentally did.
05:50 - He or she just allocated
more and more memory
05:53 - but never really got around
to freeing that memory.
05:56 - So Valgrind can help you find those
mistakes before you or your users do.
05:59 - So let's do a quick example, let
me go CS50 IDE, and let me go ahead
06:04 - and make one new program here.
06:07 - We'll call it memory.c because
we'll see later today how
06:10 - I might chase down those memory leaks.
06:12 - But for now, let's start with something
even simpler, which all of you
06:15 - may be done by now, which is
to accidentally touch memory
06:18 - that you shouldn't, changing it, reading
it and let's see what this might mean.
06:21 - So let me do the
familiar at the top here.
06:25 - Include standard IO.
06:28 - Well, let's not even do that yet.
06:30 - Let's just do this first.
06:31 - Let's do int, main(void),
just to start a simple program
06:34 - and in here let me go ahead and
just call a function called f.
06:38 - I don't really care what
its name is for today.
06:40 - I just want to call a function
f, and then that's it.
06:43 - Now this function f, let me go ahead
and define it as follows, void f(void).
06:47 - It's not going to do
much of anything at all.
06:50 - But let's suppose, just for the sake
of discussion, that f's purpose in life
06:53 - is just to allocate memory
for whatever useful purpose,
06:55 - but for now it's just
for demonstration's sake.
06:58 - So what's the function with
which you can allocate memory?
07:01 - AUDIENCE: Malloc.
07:02 - DAVID J. MALAN: Malloc.
07:03 - So suppose I want malloc
space for, I don't know,
07:06 - something simple like just one integer.
07:08 - We're just doing this for
demonstration purposes,
07:10 - or actually let's do more,
10 integers, 10 integers.
07:13 - I could, of course, do-- well, give me
10, but how many bytes do what I want?
07:17 - How many bytes do I
need for 10 integers?
07:19 - AUDIENCE: sizeof(int).
07:20 - DAVID J. MALAN: Yeah, so I
can do literally sizeof(int)
07:23 - and most likely the size
of an int is going to be?
07:28 - AUDIENCE: Four.
07:28 - DAVID J. MALAN: Four, probably.
07:30 - On many systems today, it's
just 4 bytes or 32 bits,
07:32 - but you don't want to hard code that
lest someone else's computer not use
07:36 - those same values.
07:37 - So the size of an int.
07:38 - So 10 times the size of an int.
07:39 - Malloc returns what type of data?
07:42 - What does that hand me back?
07:45 - AUDIENCE: [INAUDIBLE]
07:46 - DAVID J. MALAN: Yeah, returns
an address or a pointer.
07:49 - Specifically, the address, 100, 900,
whatever, of the chunk of memory
07:53 - it just allocated for you.
07:55 - So if I want to keep that around,
I need to declare a pointer.
07:58 - Let's just call it x for today
that stores that address.
08:01 - Could call it x, y, z, whatever, but
it's not an int that it's returning.
08:04 - It's the address of an int.
08:05 - And remember, that's what
the star operator now means.
08:07 - The address of some data type.
08:10 - It's just a number.
08:11 - All right, so now if I were to--
08:14 - first, let's clean this up.
08:15 - Turns out that you use malloc,
I need to use stdlib.h.
08:20 - We saw that last week, albeit
briefly, and then of course
08:22 - if I'm going to call f, what do
I have to do to fix this code?
08:26 - AUDIENCE: You need to declare.
08:27 - DAVID J. MALAN: Yeah, I
need to declare it up here,
08:29 - or I could just move f's
implementation up top.
08:32 - So I think this works, even
though this program at the moment
08:34 - is completely stupid.
08:35 - It doesn't do anything useful,
but it will allocate memory.
08:38 - And I'll do something
with it as follows.
08:41 - If I want to change the first
value in this chunk of memory,
08:45 - well how might I do that?
08:46 - Well, I've asked the computer
for 10 integers or rather space
08:51 - for 10 integers.
08:52 - What's interesting about
malloc is that when
08:54 - it returns a chunk of memory for
you it's contiguous, back-to-back.
08:58 - And when you hear
contiguous or back-to-back,
09:00 - what kind of data structure
does that recall to mind?
09:03 - AUDIENCE: An array.
09:04 - DAVID J. MALAN: An array.
09:05 - So it turns out we can treat
this just random chunk of memory
09:09 - like it's an array.
09:10 - So if we want to go to the first
location in that array of memory,
09:14 - I can just do this and
put in the number say 50.
09:18 - Or if I want to go to the
next location, I can do this.
09:21 - Or if I want to do the next
location, I can do this.
09:24 - Or if I want to go to the last
location, I might do this,
09:27 - but is that good or bad?
09:32 - AUDIENCE: Bad.
09:32 - DAVID J. MALAN: Why bad?
09:33 - AUDIENCE: It's-- it's out of bounds
09:35 - DAVID J. MALAN: Yeah,
so it's out of bounds.
09:36 - Right?
09:37 - This is sort of week one style
mistakes when it came to loops.
09:39 - Recall, with for loops or while
loops, you might go a little too far,
09:42 - and that's fine.
09:43 - But now we actually will
see we have a tool that
09:45 - can help us notice these things.
09:47 - So hopefully, just visually, it's
apparent that what I have going on here
09:50 - is just-- on line 12,
I have a variable x
09:54 - that storing the address
of that chunk of memory.
09:56 - And then on line 13, I'm just
trying to access location 10
10:00 - and set the value 50 there.
10:02 - But as you note, there
is no location 10.
10:04 - There's location 0, 1, 2, 3, all
the way through 9, of course.
10:08 - So how might we detect
this with a program?
10:10 - Well, let me go ahead and increase
my terminal window just a bit
10:13 - here, save my file, and let me
go ahead and compile make memory.
10:17 - OK, all is well.
10:18 - It compiled without any
error messages, and now
10:20 - let me go ahead and run memory, enter.
10:24 - All right, so that worked pretty well.
10:25 - Let's actually be a little more
explicit here just for good measure.
10:29 - Let me go ahead and print something out.
10:30 - So printf, %i for an integer, and
let's make it just more explicit.
10:36 - You inputted %i and
then comma x bracket 10.
10:42 - And what do I have to
include you use printf?
10:46 - AUDIENCE: stdio.h.
10:47 - DAVID J. MALAN: Yeah, so stdio.
10:48 - So let's just quickly
add that, stdio.h, save.
10:51 - All right, let me recompile
this, make memory, enter.
10:55 - And now let me go ahead and do ./memory.
10:59 - Huh?
11:00 - Feels like it's a correct program.
11:02 - And yet, for a couple of weeks now
we've been claiming that mm-hmm,
11:05 - don't do that.
11:06 - Don't go beyond the
boundaries of your array.
11:09 - So how do we reconcile this?
11:10 - Feels like buggy code or at least
we've told you it's buggy code,
11:13 - and yet it's working.
11:16 - Yeah?
11:16 - AUDIENCE: [INAUDIBLE]
11:19 - DAVID J. MALAN: That's a
good way of putting it.
11:21 - AUDIENCE: It's still very similar.
11:23 - We want that.
11:23 - DAVID J. MALAN: OK.
11:24 - AUDIENCE: So we can theoretically--
11:27 - it just created a program.
11:29 - DAVID J. MALAN: Yeah, and I
think if I heard you correctly,
11:32 - you said C doesn't
scream if you go too far?
11:35 - AUDIENCE: Yeah.
11:35 - DAVID J. MALAN: Yeah, OK.
11:36 - So that's a good way of putting it.
11:37 - Like, you can get
lucky in C. And you can
11:39 - do something that is objectively,
pedagogically, like technically wrong,
11:43 - but the computer's not going to crash.
11:45 - It's not going to freeze
because you just get lucky.
11:46 - Because often, for
performance reasons, when
11:48 - you allocate space for
10 integers, you're
11:51 - actually going to get
a chunk of memory back
11:53 - that's a little bigger than you need.
11:54 - It's just not safe to assume
that it's bigger than you need,
11:58 - but you might just get lucky.
11:59 - And you might end up having more memory
that you can technically get away
12:02 - with touching or accessing or changing,
and the computer's not going to notice.
12:05 - But that's not safe because
on someone else's Mac or PC,
12:08 - their computer might just be operating
a little bit differently than yours,
12:11 - and bam, that bug is going
to bite them and not you.
12:13 - And those are the hardest, most annoying
bugs to chase down as some of you
12:16 - might have experienced.
12:17 - Right?
12:18 - It works on your computer but
not a friends or vise versa.
12:21 - These are the kinds of
explanations for that.
12:23 - So Valgrind can help us track down
even these most subtle errors.
12:26 - The program seems to be working.
12:28 - Check50 or tools like
it might even assume
12:30 - that it's working because it
is printing the right thing,
12:32 - but let's take a look at what
this program Valgrind thinks.
12:36 - Let me increase the size of
the terminal window here,
12:38 - and go ahead and type
in Valgrind ./memory.
12:41 - So same program name ./memory but I'm
prefixing it with the name Valgrind.
12:47 - All right?
12:47 - Unfortunately, Valgrind
is really quite ugly,
12:50 - and it prints out a whole
bunch of stuff here.
12:52 - So let's take a look.
12:53 - At the very top, you'll see
all these numbers on the left,
12:56 - and that's just an
unfortunate aesthetic.
12:58 - But we do see some useful information.
13:00 - Invalid read of size 4 and
then it has these cryptic
13:03 - looking letters and numbers.
13:05 - What are those?
13:07 - They're just addresses and hexadecimal.
13:09 - It doesn't really matter
what they are, but Valgrind
13:11 - can tell us where the memory is
that's acting up suspiciously.
13:15 - You can then see next to that,
that Valgrind is pointing
13:18 - to function f on memory. c 15th line.
13:21 - So that's perhaps helpful,
and then main on line 8
13:24 - because that's the
function that was called.
13:26 - So Valgrind is actually kind of nice in
that it's showing us all the functions
13:29 - that you called from bottom up,
much like the stack from last week.
13:33 - And so something's going wrong
line 15, and if we go back to that,
13:37 - let's see line 15 was--
13:39 - well, sure enough.
13:41 - I'm actually trying to
access that memory location
13:43 - and frankly I did it on line 14 as well.
13:46 - So hopefully fixing one or both
of those will address this issue.
13:49 - And notice here, this frankly just
gets overwhelming pretty quickly.
13:54 - And then, oh, 40 bytes in one block
are definitely lost in lost record.
13:58 - I mean, this is the problem
with Valgrind, honestly.
14:00 - It was written some years ago,
not particularly user friendly,
14:03 - but that's fine we have
a tool to address this.
14:05 - Let me go ahead and rerun
Valgrind with help50,
14:09 - enter, and see if we can't
just assist with this.
14:13 - All right, so still the same amount of
black and white input but down here now
14:16 - help50 is noticing, oh, I can help
you with an invalid write of size 4.
14:21 - So it's still at the same
location, but this time--
14:23 - or rather same file,
memory.c but line 14.
14:26 - And we propose, looks like you're
trying to modify 4 bytes of memory that
14:30 - isn't yours, question mark.
14:32 - Did you try to store something
beyond the bounds of an array?
14:34 - Take a closer look at
line 14 of memory.c.
14:37 - So hopefully, even though
Valgrind's output is crazy esoteric,
14:40 - at least that yellow output will
point you toward, ah, line 14.
14:43 - I'm indeed touching 4 bytes,
an integer, that shouldn't be.
14:48 - And so let's go ahead and fix this.
14:49 - If I go into my program,
and I don't do this.
14:53 - Let's change it to location 9,
and location 9 here and save.
14:57 - Then let me go ahead and
rerun Valgrind without help50.
15:02 - All right, progress except--
15:05 - oops.
15:05 - Nope, no progress.
15:07 - I skipped the step.
15:08 - Yeah, I didn't recompile it.
15:10 - A little puzzled why
I saw the same thing.
15:12 - So now let's rerun Valgrind
and here it seems to be better.
15:18 - So I don't see that
same error message up
15:20 - at the very top like we did before, but
notice here, 40 bytes in one blocks.
15:25 - OK, that was bad grammar in
the program, but are definitely
15:29 - lost in loss record 1 of 1.
15:30 - So I still don't quite understand that.
15:32 - No big deal.
15:33 - Let's go ahead and run help50 and
see what the second of two errors
15:36 - apparently is here.
15:38 - So here it's highlighting those lines.
15:40 - 40 bytes and one blocks are definitely
lost, and looks like your program
15:43 - leaked 40 bytes of memory.
15:45 - Did you forget the free memory
that you allocated with malloc?
15:48 - Take a closer look at
line 13 of memory.c.
15:51 - So in this case line 13
indeed has a call to malloc.
15:54 - So what's the fix for this problem?
15:57 - AUDIENCE: Free.
15:58 - DAVID J. MALAN: Per help50
or your own intuition?
16:00 - What do I have to add to this program?
16:02 - AUDIENCE: Free.
16:03 - AUDIENCE: Free.
16:03 - Yeah, free, and where does that go?
16:07 - Right here.
16:08 - So we can free the memory.
16:11 - Why would this be bad?
16:13 - AUDIENCE: [INAUDIBLE]
16:17 - DAVID J. MALAN: Exactly.
16:18 - We're freeing the memory, which is
like saying to the operating system,
16:20 - I don't need this anymore.
16:21 - And yet, two lines later we're
using it again and again.
16:24 - So bad.
16:24 - We didn't do that mistake
last week, but you should only
16:27 - be freeing memory
when, literally, you're
16:29 - ready to free it up and give
it back, which should probably
16:31 - be at the end of the program.
16:33 - So let me go ahead and re-save
this, Open, up my terminal window,
16:36 - recompile it this time, and now,
let me run Valgrind one last time
16:40 - without help50.
16:42 - And still a little verbose, but
zero errors, from zero contexts.
16:47 - That sounds pretty good.
16:48 - And moreover, it also explicitly
says, all heap blocks were freed.
16:52 - And recall that the heap,
is that chunk of memory
16:54 - that we drew visually up here, which
is where malloc takes memory from.
16:58 - So, done.
16:59 - So this is kind of the
mentality with which
17:02 - to have when approaching the
correctness of your code.
17:05 - Like, it's one thing to run sample
inputs, or run the program like I did.
17:08 - All looked well.
17:09 - It's one thing to run tools like
check50, which we humans wrote.
17:12 - But we too are fallible, certainly,
and we might not think of anything.
17:15 - And thankfully, smart humans have
made tools, that at first glance,
17:18 - might be a little hard to use.
17:19 - Like debug 50, as is Valgrind now.
17:21 - But they ultimately help you
get your code 100% correct
17:24 - without you having to struggle visually
over just staring at the screen.
17:28 - And we see this a lot in
office hours, honestly.
17:30 - A lot of students, to their credit,
sort of reasoning through, staring
17:33 - at the screen, just trying to
understand what's going wrong,
17:35 - but they're not taking any additional
input other than the characters
17:38 - on the screen.
17:39 - You have so many tools that can feed
you more and more hints along the way.
17:43 - So do acquire those instincts.
17:46 - Any questions on this?
17:48 - Yeah?
17:48 - AUDIENCE: Sir, if you had a main
function that took arguments.
17:53 - Would you run Valgrind with
those arguments as well?
17:57 - DAVID J. MALAN: Yes, indeed.
17:58 - So Valgrind works just like
debug 50, just like help50.
18:02 - If you have command line
arguments, just run them as usual,
18:05 - but prefix your command with Valgrind,
or maybe even help50 Valgrind,
18:08 - to help one with the other.
18:10 - Good question.
18:10 - Other thoughts?
18:11 - Yeah?
18:12 - AUDIENCE: Where does
the data go [INAUDIBLE]??
18:18 - DAVID J. MALAN: Good question.
18:19 - So at the end of the
day, think about what's
18:21 - inside the computer, which
is just something like this.
18:24 - So physically, it's
obviously still there.
18:26 - It's just being treated
by the operating system--
18:29 - Mac, OS, Windows, Linux, whatever,
as like a pool of memory.
18:32 - We keep drawing it as a grid that
looks a little something like this.
18:36 - So the operating systems job is to just
keep track of which of those squares
18:40 - is in use, thanks to malloc.
18:42 - And which has been freed.
18:43 - And so you can think of
it as having little check
18:44 - marks next to them saying,
this is in use, this is in use,
18:47 - these others are not in use.
18:48 - So they just go back on the so-called
free list into that pool of memory.
18:53 - Good question.
18:53 - If you take a higher level course
on operating systems in fact,
18:56 - or CS61 or 161 at Harvard, you'll
actually build these kinds of things
19:00 - yourself.
19:01 - And implement tools
like, malloc, yourself.
19:03 - Yeah?
19:03 - AUDIENCE: So why did we have to allocate
memory in this case, and what happens
19:07 - [INAUDIBLE]?
19:07 - DAVID J. MALAN: Good question.
19:08 - Why did we have to allocate
memory in this case?
19:10 - We did not.
19:11 - This was purely, as mentioned,
for demonstration purposes.
19:14 - If we had some program
in which we wanted
19:16 - to allocate some amount of memory,
then this is how we might do it.
19:20 - However, a cleaner
way to do all of this,
19:24 - would have been to say, hey, computer,
give me 10 integers like this,
19:29 - and not have to worry
about memory management.
19:31 - And that's where we began in week
one, just using arrays on the stack,
19:35 - so to speak.
19:36 - Not using malloc at all.
19:37 - So the point is only, that once
you start using malloc, and free,
19:40 - and memory more generally, you
take on more responsibilities
19:43 - than we did in week one.
19:46 - Good question.
19:47 - And the others?
19:49 - All right.
19:49 - So, turns out, there's one
more tool, in all seriousness.
19:53 - This is the thing.
19:55 - [? DDB50. ?] So debug 50 is an allusion
to a very popular tool called, GDB 50,
20:01 - [? Gnu ?] debugger.
20:02 - It's an older tool that you
won't use at the command line,
20:05 - but it's what makes debug 50 work.
20:07 - Turns out, there's a thing.
20:08 - And there's an actual
Wikipedia article that you
20:10 - might have clicked on in my email last
night, called rubber duck debugging.
20:14 - And frankly, you don't have to go as
all out, as excessive, as we did here,
20:18 - but the purpose of this technique,
of rubber duck debugging,
20:20 - is to keep, literally, like a rubber
duck on your shelf, or on your desk.
20:24 - And when you have a bug and you don't
have the luxury of a teaching fellow,
20:27 - or a roommate who took CS50, or a more
technical friend who can help walk you
20:31 - through your code, literally,
start walking through your code
20:34 - verbally, talking to the duck saying,
well, online 2, I'm declaring main,
20:39 - and on line 3, I'm allocating
space for an array.
20:42 - And then, on line 4, I'm calling-- ah!
20:44 - That's what I'm doing wrong.
20:46 - So if any of you have ever had that
kind of moment, whether in office hours,
20:49 - or alone, where you're
either talking in your head,
20:51 - or you're talking through
your code to someone else.
20:53 - And here, she doesn't
even have to respond.
20:55 - You just hear yourself saying the
wrong thing, or having that aha moment.
21:01 - You can approximate that by just keeping
one of these little guys on your desk,
21:05 - and have that conversation.
21:06 - And it's actually not as crazy
sounding as it actually is.
21:09 - It's that process of just talking
through your code logically,
21:12 - step by step, in a way that you can't
necessarily do in your own mind.
21:15 - At least I can't.
21:16 - When you hear yourself
say something wrong,
21:18 - or that didn't quite
follow logically, bam, you
21:20 - can actually have that aha moment.
21:22 - So on the way out today, by all
means, take any one of these ducks.
21:25 - That took quite a long, time for
[? Colten ?] to lay out today.
21:28 - And we'll have more at office hours in
the weeks to come, if you would like.
21:31 - So some of you might recall such
a duck from [? Currier ?] House
21:35 - last year too, which was
a cousin of his as well.
21:38 - All right.
21:39 - So that is rubber duck debugging.
21:41 - Now, last week, recall that we
began to take off training wheels.
21:44 - We'd use for a few
weeks, the CS50 library.
21:46 - And that's kind of in the past now.
21:47 - That was just a technique,
a tool, via which
21:50 - we could get user input a little
more pleasantly, than if we actually
21:53 - started dealing with memory early on.
21:55 - And we revealed last week that
a "string", quote, unquote,
21:58 - is just what, underneath the hood in C?
22:02 - Say again.
22:04 - An array of characters.
22:05 - And even more specifically, it's a
synonym S-T-R-I-N-G for what actual
22:10 - data type?
22:12 - char star, as we've called it.
22:14 - So a char star is just
the computer scientists
22:16 - way of describing a
pointer to a character,
22:19 - or rather the address
of a character, which
22:21 - is functionally equivalent to saying an
array of memory, or sequence of memory.
22:26 - But it's kind of the more precise,
more technical way of describing it.
22:29 - And so now that we know that we have
char stars underneath the hood, well,
22:33 - where is all of that coming from?
22:34 - Well, indeed, it maps
directly to that memory.
22:36 - We keep pointing out that something
like this is inside of your computer.
22:40 - And we can think of the memory
as just being chunks of memory,
22:43 - all of whose bytes are numbered.
22:45 - 0 on up to 2 gigabytes, or 2
billion, whatever the value might be.
22:49 - But of course last week, we pointed
out that you think about this memory
22:52 - not as being hardware per se, but as
just being this pool of memory that's
22:56 - divided into different regions.
22:58 - The very top of your
computer's memory, so to speak,
23:00 - is what we call the text segment.
23:02 - And what goes in the text
segment of your computer's memory
23:05 - when you're running a program?
23:08 - Text is like, poor choice of
words, frankly, but what is it?
23:12 - Say again.
23:13 - AUDIENCE: File Headers?
23:14 - DAVID J. MALAN: Not the
file headers, in this case.
23:16 - This is in the context of running a
program, not necessarily saving a file.
23:19 - Yeah?
23:20 - AUDIENCE: String literals.
23:21 - DAVID J. MALAN: Not
string literals here,
23:23 - but they're nearby, actually, in memory.
23:25 - AUDIENCE: Functions.
23:26 - DAVID J. MALAN: Functions, closer.
23:27 - Yeah.
23:28 - The text segment of
your computer's memory
23:31 - is where, when you double
click a program to run it,
23:33 - or in Linux, when you do dot
flash something, to run it.
23:37 - That's where the zeros and ones of
your actual program, the machine code,
23:41 - that we talked about in week
zero, is just loaded into RAM.
23:44 - So recall from last week, that, you
know, anything physical in this world--
23:48 - hard drives, solid
state drives, is slow.
23:51 - So those devices are slow, but RAM, the
stuff we keep pulling up on the screen,
23:55 - is relatively fast.
23:56 - If only because it has no moving parts.
23:57 - It's purely electronic.
23:58 - So when you double click a
program on your Mac or PC,
24:01 - or do dot slash something
in Linux, that is
24:03 - loading from a slow
device, your hard drive,
24:05 - where the data is stored long
term, into RAM or memory,
24:09 - where it can run much more quickly and
pleasurably in terms of performance.
24:14 - And so, what does this
actually mean for us?
24:16 - Well, it's got to go somewhere.
24:18 - We just decided, humans,
years ago that it's
24:20 - going to go at the top, so to
speak, of this chunk of memory.
24:22 - Below that though, are the more
dynamic regions of memory--
24:25 - the stack and the heap.
24:27 - And we said this a moment ago, and last
week as well, what goes on the heap?
24:31 - Or who uses the heap?
24:33 - AUDIENCE: Dynamic memory.
24:34 - DAVID J. MALAN: Dynamic memory.
24:36 - Any time you call malloc, you're
asking the operating system
24:38 - for memory from the so-called heap.
24:40 - Anytime you call free, you're sort
of conceptually putting it back.
24:43 - Like, it's not actually going anywhere.
24:45 - You're just marking it as available for
other functions and variables to use.
24:49 - The stack, meanwhile, is used for what?
24:53 - AUDIENCE: Local variables.
24:54 - DAVID J. MALAN: Local variables
and any of your functions.
24:56 - So main, typically takes a
sliver of memory at the bottom.
24:59 - If main calls another function, it
gets a sliver of memory above that.
25:03 - If that function calls one, it
gets a sliver of memory above that.
25:06 - So they each have their own
different regions of memory.
25:08 - But of course, these arrows,
both pointing at each other,
25:11 - doesn't seem like such a good design.
25:13 - But the reality, is
bad things can happen.
25:16 - You can allocate so much memory that,
bam, the stack overflows the heap.
25:20 - Or the heap overflows the stack.
25:22 - Thus was born websites like
Stack Overflow, and the like.
25:25 - But that's just a reality.
25:26 - If you have a finite amount
of memory, at some point,
25:28 - something's going to break.
25:30 - Or the computer's going to have
to say, mm-mm, no more memory.
25:32 - You're going to have to quit some
programs, or close some files,
25:35 - or whatnot.
25:36 - So that was only to say that
that's how the memory is laid out.
25:38 - And we started to explore
this by way of a few programs.
25:42 - This one here-- it's a little dark here.
25:44 - This one here, was a swap function.
25:46 - Now it's even darker.
25:48 - It was a swap function that actually
did swap two values, A and B.
25:54 - But it didn't actually work
in the way we intended.
25:57 - What was broken about this
swap function last week?
26:02 - Like, I'm pretty sure it worked.
26:04 - And when our brave volunteer came up and
swapped the orange juice and the milk,
26:08 - that worked.
26:08 - So like, the logic was correct, but
the program itself did not work.
26:14 - Why?
26:14 - AUDIENCE: It changed the
values of the copy variables.
26:17 - DAVID J. MALAN: Exactly.
26:17 - It changed values in the
copies of the variable.
26:20 - So recall, that when
main was the function
26:22 - we called, and it had two values, x
and y, that chunk of memory was here.
26:26 - That chunk of memory was here.
26:28 - And it had like the numbers 1 and 2.
26:29 - But when it called the swap function,
that got its own chunk of memory.
26:33 - So main was at the bottom,
swap was above that.
26:35 - It had its own chunks of
memory called, a and b, which
26:38 - initially, got the values 1 and 2.
26:40 - 1 and 2 were indeed
successfully swapped,
26:42 - but that had no effect on x and y.
26:44 - So we fixed that.
26:45 - With the newer version of
this program, of course,
26:47 - it looked a lot more cryptic at
first glance, but in English,
26:50 - could someone just describe
what it is that happens
26:53 - in this example that was more correct?
26:56 - Like, what does this
program do line by line?
26:58 - Yeah?
26:59 - AUDIENCE: Instead of passing
copies of the variables,
27:01 - you pass pointers to their addresses.
27:03 - DAVID J. MALAN: Exactly.
27:04 - Instead of passing the values of
the variables, thereby copying them,
27:06 - it passes the addresses
of those variables.
27:09 - So that's like saying, I don't
technically care where it is in memory,
27:13 - but I do need to know that
it is somewhere in memory.
27:15 - So instead of passing
an x in the number 1,
27:18 - let's suppose that x
is at location 100--
27:20 - my go to example.
27:21 - It's actually the number 100
that's going to go there.
27:24 - And if y is at the location
like, 104, well, it's
27:27 - 104 that's going to go there, which
are not the values we want to swap,
27:31 - but those are sort of like little
maps, or breadcrumbs if you will,
27:34 - that lead us to the right location.
27:36 - So that when we execute this
code, what we're ultimately
27:39 - swapping in those three lines, is
this and this, and all along the way,
27:43 - recall, we're using a
temporary variable there
27:45 - that can be just thrown away after.
27:48 - So that's what pointers
allowed us to do.
27:50 - And that's what allowed us to actually
change values on the so-called stack,
27:54 - even by calling on other function.
27:58 - All right.
27:59 - Any questions then, on where we left off
last time with the stack and with swap?
28:05 - No?
28:07 - All right.
28:07 - So recall we introduced Binky as
well, who lost his head at one point,
28:11 - but why?
28:13 - What went horribly, horribly awry
with this scene from last week's film
28:16 - from Stanford?
28:20 - Binky was doing everything
correctly, right?
28:22 - Like, moving values.
28:23 - 42 was successful.
28:24 - And then, yeah?
28:25 - AUDIENCE: He tried to
dereference something that
28:27 - wasn't pointing to any actual address.
28:31 - DAVID J. MALAN: Exactly.
28:32 - He tried to dereference a pointer, an
address, that wasn't actually pointing
28:36 - to a valid address.
28:37 - Recall that this was the line in code
in question that was unlucky and bad.
28:41 - Star y, means, go to the address
in y, and do something to it.
28:45 - Set it equal to the number 13.
28:47 - But the problem was, that in
the code we looked at last week,
28:50 - all we did at the start was say, hey,
computer give me a pointer to an int,
28:54 - and call it x.
28:55 - Do the same, and call it y.
28:58 - Allocate space and point x at it.
29:02 - But we never did the same for y.
29:04 - So whereas x contained, last week, the
address of an actual chunk of memory,
29:08 - thanks to malloc, what did y
contain at that point in the story?
29:12 - The yellow line there.
29:16 - What did y contain?
29:17 - What value?
29:21 - AUDIENCE: Null.
29:22 - DAVID J. MALAN: Null.
29:23 - Maybe.
29:24 - Maybe.
29:25 - But it's not obvious because there's
no mention of null in the program.
29:28 - We might get lucky.
29:29 - Null is just 0.
29:30 - And sometimes we've seen that 0 are
the default values in a program.
29:33 - So maybe.
29:34 - But I say, maybe, and I'm hedging why.
29:37 - AUDIENCE: [INAUDIBLE].
29:39 - DAVID J. MALAN: Yeah.
29:40 - And it doesn't allocate-- well,
allocate, is not quite the right word.
29:42 - That suggests you are
allocating actual memory.
29:44 - It's a garbage value.
29:45 - There's something there.
29:46 - Right?
29:47 - My Mac has been running for a few hours.
29:48 - And your Macs, and PCs, and phones,
are probably running all day long.
29:51 - Or certainly when the lid is up.
29:52 - And so, your memory is getting
used, and unused, and used.
29:55 - Like, lots of stuff is going on.
29:57 - So your computer is not filled
with all zeros or all ones.
30:00 - If you look at it at some
random point in the day,
30:02 - it's filled with like bunches
and bunches of zeros and ones
30:05 - from previous programs
that you quit long ago.
30:07 - Windows you have in the
background and the like.
30:09 - So, the short of it
is, when you're running
30:11 - a program for the first time, that's
been running now for some time,
30:15 - it's going to get messy.
30:16 - That big rectangle of memory is
going to have some ones over here
30:18 - some zeros over here and vise versa.
30:21 - So they're garbage values, because
those bytes have some values in them.
30:26 - You just don't necessarily
know what they are.
30:28 - So the point is, you should
never ever dereference a pointer
30:31 - that you have not set yourself.
30:33 - Maybe you will crash.
30:35 - Maybe it won't crash.
30:36 - Valgrind can help you find
these things but sometimes.
30:38 - But it's just not a safe operation.
30:41 - And lastly, the last thing
we introduced last week,
30:43 - which will be the stepping stone for
what problems we'll solve this week,
30:46 - was struct.
30:47 - So struck is kind of cool, in that
you can design your own custom data
30:52 - structures.
30:53 - C is pretty limited out
of the box, so to speak.
30:55 - You only have chars and boules,
and floats, and ints, and doubles,
30:59 - and longs, and str--
31:00 - well, we don't even
have strings, per se.
31:02 - So it doesn't really come with many
features, like a lot of languages do.
31:05 - Like Python, which we'll
see in a few weeks.
31:07 - So with struct in C,
you have the ability
31:09 - to solve some problems of your own.
31:11 - For instance, with the
struct, we can actually
31:15 - start to implement our own features.
31:19 - Or our own data types.
31:20 - For instance, let me go up here.
31:22 - And let me go ahead and
create a file called say,
31:25 - student, or rather destruct dot h.
31:28 - So recall that dot h is a header file.
31:30 - Thus far, you have used header
files that other people made.
31:33 - Like, CS50 dot h, and standard IO
dot h, and standard [? lid ?] dot h,
31:36 - but you can make your own.
31:38 - Header files are just files that
typically contain code that you
31:41 - want to share across multiple programs.
31:43 - And we'll see more of this in time.
31:45 - So let me go ahead and
just save this file.
31:46 - And suppose that I want to
represent a student in memory.
31:50 - A student of course, is
probably going to have what?
31:54 - For instance, how about
a string for their name,
31:59 - a string for their dorm-- but
string is kind of two weeks ago.
32:02 - Lets call this char star.
32:04 - And lets call name, char star.
32:07 - And so you might want to associate like,
multiple pieces of data with students.
32:11 - Right?
32:11 - And you don't want to have
multiple variables, per se.
32:13 - It would be nice to kind of
encapsulate these together.
32:14 - And recall at the very
end of last week, we
32:16 - saw this feature where you
can define your own type,
32:20 - with typedef, that is
a structure itself.
32:23 - And you can give it a name.
32:25 - So in short, simply by executing
this these lines of code,
32:29 - you have just created
your own custom data type.
32:31 - It's now called student.
32:32 - And every student in the world
shall have, per this code, a name
32:36 - and a dorm associated with them.
32:38 - Now, why is this useful?
32:39 - Well the program, we looked at
the very end of last time looked
32:42 - a little something like this.
32:43 - Instruct zero dot c,
we had the following,
32:48 - I first allocated some
amount of space for student.
32:52 - I asked the user what's the
enrollment in the class or whatnot?
32:54 - That gives us an int.
32:56 - And then, we allocated an array of
type student, called students, plural.
33:01 - This was an alternative,
recall, to doing something
33:04 - like this, string names enrollment,
and string dorms enrollment.
33:10 - Which would work.
33:11 - You could have two separate
arrays, and you'd just
33:13 - have to remember that name zero
and dorm zero is the same human.
33:17 - But why do that if you
can keep things together.
33:19 - So with structs, we
were able to do this.
33:21 - Give me this many student structures,
and call the whole array, students.
33:27 - And the only new syntax we introduce to
satisfy this goal, was what operator?
33:34 - AUDIENCE: The dot.
33:35 - DAVID J. MALAN: The dot.
33:36 - Yeah.
33:36 - So in the past, recall from like
week two, we introduced arrays.
33:40 - And arrays allow you to do
square bracket notation.
33:42 - So that is no different
from a couple of weeks back.
33:45 - But if your array is not storing
just integers, or chars, or floats,
33:49 - or whatever, it's actually storing
a structure, like a student,
33:53 - you can get at that student's name
by literally just saying dot name.
33:57 - And you can get at their
dorm by doing dot dorm.
33:59 - And then everything else is the same.
34:01 - This is what's called, encapsulation.
34:03 - And it's kind of like a fundamental
principle of programming
34:05 - where, if you have some real
world entity, like a student,
34:08 - and you want to represent
students with code, yeah,
34:11 - you can have a bunch of arrays that all
have called names, dorms, emails, phone
34:16 - numbers, but that just gets messy.
34:18 - You can instead encapsulate all of that
related Information about a student
34:22 - into one data structure so that now you
have, per week zero, an abstraction.
34:27 - Like, a student is an abstraction.
34:30 - And if we break that abstraction,
what is a student actually?
34:34 - Not in the real world, but
in our code world here?
34:37 - Student is an abstraction.
34:39 - It's a useful word, all of us can
kind of agree means something,
34:41 - but technically, what
does it apparently mean?
34:45 - A student is actually a name in
a dorm, which really kind of is
34:48 - diminutive to everyone in this
room, but we've distilled it in code
34:52 - to just those two values.
34:53 - So there we have encapsulation.
34:55 - You're kind of encapsulating
together multiple values.
34:57 - And you're abstracting away
just have a more useful term,
35:00 - because no one is going to want
to talk in terms of lines of code
35:02 - to describe anything.
35:04 - So, same topic as in the past.
35:05 - So, now we have the ability to come
up with our own custom data structures
35:10 - it seems.
35:10 - That we can store anything
inside of them that we want.
35:13 - So let's now see how
poorly we've been designing
35:16 - some things for the past few weeks.
35:19 - So it turns out that much
of the code, hopefully
35:22 - we've been writing in recent
weeks has been correct,
35:25 - but we've been not necessarily
designing solutions in the best way.
35:28 - Recall that when we have
this chunk of memory,
35:30 - we've typically treated
it as at most, an array.
35:34 - So just a contiguous chunk of memory.
35:35 - And thanks to this very simple
mental model, do we get strings,
35:39 - do we get arrays of students now.
35:42 - But arrays aren't necessarily the
best data structure in the world.
35:45 - Like, what is a downside of an array
if you've encountered ones thus far.
35:52 - In C, what's a downside of an array?
35:54 - Yeah?
35:55 - AUDIENCE: [INAUDIBLE].
35:58 - DAVID J. MALAN: Can or cannot?
35:59 - AUDIENCE: Cannot.
36:00 - DAVID J. MALAN: You cannot.
36:00 - That is true.
36:01 - So in C, you cannot mix data
types inside of an array.
36:05 - They must all be ints, they must all
be chars, they must all be students.
36:09 - It's a bit of a white lie
because technically, you
36:11 - can have something called a void star,
and you can actually map-- but yes.
36:15 - That is true though, strictly
speaking-- cannot mix data types.
36:18 - Though frankly, even though
other languages let you do that,
36:20 - it's not necessarily the
best design decision.
36:22 - But sure, a limitation.
36:23 - Other thoughts.
36:24 - Yeah?
36:24 - AUDIENCE: The size cannot change.
36:26 - DAVID J. MALAN: The size cannot change.
36:27 - Let's focus on that one.
36:28 - Because that's sort of even
more constraining it would seem.
36:32 - So if you want an array for,
say, two values, what do you do?
36:37 - Well, you can do something like
int, x, bracket, 2, semi-colon.
36:41 - And what does that actually give you
inside of your computer's memory?
36:44 - It gives you some chunk
that we'll draw a rectangle.
36:47 - This is location 0.
36:48 - This is location 1.
36:49 - Suppose that, oh, a few minutes
later, you change your mind.
36:52 - Oh, darn, I just took a--
36:54 - I want to type in a
third value, or I want
36:56 - to add another student to the array.
36:58 - Where do you put that?
37:00 - Well, you don't.
37:01 - If you want to add a third
value to an array of size 2,
37:04 - what's your only option in C?
37:06 - AUDIENCE: You make a new array.
37:08 - DAVID J. MALAN: You make a new array.
37:09 - So literally.
37:09 - And if this array had
the number like 42,
37:13 - and this had the number 13, the only
way to add a third number is to allocate
37:17 - a second array, copy the values into
the same locations, 42, 13, and then,
37:23 - we'll add another value, 50.
37:25 - And then, so that you're not
using up twice as much space
37:28 - almost permanently, now you
can sort of free somehow,
37:31 - or stop using that chunk of memory.
37:33 - So that's fine.
37:34 - It's correct what we just did.
37:35 - But what's the running
time of that process?
37:40 - Recall a couple of weeks ago, we started
talking about efficiency and design.
37:43 - What's the running time
of resizing an array.
37:47 - AUDIENCE: Too long.
37:48 - DAVID J. MALAN: Say Again.
37:49 - AUDIENCE: I said, too long.
37:50 - DAVID J. MALAN: Too long.
37:51 - Fair.
37:53 - But let's be more precise.
37:54 - Big o of-- big o of what?
38:01 - AUDIENCE: N.
38:02 - DAVID J. MALAN: N. What's n?
38:03 - AUDIENCE: [INAUDIBLE].
38:05 - DAVID J. MALAN: OK.
38:05 - True.
38:05 - But what does n represent?
38:06 - AUDIENCE: [INAUDIBLE].
38:08 - DAVID J. MALAN: Yeah.
38:09 - So you don't actually have to not know.
38:10 - It's just a general answer.
38:11 - In this case, however long
the array is, call it n.
38:14 - It is that many steps to
resize it into that plus 1.
38:18 - Technically it's big o, over n, plus 1.
38:20 - But recall in our discussion,
"The big o notation," we just
38:22 - ignore the smaller terms-- the plus
1s, the divided by 2s, the plus n.
38:26 - We focus only on the most powerful
term in the expression, which
38:30 - is just n here.
38:31 - So yes, if you have an array
of size 2, and you resize it
38:35 - into an array of size 3,
or really, n plus 1, that's
38:38 - going to take me roughly n steps.
38:40 - Technically n plus 1 steps.
38:41 - But n steps.
38:42 - Ergo big o of n.
38:44 - So it's a linear process.
38:45 - So possible but not
necessarily the fastest
38:48 - thing because he literally had to
move all those damn values around.
38:51 - So what would be better than this?
38:56 - And if you've programed before, you
might have the right instincts already.
38:59 - How do we solve this problem?
39:04 - Yeah?
39:05 - AUDIENCE: Would you allocate more
memory at the end of the array?
39:07 - DAVID J. MALAN: Reallocate more
memory at the end of the array.
39:10 - So it turns out c does have
a function called, realloc.
39:15 - Perfectly, if not obviously,
named that reallocates memory.
39:19 - And if you pass it, the address of
a chunk of memory you've allocated,
39:23 - and the operating system
notices, oh, yeah you got lucky.
39:26 - I've got more memory at
the end of this array,
39:28 - it will then allocate that additional
RAM for you, and let you use it.
39:32 - Or worst case, if there's
nothing available at the end
39:34 - of the array in memory,
because it's being
39:36 - used by something else in your program.
39:38 - That's fine.
39:39 - Realloc will take on the responsibility
of creating another array somewhere
39:44 - in memory, copying all of
that data for you into it,
39:48 - and returning the address
of that new chunk of memory.
39:51 - Unfortunately, that's still linear.
39:53 - Yeah?
39:53 - AUDIENCE: Is this all
being done in the heap?
39:55 - Or--
39:55 - DAVID J. MALAN: This is
all being done in the heap.
39:57 - Malloc, and realloc, and
free, all operate on the heap.
40:00 - Yes.
40:01 - So that is a solution, but it doesn't
really speak to the efficiency.
40:04 - Yeah?
40:05 - AUDIENCE: Could you use linked list?
40:06 - DAVID J. MALAN: Yeah.
40:07 - What is a linked list?
40:09 - Go ahead.
40:10 - AUDIENCE: It's when you have an element
that points to different elements.
40:13 - DAVID J. MALAN: OK.
40:14 - Points to other elements.
40:15 - Yeah.
40:15 - So let me speak to what's
the fundamental issue here.
40:18 - The fundamental problem is much like
painting yourself into a corner,
40:23 - so to speak, as the cliche goes.
40:25 - With an array, you're deciding in
advance how big the data structure is
40:29 - and committing to it.
40:30 - Well, what if you just do the opposite.
40:32 - Don't do that.
40:33 - If you want initially, room for
just one value, say one integer,
40:39 - only ask the computer for that.
40:41 - Give me space for one integer and
I'll put my number 42 in here.
40:44 - And then, if and only if,
you want a second integer,
40:48 - do you ask the computer
for a second integer.
40:50 - And so the computer, as by a malloc,
or whatnot, will give you another one
40:54 - like, the number 13.
40:55 - And if you want a third, just ask the
same question of the operating system.
40:58 - Each time just getting
back one chunk of memory.
41:02 - But there's a fundamental gotcha here.
41:05 - There's always a trade off.
41:06 - So yes, this is possible.
41:08 - You can call malloc three times.
41:10 - Each time asking for a chunk of
memory of size 1, instead of size 3,
41:13 - for instance.
41:15 - But what's the price you pay?
41:16 - Or what problem do we
still need to solve?
41:18 - Yeah?
41:19 - AUDIENCE: They're not
stored next to each other.
41:20 - DAVID J. MALAN: Yeah.
41:20 - They're not being stored
next to each other.
41:22 - So even though I can think of this as
being the first element, the second,
41:26 - and the third, you do not have, in
this story, random access to elements.
41:31 - And random access, ergo,
random access memory, or RAM,
41:35 - just means that arithmetically,
like, mathematically, you
41:38 - can jump to location 0, location 1,
location 2, randomly, or in constant
41:43 - time.
41:43 - Just instantly.
41:44 - Because if they're all back to back
to back, all you have to do is like,
41:47 - add 1, or add 4, or whatever to
the address, and you're there.
41:51 - But the problem is, if you're
calling malloc again and again
41:55 - and again, there's no guarantee
that these things are even
41:58 - going to be proximal to one another.
42:00 - These second chunks of
memory might end up--
42:03 - if this is a big chunk of
memory we've been talking about,
42:06 - where the heaps up here,
and the stacks down here--
42:09 - 42 might end up over here.
42:11 - The next chunk of memory,
50, might end up over here.
42:14 - The third chunk might end up over here.
42:16 - So you can't just jump from
location 0, to 1, to 2,
42:19 - because you have to somehow remember
where location 0, and 1, and 2, are.
42:25 - So how do we solve this?
42:27 - Even if you haven't programed before,
like, what would a solution be here?
42:33 - AUDIENCE: Somehow store [INAUDIBLE].
42:35 - DAVID J. MALAN: OK.
42:36 - Somehow storing the addresses of--
42:38 - AUDIENCE: Of the [INAUDIBLE]
42:40 - DAVID J. MALAN: All right.
42:40 - So let's just suppose, for the sake of
discussion, that this chunk of memory
42:44 - ended up at location 100.
42:45 - This one ended up at like 150.
42:48 - This one ended up at like 475.
42:51 - Whatever those values are.
42:53 - It would seem that somehow or other
I need to remember three values--
42:56 - 100, 150, and 475.
43:00 - So where can I store that?
43:01 - Well, it turns out, I can be a
little clever but a little greedy.
43:05 - I could say to malloc, you know what,
every time I call you, don't just
43:08 - give me space for an integer,
give me space for an integer
43:11 - plus the address of another integer.
43:15 - So if you've ever kind of seen like
popcorn strung together on a string,
43:19 - or any kind of chain link fence
where one link is linking to another.
43:24 - We could create the
equivalent of-- oops not that.
43:29 - We could create the equivalent
of this kind of picture,
43:33 - where each of these squares, or nodes,
we'll start calling them, kind of links
43:38 - graphically to the other.
43:39 - Well, we've seen these
links, or these pointers,
43:41 - literally arrows that are
pointing implemented in code.
43:44 - An arrow or a pointer
is just an address.
43:46 - So you know what?
43:47 - We should just ask malloc not for
enough space for just the number 42,
43:53 - we should instead, ask for a little
more memory in each of these squares,
43:57 - making them pictorially rectangles now.
44:00 - So that now, yes, we do have
these arrows conceptually
44:04 - pointing from one location to another.
44:06 - But what values do I actually want
to put in these new additional boxes?
44:10 - AUDIENCE: The addresses of the next.
44:12 - DAVID J. MALAN: The
addresses of the next.
44:13 - So they're like little breadcrumbs.
44:15 - So in this box here, associated
with the first value,
44:18 - should be the address
of my second value, 475.
44:22 - Associated with my second
value here, per the arrow--
44:26 - and let me draw the arrow
from the right place.
44:28 - --from the arrow, should be the
address 150, because that's the last.
44:33 - And then, from this extra
box, what should I put there?
44:37 - Yeah?
44:37 - AUDIENCE: Slash 0 or something?
44:38 - DAVID J. MALAN: Yeah.
44:39 - So probably, the equivalent of slash 0,
which in the world of pointer's recall,
44:43 - is null.
44:44 - So just a special value that means
that's it, this is the end of the line.
44:47 - That still leaves us with room to
add a fourth value and point to it,
44:51 - but it for now, signifies very clearly
to us there's nothing actually there.
44:56 - So what did we just do?
44:58 - We created a list of values
50, oh sorry 42, 50, 13,
45:03 - but we linked to them together.
45:04 - First, pictorially, with just arrows.
45:06 - Like any human might
with a piece of chalk.
45:08 - But technically in
code, we could do this
45:10 - by just storing addresses
in each of these places.
45:14 - So just to be clear then, what might
this actually translate to in code?
45:19 - Well, what if I proposed this.
45:22 - In code, we might do
something like this.
45:28 - If we want to store an integer.
45:29 - We're of course, going to need to
store like int n, we'll call it.
45:32 - n will represent 42, or 50, or 13.
45:35 - But if we want to
create a data structure,
45:37 - we might want to start giving
this data structure a name.
45:39 - I called it, a moment ago, node, which
is a CS term for a node in a linked
45:44 - list, so to speak.
45:45 - And it looks like this.
45:46 - So typedef means, give me my own type.
45:48 - Struct means, make it a
structure, like a student was.
45:51 - And then, node, which is going
to be the name of this thing.
45:53 - And I'll explain in a moment why I
have the word node twice this time.
45:57 - But I left room on the board
for just one more line.
46:01 - In addition to an int,
called n, or whatever,
46:06 - I need to somehow represent
in code, the additional memory
46:09 - that I want malloc to
give me for the address.
46:11 - So first of all, these are
addresses of what data types?
46:14 - Each of those three new boxes.
46:16 - AUDIENCE: [INAUDIBLE].
46:17 - DAVID J. MALAN: They are the addresses
of integers in that point in the story.
46:21 - But technically, what is
this box really pointing to?
46:26 - Is it pointing specifically to the ints?
46:29 - AUDIENCE: [INAUDIBLE].
46:30 - DAVID J. MALAN: It's pointing to that
whole chunk of memory, if you will.
46:33 - So if you start thinking about each
of these rectangles as being a node,
46:37 - and each of the arrows as
pointing to another node,
46:39 - we need to somehow express, I need
to somehow store a pointer to a node.
46:45 - In other words, each of these arrows
needs to point to another node.
46:48 - And in code, we could say this.
46:51 - Right?
46:52 - Like, let's give it a name.
46:53 - Instead of n, which is the
number, let's call it next.
46:55 - So next, shall be the name of this field
that points to the next node in memory.
46:59 - And node star, what does that
mean in English, if you will?
47:04 - AUDIENCE: [INAUDIBLE].
47:05 - DAVID J. MALAN: Say again?
47:06 - AUDIENCE: Pointing to an address.
47:07 - DAVID J. MALAN: Pointing to an address.
47:08 - Right?
47:08 - It looks different.
47:09 - Node is a new word
today and that's fine.
47:11 - But node star, just means
a pointer to a node.
47:14 - The address of a node.
47:15 - And it turns out that
this is a custom structure
47:18 - so we actually have to say this.
47:20 - But it's the same principle even though
things are kind of escalating quickly
47:23 - here, we just need to values, an int,
and then, a pointer to another thing.
47:29 - That other thing is
going to be another node.
47:31 - And we're just using a node,
frankly, to encapsulate two values--
47:35 - an int and a pointer.
47:36 - And the way you express in C,
albeit somewhat cryptically,
47:39 - a pointer, or one of those arrows, is
you say give me a variable called next,
47:43 - have it point to a
structure called node.
47:47 - Or rather, have it be the address
of a structure of type node.
47:51 - Yeah?
47:52 - AUDIENCE: How can you [? reveal ?]
the timing of struct node [INAUDIBLE]??
48:00 - DAVID J. MALAN: Good question.
48:01 - So this feels like a circular kind of
definition because I'm defining a node,
48:06 - and yet, inside of a node is a node.
48:08 - That is OK because of the star.
48:11 - It is necessary in C--
48:14 - remember that C always is
kind of read top to bottom.
48:18 - So accordingly, this very first line
of code here, typedef struct note,
48:22 - at that point in the story,
when clang has read that line,
48:25 - it knows that a phrase,
struct node, exists.
48:28 - AUDIENCE: That's why you
say nodes [INAUDIBLE]..
48:30 - DAVID J. MALAN: Exactly.
48:32 - Exactly.
48:32 - We didn't need to do this with
students because there were
48:34 - no pointers involved to other students.
48:36 - But yes, in this case.
48:37 - So in short, this tells clang, hey,
clang, give me a structure called node.
48:42 - And then, in here, we say,
hey, clang, each of those nodes
48:45 - shall have two things,
an integer called n,
48:47 - and a pointer to another one of
these data structures of type node,
48:52 - and call the whole thing, node.
48:55 - It's a bit of a mouthful.
48:56 - But all this is, is the following.
48:58 - Let me go ahead and erase all of this.
49:00 - All this data type is--
49:03 - if we get rid of the picture
we draw on the fly there.
49:07 - --is this says, hey, clang,
give me a data structure
49:10 - that pictorially looks like this.
49:12 - It's divided into two parts.
49:14 - The first part is called n, the
second type is called, next.
49:18 - This data type is of type int.
49:20 - This is a pointer to another such node.
49:24 - And that's it.
49:24 - Even though the code looks
complex, the idea is exactly that.
49:28 - Yeah?
49:29 - AUDIENCE: [INAUDIBLE]?
49:31 - Why do you have to
say struct node again?
49:34 - DAVID J. MALAN: Good question.
49:37 - The reason is, as just
came up a moment ago, clang
49:42 - and C, in general, are kind of dumb.
49:43 - They just read code top to bottom.
49:45 - And the problem is, you have to
declare the name of this structure
49:49 - as being a struct node
before you actually use it.
49:52 - It's similar in spirit to our discussion
of prototypes-- y functions need
49:55 - to be mentioned way up top.
49:57 - This just says to clang, give
me a type called struct node.
50:00 - You don't know what it's
going to look like yet.
50:02 - But I'll finish my thought later.
50:05 - And then in here, we're just
telling clang, inside of that node
50:08 - should be an integer, as well as,
a pointer to the very type of thing
50:12 - I'm in the middle of defining.
50:14 - But if I had left off the word node
up there, and just said struct,
50:17 - you couldn't do that because it
hasn't seen the word N-O-D-E yet.
50:21 - That's all.
50:22 - Other questions?
50:24 - All right.
50:25 - So if I now have a data
structure called node,
50:29 - I can use it to kind of stitch
together these linked lists.
50:32 - And maybe just the very
things a little bit,
50:34 - and to start giving away
some ducks, would folks
50:37 - be comfortable with volunteering
to solve a problem here?
50:40 - Yeah?
50:41 - OK.
50:41 - Come on up.
50:42 - 1, 2--
50:44 - AUDIENCE: [INAUDIBLE].
50:45 - DAVID J. MALAN: Sure.
50:46 - Or you can take a duck and run.
50:48 - OK.
50:48 - 1, 2, how about 3?
50:49 - Come on over here, 3.
50:51 - So if you want to be our first
pointer, you can be number 5.
50:54 - Come on over here.
50:55 - You want to be number 9.
50:57 - And one more.
50:58 - One more volunteer.
50:59 - Come on over here.
51:00 - Yeah.
51:01 - All right.
51:02 - So-- I'll meet you over here.
51:08 - OK, 17.
51:10 - All right.
51:10 - So if you'd like to--
51:11 - just so we pick this up for
those following along at home.
51:14 - If you would like to just
say hello to the audience.
51:16 - ANDREA: Hi, I'm Andrea.
51:17 - [? COMEY: ?] Hi, [? I'm Comey. ?]
51:19 - [? KYONG: ?] Hi, [? I'm Kyong. ?]
51:21 - SPEAKER 2: Hi, I'm [INAUDIBLE].
51:22 - DAVID J. MALAN: Wonderful.
51:24 - OK.
51:24 - If you wouldn't mind all just taking
a big step back over the ducks,
51:26 - just so that we're a
little farther back.
51:28 - Let's go ahead and do this.
51:29 - If you're our first pointer, if you
could come over here for instance,
51:33 - and just stand outside the ducks.
51:34 - And if you guys could come a little
over here in front is still fine.
51:37 - So here we have the
makings of a linked list.
51:40 - And what's your name again?
51:41 - [? COMEY: ?] [? Comey. ?]
51:42 - DAVID J. MALAN: [? Comey ?] is
our first pointer if you will.
51:45 - Via [? Comey's ?]
variable are we just going
51:47 - to keep track of the first
element of the linked list.
51:49 - So if you could, with your
left hand, represent first.
51:52 - Just point over at--
what was your name again?
51:54 - ANDREA: Andrea.
51:55 - DAVID J. MALAN: So
Andrea is the number 9.
51:56 - If you could use your left
hand to point at number 5.
51:59 - And if you could use your left
hand, yep, to point at number 17.
52:02 - And your left hand to just point at
null, which we'll just call the ground.
52:05 - So you don't want to
just point it randomly
52:07 - because that would be like following
a bogus pointer, so here means null.
52:10 - All right.
52:11 - So this is a linked list.
52:12 - All you need to store are
linked list of three values
52:15 - is three nodes, inside of
which are three integers,
52:19 - and their left hands represents
that next pointer, so to speak.
52:22 - [? Comey's ?] a little different,
in that she's not holding a value.
52:25 - She's not holding an integer.
52:27 - Rather, holding just the
name of the variable, first.
52:31 - So you're the only one that's
different here fundamentally.
52:34 - So suppose I want to
insert the number 20?
52:36 - Could someone volunteer to be number 20?
52:38 - OK.
52:38 - Come on up.
52:40 - All right.
52:41 - And what's your name?
52:43 - ERIC: Eric.
52:43 - DAVID J. MALAN: Eric.
52:44 - Eric, you're the number 20.
52:45 - And Eric, actually, let's see.
52:50 - Actually can we do this?
52:52 - Let me give-- let me make
this a little more different.
52:57 - OK.
52:57 - That never happened.
52:59 - OK.
52:59 - Eric, give me that please.
53:02 - I want to insert Eric as number 5.
53:04 - So Eric, I'm keeping this list sorted.
53:06 - So where, obviously, you're going to go?
53:08 - ERIC: Go right there.
53:09 - DAVID J. MALAN: All right.
53:09 - But before you do that, let's just
consider what this looks like in code.
53:12 - In code, presumably, we have
malloced Eric from the audience.
53:17 - I've given him a value, n of number 5.
53:20 - And his left hand is like, it's garbage
value right now, because it's not
53:23 - pointing to anything specific.
53:25 - So he's got two values-- an integer,
and a left hand representing
53:28 - the next pointer.
53:30 - If the goal is to put
Eric in sorted order.
53:34 - What should our steps be?
53:36 - Like, whose hand should point
where, and in what order?
53:38 - Yeah.
53:39 - Give us one step.
53:39 - AUDIENCE: You should point to number 9.
53:41 - DAVID J. MALAN: OK so you
should point at number 9,
53:43 - which is equivalent to saying,
point at whatever first.
53:46 - Where [? Comey ?] is pointing at.
53:48 - So go ahead and do that.
53:49 - All right next?
53:50 - What's the next step?
53:50 - Someone else?
53:54 - Someone else.
53:54 - Almost there.
53:55 - Yeah?
53:55 - AUDIENCE: First should point to 5.
53:57 - DAVID J. MALAN: OK.
53:58 - So first, or [? Comey, ?]
could you point to 5.
54:00 - And that's fine.
54:00 - You don't even have to move.
54:01 - Right?
54:01 - This is the beauty of a linked list.
54:03 - It doesn't matter where
you are in memory,
54:05 - it's the whole beauty of these
pointers, where you can literally
54:08 - point at that other location.
54:09 - It's not an array where they need
to be standing back to back to back.
54:12 - They can be pointing anywhere.
54:13 - All right.
54:14 - Let's go ahead and insert one more.
54:15 - Who wants to be say, 55?
54:17 - Big value.
54:17 - Yeah.
54:18 - Come on down.
54:20 - All right.
54:21 - What's your name?
54:21 - [? KYONG: ?] [? Kyong. ?]
54:22 - DAVID J. MALAN: [? Kyong. ?] OK.
54:23 - So come on over.
54:24 - So we've just malloced
[? Kyong ?] from the audience.
54:26 - I've given him his end value of 55.
54:28 - His left hand is just some
garbage value right now.
54:31 - How do we insert [? Kyong ?]
in the right order?
54:34 - Where is the obviously supposed to go?
54:36 - In sorted order, he
obviously belongs at the end.
54:39 - But here's the catch
with the linked list.
54:42 - Just like when we've discussed
searching and sorting in the past,
54:45 - the computer is pretty blind
to all but just one value.
54:48 - And the linked list, at the moment--
54:50 - like, I don't know that these
three, these four, exist.
54:52 - All I know really, is
that [? Comey ?] exists.
54:55 - Because via this first
pointer, is the only access
54:58 - to the rest of the elements.
55:00 - And so what's cool about a linked
list, but perhaps not obvious,
55:03 - is that you only--
55:04 - the most important value is the first.
55:06 - Because from the first value,
you can get to everyone else.
55:09 - It's not useful-- excuse me
for me to remember, Andrea?
55:12 - --Andrea alone, because
if I do, I've just
55:14 - lost track of [? Comey ?] and more
importantly, because of his number,
55:18 - Eric.
55:18 - So all I have to do really,
is remember [? Comey. ?]
55:21 - So if the goal now is to insert number
55, what steps should come first?
55:27 - No pun intended.
55:28 - AUDIENCE: [INAUDIBLE].
55:29 - DAVID J. MALAN: Say again.
55:30 - AUDIENCE: Finding the first space.
55:31 - DAVID J. MALAN: OK.
55:32 - Finding the first space.
55:33 - So I'm going to start at [? Comey, ?]
and I'm going to follow this pointer.
55:36 - Number 5, does 55 belong here?
55:39 - No.
55:39 - So I'm going to follow this
pointer and get to Andrea.
55:42 - Does 55 belong here?
55:43 - No.
55:43 - Gonna follow her pointer,
and 22, does it belong here?
55:46 - No.
55:47 - I follow this pointer, 26?
55:48 - No.
55:49 - But you have a free hand, it turns out.
55:51 - So what step should come next?
55:52 - AUDIENCE: [INAUDIBLE].
55:54 - DAVID J. MALAN: We could have
you point at 55, and now done.
55:58 - So relatively simple, but what
was the running time of this?
56:02 - AUDIENCE: [INAUDIBLE].
56:04 - DAVID J. MALAN: It's big o of n.
56:05 - It's linear.
56:06 - Because I had to start at
the beginning, even though we
56:08 - humans have the luxury
of just eyeballing it.
56:10 - Saying, oh, obviously, he
belongs way at the end.
56:11 - Mm-mm.
56:12 - Not in code.
56:13 - Like, we have to start at the beginning
to reverse the whole darn list,
56:16 - until we get linearly to the very end.
56:17 - And now we're done.
56:18 - Let's try one last one.
56:20 - How about 20?
56:21 - Yeah.
56:22 - Great.
56:22 - Come on down.
56:23 - What's your name?
56:24 - JAMES: James.
56:24 - DAVID J. MALAN: James.
56:25 - All right, James.
56:26 - All right.
56:26 - So we just malloced James,
given him the number 20.
56:28 - He obviously belongs
roughly in the middle.
56:30 - What's the first step?
56:32 - AUDIENCE: [INAUDIBLE].
56:33 - DAVID J. MALAN: Sorry?
56:34 - AUDIENCE: [INAUDIBLE].
56:35 - DAVID J. MALAN: All right.
56:35 - So we start with [? Comey, ?] again.
56:36 - All right.
56:37 - First, OK.
56:37 - 5, do you belong here?
56:39 - No.
56:40 - Let me follow the link.
56:41 - OK 9, do you belong here?
56:42 - No.
56:43 - Do you belong at 22-- ooh.
56:44 - But what did I just do wrong?
56:48 - I went too far.
56:49 - At least in this story.
56:50 - Like, I literally--
Andrea is behind me now.
56:52 - OK.
56:52 - So can I follow the pointer backwards?
56:55 - You can't.
56:55 - Like in every picture we've
drawn, and every example
56:58 - we've done with an address, we only
have the address of the next pointer.
57:00 - We don't have what's called, a doubly
linked list, at least in this story,
57:03 - where I can just turn around.
57:04 - So that was a bug.
57:05 - So I need to start over instead.
57:06 - First, OK 5, OK 19--
57:09 - what I really need in
code, ultimately, is
57:11 - to kind of peek ahead and not
actually move-- not that far.
57:14 - Just to 22.
57:15 - Peek ahead at 22 and realize,
oh, that's going to be too far.
57:19 - This is not yet far enough.
57:20 - So let's go ahead and bring James over.
57:22 - Well, actually, you can
stay there physically.
57:24 - But what step has to happen first?
57:26 - I know now he belongs in here.
57:29 - You want to point at him?
57:31 - OK.
57:31 - Point at him.
57:32 - ANDREA: Oh.
57:32 - I'm sorry, he points first.
57:34 - DAVID J. MALAN: Well let's do
that, just because it is incorrect.
57:35 - That's fine.
57:36 - OK.
57:36 - Andrea proposed that we point here, but
she just broke the whole linked list.
57:40 - Why?
57:40 - ANDREA: Because there's
nothing to point at.
57:42 - DAVID J. MALAN: Right.
57:43 - No one is remembering--
what's was your name again?
57:45 - [? KYONG: ?] [? Kyong. ?]
57:45 - DAVID J. MALAN: No one's
remembered where [? Kyong ?] was.
57:47 - So you can't do that.
57:47 - Your left hand has to stay there.
57:49 - So what steps should
happen first instead?
57:50 - AUDIENCE: [INAUDIBLE].
57:52 - DAVID J. MALAN: James
should point at whatever
57:54 - Andrea is pointing at, perhaps?
57:56 - So a little redundantly at
the moment, just like before.
57:58 - OK.
57:59 - Now what happens next?
58:00 - That's step one.
58:00 - ANDREA: Now I can point.
58:01 - DAVID J. MALAN: Now
you can point at him.
58:03 - OK.
58:04 - You could do that.
58:05 - All right.
58:05 - And so now, this looks
like a complete mess,
58:08 - but if we know that
[? Comey ?] is first,
58:10 - we can follow the breadcrumbs to Eric,
and then to Andrea, and then to James,
58:16 - and then the rest of our
list step by step by step.
58:20 - So it's a huge amount of like logic now.
58:23 - But what problem have we solved?
58:24 - And I think we identified
it over here earlier.
58:26 - What was the problem first
and foremost with the arrays?
58:29 - AUDIENCE: [INAUDIBLE].
58:30 - DAVID J. MALAN: You have to
decide on their size in advance.
58:33 - And once you do that, if you want
to add an additional element,
58:36 - you have to resize the whole darn thing.
58:38 - Which is expensive because you
have to move everyone around.
58:41 - Now frankly, I'm being
a little greedy here.
58:43 - And every time we've
inserted these new elements,
58:45 - I've been keeping them in sorted order.
58:46 - So it would seem that if you insert
things in sorted order, big o event,
58:50 - every time.
58:51 - Because in the worst
case, the new element
58:52 - might end up all the way at the end.
58:54 - But what if we relax that constraint?
58:55 - What if I'm not so uptight and need
everything nice and orderly and sorted?
58:59 - What if I just want to keep growing
the list in any random order?
59:02 - And I allocate the number 34.
59:05 - And I'll play the number 34.
59:06 - Malloc 34.
59:08 - Where is the quickest
place for me to go?
59:11 - Yeah?
59:12 - AUDIENCE: Point to 5, and
then have [INAUDIBLE]..
59:14 - DAVID J. MALAN: OK.
59:14 - I'll point to 5, and then,
[? Comey, ?] if you could point to me.
59:16 - Done.
59:17 - One-- well, two steps.
59:18 - All right.
59:19 - Suppose now, I malloc 17 with
someone else, who'll we'll
59:22 - pretend is right here.
59:23 - Where's the best place for 17 to go?
59:25 - AUDIENCE: [INAUDIBLE].
59:26 - DAVID J. MALAN: Right
after [? Comey ?] too.
59:28 - So now, [? Comey ?] can point at 17, 17
can point at me, I can point at Eric,
59:33 - and so forth.
59:34 - And that's two steps again.
59:35 - Two steps-- if it's the same
number of steps every time,
59:38 - we call that, constant time.
59:39 - And we write it as big o of 1.
59:41 - And so here too, it's just a trade off.
59:43 - If you want really fast insertions,
don't worry about sorting.
59:46 - Just put them at the beginning
and deal with it later.
59:48 - If you want a dynamic resizeability,
don't use an array, use a linked list,
59:52 - and just keep allocating more and
more as you go without wasting
59:55 - a huge amount of space too.
59:56 - Which notice, that's another
big problem with an array.
59:59 - If you over allocate space, and only use
part of it, you're just wasting space.
60:02 - So there's no one solution here.
60:04 - But we do now have the
capabilities, thanks to the structs
60:06 - and pointers to stitch together,
if you will, these new problems.
60:11 - Yes, please.
60:12 - SPEAKER 2: Why can't
the node [INAUDIBLE]??
60:17 - DAVID J. MALAN: And
who am I in this story?
60:19 - SPEAKER 2: [INAUDIBLE].
60:20 - DAVID J. MALAN: Oh, OK.
60:21 - Absolutely.
60:22 - So another very reasonable
idea would be, well,
60:24 - why don't we just put
the new ones at the end?
60:26 - That's fine if I keep
track of who is at the end.
60:30 - The problem, is at the
moment in the story,
60:32 - and we'll ultimately see this in code,
I'm only remembering [? Comey. ?] And
60:35 - from [? Comey ?] am I
getting everywhere else.
60:37 - I could have another
pointer, a second pointer,
60:40 - and literally call it, last,
that's equivalent to you.
60:42 - Or that's always pointing at you.
60:44 - I just need then two pointers,
one literally called first,
60:46 - one literally called last.
60:47 - That's fine.
60:48 - That's a nice optimization if I want
to throw all the elements at the end.
60:52 - And frankly, I could get really fancy--
60:54 - and to solve the problem
that Andrea cited earlier--
60:57 - if I store not just an int
and a pointer, but instead,
61:00 - an int and two pointers,
I can even have each
61:03 - of these guys pointing with
their left and right hands
61:05 - in a doubly linked list, so as to solve
the problem Andrea identified, which
61:10 - was if I go too far no big deal.
61:12 - Take one step back.
61:13 - I don't have to think as
hard about that logic.
61:15 - So there too, a trade off.
61:17 - Let's go ahead and take
a five minute break.
61:18 - I'll turn on some music.
61:19 - Grab a duck now, if you'd like.
61:20 - And we'll return with some
fancier data structures still.
61:22 - Thanks.
61:23 - All right.
61:24 - We're back.
61:24 - So let's now translate some
of these ideas to code.
61:27 - So that we can actually solve
this problem a little more
61:29 - concretely than just having
humans pointing at each other.
61:32 - So for instance, let's
try to distill everything
61:34 - we've been talking about
into just a goal in code
61:37 - of storing a list of numbers.
61:39 - I would propose that we can take
like three passes at this problem.
61:42 - The first would be, let's just
decide in advance how many numbers we
61:45 - want to store so we don't
have to deal with all
61:47 - this complexity with the pointing
and the pointers and all this,
61:50 - and just hard code that
value somehow, and just stop
61:53 - when the user is inputted
that many numbers and no more.
61:56 - Two, we can improve upon that and at
least let the user dynamically resize
62:01 - their array.
62:02 - So that if they decide to input
more numbers than we intend,
62:05 - it's going to grow, and deal with that.
62:06 - Of course, arrays are
not necessarily ideal
62:08 - because they have to do all that
damn copying from old to new.
62:11 - That's linear time.
62:12 - It would seem smartest to
get subversion 3, which
62:14 - is actually going to use a linked list.
62:16 - So we're just more modestly
allocating space for another number,
62:20 - and another number, and another
number, or really a node.
62:23 - One number at a time.
62:25 - So let me go ahead and start as follows.
62:27 - I'm going to go ahead and include
some familiar lines in list 0.c,
62:33 - of the CS50 library, just to make it
easy to get some user input for this.
62:36 - And standard iO dot h, for printdef.
62:38 - And let me go ahead and declare
my main function as usual.
62:42 - And then, in here let's
do a couple of things.
62:44 - First, let's ask the user
for the capacity of the array
62:48 - that we're going to use.
62:49 - Or rather, let's do this first.
62:50 - Let me first rewind
and say, you know what?
62:53 - Int, numbers, 50.
62:55 - Well, that's going to be
annoying to type in 50 numbers.
62:58 - We're going to give the user two numbers
at first, that here, she can type in.
63:01 - Next, let's go ahead and prompt
the user for those numbers.
63:05 - So let me go ahead and say--
63:09 - let's do this.
63:09 - Let's at least clean this up a little
bit so that we can reuse this value.
63:13 - So we don't have a magic number.
63:14 - This just came up in
discussion actually.
63:16 - So while-- do I want to do that?
63:20 - Nope.
63:21 - Let me fix this.
63:22 - This will be my capacity of size 2.
63:24 - And that's going to give me that size.
63:26 - And then, I'm going to keep
track of how many integers
63:28 - I've prompted the user for so far.
63:30 - So initially, the size of this
structure is going to be 0.
63:33 - But it's capacity, so to speak, is 2.
63:35 - So size means how many things are in it.
63:36 - Capacity means how many
things can be in it.
63:39 - And while the size of the structure
is less than its capacity,
63:43 - let's go ahead and get
some inputs from the user.
63:45 - Let's go ahead and ask them for a
number, using our old friend, get int.
63:49 - And just say, give me a number.
63:51 - And then, let me go ahead
and insert the number
63:54 - that they type in into this array
at location size, like this.
64:00 - And then, do size plus, plus.
64:02 - I think.
64:03 - You know, I wrote it pretty quickly.
64:05 - But let's consider what I just did.
64:07 - I initialized size to 0, because
there's nothing in it initially.
64:10 - Then I say, while size is less than
the capacity of the whole thing--
64:13 - and capacity is 2 by default--
64:15 - go ahead and do the following.
64:17 - Give me an int from the user.
64:19 - OK.
64:19 - So int number gets int.
64:21 - Then, put at location,
size, in my numbers, array,
64:25 - whatever the human typed in, number.
64:28 - And then, increment
size with plus, plus.
64:30 - All right.
64:31 - So on the first iteration size is 0.
64:33 - So numbers, bracket, 0,
gets the first number.
64:35 - Numbers, bracket, 1,
gets the second number.
64:37 - Then, size equals capacity.
64:39 - So it stops, logically.
64:40 - Any questions on the logic of this code?
64:44 - All right.
64:45 - So once we have those numbers,
let's just do something simple.
64:48 - Like for int, I gets 0.
64:50 - I is less than the actual
size I, plus, plus.
64:53 - Let's just go ahead and
print out the number
65:00 - you inputted, percent I, backslash n,
and type out numbers, bracket, I. All
65:07 - right.
65:07 - So if I made no typos in list 0
dot C, then, I'm going to go ahead
65:12 - and do dot, slash, o, dot, C. I'm going
to be prompted for a couple of numbers.
65:16 - Let's go ahead and do 1, 2.
65:18 - You inputted 1, you inputted 2.
65:19 - All right.
65:20 - So not bad.
65:21 - But this is bad design, arguably, why?
65:27 - Just find one fault. It's correct.
65:29 - But bad design.
65:32 - AUDIENCE: Repetitive.
65:33 - DAVID J. MALAN: Repetitive, because
I'm using a couple of loops, sure.
65:36 - And it's fundamentally-- it's
very limited in functionality.
65:39 - Why?
65:40 - Like how useful is this program?
65:42 - AUDIENCE: It's hard coded at 2.
65:43 - DAVID J. MALAN: Yeah.
65:43 - It's hard coded at 2.
65:44 - So let's at least improve
upon this a little bit,
65:47 - and get rid of this hard coding.
65:48 - Why don't I at least ask the
user for something like this?
65:52 - Well, instead of just declaring the
capacity, let me go ahead and say,
65:56 - you know what?
65:57 - Let's just replace the 2.
65:58 - Get int, and just say
capacity, for instance.
66:01 - All right.
66:02 - And now if I do this, I'm
going to be prompted--
66:05 - so make list 0.
66:07 - Dot slash list 0.
66:10 - The capacity will be 2.
66:12 - 1, 2, that's nice.
66:14 - But if I run it again, and
give it a capacity of 3--
66:17 - 1, 2, 3, I get more capacity.
66:21 - So that's nice.
66:21 - It's an improvement for sure.
66:23 - There is a bug here.
66:25 - Before I test it further, can anyone
identify a bug or somehow crash this?
66:33 - AUDIENCE: [INAUDIBLE].
66:34 - DAVID J. MALAN: Oh, go ahead.
66:34 - AUDIENCE: If you don't input an integer.
66:36 - DAVID J. MALAN: If I
don't put an integer.
66:38 - Or-- is that same comment up here?
66:39 - AUDIENCE: I was going to say,
what happens if you go back
66:42 - and put in [INAUDIBLE] those other
[INAUDIBLE] will be in the memory.
66:47 - DAVID J. MALAN: Oh.
66:48 - No.
66:48 - Because I'm rerunning it in each time.
66:50 - I don't need to worry about
previous runs of the program.
66:53 - Yeah?
66:53 - AUDIENCE: In the for
loop, it just goes 1,
66:56 - 2, 3, it doesn't actually
care what you put it.
66:59 - DAVID J. MALAN: [INAUDIBLE] 1, 2,
3-- well, I am iterating up to size,
67:03 - which could be capacity.
67:04 - Because now they do end
up being equivalent.
67:06 - Because I'm filling the whole thing.
67:08 - But let's try this.
67:08 - If you don't type in a value.
67:10 - So let me go ahead and rerun this.
67:12 - My capacity shall be duck.
67:15 - All right.
67:16 - So we did handle that.
67:17 - Because getInt does that for me.
67:19 - But I bet I can still break this.
67:21 - Ooh, yeah, let's always
try something negative.
67:24 - Oh, OK.
67:25 - So bad.
67:25 - Like cryptic looking
message, but clearly,
67:27 - has to do with a negative value.
67:28 - So I should probably be a
little smarter about this.
67:31 - And recall from like,
Week 1, we did do this.
67:33 - With Mario, you might have done this.
67:35 - So I could do something like, do,
while capacity is less than 1.
67:41 - I could go ahead and say,
capacity getInt capacity.
67:46 - So just a little bit of error checking
to close the bug that you identified.
67:50 - All right.
67:50 - So let's go ahead and recompile this.
67:52 - Make lists 0-- oops we're going
to start hearing that a lot today.
67:57 - Aren't we [INAUDIBLE]?
67:57 - Make list 0, dot, slash, list 0.
68:00 - Capacity will be 3.
68:01 - 1, 2, 3.
68:02 - Now capacity will be negative 1.
68:04 - Doesn't allow it.
68:05 - Capacity 0, doesn't allow it.
68:07 - Capacity 1, yes.
68:09 - So non-exhaustively, I've tested it.
68:11 - It feels like it's in better shape.
68:12 - OK.
68:12 - But this program, while correct,
and while more featureful,
68:16 - still has this fundamental limit.
68:18 - Wouldn't it be nice to allow the
user to just keep typing numbers,
68:21 - as many as they want, and then quit
once they're done inputting numbers.
68:26 - Right?
68:26 - If you're making a program
to compute someone's GPA,
68:29 - different students might
have taken different courses,
68:31 - you don't want to have them
to type in all 32 courses.
68:33 - If they're younger and haven't
taken all those courses.
68:35 - Like there's a lot of scenarios
where you don't know in advance how
68:38 - many numbers the user wants to provide.
68:40 - But you want to support a few
numbers, lots of numbers, or beyond.
68:43 - So let's do this in a second version.
68:46 - In list 1 dot C, let me go ahead and
improve upon that example as follows.
68:52 - First, let me give my familiar
friends up here CS50 dot for iO,
68:57 - standard iO dot h, and then,
in here, int main void.
69:02 - And then, let's start writing this.
69:05 - So now, I don't know in advance,
necessarily, how many numbers the user
69:10 - is going to type in.
69:11 - Like the goal is, I want
them to be able to type
69:13 - in a number, another number,
another number, and then
69:16 - hit the equivalent of like, q, for quit,
when they're done inputting numbers.
69:19 - Like I don't want them to have to think
about in advance, how many numbers it
69:22 - is they're inputting.
69:24 - But how do I do that?
69:26 - Like I can't just come up with an
array called numbers, and say, 50.
69:30 - Because if the user wants
to type in 51 numbers,
69:32 - I'm going to have to resize that.
69:34 - But how do you resize an array?
69:39 - How do you resize an array?
69:41 - AUDIENCE: [INAUDIBLE].
69:43 - DAVID J. MALAN: What's that?
69:43 - AUDIENCE: You can't.
69:44 - DAVID J. MALAN: You can't.
69:44 - Right.
69:45 - We've never seen an instance
where you've re-sized an array.
69:47 - We talked about it on
the blackboard here.
69:49 - Well, just like, allocate a
bigger one and copy everything in.
69:52 - And we did identify realloc.
69:54 - But you can't actually
use realloc on an array.
69:57 - Realloc actually accepts an
address of a chunk of memory
70:01 - that you want to grow, or shrink.
70:04 - So it turns out, if we
now start to harness
70:06 - the sort of fundamental definition of
what an array is, a chunk of memory,
70:10 - we can actually build arrays ourselves.
70:13 - If an array is just a chunk of
memory, or more specifically,
70:16 - it's like the address of the
first byte of a chunk of memory,
70:21 - it would seem that I could declare
my array, not with square brackets
70:25 - as we've been doing for
weeks, but I can say,
70:27 - you know what numbers really
is, it's really just a pointer.
70:31 - And I'm initially going
to initialize it to null.
70:33 - Because there is no array.
70:35 - But now I have the ability
to point that pointer
70:37 - at any chunk of memory, small or big.
70:41 - Now why is this useful?
70:42 - Well, initially let me
claim that my capacity is 0,
70:44 - because nothing's going on yet.
70:45 - I haven't called malloc or anything.
70:47 - And initially, my size is 0 because
there's nothing in the array.
70:52 - And it doesn't even have a size.
70:53 - But let me just do this forever.
70:55 - Much like in scratch, we had the forever
block you can use, while true, and C,
70:59 - to just say keep doing this until
the user breaks out of this.
71:02 - And let me go ahead and ask the
user, give me a number, getInt.
71:06 - And just ask them for a number.
71:09 - And then, we just need
a place to put that.
71:11 - So where do I put this number?
71:14 - Well, do I have, at the moment,
any place to put the number?
71:18 - No.
71:18 - And technically speaking,
how do you express that?
71:20 - Like in pseudo code, I want to
say, if no place for number.
71:25 - But technically, I could do this.
71:26 - Well, if the size of the array at
the moment, equals its capacity,
71:33 - that feels like a lower level
way of expressing the same thing.
71:36 - If whatever the capacity is, if the
size is the same, there is no more room.
71:41 - And that simple statement also covers
the scenario where the capacity is 0,
71:47 - the size is therefore, 0.
71:48 - So its the same question.
71:50 - Either we have no space at
all, or we have some space
71:52 - but we've used it all-- size
equals, equals, capacity.
71:56 - So if the size equals
capacity, or put more casually,
71:59 - if I don't have enough space.
72:01 - What do I want to do intuitively?
72:03 - AUDIENCE: [INAUDIBLE].
72:04 - DAVID J. MALAN: Allocate more memory.
72:06 - And it turns out, you proposed,
or someone proposed earlier,
72:09 - reallocating memory.
72:10 - We can use this function
for the very first time.
72:13 - Let me go ahead and say this--
72:14 - the catch with realloc is you
have to be smart about it,
72:16 - because it returns a pointer.
72:18 - So let me propose this code first.
72:19 - First, just give me a temporary
variable, call it, temp,
72:23 - that's going to store the following.
72:25 - Actually, no.
72:26 - Let me start this more simply.
72:28 - Let me go ahead and say, numbers
should be reallocated please,
72:34 - realloc by passing its self in.
72:39 - And this time, give me the
size of an int, times--
72:43 - how many ints do I want this time?
72:47 - How many numbers did the
human just input presumably?
72:52 - AUDIENCE: [INAUDIBLE].
72:53 - DAVID J. MALAN: Just one.
72:54 - Right.
72:54 - Because literally, we've only
called getInt once in this story.
72:57 - So whatever the size of this array
is now, we need to increase it by 1.
73:03 - That's all.
73:04 - So this line of code here
is saying, hey computer,
73:09 - go ahead and reallocate this array
from whatever its current size is,
73:15 - and make it this size instead.
73:18 - The size of whatever it is, plus
1, times the size of an int.
73:22 - Because that's what we're
trying to store, is an int.
73:24 - So we have to do that multiplication.
73:26 - And realloc, as mentioned
earlier, is pretty fancy.
73:28 - It's going to take an pointer,
whatever chunk of memory
73:31 - you've already allocated, and
it's going to then reallocate
73:34 - a bigger chunk of memory.
73:36 - Hopefully, what's going
to happen is this--
73:38 - if your chunk of memory
initially looks like this,
73:41 - it's going to hopefully notice,
oh, this memory is free.
73:44 - Let me just give you
back the same address.
73:46 - So if this is address
100, and you get lucky
73:48 - and this address is also
available, the realloc function's
73:51 - going to remember that
for the operating system.
73:53 - It's going to return
the number 100 again.
73:55 - And you're good to go.
73:56 - You can safely touch memory here.
73:57 - Or if this is in use already, this
chunk of memory, and therefore we
74:03 - can't fit another byte there
because some other code you wrote
74:06 - is using that memory.
74:08 - But there is twice as much
memory available down here.
74:11 - What realloc will do, is if
you've stored the number 50,
74:14 - it will handle the process of
copying 50 to the new value.
74:18 - This is going to be left as a
garbage value for you to deal with.
74:20 - And it's going to return to you the
address of the new chunk of memory,
74:24 - having done the copying for you.
74:27 - So even though it's technically
re-allocating the array,
74:30 - it's not necessarily
just going to grow it.
74:32 - It might relocate it in
memory to a bigger chunk,
74:36 - and then give you the new
address of that memory.
74:39 - Question?
74:39 - AUDIENCE: Is that
process really preferable
74:42 - to just creating extra
memory in it's place.
74:45 - And then saving the time and energy of
reallocating them [? all at once. ?]
74:50 - DAVID J. MALAN: That's
a really good question.
74:52 - Honestly, we could avoid this problem
slightly by just doing, you know what,
74:55 - give me at least--
74:57 - go ahead and give me at least
the size of an int, times--
75:01 - I don't know, most humans are not
going to type in more than 50 numbers.
75:04 - Let's just pick 50.
75:05 - So you could do this, and that
would indeed save you time.
75:08 - Because the approach
I'm currently taking
75:10 - is pretty inefficient because
every damn time the user
75:13 - calls getInt, and gives an int,
we're resizing, resizing, resizing.
75:17 - Very expensive.
75:18 - As to what the best value is though--
75:20 - 50?
75:20 - Should it be 25?
75:21 - Should it be 1,000?
75:23 - I'm either going to
under bet or over bet.
75:25 - And it just depends on you to decide
which of those is the worst decisions.
75:30 - AUDIENCE: But, like,
in terms of programs,
75:32 - is it also pretty expensive to
have memory that you're not using
75:36 - or generally, is it usually more OK?
75:37 - DAVID J. MALAN: Good question.
75:39 - In programs you're writing, is it better
to have more memory than you're using,
75:42 - or should you really be conservative?
75:43 - These days, memory is cheap.
75:45 - We all have gigabytes of memory.
75:47 - And so wasting 50 bytes or 200 bytes,
times 4, of memory, not a big deal.
75:52 - Like, just get the job
done quickly and easily.
75:54 - But in resource constrained
devices, maybe, things like phones
75:57 - or little internet of
things style devices
76:00 - that have a lot fewer resources, you
don't really want to go wasting bytes.
76:04 - But honestly, the CPUs, the
brains in our computers,
76:06 - are so darned fast these days,
even if you're calling malloc
76:08 - 10 times, 1,000 times, it's
happening so darned fast
76:11 - that the human doesn't even notice.
76:13 - So there too.
76:13 - These are what are
called design decisions.
76:15 - And these are the kinds of
things that, in the real world,
76:17 - you might actually debate
with someone at a whiteboard,
76:19 - saying, no, this is stupid
because of this reason.
76:21 - Or he or she might push
back for other reasons.
76:23 - And no one's necessarily right.
76:25 - The whole goal is to just
that thought process first
76:27 - so you're at least
confident in what you chose.
76:29 - Yeah?
76:29 - AUDIENCE: When we were writing
to a file in the last PSET,
76:32 - was it storing it in memory first or
putting it right on the hard drive?
76:36 - DAVID J. MALAN: When
you were calling fread,
76:39 - you were by definition in
the forensics problem set
76:42 - reading bytes from disk into memory.
76:45 - When you were calling fwrite, you were
copying bytes from memory back to disk.
76:51 - If that answers the question.
76:53 - OK.
76:53 - Other questions?
76:53 - Yeah?
76:54 - AUDIENCE: Why did you
say, size + 1, in line 16?
76:58 - DAVID J. MALAN: Why do I
say, size + 1, in line 16?
77:01 - Because the whole goal is to make room
in this array for the newly inputted
77:06 - number that the human just typed in.
77:08 - And so whatever the current
size of the array is,
77:10 - I clearly need one more space.
77:14 - AUDIENCE: So that repeats on and on?
77:17 - DAVID J. MALAN: It
does repeat on and on.
77:18 - Because at the moment, I'm
inside of this while loop.
77:22 - So we do need to ask a question,
when is the human done inputting.
77:26 - And it turns out-- and
this is not obvious.
77:28 - And it's not the best user experience
on a keyboard for the human.
77:31 - But we can actually detect
the following sentiments--
77:35 - if user is done inputting numbers,
then let's go ahead and break.
77:42 - But the question then is, how
do you express that pseudo code?
77:45 - Well, you could in some
programs maybe type q for quit.
77:49 - But is that going to
work when using getInt?
77:52 - Could we detect q?
77:54 - Why not?
77:58 - AUDIENCE: Because getInt immediately
prompts you for another integer.
78:01 - DAVID J. MALAN: Exactly.
78:02 - Because getInt immediately
prompts you for another int.
78:04 - So because of the way we designed
the CS50 library, you can't detect q,
78:07 - or you can't have the human type
quit unless you don't use getInt.
78:11 - You instead use?
78:14 - AUDIENCE: getString.
78:15 - DAVID J. MALAN: We could use getString.
78:17 - And then every time the human
types in a number, we could use,
78:20 - like, A2i to convert it to an int.
78:23 - But if the human types in q or Q-U-I-T--
78:26 - a string also-- we could just have an if
condition with string compare and quit.
78:30 - But honestly, then you're
reimplementing getInt--
78:32 - so trade-off.
78:34 - Anyhow, a common way to
work around this would
78:36 - be, you know that Control-C
quits programs, perhaps,
78:39 - cancels out of your program.
78:41 - There's another popular
keystroke, Control-D,
78:43 - that sends what's called end of file.
78:45 - It simulates the end of a file.
78:48 - It simulates the end
of the human's input.
78:50 - So it's kind of like the period
at the end of an English sentence.
78:52 - So if you want to signal to a computer
that's waiting for input from you that
78:56 - you don't want to quit the
program-- that would be Control-C--
78:59 - but you just want to be done
inputting input to the computer,
79:02 - you hit Control-D,
otherwise known as EOF.
79:04 - And the way to express this--
and you would only know this from
79:07 - documentation-- would be
to say something like this,
79:09 - if the number the human
typed in equals end of file--
79:13 - but there is no such
thing in this context--
79:16 - you actually do this because
of the CS50 library works.
79:19 - It turns out that if the only
values a function can return
79:23 - are integers, that means you can
return 0, 1, negative 1, 2 billion,
79:28 - negative 2 billion give or take.
79:30 - What humans did for years
with old programming languages
79:33 - is they would just steal
one or a few numbers.
79:35 - For instance, you'd steal the number
two billion and call it intmax--
79:39 - the maximum integer.
79:41 - And you'd just say, you can
never actually type 2 billion,
79:43 - because we're using that as
a special value to signify
79:46 - that the human hit Control-D. Or
you could do negative 2 billion,
79:49 - or you could do 0, or 50.
79:51 - But at some point, you have to steal
one of the 4 billion available numbers
79:55 - to use as a sentinel
value, a special value
79:58 - that you can then check
for as a constant.
80:00 - So anyhow, this just means, when
the user is done typing input,
80:04 - go ahead and break out
of this while loop.
80:06 - And as an aside, let me fix one thing.
80:08 - It turns out things can
go wrong with realloc.
80:11 - And if realloc fails
to allocate memory, it
80:15 - can return null, a special value that
just means, eh, something went wrong.
80:19 - It's an invalid pointer.
80:20 - It's the address 0.
80:21 - And so it turns out there's a subtle
bug here where, technically, I
80:25 - should actually do this--
80:27 - store realloc's return value
in a temporary variable.
80:31 - Because if temp = null,
something went wrong.
80:35 - And I should actually go ahead
and quit out of this program.
80:39 - But let me wave my hand at that for
now because it's more of a corner case.
80:42 - But you'll see in the online version of
this program we have additional error
80:46 - checking that just checks, in
the rare case that realloc fails,
80:50 - clean it up and return properly.
80:52 - But I'll wave to the
online code for that.
80:54 - All right.
80:55 - Any questions on that
example before we move on?
80:59 - Yeah?
81:00 - AUDIENCE: So in realloc, when it creates
the new pointer for the [INAUDIBLE],,
81:06 - does it clear the memory
from the original pointer?
81:08 - Does it automatically clear it?
81:09 - DAVID J. MALAN: Good question.
81:10 - When you call realloc and it
ends up allocating more space,
81:13 - does it clear the original memory?
81:16 - No.
81:17 - And that is where garbage
values come from, for instance.
81:21 - Because they're just left in
memory from the previous use.
81:23 - Other questions?
81:24 - Yeah?
81:25 - AUDIENCE: What does the
user actually type to break?
81:29 - DAVID J. MALAN: Oh, Control-D.
Control-D. And it's not break.
81:33 - It is to send end of file, end of input.
81:36 - Control-C kills or breaks
out of the program itself.
81:38 - AUDIENCE: And that's the
same as the intmax kind of?
81:41 - DAVID J. MALAN: Same as intmax?
81:43 - Yes.
81:44 - AUDIENCE: Because you're not
adding, like, a giant value.
81:46 - DAVID J. MALAN: Correct.
81:47 - In the CS50 library,
intmax, yes, is the symbol.
81:50 - Yes.
81:50 - Yeah?
81:51 - AUDIENCE: Could you also
just ask the user to say,
81:55 - do you want to enter
another number yes or no?
81:57 - DAVID J. MALAN: Absolutely.
81:58 - We could add more logic.
81:59 - And you could use getString.
82:00 - And we could prompt him or her, hey,
do you want to input another number.
82:02 - The only downside of
that would be, now, I
82:04 - have to type in not only my
number, but yes or no constantly.
82:07 - So it's just a trade-off
user interface-wise.
82:10 - All right.
82:10 - So let me go ahead.
82:12 - And let me go ahead and return 0
here just as my simple solution
82:16 - to this problem of
something going wrong.
82:19 - I've just compiled this program.
82:21 - Let me go ahead and run it.
82:22 - I'm going to type in one number,
two numbers, three numbers.
82:27 - And now I'm bored.
82:27 - I don't want to keep doing this.
82:29 - How do I tell the computer I'm done?
82:31 - AUDIENCE: Control-D.
82:31 - DAVID J. MALAN: Control-D. Oops.
82:34 - Oh, OK.
82:35 - That's correct behavior
because I forgot a key step.
82:39 - What's that?
82:41 - AUDIENCE: [INAUDIBLE].
82:42 - DAVID J. MALAN: Yeah.
82:42 - I'm not actually doing
anything with the values.
82:44 - I should probably for int
I get 0, I less than size,
82:49 - I + + code we had before.
82:52 - And I should probably print
out You inputted %I, this.
82:57 - Save that.
82:59 - Make list one.
83:00 - So all I did was re-add
the printing code.
83:03 - Now if I rerun this-- one,
two three, Control-D--
83:08 - dammit.
83:08 - AUDIENCE: [INAUDIBLE].
83:10 - DAVID J. MALAN: Oh.
83:11 - OK.
83:11 - Now I broke my code here.
83:14 - Let me do this.
83:15 - We're going to get rid
of this error checking
83:17 - because I'm not actually ever resizing.
83:19 - numbers gets realloc.
83:21 - Oh, and maybe someone
chiming in with this--
83:24 - numbers bracket size
gets the user's input.
83:29 - Size + +-- was this a key
detail someone wanted me to do?
83:34 - OK.
83:34 - So I didn't actually
finish the program earlier.
83:36 - Notice we left off as follows--
83:39 - hey, computer, give me an
array of size 0 initially
83:43 - that's null-- there's no memory for it.
83:45 - Therefore, the size of this array is 0.
83:47 - Do the following forever.
83:49 - Get a number from the human.
83:51 - If the number equals this
special value, intmax just
83:54 - breakout because the program is done.
83:57 - And actually, sorry.
83:59 - This is why I write
these in advance too.
84:04 - OK.
84:05 - Go ahead and prompt
the user for a number.
84:08 - If they have inputted the Control-D,
just break out of this loop.
84:12 - However, if the size of the array
equals its current capacity,
84:15 - go ahead and reallocate space for this
thing being one number bigger than it
84:21 - previously was.
84:22 - Now, assuming that succeeded
and we have memory,
84:25 - go ahead, and just like our list 0
example, store in the numbers array
84:30 - at the current location, which is 0,
whatever number the human typed in.
84:34 - And then increment the size by
one to remember what we have done.
84:38 - I'm also though going to
need to do capacity + + here
84:41 - to remember that we've increased
the capacity of the array.
84:44 - So again, two new measures.
84:45 - capacity is how much
space there is in total.
84:48 - size is how much we're using.
84:50 - They happen to be
identical at the moment
84:52 - because we're growing this
thing step by step by step.
84:56 - All right.
84:57 - Let me go ahead and hit Save.
84:58 - Let me go ahead and
compile this one last time.
85:01 - ./list1 and input 1, 2, 3.
85:05 - Control-D. OK.
85:07 - Now it's just an aesthetic bug.
85:08 - I forgot my /n.
85:10 - So just to prove that I can actually
program, ./list1; 1, 2, 3; Control-D.
85:18 - Phew.
85:19 - All right.
85:20 - So you inputted 1.
85:21 - And the reason it didn't
move to another line
85:23 - is because Control-D gets sent
immediately without hitting Enter.
85:26 - All right.
85:27 - Phew.
85:28 - That's all using arrays.
85:29 - Now let's do the sort of cake baked
already and pull it out of the oven.
85:35 - The third and final
example here is list two.
85:38 - And actually, before we get
there, let me note one thing.
85:41 - Yeah, let's do one last thing here.
85:43 - Let me go ahead and run, per earlier,
our new friend valgrind on list1.
85:49 - Enter.
85:50 - It's waiting for me to type in 1, 2, 3.
85:54 - Let me go ahead and hit
Control-D. Interesting.
85:57 - I seem to have a buggy program even
though I claimed a moment ago that I
86:01 - knew what I was doing.
86:02 - 12 bytes in one blocks are definitely
lost in lost record one of one.
86:06 - Again, I don't understand
most of those words.
86:07 - But 12 bytes definitely lost--
86:10 - probably my fault. Why is it 12?
86:13 - And what are those 12 bytes?
86:16 - Yeah?
86:17 - AUDIENCE: I think you
made three integers.
86:19 - DAVID J. MALAN: Yeah, 1, 2, and 3.
86:21 - AUDIENCE: And each one is 4 bytes.
86:22 - And you never freed them
after you used malloc.
86:23 - DAVID J. MALAN: Exactly.
86:24 - I typed in three numbers--
86:25 - 1, 2, and 3.
86:25 - Each of those is 4
bytes on this computer.
86:27 - That's 12-- 3 times 4.
86:29 - And so I'd never freed them seems
to be the source of the issue.
86:32 - So at the end, let's
just prove that valgrind
86:36 - can detect correctness as well.
86:37 - Free my numbers, semi-colon.
86:40 - Let me go ahead and rerun make list1.
86:43 - And now let me increase the size
of this and do valgrind again
86:47 - on list1, typing in the same values--
86:49 - 1, 2, and 3.
86:50 - Control-D. All he blocks were freed.
86:53 - No leaks are possible.
86:54 - So again, valgrind is your friend.
86:56 - It finds problems that you
didn't even necessarily notice.
86:58 - And you didn't have to read
through your lines of code again
87:00 - and again to identify the source
of the issue unnecessarily.
87:03 - All right.
87:04 - Any questions then on these arrays
that are dynamically allocated
87:08 - and the bugs we find
therein with valgrind?
87:12 - All right.
87:12 - So the last demonstration
of code is going to be this.
87:17 - I have stolen, for this final
example, some of the building blocks
87:21 - that we had on the screen earlier.
87:23 - In my code for list2.c, I
need a structure called node.
87:28 - And that node, as we claimed
earlier with our human volunteers,
87:31 - is going to contain a
number called number,
87:33 - we'll call it this time, instead of n.
87:35 - And it's going to contain a ptr
called next to another such node.
87:40 - So that's copied and pasted earlier,
albeit with the integer renamed
87:43 - to number for clarity.
87:45 - Now, notice in main
what I'm doing first.
87:47 - Go ahead and allocate an
array of no space initially.
87:53 - So this was like when Comey was
holding up first and representing
87:56 - the beginning of our data structure.
87:58 - This is the analog using an array,
that the piece of paper that
88:02 - would be held up here would be numbers.
88:04 - And it's just pointing at
nothing, null-- like left hand
88:06 - down on the floor.
88:07 - Because there is no
memory yet allocated.
88:09 - But then, and while true,
go ahead and get an integer
88:13 - from the user with this code here.
88:16 - Check if the user hit Control-D,
as with this arcane technique.
88:21 - And then our code is
similar in spirit, but we
88:25 - have to stitch these things together.
88:27 - Allocate space for the number.
88:29 - So when I malloc an additional
volunteer from the audience
88:32 - and he or she came down, the
equivalent in code is this--
88:35 - hey, computer, allocate with malloc
enough space to fit the size of a node,
88:41 - then store the results
in a ptr called n.
88:44 - So node *n just means, give me
a pointer to a node, call it n,
88:49 - and store the address that was just
allocated from the audience as before.
88:53 - Why do I have these lines of code
here that I've highlighted in blue?
88:56 - What's that expressing?
89:03 - If bang n, or if not n would
be how you pronounce it--
89:08 - what's going on there?
89:10 - Yeah?
89:11 - AUDIENCE: If there is no more memory
that you can point to, then it fails.
89:15 - DAVID J. MALAN: Exactly.
89:16 - This isn't going to
happen all that often.
89:18 - But if the computer is out of
memory, and therefore malloc fails,
89:21 - you don't want the program
just to crash or freeze.
89:23 - Like, all of us hate when that
happens on Mac OS or Windows.
89:26 - So check for it.
89:27 - If not n, or equivalently,
if n = = null, just return 1.
89:33 - Quit gracefully, even though annoyingly.
89:35 - But don't just crash or
do something unexpected.
89:37 - So you can simplify that check to just
if not n-- if n is not a valid ptr,
89:43 - return 1.
89:44 - Now, here's the code with which we
were implementing the demonstration
89:49 - with our humans.
89:49 - And this is the scariest
looking or most cryptic at least
89:52 - looking code we're going to see in C.
89:54 - Today is our final day in
C. We've been running up
89:59 - a really steep hill of
late, learning about memory,
90:01 - and now data structures and syntax.
90:03 - This is the last of our syntax in C.
90:06 - So what are the symbols to be aware of?
90:09 - This line of code here is how I handed
one of our volunteers a piece of paper.
90:15 - On the right-hand side is the
number that was typed in--
90:18 - 55, or 5, or 20, or
whatever the value is.
90:21 - On the left-hand side is
where you want to put it.
90:24 - n and then literally an
arrow number does this.
90:29 - It has, with malloc a line or
so prior, given me in memory
90:34 - just one of these big rectangles.
90:36 - And again, the top of this in
this example is called the number
90:40 - and the bottom is called next.
90:42 - So that's our human having stood
up from the back of the room.
90:45 - When I hand that human a number,
like 55, it visually goes there.
90:49 - The line of code with which
you achieve that is this here.
90:53 - Because notice on line 31
here, when I malloc that node,
90:57 - I stored its address
in a variable called n.
91:02 - And that's a pointer, as drawn
with an arrow, to that big node.
91:05 - Or if we really want to be
nit-picky, if this is in address 100,
91:08 - yes, then the pointer actually
has the value 100 in it.
91:11 - But again, that's rarely
useful information.
91:13 - So we can abstract away
with just an arrow.
91:16 - So line 31 is what creates
those boxes on the screen.
91:21 - Line 38 is what puts the number--
91:25 - for instance, 55-- into the box exactly,
much like I handed a piece of paper
91:30 - over.
91:31 - So what is this?
91:32 - This is the only real
new notation today,
91:35 - even though we're using
lots of stars elsewhere--
91:38 - arrow This is wonderfully the first time
in C it actually maps to our pictures.
91:43 - If n is the variable and
you do n arrow something,
91:46 - that means follow the arrow--
91:48 - kind of like Chutes and Ladders
if you grew up playing that--
91:50 - and then put the number where the arrow
has led you in the field called number.
91:57 - So as an aside, we can think about this
a different way. n is what data type?
92:02 - What is this thing in blue--
92:04 - n?
92:07 - AUDIENCE: Pointer.
92:08 - DAVID J. MALAN: It's a pointer.
92:10 - And it's a pointer to one of these
things that we created earlier.
92:12 - So we're not doing students
anymore with our structures.
92:15 - We're implementing nodes, which
have numbers and next pointers.
92:18 - So it turns out that if n
is a pointer to a node--
92:24 - recall that dot notation from before--
92:27 - this is not how you access
number in this case.
92:29 - Because n is not a node itself.
92:30 - It's a pointer.
92:32 - But if n is a pointer, how
do you go to a pointer?
92:35 - How do you go to an address?
92:37 - With what notation?
92:38 - AUDIENCE: Star.
92:39 - DAVID J. MALAN: Star.
92:40 - So recall from last week, if
we want to go to an address,
92:44 - you could do syntax like this.
92:45 - Ignore the parentheses for a moment.
92:47 - Just *n means if n is an address of
a chunk of memory, *n means go there.
92:52 - Once you're there, you're conceptually
right here-- top left-hand corner.
92:56 - How do you access individual
fields like number or next?
92:59 - You use dot notation.
93:01 - So if you literally do *n.number, that
means go to the address and access
93:08 - the number field.
93:09 - There is nice syntactic
sugar in C, which
93:12 - is just a fancy way of saying shorthand
notation, where it's just the arrow.
93:16 - But that's all it is.
93:17 - This arrow notation
doesn't do anything new.
93:19 - It just combines, go there, with, access
a field in a struct, all in one breath
93:24 - if you will.
93:26 - And this just looks a little prettier.
93:28 - When I told our volunteers
earlier, point your hand
93:30 - down at the floor, that's all
that line of code is doing.
93:33 - It's saying, go to n's address,
which is here, access the next field,
93:38 - and write in that field
null, which is just
93:41 - the address 0-- the default, special
address, like pointing at the floor.
93:46 - This line of code, 40, is
just a quick error check.
93:49 - if (numbers)-- what
is that equivalent to?
93:51 - That's actually just saying,
if numbers, not equals null.
93:54 - So if numbers is legitimate, if malloc
worked correctly, then let's go ahead
93:59 - and do the following.
94:01 - Phew.
94:02 - This is a mouthful.
94:04 - What is going on here?
94:05 - So this is a for-loop
that's not using numbers.
94:08 - Well, or is it?
94:09 - Almost every for-loop we've written
and you've probably written just
94:12 - uses I, J, maybe K, but
just integers probably.
94:16 - But that doesn't have to be the case.
94:18 - What is a pointer?
94:19 - It's an address.
94:20 - What is an address?
94:23 - AUDIENCE: A place in memory.
94:24 - DAVID J. MALAN: A place in
memory, or a number really.
94:26 - So you can certainly use for-loops
just involving addresses.
94:29 - But how?
94:30 - So we'll consider this line of code.
94:32 - This here looks different
today, but it's everything
94:35 - before that first semi-colon.
94:36 - That's just where you
initialize a value.
94:38 - So this is like saying, hey,
computer, go ahead and give me
94:42 - a variable called ptr and initialize
it to be the start of my list.
94:51 - Then I'm saying, hey, computer, do this
so long as ptr does not equal null.
94:57 - And then what am I doing?
94:59 - if-- and let's ignore this
for now, it's an error check--
95:02 - go ahead and-- sorry, let
me think for one second.
95:13 - OK.
95:13 - Let's do this.
95:17 - What are these lines of code doing?
95:19 - This is the code that
was actually suggested
95:21 - at the very end of our human example.
95:23 - Like, what if we wanted to
insert all of the elements
95:26 - at the end of the link list?
95:28 - How do you express that?
95:30 - So in this highlighted lines of
code, we're asking the question,
95:34 - if the current pointer's next
field is null, we've found the end.
95:38 - Go ahead and update that next
field to equal n and then break.
95:42 - So let me translate this
to an actual picture,
95:45 - but using smaller boxes that makes
clear where something is going.
95:49 - So suppose that this program's
been running for a little while
95:53 - and we have a length list
that looks like this,
95:57 - where this one is pointing here
and maybe this one's pointing here.
96:02 - And this says null here.
96:04 - And this points here.
96:05 - And the numbers are, as we've
been using today, 42, 50, 13.
96:11 - So the start of this
list is called numbers.
96:17 - This points to the start of the list.
96:19 - What am I doing in this for-loop?
96:21 - I am just implementing the
following logic with this loop--
96:24 - give me a variable called
ptr, as represented
96:27 - in the story by my left
finger, here, and initialize
96:30 - that to be the start of the list.
96:33 - If that node's next pointer is
equal to null, add a new node here.
96:42 - But this is not null.
96:43 - I want to follow the
bread crumbs to here.
96:46 - And then, oh, we're at
the end of the list.
96:48 - I want to insert this new thing here.
96:50 - So how do express this
code actually in C?
96:55 - So if I look back up here,
this is the line of code
97:01 - that allocates my left finger
here called ptr and initialize it
97:05 - to equal numbers, which is the same
as pointing at the first element.
97:09 - It's kind of like Comey was
representing first earlier.
97:11 - But now our array is called numbers.
97:13 - Next, what am I doing?
97:16 - Does ptr equal null?
97:17 - Well, no.
97:18 - If my left hand is pointing here,
it obviously doesn't equal null.
97:21 - So we don't have to worry yet.
97:23 - Then what do I want to do?
97:25 - If ptr next equals null,
well, what does that mean?
97:28 - Well, ptr is here.
97:30 - ptr arrow next means here.
97:32 - Does this equal null in this story?
97:35 - I mean, it literally doesn't.
97:37 - Because null is not written
there. null is way down there.
97:39 - So the condition does not pass.
97:42 - So what do I do next?
97:44 - If ptr is equal to null doesn't
apply, here's a weird update.
97:50 - ptr gets ptr next.
97:52 - So it's cryptic-looking syntax.
97:54 - But if ptr is pointing
here, what is ptr next?
97:58 - That's just this, right?
98:00 - This is n.
98:00 - This is next.
98:01 - Or this is number.
98:02 - This is next.
98:03 - So ptr next is this.
98:05 - So what is this value?
98:07 - Well, this is a pointer pointing here.
98:09 - So that highlighted block of
code, ptr equals ptr next,
98:13 - has the effect visually of doing this.
98:17 - Why?
98:18 - If the arrows are a little too magical,
just think about these being addresses.
98:22 - If this is saying, the next
address is location 100,
98:25 - ptr equals ptr next is like
saying, well, this also equals 100.
98:30 - Whatever 100 is, for
instance, over here is
98:33 - what both arrows should now point out.
98:35 - And if you now repeat this
process and repeat this process,
98:38 - eventually that question we
asked earlier is going to apply--
98:41 - if ptr next equals null,
what do I want to do?
98:46 - Well, if ptr x equals null, there's
two lines going on. ptr next equals n.
98:53 - So ptr next is no longer null.
98:56 - It should instead be pointing
at n, which is the new node.
99:00 - And then that's it.
99:02 - Because this was already
initialized to null.
99:04 - And let's suppose this was 55.
99:06 - And we're done.
99:07 - So much easier to do, obviously,
in person with just humans,
99:09 - and moving around, and
pointing with their left hands.
99:12 - But in code, you just have to think
about the basic building blocks.
99:16 - What is each of these values?
99:17 - Where is each of it pointing?
99:20 - And which of those fields
do you need to update?
99:22 - And the only new code here-- even though
we're kind of combining it all in one
99:25 - massive example--
99:26 - is this.
99:27 - We are actually using arrow
notation to say, go to that address
99:31 - and access some value therein.
99:34 - And this condition down here, which
I'll wave my hand out for now,
99:37 - just handles this situation where
the list is initially empty.
99:41 - Any questions on this thus far?
99:45 - All right.
99:46 - So let's take a look more graphically
at some final problems we can solve.
99:52 - And what you'll see in the
days ahead is the following
99:56 - when it comes to these
linked lists and more.
99:58 - We now have the ability to actually
allocate things in memory dynamically.
100:01 - We don't necessarily know in
advance how many numbers we have
100:04 - or, in the case of the next problem
set, how many words we have.
100:06 - We have the ability though to use
malloc, and maybe even realloc,
100:10 - to grow and grow our
data structure in memory.
100:12 - And we have the ability
in code to actually
100:14 - traverse those values
in such a way that we
100:17 - can access memory that's
all over the board now
100:20 - and not necessarily
back to back to back.
100:22 - But what happens if we want to combine
these ideas into fancier solutions
100:26 - still?
100:27 - Well, let's take a look at that.
100:29 - In particular, if I go let's
say over here to the following,
100:35 - let's consider a problem
we might now solve.
100:38 - If I wanted to store everyone's name
in this room in a data structure,
100:42 - I could do what?
100:44 - Well, we could use an array.
100:46 - So I could actually decide how
many people are in the room--
100:48 - let's call it n--
100:49 - and actually draw n boxes on the
board, and then iteratively ask
100:52 - everyone for their name,
and actually write it down.
100:55 - If I then wanted to take attendance
thereafter and say, oh, is Alice here,
100:59 - or is Bob here, or is
Kareem here, or Brian,
101:02 - I could just look through that array
and say yes or no, that human is here.
101:05 - But what's the running
time of that algorithm?
101:08 - How long would it take to look
up a name in a data structure
101:11 - where I've just drawn it as an
array, a big list on the board?
101:14 - AUDIENCE: A big O of n.
101:15 - DAVID J. MALAN: What's that?
101:15 - AUDIENCE: A big O of n.
101:16 - DAVID J. MALAN: A big O of n, right?
101:17 - Because if it's just a list of
names, it's going to take big 0 of n.
101:20 - And frankly, that seems a little slow.
101:22 - How could I do an optimization?
101:24 - Well, what if we combined
some of these ideas?
101:26 - Arrays are nice because
they give me random sort
101:28 - of instant access to memory locations.
101:31 - But linked lists are nice because they
allow me to dynamically add or subtract
101:35 - elements even if I want from the list.
101:38 - So you know what?
101:38 - Instead of writing down everyone's
names, like Alice, and Bob,
101:44 - and Charlie, like this in just one big
array of some fixed size that might
101:52 - paint me into a corner-- now I
only have room for one more name--
101:55 - what if I instead do things
a little more cleverly?
101:57 - So when I'm actually jotting down
everyone's name in the room, what
102:01 - if I instead did, OK, is Alice here.
102:04 - All right.
102:04 - Alice is here.
102:06 - And then Brian is here.
102:07 - I'm going to put Brian here.
102:09 - And then maybe Charlie is here.
102:11 - All right.
102:11 - So Charlie.
102:13 - And then maybe Arnold is here.
102:16 - Where should I put Arnold?
102:17 - So also starts with A. You know what?
102:19 - Let's just put Arnold here.
102:21 - Arnold.
102:23 - And Abby is here.
102:24 - So you know what?
102:25 - Let's just put Abby up here as well.
102:27 - Bob came as well.
102:29 - So Bob-- so what's the pattern
I'm obviously following
102:31 - as I'm hearing names called out?
102:35 - AUDIENCE: Alphabetically sorted.
102:36 - DAVID J. MALAN: Alphabetically sorted--
102:37 - kind of.
102:38 - Like, Abby kind of ended
up in a weird place here.
102:41 - But that's fine because I
didn't hear her name first.
102:44 - But I did kind of bucketize people
into different rows of the board.
102:49 - In other words, all
of the A names I seem
102:50 - to just write down for
convenience at the top,
102:53 - and then all of the B names
together, and C names.
102:54 - And probably if I kept going,
I could do this all the way
102:56 - through Z in the English alphabet.
102:58 - So what's nice about this is that,
yeah, I'm making lists of names,
103:01 - but how long is each of those lists?
103:03 - If there's n people in
the room, each of my lists
103:06 - is not going to be n
long, which is slow.
103:09 - It's going to be what? n
divided by 26, give or take.
103:14 - If we assume that there's
an equal number of people
103:16 - with Z names and A names, it's going
to be roughly n divided by 26 so
103:20 - that I have these chains
of human names, but they're
103:23 - much shorter than they would have been
if I just grouped everyone together.
103:26 - And this is a fundamental technique
in programming called hashing.
103:31 - It turns out there are things in
this world called hash functions.
103:34 - These are just mathematical, or
verbal, or code-implemented functions
103:39 - that take as input something and produce
as output a number typically-- a number
103:43 - from 0 to, say, 25, or from 1 to 26.
103:46 - But they can also output strings
in other contexts as well.
103:49 - So my hash function here in my
mind is, if you hand me a name,
103:53 - I'm going to look at the
first letter in your name.
103:55 - And if it's A, I'm
putting you in location 0.
103:57 - If it's B, I'm going to
put you in location 1.
104:00 - If it's a Z, I'm going to put
you in location 25 at the end.
104:03 - So these are all buckets
I've got, so to speak,
104:05 - in computer science--
like 26 buckets or room
104:08 - on the board that represent
the starts of people's names.
104:11 - So what is that?
104:12 - Well, it would seem that if I don't
know in advance how many A names I have,
104:16 - that's kind of like drawing this
as a linked list, if you will,
104:19 - that might just get longer and longer.
104:22 - But I do know that I only have a
finite number of first letters.
104:27 - So that-- at the risk of
drawing a little messily--
104:30 - is kind of like drawing
what data structure?
104:32 - AUDIENCE: An array.
104:33 - DAVID J. MALAN: Yeah.
104:34 - It's kind of like drawing an
array that just has 26 spots.
104:39 - And what's nice about an array
is that I have random access.
104:42 - I can jump right to any letter of the
alphabet in constant time, one step.
104:47 - And once I get there, I'm still
going to see a list of names.
104:50 - Thankfully, thanks to linked lists,
that list can be short or long.
104:54 - But on average, let's
say it's going to be
104:55 - 126th the length that it would have been
if I just used one array or one linked
105:02 - list.
105:02 - So this technique of using a
hash function-- which, again,
105:06 - I've defined as you give me
a name; I take that as input;
105:09 - I look at the first letter; and I
return as output a number from 0 to 25--
105:13 - a hash function lets
you create a hash table.
105:17 - And there's different ways
to implement hash tables,
105:19 - but perhaps one of the most
common is indeed like this.
105:22 - You decide in advance
on the size of an array.
105:26 - But that array does not contain
the strings or the humans' names.
105:30 - That array actually
contains linked lists.
105:34 - And it's the linked lists
that contain the names.
105:37 - So we borrow ideas from, like, week two.
105:39 - We merge them with an idea today
from week four of adding arrays
105:42 - to linked list respectively.
105:44 - And we kind of get the
best of both worlds.
105:46 - Because I can immediately jump to any
letter of the alphabet super fast.
105:49 - And once I'm there,
yeah, there's a list,
105:51 - but it's not nearly as long as it would
have been if I didn't use this trick.
105:55 - So what's the running
time of all of this?
105:57 - Well, it turns out that a
hash table in the worst case
106:01 - might still take you how many steps
to find someone's name once it's
106:04 - been added to the list?
106:06 - In the very worst case, how many
steps, if there's n people in the room?
106:09 - AUDIENCE: n.
106:10 - DAVID J. MALAN: Maybe n.
106:11 - Why?
106:12 - It's kind of a perverse situation.
106:14 - But can you contrive
a scenario in which,
106:17 - even though we're doing
this fanciness, it still
106:19 - takes me n steps to confirm
or deny that someone's here?
106:21 - Yeah?
106:21 - AUDIENCE: Everyone's name
starts with the same letter.
106:23 - DAVID J. MALAN: Everyone's name
starts with the same letter
106:25 - for some weird reason.
106:26 - Now, it's a little silly
in the human world.
106:28 - But it could happen
if you're just talking
106:29 - data or whatever in the computer world.
106:32 - This can devolve into, sure, an array
with just one really linked list.
106:37 - But in practice, that's not
likely going to happen, right?
106:39 - If we actually spent the time here
and asked everyone for their name,
106:42 - we'd probably get a reasonably
uniform distribution of letters,
106:46 - at least as is statistically
likely with just human names.
106:49 - So that would kind of spread things out.
106:51 - And so there's this fundamental
distinction between sort of real-world
106:55 - running time, or wall clock time--
how many seconds are actually spinning
106:58 - on the clock--
106:59 - versus asymptotic running time.
107:00 - We've talked for a couple of weeks now
about running time as being big O of n.
107:04 - And that might be still the case, that
a hash table-- yes, in the worst case,
107:08 - it's still a big O of n data structure.
107:10 - Because in the worst case,
it's going to take n steps.
107:12 - But in the real world, big O of n
is really big O of n divided by 26,
107:18 - even though we always ignore
those lower-order terms.
107:21 - But when it's you, the human, running
the code and analyzing the data,
107:24 - running 26 times faster is
actually real time saved,
107:30 - even though a mathematician might say,
ah, that's the same fundamentally.
107:33 - And indeed, one of the problems
ahead for the next problem set
107:36 - is going to be to suss out
exactly what the implications are
107:39 - in your own code for actual
wall clock running time.
107:43 - And making smarter design
decisions, like something like this,
107:46 - can actually really speed up your
code to be 26 times as fast, even
107:50 - though, yes, a
theoretician would say, ah,
107:52 - but that's still asymptotically
or mathematically
107:55 - equivalent to just something linear.
107:58 - So it's this fine tuning that will
make your code even better and better.
108:01 - Now, frankly, hashing
on first names probably
108:03 - isn't the smartest thing alone, right?
108:05 - Like, does anyone's-- and
this is going to be hard.
108:09 - Does anyone's name start with X here?
108:11 - AUDIENCE: [INAUDIBLE].
108:12 - DAVID J. MALAN: [INAUDIBLE] is not here.
108:13 - But thank you for that
perfect counter-example.
108:15 - But she's not here.
108:16 - So look, there's no Zs.
108:17 - So now we're down to 25 possible values.
108:19 - And I could probably pick
some less common letters too.
108:22 - The point is there's probably
a few more As than there are Zs
108:25 - or a few more B's than there are
Q's just by nature of human names.
108:28 - So maybe just using the first
letter isn't good enough.
108:32 - And frankly, with 26 names-- suppose
we did this for all of Harvard
108:35 - and had thousands of names.
108:37 - Each of my chains might still have
hundreds or thousands of names.
108:40 - So another design question is going to
be, well, how many buckets should you
108:43 - have, how big should the array be.
108:45 - Maybe you shouldn't look
at the first letter.
108:47 - What if you look at the first and the
second letter together-- so AA, and AB,
108:50 - and AC, and then dot dot dot,
BA, BB, BC, so you could come up
108:55 - with more and more buckets?
108:57 - But what else?
108:57 - How else might we kind of
uniformly distribute people?
109:01 - What do all of you have that we could
use as input to a hash function?
109:06 - AUDIENCE: A last name.
109:07 - DAVID J. MALAN: OK.
109:07 - Well, you could do last
name, which might give us
109:09 - a different or similar distribution.
109:11 - Yeah?
109:11 - AUDIENCE: ID number.
109:12 - DAVID J. MALAN: Whats that?
109:12 - AUDIENCE: ID number.
109:13 - DAVID J. MALAN: Yeah.
109:13 - We could use your ID number and actually
look at the first digit of your ID.
109:17 - And odds are, it's 0 through 9.
109:19 - So we could probably at least
get 10 buckets that way.
109:21 - And that's probably
uniformly distributed.
109:23 - I'm not sure.
109:24 - We could use birth dates in some way.
109:27 - Like, we could put all of
the freshmen in one bucket,
109:29 - all the seniors in another
bucket, and everyone else,
109:31 - and so forth, in their own buckets,
which would also give us some input.
109:34 - So again, a hash function is entirely
up to you to program and design.
109:38 - The goal though is to smooth things out.
109:41 - You want to have roughly the same
number of things in each linked list
109:44 - just so that you have
about the same performance
109:48 - across all of these various inputs.
109:50 - So let's take a look at a
couple of other data structures,
109:53 - again, in this abstract way.
109:54 - Now that we know that, even though
it's not obvious at first attempt,
109:58 - we know how to construct arrays.
109:59 - We kind of know now how
to construct linked lists.
110:02 - It stands to reason we could
implement them together in code.
110:05 - What else could we do now
with these building blocks?
110:08 - So for instance, this structure here
is a very common one, known as a tree.
110:13 - A tree like a family tree, where
there's one patriarch or matriarch
110:16 - at the top, and then their children,
and then their grandchildren,
110:19 - and great grandchildren, and so forth.
110:21 - And what's nice about a tree structure
is that, if you're storing data,
110:25 - you can actually store the data
in clever ways to the left child,
110:28 - to the right child, and
so forth, as follows.
110:32 - Notice here, there's something curious
about all the numbers in this data
110:37 - structure.
110:38 - What is noteworthy about them?
110:44 - What is noteworthy?
110:45 - Yeah?
110:45 - AUDIENCE: Multiples of 11.
110:46 - DAVID J. MALAN: What's that?
110:47 - AUDIENCE: They're multiples of 11.
110:48 - DAVID J. MALAN: They
are multiples of 11.
110:50 - That was just to make them look
pretty though by the author here.
110:53 - Yeah?
110:53 - AUDIENCE: [INAUDIBLE].
110:55 - DAVID J. MALAN: Yeah.
110:56 - There's a mathematical significance too.
110:58 - Like, no matter what node or
circle you look at, the value in it
111:02 - is bigger than the left child and
it's smaller than the right child.
111:08 - So it's kind of in-between.
111:09 - Any circle you look at, the
number to the left is smaller,
111:11 - the number to the right is bigger.
111:13 - And I think that applies
universally all over the place.
111:15 - Yes?
111:16 - So what does that mean?
111:17 - We'll recall from, like, week 0 when we
had a whole bunch of phone book pages
111:23 - that we were searching--
111:24 - 1, 2, 3, 4, 5, 6.
111:26 - Let's give ourselves a 7th one.
111:27 - Recall that when we did divide
and conquer, or binary search,
111:30 - we did it on an array.
111:31 - And what was nice about binary
search was we started in the middle,
111:34 - and then we maybe went left,
or we maybe went right,
111:36 - and we kind of divided
and divided and divided
111:38 - and conquered the problem much more
efficiently in logarithmic time
111:41 - than it would have been
if we did it linearly.
111:44 - But we know now weeks later that
arrays are kind of limiting, right?
111:48 - If I keep storing all of
my values in an array,
111:51 - what can I not do with the array?
111:56 - Make it bigger, right?
111:57 - I can't add an element to it
without copying every darn element,
112:00 - as we've discussed thus far today.
112:02 - But what if I was a
little smarter about it?
112:04 - What if I stored my values,
not just in an array,
112:07 - but I started storing
them in these circles--
112:10 - let's call them nodes--
112:12 - and each of those nodes is really just
an integer plus two additional values?
112:18 - How would we implement this
data structure in memory?
112:20 - Well, here's an int n-- could
represent the number in question.
112:24 - And we could put that
in a data structure
112:26 - called a node that just has the
same syntax as earlier today,
112:29 - but I've left room for two more fields.
112:31 - What is it that I want
to represent in code if I
112:34 - want to start storing my numbers,
not in this old-school week 0 array,
112:38 - but in a tree?
112:42 - AUDIENCE: Two pointers.
112:43 - DAVID J. MALAN: Two--
112:43 - AUDIENCE: Pointers.
112:44 - DAVID J. MALAN: Two pointers.
112:44 - Right?
112:45 - A tree, as drawn here
literally with arrows,
112:49 - is just like saying every
one of these nodes or circles
112:51 - has a left child and a right child.
112:53 - How do you implement children?
112:55 - Well, you can literally just use
pointer notation as well here.
112:58 - A left child is just a pointer
to another struct on the left.
113:01 - And a right child is just another
pointer to the child on the right.
113:05 - And what's nice about this
ultimately is that we can now
113:08 - traverse this tree just as efficiently
as we can traverse this array.
113:14 - Because notice if I want to
search for the number 66,
113:18 - how many steps does it take
me if I start at the top?
113:23 - Just like Comey represented
the start of our linked list,
113:26 - so in the world of a tree does the
root have special significance.
113:29 - And that's where we always begin.
113:31 - So how many steps does it take
me to find 66 given the top?
113:33 - AUDIENCE: Three.
113:34 - AUDIENCE: Two.
113:35 - DAVID J. MALAN: It looks like--
113:36 - yeah, two or three, right?
113:37 - I start at the top.
113:38 - I look at it and say, hmm,
55, which way do I go.
113:41 - I go to the right.
113:42 - Then I see 77.
113:43 - OK.
113:43 - Which way do I go?
113:44 - I go to the left.
113:45 - So it's the same logic as week 0 in
dividing and conquering the phone book
113:49 - or an array a couple of weeks later.
113:51 - But we get to the number we
care about pretty quickly.
113:54 - And it's not linear.
113:55 - And in fact, if we actually
did out the math, what's
113:57 - really cool about a binary search
tree is that if you have n elements,
114:00 - n circles, the height of that tree is
by definition mathematically log n.
114:06 - So the height of the
tree just so happens
114:09 - to correspond to exactly how
many times you can take n
114:12 - and divide it, divide it,
divide it, divide it in two.
114:15 - And you can actually see this if you
think about it the reverse direction.
114:18 - On the bottom row, there
are how many elements?
114:21 - All right?
114:21 - And on the middle row, there is?
114:23 - AUDIENCE: Two.
114:23 - DAVID J. MALAN: Two.
114:24 - And on the top row, there's one.
114:26 - So you can actually see it
in the reverse direction.
114:27 - This is like divide and conquer,
but in a different conceptual way.
114:33 - Every row in the tree has half as
many elements as the one below it.
114:38 - And so the implication of that is just
like from week 0 in the phone book
114:41 - when we're dividing, and dividing, and
dividing in half, and half, and half.
114:45 - So this is only to say, now that
we have structures and pointers,
114:48 - we can build something like this.
114:50 - But let's try one
other example here too.
114:53 - This is a crazy looking example.
114:55 - But it's kind of amazing.
114:57 - Suppose that, if we wanted to
store a dictionary of words--
115:01 - so not humans' names this
time, but English words.
115:04 - So Merriam Webster or Oxford
English Dictionary has what?
115:06 - Thousands, hundreds
of thousands of words
115:08 - these days in English for instance?
115:10 - How do you actually store those?
115:12 - Well, if you just look up words in
a dictionary back in yesteryear,
115:15 - that is linear.
115:16 - You have to start at the
beginning and look through it
115:18 - page by page, looking for words.
115:19 - Or you could be a little smarter.
115:21 - Because the words in any dictionary
are hopefully alphabetized,
115:23 - you can do the Mike Smith-style divide
and conquer by going to the middle,
115:27 - then the middle of the
middle, and so forth--
115:29 - log of n.
115:30 - But what if I told you, you could
look up words in constant time--
115:34 - some fixed number of steps?
115:36 - None of this divide
and conquer complexity.
115:38 - No log n.
115:39 - Just constant time-- you want
a word, go get it instantly.
115:43 - That's where this last structure
comes in, which is called a trie--
115:46 - T-R-I-E-- short for retrieval, even
though it's pronounced the opposite.
115:51 - So a trie is a tree each
of whose nodes is an array.
115:57 - So it's like this weird Frankenstein's
monster kind of data structure.
116:00 - We're just really combining lots
of different ideas, as follows.
116:04 - And the way a trie works, as is implied
by this partial diagram on the board,
116:10 - is that if you want to store
the name Brian, for instance,
116:14 - in your dictionary--
it's the first word--
116:15 - what you do is you start by
creating a tree with just one node.
116:19 - But that node is effectively an array.
116:22 - That array is of size, let's
say for simplicity, 26.
116:26 - So A through Z. This location here
therefore represents B for Brian.
116:32 - So if I want to insert Brian into this
tree, I create one node at the top.
116:37 - And then for the second
letter in his name, R,
116:39 - I create another node,
also an array, A through Z.
116:44 - And so here, I put a
pointer to this node here.
116:48 - B-R-I. So I should have
drawn some more boxes.
116:51 - A, B, C, D, E, F, G, H, I. So here, I'm
going to draw another pointer to B--
117:01 - wait.
117:02 - Bian.
117:02 - [LAUGHTER]
117:04 - OK.
117:04 - That's wrong.
117:07 - Billy shall be our name.
117:09 - Billy is at B. Wait.
117:12 - No.
117:14 - Dammit.
117:15 - B, B. B-I-A-- yes, this works.
117:18 - This works.
117:19 - OK.
117:19 - Sorry.
117:20 - So here we go.
117:20 - We're inserting Billy into
this fancy data structure.
117:23 - So the first node
represents the first letter.
117:25 - The second node represents
the second letter.
117:27 - The third node represents
the third letter.
117:29 - And so forth.
117:30 - But what's cool about
this is the re-usability.
117:32 - So notice if this is the second letter
and I counted this out correctly,
117:36 - I, this is going to lead
to a third node deeper
117:39 - in the tree where it's L that we
care about next, and then another one
117:44 - down here which represents another L.
117:47 - And I'll start drawing the letters.
117:49 - L. This is B. This is I.
L. And we'll call this L.
117:53 - And then, finally, another one
over here, which is a Y. And this
117:59 - gets pointing down here.
118:00 - This gets pointing here.
118:02 - And so forth.
118:03 - So in short, we have
one node essentially
118:06 - for every letter in the word that we're
inserting into the data structure.
118:11 - Now, this looks stupidly
inefficient at the moment.
118:14 - Because to store B, I, L, L, Y,
how much memory did I just use?
118:20 - 26 plus 26 plus 26 plus 26 plus 26.
118:26 - Just to store five
characters, I use 26 times 5.
118:30 - But this is kind of thematic
in computer science--
118:33 - spend a little more space, and I bet
I can decrease the amount of time
118:36 - it takes to find anyone.
118:37 - Because now no matter how many other
students are in this data structure--
118:42 - and for instance, let's do another one.
118:44 - If we had another one, like Bob--
118:48 - so B is the same first letter.
118:51 - That leads us to this second node.
118:52 - O is somewhere else in
this array, say, over here.
118:57 - So this represents O. And
then Bob has another one.
119:00 - So there's going to
be another array here.
119:02 - And this is why the picture
above draws this so succinctly.
119:06 - This is how we might store Bob.
119:08 - So B, I, L, L, Y. Or you can
follow a different route, B, O, B.
119:16 - So we can start to reuse
some of these arrays.
119:19 - So there's where you start to
get some of the efficiency.
119:21 - Any time names share a few letters,
then you start reusing those same nodes.
119:25 - So it's not super, super wasteful.
119:27 - But the question now is, if there's
like 1,000 students in the class,
119:30 - or 1,000 students in the room,
we're going have a lot of nodes
119:33 - there on the board.
119:34 - But how many steps does
it take to find Billy,
119:38 - or Bob, or any name with this data
structure, and to conclude yes or no
119:44 - that student is in the class?
119:48 - So, like, five for Billy, three for Bob.
119:51 - And notice none of that
math has any relationship
119:56 - to how many students are in the room.
119:58 - If we instead wrote out a long list
of 1,000 names, in the worst case,
120:02 - it might take me 1,000
steps to find Billy or Bob.
120:04 - Maybe I could be a little
smarter if I sort it.
120:06 - But in the worst case,
big O of n, it's linear.
120:08 - Or if I used a hash table
before, and maybe there's
120:12 - 1,000 students in the
room, but, OK, there's
120:14 - 26 letters in the English
alphabet at least.
120:16 - So that's 26 buckets.
120:17 - So maybe it's 1,000
divided by 26, worst case,
120:19 - if I'm using those linked
lists inside my array.
120:23 - But wait a minute.
120:24 - If I'm using this structure, a
trie, where every node in the tree
120:28 - is just in an array that leads me to the
next node, ala breadcrumbs, B, I, L, L,
120:34 - Y is 5 and always 5.
120:36 - B, O, B is always 3.
120:38 - B, R, I, A, N would have been 5 as well.
120:41 - None of these totals has
any impact or any influence
120:46 - from the number of total
names in the data structure.
120:49 - So a trie in some sense
is this amazing holy grail
120:54 - in that, by combining these various data
structures, now you get constant time,
120:57 - but you do pay a price.
120:59 - And just to be clear, what is
the price we seem to be paying?
121:02 - AUDIENCE: Memory.
121:03 - DAVID J. MALAN: Memory.
121:04 - And in fact, this is why I'm
not really drawing it much more.
121:07 - Because it just becomes a big
mess on the screen because it's
121:09 - hard to draw such wide data structures.
121:11 - It's taking a huge amount of memory.
121:13 - But theoretically, it's coming faster.
121:15 - Yeah?
121:16 - Question.
121:17 - AUDIENCE: So would you deal with
a case if someone is in the Bob,
121:20 - but then the other kid is in the Bobby?
121:22 - DAVID J. MALAN: Good question.
121:23 - So it's a bit of a simplification.
121:25 - If you were storing both Bob and
Bobby, you would actually keep going.
121:28 - So each of these elements
is not just one letter.
121:31 - You also have essentially a node
there or some other data structure
121:35 - that says either stop here or continue.
121:37 - And you'll see actually
in the problems that we'll
121:39 - propose to you how you can
represent that idea if you
121:42 - choose to go this route.
121:43 - Indeed, the challenge ahead ultimately
is something quite like this.
121:46 - You will implement your
very own spell checker.
121:48 - And we will give you code that
gets you started with this process.
121:51 - And of course, a spell checker
these days in Google Docs
121:53 - and Microsoft Word just underlines
in red misspelled words.
121:56 - But what's going on?
121:57 - And how is it that
Word or Google Docs can
121:59 - spell check your English or
whatever language so quickly?
122:02 - Well, it has a dictionary in memory,
probably with tens of thousands
122:05 - or hundreds of thousands of words.
122:07 - And all they're doing constantly
is, every time you type a word
122:10 - and hit the Spacebar,
or Period, or Enter,
122:13 - it's quickly looking up that new
word or those words in its dictionary
122:16 - and saying, yes or no, should I squiggle
a red line underneath this word.
122:20 - And so what we're going to do is
give you a big text file, ASCII text,
122:23 - containing 100-plus thousand words.
122:26 - You're going to have to
decide how to load those
122:28 - into memory, not just correctly,
but in a way that's well designed.
122:32 - And we'll even give you a
tool, if you choose to use it,
122:34 - that times how long your code takes.
122:36 - And it even counts how much
RAM you're actually using.
122:39 - But the key goals for this
week and our final week in C
122:42 - is to take some of these
basic building blocks,
122:44 - like arrays, and
pointers, and structures,
122:48 - and decide for yourselves how you're
most comfortable stitching them
122:51 - together, to what extent you want to
really fine tune your code beyond just
122:55 - getting it correct, and to give you
a better sense of the underlying code
123:00 - that people have had to
write for years in libraries
123:02 - to make programming doable, ala Scratch.
123:05 - Because in just a few weeks, we're
going to transition to Python.
123:07 - And the dozens of lines of
code you've been writing now
123:10 - are going to be whittled
down to one line, two line,
123:12 - because we're going to get a lot
more features from these newer,
123:15 - fancier languages.
123:16 - But you'll hopefully have an
appreciation of what is actually
123:18 - going on underneath that hood.
123:20 - So I'll stick around for
any one-on-one questions.
123:22 - Let's call it a day.
123:22 - Take a duck on your way
out for roommates as well.
123:24 - And we'll see you next time.