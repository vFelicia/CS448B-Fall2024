00:00 - [Introduction]
00:49 - DAVID MALAN: This is CS50,
Harvard University's introduction
00:52 - to the intellectual
enterprises of computer science
00:55 - and the art of programming.
00:56 - My name is David Malan,
and if you are among those
00:59 - in the room who are thinking, why
am I in a class of computer science,
01:03 - realize that I too felt
that exact same way.
01:05 - In fact, my freshman
year, I didn't quite
01:07 - get up the nerve to take this class
or computer science more generally,
01:10 - and that was largely because
I was intimidated by it.
01:13 - I was a little nervous.
01:14 - It felt well out of my comfort zone.
01:16 - And I really didn't know at the end
of the day what it actually was.
01:19 - But realize if you, too, are
feeling a little bit of that,
01:22 - or even if you're among
those more comfortable who
01:24 - have dabbled in computer
science or programming,
01:26 - realize that there's so many blanks
that we can fill in along the way
01:29 - so that ultimately, at the
end of the semester, everyone
01:31 - will feel themselves on the same page.
01:34 - And until then, rest assured that 68%
of the people sitting to your left
01:38 - and to your right and
behind and in front
01:40 - have never taken a CS course
before, which may very well be
01:45 - the demographic into which you fit.
01:47 - But realize, too, that with
such an amazing support
01:50 - structure with so many office hours
and sections and materials and beyond,
01:53 - realize that what's ultimately
important in this course
01:56 - is not so much where you end
up relative to your classmates
01:59 - in week 10, our final week, but
where you end up relative to yourself
02:03 - in week zero.
02:04 - And indeed, that is where we now are.
02:06 - And as it turns out, computer
scientists start counting at zero.
02:08 - And so over the next 11
weeks, we will take you
02:11 - from being among those
less comfortable or perhaps
02:14 - somewhere in between
less comfortable and more
02:16 - to feeling much more comfortable
and confident and capable than that.
02:20 - But to get there, we need to understand
what computer science really is.
02:23 - And this was something I didn't
understand until I set foot in a room
02:26 - like this.
02:27 - And I dare say we can distill computer
science into just this picture.
02:31 - Computer science is
about problem solving.
02:33 - And I know that high school
courses typically do kind of paint
02:36 - a misleading picture
that it's only about
02:38 - and it's entirely about programming
and people with their heads
02:40 - down in the computer lab working
fairly anti-socially on code,
02:44 - but the reality is it's all about
solving problems, and very often,
02:47 - solving problems collaboratively
either in person or by leveraging code,
02:51 - programs that others
have written in the past.
02:53 - And what does it mean
to solve a problem?
02:54 - Well, you need inputs.
02:56 - So there's a problem
you're trying to solve.
02:58 - That is the input.
02:59 - And you want output.
02:59 - You want the solution to that problem.
03:01 - And the sort of secret
sauce of computer science
03:03 - is going to be everything
in this proverbial black box
03:06 - in the middle over the
next several weeks,
03:08 - where you begin to understand
exactly what you can do with that.
03:12 - But in order to start solving
problems, we kind of just
03:15 - need to decide as a group how we're
going to represent these problems
03:18 - and what might a problem be.
03:19 - Well, in this room, there's
a whole bunch of people.
03:21 - If we wanted to take attendance or
count the number of people in this room,
03:24 - I might need to start keeping
track of how many people I see.
03:28 - But how do I represent the
number of people I see?
03:30 - Well, I can do it sort of old school
and I can just take out a piece of chalk
03:34 - or whatnot and say, all right.
03:35 - I see 1, 2, 3, 4, 5.
03:38 - I can do little stylistic
conventions like that
03:40 - to save space and remind myself.
03:42 - 6, 7, 8, 9, 10, and so forth.
03:45 - Or I can, of course, just
do that on my own hand.
03:48 - So 1, 2, 3, 4, 5, and so forth.
03:52 - But obviously, how high can
I count on just one hand?
03:57 - So 5 you would think, but that's
just because we haven't really
04:00 - thought hard enough about this problem.
04:01 - It turns out that with just these five
fingers, let alone these five more,
04:04 - I can actually count rather higher
because after all, the system
04:08 - I'm using of hashmarks
on the board or just
04:10 - now with my fingers is just kind of
keeping my fingers down and putting
04:13 - them up to represent ones, really.
04:16 - But what if I actually took into
account the order of my fingers
04:19 - and sort of permuted them, so to speak,
so that it's really patterns of fingers
04:22 - that represent the number
of people in the room,
04:24 - and not just the mere presence
of a finger going up or down.
04:27 - In other words, this can remain zero.
04:29 - This could still be one.
04:31 - But what if two is not
just this, the obvious?
04:34 - But what if it's just this?
04:36 - So raising just one, my second finger.
04:38 - What if, then, three is this?
04:41 - So we have 0, 1, 2, 3.
04:44 - That's going to lead us to
four somewhat offensively.
04:47 - But if we begin to jump
ahead to five, I might now
04:51 - permute this finger and this finger up.
04:52 - And if I want to now represent
six, I could do this.
04:56 - And now seven.
04:56 - In other words, I've expressed so
many more patterns on my hand already
04:59 - and if we keep doing this,
I think I can actually
05:01 - represent painfully perhaps like 32
different patterns, and therefore
05:06 - 32 different people, on my hands alone.
05:09 - Or 31 people if I
start counting at zero.
05:11 - So what is that--
what's the relationship
05:13 - and how did we even get here?
05:14 - Well, it turns out that
computers are kind of simplistic,
05:17 - much like our hands here.
05:19 - At the end of the day, your
computer is plugged into the wall
05:21 - or it's got a battery, so it either
has or it does not have electricity.
05:24 - At the end of the day, that
is the physical resource
05:27 - that drives these things and our
phones and all of technology today.
05:30 - So if there is either electricity
or not, that kind of maps nicely
05:33 - to no finger or yes finger.
05:35 - And indeed, computers, as you probably
know, only speak what language?
05:39 - What alphabet, so to speak?
05:40 - Yeah.
05:41 - Binary.
05:41 - Bi meaning two.
05:42 - And indeed, that refers to the
fact that in binary in computers,
05:46 - you only have two digits--
05:48 - zero and one.
05:49 - We humans, of course, have
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
05:53 - and then we can combine
those to count even higher.
05:55 - But computers only have
0, 1, and then that's it.
05:57 - Because at the end of
the day, there's actually
05:59 - a direct mapping between power being off
and it being a zero or power being on
06:04 - and it being one, or some electrons
or whatever flowing from your battery
06:07 - or from the wall.
06:08 - So this is why computers
tend to speak only binary,
06:12 - because at the end of the day,
it just maps really cleanly
06:14 - to what it is that's powering
them in the first place.
06:18 - But how is this actually useful?
06:19 - If computers only have zeros and
ones, how can they do anything useful?
06:23 - Well, think about our human world, where
you might have this pattern of symbols.
06:28 - This is decimal, dec meaning 10
because you have 0 through 9.
06:31 - And this is, of course, 123.
06:33 - But why?
06:33 - If you haven't thought about
this in quite some time,
06:36 - this is really just a pattern of three
symbols, one and two and three shapes,
06:40 - or glyphs, on the screen.
06:41 - But we humans, ever since grade
school, have started ascribing meaning
06:44 - to each of these numbers, right?
06:46 - If you think back, this is the ones
column, this is the tens column,
06:49 - this is the hundreds column, and
so forth, and we could keep going.
06:53 - And so why does this pattern--
one, two, three-- mean 123?
06:57 - Well, it's because all
of us sort of intuitively
06:59 - nowadays are just quickly in our
head doing 100 times 1 plus 10 times
07:04 - 2 plus 1 times 3, which of course
gives us 100 plus 20 plus three,
07:11 - and then the number we
know mathematically as 123.
07:15 - But we're all doing this so quickly, you
don't really think about this anymore.
07:18 - Well, computers work
fundamentally the same way.
07:21 - They don't have as many digits--
07:22 - 0 through 9-- as we do.
07:24 - They only have zeros and ones.
07:26 - And so if they were to
store values, you're
07:28 - only going to see zeros
and ones on the screen,
07:29 - but those zeros and ones
just mean different things.
07:31 - Instead of having a ones
place, tens, a hundreds,
07:34 - they're going to have a ones
place, a twos place, a fours place,
07:39 - and then eights and 16 and beyond.
07:41 - Now, why?
07:42 - Well, one and 10 and 100, turns
out those are powers of 10.
07:46 - 10 to the 0 is technically 1.
07:48 - 10 to the 1 is just 10.
07:50 - 10 to the 2 is 100.
07:51 - And that's why you have ones, tens
hundreds, thousands, and so forth.
07:55 - Computers are apparently
using powers of 2.
07:57 - Not surprising.
07:58 - Binary-- two.
07:59 - So if you only have ones, twos,
and fours as your placeholders,
08:04 - if a computer were
storing these digits--
08:08 - 0, 0, 0-- that computer is presumably
storing what number so far as we
08:12 - humans understand it?
08:14 - Well, that's how a
computer would store zero.
08:16 - If a computer is storing
literally 0, 0, 0, just
08:19 - like in our human world, that
also is 0, but that's technically
08:22 - because it's 4 times 0 plus 2 times 0
plus 1 times zero, which is obviously
08:26 - zero.
08:27 - Meanwhile, if a computer is
actually storing not just,
08:30 - say, 0, 0, 0, but instead is
storing this value in binary,
08:35 - what does that map to in decimal?
08:38 - So that's one.
08:39 - And now, why, if we change this 0 and
1 to this value here, is this two?
08:46 - Well, mathematically, for
the exact same reasons.
08:49 - And so earlier, I had five fingers, but
if you consider just my first three,
08:52 - when I did this holding up one
finger, I was representing two.
08:56 - And if I want to represent three,
recall that I put up the second finger.
08:59 - And so the reason that
could nicely represent three
09:02 - is because all I was doing with my
human hand was counting in binary.
09:07 - And I could keep counting
more and more and more.
09:09 - And so if I have five fingers or
five bits, bit meaning binary digits,
09:14 - I could count up, it turns
out, if we do the math,
09:16 - as high as 31 by starting to zero.
09:19 - It's going to be hard to
physically do that, but we could.
09:22 - So why is this useful?
09:24 - At the end of the day,
a computer, therefore,
09:26 - can represent any number of values from
0 to 1 to 2 to 3 to some number much,
09:30 - much, much higher than that.
09:31 - All it needs is enough
bits, enough zeros and ones.
09:34 - Well, what are those bits?
09:35 - Well, all of us have these days in our
phones sources of light, for instance.
09:40 - So I could actually say that
this physical device right now--
09:43 - might be a little hard to tell--
09:44 - it does have a flashlight and it's
technically off at the moment.
09:47 - But if I turn this flashlight on,
thereby using some of the electricity,
09:51 - now, I'm storing a one.
09:52 - And so the phone is on.
09:53 - Now, it's off.
09:54 - Now, it's on.
09:55 - And if I see--
09:56 - can I borrow someone's phone real quick?
09:58 - May I?
09:59 - OK.
09:59 - And flashlight.
10:00 - How do I turn on the flashlight?
10:02 - Oh.
10:03 - Shake it.
10:06 - That's OK.
10:07 - OK.
10:08 - Thank you.
10:09 - Oh.
10:09 - Thank you.
10:10 - OK.
10:10 - So this is great.
10:11 - Now, I can count higher.
10:13 - Now, this represents the number what if
I have two light bulbs or two switches
10:17 - on at the moment?
10:19 - Yeah.
10:19 - Three.
10:20 - Because I have a one,
I have a one, and I
10:22 - have two, which of course is
going to end up equaling three.
10:24 - And if I pick up a third phone
somehow, I could count even higher.
10:27 - Technically, if I had
three light bulbs on--
10:29 - one, one, one-- what
would that value be?
10:32 - Seven.
10:32 - Because it's a four plus a
two plus a one, and so forth.
10:36 - Thank you so much for the spontaneity.
10:38 - So why does this not lead
to limitations for us?
10:42 - I can count in decimal
as high as I want.
10:45 - I can now count in binary as high as
I want, so long as I have enough bits.
10:48 - But how do I actually
represent other information?
10:52 - Well, if I want to represent something
like a letter, how do I get there?
10:57 - If computers only have electricity
in them and they use binary to count,
11:01 - and yet somehow they're much more
useful than just doing math--
11:04 - they can have text messages and e-mails
and websites and videos and more--
11:08 - how do we get from zeros
and ones to letters?
11:11 - Well, we-- yeah.
11:15 - Sorry.
11:15 - A little louder.
11:18 - Yeah.
11:18 - We just need to kind of
relate the numbers to letters.
11:20 - In other words, all the people in this
room just need to decide at some point
11:23 - that, you know what?
11:24 - If we want to represent something
like the capital letter A,
11:27 - we just need to decide
on a pattern of bits,
11:29 - a pattern of fingers,
that's going to represent A.
11:31 - And it turns out humans
years ago just unilaterally
11:34 - decided 65 shall be the decimal number
that represents capital letter A.
11:39 - And you might guess capital B is
represented by what decimal number?
11:43 - 66.
11:44 - And then C is 67 and so forth.
11:46 - And there's a mapping of like
128 or even 256 possible values
11:50 - for all the keys you might
see on a typical keyboard
11:52 - in order to represent letters.
11:54 - Now, how does a computer distinguish,
though, numbers from letters?
11:58 - Well, just depends on the context.
11:59 - If you're using like a
calculator program on your Mac
12:01 - or PC or iPhone or Android,
well, the computer, the device,
12:05 - is just going to know contextually,
let me interpret this pattern of zeros
12:09 - and ones as actual numbers to do math.
12:11 - But if you're using the SMS app
or the messages app on your phone,
12:14 - you're going to actually
be in the context of text,
12:17 - and so your phone is going to interpret
that same pattern of zeros and ones,
12:20 - or light bulbs being off, or, at
the end of the day, transistors,
12:23 - tiny pieces of hardware and
computers that are either on or off--
12:27 - it's going to interpret those patterns
as just representing a letter.
12:30 - If you're in the context of a text
messaging application or Microsoft Word
12:34 - or Google Docs or the like, it
completely depends on context.
12:38 - The system we humans came up with just
called ASCII, American Standard Code
12:41 - for Information Interchange.
12:43 - The name isn't interesting, but the
fact that we all agreed years ago
12:46 - that 65 is A and so forth
is what's important.
12:50 - And so for instance, if we
look at this mapping here
12:52 - of just the first few
letters, what does this mean?
12:56 - If I were to now get a text message
and I had the ability somehow
13:00 - to look underneath the hood, so to
speak, at the pattern of zeros and ones
13:04 - that someone had just
texted me, and that pattern,
13:06 - if I convert it to decimal, technically
said, let's say, 72 and 73--
13:12 - so I get a whole bunch
of zeros and ones.
13:13 - I do some math and I realize,
OK, I just received 72 and 73,
13:17 - but this is texting, and so it's not
just numbers my friend is sending me.
13:20 - It's a message.
13:21 - What message did my friend likely send
me if he or she sent 72 and then 73?
13:27 - Yeah.
13:28 - Hi.
13:28 - H-I. Because if you skim
ahead at the right there,
13:31 - that just happens to be in ASCII the
mapping between 72 and 73, H and I.
13:36 - If technically, the message
had a third byte, if you will.
13:40 - A byte, if you've ever
wondered, is just eight bits.
13:43 - It's convenient to talk not
in terms of single bits,
13:45 - where you can't count very high,
but with a byte, or eight bits,
13:48 - you can count higher.
13:49 - And so it turns out if I received a
third byte, another sequence of eight
13:53 - zeros and ones together--
13:55 - 33.
13:56 - How would we know what
this message now is?
13:59 - Yeah.
13:59 - So it turns out you
would not know this other
14:01 - than by guessing or Googling or
just coming in with this knowledge.
14:04 - This is now "HI!"
14:05 - with an exclamation point because 33
just so happens, if you look it up,
14:09 - to map to an exclamation point, as well.
14:12 - Now, if we actually looked
at the binary of this,
14:14 - you would actually see this
pattern of zeros and ones.
14:16 - This is how you represent 72 in binary.
14:18 - This is you represent 73.
14:20 - And this is how you represent 33.
14:22 - And notice I've only used one,
two, three, four, five, six bits,
14:26 - even though I technically tend
to receive things in units of 8,
14:30 - units of bytes.
14:31 - But why did I not bother writing
another 00 here and another 0 here?
14:37 - Does it matter when you
write these things out?
14:40 - No.
14:41 - Not really.
14:41 - Like in English, in our human world,
if you were to write one, two, three,
14:46 - that's 123.
14:47 - If you were to write 0,
1, 2, 3, that's still 123.
14:50 - So even though we tend to
get them in clusters of 8,
14:53 - we don't necessarily need to write
those when just talking about them.
14:56 - So what have we done?
14:57 - Well, let me introduce a fancier
word now known as abstraction.
15:00 - Abstraction is just a term generally
used in computer science and we'll soon
15:03 - see in programming for taking some
low level-- like literally low level--
15:07 - implementation details, like
minutiae even, and understanding them
15:11 - at some point, but then deciding this
is not a useful level conceptually
15:15 - to think about problems.
15:16 - I really don't want to solve problems in
this world of thinking in 0's and 1's.
15:20 - I'd much rather think about things
minimally in decimal, or better yet,
15:23 - in the context of letters if I'm
actually receiving text, or even
15:26 - some other representation.
15:28 - So abstraction is about taking
fairly low level details
15:32 - and just simplifying them so that we
can have a more useful conversation
15:35 - and never again worry about where
the electricity is coming from.
15:39 - We can just stipulate my computer
can represent zeros and ones.
15:42 - Therefore, it can represent numbers.
15:44 - Therefore, it can also
represent ASCII or letters.
15:47 - And we can kind of move on and start
solving more interesting problems.
15:50 - But it would seem that we can't solve
all problems because on my keyboard
15:56 - here, this American keyboard here,
there's a whole bunch of symbols,
16:00 - like a 100 or 200 maybe in total if we
actually hit shift and option and all
16:03 - of that.
16:04 - But what you don't see are
some pretty common characters.
16:07 - Especially in a very
international audience,
16:09 - what can I apparently not
even type on this keyboard?
16:12 - What kinds of symbols?
16:13 - Yeah.
16:15 - Anything with an accent.
16:16 - If you have accents over
vowels or other letters.
16:18 - What else?
16:19 - I'm sorry.
16:20 - Umlauts or other
characters above letters.
16:22 - Yeah.
16:25 - Like pound symbol?
16:26 - Oh.
16:26 - Like the UK pound symbol.
16:27 - Sure.
16:28 - And other countries, too.
16:29 - Any number of Asian languages.
16:30 - There's so many symbols that are
not depicted on this keyboard,
16:33 - and yet somehow, all of us with
international keyboards or phones
16:36 - can surely express themselves.
16:38 - But that's because phones and computers
these days don't just use ASCII.
16:42 - ASCII literally used
just eight bits total.
16:45 - Technically seven, but then,
ultimately, really eight.
16:47 - And with eight bits, if
you actually do the math--
16:49 - if you have eight bits
or eight fingers, you
16:51 - can only permute them in 256
total possible ways, which
16:56 - is to say that you can only represent
256 characters using ASCII with numbers
17:01 - underneath the hood, and
that's not enough to represent
17:03 - so many different symbols
like those enumerated here.
17:06 - You can't represent any of the
accents that you can nonetheless
17:08 - type on your Macs and
PCs and you certainly
17:11 - can't type these things,
which are very much in vogue.
17:13 - Which even though they're pictures,
they're actually just characters.
17:17 - Because it turns out some years ago, the
world decided eight bits is not enough.
17:22 - Let's start using something called
Unicode, where you actually use
17:25 - one or two or three or even four bytes.
17:28 - So eight bits or 16 bits, 24 bits, or
even 32 bits to represent characters.
17:33 - And now, we have the ability
to represent thousands or even
17:35 - millions of characters.
17:37 - And frankly, daresay, the result
of that huge amount of availability
17:42 - is partly why there are so many
of these things these days.
17:45 - And they just keep making more because
there's just so many different numbers
17:48 - available to us.
17:49 - So Unicode is often a specific
version of it called UTF-8,
17:52 - which we'll see before long.
17:54 - But let me ask this question here.
17:56 - This is a crying face with
joy, I think this is called.
18:01 - So it turns out,
according to Apple or iOS,
18:03 - this is the most popular emoji
that at least iPhone people
18:06 - are sending to each other.
18:07 - So when you're receiving this, though,
if we can really take the fun out
18:10 - of this, what pattern of bits are you
actually receiving from your friend?
18:14 - He or she is clearly trying
to express some emotion,
18:17 - but really, what your friend is sending
you-- the decimal number 128,514.
18:24 - Or really, if you looked at
the zeros and ones coming
18:26 - to you over the internet
or airwaves, you're
18:29 - getting this pattern of zeros and
ones, which is hardly joyful or hardly
18:33 - descriptive, but all
your phone or computer
18:36 - are doing is seeing
this pattern of bits,
18:38 - looking it up in like a little
cheat sheet, and saying, oh.
18:40 - Whenever I see this pattern of bits
in the context of text like texting,
18:44 - I should actually display
it as that picture.
18:47 - Now, that picture has a lot
of yellow and other colors
18:50 - in it, but how do we even get there?
18:53 - Well, it turns out that this
same pattern of numbers--
18:55 - 72, 73, 33-- which just to be
sure, a moment ago, meant what?
19:00 - Hi.
19:00 - In the context of a textual program like
Microsoft Word, Google Docs, texting,
19:04 - this means hi.
19:05 - But what if you saw this
same pattern of bytes--
19:09 - and again, we could
draw the zeros and ones,
19:11 - but it's not interesting
anymore, so we're going
19:13 - to abstract away at the decimal level.
19:15 - If you got this same
pattern of zeros and ones
19:17 - or numbers in the context of
like Photoshop or a browser
19:21 - or some kind of photo program,
well, it might make more sense
19:24 - to interpret it not as text, but
as imagery, some kind of colors.
19:28 - Well, it turns out there's this
other system in the world--
19:31 - you might have seen
this acronym before--
19:32 - called RGB-- red, green, blue.
19:35 - And this is just a way of
humans having standardized years
19:38 - ago that you know what?
19:39 - If we want to represent a dot on
someone's screen, otherwise known
19:42 - as a pixel a tiny little
square on the screen
19:44 - of your phone, your laptop,
or even TV these days,
19:47 - we're going to use three bytes--
19:49 - one byte to specify how much red
should be in that specific pixel,
19:54 - one more byte to specify how much green
should be combined with red to form
19:57 - that pixel, and then
one more byte, a third,
20:00 - to represent how much blue to
combine with those other two colors
20:03 - to make a new color all together.
20:05 - So it's kind of like combining
paints, except in this case,
20:09 - it's more really waves of light in
order to get a specific color using just
20:13 - red, green, and blue as your palette.
20:16 - And so if we were to see this
red, green, blue pattern and say,
20:20 - you know what?
20:20 - Give me 72 red, 73 of
green, and 33 of blue.
20:25 - If the total possible range that I
alluded to earlier is like 0 to 256,
20:30 - or technically 0 to 255 if you start
counting in computer science from zero,
20:35 - this is like a medium amount
of red, medium amount of green,
20:38 - and just a little bit of blue,
if the range goes from 0 to 255.
20:42 - So if you combine these
three things together
20:44 - and you want to know
what color you get--
20:46 - yeah.
20:47 - So it's kind of a light
yellow that looks like this.
20:50 - So if a computer is storing a
single dot on the screen that
20:54 - happens to be in yellow, what
the computer's actually storing
20:57 - is not this dot physically,
but a pattern of three
21:00 - bytes-- how much red, how much green,
how much blue should the computer
21:03 - display at this particular point.
21:05 - So if we look at this crying face of
joy and we kind of enhance or zoom in
21:10 - on it here, you can actually see
it start to pixelate, so to speak,
21:14 - where you start to see the dots.
21:15 - If I punch in a little
more, now you can really
21:17 - start to see the dots on the screen.
21:20 - And if I go an even
further, you can actually
21:22 - see the tiny little squares that
compose this image, most of which
21:26 - at the zoom level are yellow,
but a bunch of which are black,
21:29 - a bunch of which are light
black or dark yellow.
21:33 - And that's what composes
this image ultimately.
21:35 - So this is to say if you count up
all of the pixels on the screen
21:39 - and then multiply it by one,
two, three bytes, that's
21:43 - how many bytes or kilobytes or
megabytes, if you've heard those terms,
21:46 - are going to be stored on your
computer just to represent an image.
21:51 - So we've gone from electricity to down
here, so to speak, to zeros and ones,
21:56 - to decimal, now to colors.
21:58 - Well, with colors, you can get images.
22:00 - What comes after images?
22:01 - Well, we've all watched videos or
movies certainly digitally these days.
22:05 - Well, what is a movie or a video file?
22:07 - How might that be implemented?
22:11 - Say it a little louder.
22:13 - Yeah.
22:13 - It's a collection of images.
22:15 - If you've ever heard
of frames per second--
22:16 - like movies tend to be 24 frames
per second or 30 frames per second--
22:20 - that just means that a
typical movie, every second
22:23 - is showing you 24 or
30 images per second
22:26 - and they're just flying by
so quickly that you actually
22:29 - don't notice you're just watching
a sequence of static images.
22:31 - It's like as a kid, if you ever had one
of those paper flip books where there's
22:35 - tons of drawings in them, and
as you flip through the pages,
22:38 - you see things moving, but that's
just because your eyes are just
22:40 - seeing little snapshots ever so quickly
of something moving on the paper.
22:45 - That's all a video file actually is.
22:47 - So if you have an iPhone and you've
ever played with these animojis,
22:49 - so to speak, well, all those
are are little video files
22:53 - composed of lots and
lots and lots of images
22:55 - that you have saved on your
phone or texted to someone else.
23:00 - And if we just think, now, we're at
the point of video, but that's OK.
23:03 - Videos are just bunches of images.
23:04 - Images are just bunches of colors.
23:06 - Colors are just patterns of bits.
23:07 - And bits, at the end
of the day, are just
23:09 - the result of electricity coming
into my machine or transistors
23:12 - turning switches on and off.
23:14 - Like we've all of a sudden to hold
this entire story, but none of us
23:18 - ever is going to need to really think
about binary in the context of videos
23:21 - because a video is just an abstraction
on top of bunches of images,
23:25 - and images are just an abstraction on
top bunches of pixels, and so forth.
23:29 - So we can keep painting
this hierarchy that
23:31 - just allows us to talk about
things at a more useful level,
23:34 - and the reason we had
this conversation is
23:35 - just because we needed
a way to represent
23:38 - inputs and outputs to problems.
23:41 - Let me pause there for just a second
to see if there's any questions.
23:46 - Anything at all?
23:48 - No?
23:49 - All right.
23:49 - So what's inside this black box?
23:52 - Well, it turns out this is where
the really interesting work starts
23:56 - to happen and the thought
starts to come in.
23:58 - This is the proverbial algorithms,
step by step instructions
24:01 - for solving some problem.
24:03 - And some of you might have
solved this problem before,
24:05 - either digitally or
textually, but of course,
24:07 - if you have contacts in
your phone these days
24:09 - and you've got bunches
of friends and family,
24:11 - odds are they're alphabetized
by first name or last name.
24:14 - And you have auto complete these
days, but it really is just
24:16 - a long list of names and numbers.
24:18 - That's not all that different
from yesteryear's implementation
24:20 - of the same problem, which was
this device here, a phonebook.
24:24 - Now, this phonebook might have a
friend of ours in it, say Mike Smith,
24:28 - whose last name starts with
S. And I could, of course,
24:30 - if trying to find Mike
Smith, start by looking
24:32 - at the first page, the second page,
the third page, the fourth page,
24:37 - and eventually, just
hopefully find Mike Smith.
24:39 - Indeed, is this algorithm,
this step by step process,
24:42 - correct for finding
someone like Mike Smith?
24:45 - Yeah.
24:46 - It's correct.
24:46 - It's stupid and slow
perhaps because it's
24:48 - going to take forever in
a phone book of this size,
24:51 - but it is correct because if Mike's
in here, I will, in fact, find him.
24:54 - But I could do this better.
24:55 - I could do it sort of two at a time.
24:57 - So two, four, six, eight,
10-- or imperfectly--
25:00 - 10, 12, 14.
25:02 - Is that faster?
25:04 - Obviously, it's going twice as fast.
25:06 - Is it correct?
25:08 - No.
25:08 - Why is it not correct?
25:10 - Yeah.
25:11 - I might miss him, right?
25:12 - Mike just accidentally might eventually
get sandwiched between two pages
25:15 - and I have the unlucky
experience of just missing him.
25:18 - Now, is it fixable?
25:19 - Yeah.
25:20 - I can probably, once I hit like SN
or the T section, for instance--
25:24 - I can just say, obviously,
I've gone too far for Mike.
25:26 - Let me just double back
one or just a few pages.
25:28 - So it is fixable.
25:30 - And so long as I've saved time by
flying through this twice as fast,
25:33 - can I at least afford to spend a
few more steps at the very end just
25:37 - to find Mike Smith?
25:38 - But none of us are going to do that.
25:39 - And our Apple devices and
Android devices certainly
25:42 - don't do that for efficiency today.
25:44 - Odds are most of us are going to do what
to find someone in any book like this?
25:48 - Yeah.
25:48 - Open to roughly the middle or
maybe bias ourselves toward the end
25:51 - because S is after the middle.
25:53 - But you know, I'm in the
middle of the phonebook here.
25:55 - And now, if I know that Mike is in
the S's and therefore over here,
25:58 - where do I know he's not?
26:01 - He's not in the beginning
and I can literally
26:03 - tear a problem like this in half,
throw figuratively and literally half
26:07 - of the problem away, and be left
with fundamentally the same problem,
26:11 - but it's half as big.
26:12 - I went from like-- whatever--
26:13 - 1,000 pages to 500 pages and I
can now repeat this algorithm.
26:17 - I look down.
26:18 - I'm a little too far.
26:19 - I'm in the T section now.
26:20 - OK.
26:20 - I can again tear the problem
in half, throw that half away,
26:25 - taking a 500 page byte out, a 250
page byte out, now leaving myself
26:29 - with just 250 pages more.
26:31 - And notice just how quickly I got here.
26:32 - The first two algorithms got me from
1,000 to 999 to 998, or 1,000 to 998
26:39 - to 996.
26:40 - But here, I went from
1,000 to 500 to 250.
26:43 - Feels like we're making up time here.
26:45 - And indeed, if I keep
repeating this process,
26:47 - hopefully, I'll be left with
just one page of the book
26:50 - that Mike is either on or not,
at which point, I will call him.
26:55 - And so that's an algorithm that honestly
leverages probably all the intuition we
26:58 - have and a lot of what
programming is going to be,
27:01 - is thinking about a problem like this,
figuring out how to divide and conquer
27:04 - it, and then expressing
yourself in a way
27:06 - that the computer can then
solve that problem for you.
27:09 - And just to paint a picture of how
much better this algorithm is, well,
27:12 - if this is just a very abstract
chart where we have on the vertical,
27:15 - or y-axis, how much time it
takes to solve a problem,
27:18 - and on the horizontal axis
how big the problem is--
27:21 - so the farther out you go this
way, the more pages in the problem,
27:24 - the more pages in the phonebook.
27:25 - And the higher you go up
here, the more seconds or page
27:28 - turns it's going to take.
27:29 - That first algorithm is
just like a linear slope,
27:32 - so to speak, because for every
additional page in the book,
27:35 - it might take me one more second.
27:37 - Right, up.
27:38 - It's just a one for one
relationship with pages.
27:41 - The second algorithm,
if I plot it, where
27:43 - I'm flying through
twice as fast, what is
27:45 - that line going to look like instead?
27:51 - Yeah.
27:51 - It's going to look lower than this one.
27:53 - It's still going to be a straight
line because now, there's a two to one
27:56 - relationship, but if you've got a
phone book that's got this many pages,
27:59 - and in the first algorithm,
it took this long, here,
28:02 - well, in the second algorithm, it will
take half as many steps, plus or minus
28:07 - or two if you need to actually
double back a little bit.
28:09 - But that third algorithm is
what we'll call logarithmic.
28:12 - If n is the number of
pages in the phone book,
28:15 - the first algorithm,
in the very worst case,
28:16 - might take all n pages
to find Mike Smith.
28:18 - The second algorithm is going to
take half as many steps because I'm
28:21 - flying through it two at a time.
28:22 - But the third algorithm is going
to look and feel like this.
28:26 - It's going to be curved and ever so
slowly rising and rising and rising,
28:30 - the implication of which is if
Verizon or the phone company
28:33 - doubles the number of
pages in the phonebook
28:35 - next year because Cambridge and
Somerville merged together in the phone
28:39 - book and we now have 2,000 pages.
28:41 - Well, how many more steps
does my third algorithm take?
28:45 - Just one.
28:45 - Because I can take a 1,000
page bite out of the problem
28:48 - with that clever algorithm, whereas
my first two algorithms would take it
28:52 - one or just two pages at a time.
28:54 - So that is to say we have to hugely
increase the size of this problem
28:58 - just for the number of seconds or page
turns to appreciably actually increase.
29:03 - And so as we start to
learn about programming,
29:05 - it's, again, going to be leveraging
of this intuition in order
29:08 - to actually solve problems and
code more effectively than we
29:13 - might without that intuition alone.
29:17 - So let's formalize this now.
29:19 - So that was kind of a very intuitive way
of dividing and conquering a problem.
29:22 - Just kind of made sense
to go in the middle,
29:24 - tear it, then go to the
other half or the other half
29:26 - and tear it again, and so forth.
29:29 - But a computer, even as cool as Alexa
and Google Home and all of this are,
29:33 - you can't really just talk
to them as another human
29:36 - and have them execute things correctly.
29:37 - I struggle just to get Siri
to set a timer on my phone.
29:41 - So we're not quite there yet,
so we're still at the age
29:43 - where we have to be ever
so precise with computers,
29:46 - voice activated or otherwise, and
so thus enter pseudocode for now.
29:50 - Pseudocode has no formal definition.
29:52 - This is just a way of saying use English
like syntax or any spoken language
29:57 - and just express yourself
succinctly and correctly
30:00 - so that a computer or a
robot or even another person
30:03 - can understand what it
is you're trying to say.
30:05 - So here, I propose, is
an algorithm written
30:08 - in pseudocode, English like syntax,
that just gets my point across.
30:11 - And I could write this
in any number of ways.
30:13 - I've numbered the steps from zero on
up, just for the sake of discussion,
30:16 - but this would seem to
capture what I did there.
30:18 - Pick up the phone book.
30:20 - Open to the middle of the phone.
30:21 - Look at the names.
30:22 - If Smith is among the names, call Mike.
30:25 - Else, if Mike Smith is
earlier in the book,
30:27 - go to the left, specifically the
middle of the left half of the book,
30:31 - and then go back to step two.
30:32 - Because indeed, I was just doing
the same thing again and again,
30:35 - and the reason I wasn't doing it
forever was because every time I
30:38 - repeated myself by opening and
tearing, I was shrinking the problem.
30:42 - And I can only shrink a problem
of some fixed finite size
30:44 - so many times until I
get just one page, and so
30:47 - if I continue this logic looking to the
right or to the left or just quitting,
30:51 - if I don't find Mike at
all on the last page,
30:53 - this would seem to capture
more precisely that code.
30:56 - Well, let's actually excerpt
from this now a few concepts
30:59 - and then start to apply
them to actual code.
31:01 - Highlighted in yellow here, I dare
say, are all of the verbs or actions.
31:05 - These are the functions, as we're
going to start calling them,
31:08 - in this algorithm.
31:09 - A function is just a specific
step, a specific action
31:12 - you take in order to do something.
31:15 - And so in yellow here-- pick up,
open to, look at, call, open, quit
31:19 - are all actions or verbs.
31:20 - Are henceforth, we'll
call them functions.
31:23 - Meanwhile, highlighted in yellow
here-- if, else if, else if, else.
31:27 - These are kind of
starting to ask questions.
31:29 - What might these be called
if you have some familiarity?
31:32 - Yes.
31:33 - Turns out many programming
languages, if you've seen any before,
31:35 - would call these conditions.
31:36 - They're branches, or
proverbial forks in the road.
31:39 - If this is true, go this way.
31:40 - Else, maybe go this other way, or
perhaps a third or fourth direction
31:44 - altogether.
31:45 - Meanwhile, if we actually look
at these highlighted phrases--
31:48 - if Smith is among names or
if Smith is earlier in book
31:51 - or Smith is later in book--
31:52 - these are the specific questions we're
asking in order to make that decision.
31:56 - These are known as Boolean
expressions, named after a gentleman
31:59 - by the last name of
Boole some years ago.
32:01 - And so a Boolean expression
is just a question
32:03 - that has a yes or no answer, a
true false answer, a one zero
32:07 - answer, if you will.
32:08 - And that's a nice mapping to what
computers are really good at.
32:11 - So within conditions, you
have Boolean expressions
32:13 - to decide which fork in the
road you want to go down.
32:16 - And then lastly,
highlighted in yellow here
32:18 - is go back to step 2
in a couple of places.
32:21 - This is inducing some
kind of cycle or loop
32:23 - that's telling the computer to do
something again and again and again.
32:27 - So in short, we have these building
blocks already conceptually.
32:31 - And it turns out, we can
now start to translate these
32:34 - to an actual programming language.
32:36 - The first of the languages
we'll introduce in CS50
32:38 - is something called Scratch.
32:39 - Turns out this is not
a text based language,
32:41 - like in my English pseudocode
there, but it's graphical
32:44 - and things look like puzzle
pieces that you can drag and drop
32:46 - and they interconnect if it
makes logical sense to do so.
32:48 - And in fact, some of you might have
played this back in the day as kids
32:51 - or even more recently because
it's actually targeted typically
32:54 - at students in like
after school programs who
32:55 - just want to learn more methodical, more
algorithmic, or computational thinking.
33:00 - And we're going to use it to
explore not only these building
33:02 - blocks, but a few others, as well.
33:04 - It turns out in the other languages
we'll explore in CS50 and beyond,
33:08 - are languages like C that we'll actually
transition to as quickly as next week,
33:12 - to then translate what we do this
week in Scratch to next week in C.
33:16 - And in languages like
Python and JavaScript
33:18 - and SQL, which we'll also explore,
do we have other capabilities--
33:21 - the ability to store data
in variables, so to speak,
33:24 - to use threads, which means get the
computer to do multiple things at once,
33:27 - events, to mean listen for
things happening, like a click
33:30 - on the page or a human typing
or even saying something.
33:33 - We'll be able to do all of
the things that you take
33:36 - for granted in your very own phones.
33:38 - And we'll do this first
by way of this guy.
33:41 - So this is Scratch, the default cat
that comes with this programming
33:44 - language from MIT's media lab.
33:45 - And via Scratch can we start
programming him to move up,
33:48 - down, left, right, say something,
utter something, and other commands
33:52 - all together.
33:53 - In fact, let me go ahead
and switch contexts here
33:56 - to show you the very first
thing I ever wrote in Scratch.
33:59 - It was back in the day when
I was in graduate school
34:01 - and Scratch had just
been invented by MIT.
34:03 - Let me go ahead and open this.
34:05 - And I called it Oscar Time.
34:08 - And if we could perhaps have a
volunteer come on up for just a moment.
34:11 - You have to be comfortable being
on stage and on the internet.
34:14 - How about here in the white shirt?
34:15 - I saw your hand first.
34:16 - Come on down.
34:18 - So this is Oscar Time.
34:19 - It's implemented in a
language called Scratch.
34:21 - And at the end of the day, all that
is underneath the hood of this program
34:25 - is functions and loops and conditions
and a few other of these concepts.
34:29 - Hi.
34:29 - What's your name?
34:30 - AVIVA: Aviva.
34:30 - DAVID MALAN: Aviva.
34:31 - David.
34:31 - Nice to meet you.
34:32 - Come on over here.
34:33 - And in just a moment, I'm
going to go ahead and click
34:37 - the green flag at the top
left hand corner, which
34:39 - is going to play this game.
34:40 - And we'll see on the
screen the instructions.
34:42 - [MUSIC PLAYING]
34:45 - OSCAR: (SINGING) Oh, I love trash.
34:50 - Anything dirty or dingy or dusty.
34:54 - Anything ragged or rotten or rusty.
34:58 - Yes, I love trash.
35:02 - If you really want to see
something trashy, look at this.
35:05 - I have here a sneaker
that's tattered and worn.
35:09 - It's all full of holes
and the laces are torn.
35:13 - A gift from my mother
the day I was born.
35:17 - I love it because it's trash.
35:21 - Oh, I love trash.
35:25 - Anything dirty or dingy or dusty.
35:29 - Anything ragged or rotten or rusty.
35:34 - Yes, I love trash.
35:37 - Here's some more rotten stuff.
35:40 - I have here some
newspaper 13 months old.
35:43 - DAVID MALAN: All right.
35:44 - Everybody, give a round of applause
for Aviva for coming on up.
35:46 - Thank you.
35:47 - Here.
35:48 - Aviva.
35:48 - [APPLAUSE]
35:51 - A little CS50 stress ball.
35:53 - So suffice it to say, if
you're tired of this song,
35:56 - consider how tired I was eight hours
later while debugging and building
35:59 - this program.
36:00 - But consider what it is we just saw.
36:02 - It's this interactive game and stuff
is animated and music is playing.
36:05 - But if you focus on decomposing,
so to speak, this program into just
36:09 - basic building blocks, this is just kind
of a big abstraction over some lower
36:13 - level pieces of functionality.
36:15 - Like this trash can here.
36:16 - At the moment, it's just a
picture, and on occasion,
36:18 - as soon as Aviva dropped something
into the trash, the lid came up
36:21 - and Oscar came out, he said
something, and then he went back down.
36:24 - But that animation is super simplistic.
36:26 - It was just a sequence of 1, 2, 3,
or so images displaying and then
36:31 - going back down to create
the illusion of animation.
36:33 - Meanwhile, every time
Oscar said something,
36:36 - that was keeping track of her
score in what's called a variable.
36:39 - In algebra, you have x and y and z, but
in programming, you have the same idea,
36:42 - but it's generally more useful
to call them more descriptively,
36:45 - like your score.
36:46 - And so there's probably a
variable in this game called
36:48 - score that was just keeping
track of how many times
36:51 - Aviva had dropped
something into the trash.
36:53 - Meanwhile, the trash itself and the
shoe and the newspaper-- and even more
36:57 - things happen eventually--
were falling from the sky
37:00 - at sort of random locations, and
that's because I programmed the game
37:03 - to sort of start the trash
here or over here, just
37:06 - to make it a little more
challenging as the game picked up.
37:08 - And in fact, things start falling
faster and faster over time,
37:11 - like a typical game, getting
more and more difficult.
37:14 - So how do we get to something like that?
37:16 - Well, let me go ahead and
open up Scratch itself
37:19 - and introduce the environment.
37:21 - So in Scratch, you essentially
have three general areas.
37:24 - And it's web based, and so you
can do this on any computer.
37:26 - And in the left hand side here,
you have those puzzle pieces
37:29 - to which I referred earlier.
37:30 - These puzzle pieces are all mapping
to functions or loops or conditions
37:36 - or variables, things that
we saw before, and I'm
37:38 - going to able to drag and drop
them into the middle in order
37:41 - to interconnect them
and write my program,
37:43 - which we'll do in just a moment.
37:44 - Meanwhile, Scratch lives in this stage,
this world, where he can move up,
37:48 - down, left, right.
37:49 - You can change what Scratch looks like.
37:50 - You can add other characters,
otherwise known as sprites,
37:53 - in order to have multiple
things happening at once.
37:55 - And of course, you can fullscreen it.
37:56 - And so the Oscar Time game a moment ago
was actually a whole bunch of sprites.
38:00 - Oscar's trash can was one.
38:02 - Each piece of trash was another sprite.
38:04 - The newspaper was a
sprite, and so forth.
38:07 - So each of them were separate programs
running in parallel at the same time.
38:11 - So let's actually make him do something.
38:13 - It turns out that if I
jump down to, say, events,
38:16 - I'm going to see one of
the most powerful blocks
38:18 - from the get go, which is
this when green flag clicked.
38:22 - That's indeed how I started
the game with Aviva,
38:24 - by clicking just above
Scratch's world this green flag.
38:27 - And if I wanted to
stop it, as I did, you
38:29 - can click the red stop sign to say stop.
38:31 - Meanwhile, the green
flag, I can constantly
38:34 - listen for by dragging and
dropping this puzzle piece.
38:37 - When the green flag is
clicked, what do I want to do?
38:39 - Well, let me go up to looks.
38:41 - And these are just different categories.
38:43 - And we can scroll through all
the different colorful blocks,
38:45 - but they pretty much
just do what they say.
38:47 - I'm going to go under looks, where I
know there to be a block that's called
38:50 - say, and I'm going to go ahead and type
the most canonical computer science
38:53 - thing-- hello world--
38:55 - in this box.
38:56 - So notice that functions
themselves can actually
38:58 - take inputs and the input
to this function, say,
39:01 - is going to be hello world.
39:03 - If I now go over to the
green flag and click it--
39:06 - hello world.
39:07 - All right.
39:08 - So not all that difficult.
Not all that interesting.
39:11 - But it actually got the job done, and
so my program is indeed just this.
39:14 - Well, how might I make this
a little more interesting?
39:17 - Just saying, hello world all the
time isn't all that compelling.
39:19 - Well, you know what?
39:20 - Let me think.
39:21 - Let me undo this.
39:22 - Let me scroll down to sensing.
39:24 - And notice this.
39:25 - Functions can also
take input from a human
39:28 - and functions can hand you back a
value, a so-called return value.
39:32 - So this block here, ask
something-- by default, it says,
39:35 - what's your name and weight--
39:36 - is another function built into
Scratch that allows me to do this.
39:39 - So I'm going to go
ahead and drag this here
39:41 - and I'm going to let it
say, what's your name?
39:43 - Notice now that below this
block is a special block,
39:46 - whatever it is the block returns.
39:48 - So answer is whatever the
human is going to type in.
39:51 - And if I want to now say what the human
typed in, let me go again to looks.
39:56 - Go to say.
39:57 - And notice that these
blocks are kind of magnetic.
39:59 - They want to snap together.
40:00 - So I'm going to go
ahead and let go there.
40:02 - And if I go back to
sensing and grab answer,
40:05 - notice that even though it's
not quite the same size,
40:07 - it's going to grow to
fill, and now, I can
40:09 - have my program ask the user
what his or her name is and then
40:12 - say whatever that answer is.
40:14 - So let me go ahead and
stop and click play again.
40:18 - Notice it's asking me for my name,
so let me go ahead and type in David.
40:21 - Enter.
40:22 - OK.
40:22 - It's a little weird
way to greet someone.
40:24 - David.
40:25 - So it'd be nice to clean that up a bit.
40:28 - So you know what?
40:29 - I know this only from
having poked around before.
40:31 - Not all of this is
obvious at first glance.
40:33 - But it turns out that under
operators, the category,
40:36 - there's this thing here--
join apple and banana.
40:39 - Which are just default values.
40:40 - You can change them.
40:41 - Because what do I want to do?
40:42 - I want to say hello, David, or whoever,
so I kind of want to say hello, comma,
40:47 - and then, David-- whatever
the human typed in.
40:49 - And that's what join lets you do.
40:51 - It lets you join or concatenate
two phrases that are somehow
40:54 - provided by you or the user.
40:56 - So let me pull this out, the answer.
40:58 - Let me go ahead and grab the join block.
41:00 - Notice it, too, is
going to grow to fill.
41:02 - Let me go ahead and say, hello, comma,
space, and now, drag answer into there.
41:09 - And notice this nesting.
41:11 - Just like in math.
41:12 - This nesting of functions.
41:14 - I can first join hello and answer
by taking those two things as input
41:18 - and then pass them to
say as another input
41:20 - because these things are layered on top.
41:22 - And so now, if I stop this and
play it again and say, David--
41:26 - hello, David.
41:27 - Now, we have the makings of a more
interesting interactive program
41:30 - that isn't just hardcoded.
41:32 - Of course, it's not nearly as audible as
something like Oscar Time a moment ago.
41:38 - So let me go ahead and do this.
41:39 - Let me start over altogether and
treat Scratch like the cat he is
41:43 - and just start the sound called meow.
41:45 - So it turns out there's a
category of blocks called sound,
41:48 - and within sound, there is
play some default sounds.
41:50 - So start sound meow.
41:52 - And now, things will get a little cuter.
41:54 - [MEOW]
41:55 - Aw.
41:56 - And now, again.
41:58 - [MEOW]
41:59 - And I can kind of simulate a cat
by [MEOW] standing here for a while
42:03 - and keeping to click this button.
42:04 - But you know what?
42:05 - Let me make him meow few times
because that's more realistic.
42:07 - So let me grab a second
one and a third one.
42:09 - And you can get this
infinite supply of blocks.
42:11 - Let me hit play.
42:12 - [MEOW]
42:16 - Seems like a bug.
42:17 - Let's try again.
42:17 - Play.
42:18 - [MEOW]
42:21 - This is my first bug, or mistake.
42:23 - This looks correct.
42:24 - It says when green flag clicked,
start sound meow, start sound meow,
42:28 - start sound meow.
42:30 - Why am I only hearing one meow?
42:33 - Yeah.
42:34 - They're kind of at the same time
or so close to the same time
42:37 - that the sounds are kind of tripping
over each other and just overlapping,
42:41 - right?
42:41 - The block literally
says, start sound meow.
42:43 - But computers are really fast.
42:45 - If you've heard of the expression
gigahertz, that's a unit of measure.
42:48 - And if your computer has a one gigahertz
CPU, central processing unit, or brain,
42:52 - that means it can literally do
like a billion things per second.
42:55 - It can certainly start
three sounds super fast.
42:59 - And if they're effectively all
happening one after the other
43:02 - before the sound even finishes,
you're just hearing one net effect.
43:05 - So how can we fix this?
43:06 - Well, I can actually go and
fix this with this block here--
43:09 - play sound meow until done.
43:12 - Play sound meow until done.
43:15 - And now.
43:16 - [MEOWING]
43:18 - OK.
43:19 - It's a little unhappy,
this particular cat,
43:20 - but at least it's now more correct.
43:22 - And, as it turns out,
if I go to control--
43:25 - you know what?
43:26 - There's this block here--
wait some number of seconds.
43:28 - I can go ahead and insert this here.
43:30 - Let me do another one here.
43:32 - And now, hit play.
43:33 - [MEOWING]
43:38 - You know, it's not bad.
43:40 - It now sounds a little more realistic.
43:43 - But honestly, if I keep doing
this-- or you know what?
43:45 - You can actually right click
or control click on blocks,
43:47 - duplicate them, and just copy and
paste even more if you want them.
43:51 - So if I were to do this, now,
it's just going to go six times.
43:55 - And then I could copy it
again and go 12 times.
43:57 - But there's got to be
a better way, right?
43:59 - This is now bad programming.
44:00 - This is bad design.
44:01 - Because I'm literally copying
and pasting, albeit, graphically.
44:04 - But we've already seen a
building block with which
44:07 - we can design this program better.
44:09 - It's correct, but it's
not well designed.
44:11 - What would the building block be that
I need to make this a little cleaner?
44:15 - OK.
44:16 - A four loop.
44:16 - Doesn't quite exist in Scratch.
44:18 - But a loop fundamentally
does something cyclically.
44:21 - And indeed, if I go under
control and start poking around,
44:23 - you'll notice that there's a few
blocks that might apply here.
44:26 - There's the repeat block
some number of times
44:29 - or the forever block, both of
which sound like loops, or cycles.
44:32 - So sure enough, let me go ahead
here and I can throw away blocks
44:35 - by just dragging them to the left.
44:37 - Let me pull this out for a second.
44:40 - And then just say forever play this
sound, and then wait one second.
44:44 - So now, my program looks like this.
44:47 - [MEOWING]
44:53 - You know, we'll never know if it's
technically correct because it's just
44:56 - going to go, we think, forever,
but it looks like this is correct.
45:00 - And it was a lot less
code and it's a lot easier
45:02 - to maintain because if I want
him to kind of get sleepy,
45:05 - I can then maybe say
two seconds instead.
45:09 - [MEOW]
45:11 - You know, and we can adjust
this on the fly as we go.
45:13 - But let's start to combine
some of these ideas
45:15 - now and change what it is
the ultimate effect is.
45:19 - Let me go ahead and open an
example I made in advance.
45:22 - This one's called Count Zero.
45:24 - And we'll put this on the website later
so that you can play with if you like.
45:27 - And this is kind of the
opposite of counting sheep.
45:29 - Rather than me or the person
sleeping counting sheep,
45:32 - this sheep will count itself.
45:34 - So let me go ahead and just play.
45:37 - And adorably, he seems to
just be counting 1, 2, 3.
45:41 - But why is that?
45:42 - He's just going to count forever.
45:44 - But let's look at the blocks with
which he is counting forever.
45:47 - When green flag clicked, set counter.
45:49 - Turns out this orange box is
what we called a variable.
45:51 - So in algebra, it would
be like x or y or z.
45:53 - Those are not descriptive.
45:54 - I called this one counter instead, but
I could have called it x or y or z.
45:58 - And then I forever say the counter
for one second, then wait one second,
46:03 - and then change the
counter by one, which
46:04 - technically means just increment it.
46:06 - Add 1 to it.
46:07 - And the sheep is just going to
therefore count up and up and up.
46:10 - Now, this is a little
tedious, but that's
46:11 - kind of the point of counting
sheep, of course, to fall asleep.
46:15 - But what if the sheep actually kind
of liked counting a little faster?
46:18 - Well, let me go under operators here.
46:21 - Multiplication sounds like it
could get us places quicker.
46:24 - And let me go ahead and go to variables.
46:27 - And instead of changing
the counter by one,
46:29 - let me go ahead and just keep
setting it to something else.
46:32 - So let me drag and drop this.
46:33 - Set the counter equal to something
times something, specifically
46:38 - the counter times two, thereby
doubling, doubling, doubling, doubling.
46:44 - That would seem to grow,
so to speak, a lot faster.
46:47 - Let's see.
46:49 - 1, 2, 4.
46:54 - So he's counting faster, but
it's still kind of tedious.
46:56 - What if we instead do this?
46:58 - Let's stop waiting and let's
go ahead and, with the looks,
47:02 - not say counter for one second,
but let's just quickly say counter.
47:06 - So I'm going to say the counter.
47:08 - Whoops.
47:09 - I'm going to say the counter and then
I'm going to set it to itself times 2.
47:13 - So here's where we're at.
47:14 - Initialize, or set the counter to 1
initially, say it, then double it,
47:18 - then double it, then double
it, saying it along the way.
47:21 - So here we go.
47:23 - That's impressive.
47:26 - So now the sheep has counted
up to 10 to the 60th so far.
47:32 - 10 to the 100th.
47:34 - OK.
47:34 - Now, it doesn't even fit in the
speech bubble, but he's still going.
47:39 - How high can he go?
47:41 - What's the biggest number you
can count to in a computer?
47:45 - Anyone want to guess?
47:49 - Could be here a while.
47:51 - 10 to the 270th now.
47:54 - How high can you count, or rather--
47:57 - OK.
47:58 - So we gave up and just
called it infinity.
48:01 - So it turns out infinity
does have a precise value--
48:03 - 10 to the 250th or so.
48:05 - But what happens here?
48:07 - Well, because computers,
at the end of the day,
48:09 - are just storing information digitally--
but that information digitally has
48:12 - to be physically stored using
electricity, using these lower level
48:15 - switches called transistors.
48:16 - At the end of the day, my phone, my
laptop, whatever device in question
48:20 - only has a finite
amount of those things.
48:22 - I only have a finite number of fingers.
48:24 - Using unary, my old
school hashmark approach,
48:26 - I can count to five on this hand.
48:28 - Using binary, I claimed I
could count to 31 on this hand.
48:32 - But it's still finite.
48:33 - I cannot count to infinity on this
hand because I only have five fingers.
48:37 - Similarly does a computer only
have so many transistors or so
48:40 - many bytes or bits of
memory, and at some point,
48:43 - the programmer has to
think about what is he
48:45 - or she going to do when the user
wants to count so high that you
48:48 - can't physically fit it anymore.
48:51 - You have to give up like this
and say something semi accurately
48:54 - or you have to handle that
issue in some other way.
48:57 - And we'll see when we get to C that
how you handle this problem is not
49:01 - necessarily straightforward,
and indeed a lot of software
49:03 - out there does not handle this problem.
49:05 - And odds are, all of us
have programs that if you
49:07 - type big enough words or big
enough numbers into them,
49:10 - they might very well
break or crash or freeze
49:12 - because the humans, unlike MIT, did
not anticipate that that might actually
49:16 - happen and handle it.
49:17 - Well, let me go ahead and do this.
49:19 - Let me open up this program and
see if we can't read the code now.
49:22 - This is called Pet Zero and this is
a program that simulates petting.
49:28 - So if I click play and
don't touch the keyboard,
49:31 - nothing seems to be happening, but if
I now move my cursor over to the cat--
49:35 - [MEOW]
49:36 - Aw.
49:37 - It's kind of cute.
49:38 - [MEOW]
49:39 - Right now, it's more only meowing
on demand when you pet the cat.
49:42 - Why?
49:43 - Well, notice I've added
some other building blocks.
49:45 - We haven't used this one
before, but it intuitively
49:48 - probably makes pretty clear sense.
49:49 - When the green flag is clicked,
forever do the following.
49:52 - If the cat is touching the mouse
pointer-- this thing in blue
49:56 - is what we called earlier
a Boolean expression.
49:58 - It has a yes/no, a
true/false, a one/zero answer.
50:00 - And touching mouse pointer is one
of the options in the little drop
50:03 - down here if you tinker with it.
50:05 - So if the cat is touching the
mouse pointer, then and only then,
50:08 - play sound meow until done.
50:10 - So we've combined now functions
with loops with a condition.
50:14 - But why the loop?
50:16 - The cat's only meowing
once when I pet him.
50:19 - Why am I doing anything forever here?
50:24 - Someone-- yeah.
50:28 - Yeah.
50:29 - I might want to pet it again, so I
want the program to anticipate that.
50:32 - And honestly, if I omitted this
forever block and my program
50:36 - instead looked just like this--
50:39 - so let me get rid of that and this--
50:40 - and then I clicked play,
and now, I hover over him,
50:45 - why is it not working even once?
50:51 - Say it again.
50:56 - Yeah.
50:57 - So I mean, at this point,
if I can summarize,
51:00 - the computer is so damn
fast that this already
51:03 - happened by the time I moved my cursor
over to the cat, and at the moment
51:07 - I clicked play, I was
not touching the cat.
51:10 - Those blocks executed, so
to speak, top to bottom.
51:12 - That's it for the program.
51:13 - So by the time I move the cursor
over to the cat, the program is over.
51:16 - It's not listening.
51:17 - And so forever, this way I can actually
listen in perpetuity for something
51:21 - to actually happen.
51:23 - What if I want to do something
not just if something is true,
51:26 - but handle two cases?
51:27 - If or else.
51:28 - Well, let me go ahead
and open up Pet One.
51:31 - And this is another example.
51:32 - And could someone perhaps describe,
after reading this code, what
51:37 - this program is going to do instead?
51:42 - Yeah.
51:53 - Exactly.
51:54 - And let me summarize more verbally.
51:55 - So if this time, you're touching
the cat, it's going to roar instead.
51:59 - Else, it's just going to meow sweetly.
52:01 - So this time, it is meowing
perpetually once every second,
52:05 - but if you touch this particular
cat, it doesn't like it.
52:08 - So play.
52:09 - [MEOW]
52:10 - Meow.
52:11 - [MEOW]
52:12 - Meow.
52:13 - [MEOW]
52:14 - And now.
52:15 - [ROAR]
52:16 - Don't touch the cat.
52:17 - So now, we might interact
in two different ways
52:20 - by having two different
roads that you can go down.
52:22 - Well, let's actually make something
a little more interactive.
52:25 - Let me go ahead and
open another example.
52:27 - This one's called Bounce
Zero because now, we
52:29 - can start to see some design
elements from what Oscar Time was.
52:33 - Like this now it's getting
a little interesting.
52:36 - What is actually going on here?
52:38 - So let me zoom in on the blocks here.
52:40 - This block is just saying
forever move 10 steps, which
52:43 - is another block we haven't seen.
52:45 - But 10 steps is like 10 pixels.
52:46 - So move 10 pixels on the screen.
52:48 - But if you're touching the edge,
then turn around 180 degrees.
52:52 - And you can see exactly that happening.
52:54 - Scratch is turning around 180
degrees and this rotation style just
52:57 - means double back.
52:58 - Don't like loop around 180 degrees.
53:00 - So that's kind of cool.
53:02 - But this is not how humans or cats walk.
53:05 - Like what is obviously
unnatural about this?
53:10 - Yeah.
53:10 - I mean, I mean, I can't
even simulate it, right?
53:12 - Like his feet are in static
position, yet sliding back and forth
53:15 - on the screen.
53:16 - And yet, that is not what walking is.
53:18 - Like walking presumably has
some kind of movement and what?
53:20 - Well, we could just kind
of simulate it like--
53:22 - OK, I could just walk--
53:24 - walking and you can imagine taking like
really quick photographs of my legs
53:28 - or the cat's leg moving and
then just deciding this photo
53:31 - will be representative of one step.
53:33 - This photo will be
representative another.
53:35 - And you know, with just
two of those steps,
53:37 - I'd wager we could actually do
a pretty good job of simulating
53:41 - what walking looks like.
53:42 - In fact, if I go back to where we
began, this picture of Scratch,
53:46 - what if I just move his legs
ever so slightly, then go back,
53:51 - then go forward?
53:52 - And even just in my PDF, I can
simulate animation by hitting up arrow,
53:56 - down arrow, up arrow, down
arrow because it kind of
53:58 - looks like he's walking now, when
really, your human eyes are just seeing
54:01 - two different pictures again and again.
54:04 - So how can I do this?
54:05 - Well, if I go back to
Scratch, he's still walking.
54:08 - Let me go ahead and open up Bounce One,
the second version of this, and now,
54:15 - do this.
54:16 - OK.
54:18 - So how did I add this?
54:19 - There's a little purple block
that we haven't seen yet,
54:21 - but if you poke around
the categories, you'll
54:23 - see other blocks like this
next costume that just keeps
54:26 - changing the costume that he's wearing.
54:28 - It turns out Scratch exists as a
picture and his default picture
54:31 - is him not moving, but if I go up
here to top left and click costumes,
54:35 - you can actually see that
here's his one costume.
54:38 - Here's his second costume.
54:39 - And so that purple block that
says next costume, because it's
54:43 - in the forever loop, it just keeps
doing next, next, next, next, next, just
54:47 - showing one costume or the other.
54:49 - They're clearly mimicking walking.
54:52 - Now, this is not very unnatural.
54:53 - Why don't we slow him down to, say, five
steps at a time and have him go again?
54:59 - Now, this is still going pretty fast.
55:00 - Let me go ahead and say--
55:03 - we could have control.
55:05 - We could have him wait a second
after moving very dramatically.
55:11 - We could probably speed this up.
55:12 - So let's wait 1/10 of a second, 0.1.
55:15 - Or maybe let's do 0.01,
1/100 of a second.
55:18 - Now, it's getting a
little more realistic.
55:20 - But this is what animation is.
55:21 - If you've ever watched a cartoon or
a movie based on pictures like this,
55:25 - you're just tinkering with some
of these parameters, these inputs,
55:28 - in order to produce this
output by understanding
55:30 - what the fundamental representation
of these things is, which in this case
55:34 - are just pictures, again
and again and again in order
55:37 - to create that animation.
55:38 - But what about interactivity?
55:40 - Let me do this one myself.
55:41 - Let me go ahead and get rid of
this, go back to events, and say,
55:45 - when green flag clicked.
55:47 - Then, let me go ahead
and grab a forever block
55:50 - so that this keeps
going again and again.
55:52 - And then, let me go
ahead to go to motion.
55:54 - It turns out that under motion,
there's this block we haven't seen--
55:57 - point towards the mouse pointer.
55:59 - And let me go ahead
and pull this in here.
56:01 - And then, let me have it move just
like one step at a time, instead of 10.
56:06 - What is this going to do?
56:09 - What's this program do?
56:12 - Yeah.
56:12 - Say it again.
56:14 - Follow the mouse.
56:15 - Yeah.
56:15 - This is kind of like a way of
taking your cat for a walk.
56:20 - Perhaps not quite the animal we
intended, but he'll follow the cursor.
56:24 - And I can actually speed
this up a little bit.
56:27 - So let's have him move 10 steps.
56:28 - OK.
56:29 - Now, there we go.
56:32 - So now, he's moving up and down,
and so now, it's interactive.
56:34 - So you might recall that when we were
playing Oscar Time earlier and picking
56:38 - up--
56:39 - OK.
56:40 - Don't do that.
56:41 - See, that's a bug.
56:42 - He's just confused.
56:43 - He's constantly moving toward
it, but you're already--
56:45 - OK.
56:45 - So we're going to stop.
56:46 - OK.
56:47 - So now, he's following, but
that's how we might now create,
56:50 - for instance, the ability to
move those pieces of trash
56:52 - around and have them
follow the mouse cursor.
56:54 - If you think back to Oscar Time, every
time you picked up a piece of trash,
56:58 - he'd follow the cursor because there
was a forever loop and a block like this
57:01 - pointing toward the mouse pointer.
57:03 - Well, now, let's
integrate multiple ideas
57:05 - and actually have multiple scripts.
57:07 - I proposed earlier that programs
can actually have multiple threads.
57:12 - A thread is just a fancy way of saying,
in our context, multiple scripts.
57:15 - Multiple scripts in one program that
are happening essentially in parallel.
57:21 - A computer can effectively do multiple
things at a time thanks to threading,
57:24 - and more on that down the road.
57:26 - So these are more
involved, but let's see
57:27 - if we can-- let's understand
first what this program does.
57:30 - Let me go ahead and hit play.
57:31 - And this one tends to be a little loud.
57:33 - [SEA LION BARKING]
57:38 - So the sea lion is just
barking endlessly, annoyingly.
57:42 - So by reading the code, how
can I stop him from barking?
57:48 - Hit the spacebar.
57:49 - All right.
57:50 - So hit the spacebar.
57:52 - OK.
57:53 - I could just stop the
program, obviously,
57:55 - but this program is still
running, technically.
57:57 - But why did that work?
57:59 - Well, notice this on the left
hand side is the first script.
58:02 - When the green flag is clicked, set this
variable that I called muted to false.
58:06 - Could have called it x or y or
z or counter, but none of those
58:08 - really make sense, so I called it muted.
58:10 - And I set it equal to false,
which is, again, a Boolean value.
58:13 - True or false just mean yes or no.
58:16 - Forever, if the keyspace
is pressed, then do this.
58:19 - If muted is currently false,
then change muted to true.
58:24 - Else, change muted to false.
58:26 - So if muted is false, change it to true.
58:29 - If muted is true, change it to false.
58:31 - Any time the human hits the
spacebar, update that variable.
58:35 - Now, if we look at the other script,
which is also driving the sea lion,
58:39 - what is he doing?
58:40 - Forever, if muted is false.
58:43 - So if he's not muted.
58:44 - If muted is false means not muted.
58:46 - Start the sound sea lion and then
think hi, hi, hi for two seconds,
58:50 - and then wait for one more second.
58:52 - And then just repeat, repeat, repeat.
58:53 - But if I change with the
spacebar muted to true,
58:56 - he's going to say if muted
equals false, that's not so.
59:00 - I'm not going to play a sound this time.
59:01 - And so now, we have the ability to
integrate multiple scripts together
59:05 - in order to achieve a
more interactive result.
59:08 - And what about this?
59:09 - Back when I was a kid, might have
played in the summers Marco Polo.
59:15 - Super simple game.
59:16 - We played it in the pool,
for some reason, where
59:18 - one person in the pool
very safely is blindfolded,
59:20 - and then he or she yells Marco.
59:22 - And then, everyone around him
or her is supposed to yell polo.
59:25 - And then, the person
who's blindfolded is
59:27 - supposed to go chase the other
kids in the pool and tag them,
59:29 - and then they become it.
59:30 - But in other words, it's this
like signaling mechanism.
59:33 - Someone yells, Marco and
everyone else responds
59:35 - to that broadcast of the word Marco.
59:38 - Well, it turns out we can simulate
this with these two puppets.
59:40 - This guy here-- notice that I've
highlighted the orange puppet
59:43 - because there's a second
blue puppet there.
59:45 - Separate sprites.
59:46 - And these are just photographs
we uploaded to the game.
59:49 - Forever, if the key space is pressed,
so if the spacebar is pressed,
59:53 - say Marco for two seconds
and then broadcast an event.
59:57 - Meanwhile, the blue puppet
here has a super simple block,
60:02 - but it's fundamentally different
from the ones we've seen.
60:04 - He's not starting when
the green flag is clicked.
60:07 - He is starting only when
he receives an event.
60:10 - So it turns out that sprites
and Scratch can't hear or see
60:13 - what the other one is saying
in those speech bubbles.
60:15 - You have to use a
fancier technique, which
60:17 - is the special block
called broadcast, which
60:19 - is like passing a note digitally
from one sprite to another
60:23 - that the other one can read
or receive, so to speak.
60:26 - So only when he receives
this event, so to speak,
60:28 - does he say polo for two seconds.
60:30 - And again, the orange puppet
sends that secret message
60:34 - just using this other puzzle piece.
60:35 - Broadcast an event, like passing a note
that the human doesn't actually see.
60:40 - So if I now hit the green flag and
hit the spacebar, orange yells Marco.
60:45 - Blue guy yells polo in response.
60:48 - But those aren't timed together.
60:50 - Rather, the blue guy is hearing
with the orange one has said,
60:53 - thereby allowing multiple sprites
to actually intercommunicate.
60:58 - So how did we get here?
60:59 - Well, recall that we had all of
these building blocks a moment ago.
61:02 - First, we started out with
just functions and conditions
61:05 - and Boolean expressions and loops.
61:06 - We've now added to that the
ability to store information
61:09 - in variables and threads to do multiple
things at once, and then, if you do
61:12 - have multiple things
happening, events, where
61:14 - they can enter communicate somehow.
61:17 - Yet another building block.
61:18 - So if we now take a
step back and consider
61:21 - how we can make functions of
our own, we have the final piece
61:26 - of the puzzle, so to speak.
61:27 - Let me go ahead and do this.
61:29 - Let me go ahead and create a simple
program with, when green flag clipped,
61:33 - that simply simulates
coughing for a cat.
61:35 - So this cat is going to say not
hello, but cough for one second.
61:40 - And then he's going to go
ahead and wait for one second.
61:44 - And then I'm going to go ahead
and copy paste, as I did before--
61:48 - this is one of those do as I say, not as
I do-- to implement this program here,
61:52 - where he coughs three times.
61:54 - We already know, though, from
earlier that this is not good design.
61:57 - Why?
61:59 - You're repeating yourself.
62:00 - Don't repeat yourself.
62:02 - DRY is an acronym, actually.
62:03 - Don't repeat yourself
because you're doing
62:05 - three times as many times something
that you only really need to do once.
62:09 - The solution before, of course,
was just use a loop of some sort.
62:12 - So let me actually take that out.
62:14 - Let me use a repeat
block, change 10 to three,
62:18 - and then just use two of these blocks.
62:19 - And notice already, the program
is so much more compact.
62:22 - And now, if I want to change the three
to a 30 or to a 10 or any number,
62:27 - I just change one simple value.
62:28 - I don't have to rewrite or
copy paste or delete things.
62:31 - I can update the program
much more readily,
62:33 - and now, the same thing is going to
happen with just cough, cough, cough.
62:39 - But it turns out that it would be nice
to henceforth abstract away from this,
62:43 - right?
62:43 - I just want any program I
write to know how to cough.
62:46 - And coughing is really just
saying something, perhaps
62:49 - some number of times.
62:50 - But it turns out we can
abstract this away in code.
62:53 - Let me go down to my
blocks here and this allows
62:55 - me to click this button-- make a block.
62:57 - It allows me to make my own function.
62:59 - I get this dialog window here.
63:01 - And I'm just going to
call this block cough.
63:03 - I'm going to go ahead and click OK.
63:05 - And now, I have this new pink block that
itself can have blocks underneath it.
63:09 - And you know what I'm going to do?
63:10 - I'm going to go ahead and do this.
63:12 - I'm going to go ahead and
say cough under there.
63:16 - And now, notice on the left, I now
have access to this new pink piece.
63:20 - I can now put this in here.
63:22 - So now, notice even though, yes,
this is how coughing is implemented
63:26 - on the left hand side here, next
time, when I write a program,
63:30 - I just want to call cough.
63:31 - And I don't care about those lower
level implementation details.
63:34 - I don't care about the
party or any of that.
63:36 - I just want this to be an abstraction.
63:38 - But I could do better
than this wouldn't it
63:40 - be nice if instead of just
repeating cough three times,
63:43 - what if I made that a feature of cough?
63:45 - So let me do this.
63:46 - I can go ahead and right click on
this pink piece and I can edit it.
63:51 - That brings up that
same window from before.
63:52 - And notice this.
63:53 - Add an input.
63:55 - So when I make a custom block, I can
actually make pretty fancy blocks
63:58 - just like the ones MIT
gives us with the software,
64:01 - and now, I can type in something like n.
64:03 - And if I add a label just to make it
more descriptive, I can just say times.
64:07 - So now, I've made a
special custom puzzle
64:09 - piece that says cough some number
of times, where n for number
64:12 - is just the go to variable
that programmers tend to use.
64:16 - So now, I can actually move this
repeat block into cough itself,
64:24 - but rather than hard
code 3, notice this.
64:26 - I can steal that variable and now say
cough this many times by repeating
64:31 - saying this again and again and again.
64:34 - And now, when I cough in my actual
program, I just type in three here.
64:39 - So I have this beautiful
abstraction now, so to speak.
64:42 - Cough this many times and I
and no one else in the world
64:45 - never again needs to care about what
it means to cough because we've already
64:48 - implemented that before.
64:50 - And so just as MIT has given
us so much functionality
64:52 - that we ourselves don't
have to think about, so can
64:54 - I now make functionality that
I don't have to think about.
64:57 - And as we progress to higher level
languages like C and JavaScript
65:00 - and Python, we're going to
continue this process, sometimes
65:02 - solving problems ourselves by
making our own custom puzzle pieces,
65:06 - but very often using
things called libraries,
65:08 - code that other humans wrote before us
that's just useful to get the job done,
65:13 - just as Scratch has done
here in part for us.
65:16 - Let me go ahead, then,
and bring all of this
65:19 - together by opening
this other example here.
65:23 - Let me go ahead and open up this one,
which isn't something we've seen,
65:27 - but it's kind of an interactive game
like this made by a former student.
65:31 - [MUSIC PLAYING]
65:35 - Should we have an apple?
65:36 - Yes.
65:38 - A little animation.
65:44 - OK.
65:44 - That didn't end well.
65:46 - Let's try again.
65:47 - Play again.
65:49 - And notice the say block is happening.
65:51 - There's some kind of ask block.
65:54 - The student was checking if
the human typed in yes or no.
65:56 - Let's type no this time.
65:57 - No apple.
65:58 - Ooh.
65:59 - Cupcake.
65:59 - OK.
66:00 - Yes.
66:00 - Enter.
66:06 - OK.
66:08 - Don't do that.
66:09 - One more life.
66:10 - Here we go.
66:10 - [MUSIC PLAYING]
66:13 - OK.
66:13 - No apple.
66:15 - No cupcake.
66:18 - Little variable.
66:21 - [SCREAMING]
66:26 - [LAUGHTER]
66:28 - OK.
66:29 - So I won the game.
66:32 - In our final moments here, let me
go ahead and open one final example.
66:37 - As you know, CS50 is offered not only
at Harvard, but at Yale, as well,
66:41 - so it seems fitting to
perhaps end on a note that
66:43 - pits one campus perhaps against
the other by way of another game
66:47 - that a former student wrote
called Ivy's Hardest Game.
66:50 - But for this, I think we need one final
volunteer who's company coming up.
66:53 - OK.
66:53 - First hand.
66:54 - Right there.
66:55 - Come on down.
66:56 - So in Ivy's Hardest Game, it's
a game played with the keyboard.
67:00 - And even though it might look a
little overwhelming at first glance,
67:02 - just like Oscar Time did and just
like the gingerbread animation might,
67:06 - realize that if you decompose it in
just your mind's eye thinking about what
67:09 - those individual building
blocks are, you can probably
67:11 - guess what the puzzle pieces are.
67:13 - Hi.
67:13 - What's your name?
67:13 - ANDREA: Hi.
67:14 - I'm Andrea.
67:14 - DAVID MALAN: Andrea.
67:14 - David.
67:15 - Nice to meet you.
67:16 - Here is Ivy's Hardest Game.
67:20 - Pits you against all of the Ivies here.
67:22 - And then right after this will we
adjourn for cupcakes in the transept.
67:26 - Ready?
67:28 - [MUSIC PLAYING]
67:31 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
67:33 - MC HAMMER: (SINGING)
You can't touch this.
67:36 - You can't touch this.
67:42 - DAVID MALAN: Nice.
67:43 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
67:44 - MC HAMMER: (SINGING)
You can't touch this.
67:46 - My, my, my, my.
67:48 - Music hits you so hard.
67:50 - Makes me say, oh my lord.
67:52 - Thank you for blessing me with a
mind to rhyme and two hype feet.
67:55 - It feels good when you know you're down.
67:57 - A super dope homeboy from the Oaktown.
67:59 - And I'm known as such.
68:01 - And this is the beat you can't touch.
68:04 - I told you, homeboy,
you can't touch this.
68:07 - Yeah.
68:07 - That's how we're living and
you know you can't touch this.
68:11 - Look in my eyes.
68:12 - Man, you can't touch this.
68:14 - [APPLAUSE]
68:15 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
68:17 - (SINGING) Fresh new kicks and pants.
68:19 - You got it like that and now
you know you want to dance.
68:21 - So move out of your
seat and get a fly girl
68:23 - and catch this beat while it's rolling.
68:25 - Hold on.
68:26 - Pump a little bit and let me
know it's going on like that.
68:29 - Like that.
68:30 - Cold on a mission so pull on back.
68:31 - Let them know that you're too much
and this is the beat you can't touch.
68:36 - Yo, I told you, you can't touch this.
68:40 - Why you standing there, man?
68:42 - You can't touch this.
68:43 - Yo, sound the bells.
68:44 - School is in, sucker.
68:45 - You can't touch this.
68:46 - Give me a song or rhythm.
68:48 - Making them sweat.
68:48 - That's what I'm giving them.
68:50 - Now they know when you
talk about the Hammer,
68:52 - you talking about a show
that's hyped and tight.
68:55 - Singers are sweating so
pass them a wipe or a tape
68:58 - to learn what it's going to take
in the 90s to burn the charts.
69:01 - DAVID MALAN: Second to last level.
69:02 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
69:03 - MC HAMMER: (SINGING) Either work
hard or you might as well quit.
69:05 - That's word because you
know you can't touch this.
69:10 - You can't touch this.
69:14 - Break it down.
69:28 - Stop.
69:28 - Hammer time.
69:29 - Go with the flow, it is said.
69:31 - If you can't groove to this,
then you probably are dead.
69:33 - So wave your hands in the air.
69:34 - Bust a few moves.
69:35 - Run your fingers through your hair.
69:37 - This is it for a winner.
69:38 - Dance to this and you're
going to get thinner.
69:40 - Move.
69:41 - Slide your rump.
69:42 - Just for a minute, let's
all do the bump, bump, bump.
69:45 - Yeah.
69:46 - You can't touch this.
69:49 - Look, man.
69:50 - You can't touch this.
69:52 - You better get hype,
boy, because you know--
69:54 - [CROWD YELLING]
69:56 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
69:57 - (SINGING) Break it down.
70:00 - DAVID MALAN: [INAUDIBLE]
70:04 - ANDREA: [INAUDIBLE]
70:05 - DAVID MALAN: No.
70:05 - It's OK.
70:06 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
70:09 - One more life.
70:10 - [MUSIC - MC HAMMER, "U CAN'T TOUCH
THIS"]
70:11 - MC HAMMER: (SINGING) Stop.
70:12 - Hammer time.
70:18 - DAVID MALAN: All right.
70:19 - A round of applause for
Andrea, if we could.
70:21 - [APPLAUSE]
70:23 - OK.
70:25 - That's it for CS50.
70:27 - See the website for details.
70:28 - We'll see you for cake in the transept.
70:31 - Welcome aboard.