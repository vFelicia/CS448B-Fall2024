00:00 - learn JavaScript this course is designed
00:02 - to take beginners through the basics of
00:04 - JavaScript with clear explanations and
00:07 - quiz sections while we already have a
00:09 - lot of JavaScript courses on our Channel
00:12 - Stephen is an excellent teacher so we
00:15 - wanted to bring this course to our
00:16 - community welcome to JavaScript for
00:18 - beginners in this course you're going to
00:20 - dive into the essentials of the most
00:21 - widely used programming language in the
00:23 - world design with beginners in mind this
00:24 - course is segmented into seven
00:26 - comprehensive sections after finishing
00:28 - this course you have the skills needed
00:29 - to tackle Advanced courses and move
00:31 - closer to a career in Tech section one
00:33 - We Begin by exploring what JavaScript is
00:35 - and why it's a great first programming
00:36 - language to learn I'll then guide you
00:37 - through setting up your development
00:38 - environment and take the first steps
00:40 - into writing software in section two
00:41 - you'll learn about JavaScript variables
00:43 - the fundamental building blocks of
00:44 - storing and structuring data section
00:46 - three introduces you to the symbols and
00:48 - operators essential for performing
00:49 - calculations modifying data and
00:51 - executing logical operations dive into
00:53 - the power of programming as we cover
00:54 - control flow to learn how to direct your
00:56 - programs using loops and conditional
00:58 - statements making your code more dynamic
01:00 - and interactive objects are crucial in
01:01 - objectoriented programming for creating
01:03 - modern applications this section
01:04 - demystifies JavaScript objects and their
01:06 - role in developing applications learn
01:08 - about arrays a pivotal data structure in
01:10 - JavaScript will explore commonly used
01:11 - methods to manipulate and utilize arrays
01:13 - effectively we'll wrap up with functions
01:15 - enabling you to write clean reusable
01:16 - code that can simplify complex tasks
01:18 - start your coding Journey with
01:19 - JavaScript for beginners on Steven
01:21 - ccraft what is Javascript JavaScript
01:23 - stands as the most popular programming
01:25 - language in the world isessential for
01:26 - frontend web development it Powers the
01:28 - interactivity on websites but it's c
01:30 - abilities extend far beyond JavaScript
01:31 - can also craft backend Services desktop
01:33 - apps and even mobile applications let's
01:35 - break down a modern website it's built
01:37 - using HTML CSS and JavaScript HTML lays
01:40 - the foundation structuring the web page
01:42 - CSS steps in to style and design the
01:44 - structure adding colors layouts and
01:46 - fonts then JavaScript brings it all to
01:47 - life it makes websites interactive in
01:49 - real time like when you like a post or
01:51 - scroll through a feed all without
01:52 - reloading the page a common
01:54 - misconception is that JavaScript and
01:55 - Java are related in reality they're very
01:57 - different languages and serve distinct
01:59 - purposes Java often Powers large
02:01 - Enterprise backends while JavaScript is
02:03 - the go-to for front-end Development
02:05 - Across all companies this makes
02:06 - JavaScript and essential skill for web
02:08 - developers the core programming
02:09 - principles you learn here aren't just
02:11 - limited to JavaScript they're
02:12 - transferable to other languages too
02:13 - despite javascript's unique aspects it's
02:15 - an excellent starting point for
02:16 - beginners it's Dynamic powerful yet
02:18 - easier to grasp compared to other more
02:20 - verose languages like C or Java by
02:22 - mastering JavaScript you're not only
02:24 - learning an in demand programming
02:25 - language but also grasping the
02:26 - foundational coding Concepts applicable
02:28 - across software development
02:29 - [Music]
02:32 - to start programming JavaScript there
02:33 - are two essential tools you need to
02:35 - install node.js and visual studio code
02:37 - so what is no. JS this is a powerful
02:39 - runtime environment that lets you run
02:40 - JavaScript outside the confines of a web
02:42 - browser it's what enables you to build
02:44 - and run JavaScript applications on your
02:46 - computer including serers side projects
02:47 - while you could just run JavaScript in
02:49 - your browser for this course we will be
02:50 - using node.js to execute our programs
02:52 - the second tool is Visual Studio code
02:53 - otherwise known as vs code developed by
02:55 - Microsoft this is an integrated
02:56 - development environment or IDE for short
02:58 - and this is where you'll spend most your
02:59 - your time writing testing debugging and
03:01 - running your code it's a versatile
03:03 - desktop application used by developers
03:05 - worldwide and we'll be using it
03:06 - throughout this course both nodejs and
03:08 - visual studio are free and easy to
03:09 - install installing node.js Begin by
03:11 - opening your browser and heading to
03:12 - nodejs.org once you're on the side click
03:14 - to download node.js LTS stands for
03:16 - long-term support downloading this
03:18 - version is recommended for most users
03:19 - because it's the most stable and well
03:21 - supported version of node.js once
03:23 - downloaded open the installer and follow
03:24 - the onscreen instructions the default
03:26 - settings are suitable for most users so
03:27 - you can proceed with them unless you
03:28 - have specific preferences installing
03:30 - Visual Studio code next we'll install
03:32 - our IDE navigate to code. visual
03:34 - studio.com in your web browser click the
03:36 - download button for your operating
03:37 - system vs code is available for Windows
03:39 - Mac and Linux after downloading run the
03:40 - installer like with node.js the default
03:42 - installation options will work perfectly
03:44 - for our purposes so now once you have
03:46 - installed both node.js and visual studio
03:48 - code click to open up vs code after you
03:50 - click it you will see the welcome page
03:51 - then open up finder or File Explorer for
03:53 - your windows and create a new folder now
03:55 - this will be the folder where we place
03:56 - our code so I'll just name it project
03:59 - now the name of the folder doesn't
04:00 - matter then I can click and drag it into
04:03 - vs code this will open up the project
04:05 - now to add a new file to our project I
04:07 - can click on this icon and I can name it
04:09 - code. JS so the name of this file
04:12 - doesn't matter but the file extension
04:14 - does so now we can write our first line
04:15 - of code and I'll say
04:18 - console.log then in single quotes I'll
04:20 - say hello world and then I'll end it
04:23 - with the semi callon notice as I'm
04:25 - typing this file has not been saved yet
04:27 - and so I see a circle indicating that I
04:28 - have unsaved changes so to save it I can
04:30 - do command s or on Windows it would be
04:32 - contrs so now if I want to actually
04:34 - execute this file I can do file
04:37 - appearance and then
04:39 - panel to open up the integrated terminal
04:41 - in vs code now there's also a shortcut I
04:43 - can do control and back tick so if you
04:45 - don't use the back tick character often
04:46 - it's located on the left hand side of
04:48 - your keyboard above the tab key so I can
04:50 - do control and back tick to toggle this
04:52 - open so I'll be using node to execute
04:54 - this program so I'll type node and then
04:57 - the name of our file which is code. Js
05:00 - so here we see this value hello world is
05:03 - logged to the console so I'll close this
05:05 - now vs code offers a lot of features and
05:07 - a lot of ways to customize it before
05:09 - this course we'll just be covering the
05:10 - basics that you need to get started so
05:12 - on the left hand side is the activity
05:13 - bar where we see a list of icons the
05:15 - topmost icon is the folder icon and we
05:17 - can use it to toggle our project to see
05:19 - the folders and files within it next is
05:21 - the search icon and we can use this to
05:23 - search find and replace text so for
05:25 - example let's say if I do hello enter we
05:28 - see that this text is found in our code.
05:31 - JS file so close that the next one is
05:33 - our source code icon and this is used to
05:36 - keep track of the changes in our project
05:38 - as well as collaborate with other
05:39 - developers using get ver control next is
05:41 - the run and debug icon you would use
05:43 - this when setting break points in your
05:44 - code and debugging it if there are
05:45 - errors next is the extensions icon this
05:47 - gives you access to the extensions
05:49 - Marketplace so this enables you to
05:51 - install additional features to VSS code
05:53 - to improve your productivity and help
05:54 - you customize VSS code to your needs now
05:56 - the icons on the bottom is for your
05:57 - account and to adjust your settings now
05:59 - on the bottom of the screen is the
06:01 - status bar here in Blue on the left side
06:03 - you will see any errors or warnings in
06:05 - your code and on the right side I see
06:06 - the line number that I'm on for my
06:08 - current file and I also see the
06:09 - programming language being used so let's
06:11 - say if I wanted to add another file to
06:13 - my project rather than always having to
06:14 - click on this icon I can use a keyboard
06:16 - shortcut of command and N or control and
06:18 - n on windows open up a new file and on
06:20 - the bottom right we see that this is
06:21 - identified as plain text so now if I
06:23 - want to save this file as a Javascript
06:25 - file I can do command s and I can name
06:27 - it as second program
06:30 - .js and now on the bottom right we see
06:32 - that VSS code can identify that this is
06:34 - a Javascript file the next thing I want
06:36 - to cover is the command pallet you can
06:37 - access the command pallet by going to
06:39 - view and then command pallet now another
06:41 - way to do that is with the keyboard
06:42 - shortcut of command shift and P or it'll
06:45 - be control shift and P on Windows now
06:47 - the command pallet is very important as
06:48 - it is the control center for all
06:50 - commands in vs code from here we can
06:51 - also adjust the color thing that we use
06:53 - so I click on color theme and as I
06:55 - scroll up and down we can see different
06:58 - color themes for my code editor you can
07:00 - also access additional themes by going
07:03 - to the very top and clicking on browse
07:04 - additional color
07:05 - themes allowing you to search through
07:07 - different options now for this course
07:10 - I'll just stick to the standard Visual
07:11 - Studio One now to make the text larger
07:13 - you can do command and plus or control
07:15 - and plus on Windows and also command
07:17 - minus or control minus in order to make
07:19 - the text smaller so this is a quick
07:20 - overview of VSS code teaching you the
07:22 - basics that you need for this course
07:24 - before we get started if you're
07:25 - interested in supporting my courses and
07:27 - projects you can follow me on my new
07:28 - YouTube channel and Instagram at Steven
07:30 - codecraft and if you're looking to
07:31 - enhance your health and fitness routine
07:32 - check out my workout and meal planning
07:33 - app at fitfuel planner.com the app
07:35 - offers over 100 recipes workout plans
07:38 - meal plans and a grocery list feature
07:39 - it's designed to make tracking your
07:41 - calories and macronutrients
07:42 - straightforward and stressfree I
07:43 - appreciate your support and I'll see you
07:44 - in the next
07:46 - section with the vs code open let's
07:48 - start our first program we will start by
07:50 - creating a new file by clicking the icon
07:52 - on the left Explorer and we can name
07:53 - this file whatever we want I'm going to
07:55 - name it variables and I'm use the file
07:57 - extension of JS for a Javas file so in
08:00 - JavaScript our applications need to work
08:01 - with information such as an online shop
08:04 - where the information might be the
08:05 - product sold or info about the user
08:07 - variables are used to store this
08:08 - information in programming we would
08:10 - refer to this information as data in our
08:11 - applications we create read update and
08:14 - delete data we need a way to keep data
08:16 - in memory so that we can perform these
08:18 - operations on it and to do that we use
08:19 - variables a variable is a name storage
08:21 - for data so variable store data
08:23 - temporarily in a computer's memory and
08:25 - under the hood it will be stored in a
08:26 - memory location and we can access that
08:28 - data stored by the variable name then we
08:29 - give it so to declare a variable the old
08:31 - way of doing it was using the VAR
08:32 - keyword I'll show you an example of that
08:34 - we use the VAR keyword now we name the
08:37 - variable I'll use the name first name
08:41 - and then I will assign it to data so I
08:44 - assign it to the word being my first
08:46 - name and I use single quotes in order to
08:48 - tell JavaScript that this is a string a
08:50 - string of characters so programmers we
08:52 - refer to words as strings we could also
08:55 - use double quotes and both work fine in
08:57 - JavaScript Now using the VAR keyword is
09:00 - the old way of doing it now the modern
09:01 - way of doing it is to use the let
09:03 - keyword in order to initialize this
09:05 - value I'll talk about the differences of
09:07 - these conventions later in the course
09:09 - after you're comfortable with the basics
09:10 - so this statement here that I
09:12 - highlighted is known as initialization
09:14 - know that we could also declare this
09:15 - variable and assign it on two different
09:17 - lines I'll show you an example of that
09:20 - and then we do first name and assign to
09:23 - our value so this first statement which
09:25 - I have highlighted is the Declaration
09:27 - I'm declaring a variable then I'm am
09:29 - assigning it on the second line note
09:31 - that on the second line I did not have
09:33 - to use the let keyword again I only have
09:34 - to do it once when I first create it not
09:37 - that the single equal sign is known as
09:38 - the assignment operator and that's the
09:40 - operator I use to connect data to the
09:42 - variable I have declared know that there
09:44 - are some reserved words that I cannot
09:46 - use as my variable name I'll show you an
09:48 - example of that so we use our let
09:49 - keyword to create our variable and I'm
09:51 - going to name it function which is a
09:53 - reserved keyword then I will assign it
09:54 - to a string saying test so here VSS code
09:57 - indicates with these underlines this
09:59 - variable name is not allowed that's
10:00 - another benefit of using vs code because
10:02 - we can catch errors early on in our
10:04 - development so let me delete this so
10:05 - note when I declare this variable right
10:09 - just declaring it again I use camel case
10:11 - notation for my variable name and this
10:13 - helps with readability and it's a common
10:14 - convention in JavaScript so what you do
10:16 - is the first word that you use for your
10:19 - variable you will have that in all
10:20 - lowercase and then any proceeding words
10:22 - you will start the first letter
10:23 - uppercase and the rest of that word in
10:25 - lower case and this allows you to have
10:27 - descriptive variable names that are easy
10:29 - to to read as opposed to if I were to do
10:30 - something like this which is just less
10:32 - readable okay we can also declare
10:33 - multiple variables on the same line so
10:35 - here if I instead of doing the semicolon
10:37 - I use last
10:40 - name and assign it to my last name and
10:44 - end the statement with a semicolon
10:45 - semicolons tell JavaScript that this is
10:47 - the end of the line but this becomes
10:48 - hard to read especially when working
10:50 - with larger programs so we prefer to put
10:52 - every initialization on its own line so
10:54 - a real life analogy let's say we have
10:55 - let message and we sign up to the string
10:58 - hello how does look like visually so to
11:00 - grasp this visually consider this first
11:02 - screenshot so you can think of our
11:04 - variable as a box that's the amount of
11:06 - memory that JavaScript has allocated for
11:08 - us to grasp this concept visually
11:10 - consider this diagram we declare a
11:11 - variable which we imagine as a box for
11:13 - data and this box has a sticker with the
11:15 - word message on it which is the name of
11:16 - our variable then we store the value
11:18 - hello in it we could also change the
11:20 - variable as many times as we like let's
11:21 - say if I do message and I assign it to
11:24 - world ending with the semicolon well
11:25 - visually to grasp this so the previous
11:27 - string which I had as hello will be Gage
11:29 - collected by JavaScript and that new
11:31 - string that we assigned it to will be
11:33 - stored in the memory location so in
11:34 - order to run this program and to log it
11:36 - to the console we can use a built-in
11:38 - function in JavaScript known as
11:39 - console.log I'll do console.log and I'll
11:42 - pass in the name of my variable message
11:44 - ending it with a semicolon now to
11:45 - actually run this program I'll open up
11:47 - the panel you can open up the panel in
11:49 - vs code by doing control and back tick
11:51 - as the keyboard shortcut or I close that
11:54 - you can go view appearance and then
11:56 - panel to open it up so here in order to
11:59 - view what files I have in my project I
12:01 - can do LS and that's list out the files
12:03 - in my folder also known as my directory
12:05 - and here I see variables. JS which is
12:08 - the file I want to execute I'm going to
12:10 - execute this with node so I type in node
12:14 - variables.
12:16 - js and here I see the value of my
12:18 - variable logged out to the console let's
12:20 - take a short quiz to test what you
12:21 - learned this part is essential to ensure
12:23 - that you retain the information what is
12:25 - a variable
12:30 - a variable is a named storage for data
12:33 - how do you declare a
12:36 - variable you declare a variable with the
12:38 - let
12:40 - keyword in JavaScript we use the let
12:43 - keyword for variables which hold a value
12:45 - that can be changed to declare a
12:46 - variable which has a constant value
12:48 - which can't be changed we would use the
12:49 - const keyword an example of this would
12:51 - be const I name it Christmas 2024 and I
12:55 - assign that to the string say 12.25 2024
12:59 - ending it with a semicolon so when a
13:00 - programmer ass sure that a variable will
13:02 - never change they can declare it with
13:03 - const to guarantee and communicate that
13:05 - fact to everyone here if I log it out
13:07 - console.log Christmas 2024 opening up
13:10 - the panel I can say node variables. js
13:15 - and here I see that output it now with
13:16 - the cons keyword if I were to try to
13:18 - reassign it and un log it out JavaScript
13:20 - would display an error so let's say
13:22 - before outputting it let's say if I did
13:24 - Christmas 2024 and I assign that to
13:28 - 12262 24 when I try running that it will
13:31 - display an error so if I go up and run
13:33 - it so here it is an error saying that I
13:35 - cannot assign to a constant variable so
13:38 - another convention I'm doing constants
13:40 - is to use all uppercase Den notate that
13:43 - this is a constant value here I will use
13:45 - all values where each word is all
13:46 - uppercase and separated by underscore
13:48 - rather than using camel case now the use
13:50 - of this is not required and it depends
13:52 - on the convention of your team one thing
13:53 - I want you to take away from the first
13:54 - two videos of the section is that I have
13:56 - been using descriptive names for my
13:58 - variables this helps me write code that
13:59 - other people can easily understand now I
14:01 - could have named this variable as const
14:02 - n equals green but other programmers do
14:04 - not have context of what I initialize
14:06 - this constant value so always use
14:07 - descriptive names for your
14:09 - variables what is the purpose of a
14:15 - constant the purpose of a constant is to
14:17 - Define data that cannot be changed what
14:19 - is the difference between a constant and
14:21 - a
14:23 - variable a variable defines data that
14:25 - can be changed and reassigned later in
14:27 - the program whereas a constant defines
14:29 - data that cannot be
14:32 - changed in JavaScript the data that we
14:35 - use can belong to either two categories
14:37 - primitive value types and reference
14:38 - types there are eight basic data types
14:40 - in JavaScript primitive types refer to
14:42 - simple fundamental data examples include
14:44 - string number big int Boolean undefined
14:50 - null and symbol the reference data type
14:53 - is the object data type don't worry
14:55 - about memorizing this right now just
14:56 - focus on understanding and it will
14:57 - become second nature over time so let me
14:59 - show an example of each of these so I
15:01 - can initialize strings three different
15:03 - ways I can say let favorite
15:06 - fruit I'll sign it to strawberries using
15:09 - single
15:10 - quotes then I'll create a string and I
15:13 - initialize it with double quotes sign
15:16 - that to
15:18 - chocolate then I can use back ticks
15:20 - which will create a template literal so
15:21 - I can say let favorite programming
15:25 - language assign to JavaScript
15:29 - now these are the three different ways
15:31 - that we can initialize a string data
15:32 - type now we can cover numbers let's say
15:34 - if I do let number of donuts I'm that to
15:39 - 12 now numbers Encompass both integer
15:41 - values and decimal values so if I say
15:45 - let Pi then I can sign that to
15:49 - 3.14 let's say if I do let very large
15:54 - number type out a large number and then
15:57 - end it with the character n not a shown
16:00 - example of a Boolean data type which
16:02 - stores the value of either true or false
16:04 - I can say let loves coding assign that
16:07 - to the value of true now the undefined
16:10 - data type this means that a value is not
16:12 - assigned to a variable so if I just
16:14 - declare a variable let's say if I do let
16:16 - favorite
16:17 - color then by default it will be
16:19 - assigned the value of undefined so if I
16:22 - console lck that I'll see the value of
16:24 - undefined favorite color opening up the
16:27 - panel and then running it up arrow and
16:30 - run here I see its value is undefined
16:33 - now for the data type null we use null
16:35 - and we want to explicitly clear the
16:37 - value of a variable so if I do favorite
16:40 - fruit I can assign that to null we also
16:43 - have symbols which are used to create
16:45 - unique identifiers and objects so if I
16:47 - can do cons and I'll say unique key for
16:50 - example assign that to symbol and then
16:54 - open and closing parentheses now the
16:56 - last data type is a reference data type
16:58 - that is an object so an object is known
17:01 - as a reference type primitive values can
17:03 - only contain a single thing whether it
17:05 - be a number or a string objects can have
17:07 - a more complex structure and they hold
17:09 - key value pairs this enables us to store
17:11 - more than one variable all in one so for
17:13 - example I can say let course assign that
17:17 - to opening and closing curly braces so
17:19 - this defines an object literal and I can
17:22 - define a key so I'll say name set that
17:25 - to JavaScript for beginners
17:29 - comma and then I can Define another key
17:33 - ours with the value of three and I can
17:36 - end it with a semicolon so objects
17:38 - enable me to create more complex
17:40 - structures now we can use the type of
17:42 - operator in JavaScript in order to
17:44 - return the type of the operand and the
17:46 - operand could be either a variable or a
17:49 - value so if I open up the panel if I
17:51 - just type node so when we use the type
17:54 - of operator then it will return the data
17:56 - type as a string so if I do
18:00 - undefine here we see undefined returned
18:02 - as a string now if I do type of zero we
18:06 - see that data type is a number now we'll
18:08 - try for a big int if I do type of 10n we
18:13 - get big int let have I do type of Taco
18:18 - we'll get a string let's do type of
18:23 - assemble now for the last example I'll
18:25 - say type of null so the result of type
18:28 - of for null is an object note that null
18:30 - isn't actually an object the type of
18:32 - output for null being an object is from
18:34 - the early days of JavaScript and it has
18:35 - remained for backwards compatibility so
18:38 - to quickly recap there are eight basic
18:39 - data types in JavaScript of those eight
18:42 - seven of them are primma data types
18:44 - which include number big int string
18:47 - Boolean null undefined and symbol and
18:51 - for nonpr data types we have the object
18:53 - data type which is a more complex data
18:55 - structure
19:00 - what are primitive data types in
19:06 - JavaScript primitive data types refer to
19:09 - fundamental values these values can only
19:11 - contain a single thing whether it be a
19:13 - string number or Boolean what are the
19:16 - seven primitive data types in
19:22 - JavaScript the seven primitive data
19:24 - types are string number Boolean big in
19:27 - undefined null and
19:31 - symbol programming languages that allow
19:34 - you to initialize a variable to a data
19:36 - type and then reassign it to a different
19:37 - data type are known as dynamically typed
19:40 - in other languages such as C or Java you
19:42 - specify the data type that you want to
19:44 - use and cannot reassign it to a
19:46 - different data type JavaScript is
19:47 - dynamically typed so a variable is not
19:49 - bound to only being assigned to one type
19:51 - so to show an example of this fin
19:53 - initialize let first name and assign it
19:55 - to the string of Steven then I can
19:57 - reassign it to a number
19:59 - say if I assign it to the value of 100
20:02 - then I can reassign it
20:03 - to a Boolean so here we see that we can
20:06 - assign any data type value to our
20:08 - variable since it is dynamic the type of
20:10 - our variable can change at runtime here
20:12 - if I were to console Lo the types and do
20:15 - console.log type of first
20:18 - name I'll add some spacing and I'll copy
20:21 - and paste some
20:22 - here so output
20:26 - it node variables .js so here I see the
20:30 - different data types based on what I
20:32 - assigned it to be now in a professional
20:34 - setting you can see how this could
20:35 - potentially cause bugs and our
20:36 - application if someone were to assign it
20:38 - to a data type that doesn't make sense
20:40 - so we need to be careful of that and in
20:41 - professional settings you would often
20:43 - use a version of JavaScript known as
20:45 - typescript which is a statically typed
20:47 - version of JavaScript with enhanced
20:50 - [Music]
20:52 - features what is dynamic typing in
20:54 - JavaScript
21:03 - Dynamic typing refers to the ability to
21:05 - initialize a variable to one data type
21:06 - for example a string and to assign it to
21:08 - any other data type whether it be a
21:10 - number a Boolean or an
21:13 - object objects are reference types in
21:16 - JavaScript objects are used to represent
21:18 - an object or noun in real life it
21:20 - contains State and behavior enabling us
21:22 - to group together related values and
21:24 - make our code cleaner object literal
21:25 - syntax uses curly braces so if I
21:27 - initialize an object I'll say let course
21:30 - assign to curly braces then I can
21:33 - specify a key I'll name it name with the
21:36 - value of
21:37 - JavaScript for
21:40 - beginners so name is referred to as a
21:43 - key and this string is referred to as a
21:45 - value now I can add more key value pairs
21:48 - by adding a comma and then specify ours
21:50 - and then I'll say three end it with the
21:52 - semicolon now we can console log this
21:54 - object
21:55 - console.log
21:57 - course opening up the panel node
22:00 - variables. js and here this outputs the
22:03 - object so the key value pair when
22:05 - considered together is referred to as a
22:07 - property of the object and all the keys
22:10 - are represented internally as a string
22:13 - so in order to access these properties
22:14 - we can do so through two different
22:15 - notations the most common notation is
22:17 - dot notation so after course I can say
22:20 - dot name and this will output the
22:22 - associated value for this key so if I
22:25 - run it again here I see outputed the
22:27 - associated value we could also reassign
22:29 - a property if I say course. name and
22:32 - assign to
22:33 - JavaScript fundamentals ending it with
22:36 - the semicolon now if I copy this and
22:38 - paste again I see that it has updated
22:41 - that value clear the panel and then run
22:43 - again so here I see the associated value
22:46 - has been changed now we can also access
22:48 - these properties using bracket notation
22:50 - so I comment this out then if I do
22:54 - console.log of course then square
22:56 - brackets and then specify the key as a
22:59 - string so I'll say name and then I'll
23:02 - output
23:04 - it so this is a different syntax to
23:06 - accomplish the same thing I could also
23:08 - use bracket notation to update the value
23:10 - so if I do course name and assign it to
23:14 - JavaScript
23:17 - 101 then I output it
23:20 - again and this displays the updated
23:22 - value so which approach is better do
23:24 - notation is more commonly used however
23:26 - you would use bracket notation in the
23:28 - case when you don't know which Target
23:29 - property you want to access until
23:31 - runtime here if I comment this out so to
23:33 - show an example of this I'll initialize
23:34 - a variable let property and assign it to
23:38 - hours then I'll do
23:41 - console.log the name of the object which
23:42 - is course and using bracket notation I
23:45 - will use this variable as the key and
23:48 - this will output the associated value
23:50 - for the key of ours when I run in the
23:53 - panel it output the associated value
24:00 - what is an object in
24:07 - JavaScript an object is a fundamental
24:09 - data type in JavaScript that allows you
24:11 - to store key value pairs you can use the
24:12 - object literal syntax by using curly
24:14 - braces and Define the key value pairs
24:16 - inside of it are objects a reference
24:19 - type or a primitive
24:25 - type objects are a reference type PR
24:28 - type refer to values that hold a
24:30 - singular value such as a string number
24:33 - or Boolean whereas objects are more
24:35 - complex data type that allow you to
24:36 - store multiple key value
24:38 - [Music]
24:40 - pairs objects allow you to store key
24:42 - value pairs but often we need an order
24:44 - collection where we have a first element
24:46 - second element and so on this data could
24:47 - be a list of products to display on a
24:49 - web page arrays are used to store lists
24:51 - of data we would use square brackets to
24:53 - create an array literal for example we
24:55 - can do let product
24:57 - colors and we use the square bracket
25:00 - notation and here I we just store some
25:03 - strings ending it with the semicolon and
25:06 - so here I'll just console log it product
25:09 - colors opening up the
25:10 - panel and here it see it logs out the
25:13 - array our list of data now if we just
25:15 - want to access one element in our list
25:17 - we can do so through bracket notation
25:20 - and access it by the index so an
25:22 - interesting about arrays is that we
25:23 - begin counting from zero so rather than
25:26 - counting the first element as the first
25:27 - element we say that this is at the zero
25:30 - position and then one and so on so here
25:34 - if I log it
25:36 - out here I see a logged out blue for the
25:39 - first element in our array at the zero
25:41 - index so the type of variables of each
25:43 - element can change at runtime in
25:45 - JavaScript you can have different data
25:47 - types in an array to demonstrate that so
25:49 - before I call log let's say if I do
25:50 - product colors at the index at zero and
25:53 - I assign that to 42 log that
25:55 - out here I see I logged out the number
25:58 - value of 42 however in a rowo project
26:00 - you would keep the data types the same
26:02 - this is just to demonstrate the
26:03 - flexibility of JavaScript note that an
26:05 - array is an object objects have key
26:07 - value pairs in this case the key is an
26:08 - index value so here if I were to log out
26:11 - the type of let's do console. log type
26:15 - of product
26:16 - colors opening up the panel again our
26:19 - terminal let's log it out and we see
26:21 - that the data type is an object a useful
26:23 - property that you often use when working
26:25 - with arrays is the length property
26:28 - product colors.
26:30 - length so just like we know our objects
26:33 - have properties arrays in JavaScript
26:35 - have built-in properties so here I will
26:37 - log it out and we see that there are two
26:39 - elements in our
26:40 - [Music]
26:42 - array what are
26:49 - arrays arrays are a data structure in
26:51 - JavaScript that allow you to store list
26:53 - of data how would you determine the
26:55 - length of an array
27:02 - arrays have a built-in property called
27:04 - length that allows you to find the
27:06 - length of the array how would you access
27:08 - the first element of an
27:14 - array you start counting from the index
27:17 - of zero in order to access the first
27:19 - element you would use square bracket
27:20 - notation to access the element or to
27:22 - change the value of the
27:26 - element function are the building blocks
27:28 - of our applications it allows us to
27:30 - group together statements to perform a
27:32 - task or calculate a value show you an
27:34 - example we will use the function keyword
27:37 - and we can name our function using camel
27:39 - case we use these parentheses to den
27:40 - notate any argument values we can pass
27:42 - in and I can do console.
27:46 - log end with a semicolon note that we
27:49 - don't need a semicolon at the end of
27:51 - this curly brace and then to actually
27:53 - have JavaScript execute that code for us
27:55 - I can do say Hi and then call by passing
27:58 - in the parentheses here open up the
27:59 - panel and execute this code I see that
28:01 - executed the code within the curly
28:03 - braces we can also Define a parameter
28:05 - variable so here if I add in name I can
28:09 - name this whatever I want then to
28:10 - actually output it or to actually
28:12 - utilize that I can do a plus sign and
28:14 - add in the name of the variable so when
28:17 - working with strings and using a plus
28:18 - sign this is known as string
28:20 - concatenation so it would combine these
28:22 - together create a new string so since
28:24 - I've defined this parameter variable
28:25 - here I need to supply an argument when
28:27 - calling it so here I'll just pass in my
28:29 - name save and open up the panel so once
28:31 - again it's view appearance and then
28:35 - panel flare that out and then run it
28:38 - again and here I see it outputed the
28:42 - argument that I passed in to that
28:44 - parameter variable so here we see there
28:46 - is not a space and so let me add that in
28:48 - here I add the space before this closing
28:51 - single quote and let's run it again
28:56 - [Music]
28:59 - what is a
29:05 - function a function in JavaScript is a
29:07 - name piece of code we use the function
29:09 - keyword and then we can name the
29:11 - function whatever we want after we use
29:13 - parentheses and then curly braces within
29:15 - those curly braces we Define statements
29:17 - and we can invoke or call that function
29:19 - in order to execute those statements
29:21 - benefit is allows us to quickly and
29:24 - efficiently execute those statements
29:25 - without having to duplicate our code
29:28 - what is a parameter
29:34 - variable when defining our functions we
29:37 - specify a parameter list within the
29:39 - parentheses when calling our function we
29:41 - can pass in values and that will allow
29:43 - us to customize the execution of our
29:49 - function so we know that functions are a
29:51 - building block on our programs they
29:52 - enable us to group together a block of
29:54 - code which is a set of statements
29:56 - defined within curly braces one thing I
29:57 - want to to clarify is the purpose of
29:59 - functions we create a function for one
30:01 - of two options the first is to perform
30:03 - some action and the second is to
30:04 - calculate and return some value so not
30:06 - all functions require us to explicitly
30:08 - use the return keyword by default if we
30:10 - don't Supply an explicit return value
30:12 - then JavaScript will have the function
30:14 - return the value undefined I'll show you
30:15 - an example of that so if I declare a
30:17 - function I'll name it multiply and I'll
30:20 - specify two parameters num one and num
30:23 - two then the curly braces to Define our
30:25 - code block and then I will return the
30:27 - product of num one * num 2 so now if I
30:31 - were to call or invoke that function I
30:33 - can say
30:34 - console.log to Output it result and then
30:37 - I will call it I'll say multiply passing
30:39 - in 2 *
30:41 - 2 save it open up the panel up arrow and
30:45 - run it and here I see the result of four
30:47 - was outputed now if I did not use this
30:49 - return keyword and if I were instead for
30:51 - example to store it in a variable const
30:54 - product is assigned to this operation
30:58 - then JavaScript will return the value of
31:00 - undefined by default since I did not
31:02 - supply an explicit return
31:05 - keyword so if I run it
31:07 - again here I see the return value
31:10 - multiply was
31:15 - undefined what are the two reasons to
31:17 - create a
31:22 - function you would create a function
31:24 - either for it to perform an action or to
31:27 - calculate a value and return that
31:31 - value let's summarize what we covered in
31:33 - this section if this is your first time
31:34 - learning this I don't expect you to
31:36 - memorize everything from the start with
31:37 - contined practice you will pick it up
31:39 - and it will become second nature be sure
31:40 - to view the GitHub repository associated
31:42 - with this project and review the project
31:43 - files related to the section so
31:45 - variables are used to store temporary
31:47 - data data can be categorized into eight
31:49 - different data types of these eight data
31:51 - types seven of them are considered
31:53 - primitive data types they are called
31:54 - primitive data types because they are
31:56 - singular values or simple values these
31:58 - primitive data types are strings numbers
32:01 - booleans null undefined big int and
32:03 - symbol and the eighth data type are
32:05 - object objects are key value Pairs and
32:07 - they are not a primitive data type
32:08 - because they are a more complex data
32:10 - type and don't just store a singular
32:12 - value there's also a built-in data
32:13 - structure called arrays which stores
32:15 - list of data which is one of the most
32:17 - used structures that you will use as a
32:18 - developer we also covered functions so
32:20 - rather than having to copy and paste
32:22 - code and duplicate it we can simply name
32:24 - a block of code which is just a group of
32:26 - statements great job on completing the
32:28 - section and with that I'll see you in
32:29 - the next
32:31 - section in JavaScript we can operate on
32:34 - our variables by using operators these
32:36 - include arithmetic assignment comparison
32:38 - logical and bitwise operators which
32:40 - serve as fundamental building blocks for
32:42 - our applications we'll be diving into
32:44 - each of these in the
32:46 - section an expression in JavaScript is
32:49 - something that produces a value an
32:50 - expression goes on the right side of our
32:52 - variable assignment so in JavaScript we
32:54 - have different mathematical operators
32:56 - which include subtraction action
32:58 - addition multiplication represented with
33:01 - an ASC sign division represented by a
33:04 - for Slash and the modulo operator so
33:07 - modulo is the remainder of division and
33:09 - it's useful as it helps us determine
33:10 - whether a number is even or odd so let's
33:12 - open up the
33:13 - panel and type node and enter so now
33:17 - that we're in interactive mode we'll go
33:18 - through different examples so if I do 2
33:21 - + 2 that results in four likewise if I
33:24 - do 4 minus 2 we get the result of that
33:27 - so an example of multiplication an
33:29 - example of division with the for slash
33:32 - symbol we get two now an example of the
33:35 - modu operator let's say if I were to do
33:37 - 10 modul 2 so what this says is 10 / 2
33:43 - and it will return what the remainder is
33:44 - so return zero so we know that this is
33:47 - an even number likewise if I did an odd
33:48 - number / two then we get the remainder
33:52 - of one we could also raise to the power
33:54 - of let's say if I do 3 raised the Power
33:58 - of Two And that results in 9 now we also
34:01 - have the increment and decrement
34:02 - operators so if I initialize let a is
34:05 - assigned to 10 now if I want to update
34:07 - this value I can say a is equal to a + 1
34:11 - now JavaScript provides a shorter syntax
34:13 - where we can use syntactic sugar and say
34:15 - A Plus equal 1 which accomplishes the
34:17 - same thing now we can do it even shorter
34:20 - we can do a plus plus and this will
34:23 - increment the value we could also
34:24 - increment by doing Plus+ a now the
34:28 - difference is the following when I have
34:30 - the two plus operators after the
34:31 - variable it will return the current
34:33 - value stored at the variable a and then
34:35 - it will increment it after if I have the
34:37 - two plus operators before the variable
34:39 - then it will increment the value then it
34:41 - will return that updated value the same
34:43 - functionality also applies for
34:44 - decrementing the value I demonstrate
34:46 - that such as a - equal 1 or I can do a -
34:51 - minus or- - A
34:55 - [Music]
34:58 - what arithmetic operators are available
34:59 - in
35:05 - JavaScript arithmetic operators are
35:07 - symbols used in programming languages
35:09 - including JavaScript to perform common
35:11 - mathematical operations on numbers these
35:13 - include addition subtraction
35:15 - multiplication division modulus
35:17 - increment decrement and
35:19 - exponentiation if I declared let num
35:21 - assigned to one how would I increment it
35:29 - there are four ways to increment a
35:31 - number in JavaScript you can do num is
35:33 - assigned to num plus one or you can use
35:35 - the Shand of num plus equals 1 or the
35:37 - syntactic sugar of num Plus+ or you can
35:40 - do the incrementing before the variable
35:43 - name you are familiar with the
35:45 - assignment operator being a single equal
35:47 - sign such as let programming
35:50 - language assign to
35:53 - JavaScript the single equal sign does
35:55 - not actually check for equality in
35:57 - JavaScript it's an important distinction
35:58 - that stands for assignment as in
36:00 - assigning a value to a variable later in
36:02 - this section I will show you how we can
36:03 - check if two variables or two values are
36:05 - equal in
36:07 - [Music]
36:09 - JavaScript what does the single equal
36:11 - sign stand for in
36:17 - JavaScript the single equal sign stands
36:20 - for the assignment operator and we use
36:21 - it to assign a value to a
36:26 - variable when Del with numbers we often
36:28 - use comparison operators these
36:30 - comparison operators include greater
36:31 - than greater than or equal to less than
36:34 - and less than equal to the result of
36:37 - using comparison operators in an
36:38 - expression is a Boolean value so it will
36:40 - result in either true or false I'll show
36:42 - you an example of each of these and it
36:44 - will make more sense so I'm to deare
36:45 - this variable I'll say let num one is
36:47 - assigned to 14 and I'll say let num two
36:50 - is assigned to 10 then I'll declare a
36:52 - constant I'll call it is num one greater
36:56 - and I'll assign that to num one and then
36:59 - greater than num two so what I have
37:02 - highlighted here is the expression and
37:03 - this will result in a bullan value so a
37:05 - true or false value that will be stored
37:07 - in this variable so I'll log it out
37:10 - console.log is num one
37:12 - greater and let's log it out so in the
37:14 - panel I'll say node control flow and I
37:17 - see that is true so it results in a
37:19 - bullan value so let's consider the other
37:20 - scenarios I'll just rename this variable
37:22 - to make it more descriptive I'll say is
37:23 - greater than or equal to and just copy
37:27 - that over over and I'll change this
37:29 - comparison operator to you be greater
37:30 - than or equal to so open it up and we'll
37:34 - just run it
37:35 - again now I'll show the case when and
37:38 - change this compresson operator to be
37:39 - less than so this is asking is num one
37:42 - less than num two so I'll just rename
37:44 - this to be more descriptive I'll say is
37:46 - num one less than so the actual name of
37:50 - these variables is arbitrary but I do
37:52 - want it to be descriptive for anyone
37:53 - reading this program so this Returns the
37:55 - result false now I'll check if one is
37:57 - less than or equal to num two I'll just
38:00 - change the name of the variable as well
38:01 - so is num one less than or equal
38:10 - to what are the comparison operators in
38:16 - JavaScript the comparison operators are
38:18 - greater than greater than or equal to
38:20 - less than and less than equal
38:22 - [Music]
38:24 - to for checking for equality for two
38:27 - variables we can do so in two different
38:28 - ways so we know that using one equal
38:30 - sign is for the assignment operator here
38:32 - if I just initialize some variables say
38:35 - let B is assigned to two as a string so
38:38 - one equal sign is not for checking the
38:40 - equality so to see if two values are
38:42 - equal we can do so through two equal
38:43 - signs so here if I do console. log AAL B
38:49 - so this is known as loose equality when
38:51 - using two equal signs cuz here I'm
38:53 - comparing a number and a string so let's
38:56 - output this to see the result so this
38:59 - results in true the reason why is
39:01 - because this evaluates in JavaScript
39:03 - what is known as truthy so let me show
39:06 - you the other way of doing comparison
39:07 - which is with strict equality so I would
39:09 - do
39:11 - console.log a equal to B so using three
39:15 - equal signs is strict equality for the
39:18 - first time when doing loose equality it
39:21 - converts into a string by converting to
39:23 - the same data type and then comparing
39:25 - the values restrict quality it Compares
39:28 - it as is without doing any
39:30 - conversions so I'll output
39:33 - it so when doing loose equality it
39:36 - evaluates to true and the reason is
39:38 - because these are two different data
39:40 - types we are comparing a number data
39:42 - type and a string data
39:45 - type to show you another example of how
39:48 - JavaScript converts values with loose
39:52 - equality I'll show you one equal to one
39:56 - represented as a string
39:58 - and so even that these values are
40:00 - different data types JavaScript will
40:02 - convert it for us so it will evaluate to
40:05 - True let's comment these previous ones
40:07 - out here comment that out and comment
40:09 - that one
40:10 - out so once I output it here I see it
40:13 - evaluates the true likewise if I were to
40:15 - do
40:17 - true equal to
40:20 - one JavaScript will convert these into
40:23 - Boolean values before performing the
40:25 - comparison with loose equality
40:28 - all right so in order to avoid this
40:29 - confusion stick to strict equality and
40:32 - use three equal
40:34 - [Music]
40:37 - signs what is the assignment
40:44 - operator the assignment operator in
40:46 - JavaScript refers to using a single
40:48 - equal sign in order to assign a value to
40:50 - a variable what is loose equality
40:58 - loose equality in JavaScript refers to
41:00 - the comparison of two values using two
41:02 - equal signs without enforcing type
41:04 - similarity when using Luci equ quality
41:06 - JavaScript performs type coercion if the
41:08 - values being compared are of different
41:10 - data types attempting to convert them to
41:11 - a comparable form before making the
41:13 - comparison this process known as type
41:15 - coercion can lead to unexpected results
41:17 - if you're not aware of how the values
41:18 - are converted these three examples show
41:21 - how JavaScript would perform loose
41:24 - equality what is strict equality
41:32 - strict equality refers to using three
41:33 - equal signs for checking for equality
41:35 - this will return true if the values are
41:37 - equal and of the same data
41:40 - type in JavaScript we have something
41:42 - called a Turner operator so the Turner
41:44 - operator is a conditional operator that
41:46 - allows us to write cleaner code often
41:48 - times you need to perform a comparison
41:49 - and store values let's go into an
41:51 - example say let age is equal to 16 and I
41:55 - want to determine if I can drive so I
41:58 - form a comparison so age greater than
42:01 - equal to 16 well in that case I can use
42:03 - a question mark and then true or false
42:07 - so let's break this down highlighted I
42:08 - have the comparison comparing the value
42:10 - at this variable and this number so this
42:13 - question mark is the turn operator which
42:16 - means that if this results to true then
42:18 - it will return true otherwise return
42:20 - false let me console log it console. log
42:23 - can drive opening up the panel panel is
42:26 - control and back
42:27 - or view appearance panel so up Arrow
42:30 - execute it and we know that it's true so
42:32 - now I will comment this out since we no
42:33 - longer need it for now and I'll fig
42:35 - another example let's say let points
42:37 - points is equal to 110 and the output of
42:40 - to determine what the customer type is
42:42 - so points is greater than 100 then in
42:46 - that case we determine gold in the case
42:47 - when it's true or silver in the case
42:51 - when it's false so output it
42:54 - console.log customer type so what this
42:57 - does this allows us to perform an
42:59 - assignment to the customer type variable
43:01 - that we declared conditionally based on
43:03 - the result of this comparison so once
43:05 - again I'll output it note and we see
43:07 - that the customer is a gold customer
43:11 - type what is the tary
43:18 - operator the Turner operator is a way to
43:21 - conditionally assign a value to a
43:22 - variable you would use a conditional
43:24 - expression followed by a question mark
43:25 - if that conditional expression is
43:27 - evaluated the truthy then you'll use the
43:28 - value that follows just after the
43:30 - question mark otherwise you'll use the
43:32 - value following the colon which is
43:33 - specified at the end what is the value
43:35 - stored in the variable customer
43:42 - type the value stored will be the string
43:45 - containing the word
43:48 - gold we use logical operators to make
43:51 - decisions based on multiple conditions
43:53 - there are four logical operators The
43:55 - Logical operators are the or operator
43:57 - the and operator not and no coalescing
43:59 - these can be applied to values of any
44:01 - type not just bulling starting with the
44:02 - or operator which is represented by two
44:04 - vertical lines so there are four
44:06 - possible logical combinations and I'll
44:07 - show you each a console log true and use
44:11 - the logical or operator represented by
44:13 - two vertical lines in this case I'll
44:16 - just do true so what this expression
44:17 - does the expression I've highlighted
44:19 - true and true as long as one of the
44:21 - operands is true then it will return
44:24 - true so I'll just lock that out n
44:26 - operator
44:28 - .js so we know that the other option is
44:30 - if the first is false and this value is
44:33 - true so in this case we know that as
44:35 - long as one is true then it will return
44:36 - the value as
44:39 - expected right so we know that now if
44:41 - the first is true and this is false same
44:44 - result as expected then we log that
44:48 - out and the last option will be when
44:51 - they are both
44:54 - false pull out the panel and run it one
44:56 - more more time so so long as one of the
44:59 - operand is true and the expression will
45:00 - evaluate as expected if operand is not a
45:03 - Boolean value then it'll be converted to
45:04 - a Boolean value for the evaluation for
45:06 - example the number one is treated as
45:08 - true and the number zero as false so the
45:10 - or operator is evaluated from left to
45:12 - right and for each operand converts it
45:13 - to a Boolean and once it finds an
45:15 - operand that resolves to true it stops
45:17 - and Returns the original value of that
45:18 - op and if all operand have been
45:19 - evaluated to false then it Returns the
45:21 - last operant and the value is return in
45:23 - its original form without the conversion
45:25 - to a boan value now to show you another
45:26 - example
45:27 - we say let has
45:29 - reservation I'll close the panel assign
45:31 - that to true then I'll say let accepting
45:34 - Walkins and assign it to
45:36 - false if it has access to
45:40 - table has reservation or accepting
45:46 - Walkins plog that
45:48 - out opening the panel or run it and see
45:52 - it evaluates the true now let's consider
45:53 - the and operator so and returns true if
45:56 - all the operand are truthy and false
45:58 - otherwise I'll show you all possible
46:02 - combinations true true so you know
46:04 - that's true and I'll just copy it the
46:06 - other four times for the other cases now
46:09 - all other cases will be
46:11 - false so have false and true true and
46:17 - false and false and true run in the
46:20 - panel node operators. js and here we see
46:24 - as expected so this operator valuates
46:27 - from left to right and once again it
46:28 - converts each operand to a Boolean if it
46:30 - is not already a bullan type and once it
46:32 - discovers one of the operand to be false
46:34 - then it stops execution which is known
46:35 - as short circuit evaluation so to show
46:37 - you a more rward example I say let H is
46:40 - equal 16 I can say let has car equals
46:43 - true let's say cons can drive age is
46:48 - greater than equal to 16 and as car and
46:52 - let's log that
46:54 - out here it evaluates to true so that
46:57 - the Precedence of the and operator
46:59 - higher than the or operator so just to
47:01 - give you a visual of that
47:03 - console.log a let's just make it let a
47:08 - equal true and b equal true and c equal
47:12 - true and D equal true then if I were to
47:15 - write this expression and can say A and
47:17 - B or C and D then this value up here is
47:22 - actually the same as this as if you were
47:24 - to write parentheses just to show
47:27 - that using the ersan holds higher
47:29 - precedence and is evaluated first before
47:32 - the or Operator just to demonstrate that
47:34 - next is the Boolean not operator
47:36 - represented by exclamation point so it
47:38 - converts the operan to a Boolean type
47:40 - true or false and it Returns the inverse
47:42 - value so let's just say if I to do
47:43 - console.log of true then whatever this
47:46 - current value is it will return the
47:48 - inverse it will return false in this
47:50 - case here we know it evaluates defaults
47:52 - so let's say if I were to do let is
47:55 - closed on
47:57 - Sunday if find true then I can say cons
48:00 - is
48:02 - restaurant
48:03 - open to this close on Sunday then I can
48:07 - console log it then I can run it and
48:11 - here we see it is Returns the inverse of
48:13 - this value so let's close that so the
48:15 - last operator is the nullish coalescing
48:17 - operator represented by two question
48:19 - marks if a value is nuller undefined
48:22 - then we can supply a default value show
48:24 - you an example of that let's say let a
48:25 - let's just assign it to
48:27 - and we want to determine what the result
48:28 - is so if a is truthy right so in this
48:32 - case it is not so we need to apply a
48:34 - default value so we use the no Co
48:35 - Lessing operator here so this being the
48:37 - default value so if I just log it out
48:40 - result and then I'll execute it in the
48:42 - panel I'll do node operators. js and
48:45 - here we see it evaluates default by giv
48:47 - by being given the default value to make
48:49 - better sense of this I'll show you that
48:51 - this is actually syntactic Sugar if we
48:53 - were to do the longer format it would be
48:55 - a not equal to null and a not equal to
49:00 - undefined and then using the Turner
49:02 - operator which is a question mark So
49:04 - this expression this condition is
49:06 - evaluated and if it's true then return a
49:09 - otherwise return false so what we did
49:11 - before is just the shorthand version of
49:13 - this and it provides syntactic sugar and
49:15 - cleaner code and easier to read for
49:18 - [Music]
49:20 - us what are logical operators
49:28 - logical operators in JavaScript are
49:29 - special symbols or keywords used within
49:32 - Expressions to perform logical
49:33 - operations they primarily involve
49:35 - Boolean values however they can be
49:36 - applied to values of any type not just
49:38 - booleans the result of these operations
49:40 - is to determine the logical relationship
49:42 - between the operant typically resulting
49:43 - in a Boolean value that indicates the
49:45 - truthiness or fals of the combined
49:47 - expression what are the four main
49:49 - logical operators in
49:50 - [Music]
49:55 - JavaScript the form operators are the
49:57 - and operator the or operator the not
50:00 - operator and no coalescing operator what
50:02 - is this operator and how does it
50:04 - [Music]
50:08 - work this operator represented by two
50:11 - vertical lines is the or operator it
50:13 - Compares two operands or two values and
50:15 - as long as one of them results to true
50:17 - then the expression will return true
50:19 - what is this operator and how does it
50:20 - [Music]
50:25 - work this operator represented by two
50:27 - ampersands is the and operator the way
50:30 - it works is it Compares two values or
50:31 - two operands when both operands results
50:34 - to true then it will return truthy what
50:36 - is this operator and how does it
50:39 - [Music]
50:42 - work this operator represented by the
50:44 - exclamation point is known as the not
50:46 - operator also sometimes called the bang
50:48 - operator so this value Returns the
50:50 - inverse of the operand that is used with
50:52 - for example if the exclamation point is
50:54 - used in front of a variable and that
50:56 - variable is assigned to the value true
50:57 - the exclamation point will have it
50:59 - return the inverse it will return false
51:01 - what is this operator and how does it
51:03 - [Music]
51:07 - work this operator represented by two
51:10 - question marks is the no Co Lessing
51:11 - operator but this does is allows you to
51:13 - supply a default value in case the
51:15 - operand used in front of the question
51:17 - mark is
51:18 - [Music]
51:21 - false JavaScript is different from other
51:23 - programming languages one way that it
51:24 - differs is in its use of logical
51:26 - operators and how they can be applied to
51:28 - nonbing operant I'll pull up the panel
51:30 - you can go to view appearance and the
51:33 - panel so if I write enter node and
51:35 - compare false or the string Steven here
51:39 - we see Steven is returned using the or
51:41 - operator it Returns the first True Value
51:43 - so you see that this string is evaluated
51:45 - to true so in JavaScript the result of a
51:47 - logical expression is not necessarily
51:49 - true or false so it looks at the operan
51:51 - and if it's not a Boolean value it will
51:53 - then try to interpret it as truthy or
51:54 - falsy so in JavaScript something that is
51:56 - falsy which is different from the
51:58 - Boolean false encompasses the values of
52:00 - undefined null zero false the empty
52:03 - string and not a number anything not
52:05 - falsey anything which does not fall in
52:07 - the category that I previously mentioned
52:08 - is considered truthy now to show you
52:10 - another example you can consider false
52:12 - or one or two the result of this is one
52:15 - JavaScript evaluates this from left to
52:17 - right since one is considered truthy
52:19 - then JavaScript can perform shortcircuit
52:20 - evaluation and return immediately this
52:22 - means that JavaScript will stop once it
52:24 - can successfully determine the result
52:26 - and it doesn't have to evaluate every
52:27 - operan so to provide a more World W
52:29 - example let me initialize user chosen
52:31 - color is assigned to Blue and we'll say
52:35 - the default color is green now we can
52:37 - determine what is the current website
52:40 - color so I'll say user chosen color or
52:45 - default color I'll console log
52:48 - it current website color because both of
52:51 - these values are strings JavaScript will
52:53 - convert these to Boolean values and
52:54 - consider whether this is truthy node
52:58 - operators. js and here it evaluates to
53:00 - Blue but if I were to delete blue and it
53:02 - be empty string then JavaScript would
53:03 - evaluate that to be falsy and it will
53:05 - turn the default color what does the
53:08 - term falsy mean in
53:13 - JavaScript so this term applies when
53:15 - you're using logical operators with non-
53:17 - Boolean values since logical operators
53:19 - deal with Boolean values which means
53:21 - values that are true or false if you're
53:23 - using a non- bullan value such as a
53:25 - string or a number JavaScript needs to
53:27 - be able to convert that value into a
53:29 - Boolean value into a true or false value
53:32 - what are the falsy
53:36 - values JavaScript has a set of non-bo
53:39 - values which it considers to be falsy
53:41 - meaning that when javascrip converts
53:43 - these non- Boolean values into Boolean
53:44 - values via type coercion it evaluates to
53:47 - false the falsy values consist of null
53:49 - undefined not a number the empty string
53:52 - zero and false these are the values that
53:54 - JavaScript will consider to be false how
53:57 - do logical operators function when
53:59 - applied to non- Boolean
54:04 - values logical operators are evaluated
54:06 - from left to right if you're using the
54:08 - or operator once JavaScript evaluates an
54:10 - operand to be truthy then it will return
54:12 - that value if you are using the and
54:14 - operator then all the operands need to
54:16 - evaluate the truthy in the case when
54:17 - it's true then it will return the last
54:19 - value in the expression consider the
54:22 - expression let name assigned to the
54:23 - string test and con result equal to
54:25 - false or name what is the value stored
54:28 - in the variable
54:32 - result the value stored will be the
54:35 - string with the word
54:38 - test so operator precedence I'll
54:41 - initialize this variable 5 + 5 * 4 and
54:45 - then I'll console log the result
54:46 - console.log and then n your node
54:49 - operator SS here it evaluates to 25 so
54:53 - previously in JavaScript everything has
54:54 - been evaluated going from left to write
54:56 - for each statement but here when using
54:58 - operators it will use the same order of
55:00 - precedent used in math that being
55:02 - parentheses exponents multiplication
55:04 - division and then subtraction so in
55:06 - order to make this more readable usually
55:08 - we would use parentheses just to make it
55:09 - more readable for other programmers who
55:11 - are viewing our code but JavaScript does
55:14 - this under the hood so I will save it
55:16 - this will return the same result for us
55:18 - but here is just a bit more
55:20 - readable now we could also override that
55:23 - precedence by utilizing parenthesis
55:28 - [Music]
55:31 - to summarize the section on operators we
55:32 - covered the arithmetic operators which
55:34 - include addition subtraction
55:36 - multiplication division and modulo we
55:39 - covered the assignment operator which is
55:40 - used for assigning values to variables
55:43 - we covered the comparison operators
55:44 - which use greater than greater than
55:46 - equal to less than and less than equal
55:48 - to we covered the equality operators
55:50 - such as loose equality which uses two
55:52 - equal signs which will have JavaScript
55:54 - perform type coercion and compare the
55:55 - underly values of the operands
55:57 - irrespective of the data type instead we
55:59 - should use strict equality which uses
56:01 - three equal signs to ensure that we are
56:03 - checking that the values are the same
56:04 - and the data type is the same for the
56:06 - operands that we are comparing we cover
56:07 - the Turner operator which provides
56:09 - syntactic sugar for conditionally
56:11 - assigning a value depending on a
56:12 - condition so if the condition is true
56:14 - use the value specified after the
56:15 - question mark if the condition is false
56:17 - use the value specified after the colon
56:19 - we cover the logic operators which
56:21 - include the or operator with two
56:22 - vertical lines the and operator which
56:24 - uses two ampersands and the not operator
56:26 - which uses an exclamation point this
56:28 - concludes this section and I will see
56:29 - you in the next
56:31 - [Music]
56:32 - one so now rename this file to control
56:36 - flow control flow so programming is
56:39 - powerful as it enables us to execute
56:41 - different code based on conditions this
56:43 - is what enables us to provide Dynamic
56:45 - and personalize applications to end
56:47 - users the fundamental programming
56:49 - concept that enables this is conditional
56:51 - statements more specifically ifal
56:53 - statements so previously we have
56:54 - considered let's say if I already do
56:56 - price of chocolate equal to the number
56:59 - that decimal value and let's say let has
57:02 - amount in cash assigned to five well we
57:05 - can use comparison operators and score
57:08 - the result of this Boolean operation you
57:10 - can say can buy
57:12 - chocolate equal to has Mountain cache
57:15 - and if that is greater than or equal to
57:17 - the price of the product then we know we
57:18 - can determine whether this is true or
57:20 - false I'll just lock it out Lo node
57:23 - control
57:24 - flow. Js and we know that that's true
57:27 - now if I to log out instead the type of
57:29 - this variable and this will determine
57:31 - what the data type is so if I execute
57:34 - that again we know what that is a
57:35 - Boolean result so the result of these
57:37 - comparison operators we know it will be
57:39 - a Boolean result so we can utilize these
57:41 - comparisons and these conditions to
57:43 - execute different code so if I were to
57:45 - utilize an IFL statement I can say if
57:48 - which is a built-in keyword in
57:49 - JavaScript and I can utilize this
57:51 - variable in parenthesis this is known as
57:53 - a condition then I'll do curly braces
57:55 - and with these cemb braces I can write
57:57 - statements that will be executed this
57:59 - condition is true so I can say
58:01 - console.log Enjoy your purchase so now
58:05 - execute this program and we see the
58:07 - string enjoy your purchase now let's say
58:09 - if I were to make this person only had
58:11 - 99 cents in cash then if I would execute
58:14 - it then we see that that is not logged
58:16 - to the console as this is not true it
58:19 - would be false in this case so let's go
58:20 - back to setting the value of five now
58:22 - rather than just logging out in the case
58:24 - when it's true can also log in the case
58:26 - when it's false by using an lse
58:27 - statement which is built into JavaScript
58:29 - and we will log in this case console.log
58:32 - sorry you do not have you know so
58:35 - execute both cases once again we get the
58:38 - result so only this code is executed in
58:40 - this case because this value is
58:42 - evaluated to true now let's go to
58:45 - 099 now we'll see which statement is
58:48 - executed and which is logged in the case
58:50 - when can by chocolate is
58:52 - false so here we see this was locked to
58:54 - the console so to show you a different
58:56 - example and remove that we have two
58:58 - types of conditionals in programming the
58:59 - if Al statement which is used most
59:01 - commonly and we also have switch case
59:03 - statements which I'll be covering in the
59:04 - next lesson so let me consider a more
59:06 - evolved example to show you what else
59:07 - you can do with IFL statements let me
59:09 - initialize and say let hour is assign to
59:12 - 10 for example I want to do different
59:14 - conditions to determine what types of
59:16 - food a restaurant is serving based on
59:18 - the time so let's say if the hour is
59:20 - greater than 6 and the hour is less than
59:24 - or equal to 12 then it would serve
59:26 - breakfast
59:27 - console.log serving
59:30 - breakfast let's log this out so it's
59:33 - currently serving breakfast now we also
59:34 - want to consider the case when it would
59:35 - serve lunch so let's say as if the hour
59:39 - is greater than equal to 12 so say it's
59:43 - greater than 12 and the hour is less
59:47 - than or equal to 14 then in that case we
59:49 - will log
59:51 - console.log serving lunch let's open
59:54 - this up and log it out so let me change
59:55 - this value let's say it's 1:00 then we
59:58 - see that it's serving lunch now in the
60:00 - case when it would be serving dinner
60:01 - let's say else now when we have if else
60:05 - if then the last statement would just be
60:07 - else and in this case we don't need to
60:08 - supply a condition meaning that we don't
60:10 - need to do parentheses here and this
60:13 - will be evaluated as the default case
60:16 - console.log serving dinner so let's make
60:19 - this and we'll log it out so now you see
60:22 - the case of how we can utilize ifal
60:24 - statements to custom the output for the
60:26 - user in the case when we just have one
60:29 - statement within the curly braces now
60:31 - when I have this highlighted this can
60:33 - also be referred to as a code block so
60:35 - when we just have one statement within
60:36 - it we can actually clean it up and
60:37 - remove the curly braces just to make it
60:39 - a bit more readable and
60:45 - cleaner what is the ifal
60:51 - statement control flow and programming
60:53 - refers to the order in which statements
60:55 - are executed in JavaScript control flow
60:57 - structures such as the IFL statement
60:59 - dictate how and under what conditions
61:01 - certain blocks code are
61:04 - executed switch case statements can also
61:07 - be used for control flow the difference
61:08 - between iFile statements and switch case
61:10 - statements is that switch case is only
61:12 - used for equality comparisons so I'll
61:14 - show you an example let's initialize a
61:16 - variable and say let job assigned to the
61:19 - string of software
61:20 - developer now I'll show you an example
61:22 - of the control flow using IF and Al if
61:25 - statements so I'll say if job is equal 2
61:29 - so I'll use three equal signs for strict
61:30 - equality and then the string software
61:34 - developer I'll do curly braces and in
61:37 - that case I will
61:38 - console.log wres code save that open up
61:42 - the panel and I'll run it so I'll say
61:44 - node control flow. JS in here because
61:47 - this condition is true it executes and
61:49 - console logs that string I'll show some
61:51 - other examples so let's say less if job
61:55 - is equal to a
61:57 - designer curly braces I'll say
62:01 - console.log makes user interface
62:06 - documents end it with the semicolon now
62:09 - if I were to assign this variable to be
62:12 - assigned to designer and I run it again
62:15 - here it executes this console log
62:17 - statement I'll show another example Al
62:19 - if your job is equal to we'll say cloud
62:24 - engineer console
62:26 - log manages and employ Cloud
62:31 - resources right so let's say if I assign
62:34 - this value and I run it
62:38 - again console logs that and I had a
62:41 - default with the last out statement
62:45 - console.log I'll say Works directly with
62:48 - customers I'll just say sales run it and
62:53 - executes this last out statement so so
62:55 - since we are using our ifal conditions
62:57 - to do comparisons with the equality
62:59 - operator this can be a bit hard to read
63:01 - and repetitive when you find yourself
63:02 - having a long chain of if and Al if
63:05 - statements when you're using comparisons
63:07 - for all the conditions you can consider
63:09 - using switch case statements so instead
63:11 - of the code above I'll comment it out by
63:12 - highlighting it and doing command for
63:14 - slash or control for slash on Windows
63:16 - I'll use a syntax where I say switch as
63:19 - the keyword and for the condition in the
63:20 - parentheses I will specify the variable
63:24 - then what I do is I will use the keyword
63:26 - case so in the case when it's equal to
63:28 - software
63:31 - developer colon then I'll will console
63:34 - lck this
63:35 - statement and then use a keyword break
63:38 - with the semicolon to end the comparison
63:40 - then I'll say in the case when it's a
63:43 - designer colon then I'll copy this
63:46 - over so I'm effectively implementing the
63:48 - same functionality just using different
63:50 - syntax that's easier to
63:53 - read copy this over
63:56 - with a break statement and then I'll add
63:58 - a
64:01 - default so this is another way to
64:03 - achieve that same functionality now the
64:04 - reason why we use the break statement is
64:06 - that what the switch case statement
64:07 - would do is it will take this variable
64:09 - and it will compare it to every single
64:11 - case and in the case when it is equal to
64:14 - it then it would execute the code in
64:16 - this code block so by specifying the
64:18 - break statement we're telling JavaScript
64:20 - to break out of this switch case
64:23 - statement so no longer perform any more
64:25 - comparisons and move on with the program
64:27 - we'll log it out so in the case when
64:28 - it's equal to I'll say software
64:31 - developer and save it I'll scroll down
64:34 - so you can see the code and then I'll
64:36 - execute it so this is a way to achieve
64:38 - that same functionality once again when
64:39 - using switch case statements this only
64:41 - applies in the case when you are doing
64:43 - equality
64:47 - comparisons what are switch case
64:49 - statements and when would you use it
64:59 - switch case statements provide a clean
65:00 - syntax in the case when you're using a
65:03 - variable and Performing comparison
65:05 - equality you can implement the same
65:06 - functionality using IF and Al if
65:08 - statements but switch casy statements
65:10 - provide a clean alternative for
65:11 - accomplishing the same thing so to
65:12 - describe the syntax you would use the
65:14 - switch keyword then in parenthesis you
65:16 - would use a variable or a value and then
65:18 - within the code blocks you would specify
65:20 - different cases to define the case when
65:22 - that variable or value is equal to that
65:24 - case and then execute code for that
65:26 - particular use case when using switch
65:28 - case statements you also want to
65:29 - remember to supply a default
65:33 - value next we will cover for Loops so I
65:36 - will initialize an array call it let
65:38 - numbers is assigned to using our array
65:41 - literal syntax with square brackets I'll
65:43 - do 1 2 3 4 5 6 and 7even ending it with
65:47 - a semicolon now what I'll do is I'll
65:49 - initialize this number to be the index
65:52 - of zero because we know when we start
65:54 - counting these elements we we start
65:55 - counting from zero so for this index
65:57 - value in this element this is at the
65:59 - zeroth position then the first position
66:02 - second position and so on then to
66:04 - determine what the length of the array
66:05 - is I can say let length of
66:08 - array and it be numbers and arrays have
66:11 - a built-in property called length so
66:13 - that can be stored here so now what I
66:15 - want to do I want to go through and log
66:16 - each element in this array by
66:18 - referencing it by its index so I use
66:20 - bracket notation to access it by index I
66:22 - can do
66:24 - console.log so the name with the array
66:26 - square bracket notation and I'll do the
66:29 - index and I'll log that out so this
66:32 - executes and this displays the element
66:34 - at the zeroth position the first
66:36 - position of the array now let's say if I
66:38 - wanted to Output every single element
66:40 - well I can copy it over so I'll do shift
66:42 - option in the down arrow just to copy it
66:44 - over seven times now each time I want to
66:48 - increment it so rather than having to do
66:50 - do this and then do index Plus+ to
66:53 - increment it I can just do it within it
66:55 - and I know if I do the increment after
66:58 - then this will be displayed and then be
67:00 - updated after so I'll continue this TR
67:03 - for each
67:05 - one except for the last one and I'll log
67:08 - that out so here you see this executes
67:10 - and this displays every element in the
67:12 - array now this was a very repetitive
67:13 - process and we would want to do this in
67:15 - a real program so I'll comment all this
67:17 - out and we can use it to reference it as
67:19 - we build up our first for Loop so for
67:21 - Loops allow us to get the benefit in the
67:23 - power programming cuz it can execute a
67:25 - lot of code in a very short amount of
67:26 - time so we utilize the for keyword which
67:29 - is a special keyword that allows us to
67:31 - create a for Loop and we can do
67:32 - initialization here we'll say let index
67:35 - assign zero and we'll do a semicolon and
67:38 - then we can do while the index is less
67:40 - than the numbers.
67:43 - length and then the index
67:45 - increments and then I'll do curly braces
67:47 - so I'll break this
67:49 - down what we did here is just put the
67:51 - same
67:52 - logic on one line so we initial
67:56 - our variable index to keep track of
67:58 - where we are in the array then we have a
68:01 - condition so is this index value less
68:04 - than the numbers. length and this will
68:06 - evaluate to a Boolean value while it's
68:08 - true then the code within this code
68:10 - block Within These curly braces will be
68:11 - executed if it's false then it will stop
68:14 - execution now we want to continue
68:17 - incrementing through the numbers
68:19 - array so we need to continue to
68:21 - increment the index now if we were not
68:24 - have this then this will result in
68:25 - infinite Loop and this code will
68:27 - continue to be executed and our computer
68:28 - would crash so it's very important to
68:30 - have this last value incrementing it to
68:33 - make sure that we are getting closer to
68:36 - this condition being
68:38 - false so another way to think about this
68:40 - if this is your first time seeing it
68:42 - whenever we have these traditional for
68:44 - Loops we have an initialization part we
68:47 - have a conditional part and then we have
68:50 - an increment or decrement
68:52 - part so now in here I'll just do console
68:55 - log numbers at
68:59 - index so using this variable to
69:02 - reference the element that we want to
69:03 - execute so I'll execute
69:06 - that and we get the same result with
69:09 - much cleaner code so Loops reduce our
69:11 - code duplication and they have fast
69:13 - execution so here it's just executed
69:15 - with an array with seven elements but
69:17 - but let's say if I were to do another
69:18 - for Loop let's comment this out so
69:19 - command for slash or control forward
69:21 - slash let's say if I do four our initial
69:25 - ation part let num is assigned to zero
69:28 - while num is less than a value like 100
69:30 - and let's say the number increments
69:33 - right
69:34 - initialization condition and then
69:36 - increment or
69:37 - decrement so this value the code will be
69:40 - continue to be executed while this
69:42 - condition is true and once it's false it
69:45 - will stop its execution so I do
69:47 - console.log and let's execute the
69:52 - number so here you see all these values
69:54 - are quickly executed and I don't have to
69:57 - go through and do console logs for every
69:58 - single
70:01 - number what is a for
70:08 - Loop in programming a for Loop is use in
70:11 - order to execute a code block repeatedly
70:13 - so rather than having to manually repeat
70:16 - that code which will lead to code
70:17 - duplication you can define a code block
70:19 - def find within curly braces and using
70:20 - the special syntax of the for Loop you
70:22 - can continue to repeat those lines of
70:24 - code while it condition is true what is
70:26 - the Syntax for a for
70:33 - Loop the Syntax for the traditional for
70:35 - Loop uses the for keyword then you would
70:37 - define an initialization part you define
70:39 - a variable then you would Define a
70:41 - condition so while the condition is true
70:43 - you will execute the code within the
70:44 - code block within the curly braces and
70:46 - then you will have an increment or
70:47 - decrement part where you are updating
70:49 - the variable such that it gets closer to
70:51 - the condition being false because you
70:52 - need to make sure that you break out of
70:53 - the for Loop cuz you don't want to deal
70:55 - with with an infinite Loop which would
70:56 - cause your program and your computer to
70:58 - [Music]
70:59 - crash we often need to repeat actions
71:02 - and Loops are a way to repeat the same
71:03 - code multiple times you've seen the for
71:05 - Loop which provides a traditional Syntax
71:07 - for iterating over an array we use for
71:09 - Loops when we know the exact time when
71:11 - we want the loop to stop executing there
71:13 - is another syntax called a while loop
71:14 - and we can implement the same
71:15 - functionality of for loops with while
71:17 - Loops so first I will show you the for
71:19 - loop again so we'll say we know we have
71:21 - let index is assigned to zero then we
71:23 - have the condition where we say the
71:24 - index is less than numbers.
71:27 - length and then the index
71:30 - increments right so we have the
71:31 - beginning part the initialization we
71:33 - have the condition and then we have the
71:35 - step condition where we're incrementing
71:38 - console. log numbers add
71:42 - Index right since this is new syntax for
71:45 - you I want to be repetitive just to make
71:46 - it easier for you to
71:48 - remember execute that now let's use a
71:51 - while loop to achieve the same
71:52 - functionality so I will say let index is
71:54 - assigned to zero and here I will use the
71:56 - while keyword so in the parentheses I
71:58 - will say index is less than numbers.
72:01 - length and then curly braces so in here
72:04 - I will say
72:06 - console.log numbers at
72:09 - index and then the index increments so
72:13 - I'll comment this out by highlighting it
72:15 - in control for slash or control for
72:17 - slash for Windows so we see that this
72:18 - has the same Parts but it's broken up so
72:21 - here we see the initialization part here
72:24 - then the conditional part and then the
72:27 - step condition so now execute it just to
72:29 - show you that we have the same
72:31 - functionality and executes the same
72:33 - functionality now the difference is that
72:35 - we would use a for Loop when the number
72:36 - of iterations is known before entering
72:39 - the loop whereas we would use a while
72:40 - loop in the case when the number of
72:41 - iterations is not known before entering
72:43 - the loop so to show you one condition
72:44 - that shows this and demonstrates this we
72:46 - can say if we have let sum is equal to
72:49 - zero and we can just say while true so
72:53 - while this condition is true execute the
72:54 - code with in the block I can just say
72:57 - console.log
73:00 - Loop and then some increments then I can
73:03 - do um if the sum is equal to
73:07 - 10 then in that case we can use a break
73:10 - statement and break out of the loop so
73:12 - this is a special keyword we can use
73:14 - within our while loop or for Loop to
73:16 - stop and break out of the execution so
73:17 - I'll run
73:19 - this and here we see we have console
73:21 - logged Loop so in this case we have
73:23 - shown that we want this condition in
73:24 - this Loop to continue to run while this
73:26 - is true and we have this case to ensure
73:28 - that we don't have an infinite Loop so
73:30 - it doesn't run an infinite amount of
73:31 - times and we know when to terminate it
73:33 - and this is something that we cannot do
73:34 - with a for Loop meaning that we cannot
73:36 - just use a condition of while it's true
73:38 - continue
73:39 - [Music]
73:41 - executing what are the similarities and
73:43 - differences between the for Loop and the
73:44 - while
73:49 - loop the for Loop and the W Loop are
73:52 - similar in that they both execute a
73:53 - block of code repeated while a condition
73:56 - is true the difference is is that you
73:57 - would use a for Loop typically for
73:59 - iterating over an array whereas a while
74:01 - loop you would use that in order to
74:02 - execute the same block of code while a
74:04 - condition is
74:06 - true we have another loop we can use in
74:08 - JavaScript known as a do while loop now
74:11 - do while Loops are not commonly used but
74:13 - I want to show it to just so that you
74:14 - are aware of it so previously we have
74:16 - used for loops and while Loops where we
74:18 - specified a condition and then executed
74:20 - code within curly braces and if and only
74:22 - if the condition evaluated to True would
74:24 - that code block be executed so the code
74:26 - in the code block was only executed
74:28 - after the condition with do well Loops
74:29 - we specify the code block first and then
74:31 - the condition after so let me show you
74:32 - an example let's say if we do let I is
74:34 - assigned to zero so we initialize that
74:36 - now we'll use this syntax where we say
74:38 - do which is a built-in keyword in
74:40 - JavaScript then we can do
74:42 - console.log let's say I and then we
74:44 - increment it now we Supply the condition
74:46 - after so while I is less than 10 then we
74:50 - use a semicolon determinate it so so
74:51 - this syntax will execute the code block
74:53 - first right everything I have
74:55 - highlighted within the curly braces and
74:57 - then do the condition check after to
74:59 - determine if the loop should continue
75:00 - executing so with this syntax it's
75:02 - guaranteed that our code block will
75:03 - execute at least once so I'll save this
75:05 - when I'll execute it up arrow and we see
75:08 - it's
75:09 - executed what is the difference between
75:11 - a w Loop and a do W
75:18 - Loop both a while loop and a do Loop are
75:20 - similar in that they repeatedly execute
75:22 - a block of code given a condition being
75:25 - true the difference is that a while loop
75:26 - will check the condition first and if it
75:28 - is true then execute the code with a do
75:30 - while loop it will execute the code
75:32 - first specify within the curly braces
75:34 - and then check the conditional statement
75:36 - so a while loop is not guaranteed to run
75:38 - it will only run if the condition is
75:39 - true whereas a do Loop is guaranteed to
75:42 - run at least
75:44 - once one thing I want you to be aware of
75:46 - in working with loops is the problem of
75:48 - infinite Loops so when working with
75:49 - either a for Loop a while loop or a do
75:51 - while loop we must ensure that our Loops
75:53 - terminate if you were to Simply do for
75:55 - example while true for the condition and
75:58 - just do
76:00 - console.log of loop then this will
76:03 - continue to Loop and execute an infinite
76:04 - amount of times and our program and
76:06 - computer would eventually crash so when
76:08 - working with either for Loops while
76:09 - Loops or do while Loops we have to
76:11 - ensure that we specify a condition in
76:13 - the parentheses that will eventually
76:14 - evaluate to false or we can explicitly
76:16 - use a break statement to explicitly tell
76:18 - JavaScript that we want the loop to stop
76:20 - executing so once again I'll show you
76:22 - the for Loop let num assign to Z num
76:25 - less than equal to 100 num increments
76:29 - and once again we'll log out the num so
76:31 - the two things I want you to consider
76:33 - here is the condition so this Loop will
76:35 - continue to execute while this is true
76:37 - and so the step condition right here we
76:39 - want to ensure that for each iteration
76:41 - we are getting closer to terminating
76:43 - this condition to this condition being
76:45 - false so that's where we do num Plus+ as
76:47 - opposed to numus minus cuz in this case
76:50 - it will lead to an infinite Loop so
76:51 - whenever you're working with loops be
76:52 - careful of the condition that you're
76:54 - using and the step that you are
76:55 - specifying to get closer for to evalua
76:57 - to
76:57 - false what are infinite
77:03 - Loops infinite Loops can occur in a for
77:05 - Loop while loop or do while loop this
77:07 - happens when the condition you define is
77:09 - always true this will lead to the code
77:10 - block being repeatedly executed without
77:12 - being terminated this will lead to your
77:14 - program crashing how can you prevent
77:16 - infinite
77:20 - Loops to prevent infinite Loops in your
77:22 - for Loop while loop or do while loop you
77:24 - need to make sure that there is a step
77:26 - condition that is continually being
77:27 - updated so that for every execution of
77:29 - the code block you are getting closer to
77:31 - the condition being
77:34 - terminated you have seen the for Loop
77:36 - many times which shows us how we can
77:38 - Loop and iterate over an array we also
77:39 - have a syntax that allows us to iterate
77:41 - over the keys of a JavaScript object
77:43 - once again a JavaScript object is a data
77:45 - type that allows us to specify key value
77:47 - pairs so now I can initialize the object
77:49 - con course sign to and object literal I
77:52 - can specify the key of name with the
77:54 - value of JavaScript for
77:57 - beginners comma then I can add duration
78:00 - 3 hours and sections 7 I ended with a
78:05 - semicolon now if I wanted to display
78:06 - each property or key of this object I
78:08 - would need to do the following
78:10 - console.log then I can access it through
78:13 - notation course. name I can also access
78:16 - the value through square bracket
78:18 - notation by do
78:20 - console.log then course square brackets
78:23 - and then as a string pass and
78:26 - duration and the last property
78:28 - console.log course.
78:31 - sections save
78:33 - it then I'll run in the panel node
78:36 - control flow.
78:38 - JS and this displays all the values now
78:41 - this is fine since we only have three
78:43 - properties but let's say this object had
78:44 - 30 properties then this process would be
78:46 - inefficient so we want to reduce our
78:48 - codes duplication and make it clean and
78:49 - easy to read by using a 4in loop so I
78:52 - can comment this out so the four in Loop
78:55 - is used with JavaScript objects to allow
78:57 - us to iterate over the JavaScript object
78:58 - and get access to the keys so if I do
79:01 - four and I can name it cons key in
79:05 - course so I can name this variable
79:07 - whatever I want and then we specify the
79:09 - object that we want to iterate over then
79:11 - I output it
79:13 - console.log of course and then using
79:16 - square bracket notation I will specify
79:18 - the key so then I output it and I get
79:21 - the same result
79:23 - [Music]
79:26 - what is the Forin Loop and when would
79:27 - you use
79:33 - it the foreign Loop is used to iterate
79:36 - through the keys of a JavaScript object
79:38 - you would use it when you want to
79:39 - efficiently iterate through the object
79:41 - and access its
79:44 - value in the case when we are simply
79:46 - looping over the elements of an array it
79:47 - can be bothersome to always have to
79:49 - write the traditional for Loop once
79:50 - again I'll show you full execution of
79:52 - that so I initialize an array with five
79:56 - elements and the traditional for
80:00 - Loop Lane index
80:03 - increments console. log and then we have
80:06 - numbers and we access it by its index
80:09 - with the bracket notation let's execute
80:11 - this clear it go up again to re execute
80:15 - each element of the array so this is a
80:16 - lot of syntax to write and in this case
80:18 - it's not needed because we are simply
80:20 - accessing the elements of the array we
80:22 - would need this in the case if we were
80:23 - using this index variable for some other
80:26 - use case but since we're not I can
80:28 - comment it out highlight it and do
80:29 - command for slash or control for slash
80:31 - if you're on windows so if we simply
80:33 - need to access the element we can use a
80:34 - different syntax called the four of
80:36 - syntax and this is used for when
80:38 - iterating over an array so once again we
80:41 - use the four keyword and I can say let
80:43 - element of
80:45 - numbers so in this case we use of and
80:48 - this iterates over the elements of the
80:50 - array now in this case I use the
80:52 - variable name element you can name this
80:53 - whatever you want and can call it
80:54 - numbers for example but I like naming an
80:56 - element and also I use the let keyword
81:00 - for this being a variable you could also
81:02 - have it be a con since we're not
81:03 - changing it I'll name it as let and then
81:06 - I'll console.log
81:08 - it clear this out and then iterate and
81:11 - get the same
81:13 - [Music]
81:16 - result what is the four of
81:22 - loop the four of loop is a special Tex
81:24 - in JavaScript that allows us to easily
81:27 - iterate over an array for each iteration
81:29 - we get access to the element you would
81:30 - use the four of loop over the
81:32 - traditional for Loop in the case when
81:34 - you don't need to use the index that you
81:36 - currently iterating
81:38 - on break and continue statements so when
81:41 - working with loops there may be specific
81:43 - conditions when we want to stop
81:44 - execution the break statement means to
81:46 - break out of the loops execution and we
81:48 - would use this to terminate the
81:49 - execution of a loop so this can be used
81:51 - for all the different Loops that we have
81:52 - covered so far which include the four
81:54 - Loop the while loop the do while loop
81:56 - the four in Loop and the four of loop
81:58 - let me show you an example of each for
81:59 - the four Loop we can say let I is assign
82:02 - to zero I is less than 10 and I
82:06 - increments now we can say if I we'll say
82:09 - if I is equal to five curly braces then
82:12 - we'll say break so this exits the loop
82:15 - when I is five so otherwise we want to
82:17 - console log it console. log I and let's
82:20 - execute it clear this out I'll go up and
82:23 - let's execute each of the expected
82:24 - values and stops execution once I is
82:27 - equal to 5 so I'll close this out and
82:29 - I'll commment it out command slash
82:31 - control slash now I'll show you the same
82:33 - process with a while loop so I can say
82:35 - let I is assign to zero while I is less
82:38 - than
82:40 - 10 if I is equal to 5 then we'll use
82:44 - break right exit the loop when it's
82:46 - equal to five otherwise console.
82:49 - log and since we're using a while loop
82:51 - we need to make sure that we increment I
82:53 - right we get it to where it stops
82:55 - execution so we don't get an infinite
82:57 - Loop so let's open up the panel again
82:59 - view appearance and panel and I'll clear
83:02 - it with command and K or control and K
83:04 - we'll go up with up arrow and execute it
83:06 - we get the same expected result now I'll
83:07 - continue showing you for the other Loops
83:09 - let's consider a do while loop so let's
83:11 - say let I assigned to
83:13 - zero now we use our do keyword and
83:16 - specify our code block within the curly
83:18 - braces we'll specify our condition so if
83:21 - I is equal to 5 strict equality and once
83:24 - again the break statement otherwise we
83:27 - console log I and we need to make sure
83:30 - that we increment I so we don't get an
83:32 - infinite Loop now we specify our
83:34 - condition after so while I is less than
83:36 - 10 we continue looping so open up our
83:39 - panel again clear it out same expected
83:42 - result right so let's do our for in the
83:45 - for in syntax is used with objects so I
83:48 - can say cons and I'll just call this
83:50 - object and I'll just specify on one line
83:52 - so we'll say the first first key is a
83:56 - and the value is one then we'll say b 2
84:00 - and c and three and I'll just add a
84:02 - semicolon at the end here now I can do
84:04 - for let key in
84:07 - object now I can name this whatever I
84:09 - want and I could also use a const if I
84:12 - wanted but I'm going to keep it a and I
84:14 - can check if the key is equal to B for
84:17 - example so in working with objects each
84:19 - of these keys in this case it would be a
84:21 - B and C are internally represented as
84:23 - strings so if the key is equal to B then
84:27 - I'll break out otherwise I want to
84:28 - console log it so I'll say console. log
84:32 - the object at that key so let's open up
84:36 - the panel and let's run
84:38 - it so here we see it executes the value
84:41 - of one which is the value associated
84:43 - with the key a so I'll close this out
84:45 - and comment it out our last one is our
84:48 - four of Loop and it's used for ital
84:50 - objects so this includes arrays and
84:53 - strings so I can say so I can to const
84:56 - array is equal to 1 2 3 4 and 5 and I'll
85:01 - say let element of
85:04 - array if element is equal to three
85:07 - restrict equality then I can break out
85:11 - otherwise I will console log
85:14 - it open up the panel and we'll execute
85:17 - it again so we get the values of 1 and
85:19 - two and once the element is equal to
85:21 - three then we stop execution so I will
85:23 - clear everything out let's remove
85:26 - everything now let's talk about the
85:28 - continu statement so the continu
85:29 - statement means that you want to skip
85:30 - the current iteration of the loop and
85:32 - proceed to the next iteration and once
85:34 - again this can be used for all the
85:35 - different Loops that we have considered
85:36 - so far and I'll show you an example for
85:38 - each so the repetition is good because
85:40 - it really drills the syntax into your
85:42 - memory so we'll say 4 I is equal to Z
85:45 - while I is less than 10 and I increments
85:48 - now we'll say if I is modul 2 equal to0
85:53 - so I'll explain what this means so the
85:55 - module operator which I covered earlier
85:58 - this finds the remainder of division so
86:00 - in this case the remainder of dividing
86:03 - by two if that is equal to zero this
86:04 - checks that if a element or if a value
86:07 - is even then in this case I will specify
86:10 - that I want to continue meaning that I
86:12 - want to skip this current iteration and
86:14 - move to the next one so then I will
86:16 - console log in the other case all right
86:18 - so another way to think of the continue
86:20 - statement you can think of it as if it
86:21 - were skip that's actually not a keyword
86:24 - in JavaScript but that's a way you can
86:26 - think about it to better understand its
86:27 - purpose skip the current iteration and
86:29 - move to the next one so I'll open up the
86:31 - panel and we'll execute it and so in
86:32 - this case we expect only odd numbers to
86:34 - be displayed since we're skipping over
86:36 - all the even numbers so once again only
86:39 - displays the odd numbers because we're
86:41 - using the module operator right which
86:43 - gets the remainder of the division so
86:44 - I'll comment this out now I'll show you
86:46 - the continue statement in the context of
86:48 - a while loop say let I is assigned to
86:50 - zero while I is less than 10 well I'll
86:54 - say I increments and if I modul 2 right
86:59 - so strict equality zero so if that is
87:01 - even then I want to skip to the next
87:04 - iteration otherwise I'll console log it
87:06 - console log I open up the panel and
87:10 - let's display it and it displays only
87:13 - the odd numbers as expected so I'll
87:15 - comment this out now let's consider a do
87:18 - while loop so I'll say let I side zero
87:21 - do curly braces I increment
87:25 - if I modul 2 Z then
87:30 - continue otherwise log it
87:34 - out and we specify our condition well I
87:36 - is less than 10 so I'm showing you the
87:38 - different way of doing it of using the
87:40 - continue statement for all the different
87:41 - Loops that we've covered so far right
87:43 - same result only displaying the odd
87:45 - values now in the context of the four in
87:48 - Loop once again 4N is used with objects
87:51 - I can specify cons object the curly
87:53 - braces the key of A maps to the value of
87:57 - one then B and two let's say C and 3 and
88:02 - d and four and I'll add a semicolon here
88:04 - and I'll iterate over it so we have
88:06 - four let key in object now in this case
88:11 - if the object the key right so now we're
88:15 - checking the
88:16 - value mod 2 Z well in this case we'll
88:20 - want to continue it right so we want to
88:22 - skip over all the even numbers
88:25 - otherwise we'll
88:26 - console.log the object at the key so
88:29 - we'll only display the odd numbers in
88:31 - this case so open up the panel run it
88:34 - again only the odd values in our object
88:36 - we'll comment it out and our last
88:38 - example is four of which is used for
88:40 - iterating over objects like arrays and
88:42 - strings I'll specify con array is equal
88:45 - to 1 2 3 4 and 5 then we'll say let
88:48 - element of r r array now if the element
88:53 - mod 2
88:55 - is equal to Z right the remainder of the
88:57 - division is equal to Z then we know that
88:59 - it's even and we want to continue
89:01 - meaning that we want to skip over that
89:02 - otherwise we'll log it out log of
89:05 - element so let's open up the panel and
89:07 - we'll run
89:09 - it only the odd numbers in this case so
89:12 - you can use the continue keyword like a
89:14 - skip keyword and it skips over the
89:16 - current iteration and goes to the next
89:18 - iteration of the
89:19 - [Music]
89:21 - loop what is the break keyword used for
89:29 - the break keyword is used when dealing
89:31 - with control flow in for Loops or in
89:33 - switch case statements so when
89:35 - JavaScript encounters the brake
89:36 - statement within one of these structures
89:38 - it will stop the execution for that
89:40 - Associated for Loop or switch case
89:43 - statement what is the continue keyword
89:45 - used
89:50 - for the continue keyword can be used
89:53 - within for Loop Loops or while Loops so
89:55 - when JavaScript Encounters this keyword
89:56 - it will skip the current iteration of
89:58 - that for Loop and Skip on to the next
90:03 - iteration Implement a function that
90:05 - accepts two numbers and Returns the
90:07 - maximum
90:18 - number so we'll create our function with
90:20 - the function keyword and we'll name it
90:22 - Max num now we need to take in two
90:25 - parameter variables so I'll say num one
90:28 - and num two on our curly braces and then
90:31 - we had a return statement now we will
90:34 - compare these numbers so I can say num
90:36 - one and I can say greater than equal to
90:39 - num two in which case we want to return
90:43 - the maximum value which would be num one
90:46 - or num two so I'm utilizing a tary
90:49 - operator here so I'll test it say I'll
90:52 - console.log
90:54 - of Max num and I'll say two and one so
90:58 - we expect two to be locked to the
91:01 - console so execute it and the maximum
91:04 - value is
91:05 - [Music]
91:07 - displayed Implement a function to accept
91:09 - a number as a parameter then return the
91:11 - string fizzbuzz if that number is
91:13 - divisible by three and five or return
91:15 - the string Fizz if it's only divisible
91:18 - by three and not five or return the
91:20 - string buzz if it's only divisible by
91:22 - five now if the number is not divisible
91:23 - by three or five then just return the
91:25 - original
91:32 - number the next exercise is a common
91:34 - problem asked to Junior developers to
91:36 - weed out candidates that don't
91:37 - understand the fundamentals of
91:38 - programming so I will discuss the
91:39 - problem so the problem is known as
91:41 - fizzbuzz so it takes in a number and if
91:43 - a number is divisible by three and five
91:46 - then you want to return the string
91:48 - fizzbuzz now if the number is divisible
91:50 - by three but not divisible by five then
91:53 - you want to return Fizz if the number is
91:55 - divisible by five and not divisible by
91:57 - three then you want to return Buzz
91:59 - otherwise you want to return the
92:01 - original input so now that You' Tred to
92:02 - implement this problem I will go through
92:04 - and implement this solution for you
92:05 - first we want to use the keyword
92:07 - function we'll name it fizzbuzz and it
92:10 - takes in a parameter being a number so
92:13 - I'll call it
92:14 - number have our curly braces so now we
92:17 - want to see if the number is divisible
92:19 - by three and five so we have a
92:21 - conditional statement we have if the
92:23 - number is divisible by three right so we
92:26 - use the modular operator if the
92:28 - remainder of that division is zero and
92:31 - if the
92:32 - number is divisible by five then in that
92:35 - case we want to return fizzbuzz I'll do
92:38 - single quotes
92:40 - fbuds El if the number is divisible by
92:45 - three then in that case we want to
92:47 - return
92:49 - fiz otherwise if the number is divisible
92:52 - by five
92:55 - then we will return
92:57 - buzz in the default case we will simply
93:01 - return the number input so I'll do
93:05 - console.log bis buzz and I'll test all
93:08 - conditions so first we'll do a value
93:10 - that is divisible by 3 and five we can
93:12 - do 15 so we'll log that out so we're
93:16 - expecting FS buuz to be the result we
93:19 - get the expected result so now we'll say
93:22 - if it's 9 then we expect
93:25 - Fizz now in the case when it's 10 then
93:28 - we expect
93:29 - buzz and let's say if it's seven then we
93:33 - expect
93:36 - [Music]
93:38 - seven so for the next exercise I want
93:40 - you to create a function that takes in
93:42 - an array as a parameter and iterates
93:44 - through all the elements of the array
93:45 - displaying all of the even
93:52 - numbers so Implement our function we'll
93:55 - call it function and I'll call it
93:57 - display even
93:59 - numbers and I'll just call it an array
94:01 - as name of the parameter variable so now
94:03 - what I want to do is utilizing a for
94:05 - Loop so since it's an array I can use
94:07 - four and I'll say cons element or call
94:11 - it number number of array then I can
94:15 - check if the
94:17 - number is divisible by two by using the
94:20 - module operator then in that case I'll
94:23 - con I'll log it simply call display even
94:26 - numbers and invoke it passing in an
94:28 - array so I'll say 1 2 3 4 5 6 7 8 9 and
94:33 - 10 so let's output it in the panel go up
94:37 - and here we see only the even values are
94:39 - outputed now I can copy
94:41 - this and if I already say display odd
94:44 - numbers then the only change I would
94:46 - need to
94:48 - do would be to say if this is not equal
94:50 - to zero by using the not equal operator
94:54 - so in this case if I do to display odd
94:56 - numbers then only the odd numbers would
94:58 - be
94:58 - displayed so I can go up and only the
95:01 - odd values are logged to the
95:05 - console control flow refers to the order
95:08 - in which individual statements or
95:09 - function calls are executed in a program
95:11 - it determines the logical progression of
95:13 - a program based on conditions or Loops
95:15 - guiding the program to make decisions or
95:17 - repeat operations so in this section we
95:19 - covered if and Al if statements to
95:21 - conditionally determine which code to
95:22 - write so if a condition is true then
95:24 - execute the code within the specified
95:25 - code block within the curly braces we
95:27 - also have switch case statements to
95:29 - determine which code to execute based on
95:30 - equality we covered the traditional for
95:32 - Loop while Loops do well Loops the
95:34 - potential problem of infinite Loops
95:36 - which we want to avoid we covered four
95:37 - in Loops for iterating over the keys of
95:39 - a JavaScript object we covered the four
95:41 - of loop for iterating over an array we
95:43 - also have the break statement to
95:44 - terminate a loop or switch case
95:45 - statement and the continue statement
95:47 - which skips the current iteration and
95:48 - moves on to the next iteration of a loop
95:50 - great job on completing the section and
95:52 - with practice all the syntax will become
95:53 - come second
95:54 - [Music]
95:56 - nature so you know that objects are a
95:58 - way to store key value pairs they allow
96:00 - us to group together State and behavior
96:02 - that's highly related the benefit is
96:04 - that we can group together highly
96:05 - related variables and even group
96:06 - functions within it so using the object
96:08 - literal syntax I'll say const dog our
96:11 - curly braces creates an object literal
96:13 - now I can add a key so I'll say name
96:16 - with the value Max I'll say breed which
96:19 - is doxin age a five
96:24 - weight and
96:25 - pounds is 12 so far we've only stored
96:28 - key value pairs representing properties
96:30 - but we can also add our own function so
96:32 - let's say
96:33 - eat and we'll say a function so this is
96:37 - an anonymous function here and I'll say
96:40 - console.log tromp so that's one way of
96:43 - adding a function now there's another
96:44 - syntax we can just add the name of the
96:47 - method
96:49 - console.log and so when we have a
96:51 - function within an object we call it and
96:53 - Method so here we are encapsulating
96:55 - State and behavior so encapsulation
96:57 - involves grouping together data and the
96:59 - methods that manipulate the data into a
97:01 - single unit while hiding or abstracting
97:03 - away the internal details from outside
97:05 - interference or
97:07 - misuse what is the purpose of JavaScript
97:13 - objects JavaScript objects store key
97:15 - value pairs their purpose is to store
97:17 - State and behavior state is represented
97:19 - by properties and behavior is
97:21 - represented by functions within the
97:23 - object when when we specify a function
97:24 - within an object we call it a
97:27 - [Music]
97:28 - method so if we were to create another
97:30 - object with the same properties and
97:32 - methods as the dog object we would have
97:34 - to copy and paste so I'll show you an
97:35 - example of that let's say I copy all
97:37 - this and paste it here and let's say I
97:39 - call it another dog and the name let's
97:42 - give it a name of Marley say the breed
97:44 - is a chocolate lab the age let's say is
97:48 - three and say the weight and pounds is
97:51 - 60 so this leads to code duplication
97:53 - which becomes hard to maintain once our
97:54 - application begins to grow so I'm going
97:56 - to comment this out so far we've been
97:58 - using functions to perform some
98:00 - operation and return A Primitive value
98:02 - that value being a number a string or a
98:04 - bulling value but we can also use
98:05 - functions to return an object so here's
98:07 - an example of how we can do that to
98:09 - reduce our code duplication and our need
98:10 - to copy and paste create a new function
98:12 - and I'll call it get dog now I'll
98:15 - specify parameters which allow me to
98:17 - customize the properties for a dog
98:19 - object so I'll call it name breed the
98:22 - age and the weight and pounds so what
98:25 - I'll do here is I'll return an object
98:26 - literal with the same properties as this
98:29 - dog object so I'll give it a name so the
98:32 - key is name and the value is the
98:35 - parameter variable right the argument
98:36 - that we pass in have the breed we have
98:39 - the age the weight and pounds and then
98:42 - the same
98:44 - methods so you can use other syntax
98:46 - actually just to clean it
98:48 - up cons.
98:51 - log and the last method
98:56 - l so we have now created a function
98:58 - where by passing in the arguments to
99:00 - this parameter variables will allow us
99:02 - to get a dog object so if we wanted to
99:04 - create this exact object I can say move
99:07 - back up const I'll call it another dog
99:10 - equals get dog we'll pass in the name
99:15 - Marley the breed chocolate lab AG three
99:20 - and 60 so rather than having to
99:23 - duplicate all this code and copy and
99:24 - paste it we can instead get that same
99:26 - functionality all in one line by using a
99:28 - reusable function one more thing I want
99:30 - to show we see that we do have
99:32 - duplication here in our function because
99:34 - we are using the same key and value
99:36 - which have the same exact name so when
99:38 - you have this in JavaScript we have
99:40 - syntactic sugar which allows us to clean
99:42 - up our code so JavaScript is able to
99:43 - look at this and know that the key and
99:45 - the value have the same
99:48 - name so this only works when these
99:51 - values the key and this parameter ver
99:53 - that Supply to it is the same so let's
99:55 - output it out console.log I call it
99:59 - another dog so outputting that object I
100:01 - would do node objects. js and I can
100:04 - output and see the properties and the
100:08 - method what are Factory
100:17 - functions Factory functions provide an
100:19 - efficient way for us to create a new
100:21 - object now the name of the function will
100:22 - use camel case notation and it can
100:24 - accept parameter variables these
100:25 - parameter variables can help customize
100:27 - the values of the object being returned
100:29 - the benefit is that it reduces code
100:30 - duplication and the need to copy and
100:32 - [Music]
100:34 - paste so we know that the object literal
100:37 - syntax using curly braces creates one
100:39 - object and that we can use Factory
100:40 - functions to easily create multiple
100:42 - objects Factory functions is not the
100:44 - common way of achieving this rather we
100:46 - use Constructor functions the purpose of
100:47 - the Constructor function is to construct
100:49 - the initial state of an object when
100:51 - creating a Constructor function we use p
100:53 - SC notation whereas we would use camel
100:54 - case notation for variables and function
100:57 - names Constructor functions use a
100:58 - special keyword called this which
101:00 - references the object that's calling
101:02 - this code so when you see the keyword
101:03 - this you can think of it as this current
101:06 - object so the naming convention for
101:07 - Constructor functions is to have the
101:09 - name of it be a noun rather than a verb
101:11 - so Show an example of a Constructor
101:12 - function use the function keyword and we
101:14 - name it a noun so I'll name it dog I'll
101:17 - specify the parameter variables so name
101:20 - greed age and weight and pounds so if
101:23 - the differences above we have the
101:25 - factory function which uses a verb and
101:27 - camel case notation and on the bottom we
101:28 - use a noun and Pascal notation so
101:31 - internally when using a Constructor
101:33 - function there's a special keyword
101:34 - called this which is assigned to an
101:36 - object literal the curly braces and this
101:38 - is done internally and implicitly so we
101:40 - don't know how to explicitly write this
101:42 - out I just want to show you a visual
101:43 - example of it and then we would add
101:45 - properties to this this keyword so I'll
101:49 - say this.name is equal to name this.
101:51 - breed is equal to breed
101:54 - this. age is age and this. weight and
101:56 - pounds is weight and pounds so what we
101:59 - were doing we were assigning this
102:01 - current object specifying a key and
102:03 - assigning it to a value with this value
102:05 - is actually the argument being passed
102:07 - then we can specify our methods I'll do
102:09 - this. e and assign it to an anonymous
102:11 - function the function keyword and then
102:14 - I'll just copy this console log and then
102:17 - our last method do this. bar is assign
102:20 - to an anonymous function and I'll just
102:22 - copy this console log
102:24 - and this will implicitly return the this
102:26 - keyword where this keyword represents
102:29 - this current object so this convention
102:31 - of making an uppercase and using Pascal
102:33 - notation tells other programmers that
102:34 - this is a Constructor function and it's
102:36 - a common convention using JavaScript so
102:38 - to use a Constructor function we utilize
102:39 - a special keyword called new I'll scroll
102:41 - down and show an example of that I'll
102:42 - say const another dog as the name of the
102:45 - variable and I'll assign that to new dog
102:49 - then we pass in our arguments I'll
102:51 - specify Marley as the name of the dog
102:54 - it's a lab we'll say 3 years old and 60
102:58 - lb so we say that we instantiated a new
103:00 - dog object and the variable name another
103:02 - dog references this new object that we
103:04 - just created that we just instantiated
103:06 - so let's talk more about the new keyword
103:08 - the new keyword is syntactic sugar which
103:10 - means it provides a modern and clean
103:11 - syntax and does three things under the
103:13 - hood when we use the new keyword with
103:15 - the Constructor function it creates an
103:17 - empty JavaScript object it then sets to
103:19 - this keyword to point to this empty
103:20 - object in memory and then it returns
103:22 - this keyword and does so implicitly so
103:25 - to recap the main purpose of Constructor
103:27 - functions is to define a function that
103:28 - will initialize an object with an
103:30 - initial State and this initial State can
103:32 - be customized based on the arguments
103:33 - that you pass to the parameter variables
103:36 - so now I'll log out this object I'll say
103:39 - console.log another
103:41 - dog and I'll run this and here we see it
103:44 - outputs our
103:46 - [Music]
103:47 - object what are Constructor functions
103:55 - Constructor functions are used to
103:57 - instantiate objects in JavaScript we
103:59 - would name the function using Pascal
104:01 - notation and use a noun for the name
104:03 - then for setting the key value pairs we
104:05 - will use the this keyword and within it
104:07 - we can set the properties and the
104:08 - methods of an
104:11 - object objects in JavaScript are Dynamic
104:14 - meaning that we can add or remove
104:16 - Properties or methods at any time so for
104:18 - example if we have con person is
104:21 - assigned to the object literal key of
104:23 - name and the value of Steven end it with
104:25 - a semicolon here I'll just console log
104:26 - that run it again so we just see that
104:29 - object literal with the expected
104:30 - property now we can also add properties
104:32 - on the fly so if I do person and let's
104:35 - say if I use dot notation and I can just
104:37 - say any key that I want can say favorite
104:40 - food and assign that to the string tacos
104:43 - then I'll just copy this and I'll log it
104:44 - again and this will comment the first
104:46 - console log out and let's run it
104:48 - again so here we see we have added this
104:51 - property of favorite food on on the fly
104:53 - so you can update objects dynamically we
104:55 - could also update it using bracket
104:57 - notation say person and I'll say
105:00 - favorite ice cream and I'll assign that
105:02 - to CH just to show a different Syntax
105:05 - for you to add a property here I'll log
105:08 - it out coma this one out and here we see
105:11 - added that property now we can also
105:12 - delete properties and I would delete
105:14 - properties using the delete keyword so
105:16 - I'll say delete person do favorite ice
105:19 - cream and if I were to console log it
105:22 - I'll just copy and paste it here then I
105:23 - expect the object to have the properties
105:25 - of the name and the favorite food and we
105:28 - get it as expected so comment this
105:30 - console log now we could also add
105:32 - methods on the fly so I can say person.
105:34 - e as the key and just assign it to
105:36 - Anonymous function and this was just
105:38 - console log say start eating for example
105:41 - then I can invoke it I can just say
105:43 - person. e then the parentheses to invoke
105:46 - and call that method let's run it and we
105:48 - get the expected output of start eating
105:50 - which we defined in this function so
105:52 - notice that when we created this object
105:53 - literal we use the const keyword now in
105:56 - this instance since we assigning it to a
105:58 - complex data type being an object data
106:00 - type that's stores multiple key value
106:02 - pairs using the con keyword means that
106:04 - we cannot assign it to another value but
106:06 - we can still change and mutate the
106:07 - properties and methods within that
106:09 - object literal to short an example that
106:11 - I can say person and assign that to an
106:12 - empty object in object literal and let's
106:14 - run it and here we get an error because
106:17 - we cannot change the assignment to a
106:19 - constant variable after we've already
106:20 - initialized it
106:25 - explain in your own words how are
106:26 - objects
106:31 - Dynamic objects in JavaScript are
106:33 - dynamic because you can change and
106:35 - mutate the properties and methods of the
106:37 - object after it has been
106:39 - [Music]
106:40 - initialized every object in JavaScript
106:43 - has a Constructor The Constructor
106:44 - function is the one used to construct an
106:46 - object and it is called implicitly
106:48 - whenever we create a new object we use
106:50 - the term instantiate whenever we create
106:52 - a new object as in we instantiated a new
106:54 - object so we have our existing object
106:56 - with object literal syntax and person
106:58 - references this object now there is a
106:59 - built-in property for all objects called
107:01 - Constructor which we can access either
107:03 - through dot notation or bracket notation
107:05 - so I'll console log that
107:07 - console.log say person do Constructor
107:10 - output in and here we see it references
107:12 - a Constructor function I'll comment both
107:14 - these out so when we do let new object
107:17 - and assign that to an empty object
107:18 - literal with these curly braces
107:20 - internally JavaScript sees this as if
107:23 - were to do let new object assigned to
107:26 - the new keyword and then object comment
107:28 - this out so these two lines the one
107:30 - above and the one beneath it mean the
107:32 - same thing however this first syntax
107:34 - which use the object literal syntax is
107:36 - syntactic sugar essentially this means
107:38 - it's a shorter way to write the same
107:39 - code so in JavaScript we also have new
107:41 - string as in the string object but
107:44 - instead we use string literals so for
107:46 - example I did my name now we also have
107:49 - new Boolean but we use true and false
107:52 - instead for bulling literals we also
107:54 - have a new
107:55 - number but we just use numbers as a
107:57 - number literal so every object has a
107:59 - Constructor property which refers to the
108:01 - Constructor function used to create that
108:05 - object what is the Constructor
108:12 - property The Constructor property is a
108:15 - property that exists for all objects in
108:17 - JavaScript you can access it with either
108:18 - the dot notation or bracket notation and
108:20 - it references the Constructor function
108:22 - used to instantiate and create that
108:25 - [Music]
108:27 - object in JavaScript unlike other
108:29 - programing languages functions are
108:31 - objects so for this function that I'll
108:32 - Define here I'll name it function add
108:35 - and it'll accept two parameters num one
108:37 - and num two and then I'll just return
108:40 - the sum of these values so this function
108:42 - here is actually an object in JavaScript
108:45 - so it is an object in memory I'll show
108:46 - you an example of that I can actually
108:48 - assign it to another value so I'll say
108:50 - const n just the name of this variable
108:52 - and I'll assign that to the name of this
108:55 - function so now n references this object
108:58 - in memory it references this function I
109:00 - can actually call and invoke this
109:01 - function and I'll show you an example of
109:02 - that I'll do console.log and I'll say n
109:05 - and I'll invoke it and I'll pass in two
109:07 - arguments I'll just say two and two now
109:09 - I'll log it out up arrow and here you
109:11 - see the value four is expected so I'll
109:13 - comment this out so this function that
109:14 - defined add has members meaning that it
109:17 - has properties and methods here I'll
109:19 - console log and I'll say add and this
109:22 - has a prop property length which defines
109:24 - the number of parameters that this
109:26 - function accepts I'll loog that out and
109:28 - I expect two and we get it as expected
109:30 - so I'll comment all this out and I will
109:32 - Define a Constructor function I'll say
109:34 - function and then using Pascal notation
109:36 - so the first letter is capitalize I'll
109:38 - name it programmer and it will accept
109:41 - one parameter I'll just say name so we
109:43 - know to use the this keyword which means
109:45 - this current object so I'll say this.
109:47 - name and I'll assign it and I'll also
109:50 - Define a method within this Constructor
109:52 - function I'll say this. writes code or
109:54 - write code is assigned to an anonymous
109:56 - function and I'll say
109:58 - console.log and I'll say code in
110:01 - JavaScript end it with a semicolon so
110:03 - this Constructor function is an object
110:05 - in memory I can console.log and I'll say
110:07 - programmer.
110:09 - l and we log it out and we see it
110:11 - accepts one parameter I'll just copy one
110:13 - more time and I'll say
110:14 - Constructor log that out so here this
110:17 - references the Constructor function I'll
110:19 - show you a different syntax just to
110:20 - further demonstrate how functions are
110:21 - objects in Javas script I'll comment
110:23 - this out command for slash or control
110:25 - slash if you're on Windows and I'll say
110:26 - const programmer and assign it to New
110:31 - function I'll specify my parameter name
110:34 - it name and then I'll use back
110:37 - ticks as the second argument and I'll
110:39 - Define this.name is assigned to name and
110:42 - this do write code is assigned to the
110:44 - anonymous function I'll just copy this
110:46 - console log here so here I see I'm using
110:50 - the new function syntax to instantiate a
110:53 - function object assigning it to this
110:55 - value so then I can instantiate it say
110:57 - cons new programmer then I'll use the
111:00 - new keyword to call the Constructor
111:02 - function say new programmer and pass in
111:05 - the argument of my name end it with the
111:07 - semi and then I'll say new programmer
111:09 - and call the method write code so let's
111:11 - log that out and we get the output as
111:14 - [Music]
111:16 - expected explain how functions are
111:18 - objects in JavaScript
111:25 - internally functions are represented as
111:27 - objects in JavaScript meaning that they
111:29 - have properties and
111:32 - methods so you know that we have eight
111:34 - different data types in JavaScript which
111:36 - include the primitive data types which
111:38 - are number string Boolean null undefined
111:42 - symbol and big int we also have the
111:45 - complex data type better known as object
111:47 - data types so arrays and functions also
111:49 - fall into the object category the reason
111:51 - we differentiate these data types is
111:53 - because of how they are allocated in
111:54 - memory so let's consider the perimeter
111:56 - data type first if I say let a and I
111:58 - initialize that to 10 let's say let B
112:00 - and I initialize that to be assigned to
112:02 - the variable a now if I reassign the
112:04 - value a let's say if I assign that to
112:06 - the value 20 let's console log both of
112:08 - them and console. log V open up the
112:11 - panel and we'll run it so here we see
112:14 - the output different values so both A
112:16 - and B are assigned to a number which is
112:18 - a primitive data type and when we log
112:20 - them out we see that they are two
112:21 - independent variables meaning that that
112:22 - they refer to different memory addresses
112:24 - when we assign a variable to another
112:26 - variable which holds a primitive value
112:28 - then that primitive value will be passed
112:29 - by copy so essentially this would be the
112:31 - same as doing let B assigned to the
112:33 - value of 10 so if this is your first
112:34 - time being introduced to this concept
112:36 - this may seem overwhelming at first but
112:37 - this will become second nature over time
112:39 - to summarize what I've been saying just
112:40 - remember this primitive values are
112:42 - passed by copy not by reference so I'll
112:44 - clear this so let's say if I initialize
112:46 - let a is assigned to the object literal
112:47 - which has the property value 20 and I'll
112:49 - say let B is assigned to a so B is
112:52 - assigned to this reference variable
112:54 - which is assigned to this object so let
112:55 - me change this value so I'll say a.
112:58 - value and I'll assign that to the value
113:00 - 100 so now let's output both of them so
113:02 - I say console.log I say A and
113:05 - console.log B let's see in the panel so
113:08 - here you see when I log them out they
113:09 - have the same value I updated the value
113:11 - of a but I did not update the value of B
113:13 - and the reason why they outputed the
113:14 - same value is because they are both
113:16 - referencing the same object and memory
113:17 - they're both referencing the same memory
113:19 - address so to summarize Primitives are
113:20 - copied by their value and object are
113:22 - copied by their reference this is an
113:24 - important concept and it will make more
113:25 - sense with practice and this concept
113:26 - also applies to other programming
113:30 - languages what are primitive values and
113:32 - what are they passed
113:36 - by primitive values refer to simple
113:38 - values such as string number booleans
113:41 - and they are passed by copy what are
113:43 - object values and what are they passed
113:47 - by object values refers to key value
113:50 - pairs this also includes arrays and they
113:52 - are passed by
113:55 - reference so we've covered the different
113:57 - for Loops we've covered the four of loop
113:59 - which is used to iterate over an array
114:01 - we have the four in Loop which is used
114:02 - to iterate over the keys of an object
114:04 - and I'll give you a reminder of both of
114:05 - those so first I'll create I'll say let
114:07 - numbers and assign that to an array of 1
114:09 - 2 3 4 and five and to it it over it I'll
114:12 - use four I'll say con elements of
114:14 - numbers now once again I could name this
114:16 - variable whatever I want but I'm naming
114:18 - elements just to demonstrate that it's
114:19 - iterates over the elements of the array
114:21 - then I'll do log of elements let's log
114:25 - that out with node objects. js and this
114:28 - outputs all the elements in the array so
114:30 - I comment this out then I'll create an
114:31 - object say cons dog is assigned to the
114:33 - curly braces name Max I'll say age is
114:38 - five and I'll say I color is blue I'll
114:40 - end it with the semicon then I'll say
114:42 - four cons key in dog so the four in Lube
114:46 - will iterate over the keys of an object
114:49 - so I'll say console.log dog and using
114:50 - square bracket notation I'll use the key
114:53 - to iterate the values let's output it
114:56 - and we get the expected result comment
114:58 - this out so we have another Syntax for
115:00 - enumerating over the keys and the values
115:02 - of an object I'll store the values here
115:04 - I'll say const and I'll name it keys and
115:06 - we can use object. keys and pass in the
115:10 - name of the object this case it's dog so
115:12 - object is a built-in class in JavaScript
115:14 - and it has properties and methods once
115:16 - again methods are just functions defined
115:18 - within an object so this returns all the
115:20 - keys of the object as an array a console
115:22 - Lo
115:23 - console.log
115:25 - keys so this outputs all the keys of the
115:29 - object comment this out now we also have
115:31 - object. values in order to get all these
115:33 - values stored as an array so I can say
115:35 - const values is equal to object. values
115:40 - of Doc let's console.log that and output
115:43 - it now we get all of the values of this
115:46 - object stored as an array we could also
115:48 - get the properties so the key value
115:50 - pairs each stored as an element in the
115:52 - array to show you that I'll say cons and
115:54 - I'll call it entries equal to object.
115:57 - entries and pass in the name of that
115:59 - object let's console log
116:01 - that
116:03 - entries we'll output it so here we see
116:07 - the key value pairs has been stored as
116:09 - an element in the array so essentially
116:11 - this is a nested array so this provides
116:13 - another syntax to accomplish the same
116:14 - thing which is enumerating over an
116:16 - object now to show you how we can use
116:18 - these methods to iterate over the values
116:20 - I'll show you an example let's say four
116:21 - and I will say const key of object.
116:27 - keys fast and dog I'm using four of
116:30 - because we are iterating over an array
116:31 - then I can just copy and paste this to
116:34 - key or output
116:36 - that so once again this iterates over
116:38 - the array and comment that out then I'll
116:40 - say four const value of object. values
116:45 - the name of the object and let output
116:49 - that this outputs all the values and
116:52 - then we'll do our entries so I can say
116:53 - four const entry of object. entries pass
116:59 - in the name of the object console.log of
117:03 - entry and we'll output it so here we see
117:05 - the key value pairs displayed as an
117:08 - array and this particular syntax may
117:10 - come in handy when doing programming
117:11 - interviews during cases when you need to
117:13 - enumerate over an
117:16 - object how can you enumerate over the
117:19 - properties of an object
117:26 - there are different ways to enumerate
117:28 - over the properties of an object one way
117:29 - is you can use the fourin loop iterate
117:31 - over the keys of an object we can also
117:33 - use the built-in object class for
117:35 - example iterating over the keys with
117:37 - object. keys enumerating over the values
117:39 - with object. values and enumerating over
117:41 - the properties with object.
117:43 - [Music]
117:45 - entries so we know that if we have two
117:47 - variables I'll say let a is assigned to
117:49 - the object literal value of 10 I'll say
117:52 - let B is assigned to a now if I were to
117:54 - update one of the variables we know that
117:56 - since they both reference the same
117:58 - object if I change one it will also
118:00 - affect the other variable console.log a
118:02 - and console. log B and since they both
118:04 - reference the same object they will both
118:06 - have a value of 20 so I run in the panel
118:08 - so here they display the same value as
118:10 - they both reference the same object now
118:12 - if we wanted to have it the case where
118:13 - if we change the value of one of these
118:15 - variables it doesn't affect the other
118:16 - then we would need to have it be two
118:18 - independent variables and that could be
118:19 - accomplished by creating a clone of an
118:21 - object so we know that objects are
118:23 - passed by reference so we need to use a
118:25 - built-in method called object. assign so
118:27 - instead of saying let B is assigned to a
118:29 - I'll initialize it to an object literal
118:31 - then before I assign this value I will
118:33 - do object assign first I will pass the
118:36 - target object this is the object that I
118:38 - want to copy to so in this case it would
118:40 - be B and then I provide one or more
118:41 - Source objects in which I want to copy
118:43 - the properties and methods to the Target
118:45 - object in this case it is the variable a
118:47 - so all the properties and methods of a
118:49 - will be copied to B and it will create
118:51 - two independent Vari
118:52 - so B will now have a clone of the object
118:54 - that a references so here I'll save this
118:56 - and I'll run it so here you see they
118:58 - reference two different objects and they
119:00 - have different values changing one does
119:02 - not affect the other now we also have
119:04 - another syntax that allows us to
119:05 - accomplish this known as the spread
119:07 - operator it uses three dots as in an
119:09 - ellipsis and this will create a copy of
119:11 - the object so instead of having to do
119:13 - object. assign when I initialize B I can
119:15 - use three dots dot dot dot and then the
119:19 - object that I want to clone in this case
119:21 - it' be a so this will create two
119:22 - independent objects so they are not
119:24 - referencing the same object in memory
119:26 - open up the panel and we'll get the same
119:30 - result how would you make a clone of an
119:38 - object in JavaScript you can make a
119:41 - clone of an object by using object.
119:43 - assign for the first argument you would
119:44 - pass the target object then you can pass
119:46 - in one or more Source objects you can
119:48 - also use a more modern syntax known as
119:51 - the spread operator in order to copy the
119:53 - properties and methods to a Target
119:54 - object by the use of three dots before
119:57 - the variable that references the
120:01 - object in programming languages like C++
120:04 - when you create an object you have to
120:05 - allocate memory and deallocate it but in
120:07 - programming languages such as JavaScript
120:09 - C and Java we don't have this concept so
120:12 - you don't have to explicitly deallocate
120:14 - memory the JavaScript engine has a
120:15 - garbage collector meaning that it will
120:16 - self-manage itself and find the
120:18 - variables and objects that are no longer
120:20 - being used in our program and it will
120:22 - intelligently free up that memory as
120:23 - JavaScript developers we don't have to
120:24 - worry about allocating and deallocating
120:26 - memory for our
120:30 - objects in JavaScript we have a built-in
120:32 - class called math this has static helper
120:34 - methods to help us do mathematical
120:36 - calculations and is often utilized in
120:38 - programming interviews it has many
120:39 - methods so don't worry about memorizing
120:40 - it rather refer to developer.
120:42 - mozilla.org search for a math and click
120:45 - the first
120:46 - recommendation then you can read the
120:48 - documentation and view the various
120:49 - methods that it contains here I will
120:51 - show you the most commonly used ones
120:53 - I'll open up the panel and I'll type in
120:54 - node so when working with decimal
120:57 - numbers I can use math. round and pass
121:00 - in
121:01 - 3.14 and this will round the number
121:03 - likewise if I did math that round say
121:06 - 3.6 and it will round up now if I always
121:08 - want to round down I can use math. floor
121:12 - let's say 4.6 if I always want to round
121:15 - up I can do math. ceiling say I do 4.2
121:18 - now to find the maximum number I can do
121:21 - math. Max and I can pass in one and two
121:24 - I could also add in more arguments to
121:26 - say if I 1 2 3 4 and five so it accepts
121:30 - more than just two arguments likewise I
121:32 - have math. Min just say if I do 1 two
121:35 - and three we could also raise to the
121:36 - power of so I can say
121:38 - math. the base number say if I make it
121:41 - two and let's just say if it's cubed
121:43 - then I can perform that I can do math.
121:45 - square root say 25 so I'll clear this
121:49 - out now one of the most useful built-in
121:50 - methods is the random method we can do
121:53 - math. random so this will return a
121:55 - number between 0 and 1 as a decimal
121:57 - value now if I want to return a random
121:59 - number between a range then I need to
122:01 - perform it differently let's say if I do
122:03 - let Min assign that to one and I say let
122:06 - Max equal to 10 now if I want to return
122:08 - a random number I can say cons random
122:10 - number then I'll assign that to math.
122:14 - random times the max minus the Min plus
122:19 - the minimum so this will return return a
122:21 - number between 1 and 10 and if I wanted
122:23 - to always be an integer value then I
122:25 - would do math. round and wrap it in
122:28 - parentheses so I'll console Lo this
122:30 - value console.log random num and this
122:33 - will generate a random number between
122:34 - that range I just run node node objects.
122:37 - js if I ran it again so don't worry
122:40 - about memorizing these these will come
122:41 - second nature over time I just wanted to
122:43 - introduce you to the built-in methods
122:45 - that you have access
122:48 - to what are some of the methods that the
122:50 - built-in math class has
122:56 - some of the methods that we covered
122:57 - include math. floor math. round math.
123:00 - seal math. Max math. Min square root
123:03 - math. power and math. random how would
123:05 - you generate a random number between 1
123:07 - and
123:11 - 100 this L of code represents the
123:14 - formula in order to create a random
123:16 - number between a minimum number and a
123:17 - maximum
123:20 - number so when jaas script we have two
123:22 - kinds of strings one way is the string
123:24 - literal through the use of single quotes
123:26 - double quotes or back ticks so for
123:28 - example if I just do CL name and assign
123:31 - it to a name a console log I'll say type
123:34 - of name when I output it I'll see that
123:37 - it is a string data type now I can also
123:39 - make a string using the string object so
123:41 - I can say const I'll call it another
123:44 - name assign that to put the new keyword
123:47 - which calls the Constructor of string I
123:49 - can pass an argument here I'll just say
123:51 - Joe as the name now if I console log the
123:53 - type I'll see that it is an object
123:56 - another name output it and we see this
123:59 - value is an object data type so I'll
124:01 - comment this out so with this variable
124:03 - that is assigned to this string literal
124:05 - we can access the methods of strings
124:07 - using dot notation or bracket notation
124:09 - and the JavaScript engine will
124:11 - internally wrap that string literal with
124:13 - the string object so there are built-in
124:15 - methods that allow us to operate and
124:17 - manipulate strings in this video I'll
124:19 - show you some of the most commonly used
124:20 - ones I'll make a new string I'll say let
124:22 - sentence and I'll s that to a new
124:25 - sentence and I end with period comment
124:28 - this out now I can check does include
124:31 - new for example I can say sentence and
124:33 - one built-in method is
124:35 - includes pass in the string new and so
124:37 - what this does is this checks the string
124:40 - and sees if the string passed to it as
124:42 - an argument is found if it is then it
124:44 - returns true otherwise it returns false
124:46 - here I just log it out does include new
124:49 - here we see that it does include we can
124:52 - access characters by index value where
124:54 - the first character of a string is at
124:56 - the index of zero the second character
124:58 - is at the index of one third character
125:00 - is index 2 and so on so if I do
125:03 - console.log a sentence at the index of
125:06 - three so if we count this we see the
125:08 - first character at the zero position is
125:10 - a then the empty string then n is at the
125:13 - second index and then E is at the third
125:15 - index because we start counting from
125:17 - zero so we're expecting e we show it in
125:18 - the panel and we get the character that
125:21 - we expected this out I can say cons
125:23 - starts with a I'll say sentence so the
125:27 - method is starts with I'll pass in the
125:30 - string of a and this will return true if
125:32 - the sentence begins with this character
125:34 - and false otherwise. log resp a and we
125:38 - see that is true now I'll just copy this
125:41 - paste it here and I'll rename it I'll
125:42 - say ends with a and change the method to
125:45 - be ends with change that here com it out
125:49 - so we expect this to be false I'll run
125:52 - it and we get false as expected now
125:54 - another useful method is the replace
125:56 - method so if I do let updated
125:59 - sentence sentence. replace first
126:02 - argument I can specify the string that I
126:04 - want to replace in the current existing
126:06 - string oper on so let's say new and I
126:10 - want to replace that to be short so this
126:12 - will return a new sentence and it will
126:14 - not mutate this existing sentence let's
126:16 - output it also log update sentence
126:20 - output it so we expecting the new string
126:22 - to be a short sentence and we get that
126:25 - updated string now some other useful
126:26 - methods is the trim method so if you're
126:28 - expecting user input from an input field
126:30 - it is useful to use the trim method in
126:32 - case the user has spaces in the
126:34 - beginning or at the end of their input
126:36 - so let's update this as if we had space
126:38 - in the beginning and space at the end
126:40 - I'll call this trimmed sentence so I can
126:43 - say sentence. trim and this will remove
126:45 - the spaces from both the beginning and
126:46 - the end here just console log
126:50 - it and get that string with the spaces
126:53 - trimmed at the end now some of the
126:54 - methods is trim left which will remove
126:56 - the spaces from the beginning of the
126:58 - string and we have trim right which will
126:59 - remove spaces at the end one useful
127:01 - method that is commonly used in
127:02 - programming interviews is the split
127:04 - method with the split method we can
127:05 - specify a delimiter and what JavaScript
127:07 - would do is that it will create an array
127:09 - split in the sentence so I can say con
127:12 - and I'll say words in
127:15 - sentence then I will say sentence about
127:17 - the split and the delator I'll say this
127:19 - empty string so so this will split the
127:22 - string whenever it encounters an empty
127:24 - space and those elements will be placed
127:26 - in an array here I'll remove these
127:27 - spaces in the beginning and the end so
127:28 - here let's console log
127:30 - console.log words and sentence then I
127:33 - output
127:34 - it so it is split based on the white
127:36 - space so I'll comment this out two other
127:38 - helpful methods are two lowercase and
127:40 - two uppercase so let's say a user enters
127:42 - in their
127:43 - email and they enter it with mixed
127:45 - casing so some letters are capitalized
127:47 - some are lowercase well when we save
127:49 - that email in the database we likely
127:51 - want to make that all lowercase or all
127:53 - uppercase so the next time when the user
127:55 - logs in they are not restricted from
127:56 - logging in based on case sensitivity so
127:58 - I can say say let lower case email
128:02 - assign that to email and I'll say to
128:04 - lower case console log that lowercase
128:08 - email node objects. js and we get that
128:11 - same string but in all lowercase
128:13 - likewise I can say let
128:16 - uppercase email sign that to email. two
128:20 - uppercase output it uppercase
128:24 - Emil now we get in all uppercase there
128:26 - are many more methods available for
128:28 - Strings and it's best to consult
128:29 - developer. mozilla.org to view the
128:31 - documentation for
128:33 - [Music]
128:35 - Strings name some of the methods in the
128:37 - string
128:38 - [Music]
128:42 - class some of the methods in the string
128:45 - class that we covered in this lesson is
128:46 - replace trim trim left trim right
128:49 - includes index of split two lowercase
128:51 - and and two
128:54 - uppercase in previous lessons when
128:56 - working with strings we have used either
128:57 - single quotes or double quotes we have
128:59 - another way to create a string literal
129:01 - and that is with back ticks so the back
129:02 - tick key on your keyboard is usually
129:04 - above the caps lock key on the upper
129:05 - left side the benefit of using back tick
129:07 - characters which we call a template
129:09 - literal is that it allows us to use
129:10 - string interpolation rather than having
129:12 - to use string concatenation so for
129:14 - example if I say let first name and
129:16 - assign that to my name and then I say
129:18 - let last name and assign that to my last
129:21 - name name now if I want to combine them
129:23 - I can say let I'll say full name and I
129:26 - have to do first name and use the plus
129:29 - sign operator add last name and this
129:31 - performs string concatenation creating a
129:33 - new string and storing it in this
129:35 - variable so let's output it console. log
129:38 - full name and when we run it we see the
129:41 - strings have been combined but there is
129:42 - no space between them so let me add that
129:45 - in I'll add an empty space and then
129:47 - another plus sign now if I run it again
129:50 - I see it properly displays with the
129:52 - space in between so rather than having
129:54 - to include this which is a bit hard to
129:56 - read I have another syntax that I could
129:57 - use so I'll comment this out with
129:59 - template literals it provides a cleaner
130:01 - syntax to accomplish the same thing I
130:03 - can say let full name then I'll use back
130:06 - ticks to create that string literal
130:08 - otherwise known as a template literal
130:10 - then I can use a syntax a dollar sign
130:12 - and then curly braces this acts as a
130:15 - placeholder and within the curling
130:16 - braces I can specify an expression in
130:18 - this case I would use the variable first
130:21 - name name then a space then dollar sign
130:25 - and then last
130:26 - name now I output it and I get the same
130:32 - result what are template
130:39 - literals tempate literals provide an
130:41 - alternative syntax to the traditional
130:43 - strings by using back ticks the benefit
130:45 - is enables us to use string
130:46 - interpolation meaning that with the
130:48 - dollar sign and then curly braces we can
130:50 - utilize that as a placeholder and
130:52 - specify Expressions within it rather
130:54 - than having to use concatenation with
130:55 - the plus
130:57 - [Music]
130:59 - operator in JavaScript we have a
131:01 - built-in date object it stores the date
131:03 - and time it also provides methods for
131:05 - data and time management in JavaScript
131:07 - we would use the date object most
131:08 - commonly to store creation and
131:10 - modification times for a resource the
131:12 - date object can be initialized in
131:13 - multiple ways I'll open up the panel
131:16 - type in node and then enter now we can
131:18 - initialize a date object by going new
131:21 - then date and if I pass in no arguments
131:24 - then this will create a date object
131:26 - based on the current date and time do
131:28 - now and enter this shows my current date
131:30 - and time now I could also create a date
131:32 - object by passing in a number which will
131:34 - represent the number of milliseconds
131:36 - since January 1st 1970 so for example I
131:39 - can say let January 1st of
131:43 - 1970 equal to new date and if I pass in
131:47 - zero representing 0 seconds since
131:49 - January 1st 1970 then when I lock that
131:51 - out then it displays the date and time
131:54 - likewise if I were to do let December
131:56 - 31st 1969 sign to new date and if I do
132:01 - -24 * 3600 * 1,000 then this would be
132:05 - the previous day you could also pass in
132:08 - a date string to construct a date object
132:09 - by just do cons we'll say date one
132:13 - assign it to new date by pass in
132:15 - December 25th 2024 and specify
132:19 - time like can log that
132:22 - out now I can do January 1st of this
132:25 - year and I can say new date passing in
132:29 - the year then the month which is indexed
132:31 - at zero so zero would represent January
132:33 - then the 1 I log that out so check out
132:36 - developer. mozilla.org to read the
132:38 - documentation on the date object there
132:40 - are many methods built in that can't be
132:41 - feasy covered in one video now to cover
132:43 - some of the most common methods I'll
132:44 - clear this out now if I have now
132:46 - assigned to new date one method we could
132:49 - use is now. getet full year we have now.
132:53 - getet
132:54 - month represented as a number and now.
132:56 - getet date we also have now. get time
133:00 - zone offset so this will return the
133:02 - difference between coordinating
133:03 - universal time and your local time zone
133:05 - in minutes this video was just meant to
133:07 - provide an introduction to the date
133:08 - object and to give you an idea of all
133:10 - that this object can
133:13 - do so in this section we covered object
133:16 - literals Factory functions using camel
133:18 - case notation to create a new function
133:20 - we covered Constructor function which
133:21 - uses Pascal notation and we can
133:23 - instantiate objects using the new
133:25 - keyword with these Constructor functions
133:27 - Constructor functions utilize the
133:28 - keyword this which refers to this
133:30 - current object and it implicitly returns
133:32 - a new object we covered the dynamic
133:34 - nature of JavaScript objects and how we
133:35 - can add Properties or delete properties
133:37 - on the Fly we covered that functions are
133:39 - objects in JavaScript and they have
133:40 - properties note that primitive value
133:42 - types are passed by copy and object
133:44 - types are passed by reference you can
133:45 - clone an object with object. assign or
133:47 - use the more modern syntax which is the
133:49 - spread operator represented by three
133:51 - dots we went over template literals and
133:53 - how we can use string interpolation and
133:55 - we briefly covered methods built into
133:56 - the string class and date class so great
133:58 - job completing this section we covered a
134:00 - lot of material and I will see you in
134:01 - the next
134:04 - one arrays are a commonly used data
134:06 - structure which provides a collection of
134:08 - elements in other words a list of items
134:10 - in JavaScript each index position known
134:12 - as an element can be of any data type
134:14 - however in real applications all the
134:16 - elements of an array are usually of the
134:17 - same data type there are many built-in
134:18 - methods for arrays which enable you to
134:20 - modify filter data and retrieve data
134:22 - using clean and modern syntax in this
134:24 - section we'll dive into some of the most
134:25 - commonly used
134:28 - methods what is an
134:34 - array an array is a commonly used data
134:36 - structure in JavaScript that stores a
134:38 - list of
134:41 - data so one of the most common
134:42 - operations when dealing with arrays is
134:44 - adding elements so I'll rename my file
134:46 - to be arrays.
134:48 - JS then I'll declare an array I'll say
134:50 - con call it numbers square brackets and
134:53 - I'll say 5 4 3 2 and 1 so since we have
134:56 - used the const keyword we can't reassign
134:58 - this array to any other value so the
135:00 - numbers variable references the array in
135:03 - memory and an array is an object meaning
135:05 - it contains key value pairs in this case
135:07 - mapping an index value which starts at
135:09 - zero going from 0 1 2 3 and four and
135:13 - that maps and corresponds to this
135:15 - element value so the cons keyword means
135:16 - we can't reassign it but we can modify
135:18 - the array so for adding elements to this
135:20 - array there are three scenarios or three
135:22 - ways that we can add an element to it we
135:23 - can add to the end we can add to the
135:25 - beginning and we can add to the middle
135:26 - so to add a value to the end you would
135:28 - use the push method so I can say
135:29 - numbers. push I'll pass in the value
135:32 - seven and let's console log
135:34 - it then I'll say node arrays. js and
135:39 - here we see the array outputed and the
135:41 - element that I pushed was added to the
135:43 - end of the array so the push method can
135:45 - accept multiple arguments so we can add
135:46 - multiple values at once in one go so
135:48 - let's say I want to add seven8 and n
135:51 - let's save it and we'll log that
135:53 - out and here we see it has added all
135:55 - these values to the end let's comment
135:57 - this out we can also add a value to the
135:59 - front of the array and we would use the
136:00 - method unshift so I'll say numbers
136:03 - unshift and I will say 25 so I'll just
136:06 - copy this console log and I'll paste it
136:08 - here once again in the console and we
136:10 - see the value 25 has been added in the
136:12 - beginning of the array we can also do
136:13 - multiple values of once let's say 25 and
136:16 - 24 and both those values have been added
136:18 - to the beginning of our array comment it
136:20 - out again next you want to consider
136:21 - adding elements to the middle of an
136:23 - array and to do that you would use the
136:24 - splice method so the splice method for
136:26 - adding elements we uses three arguments
136:28 - I can say numbers C splice for the first
136:31 - argument you would specify the index
136:32 - position where you want to start from in
136:34 - this case I'll say from the first index
136:36 - position so this be the index position
136:37 - just after the value five for the second
136:39 - argument you would specify a number
136:41 - which indicates the number of elements
136:42 - that you want to delete since I don't
136:43 - want to delete any elements in this
136:44 - example I would use the value zero now
136:46 - for the third argument is where you
136:47 - would specify what data you want to add
136:50 - and you can add more than one value in
136:51 - this case I say I want to add the values
136:53 - 25 and 24 and then I'll console log it
136:56 - opening up the panel I go up and run it
136:59 - here I see the values 25 and 24 have
137:01 - been added starting from the first index
137:04 - position of the
137:06 - array how would you add an element to
137:08 - the beginning of an
137:13 - array you would use the method unshift
137:15 - to add to the beginning of the array how
137:17 - would you add to the middle of an array
137:23 - you would use the splice method how
137:26 - would you add an element to the end of
137:27 - an
137:31 - array you would use the push
137:35 - method arrays can store both primitive
137:37 - data types or reference data types
137:39 - meaning objects there are three main
137:41 - methods that we can use to check if an
137:43 - array contains a primitive value and
137:45 - that isindex of last index of and do
137:48 - includes let's go over an example of
137:49 - each let's say if we initialize
137:52 - the array numbers is assigned to 5 4 3 2
137:55 - and 1 now if we want to find the index
137:57 - of the value of three I can say const
138:00 - index of three and assign that to
138:03 - numbers. index of and then the value I
138:05 - want to search for so this will return
138:07 - the index that it's found at starting
138:09 - from left to right now if this value
138:11 - that I pass as an argument is not found
138:13 - in the array then it return the value
138:15 - negative 1 so I can output that and I'm
138:17 - expecting the value of two so I can say
138:19 - console. log
138:21 - of index of three now if I output that
138:23 - in the
138:24 - console and here I see the value of two
138:26 - indicating the index that it's found at
138:28 - now typically I wouldn't just output the
138:30 - index value rather I would use it with
138:32 - bracket notation so I can say numbers
138:34 - and then bracket notation then I would
138:35 - utilize that variable so I can access
138:38 - this value by
138:39 - Index this out now let's say that if we
138:41 - had a duplicate value so if I add three
138:43 - at the end index of always searches from
138:45 - left to right so if I wanted to find out
138:47 - what is the last index of it then I can
138:49 - use the last index of so comp last index
138:53 - of three ass to numbers. last index of
138:57 - that same value so we expecting last
138:59 - index of three to be five cuz we count
139:01 - from 0 1 2 3 4 and 5 that is the index
139:05 - position so let's just output that
139:07 - console. log last index of
139:10 - three and we get the value of five as
139:12 - the index where it is stored at now
139:14 - let's try a case when we search for a
139:15 - value that does not exist we can say
139:17 - const index of 10 and assign that to 2
139:21 - numbers. last index of 10 so this will
139:24 - have the value of-1 and if we try to
139:26 - access that by bracket notation then we
139:28 - will get the value of undefined so let's
139:29 - output both of those
139:31 - console.log so this will
139:33 - output1 and then when we try accessing
139:35 - it we will get
139:37 - numbers index of 10 and this be
139:40 - undefined let's see that and we get that
139:43 - output now whenever we use index of or
139:45 - last index of we typically do a
139:47 - conditional statement and check and
139:49 - ensure that the value is not negative
139:50 - one before using it to access that
139:52 - element so I can com that out and then I
139:54 - can do for example
139:56 - if index of 10 is equal to1 indicating
140:01 - that the value of 10 is not found in the
140:02 - array then I can conso log 10 is not
140:06 - found in the array can output
140:09 - that so we can utilize index of and last
140:12 - index of with our conditional statements
140:14 - now if we are not utilizing that index
140:16 - value in order to access or change that
140:18 - element then we can just use the
140:19 - includes method which will return a
140:21 - Boolean value of true or false depending
140:23 - on if that value is found in the array
140:25 - so I can say if numbers do includes 10
140:30 - then I can say
140:32 - console.log 10 is found in the array and
140:36 - so since 10 is not found in the array
140:38 - this will not be console loged let's see
140:39 - if I log it out and there is no output
140:42 - now I could use the exclamation point in
140:44 - the beginning so with the exclamation
140:45 - point this reads if the numbers array
140:47 - does not include the value 10 then I'll
140:49 - put what is in the code block so I can
140:51 - say 10 is not found in the array and
140:54 - when I run in the console I see that
140:58 - output how would you check if an array
141:00 - contains a primitive
141:06 - value there are three main methods you
141:08 - can use you can use index of last index
141:11 - of or do
141:14 - includes consider the following array
141:17 - employees assign it to an array of
141:20 - objects I'll say the ID name gym so then
141:25 - I'll add two more objects to this array
141:28 - I'll copy this and then I'll do shift
141:29 - option and down arrow two more times
141:32 - then I'll update the IDS two and three
141:36 - and update the names say
141:38 - melot and
141:40 - Pam so with this array of objects using
141:43 - the includes method or index of won't
141:46 - help us find an element as comparing two
141:48 - different objects even if they have the
141:50 - same property won't be equal as those
141:52 - objects have different memory addresses
141:54 - so instead you would use the find method
141:56 - going to find that here say const
141:58 - employee equal to employees. find now as
142:03 - the argument you would pass a function
142:05 - in this context the function will be
142:06 - referred to as a callback function we
142:08 - call it a callback function because we
142:10 - pass the function as an argument and it
142:11 - will be invoked at a later time now this
142:14 - particular type of callback function for
142:15 - the fine method is referred to as a
142:17 - predicate function meaning that it will
142:19 - return true or false previously I
142:21 - mentioned that functions are objects so
142:23 - this is what enables us to pass
142:24 - functions around as arguments in
142:26 - JavaScript so we can specify function we
142:29 - will define an anonymous function so we
142:31 - won't give it a name now it will accept
142:32 - an argument we'll specify e as the
142:34 - parameter variable then we can do curly
142:36 - braces and end it with the semicolon now
142:38 - within the code block the predicate
142:39 - function has to return a true or false
142:41 - value so we can do return then the
142:44 - parameter variable e do name equal to
142:48 - and we'll say gy so if this value is not
142:51 - found then it will return undefined
142:53 - otherwise it will return that element so
142:56 - I can console log it
142:58 - console.log
142:59 - employee opening up the
143:03 - panel here you can see it outputs that
143:06 - object so the find method will return
143:08 - the first element that matches we also
143:11 - have the find index method which acts
143:13 - the same way except instead of returning
143:15 - the object it will return the index
143:17 - where that object is found at
143:21 - what array methods would you use to find
143:23 - and locate an
143:29 - object you can use the find method or
143:32 - find index method for both of them you
143:34 - would specify a predicate function to
143:36 - locate an object based on a
143:40 - property but previously we use an
143:42 - anonymous function in order to Define
143:44 - our callback function however there is
143:46 - another more modern syntax that is more
143:48 - commonly used and it's easier to read
143:49 - this syntax is known know as an arrow
143:51 - function so traditional functions will
143:53 - look like by the function add and I
143:56 - specify two parameters num one and num
143:58 - two curly braces and then I just return
144:01 - num one plus num 2 so this is known as
144:04 - function declaration now another syntax
144:06 - to accomplish the same thing is the
144:07 - arrow function so I can name it const
144:09 - I'll comment this out then I'll name it
144:11 - add an equal sign for an assignment and
144:13 - then I specify the parameter variables
144:15 - so I'll say num one and num two and then
144:18 - I will use an equal sign and then the
144:20 - greater than sign so this Den notates an
144:23 - arrow now I would specify that same
144:25 - functionality in the curly braces num
144:27 - one plus num two so remember functions
144:29 - are objects in JavaScript so this is
144:32 - being assigned to the ad variable Arrow
144:35 - function syntax is commonly used for
144:38 - callback functions when you have an
144:39 - arrow function that has just one
144:41 - statement in the code block then you can
144:42 - simplify it you can remove the curly
144:44 - braces and put everything on one
144:47 - line you could also remove the return
144:49 - statement
144:51 - because the arrow function knows
144:53 - implicitly that you are returning this
144:55 - expression this provides a cleaner
144:56 - syntax to use when using predicates so
144:59 - rather than using this implementation
145:01 - with the function declaration we comment
145:02 - that out and here I can remove that
145:05 - function keyword so it's no longer an
145:07 - anonymous function then I use the symbol
145:09 - for Arrow function and I can clean it up
145:11 - and put everything on one line so I can
145:13 - remove this return statement and remove
145:15 - the curly
145:18 - braces so this is a cleaner way to
145:20 - accomplish the same
145:24 - thing how would you define a function
145:26 - for theine
145:33 - method the doine method is a method that
145:35 - exists for the array class and is used
145:37 - in order to find an object for the
145:39 - argument you would specify a function in
145:41 - this case it would be a predicate
145:42 - function meaning that it would result in
145:44 - true or false you could use either an
145:46 - anonymous function or an arrow function
145:48 - in order to implement this
145:51 - what is an arrow
145:58 - function an arrow function is an
146:00 - alternative syntax to the function
146:02 - declaration syntax you would assign it
146:03 - to a variable and Define it with
146:05 - parentheses and then use the symbol for
146:07 - equal sign and greater than symbol and
146:09 - then specify the code block if the code
146:11 - block only consists of one line then you
146:12 - can put everything on one line and you
146:14 - can remove the return
146:18 - keyword so once again let's create an
146:20 - array I'll name it const numbers is
146:22 - assigned to 1 2 3 4 and 5 so for adding
146:26 - elements to an array we can use the push
146:28 - method to add to the end we have unshift
146:30 - to add to the beginning and we have
146:31 - splice to add to the middle now for
146:33 - removing elements we have pop to remove
146:35 - from the end we have splice to remove
146:37 - from the middle and we have shift to
146:38 - remove from the beginning so let me show
146:40 - an example of each of these so if I do
146:42 - cons last element assign to numbers. pop
146:46 - this will remove the last element so in
146:48 - this case the value five stored in this
146:50 - VAR varable so let's output that say
146:51 - console. log now I'll use backticks and
146:54 - we'll use our template literals I'll say
146:56 - last element colon and then dollar sign
146:58 - curly brace last element and let's
147:01 - output that we're expecting the value
147:03 - five so here we see last element and
147:06 - then the value that was removed but I
147:07 - want to remove the first element can say
147:10 - numbers. shift so this will remove the
147:14 - value of one so let's output that
147:16 - console.log by say first element and
147:19 - then sign first element end it with a
147:22 - semicon we can output that go up and run
147:24 - it again so here we see the first
147:26 - element of the array was removed we
147:28 - could also add a space between these
147:29 - values by add back sln so when
147:32 - JavaScript encounters back sln it knows
147:35 - that this means to create a new line so
147:37 - if I run it again we can expect this
147:38 - time there would be a space between
147:40 - these
147:41 - outputs so let's do our last method
147:44 - which is the splice method so for the
147:46 - splice method it could be used to add to
147:47 - the middle of an array or to remove from
147:49 - the middle of array so here we do say
147:51 - cons I'll name it middle element equal
147:54 - to numbers. splice so for splice the
147:57 - first argument is the index to start at
147:59 - the second argument is the number of
148:01 - elements to delete starting from the
148:02 - index specified in the first argument
148:04 - any argument that you pass after that is
148:06 - optional and it will specify the new
148:08 - values to add if I say from index one
148:10 - and I want to remove one element this
148:12 - will return the value and store it in
148:14 - Middle element so if I
148:16 - do console.log
148:20 - middle
148:23 - element and output
148:26 - it here I see the middle element has
148:28 - been outputed with a value of
148:32 - three how would you remove an element
148:35 - from the beginning of an
148:40 - array you would use the shift method to
148:43 - remove an element from the beginning how
148:45 - would you remove an element from the
148:46 - middle of an array
148:53 - you would use the splice method how
148:56 - would you remove an element from the end
148:57 - of an
149:02 - array you would use the pop
149:07 - method so we covered how to add elements
149:09 - to the numbers array as well as how to
149:11 - remove elements now if you wanted to
149:12 - clear all the elements of an array there
149:14 - are different ways that we can do that
149:15 - one way is we can use a while loop we
149:18 - can say while numbers. length
149:20 - is greater than zero then we can call
149:23 - numbers. Pop so repeatedly move from the
149:25 - end so although this works if the
149:27 - numbers array was large this would be an
149:29 - inefficient way to do so we can comment
149:31 - it out and we'll look at a different way
149:32 - so we've covered the numbers. length
149:34 - property we could also use this property
149:36 - in order to assign a value so if we
149:38 - assign it to zero this will clear the
149:40 - numbers array so I can output that I'll
149:42 - say console.log and I'll output this
149:45 - array and there I see that the array is
149:47 - empty let's comment this out now we've
149:49 - used the splice method which can be used
149:51 - for adding and removing elements so we
149:53 - can say numbers.
149:55 - splice starting from the first element
149:58 - at index zero and then for the second
150:00 - argument it specify the number of
150:02 - elements to delete so I can say numbers.
150:04 - length and this will remove every
150:06 - element also the splice method will
150:08 - return all the elements that were
150:09 - deleted in an array so I'll just say
150:11 - cons I'll just say deleted numbers let's
150:15 - log that console.log and template
150:17 - variable deleted numbers qu
150:20 - deleting numbers when we output
150:24 - that we can see all the values that have
150:27 - been deleted comment this out now
150:29 - another way we can do that is simply
150:31 - defining numbers to a new array so
150:34 - remember an array is an object so when
150:36 - we assign it to a new array the previous
150:38 - array will be garbage collected since I
150:40 - use the con keyword that means I cannot
150:43 - reassign it so I would need to change
150:44 - this to let in order for me to reassign
150:47 - this variable another thing to be aware
150:48 - of if I were to have another variable
150:50 - let's say if I name it let another array
150:53 - assign it to numbers then both of these
150:55 - values will be referencing the same
150:57 - array in memory so in this case even
150:59 - though I reassigned numbers to an empty
151:01 - array another array will still be
151:03 - referencing this previous array so it
151:05 - will not be garbage
151:09 - collected how would you empty the
151:11 - contents of an
151:16 - array to empty an array you can simply
151:19 - assign it to to a new array you could
151:21 - also set the length property to zero or
151:23 - use the splice
151:26 - method so let's say we have two arrays
151:28 - and we want to combine them into one
151:30 - array so I can initialize const example
151:33 - numbers a assign to 1 2 and 3 then const
151:38 - example numbers B assigned to four 5 and
151:42 - 6 so now I can combine them using the
151:44 - concat method so I can say con combined
151:47 - array is equal to example numbers a
151:51 - conat example numbers B so this will
151:55 - return a new array console. log combined
151:58 - array and displaying it in the panel
152:01 - here I see it has created a new array
152:03 - now we can also slice the array meaning
152:05 - that we can specify a start index and an
152:07 - end index and it will return a new array
152:09 - with the elements found within that
152:11 - range the slice method will not affect
152:13 - the original array so I can say const
152:15 - First Slice assign to combined array.
152:19 - slice from 0 to 4 so opening up the
152:22 - panel here since I specified the range
152:24 - between 0 and four it will return a new
152:26 - array containing the values of 1 2 3 and
152:29 - four so the second argument is exclusive
152:32 - here if I log that out console.log for
152:37 - slice so these are the two methods to
152:40 - combine and slice arrays so if you're
152:42 - performing this with primitive values
152:43 - then the elements will be passed by copy
152:46 - however if you're dealing with objects
152:47 - then the elements will be passed by
152:48 - reference
152:51 - how would you combine two
152:57 - arrays you would use the concat method
153:00 - to create a new
153:02 - array how would you get a slice of an
153:09 - array you would use the slice method and
153:12 - you can pass two arguments the start
153:13 - index and the nend
153:16 - index there is another way to combine
153:19 - two
153:20 - which is to utilize the spread operator
153:22 - we have discussed the spread operator
153:23 - before so it can be used to copy the
153:26 - properties of an object or the elements
153:27 - of an array so rather than using the
153:29 - concat method I can say let combined is
153:31 - assigned to three dots to spread the
153:35 - elements in this array comma and then
153:38 - the other array so this accomplishes the
153:40 - same thing as the concat method and this
153:42 - is the more commonly used syntax
153:44 - outputting this and we get the same
153:47 - result this syntax also provides more
153:49 - flexibility than the concat method as we
153:52 - can add elements in between these values
153:55 - meaning I can put a value here or
153:57 - perhaps at the end so it provides more
154:00 - flexibility than the concat method so if
154:02 - I remove this if I just say let a is
154:05 - assign to one and two and then let B is
154:08 - assigned to a so arrays are objects
154:09 - which means that they are passed by
154:11 - reference so the references of A and B
154:13 - both reference the same array in memory
154:16 - so the same object in memory so we could
154:18 - also utilize the spread operator in in
154:19 - order to make a copy of an array so
154:22 - instead of saying let B is assigned to a
154:23 - I can say square brackets to create the
154:25 - array and then the spread operator so
154:27 - this creates a new array and spreads the
154:31 - content what is the spread
154:36 - operator the spread operator refers to
154:39 - using three dots in order to copy over
154:41 - an object so this could refer to an
154:43 - object literal and copying over the
154:44 - properties it could also refer to the
154:46 - elements of an
154:48 - array to iterate over an array you could
154:51 - use the four of loop that we covered
154:52 - previously so just a quick reminder if I
154:54 - initialize the numbers array again 1 2
154:57 - three four and five then I can do four
155:00 - can say let number of numbers and
155:03 - because I'm just going to use one line I
155:05 - don't need the curly braces just to
155:07 - Output that so here I see it outputed
155:10 - every element now there is another
155:11 - built-in method in the array class known
155:13 - as for each so the argument that you
155:16 - would pass into the method is a callback
155:18 - function so if I did numbers. 4 each in
155:23 - camel case then as the argument I can
155:25 - pass in an arrow
155:27 - function specify the number then the
155:30 - arrow and the curly braces then I can
155:33 - console. log the
155:35 - number so if I put that I get the same
155:38 - result since this codeb only includes
155:41 - one statement I could put everything on
155:42 - one line to simplify
155:47 - it so if an error function only has has
155:49 - one parameter then you can remove the
155:51 - parentheses around it helping clean it
155:54 - up even more the 4 method also accepts
155:56 - an optional second parameter which takes
155:58 - into account the
156:01 - index so here if I add that
156:04 - in then I can utilize that when I
156:06 - console log it so if I use template
156:09 - string then I can say at
156:12 - index specified here and then colon and
156:16 - then I'll specify the number at that
156:18 - index so if I log in
156:21 - out then I can see what value is stored
156:23 - at each
156:25 - index how would you iterate through an
156:31 - array you could use the four of loop to
156:34 - iterate through all the elements of an
156:35 - array you could also use the builtin for
156:37 - each method you would pass in a function
156:39 - as an argument which will take an
156:40 - element as a parameter and optionally
156:41 - take in the index as a second
156:45 - parameter to transform an array into a
156:48 - string The Joint method can be utilize
156:50 - so if I initialize the array const
156:52 - numbers assigned to 1 2 3 4 and 5 I can
156:56 - convert that into a string so I can say
156:59 - const join numbers assigned to numbers.
157:04 - jooin so the joint method allows you to
157:06 - specify a separator as the argument and
157:09 - this separator will be placed in between
157:10 - the elements for an example of that it
157:13 - will take in a string and I will specify
157:15 - a comma as a separator then I can
157:17 - console log that console
157:20 - log join numbers open up the panel and I
157:24 - run it and here I see this has been
157:26 - outputed as a string where every element
157:28 - is separated by commas on the flip side
157:30 - the split method is available for
157:32 - Strings enabling the reversal of this
157:34 - process by transforming a string into an
157:36 - array so this will not alter the
157:38 - original string rather it will return an
157:40 - array so let's say if I comment this out
157:43 - so if I do const course name is assigned
157:46 - to JavaScript
157:51 - beginners then I can split up the words
157:54 - into parts and I can say course name.
157:58 - split and as the argument I can specify
158:01 - the separator as an empty string so
158:03 - because I specified an empty string as
158:05 - the separator what JavaScript would do
158:07 - is it will go from left to right and
158:08 - whenever it Encounters this value the
158:11 - empty space it will perform a split so
158:13 - this string will be converted into an
158:14 - array this word JavaScript will be at
158:16 - the zero index of that new array for
158:19 - will be at the first index and beginners
158:22 - will be at the second index so if I log
158:25 - that out
158:26 - console.log
158:28 - Parts output it here I see I've
158:31 - converted that string into an array so
158:34 - to show an example of how this can be
158:35 - useful consider the term of a URL slug
158:38 - so this refers to having a descriptive
158:39 - path in your url your uniform resource
158:41 - locator in url slugs words are separated
158:44 - by a hyphen so in order to perform this
158:46 - we can use the join method so the
158:48 - sentence JavaScript for beginers
158:49 - is what we want to include in our URL We
158:52 - performed a split based on whites space
158:53 - and stored it in an array now I want to
158:55 - join everything together with a hyphen
158:57 - so I can say const and I'll say URL slug
159:02 - is assigned to parts. jooin and I will
159:05 - specify The Hyphen character then I can
159:08 - output
159:09 - that opening up the panel and running it
159:12 - again here I see is now displaying each
159:15 - of the words separated by hyphen now
159:17 - let's say we want to make every word in
159:19 - the sentence lowercase so the simplest
159:20 - way to do that will be to use the two
159:22 - lowercase method in the string class so
159:25 - before performing the split I can say
159:27 - cons and I'll call it lowercase course
159:30 - name is assigned to course name. two
159:35 - lowercase then I can utilize this
159:38 - variable for performing the split so now
159:40 - if I output
159:42 - it and now displays all the words in
159:44 - lowercase and separated by hyphen so we
159:47 - can clean up our code even more here we
159:49 - have course name it's assigned to a
159:50 - string then we call do to lowercase
159:53 - assigning the value to this variable
159:54 - which is a string data type then we call
159:56 - the split method to convert it into an
159:58 - array we can actually clean up these two
160:00 - lines by utilizing something called
160:02 - method chaining so I'll add some spacing
160:05 - to make it more
160:06 - readable and I'll comment this out and
160:08 - show how we can do it with cleaner code
160:10 - so if I do cons parts and assign to
160:13 - course name do2
160:17 - lowercase so this is still the string
160:19 - data type so I can call Dot
160:22 - split and specify the separator this
160:25 - enables us to implement the same
160:26 - functionality in one line often times
160:29 - when we do method chaining we would add
160:30 - the method calls to their own line so I
160:32 - can add a new line and then tab and the
160:35 - same thing with the split method so when
160:37 - performing method chaining and calling
160:39 - one method after another we often put it
160:41 - on its own line and we're able to do
160:43 - this because they are all the same data
160:45 - type in this case the string data
160:47 - type how does the join method
160:53 - work the join method is available for
160:56 - arrays in order to convert the elements
160:58 - into a string it accepts an argument
160:59 - where you can specify what the separator
161:01 - will be and that separator will be
161:02 - placed in between the elements for the
161:04 - string that it returns how does the
161:07 - split method
161:11 - work the split method exists for the
161:13 - string data type you specify the
161:15 - separator and then it will convert the
161:16 - string into an array
161:19 - [Music]
161:21 - in programming sorting is a common
161:23 - operation JavaScript arrays come with a
161:25 - built-in sort method that allows you to
161:26 - easily sort the array Elements by
161:28 - default when you call sort on an array
161:30 - containing strings or numbers it sorts
161:32 - the elements in ascending order let's
161:34 - see this an action if I initialize this
161:35 - array let characters assign to c d b and
161:41 - a in order to sort these elements we
161:44 - simply need to call the built-in sort
161:46 - method so I can say characters. sort and
161:49 - then I'll log it out
161:51 - console.log characters and we will see
161:54 - it sorted in ascending order so here if
161:56 - I do node arrays. js we see the elements
162:00 - have been
162:01 - sorted another useful method in the
162:03 - array data structure is the reverse
162:04 - method so this can be used to reverse
162:06 - the order of the elements so rather than
162:08 - sort if I say reverse here we will see
162:10 - these elements updated in reverse order
162:13 - so if I output
162:14 - that here I see the array has been
162:16 - updated with the order reversed so if I
162:18 - switch back back to the sort method this
162:20 - approach Works seamlessly for arrays
162:22 - containing strings or numbers however
162:24 - when you have an array of objects you
162:25 - need to provide a callback function to
162:27 - the sort method this function defines
162:29 - the Sorting logic based on the
162:30 - properties of the object in the array so
162:32 - I'll clear this out and let's consider
162:34 - an array of employee objects so if I say
162:36 - let
162:38 - employees and within it I'll specify an
162:40 - object with an ID of one and a name of
162:44 - gen then I'll copy and I'll create four
162:46 - more elements so if I do shift option
162:48 - and down arrow
162:50 - creating former elements and I'll update
162:51 - the IDS to be two 3 and four and for the
162:55 - name I'll say Steven then Andrew then
162:59 - Terry and I end it with the semicolon so
163:01 - here I see these objects are ordered
163:04 - based on the ID however if I want to
163:06 - sort it based on the names then I need
163:08 - to specify a callback function in that
163:11 - callback function I will specify two
163:12 - parameters which represents two elements
163:14 - in this case two objects being compared
163:16 - so if I do employees
163:19 - sort now I can name these parameters
163:21 - whatever I want in this case I'll just
163:23 - name it A and B then I'll specify the
163:25 - arrow function and the curly braces so
163:28 - in our callback function we will compare
163:29 - values based on one of the object's
163:31 - properties so in this case we will use
163:33 - the name property the Callback function
163:35 - returns a number that determines the
163:36 - short order returning a negative value
163:38 - means the first argument in this case a
163:40 - comes before the second argument
163:42 - returning zero means that they are
163:44 - considered equal and in sorted order
163:45 - returning a positive value means that
163:47 - the first argument a comes after a
163:49 - second so since we'll will be sorting
163:50 - based on the name property we'll be
163:52 - performing a comparison based on these
163:54 - characters now characters are internally
163:56 - represented as numbers in computers
163:58 - based on their ask key values this means
164:00 - capital letters are considered less than
164:02 - lowercase letters to handle case
164:04 - sensitivity it's a good practice to
164:05 - convert strings to the same case for
164:07 - comparison so let's Implement our
164:09 - callback function so first I'll make it
164:10 - all lowercase so I can say const lower
164:12 - case a is assigned to a then the name
164:17 - property of that object and then I'll
164:19 - call two lowercase which is a built-in
164:21 - method for Strings then I'll just copy
164:23 - this with shift option and down arrow
164:26 - and I'll name it lower case b and then
164:28 - I'll change the object that we're using
164:30 - B then I can perform the comparison
164:32 - using the comparison operators so if I
164:34 - do if lowercase a is less than lowercase
164:39 - b in this case we will
164:41 - return1 which means that the object to a
164:43 - will come before the object to B so for
164:46 - example if we consider the object a to
164:48 - be this first
164:49 - object and we consider B to be the
164:53 - object just after it we are comparing
164:55 - these two name properties and because we
164:57 - determine gen to come before the name
165:00 - Steven returning a negative value means
165:02 - that object a comes before object B so
165:05 - we compare two elements at a time now in
165:07 - the case when if lowercase a is greater
165:10 - than lowercase b then we return a
165:13 - positive value which means that a comes
165:15 - after the object B otherwise if they are
165:17 - equal then we return zero so this
165:19 - callback function will be used to sort
165:21 - the objects in our array so now if I
165:22 - console log employees I will see that
165:24 - they are sorted alphabetically based on
165:26 - the name property so now I'll put it
165:30 - console.log
165:32 - employees open up the panel and we'll
165:34 - clear it and then we'll run it so here I
165:36 - see the objects are sorted
165:40 - alphabetically how would you sort the
165:42 - elements of an
165:46 - array you can use the built-in sort
165:48 - method to sort the elements of an array
165:50 - you can simply invoke the sort method if
165:51 - the array consisted of elements that are
165:53 - strings or numbers however if the array
165:55 - consists of elements which are objects
165:57 - then you need to specify a callback
165:59 - function this callback function will
166:00 - accept two parameters representing two
166:02 - objects to compare and you would compare
166:04 - those objects based on their
166:07 - properties in JavaScript arrays come
166:10 - equipped with several powerful methods
166:11 - that allow us to process and evaluate
166:13 - the data within them efficiently two
166:15 - such methods are every and sum both of
166:17 - which are used to test elements in an
166:19 - array against a condition let's explore
166:21 - how each of these methods work and when
166:22 - to use them starting with the every
166:24 - method the every method tests whether
166:25 - all elements in Array pass the test
166:27 - implemented by the provided function it
166:29 - returns true if every element in the
166:30 - array satisfies the specified condition
166:33 - and false otherwise this method is
166:34 - perfect for scenarios when you need to
166:36 - ensure that an entire collection meets a
166:38 - certain criteria for example let's check
166:39 - if every number in an array is even so
166:41 - let's instantiate an array of numbers
166:43 - I'll say const numbers assigned to 2 4 6
166:48 - 8 and 10
166:49 - so I will store the result in a variable
166:51 - R all even which will hold a Boolean
166:54 - value this is assigned to the result of
166:56 - numbers every so when I hover over every
166:59 - I see that it accepts a callback
167:01 - function which is a predicate so this
167:02 - callback function must return true or
167:04 - false and it can accept up to three
167:05 - parameters the first parameter is the
167:07 - current element of the array the second
167:09 - parameter is the index of where the
167:11 - element is stored and the third
167:12 - parameter is the original array of these
167:14 - three parameters only the first one is
167:16 - mandatory and the other two are optional
167:18 - in this case I only the first parameter
167:19 - so I'll name it
167:21 - number then I'll use the arrow function
167:23 - syntax the curly braces and then I will
167:25 - return when that number mod 2 is equal
167:29 - to zero then we know that it is even so
167:31 - I can console log are all even console.
167:34 - log I use my template string R all even
167:38 - callon and then I use string
167:40 - interpolation R all even end it with a
167:42 - semi colon and then we'll log this out
167:45 - up arrow and here I see the value true
167:48 - so we know all the elements are even so
167:50 - because our code block just consists of
167:51 - one statement we can clean it up and put
167:53 - everything on one
167:55 - line so here if I run it
167:58 - again get the same result now let's
168:00 - consider the sum method on the flip side
168:02 - the sum method checks if at least one
168:04 - element in the array passes the test
168:06 - implemented by the provided function it
168:08 - returns true as soon as one element
168:10 - satisfies the condition making it useful
168:12 - for scenarios when you're looking for
168:13 - the presence of an element that meets a
168:15 - specific requirement so let's
168:16 - instantiate an array and say cons
168:17 - numbers sign to 1 3 5 7 8 and 9 I will
168:24 - store the value in a variable has one
168:27 - even number which holds the bulling
168:30 - result and then I'll say numbers. sum so
168:32 - once again this predicate callback
168:34 - function accepts up to three parameters
168:36 - in this case we only need the first one
168:37 - which is the element that we're
168:38 - operating on and I'll name it number and
168:41 - I'll use the arrow function syntax and I
168:43 - will check number mod 2 is equal to Z
168:47 - then I can log that out console. log
168:50 - template string again has one even
168:53 - number colon and then interpolation has
168:57 - one even number ending with a semicolon
169:00 - and let's output
169:02 - that so here I see the value true
169:05 - because this array has the value of
169:07 - eight it's important to note that both
169:08 - the every and some methods operate on
169:10 - arrays in a way that they stop
169:12 - processing elements as soon as the
169:13 - outcome is determined for every it stops
169:15 - and returns false as soon as it
169:16 - encounters an element that does not meet
169:18 - the condition some stops and returns
169:20 - true at the first instance of an element
169:21 - that satisfies the condition these
169:23 - methods are incredibly useful for array
169:25 - processing in JavaScript providing a
169:26 - concise and readable way to evaluate
169:28 - conditions across array elements whether
169:30 - you're checking for consistency with
169:31 - every or searching for possibilities
169:33 - with some these methods offer elegant
169:35 - solutions to Common programming
169:39 - scenarios what is the every method and
169:41 - how does it
169:47 - work the every method is a built-in
169:49 - method in the array data structure and a
169:51 - test whether every single element in an
169:53 - array satisfies a specified condition
169:56 - what is the sum method and how does it
170:02 - work the sum method is a built-in method
170:04 - in the array data structure it returns
170:06 - true if at least one of the elements in
170:08 - the array passes a particular condition
170:10 - and false
170:13 - otherwise one of the most versatile
170:15 - built-in methods for arrays in
170:16 - JavaScript is the filter method this
170:18 - method is designed to go through an
170:20 - array and extract elements that meet a
170:22 - specific condition returning a new array
170:24 - comprised of only those elements it's
170:26 - particularly useful for creating subsets
170:27 - of an array that match certain criteria
170:29 - so consider an array of numbers find
170:31 - instantiate con numbers S 2 1 2 3 4 5
170:36 - and six if we want to filter the array
170:38 - so that we only have the even numbers we
170:40 - can use the filter method so I can say
170:42 - con even numbers sign to numbers. filter
170:47 - so the filter method works by by
170:48 - accepting a callback function and this
170:50 - function acts as a test often called a
170:52 - predicate function that returns a
170:53 - Boolean value so it returns true or
170:55 - false for each element in the original
170:56 - array the filter method calls this
170:58 - callback function and if the Callback
170:59 - function returns true for an element
171:01 - that element is included in the new
171:02 - array returned by filter if false the
171:04 - element is excluded so I will specify my
171:06 - callback function to be number and I'll
171:08 - use the arrow function syntax so number
171:12 - mod 2 equal to Z so if this is true then
171:16 - we know that the value is even it will
171:17 - be included an even numbers so let's
171:19 - console log that
171:21 - console.log even numbers then run in the
171:25 - panel so here I see the array consist of
171:28 - only the even values so let's look at a
171:30 - more complex example involving an array
171:32 - of objects which is a more common use
171:34 - case for worldw projects thr this out
171:36 - and I'll State an array containing
171:38 - objects so I'll say const
171:40 - employees assign to the array then I'll
171:43 - specify the object ID of one the name of
171:47 - Alice and the role of a
171:51 - developer comma and then shift option
171:54 - and down arrow to create more copies
171:56 - update the
171:58 - IDS and the names I'll say Bob I'll say
172:02 - Charlie and I'll say
172:05 - Danielle update their roles so designer
172:08 - developer and manager so now I want to
172:12 - filter so that we only contain the
172:14 - developers so I'll say developers equals
172:17 - employees filter then I'll specify my
172:20 - callback function I'll name it employee
172:23 - for the element and then when the
172:25 - employee. roll is equal to developer
172:29 - then it will be included in the
172:30 - developer's array I'll outp put this
172:35 - developers and then when we run in the
172:38 - panel here I see both employees with the
172:40 - role of developer are included this
172:43 - demonstrates the filter method's power
172:44 - to work with arrays containing objects
172:46 - and utilizing the objects properties to
172:48 - make very specific selections so the
172:50 - filter method is non-destructive and it
172:52 - does not change the original array
172:53 - instead it creates a new array with
172:55 - elements that pass that test or that
172:57 - match the
172:58 - [Music]
173:01 - criteria how would you filter the
173:02 - elements of an
173:08 - array you would use the built-in filter
173:10 - method and specify a callback function
173:12 - in that callback function you would
173:13 - specify what condition You Want To Be
173:15 - True in order for that element to be
173:16 - included in the array to return
173:21 - the map method is a Cornerstone of array
173:23 - manipulation in JavaScript offering a
173:24 - powerful way to process and transform
173:27 - array elements it operates on each
173:28 - element of an array applying a function
173:30 - you specify and returns a new array
173:32 - composed of the results this makes map
173:34 - an Ideal tool for a transforming data
173:36 - without altering the original array
173:37 - imagine map as a transformative method
173:39 - you give it an array and a
173:40 - transformation Rule and it gives back a
173:42 - new array where each element has been
173:43 - changed according to that rule let's
173:45 - start with a simple example squaring
173:46 - each number in Array of numbers so if I
173:48 - initialize con numbers assign to 2 4 6 8
173:54 - and 10 using the map method I'll store
173:56 - the result in square numbers sign to
174:00 - numbers. map I'll specify my call back
174:03 - function I'll say num the arrow function
174:05 - num * num in this case map takes each
174:09 - number squares it and includes the
174:11 - result in the new array here if I log it
174:13 - out
174:15 - console.log square numbers opening up
174:18 - the panel or run this
174:21 - file and here I see each value has been
174:23 - squared let's consider another example
174:25 - transforming strings so I'll delete this
174:27 - so map is not limited to numbers it
174:29 - works with any data type so for this
174:31 - example we will convert an array of
174:32 - characters into uppercase characters so
174:35 - let say con characters assigned to a b c
174:41 - and d I'll store the result in uppercase
174:46 - characters that's equal to to
174:49 - characters map for the Callback function
174:52 - I'll specify the element to be character
174:55 - map to character. 2
174:58 - uppercase ending with a semicolon so now
175:00 - console.log it
175:03 - console.log uppercase characters then I
175:06 - run in the
175:07 - panel so here I see each element has
175:09 - been converted to uppercase I'll clear
175:11 - this out so now I'll show an example
175:14 - working with objects so when using the
175:16 - map method with objects this enables us
175:17 - to update Properties or transform
175:19 - objects entirely for instance if you
175:21 - have an array of employee objects and
175:22 - you need to normalize their email
175:24 - address to lowercase for consistent
175:26 - databased storage map makes this task
175:28 - easy to do so if I initialize const
175:31 - employees to an array and I'll say ID is
175:34 - one name is
175:36 - Alice and email his mixed case so I'll
175:40 - say
175:41 - Alice at
175:43 - gmail.com just in case their email was
175:46 - entered in and mixed case
175:48 - I'll make two more copies and update the
175:50 - IDS and the names so here I'll say
175:52 - Steven and I'll say Joe and for the
175:55 - email I'll say
175:57 - say and mix
175:59 - case and
176:03 - Joe ending with the semicolon so now for
176:06 - performing the map I'll say cons updated
176:09 - employees assign
176:11 - to employees. map un name the parameter
176:15 - to be
176:16 - employee Arrow function and here I'll do
176:19 - a parenthesis and then curly brace so
176:22 - the curly brace is for the object
176:24 - literal that I'll be returning so I'll
176:25 - use the spread operator employee so the
176:29 - spread operator copies over all of the
176:31 - properties into this new object that we
176:34 - are returning now I want to update the
176:36 - email property such that all lowercase
176:39 - so I can do
176:41 - email call in and then I'll do employee.
176:44 - email. to lowercase
176:49 - so in this example map iterates over
176:50 - each employee object creating a new
176:52 - object that preserves the original
176:54 - properties while transforming the emo
176:55 - property to lowercase the use of the
176:57 - spread operator ensures that we're not
176:59 - modifying the original objects
177:01 - showcasing the map's utility and
177:02 - creating modified copies of objects
177:04 - while leaving the originalr right
177:05 - untouched so let's console log that
177:08 - console.log of update employees open up
177:11 - the panel up arrow and run it and here
177:15 - we see update employees shows all the
177:17 - emails and
177:22 - lowercase how would you transform or map
177:24 - over each element of an
177:30 - array you can use the built-in map
177:33 - method with that method you would
177:34 - specify a callback function where you
177:36 - will operate on each element and
177:37 - transform it in some way this would
177:38 - result in creating a new array
177:40 - consisting of those updated
177:43 - values JavaScript has a very powerful
177:46 - array method called reduce it can
177:48 - transform an array into just about
177:49 - anything whether that be a single number
177:51 - a string an object or even another array
177:53 - let's see how this works with a
177:54 - practical example let's consider an
177:56 - array of numbers and we want to
177:57 - calculate their sum here's how you would
177:58 - traditionally implement it instantiate
178:01 - Con numbers and assign to 1 10 5 and 14
178:05 - then I can initialize the sum and set it
178:07 - to zero then I can use the four of loop
178:10 - to iterate through all the elements in
178:11 - this array so I can say four const num
178:15 - of numbers
178:18 - then I can do sum plus equals num now I
178:21 - can console log that console.log our
178:24 - template string I'll say total sum colon
178:27 - using interpolation say the sum end it
178:30 - with the semicolon and let's run in the
178:32 - panel here I see the total sum is 30 now
178:35 - this approach calculates the sum but
178:37 - JavaScript offers a cleaner way to
178:39 - achieve the same result using the reduce
178:40 - method so I comment this
178:42 - out the reduce method iterates over each
178:45 - element in the array applying a function
178:47 - that you define and accumulates the
178:48 - results into a single value here's how
178:50 - you can use the reduce method to sum an
178:52 - array of numbers so on a new line I'll
178:53 - say con sum is assign to numbers. reduce
178:58 - then specify two parameters the
179:01 - accumulator and the current value using
179:05 - the arrow function syntax ending it with
179:07 - the semicolon then I will return the
179:10 - accumulator plus the current value so
179:13 - the first argument that we specify for
179:15 - the reduce method is this callback
179:17 - function it also accepts a second
179:18 - optional argument which is the initial
179:20 - value of the accumulator so I'll set
179:22 - that to be zero as the initial starting
179:24 - value so a reducer function is called
179:26 - for each element in the array this
179:28 - function receives two parameters the
179:29 - accumulator which is the accumulated
179:31 - result of the previous function calls
179:33 - and the current value which is the
179:34 - current array element being processed
179:36 - the initial value for the accumulator in
179:37 - our case is zero because we're summing
179:39 - the numbers starting from zero the
179:41 - reducer functions job is to combine the
179:43 - accumulator and the current value in
179:44 - some way then return the result which
179:46 - becomes the accumulator value for the
179:48 - the next iteration once reduce has
179:49 - processed every element in the array it
179:51 - Returns the final accumulator value
179:53 - providing initial value is optional if
179:54 - you don't include it reduce will use the
179:56 - first element of the array as the
179:57 - initial accumulator value and start
179:59 - iterating from the second element
180:01 - however it's a good practice to always
180:02 - specify the initial value to avoid
180:04 - unexpected results especially when
180:05 - working with empty arrays or arrays
180:07 - containing elements of different types
180:09 - so I'll copy this console log and I'll
180:10 - put it just to ensure that we get the
180:12 - same value I run the
180:14 - panel we get the sum of 30 so I can
180:17 - comment this out
180:19 - and here is a simplified version of the
180:20 - sum calculation without explicitly
180:22 - providing an initial value so I can do
180:25 - sum assign to numbers.
180:29 - reduce specifying the
180:31 - accumulator as the first parameter then
180:34 - the current
180:35 - value Arrow function syntax and then
180:39 - accumulator plus the current value
180:42 - ending it with a semicolon now I can run
180:44 - in the
180:45 - panel and we get the same result
180:48 - [Music]
180:50 - what is the reduceed method and how does
180:52 - it
180:56 - work the reduce method is a built-in
180:59 - method for the array data structure that
181:00 - reduces all the elements of an array
181:02 - into a single value this value could be
181:04 - a number a string an object or another
181:06 - array it accepts two possible parameters
181:08 - so for the first parameter you would
181:09 - specify a callback function this
181:11 - callback function will accept two
181:12 - parameters the accumulator and the
181:14 - current value now reduce also accepts an
181:16 - optional second parameter you can supply
181:18 - the initial starting value for the
181:21 - accumulator functions are the
181:23 - Cornerstone of JavaScript serving as
181:25 - reusable code blocks in JavaScript
181:27 - functions are objects let's explore two
181:29 - primary methods to create functions in
181:31 - JavaScript through function declaration
181:32 - syntax and function expression syntax
181:35 - I'll rename my file to functions
181:38 - starting with function declarations here
181:40 - we utilize the function keyword a key
181:41 - characteristic of function declarations
181:43 - is their Simplicity and the absence of a
181:45 - semicolon at the end for example you do
181:47 - fun function say hi parentheses and then
181:53 - console.log hi then I can invoke it just
181:56 - say say hi let run in the panel I'll say
181:59 - node functions. js and here I see
182:02 - executed the statement within the code
182:04 - block so this syntax is straightforward
182:05 - and efficient for defining functions now
182:07 - we also have function Expressions which
182:09 - introduce a different approach we close
182:11 - the panel and I'll delete this so now
182:13 - implement it with function expression
182:14 - syntax I'll say let say hi is a assign
182:18 - to
182:19 - function then our curly braces I'll say
182:22 - console. log of high and I'll end the
182:25 - curly braces with the semicolon so in
182:27 - this case we Define an anonymous
182:29 - function which does not have an
182:30 - Associated name and we assign it to a
182:32 - variable say hi note that functions are
182:34 - objects in JavaScript so now I can
182:35 - invoke it say hi running in the
182:39 - panel and we get the same result so if I
182:41 - close this some function Expressions
182:43 - could also be named so rather than using
182:45 - an anonymous function let's say if I
182:46 - were to change the name name with this
182:48 - variable to greeting and I make this a
182:50 - name function and call it say hi and to
182:52 - invoke it I'll just use greeting and
182:55 - then the parentheses so this provides
182:57 - the flexibility of an expression and the
182:59 - clarity of a name function so in this
183:01 - scenario greeting acts as a reference to
183:03 - our function treating it as an object
183:04 - then to execute this function we simply
183:06 - invoke greeting here I just output it
183:08 - again and we get the same result in
183:10 - summary JavaScript functions whether
183:12 - using function declaration syntax or
183:14 - function expression syntax form the
183:16 - building blocks of our applications
183:19 - what are function
183:26 - declarations function declarations are
183:28 - the traditional syntax to create
183:29 - functions in JavaScript You' use the
183:31 - function keyword and then name the
183:32 - function specifying a parameter list and
183:34 - then the implementation within curly
183:36 - braces what are function
183:43 - Expressions function expressions are an
183:45 - alternative syntax in JavaScript where
183:47 - you would imp a function whether it be
183:48 - an anonymous function or a name function
183:50 - and assign it to a variable we can do
183:52 - this in JavaScript since functions are
183:56 - objects in the previous lesson we
183:58 - covered two different ways for creating
184:00 - functions in JavaScript the function
184:01 - declaration syntax and the function
184:03 - expression syntax a key difference
184:05 - between these lies in their behavior
184:06 - related to hoisting to illustrate this
184:08 - let's consider function declaration
184:10 - first so Implement a function call it
184:12 - add and it will accept two parameters
184:14 - num one and num two curly braces and
184:17 - we'll just console log the output
184:19 - console.log num one plus num 2 now to
184:22 - invoke it I'll just do add then I'll do
184:25 - two plus two and let's output
184:27 - that so we see the output is four now
184:30 - with this approach using the function
184:31 - declaration syntax JavaScript allows us
184:33 - to call or invoke the function before
184:35 - it's defined in the code so rather than
184:37 - invoking it after its
184:39 - declaration I can move it before its
184:42 - declaration and this approach would
184:43 - still work so if I output it we get the
184:46 - same result this is due to a JavaScript
184:49 - mechanism known as hoisting hoisting is
184:50 - a process where the JavaScript engine
184:52 - automatically moves all function
184:54 - declarations to the top of their scope
184:55 - before code execution this means that no
184:57 - matter where functions are declared they
184:58 - are moved to the top of their enclosing
185:00 - scope allowing them to be called before
185:01 - they're defined in the program however
185:03 - this doesn't apply to function
185:04 - Expressions so if I try this with the
185:06 - function expression syntax closing the
185:08 - panel I'll comment this out so if I do
185:11 - let add is assigned to Anonymous
185:13 - function with the same parameter list
185:16 - num one and num two and I'll just copy
185:18 - and paste this console log now if I try
185:21 - running it clear this and run it this
185:24 - code results in a reference eror because
185:26 - we cannot access and invoke ad before
185:28 - its initialization the reason is that
185:30 - function expressions are not hoisted in
185:32 - the same way as function declarations
185:34 - since ad is defined using a let variable
185:36 - assignment it cannot be accessed until
185:37 - the execution reaches the point where it
185:39 - is defined in summary hoisting allows
185:41 - function declarations to be lifted to
185:43 - the top of their scope making them
185:44 - available throughout their enclosing
185:45 - scope
185:48 - what is
185:49 - [Music]
185:54 - hoisting function hoisting refers to a
185:56 - JavaScript mechanism where function
185:58 - declarations are moved to the top of
186:00 - their containing scope during the
186:01 - compilation phase this allows you to
186:03 - call or invoke the function anywhere
186:04 - within its enclosing
186:07 - scope let's dive into how functions
186:09 - handle arguments in JavaScript using a
186:11 - simple example here Implement function
186:14 - I'll name it
186:15 - multiply it will accept two
186:18 - num one and num
186:19 - two curly braces and then we'll just
186:22 - return the product so num one * num two
186:26 - now if I invoke it console. log multiply
186:31 - and then 2 * 2 add in semicolon so we
186:35 - can output it so we get the output of
186:37 - four so when we call this function we
186:39 - Supply two arguments in each parameter
186:41 - is assigned to one of these arguments
186:43 - leading to the expected multiplication
186:45 - result but if we were to call this and
186:46 - only pass one ARG arent for
186:49 - example if I remove this second argument
186:52 - and I call it again I get the value of
186:54 - not a number in this case since we
186:57 - didn't Supply two arguments and didn't
186:59 - Supply an argument for the parameter num
187:01 - two then num two will be assigned the
187:02 - value of undefined by default so in
187:05 - JavaScript any parameter that doesn't
187:06 - receive an explicit argument is
187:08 - automatically assigned to the value
187:09 - undefined this default Behavior ensures
187:12 - that functions don't break even when
187:13 - they receive fewer arguments than
187:15 - expected though it may lead to
187:16 - unexpected results in your functions
187:18 - JavaScript functions are quite flexible
187:20 - with a number of arguments you pass to
187:21 - them you can even pass more arguments
187:23 - than there are parameters defined so for
187:25 - example if I pass in two and say if I
187:28 - pass in the value four if I were to call
187:30 - it again here I get the expected result
187:33 - without an error now to actually make
187:35 - use of all these arguments we can
187:37 - leverage the arguments object every
187:39 - function in JavaScript has access to a
187:40 - special object named arguments which
187:42 - captures all the arguments pass to the
187:44 - function so let's see an example of that
187:46 - here if I just console log the arguments
187:48 - object arguments opening up the panel
187:52 - we'll clear this then we'll log it again
187:55 - so here I see this outputs the argument
187:57 - object in this object the keys refer to
187:59 - the index position of the parameter and
188:01 - its corresponding argument value if we
188:03 - want our function to support any number
188:04 - of arguments we can iterate over the
188:06 - arguments object I close the
188:10 - panel I delete our statements in the
188:12 - code block then I'll declare let product
188:15 - assign to one then I'll utilize our four
188:17 - of loop so four I'll say con num of
188:22 - arguments and within it I'll do product
188:25 - times equal the
188:27 - num then I return the
188:30 - product so with this setup our multiply
188:32 - function can now handle two three or
188:34 - even 10 arguments multiplying them all
188:36 - together the argument's object is
188:37 - iterable allowing us to Loop over it
188:39 - with the four of syntax it's important
188:41 - to note that while arguments is array
188:43 - likee it's not a natural array this
188:44 - means that it has some array behaviors
188:46 - like being iterable in having a length
188:48 - property but lacks array methods like
188:50 - map or reduce here I'll clear the panel
188:52 - and just log it out and here I see the
188:54 - result of multiplying 2 * 2 * 4 by
188:57 - understanding the argument object you
188:58 - can create more flexible functions in
189:00 - JavaScript capable of handling a
189:01 - variable number of arguments seamlessly
189:03 - note that we don't often use the
189:04 - arguments object but I wanted to cover
189:06 - it so that you're aware of
189:07 - [Music]
189:09 - it what happens if a function is called
189:12 - with fewer arguments than expects to
189:14 - receive
189:18 - if a function is called with fewer
189:20 - arguments than it expects then the
189:21 - parameters that you didn't Supply a
189:23 - value to will be assigned the value of
189:25 - undefine by default this could lead to
189:27 - unexpected results in your
189:30 - functions previously we covered the
189:32 - spread operator which is used for
189:34 - cloning objects in JavaScript for
189:35 - example if I create the object literal
189:37 - let course sign to the object with a
189:41 - name JavaScript for
189:45 - beginners I'll say
189:48 - duration 3 hours end it with a semicolon
189:51 - now I can make a copy of this let's say
189:53 - if I do let new course assign to object
189:57 - literal then the spread operator with
189:59 - three dots and then the object that I
190:01 - want to
190:02 - copy so if I lck this out new
190:06 - course opening up the panel and running
190:08 - it this outputs a copy of this object so
190:12 - the Sprint operator allows us to easily
190:14 - copy properties from one object to
190:16 - another now if you want to modify the
190:17 - name name property in the process we
190:19 - could do so by put this on new line
190:23 - comma and then I'll do name and I'll
190:25 - change the name to be
190:27 - JavaScript Pro for the name of the
190:29 - course I'll just add the spacing here
190:32 - now if I to the panel and I run it again
190:35 - here I see the name property has been
190:37 - updated so now let's pivot to a similar
190:39 - but distinct use of this syntax in the
190:41 - context of functions so when we use this
190:44 - dot dot dot operator functions we refer
190:46 - to it as the rest operator so unlike the
190:48 - spread operator which expands an array
190:50 - or object the rest operator allows us to
190:52 - gather a varying number of arguments
190:54 - into a single array parameter this is
190:56 - particularly useful when we want a
190:58 - function to accept an indefinite number
191:00 - of arguments so clear this out so
191:02 - consider this example I declare a
191:03 - function I name it multiply then for its
191:06 - parameter I can do dot dot dot
191:09 - args specify the code block I'll say
191:12 - return ARS do
191:13 - reduce so this name of args is arbitrary
191:16 - I can name it whatever I want so this
191:18 - allows me to specify a varying number of
191:20 - arguments which we packed into an array
191:22 - so I can use the array method reduce in
191:24 - order to reduce all the values in the
191:26 - array to a single value so in this case
191:27 - it will result in the product of
191:29 - multiplying all these numbers together
191:31 - so I can do
191:33 - accumulator and then current
191:35 - value the arrow function I'll close the
191:38 - sidebar so more room then I would do
191:40 - accumulator times current value then
191:43 - I'll specify the value of one as a
191:44 - starting value for the accumulator so
191:46 - now I'll put this console. log of
191:49 - multiply 1 2 3 and four so I'll run in
191:53 - the
191:54 - panel and here we get the value of 24
191:57 - it's multiplying these arguments
191:59 - together so this shows an example of how
192:01 - we can use the rest operator in our
192:03 - parameter list so I clear this out close
192:05 - the panel let's consider another example
192:07 - see if I create a function I call it
192:09 - multiply again now for the first
192:12 - parameter I'll specify that to be
192:14 - multiplier and for the second parameter
192:16 - I'll specify that with the rest operator
192:18 - and I'll name that array
192:21 - numbers so then I'll specify return
192:24 - numbers map in my call back I'll specify
192:27 - number then number times multiplier
192:31 - ending it with the semicolon so this
192:33 - numbers parameter will gather any
192:35 - additional arguments passed into the
192:36 - function and store it in an array called
192:38 - numbers so if I were to use this I can
192:40 - say
192:42 - console.log multiply so for the first
192:45 - argument which be used as the multiplier
192:47 - let's say if I specify two then any
192:49 - subsequent value will be an element in
192:52 - the array numbers so I can do 1 2 3 and
192:55 - four ending with the semicolon now since
192:57 - I'm using the map function this will
192:59 - return a new array with these values
193:01 - being doubled so if I output
193:04 - that I get 2 4 6 and 8 so this
193:07 - demonstrates how the rest operator
193:08 - enables the multiply function to accept
193:10 - any number of arguments beyond the first
193:12 - multiplier parameter it's important to
193:14 - remember that if a function includes
193:15 - multiple parameters the rest parameter
193:17 - must be the last one in the parameter
193:19 - list ensuring it captures all remaining
193:21 - arguments also the name of the rest
193:22 - parameter can be anything whether it be
193:24 - numbers args or any identifier that
193:26 - makes sense in your functions
193:31 - context what is the rest
193:37 - operator the rest operator allows you to
193:40 - represent an indefinite number of
193:41 - arguments as an array this is useful
193:43 - when working with functions that can
193:45 - accept a variable number of arguments
193:49 - let's explore default parameters in
193:51 - JavaScript a feature that significantly
193:52 - enhances function flexibility let's
193:54 - start with a simple function if I use
193:56 - the function declaration syntax I'll say
193:58 - function write code and for the
194:00 - parameter I'll specify that to be
194:02 - language or curly braces and then I'll
194:05 - console log with back ticks I'll say
194:08 - write code in and then interpolation
194:12 - language end it with a semicolon and now
194:15 - I can invoke it so if I say write code
194:17 - for the argument I'll specify that to be
194:20 - JavaScript I run the
194:22 - panel so here we see a log to the
194:24 - console now let's say if I copy this
194:26 - shift option and down arrow and let's
194:29 - say if I do c as the programming
194:31 - language run it again so we implemented
194:34 - a reusable function but what if we were
194:35 - to call right code without any arguments
194:37 - say if I do shift option down again to
194:39 - copy it but I don't pass any arguments
194:42 - I'll clear this if I run it again here I
194:45 - see the last one is write code in
194:47 - undefined so without an argument this
194:48 - parameter is assign the value of
194:50 - undefined by default so this is where
194:52 - default parameters may be used in modern
194:54 - JavaScript we can assign a default value
194:56 - to parameters ensuring our function
194:57 - behaves predictively even when specific
194:59 - arguments aren't provided so here where
195:01 - I specify my parameter I can assign a
195:03 - default value in this case I'll say
195:05 - JavaScript so I'll clear this and if I
195:07 - run it again here I see the last output
195:10 - was write code in JavaScript since
195:11 - language has the default value assigned
195:13 - to JavaScript so let's clear this and
195:15 - let's do another example so now can
195:17 - consider a function with more than one
195:18 - parameter so I'll say function code
195:20 - details for the first parameter I'll use
195:23 - language and I'll have the default value
195:25 - of
195:26 - JavaScript I'll close the sidebar with
195:29 - command and B and I'll do tool is vs
195:32 - code our curly braces and now a console
195:35 - log back tick writing code in language
195:42 - using tool end it with the semicolon so
195:45 - if you set a default value for a
195:46 - parameter then any parameters that
195:48 - follow should also have default values
195:50 - this function has two parameters
195:51 - language and Tool both with default
195:53 - values so this design allows for
195:55 - versatile function calls so if I were to
195:57 - call it with no arguments I'll do
195:59 - another example specifying just one
196:01 - argument let's say if I do python then
196:04 - I'll specify c as the language and
196:07 - visual studio as the tool so if I output
196:10 - this and run it here I see for the first
196:13 - function call with no arguments pass it
196:14 - uses the default values so writing code
196:16 - and jav JavaScript using VSS code the
196:18 - second one I just supplied one argument
196:20 - so it's writing code in Python using VSS
196:22 - code and third one I supplied two
196:24 - arguments this outputed writing code in
196:25 - C using visual studio let's do one more
196:27 - example let's say if I do function
196:29 - create user the first parameter will be
196:32 - name the second parameter will be roll
196:35 - with the default value of guest the
196:37 - third parameter will be status and
196:39 - assign to active do my curly braces and
196:42 - then I'll console log it with back tick
196:45 - user call
196:48 - then the name comma the
196:51 - role and the
196:54 - status ending with the semicolon so now
196:56 - I can do create user and I'll specify
196:59 - the first argument since this parameter
197:01 - is mandatory so I'll say
197:03 - Steven and I'll do another example let's
197:05 - say if I specify the name to be Alice
197:08 - with the role of admin and the status is
197:11 - active here if I output it so for this
197:14 - function the role and the status
197:16 - parameters have defa values so this
197:17 - setup is practical for situations when
197:19 - you might not have all the details up
197:21 - front but still need to ensure your
197:22 - functions executes smoothly default
197:24 - parameters simplify function calls and
197:26 - make your JavaScript code more readable
197:27 - and maintainable especially when dealing
197:29 - with multiple parameters and the
197:30 - potential for missing
197:34 - arguments what are default
197:40 - parameters default parameters allow
197:42 - functions to have predefined values that
197:44 - are used if no argument is passed to the
197:46 - function
197:48 - fun let's dive into the use of Getters
197:50 - and Setters within JavaScript objects
197:52 - which enhance how we interact with
197:54 - object properties so let's Define a
197:55 - simple object I'll name it Con course
197:58 - assign
197:59 - to where the name is JavaScript for
198:02 - beginners and the duration is 3 hours
198:06 - we'll end it with a semicolon and we'll
198:08 - just console log it with back tick say
198:12 - course. name is course.
198:17 - a so output that so we see JavaScript
198:21 - for beginners is 3 hours so this basic
198:23 - approach allows us to access object
198:25 - properties directly however modern
198:27 - JavaScript offers more sophisticated
198:29 - mechanisms to interact with properties
198:30 - such as with methods so if I close this
198:32 - so I'll specify a method in my object
198:34 - I'll name it
198:35 - details and I'll say return back ticks
198:38 - I'll say this as in this current object
198:44 - name is this do ation ending with the
198:48 - semicon so I comment this out I can
198:51 - instead do
198:53 - console.log of course. details for
198:56 - calling that method so if I run this
198:58 - again I'll get the same output so while
199:01 - this details method effectively
199:02 - encapsulates the way we describe a
199:04 - course it's readon so we can't directly
199:06 - modify the course details using this
199:08 - method so this is where Getters and
199:09 - Setters can come in so these special
199:11 - methods allow us to Define custom Logic
199:13 - for reading and writing properties
199:14 - they're defined using the get and set
199:16 - keyword and are used as if they were
199:18 - regular properties so to turn this
199:19 - method into a getter I would use the
199:21 - keyword get before the method name so to
199:24 - specify a Setter I'll do comma and I'll
199:28 - say set details for the parameter
199:32 - that'll be a
199:33 - value so what this allows us to use this
199:36 - method as if it were a property of the
199:38 - JavaScript object so this Setter can be
199:40 - used to be assigned to a value like
199:42 - JavaScript for beginners is 3 hours so a
199:44 - value were to hold this string we would
199:46 - need to break it up and store it in our
199:48 - properties so I can say let Parts is
199:50 - assigned to Value calling the split
199:52 - method which exists for Strings and I'll
199:55 - specify the separator as the space is
199:59 - and then another space so that will
200:00 - break this string up into an array and I
200:03 - can access the elements of the array to
200:04 - update these properties so I can say
200:06 - this fat name assign to Parts at the
200:10 - first index then I can say this do
200:12 - duration is assigned to Parts at the
200:15 - second index at the index of one clear
200:17 - this out so since this is a getter it
200:19 - will act as if it is a property rather
200:21 - than a method so in order to call this I
200:23 - won't need to use the parentheses so
200:25 - I'll put that and when I run it I get
200:27 - the same result now if I already use the
200:29 - setter which is this method we defin
200:31 - here I can say course. details is
200:34 - assigned to I'll say JavaScript Pro is
200:39 - 10 hours now for to access the details
200:41 - of this course I can copy this paste it
200:44 - here and I'll comment this out so let's
200:46 - let's run it again so here I see my
200:48 - properties have been updated and so when
200:50 - I call details this outputs JavaScript
200:53 - Pro is 10 hours so in this enhanced
200:55 - example the getter for detos simply
200:57 - formats and Returns the course
200:59 - information and we're able to access it
201:01 - as if it were a property rather than a
201:03 - method now the setter for details takes
201:06 - a string splits it and updates both the
201:09 - name and duration of the course object
201:11 - it allows us to modify the course's
201:12 - details in a controlled manner Getters
201:14 - and Setters provide a powerful way to
201:16 - create virtual properties that you can
201:17 - read and set like standard properties
201:19 - but with additional logic behind them
201:21 - this feature is especially useful for
201:22 - validation logging and dynamically
201:24 - computed properties remember while
201:26 - Getters and Setters make your objects
201:27 - more robust and encapsulated they also
201:29 - introduce a layer of abstraction that
201:31 - can make debugging more challenging if
201:32 - not used
201:35 - carefully what are the get and set
201:42 - keywords the get and set keywords can be
201:44 - used within object literals or classes
201:47 - in order to Define Getters and Setters
201:48 - this enables you to use a method as if
201:50 - it were a property the benefit of using
201:52 - Getters and Setters is that it can
201:53 - improve data encapsulation and provide a
201:55 - more intuitive interface for interacting
201:57 - with an object's
202:00 - properties in this lesson we'll explore
202:02 - the powerful concept of error handling
202:03 - in JavaScript particularly through the
202:05 - use of Tri catch blocks so let's
202:07 - consider an object course with a getter
202:09 - and Setter for its details property now
202:11 - for this parameter variable that we
202:12 - specify for our Setter there's no
202:14 - guarantee that this value is a string
202:16 - data type for example someone could do
202:18 - course. details and assign it to a
202:21 - number for example so we want to check
202:22 - Ure this parameter is a string so I can
202:25 - check if type of value is not equal to a
202:31 - string then in this case we can just
202:34 - return and stop execution now while this
202:36 - code will prevent the air being thrown
202:38 - there are cases when you want to throw
202:39 - an air in programming we'll call this
202:41 - throwing an exception so here I'll do
202:42 - curly braces and instead I'll do throw
202:45 - new error
202:47 - and I'll specify the message to be
202:50 - value and the value is not a
202:54 - string so now the programmer who is
202:56 - utilizing the setter will now get an
202:58 - exception an error saying that the value
203:00 - they assign it to is not a string so now
203:03 - if I run this with node functions. js
203:07 - then it throws this exception so by
203:09 - implementing this check in our Setter we
203:11 - can throw an exception when the value
203:12 - isn't a string thus preventing
203:14 - unexpected behavior however simply
203:16 - throwing an error halts our program's
203:17 - execution and reports the error which
203:19 - isn't always the desired outcome so in
203:21 - JavaScript errors are objects and when
203:23 - thrown they create exceptions now we
203:25 - don't want unhandled exceptions to
203:26 - terminate our program abruptly so this
203:28 - is where TR catch blocks come into play
203:30 - allowing us to gracefully handle errors
203:32 - so I'll close the panel here when we
203:35 - perform this operation I can wrap it in
203:37 - try catch blocks so I'll do the try
203:40 - keyword curly braces and I'll move this
203:43 - code within this block So within this
203:46 - code block we would Place statements
203:48 - that could potentially throw an
203:49 - exception now if an exception is thrown
203:52 - then we want to catch it I can name this
203:54 - e for error or E for exception so this
203:57 - will allow us to catch the exception
203:59 - without terminating our program so
204:00 - you're going output console.log a
204:03 - descriptive error message so I can say
204:05 - CAU an error and here I'll just say e.
204:10 - message which is a property that exists
204:12 - for errors so now if I run it run the
204:15 - panel so here I see this outputed this
204:17 - airor message rather than terminating
204:19 - the program so to reiterate the catch
204:21 - block specified here catches with the
204:23 - thrown error enabling us to handle it
204:25 - and log it to the console without
204:27 - stopping the program so this pattern of
204:28 - defensive programming particularly the
204:30 - use of Tri catch blocks is crucial for
204:32 - creating robust JavaScript applications
204:34 - it allows us to manage errors
204:35 - effectively ensuring our programs can
204:37 - recover from unexpected situations
204:40 - [Music]
204:42 - gracefully what are Tri catch blocks
204:48 - Tri catch blocks are used for defensive
204:50 - programming in the case when you are
204:52 - executing code that may throw an
204:53 - exception this enables you to catch the
204:55 - exception in order to prevent your
204:56 - program from
204:58 - crashing let's cover the concepts of
205:01 - local scope versus global scope in
205:02 - JavaScript first let's discuss the
205:04 - global scope so a variable declared
205:06 - outside any function block or
205:08 - conditional has a global scope meaning
205:09 - it's accessible from any part of the
205:11 - code after its declaration so CH 2 con's
205:14 - name and the sign two Steven and and
205:16 - just console log it the name we output
205:20 - it and we get our expected string so
205:22 - here this variable is declared in the
205:24 - global scope it's within Global reach
205:26 - meaning any script or function can
205:27 - access it conversely local scope refers
205:29 - to variables declared within a block
205:31 - function or conditional so these
205:32 - variables are only accessible within the
205:34 - confines of their curly braces so I for
205:37 - instead wrap this in a curly brace to
205:40 - Def a
205:41 - block I'll highlight this and do command
205:44 - then the right square bracket to indent
205:45 - it
205:47 - now if I run again I get the same result
205:50 - however if I were to move this console
205:52 - lock statement outside of the code block
205:55 - and if I run again I got a reference
205:57 - there saying that the name is not
205:59 - defined so since we declared this
206:00 - variable within this code block it only
206:02 - exist and is accessible within the Block
206:04 - it's defined in and outside of it is not
206:06 - accessible leading to a reference eror
206:07 - so the scope of a variable determines
206:09 - it's accessibility so declaring
206:11 - variables locally within a specific
206:12 - context rather than globally is
206:14 - generally considered best practice for
206:16 - several reasons one is for avoiding
206:18 - Global pollution Global variables can
206:19 - lead to conflicts especially in large
206:21 - applications or when integrating with
206:23 - third party libraries another reason is
206:24 - maintaining code Clarity local variables
206:26 - ensure data is only accessible where
206:28 - it's needed making the code easier to
206:30 - understand and debug another reason is
206:31 - enhancing performance JavaScript engines
206:33 - can optimize the look of time for local
206:35 - variables better than for Global
206:36 - variables to further illustrate let's
206:38 - see how this works within a function
206:39 - I'll clear this out and I'll close the
206:41 - panel so if I I name a function I'll
206:43 - call it
206:44 - GRE and within it I'll say cons message
206:47 - is assigned to hello world and then I'll
206:51 - conso log this
206:53 - message now when I invoke
206:56 - GRE I'll get the expected console log
206:59 - statement however if I were try to
207:00 - access this variable message say if I do
207:04 - console.log of message and then I run it
207:07 - here I see another reference error
207:08 - saying that the message variable is not
207:10 - defined so this shows that this variable
207:12 - is local to the Greet function it's
207:14 - created when the Greet function is
207:15 - invoked seases to exist after the
207:17 - function completes keeping our Global
207:19 - namespace clean and our code predictable
207:21 - understanding the distinction between
207:22 - local and Global scope is fundamental in
207:24 - JavaScript it helps in structuring your
207:26 - code more effectively preventing
207:27 - accidental data modification and keeping
207:29 - your Global namespace uncluttered always
207:31 - aim to minimize the use of global
207:32 - variables and leverage local scope
207:34 - whenever possible for more maintainable
207:35 - and airror free
207:37 - [Music]
207:39 - code what is the difference between the
207:41 - global scope and the local scope
207:46 - in JavaScript the scope of a variable
207:48 - determines where it can be accessed
207:49 - within the code variables declared
207:51 - outside any function or block are in the
207:52 - global scope making them accessible
207:54 - throughout the entire script in contrast
207:56 - variables declared within a function or
207:57 - block such as Loops or conditional
207:59 - statements are in local scope meaning
208:00 - they are only accessible within that
208:02 - specific
208:04 - Block in this lesson I will discuss the
208:06 - differences between the let and VAR
208:07 - keywords in JavaScript highlighting why
208:09 - modern practices favor the let and cons
208:11 - keyword rather than the VAR keyword in
208:13 - JavaScript versions prior to es6 which
208:16 - stands for ecmascript 2015 the VAR
208:18 - keyword was primarily used to declare
208:20 - variables however the introduction of
208:22 - es6 brought significant improvements
208:23 - including the addition of the let and
208:25 - cons keywords for variable declarations
208:27 - these were introduced to address some of
208:29 - the issues associated with the VAR
208:30 - keyword so the VAR keyword is function
208:32 - scoped meaning that it is only scoped to
208:34 - the function within which it is defined
208:36 - not to any blocks within that function
208:37 - like Loops or conditionals this can lead
208:39 - to unexpected behavior and errors in
208:41 - your code so consider this example using
208:42 - the VAR keyword part to create a
208:44 - function and name it display
208:46 - and if I were to implement a traditional
208:48 - for Loop I'll say four VAR I is assigned
208:51 - to zero I is less than 5 I increments
208:55 - and I'll console log
208:57 - that so if I were also to console log
209:01 - outside of this for Loop the value of I
209:04 - so if I were to invoke it and run it in
209:06 - the
209:07 - panel here I see within my for Loop this
209:09 - outputs the values of 0 to 4 and
209:12 - continues as long as the value of I is
209:14 - less than 5 however I'm still able to
209:16 - access this variable outside of this
209:19 - code block as seen in the outputting of
209:21 - the value of five so in this scenario
209:23 - the variable I which is declared inside
209:25 - a for Loop is accessible outside of the
209:27 - loop block because VAR does not have
209:29 - block scope but rather it is function
209:30 - scope the let keyword in the other hand
209:32 - introduces block scoping to JavaScript
209:34 - this means that a variable declared with
209:36 - let is only accessible within the block
209:38 - it was defined in so to update this to
209:39 - be the let keyword and run
209:42 - it here I see what output every value in
209:45 - the loop however when I try to access
209:46 - this variable outside of the code block
209:48 - then it would throw an exception saying
209:49 - that I is not defined so to reiterate in
209:52 - this version of display attempting to
209:53 - access the variable I outside its
209:55 - defining scope which is the for Loop in
209:57 - this case results in a reference air
209:58 - showcasing that it's a block level scope
210:01 - so why does this matter we want to
210:02 - minimize the global scope pollution and
210:04 - using let helps avoid adding unnecessary
210:06 - variables to the global scope which
210:07 - could conflict with other scripts or
210:09 - third party libraries using the let and
210:11 - cons keyword also helps us reduce our
210:13 - errors so block scoping makes it easier
210:14 - to track where variables are available
210:16 - reducing the risk of accidentally
210:18 - overwriting or misusing variables it
210:20 - also helps improve code readability so
210:22 - code that takes advantage of block
210:23 - scoping is often easier to read and
210:25 - understand as it's clearer where each
210:26 - variable is defined so while VAR has its
210:28 - place in JavaScript history the
210:29 - introduction of the let and cons keyword
210:31 - has provided developers with more robust
210:33 - tools for variable declaration by
210:35 - understanding and utilizing the let and
210:36 - cons keyword and their block scope
210:38 - nature you can write cleaner more
210:39 - reliable jwarp
210:42 - code what is the difference between the
210:44 - let keyword and the VAR key
210:50 - keyword both the Le keyword and the VAR
210:53 - keyword can be used to declare a
210:54 - variable the let keyword is the modern
210:56 - way to declare a variable and it was
210:57 - introduced in es6 the difference is that
210:59 - the let keyword is block scoped and the
211:01 - VAR keyword is function scoped with the
211:03 - let keyword the variable will be
211:05 - accessible within the block it is
211:06 - defined in with the VAR keyword the
211:08 - variable will be accessible within the
211:09 - function it is Def finded
211:11 - in in this lesson we will cover the this
211:14 - keyword in JavaScript understanding that
211:16 - this keyword is crucial because it
211:17 - refers to the object that is currently
211:19 - executing the function or method in
211:21 - JavaScript the value of this depends on
211:23 - the context in which a function is
211:25 - called not where it's declared so let's
211:27 - break this down if I create an object
211:29 - name it course with the name JavaScript
211:33 - for
211:34 - beginners and if I declare a method I'll
211:37 - name it start
211:39 - console.log of
211:42 - this.name now I were to call this method
211:44 - I'll say course do start and if I output
211:49 - that I get JavaScript for beginners so
211:51 - in this example the this keyword points
211:54 - to this course object allowing us to
211:57 - access the name property of course in a
211:59 - regular function meaning not a method of
212:01 - an object that this keyword will
212:03 - reference the global object in browsers
212:05 - it's the window object and in node.js
212:07 - it's the global object so if I to move
212:10 - this and then say create a function and
212:12 - call it start video and here I'll just
212:15 - console log
212:17 - this so I'll call this function call
212:19 - start video and I'll execute
212:23 - it scrolling up so since I executed this
212:26 - with node.js this outputed the global
212:29 - object and in browsers this would output
212:31 - the window object let me clear this out
212:34 - so that covers the function declaration
212:36 - syntax Now Arrow functions don't have
212:38 - their own this context instead they
212:40 - inherit this from the parent scope at
212:43 - the time they are defined so far Crea
212:44 - another object say con course assign to
212:47 - the name es6
212:51 - syntax then start and I'll have that use
212:54 - an arrow function parenthesis the arrow
212:57 - curly braces this will
212:59 - console.log this.name so now if I use
213:02 - that course.
213:05 - start when I invoke
213:08 - it here I see this do name is undefined
213:11 - this is because when using the arrow
213:12 - function the this. keyword inherits from
213:14 - its parent scope so in this case from
213:16 - the global object and since the global
213:18 - object doesn't have a name property this
213:20 - value would be undefined now you can
213:22 - explicitly set the value of this using
213:25 - bind so bind returns a new function with
213:27 - this bound to a specific object but
213:28 - doesn't immediately invoke it so if I
213:30 - were to clear this to demonstrate that
213:32 - close in the panel so if I create a
213:34 - function and I'll name it
213:36 - introduce with the parameter of
213:38 - language I'll do
213:41 - console.log I'll say this.name then
213:44 - using catenation
213:46 - say
213:48 - teaches
213:50 - language so for to create an object I'll
213:53 - say instructor sign to my
213:57 - name now this function introduce has a
214:00 - bind method so if for to say cons
214:02 - introduction is assigned to introduce
214:05 - bind then I'll pass in this
214:07 - object and of the semicolon then if I
214:10 - were to invoke it using introduction
214:14 - introduction for the language I'll
214:16 - specify that to be JavaScript ending
214:18 - with a semiconon and if I output it here
214:21 - I see the string Steven teaches
214:23 - JavaScript so performing the bind this
214:26 - specifies this.name which is binded to
214:29 - this object so the this keyword in
214:32 - JavaScript plays a critical role in
214:33 - determining the context of function
214:35 - execution its value is determined by the
214:37 - execution context or explicitly bound
214:39 - using bind understanding and mastering
214:41 - this allows for more flexible and
214:43 - Powerful code structures especially when
214:44 - working with object or in a
214:49 - JavaScript how would you explicitly set
214:51 - the value of the dis keyword for a
214:53 - function or
214:58 - method in JavaScript to explicitly set
215:01 - the value of the this keyword for a
215:03 - function you can use the bind method the
215:05 - bind method creates a new function that
215:06 - when called has its this keyword set to
215:08 - the provided value this allows you to
215:10 - call a function with this set to a
215:12 - specific object even if the function is
215:14 - defined in a different context
215:16 - if you're interested in supporting my
215:18 - courses and projects you can follow me
215:19 - on my new YouTube channel and Instagram
215:21 - at Steven codecraft and if you're
215:22 - looking to enhance your health and
215:23 - fitness routine check out my workout and
215:24 - meal planning app at fitfuel planner.com
215:26 - the app offers over 100 recipes workout
215:28 - plans meal plans and a grocery list
215:30 - feature it's designed to make tracking
215:32 - your calories and macronutrients
215:33 - straightforward and stressfree I
215:35 - appreciate your support